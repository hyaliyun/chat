import{_ as p,o as n,c as i,a as t,m as h,t as d,C as g,M as y,U as _,f as u,F as b,p as v,e as w,q as x}from"./chunks/framework.B1z0IdBH.js";const k={name:"PoemCard",props:{poem:{type:Object,required:!0}}},T={class:"poem-container"},q={class:"review"},I={class:"review-title"},N={class:"review-content"};function E(r,e,l,c,s,a){return n(),i("div",T,[t("div",q,[t("div",I,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),h(d(l.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",N,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),h(d(l.poem.solution),1)])])])}const A=p(k,[["render",E],["__scopeId","data-v-c4a7b781"]]),S=JSON.parse('[{"question":"# Matrix Multiplication Coding Challenge **Context**: Matrix multiplication is a fundamental operation in various fields including graphics processing, data transformations, and machine learning. Understanding and implementing matrix multiplication can help solidify concepts related to nested loops and multidimensional data structures. **Objective**: Write a function `multiply(multiplicand, multiplier)` that multiplies two given two-dimensional matrices (lists of lists) and returns their product. Ensure to handle incompatible matrix dimensions gracefully and consider efficiency for larger matrices. **Input**: - Two matrixes as two-dimensional lists: - `multiplicand`: List[List[int]] — a matrix with dimensions m x n. - `multiplier`: List[List[int]] — a matrix with dimensions n x p. **Output**: - The resultant matrix as a two-dimensional list: List[List[int]] — a matrix with dimensions m x p. **Constraints**: - Each inner list in the input matrices represents a row. - Elements of the matrices will be integers. - Handling the case when the number of columns in the multiplicand is not equal to the number of rows in the multiplier by raising an exception. **Example**: ```python # Example 1: multiplicand = [ [1, 2], [3, 4] ] multiplier = [ [2, 0], [1, 2] ] # Resultant Matrix should be: # [ # [4, 4], # [10, 8] # ] result = multiply(multiplicand, multiplier) print(result) # Expected Output: [[4, 4], [10, 8]] ``` **Performance Requirements**: Ensure the implementation runs efficiently within acceptable limits for matrix dimensions up to 100x100. **Implementation**: Consider edge cases and ensure your implementation is robust against invalid inputs.","solution":"def multiply(multiplicand, multiplier): Multiplies two given two-dimensional matrices and returns their product. :param multiplicand: List[List[int]] — matrix with dimensions m x n :param multiplier: List[List[int]] — matrix with dimensions n x p :return: List[List[int]] — resulting matrix with dimensions m x p :raises ValueError: if the number of columns in the multiplicand is not equal to the number of rows in the multiplier # Check dimensions m = len(multiplicand) n = len(multiplicand[0]) n2 = len(multiplier) p = len(multiplier[0]) if n != n2: raise ValueError(\\"Incompatible dimensions for matrix multiplication.\\") # Initialize the result matrix with zeros result = [[0 for _ in range(p)] for _ in range(m)] # Perform matrix multiplication for i in range(m): for j in range(p): for k in range(n): result[i][j] += multiplicand[i][k] * multiplier[k][j] return result"},{"question":"You are required to implement a class `DynamicSeparateChainingHashTable` that extends the functionality of a standard Separate Chaining Hash Table by dynamically resizing the table when the load factor exceeds a certain threshold. # Requirements: 1. **Class Definition**: * Implement the class `DynamicSeparateChainingHashTable` which should inherit from `SeparateChainingHashTable`. 2. **Dynamic Resizing**: * When the number of elements (load factor) exceeds 0.75 times the current table size, double the table size. * Rehash all elements when resizing. 3. **Input and Output**: * Implement the same `put`, `get`, and `del_` methods to insert, retrieve, and delete key-value pairs. * Ensure that other utility functions like `__len__`, `__getitem__`, and `__setitem__` work seamlessly. # Function Signatures: ```python class DynamicSeparateChainingHashTable(SeparateChainingHashTable): def __init__(self, size=11): super().__init__(size) def put(self, key, value): # New code for resizing if necessary super().put(key, value) def get(self, key): return super().get(key) def del_(self, key): super().del_(key) def _resize_and_rehash(self): # Implement the logic to resize and rehash all elements pass ``` # Details: 1. **Dynamic Resizing**: - When resizing, double the current size of the table and rehash all existing elements. - `_resize_and_rehash` function should create a new table with doubled size and rehash all elements from the old table to the new table. 2. **Edge Cases**: - Resizing should happen transparently without disrupting ongoing operations. - Handle scenarios where keys are frequently inserted and deleted, maintaining a balanced load factor. 3. **Performance**: - Ensure resizing and rehashing maintains average case O(1) insertion and lookup time, but understand that resizing will have O(n). - Optimize the `put` method to check load factor and trigger resizing. # Example: ```python >>> table = DynamicSeparateChainingHashTable(size=4) >>> table.put(\'key1\', \'value1\') >>> table.put(\'key2\', \'value2\') >>> table.put(\'key3\', \'value3\') >>> table.put(\'key4\', \'value4\') # This should trigger resizing >>> table.get(\'key1\') \'value1\' >>> table.del_(\'key2\') >>> table.get(\'key2\') is None True ``` # Constraints: * Assume keys are strings and values are any data type. * Keys will contain only printable ASCII characters. Implement the `DynamicSeparateChainingHashTable` class enhancing the provided code with a detailed focus on dynamic resizing and element rehashing.","solution":"class SeparateChainingHashTable: def __init__(self, size=11): self.size = size self.table = [[] for _ in range(size)] self.num_elements = 0 def hash_function(self, key): return hash(key) % self.size def put(self, key, value): index = self.hash_function(key) for entry in self.table[index]: if entry[0] == key: entry[1] = value return self.table[index].append([key, value]) self.num_elements += 1 def get(self, key): index = self.hash_function(key) for entry in self.table[index]: if entry[0] == key: return entry[1] return None def del_(self, key): index = self.hash_function(key) for i, entry in enumerate(self.table[index]): if entry[0] == key: del self.table[index][i] self.num_elements -= 1 return return None def __len__(self): return self.num_elements def __getitem__(self, key): return self.get(key) def __setitem__(self, key, value): self.put(key, value) class DynamicSeparateChainingHashTable(SeparateChainingHashTable): def __init__(self, size=11): super().__init__(size) self.load_factor_threshold = 0.75 def put(self, key, value): super().put(key, value) if self.num_elements / self.size > self.load_factor_threshold: self._resize_and_rehash() def _resize_and_rehash(self): old_table = self.table new_size = self.size * 2 self.size = new_size self.table = [[] for _ in range(new_size)] self.num_elements = 0 for bucket in old_table: for key, value in bucket: super().put(key, value)"},{"question":"Implement a function `reverse_stutter` that takes a stack as a parameter and reverses the order of the elements in the stack and then duplicates each reversed element twice. This should be achieved using a single queue as auxiliary storage. Function Signature: ```python def reverse_stutter(stack: list) -> list: pass ``` Input: A list of integers representing the stack with the top of the stack being the last element of the list. Example: ``` stack = [3, 7, 1, 14, 9] ``` Output: A list of integers representing the modified stack, where the elements are reversed and each element is duplicated twice. Example: ``` reverse_stutter([3, 7, 1, 14, 9]) -> [9, 9, 14, 14, 1, 1, 7, 7, 3, 3] ``` Constraints: 1. The function should use only O(n) auxiliary space. 2. The solution should run in O(n) time complexity. 3. You may assume the stack will not hold more than 1000 elements. Notes: - An empty stack should return an empty list. - Consider edge cases such as a stack with one element. Example: ```python assert reverse_stutter([3, 7, 1, 14, 9]) == [9, 9, 14, 14, 1, 1, 7, 7, 3, 3] assert reverse_stutter([]) == [] assert reverse_stutter([8]) == [8, 8] ```","solution":"from collections import deque def reverse_stutter(stack: list) -> list: Takes a stack (represented as a list with the top being the last element) and returns a new stack where the elements are in reverse order and each is duplicated twice. if not stack: return [] queue = deque() # Move elements from stack to queue while stack: queue.append(stack.pop()) # Move elements back to stack, now in reverse order and duplicate each while queue: elem = queue.popleft() stack.append(elem) stack.append(elem) return stack"},{"question":"# Rotate Matrix 90 Degrees (Clockwise) Consider an `n x n` 2D matrix representing an image. You need to rotate the image 90 degrees clockwise in-place, without using any extra space. # Function Signature ```python def rotate(mat: List[List[int]]) -> None: pass ``` # Input * A 2D list `mat` with dimensions `n x n` where `n` is an integer (1 ≤ n ≤ 20). # Output * The function should modify the 2D list `mat` in place such that it represents the image rotated 90 degrees clockwise. # Examples ```python # Example 1 mat = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate(mat) print(mat) # Output: # [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] # Example 2 mat = [ [1, 2], [3, 4] ] rotate(mat) print(mat) # Output: # [ # [3, 1], # [4, 2] # ] ``` # Constraints * The function must modify the matrix in-place. * You cannot use any additional data structures for storage. # Detailed Requirements 1. Ensure your function handles all edge cases like an empty matrix and matrices with single element. 2. The input matrix will always be a square matrix (n x n). # Performance Requirements * The time complexity of your solution should be O(n^2), and the space complexity should be O(1). # Implementation Steps 1. Reverse the rows of the matrix. 2. Swap the symmetry elements by traversing only half of the matrix diagonally.","solution":"def rotate(mat): Rotates the given n x n 2D matrix by 90 degrees clockwise in place. n = len(mat) # Step 1: Reverse the matrix rows mat.reverse() # Step 2: Transpose the matrix for i in range(n): for j in range(i, n): mat[i][j], mat[j][i] = mat[j][i], mat[i][j]"},{"question":"# Question: Implement a More Efficient Priority Queue Scenario A logistics company manages a dynamic list of delivery tasks where each task has a specific priority. Due to the rapidly changing nature of these tasks, they need an efficient system to manage the priorities. Currently, they use a simple priority queue but find it inefficient due to delays during task insertion. They want you to implement a more efficient version of the priority queue. Task You are required to implement a priority queue using a heap-based data structure to improve the insertion efficiency. Create a class `EfficientPriorityQueue` with the following methods: * `__init__(self, items=None, priorities=None)`: Initialize the queue with initial tasks and their priorities. * `size(self)`: Return the number of items in the queue. * `push(self, item, priority)`: Insert a new item with its priority into the queue in O(log n). * `pop(self)`: Remove and return the item with the lowest priority in O(log n). Expectations - **Input**: Items and priorities provided as lists to initialize the queue. - **Output**: Methods that handle the priorities efficiently as described. - **Constraints**: - `[1 <= len(items) <= 10^5]` - `[-10^5 <= priority <= 10^5]` Example ```python pq = EfficientPriorityQueue(items=[\\"task1\\", \\"task2\\"], priorities=[1, 2]) print(pq.size()) # Output: 2 pq.push(\\"task3\\", 0) print(pq.pop()) # Output: \\"task3\\" print(pq.pop()) # Output: \\"task1\\" ``` Implement the `EfficientPriorityQueue` based on these requirements.","solution":"import heapq class EfficientPriorityQueue: def __init__(self, items=None, priorities=None): Initialize the queue with initial tasks and their priorities. if items is None: items = [] if priorities is None: priorities = [] self.heap = [] for item, priority in zip(items, priorities): heapq.heappush(self.heap, (priority, item)) def size(self): Return the number of items in the queue. return len(self.heap) def push(self, item, priority): Insert a new item with its priority into the queue in O(log n). heapq.heappush(self.heap, (priority, item)) def pop(self): Remove and return the item with the lowest priority in O(log n). if self.heap: return heapq.heappop(self.heap)[1] raise IndexError(\\"pop from an empty priority queue\\")"},{"question":"# The Problem You are tasked with implementing the Union-Find (Disjoint Set) data structure with optimized operations. You need to specifically focus on path compression and optional rank or size-based strategies for union operations. # Task Implement the Union-Find data structure with the following methods: - `add(element)`: Adds a new set containing the single element. - `root(element)`: Finds and returns the root of the set containing the element, applying path compression. - `unite(element1, element2)`: Merges the sets containing `element1` and `element2` with union by size to keep the structure balanced. - `find_if_connected(element1, element2)`: Checks if `element1` and `element2` are in the same set. # Input/Output: - **Input**: - Series of method calls on the predefined Union-Find class. - Elements must be positive integers. - The number of elements (`n`) will be in the range 1 to 10^5. - **Output**: - For `find_if_connected`, return `True` if the elements are in the same set, otherwise `False`. # Constraints: - Ensure all operations are performed efficiently. - Handle edge cases like duplicate adds, self-union, and non-existent elements gracefully. # Example: ```python # Initialize Union-Find structure uf = Union() # Add elements uf.add(1) uf.add(2) uf.add(3) uf.add(4) # Unite sets uf.unite(1, 2) uf.unite(3, 4) # Check connections print(uf.find_if_connected(1, 2)) # True print(uf.find_if_connected(1, 3)) # False # Further unification uf.unite(2, 3) print(uf.find_if_connected(1, 4)) # True ``` # Requirements: - Implement the methods in the `Union` class as described. - Ensure correctness and performance efficiency, leveraging path compression and union by size.","solution":"class Union: def __init__(self): self.parent = {} self.size = {} def add(self, element): if element not in self.parent: self.parent[element] = element self.size[element] = 1 def root(self, element): if self.parent[element] != element: self.parent[element] = self.root(self.parent[element]) # Path compression return self.parent[element] def unite(self, element1, element2): root1 = self.root(element1) root2 = self.root(element2) if root1 != root2: if self.size[root1] < self.size[root2]: root1, root2 = root2, root1 self.parent[root2] = root1 self.size[root1] += self.size[root2] def find_if_connected(self, element1, element2): return self.root(element1) == self.root(element2)"},{"question":"**Scenario:** You are a software engineer working for a company that processes structured data streams. You need to develop a function for merging two pre-sorted linked lists, ensuring the result remains sorted. This capability is crucial for efficiently merging data from different sources. **Task:** Implement a function `merge_two_sorted_lists` that takes as input the heads of two sorted singly linked lists and returns the head of a new singly linked list that contains all the elements from the input lists in sorted order. The function should be implemented both iteratively and recursively. **Function Signature (Iterative):** ```python def merge_two_sorted_lists(l1: Node, l2: Node) -> Node: # Implement your code here ``` **Function Signature (Recursive):** ```python def merge_two_sorted_lists_recursive(l1: Node, l2: Node) -> Node: # Implement your code here ``` **Input:** - `l1` (Node): The head node of the first sorted linked list. - `l2` (Node): The head node of the second sorted linked list. **Output:** - The head node of the newly merged sorted linked list. **Constraints:** - All Node values are integers. - Nodes are sorted in non-decreasing order. - Lists can have different lengths and can be empty. **Example:** ```python # Example of creating linked lists: # l1: 1 -> 2 -> 4 # l2: 1 -> 3 -> 4 n1, n2, n3 = Node(1), Node(2), Node(4) n1.next, n2.next = n2, n3 l1 = n1 m1, m2, m3 = Node(1), Node(3), Node(4) m1.next, m2.next = m2, m3 l2 = m1 # Merge the lists result = merge_two_sorted_lists(l1, l2) # Expected output: 1 -> 1 -> 2 -> 3 -> 4 -> 4 result_recursive = merge_two_sorted_lists_recursive(l1, l2) # Expected output: 1 -> 1 -> 2 -> 3 -> 4 -> 4 ``` **Performance Requirements:** - Time Complexity: O(n + m) - Space Complexity: O(1) for the iterative approach, O(n + m) for the recursive approach due to call stack. Create both `merge_two_sorted_lists` (iterative) and `merge_two_sorted_lists_recursive` (recursive) functions and ensure they pass all given test cases.","solution":"class Node: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_two_sorted_lists(l1: Node, l2: Node) -> Node: Merges two sorted linked lists iteratively. dummy = Node() current = dummy while l1 and l2: if l1.val < l2.val: current.next = l1 l1 = l1.next else: current.next = l2 l2 = l2.next current = current.next if l1: current.next = l1 elif l2: current.next = l2 return dummy.next def merge_two_sorted_lists_recursive(l1: Node, l2: Node) -> Node: Merges two sorted linked lists recursively. if not l1: return l2 if not l2: return l1 if l1.val < l2.val: l1.next = merge_two_sorted_lists_recursive(l1.next, l2) return l1 else: l2.next = merge_two_sorted_lists_recursive(l1, l2.next) return l2"},{"question":"You are given a set of distinct integers represented by an array `nums`. Your task is to implement a function `all_subsets(nums)` which returns all possible subsets of the given set. Each subset should appear exactly once in the output, and the order of output subsets does not matter. Implement the solution using a backtracking approach. # Function Signature ```python def all_subsets(nums: List[int]) -> List[List[int]]: ``` # Input * `nums` (A list of distinct integers, `1 <= len(nums) <= 12`, `-10 <= nums[i] <= 10`). # Output * Return a list of lists representing all possible subsets of the given input list. # Constraints * The function should run in a reasonable time for input size up to 12. * The solution should use no auxiliary libraries (standard library only). # Examples ```python assert all_subsets([1, 2, 3]) == [[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]] assert all_subsets([0]) == [[], [0]] assert all_subsets([]) == [[]] assert all_subsets([-1, 1]) == [[], [-1], [1], [-1, 1]] ``` # Notes 1. The order of subsets in the output does not matter. 2. The recursive backtracking approach should be used. 3. Your function should effectively handle and return results for both small and reasonably large input sizes within the constraints.","solution":"from typing import List def all_subsets(nums: List[int]) -> List[List[int]]: def backtrack(start: int, path: List[int]): # Append the current subset (path) to the result list result.append(path[:]) # Iterate through the possible candidates for the next element in the subset for i in range(start, len(nums)): # Include nums[i] in the current subset path.append(nums[i]) # Move on to the next element backtrack(i + 1, path) # Backtrack by removing the element just added path.pop() result = [] backtrack(0, []) return result"},{"question":"# Queue Operations Implementation You are tasked with implementing a priority queue. A priority queue is an extension of the queue ADT that includes a priority associated with each item. In a priority queue, an element with higher priority is served before an element with lower priority. If two elements have the same priority, they are served according to their order in the queue. Develop a class `PriorityLinkedListQueue` that supports the following operations: - `enqueue(value, priority)`: Adds an item to the queue with a given priority. - `dequeue()`: Removes and returns the item with the highest priority. - `peek()`: Returns the item with the highest priority without removing it. - `is_empty()`: Returns `True` if the queue is empty, `False` otherwise. - `size()`: Returns the number of items in the queue. Input and Output: - For `enqueue(value, priority)`, `value` is the item to be added, and `priority` is an integer representing the priority (higher number indicates higher priority). - For `dequeue()`, returns the value of the item with the highest priority. - For `peek()`, returns the value of the item with the highest priority. - For `is_empty()`, returns `True` or `False`. - For `size()`, returns an integer. Constraints: - Assume priority values are integers. - The queue should handle up to (10^5) elements. - All operations should be optimized for performance. Here’s a template for your implementation: ```python class PriorityNode: def __init__(self, value, priority): self.value = value self.priority = priority self.next = None class PriorityLinkedListQueue: def __init__(self): self._front = None self._size = 0 def enqueue(self, value, priority): Add an item with the given priority. new_node = PriorityNode(value, priority) if self._front is None or self._front.priority < priority: new_node.next = self._front self._front = new_node else: current = self._front while current.next and current.next.priority >= priority: current = current.next new_node.next = current.next current.next = new_node self._size += 1 def dequeue(self): Remove and return the item with the highest priority. if self.is_empty(): raise IndexError(\\"Queue is empty\\") value = self._front.value self._front = self._front.next self._size -= 1 return value def peek(self): Return the item with the highest priority without removing it. if self.is_empty(): raise IndexError(\\"Queue is empty\\") return self._front.value def is_empty(self): Check if the queue is empty. return self._front is None def size(self): Return the number of items in the queue. return self._size # Example Usage: pq = PriorityLinkedListQueue() pq.enqueue(\\"task1\\", 1) pq.enqueue(\\"task2\\", 3) print(pq.peek()) # Output: \\"task2\\" print(pq.dequeue()) # Output: \\"task2\\" print(pq.size()) # Output: 1 ```","solution":"class PriorityNode: def __init__(self, value, priority): self.value = value self.priority = priority self.next = None class PriorityLinkedListQueue: def __init__(self): self._front = None self._size = 0 def enqueue(self, value, priority): Add an item with the given priority. new_node = PriorityNode(value, priority) if self._front is None or self._front.priority < priority: new_node.next = self._front self._front = new_node else: current = self._front while current.next and current.next.priority >= priority: current = current.next new_node.next = current.next current.next = new_node self._size += 1 def dequeue(self): Remove and return the item with the highest priority. if self.is_empty(): raise IndexError(\\"Queue is empty\\") value = self._front.value self._front = self._front.next self._size -= 1 return value def peek(self): Return the item with the highest priority without removing it. if self.is_empty(): raise IndexError(\\"Queue is empty\\") return self._front.value def is_empty(self): Check if the queue is empty. return self._front is None def size(self): Return the number of items in the queue. return self._size # Example Usage: pq = PriorityLinkedListQueue() pq.enqueue(\\"task1\\", 1) pq.enqueue(\\"task2\\", 3) print(pq.peek()) # Output: \\"task2\\" print(pq.dequeue()) # Output: \\"task2\\" print(pq.size()) # Output: 1"},{"question":"Problem Statement: Rotate Array Implementation # Context: You are given an array of integers and an integer k. You need to rotate the array to the right by k steps. Your task is to implement this rotation in three different ways to evaluate various approaches and their efficiencies. # Function to Implement: 1. **rotate_v1(array, k)**: - Rotate the array using repeated rotation by one element. - Optimize for simplicity, acceptable for smaller values of k. 2. **rotate_v2(array, k)**: - Rotate the array using segment reversals. - Aim for improved performance with O(n) time complexity and in-place modifications. 3. **rotate_v3(array, k)**: - Rotate the array using slicing and list concatenation. - Ideal for leveraging language-specific features but may use extra space. # Input: - `array`: A list of integers of length n (1 ≤ n ≤ 10^5) - `k`: A non-negative integer (0 ≤ k ≤ 10^9) # Output: - Rotated array after k steps to the right. # Constraints: 1. Optimize each implementation based on specified approach. 2. Handle cases where k > n by effectively using `k % n`. # Examples: Test all three implementations: 1. Input: `array = [1, 2, 3, 4, 5, 6, 7]`, `k = 3` Output: `[5, 6, 7, 1, 2, 3, 4]` 2. Input: `array = [1, 2, 3, 4, 5, 6, 7]`, `k = 10` Output: `[5, 6, 7, 1, 2, 3, 4]` (since 10 % 7 = 3) Implement the following functions: ```python def rotate_v1(array, k): # Implement repeated one-step rotation logic. pass def rotate_v2(array, k): # Implement segment reversal logic. pass def rotate_v3(array, k): # Implement array slicing logic. pass ``` # Edge Cases to Consider: 1. Empty array 2. k is 0 or larger than length of array 3. Doubles up as `k` multiple of length of array, hence resulting in the same original array.","solution":"def rotate_v1(array, k): Rotate the array to the right by k steps using repeated one-step rotation. n = len(array) if n == 0: return array k = k % n for _ in range(k): last = array.pop() array.insert(0, last) return array def rotate_v2(array, k): Rotate the array to the right by k steps using segment reversals. n = len(array) if n == 0: return array k = k % n def reverse_segment(start, end): while start < end: array[start], array[end] = array[end], array[start] start += 1 end -= 1 reverse_segment(0, n - 1) reverse_segment(0, k - 1) reverse_segment(k, n - 1) return array def rotate_v3(array, k): Rotate the array to the right by k steps using slicing and list concatenation. n = len(array) if n == 0: return array k = k % n return array[-k:] + array[:-k]"},{"question":"# Prime Sum Problem: **Scenario**: You\'ve been tasked to develop a utility for a secure communication application. One fundamental operation is determining the sum of all prime numbers up to a given number `n`. This is critical for generating encryption keys that are derived from the sum of primes. **Instructions**: Write a function `sum_of_primes(n)` that takes an integer `n` as an input and returns the sum of all prime numbers less than or equal to `n`. **Function Signature**: ```python def sum_of_primes(n: int) -> int: ``` **Input**: - An integer `n` (1 ≤ n ≤ 10^6) **Output**: - An integer representing the sum of all prime numbers less than or equal to `n`. **Constraints**: - Your algorithm should be efficient to handle the upper limit of `n` up to 10^6. - Time Complexity should be considered carefully to ensure performance. **Example**: ```python # Example 1 input: 10 output: 17 # Explanation: Primes less than or equal to 10 are 2, 3, 5, and 7. Their sum is 17. # Example 2 input: 1 output: 0 # Explanation: There are no primes less than or equal to 1. ``` **Edge Cases to Consider**: - What if the input number is very small (e.g., `1` or `2`)? - How does the function handle the upper constraint effectively within reasonable time limits? **Hints**: - Utilize the prime-checking algorithm provided in the analysis for efficient prime detection. - Consider using more advanced prime-checking methods or preprocessing (e.g., Sieve of Eratosthenes) for better performance.","solution":"def sum_of_primes(n): Returns the sum of all prime numbers <= n. if n < 2: return 0 is_prime = [True] * (n + 1) is_prime[0], is_prime[1] = False, False for start in range(2, int(n**0.5) + 1): if is_prime[start]: for multiple in range(start*start, n + 1, start): is_prime[multiple] = False return sum(index for index, prime in enumerate(is_prime) if prime)"},{"question":"# N-Sum Problem You are given an array of integers, `nums`, and an integer `target`. Find all unique n-tuples (n-sized subarrays) in `nums` such that the sum of the elements in each n-tuple equals `target`. You must implement the function `n_sum` which takes the following parameters: - `n` (int): the size of the tuple. - `nums` (List[int]): list of integers from which tuples are to be found. - `target` (int): the target sum for the n-tuple. - Additional optional arguments: `sum_closure`, `compare_closure`, `same_closure` to customize summing, comparing, and equality functionalities. # Expected Function Definition ```python def n_sum(n: int, nums: list[int], target: int, **kv) -> list[list[int]]: pass ``` # Additional Notes - You are allowed to use the default operations provided within the function for summation, comparison, and equality checks. - Your solution must avoid duplications. - Handle edge cases like: * Empty list or list with insufficient elements. * Edge cases for target value and tuple size. # Input 1. `n`: integer (size of the tuple), `2 <= n <= len(nums)` 2. `nums`: List of integers 3. `target`: integer, sum that the n-tuple must match. 4. Optionally, you might define the following closure functions: * `sum_closure(a, b)`: Function to sum two elements. * `compare_closure(num, target)`: Function to compare the resultant sum with the target. * `same_closure(a, b)`: Function to check for duplicate elements. # Output A list of unique n-tuples where each tuple sums up to the target. # Example Scenarios ```python # Scenario 1: Basic Example n = 4 nums = [1, 0, -1, 0, -2, 2] target = 0 assert n_sum(n, nums, target) == [ [-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1] ] # Scenario 2: Custom Sum and Compare Functions n = 2 nums = [[-3, 0], [-2, 1], [2, 2], [3, 3], [8, 4], [-9, 5]] target = -5 def custom_sum(a, b): return [a[0] + b[1], a[1] + b[0]] def custom_compare(num, target): if num[0] < target: return -1 elif num[0] > target: return 1 else: return 0 assert n_sum(n, nums, target, sum_closure=custom_sum, compare_closure=custom_compare) == [ [[-9, 5], [8, 4]] ] ```","solution":"def n_sum(n, nums, target, **kv): # Default closures if none provided sum_closure = kv.get(\'sum_closure\', lambda a, b: a + b) compare_closure = kv.get(\'compare_closure\', lambda num, target: (num > target) - (num < target)) same_closure = kv.get(\'same_closure\', lambda a, b: a == b) def find_n_sum(nums, target, n, result, results): if len(nums) < n or n < 2: return # 2-sum is a base case that can be solved with two pointers if n == 2: left, right = 0, len(nums) - 1 while left < right: current_sum = sum_closure(nums[left], nums[right]) comparison = compare_closure(current_sum, target) if comparison == 0: results.append(result + [nums[left], nums[right]]) left += 1 while left < right and same_closure(nums[left], nums[left - 1]): left += 1 elif comparison < 0: left += 1 else: right -= 1 else: for i in range(len(nums) - n + 1): if i == 0 or not same_closure(nums[i - 1], nums[i]): find_n_sum(nums[i + 1:], target - nums[i], n - 1, result + [nums[i]], results) nums.sort() results = [] find_n_sum(nums, target, n, [], results) return results"},{"question":"# Problem: Connected Cities As a part of a global infrastructure initiative, you are tasked to manage connectivity between various cities. You must write a program to simulate the connection of cities and determine whether two cities are connected directly or indirectly after various merge operations. Consider `n` cities labeled from `0` to `n-1`. Initially, all cities are isolated. You can perform the following operations: 1. **addConnection(city1, city2)**: Connects two cities. If they belong to different sets, merge their sets. 2. **queryConnection(city1, city2)**: Checks if two cities are connected directly or indirectly (i.e., if they belong to the same set). Write a Python class `ConnectedCities` that supports the following methods: - **addConnection(city1, city2)**: This method takes two city identifiers and connects the cities. - **queryConnection(city1, city2)**: This method returns `True` if the two cities are connected, and `False` otherwise. # Example ```python cc = ConnectedCities() cc.addConnection(0, 1) cc.addConnection(1, 2) print(cc.queryConnection(0, 2)) # Should output: True print(cc.queryConnection(0, 3)) # Should output: False cc.addConnection(0, 3) print(cc.queryConnection(1, 3)) # Should output: True ``` # Constraints - `n` can be as large as `10^5`. - Each city is represented by a unique integer, `0` through `n-1`. - The number of operations (addConnection and queryConnection combined) is up to `10^6`. # Implementation Notes - Optimize your solution to handle up to 1 million operations efficiently. - Use the Union-Find data structure with path compression and union by size/rank to ensure efficient performance.","solution":"class ConnectedCities: def __init__(self, n): self.parent = list(range(n)) self.rank = [0] * n def find(self, city): if self.parent[city] != city: self.parent[city] = self.find(self.parent[city]) # Path compression return self.parent[city] def addConnection(self, city1, city2): root1 = self.find(city1) root2 = self.find(city2) if root1 != root2: # Union by rank if self.rank[root1] > self.rank[root2]: self.parent[root2] = root1 elif self.rank[root1] < self.rank[root2]: self.parent[root1] = root2 else: self.parent[root2] = root1 self.rank[root1] += 1 def queryConnection(self, city1, city2): return self.find(city1) == self.find(city2)"},{"question":"# Pattern Matching Algorithm Objective Write a function to determine if a given pattern matches a given string, such that there is a one-to-one correspondence between characters in the pattern and substrings in the string using a backtracking approach. Function Signature ```python def pattern_match(pattern: str, string: str) -> bool: ``` Input Constraints - `pattern`: A string `p` containing only lowercase letters. - `string`: A string `s` containing only lowercase letters. - Maximum length of `pattern` and `string` is 1000. Output - Return `True` if `string` matches the `pattern`, otherwise return `False`. Example ```python print(pattern_match(\\"abab\\", \\"redblueredblue\\")) # True print(pattern_match(\\"aaaa\\", \\"asdasdasdasd\\")) # True print(pattern_match(\\"aabb\\", \\"xyzabcxzyabc\\")) # False ``` Requirements 1. Use a backtracking approach to ensure each character in `pattern` is bijectively mapped to a substring in `string`. 2. Ensure the function handles edge cases like mismatched lengths, repetitive substrings, and unique character mappings. 3. Aim for clear, readable code with appropriate comments. Performance Consideration Although the solution may have high time complexity for worst-case scenarios, intelligent pruning and avoiding redundant checks can help manage more challenging inputs within constraints.","solution":"def pattern_match(pattern: str, string: str) -> bool: def backtrack(p_idx, s_idx, p_to_s, s_to_p): if p_idx == len(pattern) and s_idx == len(string): return True if p_idx == len(pattern) or s_idx == len(string): return False p_char = pattern[p_idx] for end in range(s_idx + 1, len(string) + 1): substr = string[s_idx:end] if p_char in p_to_s: if p_to_s[p_char] == substr: if backtrack(p_idx + 1, end, p_to_s, s_to_p): return True elif substr in s_to_p: continue else: p_to_s[p_char] = substr s_to_p[substr] = p_char if backtrack(p_idx + 1, end, p_to_s, s_to_p): return True del p_to_s[p_char] del s_to_p[substr] return False return backtrack(0, 0, {}, {})"},{"question":"**Context**: You\'re tasked with optimizing data storage systems, and minimizing the number of write operations to memory is crucial for the system\'s longevity and efficiency. **Problem Statement**: Implement the `cycle_sort` function that sorts a list of integers using cycle sort algorithm, which minimizes the number of write operations necessary to complete the sorting. **Function Signature**: ```python def cycle_sort(arr: List[int]) -> List[int]: ``` **Input**: 1. `arr`: A list of integers (1 ≤ len(arr) ≤ 10^4, -10^6 ≤ arr[i] ≤ 10^6) **Output**: 1. Returns a sorted list of integers with minimum write operations. **Constraints**: 1. You must not use any built-in sort functions. 2. Optimize for minimizing write operations rather than time complexity. 3. The solution should handle edge cases gracefully. **Example**: ```python # Example 1 arr = [4, 3, 2, 1] print(cycle_sort(arr)) # Output: [1, 2, 3, 4] # Example 2 arr = [3, 3, 2, 1, 1] print(cycle_sort(arr)) # Output: [1, 1, 2, 3, 3] # Example 3 arr = [1] print(cycle_sort(arr)) # Output: [1] ``` # Assessment Criteria: 1. Correctness: The function should return a correctly sorted list. 2. Efficiency: The function should minimize the number of writing operations. 3. Robustness: Properly handle edge cases, such as arrays with single elements or all identical elements. 4. Code Quality: Code should be well-structured, readable, and maintainable.","solution":"from typing import List def cycle_sort(arr: List[int]) -> List[int]: Function to sort a list using Cycle Sort which aims to minimize the number of write operations. # Traverse the array to find cycles to rotate. for cycle_start in range(len(arr) - 1): item = arr[cycle_start] # Find the position where we put the element. pos = cycle_start for i in range(cycle_start + 1, len(arr)): if arr[i] < item: pos += 1 # If the item is already in the correct position. if pos == cycle_start: continue # Skip all duplicates. while item == arr[pos]: pos += 1 # Put the item to the correct position. arr[pos], item = item, arr[pos] # Rotate the rest of the cycle. while pos != cycle_start: pos = cycle_start for i in range(cycle_start + 1, len(arr)): if arr[i] < item: pos += 1 while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] return arr"},{"question":"**Question**: You are tasked with enhancing the selection sort algorithm to handle a specific scenario optimally. Given an array `arr` of integers and an integer `k`, your goal is to modify the selection sort algorithm such that it only sorts the first `k` elements of the array in ascending order. The remaining elements beyond the `k`-th index should remain in their original positions. Implement a function `partial_selection_sort(arr, k)` that performs this operation. # Input - `arr`: A list of integers. (1 <= len(arr) <= 10^4) - `k`: An integer representing the number of elements to sort. (1 <= k <= len(arr)) # Output - The function should return the modified list with the first `k` elements sorted in ascending order. # Constraints - The algorithm should retain O(k * (n - k)) complexity since only the first `k` elements need sorting. - The function should sort elements in place without using additional memory. # Example ```python partial_selection_sort([3, 1, 2, 5, 4], 3) ``` Expected Output: ``` [1, 2, 3, 5, 4] ``` # Notes - The function should handle edge cases like an empty array or k equal to the length of the array. - Ensure that the remaining elements in the array (from index `k` onward) remain unaltered.","solution":"def partial_selection_sort(arr, k): Sorts the first k elements of the input list arr using the selection sort algorithm. Parameters: arr (list): The list of integers to sort. k (int): The number of elements to sort. Returns: list: The modified list with the first k elements sorted. n = len(arr) for i in range(k): min_index = i for j in range(i + 1, k): if arr[j] < arr[min_index]: min_index = j arr[i], arr[min_index] = arr[min_index], arr[i] return arr"},{"question":"Find the K-th to Last Element of a Linked List Background In many applications, you\'re required to perform operations relative to the end of a list. Finding the k-th to last element is a common and important operation in linked list manipulation. Task You are required to implement a function `kth_to_last(head, k)` that returns the k-th to last element of a singly linked list. Implementation Write a function `kth_to_last(head: Node, k: int) -> Node` where: - `Node` is a class representing a node in the linked list and has two attributes: - `val`: the value of the node (string in this context). - `next`: a reference to the next node in the list or None if it is the last node. - `head` is the reference to the first node in the singly linked list. - `k` is an integer representing the k-th to last position (0-based index). Input & Output Formats - **Input**: - A singly linked list where each node contains a string value and a reference to the next node. - An integer `k`, where `k ≥ 0`. - **Output**: Return the node that is k-th to last in the list. If k is invalid (greater than or equal to the number of nodes), raise an `IndexError`. Constraints - Do not use in-built list conversion methods. - Solve the problem with O(n) time complexity and O(1) space complexity. Example Given the linked list: `A -> B -> C -> D -> E` - For `k = 2`, the k-th to last element is `C`. Function Signature ```python class Node: def __init__(self, val=None): self.val = val self.next = None def kth_to_last(head: Node, k: int) -> Node: # Your code here # Example usage and testing def print_linked_list(head): string = \\"\\" while head: string += head.val + \\" -> \\" if head.next else head.val head = head.next print(string) def test(): a = Node(\\"A\\") b = Node(\\"B\\") c = Node(\\"C\\") d = Node(\\"D\\") e = Node(\\"E\\") a.next = b b.next = c c.next = d d.next = e print_linked_list(a) # Example test case kth = kth_to_last(a, 2) assert kth.val == \\"C\\", f\\"Expecting \'C\', got {kth.val}\\" test() ``` Additional Notes Ensure your implementation handles edge cases, such as: - If `k` is larger than the linked list length, an `IndexError` should be raised. - If `k` is exactly the length of the linked list, the function should raise an `IndexError`.","solution":"class Node: def __init__(self, val=None): self.val = val self.next = None def kth_to_last(head: Node, k: int) -> Node: Returns the k-th to last element of a singly linked list. :param head: Node, the head of the singly linked list. :param k: int, the 0-based index from the end of the list. :return: Node, the k-th to last node. :raises IndexError: if k is out of bounds. # First pointer will advance to k positions from head current = head for _ in range(k): if current is None: raise IndexError(\\"k is larger than the length of the list\\") current = current.next # Set up the second pointer at the head kth_node = head # Move both pointers until the first one reaches the end while current and current.next: current = current.next kth_node = kth_node.next # If the current is None, that means k is exactly the length of the list if current is None: raise IndexError(\\"k is larger than or equal to the length of the list\\") return kth_node"},{"question":"# Array Filtering by Range Context: You are designing a data processing pipeline for a large dataset containing numeric values. To clean the data, you need to filter out values that fall outside a specific range. Specifically, you want to implement a function that limits the elements of an array to only those that fall between two given boundaries, inclusive. Task: Implement a function `limit(arr, min_lim=None, max_lim=None)` in Python that takes an array of numbers and optional minimum and maximum boundary values. The function should return a new array containing only the numbers within the specified range. If the minimum or maximum boundary is not provided, the function should use the respective minimum or maximum value from the array. Function Signature: ```python def limit(arr, min_lim=None, max_lim=None): pass ``` Input: - `arr`: A list of integers (e.g., `[1, 2, 3, 4, 5]`) - `min_lim`: An optional integer value representing the minimum boundary (e.g., `2`) - `max_lim`: An optional integer value representing the maximum boundary (e.g., `4`) Output: - A list of integers containing only the elements that fall between `min_lim` and `max_lim`, inclusive. Constraints: - If the input array `arr` is empty, return an empty list. - If `min_lim` is not provided, use the minimum value in `arr`. - If `max_lim` is not provided, use the maximum value in `arr`. - Assume all elements in `arr` are integers. Examples: ```python # Example 1 # Input: arr = [1, 2, 3, 4, 5], min_lim = 2, max_lim = 4 # Output: [2, 3, 4] # Example 2 # Input: arr = [10, 20, 30, 40, 50], max_lim = 25 # Output: [10, 20] # Example 3 # Input: arr = [-10, -5, 0, 5, 10], min_lim = -3 # Output: [0, 5, 10] # Example 4 # Input: arr = [], min_lim = 0, max_lim = 10 # Output: [] ``` Edge Cases: - Empty input array - Input array with all elements outside the boundaries - Only one boundary (`min_lim` or `max_lim`) provided as `None`","solution":"def limit(arr, min_lim=None, max_lim=None): Returns a filtered list where elements are within the given min_lim and max_lim boundaries, inclusive. If min_lim or max_lim is not provided, the respective min or max value from the array is used. if not arr: return [] min_value = min(arr) if min_lim is None else min_lim max_value = max(arr) if max_lim is None else max_lim return [x for x in arr if min_value <= x <= max_value]"},{"question":"You are given an array of `n` integers, and you are required to rotate this array to the right by `k` steps. You need to implement the function in a way that reflects your understanding of the different methods discussed. Implement the function `rotate_array(array: List[int], k: int) -> List[int]` using Python. The function should take in a list of integers and an integer `k`, and return the list rotated to the right by `k` steps. You should ensure that your implementation handles edge cases effectively and optimizes for performance where possible. # Input * `array` - A list of integers `[a1, a2, ..., an]` (1 ≤ n ≤ 10^5). * `k` - An integer specifying the number of steps to rotate the list (0 ≤ k ≤ 10^5). # Output * The rotated list of integers. # Constraints * Your solution should modify the original list in place. * Maintain optimal time complexity where feasible. # Performance Requirements - Time Complexity: Aim for no more than `O(n)`. # Example ```python rotate_array([1, 2, 3, 4, 5, 6, 7], 3) # Output: [5, 6, 7, 1, 2, 3, 4] rotate_array([1, 2, 3, 4, 5, 6, 7], 0) # Output: [1, 2, 3, 4, 5, 6, 7] rotate_array([1, 2, 3, 4, 5, 6, 7], 7) # Output: [1, 2, 3, 4, 5, 6, 7] ``` # Notes 1. Implement the function in a way that reuses the input array as much as possible. 2. Think about edge cases and performance requirements during implementation.","solution":"from typing import List def rotate_array(array: List[int], k: int) -> List[int]: Rotates the array to the right by k steps. n = len(array) if n == 0: return array k = k % n # In case k is larger than n array[:] = array[-k:] + array[:-k] # Rotate in place return array"},{"question":"**Context**: Multiplying a sequence of matrices is a common problem in computer graphics, machine learning, and many other fields. However, the order in which matrices are multiplied can significantly affect the number of operations required. The matrix chain multiplication problem aims to find this optimal order. **Problem Statement**: You are given a sequence of matrices, and you need to determine the most efficient way to multiply these matrices together. Your task is to implement the matrix chain multiplication algorithm to minimize the total number of scalar multiplications. # Function Signature ```python def matrix_chain_order(p: List[int]) -> Tuple[List[List[int]], List[List[int]]]: Given dimensions of matrices, computes the minimum multiplication cost. Parameters: p (List[int]): A list where the ith entry represents the number of rows of the ith matrix, and the (i+1)th entry represents the number of columns of the ith matrix. Returns: Tuple containing: - List of List of int: The costs of multiplying the matrices from i to j. - List of List of int: The optimal split points. pass def print_optimal_solution(sol: List[List[int]], i: int, j: int) -> None: Prints the optimal order of multiplying matrices. Parameters: sol (List[List[int]]): Solution matrix containing split points. i (int): Starting index. j (int): Ending index. Returns: None pass ``` # Input - A list of integers ( p ) where the ( i )-th entry represents the number of rows of the ( i )-th matrix, and the ( (i+1) )-th entry represents the number of columns of the ( i )-th matrix. - ( p ) is of size ( n+1 ) for ( n ) matrices. # Output - Two 2D lists: `matrix` to store the minimum number of multiplications needed to multiply matrices from ( i ) to ( j ), and `sol` to store the optimal split points for these subproblems. - The `print_optimal_solution` function should print the optimal order of matrix multiplication. # Constraints - ( 1 leq len(p) leq 100 ) - ( 1 leq p[i] leq 500 ) # Example ```python from typing import List, Tuple def matrix_chain_order(p: List[int]) -> Tuple[List[List[int]], List[List[int]]]: n = len(p) - 1 matrix = [[0 for _ in range(n + 1)] for _ in range(n + 1)] sol = [[0 for _ in range(n + 1)] for _ in range(n + 1)] for chain_length in range(2, n + 1): for i in range(1, n - chain_length + 2): j = i + chain_length - 1 matrix[i][j] = float(\'inf\') for k in range(i, j): q = matrix[i][k] + matrix[k + 1][j] + p[i - 1] * p[k] * p[j] if q < matrix[i][j]: matrix[i][j] = q sol[i][j] = k return matrix, sol def print_optimal_solution(sol: List[List[int]], i: int, j: int) -> None: if i == j: print(f\\"A{i}\\", end=\\"\\") else: print(\\"(\\", end=\\"\\") print_optimal_solution(sol, i, sol[i][j]) print_optimal_solution(sol, sol[i][j] + 1, j) print(\\")\\", end=\\"\\") # Test example p = [30, 35, 15, 5, 10, 20, 25] matrix, sol = matrix_chain_order(p) print(\\"Minimum number of multiplications is:\\", matrix[1][len(p) - 1]) print(\\"Optimal multiplication order is: \\", end=\\"\\") print_optimal_solution(sol, 1, len(p) - 1) ``` **Expected Output**: ``` Minimum number of multiplications is: 15125 Optimal multiplication order is: ((A1(A2A3))((A4A5)A6)) ```","solution":"from typing import List, Tuple def matrix_chain_order(p: List[int]) -> Tuple[List[List[int]], List[List[int]]]: n = len(p) - 1 matrix = [[0 for _ in range(n + 1)] for _ in range(n + 1)] sol = [[0 for _ in range(n + 1)] for _ in range(n + 1)] for chain_length in range(2, n + 1): for i in range(1, n - chain_length + 2): j = i + chain_length - 1 matrix[i][j] = float(\'inf\') for k in range(i, j): q = matrix[i][k] + matrix[k + 1][j] + p[i - 1] * p[k] * p[j] if q < matrix[i][j]: matrix[i][j] = q sol[i][j] = k return matrix, sol def print_optimal_solution(sol: List[List[int]], i: int, j: int) -> None: if i == j: print(f\\"A{i}\\", end=\\"\\") else: print(\\"(\\", end=\\"\\") print_optimal_solution(sol, i, sol[i][j]) print_optimal_solution(sol, sol[i][j] + 1, j) print(\\")\\", end=\\"\\") # Test example p = [30, 35, 15, 5, 10, 20, 25] matrix, sol = matrix_chain_order(p)"},{"question":"# Task You are tasked with implementing a function to reverse a string for a specific application. The implementation must reverse the string in an efficient and comprehensible manner. You will implement a function using iterative, recursive, and Python\'s built-in capabilities and compare their efficiency. # Requirements: 1. Implement a function `reverse_string_iterative(s: str) -> str` that reverses the string iteratively. 2. Implement a function `reverse_string_recursive(s: str) -> str` that reverses the string recursively. 3. Implement a function `reverse_string_pythonic(s: str) -> str` using Python\'s built-in methods. 4. Compare the execution time of these three functions for reversing strings of varying lengths. # Input Format: * A single string `s` to be reversed. `1 <= len(s) <= 10^6` # Constraints: - The input string `s` will only contain printable ASCII characters. # Expected Output: Three functions with the following signatures: ```python def reverse_string_iterative(s: str) -> str: pass def reverse_string_recursive(s: str) -> str: pass def reverse_string_pythonic(s: str) -> str: pass ``` # Scenario: Suppose you are developing a text processing system where you need to reverse textual data efficiently based on different lengths and performance requirements. Your implementation will help you choose the best string reversal approach for various use cases within the system. # Examples: Example 1: ```python reverse_string_iterative(\\"hello\\") ``` Output: ``` \\"olleh\\" ``` Example 2: ```python reverse_string_recursive(\\"world\\") ``` Output: ``` \\"dlrow\\" ``` Example 3: ```python reverse_string_pythonic(\\"python\\") ``` Output: ``` \\"nohtyp\\" ``` # Performance Requirements: Measure the performance of each method by timing the execution on strings of lengths varying between 1 and 10^6 characters. Report any significant differences in execution times and discuss the most suitable approach for different scenarios.","solution":"def reverse_string_iterative(s: str) -> str: Returns the reversed string using an iterative approach. reversed_s = \\"\\" for char in s: reversed_s = char + reversed_s return reversed_s def reverse_string_recursive(s: str) -> str: Returns the reversed string using a recursive approach. if len(s) == 0: return s else: return reverse_string_recursive(s[1:]) + s[0] def reverse_string_pythonic(s: str) -> str: Returns the reversed string using Python\'s built-in slicing capabilities. return s[::-1]"},{"question":"# Gnome Sort Variation Challenge Gnome sort is an interesting, yet simple-to-understand sorting algorithm. Your task is to implement an enhanced version of Gnome Sort that not only sorts the list but also counts the total number of swaps made during the sorting process. Function Signature: ```python def enhanced_gnome_sort(arr: list[int]) -> tuple[list[int], int]: pass ``` # Input * An unsorted list of integers `arr` of length n (0 ≤ n ≤ 10^5). # Output * A tuple where the first element is the sorted list and the second element is an integer representing the number of swaps performed. # Constraints * Try to achieve the performance close to O(n^2) in the worst-case scenario with O(1) extra space. # Example ```python assert enhanced_gnome_sort([34, 2, 10, -9]) == ([-9, 2, 10, 34], 5) assert enhanced_gnome_sort([1, 2, 3, 4, 5]) == ([1, 2, 3, 4, 5], 0) assert enhanced_gnome_sort([]) == ([], 0) ``` # Complexity * Ensure that your implementation handles the worst-case time complexity of O(n^2) and maintains the space complexity of O(1). # Scenario or Context Consider a simple scenario where you have a list of participants\' scores in a game. You want to sort the scores in ascending order, while also keeping track of how many swaps were needed to sort the scores. This additional information might be useful for understanding the level of disorder in the initial list.","solution":"def enhanced_gnome_sort(arr: list[int]) -> tuple[list[int], int]: Sorts the list using an enhanced version of Gnome Sort that counts the total number of swaps. Returns a tuple where the first element is the sorted list and the second element is the number of swaps. index = 0 swaps = 0 n = len(arr) while index < n: if index == 0 or arr[index] >= arr[index - 1]: index += 1 else: arr[index], arr[index - 1] = arr[index - 1], arr[index] # Swap swaps += 1 index -= 1 return arr, swaps"},{"question":"You are working on a system that analyzes complex networks and their structures. One important aspect of this analysis is identifying strongly connected components within directed graphs using Kosaraju\'s algorithm. # Problem Statement Write a function `strongly_connected_components` that accepts the number of vertices `V` and an adjacency list `adj` representing a directed graph, and returns the number of strongly connected components (SCCs) within the graph. # Input Format - `V`: An integer representing the number of vertices in the graph. - `adj`: An adjacency list where `adj[i]` is a list of integers representing the vertices that vertex `i` has a directed edge to. # Output Format - Return an integer representing the number of strongly connected components in the graph. # Constraints - 0 <= V <= 10^5 - 0 <= |adj[i]| <= 10^5 # Example ```python def main(): V = 6 adj = [ [2], # vertex 0 -> 2 [0], # vertex 1 -> 0 [3], # vertex 2 -> 3 [1, 4], # vertex 3 -> 1, 4 [5], # vertex 4 -> 5 [4], # vertex 5 -> 4 ] print(strongly_connected_components(V, adj)) # Output: 2 if __name__ == \'__main__\': main() ``` Given the inputs, the function should return `2` indicating the graph has two strongly connected components. # Requirements - Implement the function within linear time complexity in terms of the number of vertices and edges.","solution":"def strongly_connected_components(V, adj): Returns the number of strongly connected components in a directed graph. Parameters: V (int): Number of vertices in the graph. adj (List[List[int]]): Adjacency list representing the graph. Returns: int: Number of strongly connected components. def dfs(v, visited, stack): visited[v] = True for neighbor in adj[v]: if not visited[neighbor]: dfs(neighbor, visited, stack) stack.append(v) def reverse_graph(V, adj): rev_adj = [[] for _ in range(V)] for v in range(V): for neighbor in adj[v]: rev_adj[neighbor].append(v) return rev_adj def reverse_dfs(v, visited, rev_adj): visited[v] = True for neighbor in rev_adj[v]: if not visited[neighbor]: reverse_dfs(neighbor, visited, rev_adj) stack = [] visited = [False] * V for i in range(V): if not visited[i]: dfs(i, visited, stack) rev_adj = reverse_graph(V, adj) visited = [False] * V scc_count = 0 while stack: v = stack.pop() if not visited[v]: reverse_dfs(v, visited, rev_adj) scc_count += 1 return scc_count"},{"question":"Improved Comb Sort Implementation # Context Comb Sort is an enhancement over the traditional Bubble Sort algorithm with an aim to improve performance by eliminating turtles or small values near the end of the list which slow down the sorting process. The algorithm works by initially comparing elements far apart, reducing the gap until it becomes 1, and finally, completing the sort like Bubble Sort. # Task Your task is to implement an optimized version of the Comb Sort algorithm. In your implementation, you should consider and handle edge cases such as empty arrays, arrays with only one element, and already sorted arrays effectively. # Specifications Write a function `optimized_comb_sort(arr: list) -> list` that takes a list of integers and returns a sorted list using an optimized version of Comb Sort. Input * A list of integers `arr` where -10^6 ≤ arr[i] ≤ 10^6 * The number of elements in the list `n` (0 ≤ n ≤ 10^6) Output * A sorted list of integers in ascending order. # Constraints * Use the shrinking factor of 1.3 * Optimize edge case handling * Perform early termination if multiple gap stages have no swaps # Example ```python assert optimized_comb_sort([5, 1, 4, 2, 8]) == [1, 2, 4, 5, 8] assert optimized_comb_sort([]) == [] assert optimized_comb_sort([1]) == [1] assert optimized_comb_sort([-5, 0, -3, -1, -2]) == [-5, -3, -2, -1, 0] assert optimized_comb_sort([1, 2, 2, 3, 3, 1, 2, 2]) == [1, 1, 2, 2, 2, 2, 3, 3] ``` # Notes: * Consider implementing a mechanism to avoid redundant comparisons in later stages. * Ensure that your code handles large input sizes efficiently within acceptable time limits.","solution":"def optimized_comb_sort(arr: list) -> list: Sorts a list of integers in ascending order using the optimized Comb Sort algorithm. def get_next_gap(gap): # Shrink gap by the shrink factor gap = (gap * 10) // 13 if gap < 1: return 1 return gap n = len(arr) gap = n is_sorted = False while gap != 1 or not is_sorted: gap = get_next_gap(gap) is_sorted = True for i in range(n - gap): if arr[i] > arr[i + gap]: arr[i], arr[i + gap] = arr[i + gap], arr[i] is_sorted = False return arr"},{"question":"# Question Problem Statement You are asked to implement an `ArrayQueue` class with a circular buffer to optimize the space usage. Your implementation should use a Python list but must utilize its circular nature to avoid the need for array resizing during normal operations. Implement the following methods: 1. `__init__(self, capacity)` - Initializes the queue with the specified capacity. 2. `enqueue(self, value)` - Adds a new element to the rear of the queue. 3. `dequeue(self)` - Removes and returns the front element of the queue. 4. `peek(self)` - Returns the front element without removing it. 5. `is_empty(self)` - Returns whether the queue is empty. 6. `__len__(self)` - Returns the number of elements in the queue. 7. `__iter__(self)` - Iterates from the front to the rear of the queue. Your solution should handle edge cases appropriately, such as when the queue is empty. Assume all inputs are valid and focus on the efficiency of enqueue and dequeue operations. Function Signature ```python class CircularArrayQueue: def __init__(self, capacity: int): pass def enqueue(self, value): pass def dequeue(self): pass def peek(self): pass def is_empty(self): pass def __len__(self): pass def __iter__(self): pass ``` Example Usage ```python queue = CircularArrayQueue(5) queue.enqueue(1) queue.enqueue(2) print(queue.dequeue()) # Output: 1 print(queue.peek()) # Output: 2 queue.enqueue(3) print(len(queue)) # Output: 2 for item in queue: print(item) # Output: 2 3 queue.enqueue(4) queue.enqueue(5) queue.enqueue(6) print(queue.dequeue()) # Output: 2 queue.enqueue(7) print(queue.peek()) # Output: 3 ``` Constraints - The `capacity` provided in the constructor will be a positive integer. - The `enqueue` method should raise an `OverflowError` if the queue is full. - The `dequeue` and `peek` methods should raise an `IndexError` if the queue is empty. Performance Requirements - The `enqueue` and `dequeue` operations should have an average time complexity of O(1).","solution":"class CircularArrayQueue: def __init__(self, capacity: int): self.capacity = capacity self.queue = [None] * capacity self.front = 0 self.rear = 0 self.size = 0 def enqueue(self, value): if self.size == self.capacity: raise OverflowError(\\"Queue is full\\") self.queue[self.rear] = value self.rear = (self.rear + 1) % self.capacity self.size += 1 def dequeue(self): if self.is_empty(): raise IndexError(\\"Queue is empty\\") value = self.queue[self.front] self.queue[self.front] = None self.front = (self.front + 1) % self.capacity self.size -= 1 return value def peek(self): if self.is_empty(): raise IndexError(\\"Queue is empty\\") return self.queue[self.front] def is_empty(self): return self.size == 0 def __len__(self): return self.size def __iter__(self): idx = self.front num_elements = self.size while num_elements > 0: yield self.queue[idx] idx = (idx + 1) % self.capacity num_elements -= 1"},{"question":"***Question: ZigZag Iterator Usage and Extension*** # Context: A ZigZag Iterator allows for iterating over two input lists in an alternating sequence. Given two lists, it returns the first element from the first list, then the first element from the second list, followed by the second element from the first list, and so on. This pattern continues until all elements from both lists are exhausted. # Problem Statement: You are required to extend the functionality of the ZigZag Iterator to support any number of input lists, not just two. Implement a class `ExtendedZigZagIterator` that can manage multiple lists and iterate over them in a zigzag fashion. # Interface: - **`__init__(self, lists: List[List[int]])`**: Initialize your data structure with a list of lists. - **`next(self) -> int`**: Return the next element in the zigzag iteration. - **`has_next(self) -> bool`**: Return `True` if there are still elements available for iteration, otherwise `False`. # Constraints: 1. The input can be any number of lists, including zero or more. 2. Elements within the lists are assumed to be integers. 3. Lists can be of different lengths. 4. Optimize for both time and space complexities. # Example: ```python lists = [[1, 2], [3, 4, 5, 6], [7, 8, 9]] it = ExtendedZigZagIterator(lists) result = [] while it.has_next(): result.append(it.next()) print(result) # Output should be: [1, 3, 7, 2, 4, 8, 5, 9, 6] ``` # Requirements: 1. Your implementation should follow the descriptions in the interface. 2. Handle edge cases such as empty input list arrays and differing lengths of lists seamlessly. 3. Ensure efficient iteration through minimal complexity bottlenecks. # Solution Template: ```python from typing import List class ExtendedZigZagIterator: def __init__(self, lists: List[List[int]]): Initialize your data structure here. # Implementation here def next(self) -> int: :rtype: int # Implementation here def has_next(self) -> bool: :rtype: bool # Implementation here ```","solution":"from collections import deque from typing import List class ExtendedZigZagIterator: def __init__(self, lists: List[List[int]]): Initialize your data structure here. # We use a deque to manage the index of the current list and the position within that list self.lists = lists self.queue = deque() for idx, lst in enumerate(lists): if lst: # Only consider non-empty lists self.queue.append((idx, 0)) # (list_index, element_index) def next(self) -> int: Return the next element in the zigzag iteration. if not self.has_next(): raise StopIteration(\\"No more elements\\") list_idx, elem_idx = self.queue.popleft() result = self.lists[list_idx][elem_idx] # If there are more elements in the same list, add it back to queue with updated element index if elem_idx + 1 < len(self.lists[list_idx]): self.queue.append((list_idx, elem_idx + 1)) return result def has_next(self) -> bool: Return True if there are still elements available for iteration, otherwise False. return bool(self.queue)"},{"question":"**Question**: Implement a function to determine the maximum depth of a given binary tree using an efficient level-order traversal. # Task Write a function **max_depth** that takes the root of a binary tree and returns its maximum depth. # Input - The function takes a single argument: - `root`: the root node of a binary tree, where each node is an instance of the TreeNode class. # Output - The function should return an integer representing the maximum depth. # TreeNode Class ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` # Example ```python # Define the TreeNode class class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right # Construct the binary tree tree = TreeNode(10) tree.left = TreeNode(12) tree.right = TreeNode(15) tree.left.left = TreeNode(25) tree.left.left.right = TreeNode(100) tree.left.right = TreeNode(30) tree.right.left = TreeNode(36) # Call the function result = max_depth(tree) print(result) # Output should be 4 ``` # Constraints - The number of nodes in the tree is in the range `[0, 10^4]`. - The `val` of a `TreeNode` is an integer in the range `[-10^5, 10^5]`. # Notes - An empty tree should return 0. - The function must be efficient in both time and space complexities. **Hints**: 1. Use a queue to help with the level-order traversal. 2. Iteratively process each level and maintain a count for the depth.","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_depth(root): Determine the maximum depth of a binary tree using level-order traversal. Args: root (TreeNode): Root node of the binary tree. Returns: int: Maximum depth of the binary tree. if root is None: return 0 queue = deque([root]) depth = 0 while queue: depth += 1 level_size = len(queue) for i in range(level_size): node = queue.popleft() if node.left: queue.append(node.left) if node.right: queue.append(node.right) return depth"},{"question":"You are working on a system that needs to handle very large numbers, and these numbers are stored as arrays of digits. You need to increment such a number by one. Your task is to write a function that performs this increment operation in an efficient manner. The number is represented in big-endian format, meaning the most significant digit is at the head of the array. # Function Signature ```python def increment_number(digits: List[int]) -> List[int]: pass ``` # Input - `digits`: A list of non-negative integers (0-9) representing a large number. The most significant digit is at index 0. # Output - A list of non-negative integers (0-9) representing the incremented number in the same big-endian format. # Constraints - `0 <= len(digits) <= 10^5` - The digits in the list will not contain leading zeros except when the number is zero itself. # Examples ```python assert increment_number([1, 2, 3]) == [1, 2, 4] assert increment_number([1, 2, 9]) == [1, 3, 0] assert increment_number([9, 9, 9]) == [1, 0, 0, 0] assert increment_number([0]) == [1] assert increment_number([4, 3, 2, 1]) == [4, 3, 2, 2] ``` # Explanation - In the first example, 123 + 1 = 124. - In the second example, 129 + 1 = 130 (handling the carry). - In the third example, 999 + 1 = 1000 (multiple carries leading to increase in size). - In the last example, zero incremented by one results in one. # Notes - Ensure that your solution is efficient and handles large inputs within time limits. - You may not convert the list of digits directly to an integer and back to a list to perform the increment operation. - Consider edge cases and aim for in-place modifications where applicable to optimize space usage.","solution":"from typing import List def increment_number(digits: List[int]) -> List[int]: Increment the large number represented by the list of digits by one. Parameters: digits (List[int]): A list of digits representing a large number. Returns: List[int]: A list of digits representing the incremented number. n = len(digits) carry = 1 for i in range(n - 1, -1, -1): new_digit = digits[i] + carry if new_digit < 10: digits[i] = new_digit carry = 0 break else: digits[i] = 0 carry = 1 if carry == 1: digits.insert(0, 1) return digits"},{"question":"You are given a list of integers and a target integer. Your task is to write a function that finds the indices of the two numbers in the list that add up to the target number. You may assume that each input would have exactly one solution. The function should return a tuple of indices of the two numbers. # Function Signature ```python def find_two_sum_indices(nums: List[int], target: int) -> Tuple[int, int]: ``` # Input - `nums`: A list of integers of length n (1 <= n <= 10^4) - `target`: An integer that is the target sum. # Output - A tuple (i, j), where `i` and `j` are the indices of the two numbers in the list that add up to the target number. # Constraints - Each input list will have exactly one solution. - You may not use the same element twice. - Return the indices in any order. # Example ```python nums = [2, 7, 11, 15] target = 9 find_two_sum_indices(nums, target) # Output: (0, 1) because nums[0] + nums[1] = 2 + 7 = 9 ``` # Hint Use a hash map to keep track of the numbers you have seen so far and their indices. While iterating through the list, check if the complement of the current number (target - current number) already exists in the hash map.","solution":"from typing import List, Tuple def find_two_sum_indices(nums: List[int], target: int) -> Tuple[int, int]: Finds the indices of the two numbers in the list that add up to the target number. Args: nums: List[int] - A list of integers. target: int - The target sum. Returns: Tuple[int, int] - A tuple containing the indices of the two numbers that add up to the target. num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return (num_to_index[complement], i) num_to_index[num] = i"},{"question":"You are given an array of integers and your task is to sort this array using the Stooge Sort algorithm. Although Stooge Sort is not efficient for large inputs, implementing it can provide insights into recursive sorting methods. Your implementation should follow the Stooge Sort principle, which involves recursively sorting overlapping segments of the array. # Function Signature ```python def stoogesort(arr: List[int], l: int, h: int) -> List[int]: ``` # Input - `arr`: A list of integers ( (-10^9 leq text{arr[i]} leq 10^9) ) - `l`: Starting index of the segment (0 ≤ l < len(arr)) - `h`: Ending index of the segment (0 ≤ h < len(arr)) # Output - Return the sorted list. # Constraints - The input array will have at most ( 10^4 ) elements. - Consider edge cases like arrays with less than three elements, arrays with duplicate elements, and already sorted or reverse-sorted arrays. # Example ```python # Example 1 arr = [5, 3, 2, 8, 1, 4] result = stoogesort(arr, 0, len(arr) - 1) print(result) # Output should be [1, 2, 3, 4, 5, 8] # Example 2 arr = [3, 1] result = stoogesort(arr, 0, 1) print(result) # Output should be [1, 3] ``` # Additional Notes Your implementation must use the recursive Stooge Sort method described. Ensure to handle edge cases mentioned, and remember to test with arrays of different sizes and values to validate your solution.","solution":"from typing import List def stoogesort(arr: List[int], l: int, h: int) -> List[int]: if l >= h: return arr # If the first element is larger than the last element, swap them if arr[l] > arr[h]: arr[l], arr[h] = arr[h], arr[l] # If there are more than two elements in the array if h - l + 1 > 2: t = (h - l + 1) // 3 # Recursively sort first 2/3rd segment stoogesort(arr, l, h - t) # Recursively sort last 2/3rd segment stoogesort(arr, l + t, h) # Recursively sort first 2/3rd segment again to confirm the sorting stoogesort(arr, l, h - t) return arr"},{"question":"Tree Traversal and Printing # Problem Statement You are given a dictionary-based tree structure where the keys represent nodes, and each node has a list of sub-elements. Write a function `tree_traversal(tree: dict) -> None` that traverses this tree and prints its structure. Your function should follow these requirements: 1. Print each node and its sub-elements. 2. For each node, print the key, followed by an arrow (`->`), and then its sub-elements. 3. If a sub-element is not a string (i.e., another dictionary or nested structure), it should begin printing on a new line with an appropriate indentation. # Expected Input and Output **Input**: * A dictionary `tree` with: * Keys as node identifiers. * Values as lists of sub-elements (which can be strings or other lists). **Output**: * Print each node and its sub-elements in a hierarchical structure. # Constraints * You may assume that the input tree does not contain any cycles (i.e., it\'s a proper hierarchical structure). # Performance Requirements * Time complexity should be O(n), where n is the number of nodes in the tree. * Aim for an efficient solution with minimal repetitive lookups. # Example Given the tree: ```python tree = { \'a\': [\'Adam\', \'Book\', 4], \'b\': [\'Bill\', \'Computer\', 5, \'TV\', 6, \'Jill\', \'Sports\', 1], \'c\': [\'Bill\', \'Sports\', 3], \'d\': [\'Adam\', \'Computer\', 3, \'Quin\', \'Computer\', 3], \'e\': [\'Quin\', \'Book\', 5, \'TV\', 2], \'f\': [\'Adam\', \'Computer\', 7] } ``` **Output**: ``` a -> Adam -> Book -> 4 b -> Bill -> Computer -> 5 -> TV -> 6 -> Jill -> Sports -> 1 c -> Bill -> Sports -> 3 d -> Adam -> Computer -> 3 -> Quin -> Computer -> 3 e -> Quin -> Book -> 5 -> TV -> 2 f -> Adam -> Computer -> 7 ``` Your task: Implement the function `tree_traversal(tree: dict) -> None`.","solution":"def tree_traversal(tree): def traverse(node, indent=0): if isinstance(node, str): print(\\" \\" * indent + node) elif isinstance(node, dict): for key, value in node.items(): print(\\" \\" * indent + key + \\" -> \\") traverse(value, indent + 4) elif isinstance(node, list): for item in node: traverse(item, indent) else: print(\\" \\" * indent + str(node)) for key, value in tree.items(): print(key + \\" -> \\") traverse(value, 4)"},{"question":"# Stooge Sorting Problem *Context:* Stooge Sort is an inefficient, recursive sorting algorithm primarily used for educational purposes. You are provided with a list of integers that needs to be sorted in non-decreasing order using Stooge Sort. The algorithm works by recursively sorting overlapping parts of the list. *Problem Statement:* Implement a function `stooge_sort(arr: List[int]) -> List[int]` which sorts the input list using Stooge Sort algorithm. *Function Signature:* ```python def stooge_sort(arr: List[int]) -> List[int]: ``` *Input:* - `arr`: A list of integers `arr` where `1 <= len(arr) <= 100` and `-1000 <= arr[i] <= 1000`. *Output:* - The function should return a new list of integers sorted in non-decreasing order using Stooge Sort. *Constraints:* - You may not use built-in sorting functions or libraries. - The solution must be implemented using the Stooge Sort algorithm specifically. - Consider and handle edge cases like single-element lists and lists with duplicated values. *Example:* ```python # Example 1 input_arr = [5, 3, 2, 8, 1] output_arr = stooge_sort(input_arr) print(output_arr) # Output: [1, 2, 3, 5, 8] # Example 2 input_arr = [29, 10, 14, 37, 14] output_arr = stooge_sort(input_arr) print(output_arr) # Output: [10, 14, 14, 29, 37] ``` *Explanation:* - In the first example, the input `[5, 3, 2, 8, 1]` is sorted to become `[1, 2, 3, 5, 8]`. - In the second example, the input `[29, 10, 14, 37, 14]` is sorted to become `[10, 14, 14, 29, 37]`. *Notes:* - Ensure that the recursive nature and specific steps of Stooge Sort are followed. - Test your function against various cases, including arrays with negative numbers and repeated elements.","solution":"from typing import List def stooge_sort(arr: List[int]) -> List[int]: Sorts an array using the Stooge Sort algorithm. def stoogesort_helper(arr, l, h): if l >= h: return # If the element at l is greater than the element at h, swap them if arr[l] > arr[h]: arr[l], arr[h] = arr[h], arr[l] # Recursively sort overlapping parts of the array if more than 2 elements if h - l + 1 > 2: t = (h - l + 1) // 3 stoogesort_helper(arr, l, h - t) stoogesort_helper(arr, l + t, h) stoogesort_helper(arr, l, h - t) stoogesort_helper(arr, 0, len(arr) - 1) return arr"},{"question":"# Question: Search for an Optimal Value You are given a sorted list of distinct integers, representing sensor readings from a uniformly distributed dataset. Implement the `find_optimal_value` function that uses interpolation search to locate the first instance of the reading that exceeds a given threshold and is closest to the threshold. Input Format: * A sorted list of distinct integers `readings` ( text{(1 <= text{len(readings)} <= 10^6)} ) * An integer `threshold` ( text{(-10^6 <= threshold <= 10^6)} ) Output Format: * Return the reading which is the smallest reading greater than `threshold`. * If there are no such readings, return `-1`. Constraints: * Your algorithm should be efficient with a time complexity of ( O(log(log n)) ) for average cases and handle large input sizes within a reasonable execution time. Example: ```python def find_optimal_value(readings: List[int], threshold: int) -> int: # Your implementation here # Example Usage: print(find_optimal_value([-25, -12, -1, 10, 12, 15, 20, 41, 55], 10)) # Output: 12 print(find_optimal_value([5, 10, 12, 14, 17, 20, 21], 21)) # Output: -1 print(find_optimal_value([5, 10, 12, 14, 17, 20, 21], -5)) # Output: 5 ``` **Explanation**: 1. When the threshold is 10, the closest reading above it is 12. 2. When the threshold is 21, there are no readings above it, hence the output is -1. 3. When the threshold is -5, the closest reading above it is 5. The goal is to demonstrate an understanding of interpolation search while efficiently handling and searching within a large dataset.","solution":"from typing import List def find_optimal_value(readings: List[int], threshold: int) -> int: Implementation of an interpolation search to find the smallest reading greater than the threshold. If no such reading exists, return -1. n = len(readings) low, high = 0, n - 1 while low <= high and readings[low] <= threshold <= readings[high]: if readings[low] == readings[high]: break pos = low + ((threshold - readings[low]) * (high - low) // (readings[high] - readings[low])) if pos >= n: break if readings[pos] == threshold: low = pos + 1 elif readings[pos] < threshold: low = pos + 1 else: high = pos - 1 while low < n and readings[low] <= threshold: low += 1 return readings[low] if low < n else -1"},{"question":"You are given the root of a binary tree. Write a function `invertTree(root)` that inverts (mirrors) the binary tree and returns the root of the inverted tree. # Input - The input parameter, `root`, is the root node of a binary tree. Each node contains the following properties: - `val` (integer): The value of the node. - `left` (TreeNode or None): Reference to the left child. - `right` (TreeNode or None): Reference to the right child. # Output - Return the root of the tree after it has been inverted. # Constraints - The number of nodes in the tree is in the range `[0, 10^4]`. - `-100 <= Node.val <= 100` # Example Example 1: ``` Input: 4 / 2 7 / / 1 3 6 9 Output: 4 / 7 2 / / 9 6 3 1 ``` Example 2: ``` Input: 2 / 1 3 Output: 2 / 3 1 ``` # Notes - The input will be given in the form of a TreeNode object, and your function should directly manipulate this object. # Implementation Guidance Consider both recursion and iteration approaches for inverting the tree and note the different behaviors and trade-offs between these two methods.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def invertTree(root): Inverts a binary tree. Parameters: root (TreeNode): The root of the binary tree. Returns: TreeNode: The root of the inverted binary tree. if root is None: return None # Swap the left and right children root.left, root.right = root.right, root.left # Recursively invert the left and right subtrees invertTree(root.left) invertTree(root.right) return root"},{"question":"You are given a node (but not the head node) in a singly linked list. Write a function to delete that node, effectively removing it from the linked list. You only have access to this node (i.e., you cannot traverse the list from the head). # Function Signature ```python def delete_node(node: Node): # Your code here ``` # Input/Output Format * **Input**: A `Node` object referring to the node that needs to be deleted. * **Output**: This function does not return anything but modifies the linked list in place. # Constraints * The node to be deleted is not the last node in the list. * The function should raise a `ValueError` if an attempt is made to delete a null node or the last node. # Example Consider a linked list 1 -> 2 -> 3 -> 4 -> 5, and you are given the node with value `3`. * **Input**: Node with value `3`. * **Output**: After calling `delete_node(node)`, the linked list should become 1 -> 2 -> 4 -> 5. # Notes - Make sure to handle invalid scenarios by raising appropriate exceptions. - Ensure your solution runs in constant time O(1). # Testing You should write unit tests to verify the correctness of your solution. Below is an example of how you might structure your testing: ```python import unittest class TestLinkedListNodeDeletion(unittest.TestCase): def test_delete_node(self): # Initialize linked list 1 -> 2 -> 3 -> 4 -> 5 head = Node(1) current = head for value in range(2, 6): current.next = Node(value) current = current.next # Node to delete: Node with value 3 node_to_delete = head.next.next # Expected linked list after deletion: 1 -> 2 -> 4 -> 5 delete_node(node_to_delete) # Check resulting linked list expected_values = [1, 2, 4, 5] current = head for value in expected_values: self.assertEqual(current.val, value) current = current.next # Ensure the tail node\'s next pointer is None self.assertIsNone(current) def test_delete_node_edge_case(self): head = Node(1) self.assertRaises(ValueError, delete_node, head) # Should raise ValueError when single node if __name__ == \\"__main__\\": unittest.main() ```","solution":"class Node: def __init__(self, val=0, next=None): self.val = val self.next = next def delete_node(node: Node): if not node or not node.next: raise ValueError(\\"Cannot delete the last node or a None node\\") node.val = node.next.val node.next = node.next.next"},{"question":"Question: Implement a Bucket Sort Algorithm You are required to implement a Bucket Sort algorithm that sorts an array of integers. The goal is to demonstrate your understanding of the bucket sort concept, distribution mechanism, and sorting within buckets. # Task: 1. Implement a bucket sort algorithm for an array of integers. 2. Ensure your function handles edge cases, such as arrays with duplicate values and non-uniformly distributed integers. # Function Signature ```python def bucket_sort(arr: List[int]) -> List[int]: ``` # Input: - A list of integers `arr` with a length of 1 to 10^5. - All integers in `arr` will be non-negative and less than or equal to 10^6. # Output: - A list of integers sorted in ascending order. # Constraints: - Use Insertion Sort for sorting individual buckets. - Aim for an average-case time complexity of O(n + k). - Your solution should handle up to 10^5 integers efficiently. # Example: ```python input = [29, 25, 3, 49, 9, 37, 21, 43] output = [3, 9, 21, 25, 29, 37, 43, 49] ``` # Notes: - Explain any assumptions you make in your implementation. - Your code should not only work correctly but also be efficient within the given constraints.","solution":"from typing import List def insertion_sort(bucket): Helper function to perform insertion sort on a single bucket/list. for i in range(1, len(bucket)): up = bucket[i] j = i - 1 while j >= 0 and bucket[j] > up: bucket[j + 1] = bucket[j] j -= 1 bucket[j + 1] = up return bucket def bucket_sort(arr: List[int]) -> List[int]: if len(arr) == 0: return arr # Find the maximum value in the array to determine bucket ranges max_value = max(arr) # Create a number of buckets, use the length of the array for better distribution num_buckets = len(arr) buckets = [[] for _ in range(num_buckets)] # Distribute the elements into the buckets for i in range(len(arr)): index = int(arr[i] * num_buckets / (max_value + 1)) buckets[index].append(arr[i]) # Sort each bucket and concatenate them back into a single list sorted_array = [] for bucket in buckets: sorted_array.extend(insertion_sort(bucket)) return sorted_array"},{"question":"# Scenario You are working on a data integrity task where you need to identify gaps in datasets. Given a sorted array of integers and a defined range `[lo, hi]`, implement a function to identify and return all missing ranges within the defined range. # Function Description Implement the function `missing_ranges(arr, lo, hi)` where: * `arr`: A sorted list of unique integers. * `lo`: An integer representing the lower bound of the range (inclusive). * `hi`: An integer representing the upper bound of the range (inclusive). The function should return a list of tuples representing the missing ranges. Each tuple `(a, b)` specifies a missing range from `a` to `b` inclusive. # Input * A sorted list of integers `arr` (0 <= len(arr) <= 10^6). * Two integers `lo` and `hi` such that `lo <= hi`. # Output * A list of tuples representing the missing ranges. Each tuple is of the form `(a, b)` where `a` and `b` are both inclusive. # Constraints * The input array `arr` may be empty. * Elements in `arr` are all distinct and sorted in ascending order. * The values for `lo` and `hi` are within the range of 32-bit signed integers. # Examples ``` python assert missing_ranges([3, 5], 1, 10) == [(1, 2), (4, 4), (6, 10)] assert missing_ranges([1, 2, 3, 4, 5], 1, 5) == [] assert missing_ranges([], 1, 3) == [(1, 3)] assert missing_ranges([2, 5, 8], 1, 10) == [(1, 1), (3, 4), (6, 7), (9, 10)] ``` # Edge Cases to Consider 1. The array is empty, and the entire range is missing. 2. The entire range is covered by the array, resulting in no missing ranges. 3. The range `lo` to `hi` is very large, testing the function\'s performance. Implement the function `missing_ranges(arr, lo, hi)` to solve this problem.","solution":"def missing_ranges(arr, lo, hi): Identify and return all missing ranges within the defined range [lo, hi]. :param arr: A sorted list of unique integers. :param lo: An integer representing the lower bound of the range (inclusive). :param hi: An integer representing the upper bound of the range (inclusive). :return: A list of tuples representing the missing ranges. if not arr: return [(lo, hi)] if lo <= hi else [] missing = [] previous = lo - 1 for num in arr: if num - previous > 1: missing.append((previous + 1, num - 1)) previous = num if hi - arr[-1] > 0: missing.append((arr[-1] + 1, hi)) return missing"},{"question":"You are tasked with writing a function that filters an array such that only elements within a specified minimum and/or maximum value are included. The provided constraints should ensure an efficient algorithm with linear time complexity. # Function Definition: ```python def limit(arr: list[int], min_lim: Optional[int] = None, max_lim: Optional[int] = None) -> list[int]: Filters the input array based on the specified minimum and/or maximum value. Parameters: arr (list of int): The input array of integers. min_lim (int, optional): The minimum value limit (inclusive). If None, no minimum limit is applied. max_lim (int, optional): The maximum value limit (inclusive). If None, no maximum limit is applied. Returns: list of int: The filtered array containing elements within the specified range. pass ``` # Example: ```python # Example 1 print(limit([1, 2, 3, 4, 5], None, 3)) # Output: [1, 2, 3] # Example 2 print(limit([10, 23, 45, 50, 65], 20, 50)) # Output: [23, 45, 50] # Example 3 print(limit([100, 200, 300, 400], 50, None)) # Output: [100, 200, 300, 400] # Example 4 print(limit([], 10, 20)) # Output: [] # Example 5 print(limit([1, 2, 3, 4, 5])) # Output: [1, 2, 3, 4, 5] ``` # Constraints: * Assume all elements in the input array are integers. * The size of the input array can be as large as (10^6). * The values of `min_lim` and `max_lim` can be any integer, positive or negative, or `None`. # Instructions: 1. Implement the function `limit` as defined above. 2. Ensure your implementation is optimized for large input sizes. 3. Handle edge cases effectively. Your implementation will be graded based on correctness, efficiency, and adherence to Pythonic practices.","solution":"from typing import Optional def limit(arr: list[int], min_lim: Optional[int] = None, max_lim: Optional[int] = None) -> list[int]: Filters the input array based on the specified minimum and/or maximum value. Parameters: arr (list of int): The input array of integers. min_lim (int, optional): The minimum value limit (inclusive). If None, no minimum limit is applied. max_lim (int, optional): The maximum value limit (inclusive). If None, no maximum limit is applied. Returns: list of int: The filtered array containing elements within the specified range. result = [] for num in arr: if (min_lim is None or num >= min_lim) and (max_lim is None or num <= max_lim): result.append(num) return result"},{"question":"# Question: Enhanced Pathfinding in Graphs You are given a set of functions for finding different types of paths in an unweighted, directed graph. Your task is to optimize these functions and extend their functionality. **Task**: Implement the following functions: 1. **optimized_find_path(graph, start, end)** - Find a path between two nodes (not necessarily the shortest) without using recursion. - Return a list representing the path from `start` to `end` if exists, otherwise return `None`. 2. **find_all_paths_excluding_cycles(graph, start, end)** - Find all possible paths between two nodes, avoiding cycles. - Return a list of lists where each inner list represents a valid path from `start` to `end`. 3. **dijkstra_shortest_path(graph, start, end)** - Implement Dijkstra\'s algorithm to find the shortest path between two nodes in a weighted graph. - Return a list representing the shortest path from `start` to `end`. **Input:** - `graph`: Dictionary representing an adjacency list of the graph. - Example (Unweighted): `{\'A\': [\'B\', \'C\'], \'B\': [\'C\', \'D\'], \'C\': [\'D\'], \'D\': []}` - Example (Weighted): `{\'A\': {\'B\': 1, \'C\': 3}, \'B\': {\'C\': 1, \'D\': 2}, \'C\': {\'D\': 1}, \'D\': {}}` - `start`: Starting node for the path. - `end`: Ending node for the path. **Output:** - For `optimized_find_path` and `dijkstra_shortest_path`: Return a list representing the path from `start` to `end`. Return `None` if no path exists. - For `find_all_paths_excluding_cycles`: Return a list of lists where each inner list represents a valid path from `start` to `end`. **Constraints:** - You may assume all input nodes are valid nodes within the graph. - Nodes and edge weights (in the weighted graph case) are all non-negative integers or characters. - The graph won\'t have negative edge weights. # Example: ```python # Example for optimized_find_path graph_unweighted = {\'A\': [\'B\', \'C\'], \'B\': [\'C\', \'D\'], \'C\': [\'D\'], \'D\': []} print(optimized_find_path(graph_unweighted, \'A\', \'D\')) # Output: [\'A\', \'B\', \'D\'] (One possible valid path) # Example for find_all_paths_excluding_cycles print(find_all_paths_excluding_cycles(graph_unweighted, \'A\', \'D\')) # Output: [[\'A\', \'B\', \'D\'], [\'A\', \'B\', \'C\', \'D\'], [\'A\', \'C\', \'D\']] # Example for dijkstra_shortest_path graph_weighted = {\'A\': {\'B\': 1, \'C\': 3}, \'B\': {\'C\': 1, \'D\': 2}, \'C\': {\'D\': 1}, \'D\': {}} print(dijkstra_shortest_path(graph_weighted, \'A\', \'D\')) # Output: [\'A\', \'B\', \'D\'] ```","solution":"from collections import deque import heapq def optimized_find_path(graph, start, end): Find a path between start and end nodes in an unweighted, directed graph without using recursion. queue = deque([[start]]) visited = set() while queue: path = queue.popleft() node = path[-1] if node in visited: continue if node == end: return path visited.add(node) for neighbor in graph.get(node, []): new_path = list(path) new_path.append(neighbor) queue.append(new_path) return None def find_all_paths_excluding_cycles(graph, start, end): Find all possible paths between start and end nodes in an unweighted, directed graph, avoiding cycles. all_paths = [] def dfs(current_node, end, path, visited): if current_node in visited: return if current_node == end: all_paths.append(list(path)) return visited.add(current_node) for neighbor in graph.get(current_node, []): path.append(neighbor) dfs(neighbor, end, path, visited) path.pop() visited.remove(current_node) dfs(start, end, [start], set()) return all_paths def dijkstra_shortest_path(graph, start, end): Implement Dijkstra\'s algorithm to find the shortest path between start and end nodes in a weighted graph. queue = [(0, start, [])] visited = set() while queue: (cost, node, path) = heapq.heappop(queue) if node in visited: continue path = path + [node] if node == end: return path visited.add(node) for neighbor, weight in graph.get(node, {}).items(): if neighbor not in visited: heapq.heappush(queue, (cost + weight, neighbor, path)) return None"},{"question":"# Merge Sort Implementation with Advanced Features Given the principles and characteristics of the merge sort algorithm, implement the `merge_sort` function and its helper `merge` which includes the following requirements: 1. **Input**: A list of integers `arr` of size `n` (0 <= n <= 10^5). 2. **Output**: The list should be sorted in non-decreasing order. 3. **Constraints**: - Optimize the function to handle large datasets efficiently. - Ensure the implementation is stable. Implement the enhanced merge sort with the following additional requirements: 1. **Performance**: For sublists smaller than a threshold value `k`, use an insertion sort to improve performance. 2. **In-Place Sorting**: Limit extra space usage where possible by sorting in place. 3. **Edge Cases Handling**: Ensure code handles edge cases robustly, including: - Empty lists. - Lists with all duplicate elements. # Function Signature: ```python def merge_sort(arr, k=10): pass def merge(left, right, merged): pass ``` # Example: ```python >>> merge_sort([4, 2, 5, 1, 6, 3]) [1, 2, 3, 4, 5, 6] >>> merge_sort([4, 2, 5, 1, 6, 3], k=2) [1, 2, 3, 4, 5, 6] >>> merge_sort([]) [] ``` # Explanation: - The `merge_sort` function takes an additional parameter `k` – if the size of the sublist to be sorted is smaller than this threshold, use an insertion sort for better performance on small datasets. - `merge` function is a helper for merging two sorted sublists into one sorted list, modify its implementation to ensure it merges in place without extra allocation when possible. Feel free to add as many helper functions as needed, but ensure `merge_sort` is the entry point.","solution":"def insertion_sort(arr): Sorts the array in-place using insertion sort. for i in range(1, len(arr)): key = arr[i] j = i - 1 while j >= 0 and key < arr[j]: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key def merge(left, right): Merges two sorted lists into a sorted list. merged = [] i = j = 0 # Merge the two lists together while maintaining sort order while i < len(left) and j < len(right): if left[i] <= right[j]: merged.append(left[i]) i += 1 else: merged.append(right[j]) j += 1 # Append remaining elements merged.extend(left[i:]) merged.extend(right[j:]) return merged def merge_sort(arr, k=10): Sorts the array using merge sort with an insertion sort optimization for small sublists. if len(arr) <= 1: return arr if len(arr) <= k: insertion_sort(arr) return arr # Split the array into two halves mid = len(arr) // 2 left_half = merge_sort(arr[:mid], k) right_half = merge_sort(arr[mid:], k) # Merge the sorted halves return merge(left_half, right_half)"},{"question":"Scenario You are tasked with designing a function that decodes messages encoded as number sequences where each number corresponds to a letter (1 -> \'A\', 2 -> \'B\', ..., 26 -> \'Z\'). Given the mapping rules, the function should return the total number of ways the input number sequence can be decoded. Problem Statement Write a function, `count_decodings`, that takes a string `encoded_message` representing a number sequence and returns the total number of ways it can be decoded into letters. Input - `encoded_message`: A string of digits where each digit and substring (from \'1\' to \'26\') corresponds to a letter as per the given mapping (1 -> \'A\', 2 -> \'B\', ..., 26 -> \'Z\'). - Constraints: - `1 <= len(encoded_message) <= 100` - The input string will only contain digits and will not contain any special characters or spaces. - \'0\' by itself is not a valid encoding. Output - An integer that represents the total number of ways to decode the input `encoded_message`. Example ```python assert count_decodings(\\"12\\") == 2 # \\"AB\\" (1 2) or \\"L\\" (12) assert count_decodings(\\"226\\") == 3 # \\"BZ\\" (2 26), \\"VF\\" (22 6), \\"BBF\\" (2 2 6) assert count_decodings(\\"0\\") == 0 # No valid encoding assert count_decodings(\\"06\\") == 0 # No valid encoding ``` Implementation Requirements - The solution should efficiently handle both small and large inputs within the constraints. - Consider edge cases where the input string might start with \'0\' or contain invalid two-digit numbers. - Ensure memory usage is optimized for processing long sequences.","solution":"def count_decodings(encoded_message): Returns the number of ways to decode the encoded message. :param encoded_message: A string of digits representing the encoded message. :return: An integer representing the total number of ways to decode the message. if not encoded_message or encoded_message[0] == \'0\': return 0 n = len(encoded_message) dp = [0] * (n + 1) dp[0] = 1 # Base case: an empty string has one way to be decoded. dp[1] = 1 # Base case: a non-zero single digit can be decoded in one way. for i in range(2, n + 1): one_digit = int(encoded_message[i-1:i]) two_digits = int(encoded_message[i-2:i]) if 1 <= one_digit <= 9: dp[i] += dp[i-1] if 10 <= two_digits <= 26: dp[i] += dp[i-2] return dp[n]"},{"question":"# Stooge Sort Implementation Challenge Problem Statement: You are asked to implement your version of the Stooge Sort algorithm in Python. This is a recursive sorting algorithm with a unique recursive strategy for sorting sections of an array repeatedly. Function Signature: ```python def stoogesort(arr: list, l: int, h: int) -> None: Sorts the array \'arr\' from index \'l\' to \'h\' in non-decreasing order using the Stooge Sort algorithm. ``` Input: * `arr` (list): List of integers to be sorted. * `l` (int): Starting index of the subarray to be sorted. * `h` (int): Ending index of the subarray to be sorted. Output: * The function should sort the array `arr` in-place and does not return anything. Constraints: * 1 ≤ len(arr) ≤ 1000 * -10^9 ≤ arr[i] ≤ 10^9 Example: ```python arr = [2, 4, 5, 3, 1] stoogesort(arr, 0, len(arr) - 1) print(arr) # Output: [1, 2, 3, 4, 5] ``` Requirements: 1. Swap the first and last elements if the first element is greater. 2. Recursively sort the first two-thirds of the array. 3. Recursively sort the last two-thirds of the array. 4. Recursively sort the first two-thirds of the array again. Notes: - Ensure that your implementation handles edge cases like arrays with 0 or 1 elements gracefully. - Pay attention to the efficiency and make sure your implementation respects the recursive nature of the Stooge Sort algorithm.","solution":"def stoogesort(arr: list, l: int, h: int) -> None: Sorts the array \'arr\' from index \'l\' to \'h\' in non-decreasing order using the Stooge Sort algorithm. if l >= h: return # Swap the first and last elements if they are out of order if arr[l] > arr[h]: arr[l], arr[h] = arr[h], arr[l] # If there are more than two elements in the array if h - l + 1 > 2: t = (h - l + 1) // 3 # Recursively sort the first two-thirds of the array stoogesort(arr, l, h - t) # Recursively sort the last two-thirds of the array stoogesort(arr, l + t, h) # Recursively sort the first two-thirds of the array again stoogesort(arr, l, h - t)"},{"question":"# Context: You have been tasked to implement an efficient sorting algorithm for a large dataset. Based on understanding different heap sorting schemes (max-heap sort and min-heap sort), now extend this knowledge to implement a different variant. # Task: Implement a **Priority Queue Sort** using a heap data structure. The priority queue should be able to handle custom priority values associated with elements and sort the elements based on these priorities. # Requirements: * You need to provide a way to initialize the priority queue with a list of elements along with their associated priority values. * Your priority queue should support two main operations: * Insert an element with an associated priority. * Extract the element with the highest priority. * Finally, provide a function to return a list of elements sorted in descending order of their priority. # Input: * A list of tuples, where each tuple consists of two elements: 1. The element (could be an integer, string, etc.). 2. The priority value (integer). # Expected Output: * A list of elements sorted in descending order of their associated priority values. # Constraints: - All priority values will be integers. - The dataset will have at most (10^5) elements. # Example: ```python pq_data = [(\\"A\\", 2), (\\"B\\", 1), (\\"C\\", 3)] sorted_elements = priority_queue_sort(pq_data) print(sorted_elements) # Output should be [\\"C\\", \\"A\\", \\"B\\"] ``` # Implementation Skeleton: ```python class PriorityQueue: def __init__(self): self.heap = [] def insert(self, element, priority): # Your code here def extract_max(self): # Your code here def priority_queue_sort(data): pq = PriorityQueue() for element, priority in data: pq.insert(element, priority) sorted_result = [] while not pq.is_empty(): sorted_result.append(pq.extract_max()) return sorted_result # Implement `PriorityQueue` class and `priority_queue_sort` function. ```","solution":"import heapq class PriorityQueue: def __init__(self): self.heap = [] def insert(self, element, priority): # Using negative priority to simulate max-heap with heapq (which is a min-heap by default) heapq.heappush(self.heap, (-priority, element)) def extract_max(self): # Extract the highest priority element return heapq.heappop(self.heap)[1] def is_empty(self): return len(self.heap) == 0 def priority_queue_sort(data): pq = PriorityQueue() for element, priority in data: pq.insert(element, priority) sorted_result = [] while not pq.is_empty(): sorted_result.append(pq.extract_max()) return sorted_result"},{"question":"Most Frequent Value Finder You are given an array of integers. Your task is to write a function `find_most_frequent(arr)` that returns a list of the most frequently occurring value(s) in the array. If there is more than one such value, your function should return all of them in a list. Function Signature ```python def find_most_frequent(arr): # Your code here ``` Input - `arr`: List of integers (0 <= len(arr) <= 10^6, -10^9 <= arr[i] <= 10^9) Output - A list of integer(s) that are the most frequent in `arr`. Constraints - If `arr` is empty, return an empty list. - The function should handle arrays containing negative numbers and values up to 1 billion in magnitude. - The function should run in linear time, O(n). Example ```python print(find_most_frequent([1, 1, 2, 2, 3, 4])) # Output: [1, 2] print(find_most_frequent([5, 5, 5, 6, 6, 7])) # Output: [5] print(find_most_frequent([])) # Output: [] print(find_most_frequent([9])) # Output: [9] ``` Notes - Ensure your implementation is efficient and can handle large input sizes within the given constraints. - Thoroughly test your function with various edge cases.","solution":"def find_most_frequent(arr): from collections import Counter if not arr: return [] frequency = Counter(arr) max_count = max(frequency.values()) return [num for num, count in frequency.items() if count == max_count]"},{"question":"# Binary Tree Paths - Depth-First Search You are required to implement a function that collects all root-to-leaf paths in a given binary tree. Each path should be represented as a string in the format \\"root->node1->node2->...->leaf\\". The solution should make use of Depth-First Search (DFS). # Function Signature: ```python def binary_tree_paths(root: TreeNode) -> List[str]: ``` # Input: * `root`: The root node of the binary tree (`TreeNode` object). # Output: * A list of strings, where each string represents a path from the root to a leaf in the binary tree. # Constraints: * The number of nodes in the tree is in the range `[0, 100]`. * `-100 <= Node.val <= 100` # Performance: * Aim for O(N) time complexity. * Space complexity should primarily account for the call stack in your DFS traversal (aim for O(H), where H is the height of the tree). # Example: ```python # Example TreeNode class definition class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None # Example usage and expected outcome root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.right = TreeNode(5) assert binary_tree_paths(root) == [\\"1->2->5\\", \\"1->3\\"] ``` # Instructions: * Create a `TreeNode` class if you need it for testing purposes. * Implement the `binary_tree_paths` function. * Ensure your implementation handles edge cases appropriately, such as when the binary tree is empty (`root` is `None`).","solution":"from typing import List, Optional class TreeNode: def __init__(self, x: int, left: Optional[\'TreeNode\'] = None, right: Optional[\'TreeNode\'] = None): self.val = x self.left = left self.right = right def binary_tree_paths(root: Optional[TreeNode]) -> List[str]: Returns all root-to-leaf paths in the binary tree as a list of strings. def dfs(node: TreeNode, current_path: str, all_paths: List[str]): if node: current_path += str(node.val) # If leaf node, add the path to the list if not node.left and not node.right: all_paths.append(current_path) else: current_path += \\"->\\" if node.left: dfs(node.left, current_path, all_paths) if node.right: dfs(node.right, current_path, all_paths) paths = [] if root: dfs(root, \\"\\", paths) return paths"},{"question":"# Word Trie Data Structure Implementation Objective Design a data structure `WordTrie` which supports adding words and searching for words. The search must support the \'.\' wildcard character, which can match any single letter. Task Implement the `WordTrie` class with the following methods: 1. `add_word(word: str) -> None`: Adds a word to the data structure. 2. `search(word: str) -> bool`: Searches for a word in the data structure, where \'.\' can substitute any letter. Constraints * All inputs are valid lowercase English letters (a-z). * Words added and searched will have length between 1 and 1000. * Maximum of 10^4 words will be added. * Maximum of 10^4 search operations will be performed. Example Usage ```python trie = WordTrie() trie.add_word(\\"bad\\") trie.add_word(\\"dad\\") trie.add_word(\\"mad\\") assert trie.search(\\"pad\\") == False assert trie.search(\\"bad\\") == True assert trie.search(\\".ad\\") == True assert trie.search(\\"b..\\") == True ``` Implementation Notes * Carefully handle the wildcard character \'.\' by considering all possible matches at that position in the trie. * Optimize your implementation to handle the upper constraint limits.","solution":"class WordTrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class WordTrie: def __init__(self): self.root = WordTrieNode() def add_word(self, word: str) -> None: node = self.root for char in word: if char not in node.children: node.children[char] = WordTrieNode() node = node.children[char] node.is_end_of_word = True def search(self, word: str) -> bool: return self._search_from_node(self.root, word) def _search_from_node(self, node: WordTrieNode, word: str) -> bool: for index, char in enumerate(word): if char == \'.\': for child in node.children.values(): if self._search_from_node(child, word[index + 1:]): return True return False elif char in node.children: node = node.children[char] else: return False return node.is_end_of_word"},{"question":"Anagram Check With Early Termination # Problem Statement You are supplied with two strings, `s` and `t`. Write a function to determine if `t` is an anagram of `s`. In addition to the core functionality (confirmed via character frequency comparison), you need to optimize the solution to terminate early when it’s evident that `t` cannot be an anagram of `s`. # Function Signature ```python def is_anagram_optimized(s: str, t: str) -> bool: ``` # Input and Output **Input:** - Two strings `s` and `t` consisting of only lowercase English letters. **Output:** - Return `True` if `t` is an anagram of `s`, otherwise return `False`. # Constraints - The inputs will only contain lowercase English letters. - The length of `s` and `t` is not more than 100,000 characters. # Example **Example 1:** ``` Input: s = \\"anagram\\", t = \\"nagaram\\" Output: True ``` **Example 2:** ``` Input: s = \\"rat\\", t = \\"car\\" Output: False ``` # Performance Requirements - The implemented function should operate within O(n) time complexity. - Optimize space usage, leveraging O(1) space complexity based on the fixed character set size. # Hints: 1. If the lengths of the two strings do not match, immediately return `False`. 2. Use a single hash map or array to count characters and adjust counts accordingly when processing `t`.","solution":"def is_anagram_optimized(s: str, t: str) -> bool: if len(s) != len(t): return False char_count = [0] * 26 # Since the input only contains lowercase English letters for char in s: char_count[ord(char) - ord(\'a\')] += 1 for char in t: index = ord(char) - ord(\'a\') char_count[index] -= 1 if char_count[index] < 0: return False return True"},{"question":"# Scenario A company is developing a software to manage their dynamically changing contact list. The contact list should allow for efficient searching, adding, and removing of contact names based on their unique IDs. Each contact is represented as a unique ID associated with a name. # Problem Statement Implement a Binary Search Tree (BST) that supports the following operations: 1. **Insert a node with a given key and value**: Insert a new node into the BST. If the key already exists, update the node’s value with the new value. 2. **Search for a node by its key**: Search for a node in the BST by its key and return its associated value. If the node does not exist, return an appropriate message. 3. **Delete a node by its key**: Delete a node from the BST by its key. Ensure the tree remains a valid BST after deletion. # Function Specifications 1. **Insert Function** ```python def insert(root, key, value): Insert a node with key and value into the BST. If key already exists, update the value. Parameters: root (TreeNode): The root of the BST key (int): The key to insert value (str): The value to insert Returns: TreeNode: The root of the updated BST ``` 2. **Search Function** ```python def search(root, key): Search for a node by key in the BST. Parameters: root (TreeNode): The root of the BST key (int): The key to search for Returns: str/None: Value associated with the key, or a message if the key is not found ``` 3. **Delete Function** ```python def delete(root, key): Delete a node by key from the BST. Ensure the tree remains a valid BST. Parameters: root (TreeNode): The root of the BST key (int): The key to delete Returns: TreeNode: The root of the updated BST ``` # Constraints 1. All keys are integers and unique. 2. All values are strings. # Example ```python root = None root = insert(root, 50, \\"John Doe\\") root = insert(root, 30, \\"Jane Smith\\") root = insert(root, 70, \\"Emily Davis\\") print(search(root, 30)) # Output: \\"Jane Smith\\" print(search(root, 40)) # Output: \\"Key not found\\" root = delete(root, 50) print(search(root, 50)) # Output: \\"Key not found\\" root = insert(root, 50, \\"John Doe Updated\\") print(search(root, 50)) # Output: \\"John Doe Updated\\" ``` Make sure your implementation handles all edge cases appropriately.","solution":"class TreeNode: def __init__(self, key, value): self.key = key self.value = value self.left = None self.right = None def insert(root, key, value): if root is None: return TreeNode(key, value) elif key < root.key: root.left = insert(root.left, key, value) elif key > root.key: root.right = insert(root.right, key, value) else: # key == root.key root.value = value return root def search(root, key): if root is None: return \\"Key not found\\" elif key < root.key: return search(root.left, key) elif key > root.key: return search(root.right, key) else: # key == root.key return root.value def find_min(node): current = node while current.left is not None: current = current.left return current def delete(root, key): if root is None: return root if key < root.key: root.left = delete(root.left, key) elif key > root.key: root.right = delete(root.right, key) else: # key == root.key if root.left is None: return root.right elif root.right is None: return root.left temp = find_min(root.right) root.key = temp.key root.value = temp.value root.right = delete(root.right, temp.key) return root"},{"question":"Problem Statement You are developing a web application that constructs URLs for API endpoints based on a base URL and various endpoints. Additionally, the same function should work for joining file paths in the different parts of the system. Write a function `join_with_slash` that takes two strings, `base` and `suffix`, and returns a single concatenated string formatted correctly as a URL or file path. # Function Signature ```python def join_with_slash(base: str, suffix: str) -> str: pass ``` # Input * `base`: A string representing the base URL or file path. (1 ≤ len(base) ≤ 10^3) * `suffix`: A string representing an additional URL part or file name. (1 ≤ len(suffix) ≤ 10^3) # Output * A string representing the correctly formatted URL or file path. # Constraints * The inputs will be valid URL or file path parts. * No malformed characters or unusual formatting should be assumed. # Example ```python join_with_slash(\\"http://example.com\\", \\"path/to/resource\\") # Expected output: \\"http://example.com/path/to/resource\\" join_with_slash(\\"http://example.com/\\", \\"/path/to/resource\\") # Expected output: \\"http://example.com/path/to/resource\\" join_with_slash(\\"path/to/dir\\", \\"file\\") # Expected output: \\"path/to/dir/file\\" join_with_slash(\\"path/to/dir/\\", \\"file\\") # Expected output: \\"path/to/dir/file\\" ``` # Explanation * The function should handle and remove any trailing slash from `base` and leading slashes from `suffix` to create a properly formatted single string.","solution":"def join_with_slash(base: str, suffix: str) -> str: Joins a base URL or file path with a suffix, ensuring proper formatting. if base.endswith(\'/\'): base = base[:-1] if suffix.startswith(\'/\'): suffix = suffix[1:] return base + \'/\' + suffix"},{"question":"**Island Counter in 2D Grid** You are given a 2D grid map of \'1\'s (land) and \'0\'s (water). Write a function `num_islands` that returns the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water. # Input * A list of lists, `grid`, composed of \'1\'s and \'0\'s, representing a 2D grid. * E.g., `grid = [[\'1\', \'1\', \'1\', \'1\', \'0\'], [\'1\', \'1\', \'0\', \'1\', \'0\'], [\'1\', \'1\', \'0\', \'0\', \'0\'], [\'0\', \'0\', \'0\', \'0\', \'0\']]`. # Output * An integer representing the count of islands. * E.g., for the above `grid`, the output should be `1`. # Constraints 1. The input 2D grid won\'t be larger than 1000x1000. 2. The input is guaranteed to only contain \'1\'s and \'0\'s. # Task Implement the function `num_islands(grid)` using the Depth-First Search (DFS) algorithm. You need to handle edge cases efficiently, such as: * Grid with no \'1\'s. * Grid with all \'1\'s. * Large grid sizes that should avoid deep recursion stack overflow. # Performance Requirements * Ensure your solution can handle the maximum grid size efficiently without running into memory issues or performance degradation. # Example ```python grid = [ [\'1\', \'1\', \'1\', \'1\', \'0\'], [\'1\', \'1\', \'0\', \'1\', \'0\'], [\'1\', \'1\', \'0\', \'0\', \'0\'], [\'0\', \'0\', \'0\', \'0\', \'0\'] ] print(num_islands(grid)) # Output: 1 grid = [ [\'1\', \'1\', \'0\', \'0\', \'0\'], [\'1\', \'1\', \'0\', \'0\', \'0\'], [\'0\', \'0\', \'1\', \'0\', \'0\'], [\'0\', \'0\', \'0\', \'1\', \'1\'] ] print(num_islands(grid)) # Output: 3 ```","solution":"def num_islands(grid): Returns the number of islands in the given grid. :param grid: List of lists, where \'1\' represents land and \'0\' represents water. :return: Integer count of islands if not grid: return 0 rows, cols = len(grid), len(grid[0]) visited = [[False for _ in range(cols)] for _ in range(rows)] def dfs(r, c): # If out-of-bound or already visited or water (\'0\'), return if r < 0 or c < 0 or r >= rows or c >= cols: return if visited[r][c] or grid[r][c] == \'0\': return visited[r][c] = True # move in 4 directions: down, up, right, left dfs(r + 1, c) dfs(r - 1, c) dfs(r, c + 1) dfs(r, c - 1) island_count = 0 for r in range(rows): for c in range(cols): if grid[r][c] == \'1\' and not visited[r][c]: dfs(r, c) island_count += 1 return island_count"},{"question":"# Question: You are required to re-implement the `check_pangram` function in a more efficient manner using sets. This new implementation should maintain the same functionality but optimize performance by reducing repeated membership checks. Implement a function `is_pangram` that takes a single argument: * `input_string` (str): The string to be checked. The function should return: * `True` if the `input_string` contains every letter of the alphabet at least once. * `False` otherwise. Constraints: * The input string can contain any printable characters. * The function must handle both uppercase and lowercase characters, treating them equivalently. * You must ensure the function performs efficiently even with large input strings. Example ```python print(is_pangram(\\"The quick brown fox jumps over the lazy dog\\")) # True print(is_pangram(\\"Hello World!\\")) # False print(is_pangram(\\"a quick movement of the enemy\\")) # False print(is_pangram(\\"abcdefghijklmnopqrstuvwxyz\\")) # True print(is_pangram(\\"\\")) # False ``` Note: Consider using a set for tracking the letters of the alphabet as you iterate through the string. Ensure you are efficiently handling case insensitivity and minimizing the number of redundant checks.","solution":"def is_pangram(input_string): Checks if the input string is a pangram. Args: - input_string (str): The string to be checked. Returns: - bool: True if the input string contains every letter of the alphabet at least once, False otherwise. alphabet_set = set(\'abcdefghijklmnopqrstuvwxyz\') input_set = set(input_string.lower()) return alphabet_set.issubset(input_set)"},{"question":"You have been provided with a data structure called `SegmentTree` that efficiently handles range queries and updates in logarithmic time. However, this implementation lacks an important feature: **point update** functionality. Your task is to enhance the `SegmentTree` class by adding a `point_update` method that updates the value of an element in the original array and correctly updates the segment tree structure. # Function Signature ```python def point_update(self, index: int, value: int) -> None: # Your implementation here ``` # Input * `index` (int): The index of the element in the array to be updated. * `value` (int): The new value to set at the given index. # Expected Output * The method should update the internal segment tree to reflect the change in the original array and ensure that future queries on the updated range return correct results. # Constraints 1. `0 <= index < len(arr)`. 2. You can assume `arr` is initialized and contains at least 1 element. # Context Given the following code: ```python # Create a segment tree for an array with a specific function mytree = SegmentTree([2, 4, 5, 3, 4], max) # Query before update print(mytree.query(2, 4)) # Output: 5 # Update operation mytree.point_update(2, 10) # Query after update print(mytree.query(2, 4)) # Output should now reflect the updated value, e.g., 10 ``` # Requirements 1. Implement the `point_update` method within the `SegmentTree` class. 2. Ensure the method efficiently updates the segment tree. 3. Maintain the same performance guarantees for the range queries after the update. # Additional Notes * Handle edge cases such as updating an element at the bounds (start or end) of the array. * Keep the code clean and well-documented.","solution":"class SegmentTree: def __init__(self, data, function): self.n = len(data) self.data = data[:] self.function = function self.tree = [None] * (2 * self.n) self._build() def _build(self): # Initialize leaves in the second half of the array for i in range(self.n): self.tree[self.n + i] = self.data[i] # Build the segment tree by calculating internal nodes for i in range(self.n - 1, 0, -1): self.tree[i] = self.function(self.tree[2 * i], self.tree[2 * i + 1]) def query(self, left, right): Range query from index left to right inclusive. left += self.n right += self.n + 1 res = None while left < right: if left & 1: res = self.tree[left] if res is None else self.function(res, self.tree[left]) left += 1 if right & 1: right -= 1 res = self.tree[right] if res is None else self.function(res, self.tree[right]) left >>= 1 right >>= 1 return res def point_update(self, index, value): Update element at index to value and rebuild the relevant part of the segment tree. index += self.n self.tree[index] = value while index > 1: index //= 2 self.tree[index] = self.function(self.tree[2 * index], self.tree[2 * index + 1])"},{"question":"# Scenario: Your company manages a large database where records are sorted by age. Since the ages are almost uniformly distributed, a binary search is not as efficient. You decide to use the interpolation search algorithm to quickly find records based on age. # Task: Implement the function `safe_interpolation_search(array: List[int], search_key: int) -> int` which is an optimized version of `interpolation_search` to handle edge cases and improve upon the performance bottlenecks of standard interpolation search. # Requirements: 1. Handle cases where all elements in `array` are the same. 2. Avoid division by zero. 3. Must return `-1` if `search_key` is not present in `array`. 4. Should be efficient and handle large input sizes quickly. # Input: - `array`: A sorted list of integers (can be empty). - `search_key`: An integer value to search for in `array`. # Output: - Return the index of `search_key` in `array` if found, otherwise return `-1`. # Constraints: - The input array may have 0 to 10^6 elements. - Elements in the array and the `search_key` are integers. # Example: ```python >>> safe_interpolation_search([10, 20, 30, 40, 50], 30) 2 >>> safe_interpolation_search([1, 2, 3, 3, 3, 3, 4, 5], 3) 2 # return any valid index of the element \'3\' >>> safe_interpolation_search([100, 200, 300], 400) -1 >>> safe_interpolation_search([], 10) -1 ``` # Notes: 1. Efficiency and performance should be considered. 2. Code should handle edge cases like an empty array, identical elements, and invalid search positions.","solution":"def safe_interpolation_search(array, search_key): Perform an interpolation search on a sorted array to find the search_key. Args: array (List[int]): A sorted list of integers. search_key (int): The integer value to search for in the array. Returns: int: The index of search_key if found, otherwise -1. if not array: return -1 low, high = 0, len(array) - 1 while low <= high and array[low] <= search_key <= array[high]: # To handle case where all elements are the same if array[low] == array[high]: if array[low] == search_key: return low else: return -1 # Estimate position pos = low + ((search_key - array[low]) * (high - low) // (array[high] - array[low])) # The position should always be within the range if pos < low or pos > high: return -1 if array[pos] == search_key: return pos if array[pos] < search_key: low = pos + 1 else: high = pos - 1 return -1"},{"question":"# Question A city is planning to optimize its public transit routes to ensure that passengers experience the shortest travel times. The city\'s transit network is represented as a weighted, directed graph where nodes represent transit hubs and edges represent routes between these hubs with associated travel times that can be positive or negative. A negative travel time indicates a time-saving shortcut due to upgraded infrastructure. Task You are tasked with implementing the Bellman-Ford algorithm to determine the shortest travel times from a chosen transit hub to all others, and to detect if there is any negative cycle accessible from the source hub. Implementation Write a function `find_shortest_paths(graph, source)` that takes a graph represented as a dictionary and a source node, and returns a dictionary of the shortest path weights from the source to each other node. If a negative cycle is detected, return `None`. Function Signature ```python def find_shortest_paths(graph: dict, source: str) -> dict: # Implement the function ``` Input * `graph`: A dictionary representing the transit network. The keys are node names (strings), and the values are dictionaries mapping adjacent nodes to travel times (integers). * `source`: A string representing the starting transit hub node. Output * A dictionary mapping each node to its shortest travel time from the source node. If a negative cycle is detected, return `None`. Constraints * The graph can have up to 1000 nodes. * Edge travel times are integers and may be negative. * The source node is guaranteed to be a key in the input graph. Example ```python graph = { \'A\': {\'B\': 4, \'C\': 2}, \'B\': {\'C\': 3, \'D\': 2, \'E\': 3}, \'C\': {\'B\': 1, \'D\': 4, \'E\': 5}, \'D\': {\'E\': 1}, \'E\': {\'D\': -5} } source = \'A\' # Example output # With no negative cycle: # { # \'A\': 0, \'B\': 3, \'C\': 2, \'D\': 4, \'E\': -1 # } # With a negative cycle included in the reach: # None ``` **Hint**: Utilize the Bellman-Ford algorithm\'s edge-relaxation technique, and ensure you handle the detection of negative-weight cycles.","solution":"def find_shortest_paths(graph, source): Implements the Bellman-Ford algorithm to find the shortest path from the source node to all other nodes. If a negative cycle is detected, returns None. Parameters: graph (dict): A dictionary representing the graph where keys are node names and values are dictionaries of adjacent nodes with edge weights. source (str): The starting node. Returns: dict: A dictionary mapping each node to the shortest path weight from the source. Returns None if a negative cycle is detected. # Initialize the distance to all nodes to infinity, and the distance to the source node to 0 distances = {node: float(\'inf\') for node in graph} distances[source] = 0 # Relax edges up to |V|-1 times, where V is the number of vertices for _ in range(len(graph) - 1): for node in graph: for neighbor, weight in graph[node].items(): if distances[node] + weight < distances[neighbor]: distances[neighbor] = distances[node] + weight # Check for negative-weight cycles for node in graph: for neighbor, weight in graph[node].items(): if distances[node] + weight < distances[neighbor]: return None # Negative cycle detected return distances"},{"question":"# Task You are required to implement a function that sorts a list of integers using the Radix Sort algorithm with a minor variation: instead of using base 10, you will use base 16 (hexadecimal). # Function Signature ```python def radix_sort_hex(arr: List[int]) -> List[int]: ``` # Input/Output Formats * **Input**: A list `arr` of integers (1 <= len(arr) <= 10^5, 0 <= arr[i] <= 10^9). * **Output**: A sorted list of integers in ascending order. # Constraints 1. You must use a base 16 (hexadecimal) for the radix sort. 2. The input list can contain up to `10^5` elements. 3. Each element in the input list will be a non-negative integer up to `10^9`. # Performance Requirements * The function should handle the worst-case scenario within a reasonable time limit for the given constraints. # Example ```python Input: [170, 45, 75, 90, 802, 24, 2, 66] Output: [2, 24, 45, 66, 75, 90, 170, 802] Input: [15, 255, 1, 0, 1024] Output: [0, 1, 15, 255, 1024] ``` # Explanation You need to modify the radix sort algorithm to use base 16 instead of base 10. This means each digit position (from the least significant to the most significant) will range from 0 to F (16 hexadecimal digits), and the algorithm should accordingly distribute and gather numbers based on these digits. # Hint A virtual representation or conversion step will be necessary to handle hexadecimal digits, which will be critical throughout each positional sort pass.","solution":"from typing import List def counting_sort_base(arr: List[int], exp: int, base: int) -> List[int]: n = len(arr) output = [0] * n count = [0] * base for i in range(n): index = (arr[i] // exp) % base count[index] += 1 for i in range(1, base): count[i] += count[i - 1] for i in range(n - 1, -1, -1): index = (arr[i] // exp) % base output[count[index] - 1] = arr[i] count[index] -= 1 for i in range(n): arr[i] = output[i] return arr def radix_sort_hex(arr: List[int]) -> List[int]: if len(arr) == 0: return arr max_val = max(arr) exp = 1 base = 16 while max_val // exp > 0: arr = counting_sort_base(arr, exp, base) exp *= base return arr"},{"question":"You are given a list `nums` of integers where exactly two elements appear only once and all the other elements appear exactly twice. Write a function `single_number3` to identify these two unique elements. Given the constraints of time complexity O(N) and space complexity O(1), solve the problem efficiently using bitwise manipulation. # Function Signature ```python def single_number3(nums: List[int]) -> List[int]: pass ``` # Input * `nums` (List[int]): An integer list where exactly two elements appear only once and all others appear exactly twice. # Output * Returns a list containing the two unique elements. # Constraints * The input list will have at least two elements which appear exactly once. * Elements will be in the range of minus to positive of a large integer, including zero. # Example ```python # Example 1 nums = [1, 2, 1, 3, 2, 5] # Output: [3, 5] or [5, 3] (order does not matter) # Example 2 nums = [4, 1, 2, 1, 2, 3] # Output: [4, 3] or [3, 4] ``` # Solution Approach 1. Initialize an integer `ab` to zero to store the XOR of all elements in `nums`. 2. Iterate through the list, performing XOR on every element with `ab`. 3. The result will be the XOR of the two unique numbers (let\'s say A and B), `A ^ B`. 4. Identify the rightmost bit where A and B differ by isolating the lowest bit that is set in `A ^ B`. 5. Using this bit, divide all numbers into two groups: - One group with the identified bit set. - Another group without the identified bit set. 6. XOR all numbers within each group to isolate A and B.","solution":"from typing import List def single_number3(nums: List[int]) -> List[int]: # Step 1: XOR all numbers in the list to get the XOR of the two single occurring numbers. xor_all = 0 for num in nums: xor_all ^= num # Step 2: Identify the rightmost set bit in xor_all. # This will differentiate the two unique numbers. diff_bit = xor_all & -xor_all # Step 3: Divide numbers into two groups and XOR separately a = 0 b = 0 for num in nums: if num & diff_bit: a ^= num else: b ^= num # The result is the two unique numbers. return [a, b]"},{"question":"You are given an integer array `nums` which represents a sequence of numbers. Implement a function `max_subarray` to find the contiguous subarray within `nums` that has the largest sum and return that sum. # Function Signature ```python def max_subarray(nums: List[int]) -> int: ``` # Input * `nums`: A list of integers (an array), where * 1 leq `len(nums)` leq 10^5 * -10^4 leq `nums[i]` leq 10^4 # Output * An integer, the maximum sum of a contiguous subarray within the given array. # Constraints * The input array will contain at least one element. * The input array will consist of integers, which can be both negative and positive. # Example 1. Input: `nums = [-2,1,-3,4,-1,2,1,-5,4]` Output: `6` Explanation: The subarray `[4,-1,2,1]` has the largest sum = 6. 2. Input: `nums = [1]` Output: `1` Explanation: The array contains only one element. 3. Input: `nums = [5,4,-1,7,8]` Output: `23` Explanation: The subarray `[5,4,-1,7,8]` has the largest sum = 23. # Scenario Imagine you are working on an application that analyzes financial stock prices, and you need to determine the period with the highest gain within a given timeframe. Your task is to implement the `max_subarray` algorithm that efficiently calculates the best possible gain from a series of daily price changes.","solution":"from typing import List def max_subarray(nums: List[int]) -> int: Finds the contiguous subarray within an array which has the largest sum. # Initialize our variables using the first element of the array. max_current = max_global = nums[0] # Loop through the rest of the array. for i in range(1, len(nums)): # Calculate the maximum subarray sum ending at index i. max_current = max(nums[i], max_current + nums[i]) # Update the global maximum sum if needed. if max_current > max_global: max_global = max_current return max_global"},{"question":"# Unique Permutations Problem Given an array of numbers that may contain duplicates, write a Python function `permute_unique(nums: List[int]) -> List[List[int]]` that returns a list of all possible unique permutations of the input array. # Input - `nums`: A list of integers which may contain duplicates. (0 ≤ len(nums) ≤ 8) # Output - A list of lists, where each sublist is a unique permutation of the `nums`. # Constraints - The length of `nums` will not exceed 8 to ensure that the time complexity remains manageable. - Each number in `nums` can be any integer, positive or negative. # Example ```python def test_permute_unique(): assert permute_unique([1, 1, 2]) == [ [1, 1, 2], [1, 2, 1], [2, 1, 1] ] assert permute_unique([1, 2, 3]) == [ [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1] ] assert permute_unique([1, 1]) == [ [1, 1] ] assert permute_unique([]) == [ [] ] # Run the test function test_permute_unique() ``` Use the provided test cases to verify your solution. Feel free to add more test cases to ensure robustness.","solution":"from typing import List def permute_unique(nums: List[int]) -> List[List[int]]: def backtrack(path, remaining): if not remaining: res.append(path) return prev = None for i in range(len(remaining)): if remaining[i] == prev: continue backtrack(path + [remaining[i]], remaining[:i] + remaining[i+1:]) prev = remaining[i] nums.sort() res = [] backtrack([], nums) return res"},{"question":"# RSA Encryption Key Generation and Data Encryption/Decryption You are given an implementation of the RSA encryption algorithm which includes key generation, encryption, and decryption functions. The provided implementation generates RSA keys and uses them to encrypt and decrypt data. However, the current prime generation method is too simplistic and inefficient. Your task is to improve the `gen_prime` function using a more efficient probabilistic primality testing method and ensure the overall key generation code remains correct and efficient. # Enhanced Requirements: 1. Implement an efficient prime generation method using the Miller-Rabin primality test. 2. Ensure the generated RSA key (n, e, d) is valid and the encryption/decryption process works as expected. # Functions to Implement Complete the implementation for the following function: ```python def gen_prime(k, seed=None): Generate a prime with k bits using the Miller-Rabin primality test def generate_key(k, seed=None): # Complete code provided in the original snippet. ``` # Input Format * `k`: An integer representing the number of bits for n (modulus). * `seed`: An optional seed for the random number generator (used for testing and reproducibility). # Output Format * Returns a tuple (n, e, d) representing the generated RSA key. # Constraints * `k` will be in the range of [16, 1024]. * Properly handle edge cases to avoid infinite loops or incorrect results. # Performance Requirements * Ensure efficient prime testing to handle larger bit sizes within reasonable time constraints. * The implementation should not have a noticeable delay for `k` values up to 512. # Example ```python # Example usage n, e, d = generate_key(16) data = 20 encrypted = encrypt(data, e, n) decrypted = decrypt(encrypted, d, n) assert decrypted == data ``` # Additional Notes Ensure your implementation is thoroughly tested and includes correct handling of random seeding for reproducibility.","solution":"import random def miller_rabin_primality_test(n, k): Run the Miller-Rabin primality test `k` times to determine if `n` is a prime number. if n <= 1: return False if n <= 3: return True if n % 2 == 0: return False # write (n - 1) as 2^r * d r, d = 0, n - 1 while d % 2 == 0: d //= 2 r += 1 # Witness loop for _ in range(k): a = random.randint(2, n - 2) x = pow(a, d, n) if x == 1 or x == n - 1: continue for _ in range(r - 1): x = pow(x, 2, n) if x == n - 1: break else: return False return True def gen_prime(k, seed=None): Generate a prime with k bits using the Miller-Rabin primality test. if seed is not None: random.seed(seed) while True: # Generate a random k-bit number candidate = random.getrandbits(k) # Ensure it is odd and has the correct number of bits candidate |= (1 << (k - 1)) | 1 # Test the candidate using Miller-Rabin if miller_rabin_primality_test(candidate, 40): # 40 is a standard number of iterations for good accuracy return candidate def gcd(a, b): while b != 0: a, b = b, a % b return a def modinv(a, m): Return the modular inverse of a under modulo m, using the Extended Euclidean Algorithm. m0, x0, x1 = m, 0, 1 while a > 1: q = a // m m, a = a % m, m x0, x1 = x1 - q * x0, x0 if x1 < 0: x1 += m0 return x1 def generate_key(k, seed=None): Generate RSA key pair. if seed is not None: random.seed(seed) p = gen_prime(k//2, seed) q = gen_prime(k//2, seed) n = p * q phi = (p - 1) * (q - 1) e = 65537 # Commonly used free exponent if gcd(e, phi) != 1: raise ValueError(\\"e and phi(n) are not coprime.\\") d = modinv(e, phi) return n, e, d def encrypt(data, e, n): Encrypt data with public key (e, n). return pow(data, e, n) def decrypt(ciphertext, d, n): Decrypt data with private key (d, n). return pow(ciphertext, d, n)"},{"question":"# **Coding Assessment Question** Problem Statement You are given an `m x n` matrix. Implement a function that returns all the elements of the matrix in a spiral order traversal. Function Signature ```python def spiral_order(matrix: List[List[int]]) -> List[int]: ``` Input - `matrix` : A list of lists of integers, where `matrix[i][j]` represents the element at row `i` and column `j`. - (1 leq text{number of rows} leq 50) - (1 leq text{number of columns} leq 50) - The elements may be between ( -10^9 ) and ( 10^9 ) Output - A list of integers representing the matrix elements in spiral order. Example ```python # Example 1 matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] print(spiral_order(matrix)) # Expected output: [1, 2, 3, 6, 9, 8, 7, 4, 5] # Example 2 matrix = [ [1] ] print(spiral_order(matrix)) # Expected output: [1] # Example 3 matrix = [ [1, 2], [3, 4] ] print(spiral_order(matrix)) # Expected output: [1, 2, 4, 3] ``` Constraints - Your solution should run in (O(m times n)) time complexity. - Optimize for space complexity not exceeding (O(m times n)). Notes - Consider edge cases such as an empty matrix, single row/column matrices. - Ensure that your solution handles any integer value within the given range. # **Function Implementation** Implement the function `spiral_order(matrix: List[List[int]]) -> List[int]` based on the given template.","solution":"from typing import List def spiral_order(matrix: List[List[int]]) -> List[int]: Returns all the elements of the matrix in a spiral order traversal. if not matrix: return [] left, right, top, bottom = 0, len(matrix[0]) - 1, 0, len(matrix) - 1 spiral = [] while left <= right and top <= bottom: # Traverse from left to right for col in range(left, right + 1): spiral.append(matrix[top][col]) top += 1 # Traverse downwards for row in range(top, bottom + 1): spiral.append(matrix[row][right]) right -= 1 if top <= bottom: # Traverse from right to left for col in range(right, left - 1, -1): spiral.append(matrix[bottom][col]) bottom -= 1 if left <= right: # Traverse upwards for row in range(bottom, top - 1, -1): spiral.append(matrix[row][left]) left += 1 return spiral"},{"question":"# Problem: Circular Elimination Game You are organizing a game based on the famous Josephus problem. In this game, players are arranged in a circle and every k-th player is eliminated in a circular order until only one remains. The elimination process restarts immediately after removing an element. Task: Write a function `circular_elimination(players: List[int], k: int) -> List[int]` which simulates the elimination process and returns the order in which players are eliminated. # Input: - `players`: A list of integers representing players. - `k`: An integer representing the k-th player to be eliminated. # Output: - A list of integers representing the order in which players are eliminated. # Constraints: - 1 <= len(players) <= 10^4 - 1 <= k <= len(players) # Example: Example 1: ```python players = [1, 2, 3, 4, 5, 6, 7, 8, 9] k = 3 output = circular_elimination(players, k) print(output) # Should print [3, 6, 9, 4, 8, 5, 2, 7, 1] ``` Explanation: Starting from the list `[1,2,3,4,5,6,7,8,9]`: - The 3rd player (index 2) `3` is eliminated first. - The next 3rd player after `3` is `6`, and so on. Your implementation should handle edge cases like an empty list and minimize unnecessary computations to ensure efficiency with constraints provided. # Notes: Consider performance optimizations for handling input sizes near the upper constraint boundary.","solution":"from typing import List def circular_elimination(players: List[int], k: int) -> List[int]: Simulates the elimination process and returns the order in which players are eliminated. Each k-th player is removed in a circular order until only one remains. :param players: List of integers representing players. :param k: Integer representing the k-th player to be eliminated. :return: List of integers representing the order in which players are eliminated. elimination_order = [] index = 0 while players: index = (index + k - 1) % len(players) elimination_order.append(players.pop(index)) return elimination_order"},{"question":"Implement a function to find all prime numbers up to a given integer ( N ). Given an integer ( N ), return a list containing all prime numbers less than or equal to ( N ). **Function Signature**: ```python def primes_upto_n(N: int) -> List[int]: ``` # Input: * `N` (1 ≤ N ≤ ( 10^6 )): An integer representing the upper limit up to which primes are to be found. # Output: * Returns a list of integers in ascending order, which are the prime numbers up to and including `N`. # Example: ```python assert primes_upto_n(10) == [2, 3, 5, 7] assert primes_upto_n(20) == [2, 3, 5, 7, 11, 13, 17, 19] assert primes_upto_n(1) == [] ``` # Performance Requirements: * The solution should be optimized to handle the upper limit efficiently, potentially employing the Sieve of Eratosthenes method to achieve ( O(N log log N) ) time complexity. # Constraints: * Carefully handle edge cases including small `N` values. * Ensure performance is optimal for the upper limit of ( N ). **Note**: The created list should contain primes in ascending order and the function should be efficient to handle the maximum constraint efficiently. # Problem Context: Prime numbers are fundamental in various fields such as cryptography, computer security, and algorithm optimization. This exercise aims to solidify students\' understanding of prime generation techniques, efficiency improvements, and handling constraints effectively.","solution":"from typing import List def primes_upto_n(N: int) -> List[int]: Returns a list of prime numbers up to and including N using the Sieve of Eratosthenes. if N < 2: return [] sieve = [True] * (N + 1) sieve[0] = sieve[1] = False # 0 and 1 are not prime numbers for start in range(2, int(N**0.5) + 1): if sieve[start]: for multiple in range(start * start, N + 1, start): sieve[multiple] = False primes = [num for num in range(2, N + 1) if sieve[num]] return primes"},{"question":"Context A private investment firm frequently performs complex combinatorial calculations to analyze potential investment distributions in their portfolios. They need an efficient algorithm to calculate the number of possible ways to distribute investments among various funds. As part of their hiring screening, they require candidates to implement the binomial coefficient calculation. Task Write a function to compute the binomial coefficient ( C(n, k) ) in an iterative way using dynamic programming. The function should handle up to large values efficiently within the provided constraints. Input The function should take two integers ( n ) and ( k ): ```python def binomial_coefficient(n: int, k: int) -> int: pass ``` Output The function should return the binomial coefficient ( C(n, k) ) as an integer. Constraints - ( 0 leq k leq n leq 1000 ) Example ```python >>> binomial_coefficient(5, 0) 1 >>> binomial_coefficient(8, 2) 28 >>> binomial_coefficient(100, 50) 100891344545564193334812497256 ``` Additional Information - The solution should avoid deep recursion and ensure efficient computation. - Handle special cases where ( k = 0 ) or ( k = n ) by directly returning 1. - Implement the solution iteratively to avoid stack overflow problems due to recursion limits.","solution":"def binomial_coefficient(n: int, k: int) -> int: if k == 0 or k == n: return 1 k = min(k, n - k) # Take advantage of symmetry, C(n, k) = C(n, n-k) C = [0] * (k + 1) C[0] = 1 # because C(n, 0) = 1 for i in range(1, n + 1): j = min(i, k) while j > 0: C[j] += C[j - 1] j -= 1 return C[k]"},{"question":"You are given a set of items, each with a weight and a value, and a knapsack with a maximum weight capacity. You must determine the maximum value that can be accommodated in the knapsack by selecting items such that the total weight does not exceed the given capacity. Each item can be included or excluded (0/1 Knapsack problem). **Function Signature**: ```python def get_maximum_value(items: List[Item], capacity: int) -> int ``` # Input * `items`: A list of `Item` objects where each item has: * `value` (an integer): The value of the item. * `weight` (an integer): The weight of the item. * `capacity`: An integer representing the maximum weight capacity of the knapsack. # Output * Return an integer representing the maximum value that can be achieved with the given items and knapsack capacity. # Constraints * 1 ≤ number of `items` ≤ 10^3 * 1 ≤ `capacity` ≤ 10^5 * 1 ≤ `value` of each item ≤ 10^3 * 1 ≤ `weight` of each item ≤ 10^3 # Example ```python capacity = 5 items = [Item(60, 5), Item(50, 3), Item(70, 4), Item(30, 2)] # The maximum value is 80 by selecting items with values 50 and 30. result = get_maximum_value(items, capacity) print(result) # Output: 80 ``` # Clarifications * You may assume all inputs are provided in valid format and within stated constraints. * Focus on using a space-efficient approach for dynamic programming.","solution":"from typing import List class Item: def __init__(self, value: int, weight: int): self.value = value self.weight = weight def get_maximum_value(items: List[Item], capacity: int) -> int: Returns the maximum value that can be accommodated in the knapsack with given capacity. Uses dynamic programming for solution. # Create a list to store the maximum value at each capacity (0 to capacity) dp = [0] * (capacity + 1) for item in items: # Traverse dp array from right to left to ensure we do not overwrite values needed for calculations in this iteration. for c in range(capacity, item.weight - 1, -1): dp[c] = max(dp[c], dp[c - item.weight] + item.value) return dp[capacity]"},{"question":"Scenario Consider you are building a feature for a firmware of a microcontroller. This feature should determine the longest possible sequence of 1s in the binary representation of an integer by flipping exactly one bit from 0 to 1. This can help in optimizing operations that depend on the on-off states of an electronic circuit. Task Write a Python function that takes an integer as input and returns the length of the longest sequence of 1s that can be obtained by flipping exactly one bit from 0 to 1 in its binary representation. Function Signature ```python def flip_bit_longest_seq(num: int) -> int: pass ``` Input - `num`: An integer (1 <= num <= 2^31 - 1) Output - An integer representing the length of the longest sequence of 1s achievable by flipping exactly one bit from 0 to 1. Constraints - Your solution should handle reasonably large integers efficiently. - Negative numbers or non-integer inputs are out of scope for this problem. Examples 1. For the input `1775` (binary: `11011101111`), the output should be `8`. 2. For the input `15` (binary: `1111`), the output should be `5` (by flipping any of the implicit trailing 0s). Note - Remember to consider edge cases such as numbers that are already in their maximum possible sequence of 1s, or numbers that need a 0 to be flipped in the middle to get the longest sequence.","solution":"def flip_bit_longest_seq(num: int) -> int: Determine the length of the longest sequence of 1s in the binary representation of an integer by flipping exactly one bit from 0 to 1. if num == -1: return 32 # 32 bits are all 1s in this case. current_length = 0 previous_length = 0 max_length = 1 # We can always have at least one 1 while num != 0: if (num & 1) == 1: # Current bit is 1 current_length += 1 else: # Current bit is 0 previous_length = 0 if (num & 2) == 0 else current_length current_length = 0 max_length = max(previous_length + current_length + 1, max_length) num >>= 1 # Right shift the number by 1 to check the next bit return max_length"},{"question":"# Question: Validate Bracket Sequence You are required to write a function `is_balanced` that determines if a given string consisting of brackets is valid. The string will only contain the characters \'(\', \')\', \'{\', \'}\', \'[\' and \']\'. A string is considered valid if: 1. All opening brackets have their corresponding closing brackets. 2. Brackets are correctly nested and closed in the correct order. Function Signature ```python def is_balanced(s: str) -> bool: ``` Input * `s`: A string of length n (0 ≤ n ≤ 10^4) containing brackets. Output * Return `True` if the string is valid, otherwise return `False`. Constraints * Only the characters \'(\', \')\', \'{\', \'}\', \'[\' and \']\' will be present in the input string `s`. Examples ```python # Example 1 assert is_balanced(\\"()\\") == True # Example 2 assert is_balanced(\\"()[]{}\\") == True # Example 3 assert is_balanced(\\"(]\\") == False # Example 4 assert is_balanced(\\"([)]\\") == False # Example 5 assert is_balanced(\\"{[]}\\") == True ``` Performance Requirements * Your function should operate in O(n) time complexity and use O(n) additional space. **Scenario**: You are building a simple code editor that needs to validate whether the brackets used in the code are balanced. This ensures that the code won\'t have syntax errors related to unbalanced or mismatched brackets before further processing. **Hint**: Use a stack to keep track of the opening brackets. For every closing bracket, check for the most recent unmatched opening bracket.","solution":"def is_balanced(s: str) -> bool: Determines if the given string consisting of brackets is balanced. :param s: A string containing the characters \'(\', \')\', \'{\', \'}\', \'[\' and \']\'. :return: True if the string is balanced, otherwise False. stack = [] bracket_pair = {\')\': \'(\', \'}\': \'{\', \']\': \'[\'} for char in s: if char in bracket_pair.values(): # if it\'s an opening bracket stack.append(char) elif char in bracket_pair: # if it\'s a closing bracket if stack == [] or bracket_pair[char] != stack.pop(): return False return stack == []"},{"question":"# Question: Remove Duplicates from a Sorted Singly Linked List You are provided with a sorted singly linked list of integers. Your task is to write a function `remove_dups_sorted` that removes all duplicate elements from the list such that each element appears only once. The input list is sorted, hence duplicates are guaranteed to be consecutive. Function Signature: ```python def remove_dups_sorted(head: Node) -> Node: pass ``` Input - A singly linked list of integers represented by its head node. - Each `Node` contains two attributes: `val` (integer value) and `next` (pointer to the next node). Output - The head node of the modified linked list with all duplicates removed. Constraints - The input linked list is sorted in non-decreasing order. - The linked list can have up to (10^5) nodes. Implementation Requirements - Your function should modify the list in-place to achieve ( O(1) ) extra space complexity. - Ensure the solution has ( O(N) ) time complexity. Example ```python # Definition for List Node class Node: def __init__(self, val=0, next=None): self.val = val self.next = next # Example usage: # Input: 1 -> 1 -> 2 -> 3 -> 3 # Output: 1 -> 2 -> 3 head = Node(1, Node(1, Node(2, Node(3, Node(3))))) new_head = remove_dups_sorted(head) print_linked_list(new_head) # Expected Output: 1 -> 2 -> 3 ``` Notes - Implement helper function `print_linked_list` to verify the output format in the example. - Carefully handle edge cases, such as empty linked lists or lists with a single node.","solution":"class Node: def __init__(self, val=0, next=None): self.val = val self.next = next def remove_dups_sorted(head: Node) -> Node: Removes duplicates from a sorted singly linked list. if not head: return head current = head while current and current.next: if current.val == current.next.val: current.next = current.next.next else: current = current.next return head # Helper function to print linked lists, useful for debugging and testing def print_linked_list(head: Node) -> None: while head: print(head.val, end=\' -> \' if head.next else \'\') head = head.next print()"},{"question":"You are provided with a binary tree. Your task is to write a function that calculates the maximum depth of the binary tree using iterative level-order traversal (BFS). # Function Signature: ```python def max_height(root: TreeNode) -> int: ``` # Input: * `root` (TreeNode): The root of the binary tree. # Output: * Return an integer representing the maximum depth of the binary tree. # Constraints: * The number of nodes in the tree is in the range [0, 10^4]. * The values of the tree node are unique and are in the range [-10^4, 10^4]. # Example: ```python # Define the binary tree structure and utility TreeNode class class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None # Example Usage: # Construct the following tree: # 10 # / # 12 15 # / / # 25 30 36 # # 100 tree = TreeNode(10) tree.left = TreeNode(12) tree.right = TreeNode(15) tree.left.left = TreeNode(25) tree.left.right = TreeNode(30) tree.right.left = TreeNode(36) tree.left.left.right = TreeNode(100) print(max_height(tree)) # Output: 4 ``` # Explanation: The provided function should return `4` for the example tree, as the maximum depth (longest path from the root to a leaf) contains 4 nodes (10 -> 12 -> 25 -> 100). Consider recalculating maximum depth for any tree example to validate your function. # Note: Your implementation should handle large trees efficiently, ensuring optimal usage of space and computation.","solution":"from collections import deque class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def max_height(root: TreeNode) -> int: if not root: return 0 queue = deque([root]) depth = 0 while queue: level_length = len(queue) for _ in range(level_length): node = queue.popleft() if node.left: queue.append(node.left) if node.right: queue.append(node.right) depth += 1 return depth"},{"question":"# Graph Transitive Closure Calculation Scenario Suppose you are working with a social networking platform that models friendships as a directed graph. You need to determine if a user (vertex) can eventually reach another user through a series of friendships (directed edges). To achieve this, you must compute the transitive closure of the graph. Problem Statement Implement a function to determine the transitive closure of a directed graph using Depth-First Search (DFS). The function should return a 2D matrix where each element ([i][j]) is 1 if there\'s a path from the i-th vertex to the j-th vertex, otherwise it\'s 0. Function Signature ```python def transitive_closure(V: int, edges: List[Tuple[int, int]]) -> List[List[int]]: pass ``` Input - **V** (int): Number of vertices in the graph. - **edges** (List[Tuple[int, int]]): List of directed edges in the graph where each edge is represented as a tuple (source, target). Output - **List[List[int]]**: A 2D matrix representing the transitive closure of the graph. Constraints - (1 leq V leq 500) - (0 leq |edges| leq V^2) Example ```python V = 4 edges = [(0, 1), (1, 2), (2, 3)] print(transitive_closure(V, edges)) ``` Output: ```python [ [1, 1, 1, 1], [0, 1, 1, 1], [0, 0, 1, 1], [0, 0, 0, 1] ] ``` Explanation - Vertex 0 can reach all other vertices. - Vertex 1 can reach vertices 1, 2, and 3. - Vertex 2 can reach vertices 2 and 3. - Vertex 3 can only reach itself. # Constraints - The graph represented by `edges` is directed. - Ensure that your solution is efficient given the constraints.","solution":"from typing import List, Tuple def transitive_closure(V: int, edges: List[Tuple[int, int]]) -> List[List[int]]: def dfs(from_vertex, to_vertex, visited): visited[to_vertex] = True reachable[from_vertex][to_vertex] = 1 for neighbor in adj_list[to_vertex]: if not visited[neighbor]: dfs(from_vertex, neighbor, visited) # Initialize adjacency list adj_list = [[] for _ in range(V)] for src, dst in edges: adj_list[src].append(dst) # Initialize the reachable matrix reachable = [[0] * V for _ in range(V)] # For each vertex, perform DFS to mark reachable vertices for i in range(V): visited = [False] * V dfs(i, i, visited) return reachable"},{"question":"Context: You are working on a text processing application that verifies if a given text string conforms to a specified small pattern. Given the constraints that every character in the pattern must map to a unique substring of the text and vice versa, your task is to implement a function that verifies this correspondence. Task: Write a function `pattern_match(pattern: str, string: str) -> bool` to determine if the string `string` follows the given pattern `pattern`. # Function Signature: ```python def pattern_match(pattern: str, string: str) -> bool: ``` # Input: - `pattern` (str): A non-empty string containing only lowercase letters. - `string` (str): A non-empty string containing only lowercase letters. # Output: - Returns `True` if `string` follows the pattern specified in `pattern`. Returns `False` otherwise. # Constraints: - Each character in the pattern must map to a unique, non-empty substring of the string. - Both `pattern` and `string` will contain only lowercase letters. # Examples: ```python assert pattern_match(\\"abab\\", \\"redblueredblue\\") == True assert pattern_match(\\"aaaa\\", \\"asdasdasdasd\\") == True assert pattern_match(\\"aabb\\", \\"xyzabcxzyabc\\") == False ``` # Notes: - You may assume both `pattern` and `string` do not include any spaces or uppercase letters. - Your solution should handle edge cases such as patterns or strings of length zero appropriately. - Performance considerations should be kept in mind; avoid overly inefficient solutions where possible.","solution":"def pattern_match(pattern: str, string: str) -> bool: def is_match(pattern, string, p_to_s, s_to_p): if not pattern: return not string if pattern[0] in p_to_s: sub_str = p_to_s[pattern[0]] if string.startswith(sub_str): return is_match(pattern[1:], string[len(sub_str):], p_to_s, s_to_p) else: return False else: for i in range(1, len(string) - len(pattern) + 2): sub_str = string[:i] if sub_str in s_to_p: continue p_to_s[pattern[0]] = sub_str s_to_p[sub_str] = pattern[0] if is_match(pattern[1:], string[i:], p_to_s, s_to_p): return True del p_to_s[pattern[0]] del s_to_p[sub_str] return False return is_match(pattern, string, {}, {})"},{"question":"# Prime Detection Assessment Given the function `prime_check(n)`, design and implement a function `kth_prime(k)` that returns the `k`-th prime number. Implement this in a way that efficiently finds primes as needed, making use of the provided `prime_check(n)` function. Input * An integer `k` (1 ≤ k ≤ 10^5). Output * The `k`-th prime number. Constraints * The function should be optimized to handle large values of `k` efficiently. * The performance should generally focus on time complexity due to potential large input values. Example ```python print(kth_prime(1)) # Output: 2 print(kth_prime(5)) # Output: 11 print(kth_prime(10)) # Output: 29 ``` Points to Consider * Use an effective way to handle primality checking and avoid unnecessary computations. * Edge Cases: Starting values, performance when `k` is large, etc. * Note any optimization techniques could include storing previously found primes to avoid redundant checks. Solution Skeleton ```python def kth_prime(k): Returns the k-th prime number. # Implement this function pass ```","solution":"def prime_check(n): Checks whether a number n is prime. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def kth_prime(k): Returns the k-th prime number. primes = [] num = 2 while len(primes) < k: if prime_check(num): primes.append(num) num += 1 return primes[-1]"},{"question":"# Question You are tasked with creating an encryption system based on integer base conversion. Specifically, you need to implement functions to: 1. Convert an integer from base 10 to a specified base (between 2 and 36). 2. Convert a string representing a number in a specified base (between 2 and 36) back to base 10. Your task is to write two functions: `int_to_base_changesafe(num, base)` and `base_to_int_changesafe(str_to_convert, base)` with appropriate edge case handling to ensure valid inputs. Below is the detailed specification: Function 1: int_to_base_changesafe **Input**: - `num`: An integer which can be negative, zero, or positive. - `base`: An integer specifying the base to convert to. It is guaranteed to be between 2 and 36, inclusive. **Output**: - A string representing the number in the specified base. **Example**: ```python int_to_base_changesafe(5, 2) -> \'101\' int_to_base_changesafe(15, 16) -> \'F\' int_to_base_changesafe(-255, 16) -> \'-FF\' int_to_base_changesafe(0, 8) -> \'0\' ``` Function 2: base_to_int_changesafe **Input**: - `str_to_convert`: A string representing the number in the specified base. It may contain digits and uppercase letters A-Z (for bases greater than 10). - `base`: An integer specifying the base of the input string. It is guaranteed to be between 2 and 36, inclusive. **Output**: - An integer representing the number in base 10. **Example**: ```python base_to_int_changesafe(\'101\', 2) -> 5 base_to_int_changesafe(\'F\', 16) -> 15 base_to_int_changesafe(\'-FF\', 16) -> -255 base_to_int_changesafe(\'0\', 8) -> 0 ``` Constraints: - The input integer for `int_to_base_changesafe` is a valid integer. - The input string for `base_to_int_changesafe` will only contain valid characters for the specified base. Additional Requirements: 1. Handle negative numbers appropriately in both functions. 2. Ensure that returning the number \'-0\' (negative zero) is converted to \'0\' instead. 3. Efficiently handle large inputs without significant performance degradation. Implement the two functions with the necessary checks and edge case handling: ```python def int_to_base_changesafe(num, base): # Your implementation here pass def base_to_int_changesafe(str_to_convert, base): # Your implementation here pass ```","solution":"def int_to_base_changesafe(num, base): Converts an integer from base 10 to a specified base (between 2 and 36). if num == 0: return \\"0\\" digits = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" sign = \'\' if num < 0: sign = \'-\' num = -num result = \'\' while num > 0: result = digits[num % base] + result num = num // base return sign + result def base_to_int_changesafe(str_to_convert, base): Converts a string representing a number in a specified base (between 2 and 36) back to base 10. str_to_convert = str_to_convert.upper() digits = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" value_dict = {digits[i]: i for i in range(base)} sign = -1 if str_to_convert[0] == \'-\' else 1 if sign == -1: str_to_convert = str_to_convert[1:] value = 0 for char in str_to_convert: value = value * base + value_dict[char] return sign * value"},{"question":"You are given two strings containing lowercase English alphabets. Write a function that computes the length of their Longest Common Subsequence (LCS). # Function Signature ```python def longest_common_subsequence(s1: str, s2: str) -> int: ``` # Input - `s1`: A string composed of lowercase English letters (1 ≤ |s1| ≤ 1000) - `s2`: A string composed of lowercase English letters (1 ≤ |s2| ≤ 1000) # Output - Returns an integer representing the length of the LCS of the given strings. # Constraints - Both input strings will be of lengths between 1 and 1000 inclusive. # Example **Input:** ```python s1 = \\"abcdgh\\" s2 = \\"aedfhr\\" ``` **Output:** ```python 3 ``` **Explanation:** The longest subsequence that is common to both strings is \\"adh\\" which has length 3. **Note**: - The function must run within the time complexity of (O(M times N)) where M and N are the lengths of the input strings. - You need to manage the matrix appropriately to avoid excessive space usage. # Scenario Consider you are working on a text comparison tool where you need to determine how similar two strings are. One way to measure this similarity is by computing the length of their longest common subsequence. This will help in establishing the extent of similarity between versions of a document.","solution":"def longest_common_subsequence(s1: str, s2: str) -> int: Returns the length of the longest common subsequence of s1 and s2. m, n = len(s1), len(s2) # Creating a 2D DP array to store lengths of longest common subsequences. dp = [[0] * (n + 1) for _ in range(m + 1)] # Building the dp array from bottom up for i in range(1, m + 1): for j in range(1, n + 1): if s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[m][n]"},{"question":"# Robber\'s Dilemma: Maximum Loot Calculation You are aiding a professional burglar who plans to rob houses along a street. Each house has a certain amount of money stashed. However, stealing from any two consecutive houses will trigger an alarm that contacts the police. Given a list of non-negative integers representing the amount of money at each house, your task is to write a function that determines the maximum amount of money that can be robbed without triggering the police. Input: - A list of non-negative integers `houses` where each integer represents the amount of money stashed in a house. The list can be empty. Output: - A single integer representing the maximum amount of money that can be robbed. Constraints: - All elements in the list are non-negative integers. - The length of the list does not exceed 100,000. # Example ```python # Example 1 houses = [2, 3, 2] # Output: 3 # Explanation: Rob house 1 (money = 2) and do not rob house 2. # Then rob house 3 (money = 2). # Example 2 houses = [1, 2, 3, 1] # Output: 4 # Explanation: Rob house 1 (money = 1), do not rob house 2, and rob house 3 (money = 3). # Example 3 houses = [] # Output: 0 # Explanation: No houses, hence no money to rob. ``` Function Signature ```python def house_robber(houses: List[int]) -> int: # your code here ``` # Additional Notes - Consider all edge cases, such as when the list is empty or contains only one house. - Ensure the solution is efficient with a time complexity of O(n) and space complexity of O(1).","solution":"from typing import List def house_robber(houses: List[int]) -> int: if not houses: return 0 elif len(houses) == 1: return houses[0] previous_two = houses[0] previous_one = max(houses[0], houses[1]) for i in range(2, len(houses)): current = max(previous_one, previous_two + houses[i]) previous_two = previous_one previous_one = current return previous_one"},{"question":"You are tasked to implement a `DictionaryTrie` data structure that supports the following functionalities: 1. `insert(word)`: Inserts a word into the trie. 2. `search(word)`: Returns true if the word is in the trie. 3. `starts_with(prefix)`: Returns true if there is any word in the trie that starts with the given prefix. 4. `delete(word)`: Removes a word from the trie. **Constraints:** - All inputs are lowercase alphabets (\'a\' - \'z\'). - The trie should handle a large number of words efficiently. - You should ensure that the delete operation does not leave orphan nodes in the trie and the overall structure remains compact. # Function Specification ```python class DictionaryTrie: def __init__(self): # Initialize your data structure here. def insert(self, word: str) -> None: # Insert word into the trie. def search(self, word: str) -> bool: # Search for the word in the trie; return True if found, False otherwise. def starts_with(self, prefix: str) -> bool: # Return True if there is any word in the trie that starts with the given prefix. def delete(self, word: str) -> None: # Remove the word from the trie if it exists. ``` # Examples ```python # Example Usage trie = DictionaryTrie() # Insert words trie.insert(\\"apple\\") trie.insert(\\"app\\") trie.insert(\\"apply\\") # Search words print(trie.search(\\"apple\\")) # True print(trie.search(\\"app\\")) # True print(trie.search(\\"appl\\")) # False # Check prefixes print(trie.starts_with(\\"app\\")) # True print(trie.starts_with(\\"apl\\")) # False # Delete words trie.delete(\\"apple\\") print(trie.search(\\"apple\\")) # False print(trie.search(\\"app\\")) # True ``` # Constraints 1. `1 <= word.length, prefix.length <= 2000` 2. The total number of words inserted will not exceed `10^5`. # Notes - Make sure your implementation handles all specified operations efficiently. - Consider edge cases such as attempting to delete a word that doesn\'t exist.","solution":"class TrieNode: def __init__(self): self.children = {} self.end_of_word = False class DictionaryTrie: def __init__(self): self.root = TrieNode() def insert(self, word: str) -> None: current = self.root for char in word: if char not in current.children: current.children[char] = TrieNode() current = current.children[char] current.end_of_word = True def search(self, word: str) -> bool: current = self.root for char in word: if char not in current.children: return False current = current.children[char] return current.end_of_word def starts_with(self, prefix: str) -> bool: current = self.root for char in prefix: if char not in current.children: return False current = current.children[char] return True def delete(self, word: str) -> None: def _delete(node, word, depth): if depth == len(word): # Node is end of word, mark it as not end and return True if no children if not node.children: return True node.end_of_word = False return False char = word[depth] if char in node.children and _delete(node.children[char], word, depth + 1): # Delete the node if it has no children and is not end of word del node.children[char] return not node.end_of_word and not node.children return False # Call inner recursive function starting with root and depth 0 _delete(self.root, word, 0)"},{"question":"Context In a digit-based data processing system, it is essential to frequently determine the number of digits in given integers efficiently. Understanding the underlying mechanics of how digit counting algorithms work is fundamental for such systems. Problem Statement Write a Python function `num_digits(n: int) -> int` that returns the number of digits in the integer `n`. Your function should be efficient, leveraging logarithmic properties, and should handle edge cases like zero and negative numbers properly. Expected Input and Output Formats * **Input**: A single integer `n`, where `-10^18 <= n <= 10^18`. * **Output**: An integer representing the number of digits in `n`. Constraints - Input will always be a valid integer. - Ensure the function operates within O(1) time complexity. - Minimize the use of any additional space. Edge Cases to Consider - The input number `n` could be zero, positive or negative. - Pay attention to how negative signs do not contribute to the digit count. Function Signature ```python def num_digits(n: int) -> int: # your code here ``` Example ```python assert num_digits(0) == 1 assert num_digits(12345) == 5 assert num_digits(-98765) == 5 assert num_digits(1000000000000000000) == 19 assert num_digits(-1000000000000000000) == 19 ``` Using these examples, write a solution that adheres to the given problem constraints and meets performance requirements.","solution":"import math def num_digits(n: int) -> int: Returns the number of digits in the integer n. Handles zero, positive and negative numbers. if n == 0: return 1 return int(math.log10(abs(n))) + 1"},{"question":"# Problem: Two-Way Heap Sort You are tasked with implementing a dual-function sorting algorithm that can sort an array using both a max heap and a min heap depending on a given parameter. This algorithm should maintain in-place sorting and conform to O(n log n) time complexity. Your goal is to write a function that can switch between max heap and min heap sorting based on the choice specified. Function Signature: ```python def two_way_heap_sort(arr: List[int], mode: str, simulation: bool=False) -> List[int] ``` Input: - `arr`: A list of integers `arr[0]...arr[n-1]` where `0 <= n <= 10^5`. - `mode`: A string that can either be `\\"max\\"` or `\\"min\\"` indicating which heap sort to apply. - `simulation`: A boolean parameter (default=False). If set to True, the function should print out the current state of the array being sorted after each iteration. Output: - Returns a list of integers sorted in ascending order using the specified heap sort method. Requirements: 1. Your code must work for any valid input list and enforce the heap properties correctly. 2. The function must be complete and should not mutably alter the input list beyond sorting. 3. Your implementation should handle edge cases like empty arrays or arrays with one element gracefully. 4. Your function should handle large inputs efficiently, without exceeding the given time complexity. Constraints - Array elements can be negative, zero, or positive. - The `mode` parameter will always be `\\"max\\"` or `\\"min\\"`. Example ```python assert(two_way_heap_sort([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5], \\"max\\") == [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9]) assert(two_way_heap_sort([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5], \\"min\\") == [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9]) ```","solution":"import heapq from typing import List def two_way_heap_sort(arr: List[int], mode: str, simulation: bool=False) -> List[int]: Sorts the array using max heap or min heap depending on the mode. :param arr: List of integers to sort. :param mode: String indicating \\"max\\" or \\"min\\". :param simulation: Boolean indicating whether to print the array at each iteration. :return: Sorted list of integers. n = len(arr) if n <= 1: return arr.copy() if mode == \\"max\\": # Create a max heap by storing negative values arr = [-a for a in arr] heapq.heapify(arr) sorted_arr = [] for _ in range(n): max_val = -heapq.heappop(arr) sorted_arr.append(max_val) if simulation: print(sorted_arr) sorted_arr.reverse() return sorted_arr elif mode == \\"min\\": heapq.heapify(arr) sorted_arr = [] for _ in range(n): min_val = heapq.heappop(arr) sorted_arr.append(min_val) if simulation: print(sorted_arr) return sorted_arr else: raise ValueError(\\"Mode must be \'max\' or \'min\'\\")"},{"question":"Task You are asked to implement a `full_path` utility function that takes a file path string as input and returns its absolute path, resolving any user directory notations (`~`). Input * A string `file` representing a file path. This path can be relative, absolute, or contain user directory notation (`~`). Output * A string representing the absolute path of the input file. Constraints * The input path string will have a maximum length of 1,000 characters. * You can assume that the file path does not contain any invalid characters and will be a valid path string appropriate for the operating system in a typical use case. Performance Requirements * The function should complete in O(n) time complexity, where n is the length of the file path string. * The function should use at most O(n) space complexity for intermediate storage. Example ```python full_path(\\"~/.bashrc\\") # might return something like \\"/home/user/.bashrc\\" on a Unix system or \\"C:UsersUser.bashrc\\" on a Windows system. full_path(\\"documents/file.txt\\") # might return something like \\"/home/user/documents/file.txt\\" on a Unix system or \\"C:UsersUserdocumentsfile.txt\\" on a Windows system. full_path(\\"/var/log/syslog\\") # should return \\"/var/log/syslog\\" on a Unix system as it\'s already an absolute path. ``` Implementation You are provided with a basic function signature. Implement the function `full_path`. ```python import os def full_path(file): Given a file path string, return its absolute path with user paths resolved. Args: file (str): The file path to be converted to an absolute path. Returns: str: The absolute path of the given file. pass ```","solution":"import os def full_path(file): Given a file path string, return its absolute path with user paths resolved. Args: file (str): The file path to be converted to an absolute path. Returns: str: The absolute path of the given file. return os.path.abspath(os.path.expanduser(file))"},{"question":"# Bucket Sort Implementation and Optimization You are tasked with enhancing a Bucket Sort algorithm for sorting integer arrays efficiently. This task will help test your understanding of sorting algorithms, time complexity management, and optimization techniques. **Context**: The traditional Bucket Sort can be inefficient if the elements are not uniformly distributed across the buckets. Therefore, optimize the sorting within the buckets to handle possible bottlenecks. Specifically, you are to replace Insertion Sort with an optimization that improves sorting efficiency. # Requirements 1. Implement a function `bucket_sort_optimized` that optimizes the sorting within each bucket. 2. Test the function using multiple test cases including edge cases. **Function Signature**: ```python def bucket_sort_optimized(arr: List[int]) -> List[int]: ``` **Input**: - `arr`: A list of `n` non-negative integers. **Output**: - The sorted list of integers. **Constraints**: - `n` is in the range `[1, 10^5]` - Each element in `arr` is in the range `[0, 10^8]` **Performance Requirements**: - Optimize to handle uneven distributions more efficiently. - Consider both time complexity and space optimization. # Example ```python # Considering the previous bucket_sort example, the optimized function should be able to handle: arr = [29, 25, 3, 49, 9, 37, 21, 43] print(bucket_sort_optimized(arr)) # [3, 9, 21, 25, 29, 37, 43, 49] ``` **Hint**: Consider using a different sorting algorithm within each bucket for better efficiency than the traditional Insertion Sort. # Notes * You can use Python\'s built-in sort for sorting the buckets. * Ensure that your code is readable and well-documented. * Assume that the list `arr` will not contain negative numbers.","solution":"from typing import List def bucket_sort_optimized(arr: List[int]) -> List[int]: if not arr: return [] # Determine the number of buckets num_buckets = len(arr) max_value = max(arr) # Create buckets buckets = [[] for _ in range(num_buckets)] # Distribute elements into buckets for num in arr: index = (num * num_buckets) // (max_value + 1) buckets[index].append(num) # Sort each bucket individually using built-in sort for optimal performance sorted_arr = [] for bucket in buckets: sorted_arr.extend(sorted(bucket)) return sorted_arr"},{"question":"# Password Strength Improvement Louise is trying to create a new account on a secure platform. She needs to ensure that her password is strong enough to pass the following security constraints: 1. The password must be at least 6 characters long. 2. It must contain at least one digit. 3. It must contain at least one lowercase English character. 4. It must contain at least one uppercase English character. 5. It must contain at least one special character from the set `!@#%^&*()-+`. Louise has typed a random string as her password but is unsure if it meets these criteria. Your task is to find out the minimum number of characters she must add to make her password strong. # Input Format - The first line contains an integer `n` denoting the length of the string. - The second line contains a string of length `n`, which is the password typed by Louise. Each character in the password is either a lowercase/uppercase English alphabet, a digit, or a special character. # Output Format - Output a single integer: the minimum number of characters that must be added to the password to make it strong. # Constraints 1. `1 <= n <= 100` # Examples **Example 1:** ```plaintext Input: 3 Ab1 Output: 3 Explanation: The password \\"Ab1\\" is only 3 characters long, so it needs at least 3 more characters to satisfy the length requirement (6 characters minimum). The 3 characters added should include one lowercase, one uppercase, and one special character to form a strong password. ``` **Example 2:** ```plaintext Input: 11 #Algorithms Output: 1 Explanation: The password \\"#Algorithms\\" is missing a digit. Adding any digit will make the password strong. ``` # Function Signature ```python def strong_password(n: int, password: str) -> int: pass ``` Implement the function `strong_password` to solve the problem described above.","solution":"def strong_password(n: int, password: str) -> int: This function calculates and returns the minimum number of characters that need to be added to the given password to make it strong according to the following criteria: 1. At least 6 characters long. 2. Contain at least one digit. 3. Contain at least one lowercase English character. 4. Contain at least one uppercase English character. 5. Contain at least one special character from the set !@#%^&*()-+ # Define the set of special characters special_characters = set(\\"!@#%^&*()-+\\") # Flags to check which character types are present has_digit = False has_lower = False has_upper = False has_special = False # Check the current password for each type of character for char in password: if char.isdigit(): has_digit = True elif char.islower(): has_lower = True elif char.isupper(): has_upper = True elif char in special_characters: has_special = True # Calculate how many types of characters are missing missing_types = sum([not has_digit, not has_lower, not has_upper, not has_special]) # Calculate how many characters are needed to meet the length requirement length_requirement = max(0, 6 - n) # The number of characters needed will be the maximum of types missing and length requirement return max(missing_types, length_requirement)"},{"question":"Given an array `S` of integers, write a function `three_sum` that finds all unique triplets in the array which sum to zero. The solution set must not contain duplicate triplets. # Function Signature ```python def three_sum(array: List[int]) -> Set[ Tuple[int, int, int] ]: ``` # Input - `array`: A list of integers. # Output - A set of tuples, where each tuple consists of three integers that form a triplet summing to zero. # Constraints - The length of the array will be between 0 and 10^4. - Each element in the array falls between -10^5 and 10^5. # Performance Requirements - The algorithm should run in (O(n^2)) time complexity. # Example ```python array = [-1, 0, 1, 2, -1, -4] print(three_sum(array)) # Output: {(-1, 0, 1), (-1, -1, 2)} ``` # Notes - Ensure the solution set does not contain duplicate triplets. - Handle edge cases such as arrays with fewer than three elements appropriately. # Scenario You\'re tasked with developing a function for a financial analytics platform to detect balanced trip options from an array of credit balances (positive and negative) such that the net change is zero. This helps in auditing and balancing accounts without redundancy.","solution":"from typing import List, Set, Tuple def three_sum(array: List[int]) -> Set[Tuple[int, int, int]]: Given an array of integers, find all unique triplets that sum to zero. :param array: List[int] - The input array of integers :return: Set[Tuple[int, int, int]] - A set of unique triplets that sum to zero res = set() array.sort() n = len(array) for i in range(n): if i > 0 and array[i] == array[i - 1]: continue left, right = i + 1, n - 1 while left < right: current_sum = array[i] + array[left] + array[right] if current_sum == 0: res.add((array[i], array[left], array[right])) left += 1 right -= 1 while left < right and array[left] == array[left - 1]: left += 1 while left < right and array[right] == array[right + 1]: right -= 1 elif current_sum < 0: left += 1 else: right -= 1 return res"},{"question":"Problem: Implement Enhanced Radix Sort with Support for Negative Numbers # Scenario You have been contracted by a software company to improve their sorting functionality within their data processing pipeline. The company\'s data consists of integers that could be either positive or negative, and their current system does not efficiently handle these variations. Your task is to modify the existing radix sort algorithm to extend its support to arrays containing negative numbers as well. # Requirements 1. **Input**: * A list `arr` consisting of n integers where n ranges from 1 to 1000. * Each integer can range from -10^6 to 10^6. 2. **Output**: * A sorted list of integers in non-descending order. # Constraints * Assume integers fit within the range of typical 32-bit signed integers. * Your solution should retain the non-comparative nature of radix sort. * Optimize for time and space wherever possible, with a focus on maintaining stability. # Edge Cases and Examples: 1. For `arr = [170, 45, 75, -90, -802, 24, 2, 66]`, the output should be `[-802, -90, 2, 24, 45, 66, 75, 170]`. 2. For `arr = [-5, -10, 0, -3, 8, 5, 4, -1]`, the output should be `[-10, -5, -3, -1, 0, 4, 5, 8]`. 3. For `arr = [3, 3, 3, 3, 3]`, the output should be `[3, 3, 3, 3, 3]`. # Performance: * Your implementation should aim for O(nk) time complexity. * Space complexity should be kept within reasonable limits given the constraints. # Instructions: Implement the function `enhanced_radix_sort(arr)` that meets the requirements above. ```python def enhanced_radix_sort(arr): # your implementation here ```","solution":"def counting_sort(arr, exp): n = len(arr) output = [0] * n # output array that will have sorted arr count = [0] * 10 # count array to store count of occurrences # Store count of occurrences in count[] for i in range(n): index = abs(arr[i]) // exp count[index % 10] += 1 # Change count[i] so that count[i] now contains actual # position of this digit in output[] for i in range(1, 10): count[i] += count[i - 1] # Build the output array for i in range(n - 1, -1, -1): index = abs(arr[i]) // exp output[count[index % 10] - 1] = arr[i] count[index % 10] -= 1 # Copy the output array to arr[], so that arr now # contains sorted numbers according to current digit for i in range(n): arr[i] = output[i] def radix_sort_non_negative(arr): max1 = max(arr) exp = 1 while max1 // exp > 0: counting_sort(arr, exp) exp *= 10 def enhanced_radix_sort(arr): if len(arr) == 0: return arr # Separate positive and negative numbers negatives = [] non_negatives = [] for num in arr: if num < 0: negatives.append(-num) # Work with positive equivalent for now else: non_negatives.append(num) # Sort the non-negative numbers using radix sort if non_negatives: radix_sort_non_negative(non_negatives) # Sort the negative numbers using radix sort if negatives: radix_sort_non_negative(negatives) negatives = [-num for num in reversed(negatives)] # Restore negative signs and order # Merge the two lists return negatives + non_negatives"},{"question":"You are tasked with finding the next higher number with the same set of digits as the given number. Write a function `next_bigger(num)` that takes a positive integer as input and returns the next higher number that uses the same digits, or `-1` if no such number exists. # Example: ``` Input: 38276 Output: 38627 Input: 99999 Output: -1 ``` # Constraints: - The input number will be a positive integer within the range of a typical 32-bit integer. - You must handle all edge cases, such as numbers with all identical digits or single-digit numbers. # Requirements: 1. Your function should correctly identify and return the next permutation based on the given digits. 2. Optimize your solution for both time and space complexities within reasonable limits. 3. Handle erroneous cases gracefully and return `-1` when necessary. # Input and Output Format: - **Input**: A single integer `num`. - **Output**: An integer representing the next higher permutation or `-1` if no such number exists. # Implementation: ```python def next_bigger(num): digits = [int(i) for i in str(num)] idx = len(digits) - 1 while idx >= 1 and digits[idx-1] >= digits[idx]: idx -= 1 if idx == 0: return -1 pivot = digits[idx-1] swap_idx = len(digits) - 1 while pivot >= digits[swap_idx]: swap_idx -= 1 digits[swap_idx], digits[idx-1] = digits[idx-1], digits[swap_idx] digits[idx:] = digits[:idx-1:-1] return int(\'\'.join(str(x) for x in digits)) # Example Usage print(next_bigger(38276)) # Output: 38627 print(next_bigger(99999)) # Output: -1 ```","solution":"def next_bigger(num): digits = [int(i) for i in str(num)] idx = len(digits) - 1 while idx >= 1 and digits[idx-1] >= digits[idx]: idx -= 1 if idx == 0: return -1 pivot = digits[idx-1] swap_idx = len(digits) - 1 while pivot >= digits[swap_idx]: swap_idx -= 1 digits[swap_idx], digits[idx-1] = digits[idx-1], digits[swap_idx] digits[idx:] = digits[:idx-1:-1] return int(\'\'.join(str(x) for x in digits))"},{"question":"# Sorting Challenge: Cocktail Shaker Sort Implementation You have been provided with an algorithm called Cocktail Shaker Sort, which is a variation of the classic Bubble Sort algorithm. Your task is to implement this sorting algorithm. Problem Statement Given an array of integers, use the Cocktail Shaker Sort algorithm to sort the array in ascending order. Write a function `cocktail_shaker_sort(arr)` that takes in an array `arr` and returns a new sorted array. Constraints - The input array can have a maximum size of 1000. - The elements of the array are integers in the range of -10^6 to 10^6. Input Format - A list of integers `arr`. Output Format - A new list of integers sorted in ascending order. Example Input: ```python arr = [5, 3, 4, 2, 1] ``` Output: ```python [1, 2, 3, 4, 5] ``` Input: ```python arr = [10, -1, 3, -5, 0] ``` Output: ```python [-5, -1, 0, 3, 10] ``` Notes: - Ensure that your implementation handles the edge cases such as an empty array, a single-element array, and arrays that are already sorted. - Make sure to consider both time and space complexities in your implementation. - Test your function thoroughly to ensure correctness.","solution":"def cocktail_shaker_sort(arr): Sorts an array using the Cocktail Shaker Sort algorithm. n = len(arr) if n <= 1: return arr start = 0 end = n - 1 while start <= end: swapped = False # Traverse from left to right for i in range(start, end): if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] swapped = True # Break if no elements were swapped, indicating the array is sorted if not swapped: break # Move the end point back by one because the last element is already sorted end -= 1 # Reset swapped to False for the next phase swapped = False # Traverse from right to left for i in range(end, start, -1): if arr[i] < arr[i - 1]: arr[i], arr[i - 1] = arr[i - 1], arr[i] swapped = True # Break if no elements were swapped, indicating the array is sorted if not swapped: break # Move the start point forward by one because the first element is already sorted start += 1 return arr"},{"question":"# Question You are given two functions, `serialize` and `deserialize`, for a binary tree. Objective: Implement a method to determine if two binary trees are identical using these functions. Instructions: 1. Write a function `are_trees_identical(tree1, tree2)` that takes the serialized result of two binary trees and returns `True` if they are identical and `False` otherwise. 2. Assume that the provided `TreeNode` class and serialization/deserialization functions (`serialize` and `deserialize`) are used for tree manipulation. 3. The function `are_trees_identical` should first deserialize the serialized input strings to reconstruct the trees, then compare the structures and values of the two trees. Expected Function Definition: ```python def are_trees_identical(serialized_tree1: str, serialized_tree2: str) -> bool: # Your solution here ``` Constraints: - Both `serialized_tree1` and `serialized_tree2` are non-empty strings containing the serialized form of the trees. Example: Suppose the serialized representation of the trees are as follows: - serialized_tree1 = \\"1 2 # # 3 # #\\" - serialized_tree2 = \\"1 2 # # 3 # #\\" Then the function `are_trees_identical` should return `True`. Similarly, - serialized_tree1 = \\"1 2 # # 3 # #\\" - serialized_tree2 = \\"1 2 # # 4 # #\\" Then the function `are_trees_identical` should return `False`. Performance Requirements: - The solution should efficiently handle binary trees with a large number of nodes.","solution":"# Assuming the TreeNode class and serialization/deserialization functions are defined as follows: class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def serialize(root): def helper(node): if not node: return \\"#\\" left_serialized = helper(node.left) right_serialized = helper(node.right) return f\\"{node.val} {left_serialized} {right_serialized}\\" return helper(root) def deserialize(data): def helper(nodes): value = next(nodes) if value == \\"#\\": return None node = TreeNode(int(value)) node.left = helper(nodes) node.right = helper(nodes) return node node_iter = iter(data.split()) return helper(node_iter) def are_trees_identical(serialized_tree1, serialized_tree2): def is_identical(node1, node2): if not node1 and not node2: return True if node1 and node2 and node1.val == node2.val: return is_identical(node1.left, node2.left) and is_identical(node1.right, node2.right) return False tree1 = deserialize(serialized_tree1) tree2 = deserialize(serialized_tree2) return is_identical(tree1, tree2)"},{"question":"Implement a Sorted Doubly Linked List Design and implement a doubly linked list that maintains its elements in sorted order. Your implementation should support the following operations: - **insert(value)**: Inserts a new value into the list maintaining the sorted order. - **delete(value)**: Deletes the first occurrence of a value from the list. - **find(value)**: Returns a boolean indicating whether the value exists in the list. - **print_list()**: Prints the elements of the list in the order from head to tail. # Input and Output Formats - **insert(value)**: Inserts an integer value into the doubly linked list. - **delete(value)**: Deletes an integer value from the doubly linked list, if it exists. - **find(value)**: Returns `True` if the value exists, `False` otherwise. - **print_list()**: Prints the current state of the list. # Constraints - All values are integers. - Values can appear multiple times. - Assume the initial list is empty. - Aim for a balance between clarity (maintaining sortedness) and performance. # Example ```python dll = SortedDoublyLinkedList() dll.insert(10) dll.insert(5) dll.insert(15) dll.insert(5) dll.print_list() # Output: 5 5 10 15 dll.delete(10) dll.print_list() # Output: 5 5 15 print(dll.find(15)) # Output: True print(dll.find(20)) # Output: False ```","solution":"class Node: def __init__(self, value): self.value = value self.prev = None self.next = None class SortedDoublyLinkedList: def __init__(self): self.head = None self.tail = None def insert(self, value): new_node = Node(value) if not self.head: # Empty list self.head = new_node self.tail = new_node else: current = self.head prev = None while current and current.value < value: prev = current current = current.next if not prev: # Insert at head new_node.next = self.head self.head.prev = new_node self.head = new_node else: prev.next = new_node new_node.prev = prev if current: new_node.next = current current.prev = new_node else: # Insert at tail self.tail = new_node def delete(self, value): current = self.head while current: if current.value == value: if current.prev: # Not head current.prev.next = current.next else: # Head self.head = current.next if current.next: # Not tail current.next.prev = current.prev else: # Tail self.tail = current.prev return current = current.next def find(self, value): current = self.head while current: if current.value == value: return True current = current.next return False def print_list(self): current = self.head while current: print(current.value, end=\' \') current = current.next print()"},{"question":"# Problem You are tasked with implementing a function that determines the number of digits in a given integer. To assess your understanding of logarithms and number properties, you will use the `math.log10()` function for this task. # Function Signature ```python def count_digits(n: int) -> int: pass ``` # Input - An integer `n` where `-10^18 ≤ n ≤ 10^18` # Output - Return the number of digits in the integer `n`. # Examples ```python assert count_digits(12345) == 5 assert count_digits(-12345) == 5 assert count_digits(0) == 1 assert count_digits(1000000000) == 10 ``` # Constraints - You must use the `math.log10()` function to compute the number of digits. - Handle negative numbers by taking their absolute value. - Ensure your solution executes in constant time, O(1). # Scenario Consider you are developing a user interface that ensures the numeric identifier for users doesn\'t exceed a certain number of digits. Your function will verify the number of digits quickly to enforce this validation. # Guidelines 1. Handle edge cases like when `n` is zero. 2. Make sure to take the absolute value for negative numbers before computing `log10`.","solution":"import math def count_digits(n: int) -> int: Returns the number of digits in the integer n using math.log10. Args: n (int): The integer whose digits are to be counted. Returns: int: The number of digits in the integer n. if n == 0: return 1 return int(math.log10(abs(n))) + 1"},{"question":"You are required to implement a data structure for simulating an automated event scheduling system using a queue. The queue should support basic operations, including the ability to prioritize certain events by placing them at the front. **Task**: Your task is to create a `PriorityQueue` class that extends the basic queue operations with an extra method to prioritize an item. You should handle memory efficiently and ensure that the operations respect queue properties. Class Definition * **PriorityQueue()**: Initialize your queue object. * **enqueue(item)**: Adds a new item to the rear of the queue. * **dequeue()**: Removes the front item from the queue. * **priority_enqueue(item)**: Adds a new item to the front of the queue. * **is_empty()**: Tests to see whether the queue is empty and returns a boolean value. * **size()**: Returns the number of items in the queue. * **peek()**: Returns the front element of the queue without removing it. Input Output Format ```python class PriorityQueue: def __init__(self): pass def enqueue(self, item): pass def dequeue(self): pass def priority_enqueue(self, item): pass def is_empty(self): pass def size(self): pass def peek(self): pass ``` * **enqueue(item)**: * Input: item (any data type) * Output: None * **dequeue()**: * Input: None * Output: item (whatever type was enqueued) * **priority_enqueue(item)**: * Input: item (any data type) * Output: None * **is_empty()**: * Input: None * Output: Boolean (True if empty, False otherwise) * **size()**: * Input: None * Output: Integer (number of items in the queue) * **peek()**: * Input: None * Output: item (whatever type was enqueued) Constraints * All operations should have an optimal time complexity regarding queue behavior. * Handle edge cases such as operations on an empty queue appropriately. * Consider memory optimization for handling multiple elements. Example ```python pq = PriorityQueue() pq.enqueue(1) pq.enqueue(2) pq.priority_enqueue(3) assert pq.size() == 3 assert pq.peek() == 3 assert pq.dequeue() == 3 assert pq.dequeue() == 1 assert pq.is_empty() is False assert pq.dequeue() == 2 assert pq.is_empty() is True ```","solution":"class PriorityQueue: def __init__(self): self.queue = [] def enqueue(self, item): self.queue.append(item) def dequeue(self): if self.is_empty(): return None return self.queue.pop(0) def priority_enqueue(self, item): self.queue.insert(0, item) def is_empty(self): return len(self.queue) == 0 def size(self): return len(self.queue) def peek(self): if self.is_empty(): return None return self.queue[0]"},{"question":"Efficient Minimum Removal from a Stack **Objective**: Implement a function that removes the smallest element from a given stack and optimizes memory usage wherever possible. **Background**: You are given a stack of integers which you need to modify by removing the smallest element. The stack operates under the Last-In-First-Out (LIFO) principle. Ensure your function can handle cases where the stack is empty or contains multiple elements of the same value. **Function Signature**: ```python def remove_min_optimized(stack: list) -> list: pass ``` **Input**: * A list `stack` representing the stack. Example: `[2, 8, 3, -6, 7, 3]` **Output**: * The stack list after removing the smallest element. **Constraints**: * The input stack will not exceed 10^4 elements. * Stack elements are integers and can range from -10^9 to 10^9. **Example**: ```python # Example 1: stack = [2, 8, 3, -6, 7, 3] print(remove_min_optimized(stack)) # Output: [2, 8, 3, 7, 3] # Example 2: stack = [] print(remove_min_optimized(stack)) # Output: [] ``` **Scenario**: Consider a scenario where you are managing a dynamic list of priorities for tasks. Each task is assigned a priority level, and priorities are maintained in a stack due to the nature of task insertion and processing. If a low-priority task (minimum value) is canceled, you need to ensure it is removed, while maintaining the order of insertion and the priority list structure.","solution":"def remove_min_optimized(stack: list) -> list: Removes the smallest element from the given stack. :param stack: List of integers representing the stack. :return: Modified stack list after removing the smallest element. if not stack: return stack min_element = min(stack) stack.remove(min_element) return stack"},{"question":"**Context**: You are tasked with organizing a warehouse where products are categorized into three types: `A`, `B`, and `C`. To efficiently store and retrieve products based on their type, you need to arrange them such that all products of the same type are contiguous, and follow the order `A`, `B`, `C`. **Problem Statement**: You are given an array of n elements, where each element can be `0`, `1`, or `2`, representing product types `A`, `B`, and `C`, respectively. Write a function `sort_products(products)` that sorts the array so that all `0s` appear before `1s`, which appear before `2s`. **Function Signature**: ```python def sort_products(products: List[int]) -> None: Modify the list \'products\' in-place to sort it such that all 0s (Type A) come before all 1s (Type B), which come before all 2s (Type C). ``` # Input and Output Formats * **Input**: A list of integers (`products`) of length `n` where each value can be either `0`, `1`, or `2`. * **Output**: The function should modify the input list in place and should not return anything. # Constraints * The function should not use any built-in sorting functions or libraries. * The sorting should be performed with O(n) time complexity and O(1) additional space complexity. # Example ```python products = [2, 0, 2, 1, 1, 0] sort_products(products) print(products) # Output: [0, 0, 1, 1, 2, 2] ``` # Edge Cases 1. An empty array: `[]` 2. An array with a single element: `[0]`, `[1]`, or `[2]` 3. An array where all elements are the same type: `[0, 0, 0]`, `[1, 1, 1]`, `[2, 2, 2]` # Performance Requirements * Time Complexity: O(n) * Space Complexity: O(1) Make sure your solution efficiently handles all edge cases and satisfies the performance requirements.","solution":"def sort_products(products): Modify the list \'products\' in-place to sort it such that all 0s (Type A) come before all 1s (Type B), which come before all 2s (Type C). low, mid, high = 0, 0, len(products) - 1 while mid <= high: if products[mid] == 0: products[low], products[mid] = products[mid], products[low] low += 1 mid += 1 elif products[mid] == 1: mid += 1 else: products[mid], products[high] = products[high], products[mid] high -= 1"},{"question":"# Pigeonhole Sort Implementation You have been hired by a software development company that specializes in processing large volumes of integer data. One of the tasks at hand requires sorting lists of integers efficiently. However, the lists they deal with often have a relatively small range of key values compared to the number of elements. Your task is to implement the Pigeonhole Sort algorithm, which is suitable for this type of problem. Write a function `pigeonhole_sort` in Python that takes a list of integers and returns a sorted list. Function Signature ```python def pigeonhole_sort(arr: List[int]) -> List[int]: ``` Input * `arr` (List[int]): A list of integers that need to be sorted. Output * Returns a sorted list of integers. Constraints * Each integer in the list can be in the range from -1000 to 1000. * The length of the list `n` is such that `1 <= n <= 10^5`. Example ```python assert pigeonhole_sort([8, 3, 2, 3, 8, 7, 1]) == [1, 2, 3, 3, 7, 8, 8] assert pigeonhole_sort([-5, 0, -2, 3, 2, -8]) == [-8, -5, -2, 0, 2, 3] ``` Requirements - The function should handle edge cases gracefully, such as an empty list or a list with a single element. - Ensure that the solution is efficient in terms of both time and space complexity, taking into account the constraints provided. - Add appropriate error handling and optimization where necessary. Good luck!","solution":"from typing import List def pigeonhole_sort(arr: List[int]) -> List[int]: if not arr: return [] # Find minimum and maximum values in the array mn = min(arr) mx = max(arr) # The size of the pigeonholes pigeonhole_range = mx - mn + 1 # Initialize pigeonholes pigeonholes = [0] * pigeonhole_range # Populate the pigeonholes for num in arr: pigeonholes[num - mn] += 1 # Now, create the sorted array sorted_arr = [] for i in range(pigeonhole_range): while pigeonholes[i] > 0: sorted_arr.append(i + mn) pigeonholes[i] -= 1 return sorted_arr"},{"question":"# Pancake Birthday Party Context You are organizing a birthday party and want to serve the pancakes in a neat, sorted stack based on their size. Given a stack of pancakes, your task is to sort them so that the smallest pancake is on top and the largest pancake is at the bottom using the pancake sort algorithm. Task Implement the `pancake_sort` function in Python to sort a list of integers representing the size of pancakes. Function Signature ```python def pancake_sort(arr: List[int]) -> List[int]: ``` Input * `arr`: A list of integers representing the sizes of pancakes. Output * Returns a sorted list of integers in ascending order using the pancake sort technique. Example ```python # Example 1 input: [3, 6, 1, 10, 2] output: [1, 2, 3, 6, 10] # Example 2 input: [4, 5, 3, 2, 1] output: [1, 2, 3, 4, 5] ``` Constraints * Do not use any built-in sort() function. * You may assume all pancake sizes are positive integers. * The maximum length of the pancake stack is 1000. Performance Requirements * The algorithm should be implemented with an overall time complexity of O(N^2). Edge Cases to Consider * An empty array should return an empty array. * A single-element array should return the same single element. * Arrays with duplicate sizes should correctly sort the duplicates. Use these constraints and information to correctly implement the pancake sort algorithm and submit your solution.","solution":"from typing import List def flip(arr: List[int], k: int) -> None: Reverses the order of the first k elements in arr. arr[:k] = arr[:k][::-1] def pancake_sort(arr: List[int]) -> List[int]: Sorts the given list of integers using the pancake sort technique. Parameters: arr (List[int]): A list of integers representing the sizes of pancakes. Returns: List[int]: A sorted list of integers in ascending order. n = len(arr) for size in range(n, 1, -1): # Find the index of the largest pancake we need to move to the correct position max_index = arr.index(max(arr[:size])) # Place the largest pancake at the beginning if it\'s not already there if max_index != 0: flip(arr, max_index + 1) # Move the largest pancake to its correct position flip(arr, size) return arr"},{"question":"Counting Connected Components in an Undirected Graph Given an undirected graph, write a function to count the number of connected components. The graph is represented by an adjacency list. Function Signature ```python def count_components(adjacency_list: List[List[int]], size: int) -> int: pass ``` Input - `adjacency_list` : A list of lists, where `adjacency_list[i]` contains the nodes adjacent to node `i`. - `size` : An integer representing the number of nodes in the graph. Output - An integer representing the number of connected components in the graph. Constraints - 1 ≤ size ≤ 10^4 - 0 ≤ edges ≤ 2 * 10^4 (total number of edges) Example ```python # Example 1: adjacency_list = [[], [2], [1, 4], [7], [2, 5], [4, 6], [5], [3]] size = 7 assert count_components(adjacency_list, size) == 2 # Example 2: adjacency_list = [[], [2], [1, 3], [2], [], [6], [5]] size = 6 assert count_components(adjacency_list, size) == 3 ``` # Scenario Assume you are working on a network analysis problem, where you have to find and report isolated sub-networks within a larger network. The network is provided as an undirected graph, where nodes represent devices and edges represent direct communication links between them. You need to determine the number of isolated sub-networks (connected components). Write an efficient function to identify and count these isolated sections, demonstrating your understanding of depth-first search (DFS) and graph traversal.","solution":"from typing import List def count_components(adjacency_list: List[List[int]], size: int) -> int: def dfs(node, visited): # Mark the current node as visited visited[node] = True # Visit all the adjacent nodes for neighbor in adjacency_list[node]: if not visited[neighbor]: dfs(neighbor, visited) visited = [False] * (size + 1) count = 0 for i in range(1, size + 1): if not visited[i]: dfs(i, visited) count += 1 return count # Example usage: # adjacency_list = [[], [2], [1, 4], [7], [2, 5], [4, 6], [5], [3]] # size = 7 # print(count_components(adjacency_list, size)) # Output: 2"},{"question":"As part of a geometric computations package, you are required to implement a function that uses the Pythagorean theorem to compute the length of the missing side of a right-angled triangle. The function will be provided with either the lengths of two sides or the length of one side and the hypotenuse. # Input The function will receive three arguments: 1. `opposite` (str or float): Length of the opposite side or \\"?\\" if unknown. 2. `adjacent` (str or float): Length of the adjacent side or \\"?\\" if unknown. 3. `hypotenuse` (str or float): Length of the hypotenuse side or \\"?\\" if unknown. # Output *Return*: The length of the missing side. - If the input includes a non-feasible triangle or invalid input, raise a `ValueError` with the message \\"Invalid input!\\". # Function Signature ```python def pythagoras(opposite, adjacent, hypotenuse): ``` # Example ```python # Example 1: print(pythagoras(\\"?\\", 3, 5)) # Output: \\"Opposite = 4.0\\" # Example 2: print(pythagoras(3, \\"?\\", 5)) # Output: \\"Adjacent = 4.0\\" # Example 3: print(pythagoras(3, 4, \\"?\\")) # Output: \\"Hypotenuse = 5.0\\" # Example 4: print(pythagoras(3, 4, 5)) # Output: \\"You already know the answer!\\" # Example 5: print(pythagoras(\\"?\\", \\"?\\", 5)) # Raises ValueError ``` # Constraints * The known sides (if not `?`) are positive floating-point numbers. * Only one of the sides will be unknown (`?`) in each query. * Hypotenuse side should always be the largest among the sides. # Note Ensure accurate exception handling and validation to handle edge cases effectively.","solution":"import math def pythagoras(opposite, adjacent, hypotenuse): # Convert the inputs to floats if they are not \\"?\\" opposite = float(opposite) if opposite != \\"?\\" else None adjacent = float(adjacent) if adjacent != \\"?\\" else None hypotenuse = float(hypotenuse) if hypotenuse != \\"?\\" else None # Determine which side is missing if opposite is None: if adjacent is None or hypotenuse is None: raise ValueError(\\"Invalid input!\\") if hypotenuse <= adjacent: raise ValueError(\\"Invalid input!\\") opposite = math.sqrt(hypotenuse**2 - adjacent**2) return f\\"Opposite = {opposite:.1f}\\" elif adjacent is None: if opposite is None or hypotenuse is None: raise ValueError(\\"Invalid input!\\") if hypotenuse <= opposite: raise ValueError(\\"Invalid input!\\") adjacent = math.sqrt(hypotenuse**2 - opposite**2) return f\\"Adjacent = {adjacent:.1f}\\" elif hypotenuse is None: if opposite is None or adjacent is None: raise ValueError(\\"Invalid input!\\") hypotenuse = math.sqrt(opposite**2 + adjacent**2) return f\\"Hypotenuse = {hypotenuse:.1f}\\" else: if not (opposite**2 + adjacent**2 == hypotenuse**2): raise ValueError(\\"Invalid input!\\") return \\"You already know the answer!\\""},{"question":"# Scenario Imagine you are given access to a vast corpus of binary trees recorded from different datasets. Your goal is to write a function that validates if each binary tree adheres to the Binary Search Tree (BST) properties. For this, you need an efficient algorithm, as time complexity is critical when handling large datasets. # Task Implement a function `is_bst` that determines whether a given binary tree is a valid BST. Your algorithm should have a time complexity of O(n) and use at most O(h) space, where n is the number of nodes and h is the height of the tree. # Function Signature ```python def is_bst(root: TreeNode) -> bool: :type root: TreeNode :rtype: bool ``` # Input * The function receives a single parameter `root`, which is the root node of a binary tree where `root` is an instance of `TreeNode`. # Output * The function should return `True` if the binary tree is a valid BST, otherwise `False`. # TreeNode Class Here\'s a simple definition of the `TreeNode` class for reference: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` # Examples Example 1 ```python Input: 2 / 1 3 Output: True ``` Example 2 ```python Input: 1 / 2 3 Output: False ``` # Constraints * The number of nodes in the binary tree can be up to (10^4). * The value of each node will be within the range ([-10^4, 10^4]).","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_bst(root: TreeNode) -> bool: def validate(node, low=float(\'-inf\'), high=float(\'inf\')): # Empty trees are considered BSTs if not node: return True # The current node\'s value must be between low and high if node.val <= low or node.val >= high: return False # The left subtree must have all values < node.val # The right subtree must have all values > node.val return (validate(node.left, low, node.val) and validate(node.right, node.val, high)) return validate(root)"},{"question":"You are given a singly linked list where some nodes may contain duplicate values. Your task is to write two functions to remove duplicates from this linked list. 1. Implement a function that removes duplicates using extra space (a hashset). 2. Implement another function that removes duplicates without using extra space. # Function Signature ```python class Node: def __init__(self, val=None): self.val = val self.next = None def remove_dups(head: Node) -> None: pass def remove_dups_without_set(head: Node) -> None: pass ``` # Input - The `head` of a singly linked list, where each node contains: * `val` (str): The value of the node. * `next` (Node): The reference to the next node in the list or `None` if it is the last node. # Output - Both functions should modify the linked list in place and should not return anything. - After running either of the functions, the linked list should have no duplicates. # Constraints - The list can be empty. - The maximum number of nodes in the list is 10^5. - The function should handle both uppercase and lowercase letters. - The first function will use extra space, the second will not. # Example Given the linked list A -> A -> B -> C -> D -> C -> F -> G, your functions should transform the list to: - Using `remove_dups`: `A -> B -> C -> D -> F -> G` - Using `remove_dups_without_set`: `A -> B -> C -> D -> F -> G` # Notes - Ensure your solution does not create new nodes but instead modifies the existing nodes.","solution":"class Node: def __init__(self, val=None): self.val = val self.next = None def remove_dups(head: Node) -> None: Removes duplicates from a linked list using extra space (a hashset). if not head: return current = head seen = set() seen.add(current.val) while current.next: if current.next.val in seen: current.next = current.next.next else: seen.add(current.next.val) current = current.next def remove_dups_without_set(head: Node) -> None: Removes duplicates from a linked list without using extra space. current = head while current: runner = current while runner.next: if runner.next.val == current.val: runner.next = runner.next.next else: runner = runner.next current = current.next"},{"question":"# Linked List Cyclification You are provided with two classes, `DoublyLinkedListNode` and `SinglyLinkedListNode`, that represent the nodes in doubly and singly linked lists, respectively. Your task is to create two custom linked list classes, `DoublyLinkedList` and `SinglyLinkedList`. Each class should support the following operations: 1. **insert(value)**: Insert a node with the given value at the beginning of the list. 2. **remove(value)**: Remove the first occurrence of a node with the given value. 3. **is_cyclic()**: Checks if the list is cyclic (i.e., there is a cycle in the list). Guidelines * For `DoublyLinkedList`, ensure that each node has both `next` and `prev` pointers. * For `SinglyLinkedList`, each node should only have a `next` pointer. * The `is_cyclic` method should effectively detect cycles to ensure there\'s no infinite loop. Input & Output Format * **insert(value)**: No input; appends value at the beginning. * **remove(value)**: * **Input**: Integer `value`. * **Output**: Boolean indicating if the node was successfully removed. * **is_cyclic()**: * **Input**: None. * **Output**: Boolean indicating if the linked list contains a cycle. Constraints * You should handle cases where the list is initially empty. * Ensure proper handling of edge cases such as removing a node that does not exist. * Optimize the `is_cyclic` method to run in O(n) time using Floyd’s Tortoise and Hare algorithm or an equivalent approach. # Example ```python # Example Usage dll = DoublyLinkedList() dll.insert(10) dll.insert(20) dll.insert(30) print(dll.is_cyclic()) # Output: False dll.head.next.next.next = dll.head # Manually creating a cycle for testing print(dll.is_cyclic()) # Output: True sll = SinglyLinkedList() sll.insert(10) sll.insert(20) sll.insert(30) print(sll.is_cyclic()) # Output: False sll.head.next.next.next = sll.head # Manually creating a cycle for testing print(sll.is_cyclic()) # Output: True ``` Implement the `DoublyLinkedList` and `SinglyLinkedList` classes with the required methods according to the above specifications.","solution":"class DoublyLinkedListNode: def __init__(self, value): self.value = value self.next = None self.prev = None class DoublyLinkedList: def __init__(self): self.head = None def insert(self, value): new_node = DoublyLinkedListNode(value) if self.head: self.head.prev = new_node new_node.next = self.head self.head = new_node def remove(self, value): current = self.head while current: if current.value == value: if current.prev: current.prev.next = current.next if current.next: current.next.prev = current.prev if current == self.head: self.head = current.next return True current = current.next return False def is_cyclic(self): slow, fast = self.head, self.head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: return True return False class SinglyLinkedListNode: def __init__(self, value): self.value = value self.next = None class SinglyLinkedList: def __init__(self): self.head = None def insert(self, value): new_node = SinglyLinkedListNode(value) new_node.next = self.head self.head = new_node def remove(self, value): current = self.head prev = None while current: if current.value == value: if prev: prev.next = current.next else: self.head = current.next return True prev = current current = current.next return False def is_cyclic(self): slow, fast = self.head, self.head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: return True return False"},{"question":"# Question: You are required to implement a modified stack data structure that maintains its elements in descending order (from the highest to the lowest). The provided `OrderedStack` class aims to keep the stack always ordered such that the highest value is at the top and the lowest value is at the bottom. Your Task: You need to implement a function `get_ordered_stack_sequence` that takes an array of integers and returns the sequence of elements from the ordered stack after pushing all array elements. Function Signature: ```python def get_ordered_stack_sequence(arr: list) -> list: ``` # Input: * `arr` (0 <= len(arr) <= 1000): An array of integers. # Output: * A list of integers representing the ordered stack sequence from top to bottom. # Constraints: * All integers are within the range of -10^6 to 10^6. * The output must be in descending order from the highest at the top to the lowest at the bottom. # Example: ```python assert get_ordered_stack_sequence([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]) == [9, 6, 5, 5, 5, 4, 3, 3, 2, 1, 1] assert get_ordered_stack_sequence([]) == [] ``` Implementation Details: 1. Initialize the `OrderedStack` instance. 2. Push each element of the array into the `OrderedStack`. 3. Return a list of elements from the top to the bottom of the stack. --- * Make sure to handle edge cases like an empty input array. * Raise appropriate errors for invalid inputs. * Aim to match the provided output format.","solution":"class OrderedStack: def __init__(self): self.stack = [] def push(self, value): # Use binary search to find the correct position to insert the new element left, right = 0, len(self.stack) while left < right: mid = (left + right) // 2 if self.stack[mid] < value: right = mid else: left = mid + 1 self.stack.insert(left, value) def get_stack(self): return self.stack def get_ordered_stack_sequence(arr): ordered_stack = OrderedStack() for num in arr: ordered_stack.push(num) return ordered_stack.get_stack()"},{"question":"Question You are given two positive integers, `a` and `n`, where gcd(a, n) = 1. Your task is to write a function `find_order(a, n)` that determines the smallest positive integer `k` such that ( a^k mod n = 1 ). If no such `k` exists, return -1. # Input - Two integers `a` and `n` (1 <= a, n <= 10^9). # Output - An integer `k` representing the smallest positive integer for which ( a^k mod n = 1 ). If such an integer does not exist, return -1. # Constraints - Assume that gcd(a, n) = 1. # Example ```python assert find_order(3, 7) == 6 # Explanation: 3^6 % 7 = 1 assert find_order(2, 5) == 4 # Explanation: 2^4 % 5 = 1 assert find_order(10, 17) == 16 # Explanation: 10^16 % 17 = 1 ``` # Performance Requirements - Your solution should be efficient and able to handle the largest inputs within a reasonable time limit. # Additional Notes - Pay attention to edge cases, especially where the inputs might lead to boundary conditions. - Think about possible optimizations to reduce the number of iterations needed. Good luck, and happy coding!","solution":"def find_order(a, n): Find the smallest positive integer k such that a^k % n = 1. if a % n == 1: return 1 k = 1 current = a % n while k < n: if current == 1: return k k += 1 current = (current * a) % n return -1"},{"question":"# Coding Challenge: Implement a Sorted Array Insertion Function Objective Write a function that, given a sorted array, inserts a given value into the array such that the array remains sorted. Function Signature ```python def insert_sorted(array, value): Inserts the value into the sorted array in the appropriate position. Args: array (list): A list of integers sorted in ascending order. value (int): The integer value to be inserted. Returns: list: The sorted list after inserting the value. ``` Inputs * `array` (list): A list of integers which is sorted in non-decreasing order. * `value` (int): An integer to be inserted into the array. Outputs * Return a new sorted list with the `value` inserted in the appropriate position. Example ```python insert_sorted([1, 3, 5, 6], 5) # Output: [1, 3, 5, 5, 6] insert_sorted([1, 3, 5, 6], 2) # Output: [1, 2, 3, 5, 6] insert_sorted([1, 3, 5, 6], 7) # Output: [1, 3, 5, 6, 7] insert_sorted([1, 3, 5, 6], 0) # Output: [0, 1, 3, 5, 6] ``` Constraints * The length of the input array is between 0 and 10^6. * The value to insert is an integer in the range of -10^9 to 10^9. Requirements * Do not use any in-built sorting functions. * Your solution should aim for optimal time complexity. Performance * Ensure your solution works with large inputs efficiently using O(log n) insertion determination.","solution":"def insert_sorted(array, value): Inserts the value into the sorted array in the appropriate position. Args: array (list): A list of integers sorted in ascending order. value (int): The integer value to be inserted. Returns: list: The sorted list after inserting the value. if not array: return [value] # Binary search to find the correct insertion point left, right = 0, len(array) - 1 while left <= right: mid = (left + right) // 2 if array[mid] == value: left = mid break elif array[mid] < value: left = mid + 1 else: right = mid - 1 # Insert the value in the correct position return array[:left] + [value] + array[left:]"},{"question":"# Decoding Messages with Dynamic Programming **Problem Statement**: A message containing letters from A-Z is being encoded using the following mapping: ``` \'A\' -> 1 \'B\' -> 2 ... \'Z\' -> 26 ``` Given an encoded message containing digits, determine the total number of ways to decode it. **Example**: Given the encoded message \\"12\\", it could be decoded as: - \\"AB\\" (1 2) - \\"L\\" (12) So the number of ways to decode \\"12\\" is 2. **Constraints**: - The input string will only contain digits and will be non-empty. **Task**: Implement a function `count_decodings(encoded_message: str) -> int` that calculates the total number of ways to decode a given message. **Function Signature**: ```python def count_decodings(encoded_message: str) -> int: pass ``` **Input**: - `encoded_message`: A string (1 <= len(encoded_message) <= 100), containing only digits from \'0\' to \'9\'. **Output**: - An integer representing the total number of ways to decode the input string. **Performance Requirements**: - The algorithm should run in O(n) time complexity, where n is the length of the encoded message. - The space complexity should optimize for minimal additional storage. **Examples**: 1. `count_decodings(\\"12\\")` → 2 2. `count_decodings(\\"226\\")` → 3 (BZ, VF, BBF) 3. `count_decodings(\\"0\\")` → 0 (invalid encoding) 4. `count_decodings(\\"06\\")` → 0 (invalid encoding)","solution":"def count_decodings(encoded_message: str) -> int: This function calculates the total number of ways to decode a given encoded message containing digits. if not encoded_message or encoded_message[0] == \'0\': return 0 n = len(encoded_message) dp = [0] * (n + 1) dp[0], dp[1] = 1, 1 for i in range(2, n + 1): single_digit = int(encoded_message[i - 1]) two_digits = int(encoded_message[i - 2: i]) if single_digit >= 1: dp[i] += dp[i - 1] if 10 <= two_digits <= 26: dp[i] += dp[i - 2] return dp[n]"},{"question":"# Array Rotation Context Shifting and rotating are common operations in various applications, from data preprocessing to real-time system scheduling. Given an array, understanding how to manipulate its elements efficiently is crucial in many programming and data structure tasks. Challenge Implement a function to rotate an array to the right by `k` steps in an efficient manner. Function Signature ```python def rotate_array(arr: List[int], k: int) -> List[int]: Rotate array arr to the right by k steps :param arr: List[int] - List of integers to be rotated. :param k: int - Number of steps to rotate the array to the right. :return: List[int] - Rotated array. Note: Your implementation should be efficient and you should handle the edge cases properly. ``` Input & Output - **Input**: * `arr` - List of integers. Length of `arr` can be 0 to 10,000. * `k` - Non-negative integer that dictates the number of steps to rotate the array. - **Output**: * Rotated array after `k` steps to the right. Constraints - The result should be obtained in less than O(n*k) time complexity where possible. - Only in-place modification and minimal space complexity solutions will get full marks. - Handle various edge cases (e.g., empty array, `k` being larger than the length of the array). Example ```python assert rotate_array([1, 2, 3, 4, 5, 6, 7], 3) == [5, 6, 7, 1, 2, 3, 4] assert rotate_array([1, 2], 3) == [2, 1] assert rotate_array([], 4) == [] assert rotate_array([1, 2, 3], 0) == [1, 2, 3] assert rotate_array([1, 2, 3], 3) == [1, 2, 3] ``` Evaluate the function thoroughly by considering upper boundary edge cases as well.","solution":"def rotate_array(arr, k): Rotate array arr to the right by k steps. :param arr: List[int] - List of integers to be rotated. :param k: int - Number of steps to rotate the array to the right. :return: List[int] - Rotated array. if not arr: return [] k = k % len(arr) # to handle k >= len(arr) return arr[-k:] + arr[:-k]"},{"question":"# Question Scenario You are tasked with writing a function to help a drone determine the best k recharge stations from a list based on their proximity to the drone\'s current position. This functionality is crucial for optimizing the drone\'s routes for various delivery schedules. The recharge stations are represented as (x, y) coordinates in a 2D plane, and the drone needs to find the k closest stations to its current position, also given as coordinates. Problem Statement Implement a function called `find_k_closest_stations(points, k, drone_position)` where: * `points` is a list of tuples, each representing the (x, y) coordinates of a recharge station. * `k` is an integer representing the number of closest stations to find. * `drone_position` is a tuple representing the current (x, y) coordinates of the drone. * The function should return a list containing the coordinates of the k closest recharge stations to the drone. # Input Format ```python def find_k_closest_stations(points: List[Tuple[int, int]], k: int, drone_position: Tuple[int, int]) -> List[Tuple[int, int]]: ``` * `points`: List of tuples [(x1, y1), (x2, y2), ...] where each tuple represents the (x, y) coordinates of a recharge station. * `k`: Integer k. * `drone_position`: Tuple (x, y) representing the coordinates of the drone. # Output Format * The function should return a List of tuples representing the k closest recharge stations. If there are fewer than k stations available, return all stations. # Constraints * 1 <= len(points) <= 10^4 * 1 <= k <= len(points) * The coordinates can be negative or positive integers. # Examples ```python find_k_closest_stations([(1, 2), (3, 4), (2, -1)], 2, (0, 0)) # Expected Output: [(1, 2), (2, -1)] find_k_closest_stations([(5, 6), (1, 2), (3, 4), (7, 8)], 3, (2, 3)) # Expected Output: [(1, 2), (3, 4), (5, 6)] ``` # Notes * The function should leverage a heap or priority queue to efficiently maintain the k closest points. * Ensure to handle edge cases where the number of points is less than k.","solution":"import heapq from typing import List, Tuple def find_k_closest_stations(points: List[Tuple[int, int]], k: int, drone_position: Tuple[int, int]) -> List[Tuple[int, int]]: Finds the k closest recharge stations to the current drone position. Parameters: points (List[Tuple[int, int]]): List of recharge station coordinates. k (int): Number of closest stations to find. drone_position (Tuple[int, int]): Current coordinates of the drone. Returns: List[Tuple[int, int]]: List of k closest recharge stations. x0, y0 = drone_position distances = [] for x, y in points: distance = (x - x0) ** 2 + (y - y0) ** 2 distances.append((distance, (x, y))) closest_points = heapq.nsmallest(k, distances, key=lambda x: x[0]) return [point for _, point in closest_points]"},{"question":"# Nearest Neighbor Search **Scenario**: You are tasked with improving the security of a biometric authentication system. The system initially classifies a user\'s input based on their closest recorded biometric template using the Nearest Neighbor method. # Task Implement a function called `nearest_neighbor` that classifies an input vector `x` by comparing it to a training set `tSet` using the nearest neighbor approach. # Requirements - **Function Signature**: `def nearest_neighbor(x: tuple, tSet: dict) -> Any:` - **Input**: - `x` - a tuple representing the feature vector of the input data - `tSet` - a dictionary where keys are tuples representing feature vectors from the training set, and values are labels (classification) associated with those vectors. - **Output**: - Return the classification of the input vector by identifying and returning the label of the closest feature vector in the training set. # Constraints - All tuples (both from input and training set) have the same dimensionality. - Vectors and labels in `tSet` are non-empty. - Assume all numerical components of vectors are real numbers. # Examples ```python # Example 1: x = (1.0, 2.0) tSet = { (1.0, 1.0): \\"Class A\\", (2.0, 2.0): \\"Class B\\", (3.0, 3.0): \\"Class C\\" } print(nearest_neighbor(x, tSet)) # Output: \\"Class A\\" # Example 2: x = (3.5, 4.5) tSet = { (1.0, 2.0): \\"Class 1\\", (4.0, 5.0): \\"Class 2\\", (6.0, 7.0): \\"Class 3\\" } print(nearest_neighbor(x, tSet)) # Output: \\"Class 2\\" ``` # Note You may utilize the provided helper function `distance(x, y)` to compute the Euclidean distance between two vectors `x` and `y`. ```python import math def distance(x, y): assert len(x) == len(y), \\"Vectors must have the same length\\" return math.sqrt(sum((xi - yi) ** 2 for xi, yi in zip(x, y))) ``` Implement the `nearest_neighbor` function to achieve the task described.","solution":"import math def distance(x, y): Computes the Euclidean distance between two vectors x and y. assert len(x) == len(y), \\"Vectors must have the same length\\" return math.sqrt(sum((xi - yi) ** 2 for xi, yi in zip(x, y))) def nearest_neighbor(x, tSet): Classifies an input vector x by comparing it to a training set tSet using the nearest neighbor method. Parameters: x (tuple): Feature vector of the input data. tSet (dict): Dictionary where keys are tuples representing feature vectors from the training set, and values are labels associated with those vectors. Returns: Any: Classification label of the closest feature vector in the training set. min_distance = float(\'inf\') nearest_label = None for key, label in tSet.items(): d = distance(x, key) if d < min_distance: min_distance = d nearest_label = label return nearest_label"},{"question":"Implementing Improved Cholesky Decomposition with Error Handling Implement an improved version of the Cholesky decomposition algorithm provided. This version should include enhancements such as better error handling and edge case management. Requirements: 1. **Input**: A Hermitian positive-definite matrix (A) of size (n times n) (list of lists of floats). 2. **Output**: A lower triangular matrix (V) such that (A = V cdot V^*), or an appropriate error message if the decomposition is not possible. 3. **Constraints**: - Ensure the input matrix is square. - Handle the case where the matrix is not positive-definite gracefully by returning an error message. 4. **Performance**: Your solution should maintain a time complexity of (O(n^3)). Function Signature: ```python def improved_cholesky_decomposition(A: List[List[float]]) -> Union[List[List[float]], str]: pass ``` # Example: ```python # Input matrix A: A = [ [4, 12, -16], [12, 37, -43], [-16, -43, 98] ] # Expected output matrix V: # [ # [2.0, 0.0, 0.0], # [6.0, 1.0, 0.0], # [-8.0, 5.0, 3.0] # ] # Potential error message for non-valid input matrix: # \\"Matrix is not positive-definite\\" or \\"Matrix is not square\\" ``` Use the provided example as a basis, but ensure your solution covers all edge cases and appropriately manages errors.","solution":"from typing import List, Union def improved_cholesky_decomposition(A: List[List[float]]) -> Union[List[List[float]], str]: n = len(A) if any(len(row) != n for row in A): return \\"Matrix is not square\\" V = [[0.0] * n for _ in range(n)] for i in range(n): for j in range(i + 1): sum_val = sum(V[i][k] * V[j][k] for k in range(j)) if i == j: # Diagonal elements if A[i][i] - sum_val <= 0: return \\"Matrix is not positive-definite\\" V[i][j] = (A[i][i] - sum_val) ** 0.5 else: if V[j][j] == 0: return \\"Matrix is not positive-definite\\" V[i][j] = (A[i][j] - sum_val) / V[j][j] return V"},{"question":"Suppose you are building a cryptographic module that requires computing the order of a number modulo `n`. The order of `a` modulo `n` is defined as the smallest positive integer `k` such that `a^k ≡ 1 (mod n)`, provided `gcd(a, n) = 1`. If no such integer exists, return -1. # Task Write a function `find_order(a, n)` that: 1. Checks if `gcd(a, n) = 1`. If not, print an error message and return -1. 2. Computes the order of `a` modulo `n` using the definition provided. 3. Returns the order if it exists, otherwise returns -1. # Function Signature ```python def find_order(a: int, n: int) -> int: ``` # Input * `a` (1 ≤ a ≤ 10^6): An integer whose order modulo `n` needs to be found. * `n` (2 ≤ n ≤ 10^6): The modulus, an integer relative prime to `a`. # Output * An integer representing the order of `a` modulo `n`, or -1 if the order does not exist. # Constraints * Ensure that the function works efficiently for large values of `n`. # Examples ```python find_order(3, 7) # Output: 6 find_order(2, 4) # Output: -1 find_order(10, 17) # Output: 16 ``` # Notes 1. If `gcd(a, n) ≠ 1`, the algorithm should terminate with appropriate messaging. 2. Assume the input values are always within the constraints provided. 3. Consider performance implications and optimize if possible.","solution":"import math def gcd(a, b): while b: a, b = b, a % b return a def find_order(a: int, n: int) -> int: Find the order of `a` modulo `n`. Parameters: a (int): The base integer. n (int): The modulus. Returns: int: The order of `a` modulo `n`, or -1 if no such order exists. if gcd(a, n) != 1: print(\\"gcd(a, n) is not 1\\") return -1 k = 1 current = a % n while current != 1: current = (current * a) % n k += 1 if k > n: # This case should theoretically never occur as Euler\'s theorem guarantees a bound return -1 return k"},{"question":"# Priority Queue Implementation Using Heap **Objective**: Implement a priority queue using a min-heap to improve the efficiency of insertion and extraction operations. **Description**: A priority queue is a data structure that allows elements to be inserted with an associated priority. The element with the minimal priority can be efficiently retrieved and removed. The current implementation uses a linear array, which results in inefficient insertion operations. Instead, you are required to implement a priority queue using a min-heap to optimize the insertion and extraction operations. **Task**: Write a class `MinHeapPriorityQueue` that provides the following methods: 1. **`__init__(self)`**: Initializes the priority queue. 2. **`size(self)`**: Returns the size of the priority queue. 3. **`push(self, item, priority)`**: Pushes an item with a given priority into the priority queue. 4. **`pop(self)`**: Removes and returns the item with the lowest priority. **Input and Output Formats**: * **Input**: * `push(item, priority)`: `item` (any data type) and `priority` (integer). * `pop()`: No inputs. * **Output**: * `push()`: No return value. * `pop()`: Returns the item with the lowest priority. **Constraints**: * The priority should be an integer. * There will be at least one element when `pop()` is called. **Performance Requirements**: * `push()`: Average time complexity should be O(log n). * `pop()`: Average time complexity should be O(log n). **Example**: ```python pq = MinHeapPriorityQueue() pq.push(\'task1\', 1) pq.push(\'task3\', 3) pq.push(\'task2\', 2) print(pq.pop()) # Output: \'task1\' print(pq.pop()) # Output: \'task2\' print(pq.pop()) # Output: \'task3\' ``` # Implementation Guidelines 1. Use a list to represent the heap. 2. Use the `heapq` module from the Python standard library to implement the min-heap operations. 3. Ensure that the `pop` method raises an exception or handles an empty heap scenario gracefully.","solution":"import heapq class MinHeapPriorityQueue: def __init__(self): Initializes the priority queue with an empty list. self.heap = [] def size(self): Returns the size of the priority queue. return len(self.heap) def push(self, item, priority): Pushes an item with a given priority into the priority queue. heapq.heappush(self.heap, (priority, item)) def pop(self): Removes and returns the item with the lowest priority. if self.heap: _, item = heapq.heappop(self.heap) return item else: raise IndexError(\\"pop from an empty priority queue\\")"},{"question":"# Scenario and Coding Question You are working on a machine learning project that involves handling extremely large datasets represented as sparse vectors. Due to the high dimensionality and sparsity of the data, efficiently storing and computing dot products of these vectors is crucial. To this end, you\'ve been provided with functions that convert a dense vector into a sparse representation and compute the dot product of two sparse vectors. Your task is to extend this functionality further by implementing additional operations on sparse vectors while maintaining the efficiency benefits. The new operations should include: 1. Implement a function to add two sparse vectors. 2. Implement a function to multiply a sparse vector by a scalar. Function Signature ```python def sparse_vector_addition(iv_list1, iv_list2): Add two sparse vectors and return the resulting sparse vector. Parameters: iv_list1 (list of tuples): The first sparse vector as a list of (index, value) pairs. iv_list2 (list of tuples): The second sparse vector as a list of (index, value) pairs. Returns: list of tuples: Resulting sparse vector as a list of (index, value) pairs. pass def sparse_vector_scalar_multiply(iv_list, scalar): Multiply a sparse vector by a scalar and return the resulting sparse vector. Parameters: iv_list (list of tuples): The sparse vector as a list of (index, value) pairs. scalar (float): The scalar value to multiply by. Returns: list of tuples: Resulting sparse vector as a list of (index, value) pairs. pass ``` Input and Output Formats 1. `sparse_vector_addition`: Takes two sparse vectors (lists of (index, value) pairs) and returns a new sparse vector representing their sum. - Example input: `iv_list1 = [(0, 1.0), (2, 3.0)]`, `iv_list2 = [(2, 2.0), (3, 4.0)]` - Expected output: `[(0, 1.0), (2, 5.0), (3, 4.0)]` 2. `sparse_vector_scalar_multiply`: Takes a sparse vector and a scalar value, then returns a new sparse vector where each value is multiplied by the scalar. - Example input: `iv_list = [(0, 1.0), (2, 3.0)]`, `scalar = 2.0` - Expected output: `[(0, 2.0), (2, 6.0)]` Constraints and Performance Requirements - The input vectors have lengths up to (10^6) and contain at most (10^5) non-zero elements. - Optimize for both time and space efficiency. Provide tested and optimized implementations for both functions considering the properties and challenges of sparse vectors.","solution":"def sparse_vector_addition(iv_list1, iv_list2): Add two sparse vectors and return the resulting sparse vector. Parameters: iv_list1 (list of tuples): The first sparse vector as a list of (index, value) pairs. iv_list2 (list of tuples): The second sparse vector as a list of (index, value) pairs. Returns: list of tuples: Resulting sparse vector as a list of (index, value) pairs. result_dict = {} for index, value in iv_list1: result_dict[index] = value for index, value in iv_list2: if index in result_dict: result_dict[index] += value else: result_dict[index] = value # Remove entries with zero value (result of addition) result = [(index, value) for index, value in result_dict.items() if value != 0] return sorted(result) def sparse_vector_scalar_multiply(iv_list, scalar): Multiply a sparse vector by a scalar and return the resulting sparse vector. Parameters: iv_list (list of tuples): The sparse vector as a list of (index, value) pairs. scalar (float): The scalar value to multiply by. Returns: list of tuples: Resulting sparse vector as a list of (index, value) pairs. result = [(index, value * scalar) for index, value in iv_list if value * scalar != 0] return result"},{"question":"You are implementing a priority service system wherein specific tasks are chosen based on their priority levels. Your task is to enhance the priority queue implementation so that it functions efficiently even with a large number of tasks. Specifically, you need to: * Refactor the existing linear array-based priority queue to use a binary heap, which will improve insertion time complexity. # Requirements * Implement a priority queue using a binary heap. You may use a min-heap for this purpose. * Your priority queue class should support the following operations: * `push(item, priority)`: Insert an item with a given priority. * `pop()`: Remove and return the item with the highest priority (lowest numerical priority value). * `size()`: Return the size of the priority queue. * Ensure that all operations are efficient: * Insertion and removal should both be O(log n). # Function Signatures ```python class PriorityQueue: def __init__(self, items=None, priorities=None): pass def push(self, item, priority): pass def pop(self): pass def size(self): pass ``` # Input/Output Format * The `push(item, priority)` function takes two parameters: * `item` (any data type). * `priority` (integer or float). * The `pop()` function returns the item with the highest priority. * The `size()` function returns an integer representing the number of items in the priority queue. # Constraints * Items and priorities are provided in random order. * Priorities are distinct integers. # Example ```python pq = PriorityQueue() pq.push(\'task1\', 3) pq.push(\'task2\', 2) pq.push(\'task3\', 1) print(pq.pop()) # Output: \'task3\' (highest priority, priority value 1) print(pq.size()) # Output: 2 pq.push(\'task4\', 0) print(pq.pop()) # Output: \'task4\' (highest priority, priority value 0) print(pq.size()) # Output: 2 ```","solution":"import heapq class PriorityQueue: def __init__(self): self.heap = [] def push(self, item, priority): heapq.heappush(self.heap, (priority, item)) def pop(self): return heapq.heappop(self.heap)[1] def size(self): return len(self.heap)"},{"question":"# AVL Tree Implementation and Traversal You are tasked with implementing and extending the functionality of an AVL Tree, a self-balancing binary search tree. This will test your understanding of tree structures, balancing mechanisms, and recursive data manipulation. Your Tasks: 1. Implement the `delete` method to remove an element from the AVL tree while ensuring the tree remains balanced. 2. Implement the `pre_order_traverse` method to traverse the tree in pre-order and return the keys in a list. 3. Implement the `post_order_traverse` method to traverse the tree in post-order and return the keys in a list. # Requirements **Function Signature**: ```python class AvlTree: def delete(self, key: int) -> None: pass def pre_order_traverse(self) -> list: pass def post_order_traverse(self) -> list: pass ``` # Input and Output Formats: 1. **delete(key)**: - `key (int)`: The value of the node to be deleted. - **No Output**: Modifies the tree in-place. 2. **pre_order_traverse()**: - **No Input**: Traverses the tree in pre-order. - **Output (List[int])**: A list of node keys in pre-order traversal. 3. **post_order_traverse()**: - **No Input**: Traverses the tree in post-order. - **Output (List[int])**: A list of node keys in post-order traversal. # Constraints: - AVL tree follows the property of a binary search tree. - The range of `key` is between `-10^9` to `10^9`. - The tree can contain at most `10^5` nodes. - Ensure removal and insertion operations maintain AVL balance. # Example: ```python # Instantiate AvlTree and Insert Elements avl = AvlTree() avl.insert(10) avl.insert(20) avl.insert(5) avl.insert(4) avl.insert(7) # Pre-order traversal assert avl.pre_order_traverse() == [10, 5, 4, 7, 20] # Post-order traversal assert avl.post_order_traverse() == [4, 7, 5, 20, 10] # Delete an element avl.delete(5) # In-order traversal after delete assert avl.in_order_traverse() == [4, 7, 10, 20] ``` Note: Keep in mind to handle edge cases such as deleting a leaf node, deleting a node with one child, and deleting a node with two children. The tree must always remain balanced after any delete operation.","solution":"class Node: def __init__(self, key): self.key = key self.left = None self.right = None self.height = 1 class AvlTree: def __init__(self): self.root = None def get_height(self, node): if not node: return 0 return node.height def get_balance(self, node): if not node: return 0 return self.get_height(node.left) - self.get_height(node.right) def right_rotate(self, z): y = z.left T3 = y.right y.right = z z.left = T3 z.height = 1 + max(self.get_height(z.left), self.get_height(z.right)) y.height = 1 + max(self.get_height(y.left), self.get_height(y.right)) return y def left_rotate(self, z): y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self.get_height(z.left), self.get_height(z.right)) y.height = 1 + max(self.get_height(y.left), self.get_height(y.right)) return y def insert(self, key): if not self.root: self.root = Node(key) else: self.root = self._insert(self.root, key) def _insert(self, node, key): if not node: return Node(key) elif key < node.key: node.left = self._insert(node.left, key) else: node.right = self._insert(node.right, key) node.height = 1 + max(self.get_height(node.left), self.get_height(node.right)) balance = self.get_balance(node) if balance > 1 and key < node.left.key: return self.right_rotate(node) if balance < -1 and key > node.right.key: return self.left_rotate(node) if balance > 1 and key > node.left.key: node.left = self.left_rotate(node.left) return self.right_rotate(node) if balance < -1 and key < node.right.key: node.right = self.right_rotate(node.right) return self.left_rotate(node) return node def delete(self, key): if self.root: self.root = self._delete(self.root, key) def _delete(self, node, key): if not node: return node if key < node.key: node.left = self._delete(node.left, key) elif key > node.key: node.right = self._delete(node.right, key) else: if not node.left: return node.right elif not node.right: return node.left temp_val = self.get_min_value_node(node.right) node.key = temp_val.key node.right = self._delete(node.right, temp_val.key) if not node: return node node.height = 1 + max(self.get_height(node.left), self.get_height(node.right)) balance = self.get_balance(node) if balance > 1 and self.get_balance(node.left) >= 0: return self.right_rotate(node) if balance > 1 and self.get_balance(node.left) < 0: node.left = self.left_rotate(node.left) return self.right_rotate(node) if balance < -1 and self.get_balance(node.right) <= 0: return self.left_rotate(node) if balance < -1 and self.get_balance(node.right) > 0: node.right = self.right_rotate(node.right) return self.left_rotate(node) return node def get_min_value_node(self, node): if node is None or node.left is None: return node return self.get_min_value_node(node.left) def pre_order_traverse(self): result = [] self._pre_order_traverse(self.root, result) return result def _pre_order_traverse(self, node, result): if not node: return result.append(node.key) self._pre_order_traverse(node.left, result) self._pre_order_traverse(node.right, result) def post_order_traverse(self): result = [] self._post_order_traverse(self.root, result) return result def _post_order_traverse(self, node, result): if not node: return self._post_order_traverse(node.left, result) self._post_order_traverse(node.right, result) result.append(node.key)"},{"question":"You are required to implement a function `isAnagram` that determines whether two given strings are anagrams of each other. An anagram is formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once. Your function should consider the following: - The comparison should be case-insensitive (e.g., \\"Listen\\" and \\"Silent\\" are anagrams). - The function should ignore non-alphabet characters. # Input and Output Format - **Input**: Two strings, `s1` and `s2`. - **Output**: A boolean value, `True` if the strings are anagrams, `False` otherwise. # Function Signature ```python def isAnagram(s1: str, s2: str) -> bool: ``` # Constraints 1. The input strings should contain only printable characters. 2. The comparison must be case-insensitive. 3. Only alphabetic characters should be considered in the comparison. # Example ```python print(isAnagram(\\"apple\\", \\"Pleap\\")) # Output: True print(isAnagram(\\"apple\\", \\"cherry\\")) # Output: False print(isAnagram(\\"Listen\\", \\"Silent\\")) # Output: True print(isAnagram(\\"A gentleman\\", \\"Elegant man!\\")) # Output: True ``` # Notes - Implement robust handling of input by normalizing case and stripping non-alphabet characters. - Ensure that your algorithm operates efficiently, abiding by the expected linear time complexity where applicable. # Implementation Guidelines 1. Normalize the input strings by converting them to lowercase. 2. Remove any non-alphabet characters. 3. Count the frequency of each character in both strings. 4. Compare the frequency distributions to determine if the strings are anagrams.","solution":"def isAnagram(s1: str, s2: str) -> bool: Determines if the two provided strings are anagrams of each other, considering only alphabetic characters and ignoring case. import re from collections import Counter # Normalize strings: convert to lowercase and remove non-alphabet characters normalize = lambda s: re.sub(r\'[^a-z]\', \'\', s.lower()) s1_normalized = normalize(s1) s2_normalized = normalize(s2) # Compare the character counts return Counter(s1_normalized) == Counter(s2_normalized)"},{"question":"# Task Implement a `WordDictionary` class to support adding words and searching for words, where the search can contain \\".\\" as a wildcard character. # Detailed Requirements 1. **Class Methods**: * `add_word(word: str) -> None`: Adds a word to the data structure. * `search(word: str) -> bool`: Searches for a word or a pattern in the data structure. The pattern can contain the special character \\".\\" which can match any single character. 2. **Input Format**: - The method `add_word` will receive a single string, `word`, containing only lowercase English letters. - The method `search` will receive a single string, `word`, which can include lowercase English letters and the special character \\".\\". 3. **Output Format**: - The `add_word` method does not return anything. - The `search` method returns a boolean indicating whether the word or pattern matches any word in the data structure. 4. **Constraints**: - `1 <= word.length <= 500` - All words will only contain lowercase English letters. - Maximum of 3 * 10^4 calls will be made to both `add_word` and `search`. # Example ```python dictionary = WordDictionary() dictionary.add_word(\\"bad\\") dictionary.add_word(\\"dad\\") dictionary.add_word(\\"mad\\") assert dictionary.search(\\"pad\\") == False # False assert dictionary.search(\\"bad\\") == True # True assert dictionary.search(\\".ad\\") == True # True assert dictionary.search(\\"b..\\") == True # True ``` Complete the `WordDictionary` class by appropriately implementing the `add_word` and `search` methods.","solution":"class WordDictionary: def __init__(self): self.words = [] def add_word(self, word: str) -> None: self.words.append(word) def search(self, word: str) -> bool: import re # Replace \'.\' with regex \'.\' which matches any character pattern = re.compile(f\\"^{word}\\") for w in self.words: if pattern.match(w): return True return False"},{"question":"You are required to implement a function using an AVL tree structure to store integers that maintains self-balancing. The AVL tree should allow insertions while keeping the tree balanced to ensure efficient search operation. Additionally, implement an in-order traversal method to retrieve the elements in sorted order. Your task is to complete the missing parts of the given AVL Tree implementation. # Function Signature ```python class AvlTree: def __init__(self): # initialize the tree def insert(self, key: int): # insert a key into the AVL tree def in_order_traverse(self) -> list: # return the keys in the AVL tree in sorted order # TreeNode class is provided externally from tree.tree import TreeNode ``` # Input - An integer `key` for the `insert` method. - No input for the `in_order_traverse` method. # Output - The `in_order_traverse` method should return a list of integers sorted in ascending order. # Constraints - Assume no duplicate integers are inserted. - The `key` integer will lie within the range of -10<sup>4</sup> to 10<sup>4</sup>. # Scenario Consider a scenario where you need to quickly look up and insert integer data frequently, such as usage statistics or dynamic set of events. AVL tree, which self-balances with each insertion ensuring that lookup and insertion operations remain efficient, would be an optimal choice. # Performance Requirements - Both insertion and traversal must be performed in O(log n) time complexity. # Example ```python avl = AvlTree() numbers = [20, 4, 15, -3] for number in numbers: avl.insert(number) print(avl.in_order_traverse()) # Should output [-3, 4, 15, 20] ``` # Hints 1. Ensure the tree remains balanced after each insertion using necessary rotations. 2. Recompute height and balance factor after every insertion to maintain the AVL properties.","solution":"class TreeNode: def __init__(self, key): self.key = key self.left = None self.right = None self.height = 1 class AvlTree: def __init__(self): self.root = None def insert(self, key: int): if not self.root: self.root = TreeNode(key) else: self.root = self._insert(self.root, key) def in_order_traverse(self) -> list: result = [] self._in_order_traverse(self.root, result) return result def _insert(self, node, key): if not node: return TreeNode(key) if key < node.key: node.left = self._insert(node.left, key) else: node.right = self._insert(node.right, key) node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) balance = self._get_balance(node) # Left Left Case if balance > 1 and key < node.left.key: return self._right_rotate(node) # Right Right Case if balance < -1 and key > node.right.key: return self._left_rotate(node) # Left Right Case if balance > 1 and key > node.left.key: node.left = self._left_rotate(node.left) return self._right_rotate(node) # Right Left Case if balance < -1 and key < node.right.key: node.right = self._right_rotate(node.right) return self._left_rotate(node) return node def _in_order_traverse(self, node, result): if node: self._in_order_traverse(node.left, result) result.append(node.key) self._in_order_traverse(node.right, result) def _left_rotate(self, z): y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def _right_rotate(self, z): y = z.left T3 = y.right y.right = z z.left = T3 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def _get_height(self, node): if not node: return 0 return node.height def _get_balance(self, node): if not node: return 0 return self._get_height(node.left) - self._get_height(node.right)"},{"question":"A Red-Black Tree (RBTree) is a balanced binary search tree with distinct properties that ensure the tree remains balanced during insertions and deletions. You are required to implement certain functions to manipulate the RBTree. Specifically, you must: 1. Implement a function to determine if a given tree is a valid Red-Black Tree. 2. Implement a function to count the number of red nodes in the RBTree. 3. Implement a function to verify the Red-Black Tree properties after each insertion and deletion operation. # Function Descriptions 1. **is_valid_rbtree(root: RBNode) -> bool** * This function should determine if a given tree rooted at `root` is a valid Red-Black Tree. * **Input**: The root node of the tree. * **Output**: Boolean `True` if the tree is valid, otherwise `False`. 2. **count_red_nodes(root: RBNode) -> int** * This function should count and return the number of red nodes in the tree rooted at `root`. * **Input**: The root node of the tree. * **Output**: Integer count of red nodes. 3. **verify_properties(root: RBNode) -> bool** * This function should verify if the given tree rooted at `root` maintains all the properties of a Red-Black Tree. * **Input**: The root node of the tree. * **Output**: Boolean `True` if the tree maintains all the Red-Black Tree properties, otherwise `False`. # Constraints - Each node in the tree contains a value, left and right child references, parent reference, and a color indicator (1 for red and 0 for black). - The input tree may have up to 10^4 nodes. - Input values are guaranteed to be distinct integers. # Example ```python # Example Node Definition class RBNode: def __init__(self, val, is_red, parent=None, left=None, right=None): self.val = val self.parent = parent self.left = left self.right = right self.color = is_red # Tree Construction for Testing root = RBNode(10, 0) root.left = RBNode(5, 1, root) root.right = RBNode(15, 1, root) root.left.left = RBNode(2, 0, root.left) root.left.right = RBNode(8, 0, root.left) # Expected Outputs print(is_valid_rbtree(root)) #Expected: True print(count_red_nodes(root)) #Expected: 2 print(verify_properties(root)) #Expected: True ``` # Additional Notes - The provided code snippet already contains the implementation for the Red-Black Tree insertion and deletion. You should leverage this in implementing and testing the above functions. - Ensure thorough testing with edge cases such as an empty tree, tree with one node, fully balanced trees, and trees requiring multiple rotations.","solution":"class RBNode: def __init__(self, val, is_red, parent=None, left=None, right=None): self.val = val self.parent = parent self.left = left self.right = right self.color = is_red # 1 for red, 0 for black def is_valid_rbtree(root): Determine if a given tree is a valid Red-Black Tree. A valid Red-Black Tree should satisfy the following properties: 1. Every node is either red or black. 2. The root is black. 3. All leaves (NIL) are black. 4. If a red node has children then, the children are always black. 5. Every path from a node to its descendant NIL nodes has the same number of black nodes. if not root: # An empty tree is considered a valid Red-Black Tree return True def check_properties(node, black_count, path_black_count): if node is None: return path_black_count == -1 or black_count == path_black_count if node.color == 0: black_count += 1 elif node.color == 1: if node.left and node.left.color == 1 or node.right and node.right.color == 1: return False left_valid = check_properties(node.left, black_count, path_black_count) right_valid = check_properties(node.right, black_count, path_black_count) if node.left is None and node.right is None: if path_black_count == -1: path_black_count = black_count return black_count == path_black_count return left_valid and right_valid if root.color == 1: return False return check_properties(root, 0, -1) def count_red_nodes(root): Count the number of red nodes in the tree. if not root: return 0 left_red = count_red_nodes(root.left) right_red = count_red_nodes(root.right) return left_red + right_red + (1 if root.color == 1 else 0) def verify_properties(root): Verify if the given tree maintains all Red-Black Tree properties. return is_valid_rbtree(root)"},{"question":"**Sudoku Solver Challenge** You are given a 9x9 Sudoku board with some pre-filled values and empty cells designated by \\".\\". Your task is to write a function to solve this Sudoku puzzle by filling each empty cell with a number from \'1\' to \'9\'. Your solution must follow these rules: 1. Each row must contain the digits \'1\' to \'9\' without repetition. 2. Each column must contain the digits \'1\' to \'9\' without repetition. 3. Each of the nine 3x3 sub-grids must contain the digits \'1\' to \'9\' without repetition. You should implement the function using a depth-first search (DFS) and backtracking approach augmented with heuristics to optimize the performance. **Function Signature** ```python def solve_sudoku(board: List[List[str]]) -> None: Solves the Sudoku board in-place. Args: board (List[List[str]]): A 9x9 2D list representing the board with empty cells as \'.\'. ``` **Input Format** - `board`: A 9x9 grid with digits \'1\'-\'9\' and \'.\' for empty cells. **Output Format** - Modifies `board` in-place to a valid Sudoku solution. **Constraints** 1. `board` will be a valid Sudoku board with a solution. 2. Ensure the solution modifies the input board directly without any returns. **Example** ```python input_board = [ [\\"5\\",\\"3\\",\\".\\",\\".\\",\\"7\\",\\".\\",\\".\\",\\".\\",\\".\\"], [\\"6\\",\\".\\",\\".\\",\\"1\\",\\"9\\",\\"5\\",\\".\\",\\".\\",\\".\\"], [\\".\\",\\"9\\",\\"8\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\"], [\\"8\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\"3\\"], [\\"4\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\"3\\",\\".\\",\\".\\",\\"1\\"], [\\"7\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\".\\",\\".\\",\\".\\",\\"6\\"], [\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\"8\\",\\".\\"], [\\".\\",\\".\\",\\".\\",\\"4\\",\\"1\\",\\"9\\",\\".\\",\\".\\",\\"5\\"], [\\".\\",\\".\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\".\\",\\"7\\",\\"9\\"] ] solve_sudoku(input_board) print(input_board) # should print the solved Sudoku board ``` **Notes:** - Assume that the initial board does not violate Sudoku rules. - Focus on optimizing the time taken to reach the solution.","solution":"from typing import List def solve_sudoku(board: List[List[str]]) -> None: Solves the Sudoku board in-place. Args: board (List[List[str]]): A 9x9 2D list representing the board with empty cells as \'.\'. def is_valid(board, row, col, num): for i in range(9): if board[row][i] == num or board[i][col] == num: return False if board[row//3*3 + i//3][col//3*3 + i%3] == num: return False return True def solve(board): for i in range(9): for j in range(9): if board[i][j] == \'.\': for num in \'123456789\': if is_valid(board, i, j, num): board[i][j] = num if solve(board): return True board[i][j] = \'.\' return False return True solve(board)"},{"question":"# RSA Encryption Challenge You are tasked to implement the RSA encryption and decryption functions `encrypt` and `decrypt` using provided public and private keys. The RSA encryption system is an asymmetric cryptographic algorithm widely used for secure data transmission. **Encryption**: - Input: a number `data`, a public key component `e`, and a modulus `n`. - Output: the encrypted data as per the RSA algorithm. **Decryption**: - Input: the encrypted data, a private key component `d`, and the same modulus `n`. - Output: the original data. # Function Signatures ```python def encrypt(data: int, e: int, n: int) -> int: pass def decrypt(data: int, d: int, n: int) -> int: pass ``` # Requirements: 1. Implement the `encrypt` function that correctly encrypts the given data using the public key components. 2. Implement the `decrypt` function that correctly decrypts the encrypted data back to the original data using the private key components. 3. Use Python\'s built-in `pow()` function for fast modular exponentiation. # Example: ```python n, e, d = generate_key(16) data = 45 encrypted_data = encrypt(data, e, n) decrypted_data = decrypt(encrypted_data, d, n) assert decrypted_data == data # Should be True ``` # Note: - `generate_key(k)` function is provided to generate the RSA keys (public and private). It returns `(n, e, d)`. - Make sure to handle edge cases where the data is too large or the keys are too small. - Optimize for both time and space complexity where feasible. # Constraints: - ( 1 leq data leq 10^{12} ) - The bit length of keys ( k ) will be reasonably large to ensure security (typically 512 bits or more).","solution":"def encrypt(data: int, e: int, n: int) -> int: Encrypts the given data using the public key exponent e and modulus n. return pow(data, e, n) def decrypt(data: int, d: int, n: int) -> int: Decrypts the given data using the private key exponent d and modulus n. return pow(data, d, n)"},{"question":"# Scenario You have been asked to implement an algorithm for the classic Set Cover Problem. Your task is to find the subset of sets (from a given collection) that covers all elements of a given universe with minimal cost. Given two approaches, optimal (brute-force) and greedy (approximation), you need to demonstrate both and implement a test case to validate your solutions. # Task 1. **Optimal Set Cover**: Implement the `optimal_set_cover` function which uses a brute-force method to find the minimum cost set cover. 2. **Greedy Set Cover**: Implement the `greedy_set_cover` function which uses an approximate greedy algorithm. # Function Signatures ```python def optimal_set_cover(universe, subsets, costs): Args: universe (set of int): A set of integers representing the universe. subsets (dict of {str: set of int}): A dictionary where keys are subset names and values are sets of integers. costs (dict of {str: int}): A dictionary where keys are subset names and values are the costs associated with them. Returns: list of str: A list of subset names that form the minimum cost set cover. pass def greedy_set_cover(universe, subsets, costs): Args: universe (set of int): A set of integers representing the universe. subsets (dict of {str: set of int}): A dictionary where keys are subset names and values are sets of integers. costs (dict of {str: int}): A dictionary where keys are subset names and values are the costs associated with them. Returns: list of str: A list of subset names that form the minimum cost set cover. pass ``` # Example ```python universe = {1, 2, 3, 4, 5} subsets = {\'S1\': {4, 1, 3}, \'S2\': {2, 5}, \'S3\': {1, 4, 3, 2}} costs = {\'S1\': 5, \'S2\': 10, \'S3\': 3} optimal_cover = optimal_set_cover(universe, subsets, costs) print(\'Optimal Set Cover:\', optimal_cover) print(\'Optimal Cost:\', sum(costs[s] for s in optimal_cover)) greedy_cover = greedy_set_cover(universe, subsets, costs) print(\'Greedy Set Cover:\', greedy_cover) print(\'Greedy Cost:\', sum(costs[s] for s in greedy_cover)) ``` Expected Output: ``` Optimal Set Cover: [\'S2\', \'S3\'] Optimal Cost: 13 Greedy Set Cover: [\'S3\', \'S2\'] Greedy Cost: 13 ``` # Constraints - All elements in the universe and subsets are positive integers. - Costs are non-negative integers. - The length of the universe set and each subset can be between 1 and 100. - The number of subsets can be between 1 and 20. **Performance Requirements**: - The optimal algorithm should handle moderate-sized inputs efficiently. - The greedy algorithm should handle larger sized inputs with reasonable performance degradation.","solution":"import itertools def optimal_set_cover(universe, subsets, costs): Implements the brute-force optimal set cover. best_cover = None best_cost = float(\'inf\') subset_names = list(subsets.keys()) all_combinations = (comb for r in range(1, len(subset_names) + 1) for comb in itertools.combinations(subset_names, r)) for comb in all_combinations: combined_set = set() total_cost = 0 for subset_name in comb: combined_set |= subsets[subset_name] total_cost += costs[subset_name] if combined_set == universe and total_cost < best_cost: best_cover = comb best_cost = total_cost return list(best_cover) def greedy_set_cover(universe, subsets, costs): Implements the greedy approximation of the set cover. elements_to_cover = set(universe) chosen_subsets = [] while elements_to_cover: best_subset = None max_covered = 0 subset_name_to_remove = None for subset_name, subset in subsets.items(): covered_elements = len(subset & elements_to_cover) if covered_elements > max_covered: best_subset = subset best_subset_name = subset_name max_covered = covered_elements elements_to_cover -= best_subset chosen_subsets.append(best_subset_name) return chosen_subsets"},{"question":"**Comb Sort Implementation and Optimization** **Context:** Comb sort is an improved version of Bubble Sort that initially starts with a large gap between compared elements and reduces this gap in each pass. By doing so, it eliminates small values at the end of the list (turtle elements) much faster, making it more efficient than Bubble Sort in general. **Problem Statement:** Write a Python function `optimized_comb_sort(arr, shrink_factor)` that sorts a given list of integers `arr` using the Comb Sort algorithm. The function should also allow for the adjustment of the shrink factor to optimize performance. **Function Signature:** ```python def optimized_comb_sort(arr: List[int], shrink_factor: float = 1.3) -> List[int]: pass ``` **Input:** 1. `arr` (List[int]): A list of integers to be sorted. The list can contain up to `10^5` elements. 2. `shrink_factor` (float): Optional parameter that specifies the shrink factor for reducing the gap. Default is 1.3. **Output:** * Returns a sorted list of integers in ascending order. **Constraints:** * The shrink factor should be greater than 1 and typically up to around 2. * The function should handle edge cases such as empty lists, single-element lists, and already sorted/reverse sorted lists. * Ensure the sorting is efficient and optimizes time complexity where possible. **Examples:** ```python >>> optimized_comb_sort([20, -5, 7, 4, 1, -2]) [-5, -2, 1, 4, 7, 20] >>> optimized_comb_sort([5, 2, 9, 1, 5, 6], 1.5) [1, 2, 5, 5, 6, 9] >>> optimized_comb_sort([3]) [3] >>> optimized_comb_sort([]) [] ``` **Performance Requirements:** * Target average-case time complexity is O(N log N). * Ensure space complexity remains O(1), keeping the in-place property of the algorithm. **Hints:** * Test different shrink factors to see their impact on performance. * Carefully handle the gap reduction to maintain sorting efficiency.","solution":"from typing import List def optimized_comb_sort(arr: List[int], shrink_factor: float = 1.3) -> List[int]: Sorts the given list using the Comb Sort algorithm with an optional shrink factor. n = len(arr) gap = n swapped = True # Continue until the gap becomes 1 and no more swaps are done while gap != 1 or swapped: # Calculate the new gap gap = int(gap / shrink_factor) if gap < 1: gap = 1 swapped = False # Perform a single pass with the current gap for i in range(0, n - gap): if arr[i] > arr[i + gap]: arr[i], arr[i + gap] = arr[i + gap], arr[i] swapped = True return arr"},{"question":"Scenario You are tasked with developing a system that tracks and manages multiple time intervals (e.g., appointments, reserved slots). Users can add new intervals, and the system must automatically merge any overlapping intervals to maintain a clean and conflict-free schedule. Objective Implement a class `IntervalManager` that manages a list of intervals, providing functionalities to: 1. Add a new interval. 2. Merge overlapping intervals automatically. 3. Retrieve the current list of intervals after any modifications. Input and Output 1. **Function 1: add_interval** - **Input**: An interval specified by its start and end times (e.g., `add_interval(1, 5)`). - **Output**: None (modifies the internal state). 2. **Function 2: get_intervals** - **Input**: None. - **Output**: List of merged intervals in the form of tuples, sorted by start time (e.g., `[(1, 5), (10, 15)]`). Constraints * Intervals are specified by integer start and end times. * Overlapping intervals should be merged automatically on every addition. # Implementation Notes * Use the provided `Interval` class as part of your solution. * Optimize the add_interval operation to avoid unnecessary merges whenever possible. Example ```python # Creating an instance of IntervalManager manager = IntervalManager() # Adding intervals manager.add_interval(1, 5) manager.add_interval(10, 15) manager.add_interval(3, 7) # Getting the list of merged intervals print(manager.get_intervals()) # Output: [(1, 7), (10, 15)] ``` Your Implementation Implement the `IntervalManager` class accordingly. ```python class IntervalManager: def __init__(self): self.intervals = [] def add_interval(self, start, end): # Your implementation here def get_intervals(self): # Your implementation here ```","solution":"class IntervalManager: def __init__(self): self.intervals = [] def add_interval(self, start, end): new_intervals = [] added = False for interval in self.intervals: if end < interval[0]: if not added: new_intervals.append((start, end)) added = True new_intervals.append(interval) elif start > interval[1]: new_intervals.append(interval) else: start = min(start, interval[0]) end = max(end, interval[1]) if not added: new_intervals.append((start, end)) self.intervals = new_intervals def get_intervals(self): return self.intervals"},{"question":"Implement an Optimized Nearest Neighbor Algorithm **Context:** You are working on a machine learning project that involves classifying data points using the nearest neighbor algorithm. Given the limitations of the basic implementation provided, you need to optimize the algorithm to handle larger datasets more efficiently. **Problem Statement:** Implement an optimized version of the nearest neighbor algorithm that can efficiently handle larger datasets. You may use KD-Trees for this purpose. **Requirements:** 1. Write a function `kd_tree_insert` to insert points into a KD-Tree. 2. Write a function `kd_tree_nearest` to find the nearest neighbor using the KD-Tree. 3. Use these functions to implement `optimized_nearest_neighbor`. **Function Signatures:** ```python def kd_tree_insert(root, point, depth=0): pass def kd_tree_nearest(root, point, depth=0): pass def optimized_nearest_neighbor(x, tSet): pass ``` **Input/Output Format:** * `kd_tree_insert(root, point, depth=0)`: Inserts a point into the KD-Tree. * Input: `root`: Root node of the KD-Tree. `point`: A tuple representing the point to be inserted. `depth`: The current depth, used to determine which axis to split. * Output: None * `kd_tree_nearest(root, point, depth=0)`: Finds the nearest neighbor of the given point using the KD-Tree. * Input: `root`: Root node of the KD-Tree. `point`: A tuple representing the point for which the nearest neighbor is to be found. `depth`: The current depth, used to determine which axis to search. * Output: A tuple representing the nearest neighbor. * `optimized_nearest_neighbor(x, tSet)`: Finds the nearest neighbor using KD-Tree based optimization. * Input: `x`: A tuple representing the query point. `tSet`: A dictionary with points as keys and their classifications as values. * Output: The classification of the nearest neighbor. **Constraints:** * All input vectors are tuples of the same length. * The training set has at least one point. **Performance Requirements:** Your solution should handle a training set with up to 10,000 points efficiently. **Example:** ```python tSet = { (1, 2): \'A\', (3, 4): \'B\', (5, 6): \'A\', (7, 8): \'B\', } x = (4, 5) # Expected Output: \'B\' (the nearest neighbor is (3, 4)) result = optimized_nearest_neighbor(x, tSet) print(result) # Output: \'B\' ``` Provide your implementations for `kd_tree_insert`, `kd_tree_nearest`, and `optimized_nearest_neighbor`.","solution":"import math class KDTreeNode: def __init__(self, point, left=None, right=None): self.point = point self.left = left self.right = right def kd_tree_insert(root, point, depth=0): if root is None: return KDTreeNode(point) axis = depth % len(point) if point[axis] < root.point[axis]: root.left = kd_tree_insert(root.left, point, depth + 1) else: root.right = kd_tree_insert(root.right, point, depth + 1) return root def distance_squared(point1, point2): return sum((x - y) ** 2 for x, y in zip(point1, point2)) def kd_tree_nearest(root, point, depth=0, best=None, best_dist=float(\'inf\')): if root is None: return best axis = depth % len(point) here_dist = distance_squared(root.point, point) if here_dist < best_dist: best = root.point best_dist = here_dist diff = point[axis] - root.point[axis] close, away = (root.left, root.right) if diff < 0 else (root.right, root.left) best = kd_tree_nearest(close, point, depth + 1, best, best_dist) if abs(diff) < best_dist: best = kd_tree_nearest(away, point, depth + 1, best, distance_squared(point, best)) return best def optimized_nearest_neighbor(x, tSet): root = None for point in tSet: root = kd_tree_insert(root, point) nearest_point = kd_tree_nearest(root, x) return tSet[nearest_point]"},{"question":"# Coding Challenge **Problem Statement**: You are given a sorted array (in increasing order) of integer values. Your task is to find the index of the last occurrence of a given integer in the array. If the integer does not exist in the array, return -1. Implement the function `last_occurrence(array: List[int], query: int) -> int`. The function should utilize a binary search algorithm for efficient searching. **Input**: - `array`: A list of integers sorted in increasing order. - `query`: An integer value whose last occurrence\'s index needs to be found in the array. **Output**: - Return the index of the last occurrence of the `query` integer in the array. If the `query` integer is not present, return -1. **Constraints**: 1. The elements of the array are sorted in increasing order. 2. `array` contains at least one element. 3. Try to achieve O(log n) time complexity and O(1) space complexity. **Example**: ```python print(last_occurrence([1, 2, 3, 3, 3, 4, 5], 3)) # Output: 4 print(last_occurrence([5, 7, 7, 8, 8, 10], 8)) # Output: 4 print(last_occurrence([2, 4, 4, 4, 4, 5], 4)) # Output: 4 print(last_occurrence([2, 4, 6, 8, 10], 7)) # Output: -1 ``` **Edge Cases to Consider**: - The `array` is empty. (You may assume you won\'t need to handle this as per constraint #2). - `query` is not present in `array`. - All elements of `array` are equal to `query`. - `query` appears exactly once in `array`.","solution":"def last_occurrence(array, query): Finds the index of the last occurrence of query in the sorted array. Args: array (List[int]): A sorted list of integers. query (int): The integer value whose last occurrence\'s index needs to be found. Returns: int: The index of the last occurrence of query in the array, or -1 if it does not exist. left, right = 0, len(array) - 1 result = -1 while left <= right: mid = (left + right) // 2 if array[mid] == query: result = mid left = mid + 1 # Continue to search in the right half elif array[mid] < query: left = mid + 1 else: right = mid - 1 return result"},{"question":"# Interleaved Multilist Iterator You are tasked with designing an iterator that iterates over an arbitrary number of input lists in a round-robin fashion, returning elements in a \\"zigzag\\" manner. This means that the iterator should alternate between lists, yielding one element from each list at a time, and moving to the next list once the previous one has been exhausted. # Implementation Details: Implement a class `MultilistZigZagIterator` with the following methods: ```python class MultilistZigZagIterator: def __init__(self, lists: List[List[int]]): Initialize your data structure here. :param lists: List of lists to be iterated in a zigzag manner pass def next(self) -> int: :return: the next element in the iteration pass def has_next(self) -> bool: :return: True if there are still elements remaining in any of the lists, False otherwise pass ``` # Constraints: 1. The input is a list of lists containing integers. It can be any number of lists. 2. Each list may contain zero or more integers. 3. The `next` method should raise an exception if called when there are no more elements to return. # Example Usage: ```python lists = [[1, 2, 3], [4, 5, 6, 7], [8, 9]] iterator = MultilistZigZagIterator(lists) result = [] while iterator.has_next(): result.append(iterator.next()) print(result) # Example Output: [1, 4, 8, 2, 5, 9, 3, 6, 7] ``` # Additional Notes: - Ensure your implementation is efficient in terms of time complexity. - Consider edge cases such as empty lists or ones with different lengths. - Avoid modifying the original input lists within your methods.","solution":"from collections import deque from typing import List class MultilistZigZagIterator: def __init__(self, lists: List[List[int]]): Initialize your data structure here. :param lists: List of lists to be iterated in a zigzag manner # Filter out empty lists and create a deque of the remaining lists self.queues = deque([deque(lst) for lst in lists if lst]) def next(self) -> int: :return: the next element in the iteration if not self.has_next(): raise Exception(\\"No more elements\\") # Get the first non-empty list from the deque current_queue = self.queues.popleft() # Pop the first element from this list value = current_queue.popleft() # If the list still has elements, add it back to the deque if current_queue: self.queues.append(current_queue) return value def has_next(self) -> bool: :return: True if there are still elements remaining in any of the lists, False otherwise return bool(self.queues)"},{"question":"# Context Many file manipulation tools depend on resolving the correct paths of files and directories fed as input. For cross-platform compatibility and user convenience, it\'s crucial to convert any user-tildes and relative paths to canonical absolute paths. # Task Write a function `resolve_path(file: str) -> str` that normalizes and resolves a file path, performing the following operations: 1. Expands any user’s home directory shorthand (`~`). 2. Converts the path to an absolute path. # Requirements: * **Input**: A single string `file` representing a potentially relative file path, which may also include the user\'s home directory shorthand (`~`). * **Output**: A single string representing the canonical absolute path. # Example ```python # Given the file path \\"~/documents/workspace/project.txt\\" # Assuming the user\'s home directory is \\"/home/username\\" resolve_path(\\"~/documents/workspace/project.txt\\") # Should return \\"/home/username/documents/workspace/project.txt\\" # Given the relative path \\"../project_version\\" # Assuming the absolute path of the current working directory is \\"/home/username/documents\\" resolve_path(\\"../project_version\\") # Should return \\"/home/username/project_version\\" ``` # Constraints - Assume the input path string is at most 300 characters long. - The function should handle both Unix-like file paths and Windows file paths. - The function should raise a `ValueError` if the path is invalid or contains unsupported characters. # Edge Cases 1. Input file path is just the user\'s home directory (`\\"~\\"`) 2. Input file path is an empty string. 3. Input path with mixed or incorrect slashes/backslashes. 4. Paths with special directory names like `.` and `..`. Implement the function `resolve_path` with the above specifications.","solution":"import os import re def resolve_path(file: str) -> str: Resolves the given file path to an absolute canonical path. Expands user\'s home directory shorthand (`~`) and converts to an absolute path. Args: file (str): A potentially relative file path which may include `~`. Returns: str: The canonical absolute path. if not file or re.search(r\'[<>:\\"|?*]\', file): raise ValueError(\\"Invalid path\\") file = os.path.expanduser(file) file = os.path.abspath(file) return file"},{"question":"You are a software engineer managing a large dataset contained within a stack structure, which needs to be processed in pairs for a specific batch operation. To ensure correct processing and maintain execution efficiency, you need to design a function that switches successive pairs of numbers starting from the bottom of the stack. If the stack has an odd number of elements, the top element should remain unaltered. Implement a function `switch_pairs` that accepts a stack (represented as a list in Python) and accomplishes the specified pair switching. You are required to use one of the provided methods: either using an auxiliary stack or a queue for temporary storage. Function Signature ```python def switch_pairs(stack: list[int]) -> list[int]: ``` Input * `stack: list[int]`: A list of integers representing a stack where the last element of the list is the top of the stack. Output * `list[int]`: The stack after switching successive pairs starting from the bottom. Constraints * The function must handle both even and odd numbers of elements. * The stack may contain up to 10^5 elements. * The stack will not contain duplicate values. Example ```python # Example 1 stack = [3, 8, 17, 9, 1, 10] print(switch_pairs(stack)) # Output: [8, 3, 9, 17, 10, 1] # Example 2 stack = [3, 8, 17, 9, 1] print(switch_pairs(stack)) # Output: [8, 3, 9, 17, 1] ``` Requirements 1. Your solution must be efficient and handle large inputs within a reasonable time frame. 2. Consider edge cases such as an empty stack or a stack with a single element. 3. You may provide separate functions or integrate them into a single implementation to switch pairs using either an auxiliary stack or a queue. Evaluation Criteria * Correctness of the implementation * Efficiency in terms of time and space complexity * Proper handling of edge cases and constraints * Code clarity and readability","solution":"def switch_pairs(stack: list[int]) -> list[int]: This function switches successive pairs of numbers starting from the bottom of the stack. If the stack has an odd number of elements, the top element remains unaltered. from collections import deque aux_queue = deque() while stack: aux_queue.appendleft(stack.pop()) while aux_queue: first = aux_queue.popleft() if aux_queue: second = aux_queue.popleft() stack.append(second) stack.append(first) else: stack.append(first) return stack"},{"question":"# Missing Ranges Finder Consider an array of sorted unique integers and a specified low and high boundary. Your task is to find and return a list of ranges representing the missing intervals between the low and high boundaries (inclusive) that are not present in the array. Function Signature ```python def missing_ranges(arr: List[int], lo: int, hi: int) -> List[Tuple[int, int]]: ``` # Input - `arr` (List[int]): A sorted list of unique integers. (0 <= len(arr) <= 10^5, -10^9 <= arr[i] <= 10^9) - `lo` (int): The lower bound of the range to check. (-10^9 <= lo <= 10^9) - `hi` (int): The upper bound of the range to check. (-10^9 <= hi <= 10^9) # Output - List[Tuple[int, int]]: A list of tuples, where each tuple represents a missing range [a, b] in the inclusive interval [lo, hi]. # Constraints - The difference between `hi` and `lo` will be at most 10^5. - The input list `arr` is sorted in non-decreasing order and consists of unique elements. - Assume `lo <= hi`. # Performance Requirements - Your solution should execute in O(n) time complexity, where n is the length of `arr`. - Minimize additional space usage apart from the returned list. # Examples Example 1 ```python arr = [3, 5] lo = 1 hi = 10 # Expected Output: [(1, 2), (4, 4), (6, 10)] ``` Example 2 ```python arr = [] lo = 1 hi = 5 # Expected Output: [(1, 5)] ``` Example 3 ```python arr = [2, 3, 7, 8] lo = 1 hi = 10 # Expected Output: [(1, 1), (4, 6), (9, 10)] ``` # Hint Consider the cases where `arr` could be empty or cover the entire range completely. Handle the off-by-one errors particularly at the boundaries (inclusive ends).","solution":"from typing import List, Tuple def missing_ranges(arr: List[int], lo: int, hi: int) -> List[Tuple[int, int]]: missing_ranges_list = [] prev = lo - 1 for num in arr: if num > prev + 1: missing_ranges_list.append((prev + 1, num - 1)) prev = num if prev < hi: missing_ranges_list.append((prev + 1, hi)) return missing_ranges_list"},{"question":"# Coding Challenge Scenario: You are tasked with programming a robot to find all possible ways to navigate from the top-left corner to the bottom-right corner of a grid. The robot can only move right or down at any point in time. Problem Statement: Write a function `count_paths(m, n)` that returns the number of unique paths from the top-left corner to the bottom-right corner of an `m x n` grid. You can only move either down or right at any point in time. Input: - `m` (int): the number of rows in the grid. - `n` (int): the number of columns in the grid. Output: - Return an integer representing the number of unique paths from the top-left corner to the bottom-right corner of the grid. Constraints: - `1 <= m, n <= 100` Example: ```python def main(): m, n = map(int, input(\'Enter two positive integers: \').split()) result = count_paths(m, n) print(result) if __name__ == \'__main__\': main() ``` **Example Usage**: ``` Input: 3 3 Output: 6 Input: 1 5 Output: 1 ``` **Notes**: 1. You should initialize the grid `count` such that all entries in the first row and first column are `1`, because there\'s only one way to move to any cell in the first row (right) or the first column (down). 2. For each cell `[i][j]` in the grid that is not in the first row or column, its value should be calculated by summing the values of the cell directly above it (`[i-1][j]`) and the cell directly to the left of it (`[i][j-1]`).","solution":"def count_paths(m, n): Returns the number of unique paths from the top-left corner to the bottom-right corner of an m x n grid. Parameters: m (int): number of rows in the grid n (int): number of columns in the grid Returns: int: number of unique paths # Create a 2D array with dimensions m x n and initialize it with 0s dp = [[0]*n for _ in range(m)] # There\'s only one way to reach any cell in the first row or first column for i in range(m): dp[i][0] = 1 for j in range(n): dp[0][j] = 1 # Compute number of paths for other cells for i in range(1, m): for j in range(1, n): dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[m-1][n-1]"},{"question":"# Question: Implement a Deterministic Primality Test using Rabin-Miller Optimizations Problem Statement You are tasked to implement a deterministic version of the Rabin-Miller primality test for all integers in the range of 1 to 2^32 - 1. Given the constraints of the standard algorithm, your solution should handle edge cases and accurately determine the primality without relying on probabilistic methods. Input * An integer `n` (1 <= n <= 2^32 - 1) Output * Return `True` if `n` is prime, otherwise `False`. Constraints 1. The input integer `n` will always be in the range from 1 to 2^32 - 1. 2. The implementation should be deterministic and optimized for this range. Example ```python assert deterministic_is_prime(2) == True assert deterministic_is_prime(15) == False assert deterministic_is_prime(2**31 - 1) == True assert deterministic_is_prime(2**32 - 1) == False ``` Notes * Optimize your function for performance. * Use internal checks to optimize factorization of `n-1` efficiently. * Ensure modular arithmetic calculations handle large numbers accurately.","solution":"def deterministic_is_prime(n): if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False # Use 2, 3, 5, 7, 11, 13, 17 as bases for the Rabin-Miller primality test bases = [2, 3, 5, 7, 11, 13, 17] d, r = n - 1, 0 while d % 2 == 0: d //= 2 r += 1 def check_composite(a, d, n, r): x = pow(a, d, n) if x == 1 or x == n - 1: return False for _ in range(r - 1): x = pow(x, 2, n) if x == n - 1: return False return True for base in bases: if base > n - 2: continue if check_composite(base, d, n, r): return False return True"},{"question":"# Task Implement a function to compress a sequence of data using Run-Length Encoding (RLE). # Function Signature ```python def compress_rle(data: str) -> str: ``` # Input * `data` (str): A non-null string representing the sequence of data to be encoded. # Output * (str): A string representing the encoded data using RLE. # Requirements 1. Your function should handle different lengths of `data`, including empty strings. 2. Ensure the function correctly processes sequences of repeated characters. 3. The output should match the expected RLE format. # Example ```python assert compress_rle(\'aaabbc\') == \'3a2b1c\' assert compress_rle(\'\') == \'\' assert compress_rle(\'a\') == \'1a\' assert compress_rle(\'abcd\') == \'1a1b1c1d\' ``` Implement a function that decodes an RLE encoded string back to its original form. # Function Signature ```python def decompress_rle(data: str) -> str: ``` # Input * `data` (str): A non-null string representing the RLE encoded data. # Output * (str): A string representing the original decompressed data. # Requirements 1. Your function should handle valid and correctly formatted RLE encoded strings. 2. Ensure the function correctly processes sequences of counts followed by characters. 3. The output should match the expected original data. # Example ```python assert decompress_rle(\'3a2b1c\') == \'aaabbc\' assert decompress_rle(\'\') == \'\' assert decompress_rle(\'1a\') == \'a\' assert decompress_rle(\'1a1b1c1d\') == \'abcd\' ``` Your task is to implement both `compress_rle` and `decompress_rle` functions to meet the provided specifications.","solution":"def compress_rle(data: str) -> str: Compresses the data using Run-Length Encoding (RLE). Parameters: data (str): The input string to be compressed. Returns: str: The RLE compressed string. if not data: return \\"\\" compressed_parts = [] current_char = data[0] count = 1 for char in data[1:]: if char == current_char: count += 1 else: compressed_parts.append(f\\"{count}{current_char}\\") current_char = char count = 1 compressed_parts.append(f\\"{count}{current_char}\\") return \'\'.join(compressed_parts) def decompress_rle(data: str) -> str: Decompresses the RLE encoded data back to its original form. Parameters: data (str): The RLE encoded input string. Returns: str: The decompressed original string. if not data: return \\"\\" decompressed_chars = [] count = \\"\\" for char in data: if char.isdigit(): count += char else: decompressed_chars.append(char * int(count)) count = \\"\\" return \'\'.join(decompressed_chars)"},{"question":"# Question You are provided with a class `Graph` that uses DFS to compute the transitive closure of a directed graph. Your task is to extend the functionality of the `Graph` class to include a method that checks whether there exists a path between any given pair of vertices (source and destination). # Requirements 1. Implement a method `is_reachable(self, source, destination)` that returns `True` if there is a path from `source` to `destination`, and `False` otherwise. 2. Use the precomputed transitive closure matrix to determine reachability, ensuring an efficient O(1) lookup time. # Input and Output Formats * **Input**: - Integers `source` and `destination` representing the vertices between which reachability needs to be checked. * **Output**: - Return a boolean value indicating whether `destination` is reachable from `source`. # Constraints * Assume vertices are labeled as integers from 0 to V-1. * The graph may have up to 200 vertices. # Example ```python # Initialize graph with 4 vertices graph = Graph(4) graph.add_edge(0, 1) graph.add_edge(1, 2) graph.add_edge(2, 3) # Compute transitive closure closure = graph.transitive_closure() # Check reachability using the new method print(graph.is_reachable(0, 3)) # Output: True print(graph.is_reachable(3, 0)) # Output: False ``` # Implementation Skeleton You are provided with the following code to start with: ```python class Graph: This class represents a directed graph using adjacency lists def __init__(self, vertices): self.vertex_count = vertices self.graph = {} self.closure = [[0 for j in range(vertices)] for i in range(vertices)] def add_edge(self, source, target): if source in self.graph: self.graph[source].append(target) else: self.graph[source] = [target] def dfs_util(self, source, target): self.closure[source][target] = 1 for adjacent in self.graph[target]: if self.closure[source][adjacent] == 0: self.dfs_util(source, adjacent) def transitive_closure(self): for i in range(self.vertex_count): self.dfs_util(i, i) return self.closure # Add your implementation here def is_reachable(self, source, destination): pass ```","solution":"class Graph: This class represents a directed graph using adjacency lists def __init__(self, vertices): self.vertex_count = vertices self.graph = {} self.closure = [[0 for j in range(vertices)] for i in range(vertices)] def add_edge(self, source, target): if source in self.graph: self.graph[source].append(target) else: self.graph[source] = [target] def dfs_util(self, source, target): self.closure[source][target] = 1 for adjacent in self.graph.get(target, []): if self.closure[source][adjacent] == 0: self.dfs_util(source, adjacent) def transitive_closure(self): for i in range(self.vertex_count): self.dfs_util(i, i) return self.closure def is_reachable(self, source, destination): Returns True if there is a path from source to destination, and False otherwise. return self.closure[source][destination] == 1"},{"question":"# Strong Password Checker **Scenario**: A website you are developing has a signup page where users are required to input a name and a password. To ensure the security of your users, you want to enforce strong password policies. Specifically, you want to ensure that any password entered is strong according to the following criteria: 1. Its length is at least 6 characters. 2. It contains at least one digit (0-9). 3. It contains at least one lowercase English letter (a-z). 4. It contains at least one uppercase English letter (A-Z). 5. It contains at least one special character (!@#%^&*()-+). Given a password, write a function that calculates the minimum number of characters that must be added to make the password strong. **Function Signature**: ```python def strong_password(n: int, password: str) -> int: ``` **Input**: * An integer `n` representing the length of the password. * A string `password` representing the password input by the user. **Output**: * An integer representing the minimum number of characters that must be added to make the password strong. **Constraints**: * The password string only contains characters from within the set {a-z, A-Z, 0-9, and the special characters !@#%^&*()-+}. * 1 ≤ n ≤ 100 **Example**: ```python # Example 1 n = 3 password = \\"Ab1\\" # Because the current password is of length 3, three more characters are needed to meet the minimum length requirement, so the output should be 3. print(strong_password(n, password)) # Output: 3 # Example 2 n = 11 password = \\"#Algorithms\\" # The password is already of length 11, but it is missing a digit. Hence, only one more character is needed. print(strong_password(n, password)) # Output: 1 ``` **Explanation**: For any given password, your function should: 1. Identify which character types are missing. 2. Calculate how many characters need to be added to meet both the length and character type requirements. 3. Return the maximum of the count of missing types and the number needed to reach the minimum length of 6.","solution":"def strong_password(n: int, password: str) -> int: Calculate the minimum number of characters that must be added to make the password strong. Arguments: n -- Length of the password password -- The password in question Returns: An integer representing the minimum number of characters to be added. has_digit = any(c.isdigit() for c in password) has_lower = any(c.islower() for c in password) has_upper = any(c.isupper() for c in password) has_special = any(c in \\"!@#%^&*()-+\\" for c in password) missing_types = 0 if not has_digit: missing_types += 1 if not has_lower: missing_types += 1 if not has_upper: missing_types += 1 if not has_special: missing_types += 1 if n < 6: return max(missing_types, 6 - n) else: return missing_types"},{"question":"# Question You have been given a Python function `insertion_sort` that sorts an input list using the insertion sort algorithm. The current implementation sorts elements in non-decreasing order. Your task is to extend this function to support sorting in both ascending and descending orders based on an additional parameter `order`. Requirements: 1. Modify the function `insertion_sort` to include an additional boolean parameter `order`. If `order` is `True`, the function should sort the array in ascending order, and if `order` is `False`, the function should sort the array in descending order. 2. Ensure the function handles various types of input including: * Empty list. * Lists with all identical elements. * Lists with negative and floating-point numbers. 3. Maintain the \\"simulation\\" functionality as in the original function, which prints the array after each iteration of the outer loop if the `simulation` parameter is set to `True`. # Function Signature ```python def insertion_sort(arr: list, order: bool = True, simulation: bool = False) -> list: ``` # Input * `arr`: A list of numbers (can be integers or floating-point numbers). * `order`: A boolean where `True` implies ascending order and `False` implies descending order. * `simulation`: A boolean flag to print the array after each iteration for debugging purposes. # Output * Returns the sorted list as per the specified order. # Example ```python print(insertion_sort([4, 2, 5, 3, 1], order=True)) # Output: [1, 2, 3, 4, 5] print(insertion_sort([4, 2, 5, 3, 1], order=False)) # Output: [5, 4, 3, 2, 1] print(insertion_sort([3, 3, 3], order=True)) # Output: [3, 3, 3] print(insertion_sort([-1, -4, 2], order=False)) # Output: [2, -1, -4] ``` # Constraints * The input list can have up to (10^4) elements. * Elements in the list will be in the range ([-10^6, 10^6]). # Notes Implement error handling to ensure the function does not fail with invalid input scenarios.","solution":"def insertion_sort(arr: list, order: bool = True, simulation: bool = False) -> list: Sorts an array using the insertion sort algorithm. Parameters: arr (list): list of integers or floating-point numbers to sort. order (bool): True for ascending order, False for descending order. simulation (bool): If True, prints the array after each outer loop iteration. Returns: list: Sorted list in the specified order. length = len(arr) for i in range(1, length): key = arr[i] j = i - 1 if order: # Ascending order while j >= 0 and arr[j] > key: arr[j + 1] = arr[j] j -= 1 else: # Descending order while j >= 0 and arr[j] < key: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key if simulation: print(arr) return arr"},{"question":"# Question: First Occurrence Finder In a sorted array of integers arranged in increasing order, you are required to find the index of the first occurrence of a given target integer. **Function Signature:** ```python def first_occurrence(array: List[int], query: int) -> int: ``` # Input: - `array` (List[int]): A sorted array of integers in increasing order. - `query` (int): The target integer to find the first occurrence of. # Output: - `int`: The index of the first occurrence of the target in the array. If the target is not present, return `-1`. # Constraints: - The array will have at most 10^5 elements. - The array can include negative and positive integers. - The function should operate with a time complexity of O(log n). # Example: **Example 1:** ```python input: array = [1, 2, 4, 4, 4, 5, 6], query = 4 output: 2 ``` **Explanation:** The target 4 first occurs at index 2 in the array. **Example 2:** ```python input: array = [1, 2, 4, 5, 6], query = 3 output: -1 ``` **Explanation:** The target 3 does not exist in the array, so the function returns -1. # Edge Cases to Consider: 1. Array with only one element. 2. Target element not present in the array. 3. Array with all identical elements. 4. Target occurring at the beginning or end of the array. 5. Empty array should return -1. # Implementation: Implement the function with a binary search approach to ensure efficient performance.","solution":"from typing import List def first_occurrence(array: List[int], query: int) -> int: Find the index of the first occurrence of a given target integer in a sorted array. :param array: List[int] - A sorted array of integers in increasing order. :param query: int - The target integer to find the first occurrence of. :return: int - The index of the first occurrence of the target in the array. Returns -1 if the target is not present. low, high = 0, len(array) - 1 result = -1 while low <= high: mid = (low + high) // 2 if array[mid] == query: result = mid high = mid - 1 # Try to find a smaller index with the same value. elif array[mid] < query: low = mid + 1 else: high = mid - 1 return result"},{"question":"# Reverse Sentence Words - Challenge **Scenario**: Imagine you\'re working on a text editor that frequently needs to reverse the order of words in sentences. You have been tasked with writing a function to perform this operation efficiently. **Objective**: Implement a function `reverse_words_in_sentence` that receives a string input representing a sentence and returns the sentence with the words\' order reversed. **Function Signature**: ```python def reverse_words_in_sentence(sentence: str) -> str: pass ``` **Input**: - A single string `sentence` containing words separated by spaces. - Constraints: - 1 <= len(sentence) <= 10^5 - Words consist of printable ASCII characters except spaces. - There can be multiple spaces between words and leading/trailing spaces. **Output**: - A single string with the words\' order reversed, retaining only a single space between each word and no leading or trailing spaces. **Example**: ```python assert reverse_words_in_sentence(\\"I am keon kim and I like pizza\\") == \\"pizza like I and kim keon am I\\" assert reverse_words_in_sentence(\\" Hello World! \\") == \\"World! Hello\\" assert reverse_words_in_sentence(\\"singleWord\\") == \\"singleWord\\" ``` **Constraints**: - Your solution should handle multiple spaces and ensure there are no leading or trailing spaces in the output. - Aim for an O(n) time complexity solution. **Performance Requirements**: - The solution should efficiently handle sentences up to 100000 characters. **Notes**: 1. You should not use any built-in function that directly reverses the order of elements (e.g., Python `reversed()` on lists). **Hints**: - Consider breaking the sentence into manageable pieces (words) and reverse them in place.","solution":"def reverse_words_in_sentence(sentence: str) -> str: Reverse the order of words in a given sentence, ensuring only one space between words and no leading or trailing spaces. # Split the sentence into words, filtering out any empty strings caused by multiple spaces words = sentence.split() # Reverse the list of words reversed_words = words[::-1] # Join the reversed list of words into a single string with one space between each word reversed_sentence = \' \'.join(reversed_words) return reversed_sentence"},{"question":"You are required to implement a function that resolves relative file paths or paths including `~` to their absolute counterparts. The function must handle typical edge cases such as invalid paths and non-existent user directories. # Function Signature ```python def resolve_path(file_path: str) -> str: pass ``` # Input * `file_path` (str): A string representing the file path. It may include `~` to denote the home directory. # Output * Returns a string representing the full absolute path of the provided file path. # Constraints * Paths passed will be string of length between 1 and 4096. * The function should handle non-existent user or invalid path formats gracefully without breaking. # Example ```python # Example 1 resolve_path(\\"~/Documents/project\\") # Returns: \\"/home/username/Documents/project\\" or equivalent on different OS # Example 2 resolve_path(\\"relative/path/to/file\\") # Returns: The absolute path equivalent \\"/current/absolute/path/to/file\\" ``` # Notes - The function must handle paths with `~` and convert them correctly to the home directory paths. - It should also convert any relative paths to their absolute equivalents.","solution":"import os from pathlib import Path def resolve_path(file_path: str) -> str: Resolves a relative file path or a path including `~` to its absolute counterpart. Args: file_path (str): A string representing the file path. Returns: str: The resolved absolute path. # Use pathlib to handle home directory symbol properly absolute_path = Path(file_path).expanduser().resolve() return str(absolute_path)"},{"question":"# Matrix Chain Multiplication **Problem Statement**: Given an array `p` of size `n+1`, where the `i-th` element represents the number of rows in the `i-th` matrix and the `(i+1)-th` element represents the number of columns in the `i-th` matrix, write a function `optimal_matrix_chain_order(p)` to determine the minimum number of scalar multiplications needed to multiply the given chain of matrices together in the most efficient order. Additionally, implement a function `print_optimal_order(s, i, j)` that prints the optimal multiplication sequence using the solution matrix `s`. **Function Signature**: ```python def optimal_matrix_chain_order(p: List[int]) -> int: pass def print_optimal_order(s: List[List[int]], i: int, j: int) -> None: pass ``` **Inputs**: 1. `p`: A list of integers where `p[i]` represents the number of rows/columns of the matrices leading to a valid matrix multiplication sequence. The length of `p` will be `n+1` where `n` is the number of matrices. **Outputs**: 1. Return the minimum number of scalar multiplications needed. 2. Print the optimal order of multiplication in a readable format. **Constraints**: - `2 ≤ len(p) ≤ 100` - `1 ≤ p[i] ≤ 1000` **Example**: ```python # Given p = [30, 35, 15, 5, 10, 20, 25] # Output print(optimal_matrix_chain_order(p)) # Output: 15125 # Expected Output for optimal order \\"((A1( (A2A3) )((A4A5)A6)))\\" # Note: The actual format may vary but should reflect the correct order of operations. ``` Ensure that you consider edge cases while designing your solution and handle large inputs efficiently within the constraints provided.","solution":"from typing import List def optimal_matrix_chain_order(p: List[int]) -> int: n = len(p) - 1 # number of matrices m = [[0 for _ in range(n)] for _ in range(n)] s = [[0 for _ in range(n)] for _ in range(n)] for l in range(2, n + 1): # l is the chain length for i in range(n - l + 1): j = i + l - 1 m[i][j] = float(\'inf\') for k in range(i, j): q = m[i][k] + m[k+1][j] + p[i] * p[k+1] * p[j+1] if q < m[i][j]: m[i][j] = q s[i][j] = k return m[0][n-1], s def print_optimal_order(s: List[List[int]], i: int, j: int) -> str: if i == j: return f\\"A{i+1}\\" else: return f\\"({print_optimal_order(s, i, s[i][j])}{print_optimal_order(s, s[i][j] + 1, j)})\\""},{"question":"You are tasked with implementing an improved sorting algorithm to replace a slow sorting process in a legacy system. While considering the limitations and characteristics of the Exchange Sort, your goal is to develop a more efficient algorithm. The requirements are that the algorithm must: 1. Sort an array of integers in ascending order. 2. Provide better performance than the original Exchange Sort. 3. Be able to handle edge cases like empty arrays and arrays with duplicate elements. # Your Task Implement the **Quick Sort** algorithm, an efficient sorting algorithm with an average time complexity of (O(n log n)). # Function Signature ```python def quick_sort(arr): Sorts an array of integers in ascending order using the Quick Sort algorithm. Parameters: arr (list): A list of integers Returns: list: A sorted list of integers pass ``` # Input and Output Formats 1. **Input**: - An array `arr` of integers where (1 leq text{len(arr)} leq 10^5). - The elements of the array can be any integer within the 32-bit signed integer range. 2. **Output**: - Return the array sorted in ascending order. # Constraints - Avoid using Python\'s built-in sorting methods. - Focus on the efficiency and clarity of your implementation. # Example ```python # Example 1 input_arr = [34, 7, 23, 32, 5, 62] output_arr = quick_sort(input_arr) print(output_arr) # Output should be: [5, 7, 23, 32, 34, 62] # Example 2 input_arr = [] output_arr = quick_sort(input_arr) print(output_arr) # Output should be: [] # Example 3 input_arr = [1] output_arr = quick_sort(input_arr) print(output_arr) # Output should be: [1] ``` Good luck, and ensure your implementation is efficient and handles the edge cases correctly.","solution":"def quick_sort(arr): Sorts an array of integers in ascending order using the Quick Sort algorithm. Parameters: arr (list): A list of integers Returns: list: A sorted list of integers if len(arr) <= 1: return arr pivot = arr[len(arr) // 2] left = [x for x in arr if x < pivot] middle = [x for x in arr if x == pivot] right = [x for x in arr if x > pivot] return quick_sort(left) + middle + quick_sort(right)"},{"question":"**Problem Statement**: You are provided with an array of integers `arr`. Your task is to implement the Comb Sort algorithm to sort the array in non-decreasing order. Comb Sort is an optimization of Bubble Sort which uses a gap sequence to compare elements. **Function Signature**: ```python def comb_sort(arr: List[int]) -> List[int]: pass ``` **Input**: - `arr`: A list of integers which can be of any size (0 ≤ len(arr) ≤ 10^5). - The values of integers are within the range -10^6 to 10^6. **Output**: - A list of integers sorted in non-decreasing order. **Constraints**: - The implementation should optimize performance for both small and large datasets. - Your solution should be in-place with O(1) space complexity. - Ensure that the solution handles edge cases such as empty arrays gracefully. **Example**: ```python assert comb_sort([5, 3, 8, 4, 2]) == [2, 3, 4, 5, 8] assert comb_sort([]) == [] assert comb_sort([1]) == [1] assert comb_sort([3, 6, 1, 7, 2, 9]) == [1, 2, 3, 6, 7, 9] ``` **Performance Requirements**: - Your solution should run efficiently for large input sizes, ideally aiming for O(N log N) average time complexity. **Context**: Comb Sort is particularly useful in scenarios where the input array is moderately sized and an easy-to-implement sorting algorithm is desired. It improves over Bubble Sort by reducing the dependency on the worst-case scenario through the gap comparisons, leading to generally faster sorts.","solution":"def comb_sort(arr): Implementation of Comb Sort algorithm that sorts an array in non-decreasing order. def get_next_gap(gap): # Shrink gap by shrink factor 1.3, minimum gap is 1 gap = (gap * 10) // 13 if gap < 1: return 1 return gap n = len(arr) gap = n swapped = True while gap != 1 or swapped: gap = get_next_gap(gap) swapped = False for i in range(n - gap): if arr[i] > arr[i + gap]: arr[i], arr[i + gap] = arr[i + gap], arr[i] swapped = True return arr"},{"question":"# Comb Sort Implementation **Objective**: Write a function `comb_sort(arr)` that implements the Comb Sort algorithm. **Function Signature**: ```python def comb_sort(arr: List[int]) -> List[int]: ``` **Input**: * `arr` (List[int]): A list of integers to be sorted. 0 ≤ len(arr) ≤ 10^5, and -10^6 ≤ arr[i] ≤ 10^6. **Output**: * Returns a list of integers sorted in ascending order. **Constraints**: * The function should run in O(N log N) average time complexity. * Minimum additional space usage (in-place sorting). **Requirements**: * Ensure that the function handles edge cases such as: * Empty list. * List with one element. * List with duplicate elements. * Verify correct handling of the `gap` reduction to avoid infinite loops. * Consider optimization for early exit if the array becomes sorted before final iterations. **Example**: ```python assert comb_sort([34, 7, 23, 32, 5, 62]) == [5, 7, 23, 32, 34, 62] assert comb_sort([8, 4, 1, 56, 3, -44, 23, -6, 28, 0]) == [-44, -6, 0, 1, 3, 4, 8, 23, 28, 56] assert comb_sort([1, 1, 1, 1, 1]) == [1, 1, 1, 1, 1] assert comb_sort([]) == [] ``` Implement `comb_sort` following the requirements and edge cases outlined above.","solution":"from typing import List def comb_sort(arr: List[int]) -> List[int]: n = len(arr) gap = n shrink_factor = 1.3 sorted = False while not sorted: # Update gap value for next comb gap = int(gap // shrink_factor) if gap > 1: sorted = False else: gap = 1 sorted = True # A single \\"comb\\" over the input list i = 0 while i + gap < n: if arr[i] > arr[i + gap]: arr[i], arr[i + gap] = arr[i + gap], arr[i] sorted = False i += 1 return arr"},{"question":"# Scenario Alice loves solving problems involving DNA sequences. She has a collection of DNA sequences and wants to find out how often a smaller DNA pattern appears in these sequences. DNA sequences are essentially very large strings, and patterns can vary in length. Alice heard about the Knuth-Morris-Pratt (KMP) algorithm and wants to utilize it to solve her problem efficiently. # Task Given a large DNA sequence and a DNA pattern, your task is to implement a function that uses the Knuth-Morris-Pratt (KMP) algorithm to find all starting indices where the pattern appears in the sequence. # Function Signature ```python def dna_pattern_search(dna_sequence: str, dna_pattern: str) -> List[int]: Given a DNA sequence and a DNA pattern, return the list of starting indices in the sequence where the pattern matches using KMP algorithm. Args: dna_sequence (str): The DNA sequence to search within. dna_pattern (str): The DNA pattern to search for. Returns: List[int]: List of starting indices where the pattern matches in the sequence. Example: >>> dna_pattern_search(\'ACGTACGTGACG\', \'ACGT\') [0, 4] Constraints: - 0 <= len(dna_sequence) <= 10^6 - 0 <= len(dna_pattern) <= 10^6 Note: - If either dna_sequence or dna_pattern is an empty string, return an empty list. - The solution should have a linear time complexity O(N + M) where N is the length of dna_sequence and M is the length of dna_pattern. pass ``` # Requirements - Implement the function without using any built-in string search functions. - Ensure the function handles large inputs efficiently by adhering to the O(N + M) complexity. - Consider edge cases like empty strings and patterns longer than the sequence.","solution":"from typing import List def compute_lps(pattern: str) -> List[int]: Helper function that computes the Longest Prefix Suffix (LPS) array for KMP algorithm. lps = [0] * len(pattern) length = 0 # length of the previous longest prefix suffix i = 1 while i < len(pattern): if pattern[i] == pattern[length]: length += 1 lps[i] = length i += 1 else: if length != 0: length = lps[length - 1] else: lps[i] = 0 i += 1 return lps def dna_pattern_search(dna_sequence: str, dna_pattern: str) -> List[int]: Implement the KMP algorithm to find all starting indices where the pattern appears in the sequence. if not dna_sequence or not dna_pattern: return [] N = len(dna_sequence) M = len(dna_pattern) lps = compute_lps(dna_pattern) result = [] i = 0 # index for dna_sequence j = 0 # index for dna_pattern while i < N: if dna_pattern[j] == dna_sequence[i]: i += 1 j += 1 if j == M: result.append(i - j) j = lps[j - 1] elif i < N and dna_pattern[j] != dna_sequence[i]: if j != 0: j = lps[j - 1] else: i += 1 return result"},{"question":"Implement a Queue data structure that supports basic operations using two stacks. Function Definitions: - `class StackQueue`: The main class that includes the following methods: - `__init__(self)`: Initializes the data structure with two stacks. - `enqueue(self, item)`: Adds an item to the rear of the queue. - `dequeue(self)`: Removes and returns the front item from the queue. Should raise `IndexError` if the queue is empty. - `peek(self)`: Returns (without removing) the front item from the queue. Should raise `IndexError` if the queue is empty. - `is_empty(self)`: Returns `True` if the queue is empty, `False` otherwise. - `size(self)`: Returns the number of items in the queue. Constraints: - You must implement the queue operations `enqueue` and `dequeue` using the two stacks. - Operate within a reasonable time complexity for each method. Sample Usage: ```python q = StackQueue() q.enqueue(1) q.enqueue(2) q.enqueue(3) print(q.dequeue()) # Output: 1 print(q.peek()) # Output: 2 print(q.size()) # Output: 2 print(q.is_empty())# Output: False q.dequeue() q.dequeue() print(q.is_empty()) # Output: True ``` Additional Information: - Ensure your implementation properly handles edge cases and doesn\'t result in excessive time complexity. - Provide clear comments explaining any complex logic.","solution":"class StackQueue: def __init__(self): Initialize the two stacks used for the queue operations. self.stack1 = [] # Stack used for enqueue operations self.stack2 = [] # Stack used for dequeue operations def enqueue(self, item): Add an item to the rear of the queue. self.stack1.append(item) def dequeue(self): Remove and return the front item from the queue. Raises IndexError if the queue is empty. if self.is_empty(): raise IndexError(\\"dequeue from empty queue\\") # If stack2 is empty, transfer all elements from stack1 to stack2 if not self.stack2: while self.stack1: self.stack2.append(self.stack1.pop()) return self.stack2.pop() def peek(self): Return the front item from the queue without removing it. Raises IndexError if the queue is empty. if self.is_empty(): raise IndexError(\\"peek from empty queue\\") # If stack2 is empty, transfer all elements from stack1 to stack2 if not self.stack2: while self.stack1: self.stack2.append(self.stack1.pop()) return self.stack2[-1] def is_empty(self): Returns True if the queue is empty, False otherwise. return not self.stack1 and not self.stack2 def size(self): Returns the number of items in the queue. return len(self.stack1) + len(self.stack2)"},{"question":"You are required to implement a Binary Search Tree (BST) that supports dynamic data insertion, lookup, and traversal operations. Your implementation should ensure efficient average-case performance while handling edge cases appropriately. # Requirements 1. Implement the following operations: - **Insert(data)**: Inserts `data` into the BST. - **Search(data)**: Returns `True` if `data` exists in the BST, otherwise `False`. - **Size()**: Returns the total number of nodes in the BST. - **Traversal**: - **Preorder(root)**: Prints nodes in preorder traversal. - **Inorder(root)**: Prints nodes in inorder traversal. - **Postorder(root)**: Prints nodes in postorder traversal. # Input/Output Specifications - For this task, you will implement a class `BST` with the above methods. - Input methods: - `insert(data)` accepts an integer `data` to be inserted. - `search(data)` accepts an integer `data` to be searched. - `get_root()` returns the root node of the BST. - Traversal methods (`preorder`, `inorder`, `postorder`) print node values separated by a space. - `size()` returns the integer count of nodes in the BST. # Constraints - Insert and search operations should have an average time complexity of (O(log N)). - In-case of `Traversal`, the print output should be as expected for each traversal type. # Example ```python bst = BST() assert bst.size() == 0 bst.insert(10) bst.insert(5) bst.insert(15) bst.insert(3) bst.insert(7) bst.insert(13) bst.insert(17) assert bst.size() == 7 assert bst.search(7) == True assert bst.search(12) == False # Preorder Traversal: bst.preorder(bst.get_root()) # Output: 10 5 3 7 15 13 17 # Inorder Traversal: bst.inorder(bst.get_root()) # Output: 3 5 7 10 13 15 17 # Postorder Traversal: bst.postorder(bst.get_root()) # Output: 3 7 5 13 17 15 10 ```","solution":"class Node: def __init__(self, key): self.left = None self.right = None self.value = key class BST: def __init__(self): self.root = None self.node_count = 0 def insert(self, key): if self.root is None: self.root = Node(key) else: self._insert(self.root, key) self.node_count += 1 def _insert(self, node, key): if key < node.value: if node.left is None: node.left = Node(key) else: self._insert(node.left, key) else: if node.right is None: node.right = Node(key) else: self._insert(node.right, key) def search(self, key): return self._search(self.root, key) def _search(self, node, key): if node is None: return False if node.value == key: return True elif key < node.value: return self._search(node.left, key) else: return self._search(node.right, key) def size(self): return self.node_count def get_root(self): return self.root def preorder(self, node): if node is not None: print(node.value, end=\\" \\") self.preorder(node.left) self.preorder(node.right) def inorder(self, node): if node is not None: self.inorder(node.left) print(node.value, end=\\" \\") self.inorder(node.right) def postorder(self, node): if node is not None: self.postorder(node.left) self.postorder(node.right) print(node.value, end=\\" \\")"},{"question":"# AVL Tree Implementation and Verification **Objective**: Implement key operations on an AVL tree and verify its properties through in-order traversal. Your task is to implement the deletion operation on the AVL tree and ensure it maintains its balance property after deletion. # Requirements 1. **Implement the `delete` method** in the `AvlTree` class: - The method should remove a node with the specified key if it exists. - Ensure the tree remains balanced after the deletion using appropriate rotations. 2. **Input Format**: - You will receive operations in the form of a list of tuples. - Each tuple contains a string (\\"insert\\", \\"delete\\") and an integer (key). - Example: `[(\\"insert\\", 10), (\\"insert\\", 20), (\\"delete\\", 10), (\\"insert\\", 5)]` 3. **Output Format**: - After performing all operations, return the in-order traversal of the tree as a list of integers. - Example Output: `[5, 20]` # Constraints - Keys are unique positive integers. # Function Signature - Implement the method `def delete(self, key: int):` within the `AvlTree` class. - Implement a helper function `def process_operations(operations: List[Tuple[str, int]]) -> List[int]:` to initialize an AVL tree, process the operations, and return the in-order traversal result. # Example ```python # Assuming `AvlTree` class is defined as above with an added `delete` method def process_operations(operations): tree = AvlTree() for operation, key in operations: if operation == \\"insert\\": tree.insert(key) elif operation == \\"delete\\": tree.delete(key) return tree.in_order_traverse() # Example usage: operations = [(\\"insert\\", 10), (\\"insert\\", 20), (\\"delete\\", 10), (\\"insert\\", 5)] print(process_operations(operations)) # Output should be [5, 20] ``` # Note - Ensure your implementation handles balancing correctly after each delete operation to maintain AVL tree properties. - Handle edge cases such as deleting nodes that don’t exist or deletion causing multiple rotations.","solution":"class TreeNode: def __init__(self, key): self.key = key self.left = None self.right = None self.height = 1 class AvlTree: def __init__(self): self.root = None def insert(self, key): if not self.root: self.root = TreeNode(key) else: self.root = self._insert(self.root, key) def _insert(self, node, key): if not node: return TreeNode(key) elif key < node.key: node.left = self._insert(node.left, key) else: node.right = self._insert(node.right, key) node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) balance = self._get_balance(node) if balance > 1 and key < node.left.key: return self._right_rotate(node) if balance < -1 and key > node.right.key: return self._left_rotate(node) if balance > 1 and key > node.left.key: node.left = self._left_rotate(node.left) return self._right_rotate(node) if balance < -1 and key < node.right.key: node.right = self._right_rotate(node.right) return self._left_rotate(node) return node def delete(self, key): if not self.root: return self.root = self._delete(self.root, key) def _delete(self, node, key): if not node: return node elif key < node.key: node.left = self._delete(node.left, key) elif key > node.key: node.right = self._delete(node.right, key) else: if not node.left: return node.right elif not node.right: return node.left temp = self._get_min_value_node(node.right) node.key = temp.key node.right = self._delete(node.right, temp.key) node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) balance = self._get_balance(node) if balance > 1 and self._get_balance(node.left) >= 0: return self._right_rotate(node) if balance > 1 and self._get_balance(node.left) < 0: node.left = self._left_rotate(node.left) return self._right_rotate(node) if balance < -1 and self._get_balance(node.right) <= 0: return self._left_rotate(node) if balance < -1 and self._get_balance(node.right) > 0: node.right = self._right_rotate(node.right) return self._left_rotate(node) return node def _get_height(self, node): return node.height if node else 0 def _get_balance(self, node): return self._get_height(node.left) - self._get_height(node.right) if node else 0 def _right_rotate(self, y): x = y.left T2 = x.right x.right = y y.left = T2 y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) x.height = 1 + max(self._get_height(x.left), self._get_height(x.right)) return x def _left_rotate(self, x): y = x.right T2 = y.left y.left = x x.right = T2 x.height = 1 + max(self._get_height(x.left), self._get_height(x.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def _get_min_value_node(self, node): if node is None or node.left is None: return node return self._get_min_value_node(node.left) def in_order_traverse(self): result = [] self._in_order_traverse(self.root, result) return result def _in_order_traverse(self, node, result): if node: self._in_order_traverse(node.left, result) result.append(node.key) self._in_order_traverse(node.right, result) def process_operations(operations): tree = AvlTree() for operation, key in operations: if operation == \\"insert\\": tree.insert(key) elif operation == \\"delete\\": tree.delete(key) return tree.in_order_traverse()"},{"question":"Design and implement a `ChainedHashTable` class with separate chaining to resolve hash collisions instead of linear probing. In separate chaining, each bucket of the hash table is associated with a linked list of entries sharing the same hash index. Your implementation should provide the following functionalities: 1. **put(key, value)**: Add a new key-value pair to the map. If the key is already in the map, replace the old value with the new value. 2. **get(key)**: Given a key, return the value stored in the map or `None` if the key is not found. 3. **del(key)**: Delete the key-value pair from the map. 4. **len()**: Return the number of key-value pairs stored in the map. 5. **in**: Return `True` if the given key is in the map, `False` otherwise. Expected Input and Output: - **Input**: `key` is an integer, `value` can be any type. - **Output**: For `get`, return the value associated with the key, or `None` if the key is not found. For `del`, remove the key-value pair and return `None`. Constraints: 1. Your hash table should handle resizing when the load factor exceeds 0.75. 2. Ensure the operations are optimized for average-case O(1) time complexity. Performance Requirements: 1. Average-case time complexity for insertions, deletions, and lookups should be O(1). 2. The space complexity should be O(n), where n is the number of key-value pairs stored. # Example: ```python hash_map = ChainedHashTable() hash_map.put(1, \\"one\\") hash_map.put(2, \\"two\\") print(hash_map.get(1)) # Output: \\"one\\" print(hash_map.get(3)) # Output: None hash_map.put(1, \\"ONE\\") print(hash_map.get(1)) # Output: \\"ONE\\" hash_map.del(1) print(hash_map.get(1)) # Output: None print(len(hash_map)) # Output: 1 (Only key 2 is present) ``` # Instructions: 1. You must define a class named `ChainedHashTable`. 2. Implement the methods mentioned above. 3. Avoid using any built-in hash table methods or libraries for the main logic. 4. Ensure your solution is well tested with various cases including edge cases.","solution":"class ChainedHashTable: class Node: def __init__(self, key, value): self.key = key self.value = value self.next = None def __init__(self, capacity=10): self.capacity = capacity self.size = 0 self.table = [None] * capacity self.load_factor_threshold = 0.75 def _hash(self, key): return hash(key) % self.capacity def _resize(self): new_capacity = self.capacity * 2 new_table = [None] * new_capacity for i in range(self.capacity): node = self.table[i] while node: new_index = hash(node.key) % new_capacity new_node = self.Node(node.key, node.value) new_node.next = new_table[new_index] new_table[new_index] = new_node node = node.next self.capacity = new_capacity self.table = new_table def put(self, key, value): if self.size / self.capacity > self.load_factor_threshold: self._resize() index = self._hash(key) node = self.table[index] while node: if node.key == key: node.value = value return node = node.next new_node = self.Node(key, value) new_node.next = self.table[index] self.table[index] = new_node self.size += 1 def get(self, key): index = self._hash(key) node = self.table[index] while node: if node.key == key: return node.value node = node.next return None def delete(self, key): index = self._hash(key) node = self.table[index] prev_node = None while node: if node.key == key: if prev_node: prev_node.next = node.next else: self.table[index] = node.next self.size -= 1 return prev_node = node node = node.next def __len__(self): return self.size def __contains__(self, key): return self.get(key) is not None"},{"question":"**Problem Statement**: Write a function `next_bigger` that takes an integer `num` and finds the next higher number that has the exact same set of digits as `num`. If no such number exists (i.e., the given number is the highest possible permutation of its digits), return `-1`. **Function Signature**: ```python def next_bigger(num: int) -> int: ``` **Input**: * An integer `num` where `1 ≤ num ≤ 10^15`. **Output**: * An integer that represents the next higher permutation of `num`\'s digits, or `-1` if no such permutation exists. **Examples**: ```python next_bigger(38276) -> 38627 next_bigger(54321) -> -1 next_bigger(12345) -> 12354 next_bigger(999) -> -1 next_bigger(1528452) -> 1528524 ``` **Constraints/Performance Requirements**: * The function should handle large integers up to `10^15` efficiently. * The solution should have a time complexity of O(n) where n is the number of digits in the input integer. * The solution should use O(n) additional space for digit manipulation. **Scenario/Context**: Imagine you are designing a feature for a digital locker system that generates the next secure pin by rearranging the digits of the current pin. This algorithm will ensure that the next pin is as close as possible to the current pin but still larger. Write thorough test cases to validate your solution, including edge cases like single-digit integers, numbers with all identical digits, and numbers at their lexical maximum permutation.","solution":"def next_bigger(num: int) -> int: digits = list(str(num)) length = len(digits) # Step 1: Find the rightmost digit that is smaller than the digit next to it i = length - 2 while i >= 0 and digits[i] >= digits[i + 1]: i -= 1 # If no such digit is found, return -1 as the number is the highest permutation if i == -1: return -1 # Step 2: Find the smallest digit on right side of \'i\' which is greater than digits[i] j = length - 1 while digits[j] <= digits[i]: j -= 1 # Step 3: Swap digits[i] with digits[j] digits[i], digits[j] = digits[j], digits[i] # Step 4: Reverse the sequence after position \'i\' digits = digits[:i + 1] + digits[i + 1:][::-1] return int(\\"\\".join(digits))"},{"question":"Given a binary search tree (BST), you are required to implement the inorder traversal of this tree without using recursion. The function should return a list of values representing the inorder traversal. # Constraints: * The tree can contain 0 to 10000 nodes. * Each node has an integer value. * The returned list should be in ascending order for a binary search tree. # Input: * A binary tree represented by its root node. # Output: * A list of integers representing the inorder traversal of the binary tree. # Function Signature: ```python def iterative_inorder_traversal(root: Optional[Node]) -> List[int]: pass ``` # Example Consider the following binary search tree: ``` 4 / 2 6 / / 1 3 5 7 ``` For the above tree, the inorder traversal will be: [1, 2, 3, 4, 5, 6, 7]. Example Input: ```python root = Node(4) root.left = Node(2) root.right = Node(6) root.left.left = Node(1) root.left.right = Node(3) root.right.left = Node(5) root.right.right = Node(7) ``` Example Output: ```python [1, 2, 3, 4, 5, 6, 7] ``` You are to implement the `iterative_inorder_traversal` function that performs the required inorder traversal and returns the result as a list.","solution":"class Node: def __init__(self, value): self.value = value self.left = None self.right = None from typing import List, Optional def iterative_inorder_traversal(root: Optional[Node]) -> List[int]: Perform inorder traversal of a binary search tree iteratively and return a list of visited nodes. stack = [] result = [] current = root while stack or current: while current: stack.append(current) current = current.left current = stack.pop() result.append(current.value) current = current.right return result"},{"question":"# Scenario A fictional texting prediction application is being developed to suggest the next word a user might type. The application uses a Markov chain wherein the state transition probabilities are formed based on the frequency of word sequences from previous user messages. # Problem Implement a Python function `simulate_message(chain, start_state, length)` that generates a textual message of a given length based on a Markov chain model. The `chain` object is a dictionary representing state transitions, `start_state` is the initial word, and `length` is the desired length of the message. # Function Signature ```python def simulate_message(chain: dict, start_state: str, length: int) -> str: pass ``` # Input and Output * **Input**: * `chain`: A dictionary where keys are words (states) and values are dictionaries with subsequent words and their transition probabilities. * `start_state`: Initial word (string) to start the message. * `length`: Desired message length (integer). * **Output**: * A string representing the sequence of words generated based on the Markov chain. # Constraints * The `chain` dictionary is non-empty. * `start_state` exists in the `chain`. * `length` is a positive integer. * The transition probabilities for each state sum up to 1. # Example ```python chain = { \'I\': {\'love\': 0.1, \'like\': 0.9}, \'love\': {\'Python\': 1.0}, \'like\': {\'programming\': 0.4, \'Python\': 0.6}, \'programming\': {\'very\': 1.0}, \'very\': {\'much\': 1.0}, \'Python\': {\'is\': 0.5, \'rocks\': 0.5}, \'is\': {\'great\': 1.0}, \'rocks\': {\'.\': 1.0}, \'great\': {\'.\': 1.0}, \'.\': {} } start_state = \'I\' length = 5 simulate_message(chain, start_state, length) ``` # Expected Output A possible output string could be: `\'I like Python rocks .\'` # Performance Requirements * Handle linear selection time for state transitions up to reasonable input sizes. * Avoid infinite loops or non-termination issues.","solution":"import random def simulate_message(chain, start_state, length): Generates a message of a given length based on a Markov chain model. Parameters: chain (dict): Dictionary representing state transitions. start_state (str): Initial word to start the message. length (int): Desired message length. Returns: str: Generated sequence of words. current_state = start_state message = [current_state] for _ in range(length - 1): next_states = list(chain[current_state].items()) probabilities = [transition[1] for transition in next_states] next_state = random.choices([transition[0] for transition in next_states], probabilities)[0] message.append(next_state) current_state = next_state if current_state not in chain or not chain[current_state]: break return \' \'.join(message)"},{"question":"Bellman-Ford Algorithm with Path Reconstruction Context You are working for a navigation system company that requires accurate shortest path determination in various weighted graphs. The system must not only find the shortest paths but also detect if any negative-weight cycles exist. Problem Statement Implement the Bellman-Ford algorithm. Your implementation should include: 1. **Shortest Path Calculation**: Compute the shortest paths from a given source to all other nodes. 2. **Negative-weight Cycle Detection**: Identify if there is any negative-weight cycle in the graph. 3. **Path Reconstruction**: If there is no negative cycle, return the shortest path from the source to a given destination. Function Signature ```python def bellman_ford_with_path(graph, source, destination): Determines the shortest path from source to destination in the given graph. :param graph: dict, a dictionary where keys are nodes and values are dictionaries with keys as adjacent nodes and values as edge weights. :param source: str, the source node. :param destination: str, the destination node. :return: tuple, (bool, list) where the boolean indicates the presence of a negative cycle (True if no negative cycle, False if negative cycle exists). The list contains the shortest path from source to destination if no negative cycle exists, otherwise it is empty. pass ``` Input and Output - **Input**: - `graph`: A dictionary representing the weighted graph. Each key-value pair in the dictionary represents a node and its adjacent nodes with edge weights. - `source`, `destination`: Strings representing the source and destination nodes respectively. - **Output**: - A tuple where the first element is a boolean indicating the presence of a negative-weight cycle (True for no cycle, False otherwise). The second element is a list representing the shortest path from source to destination if no negative cycle exists. The list is empty if a negative cycle is detected. Example ```python graph = { \'a\': {\'b\': 6, \'e\': 7}, \'b\': {\'c\': 5, \'d\': -4, \'e\': 8}, \'c\': {\'b\': -2}, \'d\': {\'a\': 2, \'c\': 7}, \'e\': {\'b\': -3} } result = bellman_ford_with_path(graph, \'a\', \'d\') print(result) # Output should be (True, [\'a\', \'e\', \'b\', \'d\']) ``` Constraints * The graph can have negative weights but no negative-weight cycles for a valid path. * The graph is represented as a dictionary of dictionaries. * Assume unique keys for nodes. * Edge weights can be any integer.","solution":"def bellman_ford_with_path(graph, source, destination): Determines the shortest path from source to destination in the given graph. :param graph: dict, a dictionary where keys are nodes and values are dictionaries with keys as adjacent nodes and values as edge weights. :param source: str, the source node. :param destination: str, the destination node. :return: tuple, (bool, list) where the boolean indicates the presence of a negative cycle (True if no negative cycle, False if negative cycle exists). The list contains the shortest path from source to destination if no negative cycle exists, otherwise it is empty. # Initialize distances and predecessors distance = {node: float(\'inf\') for node in graph} predecessor = {node: None for node in graph} distance[source] = 0 # Relax edges repeatedly (|V| - 1 times) for _ in range(len(graph) - 1): for u in graph: for v in graph[u]: if distance[u] + graph[u][v] < distance[v]: distance[v] = distance[u] + graph[u][v] predecessor[v] = u # Check for negative-weight cycles for u in graph: for v in graph[u]: if distance[u] + graph[u][v] < distance[v]: return (False, []) # Negative-weight cycle detected # Reconstruct the shortest path from source to destination path = [] current = destination while current is not None: path.append(current) current = predecessor[current] path.reverse() if path[0] == source: return (True, path) return (True, [])"},{"question":"# Coding Assessment: Finding Pair Sum Indices Context: You are given a sorted array of integers. Your task is to implement a function that finds two distinct indices such that the numbers at these indices sum up to a given target. The array is sorted in ascending order and you can assume that there is exactly one solution. Requirements: * **Function Signature**: `def find_pair_sum_indices(numbers: List[int], target: int) -> List[int]:` * **Input**: - `numbers`: List of integers sorted in ascending order (1 ≤ len(numbers) ≤ 10^4). - `target`: The target sum as an integer. * **Output**: - Returns a list of two integers, which are indices of the `numbers` that add up to the `target` (1-based index, where index1 < index2). Constraints: * You may not use the same element twice. * The solution must have exactly one pair of indices that meet the criteria. * Aim to minimize time complexity. Examples: ```python find_pair_sum_indices([2, 7, 11, 15], 9) # Output: [1, 2] find_pair_sum_indices([1, 2, 3, 4, 5, 6], 11) # Output: [5, 6] find_pair_sum_indices([5, 10, 15, 22, 30], 25) # Output: [2, 3] ``` Notes: 1. Emphasize efficient handling of large input sizes. 2. Consider memory use if employing extra data structures. Hints: * Think about using two-pointer technique or exploring optimized hashing approaches. * Ensure proper handling of array bounds and indices.","solution":"from typing import List def find_pair_sum_indices(numbers: List[int], target: int) -> List[int]: left, right = 0, len(numbers) - 1 while left < right: current_sum = numbers[left] + numbers[right] if current_sum == target: # Return the indices in 1-based format return [left + 1, right + 1] elif current_sum < target: left += 1 else: right -= 1 # This return should never be reached according to the problem statement return []"},{"question":"# Matrix Path Product Calculation You are given a directed graph represented by its adjacency matrix. Each entry (i, j) in the matrix indicates the weight of the edge from vertex i to vertex j. Your task is to compute the maximum product of weights along any path of exactly `k` edges in this graph. Input * `adj_matrix`: A list of lists (2D matrix) representing the adjacency matrix of the graph. `adj_matrix[i][j]` is an integer representing the weight of the edge from vertex `i` to `vertex j`. A value of 0 indicates no direct edge between i and j. * `k`: An integer, the exact number of edges in the path. Output * An integer representing the maximum product of weights along any path composed of exactly `k` edges. Example ```python adj_matrix = [ [0, 2, 3], [0, 0, 4], [0, 0, 0] ] k = 2 # Maximum product path: 2 -> 1 -> 2 with product = 2 * 4 = 8 Output: 8 ``` Constraints * (1 leq n leq 100) where (n) is the number of vertices in the graph. * (1 leq k leq 1,000,000), which indicates the length of the path in terms of edge count. * All weights are non-negative integers. # Implementation Details * Ensure the implementation efficiently handles large `k` values using matrix exponentiation. * Consider using a helper function to multiply matrices with appropriate modifications for the product-based separation over addition.","solution":"def max_product_path(adj_matrix, k): Returns the maximum product of weights along any path composed of exactly `k` edges. n = len(adj_matrix) # Helper function to multiply two matrices def matrix_multiply(A, B): result = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): max_product = 0 for l in range(n): if A[i][l] != 0 and B[l][j] != 0: max_product = max(max_product, A[i][l] * B[l][j]) result[i][j] = max_product return result # Helper function to perform matrix exponentiation using binary exponentiation def matrix_power(matrix, exp): if exp == 1: return matrix elif exp % 2 == 0: half_power = matrix_power(matrix, exp // 2) return matrix_multiply(half_power, half_power) else: return matrix_multiply(matrix, matrix_power(matrix, exp - 1)) # Compute the maximum product matrix for exactly k edges result_matrix = matrix_power(adj_matrix, k) # Find the maximum product in the resultant matrix max_product = 0 for i in range(n): for j in range(n): max_product = max(max_product, result_matrix[i][j]) return max_product"},{"question":"Given two input binary strings `a` and `b`, write a function `add_binary(a, b)` that returns their sum as a binary string. # Input: * `a` and `b` are non-empty strings representing binary numbers. `a` and `b` can be arbitrarily long, up to 5000 characters each. # Output: * The function should return a string representing the binary sum of `a` and `b`. # Constraints: * Both input strings `a` and `b` will consist only of \'0\' or \'1\'. * Leading zeros in the input strings should be handled appropriately. * The output string should not have any leading zeros. # Examples: ```python assert add_binary(\\"11\\", \\"1\\") == \\"100\\" assert add_binary(\\"1010\\", \\"1011\\") == \\"10101\\" assert add_binary(\\"0\\", \\"0\\") == \\"0\\" assert add_binary(\\"110\\", \\"101\\") == \\"1011\\" ``` # Scenario: Imagine you are tasked with simulating the addition process of binary numbers in the backend of a cryptocurrency system. Accurate handling of binary arithmetic operations is crucial to the integrity of cryptocurrency transactions due to the nature of digital data processing. Your function will ensure accurate transactions by correctly summing binary values stored as strings.","solution":"def add_binary(a, b): i, j = len(a) - 1, len(b) - 1 carry = 0 result = [] while i >= 0 or j >= 0 or carry: sum_val = carry if i >= 0: sum_val += int(a[i]) i -= 1 if j >= 0: sum_val += int(b[j]) j -= 1 carry = sum_val // 2 result.append(str(sum_val % 2)) # The result array contains the binary digits in reverse order return \'\'.join(result[::-1])"},{"question":"You are working on optimizing storage and computation for large high-dimensional but sparse data vectors. A common operation you need to perform is the dot product between such vectors, which has numerous applications in fields like machine learning and scientific computing. Given two vectors in their sparse format represented as lists of tuples where each tuple contains the index and the corresponding non-zero value, you will write a function that calculates the dot product of these vectors. Function Signature ```python def sparse_vector_dot_product(vector1: List[Tuple[int, float]], vector2: List[Tuple[int, float]]) -> float: pass ``` # Inputs - `vector1`: A list of tuples representing the first sparse vector. Each tuple is of the form `(index, value)`, where `index` is an integer and `value` is a float. - `vector2`: A list of tuples representing the second sparse vector, similar in format to `vector1`. # Output - Returns a float representing the dot product of the two sparse vectors. # Constraints - The input vectors can be large, up to 10^6 elements in length. - The sparse representation will have significantly fewer elements compared to the original vectors\' length. - The indices within a vector are sorted in ascending order. - Values will be non-zero floating-point numbers. # Example Input ```python vector1 = [(0, 1.0), (2, 3.0), (3, 4.0)] vector2 = [(1, 2.0), (2, 3.0), (3, 1.0)] ``` Output ```python 13.0 ``` Explanation The dot product calculation proceeds as follows: ```python # Matching indices are 2 and 3 # vector1[2] * vector2[2] + vector1[3] * vector2[3] # 3.0 * 3.0 + 4.0 * 1.0 # 9.0 + 4.0 = 13.0 ``` # Instructions 1. Implement the `sparse_vector_dot_product` function. 2. Ensure the function handles edge cases efficiently, such as empty vectors or completely non-overlapping indices. 3. Optimize traversal using a two-pointer technique for efficiency given constraints.","solution":"from typing import List, Tuple def sparse_vector_dot_product(vector1: List[Tuple[int, float]], vector2: List[Tuple[int, float]]) -> float: Computes the dot product of two sparse vectors represented as lists of index-value tuples. if not vector1 or not vector2: return 0.0 i, j = 0, 0 dot_product = 0.0 while i < len(vector1) and j < len(vector2): index1, value1 = vector1[i] index2, value2 = vector2[j] if index1 == index2: dot_product += value1 * value2 i += 1 j += 1 elif index1 < index2: i += 1 else: j += 1 return dot_product"},{"question":"# Coding Challenge: Graph Traversal Objective: Implement advanced graph traversal algorithms that deeply analyze and comprehend a given graph\'s structure. Scenario: You are provided with an undirected graph represented as an adjacency list. You are required to implement two functions: 1. **Cycle Detection using DFS** - This will check if the graph contains any cycles. 2. **Shortest Path using BFS** - This will find the shortest path from a given start vertex to a target vertex. Requirements: 1. **DFS Cycle Detection**: Implement a function `detect_cycle(graph: dict, start: Any) -> bool` that returns `True` if there is a cycle in the graph, and `False` otherwise. **Function Signature**: ```python def detect_cycle(graph: dict, start: Any) -> bool: ``` 2. **BFS Shortest Path**: Implement a function `shortest_path(graph: dict, start: Any, target: Any) -> List[Any]` that returns the shortest path as a list of vertices. If there is no path, return an empty list. **Function Signature**: ```python def shortest_path(graph: dict, start: Any, target: Any) -> List[Any]: ``` Constraints: * The graph is provided as an adjacency list where the keys are node identifiers and the values are sets of connected node identifiers. * The graph can have up to 1,000 vertices and 5,000 edges. * The identifiers are unique and can be any hashable type. * You can assume graph nodes are comparable using `==`. Example: ```python graph = { 1: {2, 3}, 2: {1, 4}, 3: {1}, 4: {2, 5, 6}, 5: {4}, 6: {4} } # Cycle detection print(detect_cycle(graph, 1)) # Output: False # Shortest path print(shortest_path(graph, 1, 6)) # Output: [1, 2, 4, 6] ```","solution":"def detect_cycle(graph, start): visited = set() def dfs(node, parent): visited.add(node) for neighbor in graph[node]: if neighbor not in visited: if dfs(neighbor, node): return True elif neighbor != parent: return True return False for vertex in graph: if vertex not in visited: if dfs(vertex, None): return True return False from collections import deque def shortest_path(graph, start, target): if start not in graph or target not in graph: return [] queue = deque([(start, [start])]) visited = {start} while queue: current, path = queue.popleft() if current == target: return path for neighbor in graph[current]: if neighbor not in visited: visited.add(neighbor) queue.append((neighbor, path + [neighbor])) return []"},{"question":"# Comb Sort Implementation Comb Sort is an improvement over the Bubble Sort algorithm. It adds the concept of gap and reduces it over iterations, aiming to speed up the sorting process by moving elements further apart to their correct positions. **Task**: Write a `comb_sort` function to sort a list of integers in non-decreasing order. Function Signature ```python def comb_sort(arr: List[int]) -> List[int]: ``` Input: - `arr`: A list of integers Output: - Returns a list of integers sorted in ascending order. Constraints: - `0 <= len(arr) <= 10^6` - `-10^9 <= arr[i] <= 10^9` for each integer `arr[i]` Requirements: - The algorithm should handle edge cases like empty arrays or arrays with only one element. - The solution should aim to be optimized for average-case scenarios. Example: ```python # Example 1 input_array = [34, -50, 42, 0, 13, -5, 60, -10] output = comb_sort(input_array) print(output) # Output should be: [-50, -10, -5, 0, 13, 34, 42, 60] # Example 2 input_array = [1, 2, 3, 4, 5] output = comb_sort(input_array) print(output) # Output should be: [1, 2, 3, 4, 5] ``` Hints: 1. Ensure the shrink factor and gap is calculated correctly to avoid infinite loops. 2. Handle edge cases like empty or single element lists gracefully. 3. The function should sort in place and then return the sorted list. # Note: Do not rely on external libraries and ensure the solution adheres to the constraints defined.","solution":"def comb_sort(arr): Sorts a list of integers using the Comb Sort algorithm. :param arr: List of integers to be sorted :return: Sorted list of integers def get_next_gap(gap): # Shrink factor of 1.3 gap = (gap * 10) // 13 if gap < 1: return 1 return gap n = len(arr) gap = n swapped = True while gap != 1 or swapped: gap = get_next_gap(gap) swapped = False for i in range(0, n - gap): if arr[i] > arr[i + gap]: arr[i], arr[i + gap] = arr[i + gap], arr[i] swapped = True return arr"},{"question":"You are given a class `TreeNode` representing a node in a binary search tree. Your task is to implement a class `BinarySearchTree` and its methods to support the following operations: 1. `insert(val: int)`: Insert the node with value `val` into the BST. 2. `delete(val: int)`: Delete the node with value `val` from the BST. 3. `contains(val: int) -> bool`: Check whether the BST contains a node with value `val`. 4. `in_order_traversal() -> List[int]`: Return a list of all values in the BST sorted in ascending order. # Constraints * The tree can contain any integer values. * Operations on the tree should attempt to maintain a balance. # Example ```python # Example usage: bst = BinarySearchTree() bst.insert(5) bst.insert(3) bst.insert(7) bst.insert(2) assert bst.in_order_traversal() == [2, 3, 5, 7] bst.delete(3) assert bst.in_order_traversal() == [2, 5, 7] assert bst.contains(5) == True assert bst.contains(3) == False ``` # Function Signatures ```python class BinarySearchTree: def __init__(self): # Initialize your data structure here. pass def insert(self, val: int) -> None: # Implement the insert operation. pass def delete(self, val: int) -> None: # Implement the delete operation. pass def contains(self, val: int) -> bool: # Implement the contains operation. pass def in_order_traversal(self) -> List[int]: # Implement the in-order traversal. pass ``` # Notes * Focus on the correct implementation of these methods, and ensure your data structure maintains the BST properties. * Analyze edge cases such as inserting or deleting from an empty tree, and deleting nodes with different configurations (like having one child or two children). * Consider implementing helper functions to assist with maintaining clarity in your code.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BinarySearchTree: def __init__(self): self.root = None def insert(self, val: int) -> None: if not self.root: self.root = TreeNode(val) else: self._insert(self.root, val) def _insert(self, node, val): if val < node.val: if node.left is None: node.left = TreeNode(val) else: self._insert(node.left, val) else: if node.right is None: node.right = TreeNode(val) else: self._insert(node.right, val) def delete(self, val: int) -> None: self.root = self._delete(self.root, val) def _delete(self, node, val): if not node: return None if val < node.val: node.left = self._delete(node.left, val) elif val > node.val: node.right = self._delete(node.right, val) else: if not node.left: return node.right elif not node.right: return node.left min_larger_node = self._get_min(node.right) node.val = min_larger_node.val node.right = self._delete(node.right, min_larger_node.val) return node def _get_min(self, node): current = node while current.left is not None: current = current.left return current def contains(self, val: int) -> bool: return self._contains(self.root, val) def _contains(self, node, val): if not node: return False if val == node.val: return True elif val < node.val: return self._contains(node.left, val) else: return self._contains(node.right, val) def in_order_traversal(self) -> list[int]: result = [] self._in_order_traversal(self.root, result) return result def _in_order_traversal(self, node, result): if node: self._in_order_traversal(node.left, result) result.append(node.val) self._in_order_traversal(node.right, result)"},{"question":"# Bucket Sort Optimization Challenge You are tasked with optimizing the Bucket Sort algorithm provided. The existing algorithm utilizes Insertion Sort for sorting the contents of each bucket. However, Insertion Sort may become inefficient for larger datasets. Your goal is to implement a more efficient sorting mechanism for the buckets while ensuring the overall functionality and stability of Bucket Sort. Requirements: 1. Implement the `optimized_bucket_sort` function that optimizes the existing bucket sort implementation. 2. Replace `next_sort` with a more efficient sorting algorithm (e.g., Merge Sort). Ensure that your chosen sort maintains stability. 3. Maintain the existing bucket distribution mechanism but optimize the index calculation to handle a broader range of values more efficiently. ```python def optimized_bucket_sort(arr): \'\'\' Optimized Bucket Sort Your implementation goes here \'\'\' # Implement the bucket sorting logic pass def merge_sort(arr): \'\'\' Merge Sort for sorting individual buckets \'\'\' # Implement merge sort logic pass ``` # Input - `arr`: A list of integers having length n (1 ≤ n ≤ 10^6) and each element in the range 0 to 10^6. # Output - Return a sorted list of integers. # Constraints - Efficiency is key due to potentially large input sizes. Example ```python print(optimized_bucket_sort([4, 2, 2, 8, 3, 3, 1])) # Output: [1, 2, 2, 3, 3, 4, 8] print(optimized_bucket_sort([56, 89, 12, 47, 25, 19, 92, 55])) # Output: [12, 19, 25, 47, 55, 56, 89, 92] ``` Good luck!","solution":"def optimized_bucket_sort(arr): if len(arr) == 0: return arr # Find the maximum value in the array to determine the number of buckets max_value = max(arr) size = max_value // len(arr) + 1 # Create buckets and distribute the elements buckets = [[] for _ in range(size)] for num in arr: index = num // len(arr) buckets[index].append(num) # Sort each bucket using merge sort and concatenate the results sorted_arr = [] for bucket in buckets: sorted_arr.extend(merge_sort(bucket)) return sorted_arr def merge_sort(arr): if len(arr) <= 1: return arr mid = len(arr) // 2 left_half = merge_sort(arr[:mid]) right_half = merge_sort(arr[mid:]) return merge(left_half, right_half) def merge(left, right): sorted_arr = [] i = j = 0 while i < len(left) and j < len(right): if left[i] <= right[j]: sorted_arr.append(left[i]) i += 1 else: sorted_arr.append(right[j]) j += 1 sorted_arr.extend(left[i:]) sorted_arr.extend(right[j:]) return sorted_arr"},{"question":"# Question You are tasked with implementing the K-Nearest Neighbors (KNN) classification algorithm. KNN is an extension of the nearest neighbor algorithm provided in the code snippets. Instead of returning the closest single neighbor, KNN will return the most common class among the \'k\' closest neighbors. Requirements: Write a function `knn_classifier(x, tSet, k)` where: - `x` is a tuple representing the test vector. - `tSet` is a dictionary where keys are tuples representing vectors and values are their corresponding class labels. - `k` is an integer representing the number of nearest neighbors to consider. The function should return the most common class label among the k nearest neighbors to the test vector `x`. Expected Input and Output - The function `knn_classifier(x, tSet, k)` should satisfy: * `x` is a tuple of numbers (length of vectors). * `tSet` is a non-empty dictionary where keys are tuples (vectors of the same length as `x`) and the values are class labels. * `k` is a positive integer (k <= len(tSet)). - **Input Example**: ```python test_vector = (1.5, 2.5) training_set = { (1.0, 2.0): \'A\', (2.0, 3.0): \'B\', (3.0, 4.0): \'A\' } k = 2 ``` - **Output Example**: ```python \'A\' ``` Constraints and Limitations: * You can assume that there will be unique distances among vectors, so there\'s no need to handle ties. * The function should handle potential edge cases such as empty training sets or vectors of unequal length through assertions. Performance Requirements: * The function should be efficient enough to handle reasonable sizes of training sets up to 10,000 vectors. # Solution ```python import math from collections import Counter def distance(x,y): assert len(x) == len(y), \\"The vectors must have the same length\\" sum = 0 for i in range(len(x)): sum += (x[i] - y[i]) ** 2 return math.sqrt(sum) def knn_classifier(x, tSet, k): assert isinstance(x, tuple) and isinstance(tSet, dict) assert k > 0 and k <= len(tSet) distances = [] for key in tSet: d = distance(x, key) distances.append((d, tSet[key])) distances.sort(key=lambda x: x[0]) nearest_neighbors = [label for _, label in distances[:k]] most_common_label = Counter(nearest_neighbors).most_common(1)[0][0] return most_common_label ```","solution":"import math from collections import Counter def distance(x, y): assert len(x) == len(y), \\"The vectors must have the same length\\" sum = 0 for i in range(len(x)): sum += (x[i] - y[i]) ** 2 return math.sqrt(sum) def knn_classifier(x, tSet, k): assert isinstance(x, tuple) and isinstance(tSet, dict) assert k > 0 and k <= len(tSet) distances = [] for key in tSet: d = distance(x, key) distances.append((d, tSet[key])) distances.sort(key=lambda item: item[0]) nearest_neighbors = [label for _, label in distances[:k]] most_common_label = Counter(nearest_neighbors).most_common(1)[0][0] return most_common_label"},{"question":"# Context You are tasked with enhancing a traffic navigation system that relies on directed graphs to model the road network. Your goal is to implement additional functionality on top of an existing `DirectedGraph` class, which already supports basic node and edge additions. # Problem Statement **Objective**: You need to implement a method named `find_shortest_path` inside the `DirectedGraph` class. This method should find the shortest path between two given nodes using Dijkstra\'s algorithm. **Function Specification**: ```python def find_shortest_path(self, start_node, end_node): Finds the shortest path from start_node to end_node using Dijkstra\'s algorithm. Args: start_node (str): The name of the starting node. end_node (str): The name of the end node. Returns: List[str]: A list of node names representing the shortest path from start_node to end_node. If no path exists, return an empty list. pass ``` # Constraints 1. Each edge has an associated weight that represents the distance between nodes. You can use a dictionary to store these weights. 2. Nodes and edges will always have valid names. 3. You do not need to handle negative weights. 4. Assume all input node names exist in the graph. # Example Suppose we have the following weighted directed graph: ``` A -> B (1) A -> C (4) B -> C (2) B -> D (5) C -> D (1) ``` Calling `find_shortest_path(\'A\', \'D\')` should return `[\'A\', \'B\', \'C\', \'D\']`. # Solution Guidelines 1. **Initialize Data Structures**: You will need a priority queue to select the node with the smallest known distance at each step. 2. **Distance Dictionary**: Keep track of the shortest known distance to each node. 3. **Predecessor Dictionary**: Maintain predecessors to reconstruct the shortest path once you reach the end node. 4. **Priority Queue Operations**: Efficiently extract the node with the smallest distance and update neighbor distances.","solution":"import heapq class DirectedGraph: def __init__(self): self.adjacency_list = {} def add_node(self, node_name): if node_name not in self.adjacency_list: self.adjacency_list[node_name] = {} def add_edge(self, start_node, end_node, weight): if start_node in self.adjacency_list: self.adjacency_list[start_node][end_node] = weight else: self.adjacency_list[start_node] = {end_node: weight} def find_shortest_path(self, start_node, end_node): distances = {node: float(\'infinity\') for node in self.adjacency_list} distances[start_node] = 0 # Priority queue to keep track of nodes to visit priority_queue = [(0, start_node)] # Dictionary to keep track of the path predecessors = {node: None for node in self.adjacency_list} while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_distance > distances[current_node]: continue for neighbor, weight in self.adjacency_list[current_node].items(): distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance predecessors[neighbor] = current_node heapq.heappush(priority_queue, (distance, neighbor)) # Reconstruct the path path = [] current = end_node while current is not None: path.insert(0, current) current = predecessors[current] if distances[end_node] == float(\'infinity\'): return [] return path"},{"question":"# Insertion Sort Extension with a Custom Order Function Scenario You are tasked with extending the functionality of the Insertion Sort algorithm. The standard implementation sorts in ascending order. However, you need to make the algorithm flexible by allowing it to sort based on a custom order defined by a comparison function. # Problem Statement Your task is to implement an `advanced_insertion_sort` function that sorts an array based on a custom comparison function. The comparison function should take two parameters and return a positive number if the first parameter is greater, zero if they are equal, and a negative number if the first parameter is smaller. # Function Signature ```python def advanced_insertion_sort(arr, compare): Sorts arr using a custom comparison function. Args: - arr: list of elements to be sorted. - compare: custom comparison function. Returns: - list: sorted arr. # Example Custom Comparison Function def compare_ascending(x, y): return x - y def compare_descending(x, y): return y - x ``` Input * `arr`: List of elements (int or any comparable type). * `compare`: a comparison function that defines the sorting order. Output * Returns the sorted list based on the custom comparison function. Constraints * The list will contain up to 10^3 elements. * The elements in the list will be integers. * Comparison function will always return an integer. Performance * Must operate within O(n^2) time complexity and O(1) space complexity. Example ```python # ascending order print(advanced_insertion_sort([4, 3, 2, 1], compare_ascending)) # Output: [1, 2, 3, 4] # descending order print(advanced_insertion_sort([1, 2, 3, 4], compare_descending)) # Output: [4, 3, 2, 1] ```","solution":"def advanced_insertion_sort(arr, compare): Sorts arr using a custom comparison function. Args: - arr: list of elements to be sorted. - compare: custom comparison function. Returns: - list: sorted arr. for i in range(1, len(arr)): key = arr[i] j = i - 1 while j >= 0 and compare(arr[j], key) > 0: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key return arr # Example Custom Comparison Functions def compare_ascending(x, y): return x - y def compare_descending(x, y): return y - x"},{"question":"# Question: Longest Bitonic Subsequence You are given an unsorted array of integers. Your task is to find the length of the longest bitonic subsequence. A bitonic subsequence is a sequence which initially increases and then decreases. Implement the function `longest_bitonic_subsequence(arr: List[int]) -> int`. Input - `arr`: A list of integers. Output - An integer representing the length of the longest bitonic subsequence. Constraints - `1 <= len(arr) <= 1000` - `-10^4 <= arr[i] <= 10^4` # Examples 1. **Input**: [1, 11, 2, 10, 4, 5, 2, 1] **Output**: 6 **Explanation**: The longest bitonic subsequence is [1, 2, 10, 4, 2, 1]. 2. **Input**: [12, 11, 40, 5, 3, 1] **Output**: 5 **Explanation**: The longest bitonic subsequence is [12, 11, 5, 3, 1]. 3. **Input**: [80, 60, 30, 40, 20, 10] **Output**: 5 **Explanation**: The longest bitonic subsequence is [80, 60, 30, 20, 10]. # Notes - For this problem, a combination of Longest Increasing Subsequence (LIS) and Longest Decreasing Subsequence (LDS) helps in reaching the solution. - First compute LIS ending at each position using dynamic programming. - Then compute LDS starting from each position using dynamic programming. - The maximum length of the bitonic subsequence is then derived by considering both subsequences for each position.","solution":"from typing import List def longest_bitonic_subsequence(arr: List[int]) -> int: if not arr: return 0 n = len(arr) # Compute LIS (Longest Increasing Subsequence) for every index lis = [1] * n for i in range(1, n): for j in range(i): if arr[i] > arr[j] and lis[i] < lis[j] + 1: lis[i] = lis[j] + 1 # Compute LDS (Longest Decreasing Subsequence) for every index lds = [1] * n for i in range(n-2, -1, -1): for j in range(i+1, n): if arr[i] > arr[j] and lds[i] < lds[j] + 1: lds[i] = lds[j] + 1 # Calculate the maximum length of bitonic subsequence max_bitonic = 0 for i in range(n): max_bitonic = max(max_bitonic, lis[i] + lds[i] - 1) return max_bitonic"},{"question":"# Scenario: You are given the task of designing an efficient way to encode messages using RSA encryption technique. As part of this, you need to compute Euler\'s Totient Function for a key parameter in the system. You are required to implement the totient function to determine how many integers up to a given number n are coprime with it. This function will be an essential component of the RSA algorithm. # Task: Write a function `phi(n: int) -> int` which computes the Euler\'s Totient Function ϕ(n). # Input: - A single integer `n` (1 ≤ n ≤ 10^6). # Output: - Return an integer that represents the count of integers from 1 to n that are coprime with n. # Constraints: - The function should be efficiently implemented with a time complexity of O(√n). - Ensure that the function handles the edge cases correctly such as when n is 1. # Example: ```python assert phi(1) == 1 assert phi(5) == 4 # The numbers 1, 2, 3, 4 are coprime with 5 assert phi(10) == 4 # The numbers 1, 3, 7, 9 are coprime with 10 assert phi(25) == 20 # The numbers 1, 2, 3, 4, 6, 7, 8, 9, 11, 12, 13, 14, 16, 17, 18, 19, 21, 22, 23, 24 are coprime with 25 ``` Write the function `phi` to pass the given example cases and all other edge cases within the constraints mentioned.","solution":"def phi(n: int) -> int: Computes the Euler\'s Totient Function ϕ(n). It returns the count of integers from 1 to n that are coprime with n. if n == 1: return 1 result = n p = 2 while p * p <= n: if n % p == 0: while n % p == 0: n //= p result -= result // p p += 1 if n > 1: result -= result // n return result"},{"question":"**Problem Statement**: Given the provided `ResizableHashTable` implementation, enhance it by adding a method called `keys_with_prefix` that will return a list of all keys (as integers) that start with a given prefix. # Function Signature ```python def keys_with_prefix(self, prefix: str) -> list: Returns all keys (as integers) in the hash table that start with the given prefix. ``` # Expected Inputs and Outputs - **Input**: - `prefix` (str): The prefix to filter keys. - **Output**: - A list of integers representing the keys that start with the given prefix. # Constraints - Assume that all keys in the hash table are non-negative integers. - The prefix is guaranteed to be a string of digits. # Example ```python ht = ResizableHashTable() ht.put(123, \\"value1\\") ht.put(456, \\"value2\\") ht.put(1234, \\"value3\\") ht.put(1245, \\"value4\\") print(ht.keys_with_prefix(\\"12\\")) # Output: [123, 1234, 1245] print(ht.keys_with_prefix(\\"45\\")) # Output: [456] print(ht.keys_with_prefix(\\"67\\")) # Output: [] ``` # Requirements - Ensure that your implementation efficiently traverses over the keys in the hash table. - Handle the cases where there are deleted or empty slots in the hash table.","solution":"class ResizableHashTable: def __init__(self): self.capacity = 8 self.size = 0 self.keys = [None] * self.capacity self.values = [None] * self.capacity def _hash(self, key): return key % self.capacity def put(self, key, value): idx = self._hash(key) initial_idx = idx while self.keys[idx] is not None and self.keys[idx] != key: idx = (idx + 1) % self.capacity if idx == initial_idx: raise Exception(\\"HashTable is full\\") if self.keys[idx] is None: self.size += 1 self.keys[idx] = key self.values[idx] = value if self.size * 2 >= self.capacity: self._resize(self.capacity * 2) def get(self, key): idx = self._hash(key) initial_idx = idx while self.keys[idx] is not None: if self.keys[idx] == key: return self.values[idx] idx = (idx + 1) % self.capacity if idx == initial_idx: break return None def delete(self, key): idx = self._hash(key) initial_idx = idx while self.keys[idx] is not None: if self.keys[idx] == key: self.keys[idx] = None self.values[idx] = None self.size -= 1 return True idx = (idx + 1) % self.capacity if idx == initial_idx: break return False def _resize(self, new_capacity): old_keys = self.keys old_values = self.values self.capacity = new_capacity self.size = 0 self.keys = [None] * self.capacity self.values = [None] * self.capacity for key, value in zip(old_keys, old_values): if key is not None: self.put(key, value) def keys_with_prefix(self, prefix: str) -> list: Returns all keys (as integers) in the hash table that start with the given prefix. prefix_len = len(prefix) result = [] for key in self.keys: if key is not None and str(key).startswith(prefix): result.append(key) return result"},{"question":"# Coding Challenge: Bogo Sort Conceptual Implementation Context In this challenge, you are required to implement a simplified variant of the Bogo Sort algorithm. As you have studied, Bogo Sort is an inefficient sorting algorithm that sorts an array by repetitively shuffling it until it is sorted. However, for the sake of this exercise, your implementation must simulate the Bogo Sort algorithm but terminate after a predetermined number of shuffles if it does not sort the array, to avoid endless execution. Task Write a function `bogo_sort_limited(arr, max_shuffles)` that takes an array `arr` and an integer `max_shuffles`. The function should try to sort the array using the Bogo Sort method but should terminate after shuffling the array `max_shuffles` times if it is not sorted by then. Function Signature ```python def bogo_sort_limited(arr: List[int], max_shuffles: int) -> Tuple[List[int], bool]: ``` Input * `arr` - A list of integers. * `max_shuffles` - An integer representing the maximum number of shuffles allowed. Output * A tuple where: * The first element is the array after the last shuffle attempt. * The second element is a boolean indicating whether the array was successfully sorted within the given shuffle limit. Constraints * The length of the array `n` will be at most 10. * The elements in the array will be integers within the range from `-10^6` to `10^6`. * The `max_shuffles` value will be a positive integer no greater than 10000. Example ```python # Example 1: input_arr = [2, 3, 1] max_tries = 1000 result = bogo_sort_limited(input_arr, max_tries) print(result) # Expected Output: ([1, 2, 3], True) or might return (shuffled arr, False) depending on `max_tries`. # Example 2: input_arr = [1, 3, 2, 4] max_tries = 5 result = bogo_sort_limited(input_arr, max_tries) print(result) # Expected Output: (shuffled arr, False) - Highly probable as 5 tries may be insufficient. ```","solution":"import random from typing import List, Tuple def is_sorted(arr: List[int]) -> bool: Helper function to check if the array is sorted. return all(arr[i] <= arr[i + 1] for i in range(len(arr) - 1)) def bogo_sort_limited(arr: List[int], max_shuffles: int) -> Tuple[List[int], bool]: Bogo sort implementation with limited shuffles. :param arr: List of integers to be sorted :param max_shuffles: Maximum number of shuffles allowed :return: Tuple containing the shuffled array and a boolean indicating if it was sorted within the limit attempt = 0 while attempt < max_shuffles: if is_sorted(arr): return arr, True random.shuffle(arr) attempt += 1 return arr, is_sorted(arr)"},{"question":"# Question: Path Sum Checker in a Binary Tree You are given a binary tree and a target sum. Your task is to determine if the tree has a root-to-leaf path such that the sum of the node values along that path equals the given target sum. Write a function `check_path_sum(root, target_sum)` to solve this problem. Implement this function using at least one of the following methods, and explain your choice briefly: 1. Recursive Depth-First Search (DFS). 2. Iterative Depth-First Search (DFS) with Stack. 3. Iterative Breadth-First Search (BFS) with Queue. Function Signature: ```python def check_path_sum(root: TreeNode, target_sum: int) -> bool: # Your implementation here ``` # Input: * `root`: The root node of a binary tree. * `target_sum`: An integer representing the required path sum. # Output: * Return `True` if such a path exists, and `False` otherwise. # Constraints: * The number of nodes in the tree is in the range `[0, 10^4]`. * `-1000 <= Node.val <= 1000` * `-10^4 <= target_sum <= 10^4` # Example: ```python # Given the binary tree: # 5 # / # 4 8 # / / # 11 13 4 # / # 7 2 1 # target_sum = 22 # check_path_sum(root, 22) should return True, as the path 5->4->11->2 has a sum of 22. from your_module import check_path_sum root = TreeNode(5, left=TreeNode(4, left=TreeNode(11, left=TreeNode(7), right=TreeNode(2))), right=TreeNode(8, left=TreeNode(13), right=TreeNode(4, right=TreeNode(1)))) print(check_path_sum(root, 22)) # Output: True ``` # Notes: * You should handle edge cases such as an empty tree or negative values. * Ensure your implementation is efficient enough to handle the upper constraint limits.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def check_path_sum(root: TreeNode, target_sum: int) -> bool: if not root: return False # Using Recursive Depth-First Search (DFS) def dfs(node, current_sum): if not node: return False current_sum += node.val if not node.left and not node.right: # Check if it\'s a leaf node return current_sum == target_sum # Recursively check the left and right subtree return dfs(node.left, current_sum) or dfs(node.right, current_sum) return dfs(root, 0)"},{"question":"Objective: Implement a function to identify two unique elements in a list where every other element appears exactly twice. Detailed Prompt: You are given an array of integers, `nums`, where exactly two elements appear only once, and all other elements appear exactly twice. Your task is to identify and return the two elements that appear only once. # Function Signature: ```python def find_unique_elements(nums: List[int]) -> List[int]: pass ``` # Input Format: - A list of integers `nums` with a length between 2 and 3 * 10^4. - Each integer is between -3 * 10^4 and 3 * 10^4. # Output Format: - A list containing the two integers that appear only once in any order. # Constraints: - The solution must run in O(N) time complexity. - The solution must use O(1) additional space complexity. # Example: ```python assert find_unique_elements([1, 2, 1, 3, 2, 5]) in [[3, 5], [5, 3]] assert find_unique_elements([7, 1, 5, 7]) == [1, 5] ``` # Notes: - Ensure your solution handles varied input sizes and values correctly. - Consider performance and edge cases, and document your approach. Implementation Guidelines: 1. Utilize XOR to cancel out the pair elements and isolate the unique ones. 2. Use a single loop to find the XOR of all the elements. 3. Determine a distinct bit that differentiates the two unique numbers. 4. Use this bit to partition the numbers into two groups and isolate the unique numbers.","solution":"from typing import List def find_unique_elements(nums: List[int]) -> List[int]: # Step 1: XOR all the numbers together to get the XOR of the two unique numbers. xor = 0 for num in nums: xor ^= num # Step 2: Find a set bit (bit that is 1) in the xor result. This bit is different between # the two unique numbers. distinct_bit = xor & -xor # Step 3: Use the distinct bit to partition the numbers into two groups and XOR the numbers # in each group to find the unique numbers. num1 = num2 = 0 for num in nums: if num & distinct_bit: num1 ^= num else: num2 ^= num return [num1, num2]"},{"question":"# Problem: Implement a Circular Queue Objective You are tasked with implementing a Circular Queue which is a type of queue where the last position is connected back to the first position to make a circle. It uses a fixed-size array for storage and supports the operations: `enqueue`, `dequeue`, `peek`, `isEmpty`, and `size`. Requirements 1. **Initialization**: The circular queue must support initialization with a predefined capacity. 2. **Enqueue Operation**: Adds an element to the queue. If the queue is full, it should raise an error. 3. **Dequeue Operation**: Removes and returns the front element of the queue. If the queue is empty, it should raise an error. 4. **Peek Operation**: Returns the front element without removing it. If the queue is empty, it should raise an error. 5. **isEmpty Function**: Returns `True` if the queue is empty, `False` otherwise. 6. **size Function**: Returns the number of elements in the queue. Input/Output Formats * **Input**: * `CircularQueue(int capacity)` - Constructs a CircularQueue with a specified capacity. * `enqueue(int value)` - Enqueues an integer value to the rear of the queue. * `dequeue()` - Dequeues the front element of the queue. * `peek()` - Returns the front element without dequeuing it. * `isEmpty()` - Returns `True` if the queue is empty, otherwise `False`. * `size()` - Returns the number of elements present in the queue. * **Output**: * For `enqueue` and `dequeue`: No output, but actions are performed on the queue. * For `peek`: Returns the front element. * For `isEmpty`: Returns a boolean value. * For `size`: Returns an integer. Constraints 1. Capacity of the queue will be a positive integer. 2. Each value enqueued will be an integer. 3. Methods should be optimized for performance. Notes 1. Handle edge conditions for an empty queue for `dequeue` and `peek` operations. 2. Ensure no overflow occurs when adding or removing elements. 3. When full, the queue should raise an appropriate error in `enqueue`. 4. Aim for O(1) time complexity for all operations. Testing * Ensure you test with an empty queue, a full queue, and typical operations scenarios.","solution":"class CircularQueue: def __init__(self, capacity): self.capacity = capacity self.queue = [None] * capacity self.front = 0 self.rear = -1 self.count = 0 def enqueue(self, value): if self.isFull(): raise IndexError(\\"Queue is full\\") self.rear = (self.rear + 1) % self.capacity self.queue[self.rear] = value self.count += 1 def dequeue(self): if self.isEmpty(): raise IndexError(\\"Queue is empty\\") value = self.queue[self.front] self.queue[self.front] = None # Not necessary, but helps in debugging self.front = (self.front + 1) % self.capacity self.count -= 1 return value def peek(self): if self.isEmpty(): raise IndexError(\\"Queue is empty\\") return self.queue[self.front] def isEmpty(self): return self.count == 0 def isFull(self): return self.count == self.capacity def size(self): return self.count"},{"question":"You are tasked with determining the reachability of nodes in a directed graph using the transitive closure concept. Implement a function that takes the number of vertices and a list of directed edges, and returns the transitive closure matrix of the directed graph. # Function Signature ```python def find_transitive_closure(num_vertices: int, edges: List[Tuple[int, int]]) -> List[List[int]]: ``` # Input - `num_vertices`: An integer representing the number of vertices (V) in the graph. - `edges`: A list of tuples where each tuple (a, b) represents a directed edge from vertex `a` to vertex `b`. # Output - Returns a 2D list (matrix) representing the transitive closure of the graph. The matrix should be of size VxV where matrix[i][j] is 1 if there\'s a path from vertex `i` to vertex `j`, and 0 otherwise. # Constraints - All vertices are labeled from `0` to `num_vertices - 1`. - 1 <= num_vertices <= 100 (You can assume reasonable constraints for testing purposes). - 0 <= len(edges) <= num_vertices*(num_vertices-1) # Example ```python vertices = 4 edges = [(0, 1), (1, 2), (2, 3), (3, 1)] # The expected output will show reachability in a graph with defined edges. expected_matrix = [ [1, 1, 1, 1], [0, 1, 1, 1], [0, 1, 1, 1], [0, 1, 1, 1] ] assert find_transitive_closure(vertices, edges) == expected_matrix ``` # Explanation In the example, all vertices can reach other vertices directly or indirectly in the graph, hence the resultant transitive closure matrix shows `1` wherever there is a path. # Notes 1. Ensure you handle edge cases like self-loops, no edges, and cyclic graphs. 2. Consider how you\'ll represent and traverse the graph using adjacency lists for a more efficient traversal process. 3. Optimize and test for scalability within the given constraints.","solution":"from typing import List, Tuple def find_transitive_closure(num_vertices: int, edges: List[Tuple[int, int]]) -> List[List[int]]: # Initialize the transitive closure matrix with 0s closure = [[0] * num_vertices for _ in range(num_vertices)] # Every vertex can reach itself, so set the diagonal to 1s for i in range(num_vertices): closure[i][i] = 1 # Populate the closure matrix based on direct edges for (u, v) in edges: closure[u][v] = 1 # Apply Floyd-Warshall algorithm to compute transitive closure for k in range(num_vertices): for i in range(num_vertices): for j in range(num_vertices): closure[i][j] = closure[i][j] or (closure[i][k] and closure[k][j]) return closure"},{"question":"You are tasked to design a function that converts a given file path into an absolute path, validating its correctness by checking if the path actually exists on the system. This will help ensure the file paths used in your application are both absolute and valid, preventing runtime errors due to missing files. # Function Signature ```python def get_valid_absolute_path(file: str) -> str: pass ``` # Input - A string `file` representing a file path. This path may be relative, absolute, or include user home directory references. # Output - A string representing the absolute path of `file`, only if the file exists. If the file does not exist, return an appropriate error message. # Constraints - You must use the `os` module for path manipulations. - The function should handle paths with user home directories (`~`) correctly. - You should handle cross-platform compatibility (e.g., Unix and Windows). # Example Usage ```python # Assuming \'/home/user\' exists and \'~/example.txt\' exists in user\'s home directory print(get_valid_absolute_path(\'~/example.txt\')) # Output: /home/user/example.txt # Assuming \'/home/user\' exists but \'~/nonexistent.txt\' does not exist print(get_valid_absolute_path(\'~/nonexistent.txt\')) # Output: Error: file does not exist # Assuming \'/usr/bin/python3\' exists print(get_valid_absolute_path(\'/usr/bin/python3\')) # Output: /usr/bin/python3 # Assuming the current directory is \'/home/user/projects\' and \'main.py\' exists in it print(get_valid_absolute_path(\'main.py\')) # Output: /home/user/projects/main.py ``` # Notes - Ensure proper error handling and provide meaningful error messages. - Consider edge cases such as empty strings, invalid paths, special characters, etc.","solution":"import os def get_valid_absolute_path(file: str) -> str: Converts a given file path into an absolute path and validates its existence. Parameters: file (str): A file path which can be relative, absolute, or include user home directory references. Returns: str: The absolute path if it exists, otherwise an appropriate error message. if not file: return \\"Error: Invalid input, the file path cannot be empty.\\" # Expand the user home directory if present expanded_path = os.path.expanduser(file) # Convert to absolute path absolute_path = os.path.abspath(expanded_path) # Check if the file exists if os.path.exists(absolute_path): return absolute_path else: return \\"Error: File does not exist.\\""},{"question":"# Absolute Path Resolution Context You are building a file management application where you need to manage various files from different locations on a user\'s machine. To ensure your application consistently manages files regardless of the current working directory or user-specific paths, it is essential to convert all file paths to absolute paths. Task Write a function `get_absolute_path(file)` that takes a single string input `file`. This string could be: * A relative path to the current working directory. * An absolute path. * A path starting with `~` referring to the user\'s home directory. Your function should return the absolute path of the file. Function Signature ```python def get_absolute_path(file: str) -> str: pass ``` Input * `file`: A string representing the file path. Output * A string representing the absolute path of the file. Constraints * The input string will contain only valid characters for file paths. * Assume the operating system follows Unix-like path conventions (i.e., paths starting with `/` for absolute paths or with `~` for the home directory). Example ```python assert get_absolute_path(\'~/my_file.txt\') == \'/home/yourusername/my_file.txt\' # Expected path for user `yourusername` assert get_absolute_path(\'docs/notes.txt\') == \'/home/yourusername/docs/notes.txt\' # Considering current dir is user\'s home. assert get_absolute_path(\'/usr/bin/python3\') == \'/usr/bin/python3\' # Already absolute path. ``` Additional Notes Handle edge cases including: * Empty string inputs should return the current directory\'s absolute path. * Paths with `.` or `..`","solution":"import os def get_absolute_path(file: str) -> str: Returns the absolute path for the given file path, resolving relative paths and paths with \'~\' referring to the home directory. if not file: return os.path.abspath(\'.\') # Expand the user\'s home directory if the path starts with ~ if file.startswith(\'~\'): file = os.path.expanduser(file) # Convert to absolute path return os.path.abspath(file)"},{"question":"**Scenario**: You are designing a feature for a new numeric puzzle game. One level requires players to generate the next higher number using the same digits of a given number. This helps players learn about permutations and number rearrangements. You want to implement a function to find the next higher number efficiently. **Objective**: Write a function `next_higher_number(num: int) -> int` that takes in an integer `num` and returns the next higher number that uses exactly the same digits. If no such number exists, return `-1`. # Implementation Details 1. Your function should be named `next_higher_number`. 2. **Input**: - An integer `num` where `1 <= num <= 10^9`. 3. **Output**: - An integer representing the next higher number using the same digits. If no such number exists, return `-1`. 4. **Constraints**: - Handle edge cases as described in the analysis: - Single-digit numbers should return `-1`. - Numbers with digits in descending order should return `-1`. - Ensure no number with leading zeros after transformation. # Function Signature ```python def next_higher_number(num: int) -> int: pass ``` # Examples ```python assert next_higher_number(38276) == 38627 assert next_higher_number(12345) == 12354 assert next_higher_number(54321) == -1 assert next_higher_number(99999) == -1 ``` # Performance Requirements - All operations should ideally run in linear time relative to the number of digits in `num`. - Aim for an efficient solution without unnecessary computational overhead.","solution":"def next_higher_number(num: int) -> int: digits = list(str(num)) n = len(digits) # Find the first digit that is smaller than the digit next to it, from right to left for i in range(n - 2, -1, -1): if digits[i] < digits[i + 1]: break else: # If no such digit is found, all digits are in descending order return -1 # Find the smallest digit on right side of (i-th digit) but larger than digits[i] for j in range(n - 1, i, -1): if digits[j] > digits[i]: break # Swap digits[i] with digits[j] digits[i], digits[j] = digits[j], digits[i] # Reverse the digits after the (i-th digit) digits = digits[:i + 1] + sorted(digits[i + 1:]) # Convert list of digits back to integer next_number = int(\'\'.join(digits)) return next_number if next_number != num else -1"},{"question":"You are given an array of integers and a target number. Your goal is to write a function that returns the indices of two numbers such that they add up to the target. # Function Signature: ```python def find_pair_with_sum(nums: List[int], target: int) -> Tuple[int, int]: ``` # Input: * `nums`: A list of integers (e.g., [2, 7, 11, 15]) * `target`: An integer that represents the target sum (e.g., 9) # Output: * A tuple containing the indices of the two numbers that add up to the target (e.g., (0, 1)) # Constraints: * Each input will have exactly one solution. * You may not use the same element twice. * The provided list length can be zero or more. # Example: ```python nums = [2, 7, 11, 15] target = 9 assert find_pair_with_sum(nums, target) == (0, 1) ``` # Requirements: 1. The solution should have a time complexity of O(n). 2. Ensure to handle edge cases such as an empty array and a single element array. 3. The indices returned should be in the order in which they appear in the list. # Scenario: Consider you are a developer working on a payment processing system. You need to identify pairs of transactions that collectively match a certain amount to flag them for review. # Additional Notes: * Exception handling: if no valid pair exists, handle it as per project specifications (return `None` or raise an exception as applicable). **Show your understanding by writing a well-structured and efficient function.**","solution":"from typing import List, Tuple, Optional def find_pair_with_sum(nums: List[int], target: int) -> Optional[Tuple[int, int]]: Returns the indices of two numbers such that they add up to the target. Parameters: nums (List[int]): A list of integers. target (int): The target sum. Returns: Optional[Tuple[int, int]]: A tuple containing the indices of the two numbers that add up to the target, or None if no such pair exists. num_to_index = {} for index, num in enumerate(nums): complement = target - num if complement in num_to_index: return (num_to_index[complement], index) num_to_index[num] = index return None # Since the problem guarantees one solution, this line theoretically should not be reached."},{"question":"# Question Given an integer list and a commutative function, implement a custom segment tree to support range queries and updates. Demonstrate your implementation with sum queries, maximum queries, and tuple element-wise summation. Function Signature ```python class SegmentTree: def __init__(self, arr: List[int], function: Callable[[Any, Any], Any]): pass def update(self, index: int, value: int) -> None: pass def query(self, left: int, right: int) -> int: pass ``` # Input * **Initialization Array (arr)**: List of elements to be included in the segment tree. * **Function (function)**: A commutative function like sum or max. * **Update (index, value)**: An index to be updated with a specified value. * **Query (left, right)**: A range [left, right] inclusive to be queried. # Output * **Update**: Performs update in O(log N) time. * **Query**: Returns result of the commutative function applied across the range in O(log N) time. # Constraints * 1 <= len(arr) <= 10^5 * -10^9 <= arr[i] <= 10^9 * At most 10^5 updates and queries combined on the segment tree. # Example ```python # Create a segment tree with array and a max function mytree = SegmentTree([2, 4, 5, 3, 4], max) print(mytree.query(2, 4)) # Outputs: 5 mytree.update(3, 6) print(mytree.query(0, 3)) # Outputs: 6 # Accumulate sum function on an integer array mytree = SegmentTree([4, 5, 2, 3, 4, 43, 3], lambda a, b: a + b) print(mytree.query(0, 6)) # Outputs: 64 mytree.update(2, -10) print(mytree.query(0, 6)) # Outputs: 52 # Apply tuple elementwise summation mytree = SegmentTree([(1, 2), (4, 6), (4, 5)], lambda a, b: (a[0] + b[0], a[1] + b[1])) print(mytree.query(0, 2)) # Outputs: (9, 13) mytree.update(2, (-1, 2)) print(mytree.query(0, 2)) # Outputs: (4, 10) ``` Solution Constraints and Requirements * Your solution must handle up to 10^5 elements and 10^5 operations efficiently within the given constraints. * Ensure no invalid memory access or segmentation faults occur.","solution":"from typing import List, Callable, Any class SegmentTree: def __init__(self, arr: List[Any], function: Callable[[Any, Any], Any]): self.n = len(arr) self.tree = [None] * (2 * self.n) self.function = function # Initialize the segment tree with the provided array for i in range(self.n): self.tree[self.n + i] = arr[i] for i in range(self.n - 1, 0, -1): self.tree[i] = self.function(self.tree[2 * i], self.tree[2 * i + 1]) def update(self, index: int, value: Any) -> None: pos = index + self.n self.tree[pos] = value while pos > 1: pos //= 2 self.tree[pos] = self.function(self.tree[2 * pos], self.tree[2 * pos + 1]) def query(self, left: int, right: int) -> Any: result = None left += self.n right += self.n + 1 while left < right: if left % 2 == 1: result = self.tree[left] if result is None else self.function(result, self.tree[left]) left += 1 if right % 2 == 1: right -= 1 result = self.tree[right] if result is None else self.function(result, self.tree[right]) left //= 2 right //= 2 return result"},{"question":"You are given a string that you need to reverse for a text-processing application. However, instead of using Python\'s built-in capabilities directly, you are required to write a function to reverse the string by implementing the logic manually. This is to test your understanding of algorithmic approaches. Write a function `reverse_string(s: str) -> str` that takes a single string `s` as input and returns the reversed string. # Constraints * The input string `s` will only contain printable ASCII characters. * The length of the string `s` will not exceed 1000 characters. # Requirements 1. Implement the function using an iterative approach, without using Python string slicing, `reversed()`, or other built-in functions/methods that directly provide reversing functionality. 2. Consider edge cases such as empty strings and single-character strings. 3. Ensure the function has a time complexity of O(n) and a space complexity of O(n). # Function Signature ```python def reverse_string(s: str) -> str: pass ``` # Example ```python assert reverse_string(\\"hello\\") == \\"olleh\\" assert reverse_string(\\"\\") == \\"\\" assert reverse_string(\\"a\\") == \\"a\\" assert reverse_string(\\"abcdef\\") == \\"fedcba\\" ``` # Evaluation Criteria * Correctness: The function should return the correct reversed string for various inputs. * Efficiency: The function should operate within the expected time and space complexities. * Code Quality: The implementation should be clear, and edge cases should be handled appropriately.","solution":"def reverse_string(s: str) -> str: Reverses the input string manually without using built-in functionalities. result = [] for i in range(len(s) - 1, -1, -1): result.append(s[i]) return \'\'.join(result)"},{"question":"# Binary Heap: Implement Remove K-Min Elements Context You are tasked with managing a priority queue for a real-time system. The system maintains a large set of numeric priorities, and frequently, the smallest priority elements need to be processed and removed efficiently. To handle this, we utilize a Min Heap data structure which supports efficient insertion and removal operations. Task Extend the existing `BinaryHeap` class by implementing a method `remove_k_min(k)` that efficiently removes and returns the `k` smallest elements from the heap. Core Requirements 1. Develop `remove_k_min(k)` which accepts an integer `k`, removes the `k` smallest elements from the heap, and returns them as a list. 2. Ensure the implementation has optimal performance characteristics, primarily targeting O(k log N) time complexity. 3. Handle edge cases, such as when `k` is greater than the number of elements in the heap. Function Signature ```python def remove_k_min(self, k: int) -> list: # Implementation code here ``` Constraints 1. `1 <= k <= self.current_size` 2. The function should not use additional sorting. Example With a given Min Heap: ```python Heap: [0, 4, 50, 7, 55, 90, 87] remove_k_min(3) => should return [4, 7, 50] Updated heap: [0, 55, 87, 90] ``` Notes * You should build upon the existing `BinaryHeap` class structure. * Make sure to return the elements in the removal order, i.e., first element removed should be the smallest.","solution":"import heapq class BinaryHeap: def __init__(self): self.heap = [] def insert(self, k): heapq.heappush(self.heap, k) def remove_min(self): return heapq.heappop(self.heap) def remove_k_min(self, k: int) -> list: k_min_elements = [] for _ in range(k): k_min_elements.append(self.remove_min()) return k_min_elements"},{"question":"# Cycle Detection in a Directed Graph Scenario You are tasked with developing a component for a task scheduler system that ensures there are no circular dependencies among the tasks. Each task might depend on other tasks for its execution. If a circular dependency is present, your system should be able to detect it and handle it gracefully. Problem Statement Write a function `detect_cycle_in_tasks(tasks)` that detects if there is a cycle in a given set of tasks. The function should take a dictionary representing the task dependencies as input. Each key is a task, and the corresponding value is a list of tasks that the key task depends on. # Function Signature ```python def detect_cycle_in_tasks(tasks: Dict[str, List[str]]) -> bool: pass ``` Input * `tasks`: A dictionary where key is a string representing a task, and value is a list of strings representing the tasks on which the key task depends. Output * Returns `True` if there is at least one cycle in the task dependencies, otherwise `False`. Constraints 1. Task names are unique strings. 2. The number of tasks will not exceed 10^3. 3. The total number of dependencies will not exceed 10^4. Examples *Example 1*: ```python tasks = {\'A\': [\'B\', \'C\'], \'B\': [\'D\'], \'C\': [\'F\'], \'D\': [\'E\', \'F\'], \'E\': [\'B\'], \'F\': []} print(detect_cycle_in_tasks(tasks)) # Output: True ``` *Example 2*: ```python tasks = {\'A\': [\'B\'], \'B\': [\'C\'], \'C\': [], \'D\': [\'E\'], \'E\': []} print(detect_cycle_in_tasks(tasks)) # Output: False ``` Notes Your solution should efficiently handle the mentioned constraints and consider edge cases such as disconnected graphs and tasks with no dependencies.","solution":"def detect_cycle_in_tasks(tasks): Detects if there is a cycle in the given set of tasks. Parameters: tasks (Dict[str, List[str]]): A dictionary representing the task dependencies. Returns: bool: True if there is at least one cycle, otherwise False. visited = set() rec_stack = set() def is_cyclic(v): # Mark the current node as visited and put it in the recursion stack visited.add(v) rec_stack.add(v) # Recur for all tasks it depends on for neighbor in tasks.get(v, []): if neighbor not in visited: if is_cyclic(neighbor): return True elif neighbor in rec_stack: return True # Remove the node from recursion stack rec_stack.remove(v) return False # Check for each task if it is part of a cycle for task in tasks: if task not in visited: if is_cyclic(task): return True return False"},{"question":"You are given a function `remove_bit(num, i)` that removes a bit from a binary number at a specified position `i`. This function is highly efficient with its constant time complexity due to its use of bitwise operations. # Task: Your task is to implement a function `toggle_bit(num, pos)` that toggles a bit at a given position `pos` in the binary representation of a number. Toggling means changing a bit from 0 to 1 or from 1 to 0. # Function Signature: ```python def toggle_bit(num: int, pos: int) -> int: pass ``` # Input: - `num` - An integer representing the number whose bit needs to be toggled. - `pos` - An integer representing the position of the bit to be toggled (0-indexed). # Output: - Returns an integer with the bit at the specified position toggled. # Constraints: - `0 <= num <= 2^31 - 1` - `0 <= pos < 31` # Example: ```python # Example 1: num = 21 # (10101 binary) pos = 2 # Toggling the bit at position 2 (0-indexed) changes 10101 to 10001 assert toggle_bit(num, pos) == 17 # (10001 binary) # Example 2: num = 5 # (101 binary) pos = 0 # Toggling the bit at position 0 changes 101 to 100 assert toggle_bit(num, pos) == 4 # (100 binary) ``` # Explanation: To toggle a bit at position `pos`, you can use the XOR operator (`^`) with a mask that has a 1 at position `pos`. For example, if `pos` is 2, the mask would be `1 << pos`, which is `100` in binary. XOR-ing this with the number will toggle the bit at that position. # Hint: Consider using a mask `1 << pos` and the XOR operation to accomplish this task efficiently.","solution":"def toggle_bit(num: int, pos: int) -> int: Toggles the bit at position `pos` in the integer `num`. Args: - num: Integer whose bit needs to be toggled. - pos: Position of the bit to be toggled (0-indexed). Returns: - Integer with the bit at the specified position toggled. return num ^ (1 << pos)"},{"question":"# Binary Tree Postorder Traversal You are given the root of a binary tree. Your task is to implement the postorder traversal algorithm using both iterative and recursive approaches. Postorder traversal visits the nodes in the following order: left subtree, right subtree, and then the root node. **Function Signatures**: - `def postorder_iterative(root: Node) -> List[int]:` - `def postorder_recursive(root: Node) -> List[int]:` **Input**: - `root`: The root node of the binary tree. **Output**: - A list of integers representing the postorder traversal of the tree. **Constraints**: - The number of nodes in the tree is in the range `[0, 10^4]`. - `-10^3 <= Node.val <= 10^3` **Performance Requirements**: - Ensure the time complexity does not exceed O(n). - Handle edge cases such as an empty tree or skewed trees efficiently. # Example Scenarios **Example 1**: - **Input**: `root = [1, null, 2, 3]` *(Binary Tree: 1 -> 2 -> 3)* - **Output**: `[3, 2, 1]` **Example 2**: - **Input**: `root = []` *(An empty binary tree)* - **Output**: `[]` # Additional Information Implement the class `Node` to represent the tree structure: ```python class Node: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` Your task is to complete the two functions for iterative and recursive postorder traversal. ```python def postorder_iterative(root: Node) -> List[int]: # Implement the iterative approach pass def postorder_recursive(root: Node) -> List[int]: # Implement the recursive approach pass ``` Ensure that the implementations handle all edge cases and perform efficiently within the given constraints.","solution":"class Node: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def postorder_recursive(root): result = [] def traverse(node): if node is not None: traverse(node.left) traverse(node.right) result.append(node.val) traverse(root) return result def postorder_iterative(root): if root is None: return [] stack, result = [root], [] while stack: node = stack.pop() result.append(node.val) if node.left: stack.append(node.left) if node.right: stack.append(node.right) return result[::-1]"},{"question":"# Coding Task: Implement an Improved Radix Sort You are required to implement an improved version of the Radix Sort algorithm. Your task involves enhancing the provided implementation to handle some of the common issues and edge cases described above. # Function Signature: ```python def improved_radix_sort(arr: List[int], simulation: bool = False) -> List[int]: pass ``` # Input: - `arr` (List[int]): A list of non-negative integers to be sorted. - `simulation` (bool): Optional boolean flag to enable printing intermediate states of the array during sorting (default is False). # Output: - Returns a sorted list of integers. # Constraints: - 0 <= len(arr) <= 10^6 - All elements in `arr` are non-negative integers and less than 10^9 # Requirements: 1. Ensure your solution handles cases where input list might be empty or contain only one element. 2. Optimize space usage, particularly for handling the queue list. 3. If `simulation` is True, print the array after each sorting iteration by digit, starting from the least significant digit. # Example: ```python print(improved_radix_sort([170, 45, 75, 90, 802, 24, 2, 66], simulation=True)) # Expect to see sorting steps printed for each digit place # Final output: [2, 24, 45, 66, 75, 90, 170, 802] print(improved_radix_sort([], simulation=False)) # Output: [] print(improved_radix_sort([1], simulation=False)) # Output: [1] ``` # Notes: Be mindful of performance, particularly with large input sizes. Validate your approach with edge cases and ensure your code handles extremely large integers effectively.","solution":"from typing import List def improved_radix_sort(arr: List[int], simulation: bool = False) -> List[int]: if not arr: return arr max_num = max(arr) exp = 1 radix = 10 while max_num // exp > 0: counting_sort(arr, exp, radix, simulation) exp *= 10 return arr def counting_sort(arr: List[int], exp: int, radix: int, simulation: bool) -> None: n = len(arr) output = [0] * n count = [0] * radix for i in range(n): index = arr[i] // exp count[index % radix] += 1 for i in range(1, radix): count[i] += count[i - 1] for i in range(n - 1, -1, -1): index = arr[i] // exp output[count[index % radix] - 1] = arr[i] count[index % radix] -= 1 for i in range(n): arr[i] = output[i] if simulation: print(f\\"After sorting on digit place {exp}: {arr}\\")"},{"question":"Finding All Cliques in an Undirected Graph Problem Statement Given an undirected graph represented by a dictionary where the keys are vertex identifiers and the values are sets of vertices connected to the key vertex, write an algorithm to find all maximal cliques in the graph using the Bron-Kerbosch Algorithm. Explanation - A clique is defined as a subset of vertices such that every two vertices are connected by an edge. - A maximal clique is a clique that cannot be extended by including any adjacent vertex. - The input to your function will be a dictionary where each key is a vertex and its corresponding value is a set of vertices it is connected to. Function Signature ```python def find_all_cliques(edges: Dict[int, Set[int]]) -> List[List[int]]: ``` Input Format - `edges`: A dictionary `edges` where keys are integers representing vertices, and values are sets of integers representing the vertices connected by an edge to the key vertex. Output Format - A list of lists, where each inner list represents a maximal clique. Constraints - The graph is undirected. - The vertex identifiers are non-negative integers. - The graph may be sparse or dense. Example ```python edges = { 0: {1, 2}, 1: {0, 2, 3}, 2: {0, 1}, 3: {1} } # Expected output: [[0, 1, 2], [1, 3]] print(find_all_cliques(edges)) ``` Notes - Ensure that your algorithm handles edge cases such as an empty graph, a graph with no edges, and a fully connected graph. - Consider the complexity of your solution and try to optimize it where possible. - You are expected to solve this problem using the Bron-Kerbosch Algorithm as described in the problem statement.","solution":"from typing import Dict, Set, List def bron_kerbosch(R: Set[int], P: Set[int], X: Set[int], result: List[List[int]], graph: Dict[int, Set[int]]): if not P and not X: result.append(list(R)) return for v in list(P): bron_kerbosch(R.union({v}), P.intersection(graph[v]), X.intersection(graph[v]), result, graph) P.remove(v) X.add(v) def find_all_cliques(edges: Dict[int, Set[int]]) -> List[List[int]]: result = [] all_vertices = set(edges.keys()) for neighbors in edges.values(): all_vertices.update(neighbors) bron_kerbosch(set(), all_vertices, set(), result, edges) return result"},{"question":"# AVL Tree Implementation Enhancement Task **Scenario**: You are working on a high-performance data storage system that needs to support efficient insertions and lookups. The AVL Tree you have been provided is almost complete but requires a deletion mechanism to remove existing keys while keeping the tree balanced. **Task**: Implement a `delete` method for the given `AvlTree` class. The `delete` method should remove a node with the specified key and ensure the tree maintains its balanced property after the deletion. Implement necessary rotations to maintain the balance of the tree. Input and Output 1. The function should have the following signature: ```python def delete(self, key: int): ``` 2. **Input**: * A single integer `key` that needs to be deleted from the AVL Tree if it exists. 3. **Output**: * The function should not return anything. The tree should be updated in place. Constraints * All keys in the AVL Tree are unique. Performance Requirements * The deletion along with re-balancing should be performed in O(log n) time complexity. Example Given the following AVL Tree: ``` 30 / 20 40 / 10 25 50 ```` After deleting the key `20`, the AVL Tree should be: ``` 30 / 25 40 / 10 50 ``` Assumptions * The `AvlTree` class and necessary methods for insertion and balancing are already defined. * The `TreeNode` class is defined and used for the nodes in the tree. Implement the `delete` method in the AVL Tree class.","solution":"class TreeNode: def __init__(self, key, left=None, right=None, height=1): self.key = key self.left = left self.right = right self.height = height class AvlTree: def __init__(self): self.root = None def get_height(self, node): if not node: return 0 return node.height def get_balance(self, node): if not node: return 0 return self.get_height(node.left) - self.get_height(node.right) def rotate_right(self, y): x = y.left T2 = x.right x.right = y y.left = T2 y.height = max(self.get_height(y.left), self.get_height(y.right)) + 1 x.height = max(self.get_height(x.left), self.get_height(x.right)) + 1 return x def rotate_left(self, x): y = x.right T2 = y.left y.left = x x.right = T2 x.height = max(self.get_height(x.left), self.get_height(x.right)) + 1 y.height = max(self.get_height(y.left), self.get_height(y.right)) + 1 return y def insert(self, key): self.root = self._insert(self.root, key) def _insert(self, node, key): if not node: return TreeNode(key) elif key < node.key: node.left = self._insert(node.left, key) else: node.right = self._insert(node.right, key) node.height = max(self.get_height(node.left), self.get_height(node.right)) + 1 balance = self.get_balance(node) if balance > 1 and key < node.left.key: return self.rotate_right(node) if balance < -1 and key > node.right.key: return self.rotate_left(node) if balance > 1 and key > node.left.key: node.left = self.rotate_left(node.left) return self.rotate_right(node) if balance < -1 and key < node.right.key: node.right = self.rotate_right(node.right) return self.rotate_left(node) return node def delete(self, key): self.root = self._delete(self.root, key) def _delete(self, node, key): if not node: return node if key < node.key: node.left = self._delete(node.left, key) elif key > node.key: node.right = self._delete(node.right, key) else: if node.left is None: temp = node.right node = None return temp elif node.right is None: temp = node.left node = None return temp temp = self.get_min_value_node(node.right) node.key = temp.key node.right = self._delete(node.right, temp.key) if node is None: return node node.height = max(self.get_height(node.left), self.get_height(node.right)) + 1 balance = self.get_balance(node) if balance > 1 and self.get_balance(node.left) >= 0: return self.rotate_right(node) if balance > 1 and self.get_balance(node.left) < 0: node.left = self.rotate_left(node.left) return self.rotate_right(node) if balance < -1 and self.get_balance(node.right) <= 0: return self.rotate_left(node) if balance < -1 and self.get_balance(node.right) > 0: node.right = self.rotate_right(node.right) return self.rotate_left(node) return node def get_min_value_node(self, node): if node is None or node.left is None: return node return self.get_min_value_node(node.left)"},{"question":"As a software engineer, you are asked to implement a function that verifies whether a stack contains a sequence of strictly increasing consecutive integers. You can choose to use either an additional stack or a queue as auxiliary storage for restoring the stack after checking. Function Signature ```python def is_strictly_increasing_consecutive(stack): stack: List[int] - A list of integers representing a stack (bottom of the stack at index 0) Returns: bool - Whether the stack contains strictly increasing consecutive integers. ``` Input and Output - **Input**: A list of integers representing the stack. The integer at index 0 represents the bottom of the stack, and the integer at index `len(stack)-1` represents the top. - **Output**: A boolean value; `True` if the stack contains strictly increasing consecutive integers from bottom to top, `False` otherwise. Examples 1. `is_strictly_increasing_consecutive([3, 4, 5, 6, 7])` returns `True` 2. `is_strictly_increasing_consecutive([3, 5, 6, 7])` returns `False` 3. `is_strictly_increasing_consecutive([1])` returns `True` 4. `is_strictly_increasing_consecutive([])` returns `True` Constraints and Considerations - The function should handle stacks of any size, including empty stacks. - Your solution must ensure the original stack is restored to its initial state after the function call. - The function must operate with a time complexity of O(n) and a space complexity of O(n), where n is the number of elements in the stack. - Consider edge cases such as single-element stacks and already ordered and unsorted sequences. Performance Requirements - Efficient stack and auxiliary storage operations. - Proper handling and restoration of the original stack when operations are complete.","solution":"def is_strictly_increasing_consecutive(stack): Determines whether the given stack contains strictly increasing consecutive integers. stack: List[int] - A list of integers representing a stack (bottom of the stack at index 0) Returns: bool - Whether the stack contains strictly increasing consecutive integers. if len(stack) <= 1: return True auxiliary_stack = [] is_consecutive = True while stack: current = stack.pop() if auxiliary_stack and auxiliary_stack[-1] != current + 1: is_consecutive = False auxiliary_stack.append(current) while auxiliary_stack: stack.append(auxiliary_stack.pop()) return is_consecutive"},{"question":"# Task You have to implement and test the `Union` class (Union-Find/Disjoint Set) that supports dynamic connectivity among elements, along with an application to count the number of islands on a grid after converting specific positions from water to land. # Implementation Details 1. **Union Class**: - Implement a class called `Union` with the following functionalities: - **add(element: Tuple[int, int])**: Adds a new element to the disjoint set. Each element starts in its own set. - **root(element: Tuple[int, int])**: Returns the root of the set containing the element, with path compression. - **unite(element1: Tuple[int, int], element2: Tuple[int, int])**: Merges the sets containing `element1` and `element2` using union by size. 2. **Island Counting Function**: - Implement a function `num_islands(positions: List[Tuple[int, int]]) -> List[int]` that takes a list of grid positions to convert to land, and returns the number of islands after each conversion. Assume an initially empty grid filled with water (0s). # Input and Output Format - **Input**: - A list of integer tuples representing positions to convert to land. - **Output**: - A list of integers representing the number of islands after each conversion. # Constraints - Consider the grid positions provided are within the bounds of a sensible grid size for practical purposes (e.g., maximum 10^4 elements). # Example ```python positions = [(0, 0), (0, 1), (1, 2), (2, 1)] assert num_islands(positions) == [1, 1, 2, 3] ``` # Notes - An island is formed by adjacent lands (vertically and horizontally). - Use the Union-Find data structure for efficient connectivity checks and merging sets. # Performance Requirements - Ensure that the union and find operations are optimized for large inputs using path compression and union by size, supporting up to 10^4 elements efficiently.","solution":"class Union: def __init__(self): self.parent = {} self.rank = {} def add(self, element): if element not in self.parent: self.parent[element] = element self.rank[element] = 0 def root(self, element): if self.parent[element] != element: self.parent[element] = self.root(self.parent[element]) return self.parent[element] def unite(self, element1, element2): root1 = self.root(element1) root2 = self.root(element2) if root1 != root2: if self.rank[root1] > self.rank[root2]: self.parent[root2] = root1 elif self.rank[root1] < self.rank[root2]: self.parent[root1] = root2 else: self.parent[root2] = root1 self.rank[root1] += 1 def num_islands(positions): union_set = Union() directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] land_positions = set() num_islands_list = [] num_islands = 0 for pos in positions: if pos in land_positions: num_islands_list.append(num_islands) continue land_positions.add(pos) union_set.add(pos) num_islands += 1 for d in directions: neighbor = (pos[0] + d[0], pos[1] + d[1]) if neighbor in land_positions: if union_set.root(pos) != union_set.root(neighbor): union_set.unite(pos, neighbor) num_islands -= 1 num_islands_list.append(num_islands) return num_islands_list"},{"question":"Implement an Enhanced Trie Context You are a software engineer tasked with developing a powerful autocomplete feature for a text editor. The autocomplete must quickly suggest words based on the currently typed prefix. You choose to use a data structure called a \\"trie\\" to accomplish this task. Task Implement the functionalities of the trie, including insertion, search, and prefix matching. Additionally, add a method to suggest words based on a given prefix. Function Specifications * **Function Name**: `insert` * **Input**: A string `word` that consists of lowercase letters a-z. * **Output**: None * **Function Name**: `search` * **Input**: A string `word` that consists of lowercase letters a-z. * **Output**: `True` if the word exists in the trie, `False` otherwise. * **Function Name**: `starts_with` * **Input**: A string `prefix` that consists of lowercase letters a-z. * **Output**: `True` if there is any word in the trie that starts with the prefix, `False` otherwise. * **Function Name**: `suggest` * **Input**: A string `prefix` that consists of lowercase letters a-z. * **Output**: A list of all suggested words in the trie that start with the given prefix. Example ```python trie = Trie() trie.insert(\\"hello\\") trie.insert(\\"hell\\") trie.insert(\\"heaven\\") trie.insert(\\"heavy\\") print(trie.search(\\"hell\\")) # Output: True print(trie.search(\\"hello\\")) # Output: True print(trie.search(\\"heav\\")) # Output: False print(trie.starts_with(\\"he\\")) # Output: True print(trie.starts_with(\\"hea\\")) # Output: True print(trie.starts_with(\\"heav\\")) # Output: True print(trie.starts_with(\\"hez\\")) # Output: False print(trie.suggest(\\"he\\")) # Output: [\\"hell\\", \\"hello\\", \\"heaven\\", \\"heavy\\"] print(trie.suggest(\\"hea\\")) # Output: [\\"heaven\\", \\"heavy\\"] ``` Constraints * All inputs strings will only consist of lowercase letters a-z. * Prefix queries will be at most length 20. Performance Requirements * Ensure the implementation is efficient with respect to the operations insert, search, prefix matching, and the suggest method. * Handle edge cases like empty strings gracefully, if applicable.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word): node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, word): node = self.root for char in word: if char not in node.children: return False node = node.children[char] return node.is_end_of_word def starts_with(self, prefix): node = self.root for char in prefix: if char not in node.children: return False node = node.children[char] return True def suggest(self, prefix): def dfs(node, path, results): if node.is_end_of_word: results.append(\\"\\".join(path)) for char, next_node in node.children.items(): path.append(char) dfs(next_node, path, results) path.pop() node = self.root results = [] path = [] for char in prefix: if char not in node.children: return [] node = node.children[char] dfs(node, list(prefix), results) return results"},{"question":"Scenario You are tasked with optimizing an automated surveillance system. One of the components is responsible for analyzing binary sequences to determine faults. Given a binary array, your task is to find the index of a 0 that, when replaced with 1, maximizes the length of the longest contiguous sequence of 1s. Problem Statement Write a Python function `max_ones_index_v2(arr: List[int]) -> int` that returns the index of the 0 in the binary array `arr` that, when replaced with 1, results in the longest contiguous sequence of 1s. If no 0 exists in the array, the function should return -1. Constraints - The input `arr` is a list of integers where each element is either 0 or 1. - The length of `arr` will be in the range [1, 10^7]. - The function should run in O(n) time and use O(1) extra space. Input - `arr`: A list of integers (0 or 1). Output - An integer representing the index of the 0 to be replaced with 1 to get the longest contiguous sequence of 1s. If no 0 is present, return -1. Performance Requirements - Your solution should run in linear time O(n) and should utilize constant extra space O(1). # Example ```python # Example 1: arr = [1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1] # Function call: max_ones_index_v2(arr) # Expected output: 3 # Example 2: arr = [1, 1, 1, 1, 1] # Function call: max_ones_index_v2(arr) # Expected output: -1 ``` Additional Information Carefully handle edge cases, such as arrays with no zeros, arrays with one zero, or very large arrays. The solution should efficiently find the required index while maintaining the specified time and space complexities.","solution":"def max_ones_index_v2(arr): max_length = 0 max_index = -1 current_length = 0 prev_zero_index = -1 prev_prev_zero_index = -1 for i in range(len(arr)): if arr[i] == 1: current_length += 1 else: if prev_zero_index != -1: current_length = i - prev_prev_zero_index else: current_length += 1 prev_prev_zero_index = prev_zero_index prev_zero_index = i if current_length > max_length: max_length = current_length max_index = prev_zero_index return max_index"},{"question":"You are required to write a function `sum_dig_pow(low, high)` that returns a list of numbers within the given range `[low, high]` (inclusive) such that for each number, the number itself is equal to the sum of its digits each raised to a consecutive power starting from 1. # Input: - Two integers, `low` and `high` representing the inclusive range of numbers to check. # Output: - A list of integers that satisfy the specified property within the given range `[low, high]`. # Constraints: - 0 <= `low` <= `high` <= 10^5 # Performance Requirements: - The solution should be optimized for ranges up to 100,000. # Example: ```python def sum_dig_pow(low, high): result = [] for number in range(low, high + 1): exponent = 1 # set to 1 summation = 0 # set to 1 number_as_string = str(number) tokens = list(map(int, number_as_string)) # parse the string into individual digits for k in tokens: summation = summation + (k ** exponent) exponent += 1 if summation == number: result.append(number) return result # Test cases print(sum_dig_pow(1, 10)) # Output: [1, 2, 3, 4, 5, 6, 7, 8, 9] print(sum_dig_pow(1, 100)) # Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 89] print(sum_dig_pow(10, 150)) # Output: [89, 135] print(sum_dig_pow(90, 150)) # Output: [89, 135] ``` **Note**: Ensure your function handles large ranges efficiently. Avoid brute force where possible, and consider algorithmic optimizations.","solution":"def sum_dig_pow(low, high): Returns a list of numbers within the given range [low, high] such that the number is equal to the sum of its digits each raised to a consecutive power starting from 1. def is_eureka_number(number): digits = list(map(int, str(number))) return number == sum(d ** (i + 1) for i, d in enumerate(digits)) return [num for num in range(low, high + 1) if is_eureka_number(num)]"},{"question":"**Scenario**: You are given an array of integers where every element appears twice except for one unique element. Your task is to identify the unique element that appears only once. The solution should be efficient in terms of both time and space complexity. **Function Signature**: ```python def single_number(nums: List[int]) -> int: Given an array of integers where every element appears twice except for one, find the element that appears only once. :param nums: List[int] - List of integers where each integer appears twice except for one. :return: int - The single number that appears only once. Constraints: * The array will always contain at least one element. * Every element in the array, except for one, appears exactly twice. pass ``` **Input**: * `nums`: A list of integers where every element appears twice except for one. **Output**: * The integer that appears only once in the array. **Example**: ```python assert single_number([2, 2, 1]) == 1 assert single_number([4, 1, 2, 1, 2]) == 4 assert single_number([1]) == 1 ``` **Constraints**: * You must implement an algorithm that runs in linear time complexity (O(n)). * The solution should use constant extra space (O(1)). **Hints**: * Consider using a bitwise XOR operation to solve the problem efficiently. **Clarifications**: * The array will always conform to the given constraints. * Ensure your solution handles all possible valid inputs correctly.","solution":"from typing import List def single_number(nums: List[int]) -> int: Given an array of integers where every element appears twice except for one, find the element that appears only once. :param nums: List[int] - List of integers where each integer appears twice except for one. :return: int - The single number that appears only once. Constraints: * The array will always contain at least one element. * Every element in the array, except for one, appears exactly twice. unique = 0 for num in nums: unique ^= num return unique"},{"question":"You are required to implement an improved version of the Jump Search algorithm that can efficiently search for an element in both sorted and unsorted arrays. If the array is not sorted, the function should first sort the array before performing the search. Guidelines - You should use the original jump search\'s block-based approach. - Optimize the jump search by first sorting the array if not sorted. # Function Signature ```python def optimized_jump_search(arr: List[int], target: int) -> int: pass ``` # Input - `arr` : List[int] : An array of integers (both sorted and unsorted). - `target` : int : The integer to be searched in the array. # Output - int : The index of the target in the array, if found. - Return -1 if the target is not present. # Constraints - The input array can be of any length from 0 to 10^6. - The elements of the array can be any integer within the range of -10^9 to 10^9. # Example ```python # Example 1 arr = [3, 1, 2, 4, 5] target = 4 assert optimized_jump_search(arr, target) == 3 # Example 2 arr = [10, 20, 30, 40, 50] target = 35 assert optimized_jump_search(arr, target) == -1 # Example 3 arr = [] target = 5 assert optimized_jump_search(arr, target) == -1 ``` # Additional Notes - Pay attention to handling edge cases such as an empty array. - Ensure that your function can handle large input sizes efficiently. - Provide additional unit tests to demonstrate the correctness of your solution.","solution":"from typing import List import math def optimized_jump_search(arr: List[int], target: int) -> int: if not arr: return -1 # Check if array is sorted if arr != sorted(arr): arr.sort() n = len(arr) step = int(math.sqrt(n)) prev = 0 # Finding the block where the element may be present while arr[min(step, n)-1] < target: prev = step step += int(math.sqrt(n)) if prev >= n: return -1 # Linear search within the block for i in range(prev, min(step, n)): if arr[i] == target: return i return -1"},{"question":"# Cycle Sort Implementation Challenge Context You are a software developer tasked with implementing an efficient sorting algorithm for a high-reliability system, such as one using EEPROM or non-volatile memory, where the number of write operations needs to be minimized. Cycle Sort is particularly suited for this as it performs the minimum possible number of writes. Task Implement the Cycle Sort algorithm to sort a list of integers in non-descending order. Function Signature ```python def cycle_sort(arr: List[int]) -> List[int]: pass ``` # Input * A list of integers `arr` where 1 <= len(arr) <= 1000. * The elements of `arr` can include duplicates and will be in the range -10^6 to 10^6. # Output * The function should return a new list containing the sorted integers of the input list, `arr`. Constraints * You must perform the sorting in-place, modifying the input list directly. * Minimize the number of write operations to the list. * The list should not be simply sorted using built-in sort functions or any other algorithm. Requirements - Ensure that the algorithm handles edge cases, including arrays with duplicates and already sorted arrays efficiently. # Example ```python # Example 1 input: [3, 1, 2, 3, 4] output: [1, 2, 3, 3, 4] # Example 2 input: [10, 7, 5, 5, 5, 3, 1, 100] output: [1, 3, 5, 5, 5, 7, 10, 100] ``` Use the structure and key principles of Cycle Sort described above to implement your function effectively.","solution":"from typing import List def cycle_sort(arr: List[int]) -> List[int]: Perform in-place Cycle Sort on the input list and return the sorted list. n = len(arr) for cycle_start in range(0, n - 1): item = arr[cycle_start] # Find position where we put the element pos = cycle_start for i in range(cycle_start + 1, n): if arr[i] < item: pos += 1 # If item is already in correct position if pos == cycle_start: continue # Skip duplicates while item == arr[pos]: pos += 1 # Put the item to the correct position if pos != cycle_start: arr[pos], item = item, arr[pos] # Rotate the rest of the cycle while pos != cycle_start: pos = cycle_start for i in range(cycle_start + 1, n): if arr[i] < item: pos += 1 while item == arr[pos]: pos += 1 if item != arr[pos]: arr[pos], item = item, arr[pos] return arr"},{"question":"You are required to design and implement a data structure named `EnhancedRandomizedSet` that maintains all operations in average O(1) time. Task 1. Implement a class `EnhancedRandomizedSet` with the following methods: - `insert(val: int) -> bool`: Inserts a value into the set if it is not already present. Returns `True` if the value was inserted, `False` otherwise. - `remove(val: int) -> bool`: Removes a value from the set if it is present. Returns `True` if the value was removed, `False` otherwise. - `get_random() -> int`: Returns a random element from the current set of elements. All elements should have the same probability of being returned. - `get_all() -> List[int]`: Returns a list containing all the elements in the data structure in any order. Requirements - You must implement the `EnhancedRandomizedSet` class without using any external libraries besides those provided in the standard library. - Your solution should have optimal space and time complexity. Aim for average-case O(1) time complexity for the main operations. - You must handle potential edge cases such as attempting to remove an element not in the set, inserting duplicates, or querying random elements from an empty set. Example Usage ```python rs = EnhancedRandomizedSet() print(rs.insert(1)) # True print(rs.insert(2)) # True print(rs.insert(2)) # False print(rs.remove(3)) # False print(rs.get_all()) # [1, 2] in any order print(rs.get_random()) # Returns 1 or 2 print(rs.remove(2)) # True print(rs.get_all()) # [1] ```","solution":"import random class EnhancedRandomizedSet: def __init__(self): self.vals = [] self.pos = {} def insert(self, val: int) -> bool: if val in self.pos: return False self.pos[val] = len(self.vals) self.vals.append(val) return True def remove(self, val: int) -> bool: if val not in self.pos: return False index = self.pos[val] last_element = self.vals[-1] self.vals[index] = last_element self.pos[last_element] = index self.vals.pop() del self.pos[val] return True def get_random(self) -> int: if not self.vals: return None # Or raise an exception if desired return random.choice(self.vals) def get_all(self) -> list: return self.vals[:]"},{"question":"# Question: Longest Common Substring Length with Unique Characters Constraint **Context:** You work as a developer for a company specializing in text analysis. You have been tasked with creating an efficient function that finds the longest substring common to two input strings, `a` and `b`. Inputs: * Two strings, `a` and `b`. * Note: String `b` contains all distinct characters (no repeating characters). Outputs: * An integer denoting the length of the longest common substring between `a` and `b`. Constraints: * The length of the strings can be up to 10^5. * Minimum length of strings = 1. Performance Requirement: * The time complexity should be O(n log n). # Example: Input: ```python a = \\"abcde\\" b = \\"qwerabczxcv\\" ``` Output: ```python 3 ``` Explanation: * The longest common substring is \\"abc\\" which has a length of 3. # Function Signature ```python def longest_common_substr_length(a: str, b: str) -> int: pass ``` Implement the function `longest_common_substr_length` that satisfies the above requirements.","solution":"def longest_common_substr_length(a: str, b: str) -> int: def check_length(length: int) -> bool: Helper function to check if there\'s a common substring of given length between `a` and `b` substrings_a = {a[i:i+length] for i in range(len(a) - length + 1)} for i in range(len(b) - length + 1): if b[i:i+length] in substrings_a: return True return False low, high = 0, min(len(a), len(b)) result = 0 while low <= high: mid = (low + high) // 2 if check_length(mid): result = mid low = mid + 1 else: high = mid - 1 return result"},{"question":"You are given a binary tree and need to implement a function that performs a post-order traversal in two ways - iteratively and recursively. Function Signatures - Iterative: `def postorder_iterative(root: Node) -> List[int]:` - Recursive: `def postorder_recursive(root: Node) -> List[int]:` Input - `root`: The root node of the binary tree (can be `None`). Output - A list of integers representing the post-order traversal of the binary tree. Constraints - Each node contains an integer value that fits into a 32-bit signed integer. - The number of nodes in the tree (`n`) is such that `0 <= n <= 10^4`. Example ```python class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right # Example Tree: # 1 # / # 2 3 # / # 4 5 root = Node(1, Node(2, Node(4), Node(5)), Node(3)) assert postorder_iterative(root) == [4, 5, 2, 3, 1] assert postorder_recursive(root) == [4, 5, 2, 3, 1] ``` Notes 1. Handle edge cases like an empty tree. 2. Ensure your solution efficiently handles large trees with the maximum number of nodes. 3. Avoid using Python\'s built-in libraries for traversal; implement your own.","solution":"class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right def postorder_recursive(root): Perform a recursive post-order traversal of the binary tree. def helper(node): if node is None: return [] return helper(node.left) + helper(node.right) + [node.val] return helper(root) def postorder_iterative(root): Perform an iterative post-order traversal of the binary tree. if root is None: return [] stack = [root] result = [] while stack: node = stack.pop() result.insert(0, node.val) # Prepend to result if node.left: stack.append(node.left) if node.right: stack.append(node.right) return result"},{"question":"# Preorder Traversal Expertise Challenge Scenario You are tasked with implementing the preorder traversal algorithm for a binary tree. Preorder traversal is one of the depth-first search (DFS) orders and is very useful in tree data structures, such as generating prefix expressions from an expression tree. Task Write two functions in Python to perform a preorder traversal of a binary tree: one using an iterative approach and the other using recursion. Requirements 1. **Iterative Preorder Traversal** - Function Name: `preorder_iterative` - Input: A binary tree root node of type `Node`. - Output: A list of node values in the order they were visited. 2. **Recursive Preorder Traversal** - Function Name: `preorder_recursive` - Input: A binary tree root node of type `Node`. - Output: A list of node values in the order they were visited. Definitions The `Node` class is defined as follows: class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right Constraints - Each node\'s value is a unique integer. - You must handle the case where the tree is empty (i.e., root is None). - Assume the binary tree will have at most 1000 nodes. Performance - Your iterative and recursive functions should both have a time complexity of O(n), where n is the number of nodes in the tree. - Aim to minimize space usage, with the understanding that space complexity for both functions should also be O(n) in the worst case. Example Consider the binary tree: 1 / 2 3 / 4 5 * `preorder_iterative(root)` should return `[1, 2, 4, 5, 3]`. * `preorder_recursive(root)` should return `[1, 2, 4, 5, 3]`. Implement your solution ensuring it\'s thoroughly tested against various edge cases, including an empty tree and highly imbalanced trees.","solution":"class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right def preorder_iterative(root): Perform an iterative preorder traversal of a binary tree. if not root: return [] stack = [root] result = [] while stack: node = stack.pop() if node: result.append(node.val) if node.right: stack.append(node.right) if node.left: stack.append(node.left) return result def preorder_recursive(root): Perform a recursive preorder traversal of a binary tree. result = [] def traverse(node): if not node: return result.append(node.val) traverse(node.left) traverse(node.right) traverse(root) return result"},{"question":"# Question: You have to implement a function named **`cosine_similarity`** that calculates the cosine similarity between two given 1D lists of numerical values (vectors). Function Signature: ```python def cosine_similarity(vec1: List[float], vec2: List[float]) -> float: ``` Input: - `vec1`: A list of floats representing the first vector. - `vec2`: A list of floats representing the second vector. **Note**: Both vectors must be of the same length. Output: - `float`: A single float value representing the cosine similarity between the two input vectors. Constraints: - The length of vectors should be between 1 to 10,000 inclusive. - All elements in the vectors are valid float numbers. Example: ```python cosine_similarity([1, 1, 1], [1, 2, -1]) # returns 0.47140452079103173 cosine_similarity([0, 0, 0], [1, 1, 1]) # raises an appropriate error ``` Additional Information: - You are required to handle edge cases, such as vectors of different lengths and zero vectors, appropriately by raising exceptions when necessary. - The function should not use any external libraries, though standard library imports like `math` are acceptable. Performance Requirement: - The solution should run efficiently for vectors of length up to 10,000. Scenario: Imagine you are working on a document similarity engine. You have a corpus of documents represented as term frequency vectors, and you need to calculate how similar one document is to another. Implement the given function to measure the similarity effectively based on cosine similarity.","solution":"from typing import List import math def cosine_similarity(vec1: List[float], vec2: List[float]) -> float: if len(vec1) != len(vec2): raise ValueError(\\"Vectors must be of the same length.\\") dot_product = sum(a * b for a, b in zip(vec1, vec2)) magnitude_vec1 = math.sqrt(sum(a * a for a in vec1)) magnitude_vec2 = math.sqrt(sum(b * b for b in vec2)) if magnitude_vec1 == 0 or magnitude_vec2 == 0: raise ValueError(\\"Vectors must not be zero vectors.\\") return dot_product / (magnitude_vec1 * magnitude_vec2)"},{"question":"# Matrix Chain Multiplication Optimization You are tasked with implementing the Matrix Chain Multiplication using dynamic programming. Your solution should calculate the minimum number of scalar multiplications required to multiply the entire chain. Additionally, reconstruct the optimal matrix multiplication order. Requirements - Implement the function `matrix_chain_order` that takes in an array where each element represents the dimensions of matrices in the chain and returns the minimum cost and the optimal order. - Implement the function `print_optimal_solution` that prints the order of matrix multiplication. - Ensure your solution efficiently handles edge cases and high inputs. Function Signatures ```python def matrix_chain_order(array: List[int]) -> Tuple[List[List[int]], List[List[int]]]: pass def print_optimal_solution(optimal_solution: List[List[int]], i: int, j: int) -> None: pass ``` Input Format - `array`: A list of integers where the i-th matrix has dimension array[i-1] x array[i]. Output Format - `matrix_chain_order` returns two matrices: - The first matrix contains the minimum multiplication costs. - The second matrix contains the split positions. - `print_optimal_solution` prints the optimal order in the format `(A1(A2A3))`. Constraints - The number of matrices (n-1) will be such that 1 <= n <= 100. Example ```python array = [30, 35, 15, 5, 10, 20, 25] matrix, optimal_solution = matrix_chain_order(array) print(\\"No. of Operation required:\\", matrix[1][len(array) - 1]) print_optimal_solution(optimal_solution, 1, len(array) - 1) ``` Notes 1. The provided `main()` function in the analysis can be used for testing. 2. Focus on handling edge cases such as single-matrix multiplication and large-sized matrices efficiently.","solution":"from typing import List, Tuple def matrix_chain_order(p: List[int]) -> Tuple[List[List[int]], List[List[int]]]: n = len(p) - 1 m = [[0 for _ in range(n + 1)] for _ in range(n + 1)] s = [[0 for _ in range(n + 1)] for _ in range(n + 1)] for l in range(2, n + 1): for i in range(1, n - l + 2): j = i + l - 1 m[i][j] = float(\'inf\') for k in range(i, j): q = m[i][k] + m[k + 1][j] + p[i - 1] * p[k] * p[j] if q < m[i][j]: m[i][j] = q s[i][j] = k return m, s def print_optimal_solution(s: List[List[int]], i: int, j: int) -> None: if i == j: print(f\'A{i}\', end=\'\') else: print(\'(\', end=\'\') print_optimal_solution(s, i, s[i][j]) print_optimal_solution(s, s[i][j] + 1, j) print(\')\', end=\'\')"},{"question":"Implement a **Min Binary Heap** class, which represents a minimal binary heap. This class should support the following fundamental operations efficiently: 1. **Insert** a value into the heap. 2. **Remove (extract) the minimum** value from the heap. # Objectives You need to complete the `MinBinaryHeap` class with the following functionalities: 1. **insert(val)**: * Adds a new value to the heap. * Automatically percolates the value up to maintain the heap property. 2. **remove_min()**: * Removes and returns the minimum (root) value of the heap. * Percolates the last element down to maintain the heap property. # Requirements 1. **Input Format**: * For `insert(val)`: A single integer `val` which is to be inserted. * For `remove_min()`: No input parameter. 2. **Output Format**: * For `insert(val)`: No output is required. * For `remove_min()`: Returns an integer which is the minimum value in the heap before removal. 3. **Constraints**: * The heap will contain only integer values. * The heap will not contain more than 100,000 elements. * It is guaranteed that `remove_min` will not be called on an empty heap. Complete the `MinBinaryHeap` class by implementing the methods as specified. # Example ```python # Example Usage heap = MinBinaryHeap() heap.insert(4) heap.insert(50) heap.insert(7) print(heap.remove_min()) # Output: 4 heap.insert(2) heap.insert(55) print(heap.remove_min()) # Output: 2 heap.insert(90) heap.insert(87) print(heap.remove_min()) # Output: 7 ``` Implement the `MinBinaryHeap` class below. ```python class MinBinaryHeap: def __init__(self): self.heap = [0] # Initialize the heap with a dummy element at index 0 self.current_size = 0 def perc_up(self, i): while i // 2 > 0: if self.heap[i] < self.heap[i // 2]: self.heap[i], self.heap[i // 2] = self.heap[i // 2], self.heap[i] i = i // 2 def insert(self, val): self.heap.append(val) self.current_size += 1 self.perc_up(self.current_size) def min_child(self, i): if i * 2 + 1 > self.current_size: return i * 2 else: if self.heap[i * 2] < self.heap[i * 2 + 1]: return i * 2 else: return i * 2 + 1 def perc_down(self, i): while i * 2 <= self.current_size: mc = self.min_child(i) if self.heap[i] > self.heap[mc]: self.heap[i], self.heap[mc] = self.heap[mc], self.heap[i] i = mc def remove_min(self): min_val = self.heap[1] self.heap[1] = self.heap[self.current_size] self.current_size -= 1 self.heap.pop() self.perc_down(1) return min_val ```","solution":"class MinBinaryHeap: def __init__(self): self.heap = [0] # Initialize the heap with a dummy element at index 0 self.current_size = 0 def perc_up(self, i): while i // 2 > 0: if self.heap[i] < self.heap[i // 2]: self.heap[i], self.heap[i // 2] = self.heap[i // 2], self.heap[i] i = i // 2 def insert(self, val): self.heap.append(val) self.current_size += 1 self.perc_up(self.current_size) def min_child(self, i): if i * 2 + 1 > self.current_size: return i * 2 else: if self.heap[i * 2] < self.heap[i * 2 + 1]: return i * 2 else: return i * 2 + 1 def perc_down(self, i): while i * 2 <= self.current_size: mc = self.min_child(i) if self.heap[i] > self.heap[mc]: self.heap[i], self.heap[mc] = self.heap[mc], self.heap[i] i = mc def remove_min(self): min_val = self.heap[1] self.heap[1] = self.heap[self.current_size] self.current_size -= 1 self.heap.pop() self.perc_down(1) return min_val"},{"question":"# Pancake Sorting Challenge Pancake sorting is a fascinating algorithm that operates similarly to the game of sorting pancakes on a grill by flipping them with a spatula. The goal is to sort an array of numbers using only a series of flips. A flip reverses the order of the elements in a prefix of the array, which means that it\'s possible to flip the array around any index. Your task is to implement the **pancake_sort function** which sorts an array using these flips exclusively. # Function Signature ```python def pancake_sort(arr: List[int]) -> List[int]: pass ``` # Input - `arr`: A list of integers ( 1 leq text{len(arr)} leq 10^3 ) # Output - The function should return a list of integers in non-decreasing order. # Example Input: ```python pancake_sort([3, 2, 4, 1]) ``` Output: ```python [1, 2, 3, 4] ``` # Constraints - You must use the flipping operation exactly as described. - No other sorting techniques are allowed (like direct comparisons and swaps). # Notes - Consider handling special cases such as already sorted arrays or arrays of length 1. - Ensure that your code is efficient for the input size.","solution":"from typing import List def flip(arr: List[int], k: int) -> None: Flip function to reverse the order of the first k elements of the array arr[:k] = arr[:k][::-1] def pancake_sort(arr: List[int]) -> List[int]: Perform pancake sorting on the input array `arr` and return the sorted array. n = len(arr) for size in range(n, 1, -1): # Find the index of the maximum element in the first `size` elements max_idx = arr.index(max(arr[:size])) if max_idx != size - 1: # Flip the maximum number to the beginning flip(arr, max_idx + 1) # Flip it again to move it to its correct position flip(arr, size) return arr"},{"question":"# Array Manipulation Challenge: Move Zeros to the End Context You are tasked with cleaning up an array by moving all zero values to the end. This is common in data cleaning operations where zero values are considered irrelevant or placeholders for missing data. Objective Write a function that takes an array containing various data types (integers, booleans, strings, etc.) and moves all the zeros to the end, without changing the order of the other elements. Function Signature ```python def move_zeros(array: list) -> list: # Your implementation here pass ``` Inputs - `array`: A list containing various types of elements, including integers, booleans, and strings. Outputs - Returns a new list where all zero values from the input `array` are moved to the end, while the order of other elements remains unchanged. Constraints - Do not use any built-in Python methods that directly solve \\"move zeros\\" type problems. - Maintain the relative order of non-zero elements. - Handle \'False\' as a non-zero value. Performance Requirements - The function should run in O(n) time complexity. - The function should use O(n) additional space. Examples ```python move_zeros([False, 1, 0, 1, 2, 0, 1, 3, \\"a\\"]) # Output: [False, 1, 1, 2, 1, 3, \\"a\\", 0, 0] move_zeros([0, 0, 1]) # Output: [1, 0, 0] move_zeros([1, 2, 3]) # Output: [1, 2, 3] move_zeros([0, 0, 0]) # Output: [0, 0, 0] ``` Note Think about edge cases such as arrays with no zeros, arrays where all elements are zeros, or arrays containing a mix of different data types including `False`.","solution":"def move_zeros(array: list) -> list: Moves all zero values to the end of the array, maintaining the order of non-zero elements. Parameters: array (list): A list containing various types of elements. Returns: list: A new list with all zero values moved to the end. non_zeros = [] zeros = [] for element in array: if element == 0 and not isinstance(element, bool): zeros.append(element) else: non_zeros.append(element) return non_zeros + zeros"},{"question":"# Problem: Graph Connectivity Check You are given a graph represented as an adjacency list, and a starting node. Your task is to implement functions to count the number of connected components in the graph using both Depth First Search (DFS) and Breadth First Search (BFS). Input * `graph`: A dictionary representing the adjacency list of the graph. Keys are node values and each key has a list of its neighboring nodes. * `start`: The node value where traversal starts. Output Return the number of connected components in the graph. Constraints * All node values are unique. * The graph may be disconnected i.e., it may consist of several disconnected components. * The graph can be cyclic or acyclic. * The graph can contain up to 1000 nodes. Performance Requirements The solution should be efficient with respect to both time and space complexities. Aim for linear complexity in relation to the number of nodes and edges. Example ```python graph = { 0: [1, 2], 1: [0], 2: [0], 3: [4], 4: [3] } start = 0 ``` *Output*: `2` (The graph has two connected components: {0,1,2} and {3,4}) # Requirements 1. Implement the function `count_connected_components_dfs(graph, start)` using DFS. 2. Implement the function `count_connected_components_bfs(graph, start)` using BFS. ```python def count_connected_components_dfs(graph, start): # Your code here pass def count_connected_components_bfs(graph, start): # Your code here pass ``` Make sure to handle edge cases, such as an empty graph or a graph with a single node.","solution":"def count_connected_components_dfs(graph, start): Returns the number of connected components in the graph using DFS. visited = set() def dfs(node): stack = [node] while stack: current = stack.pop() if current not in visited: visited.add(current) for neighbor in graph.get(current, []): if neighbor not in visited: stack.append(neighbor) components = 0 for node in graph: if node not in visited: dfs(node) components += 1 return components def count_connected_components_bfs(graph, start): Returns the number of connected components in the graph using BFS. visited = set() def bfs(node): queue = [node] while queue: current = queue.pop(0) if current not in visited: visited.add(current) for neighbor in graph.get(current, []): if neighbor not in visited: queue.append(neighbor) components = 0 for node in graph: if node not in visited: bfs(node) components += 1 return components"},{"question":"# Question Scenario You are working on a problem that requires you to identify Krishnamurthy numbers within a given range. Your task is to write a function that can efficiently determine if numbers in that range are Krishnamurthy numbers. Task Write a function `find_krishnamurthy_numbers_in_range(start: int, end: int) -> List[int]` that identifies all Krishnamurthy numbers within a specified inclusive range `[start, end]`. # Requirements - Input: Two integers, `start` and `end` (0 <= start <= end <= 10^6) - Output: A list of integers, consisting of all Krishnamurthy numbers within the specified range. # Constraints - You must use optimal time and space complexity as much as possible. - Factorials should be precomputed for digits 0-9 to save time. # Example ```python find_krishnamurthy_numbers_in_range(1, 150) # Should return [1, 2, 145] find_krishnamurthy_numbers_in_range(100, 50000) # Should return [145, 40585] ``` # Hint Use the provided function `find_factorial` for factorial calculation and the `krishnamurthy_number` function for a single number check. Iterate over the range from `start` to `end` and collect all Krishnamurthy numbers.","solution":"from typing import List def find_factorial(n: int) -> int: if n == 0 or n == 1: return 1 result = 1 for i in range(2, n + 1): result *= i return result # Precompute the factorials of digits 0-9 factorials = {i: find_factorial(i) for i in range(10)} def is_krishnamurthy_number(n: int) -> bool: return n == sum(factorials[int(digit)] for digit in str(n)) def find_krishnamurthy_numbers_in_range(start: int, end: int) -> List[int]: krishnamurthy_numbers = [] for number in range(start, end + 1): if is_krishnamurthy_number(number): krishnamurthy_numbers.append(number) return krishnamurthy_numbers"},{"question":"# Problem Description You are tasked with implementing the Interpolation Search algorithm, but with additional functionality to safeguard against performance degradation caused by non-uniform data distributions. Your enhanced version should switch to Binary Search if the calculated probable position is out of expected bounds too frequently (more than a predefined threshold). # Function Signature ```python def enhanced_interpolation_search(array: List[int], search_key: int, switch_threshold: int = 3) -> int: pass ``` # Input * `array`: List[int] - A sorted list of integers `[a1, a2, ..., an]`. * `search_key`: int - The target element to search for. * `switch_threshold`: int - Number of times the algorithm can tolerate bad position estimates before switching to Binary Search (default value: 3). # Output * Returns the index of `search_key` if found in `array`, otherwise returns -1. # Constraints * The input list, `array`, will have a maximum length of `10^6`. * The input list, `array`, will contain integers between `-10^9` to `10^9`. # Examples ```python array1 = [10, 12, 14, 17, 20, 21] search_key1 = 17 switch_threshold1 = 2 print(enhanced_interpolation_search(array1, search_key1, switch_threshold1)) # Output: 3 array2 = [1, 3, 5, 7, 8, 9, 11] search_key2 = 15 switch_threshold2 = 2 print(enhanced_interpolation_search(array2, search_key2, switch_threshold2)) # Output: -1 array3 = [10, 10, 10, 10, 10, 15, 20, 25] search_key3 = 15 switch_threshold3 = 3 print(enhanced_interpolation_search(array3, search_key3, switch_threshold3)) # Output: 5 ``` # Implementation Guidelines 1. Begin with the Interpolation Search method. 2. Track miscalculations (cases where the estimated position is significantly off). 3. If miscalculations exceed `switch_threshold`, switch to Binary Search. # Additional Notes * Submit error-free and efficient code. * Ensure it handles edge cases like empty arrays, duplicates, single-element arrays.","solution":"from typing import List def binary_search(array: List[int], search_key: int) -> int: low, high = 0, len(array) - 1 while low <= high: mid = (low + high) // 2 if array[mid] == search_key: return mid elif array[mid] < search_key: low = mid + 1 else: high = mid - 1 return -1 def enhanced_interpolation_search(array: List[int], search_key: int, switch_threshold: int = 3) -> int: low, high = 0, len(array) - 1 bad_position_count = 0 while low <= high and search_key >= array[low] and search_key <= array[high]: if low == high: if array[low] == search_key: return low return -1 position = low + ((high - low) // (array[high] - array[low]) * (search_key - array[low])) # Check for the probable position out of bounds if position < low or position > high: bad_position_count += 1 if bad_position_count >= switch_threshold: return binary_search(array, search_key) else: bad_position_count = 0 if array[position] == search_key: return position if array[position] < search_key: low = position + 1 else: high = position - 1 return binary_search(array, search_key) # Example usage: # array1 = [10, 12, 14, 17, 20, 21] # search_key1 = 17 # switch_threshold1 = 2 # print(enhanced_interpolation_search(array1, search_key1, switch_threshold1)) # Output: 3"},{"question":"# Knuth-Morris-Pratt Pattern Matching Algorithm Scenario You are developing an email filter that detects specific keywords within incoming emails. You want to efficiently find the positions of all occurrences of these keywords within the email body. Task Implement a function using the Knuth-Morris-Pratt (KMP) algorithm to find all starting positions of a keyword in a given email body. Function Signature ```python def find_keyword_positions(email_body: str, keyword: str) -> List[int]: Finds all starting positions of the keyword in the email body using the KMP pattern matching algorithm. Args: email_body: A string representing the body of the email. keyword: A string representing the keyword to search for. Returns: A list of integers representing the starting positions where the keyword is found in the email body. Examples: find_keyword_positions(\\"Welcome to the new world\\", \\"new\\") should return [15] find_keyword_positions(\\"Knuth-Morris-Pratt is the best\\", \\"great\\") should return [] find_keyword_positions(\\"Repeat repeat repeat\\", \\"repeat\\") should return [7, 14] pass ``` Constraints * The email body and keyword will consist of only lowercase alphabets and spaces. * Length of the email body will not exceed 100,000 characters. * Length of the keyword will not exceed 10,000 characters. Performance Requirements * The function should run in O(N + M) time complexity, where N is the length of the email body and M is the length of the keyword. Notes * Return an empty list if the keyword is not found in the email body. * Ensure that your solution handles all edge cases efficiently.","solution":"def find_keyword_positions(email_body: str, keyword: str) -> [int]: Finds all starting positions of the keyword in the email body using the KMP pattern matching algorithm. Args: email_body: A string representing the body of the email. keyword: A string representing the keyword to search for. Returns: A list of integers representing the starting positions where the keyword is found in the email body. def compute_lps(pattern: str) -> [int]: Compute the Longest Prefix Suffix (LPS) array. LPS = [0] * len(pattern) length = 0 i = 1 while i < len(pattern): if pattern[i] == pattern[length]: length += 1 LPS[i] = length i += 1 else: if length != 0: length = LPS[length - 1] else: LPS[i] = 0 i += 1 return LPS N = len(email_body) M = len(keyword) if M == 0: return [] LPS = compute_lps(keyword) result = [] i = 0 # Index for email_body j = 0 # Index for keyword while i < N: if keyword[j] == email_body[i]: i += 1 j += 1 if j == M: result.append(i - j) j = LPS[j - 1] elif i < N and keyword[j] != email_body[i]: if j != 0: j = LPS[j - 1] else: i += 1 return result"},{"question":"**Sorting Student Grades** You are working on an application that sorts student grades before displaying them on the class dashboard. You must implement an efficient sorting function using the Insertion Sort algorithm. The grades should be displayed in ascending order. Additionally, the function should also be able to provide a step-by-step simulation of the sorting process. Function Signature ```python def insertion_sort(grades: list[int], simulation: bool=False) -> list[int]: pass ``` Input * `grades`: A list of integers representing student grades (0 <= grades[i] <= 100, 0 <= len(grades) <= 1000). * `simulation`: A boolean flag indicating whether to print the sorting process step-by-step. Output * Returns a list of integers representing the sorted student grades in ascending order. Constraints * If `simulation` is set to `True`, the function should print each iteration of the sorting process. * The function should handle edge cases such as an empty list or a list with a single element. Example ```python print(insertion_sort([84, 92, 76, 91, 58], True)) # Expected output for step-by-step simulation: # iteration 0 : 84 92 76 91 58 # iteration 1 : 84 92 76 91 58 # iteration 2 : 76 84 92 91 58 # iteration 3 : 76 84 91 92 58 # iteration 4 : 58 76 84 91 92 # Final returned list: [58, 76, 84, 91, 92] print(insertion_sort([34, 35, 35, 33, 30], False)) # Expected output: [30, 33, 34, 35, 35] ``` Note * Focus on properly implementing the insertion sort algorithm. * Ensure the simulation correctly reflects each iteration\'s status of the list. * The time complexity should be acceptable for the given input size (n <= 1000).","solution":"def insertion_sort(grades: list[int], simulation: bool=False) -> list[int]: Sorts the list of grades using the Insertion Sort algorithm. Args: grades (list of int): List of student grades to be sorted. simulation (bool): Flag to indicate whether to print step-by-step sorting process. Returns: list of int: Sorted list of grades. n = len(grades) if simulation: print(f\\"initial list: {\' \'.join(map(str, grades))}\\") for i in range(1, n): key = grades[i] j = i - 1 while j >= 0 and grades[j] > key: grades[j + 1] = grades[j] j -= 1 grades[j + 1] = key if simulation: print(f\\"iteration {i} : {\' \'.join(map(str, grades))}\\") if simulation: print(f\\"final sorted list: {\' \'.join(map(str, grades))}\\") return grades"},{"question":"Decode Ways Given an encoded message containing digits from \'0\' to \'9\', determine the total number of ways to decode it. **Input Format**: - A single string `s` representing the encoded message. **Output Format**: - An integer indicating the total number of ways to decode the message. **Constraints**: - The input string will be non-empty and contain only digits. - The input string does not contain any invalid sequences like leading zeros (e.g., \\"01\\"). # Example * **Example 1**: ``` Input: s = \\"12\\" Output: 2 Explanation: \\"12\\" can be decoded as \\"AB\\" (1 2) or \\"L\\" (12). ``` * **Example 2**: ``` Input: s = \\"226\\" Output: 3 Explanation: \\"226\\" can be decoded as \\"BZ\\" (2 26), \\"VF\\" (22 6), or \\"BBF\\" (2 2 6). ``` * **Example 3**: ``` Input: s = \\"0\\" Output: 0 Explanation: \\"0\\" cannot be decoded. ``` * **Example 4**: ``` Input: s = \\"06\\" Output: 0 Explanation: \\"06\\" cannot be decoded as a valid \'zero\' decode leading digit. # Function Signature ```python def num_decodings(s: str) -> int: # your implementation here ``` # Your Task Implement the function `num_decodings(s: str) -> int` that returns the number of ways to decode the input string `s`. # Note Ensure the function handles all edge cases, such as strings with zeros and invalid formats properly, while maintaining optimal performance.","solution":"def num_decodings(s: str) -> int: if not s or s[0] == \'0\': return 0 n = len(s) dp = [0] * (n + 1) dp[0], dp[1] = 1, 1 for i in range(1, n): if s[i] != \'0\': dp[i + 1] += dp[i] if 10 <= int(s[i-1:i+1]) <= 26: dp[i + 1] += dp[i - 1] return dp[n]"},{"question":"# Implementing a Circular ZigZag Iterator **Objective**: Implement a circular iterator that takes in multiple lists and iterates through them in a round-robin fashion. **Scenario**: Given `k` input lists, create an iterator that produces elements one by one from each list in a round-robin fashion until all lists are exhausted. If a list runs out of elements, it should be skipped in further rounds. **Function Signature**: ```python class CircularZigZagIterator: def __init__(self, lists: List[List[int]]): Initialize the iterator with a list of lists. :param lists: A list of lists where each sublist contains integers. pass def next(self) -> int: Returns the next element from the multi-lists in a round-robin manner. :return: The next integer. pass def has_next(self) -> bool: Check if there are remaining elements in any of the lists. :return: Boolean indicating if any elements are left. pass ``` **Input**: * The `__init__` method should take a list of lists, where each sublist contains integers. * The `next` method returns the next integer in the round-robin sequence. * The `has_next` method indicates whether there are more elements to iterate. **Output**: * `next` returns the next integer. * `has_next` returns a boolean indicating if any lists have remaining elements. **Constraints**: * Each sublist is non-empty and contains only integers. * The total number of integers across all lists does not exceed 10^5. **Example**: ```python l1 = [1, 2] l2 = [3, 4, 5, 6] l3 = [7, 8, 9] it = CircularZigZagIterator([l1, l2, l3]) result = [] while it.has_next(): result.append(it.next()) # Expected output: [1, 3, 7, 2, 4, 8, 5, 9, 6] print(result) ```","solution":"from collections import deque from typing import List class CircularZigZagIterator: def __init__(self, lists: List[List[int]]): Initialize the iterator with a list of lists. :param lists: A list of lists where each sublist contains integers. # Queue of (iterator, remaining count) pairs self.queue = deque((iter(lst), len(lst)) for lst in lists if lst) def next(self) -> int: Returns the next element from the multi-lists in a round-robin manner. :return: The next integer. if not self.has_next(): raise StopIteration(\\"No more elements in the iterator.\\") # Pop the front element it, count = self.queue.popleft() element = next(it) count -= 1 # If there are remaining elements, add it back to the queue if count > 0: self.queue.append((it, count)) return element def has_next(self) -> bool: Check if there are remaining elements in any of the lists. :return: Boolean indicating if any elements are left. return len(self.queue) > 0"},{"question":"# Coding Challenge: Reversing a String Using Different Approaches Problem Statement You are required to implement function(s) to reverse a string. Your implementation should demonstrate a deep understanding of different approaches and their characteristics. You will implement the following: 1. **Recursive String Reversal**: Implement a function `reverse_recursive(s: str) -> str` that reverses the input string using recursion. 2. **Iterative String Reversal**: Implement a function `reverse_iterative(s: str) -> str` that reverses the input string using an iterative approach. 3. **Pythonic String Reversal**: Implement a function `reverse_pythonic(s: str) -> str` that reverses the input string using a Pythonic approach. Requirements - The functions should take a string `s` as input and return a new string which is the reversed version of `s`. - Assume valid input: the string only contains printable ASCII characters and is not `None`. Example ```python assert reverse_recursive(\\"hello\\") == \\"olleh\\" assert reverse_iterative(\\"world\\") == \\"dlrow\\" assert reverse_pythonic(\\"example\\") == \\"elpmaxe\\" ``` Constraints - The length of the string ( s ) is ( 0 leq text{len}(s) leq 10^6 ). - Consider the trade-offs between time and space complexities in your implementations. - Provide thorough test cases to demonstrate your solution\'s correctness. Notes - Edge cases to consider: empty string, single character string. - Evaluate the performance difference between your implementations through time complexity analysis.","solution":"def reverse_recursive(s: str) -> str: Reverses the string using recursion. if len(s) <= 1: return s return reverse_recursive(s[1:]) + s[0] def reverse_iterative(s: str) -> str: Reverses the string using an iterative approach. reversed_str = [] for char in s: reversed_str.insert(0, char) return \'\'.join(reversed_str) def reverse_pythonic(s: str) -> str: Reverses the string using Python\'s slicing. return s[::-1]"},{"question":"You have been provided with a sorted integer array without duplicates. Your task is to compress this array into a list of ranges. Each range should be represented as a string. The ranges should cover all consecutive integers in the array. # Input - A sorted list of integers without duplicates, denoted as `array`. # Output - A list of strings, where each string represents a summarized range. # Function Signature ```python def summarize_ranges(array: List[int]) -> List[str]: ``` # Examples Example 1 ```python array = [0, 1, 2, 4, 5, 7] Output: [\\"0-2\\", \\"4-5\\", \\"7\\"] ``` Example 2 ```python array = [1, 3, 5, 7] Output: [\\"1\\", \\"3\\", \\"5\\", \\"7\\"] ``` Example 3 ```python array = [1, 2, 3, 4, 5] Output: [\\"1-5\\"] ``` # Constraints - The input array is guaranteed to be sorted and contains no duplicates. - The input list will have at least one element. - The length of the array will not exceed 10^4. Performance Requirements - Your implementation should run in linear time, O(n), with respect to the number of elements in the input array. # Notes - Think carefully about edge cases such as arrays with only one or two elements. - Consider how to efficiently summarize the ranges without needing extra passes through the array.","solution":"from typing import List def summarize_ranges(array: List[int]) -> List[str]: if not array: return [] ranges = [] start = end = array[0] for num in array[1:]: if num == end + 1: end = num else: if start == end: ranges.append(f\\"{start}\\") else: ranges.append(f\\"{start}-{end}\\") start = end = num # Add the last range if start == end: ranges.append(f\\"{start}\\") else: ranges.append(f\\"{start}-{end}\\") return ranges"},{"question":"As a data engineer for a rapidly growing tech company, you\'ve been tasked to design an efficient hashing mechanism for storing and managing user data. The company expects the data to grow dynamically and wants to ensure rapid access and modifications to the data. Using the principles of the provided `ResizableHashTable` class, your task is to implement an `AutoResizingHashTable` class that includes the following functionalities: 1. **insert(key, value)**: Adds a new key-value pair to the table. If the key already exists, updates the value. 2. **retrieve(key)**: Returns the corresponding value for a given key. If the key doesn\'t exist, returns `None`. 3. **delete(key)**: Removes the key-value pair from the table. If the key doesn\'t exist, does nothing. 4. **keys()**: Returns a list of all keys currently stored in the table. 5. **load_factor()**: Returns the current load factor of the table (number of key-value pairs divided by the table size). Your implementation should handle collisions using linear probing and resize the hash table when the load factor exceeds 0.75 to maintain performance. # Requirements - **Input**: - `insert`: Two integers, `key` and `value`. - `retrieve`: One integer, `key`. - `delete`: One integer, `key`. - `keys`: No input parameters. - `load_factor`: No input parameters. - **Output**: - `insert`, `delete`: No return. - `retrieve`: Returns the value associated with the key or `None`. - `keys`: List of all keys. - `load_factor`: A floating-point number representing the current load factor. - **Constraints**: - Keys and values will be non-negative integers. - Operations will be performed with relatively small inputs for testing purposes, but your implementation should be efficient enough for large-scale use. # Example ```python # Creating an instance of AutoResizingHashTable hash_table = AutoResizingHashTable() # Inserting key-value pairs hash_table.insert(1, 10) hash_table.insert(2, 20) hash_table.insert(3, 30) # Retrieving values print(hash_table.retrieve(1)) # Output: 10 print(hash_table.retrieve(4)) # Output: None # Deleting a key hash_table.delete(2) print(hash_table.retrieve(2)) # Output: None # Getting all keys print(hash_table.keys()) # Output: [1, 3] # Checking the load factor print(hash_table.load_factor()) # Output: Depends on the current state ``` Implement the `AutoResizingHashTable` class below: ```python class AutoResizingHashTable: def __init__(self): # your initialization code here def insert(self, key, value): # your insertion code here def retrieve(self, key): # your retrieval code here def delete(self, key): # your deletion code here def keys(self): # your method to get all keys here def load_factor(self): # your load factor code here ```","solution":"class AutoResizingHashTable: def __init__(self, initial_capacity=8): self.table = [None] * initial_capacity self.size = 0 self.capacity = initial_capacity def _hash(self, key): return key % self.capacity def _resize(self): old_table = self.table self.capacity *= 2 self.table = [None] * self.capacity self.size = 0 for item in old_table: if item is not None: self.insert(item[0], item[1]) def insert(self, key, value): if self.load_factor() > 0.75: self._resize() idx = self._hash(key) while self.table[idx] is not None and self.table[idx][0] != key: idx = (idx + 1) % self.capacity if self.table[idx] is None: self.size += 1 self.table[idx] = (key, value) def retrieve(self, key): idx = self._hash(key) original_idx = idx while self.table[idx] is not None: if self.table[idx][0] == key: return self.table[idx][1] idx = (idx + 1) % self.capacity if idx == original_idx: break return None def delete(self, key): idx = self._hash(key) original_idx = idx while self.table[idx] is not None: if self.table[idx][0] == key: self.table[idx] = None self.size -= 1 return idx = (idx + 1) % self.capacity if idx == original_idx: break def keys(self): return [item[0] for item in self.table if item is not None] def load_factor(self): return self.size / self.capacity"},{"question":"# Context You are given an array of n objects, each color-coded as red, white, or blue. The objective is to rearrange the array such that objects of the same color are adjacent and ordered as red, white, and blue. The integers 0, 1, and 2 represent the colors red, white, and blue, respectively. # Problem Statement Implement a function that sorts the given array in-place without using any library sort function. # Function Signature ```python def sort_colors(nums: List[int]) -> None: Modify the nums list in-place to sort the colors. Args: nums (List[int]): A list of integers where 0 represents red, 1 represents white, and 2 represents blue. Returns: None: The function should modify the nums list in-place. ``` # Examples ```python # Example 1 nums = [2, 0, 2, 1, 1, 0] sort_colors(nums) print(nums) # Output: [0, 0, 1, 1, 2, 2] # Example 2 nums = [2, 0, 1] sort_colors(nums) print(nums) # Output: [0, 1, 2] # Example 3 nums = [0] sort_colors(nums) print(nums) # Output: [0] # Example 4 nums = [1, 2, 0] sort_colors(nums) print(nums) # Output: [0, 1, 2] ``` # Constraints * Do not use any built-in sorting functions. * The function should work in O(n) time complexity. * Use only O(1) extra space (in-place sorting). # Notes * Ensure your function handles edge cases such as empty arrays and arrays with all elements being the same. * To avoid incorrect results, pay careful attention to how you manage the pointers and array indices during implementation.","solution":"from typing import List def sort_colors(nums: List[int]) -> None: Modify the nums list in-place to sort the colors. Args: nums (List[int]): A list of integers where 0 represents red, 1 represents white, and 2 represents blue. Returns: None: The function should modify the nums list in-place. low, mid, high = 0, 0, len(nums) - 1 while mid <= high: if nums[mid] == 0: nums[low], nums[mid] = nums[mid], nums[low] low += 1 mid += 1 elif nums[mid] == 1: mid += 1 else: nums[high], nums[mid] = nums[mid], nums[high] high -= 1"},{"question":"# Ordered Stack Implementation and Query Operations You are given an implementation of an `OrderedStack` class, which maintains stack elements in ascending order with the highest value on top. Based on this provided code, you are to implement two additional features in the `OrderedStack` class: 1. **find_min**: This method should return the smallest element in the stack without modifying the stack. 2. **sort_stack**: This method should return a new sorted list of the stack elements in increasing order. Method Headers ```python def find_min(self): # Finds and returns the minimum element in the stack pass def sort_stack(self): # Returns a new list with stack elements sorted in increasing order pass ``` Detailed Requirements 1. `find_min`: Should efficiently find and return the smallest element in the stack. Ensure this function has a time complexity better than or equal to O(n). 2. `sort_stack`: Should return a new list containing the stack elements in increasing order without modifying the original ordered stack. The `OrderedStack` class should look like: ```python class OrderedStack: def __init__(self): self.items = [] def is_empty(self): return self.items == [] def push_t(self, item): self.items.append(item) def push(self, item): temp_stack = OrderedStack() if self.is_empty() or item > self.peek(): self.push_t(item) else: while item < self.peek() and not self.is_empty(): temp_stack.push_t(self.pop()) self.push_t(item) while not temp_stack.is_empty(): self.push_t(temp_stack.pop()) def pop(self): if self.is_empty(): raise IndexError(\\"Stack is empty\\") return self.items.pop() def peek(self): return self.items[len(self.items) - 1] def size(self): return len(self.items) def find_min(self): pass def sort_stack(self): pass ``` Constraints * Method calls to `find_min` and `sort_stack` can be made multiple times. * `OrderedStack` will only contain integers. * `find_min` must not alter the internal order of the stack. * `sort_stack` should return a new list with elements in non-decreasing order. Example: ```python stack = OrderedStack() stack.push(3) stack.push(1) stack.push(2) stack.push(4) print(stack.find_min()) # Output should be 1 print(stack.sort_stack()) # Output should be [1, 2, 3, 4] ``` You must implement the specified methods (`find_min` and `sort_stack`) such that they adhere to the given requirements and constraints.","solution":"class OrderedStack: def __init__(self): self.items = [] def is_empty(self): return self.items == [] def push_t(self, item): self.items.append(item) def push(self, item): temp_stack = OrderedStack() if self.is_empty() or item > self.peek(): self.push_t(item) else: while not self.is_empty() and item < self.peek(): temp_stack.push_t(self.pop()) self.push_t(item) while not temp_stack.is_empty(): self.push_t(temp_stack.pop()) def pop(self): if self.is_empty(): raise IndexError(\\"Stack is empty\\") return self.items.pop() def peek(self): return self.items[-1] def size(self): return len(self.items) def find_min(self): if self.is_empty(): raise IndexError(\\"Stack is empty\\") return min(self.items) def sort_stack(self): return sorted(self.items)"},{"question":"# Problem: Increment Large Numbers Represented as Arrays You are given an array `digits` that represents a non-negative integer, where each element in the array is a digit in the number. The entire number might be very large, but the digits are stored in a manner such that the most significant digit is at the head of the list. Your task is to implement a function `plus_one` that should add one to the integer represented by the array and return the resulting array of digits. Function Signature: ```python def plus_one(digits: List[int]) -> List[int]: ``` # Input * `digits` - a list of integers where each integer is between `0` and `9`, representing a non-negative number. * Example: `[1, 2, 3]` represents the number `123`. # Output * The function should return a list of integers representing the number with one added. * Example: Given the input `[1, 2, 3]`, the output should be `[1, 2, 4]`. # Constraints * The input list will always have at least one element. * The integer represented by the array will be non-negative. * Your solution should handle the carry operation correctly and be efficient in terms of both time and space complexity. # Performance Requirements * The implemented algorithm should have a time complexity of `O(n)` where `n` is the length of the input list. * It should also have a space complexity of `O(1)` if modifying the list in-place or `O(n)` if constructing a new list. # Example ```python assert plus_one([1, 2, 3]) == [1, 2, 4] assert plus_one([9, 9, 9]) == [1, 0, 0, 0] assert plus_one([0]) == [1] assert plus_one([9, 8, 7, 6, 5, 4, 3, 2, 1, 0]) == [9, 8, 7, 6, 5, 4, 3, 2, 1, 1] ``` # Notes * You can use any of the provided code snippets as reference, but ensure that your solution is efficient and meets the space and time complexity requirements.","solution":"from typing import List def plus_one(digits: List[int]) -> List[int]: Given a list of integers representing a non-negative integer, increment the integer by one and return the resulting list of digits. n = len(digits) for i in range(n-1, -1, -1): if digits[i] < 9: digits[i] += 1 return digits digits[i] = 0 return [1] + digits"},{"question":"Given an unsorted array of integers, write a function `findLongestIncreasingSubsequence(arr: List[int]) -> int` to find the length of the longest increasing subsequence. Implementation Requirements - Implement the function using an approach that has a time complexity of at most `O(n log n)` where `n` is the length of the input array. - Ensure your solution is optimized for both time and space. Input - A single parameter `arr` which is a list of integers, `1 <= len(arr), len(n) <= 10^5` where every element of `arr` can be a positive or negative integer with magnitude up to `10^5`. Output - Return an integer representing the length of the longest increasing subsequence in the given array. Constraints - You should optimize for performance, considering both time and space complexity. Example ```python Input: arr = [10, 9, 2, 5, 3, 7, 101, 18] Output: 4 Explanation: The longest increasing subsequence is [2, 3, 7, 101]. Input: arr = [0, 1, 0, 3, 2, 3] Output: 4 Explanation: The longest increasing subsequence is [0, 1, 2, 3]. ``` **Note:** You may use additional helper functions or data structures (such as segment trees), but they must be implemented within your solution.","solution":"from bisect import bisect_left def findLongestIncreasingSubsequence(arr): Returns the length of the longest increasing subsequence in the array. if not arr: return 0 lis = [] for num in arr: pos = bisect_left(lis, num) if pos == len(lis): lis.append(num) else: lis[pos] = num return len(lis)"},{"question":"# Stutter the Stack Context You are tasked with taking a given stack of integers and generating a new stack such that each integer in the original stack is duplicated consecutively. Requirements Write a function `stutter_stack(stack)` that receives a list of integers representing a stack (with the end of the list being the top of the stack). The function should return the modified stack where each integer from the original stack appears twice in consecutive positions. Input and Output Format * **Input**: A list `stack` of integers, representing the original stack. The end of the list is to be treated as the \'top\' of the stack. * **Output**: A modified list where each value in the original stack is duplicated consecutively. Constraints * You may use either an additional stack or a queue to accomplish the task. * The function should preserve the order of data as in the original stack. Example **Example 1**: * Input: `[3, 7, 1, 14, 9]` * Output: `[3, 3, 7, 7, 1, 1, 14, 14, 9, 9]` **Example 2**: * Input: `[5, 2, 8]` * Output: `[5, 5, 2, 2, 8, 8]` **Example 3**: * Input: `[]` * Output: `[]` Additional Notes 1. Aim for an efficient solution both in terms of time and space. 2. Be mindful of edge cases, such as empty stacks or stacks with a single element.","solution":"def stutter_stack(stack): Given a stack of integers, returns a new stack where each integer is duplicated consecutively. Parameters: stack (list): List of integers representing the original stack Returns: list: New stack with each integer duplicated consecutively stuttered_stack = [] for value in stack: stuttered_stack.append(value) stuttered_stack.append(value) return stuttered_stack"},{"question":"# Scenario: You are developing a text editor that provides suggestions for correcting and aligning text between two document versions. One crucial feature is to determine how similar two versions are by finding the minimum number of delete operations needed to make them identical. # Task: Write a function `min_distance_optimized(word1, word2)` that follows these constraints: 1. Uses a dynamic programming approach. 2. Optimizes space complexity without affecting the time complexity. # Input and Output: - **Input**: Two strings `word1` and `word2`. - **Output**: An integer representing the minimum number of deletions required. # Constraints: - The length of both strings will be between 0 and 1000. - All characters in the strings are lowercase English letters. # Performance Requirement: - Your solution must have a time complexity of `O(m * n)` and an optimized space complexity of `O(min(m, n))`. # Example: ```python def min_distance_optimized(word1, word2): # Implementation here pass # Test Case assert min_distance_optimized(\\"sea\\", \\"eat\\") == 2 assert min_distance_optimized(\\"abcd\\", \\"abc\\") == 1 assert min_distance_optimized(\\"\\", \\"abc\\") == 3 assert min_distance_optimized(\\"abc\\", \\"\\") == 3 ``` # Explanation: - For the input `\\"sea\\"` and `\\"eat\\"`, you need two deletions to make the strings equal: * Delete \'s\' from `\\"sea\\"` to get `\\"ea\\"`. * Delete \'t\' from `\\"eat\\"` to get `\\"ea\\"`. - Ensure the function efficiently uses space by only keeping the necessary parts of the DP table at any time.","solution":"def min_distance_optimized(word1, word2): Returns the minimum number of deletions required to make the two strings identical. Uses a dynamic programming approach with optimized space complexity. m, n = len(word1), len(word2) # Ensure that `m` is the smaller length to use less space if m > n: word1, word2 = word2, word1 m, n = n, m # Initialize the previous and current row for DP prev_row = list(range(m + 1)) current_row = [0] * (m + 1) # Iterate over the second string for j in range(1, n + 1): current_row[0] = j for i in range(1, m + 1): if word1[i - 1] == word2[j - 1]: current_row[i] = prev_row[i - 1] else: current_row[i] = min(prev_row[i], current_row[i - 1]) + 1 # Swap rows for the next iteration prev_row, current_row = current_row, prev_row return prev_row[m]"},{"question":"# Question You are tasked with implementing the `ZigzagIterator` class that iterates over two input lists in a zigzag manner. You need to interleave the elements from the two lists such that elements are picked alternatively. If one list is exhausted before the other, continue with the remaining elements of the non-exhausted list. You are to implement the `next` and `has_next` methods that accomplish this task. Function Signatures: ```python class ZigzagIterator: def __init__(self, v1: List[int], v2: List[int]): pass def next(self) -> int: pass def has_next(self) -> bool: pass ``` Example Suppose you are given two input lists: ```python v1 = [1, 2] v2 = [3, 4, 5, 6] ``` When using the `ZigzagIterator` like this: ```python it = ZigzagIterator(v1, v2) result = [] while it.has_next(): result.append(it.next()) print(result) ``` The expected output should be: ``` [1, 3, 2, 4, 5, 6] ``` Constraints: * `0 <= len(v1), len(v2) <= 1000` * `1 <= v1[i], v2[i] <= 1000` # Requirements: * The `next` method should return the next element in zigzag order. * The `has_next` method should return `True` if there are still elements to iterate over, otherwise `False`. Notes: - Consider edge cases like when one or both lists are empty. - Ensure you handle all possible scenarios efficiently and correctly. Provide the implementation of the `ZigzagIterator` class adhering to the specified requirements.","solution":"from collections import deque class ZigzagIterator: def __init__(self, v1, v2): Initialize the ZigzagIterator with two lists. self.queue = deque([(v1, 0), (v2, 0)]) def next(self): Return the next element in zigzag order. if self.has_next(): v, idx = self.queue.popleft() value = v[idx] if idx + 1 < len(v): self.queue.append((v, idx + 1)) return value def has_next(self): Return True if there are still elements to iterate over, otherwise False. while self.queue and self.queue[0][1] >= len(self.queue[0][0]): self.queue.popleft() return len(self.queue) > 0"},{"question":"# Coding Challenge: Coin Change Combinations Background Imagine you are responsible for developing a feature in a financial software that calculates the number of ways to achieve a specific amount using given coin denominations. You need to determine all the combinations of the given coin denominations that sum up to a target amount. Task Write a function `count_ways` to determine the number of different combinations (order of coins does not matter) that can sum up to a given value using the specified denominations of coins. Function Signature ```python def count_ways(coins: list[int], value: int) -> int: ``` Input - `coins`: A list of unique integers where each integer represents the denomination of a coin. (1 <= len(coins) <= 100, 1 <= coins[i] <= 100) - `value`: An integer indicating the amount you need to reach using any combination of the given coins. (1 <= value <= 1000) Output - Returns an integer, representing the number of different combinations of coins that sum up to the `value`. Example ```python coins = [1, 2, 3] value = 4 print(count_ways(coins, value)) # Output: 4 coins = [2, 5, 3, 6] value = 10 print(count_ways(coins, value)) # Output: 5 ``` Constraints - Assume you have an infinite supply of each type of coin. - You must ensure your solution runs efficiently for the given input ranges. Additional Information - You should consider edge cases like when `value` is zero or the list of `coins` is empty. - The algorithm’s performance should be within acceptable limits given the input constraints.","solution":"def count_ways(coins: list[int], value: int) -> int: Returns the number of ways to combine coins to achieve the specified value. # Initialize a dp array with zeros and set dp[0] to 1 dp = [0] * (value + 1) dp[0] = 1 # Iterate over each coin and update the dp array for coin in coins: for x in range(coin, value + 1): dp[x] += dp[x - coin] return dp[value]"},{"question":"Given an array of floating-point numbers uniformly distributed over the range [0, 1), implement a bucket sort algorithm to sort the array. # Problem Description **Function Signature**: `def bucket_sort(arr: List[float]) -> List[float]` Write a Python function that sorts an array of floating-point numbers using the bucket sort algorithm. The function should: 1. Create buckets and distribute the input numbers into the appropriate buckets. 2. Sort the numbers within each bucket using insertion sort. 3. Concatenate the sorted buckets to form the final sorted array. # Parameters: - `arr` (List[float]): An array of floating-point numbers within the range [0.0, 1.0). # Returns: - `List[float]`: A new array with the input numbers sorted in ascending order. # Constraints: - The input array is guaranteed to contain floating-point numbers in the range [0.0, 1.0). - Duplicate values may occur. - The length of the array will not exceed 10^6 elements. - The array can contain zero or more elements. # Example: ```python input_array = [0.78, 0.17, 0.39, 0.26, 0.72, 0.94, 0.21, 0.12, 0.23, 0.68] sorted_array = bucket_sort(input_array) print(sorted_array) # Output: [0.12, 0.17, 0.21, 0.23, 0.26, 0.39, 0.68, 0.72, 0.78, 0.94] ``` # Notes: - Ensure the algorithm handles edge cases, such as an empty input array gracefully. - Focus on the efficiency of bucket distribution and sorting using insertion sort within each bucket. - Provide any assumptions you make explicitly in your code comments.","solution":"from typing import List def insertion_sort(arr: List[float]) -> List[float]: for i in range(1, len(arr)): key = arr[i] j = i - 1 while j >= 0 and key < arr[j]: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key return arr def bucket_sort(arr: List[float]) -> List[float]: if not arr: return [] # Number of buckets n = len(arr) buckets = [[] for _ in range(n)] # Distribute input array values into buckets for num in arr: index = int(n * num) # Bucket index buckets[index].append(num) # Sort each bucket using insertion sort for i in range(n): buckets[i] = insertion_sort(buckets[i]) # Concatenate all sorted buckets sorted_array = [] for bucket in buckets: sorted_array.extend(bucket) return sorted_array"},{"question":"You are working on a system utility tool that processes file paths provided by users. One of the key functionalities of this tool is to ensure that any file path input is transformed into its absolute form, resolving relative paths and user-specific shortcuts. Please implement the function `resolve_path` which takes a single argument `path`, a string representing a file path, and returns the fully resolved absolute path. The resolution should handle user home shortcuts (`~`) and convert any relative path into an absolute path based on the current working directory. # Input - `path`: a string representing a file path (1 ≤ `len(path)` ≤ 1000), which may include user home shortcuts (`~`). # Output - Return the absolute path as a string. # Constraints - Ensure the path length does not exceed 1000 characters. - User home shortcuts (`~`) should resolve correctly based on the system running the script. - The function should handle paths that contain directory references like `..` and `.` efficiently. # Example ```python # Example 1: path = \\"~/documents/file.txt\\" print(resolve_path(path)) # Outputs the absolute path representation of \\"~/documents/file.txt\\" # Example 2: path = \\"../up_one_level/file.txt\\" print(resolve_path(path)) # Outputs the absolute path by resolving one directory level up ``` # Additional Information - Use appropriate Python library functions to handle path transformations. - Ensure the script does not raise errors for non-existent paths; simply resolve them. - Do not utilize external libraries beyond the standard library.","solution":"import os def resolve_path(path): Returns the absolute path by resolving user home shortcuts (~) and relative paths. return os.path.abspath(os.path.expanduser(path))"},{"question":"Context In computer systems, binary representation of data is fundamental. Given n-bit integers, certain operations involve flipping a specific bit (0 to 1 or vice versa). One such challenge arises in optimizing the length of sequences of 1s. Problem Description You are given a non-negative integer. You can flip **exactly one bit** from 0 to 1 to achieve the maximum possible length of consecutive 1s in the binary representation of the number. Task Write a function `flip_bit_longest_seq(num: int) -> int` that takes a single non-negative integer `num` and returns the length of the longest sequence of consecutive 1s that can be obtained by flipping exactly one bit from 0 to 1 in its binary representation. Expected Input and Output - **Input**: - An integer `num` where 0 ≤ `num` ≤ 2^31 - 1 (standard 32-bit integers). - **Output**: - An integer representing the length of the longest sequence of 1s after flipping one 0 bit. Constraints - You must flip exactly one bit, i.e., at least one 0 must be present in the binary representation of `num`. Example - **Input**: 1775 - Binary representation: `11011101111` - **Output**: 8 - By flipping the 0 between the first and second groups of 1s, `11011111111` is formed with a length of 8 consecutive 1s. Implementation Details This task tests your understanding of bit manipulation, efficient iteration over binary digits, and handling special edge cases when flipping bits in binary representation.","solution":"def flip_bit_longest_seq(num: int) -> int: Takes a non-negative integer num and returns the length of the longest sequence of 1s that can be achieved by flipping exactly one bit from 0 to 1 in its binary representation. if num == 0: return 1 # Flipping any bit in 0 makes it just a single 1 max_length = 1 current_length = 0 previous_length = 0 while num != 0: if (num & 1) == 1: # Current bit is a 1 current_length += 1 else: previous_length = current_length # Save the count of 1s before this 0 current_length = 0 max_length = max(max_length, previous_length + current_length + 1) num >>= 1 return max_length"},{"question":"Scenario You are developing a utility for an analytics application that processes sensor data readings. The application receives large arrays of numerical data points, but often only the readings within a specific range are of interest for detailed analysis. Problem Statement Write a function `filter_data_range` that takes an array of numbers and two optional limits (`min_limit`, `max_limit`). The function should return a new array containing only the elements that are greater than or equal to `min_limit` and less than or equal to `max_limit`. If `min_limit` is not provided, use the minimum value of the array. If `max_limit` is not provided, use the maximum value of the array. Input * An array `data` of length `n` (0 <= n <= 10^6) containing numerical values. * An optional number `min_limit` (defaults to None). * An optional number `max_limit` (defaults to None). Output An array containing the numbers from `data` that lie within the inclusive range `[min_limit, max_limit]`. Constraints * All elements in the input array `data` are comparable. * The function should handle large arrays efficiently. Example ```python # Example 1 data = [1, 5, 8, 12, 20] min_limit = 5 max_limit = 10 # Output: [5, 8] # Example 2 data = [3, 7, 10, 15, 20] min_limit = None max_limit = 12 # Output: [3, 7, 10] # Example 3 data = [] min_limit = 5 max_limit = 10 # Output: [] ``` Function Signature ```python def filter_data_range(data, min_limit=None, max_limit=None): pass ``` Requirements * The solution must have a time complexity of O(n). * The function must handle cases where `min_limit` or `max_limit` are None appropriately. * Ensure that edge cases (empty arrays, all elements beyond limits, etc.) are correctly managed.","solution":"def filter_data_range(data, min_limit=None, max_limit=None): if not data: return [] if min_limit is None: min_limit = min(data) if max_limit is None: max_limit = max(data) return [x for x in data if min_limit <= x <= max_limit]"},{"question":"# Context You are given an array of integers where each integer represents a color. The colors are represented by integers 0, 1, and 2, which correspond to red, white, and blue, respectively. The task is to sort this array so that the colors are in the order of red, white, and blue. You should achieve this using only one scan through the array and constant space. # Task Implement the function `sort_colors(nums)` that sorts the provided array `nums` in place so that all the 0s (red) come first, followed by all the 1s (white), and all the 2s (blue) come last. # Input Format - A single list of integers `nums` where each integer is either 0, 1, or 2, representing colors red, white, and blue respectively. # Output Format - The function does not return anything, but the input list `nums` should be sorted in-place. # Constraints - You must not use the library\'s sort function. - The algorithm must work with a time complexity of O(n) and a space complexity of O(1). # Examples Example 1 **Input**: ```python nums = [2, 0, 2, 1, 1, 0] ``` **Output**: ```python # After sorting in-place, nums should be: [0, 0, 1, 1, 2, 2] ``` Example 2 **Input**: ```python nums = [1, 2, 0, 1, 2, 0, 1] ``` **Output**: ```python # After sorting in-place, nums should be: [0, 0, 1, 1, 1, 2, 2] ``` # Additional Notes - Ensure that your implementation handles all edge cases efficiently. - Test your function thoroughly to ensure it sorts the array correctly in all scenarios.","solution":"def sort_colors(nums): Sorts the colors represented by 0 (red), 1 (white), and 2 (blue) in-place so that red comes first, followed by white, and then blue. red, white, blue = 0, 0, len(nums) - 1 while white <= blue: if nums[white] == 0: nums[red], nums[white] = nums[white], nums[red] red += 1 white += 1 elif nums[white] == 1: white += 1 else: nums[white], nums[blue] = nums[blue], nums[white] blue -= 1"},{"question":"# Rotated and Inverted Matrix Processing Scenario You are working on an image processing application that deals with grid transformations. Your application needs to handle common operations like rotations and inversions of a matrix. The transformations you need to support include rotating a matrix 90 degrees clockwise, 90 degrees counterclockwise, top-left inversion, and bottom-left inversion. Each operation results in a new rearrangement of matrix elements. Objective Implement the following functions: 1. `rotate_clockwise(matrix)` 2. `rotate_counterclockwise(matrix)` 3. `top_left_invert(matrix)` 4. `bottom_left_invert(matrix)` Each function should take a 2D list `matrix` as input and return a new 2D list that is the result of the corresponding transformation. Input Format - `matrix`: A list of lists, where each inner list represents a row of the matrix. It can be of size N x M, where N is the number of rows and M is the number of columns. Output Format - A list of lists representing the transformed matrix. Constraints - The matrix can be empty. - The matrix can have a single element. - The matrix can be non-square (N ≠ M). Examples 1. **Rotate Clockwise** ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate_clockwise(matrix) -> [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] ``` 2. **Rotate Counterclockwise** ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate_counterclockwise(matrix) -> [ [3, 6, 9], [2, 5, 8], [1, 4, 7] ] ``` 3. **Top-left Invert** ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] top_left_invert(matrix) -> [ [1, 4, 7], [2, 5, 8], [3, 6, 9] ] ``` 4. **Bottom-left Invert** ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] bottom_left_invert(matrix) -> [ [9, 6, 3], [8, 5, 2], [7, 4, 1] ] ``` Notes * Ensure to handle edge cases like empty matrices or single element matrices gracefully. * Aim to optimize both time and space complexity where possible.","solution":"def rotate_clockwise(matrix): if not matrix or not matrix[0]: return [] rows, cols = len(matrix), len(matrix[0]) rotated = [[0]*rows for _ in range(cols)] for r in range(rows): for c in range(cols): rotated[c][rows - 1 - r] = matrix[r][c] return rotated def rotate_counterclockwise(matrix): if not matrix or not matrix[0]: return [] rows, cols = len(matrix), len(matrix[0]) rotated = [[0]*rows for _ in range(cols)] for r in range(rows): for c in range(cols): rotated[cols - 1 - c][r] = matrix[r][c] return rotated def top_left_invert(matrix): if not matrix or not matrix[0]: return [] rows, cols = len(matrix), len(matrix[0]) inverted = [[0]*rows for _ in range(cols)] for r in range(rows): for c in range(cols): inverted[c][r] = matrix[r][c] return inverted def bottom_left_invert(matrix): if not matrix or not matrix[0]: return [] rows, cols = len(matrix), len(matrix[0]) inverted = [[0]*rows for _ in range(cols)] for r in range(rows): for c in range(cols): inverted[cols - 1 - c][rows - 1 - r] = matrix[r][c] return inverted"},{"question":"# Knuth-Morris-Pratt String Matching Algorithm You are given two strings, `text` and `pattern`, and you need to implement a function that finds all occurrences of the `pattern` in the `text` using the Knuth-Morris-Pratt (KMP) algorithm. Your task is to write code that constructs the partial match (prefix) table and uses it to efficiently search for the pattern in the text. Function Signature ```python from typing import List, Sequence def knuth_morris_pratt(text: Sequence[str], pattern: Sequence[str]) -> List[int]: pass ``` Input * `text` (Sequence[str]): The text in which the pattern is to be searched. * `pattern` (Sequence[str]): The pattern that you are looking for in the text. Output * List[int]: A list of start indices in the text where the pattern matches. If the pattern is not found, return an empty list. Constraints * The search should be case-sensitive. * You should handle the possibility of empty text or pattern appropriately. * The implementation should efficiently handle large texts and patterns within reasonable limits (e.g., text length up to 10^5 and pattern length up to 10^4). Example ```python print(knuth_morris_pratt(\'hello there hero!\', \'he\')) # Output: [0, 7, 12] print(knuth_morris_pratt(\'abcdabcabcd\', \'abc\')) # Output: [0, 4, 7] print(knuth_morris_pratt(\'aaaaa\', \'aa\')) # Output: [0, 1, 2, 3] print(knuth_morris_pratt(\'hello\', \'world\')) # Output: [] ``` Additional Details 1. Ensure that your implementation is linear in terms of both time and space complexity. 2. Handle cases where the pattern is longer than the text or either of them is empty. 3. Optimize your solution according to the discussed principles and complexity.","solution":"from typing import List, Sequence def knuth_morris_pratt(text: Sequence[str], pattern: Sequence[str]) -> List[int]: if not pattern: return [] # Step 1: Create the partial match table (prefix table) def compute_prefix_table(pattern: Sequence[str]) -> List[int]: m = len(pattern) prefix_table = [0] * m j = 0 # length of previous longest prefix suffix for i in range(1, m): while (j > 0 and pattern[i] != pattern[j]): j = prefix_table[j-1] if pattern[i] == pattern[j]: j += 1 prefix_table[i] = j else: prefix_table[i] = 0 return prefix_table # Step 2: Perform the search def kmp_search(text: Sequence[str], pattern: Sequence[str]) -> List[int]: n = len(text) m = len(pattern) prefix_table = compute_prefix_table(pattern) result = [] j = 0 # index for pattern for i in range(n): while (j > 0 and text[i] != pattern[j]): j = prefix_table[j-1] if text[i] == pattern[j]: j += 1 if j == m: result.append(i - m + 1) j = prefix_table[j-1] return result return kmp_search(text, pattern)"},{"question":"You are given the root of a binary tree and need to perform a postorder traversal of the tree nodes. Implement two functions to solve this problem: 1. An **iterative** approach to traverse the tree in postorder. 2. A **recursive** approach to traverse the tree in postorder. Specifications Function signatures should be as follows: ```python def postorder_iterative(root: Node) -> List[int]: pass def postorder_recursive(root: Node) -> List[int]: pass ``` Input * `root`: The root node of the binary tree, which may be `None` (an empty tree) or a valid `Node`. Output * A list of integers representing the values of the tree nodes in postorder. Constraints * The number of nodes in the tree is in the range [0, 10^4]. * Each node\'s value is a unique integer. Performance Requirements * Both approaches should operate within a time complexity of O(n) and space complexity of O(n). Example: ```python # Assume the Node class is already defined # Tree structure: # 1 # / # 2 3 # / # 4 5 root = Node(1, Node(2, Node(4), Node(5)), Node(3)) print(postorder_iterative(root)) # Output: [4, 5, 2, 3, 1] print(postorder_recursive(root)) # Output: [4, 5, 2, 3, 1] ``` Notes * Consider edge cases such as an empty tree or trees that are highly skewed.","solution":"class Node: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def postorder_iterative(root: Node) -> list: This function performs postorder traversal of a binary tree iteratively. if root is None: return [] stack = [] output = [] stack.append(root) while stack: current = stack.pop() output.append(current.val) # append left child first so right child is processed first if current.left: stack.append(current.left) if current.right: stack.append(current.right) # reverse the output list to get the postorder traversal return output[::-1] def postorder_recursive(root: Node) -> list: This function performs postorder traversal of a binary tree recursively. result = [] def postorder(node): if node is None: return postorder(node.left) postorder(node.right) result.append(node.val) postorder(root) return result"},{"question":"# Number Base Conversion Your task is to implement two functions to convert numbers between different bases. 1. **int_to_base(num, base)**: Converts a given base-10 integer `num` to a string representing the number in the specified `base`. 2. **base_to_int(str_to_convert, base)**: Converts a string representing a number in the specified `base` back to a base-10 integer. # Function Signatures ```python def int_to_base(num: int, base: int) -> str: pass def base_to_int(str_to_convert: str, base: int) -> int: pass ``` # Input and Output * **int_to_base(num, base):** * **Input**: * `num` (int): The integer to convert. It can be negative. * `base` (int): The base to convert to, such as 2, 8, 16, etc. * **Output**: * (str): The string representation of `num` in the given `base`. * **base_to_int(str_to_convert, base):** * **Input**: * `str_to_convert` (str): The string to convert. It will only contain valid characters for the base. * `base` (int): The base of `str_to_convert`, such as 2 (binary), 8 (octal), 16 (hexadecimal), etc. * **Output**: * (int): The base-10 integer representation of `str_to_convert`. # Constraints * Ensure that `base` is between 2 and 36, inclusive. * If `base` is out of this range, you should raise a `ValueError`. # Performance Requirements * Your implementation should be efficient and handle large integers within the limits of typical integer sizes in Python. # Example ```python print(int_to_base(5, 2)) # Output: \\"101\\" print(int_to_base(-255, 16)) # Output: \\"-FF\\" print(base_to_int(\\"101\\", 2)) # Output: 5 print(base_to_int(\\"FF\\", 16)) # Output: 255 ``` # Notes * Assume that the input to `base_to_int` is always a valid string for the given base. * Python\'s `int()` function should not be used for conversion in `base_to_int`.","solution":"def int_to_base(num: int, base: int) -> str: if base < 2 or base > 36: raise ValueError(\\"Base must be between 2 and 36, inclusive.\\") if num == 0: return \\"0\\" digits = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" neg = num < 0 num = abs(num) result = \'\' while num: result = digits[num % base] + result num //= base if neg: result = \'-\' + result return result def base_to_int(str_to_convert: str, base: int) -> int: if base < 2 or base > 36: raise ValueError(\\"Base must be between 2 and 36, inclusive.\\") digits = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" neg = str_to_convert[0] == \'-\' if neg: str_to_convert = str_to_convert[1:] num = 0 for char in str_to_convert: num = num * base + digits.index(char) return -num if neg else num"},{"question":"You are given a directed graph representing a flow network with `V` vertices (numbered 0 to V-1) and a `V x V` capacity matrix where `capacity[i][j] > 0` represents the capacity of the edge from vertex `i` to vertex `j`. Each edge (i, j) represents a directed flow allowing transfer of material from vertex `i` to vertex `j` up to a given capacity `capacity[i][j]`. There could be sites (vertices) with no outgoing edges i.e., isolated vertices in the flow network. The source vertex is `0` and the sink vertex is `V-1`. # Task You need to implement the following functions to compute the maximum flow from the source to the sink using three different algorithms: Ford-Fulkerson, Edmonds-Karp, and Dinic’s algorithm. 1. **ford_fulkerson(capacity: List[List[int]], source: int, sink: int) -> int**: Implements the Ford-Fulkerson algorithm using DFS. 2. **edmonds_karp(capacity: List[List[int]], source: int, sink: int) -> int**: Implements the Edmonds-Karp algorithm using BFS. 3. **dinic(capacity: List[List[int]], source: int, sink: int) -> int**: Implements Dinic’s algorithm. # Input * `capacity`: A list of lists of integers that represent the capacity of the flow network. `capacity[i][j]` is the maximum flow of the edge from vertex `i` to vertex `j`. * `source`: An integer representing the source vertex (default is 0). * `sink`: An integer representing the sink vertex (default is V-1). # Output * The maximum flow from the source to the sink. # Example ```python capacity = [ [0, 16, 13, 0, 0, 0], [0, 0, 10, 12, 0, 0], [0, 4, 0, 0, 14, 0], [0, 0, 9, 0, 0, 20], [0, 0, 0, 7, 0, 4], [0, 0, 0, 0, 0, 0] ] source = 0 sink = 5 max_flow = ford_fulkerson(capacity, source, sink) print(max_flow) # Output: 23 max_flow = edmonds_karp(capacity, source, sink) print(max_flow) # Output: 23 max_flow = dinic(capacity, source, sink) print(max_flow) # Output: 23 ``` # Constraints * `1 <= V <= 1000` * `0 <= capacity[i][j] <= 10^9` * The graph is a directed graph. * Assume that source is always vertex 0 and sink is vertex V-1. # Notes * You may assume that the input graph is connected and always has at least one path from source to sink. * Optimize for large graphs where possible ensuring the implementation is efficient in both time and space.","solution":"def ford_fulkerson(capacity, source, sink): from collections import deque def dfs_flow(C, F, visited, u, t, flow): if u == t: return flow visited[u] = True for v in range(len(C)): if not visited[v] and C[u][v] - F[u][v] > 0: min_flow = dfs_flow(C, F, visited, v, t, min(flow, C[u][v] - F[u][v])) if min_flow > 0: F[u][v] += min_flow F[v][u] -= min_flow return min_flow return 0 n = len(capacity) flow = 0 F = [[0] * n for _ in range(n)] while True: visited = [False] * n inc_flow = dfs_flow(capacity, F, visited, source, sink, float(\'Inf\')) if inc_flow == 0: break flow += inc_flow return flow def edmonds_karp(capacity, source, sink): from collections import deque def bfs_flow(C, F, s, t, parent): visited = [False] * len(C) queue = deque([s]) visited[s] = True while queue: u = queue.popleft() for v in range(len(C)): if not visited[v] and C[u][v] - F[u][v] > 0: queue.append(v) visited[v] = True parent[v] = u if v == t: return True return False n = len(capacity) flow = 0 F = [[0] * n for _ in range(n)] parent = [-1] * n while bfs_flow(capacity, F, source, sink, parent): path_flow = float(\'Inf\') v = sink while v != source: u = parent[v] path_flow = min(path_flow, capacity[u][v] - F[u][v]) v = u v = sink while v != source: u = parent[v] F[u][v] += path_flow F[v][u] -= path_flow v = u flow += path_flow return flow def dinic(capacity, source, sink): from collections import deque def bfs_levels(C, F, s, t, level): queue = deque([s]) level[s] = 0 while queue: u = queue.popleft() for v in range(len(C)): if level[v] < 0 and C[u][v] - F[u][v] > 0: level[v] = level[u] + 1 queue.append(v) return level[t] >= 0 def dfs_flow(C, F, level, u, t, flow): if u == t: return flow pushed = 0 for v in range(len(C)): if level[v] == level[u] + 1 and C[u][v] - F[u][v] > 0: min_flow = dfs_flow(C, F, level, v, t, min(flow, C[u][v] - F[u][v])) if min_flow > 0: F[u][v] += min_flow F[v][u] -= min_flow flow -= min_flow pushed += min_flow return pushed n = len(capacity) flow = 0 F = [[0] * n for _ in range(n)] while True: level = [-1] * n if not bfs_levels(capacity, F, source, sink, level): break while True: inc_flow = dfs_flow(capacity, F, level, source, sink, float(\'Inf\')) if inc_flow == 0: break flow += inc_flow return flow"},{"question":"You are given a non-negative integer represented as an array of digits, where each element in the array contains a single digit. The digits are stored in big-endian format, meaning the most significant digit is at the head of the list. Write a function `increment_integer(digits)` that takes this array and returns a new array representing the integer incremented by one. # Function Signature `def increment_integer(digits: List[int]) -> List[int]:` # Input * `digits` - A non-empty list of non-negative integers where each integer is between 0 and 9 (inclusive) representing the digits of a non-negative integer in big-endian order. # Output * Return a list of integers representing the incremented integer in big-endian order. # Constraints * The input list will not be empty and will only contain digits between 0 and 9. # Example 1. **Input**: `digits = [1, 2, 3]` **Output**: `[1, 2, 4]` 2. **Input**: `digits = [9, 9, 9]` **Output**: `[1, 0, 0, 0]` # Notes * You should not convert the array to an integer directly. * Handle carryovers properly. * Ensure that the solution is efficient and works for large numbers.","solution":"def increment_integer(digits): Increments the integer represented by a list of digits by one. n = len(digits) for i in range(n-1, -1, -1): if digits[i] < 9: digits[i] += 1 return digits digits[i] = 0 # If all the digits were 9, we need to add an extra digit at the beginning return [1] + digits"},{"question":"You are required to implement a MinStack, a stack that supports push, pop, top, and retrieving the minimum element in constant time. Your implementation should be based on the AbstractStack class provided above. # Objective Implement a MinStack class that extends the AbstractStack class, where in addition to the regular stack operations, it also supports retrieving the minimum element in the stack in constant time. The class should support the following operations: - `push(value: int)`: Push an integer onto the stack. - `pop()`: Remove the element on the top of the stack and return it. - `top() (or peek())`: Get the top element. - `get_min()`: Retrieve the minimum element in the stack. # Constraints - All operations should run in constant time O(1). - The stack should handle a large number of operations efficiently. - Use of external libraries except for built-in data structures is not permitted. # Example ```python min_stack = MinStack() min_stack.push(-2) min_stack.push(0) min_stack.push(-3) print(min_stack.get_min()) # return -3 min_stack.pop() print(min_stack.top()) # return 0 print(min_stack.get_min()) # return -2 ```","solution":"class MinStack: def __init__(self): Initialize your data structure here. self.stack = [] self.min_stack = [] def push(self, x: int) -> None: Push element x onto stack. self.stack.append(x) if not self.min_stack or x <= self.min_stack[-1]: self.min_stack.append(x) def pop(self) -> None: Removes the element on top of the stack and return that element. if self.stack: top = self.stack.pop() if top == self.min_stack[-1]: self.min_stack.pop() return top def top(self) -> int: Get the top element. if self.stack: return self.stack[-1] def get_min(self) -> int: Retrieve the minimum element in the stack. if self.min_stack: return self.min_stack[-1]"},{"question":"# Question You are required to implement additional functionalities for the `SeparateChainingHashTable` to improve its utility. Specifically, you are to implement the following methods: 1. **Keys Method**: A method that returns all the keys stored in the hash table. 2. **Resize Method**: A method to resize the hash table to a new size and rehash all existing key-value pairs accordingly. # Specifications 1. **Keys Method** - **Method Name**: `keys` - **Return Type**: List of keys 2. **Resize Method** - **Method Name**: `resize` - **Parameters**: - `new_size (int)`: The new size for the hash table. - **Return Type**: None (the hash table should be resized in place) # Edge Cases to Handle - When the hash table is empty and `keys` method is called. - Preservation of existing data when resizing. - Efficient rehashing to the new table size during resizing. # Input and Output Formats - **Input**: No direct input for these methods but consider indirect inputs through inserting key-value pairs. - **Output**: - The `keys` method should return a list of keys. - The `resize` method should not return anything but should resize the underlying hash table. # Example Usage ```python # Assume SeparateChainingHashTable implementation provided # Example usage of keys method table = SeparateChainingHashTable() table.put(\'a\', 1) table.put(\'b\', 2) table.put(\'c\', 3) print(table.keys()) # Output: [\'a\', \'b\', \'c\'] # Example usage of resize method table.resize(20) ``` **Constraints**: - Keys can be any hashable data type. - Table size after resize must be greater than 0. Implement the `keys` and `resize` methods in the `SeparateChainingHashTable` class to pass the given scenarios.","solution":"class SeparateChainingHashTable: def __init__(self, initial_size=10): self.size = initial_size self.table = [[] for _ in range(initial_size)] def _hash(self, key): return hash(key) % self.size def put(self, key, value): index = self._hash(key) for pair in self.table[index]: if pair[0] == key: pair[1] = value return self.table[index].append([key, value]) def get(self, key): index = self._hash(key) for pair in self.table[index]: if pair[0] == key: return pair[1] return None def keys(self): Returns all the keys stored in the hash table. all_keys = [] for bucket in self.table: for pair in bucket: all_keys.append(pair[0]) return all_keys def resize(self, new_size): Resize the hash table to a new size and rehash all existing key-value pairs. old_table = self.table self.size = new_size self.table = [[] for _ in range(new_size)] for bucket in old_table: for key, value in bucket: index = self._hash(key) self.table[index].append([key, value])"},{"question":"# Question: Histogram Implementation and Analysis **Objective**: Implement a histogram function to count the occurrences of each unique item in a given list and extend it to a more complex scenario. Given the need to understand the distribution of user ages in a social media platform, you are tasked with: 1. Creating a function that computes the histogram of user ages. 2. Analyzing the histogram to find the most and least frequent ages. **Function Signature**: ```python def calculate_age_histogram(ages: list) -> dict: pass def find_most_least_frequent_ages(histogram: dict) -> tuple: pass ``` **Functions Description**: 1. `calculate_age_histogram(ages: list) -> dict` - **Input**: A list of integers representing user ages (1 <= ages[i] <= 120). - **Output**: A dictionary with ages as keys and their counts as values. 2. `find_most_least_frequent_ages(histogram: dict) -> tuple` - **Input**: A dictionary representing the age histogram (output of `calculate_age_histogram`). - **Output**: A tuple containing the most frequent age and the least frequent age. In case of ties, return the smallest age. **Performance Requirements**: - **Time Complexity**: O(n) for `calculate_age_histogram`, O(m) for `find_most_least_frequent_ages` where m is the number of unique ages. - **Space Complexity**: O(m) for histogram storage. **Constraints**: - The input list may have up to 10^5 elements. - Age values are between 1 and 120 inclusive. **Example**: ```python # Example Input ages = [21, 25, 21, 22, 25, 25, 30, 21, 30] # Expected Output # calculate_age_histogram(ages) -> {21: 3, 22: 1, 25: 3, 30: 2} # find_most_least_frequent_ages({21: 3, 22: 1, 25: 3, 30: 2}) -> (21, 22) ``` **Notes**: - Make sure to handle the edge cases such as empty list, all ages same, and age values outside of valid range. - Pay attention to both functions\' performance to ensure they meet the requirements for large inputs.","solution":"def calculate_age_histogram(ages: list) -> dict: Computes the histogram of ages. :param ages: List of integers representing user ages (1 <= ages[i] <= 120). :return: Dictionary with ages as keys and their counts as values. histogram = {} for age in ages: if age in histogram: histogram[age] += 1 else: histogram[age] = 1 return histogram def find_most_least_frequent_ages(histogram: dict) -> tuple: Finds the most frequent and least frequent ages from the histogram. :param histogram: Dictionary representing the age histogram. :return: Tuple containing the most frequent age and the least frequent age. if not histogram: return (None, None) most_frequent_age = min(histogram, key=lambda age: (-histogram[age], age)) least_frequent_age = min(histogram, key=lambda age: (histogram[age], age)) return most_frequent_age, least_frequent_age"},{"question":"# Advanced Algorithm Assessment: Fenwick Tree Application Objective Design a system to efficiently manage and query the data of a live-stream platform where users can send \\"likes\\" to a streamer. The goal is to maintain a real-time count of likes and allow querying of total likes received in any given period. Requirements Implement a class `StreamLikes` with the following functionalities: 1. **Initialization**: Create a `StreamLikes` instance with a timeline of zeros indicating no likes at `n` timestamps initially. 2. **like(timestamp)**: Increment the number of likes at the given timestamp. - **Input**: `timestamp` (integer) - **Output**: None 3. **getTotalLikes(start, end)**: Return the total number of likes received from the start timestamp to the end timestamp (inclusive). - **Input**: `start`, `end` (integers defining the range) - **Output**: Integer representing the total likes between timestamps `start` and `end` inclusive. Constraints - Timestamps range from 0 to `n-1`. - 1 <= `n` <= 100000 - 0 <= `timestamp` < `n` - You may assume all timestamps passed to `like` are valid, and start <= end for `getTotalLikes`. Implementation Implement the class `StreamLikes` using a Fenwick Tree to ensure efficient updates and range queries. Below is the method signature. ```python class StreamLikes: def __init__(self, n: int): Initializes a StreamLikes instance for a timeline of n timestamps. pass def like(self, timestamp: int) -> None: Increment the number of likes at the given timestamp. pass def getTotalLikes(self, start: int, end: int) -> int: Return the total number of likes received from start to end timestamp inclusive. pass ``` Example ```python # Example usage sl = StreamLikes(10) sl.like(2) sl.like(2) sl.like(4) print(sl.getTotalLikes(1, 3)) # Output: 2 print(sl.getTotalLikes(2, 4)) # Output: 3 print(sl.getTotalLikes(1, 1)) # Output: 0 ```","solution":"class StreamLikes: def __init__(self, n: int): Initializes a StreamLikes instance for a timeline of n timestamps. self.n = n self.ft = [0] * (n + 1) def _update(self, idx: int, val: int) -> None: Internal method to update the Fenwick Tree. idx += 1 # Fenwick tree is 1-indexed while idx <= self.n: self.ft[idx] += val idx += idx & -idx def _query(self, idx: int) -> int: Internal method to query the prefix sum up to idx. idx += 1 # Fenwick tree is 1-indexed sum_ = 0 while idx > 0: sum_ += self.ft[idx] idx -= idx & -idx return sum_ def like(self, timestamp: int) -> None: Increment the number of likes at the given timestamp. self._update(timestamp, 1) def getTotalLikes(self, start: int, end: int) -> int: Return the total number of likes received from start to end timestamp inclusive. if start == 0: return self._query(end) else: return self._query(end) - self._query(start - 1)"},{"question":"# Graph Traversal: Unique Paths Scenario You\'re working on a network analysis tool where you need to identify unique paths through a graph without cycles. Given an unweighted, directed graph representing components and their dependencies, your task is to implement a function to find all unique paths from a given start node to a target node. Function Signature ```python def find_all_unique_paths(graph, start, target): :param graph: dict, adjacency list representation of the graph. :param start: int/string, the start node. :param target: int/string, the target node to reach. :return: List of lists, each inner list representing a unique path from start to target. pass ``` Input * `graph`: A dictionary where keys are node identifiers and values are lists of nodes directly accessible from the key node. * `start`: The starting node identifier. * `target`: The target node identifier. Output * List of all unique paths from the start node to the target node. Each path should be represented as a list of nodes. Constraints * Nodes are identified by unique integers or strings. * The graph may contain cycles. * There may be multiple paths from the start to the target node. Example ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'C\', \'D\'], \'C\': [\'D\'], \'D\': [\'E\'], \'E\': [] } start = \'A\' target = \'E\' find_all_unique_paths(graph, start, target) # Expected Output: [[\'A\', \'B\', \'C\', \'D\', \'E\'], [\'A\', \'B\', \'D\', \'E\'], [\'A\', \'C\', \'D\', \'E\']] ``` Guidelines 1. Consider using DFS to explore paths. 2. Handle cycles to avoid infinite loops. 3. Collect and return all unique paths from the start node to the target node. 4. Ensure your implementation is efficient to handle larger graphs.","solution":"def find_all_unique_paths(graph, start, target): Find all unique paths from start node to target node in a directed graph. :param graph: dict, adjacency list representation of the graph. :param start: int/string, the start node. :param target: int/string, the target node to reach. :return: List of lists, each inner list representing a unique path from start to target. def dfs(current, path): if current == target: paths.append(path.copy()) return for neighbor in graph.get(current, []): if neighbor not in path: # Avoid cycles path.append(neighbor) dfs(neighbor, path) path.pop() paths = [] dfs(start, [start]) return paths"},{"question":"# Coding Assessment: Strong Connectivity Checker Problem Statement You are provided with a directed graph implementation. Your task is to extend this implementation to count the number of strongly connected components within the graph. A strongly connected component (SCC) is a maximal subgraph where any two vertices are reachable from each other. Requirements 1. Implement a method `count_strongly_connected_components` in the `Graph` class that returns the number of SCCs in the graph. 2. Ensure that your implementation leverages appropriate algorithms for effective SCC detection within the graph. Definition ```python def count_strongly_connected_components(self) -> int: Count the number of strongly connected components in the graph. Returns: int: Number of strongly connected components ``` Input Format - No input required directly from the user; you will test the method using the `Graph` class. Output Format - An integer representing the number of strongly connected components. Constraints - The graph can have up to 10^4 vertices and 10^5 edges. Example Usage ```python # Example 1 g = Graph(5) g.add_edge(0, 1) g.add_edge(1, 2) g.add_edge(2, 0) g.add_edge(1, 3) g.add_edge(3, 4) print(g.count_strongly_connected_components()) # Output: 3 # Example 2 g = Graph(4) g.add_edge(0, 1) g.add_edge(1, 2) g.add_edge(2, 3) g.add_edge(3, 0) print(g.count_strongly_connected_components()) # Output: 1 ``` Explanation Example 1: - The graph has three strongly connected components: {0, 1, 2}, {3}, {4}. Example 2: - The entire graph is a single strongly connected component. Special Notes - Pay special attention to edge cases, such as single vertex graphs, fully disconnected graphs, and graphs with complex connectivity patterns. - Consider implementing Kosaraju’s or Tarjan\'s algorithm for efficiently finding all SCCs.","solution":"class Graph: def __init__(self, vertices): self.graph = {i: [] for i in range(vertices)} self.V = vertices def add_edge(self, u, v): self.graph[u].append(v) def count_strongly_connected_components(self): Count the number of strongly connected components in the graph using Kosaraju\'s algorithm. Returns: int: Number of strongly connected components def dfs(v, visited, stack): visited[v] = True for neighbor in self.graph[v]: if not visited[neighbor]: dfs(neighbor, visited, stack) stack.append(v) def reverse_dfs(v, visited, reversed_graph): visited[v] = True for neighbor in reversed_graph[v]: if not visited[neighbor]: reverse_dfs(neighbor, visited, reversed_graph) stack = [] visited = [False] * self.V for i in range(self.V): if not visited[i]: dfs(i, visited, stack) reversed_graph = {i: [] for i in range(self.V)} for u in self.graph: for v in self.graph[u]: reversed_graph[v].append(u) visited = [False] * self.V count = 0 while stack: node = stack.pop() if not visited[node]: reverse_dfs(node, visited, reversed_graph) count += 1 return count"},{"question":"# Scenario You are working on a text blending application that needs to check if a blended text can be produced from two given parts. You are provided the blended text `s`, and parts `part1` and `part2`. The characters in `part1` and `part2` must appear in the same order in `s`, but they can be interleaved. # Objectives Implement the function `is_merge(s, part1, part2)` that returns `True` if `s` can be formed by interleaving `part1` and `part2`. Otherwise, return `False`. # Function Signature ```python def is_merge(s: str, part1: str, part2: str) -> bool: pass ``` # Input * `s` (String): The blended text string. * `part1`, `part2` (String): The two parts to be merged. # Output * Return a boolean indicating whether `s` can be successfully formed from the interleaving characters of `part1` and `part2`. # Constraints * The lengths of `s`, `part1`, and `part2` will always be non-negative integers. * No assumptions are made about the character set of the input strings. # Examples 1. `is_merge(\\"codewars\\", \\"cdw\\", \\"oears\\")` should return `True`. 2. `is_merge(\\"codewars\\", \\"cdw\\", \\"oeasr\\")` should return `False`. # Additional Requirements 1. Handle edge cases like empty strings appropriately. 2. The implementation should be optimized to handle moderate string lengths efficiently.","solution":"def is_merge(s: str, part1: str, part2: str) -> bool: len_s, len_p1, len_p2 = len(s), len(part1), len(part2) if len_s != len_p1 + len_p2: return False dp = [[False] * (len_p2 + 1) for _ in range(len_p1 + 1)] dp[0][0] = True for i in range(len_p1 + 1): for j in range(len_p2 + 1): if i > 0 and dp[i-1][j] and s[i+j-1] == part1[i-1]: dp[i][j] = True if j > 0 and dp[i][j-1] and s[i+j-1] == part2[j-1]: dp[i][j] = True return dp[len_p1][len_p2]"},{"question":"# Palindromic Substring Partitioning Objective Design a function that computes all ways to part a given string into substrings where each substring is a palindrome. As a subsequent task, improve the performance of this function using dynamic programming. Scenario You are working on a text processing tool where a feature requires partitioning a string into all possible sets of palindromic substrings. For example, given the string `\\"abcbab\\"`, the tool should return all possible lists of palindromic partitions like `[[\'abcba\', \'b\'], [\'a\', \'bcb\', \'a\', \'b\'], [\'a\', \'b\', \'c\', \'bab\'], [\'a\', \'b\', \'c\', \'b\', \'a\', \'b\']]`. # Task Write two functions: 1. **palindromic_substrings(s)** 2. **palindromic_substrings_dp(s)** Function Specifications # 1. `palindromic_substrings(s)` - **Input**: A single string `s` (1 ≤ |s| ≤ 15). - **Output**: A list of lists where each sublist contains a partition of `s` such that every substring in each partition is a palindrome. - **Constraints**: - Each character in the string is an ASCII character. - Output should include all possible palindromic partitions regardless of their order. # 2. `palindromic_substrings_dp(s)` - **Input**: Same as above. - **Output**: Same as above. - **Specifications**: Utilize dynamic programming techniques to enhance performance over the basic recursive approach. Example ```python def test_palindromic_substrings(): assert palindromic_substrings(\'abcbab\') == [[\'abcba\', \'b\'], [\'a\', \'bcb\', \'a\', \'b\'], [\'a\', \'b\', \'c\', \'bab\'], [\'a\', \'b\', \'c\', \'b\', \'a\', \'b\']] assert palindromic_substrings(\'a\') == [[\'a\']] assert palindromic_substrings(\'\') == [[]] assert palindromic_substrings_dp(\'abcbab\') == [[\'abcba\', \'b\'], [\'a\', \'bcb\', \'a\', \'b\'], [\'a\', \'b\', \'c\', \'bab\'], [\'a\', \'b\', \'c\', \'b\', \'a\', \'b\']] assert palindromic_substrings_dp(\'a\') == [[\'a\']] assert palindromic_substrings_dp(\'\') == [[]] test_palindromic_substrings() ``` Put your implementation skills to the test by solving this palindromic substring partitioning problem first using a straightforward recursive approach and then optimizing it with dynamic programming.","solution":"def is_palindrome(s): return s == s[::-1] def palindromic_substrings(s): def dfs(start, path, result): if start == len(s): result.append(path) return for end in range(start + 1, len(s) + 1): if is_palindrome(s[start:end]): dfs(end, path + [s[start:end]], result) result = [] dfs(0, [], result) return result def palindromic_substrings_dp(s): n = len(s) dp = [[False] * n for _ in range(n)] for i in range(n): dp[i][i] = True for length in range(2, n + 1): for i in range(n - length + 1): j = i + length - 1 if length == 2: dp[i][j] = (s[i] == s[j]) else: dp[i][j] = (s[i] == s[j] and dp[i + 1][j - 1]) def dfs(start, path, result): if start == len(s): result.append(path) return for end in range(start, len(s)): if dp[start][end]: dfs(end + 1, path + [s[start:end + 1]], result) result = [] dfs(0, [], result) return result"},{"question":"Scenario You are tasked with finding two unique numbers from a list where every other number appears exactly twice. To achieve this, you must write an efficient function that leverages linear time and constant space complexity. Problem Statement Implement a function `find_unique_numbers(nums)` that takes an array of integers `nums` as input and returns a list containing exactly two integers that appear only once in the input array. All the other integers in the array appear exactly twice. The order of the output numbers does not matter. You must ensure that your solution has a time complexity of O(N) and a space complexity of O(1). Function Signature ```python def find_unique_numbers(nums: List[int]) -> List[int]: pass ``` Input - `nums`: A list of integers, where exactly two numbers appear only once and all other numbers appear exactly twice. (1 <= len(nums) <= 10^5) Output - A list containing the two unique integers. Example ```python # Example 1: nums = [1, 2, 1, 3, 2, 5] # expected output [3, 5] or [5, 3] # Example 2: nums = [2, 4, 2, 5, 6, 4] # expected output [5, 6] or [6, 5] ``` Constraints - Time Complexity: O(N) - Space Complexity: O(1) Note - Do not use any built-in functions that directly solve the problem. - Think about XOR properties and how they can help isolate the unique numbers.","solution":"from typing import List def find_unique_numbers(nums: List[int]) -> List[int]: # Initial XOR of all elements xor_result = 0 for num in nums: xor_result ^= num # Find the rightmost 1-bit that differs in the two unique numbers diff_bit = xor_result & -xor_result unique1, unique2 = 0, 0 for num in nums: if num & diff_bit: unique1 ^= num else: unique2 ^= num return [unique1, unique2]"},{"question":"# Objective Implement a function `shortest_path(maze)` that takes a 2D list representing a grid where `1` is a traversable cell and `0` is a blocked cell, and returns the minimum number of steps required to go from the top-left cell `(0,0)` to the bottom-right cell of the grid. If no such path exists, return `-1`. # Input Format * A list of lists `maze` of size `m x n` where `1` represents an open cell and `0` represents a blocked cell. `1 <= m, n <= 100`. # Output Format * An integer representing the minimum steps needed to reach from `(0,0)` to `(m-1,n-1)` or `-1` if there is no such path. # Constraints * `maze` will only contain `0` or `1` * The starting cell `(0,0)` and target cell `(m-1,n-1)` could be `1` or `0` * If the target cell is `(m-1,n-1)` is `0`, return `-1` immediately. # Performance Requirements * The solution should run in O(|E| + |V|) time complexity. * The solution should be able to handle grids up to 100x100 efficiently. # Example ```python assert shortest_path([ [1, 0, 1, 1, 1, 1], [1, 0, 1, 0, 1, 0], [1, 0, 1, 0, 1, 1], [1, 1, 1, 0, 1, 1] ]) == 14 assert shortest_path([ [1, 0, 0], [0, 1, 1], [0, 1, 1] ]) == -1 ``` # Constraints * If the grid starts or ends with `0`, the function must return `-1`. Implement the `shortest_path` function below: ```python def shortest_path(maze): from collections import deque BLOCKED, ALLOWED = 0, 1 UNVISITED, VISITED = 0, 1 initial_x, initial_y = 0, 0 height, width = len(maze), len(maze[0]) if maze[initial_x][initial_y] == BLOCKED or maze[height-1][width-1] == BLOCKED: return -1 directions = [(0, -1), (0, 1), (-1, 0), (1, 0)] target_x, target_y = height - 1, width - 1 queue = deque([(initial_x, initial_y, 0)]) is_visited = [[UNVISITED for w in range(width)] for h in range(height)] is_visited[initial_x][initial_y] = VISITED while queue: x, y, steps = queue.popleft() if x == target_x and y == target_y: return steps for dx, dy in directions: new_x, new_y = x + dx, y + dy if 0 <= new_x < height and 0 <= new_y < width: if maze[new_x][new_y] == ALLOWED and is_visited[new_x][new_y] == UNVISITED: queue.append((new_x, new_y, steps + 1)) is_visited[new_x][new_y] = VISITED return -1 ```","solution":"def shortest_path(maze): from collections import deque BLOCKED, ALLOWED = 0, 1 UNVISITED, VISITED = 0, 1 initial_x, initial_y = 0, 0 height, width = len(maze), len(maze[0]) # If start or end is blocked, no path exists if maze[initial_x][initial_y] == BLOCKED or maze[height-1][width-1] == BLOCKED: return -1 # Possible directions of movement (left, right, up, down) directions = [(0, -1), (0, 1), (-1, 0), (1, 0)] target_x, target_y = height - 1, width - 1 queue = deque([(initial_x, initial_y, 0)]) is_visited = [[UNVISITED for _ in range(width)] for _ in range(height)] is_visited[initial_x][initial_y] = VISITED while queue: x, y, steps = queue.popleft() if x == target_x and y == target_y: return steps for dx, dy in directions: new_x, new_y = x + dx, y + dy if 0 <= new_x < height and 0 <= new_y < width: if maze[new_x][new_y] == ALLOWED and is_visited[new_x][new_y] == UNVISITED: queue.append((new_x, new_y, steps + 1)) is_visited[new_x][new_y] = VISITED return -1"},{"question":"# License Key Formatting Given a string `key` representing a license key and an integer `k`, write a function `license_number(key, k)` that formats the key and groups the alphanumeric characters into groups of `k`, separated by hyphens. If there are leftover characters at the start which are fewer than `k`, they should form the initial group. For example: ``` - Input: key = \\"2-4A0r7-4k\\", k = 4 Output: \\"24A0-R74K\\" - Input: key = \\"2-4A0r7-4k\\", k = 3 Output: \\"24-A0R-74K\\" - Input: key = \\"---\\", k = 2 Output: \\"\\" ``` # Input and Output Format - **Input**: - A string `key` consisting of alphanumeric characters and hyphens (`-`), with a length ranging between 1 and 10000. - An integer `k` where `1 <= k <= 10000`. - **Output**: - A formatted string with groups of alphanumeric characters delimited by hyphens. All alphabetic characters should be converted to uppercase. # Constraints - The final string should not have leading or trailing hyphens. - All alphabetic characters in the formatted key should be in uppercase. # Performance Requirements - Ensure that the algorithm runs efficiently within the constraints. - Focus on minimizing the space complexity as much as possible.","solution":"def license_number(key, k): Formats the given license key into groups of k characters, separated by hyphens. All letters are converted to uppercase. # Remove all hyphens and convert to uppercase cleaned_key = key.replace(\'-\', \'\').upper() # Result list to collect the groups result = [] # Start from the end of the cleaned key and work backwards while len(cleaned_key) > k: # Append the last k characters to the result list result.append(cleaned_key[-k:]) # Remove the last k characters from the cleaned key cleaned_key = cleaned_key[:-k] # Append any remaining characters (they form the first group) result.append(cleaned_key) # The groups are collected in reverse order, so we need to reverse them return \'-\'.join(result[::-1])"},{"question":"Right-angled Triangle Side Calculation You are given the lengths of two sides of a right-angled triangle. The sides are identified as `opposite`, `adjacent`, and `hypotenuse`. Your task is to implement the function `calculate_third_side` that computes the length of the unknown side of the triangle. The unknown side is indicated by a question mark `\\"?\\"`. Function Signature ```python def calculate_third_side(opposite: str, adjacent: str, hypotenuse: str) -> str: pass ``` Input - Three strings indicating the lengths of the opposite, adjacent, and hypotenuse sides of the triangle. Exactly one of these strings will be `\\"?\\"` to indicate that this is the unknown side. Output - A string in the format `\\"Side Name = length\\"` where `Side Name` is one of `\\"Opposite\\"`, `\\"Adjacent\\"`, or `\\"Hypotenuse\\"` and `length` is the calculated length of that side (rounded to 2 decimal places). Examples 1. **Example Input 1**: ```python opposite = \\"3\\" adjacent = \\"4\\" hypotenuse = \\"?\\" ``` **Example Output 1**: ```python \\"Hypotenuse = 5.0\\" ``` 2. **Example Input 2**: ```python opposite = \\"5\\" adjacent = \\"?\\" hypotenuse = \\"13\\" ``` **Example Output 2**: ```python \\"Adjacent = 12.0\\" ``` 3. **Example Input 3**: ```python opposite = \\"?\\" adjacent = \\"12\\" hypotenuse = \\"13\\" ``` **Example Output 3**: ```python \\"Opposite = 5.0\\" ``` Constraints - Input values can be in floating-point format and should be positive. - The input triangle sides will always form a valid right-angled triangle. - The calculated length should be rounded to two decimal places. Notes - Handle invalid inputs gracefully: if the input values do not form a valid right-angled triangle, the function should return `\\"Invalid input\\"`.","solution":"import math def calculate_third_side(opposite: str, adjacent: str, hypotenuse: str) -> str: try: if opposite == \\"?\\": adjacent = float(adjacent) hypotenuse = float(hypotenuse) if hypotenuse <= adjacent: return \\"Invalid input\\" opposite = math.sqrt(hypotenuse**2 - adjacent**2) return f\\"Opposite = {round(opposite, 2)}\\" elif adjacent == \\"?\\": opposite = float(opposite) hypotenuse = float(hypotenuse) if hypotenuse <= opposite: return \\"Invalid input\\" adjacent = math.sqrt(hypotenuse**2 - opposite**2) return f\\"Adjacent = {round(adjacent, 2)}\\" elif hypotenuse == \\"?\\": opposite = float(opposite) adjacent = float(adjacent) hypotenuse = math.sqrt(opposite**2 + adjacent**2) return f\\"Hypotenuse = {round(hypotenuse, 2)}\\" else: return \\"Invalid input\\" except ValueError: return \\"Invalid input\\""},{"question":"Implement a Red-Black Tree Insert and Delete Implement a Red-Black Tree (RBT) with both insertion and deletion functionalities to maintain balanced tree properties. Your task is to write methods to: 1. Insert a value into the Red-Black Tree. 2. Delete a value from the Red-Black Tree. The implementation should maintain the properties of a Red-Black Tree to ensure balanced tree height. # Function Definitions 1. Insert a Node: ```python def insert(self, val: int) -> None: Inserts a value into the Red-Black Tree. :param val: The integer value to be inserted. :return: None ``` 2. Delete a Node: ```python def delete(self, val: int) -> bool: Deletes a value from the Red-Black Tree. :param val: The integer value to be deleted. :return: bool, indicating whether the deletion was successful. ``` 3. Check In-order Traversal: ```python def in_order_traversal(self) -> list: Performs an in-order traversal of the tree. :return: List of dictionaries with node values and colors. ``` # Constraints 1. Values inserted will be unique integers. 2. Values to be deleted are guaranteed to be in the tree. 3. Maintain the properties of the Red-Black Tree after each insertion and deletion operation. 4. The in-order traversal output should be a list of dictionaries where each dictionary contains two keys: \\"val\\" for the node\'s value and \\"color\\" for the node\'s color (0 for black, 1 for red). # Example Test your implementation with the following scenario: 1. Insert values [11, 2, 14, 1, 7, 15, 5, 8, 4]. 2. Delete values [7, 14]. 3. Perform an in-order traversal after each operation to ensure tree balance and correctness. ```python # Example usage rb_tree = RBTree() test_insert_vals = [11, 2, 14, 1, 7, 15, 5, 8, 4] test_delete_vals = [7, 14] for val in test_insert_vals: rb_tree.insert(val) print(\\"In-order after inserts:\\", rb_tree.in_order_traversal()) for val in test_delete_vals: rb_tree.delete(val) print(\\"In-order after deletes:\\", rb_tree.in_order_traversal()) ``` The solution should verify that the tree remains balanced and correctly adheres to Red-Black Tree properties throughout the insertions and deletions.","solution":"class Node: def __init__(self, val, color=1): # 1 denotes red, 0 denotes black self.val = val self.color = color self.left = None self.right = None self.parent = None class RBTree: def __init__(self): self.TNULL = Node(0) self.TNULL.color = 0 self.root = self.TNULL def insert(self, key): node = Node(key) node.parent = None node.val = key node.left = self.TNULL node.right = self.TNULL node.color = 1 # New node must be red y = None x = self.root while x != self.TNULL: y = x if node.val < x.val: x = x.left else: x = x.right node.parent = y if y is None: self.root = node elif node.val < y.val: y.left = node else: y.right = node if node.parent is None: node.color = 0 return if node.parent.parent is None: return self.insert_fix(node) def insert_fix(self, k): while k.parent.color == 1: if k.parent == k.parent.parent.right: u = k.parent.parent.left if u.color == 1: u.color = 0 k.parent.color = 0 k.parent.parent.color = 1 k = k.parent.parent else: if k == k.parent.left: k = k.parent self.right_rotate(k) k.parent.color = 0 k.parent.parent.color = 1 self.left_rotate(k.parent.parent) else: u = k.parent.parent.right if u.color == 1: u.color = 0 k.parent.color = 0 k.parent.parent.color = 1 k = k.parent.parent else: if k == k.parent.right: k = k.parent self.left_rotate(k) k.parent.color = 0 k.parent.parent.color = 1 self.right_rotate(k.parent.parent) if k == self.root: break self.root.color = 0 def delete(self, key): self.delete_node_helper(self.root, key) def delete_node_helper(self, node, key): z = self.TNULL while node != self.TNULL: if node.val == key: z = node if node.val <= key: node = node.right else: node = node.left if z == self.TNULL: print(\\"Couldn\'t find key in the tree\\") return y = z y_original_color = y.color if z.left == self.TNULL: x = z.right self.rb_transplant(z, z.right) elif z.right == self.TNULL: x = z.left self.rb_transplant(z, z.left) else: y = self.minimum(z.right) y_original_color = y.color x = y.right if y.parent == z: x.parent = y else: self.rb_transplant(y, y.right) y.right = z.right y.right.parent = y self.rb_transplant(z, y) y.left = z.left y.left.parent = y y.color = z.color if y_original_color == 0: self.delete_fix(x) def delete_fix(self, x): while x != self.root and x.color == 0: if x == x.parent.left: s = x.parent.right if s.color == 1: s.color = 0 x.parent.color = 1 self.left_rotate(x.parent) s = x.parent.right if s.left.color == 0 and s.right.color == 0: s.color = 1 x = x.parent else: if s.right.color == 0: s.left.color = 0 s.color = 1 self.right_rotate(s) s = x.parent.right s.color = x.parent.color x.parent.color = 0 s.right.color = 0 self.left_rotate(x.parent) x = self.root else: s = x.parent.left if s.color == 1: s.color = 0 x.parent.color = 1 self.right_rotate(x.parent) s = x.parent.left if s.right.color == 0 and s.left.color == 0: s.color = 1 x = x.parent else: if s.left.color == 0: s.right.color = 0 s.color = 1 self.left_rotate(s) s = x.parent.left s.color = x.parent.color x.parent.color = 0 s.left.color = 0 self.right_rotate(x.parent) x = self.root x.color = 0 def rb_transplant(self, u, v): if u.parent == None: self.root = v elif u == u.parent.left: u.parent.left = v else: u.parent.right = v v.parent = u.parent def left_rotate(self, x): y = x.right x.right = y.left if y.left != self.TNULL: y.left.parent = x y.parent = x.parent if x.parent == None: self.root = y elif x == x.parent.left: x.parent.left = y else: x.parent.right = y y.left = x x.parent = y def right_rotate(self, x): y = x.left x.left = y.right if y.right != self.TNULL: y.right.parent = x y.parent = x.parent if x.parent == None: self.root = y elif x == x.parent.right: x.parent.right = y else: x.parent.left = y y.right = x x.parent = y def minimum(self, node): while node.left != self.TNULL: node = node.left return node def in_order_traversal(self): res = [] self._in_order_helper(self.root, res) return res def _in_order_helper(self, node, res): if node != self.TNULL: self._in_order_helper(node.left, res) res.append({\\"val\\": node.val, \\"color\\": node.color}) self._in_order_helper(node.right, res)"},{"question":"# Two-Sum Problem Using Hash Map Given an array of integers, return indices of the two numbers such that they add up to a specific target. Each input will have exactly one solution, and you may not use the same element twice. Function Signature: ```python def two_sum(array: List[int], target: int) -> Tuple[int, int]: ``` Input * `array` (List[int]): A list of integers, e.g., [2, 7, 11, 15]. * `target` (int): The target sum, e.g., 9. Output * (Tuple[int, int]): A tuple containing the indices of the two numbers such that they add up to the target. Constraints * Each input will have exactly one solution. * You may not use the same element twice. * The function should run in O(n) time complexity. Scenario/Context You are tasked with creating a function for a financial application. The function must find two transactions that add up to a specified amount. This is useful for identifying fraudulent transactions or ensuring financial consistency. Examples ```python # Example 1 array = [2, 7, 11, 15] target = 9 # Returns: (0, 1) because 2 + 7 = 9 # Example 2 array = [3, 2, 4] target = 6 # Returns: (1, 2) because 2 + 4 = 6 # Example 3 array = [3, 3] target = 6 # Returns: (0, 1) because 3 + 3 = 6 ``` # Challenge Write a function that implements the above logic efficiently, considering edge cases, performance bottlenecks, and ensuring correct results.","solution":"from typing import List, Tuple def two_sum(array: List[int], target: int) -> Tuple[int, int]: Finds the indices of two elements in the array that sum up to the target. Parameters: - array (List[int]): List of integers. - target (int): The target sum. Returns: - Tuple[int, int]: A tuple with the indices of the two elements that sum to the target. hashmap = {} for i, num in enumerate(array): complement = target - num if complement in hashmap: return (hashmap[complement], i) hashmap[num] = i return None"},{"question":"**Scenario**: You are working as a software engineer at a tech firm. One of your tasks is to identify anomalies in the company\'s product IDs. The product IDs are logged in an array where each product ID appears twice except for one unique product ID that is logged only once. Your goal is to find this unique product ID efficiently. # Problem Description Implement a function `find_unique_product_id` that accepts an array of integers `product_ids` and returns the unique product ID that appears once while every other ID appears exactly twice. # Function Signature ```python def find_unique_product_id(product_ids: List[int]) -> int: pass ``` # Input * `product_ids` (List[int]): A list of integers where each integer appears twice except for one unique integer. # Output * Returns an integer, which is the unique product ID that only appears once. # Constraints * All elements in the list are integers. * The list is non-empty and contains an odd number of integers. * The algorithm should run in linear time, O(n). * Extra space usage should be constant, O(1). # Example ```python product_ids = [4, 1, 2, 1, 2] print(find_unique_product_id(product_ids)) # Output: 4 product_ids = [7, 3, 5, 4, 5, 3, 7] print(find_unique_product_id(product_ids)) # Output: 4 ``` # Hint Use bitwise XOR to solve the problem efficiently as demonstrated in the provided analysis.","solution":"def find_unique_product_id(product_ids): Returns the unique product ID that appears only once in the list of product IDs while every other ID appears exactly twice. unique_id = 0 for pid in product_ids: unique_id ^= pid return unique_id"},{"question":"# Context Imagine you are working with a data system that logs a series of events periodically throughout the day in an array. After a system reboot, the array you work with could get \\"rotated\\" at an unknown pivot. Your task is to find the earliest logged event which corresponds to the smallest element in a numerically sorted manner. This needs to be done efficiently since the array size could be large. # Task Write a function `find_min_rotated(array)` that finds the minimum element in a rotated sorted array. The function should operate within O(logN) time complexity, reflecting efficient log-based performance indicative of a binary search approach. **Function Signature**: ```python def find_min_rotated(array: List[int]) -> int: ``` # Input - `array`: A list of integers that represents a rotated sorted array, where each element is unique and the original array was sorted in ascending order but might be rotated around some pivot. # Output - Return the minimum element from the rotated sorted array. # Constraints - The input list adds at least one element. - The integers within the array are unique and fit within typical 32-bit integer constraints. # Example ```python print(find_min_rotated([4, 5, 6, 7, 0, 1, 2])) # Output: 0 print(find_min_rotated([3, 4, 5, 1, 2])) # Output: 1 print(find_min_rotated([2, 3, 4, 5, 6, 7, 1])) # Output: 1 print(find_min_rotated([1])) # Output: 1 ``` # Notes: Consider both function forms (iterative and recursive) provided, but submit the one that you think is more efficient in terms of space complexity and robustness against large inputs.","solution":"def find_min_rotated(array): This function finds the minimum element in a rotated sorted array. Args: array (List[int]): The input list representing a rotated sorted array. Returns: int: The minimum element in the input array. if not array: raise ValueError(\\"Input array should not be empty\\") left, right = 0, len(array) - 1 while left < right: mid = (left + right) // 2 if array[mid] > array[right]: left = mid + 1 else: right = mid return array[left]"},{"question":"You are tasked to implement a hybrid queue, a combination of both array-based and linked-list-based queues. This hybrid queue should handle two primary operations, `enqueue` and `dequeue`, while optimizing for average-case time complexity. Implementation Requirements: 1. **Class Name**: `HybridQueue` 2. **Methods**: - `enqueue(value)`: Adds an element to the queue. - `dequeue()`: Removes and returns the front element from the queue. - `is_empty()`: Returns `True` if the queue is empty, otherwise `False`. - `peek()`: Returns the front element of the queue without removing it. - `__iter__()`: Iterates over the elements of the queue in FIFO order. Constraints and Notes: 1. Optimize to minimize the average-case time complexity for the `enqueue` and `dequeue` operations. 2. Use the principles of both `ArrayQueue` and `LinkedListQueue` to achieve better performance where applicable. 3. Your implementation should handle at least 1 million elements for both enqueuing and dequeuing operations efficiently. 4. The `enqueue` operation can run in amortized O(1) time due to occasional resizing or rebalancing. 5. The `dequeue` operation should run in O(1) time. # Example: ```python hq = HybridQueue() hq.enqueue(10) hq.enqueue(20) hq.enqueue(30) print(hq.dequeue()) # Output: 10 print(hq.peek()) # Output: 20 print(hq.dequeue()) # Output: 20 print(hq.is_empty()) # Output: False print(hq.dequeue()) # Output: 30 print(hq.is_empty()) # Output: True ``` *Function Signature for Reference:* ```python class HybridQueue: def __init__(self): pass def enqueue(self, value): pass def dequeue(self): pass def is_empty(self): pass def peek(self): pass def __iter__(self): pass # Example of usage: hq = HybridQueue() hq.enqueue(10) hq.enqueue(20) print(hq.dequeue()) # Should print 10 print(hq.peek()) # Should print 20 ```","solution":"class Node: def __init__(self, value=None, next_node=None): self.value = value self.next_node = next_node class HybridQueue: def __init__(self): self.front = None self.rear = None self._size = 0 def enqueue(self, value): new_node = Node(value) if self.rear is None: self.front = self.rear = new_node else: self.rear.next_node = new_node self.rear = new_node self._size += 1 def dequeue(self): if self.is_empty(): raise IndexError(\\"dequeue from empty queue\\") value = self.front.value self.front = self.front.next_node if self.front is None: self.rear = None self._size -= 1 return value def is_empty(self): return self.front is None def peek(self): if self.is_empty(): raise IndexError(\\"peek from empty queue\\") return self.front.value def __iter__(self): current = self.front while current is not None: yield current.value current = current.next_node def __len__(self): return self._size"},{"question":"You are required to implement a function to sort an array of integers using the quick sort algorithm. The function should adhere to the following specifications: # Function Signature: ```python def quick_sort(arr: List[int], simulation: bool = False) -> List[int]: ``` # Inputs: - `arr`: A list of integers, `arr`. - `simulation` (optional): A boolean flag to print the array at each recursive call (default is `False`). # Outputs: - A list of integers sorted in ascending order. # Constraints: - Your implementation should handle arrays of up to `10^5` elements efficiently. - Aim to minimize additional space complexity. - Handle edge cases such as empty arrays and arrays with duplicate integers. # Scenarios: 1. **General case with random integers**: ```python arr = [3, 6, 8, 10, 1, 2, 1] quick_sort(arr) # should return [1, 1, 2, 3, 6, 8, 10] ``` 2. **Array already sorted**: ```python arr = [1, 2, 3, 4, 5] quick_sort(arr) # should return [1, 2, 3, 4, 5] ``` 3. **Array with duplicate elements**: ```python arr = [4, 5, 4, 3, 2, 1, 2] quick_sort(arr) # should return [1, 2, 2, 3, 4, 4, 5] ``` 4. **Empty array**: ```python arr = [] quick_sort(arr) # should return [] ``` # Notes: - Ensure your solution does not exceed the O(n log(n)) time complexity on average and O(log(n)) space complexity. - Include appropriate error handling for edge cases to avoid infinite loops or incorrect sorting. - When `simulation=True`, print the array at each recursive call to observe the sorting process.","solution":"from typing import List def quick_sort(arr: List[int], simulation: bool = False) -> List[int]: if simulation: print(arr) if len(arr) <= 1: return arr pivot = arr[len(arr) // 2] left = [x for x in arr if x < pivot] middle = [x for x in arr if x == pivot] right = [x for x in arr if x > pivot] return quick_sort(left, simulation) + middle + quick_sort(right, simulation)"},{"question":"# Binary Search Tree (BST) Implementation Objective: You are to implement a Binary Search Tree (BST) with core functionalities including insertion, searching, and in-order traversal. The objective is to demonstrate your understanding of tree data structures and their efficient operations. Description: Implement a class `BST` with the following methods: 1. `insert(val: int) -> None`: Inserts a value into the BST. 2. `search(val: int) -> bool`: Searches for a value in the BST, returning `True` if found, `False` otherwise. 3. `in_order_traversal() -> List[int]`: Returns a list of elements in the BST in in-order traversal order. Expected Input and Output: - `insert(val: int) -> None`: No return value. Inserts the given value into the tree following BST properties. - `search(val: int) -> bool`: Returns `True` if the value exists in the tree, `False` otherwise. - `in_order_traversal() -> List[int]`: Returns a list of values in ascending order. Constraints: - All values inserted will be integers. - For simplicity, assume no duplicate values will be inserted. - The BST will not exceed 10^4 nodes. Performance Requirement: - Ensure that your implementation is efficient and leverages the BST properties. Scenario: ``` bst = BST() bst.insert(5) bst.insert(3) bst.insert(7) bst.insert(2) bst.insert(4) bst.insert(6) bst.insert(8) assert bst.search(4) == True assert bst.search(9) == False assert bst.in_order_traversal() == [2, 3, 4, 5, 6, 7, 8] ``` Implement the `BST` class based on the description and constraints provided.","solution":"class Node: def __init__(self, key): self.left = None self.right = None self.val = key class BST: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = Node(key) else: self._insert(self.root, key) def _insert(self, root, key): if root is None: return Node(key) else: if key < root.val: root.left = self._insert(root.left, key) else: root.right = self._insert(root.right, key) return root def search(self, key): return self._search(self.root, key) def _search(self, root, key): if root is None or root.val == key: return root is not None if key < root.val: return self._search(root.left, key) return self._search(root.right, key) def in_order_traversal(self): result = [] self._in_order_traversal(self.root, result) return result def _in_order_traversal(self, root, result): if root: self._in_order_traversal(root.left, result) result.append(root.val) self._in_order_traversal(root.right, result)"},{"question":"# Question: Implement and Enhance Tree Data Structure Printing You are given a dictionary `tree` that represents a hierarchical tree structure. Each key in the dictionary is an identifier, and its value is a list that can contain strings and other lists. Your task is to implement a function `enhanced_tree_print(tree: dict) -> None` that will print each element in the tree, respecting the hierarchical structure with proper indentation. Additionally, the function should handle edge cases gracefully and aim to minimize redundant operations. Input * `tree` (Dictionary): A dictionary representing a hierarchical tree structure. Output * The function should not return a value but should print the tree structure with proper formatting. Constraints * The input dictionary will have at most `10^3` keys. * Each key will have a list with a maximum of `10^2` elements. * Elements can either be strings or dictionaries (for nested structures). Requirements * Minimize redundant operations such as multiple lookups. * Ensure proper indentation for nested structures. * Handle edge cases like empty trees gracefully. Example ```python tree_example = { \'a\': [\'Adam\', \'Book\', 4, {\'nested\': [\'inner1\', 42]}], \'b\': [\'Bill\', \'Computer\', 5, \'TV\', 6], \'c\': [\'Bill\', \'Sports\', 3], \'d\': [\'Adam\', \'Computer\', 3, \'Quin\', {\'deep\': [\'depth\', \'level1\']}] } enhanced_tree_print(tree_example) ``` Expected Output ``` a -> Adam -> Book -> 4 -> nested -> inner1 -> 42 b -> Bill -> Computer -> 5 -> TV -> 6 c -> Bill -> Sports -> 3 d -> Adam -> Computer -> 3 -> Quin -> deep -> depth -> level1 ``` Note - Ensure the output maintains the hierarchical order and proper indentation. - Avoid redundant operations for efficiency.","solution":"def enhanced_tree_print(tree, indent=0): Prints the tree structure with proper formatting and indentation. Parameters: tree (dict): A dictionary representing a hierarchical tree structure. indent (int): The current level of indentation (used internally). def print_with_indent(value, indent): print(\' \' * indent + str(value)) for key, value in tree.items(): print_with_indent(f\\"{key} ->\\", indent) for item in value: if isinstance(item, dict): enhanced_tree_print(item, indent + 2) else: print_with_indent(item, indent + 2)"},{"question":"# FizzBuzz Advanced Replacement Your task is to create a function that not only performs the standard FizzBuzz but also allows additional replacement rules. Function Signature ```python def advanced_fizzbuzz(n: int, replacements: list) -> list: Generates a list from 1 to n with multiple replacements. Args: n (int): The length of the list (1 <= n). replacements (list): A list of tuples where each tuple contains: (int divisor, string replacement). Returns: list: The sequence from 1 to n with specified replacements. ``` Problem Statement: 1. The function `advanced_fizzbuzz` should generate a list of integers from 1 to `n` with specific values replaced based on the provided `replacements` list. 2. The `replacements` list will contain tuples `(divisor, replacement)`, indicating that any number divisible by `divisor` should be replaced with `replacement`. 3. If a number is divisible by multiple values provided in `replacements`, concatenate their corresponding replacements instead of the number itself. Input: - An integer `n` (1 <= `n`). - A list of tuples `replacements` where each tuple contains: * An integer `divisor` * A string `replacement` Output: - A list of integers and strings, based on the replacement rules. Example: ```python # Example 1 print(advanced_fizzbuzz(15, [(3, \\"Fizz\\"), (5, \\"Buzz\\")])) # Output: [1, 2, \'Fizz\', 4, \'Buzz\', \'Fizz\', 7, 8, \'Fizz\', \'Buzz\', 11, \'Fizz\', 13, 14, \'FizzBuzz\'] # Example 2 print(advanced_fizzbuzz(10, [(2, \\"Two\\"), (3, \\"Three\\")])) # Output: [1, \'Two\', \'Three\', \'Two\', 5, \'TwoThree\', 7, \'Two\', \'Three\', \'Two\'] ``` Constraints: - `divisors` in replacements will always be positive integers. - The function should handle cases where no replacements are provided (an empty list). Good luck! Demonstrate your proficiency by handling different edge cases and ensuring efficient performance.","solution":"def advanced_fizzbuzz(n: int, replacements: list) -> list: Generates a list from 1 to n with multiple replacements. Args: n (int): The length of the list (1 <= n). replacements (list): A list of tuples where each tuple contains: (int divisor, string replacement). Returns: list: The sequence from 1 to n with specified replacements. result = [] for i in range(1, n + 1): replacement = \\"\\" for divisor, repl in replacements: if i % divisor == 0: replacement += repl result.append(replacement or i) return result"},{"question":"# String Deduplication **Objective**: Write a function to remove all reoccurring characters from a given string and return the new string containing only the first occurrence of each character, maintaining their order of appearance. **Function Signature**: ```python def delete_reoccurring_characters(string: str) -> str: ``` **Input**: - A single string `string`, which represents the original string. The length of the string can be up to `10^5`. **Output**: - A new string without any reoccurring characters. **Examples**: 1. `delete_reoccurring_characters(\\"programming\\")` should return `\\"progamin\\"`. 2. `delete_reoccurring_characters(\\"aabbcc\\")` should return `\\"abc\\"`. 3. `delete_reoccurring_characters(\\"abc\\")` should return `\\"abc\\"`. 4. `delete_reoccurring_characters(\\"\\")` should return `\\"\\"`. **Constraints**: - The string may contain any ASCII characters. - The function should handle input strings up to 100,000 characters efficiently. **Performance Requirements**: - The solution should run in linear time O(n) with respect to the length of the input string. **Edge Cases**: 1. Empty strings. 2. Strings with all unique characters. 3. Strings with all repeated characters.","solution":"def delete_reoccurring_characters(string: str) -> str: Removes all reoccurring characters from the string and returns the new string containing only the first occurrence of each character. seen_chars = set() result = [] for char in string: if char not in seen_chars: seen_chars.add(char) result.append(char) return \'\'.join(result)"},{"question":"# Scenario You are working as a software engineer in a company that provides analytical tools for data processing. One of the common operations your company\'s software performs is efficient range queries on datasets. You are tasked with implementing a powerful data structure that allows for these operations. # Task Given the implementation of a `SegmentTree` class, extend the functionality of this class to include dynamic updates of array elements. This extended class should support efficient updates without rebuilding the entire tree. # Implementation Create a method `update(idx, value)` method to the `SegmentTree` class that updates the value at a specific index `idx` in the array to `value` and updates the segment tree accordingly. # Requirements * **Input**: * `idx` (an integer representing the index in the array to be updated). * `value` (the new value to replace the current value at `idx`). * **Output**: * Adjust the internal segment tree to reflect the update for future range queries. * **Constraints**: * 0 <= idx < len(arr) * The function used for combining segments (`fn`) is associative. # Function Signature ```python def update(idx: int, value: int) -> None: # updates the segment tree ```","solution":"class SegmentTree: def __init__(self, arr, fn): Initialize the segment tree. Parameters: arr : List[int] : input array fn : Callable[[Any, Any], Any] : function to combine segments self.n = len(arr) self.tree = [0] * (2 * self.n) self.fn = fn # Initialize leaves in the tree for i in range(self.n): self.tree[self.n + i] = arr[i] # Build the tree in bottom-up manner for i in range(self.n - 1, 0, -1): self.tree[i] = self.fn(self.tree[2 * i], self.tree[2 * i + 1]) def update(self, idx, value): Update the value at index idx to value. Parameters: idx : int : the index to update value : int : the new value # Set value at position idx pos = idx + self.n self.tree[pos] = value # Move upward and update parents while pos > 1: pos //= 2 self.tree[pos] = self.fn(self.tree[2 * pos], self.tree[2 * pos + 1]) def range_query(self, l, r): Perform a range query on interval [l, r). Parameters: l : int : left index (inclusive) r : int : right index (exclusive) Returns: The result of the function on the interval [l, r). res = None l += self.n r += self.n while l < r: if l % 2: if res is None: res = self.tree[l] else: res = self.fn(res, self.tree[l]) l += 1 if r % 2: r -= 1 if res is None: res = self.tree[r] else: res = self.fn(res, self.tree[r]) l //= 2 r //= 2 return res"},{"question":"You are given a series of concatenated positive integers starting from 1, that is \\"123456789101112...\\". You need to write a function `find_nth_digit(n)` that returns the nth digit in this sequence. Function Signature: ```python def find_nth_digit(n: int) -> int: pass ``` # Input: * An integer `n` (1 ≤ n ≤ 2*10^9) # Output: * An integer representing the nth digit in the infinite sequence of concatenated positive integers. # Constraints: 1. The input integer `n` falls within the range of 1 to 2*10^9 inclusively. # Example: ```python assert find_nth_digit(3) == 3 assert find_nth_digit(11) == 0 assert find_nth_digit(15) == 2 assert find_nth_digit(1) == 1 ``` # Performance Requirements: * Your solution should run efficiently within the problem constraints, making sure the time complexity remains logarithmic in nature and uses constant space. # Implementation Hints: Consider breaking down the problem into the following steps: 1. Determine the length of number strings required to reach or exceed the nth digit. 2. Identify the specific number and its position containing the nth digit. 3. Extract and return the correct digit within that number.","solution":"def find_nth_digit(n: int) -> int: # Step 1: Determine the length of number strings required to reach or exceed the nth digit length = 1 # Length of numbers in string representation (1, 2, ..., 9; 10, 11, ..., 99; etc.) count = 9 # Total numbers with `length` digits # Decrease n to determine its position within the sequence while n > length * count: n -= length * count length += 1 count *= 10 # Step 2: Identify the specific number # Determine the actual number where the position falls into start_number = 10 ** (length - 1) number = start_number + (n - 1) // length # Step 3: Extract and return the correct digit within that number digit_index = (n - 1) % length return int(str(number)[digit_index])"},{"question":"# Question: Validate Palindrome Permutations Given a string `s`, determine if any permutation of the string is a palindrome. Consider only alphanumeric characters and ignore cases. If any permutation of the string can form a palindrome, return `True`. Otherwise, return `False`. **Input**: - A string `s` (1 <= |s| <= 10^5). **Output**: - A boolean value: `True` if any permutation of the given string can form a palindrome, otherwise `False`. **Constraints**: - The function should have an efficient time complexity, ideally O(n), where n is the length of the string. - Handle special cases, such as strings with all identical characters or strings with non-alphanumeric characters. **Example**: ```python assert can_form_palindrome(\\"A man, a plan, a canal: Panama\\") == True assert can_form_palindrome(\\"race a car\\") == False assert can_form_palindrome(\\"aabbcc\\") == True assert can_form_palindrome(\\"abc\\") == False ``` **Function signature**: ```python def can_form_palindrome(s: str) -> bool: pass ``` **Explanation**: 1. **Filter and Normalize**: First, clean the string to keep only alphanumeric characters in lowercase. 2. **Character Frequency**: Determine the frequency of each character. 3. **Palindrome Permutation Rule**: For a string to be able to form a palindrome, at most one character can have an odd frequency (this would be the center character in palindromes of odd length). Implement a function `can_form_palindrome(s: str) -> bool`: **Testing and Edge Cases**: 1. Test with strings containing only one character. 2. Strings with various punctuation marks and spaces. 3. Both odd and even length strings. 4. Fully transformed strings being palindromes directly. 5. Performance with large input size (close to the upper limit of constraints).","solution":"def can_form_palindrome(s: str) -> bool: Given a string, determine if any permutation of the string can form a palindrome. from collections import Counter # Filter and normalize the string filtered_str = \'\'.join(char.lower() for char in s if char.isalnum()) # Count the frequency of each character char_count = Counter(filtered_str) # Palindrome means one or zero characters have odd counts odd_counts = sum(1 for count in char_count.values() if count % 2 != 0) # A string can be permuted to form a palindrome if there\'s at most one odd count return odd_counts <= 1"},{"question":"You are provided a list of integers or strings, and you need to construct a histogram that represents the frequency of each element. The histogram should be returned as a dictionary where keys are the unique elements of the list and values are their corresponding counts. Write a function `compute_histogram(data: list) -> dict` that achieves this. Input - `data`: A list of integers or strings (0 <= len(data) <= 10^6) Output - A dictionary where each key is an element from the list, and the corresponding value is its frequency count. Constraints - Elements in the list are either integers or strings (not mixed). - The function should handle large input sized efficiently in terms of both time and space. Performance Requirements - The function must run in O(n) time complexity. - The space complexity should also be impressively managed to accommodate large inputs and outputs efficiently. Example ```python data = [3, 3, 2, 1] compute_histogram(data) # Output: {1: 1, 2: 1, 3: 2} data = [\\"apple\\", \\"banana\\", \\"apple\\", \\"orange\\", \\"banana\\", \\"banana\\"] compute_histogram(data) # Output: {\\"apple\\": 2, \\"banana\\": 3, \\"orange\\": 1} ``` Additional Test Cases ```python data = [] compute_histogram(data) # Output: {} data = [1, 1, 1, 1, 1] compute_histogram(data) # Output: {1: 5} data = [\\"a\\", \\"b\\", \\"c\\", \\"a\\", \\"b\\", \\"a\\"] compute_histogram(data) # Output: {\\"a\\": 3, \\"b\\": 2, \\"c\\": 1} ``` **Note**: Ensure that your function maintains efficiency even with the largest possible input size.","solution":"def compute_histogram(data): Constructs a histogram that represents the frequency of each element in the list. Parameters: data (list): List of integers or strings. Returns: dict: Dictionary where keys are unique elements of the list and values are their frequency counts. histogram = {} for item in data: if item in histogram: histogram[item] += 1 else: histogram[item] = 1 return histogram"},{"question":"# Question: Implement an advanced search algorithm **Scenario**: You are working for a company that handles large databases of electronic shopping prices, sorted in ascending order. The company frequently needs to find pricing details quickly. For this reason, they are interested in using the Interpolation Search algorithm due to its efficiency in average cases with uniformly distributed data. **Task**: Implement an `enhanced_interpolation_search` function that performs a search for a given value in a sorted array of prices. You should address potential edge cases and handle common problems that this search might face, such as handling arrays with nonuniform distributions. Function Signature: ```python def enhanced_interpolation_search(prices: List[float], target_price: float) -> int: Search for the given target_price in prices array using an enhanced interpolation search. :param prices: A sorted list of item prices in ascending order. :param target_price: The price to be searched. :return: The index of the target_price in the prices list if found, otherwise return -1. ``` Input: * `prices`: A list of float elements in ascending order, representing sorted item prices. * `target_price`: A float value representing the price to search for. Output: * An integer representing the index of the target_price in the given list if it is found, otherwise -1. Constraints: * The list `prices` is guaranteed to be sorted in ascending order. * Apply optimization to enhance the performance for nonuniform distributed data. Examples: ```python >>> enhanced_interpolation_search([10.0, 20.5, 30.5, 40.75, 50.0], 30.5) 2 >>> enhanced_interpolation_search([5.0, 12.25, 14.5, 18.75, 21.0, 30.0], 18.75) 3 >>> enhanced_interpolation_search([100.0, 200.5, 300.75, 400.1, 500.5], 105.0) -1 >>> enhanced_interpolation_search([5.0], 5.0) 0 >>> enhanced_interpolation_search([], 7.5) -1 ``` **Additional Notes**: * You should test for edge cases like empty lists or lists where all elements are the same. * Ensure your implementation doesn\'t run into division-by-zero errors or infinite loops.","solution":"def enhanced_interpolation_search(prices, target_price): Search for the given target_price in prices array using an enhanced interpolation search. :param prices: A sorted list of item prices in ascending order. :param target_price: The price to be searched. :return: The index of the target_price in the prices list if found, otherwise return -1. low = 0 high = len(prices) - 1 while low <= high and target_price >= prices[low] and target_price <= prices[high]: if low == high: if prices[low] == target_price: return low return -1 # Probing position using the interpolation formula if prices[high] == prices[low]: pos = low else: pos = low + int(((float(high - low) / (prices[high] - prices[low])) * (target_price - prices[low]))) # Target found if prices[pos] == target_price: return pos # If target is larger, target is in the upper part if prices[pos] < target_price: low = pos + 1 # If target is smaller, target is in the lower part else: high = pos - 1 return -1"},{"question":"Problem Statement You are given a matrix `mat` of size `n x n` and an integer `k`. Your task is to implement a function that computes the `k`-th power of the matrix `mat`, denoted as `mat^k`. To achieve this, you should leverage matrix exponentiation by repeated squaring for efficiency. # Function Signature ```python def matrix_power(mat: list, k: int) -> list: Computes the k-th power of a given matrix mat using matrix exponentiation by squaring. Parameters: - mat (list of list of int): A square matrix of integers. - k (int): The exponent to which the matrix is to be raised. Returns: - list of list of int: A new matrix representing mat^k. # Input - `mat`: A list of lists representing an `n x n` matrix, where `1 ≤ n ≤ 100`. - `k`: An integer `0 ≤ k ≤ 10^9`. # Output - A list of lists representing the resulting matrix after raising `mat` to the power of `k`. # Constraints - Use the principles of matrix exponentiation by repeated squaring to achieve efficient computation. - Ensure that your implementation can handle the upper bounds of input sizes and power values. # Example ```python mat = [ [1, 2], [3, 4] ] k = 2 # Expected output: # [ # [7, 10], # [15, 22] #] print(matrix_power(mat, k)) ```","solution":"def matrix_multiply(mat1, mat2): n = len(mat1) result = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): for k in range(n): result[i][j] += mat1[i][k] * mat2[k][j] return result def matrix_power(mat, k): Computes the k-th power of a given matrix mat using matrix exponentiation by squaring. Parameters: - mat (list of list of int): A square matrix of integers. - k (int): The exponent to which the matrix is to be raised. Returns: - list of list of int: A new matrix representing mat^k. n = len(mat) # Initialize identity matrix of size n x n result = [[1 if i == j else 0 for j in range(n)] for i in range(n)] base = mat while k > 0: if k % 2 == 1: result = matrix_multiply(result, base) base = matrix_multiply(base, base) k //= 2 return result"},{"question":"You have been tasked to implement the Radix Sort algorithm to sort a list of non-negative integers without using any built-in sort functions. The algorithm should process each digit of the number starting from the least significant digit to the most significant digit. # Function Definition: Create a function `radix_sort(arr: List[int], simulation: bool = False) -> List[int]` that follows the Radix Sort principles to sort an array of non-negative integers. # Input: * `arr`: A list of non-negative integers. * `simulation`: A boolean flag to print the state of the array after each iteration of sorting by each significant digit (Optional, default is False). # Output: * Returns a sorted list of integers. # Constraints: * The list can contain up to 1,000,000 integers. * Each integer in the list can be up to 1,000,000,000. # Requirements: 1. **Stability** in sorting should be maintained. 2. The function should efficiently sort the input list within reasonable time limits (O(nk)). 3. Optionally, if the `simulation` flag is set to `True`, print the array state after each digit-level sort in the format: `iteration <iteration_number>: <space-separated-array-contents>`. # Example: ```python arr = [170, 45, 75, 90, 802, 24, 2, 66] sorted_arr = radix_sort(arr) print(sorted_arr) # Output: [2, 24, 45, 66, 75, 90, 170, 802] # With simulation radix_sort(arr, simulation=True) # Output: # iteration 0: 170 90 802 2 24 45 75 66 # iteration 1: 802 2 24 45 66 170 75 90 # iteration 2: 2 24 45 66 75 90 170 802 ``` # Notes: * Ensure the radix sort handles edge cases such as empty arrays, arrays with repeated elements, and very large numbers efficiently. * Handle potential integer overflow scenarios if using languages or environments where this might be a concern. * Make sure to use additional memory efficiently while maintaining the core logic of Radix Sort.","solution":"def counting_sort_for_radix(arr, exp, simulation, iteration): n = len(arr) output = [0] * n count = [0] * 10 for i in range(n): index = (arr[i] // exp) % 10 count[index] += 1 for i in range(1, 10): count[i] += count[i - 1] i = n - 1 while i >= 0: index = (arr[i] // exp) % 10 output[count[index] - 1] = arr[i] count[index] -= 1 i -= 1 for i in range(n): arr[i] = output[i] if simulation: print(f\\"iteration {iteration}: {\' \'.join(map(str, arr))}\\") def radix_sort(arr, simulation=False): if len(arr) == 0: return arr max_num = max(arr) exp = 1 iteration = 0 while max_num // exp > 0: counting_sort_for_radix(arr, exp, simulation, iteration) exp *= 10 iteration += 1 return arr"},{"question":"# Cocktail Shaker Sort Implementation and Analysis **Background**: Cocktail Shaker Sort is an enhanced version of Bubble Sort that traverses the list in both forward and backward directions. This bidirectional sorting aims to reduce the number of passes by ensuring that smaller elements move to the beginning and larger ones to the end in one complete iteration of the list. **Objective**: Implement the Cocktail Shaker Sort algorithm in Python. Further, analyze its operation for efficiency, edge cases, and optimize where possible. **Function Signature**: ```python def cocktail_shaker_sort(arr: list) -> list: pass ``` **Input**: * A list of N elements (e.g., `arr`), where N (1 ≤ N ≤ 10^5) can be any integer representing the number of integers to sort. * The elements in the list can be any integers within the range −10^9 to 10^9. **Output**: * The function should return a new list that is a sorted version of `arr`. **Constraints**: * Optimize for the best-case scenario (handling already sorted lists). * Consider early exits to avoid unnecessary iterations. * Your solution should handle large inputs efficiently within the constraints mentioned. **Example**: ```python >>> cocktail_shaker_sort([3, 0, 2, 5, -1, 4, 1]) [-1, 0, 1, 2, 3, 4, 5] >>> cocktail_shaker_sort([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> cocktail_shaker_sort([]) [] ``` # Requirements: 1. **Implement the Cocktail Shaker Sort algorithm**: - Ensure that it sorts correctly for both large and small input sizes. - Make sure to handle and test edge cases comprehensively. 2. **Optimize Performance**: - Add logic to detect if no elements were swapped during a pass to avoid further unnecessary passes. - Consider any other techniques that might improve efficiency, particularly focusing on the characteristics of the algorithm. 3. **Testing**: - Thoroughly test your implementation with various test cases, including edge cases of empty and single-element lists, large ranges of numbers, and lists with duplicate elements. 4. **Analysis of Edge Cases**: - Explain how your implementation handles edge cases, and provide reasoning for any specific design choices made to optimize the standard algorithm.","solution":"def cocktail_shaker_sort(arr: list) -> list: Sorts a list using the Cocktail Shaker Sort algorithm. if not arr: return arr n = len(arr) start = 0 end = n - 1 swapped = True while swapped: swapped = False for i in range(start, end): if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] swapped = True if not swapped: break swapped = False end -= 1 for i in range(end, start, -1): if arr[i] < arr[i - 1]: arr[i], arr[i - 1] = arr[i - 1], arr[i] swapped = True start += 1 return arr"},{"question":"# Question: Run-Length Encoding and Decoding Run-length encoding (RLE) is a simple form of data compression where runs of data (repeated elements) are stored as a single data value and count. Implement the encoding function for compressing a string and decoding function for decompressing the encoded string. Function Signature 1. `encode_rle(input: str) -> str` 2. `decode_rle(input: str) -> str` Input * The `encode_rle` function accepts a single string parameter `input` (0 <= len(input) <= 10^5), which only contains alphabetic characters. * The `decode_rle` function accepts a single string parameter `input` (0 <= len(input) <= 10^5) which is a valid run-length encoded string. Output * The `encode_rle` function should return a run-length encoded string, where each run is represented as a count followed by the character itself. * The `decode_rle` function should return the original string before run-length encoding. Example ```python assert encode_rle(\\"aaabbc\\") == \\"3a2b1c\\" assert decode_rle(\\"3a2b1c\\") == \\"aaabbc\\" ``` Constraints * **Ensure** the encoding handles strings with no consecutive repeating characters efficiently. * **Edge Cases**: - Empty strings should return empty results without errors. - Strings with varying character frequencies should be correctly encoded and decoded. * **Performance**: The solutions should be efficient and capable of handling the upper limit constraints without significant delays. Write the functions to perform the run-length encoding and decoding as described.","solution":"def encode_rle(input: str) -> str: Encodes the input string using run-length encoding. if not input: return \\"\\" encoded = [] count = 1 n = len(input) for i in range(1, n): if input[i] == input[i - 1]: count += 1 else: encoded.append(f\\"{count}{input[i - 1]}\\") count = 1 encoded.append(f\\"{count}{input[-1]}\\") return \'\'.join(encoded) def decode_rle(input: str) -> str: Decodes the run-length encoded string to its original form. if not input: return \\"\\" decoded = [] n = len(input) i = 0 while i < n: count = 0 while i < n and input[i].isdigit(): count = count * 10 + int(input[i]) i += 1 if i < n: decoded.append(input[i] * count) i += 1 return \'\'.join(decoded)"},{"question":"# Binary Search Tree Implementation and Analysis Problem Statement: You are required to implement a Binary Search Tree (BST) class that supports insertion, search, size computation, and pre-order, in-order, and post-order traversals. Your implementation should be efficient and handle edge cases such as inserting duplicate values and searching for values not present in the tree. Requirements: - **Input Format:** - `insert(data)`: Method to insert a new integer `data` into the BST. - `search(data)`: Method to search for an integer `data` in the BST. Returns `True` if found, `False` otherwise. - `size()`: Method to return the number of elements in the BST. - `preorder()`, `inorder()`, `postorder()`: Methods to perform pre-order, in-order, and post-order traversals respectively. - **Output Format:** - `search(data)`: Returns a boolean indicating whether `data` exists in the BST. - `size()`: Returns an integer representing the number of nodes in the BST. - `preorder()`, `inorder()`, and `postorder()`: Print the traversal order of the nodes. Constraints: - All values inserted are integers. - Assume `-10^6 <= data <= 10^6`. - Each `insert` operation is guaranteed to be valid (non-duplicate). Example Scenario: Consider the following sequence of operations on a BST: ```python bst = BST() bst.insert(10) bst.insert(5) bst.insert(15) bst.insert(3) bst.insert(7) print(bst.search(7)) # Output: True print(bst.size()) # Output: 5 bst.preorder() # Output: 10 5 3 7 15 bst.inorder() # Output: 3 5 7 10 15 bst.postorder() # Output: 3 7 5 15 10 ``` Unit Tests: You are encouraged to write unit tests to verify your implementation against various test cases. Use the provided structure in the `TestSuite` class. Implementation Points: - Ensure concise and efficient code that correctly implements all required methods. - Handle edge cases such as attempting to search for a non-existent value or trying to insert a duplicate value. - Consider writing additional helper methods if needed. Implement your `BST` class efficiently to pass standard unit tests as part of your assessment.","solution":"class Node: def __init__(self, value): self.value = value self.left = None self.right = None class BST: def __init__(self): self.root = None self.node_count = 0 def insert(self, data): if self.root is None: self.root = Node(data) self.node_count += 1 else: self._insert(self.root, data) def _insert(self, node, data): if data < node.value: if node.left is None: node.left = Node(data) self.node_count += 1 else: self._insert(node.left, data) elif data > node.value: if node.right is None: node.right = Node(data) self.node_count += 1 else: self._insert(node.right, data) def search(self, data): return self._search(self.root, data) def _search(self, node, data): if node is None: return False if data < node.value: return self._search(node.left, data) elif data > node.value: return self._search(node.right, data) else: return True def size(self): return self.node_count def preorder(self): return self._preorder(self.root, []) def _preorder(self, node, result): if node is not None: result.append(node.value) self._preorder(node.left, result) self._preorder(node.right, result) return result def inorder(self): return self._inorder(self.root, []) def _inorder(self, node, result): if node is not None: self._inorder(node.left, result) result.append(node.value) self._inorder(node.right, result) return result def postorder(self): return self._postorder(self.root, []) def _postorder(self, node, result): if node is not None: self._postorder(node.left, result) self._postorder(node.right, result) result.append(node.value) return result"},{"question":"# Encoding and Decoding Strings Context: You are part of a development team building a network communication system. One of the requirements is to efficiently transmit lists of strings between different system components. To achieve this, you need to encode a list of strings into a single string to be sent over the network and then decode that string back to its original list of strings on the receiving end. Problem: Implement two functions, `encode` and `decode`, which will encode a list of strings into a single string and decode the string back to the list of strings. Requirements: 1. Implement the `encode` function: * **Input**: A list of strings `strs`. * **Output**: A single string representing the encoded list. ```python def encode(strs): Encodes a list of strings to a single string. :type strs: List[str] :rtype: str ``` 2. Implement the `decode` function: * **Input**: A single string `s` that is the encoded format of a list of strings. * **Output**: The original list of strings. ```python def decode(s): Decodes a single string to a list of strings. :type s: str :rtype: List[str] ``` Constraints: * The encoded string format should preserve the full content of each string in the list. * You can assume that the strings in the list only contain printable ASCII characters. * Aim for O(N) complexity for both time and space. * Edge cases to consider: - An empty list of strings should encode to an empty string and decode back to an empty list. - Strings in the list might contain spaces or colons, and your encoding should handle such cases effectively.","solution":"def encode(strs): Encodes a list of strings to a single string. :type strs: List[str] :rtype: str return \'\'.join(f\'{len(s)}:{s}\' for s in strs) def decode(s): Decodes a single string to a list of strings. :type s: str :rtype: List[str] i, n = 0, len(s) res = [] while i < n: j = i while s[j] != \':\': j += 1 length = int(s[i:j]) res.append(s[j+1:j+1+length]) i = j + 1 + length return res"},{"question":"Problem Statement: Efficient String Matching with KMP Algorithm # Objective Implement the Knuth-Morris-Pratt (KMP) algorithm to find all occurrences of a pattern string within a given text string efficiently. # Function Signature ```python def find_pattern_occurrences(text: str, pattern: str) -> List[int]: ``` # Expected Input and Output Formats: * **Input**: - `text`: A string `text` containing the characters where patterns will be searched. (1 ≤ len(text) ≤ 10^5) - `pattern`: A string `pattern` which needs to be found in the `text`. (1 ≤ len(pattern) ≤ 10^5) * **Output**: - A list of starting indices of occurrences of `pattern` in the `text`. If the pattern is not found, return an empty list. # Constraints: * The search should be case-sensitive. * The pattern and text should only contain printable ASCII characters. * Handle edge cases like an empty pattern or text string. # Performance Requirements: * The solution should run in linear time relative to the sum of the length of the `text` and `pattern`. # Example: ```python assert find_pattern_occurrences(\'hello there hero!\', \'he\') == [0, 7, 12] assert find_pattern_occurrences(\'aaaaa\', \'aa\') == [0, 1, 2, 3] assert find_pattern_occurrences(\'abc\', \'\') == [] assert find_pattern_occurrences(\'\', \'abc\') == [] ``` # Implementation Tips: * First, construct the LPS (Longest Prefix Suffix) array for the pattern. * Then, use the LPS array to perform the search in the `text` string without unnecessary comparisons.","solution":"from typing import List def find_pattern_occurrences(text: str, pattern: str) -> List[int]: Returns a list of starting indices of occurrences of `pattern` in the `text`. If the pattern is not found, it returns an empty list. def compute_lps(pattern: str) -> List[int]: Helper function to compute the Longest Prefix Suffix (LPS) array. lps = [0] * len(pattern) length = 0 i = 1 while i < len(pattern): if pattern[i] == pattern[length]: length += 1 lps[i] = length i += 1 else: if length != 0: length = lps[length - 1] else: lps[i] = 0 i += 1 return lps if not pattern: return [] lps = compute_lps(pattern) i = 0 # index for text j = 0 # index for pattern result = [] while i < len(text): if pattern[j] == text[i]: i += 1 j += 1 if j == len(pattern): result.append(i - j) j = lps[j - 1] elif i < len(text) and pattern[j] != text[i]: if j != 0: j = lps[j - 1] else: i += 1 return result"},{"question":"# Task: Implement a Complex Integer Conversion and Validation Objective Create two functions to accommodate integer-to-byte and byte-to-integer conversion for a new system architecture that requires verifying the correctness of byte sequences. # Function 1: Convert Integer to Mixed-Endian Byte Array Write a function `int_to_bytes_mixed_endian(num, size)` which: - Converts an integer `num` to a byte array with a mixed-endian format. - In this mixed-endian format, odd-indexed bytes follow little-endian order, and even-indexed bytes follow big-endian order. For example: - `int_to_bytes_mixed_endian(305419896, 4)` should return `b\'x12x34x56x78\'` # Function 2: Validate Mixed-Endian Byte Array to Integer Write a function `mixed_endian_to_int(bytestr)` which: - Validates a given byte array in mixed-endian format. - Converts it back to an integer if the validation is successful; otherwise, returns `None`. For example: - `mixed_endian_to_int(b\'x12x34x56x78\')` should return 305419896. # Implementation Requirements 1. **Input and Output Formats**: - `int_to_bytes_mixed_endian(num, size)` takes: * `num` (0 <= num < 2^(8*size)): A non-negative integer. * `size` (0 < size <= 8): Number of bytes in the result. - Returns a byte array of length `size`. - `mixed_endian_to_int(bytestr)` takes: * `bytestr` (non-empty bytes): A byte array. - Returns an integer or `None`. 2. **Constraints**: - You need to handle only non-negative integers for this task. - Ensure that excess zero-padding bytes are removed during conversion. 3. **Performance Requirements**: - Both functions should run in O(n) time complexity. - Minimize unnecessary memory allocations. # Example ```python assert int_to_bytes_mixed_endian(305419896, 4) == b\'x12x34x56x78\' assert mixed_endian_to_int(b\'x12x34x56x78\') == 305419896 assert mixed_endian_to_int(b\'\') == None ``` # Hint - You may use regular int-to-bytes conversion for segments and adjust positions as needed.","solution":"def int_to_bytes_mixed_endian(num, size): Converts an integer to a mixed-endian byte array. In the mixed-endian format, odd-indexed bytes follow little-endian order, and even-indexed bytes follow big-endian order. :param num: The integer to convert (0 <= num < 2^(8*size)). :param size: The number of bytes in the result (0 < size <= 8). :return: A byte array of length \'size\' in mixed-endian format. if num < 0 or size <= 0 or size > 8: raise ValueError(\\"Invalid input for num or size\\") if num >= (1 << (8 * size)): raise ValueError(\\"num is too large for the given size\\") mixed_endian_bytes = bytearray(size) for i in range(size): if i % 2 == 0: # Even index: big-endian mixed_endian_bytes[i] = (num >> (8 * (size - 1 - i))) & 0xFF else: # Odd index: little-endian mixed_endian_bytes[i] = (num >> (8 * (size - 1 - i))) & 0xFF return bytes(mixed_endian_bytes) def mixed_endian_to_int(bytestr): Converts a mixed-endian byte array back to the integer if it is valid. :param bytestr: The byte array to convert. :return: The integer represented by the byte array if valid; otherwise, None. size = len(bytestr) if size == 0: return None num = 0 for i in range(size): if i % 2 == 0: # Even index: big-endian num |= bytestr[i] << (8 * (size - 1 - i)) else: # Odd index: little-endian num |= bytestr[i] << (8 * (size - 1 - i)) return num"},{"question":"**Scenario**: You are working on an application that processes historical data, part of which involves converting Roman numeral records to a more modern format for analysis. Your task is to implement a function that efficiently converts Roman numeral strings to their equivalent integer values. **Task**: Write a Python function `roman_to_int(s: str) -> int` that takes a Roman numeral string `s` and converts it to an integer. Input and Output - **Input**: A string `s` representing a Roman numeral. The string is guaranteed to be valid and within the range from 1 to 3999. - **Output**: An integer representing the converted value of the Roman numeral. Example ```python # Example 1 input: \\"III\\" output: 3 # Explanation: III = 3 # Example 2 input: \\"IV\\" output: 4 # Explanation: IV = 4 # Example 3 input: \\"IX\\" output: 9 # Explanation: IX = 9 # Example 4 input: \\"LVIII\\" output: 58 # Explanation: LVIII = 50 + 5 + 3 = 58 # Example 5 input: \\"MCMXCIV\\" output: 1994 # Explanation: M = 1000, CM = 900, XC = 90, IV = 4; therefore, 1000 + 900 + 90 + 4 = 1994 ``` Constraints - The input string `s` will only contain the characters \'I\', \'V\', \'X\', \'L\', \'C\', \'D\', and \'M\'. - The input string is guaranteed to be within the range from 1 to 3999, inclusive. **Performance Requirements** - Your implementation should have a time complexity of O(n) and a space complexity of O(1), where n is the length of the Roman numeral string. Hints - Pay attention to characters that precede larger values, like \\"IV\\" or \\"IX\\", where subtraction is required. - Using a dictionary for constant-time lookups of Roman numeral values will be beneficial. **Function Signature** ```python def roman_to_int(s: str) -> int: ```","solution":"def roman_to_int(s: str) -> int: Converts a Roman numeral string to an integer. :param s: str - Roman numeral string :return: int - Equivalent integer value roman_to_value = { \'I\': 1, \'V\': 5, \'X\': 10, \'L\': 50, \'C\': 100, \'D\': 500, \'M\': 1000 } total = 0 prev_value = 0 for char in reversed(s): value = roman_to_value[char] if value >= prev_value: total += value else: total -= value prev_value = value return total"},{"question":"# Counting Sort Implementation Context Counting Sort is a non-comparison based sorting algorithm suitable for sorting arrays of integers when the range of integers (k) is not significantly larger than the number of elements (n). Given an array of integers, your task is to implement the Counting Sort algorithm to sort the array. Task Write a function `counting_sort(arr: List[int]) -> List[int]` that takes an array of integers `arr` and returns a sorted version of this array using Counting Sort. # Function Signature ```python from typing import List def counting_sort(arr: List[int]) -> List[int]: pass ``` Input * `arr`: A list of integers where each integer can be negative or positive. The length of the array can be any non-negative integer. Output * Returns a list of integers sorted in non-decreasing order. Constraints * The size of the input array can be up to 10^6. * Elements of the array can be negative integers as well as positive, within the range of -10^6 to 10^6. Performance Requirements * The solution must run in O(n + k) time complexity. # Example ```python print(counting_sort([4, 2, -3, 6, -1, -4, 3])) # Output: [-4, -3, -1, 2, 3, 4, 6] print(counting_sort([1, 4, 2, 7, 2])) # Output: [1, 2, 2, 4, 7] print(counting_sort([])) # Output: [] ``` # Notes * Handle edge cases such as empty arrays or arrays with all identical numbers. * Ensure to correctly handle negative numbers.","solution":"from typing import List def counting_sort(arr: List[int]) -> List[int]: if not arr: return [] max_val = max(arr) min_val = min(arr) range_of_elements = max_val - min_val + 1 # Initialize count array count = [0] * range_of_elements # Store the count of each element for num in arr: count[num - min_val] += 1 # Calculate cumulative count for i in range(1, len(count)): count[i] += count[i - 1] # Place the elements in the output array based on the cumulative count output = [0] * len(arr) for num in reversed(arr): output[count[num - min_val] - 1] = num count[num - min_val] -= 1 return output"},{"question":"You are tasked with implementing a solution for tracking the minimum value in a stack. You are not allowed to modify the existing stack operations (push, pop, peek, and is_empty) but must extend the given stack implementation (either ArrayStack or LinkedListStack) to allow for retrieving the minimum element in constant time `O(1)`. # Requirements: 1. Implement a `MinStack` class that extends from `ArrayStack` or `LinkedListStack`. 2. Add a method `get_min()` which returns the minimum value currently in the stack. 3. Ensure that `get_min()` operates in constant time regardless of the number of elements in the stack. **Input Format**: - You will not read any input from standard I/O. - Instead, implement the methods specified. **Output Format**: - You will not produce any output to standard I/O. - Ensure that all methods work as specified in a class structure. # Constraints: - Your solution must handle the given operations efficiently and should not modify existing stack methods directly. - `push`, `pop`, and `get_min` should all operate in `O(1)` time complexity. Here\'s the class signature you should extend: ```python class MinStack(LinkedListStack): def __init__(self): super().__init__() # additional attributes you may need def push(self, value): # your code here def pop(self): # your code here def get_min(self): # your code here ``` **Example Usage**: ```python min_stack = MinStack() min_stack.push(3) min_stack.push(5) print(min_stack.get_min()) # Output: 3 min_stack.push(2) min_stack.push(1) print(min_stack.get_min()) # Output: 1 min_stack.pop() print(min_stack.get_min()) # Output: 2 min_stack.pop() print(min_stack.peek()) # Output: 5 print(min_stack.get_min()) # Output: 3 ``` # Notes: - Ensure your implementation is robust, considering edge cases such as an empty stack. - Do not use any built-in Python libraries or functions for this challenge. Implement the functionality from scratch.","solution":"class Node: def __init__(self, value): self.value = value self.next = None class LinkedListStack: def __init__(self): self.top = None def is_empty(self): return self.top is None def push(self, value): new_node = Node(value) new_node.next = self.top self.top = new_node def pop(self): if self.is_empty(): raise IndexError(\\"Pop from empty stack\\") node = self.top self.top = self.top.next return node.value def peek(self): if self.is_empty(): raise IndexError(\\"Peek from empty stack\\") return self.top.value class MinStack(LinkedListStack): def __init__(self): super().__init__() self.min_stack = LinkedListStack() def push(self, value): super().push(value) if self.min_stack.is_empty() or value <= self.min_stack.peek(): self.min_stack.push(value) def pop(self): value = super().pop() if not self.min_stack.is_empty() and value == self.min_stack.peek(): self.min_stack.pop() return value def get_min(self): if self.min_stack.is_empty(): raise IndexError(\\"Get min from empty stack\\") return self.min_stack.peek()"},{"question":"You are given two large sparse vectors, potentially with millions of elements but only a small percentage of them being non-zero. To efficiently store these vectors and perform operations on them, a better data representation is required. Write a Python function `sparse_vector_dot_product(vector1, vector2)` that computes the dot product of these two sparse vectors using the index-value pair representation. # Detailed Requirements 1. **Function 1**: Convert a given dense vector (list of floats) to a sparse vector represented as a list of index-value pairs. ```python def vector_to_index_value_list(vector: List[float]) -> List[Tuple[int, float]]: ``` 2. **Function 2**: Compute the dot product of two sparse vectors. ```python def sparse_vector_dot_product(vector1: List[float], vector2: List[float]) -> float: ``` # Input/Output Formats 1. **Input**: - `vector1` and `vector2`: Lists of floats, representing the dense vectors which may contain up to 10^7 elements. 2. **Output**: - A float representing the dot product of the two vectors. # Constraints and Assumptions - You may assume the vectors are of the same length. - Vectors can have up to 10 million elements, out of which only a small fraction (less than 1%) are non-zero. # Example ```python # Example input vector1 = [1.0, 0.0, 0.0, 3.0, 0.0] vector2 = [0.0, 2.0, 0.0, 0.0, 1.0] # Conversion to sparse representation # vector1_sparse = [(0, 1.0), (3, 3.0)] # vector2_sparse = [(1, 2.0), (4, 1.0)] # Dot product calculation result = sparse_vector_dot_product(vector1, vector2) print(result) # Expected output: 0.0, since no indices match with non-zero values ``` # Additional Tests Ensure your solution handles the following cases: - Both vectors are completely zero. - Vectors with exactly one matching non-zero index. - Extremely large vectors with few non-zero elements.","solution":"from typing import List, Tuple def vector_to_index_value_list(vector: List[float]) -> List[Tuple[int, float]]: Converts a dense vector to a sparse vector represented as a list of index-value pairs. return [(i, value) for i, value in enumerate(vector) if value != 0.0] def sparse_vector_dot_product(vector1: List[float], vector2: List[float]) -> float: Computes the dot product of two sparse vectors. sparse_vector1 = vector_to_index_value_list(vector1) sparse_vector2 = vector_to_index_value_list(vector2) index_value_dict2 = dict(sparse_vector2) dot_product = 0.0 for idx, value in sparse_vector1: if idx in index_value_dict2: dot_product += value * index_value_dict2[idx] return dot_product"},{"question":"# Unique Binary Search Trees Calculation Problem Statement You are tasked with writing a function to determine the number of unique Binary Search Trees (BSTs) that can be constructed using `n` distinct nodes with values from 1 through `n`. In other words, you need to calculate the `Nth` Catalan number. Function Signature ```python def num_trees(n: int) -> int: ``` # Input - A single integer `n` (0 <= n <= 19), representing the number parameters from which BSTs need to be constructed. # Output - Return the number of unique BSTs that can be created using values from `1` to `n`. # Constraints - The input integer `n` will be in the range `0 <= n <= 19`. This constraint ensures that the solution does not run into performance issues. # Example ```python assert num_trees(3) == 5 assert num_trees(1) == 1 assert num_trees(4) == 14 ``` # Explanation: For `n = 3`, there are 5 unique BSTs: 1 3 3 2 1 / / / 3 2 1 1 3 2 / / 2 1 2 3 For `n = 1`, there is 1 BST: 1 For `n = 4`, total unique BSTs are calculated as 14. # Implementation Notes * The expected solution involves the use of dynamic programming to efficiently compute the result. * You should use a list `dp` where `dp[i]` stores the number of unique BSTs that can be created using `i` nodes. Initialization of base cases: * `dp[0] = 1` (empty tree) * `dp[1] = 1` (single node tree) * Use a nested loop structure to iteratively build up the solution for all values from `2` to `n`. Implement the provided function `num_trees(n: int) -> int` to solve this problem.","solution":"def num_trees(n: int) -> int: Calculate the number of unique BSTs that can be made with n distinct nodes. This is equivalent to the nth Catalan number. if n == 0 or n == 1: return 1 # Dynamic programming approach dp = [0] * (n + 1) dp[0] = 1 dp[1] = 1 for i in range(2, n + 1): for j in range(i): dp[i] += dp[j] * dp[i - j - 1] return dp[n]"},{"question":"# Pancake Sort Challenge As an aspiring programmer, you have encountered various sorting algorithms. Today, you will implement an interesting, lesser-known one called **Pancake Sort**. This is a sorting algorithm where you pick the maximum element and move it to its position by flipping (reversing) the subarray. Problem Statement Given an array `arr` of unsorted integers, your task is to implement the Pancake Sort algorithm to sort this array in non-decreasing order. Function Signature ```python def pancake_sort(arr: List[int]) -> List[int]: pass ``` Input * `arr`: A list of non-negative integers, where `0 <= len(arr) <= 1000` and `0 <= arr[i] <= 1000`. Output * Return a list of integers sorted in non-decreasing order. Constraints * The array might be empty or contain duplicate elements. * Optimize your solution to ensure it handles worst-case scenarios as efficiently as possible within the given constraints. Example Example 1: * Input: `arr = [3, 2, 4, 1]` * Output: `[1, 2, 3, 4]` Example 2: * Input: `arr = [1, 2, 3]` * Output: `[1, 2, 3]` Requirements Write a well-documented function that implements the Pancake Sort algorithm. Your solution will be evaluated based on correctness, clarity, and efficiency. Happy coding!","solution":"def flip(arr, k): Reverses the sub-array arr[0:k+1] left = 0 right = k while left < right: arr[left], arr[right] = arr[right], arr[left] left += 1 right -= 1 def find_max_index(arr, n): Finds the index of the maximum element in arr[0:n] max_index = 0 for i in range(1, n): if arr[i] > arr[max_index]: max_index = i return max_index def pancake_sort(arr): Sorts the array using the pancake sorting algorithm n = len(arr) for size in range(n, 1, -1): max_index = find_max_index(arr, size) if max_index != size - 1: flip(arr, max_index) flip(arr, size - 1) return arr"},{"question":"You are tasked with implementing a sorting algorithm for a list of integers using a different sorting strategy. Implement a function `exchange_sort(arr)` that takes an array of integers and returns a sorted array. # Function Signature ```python def exchange_sort(arr: List[int]) -> List[int]: ``` # Input - An unsorted list of integers `arr` with length `n` where ( 0 leq n leq 10^4 ). - Elements of the list are in the range ([-10^9, 10^9]). # Output - A list of integers sorted in non-decreasing order. # Example ```python assert exchange_sort([4, 2, 7, 1]) == [1, 2, 4, 7] assert exchange_sort([10, -1, 2, 5, 0]) == [-1, 0, 2, 5, 10] assert exchange_sort([5, 5, 5, 5]) == [5, 5, 5, 5] assert exchange_sort([]) == [] assert exchange_sort([1]) == [1] ``` # Constraints - You must implement the sorting using the Exchange Sort algorithm. - Your implementation must be of O(n^2) time complexity and O(1) space complexity. - Avoid using Python\'s built-in sorting functions. # Notes - Ensure your function correctly handles edge cases, such as empty lists and lists with a single element. - Consider scenarios where the list contains both very large and very small values, including negative integers. - Focus on getting the logic right as this function is expected to have inherent performance limitations due to the algorithm\'s nature. # Testing Your implementation will be tested against various cases including large lists to assess both correctness and efficiency within the given constraints.","solution":"def exchange_sort(arr): Sort the input list using Exchange Sort algorithm. Exchange Sort is implemented by repeatedly comparing and swapping adjacent elements if they are in wrong order. Args: arr (List[int]): Unsorted list of integers. Returns: List[int]: Sorted list in non-decreasing order. n = len(arr) for i in range(n): for j in range(i + 1, n): if arr[i] > arr[j]: arr[i], arr[j] = arr[j], arr[i] return arr"},{"question":"# Insertion Sort Challenge Context You are working on implementing various sorting algorithms for an educational task to understand their differences. One of the algorithms you need to implement is Insertion Sort. Task Implement a function `insertion_sort_with_steps` that sorts an array of integers using the insertion sort algorithm. The function should also return a list of strings representing the state of the array after each insertion. Function Signature ```python def insertion_sort_with_steps(arr: List[int]) -> List[str]: pass ``` Input - An array of integers `arr` where `1 <= len(arr) <= 1000` and `-10000 <= arr[i] <= 10000`. Output - A list of strings where each string represents the state of the array after each insertion. Each state should be represented as space-separated integers. Example ```python insertion_sort_with_steps([4, 3, 2, 10, 12, 1, 5, 6]) ``` Expected Output ```python [ \\"4 3 2 10 12 1 5 6\\", \\"3 4 2 10 12 1 5 6\\", \\"2 3 4 10 12 1 5 6\\", \\"2 3 4 10 12 1 5 6\\", \\"2 3 4 10 12 1 5 6\\", \\"1 2 3 4 10 12 5 6\\", \\"1 2 3 4 5 10 12 6\\", \\"1 2 3 4 5 6 10 12\\" ] ``` Constraints - Your implementation should be efficient and work well with the provided constraints. - You may not use built-in sort functions. Notes - Ensure to handle edge cases, such as arrays with a single element or those already sorted. - Focus on the clarity and efficiency of your code.","solution":"from typing import List def insertion_sort_with_steps(arr: List[int]) -> List[str]: steps = [] # Extend list to add initial state steps.append(\' \'.join(map(str, arr))) for i in range(1, len(arr)): key = arr[i] j = i - 1 while j >= 0 and key < arr[j]: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key # Append current state of array to steps steps.append(\' \'.join(map(str, arr))) return steps"},{"question":"# Question: As a programmer, your task is to enhance the Interpolation Search algorithm to address some of its limitations while maintaining its performance advantages. Requirements: 1. Improve the function to handle and return appropriate results for all edge cases, specifically when: - The array is empty. - The array has all identical elements. - The search key is not found. - The search key is out of the range of values of the array. 2. Include additional functionality to handle non-uniform distributions by falling back to binary search if necessary. Problem Statement: Implement an enhanced version of the Interpolation Search algorithm in Python that addresses the edge cases mentioned above and includes a fallback mechanism to binary search for non-uniform distributions. The function should adhere to the following specification: ```python from typing import List def enhanced_interpolation_search(array: List[int], search_key: int) -> int: :param array: The array to be searched. :param search_key: The key to be searched in the array. :returns: Index of search_key in array if found, else -1. Enhanced Requirements: - Handles empty arrays and returns -1. - Handles arrays with all identical elements without errors. - Handles cases where search_key is not present in the array or is outside the range. - Falls back to binary search if the distribution is significantly non-uniform. Examples: >>> enhanced_interpolation_search([], 10) -1 >>> enhanced_interpolation_search([10, 10, 10, 10], 10) 0 >>> enhanced_interpolation_search([-25, -12, -1, 10, 12, 15, 20, 41, 55], -1) 2 >>> enhanced_interpolation_search([5, 10, 12, 14, 17, 20, 21], 55) -1 >>> enhanced_interpolation_search([5, 10, 12, 14, 17, 20, 21], 12) 2 if __name__ == \\"__main__\\": import doctest doctest.testmod() ``` Constraints: - The `array` can contain integers in the range ([-10^9, 10^9]). - Array length can be up to (10^6). - You have to provide the implementation using enhanced interpolation search with a fallback mechanism to binary search for non-uniform distributions.","solution":"from typing import List def interpolation_search(array: List[int], search_key: int) -> int: low = 0 high = len(array) - 1 while low <= high and search_key >= array[low] and search_key <= array[high]: if low == high: if array[low] == search_key: return low return -1 position = low + ((high - low) // (array[high] - array[low] + 1) * (search_key - array[low])) if array[position] == search_key: return position if array[position] < search_key: low = position + 1 else: high = position - 1 return -1 def binary_search(array: List[int], search_key: int, low: int, high: int) -> int: while low <= high: mid = low + (high - low) // 2 if array[mid] == search_key: return mid elif array[mid] < search_key: low = mid + 1 else: high = mid - 1 return -1 def enhanced_interpolation_search(array: List[int], search_key: int) -> int: if not array: return -1 if array[0] == array[-1]: return 0 if array[0] == search_key else -1 num_elements = len(array) # Check for non-uniform distribution and fall back to binary search if array[-1] - array[0] > 2 * (num_elements - 1): return binary_search(array, search_key, 0, num_elements - 1) return interpolation_search(array, search_key)"},{"question":"# Ternary Search in Unimodal Array Unimodal arrays are special arrays that contain a single peak, i.e., a sub-sequence strictly increases to the peak and a second sub-sequence strictly decreases from the peak. # Problem Given a unimodal array sorted in ascending order till a peak value followed by descending order till the end, and an integer `k`, implement a function `find_in_unimodal_array` that uses ternary search to find and return the index of `k` in the array. If `k` is not found, the function should return `-1`. # Function Signature ```python def find_in_unimodal_array(arr: List[int], k: int) -> int: pass ``` # Example ```python # Example 1 arr = [1, 3, 8, 12, 15, 14, 10, 6, 2] k = 15 print(find_in_unimodal_array(arr, k)) # Output: 4 # Example 2 arr = [1, 3, 8, 12, 15, 14, 10, 6, 2] k = 5 print(find_in_unimodal_array(arr, k)) # Output: -1 ``` # Constraints * `1 <= len(arr) <= 10^5` * The array `arr` is unimodal. * Elements in the array are distinct. * `-10^9 <= arr[i], k <= 10^9` Your solution should effectively use ternary search principles to leverage the unimodal property of the array, ensuring optimal performance. # Notes 1. The function should validate and handle edge cases where the array could be minimal in length. 2. Think about the various parts of the unimodal array separately when implementing ternary search.","solution":"from typing import List def find_in_unimodal_array(arr: List[int], k: int) -> int: # Find the peak element index first def find_peak(arr): left, right = 0, len(arr) - 1 while left < right: mid = (left + right) // 2 if arr[mid] < arr[mid + 1]: left = mid + 1 else: right = mid return left # Binary search in an increasing part of the array def binary_search_increasing(arr, k, left, right): while left <= right: mid = (left + right) // 2 if arr[mid] == k: return mid elif arr[mid] < k: left = mid + 1 else: right = mid - 1 return -1 # Binary search in a decreasing part of the array def binary_search_decreasing(arr, k, left, right): while left <= right: mid = (left + right) // 2 if arr[mid] == k: return mid elif arr[mid] > k: left = mid + 1 else: right = mid - 1 return -1 peak = find_peak(arr) # Try to find k in the increasing part index = binary_search_increasing(arr, k, 0, peak) if index != -1: return index # Try to find k in the decreasing part return binary_search_decreasing(arr, k, peak + 1, len(arr) - 1)"},{"question":"# Graph Traversal Assessment You are provided with a set of functions that traverse graphs in various ways to find paths between nodes. Your task is to implement a function that leverages these traversal methods to solve a complex pathfinding problem. Scenario Imagine a university campus graph, where buildings are represented as nodes, and pathways between them are edges. The graph is unweighted and does not contain any cycles. You need to help a new student find not just any path, but the path that visits the maximum number of buildings exactly once, ensuring they explore the campus as much as possible. Objective Write a function `find_max_exploration_path(graph, start)` that returns a path starting from a given building (node) that visits the maximum number of unique buildings exactly once and ends when it cannot continue further. Input - `graph`: A dictionary representing the graph, where keys are building names (nodes) and values are lists of adjacent buildings. - `start`: A string representing the starting building name. Output - A list of strings representing the path with the maximum number of unique buildings visited exactly once, starting from the `start` building. Constraints - The graph is connected and unweighted. - The graph does not contain any cycles. - Building names and paths between them are case-insensitive. Example ```python graph = { \'A\': [\'B\', \'C\', \'D\'], \'B\': [\'A\', \'E\'], \'C\': [\'A\'], \'D\': [\'A\'], \'E\': [\'B\'] } start = \'A\' result = find_max_exploration_path(graph, start) print(result) # Example output: [\'A\', \'B\', \'E\'] ``` Requirements - Your implementation should be efficient in terms of time and space. - Handle the scenario where no path is possible. Hints - Consider modifying the existing traversal methods to track visited nodes and find the maximum exploration path.","solution":"def find_max_exploration_path(graph, start): Returns the path starting from the given building that visits the maximum number of unique buildings exactly once. def dfs(building, current_path, visited): nonlocal max_path visited.add(building) current_path.append(building) # If the current path is longer than the max_path, update max_path if len(current_path) > len(max_path): max_path = list(current_path) for neighbor in graph.get(building, []): if neighbor not in visited: dfs(neighbor, current_path, visited) # Backtrack visited.remove(building) current_path.pop() max_path = [] dfs(start, [], set()) return max_path"},{"question":"# Problem: Matrix Chain Multiplication Optimization Matrix Chain Multiplication is a classic problem in Dynamic Programming where the objective is to find the most efficient way to multiply a given sequence of matrices. The task is only to determine the order of multiplications that would minimize the cost, not to perform the multiplication itself. Problem Statement Given a sequence of matrices, where the `i-th` matrix has dimensions `p[i-1] x p[i]`, your task is to write a function `matrix_chain_multiplication` that computes the minimum number of scalar multiplications needed to compute the matrix product. You should also determine the optimal way to parenthesize the sequence of matrices. Function Signature ```python def matrix_chain_multiplication(p: List[int]) -> Tuple[int, List[List[int]]]: pass ``` Input - `p`: A list of integers where `p[i]` represents the dimension of the matrix at position `i`. Output - Return a tuple where the first element is the minimal number of scalar multiplications needed, and the second element is a 2D list representing the optimal parentheses split points. Constraints - The list `p` will have a size from 2 to 100 inclusive. - Dimensions will be positive integers, less than 500. Example ```python p = [30, 35, 15, 5, 10, 20, 25] result = matrix_chain_multiplication(p) print(result[0]) # Expected output: 15125 # The result would return the minimal cost and the optimal parenthesization table. ``` Notes - Use Dynamic Programming to solve this problem. - You do not have to print the parenthesization order; just return the optimal split points. - Focus on efficient indexing and handling all edge cases related to array bounds. This problem will test your understanding of dynamic programming, matrix operations, and efficient algorithm design. Make sure your solution is optimal both in terms of time and space complexity.","solution":"from typing import List, Tuple def matrix_chain_multiplication(p: List[int]) -> Tuple[int, List[List[int]]]: n = len(p) - 1 # Initialize matrices for memoization m = [[0] * (n + 1) for _ in range(n + 1)] s = [[0] * (n + 1) for _ in range(n + 1)] for l in range(2, n + 1): # l is the chain length for i in range(1, n - l + 2): j = i + l - 1 m[i][j] = float(\'inf\') for k in range(i, j): q = m[i][k] + m[k + 1][j] + p[i - 1] * p[k] * p[j] if q < m[i][j]: m[i][j] = q s[i][j] = k return m[1][n], s"},{"question":"Implement an Efficient Sorted Insert You are tasked with writing a function `sorted_insert` that takes a sorted list and a value, and returns a new list with the value inserted at the correct position to maintain the sorted order. Use the `search_insert` helper function provided. Function Signature ```python def sorted_insert(array: List[int], val: int) -> List[int]: ``` Input * A sorted list of integers, `array` (0 ≤ len(array) ≤ 10^4). * An integer, `val`. Output * A new list of integers with `val` inserted in the correct position. Constraints * The function should maintain the sorting order of the list. * The function must consider edge cases, such as inserting into an empty list. * Aim for an efficient solution utilizing the provided `search_insert` method. Examples ```python sorted_insert([1, 3, 5, 6], 5) -> [1, 3, 5, 5, 6] sorted_insert([1, 3, 5, 6], 2) -> [1, 2, 3, 5, 6] sorted_insert([1, 3, 5, 6], 7) -> [1, 3, 5, 6, 7] sorted_insert([1, 3, 5, 6], 0) -> [0, 1, 3, 5, 6] sorted_insert([], 5) -> [5] ```","solution":"from typing import List def search_insert(array: List[int], val: int) -> int: Given a sorted array and a value, this function returns the index where val should be inserted to maintain the sort order. left, right = 0, len(array) while left < right: mid = (left + right) // 2 if array[mid] < val: left = mid + 1 else: right = mid return left def sorted_insert(array: List[int], val: int) -> List[int]: Insert val into the sorted array while maintaining the sorted order. index = search_insert(array, val) return array[:index] + [val] + array[index:]"},{"question":"**Scenario**: As a software engineer, you are tasked with developing a feature in a text editor that suggests words based on their similarity to a given word. To achieve this, you need to compute the \\"edit distance\\" or \\"Levenshtein distance\\" between words, which quantifies how dissimilar two words are by counting the minimum number of operations required to transform one word into another. **Objective**: Implement a function that calculates the edit distance between two given strings using dynamic programming. **Function Signature**: ```python def edit_distance(word_a: str, word_b: str) -> int: Calculates the edit distance between two words Args: word_a (str): The first word. word_b (str): The second word. Returns: int: The edit distance between the two words. pass ``` **Input and Output**: * **Input**: - `word_a`: A string of length ( m ) (1 <= ( m ) <= 1000) - `word_b`: A string of length ( n ) (1 <= ( n ) <= 1000) * **Output**: - An integer denoting the edit distance between `word_a` and `word_b`. **Constraints**: * The input strings will only consist of lowercase English letters. **Example**: ```python # Example 1: print(edit_distance(\\"kitten\\", \\"sitting\\")) # Output: 3 # Example 2: print(edit_distance(\\"food\\", \\"money\\")) # Output: 4 # Example 3: print(edit_distance(\\"intention\\", \\"execution\\")) # Output: 5 ``` **Explanation**: * In the first example, the edit distance between \\"kitten\\" and \\"sitting\\" is 3: - kitten -> sitten (substitution of \\"k\\" with \\"s\\") - sitten -> sittin (substitution of \\"e\\" with \\"i\\") - sittin -> sitting (insertion of \\"g\\") * In the second example, the edit distance between \\"food\\" and \\"money\\" is 4 as detailed in the provided code snippet. **Guidelines**: * Implement the function `edit_distance` using dynamic programming to efficiently compute the minimum number of operations. * Consider edge cases such as when one or both input strings are empty. * Optimize for time and space wherever possible.","solution":"def edit_distance(word_a: str, word_b: str) -> int: Calculates the edit distance between two words Args: word_a (str): The first word. word_b (str): The second word. Returns: int: The edit distance between the two words. m = len(word_a) n = len(word_b) # Create a DP table to store edit distances for substrings dp = [[0] * (n + 1) for _ in range(m + 1)] # Initialize the DP table for the base cases for i in range(m + 1): dp[i][0] = i for j in range(n + 1): dp[0][j] = j # Fill the DP table for i in range(1, m + 1): for j in range(1, n + 1): if word_a[i - 1] == word_b[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = min( dp[i - 1][j] + 1, # Deletion dp[i][j - 1] + 1, # Insertion dp[i - 1][j - 1] + 1 # Substitution ) return dp[m][n]"},{"question":"# Question: Counting Staircase Climbing Ways You are given the task of implementing a function to count the number of distinct ways to climb a staircase of a given number of steps. Each time you can either climb 1 or 2 steps. Requirements: * **Function Name**: `count_ways_to_climb` * **Input**: An integer `n` (1 ≤ n ≤ 10^5), representing the number of steps to reach the top. * **Output**: An integer representing the number of distinct ways to climb to the top. Constraints: * Optimize your solution to work in both time and space efficiently. * Avoid using large arrays to manage intermediate values if possible. Example: *Input*: `n = 4` *Output*: `5` *(There are 5 ways to climb to the top: [1,1,1,1], [1,1,2], [1,2,1], [2,1,1], [2,2])* Hint: - Think about how the Fibonacci sequence relates to this problem. Testing: Make sure to test your function with edge cases such as the smallest possible staircase, and large values near the constraint limits. Implement the function with the following signature: ```python def count_ways_to_climb(n: int) -> int: # your code here ```","solution":"def count_ways_to_climb(n: int) -> int: Returns the number of distinct ways to climb a staircase with n steps, where each time you can either climb 1 or 2 steps. if n == 1: return 1 prev2, prev1 = 1, 1 for i in range(2, n+1): current = prev1 + prev2 prev2, prev1 = prev1, current return prev1"},{"question":"Enhanced Anagram Check **Scenario**: You are given two strings, and you need to determine if one is an anagram of the other. However, the strings may include any printable ASCII characters, and the comparison should be case-insensitive. **Task**: Implement a function `is_anagram(s1: str, s2: str) -> bool` that: * Receives two strings `s1` and `s2`. * Returns `True` if `s1` and `s2` are anagrams after considering case insensitivity and ignoring non-alphabet characters. * Returns `False` otherwise. **Function Signature**: ```python def is_anagram(s1: str, s2: str) -> bool: pass ``` **Input/Output**: * **Input**: Two strings `s1` and `s2`. * **Output**: A boolean value indicating if the strings are anagrams. **Constraints**: * The function should ignore non-alphabet characters. * The comparison should be case-insensitive. * The function should handle all printable ASCII characters. **Examples**: ```python print(is_anagram(\\"Dormitory\\", \\"Dirty room!!\\")) # True print(is_anagram(\\"The eyes\\", \\"They see\\")) # True print(is_anagram(\\"Hello, World!\\", \\"world helo\\")) # False ``` **Performance Requirements**: Ensure the implementation is efficient in terms of both time and space complexity.","solution":"def is_anagram(s1: str, s2: str) -> bool: import re from collections import Counter # Filter only alphabetic characters and convert to lowercase s1_filtered = re.sub(r\'[^a-zA-Z]\', \'\', s1).lower() s2_filtered = re.sub(r\'[^a-zA-Z]\', \'\', s2).lower() # Compare counts of each character return Counter(s1_filtered) == Counter(s2_filtered)"},{"question":"# Question: Context: You\'re working for a software company where you are managing a version control system. The company needs an algorithm to track the length of the longest increasing subsequence in their version history data to optimize and predict updates more efficiently. Task: Write a function that takes an unsorted list of version numbers and returns the length of the longest increasing subsequence. Requirements: * Implement both the simple dynamic programming approach and the optimized segment tree approach. * Your function should be able to handle the following input and output scenarios: Input: * `sequence` (List[int]): A list of integers where `1 <= sequence.length <= 10^5`. Output: * `int`: The length of the longest increasing subsequence. Constraints: * The input list may have any integer values, negative or positive. * Aim for O(n^2) time complexity for the simple DP approach and O(n log n) for the segment tree approach to handle larger datasets efficiently. Examples: ```python assert longest_increasing_subsequence([10,9,2,5,3,7,101,18]) == 4 assert longest_increasing_subsequence([0,8,4,12,2]) == 3 assert longest_increasing_subsequence([3,10,2,1,20]) == 3 assert longest_increasing_subsequence([-1,3,4,5,2,2,2,2]) == 4 assert longest_increasing_subsequence_optimized([10,9,2,5,3,7,101,18]) == 4 assert longest_increasing_subsequence_optimized([0,8,4,12,2]) == 3 assert longest_increasing_subsequence_optimized([3,10,2,1,20]) == 3 assert longest_increasing_subsequence_optimized([-1,3,4,5,2,2,2,2]) == 4 ``` Consider potential edge cases and handle them accordingly. Optimize your implementation for both time and space efficiency.","solution":"def longest_increasing_subsequence(sequence): Returns the length of the longest increasing subsequence using Dynamic Programming. if not sequence: return 0 n = len(sequence) dp = [1] * n for i in range(1, n): for j in range(i): if sequence[i] > sequence[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp) import bisect def longest_increasing_subsequence_optimized(sequence): Returns the length of the longest increasing subsequence using an optimized approach. if not sequence: return 0 sub = [] for x in sequence: if not sub or sub[-1] < x: sub.append(x) else: # Find the first element in sub which is greater than or equal to x idx = bisect.bisect_left(sub, x) sub[idx] = x return len(sub)"},{"question":"# Problem: Next Higher Permutation Problem Statement: You are given a non-negative integer. Your task is to find the next higher permutation of its digits using an algorithm that computes the next lexicographical permutation. If no such permutation exists (i.e., the integer is in descending order), return -1. Your solution should handle edge cases and be efficient in time and space. Implement the function `next_higher_permutation(number: int) -> int` that performs the above task. Input: - A single integer `number` (0 <= number <= 10^9). Output: - The next higher permutation of the digits in `number`, or -1 if no such permutation exists. Constraints: - Handle single-digit numbers. - Handle numbers already in maximum possible arrangement. - Solve the problem with linear time complexity. Examples: 1. `next_higher_permutation(38276)` should return `38627` 2. `next_higher_permutation(54321)` should return `-1` 3. `next_higher_permutation(12345)` should return `12354` 4. `next_higher_permutation(11111)` should return `-1` 5. `next_higher_permutation(2018)` should return `2081` Notes: - Ensure your solution is efficient and handles all edge cases. - Assume that input is always valid.","solution":"def next_higher_permutation(number: int) -> int: Returns the next higher permutation of the digits of the given number. If no such permutation exists, returns -1. digits = list(map(int, str(number))) # Step 1: Find the rightmost digit that is smaller than the digit next to it. i = len(digits) - 2 while i >= 0 and digits[i] >= digits[i + 1]: i -= 1 # If no such digit is found, return -1 as we are at the highest permutation if i == -1: return -1 # Step 2: Find the smallest digit on the right side of (i)\'th digit which is larger than digits[i] j = len(digits) - 1 while digits[j] <= digits[i]: j -= 1 # Step 3: Swap the digits[i] and digits[j] digits[i], digits[j] = digits[j], digits[i] # Step 4: Reverse the digits after the (i)\'th position digits = digits[:i + 1] + digits[i + 1:][::-1] # Convert list of digits back to integer return int(\'\'.join(map(str, digits)))"},{"question":"# Question: Rotated String Checker Given two strings, write a function `is_rotated_version(s1: str, s2: str) -> bool` that determines if `s2` is a rotated version of `s1`. **Function Signature**: ```python def is_rotated_version(s1: str, s2: str) -> bool: pass ``` # Input - `s1`: A string (1 ≤ |s1| ≤ 10^5) - `s2`: A string (1 ≤ |s2| ≤ 10^5) # Output - Returns `True` if `s2` is a rotated version of `s1`; otherwise, `False`. # Constraints - The function must run in O(N) time complexity. # Example ```python assert is_rotated_version(\\"hello\\", \\"llohe\\") == True assert is_rotated_version(\\"hello\\", \\"helol\\") == False assert is_rotated_version(\\"abcde\\", \\"cdeab\\") == True assert is_rotated_version(\\"abcde\\", \\"abced\\") == False assert is_rotated_version(\\"\\", \\"\\") == True assert is_rotated_version(\\"a\\", \\"a\\") == True assert is_rotated_version(\\"a\\", \\"\\") == False ``` # Explanation 1. The function must first check if the lengths of the two strings are the same. If not, it should directly return `False`. 2. If the lengths are the same, concatenate `s1` with itself, and check if `s2` is a substring of this concatenated string. 3. This solution ensures linear time complexity by leveraging Python\'s substring operation. **Note**: Ensure your solution is optimized for large strings and handles all edge cases effectively.","solution":"def is_rotated_version(s1: str, s2: str) -> bool: Determines if s2 is a rotated version of s1. Args: s1 (str): The original string. s2 (str): The string to check if it\'s a rotated version of s1. Returns: bool: True if s2 is a rotated version of s1, otherwise False. if len(s1) != len(s2): return False concatenated = s1 + s1 return s2 in concatenated"},{"question":"# Frequency Limitation in List Implement a function `frequency_limiter` that processes a given list `lst` and ensures that no element appears more than `N` times, maintaining the original order of elements. You should use a time-efficient approach, employing hash tables to keep track of the element counts. Function Signature ```python def frequency_limiter(lst: list, N: int) -> list: ``` Input * `lst`: A list of integers (e.g., [1, 2, 3, 1, 2, 1, 2, 3]) * `N`: An integer specifying the maximum allowed frequency for any element (e.g., 2) Output * Returns a new list with elements limited to appear at most `N` times. Constraints * 1 <= N <= len(lst) <= 10^6 * Elements in `lst` can be any integers. Performance Requirements * Your implementation should run in O(n) time complexity where `n` is the length of the input list. * A space complexity should be kept at O(n). Example ```python # Example 1 input_list = [1, 2, 3, 1, 2, 1, 2, 3] N = 2 output_list = frequency_limiter(input_list, N) # Expected Output: [1, 2, 3, 1, 2, 3] # Example 2 input_list = [4, 5, 5, 4, 5, 4, 4] N = 1 output_list = frequency_limiter(input_list, N) # Expected Output: [4, 5] # Example 3 input_list = [7, 7, 7, 7, 7] N = 3 output_list = frequency_limiter(input_list, N) # Expected Output: [7, 7, 7] ```","solution":"def frequency_limiter(lst: list, N: int) -> list: Returns a new list with elements limited to appear at most `N` times. Maintains the original order of elements in the input list. frequency_count = {} result = [] for elem in lst: if frequency_count.get(elem, 0) < N: frequency_count[elem] = frequency_count.get(elem, 0) + 1 result.append(elem) return result"},{"question":"**Objective**: Implement the Cycle Sort algorithm. Write a function named `cycle_sort` that sorts an array of integers using the Cycle Sort algorithm. The function should take a list of integers as input and return a sorted list. Function Signature ```python def cycle_sort(arr: List[int]) -> List[int]: ``` Input - `arr`: A list of integers, e.g., [4, 3, 2, 1]. Output - A sorted list of integers, e.g., [1, 2, 3, 4]. Constraints - The function should sort the input list in place, i.e., modifying the original array. - The length of the array will be between 0 and 10^5. Example ```python assert cycle_sort([3, 2, 1, 4]) == [1, 2, 3, 4] assert cycle_sort([1, 1, 1, 1]) == [1, 1, 1, 1] assert cycle_sort([4, 3, 2, 5, 1]) == [1, 2, 3, 4, 5] assert cycle_sort([]) == [] assert cycle_sort([6, -1, 3, 7, 1]) == [-1, 1, 3, 6, 7] ``` Considerations - Handle the potential edge cases: arrays with duplicate values, already sorted arrays, empty arrays, and arrays with negative numbers. - Optimize the solution to handle larger inputs efficiently. Performance Requirements - Minimize the number of memory writes. - Ensure the function runs within a reasonable time frame for large arrays (up to 10^5 elements).","solution":"from typing import List def cycle_sort(arr: List[int]) -> List[int]: Sorts an array of integers using the Cycle Sort algorithm. In-place sorting with minimal writes. Args: - arr: List[int] : List of integers to sort Returns: - List[int] : Sorted list of integers (the same list as the input) writes = 0 # Loop through the array to calculate cycles and perform necessary swaps for cycle_start in range(0, len(arr) - 1): item = arr[cycle_start] # Find the position where we put the element of the cycle pos = cycle_start for i in range(cycle_start + 1, len(arr)): if arr[i] < item: pos += 1 # If the item is already in the correct position if pos == cycle_start: continue # Skip duplicate elements while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] writes += 1 # Rotate the rest of the cycle while pos != cycle_start: pos = cycle_start for i in range(cycle_start + 1, len(arr)): if arr[i] < item: pos += 1 while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] writes += 1 return arr"},{"question":"In an effort to enhance your algorithmic skills and understanding of string search, you\'ll work on a function that efficiently finds the occurrence of a substring within a larger string. Task: Write a Python function `find_substring(haystack: str, needle: str) -> int` that finds the index of the first occurrence of the substring `needle` in the string `haystack`. If `needle` is not present in `haystack`, return -1. Input: - `haystack` (String): The string in which to search. - `needle` (String): The substring to find. Output: - (Integer): The index of the first occurrence of `needle` in `haystack`, or -1 if `needle` is not found. Constraints: - The length of both strings will be at most `10^5`. - The solution should be optimized for large values of input sizes. Examples: ```python assert find_substring(\\"hello\\", \\"ll\\") == 2 assert find_substring(\\"aaaaa\\", \\"bba\\") == -1 assert find_substring(\\"abc\\", \\"a\\") == 0 assert find_substring(\\"mississippi\\", \\"issi\\") == 1 assert find_substring(\\"abcdef\\", \\"\\") == 0 assert find_substring(\\"abc\\", \\"d\\") == -1 ``` Guidelines: 1. Pay attention to edge cases mentioned in the analysis section. 2. Strive for a time-efficient solution beyond the naive O((m-n+1) * n) approach if possible. 3. Ensure the function handles both empty strings and large inputs gracefully. 4. Optimize for clarity and maintainability in your code.","solution":"def find_substring(haystack: str, needle: str) -> int: Finds the index of the first occurrence of the substring \'needle\' in the string \'haystack\'. Returns -1 if \'needle\' is not found. # Edge case: if the needle is an empty string, return 0 if needle == \\"\\": return 0 # Loop through the haystack considering the length of the needle for i in range(len(haystack) - len(needle) + 1): # Check if the substring matches if haystack[i:i+len(needle)] == needle: return i # If the loop completes without finding the needle, return -1 return -1"},{"question":"# Problem: Unique Character String Write a function `unique_char_string` that takes a string as input and returns a new string where every character appears only once, retaining its original order of appearance. The function should efficiently handle the process, considering both time and space complexities. Function Signature ```python def unique_char_string(input_string: str) -> str: ``` Input - `input_string` (str): A string of length (0 leq len(input_string) leq 10^6), consisting of ASCII characters. Output - A string where every character appears only once, in the order they first appeared in the input string. Constraints - The function must run in (O(n)) time complexity where (n) is the length of `input_string`. - The function should handle both uppercase and lowercase characters distinctly (i.e., it is case-sensitive). Example ```python assert unique_char_string(\\"aabbcc\\") == \\"abc\\" assert unique_char_string(\\"abcabc\\") == \\"abc\\" assert unique_char_string(\\"xyz\\") == \\"xyz\\" assert unique_char_string(\\"\\") == \\"\\" ``` Additional Notes - Consider efficiency in terms of both time and space. - Python string concatenation inside a loop can be slow; consider alternatives if necessary.","solution":"def unique_char_string(input_string: str) -> str: Returns a new string where every character appears only once, retaining its original order of appearance in the input string. seen = set() result = [] for char in input_string: if char not in seen: seen.add(char) result.append(char) return \'\'.join(result)"},{"question":"# Gnome Sort Implementation and Analysis **Scenario**: You are tasked to help a software development team understand the behavior and performance of a simple sorting algorithm called Gnome Sort. Your goal is to implement Gnome Sort and analyze its performance across various input scenarios to help the team decide when it can be a suitable sorting algorithm. **Task**: 1. Implement Gnome Sort in Python. 2. Analyze its performance on input arrays with different characteristics. # Function Specification **Function Name**: `gnome_sort` **Input**: - `arr` (List[int]): A list of integers to be sorted. **Output**: - Returns the sorted list of integers. # Constraints: - You should handle empty arrays, arrays of size 1, and arrays with duplicate elements. - Analyze and report the performance on different types of arrays: 1. Randomly ordered array. 2. Already sorted array. 3. Reverse sorted array. 4. Array with all elements identical. # Requirements: 1. Implement the Gnome Sort algorithm. 2. Write a script to generate and test the algorithm on the above types of arrays. 3. Summarize the time taken for each type of array. 4. Discuss the results and provide recommendations about when Gnome Sort might be suitable based on your findings. Write your implementation below, including your script and a brief analysis of your observations. # Implementation ```python def gnome_sort(arr): n = len(arr) index = 0 while index < n: if index == 0 or arr[index] >= arr[index-1]: index = index + 1 else: arr[index], arr[index-1] = arr[index-1], arr[index] index = index - 1 return arr # Now implement the test script and run the performance analysis import time import random def test_gnome_sort(): # Test cases test_cases = { \\"Empty array\\": [], \\"Array of one element\\": [1], \\"All elements same\\": [5] * 10, \\"Sorted array\\": list(range(1, 11)), \\"Reverse sorted array\\": list(range(10, 0, -1)), \\"Randomly ordered array\\": random.sample(range(1, 11), 10) } for desc, arr in test_cases.items(): start_time = time.perf_counter() sorted_arr = gnome_sort(arr.copy()) elapsed_time = time.perf_counter() - start_time print(f\\"{desc}: {sorted_arr} (Time: {elapsed_time:.6f}s)\\") # Run the tests test_gnome_sort() ``` In your analysis, highlight key points from your findings based on the timing and performance of Gnome Sort on different types of arrays. Discuss the practical scenarios where this sorting algorithm is beneficial.","solution":"def gnome_sort(arr): Sorts a list using the Gnome Sort algorithm. Args: arr (List[int]): A list of integers to be sorted. Returns: List[int]: The sorted list of integers. n = len(arr) index = 0 while index < n: if index == 0 or arr[index] >= arr[index - 1]: index += 1 else: arr[index], arr[index - 1] = arr[index - 1], arr[index] index -= 1 return arr"},{"question":"# Scenario You are tasked to implement a more efficient word search tool for an autocomplete system. This system uses a special dictionary where words can be dynamically added, and searches can be performed using literal characters and the \'.\' character as a wildcard matching any single character. # Task Implement a class `AdvancedWordDictionary` with the following methods: 1. `add_word(word)` - Adds a word into the data structure. 2. `search(word)` - Searches a word in the data structure that can contain \'.\' as a wildcard. # Expected Input and Output Formats: - `add_word(word: str) -> None` - `search(word: str) -> bool` # Constraints 1. Words consist of lowercase English letters (a-z). 2. The length of a word will not exceed 100. 3. Add and search operations will be called multiple times (up to 10^4). # Additional Notes: - Make sure to handle edge cases such as searching for words with only \'wildcards\' or the search word being not found. - Optimize for both space and time efficiency considering the given constraints. # Example: ```python # Initialize the dictionary word_dict = AdvancedWordDictionary() # Add words word_dict.add_word(\\"bad\\") word_dict.add_word(\\"dad\\") word_dict.add_word(\\"mad\\") # Search words print(word_dict.search(\\"pad\\")) # Output: False print(word_dict.search(\\"bad\\")) # Output: True print(word_dict.search(\\".ad\\")) # Output: True print(word_dict.search(\\"b..\\")) # Output: True ``` You are expected to implement the class `AdvancedWordDictionary` to handle the scenarios effectively.","solution":"class AdvancedWordDictionary: def __init__(self): self.words = [] def add_word(self, word): self.words.append(word) def search(self, word): def match(word, candidate): if len(word) != len(candidate): return False return all(w == c or w == \'.\' for w, c in zip(word, candidate)) return any(match(word, candidate) for candidate in self.words)"},{"question":"Objective You are to write a function that filters elements of a list to only include values within a specified range. Scenario Imagine you are creating a dashboard for an environmental monitoring system. You need to filter temperature readings to only show those within a specific range before displaying them. This allows users to focus only on the most relevant data. Task Implement a function `filter_range(data, min_val=None, max_val=None)` that returns a new list containing only the values from `data` which are between `min_val` and `max_val` inclusive. If `min_val` is `None`, treat it as the smallest value in `data`. If `max_val` is `None`, treat it as the largest value in `data`. Function Signature ```python def filter_range(data: list, min_val: float = None, max_val: float = None) -> list: pass ``` Input - `data` (list): A list of numerical values (integers or floats). - `min_val` (float): The minimum value of the range (inclusive). - `max_val` (float): The maximum value of the range (inclusive). Output - (list): A new list containing only the values from `data` that are between `min_val` and `max_val`. Constraints * The length of `data` will be between `0` and `10^6`. * The values in `data` will be between `-10^9` and `10^9`. Examples 1. `filter_range([34, 23, 15, 65, 78, 21], min_val=20, max_val=50)` should return `[34, 23, 21]` 2. `filter_range([10, 5, 3, 9], min_val=None, max_val=7)` should return `[5, 3]` 3. `filter_range([], min_val=5, max_val=10)` should return `[]` 4. `filter_range([7, 6, 10, 12], min_val=8)` should return `[10, 12]` 5. `filter_range([1, 2, 3], max_val=2)` should return `[1, 2]` Requirements Your implementation should be efficient with a time complexity of O(n) and handle edge cases effectively.","solution":"def filter_range(data, min_val=None, max_val=None): Filters elements of a list to only include values within a specified range. Parameters: data (list): A list of numerical values (integers or floats). min_val (float): The minimum value of the range (inclusive). max_val (float): The maximum value of the range (inclusive). Returns: list: A new list containing only the values from data that are between min_val and max_val. if not data: return [] if min_val is None: min_val = min(data) if max_val is None: max_val = max(data) return [x for x in data if min_val <= x <= max_val]"},{"question":"# Context and Objective You are tasked with extending an existing probabilistic algorithm - the Rabin-Miller Primality Test. The existing implementation is already capable of determining whether a number is composite or probably prime. Your goal is to enhance its efficiency by integrating some deterministic methods for handling smaller numbers and improving modular arithmetic performance. # Problem Statement Modify the provided `is_prime` function to handle the following enhancements: 1. **Edge Case Handling**: Include deterministic checks for small primes and even numbers before invoking the main probabilistic test. 2. **Performance Improvement**: Implement the `valid_witness` function using efficient modular multiplications to handle large values effectively. # Function Signature ```python def is_prime(n: int, k: int) -> bool: pass ``` # Input - `n` (int): The number to test for primality. - `k` (int): The number of rounds to perform for decreasing error probability. Assume 1 ≤ k ≤ 50. # Output - `bool`: Return `False` if `n` is definitely composite, and `True` if `n` is probably prime. # Constraints - 1 ≤ n ≤ 10^18 - `n` is a positive integer. # Example ```python print(is_prime(17, 5)) # Output: True print(is_prime(18, 5)) # Output: False ``` # Performance Requirements - Your solution should efficiently handle very large values of `n` within the given constraints. # Notes - Ensure your implementation is capable of handling edge cases and large integer computations. - Make use of Python\'s in-built functions and libraries effectively.","solution":"import random def is_prime(n: int, k: int) -> bool: Determine if `n` is a prime number using Rabin-Miller Primality Test with `k` rounds. Args: - n (int): The number to test for primality. - k (int): The number of rounds for the test. Returns: - bool: True if `n` is probably prime, False if `n` is composite. if n <= 1: return False if n <= 3: return True if n % 2 == 0: return False # Write `n - 1` as `2^r * d` with `d` odd r, d = 0, n - 1 while d % 2 == 0: r += 1 d //= 2 def valid_witness(a, d, n, r): x = pow(a, d, n) # a^d % n if x == 1 or x == n - 1: return True for _ in range(r - 1): x = pow(x, 2, n) if x == n - 1: return True return False # Check `k` rounds of tests for _ in range(k): a = random.randint(2, n - 2) if not valid_witness(a, d, n, r): return False return True"},{"question":"# Scenario You are working on a text editor application where you need to implement a functionality that allows the users to search for specific words within the document. To achieve this, your task is to implement a function that finds the first occurrence of a substring (needle) within another string (haystack). # Problem Statement Implement a function `find_substring(haystack: str, needle: str) -> int` that returns the index of the first occurrence of the `needle` in the `haystack`, or -1 if `needle` is not part of `haystack`. # Function Signature ```python def find_substring(haystack: str, needle: str) -> int: ``` # Input - `haystack`: A string representing the text in which we are searching. - `needle`: A string representing the substring we are looking for. # Output - Returns an integer which represents the index of the first occurrence of `needle` in `haystack`. - Returns -1 if `needle` is not found in `haystack`. # Constraints - Both `haystack` and `needle` consist of only lowercase English characters. - The length of `haystack` and `needle` will be in the range [0, 10^4]. # Example ```python assert find_substring(\\"hello\\", \\"ll\\") == 2 assert find_substring(\\"aaaaa\\", \\"bba\\") == -1 assert find_substring(\\"\\", \\"a\\") == -1 assert find_substring(\\"hello\\", \\"\\") == 0 ``` # Performance Requirements - Consider optimizing the solution for large inputs where possible. Ensure the implementation is clear and correct. # Guidelines - Handle the edge cases appropriately, such as empty `needle` and `haystack` being shorter than `needle`. - Aim to create efficient code to minimize the execution time and space used.","solution":"def find_substring(haystack: str, needle: str) -> int: Returns the index of the first occurrence of the needle in the haystack, or -1 if the needle is not part of the haystack. if not needle: return 0 return haystack.find(needle)"},{"question":"# Scenario You have been hired to optimize the data processing system of a stock trading platform. The platform frequently needs to compute the cumulative sum of trading volumes over varying periods and update these volumes as new trades occur. To accomplish this efficiently, you decided to implement a Fenwick Tree (Binary Indexed Tree). # Task Implement a class `FenwickTree` (Binary Indexed Tree) with the following methods: 1. **Constructor** - `__init__(self, freq: List[int])`: Initializes the binary indexed tree with the given list of integers representing the frequencies (volumes). 2. **get_sum(self, i: int) -> int**: Returns the sum of the first i elements of the array. 3. **update(self, i: int, value: int) -> None**: Updates the element at index i by adding `value` to it. 4. **construct(self) -> List[int]**: Constructs the binary indexed tree from the provided array. # Input - A list of integers `freq` representing the initial trading volumes. - Subsequent operations specified for query and update. # Output - For queries, output the sum of the first i elements. - For updates, change the array and update the Fenwick Tree accordingly. # Constraints 1. `1 <= len(freq) <= 10^5` 2. `0 <= i < len(freq)` 3. `-10^4 <= value <= 10^4` # Example ```python # Initializing the Fenwick Tree with trading volumes freq = [5, 3, 7, 9, 6] fenwick_tree = Fenwick_Tree(freq) # Constructing the Binary Indexed Tree from the given frequencies bit_tree = fenwick_tree.construct() # Query: Getting sum of first 3 elements print(fenwick_tree.get_sum(bit_tree, 2)) # Output: 15 # Update: Adding 4 to index 1 fenwick_tree.update_bit(bit_tree, 1, 4) print(fenwick_tree.get_sum(bit_tree, 2)) # Output: 19 ``` Ensure your implementation is efficient and handles the edge cases effectively.","solution":"from typing import List class FenwickTree: def __init__(self, freq: List[int]): self.n = len(freq) self.freq = freq self.bit = [0] * (self.n + 1) self.construct() def construct(self) -> None: for i in range(self.n): self.update(i, self.freq[i]) def update(self, i: int, value: int) -> None: i += 1 while i <= self.n: self.bit[i] += value i += i & -i def get_sum(self, i: int) -> int: i += 1 sum = 0 while i > 0: sum += self.bit[i] i -= i & -i return sum"},{"question":"# Question: Optimize Duplicate Removal from an Array You are asked to optimize an existing algorithm that removes duplicates from an array and returns a new array with unique elements. The current algorithm has a time complexity of O(n^2). Your task is to implement a more efficient version of the algorithm with a linear time complexity. Function Signature ```python def remove_duplicates_optimized(array: list) -> list: pass ``` Input * A list `array` (0 ≤ len(array) ≤ 10^6) containing elements of any data type. Output * A list containing unique elements from the input list, preserving their first occurrence order. Constraints * The function should handle large input sizes efficiently. * The relative order of elements should be maintained. * You should consider edge cases such as empty lists or lists with all unique or all duplicate elements. Performance Requirements * The expected time complexity is O(n). * The expected space complexity is O(n). Example ```python print(remove_duplicates_optimized([1, 1, 1, 2, 2, 3, 4, 4, \\"hey\\", \\"hey\\", \\"hello\\", True, True])) # Output: [1, 2, 3, 4, \'hey\', \'hello\'] print(remove_duplicates_optimized([1, 2, 3, 4, 5, 5, 6, 7, 7, 8, 9, 10])) # Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] print(remove_duplicates_optimized([])) # Output: [] print(remove_duplicates_optimized([1, 2, 3, 3, 3, 3])) # Output: [1, 2, 3] ``` Your task is to write the `remove_duplicates_optimized` function, improving the performance of the given duplicate removal algorithm while ensuring it meets the specified constraints and performance requirements.","solution":"def remove_duplicates_optimized(array: list) -> list: Removes duplicates from given array maintaining the order of first occurrences. seen = set() result = [] for item in array: if item not in seen: seen.add(item) result.append(item) return result"},{"question":"# Scenario You are given a singly linked list where each node contains a string. This linked list may contain duplicate elements. For example, the list may look like: `\\"A\\" -> \\"A\\" -> \\"B\\" -> \\"C\\" -> \\"D\\" -> \\"C\\" -> \\"F\\" -> \\"G\\"`. You are asked to remove the duplicates from the linked list. # Problem Description Write two functions to remove duplicates from a linked list: 1. **remove_dups(head)**: Removes duplicates using a temporary buffer (hash set). 2. **remove_dups_without_set(head)**: Removes duplicates without using any extra space (no hash set). Each function should follow these specifications: - **Input**: `head`, the reference to the head node of the linked list. - **Output**: Both in-place function updates, so no return value is necessary. The linked list should be modified directly. # Constraints - The solution should handle the edge cases appropriately. - You are provided a `print_linked_list(head)` function to visualize the linked list. - Nodes in the linked list contain string values. # Example Given the linked list: ```plaintext \\"A\\" -> \\"A\\" -> \\"B\\" -> \\"C\\" -> \\"D\\" -> \\"C\\" -> \\"F\\" -> \\"G\\" ``` - After calling `remove_dups(head)`: ```plaintext \\"A\\" -> \\"B\\" -> \\"C\\" -> \\"D\\" -> \\"F\\" -> \\"G\\" ``` - After calling `remove_dups_without_set(head)` on the original list: ```plaintext \\"A\\" -> \\"B\\" -> \\"C\\" -> \\"D\\" -> \\"F\\" -> \\"G\\" ``` Write your implementation for both functions ensuring you handle any edge cases as described in the guidelines.","solution":"class ListNode: def __init__(self, val=\'\'): self.val = val self.next = None def remove_dups(head): Removes duplicates from a linked list using a set. if head is None: return current = head seen = set() seen.add(current.val) while current.next is not None: if current.next.val in seen: current.next = current.next.next # skip the duplicate node else: seen.add(current.next.val) current = current.next def remove_dups_without_set(head): Removes duplicates from a linked list without using extra space. current = head while current is not None: runner = current while runner.next is not None: if runner.next.val == current.val: runner.next = runner.next.next # skip the duplicate node else: runner = runner.next current = current.next def print_linked_list(head): result = [] current = head while current is not None: result.append(current.val) current = current.next return \\" -> \\".join(result) # Helper function to create a linked list from a list of values def create_linked_list(values): if not values: return None head = ListNode(values[0]) current = head for val in values[1:]: current.next = ListNode(val) current = current.next return head"},{"question":"# Scenario: You are working on a project requiring you to maintain a dynamic set of integers that supports efficient search, insertion, and deletion operations. To achieve this, you decide to implement a Binary Search Tree (BST). # Task: Implement a class `BST` with the following methods: - `insert(val: int)`: Inserts a value into the BST. - `delete(val: int)`: Deletes a value from the BST. - `search(val: int) -> bool`: Searches for a value in the BST. Returns `True` if the value exists, otherwise `False`. # Input Formats: - `insert(val: int)`: An integer `val`. - `delete(val: int)`: An integer `val`. - `search(val: int) -> bool`: An integer `val`. # Output Formats: - `insert(val: int)`: None. - `delete(val: int)`: None. - `search(val: int) -> bool`: Boolean. # Constraints: - All integer values are unique within the BST. - Methods will be called in the following sequence and constraints: - `insert(val)` inserts `val` into the BST. - `delete(val)` removes `val` if it exists in the BST. - `search(val) -> bool` returns `True` or `False` based on the existence of `val` in the BST. # Implementation Requirements: Ensure that your implementation handles: - Skewed tree structures. - Proper link updates during deletions. - Edge cases like inserting and deleting the only element in the tree. **Example**: ```python bst = BST() bst.insert(10) bst.insert(5) bst.insert(15) print(bst.search(5)) # Output: True bst.delete(5) print(bst.search(5)) # Output: False ```","solution":"class Node: def __init__(self, key): self.key = key self.left = None self.right = None class BST: def __init__(self): self.root = None def insert(self, val: int): if self.root is None: self.root = Node(val) else: self._insert(self.root, val) def _insert(self, root, val): if val < root.key: if root.left is None: root.left = Node(val) else: self._insert(root.left, val) else: if root.right is None: root.right = Node(val) else: self._insert(root.right, val) def search(self, val: int) -> bool: return self._search(self.root, val) def _search(self, root, val): if root is None: return False if root.key == val: return True elif val < root.key: return self._search(root.left, val) else: return self._search(root.right, val) def delete(self, val: int): self.root = self._delete(self.root, val) def _delete(self, root, val): if root is None: return root if val < root.key: root.left = self._delete(root.left, val) elif val > root.key: root.right = self._delete(root.right, val) else: if root.left is None: return root.right elif root.right is None: return root.left temp = self._minValueNode(root.right) root.key = temp.key root.right = self._delete(root.right, temp.key) return root def _minValueNode(self, root): current = root while current.left is not None: current = current.left return current"},{"question":"Efficient Phrase Matching Context: You are working for a company that provides text analysis solutions. One of your clients needs an efficient solution for finding all occurrences of a specific phrase within a large body of text. The phrase may appear multiple times and the client needs to know all the positions in the text where this phrase starts. Objective: Implement the function `knuth_morris_pratt` which will use the Knuth-Morris-Pratt (KMP) algorithm to find all starting positions of a given pattern string within a text string. Function Signature: ```python from typing import Sequence, List def knuth_morris_pratt(text: Sequence[str], pattern: Sequence[str]) -> List[int]: Given two strings, \'text\' and \'pattern\', return the list of start indexes in \'text\' that match with \'pattern\' using the Knuth-Morris-Pratt algorithm. Args: text (Sequence[str]): The text in which to search for the pattern. pattern (Sequence[str]): The pattern to search for within the text. Returns: List[int]: List of starting indices indicating where \'pattern\' is found within \'text\'. Example: >>> knuth_morris_pratt(\'hello there hero!\', \'he\') [0, 7, 12] If an index is in the list, text[index : index + M] matches with pattern. Note: - If text is an empty string, return an empty list. - If pattern is an empty string or longer than the text, return an empty list. - Ensure that the algorithm handles edge cases efficiently. ``` Constraints: - The length of the text, `N`, will be between 0 and 10^6. - The length of the pattern, `M`, will be between 0 and 10^4. - The text and pattern will contain only printable ASCII characters. - Your implementation should run in O(N + M) time complexity. Performance Requirements: - Your solution must be efficient and handle large inputs within reasonable limits set by the constraints. - Memory usage should be optimized and adhered to format limitations. Example: ```python >>> knuth_morris_pratt(\\"ababcabcabababd\\", \\"ababd\\") [10] >>> knuth_morris_pratt(\\"abcabcabcabc\\", \\"abc\\") [0, 3, 6, 9] ``` Guidelines: - Clearly handle cases where the text or pattern is empty. - Consider both typical and edge test cases when verifying your solution.","solution":"from typing import Sequence, List def knuth_morris_pratt(text: Sequence[str], pattern: Sequence[str]) -> List[int]: Given two strings, \'text\' and \'pattern\', return the list of start indexes in \'text\' that match with \'pattern\' using the Knuth-Morris-Pratt algorithm. Args: text (Sequence[str]): The text in which to search for the pattern. pattern (Sequence[str]): The pattern to search for within the text. Returns: List[int]: List of starting indices indicating where \'pattern\' is found within \'text\'. Example: >>> knuth_morris_pratt(\'hello there hero!\', \'he\') [0, 7, 12] If an index is in the list, text[index : index + M] matches with pattern. Note: - If text is an empty string, return an empty list. - If pattern is an empty string or longer than the text, return an empty list. - Ensure that the algorithm handles edge cases efficiently. if not text or not pattern or len(pattern) > len(text): return [] def compute_lps(pattern: Sequence[str]) -> List[int]: lps = [0] * len(pattern) length = 0 i = 1 while i < len(pattern): if pattern[i] == pattern[length]: length += 1 lps[i] = length i += 1 else: if length != 0: length = lps[length - 1] else: lps[i] = 0 i += 1 return lps lps = compute_lps(pattern) result = [] i = 0 j = 0 while i < len(text): if pattern[j] == text[i]: i += 1 j += 1 if j == len(pattern): result.append(i - j) j = lps[j - 1] elif i < len(text) and pattern[j] != text[i]: if j != 0: j = lps[j - 1] else: i += 1 return result"},{"question":"# Fibonacci Sequence Calculation You are tasked with implementing a function to calculate the n-th Fibonacci number. The Fibonacci sequence F(n) is defined as: - F(0) = 0 - F(1) = 1 - F(n) = F(n-1) + F(n-2), for n > 1 Your task is to implement this sequence in three different ways: 1. A recursive method 2. A method using dynamic programming (list-based) 3. An iterative method # Function Descriptions 1. **Recursive Method** - **Function Name**: `fib_recursive(n)` - **Input**: An integer `n` (0 <= n <= 35) - **Output**: The n-th Fibonacci number. 2. **Dynamic Programming Method (List-based)** - **Function Name**: `fib_list(n)` - **Input**: An integer `n` (0 <= n <= 100) - **Output**: The n-th Fibonacci number. 3. **Iterative Method** - **Function Name**: `fib_iter(n)` - **Input**: An integer `n` (0 <= n <= 100) - **Output**: The n-th Fibonacci number. # Constraints - `fib_recursive`: n should be between 0 and 35 (inclusive) due to performance limitations. - `fib_list` and `fib_iter`: n should be between 0 and 100 (inclusive). # Example - `fib_recursive(5)` should return 5 - `fib_list(10)` should return 55 - `fib_iter(10)` should return 55 # Additional Notes - The recursive approach is expected to be slow for larger `n`. Hence it is limited to `n <= 35`. - The dynamic programming method should store intermediate Fibonacci numbers in a list for quick reference. - The iterative method should use constant space and form the solution efficiently. Implement these functions considering the constraints and performance requirements.","solution":"def fib_recursive(n): Returns the n-th Fibonacci number using a recursive method. if n == 0: return 0 elif n == 1: return 1 else: return fib_recursive(n-1) + fib_recursive(n-2) def fib_list(n): Returns the n-th Fibonacci number using a dynamic programming method (list-based). if n == 0: return 0 elif n == 1: return 1 fibs = [0, 1] for i in range(2, n + 1): fibs.append(fibs[i-1] + fibs[i-2]) return fibs[n] def fib_iter(n): Returns the n-th Fibonacci number using an iterative method. if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for i in range(2, n + 1): a, b = b, a + b return b"},{"question":"You are working on an encryption project and need to efficiently determine the number of integers that are coprime with a given number n. A function `euler_totient(n)` calculates this by enumerating potential divisors and reducing the input value iteratively. Implement the `euler_totient` function to solve this problem leveraging Euler\'s totient function efficiently. # Function Signature ```python def euler_totient(n: int) -> int: Returns the count of integers between 1 and n inclusive that are coprime with n. Parameters: n (int): The integer n to calculate the totsient function for. Returns: int: The count of coprime integers. ``` # Input * `n` (1 ≤ n ≤ 10^9): a positive integer. # Output * An integer representing the number of integers between 1 and n inclusive that are coprime with `n`. # Example ```python assert euler_totient(9) == 6 # (1, 2, 4, 5, 7, 8) assert euler_totient(10) == 4 # (1, 3, 7, 9) assert euler_totient(1) == 1 # (1) assert euler_totient(2) == 1 # (1) ``` # Constraints & Performance Requirements * Ensure the function runs efficiently for large values of `n` (up to 10^9). * Consider edge cases such as when `n` is a prime number or a power of a prime. * Handle the full constraint spectrum (1 ≤ n ≤ 10^9), ensuring your function is both correct and performant. # Notes * Do not use any built-in functions that directly calculate the totient function. * Optimize for both time and space where possible, leveraging insights into number factorization.","solution":"def euler_totient(n: int) -> int: Returns the count of integers between 1 and n inclusive that are coprime with n. Parameters: n (int): The integer n to calculate the totient function for. Returns: int: The count of coprime integers. result = n p = 2 # Check for all factors from 2 to √n while p * p <= n: if n % p == 0: while n % p == 0: n //= p result -= result // p p += 1 # If n is still greater than 1, then n must be a prime number greater than √n if n > 1: result -= result // n return result"},{"question":"Write a function called `find_factor_combinations(n: int) -> List[List[int]]` that takes an integer `n` and returns all possible combinations of its factors. Ensure factors are greater than 1 and less than `n`. # Input - `n`: An integer where `1 < n < 10^6`. # Output - A list of lists, where each sublist contains a unique combination of factors of `n` that multiply to `n`. # Constraints - Factors in each combination must be greater than 1 and less than `n`. - Order of combinations within the list does not matter, but elements within each combination should be sorted in ascending order. # Example ``` input: 1 output: [] input: 37 output: [] input: 12 output: [ [2, 6], [2, 2, 3], [3, 4] ] input: 32 output: [ [2, 16], [2, 2, 8], [2, 2, 2, 4], [2, 2, 2, 2, 2], [2, 4, 4], [4, 8] ] ``` # Thought Process 1. Begin with the smallest factor, 2, and attempt to divide `n`. 2. If a factor is found, recursively find the combinations of the resulting quotient and append the factor to each combination. 3. Ensure combinations are unique and sorted. 4. Use both iterative and recursive backtracking to explore all potential factor combinations. Implement the provided function using your preferred methodology (iterative or recursive).","solution":"from typing import List def find_factor_combinations(n: int) -> List[List[int]]: def backtrack(start, target, path): for i in range(start, int(target**0.5) + 1): if target % i == 0: new_path = path + [i, target // i] if all(j > 1 for j in new_path): result.append(new_path) backtrack(i, target // i, path + [i]) result = [] if n <= 1: return result # no factors exist for n <= 1 backtrack(2, n, []) # sort and remove duplicates unique_result = [] for lst in result: lst.sort() if lst not in unique_result: unique_result.append(lst) return unique_result"},{"question":"Problem Statement You are tasked with sorting an array of integers using Gnome Sort. As an experienced programmer, your goal is to implement the Gnome Sort algorithm, ensuring the array gets sorted in ascending order. Consider the properties and edge cases mentioned during your learning of the Gnome Sort algorithm. # Function Signature ```python def gnome_sort(arr: List[int]) -> List[int]: pass ``` # Input * `arr` (List[int]): An array of integers that you need to sort. # Output * Returns the same array `arr` sorted in ascending order. # Constraints * The size of the array (n) where 1 <= n <= 10^4. * The array may contain duplicate elements. * Integers in the array are within the range of -10^4 to 10^4. # Example ```python assert gnome_sort([34, 2, 78, 12, 45, -3, 0]) == [-3, 0, 2, 12, 34, 45, 78] assert gnome_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] assert gnome_sort([]) == [] assert gnome_sort([30, -10, 40, 25, -10, 0]) == [-10, -10, 0, 25, 30, 40] ``` # Notes * Ensure proper handling of edge cases like an empty array or an array with a single element. * Your implementation should be able to handle duplicates and the full range of allowed integer values. * Consider that while the worst-case performance is O(n^2), the best-case performance is O(n).","solution":"from typing import List def gnome_sort(arr: List[int]) -> List[int]: index = 0 while index < len(arr): if index == 0 or arr[index] >= arr[index - 1]: index += 1 else: arr[index], arr[index - 1] = arr[index - 1], arr[index] index -= 1 return arr"},{"question":"# Longest Prefix Suffix (using KMP Algorithm) You are given two strings, `haystack` and `needle`. Implement the `strStr()` function that returns the index of the first occurrence of `needle` in `haystack`, or `-1` if `needle` is not part of `haystack`. To solve this problem more efficiently than the brute force approach, you will implement the Knuth-Morris-Pratt (KMP) algorithm for substring search which has a linear time complexity. Function Signature ```python def kmp_search(haystack: str, needle: str) -> int: ``` Input * `haystack` (str): a string of length `N` * `needle` (str): a string of length `M` Output * (int): the index of the first occurrence of `needle` in `haystack` or `-1` if `needle` is not found. Constraints * `0 <= N, M <= 10^5` * All characters in `haystack` and `needle` are lowercase English letters. Performance Requirements * The solution should have O(N + M) time complexity. * The solution must be efficient in terms of both space and time to handle up to the maximum constraint size. Examples ```python # Example 1 haystack = \\"hello\\" needle = \\"ll\\" assert kmp_search(haystack, needle) == 2 # Example 2 haystack = \\"aaaaa\\" needle = \\"bba\\" assert kmp_search(haystack, needle) == -1 # Example 3 haystack = \\"\\" needle = \\"\\" assert kmp_search(haystack, needle) == 0 ``` # Implementation Details 1. **Function Skeleton**: Begin by writing the function `kmp_search` which takes `haystack` and `needle` as input. 2. **Edge Case Handling**: Return 0 if the needle is an empty string. 3. **KMP Algorithm**: * **Prefix Table (LPS array)**: Write a helper function `computeLPS` to calculate the longest prefix which is also a suffix for each prefix of the needle. * **Search Process**: Use the LPS array for the search process to skip unnecessary comparisons in the `haystack`.","solution":"def computeLPS(pattern): Computes the Longest Prefix Suffix (LPS) array for the given pattern. M = len(pattern) lps = [0] * M length = 0 i = 1 while i < M: if pattern[i] == pattern[length]: length += 1 lps[i] = length i += 1 else: if length != 0: length = lps[length - 1] else: lps[i] = 0 i += 1 return lps def kmp_search(haystack, needle): Returns the index of the first occurrence of `needle` in `haystack`, or -1 if `needle` is not part of `haystack`. N = len(haystack) M = len(needle) if M == 0: return 0 lps = computeLPS(needle) i = 0 j = 0 while i < N: if needle[j] == haystack[i]: i += 1 j += 1 if j == M: return i - j elif i < N and needle[j] != haystack[i]: if j != 0: j = lps[j - 1] else: i += 1 return -1"},{"question":"# Ternary Search Algorithm Implementation You are to implement a Ternary Search function to find a specific value within a sorted array. The array can contain any numerical values and will be provided in ascending order. Write a function `ternary_search(left, right, key, arr)` where: - `left` is the starting index of the search range. - `right` is the ending index of the search range. - `key` is the value to be searched for. - `arr` is a list of sorted integers. The function should return the index of the `key` if it is present within the bounds defined by `left` and `right` (inclusive). If the `key` is not found within the specified indices, the function should return -1. **Constraints:** - Assume that `arr` is sorted in ascending order. - The range specified by `left` and `right` is always valid. - `left` and `right` always lie within the complete array range and `left <= right`. - Handle edge cases such as empty subarrays which might be a result of further recursive searches. **Example Input/Output:** 1. `ternary_search(0, 8, 15, [1, 2, 5, 7, 10, 15, 20, 25, 30])` should return `5`. 2. `ternary_search(0, 4, 3, [3, 6, 9, 12, 15])` should return `0`. 3. `ternary_search(1, 4, 11, [2, 4, 10, 19, 24])` should return `-1`.","solution":"def ternary_search(left, right, key, arr): Performs a ternary search for the key within the segment of the array defined by left and right indices. Args: left (int): Left index of the section to search within. right (int): Right index of the section to search within. key (int): The value to be searched for. arr (list of int): Sorted array. Returns: int: The index of the key if present, else -1. if right >= left: third = (right - left) // 3 mid1 = left + third mid2 = right - third if arr[mid1] == key: return mid1 if arr[mid2] == key: return mid2 if key < arr[mid1]: return ternary_search(left, mid1 - 1, key, arr) elif key > arr[mid2]: return ternary_search(mid2 + 1, right, key, arr) else: return ternary_search(mid1 + 1, mid2 - 1, key, arr) return -1"},{"question":"You are tasked to design an algorithm that encodes a list of strings into a single string and then decodes that string back into the original list of strings. This can be essential in scenarios where multiple strings need to be sent across a network efficiently. # Function Definitions Implement the following two functions: * `def encode(strs: List[str]) -> str:` - **Input**: `strs` a list of strings. - **Output**: A single string that encodes the list of strings. - **Example**: `encode([\\"hello\\", \\"world\\"])` should return `\\"5:hello5:world\\"`. * `def decode(s: str) -> List[str]:` - **Input**: `s`, the encoded string. - **Output**: A list of strings that the encoded string represents. - **Example**: `decode(\\"5:hello5:world\\")` should return `[\\"hello\\", \\"world\\"]`. # Constraints * `1 <= len(str) <= 1000` : Length of individual strings. * `The list will have at most 100 strings`. * `Strings can contain alphanumeric characters and punctuations but will not contain the delimiter \':\' directly`. **Note**: Your solution should handle edge cases such as empty strings, single character strings, and unusual delimiters in an efficient way. # Example Encoding Example: ``` Input: [\\"encode\\", \\"this\\", \\"list!\\"] Output: \\"6:encode4:this5:list!\\" ``` Decoding Example: ``` Input: \\"6:encode4:this5:list!\\" Output: [\\"encode\\", \\"this\\", \\"list!\\"] ```","solution":"from typing import List def encode(strs: List[str]) -> str: Encodes a list of strings into a single string. :param strs: list of strings to be encoded :return: encoded string return \'\'.join(f\\"{len(s)}:{s}\\" for s in strs) def decode(s: str) -> List[str]: Decodes a single string into a list of strings. :param s: encoded string :return: list of decoded strings result = [] i = 0 while i < len(s): j = i while s[j] != \':\': j += 1 length = int(s[i:j]) result.append(s[j + 1:j + 1 + length]) i = j + 1 + length return result"},{"question":"# Scenario You have been hired by a company that specializes in drone-based geographic surveys. Your task is to analyze images rendered as 2D grids, where \'1\' indicates land and \'0\' indicates water, and count the number of isolated landmasses (islands). # Problem Description You are given a 2D grid map of \'1\'s (land) and \'0\'s (water). An island is formed by connecting adjacent lands horizontally or vertically. Surrounded by water, each island must be identified, and the total number counted. # Function Signature ```python def num_islands(grid: List[List[int]]) -> int: ``` # Input - `grid` (List[List[int]]): A 2D list of integers representing the map. # Output - Returns an integer representing the number of islands. # Constraints - The width and height of the grid do not exceed 300. - The grid is completely surrounded by water. # Example ```python # Example 1 grid = [ [1, 1, 1, 1, 0], [1, 1, 0, 1, 0], [1, 1, 0, 0, 0], [0, 0, 0, 0, 0] ] assert num_islands(grid) == 1 # Example 2 grid = [ [1, 1, 0, 0, 0], [1, 1, 0, 0, 0], [0, 0, 1, 0, 0], [0, 0, 0, 1, 1] ] assert num_islands(grid) == 3 ``` # Guidance - Use Depth-First Search (DFS) to explore each island. - Carefully handle edge cases, such as empty or fully non-uniform grids. - Ensure the performance meets the constraints provided (e.g., handle the maximum grid size efficiently). # Solution Outline 1. Loop through each cell in the grid. 2. When a \'1\' is found, initiate a DFS that marks the whole island. 3. Count each DFS initiation as a separate island. Implement your function as described above.","solution":"def num_islands(grid): if not grid: return 0 rows, cols = len(grid), len(grid[0]) def dfs(r, c): if r < 0 or c < 0 or r >= rows or c >= cols or grid[r][c] == 0: return grid[r][c] = 0 # mark land as visited dfs(r + 1, c) dfs(r - 1, c) dfs(r, c + 1) dfs(r, c - 1) island_count = 0 for r in range(rows): for c in range(cols): if grid[r][c] == 1: dfs(r, c) island_count += 1 return island_count"},{"question":"You are given the root of a binary tree. Write a function to perform a level order traversal (breadth-first traversal) on the tree and return the result as a list of lists containing the nodes’ values for each level. # Function Signature: ```python def level_order(root: TreeNode) -> List[List[int]]: ``` # Input: - `root` (TreeNode): The root node of a binary tree. It may be null, in which case the output should be an empty list. # Output: - List of lists of integers, where each sub-list represents a single level of the tree in level order. # Constraints: - The number of nodes in the tree will not exceed 10^4. - The values of the nodes will be within the range -1000 to 1000. # Example: ```python # Example Binary Tree: # 3 # / # 9 20 # / # 15 7 input: [3,9,20,null,null,15,7] output: [[3], [9,20], [15,7]] ``` # Scenario: Imagine we are trying to visually group the staff members in a corporate hierarchy into different managerial levels. Each node in the tree represents an employee, and edges represent direct reports. Your task is to write the function that provides a level-by-level grouping of employees for the entire tree which represents the corporation\'s hierarchy. **Note**: Make sure your implementation efficiently handles both the edge cases of extremely unbalanced trees and trees that are maximally balanced.","solution":"from typing import List, Optional import collections class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_order(root: Optional[TreeNode]) -> List[List[int]]: if not root: return [] result = [] queue = collections.deque([root]) while queue: level_size = len(queue) current_level = [] for _ in range(level_size): node = queue.popleft() current_level.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(current_level) return result"},{"question":"# Kosaraju\'s Algorithm Implementation for SCC Detection You are provided with a directed graph where you need to find the number of strongly connected components (SCCs) using Kosaraju\'s Algorithm. Your task is to implement the `dfs` and `kosaraju` methods in the `Kosaraju` class to achieve this. Input Format: * The first line contains two integers, **V** (number of vertices) and **E** (number of edges). * The next **E** lines each contain two integers **u** and **v**, representing a directed edge from vertex **u** to vertex **v**. Output Format: * Output a single integer, the count of SCCs in the given graph. Constraints: * (1 leq V, E leq 10^5) * Vertex numbering is 0-based. Example: **Input:** ``` 6 7 0 2 1 0 2 3 3 1 3 4 4 5 5 4 ``` **Output:** ``` 2 ``` Explanation: There are two SCCs in the graph: 1. 0 -> 2 -> 3 -> 1 -> 0 2. 4 -> 5 -> 4 # Implementation Details Implement the given `dfs` and `kosaraju` methods to find the number of strongly connected components in the directed graph. ```python class Kosaraju: def dfs(self, i, V, adj, visited, stk): visited[i] = 1 for x in adj[i]: if visited[x] == -1: self.dfs(x, V, adj, visited, stk) stk.append(i) def kosaraju(self, V, adj): stk, visited = [], [-1]*(V+1) for i in range(V): if visited[i] == -1: self.dfs(i, V, adj, visited, stk) stk.reverse() res = stk.copy() ans, visited1 = 0, [-1]*(V+1) adj1 = [[] for x in range(V)] for i in range(len(adj)): for x in adj[i]: adj1[x].append(i) for i in range(len(res)): if visited1[res[i]] == -1: ans += 1 self.dfs(res[i], V, adj1, visited1, stk) return ans def main(): V, E = map(int, input().split()) adj = [[] for x in range(V)] for i in range(E): u, v = map(int, input().split()) adj[u].append(v) print(Kosaraju().kosaraju(V, adj)) if __name__ == \'__main__\': main() ``` Ensure your solution passes the provided example and handle edge cases to confirm its correctness.","solution":"class Kosaraju: def dfs(self, node, adj, visited_stack): visited, stack = visited_stack visited[node] = True for neighbor in adj[node]: if not visited[neighbor]: self.dfs(neighbor, adj, visited_stack) stack.append(node) def reverse_graph(self, V, adj): rev_adj = [[] for _ in range(V)] for u in range(V): for v in adj[u]: rev_adj[v].append(u) return rev_adj def kosaraju(self, V, adj): stack = [] visited = [False] * V for i in range(V): if not visited[i]: self.dfs(i, adj, (visited, stack)) reversed_graph = self.reverse_graph(V, adj) visited = [False] * V scc_count = 0 while stack: node = stack.pop() if not visited[node]: scc_count += 1 self.dfs(node, reversed_graph, (visited, [])) return scc_count"},{"question":"Scenario You are working in a company developing a sophisticated 2D game engine. In part of your project, you need a systematic approach to scan a game map data stored as a 2D matrix for performing rendering optimizations and matrix operations. Implement a function that will traverse the matrix in a spiral order to fulfill this requirement. Function Details Implement the function `spiral_traversal(matrix)` which takes a 2D matrix and returns a list of its elements in spiral order. Input Description * `matrix`: A 2D list (list of lists) of integers. The `matrix` has dimensions of m x n, where 1 <= m, n <= 1000. Output Description * A list of integers containing the matrix elements traversed in a spiral order. Constraints * The input matrix may be empty. * The matrix elements will range between -1000 and 1000. Example ```python matrix = [ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ] ] # The output should be [1, 2, 3, 6, 9, 8, 7, 4, 5] assert spiral_traversal(matrix) == [1, 2, 3, 6, 9, 8, 7, 4, 5] ``` Considerations - Handle edge cases such as a single row, single column, and empty matrices. - Optimize for clarity and performance. - Ensure your function does not access out-of-bounds elements or encounter index errors. Good luck!","solution":"def spiral_traversal(matrix): Traverses a 2D matrix in spiral order and returns a list of elements. if not matrix: return [] result = [] top, bottom = 0, len(matrix) - 1 left, right = 0, len(matrix[0]) - 1 while top <= bottom and left <= right: # Traverse from left to right for col in range(left, right + 1): result.append(matrix[top][col]) top += 1 # Traverse from top to bottom for row in range(top, bottom + 1): result.append(matrix[row][right]) right -= 1 if top <= bottom: # Traverse from right to left for col in range(right, left - 1, -1): result.append(matrix[bottom][col]) bottom -= 1 if left <= right: # Traverse from bottom to top for row in range(bottom, top - 1, -1): result.append(matrix[row][left]) left += 1 return result"},{"question":"# Scenario You are working on a project that involves implementing multiple sorting algorithms to benchmark their performance. One of the sorting methods you need to implement is the Cocktail Shaker Sort, a variation of the Bubble Sort algorithm that sorts by iterating through the list in both directions. # Task Write a function `cocktail_shaker_sort(arr)` that sorts an array of integers using the Cocktail Shaker Sort algorithm. # Function Signature ```python def cocktail_shaker_sort(arr: List[int]) -> List[int]: ``` # Input - A list `arr` of integers, where ( 1 leq len(arr) leq 10^5 ) and each element is in the range (-10^9 leq arr[i] leq 10^9). # Output - A list of integers sorted in non-decreasing order. # Constraints - Your implementation must sort the list in place with a time complexity of O(n^2) for the worst case. - The algorithm should handle empty lists and lists containing one element correctly. # Example ```python print(cocktail_shaker_sort([3, 0, 2, 5, -1, 4, 1])) # Output: [-1, 0, 1, 2, 3, 4, 5] print(cocktail_shaker_sort([1, 2, 3, 4, 5])) # Output: [1, 2, 3, 4, 5] ``` # Explanation of Example - In the first example, the array `[3, 0, 2, 5, -1, 4, 1]` is sorted to `[-1, 0, 1, 2, 3, 4, 5]` using the cocktail shaker sort. - In the second example, the already sorted array `[1, 2, 3, 4, 5]` remains unchanged after sorting. **Note**: Pay attention to edge cases like empty arrays and arrays with a single element.","solution":"def cocktail_shaker_sort(arr): Sorts the given list of integers using the Cocktail Shaker Sort algorithm. :param arr: List of integers to be sorted. :return: Sorted list of integers in non-decreasing order. n = len(arr) if n <= 1: return arr swapped = True start = 0 end = n - 1 while swapped: swapped = False # Traverse the array from left to right for i in range(start, end): if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] swapped = True if not swapped: break swapped = False end -= 1 # Traverse the array from right to left for i in range(end, start, -1): if arr[i] < arr[i - 1]: arr[i], arr[i - 1] = arr[i - 1], arr[i] swapped = True start += 1 return arr"},{"question":"Enhanced Substring Search Implement an enhanced version of the Rabin-Karp algorithm to find all occurrences of a pattern string within a text string. Your solution should account for edge cases and make improvements to minimize hash collisions. Your function should return the starting indices of all matches. Function Signature ```python def enhanced_rabin_karp(pattern: str, text: str) -> List[int]: pass ``` Input * `pattern` (str): The pattern to search for within the text. * `text` (str): The text within which to search for the pattern. Output * Returns a list of integers representing the starting indices of each substring match. If no matches are found, return an empty list. Constraints * The pattern and text consist of lowercase English letters only. * The length of the pattern will not exceed the length of the text. * Efficient performance is vital; consider optimizing the hash function to minimize collisions. Example ```python print(enhanced_rabin_karp(\\"abc\\", \\"ababcabc\\")) # Output: [2, 5] print(enhanced_rabin_karp(\\"aaaa\\", \\"baaaaaa\\")) # Output: [1, 2] print(enhanced_rabin_karp(\\"xyz\\", \\"ababcabc\\")) # Output: [] ``` Performance Requirement * Your solution should ideally run in O(n + m) time complexity under average conditions. Implementation Notes 1. Re-design the hash computation to minimize collisions. 2. Handle all potential edge cases, such as empty strings. 3. Ensure your function can handle large inputs efficiently.","solution":"from typing import List def enhanced_rabin_karp(pattern: str, text: str) -> List[int]: def compute_hash(s: str, prime: int, base: int) -> int: hash_val = 0 for char in s: hash_val = (hash_val * base + ord(char)) % prime return hash_val def recompute_hash(old_hash: int, old_char: str, new_char: str, power: int, prime: int, base: int) -> int: new_hash = old_hash - power * ord(old_char) % prime new_hash = (new_hash * base + ord(new_char)) % prime if new_hash < 0: new_hash += prime return new_hash if not pattern or not text or len(pattern) > len(text): return [] prime = 101 # A prime number to use as a modulus base = 256 # A suitable base for character set m = len(pattern) n = len(text) pattern_hash = compute_hash(pattern, prime, base) text_hash = compute_hash(text[:m], prime, base) # Precalculate base power (base^(m-1) % prime) base_power = pow(base, m-1, prime) result = [] for i in range(n - m + 1): if pattern_hash == text_hash: if text[i:i+m] == pattern: result.append(i) if i < n - m: text_hash = recompute_hash(text_hash, text[i], text[i + m], base_power, prime, base) return result"},{"question":"Scenario You are working on a string manipulation tool that generates all possible abbreviations for a given word. The aim is to help users quickly find shorthand representations of words for various applications such as note-taking or encoding text. Task Implement a function `generate_abbreviations(word)` that, given an input word, returns a list of all possible abbreviations following these rules: - A letter can stay as it is, or it can be replaced by a number representing the count of letters abbreviated. - Consecutive letters can be abbreviated together. Expected Function Signature ```python def generate_abbreviations(word: str) -> List[str]: ``` Input * `word`: A string `word` with length `0 <= len(word) <= 15`. Output * A list of all possible abbreviations of the string `word`. Constraints * You must generate all abbreviations using a backtracking approach. * Consider edge cases like empty strings or strings with single characters. Examples ```python assert generate_abbreviations(\\"word\\") == [\'word\', \'wor1\', \'wo1d\', \'wo2\', \'w1rd\', \'w1r1\', \'w2d\', \'w3\', \'1ord\', \'1or1\', \'1o1d\', \'1o2\', \'2rd\', \'2r1\', \'3d\', \'4\'] assert generate_abbreviations(\\"\\") == [\\"\\"] assert generate_abbreviations(\\"a\\") == [\\"a\\", \\"1\\"] ``` Write the function `generate_abbreviations` to meet the above requirements.","solution":"from typing import List def generate_abbreviations(word: str) -> List[str]: def backtrack(position, cur_abbr, count): if position == len(word): if count > 0: cur_abbr += str(count) result.append(cur_abbr) else: # Abbreviate current character backtrack(position + 1, cur_abbr, count + 1) # Use current character if count > 0: cur_abbr += str(count) backtrack(position + 1, cur_abbr + word[position], 0) result = [] backtrack(0, \'\', 0) return result"},{"question":"# Question: Implementing Optimized Insertion Sort **Scenario**: You are working as a software engineer at a logistics company that frequently deals with small datasets of shipment weights that need to be sorted for processing. You\'ve been tasked with optimizing the sorting of these weights using an insertion sort that minimizes the number of comparisons performed during the sorting process. **Task**: Write a function `optimized_insertion_sort(arr: List[int]) -> List[int]` in Python that sorts a given list of integers using a modified version of the insertion sort. This optimized version should use binary search to find the correct position to insert the current element, reducing the number of comparisons. # Specifications: - The input list `arr` will contain integers, and its length will not exceed 1000 elements. - The function should return the sorted list. - You are not allowed to use built-in sort functions. # Input: - A list of `n` integers (`1 <= n <= 1000`), `arr`. # Output: - A list of `n` integers in non-decreasing order. # Example: ```python def optimized_insertion_sort(arr: List[int]) -> List[int]: pass # Example usage: print(optimized_insertion_sort([12, 11, 13, 5, 6])) # Output: [5, 6, 11, 12, 13] print(optimized_insertion_sort([4, 3, 2, 10])) # Output: [2, 3, 4, 10] ``` # Constraints: - You must use a binary search to determine the position of the current element. - The algorithm should handle all edge cases, such as an empty list and a list with one element efficiently. # Performance: - The function should be efficient and improve upon the straightforward insertion sort by minimizing the number of comparisons.","solution":"from typing import List def binary_search(arr: List[int], val: int, start: int, end: int) -> int: while start < end: mid = (start + end) // 2 if arr[mid] < val: start = mid + 1 else: end = mid return start def optimized_insertion_sort(arr: List[int]) -> List[int]: for i in range(1, len(arr)): current_value = arr[i] pos = binary_search(arr, current_value, 0, i) arr = arr[:pos] + [current_value] + arr[pos:i] + arr[i+1:] return arr"},{"question":"# Question: Implement Enhanced RSA Encryption Key Generation Context: RSA encryption is a fundamental algorithm in modern cryptography. It ensures the secure transmission of data over an insecure network. This question focuses on generating RSA keys with a more efficient prime number testing algorithm and handling any potential edge cases effectively. Task: 1. Implement a function `is_probably_prime(num, k)` that uses the Miller-Rabin primality test to check if a number is a probable prime. 2. Modify the `generate_key(k, seed=None)` function to use `is_probably_prime`. 3. Ensure that the generated (n, e, d) keys meet RSA requirements while optimizing for performance and handling edge cases. Function Specifications: 1. **is_probably_prime** - **Parameters**: - `num` (int): The number to test for primality. - `k` (int): The number of iterations for the Miller-Rabin test (higher `k` increases the accuracy). - **Returns**: - (bool): True if `num` is a probable prime, otherwise False. 2. **generate_key** - **Parameters**: - `k` (int): The desired bit length of the modulus `n`. - `seed` (Optional[int]): A seed value for random number generation (default is None). - **Returns**: - (tuple): A tuple of three integers `(n, e, d)` which are the RSA public modulus, public exponent, and private exponent, respectively. Constraints: - The implementation must cater to the edge cases of very small values for prime testing. - The key generation should complete in a reasonable time frame for typical RSA key sizes (e.g., 1024-bit, 2048-bit). Example Usage: ```python n, e, d = generate_key(16) data = 42 encrypted = encrypt(data, e, n) decrypted = decrypt(encrypted, d, n) assert decrypted == data print(f\\"Generated keys -> n: {n}, e: {e}, d: {d}\\") ``` Hints: - Implement Miller-Rabin correctly to ensure robust prime testing. - Test with different seed values and key bit lengths to verify performance and correctness.","solution":"import random def is_probably_prime(num, k): Uses the Miller-Rabin primality test to check if a number is a probable prime. Parameters: num (int): The number to test for primality. k (int): The number of iterations for the Miller-Rabin test (higher k increases the accuracy). Returns: bool: True if num is probably prime, otherwise False. if num <= 1: return False if num <= 3: return True if num % 2 == 0: return False # Write num-1 as 2^r * d r, d = 0, num - 1 while d % 2 == 0: r += 1 d //= 2 # Miller-Rabin Test for _ in range(k): a = random.randint(2, num - 2) x = pow(a, d, num) if x == 1 or x == num - 1: continue for _ in range(r - 1): x = pow(x, 2, num) if x == num - 1: break else: return False return True def generate_key(k, seed=None): Generates RSA public and private keys. Parameters: k (int): The desired bit length of the modulus n. seed (Optional[int]): A seed value for random number generation (default is None). Returns: tuple: A tuple of three integers (n, e, d) which are the RSA public modulus, public exponent, and private exponent, respectively. if seed is not None: random.seed(seed) # Compute prime p and q def generate_large_prime(bit_length): while True: num = random.getrandbits(bit_length) if is_probably_prime(num, 40): return num bit_length = k // 2 p = generate_large_prime(bit_length) q = generate_large_prime(bit_length) while p == q: q = generate_large_prime(bit_length) n = p * q phi = (p - 1) * (q - 1) # Choose e e = 65537 def gcd(a, b): while b: a, b = b, a % b return a while gcd(e, phi) != 1: e += 2 # Compute d def modinv(a, m): m0, x0, x1 = m, 0, 1 while a != 1: q = a // m m, a = a % m, m x0, x1 = x1 - q * x0, x0 return x1 + m0 if x1 < 0 else x1 d = modinv(e, phi) return n, e, d"},{"question":"# Maximum Contiguous Subsequence Sum – Coding Assessment Context You are tasked to help a financial analyst maximize the profit from stock price changes over a period. Given an array of daily price changes, you need to find out the maximum possible profit (sum of contiguous subarray). Problem Statement Implement a function `max_contiguous_subsequence_sum(arr)` that calculates the maximum sum of a contiguous subsequence in a given array of integers `arr`. Function Signature ```python def max_contiguous_subsequence_sum(arr) -> int: ``` Input - `arr`: A list of integers. The length of the list is between `1` and `10^5`, and the values can be any integer within the range of `-10^4` to `10^4`. Output - Return an integer representing the maximum sum of a contiguous subsequence in the array. Constraints - A subsequence must have at least one element. - If the array is empty, the result should be `0`. Examples 1. Input: `[-2, 3, 8, -1, 4]` Output: `14` Explanation: The maximum sum subsequence is `[3, 8, -1, 4]`. 2. Input: `[-1, 1, 0]` Output: `1` Explanation: The maximum sum subsequence is `[1]`. 3. Input: `[-1, -3, -4]` Output: `-1` Explanation: The maximum sum subsequence is `[-1]`. 4. Input: `[2, -4, 1, 3, -4, 5, 6]` Output: `11` Explanation: The maximum sum subsequence is `[1, 3, -4, 5, 6]`. Notes Take note to handle arrays that include negative values and implement the solution efficiently within the given constraints.","solution":"def max_contiguous_subsequence_sum(arr) -> int: Returns the maximum sum of a contiguous subsequence in the given array of integers `arr`. if not arr: return 0 max_ending_here = max_so_far = arr[0] for x in arr[1:]: max_ending_here = max(x, max_ending_here + x) max_so_far = max(max_so_far, max_ending_here) return max_so_far"},{"question":"**Structurally Unique BSTs** A Binary Search Tree (BST) is a binary tree in which each node has a value greater than all the values in its left subtree and less than all the values in its right subtree. Given an integer `n`, determine the count of structurally unique BSTs that store values 1 through `n`. **Function Signature** ```python def num_trees(n: int) -> int: ``` **Input** * `n`: An integer ( 0 leq n leq 19 ) representing the number of values (from 1 to `n`). **Output** * Returns an integer, the number of structurally unique BSTs possible using `n` values. **Constraints** * Its essential that the function works efficiently for all values of `n` within the given range. **Performance Requirements** * The algorithm should run efficiently for values of `n` up to 19, keeping in mind that ( O(n^2) ) time complexity can be justified by the constraints provided. **Examples** ```python assert num_trees(3) == 5 assert num_trees(1) == 1 assert num_trees(0) == 1 assert num_trees(4) == 14 ``` **Scenario** A software developer is working on a feature to analyze the possible configurations of a binary search tree generator. They need a function that accurately counts how many different BST structures can be built with given distinct values 1 through `n`. This will help in understanding the complexity and variations possible in tree-based data structures for optimizing storage and retrieval systems. Provide a robust and efficient function `num_trees` to assist in these calculations.","solution":"def num_trees(n: int) -> int: Return the number of structurally unique BSTs that store values 1 through n. # Base case if n == 0 or n == 1: return 1 # Initialize a list to store the computed results dp = [0] * (n + 1) dp[0], dp[1] = 1, 1 # Compute the number of unique BSTs for each number i using dynamic programming for i in range(2, n + 1): for j in range(1, i + 1): dp[i] += dp[j - 1] * dp[i - j] return dp[n]"},{"question":"# Stooge Sort Re-Implementation Challenge Problem Statement Given an array of numbers, implement the Stooge Sort algorithm to sort the array in non-decreasing order. You should write a function that takes an array and its boundaries as input and modifies the array in place. Function Signature ```python def stoogesort(arr: list[int], l: int, h: int) -> None: pass ``` Input * `arr`: A list of integers to be sorted. * `l`: The starting index of the array section to sort (0 ≤ l < len(arr)). * `h`: The ending index of the array section to sort (l ≤ h < len(arr)). Output The function should not return anything. It should modify the input list `arr` such that the elements between indices `l` and `h` are sorted in non-decreasing order. Constraints * The length of the array `n` is such that 1 ≤ n ≤ 10^3. * The array can contain both positive and negative integers. Example Input: ```python arr = [5, 3, 2, 4, 1] stoogesort(arr, 0, len(arr) - 1) ``` Output: ```python arr = [1, 2, 3, 4, 5] ``` Performance Requirements * Your solution should work efficiently within the given constraints. * Be mindful of the recursion limit in Python for large input sizes and stack depth. Additional Instructions * You should validate your solution with various test cases, including edge cases such as arrays with a single element, already sorted arrays, and arrays with all identical elements. * Document your code with comments explaining the recursive sorting process.","solution":"def stoogesort(arr, l, h): if l >= h: return # If the element at the start is larger than the element at the end, swap them if arr[l] > arr[h]: arr[l], arr[h] = arr[h], arr[l] # If there are more than two elements in the array slice if h - l + 1 > 2: # Calculate the third of the length in integer form t = (h - l + 1) // 3 # Recursively sort the first 2/3 of the array stoogesort(arr, l, h - t) # Recursively sort the last 2/3 of the array stoogesort(arr, l + t, h) # Recursively sort the first 2/3 of the array again to ensure the overall array is sorted stoogesort(arr, l, h - t)"},{"question":"**Task: Implement an Enhanced Version of Comb Sort** **Objective**: Improve the comb sort algorithm to handle larger arrays more efficiently. Implement an optimized version of comb sort which switches to insertion sort when the gap size becomes small. **Specifications**: * **Function**: `enhanced_comb_sort(arr: List[int]) -> List[int]` * **Input**: A list of integers, `arr`, where `1 <= len(arr) <= 10^4` and each element, `-10^4 <= arr[i] <= 10^4`. * **Output**: A sorted list of integers in ascending order. **Steps**: 1. Modify the existing comb sort algorithm to switch to insertion sort when the gap size goes below a certain threshold. 2. Use the shrink factor of 1.3 as suggested in the original algorithm. 3. Ensure the algorithm can handle arrays of varying sizes efficiently. **Performance Requirement**: The function should perform efficiently, handling up to the maximum input size within reasonable time limits. **Constraints**: 1. Focus must be on optimizing the sorting element swaps and comparisons. 2. You may use helper functions if needed for insertion sort or other intermediate calculations. **Example**: ```python assert enhanced_comb_sort([4, 3, 2, 1]) == [1, 2, 3, 4] assert enhanced_comb_sort([7, 10, -3, 4, 1, 5]) == [-3, 1, 4, 5, 7, 10] ```","solution":"from typing import List def insertion_sort(arr: List[int], start: int, end: int) -> None: for i in range(start + 1, end + 1): key = arr[i] j = i - 1 while j >= start and arr[j] > key: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key def enhanced_comb_sort(arr: List[int]) -> List[int]: if not arr: return arr n = len(arr) gap = n shrink_factor = 1.3 sorted_ = False while gap > 1 or not sorted_: gap = max(1, int(gap / shrink_factor)) sorted_ = True for i in range(0, n - gap): if arr[i] > arr[i + gap]: arr[i], arr[i + gap] = arr[i + gap], arr[i] sorted_ = False # Switch to insertion sort if gap is 1 if gap == 1 and not sorted_: insertion_sort(arr, 0, n - 1) break return arr"},{"question":"# Bogo Sort Verification You have studied the concept and complexities of Bogo Sort, a highly inefficient sorting algorithm. As a programming challenge, your task is to not only implement Bogo Sort but also ensure to leverage the information provided in the analysis. Problem Statement Implement a function `bogo_sort_with_verification` which sorts an array using the Bogo Sort algorithm and also verifies the correctness of the implementation. Additionally, the function should avoid infinite loops by setting a maximum iteration limit to prevent endless execution in our inefficient sort attempt. Requirements 1. Implement the Bogo Sort algorithm. 2. Check if the array is already sorted at the beginning. 3. Shuffle the array until it becomes sorted or a maximum of 10000 iterations is reached. Input and Output * **Input**: * `arr` (List[int]): A list of integers to be sorted. * **Output**: * List[int]: The sorted list. * If the array could not be sorted within the iteration limit, return the original array. Constraints * The array length n (1 ≤ n ≤ 100). * Each number in the array will be in the range [-10^6, 10^6]. Implementation ```python import random def bogo_sort_with_verification(arr): def is_sorted(arr): for i in range(len(arr) - 1): if arr[i] > arr[i + 1]: return False return True max_iterations = 10000 iterations = 0 while not is_sorted(arr) and iterations < max_iterations: random.shuffle(arr) iterations += 1 return arr # Example Test print(bogo_sort_with_verification([3, 2, 5, 1, 4])) # Possible sorted output: [1, 2, 3, 4, 5] print(bogo_sort_with_verification([1, 2, 3, 4])) # Already sorted: [1, 2, 3, 4] print(bogo_sort_with_verification([5, 4, 3, 2, 1])) # Possible sorted output: [1, 2, 3, 4, 5] ``` Make sure your code handles various scenarios gracefully, including edge cases and performance constraints.","solution":"import random def bogo_sort_with_verification(arr): def is_sorted(arr): for i in range(len(arr) - 1): if arr[i] > arr[i + 1]: return False return True max_iterations = 10000 iterations = 0 while not is_sorted(arr) and iterations < max_iterations: random.shuffle(arr) iterations += 1 return arr"},{"question":"**Problem Statement: Regular Expression Matcher** You are required to implement a function that determines whether a given input string matches a given pattern. The pattern supports two special characters: 1. `.` which matches any single character. 2. `*` which matches zero or more of the preceding element. The matching should cover the entire input string (not partial). # Function Signature ```python def is_match(s: str, p: str) -> bool: ``` # Input - `s` (1 ≤ |s| ≤ 1000): The input string comprising lowercase English letters. - `p` (1 ≤ |p| ≤ 1000): The pattern string comprising lowercase English letters and the special characters `.` and `*`. # Output - Returns `True` if the entire input string matches the pattern, otherwise `False`. # Constraints - `p` will not contain consecutive `*`. # Examples Example 1 ```python is_match(\\"aa\\", \\"a\\") # Output: False ``` Example 2 ```python is_match(\\"aa\\", \\"aa\\") # Output: True ``` Example 3 ```python is_match(\\"aa\\", \\"a*\\") # Output: True ``` Example 4 ```python is_match(\\"ab\\", \\".*\\") # Output: True ``` Example 5 ```python is_match(\\"aab\\", \\"c*a*b\\") # Output: True ``` # Performance Requirements - Your solution should be optimized for performance and should ideally have a time complexity of O(nm) and a space complexity of O(nm), where n is the length of the input string and m is the length of the pattern. # Note Consider all edge cases including patterns with no wildcards, patterns with `*` at various positions, and patterns with mixed `.` and `*` characters.","solution":"def is_match(s: str, p: str) -> bool: # Create a DP table, initialized to False dp = [[False] * (len(p) + 1) for _ in range(len(s) + 1)] # Base case: empty string matches with empty pattern dp[0][0] = True # Fill the table for the case of patterns like a* or a*b* for j in range(2, len(p) + 1): if p[j - 1] == \'*\': dp[0][j] = dp[0][j - 2] # Fill the rest of the table for i in range(1, len(s) + 1): for j in range(1, len(p) + 1): if p[j - 1] == s[i - 1] or p[j - 1] == \'.\': dp[i][j] = dp[i - 1][j - 1] elif p[j - 1] == \'*\': dp[i][j] = dp[i][j - 2] or (dp[i - 1][j] and (s[i - 1] == p[j - 2] or p[j - 2] == \'.\')) return dp[len(s)][len(p)]"},{"question":"Optimal Matrix Chain Multiplication You are given a sequence of matrices, and you have to determine the most efficient way to multiply these matrices together. The problem is not to perform the multiplications, but merely to decide the sequence of the matrix multiplications. We wish to minimize the number of scalar multiplications. Write a function `matrix_chain_order(array: List[int]) -> Tuple[List[List[int]], List[List[int]]]` that receives an array where each element represents the matrix dimensions (i.e., for matrices ( A1, A2, ldots, An ), the input array will have ( n+1 ) numbers representing the dimensions of each matrix such that ( A1 ) is of dimension ( array[0] times array[1] ), ( A2 ) is of dimension ( array[1] times array[2] ), etc.). The function should output a tuple containing two 2D lists: 1. The first list holds the minimum cost of performing matrix multiplications. 2. The second list holds the split points to construct the optimal order of multiplication. Additionally, implement a function `print_optimal_solution(solution: List[List[int]], i: int, j: int) -> None` that prints the optimal order of matrix multiplications using the results from your `matrix_chain_order` function. # Input * `array`: A list of integers representing the dimensions of matrices (length is ( n+1 )). # Output * Tuple of two lists where the first list provides the minimum cost of matrix multiplications and the second list provides the optimal split points. # Constraints * The length of the `array` ( n ) will be between 2 and 100, inclusive. * Values in `array` are positive integers and will not exceed 500. # Example ```python def main(): array = [30, 35, 15, 5, 10, 20, 25] min_cost, optimal_solution = matrix_chain_order(array) print(\\"Minimum number of operations required: \\", min_cost[1][len(array)-1]) print(\\"Optimal order of multiplications: \\") print_optimal_solution(optimal_solution, 1, len(array)-1) if __name__ == \\"__main__\\": main() ``` Output: ``` Minimum number of operations required: 15125 Optimal order of multiplications: ((A1 (A2 A3)) ((A4 A5) A6)) ``` # Notes * Ensure that your solution provides clear and accurate computation of both the minimum cost and the optimal order of multiplications. * You don\'t need to handle cases where matrices cannot be multiplied due to mismatched dimensions.","solution":"from typing import List, Tuple def matrix_chain_order(array: List[int]) -> Tuple[List[List[int]], List[List[int]]]: n = len(array) - 1 # Initialize the cost and split tables cost = [[0 for _ in range(n + 1)] for _ in range(n + 1)] split = [[0 for _ in range(n + 1)] for _ in range(n + 1)] # Fill the tables using dynamic programming for l in range(2, n + 1): # l is the chain length for i in range(1, n - l + 2): j = i + l - 1 cost[i][j] = float(\'inf\') for k in range(i, j): q = cost[i][k] + cost[k + 1][j] + array[i - 1] * array[k] * array[j] if q < cost[i][j]: cost[i][j] = q split[i][j] = k return cost, split def print_optimal_solution(solution: List[List[int]], i: int, j: int) -> None: if i == j: print(f\\"A{i}\\", end=\\"\\") else: print(\\"(\\", end=\\"\\") print_optimal_solution(solution, i, solution[i][j]) print_optimal_solution(solution, solution[i][j] + 1, j) print(\\")\\", end=\\"\\")"},{"question":"# Task Implement a function `count_keys` to count the total number of keys in a B-tree that fall within a given range `[low, high]`. Assume the B-tree class and its functions (`insert_key`, `find`, etc.) are already implemented as shown in the initial code snippets. # Scenario You work as a developer in a software company that designs efficient data retrieval systems for databases. Your task is to extend the functionality of the existing B-Tree implementation to support ranged key queries, which will help to quickly filter and fetch data within specific ranges without traversing all the nodes. # Function Signature ```python def count_keys(btree: BTree, low: int, high: int) -> int: pass ``` # Input - A `BTree` instance. - Two integers `low` and `high` representing the range of the keys to be counted. # Output - An integer representing the number of keys in the B-tree that lie within the given range `[low, high]`. # Constraints - `low` ≤ `high`. - All keys in the B-tree and the values of `low` and `high` are integers. # Example ```python # Create a B-tree of order 3 (t=3) btree = BTree(t_val=3) # Insert keys into the B-tree keys_to_insert = [10, 20, 5, 6, 12, 30, 7, 17] for key in keys_to_insert: btree.insert_key(key) # Count the number of keys within the range [6, 20] print(count_keys(btree, 6, 20)) # Output: 6 (Keys within range are: 6, 7, 10, 12, 17, 20) ``` # Notes - Your function should leverage the existing tree traversal mechanisms to efficiently count the keys. - The implementation should ensure optimal performance, avoiding unnecessary traversals. - Handle any edge cases such as empty trees or ranges that do not contain any keys.","solution":"def count_keys(btree, low, high): Count the number of keys in the B-tree that fall within the range [low, high]. def count_keys_in_node(node, low, high): if node is None: return 0 count = 0 i = 0 # Count the keys in this node that fall within [low, high] while i < len(node.keys) and node.keys[i] < low: i += 1 while i < len(node.keys) and node.keys[i] <= high: count += 1 i += 1 # If the node is a leaf, return count if node.is_leaf: return count # Otherwise, count the keys in child nodes recursively for j in range(len(node.keys) + 1): if j == len(node.keys) or node.keys[j] > low: count += count_keys_in_node(node.children[j], low, high) if j < len(node.keys) and node.keys[j] > high: break return count return count_keys_in_node(btree.root, low, high)"},{"question":"# Matrix Transformations Question Objective Write a function to perform a specified transformation on a square matrix. Function Signature ```python def transform_matrix(matrix: List[List[int]], operation: str) -> List[List[int]]: pass ``` Input * `matrix`: A 2D list of integers representing a square matrix (N x N). * `operation`: A string indicating the type of transformation. The possible values are: - `\\"rotate_clockwise\\"`: Rotate the matrix 90 degrees clockwise. - `\\"rotate_counterclockwise\\"`: Rotate the matrix 90 degrees counterclockwise. - `\\"top_left_invert\\"`: Mirror the matrix along the top left to bottom right diagonal. - `\\"bottom_left_invert\\"`: Mirror the matrix along the bottom left to top right diagonal. Output * Returns a new 2D list of integers representing the transformed matrix. Constraints * 1 ≤ N ≤ 100 (where N is the number of rows/columns in the matrix) * The matrix is guaranteed to be square (i.e., all rows have equal length). Example ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] transform_matrix(matrix, \\"rotate_clockwise\\") # Output: # [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] transform_matrix(matrix, \\"rotate_counterclockwise\\") # Output: # [ # [3, 6, 9], # [2, 5, 8], # [1, 4, 7] # ] transform_matrix(matrix, \\"top_left_invert\\") # Output: # [ # [1, 4, 7], # [2, 5, 8], # [3, 6, 9] # ] transform_matrix(matrix, \\"bottom_left_invert\\") # Output: # [ # [9, 6, 3], # [8, 5, 2], # [7, 4, 1] # ] ``` Explanation 1. In the \\"rotate_clockwise\\" operation, matrix elements are rotated 90 degrees to the right. 2. In the \\"rotate_counterclockwise\\" operation, matrix elements are rotated 90 degrees to the left. 3. In the \\"top_left_invert\\" operation, elements are mirrored along the diagonal from the top-left to the bottom-right. 4. In the \\"bottom_left_invert\\" operation, elements are mirrored along the diagonal from the bottom-left to the top-right.","solution":"from typing import List def transform_matrix(matrix: List[List[int]], operation: str) -> List[List[int]]: n = len(matrix) if operation == \\"rotate_clockwise\\": return [[matrix[n - j - 1][i] for j in range(n)] for i in range(n)] elif operation == \\"rotate_counterclockwise\\": return [[matrix[j][n - i - 1] for j in range(n)] for i in range(n)] elif operation == \\"top_left_invert\\": return [[matrix[j][i] for j in range(n)] for i in range(n)] elif operation == \\"bottom_left_invert\\": return [[matrix[n - j - 1][n - i - 1] for j in range(n)] for i in range(n)] else: raise ValueError(f\\"Unsupported operation: {operation}\\")"},{"question":"# Context You are tasked with designing an automated seat reservation system that uses a 2D grid to represent seats in a movie theater, where each seat has a specific price. The grid is sorted in a non-decreasing order both row-wise and column-wise, reflecting ticket pricing from cheapest to most expensive. # Task Write a function to determine if a specific ticket price is available in the grid and locate its position. If the price is found, return the row and column index (both 0-based) of the first occurrence. If not found, return (-1, -1). # Function Signature ```python def find_ticket_price(seats: List[List[int]], price: int) -> Tuple[int, int]: ... ``` # Input * `seats`: A list of lists of integers representing the seat prices in the theater (sorted in non-decreasing order both row-wise and column-wise). * `price`: An integer representing the target seat price to search for. # Output * A tuple of two integers representing the row and column index of the seat price if found, otherwise (-1, -1). # Constraints * The dimensions of the matrix will be in the range from 0 to 1000 (inclusive). * The prices in the matrix are non-negative integers. # Example ```python seats = [ [2, 5, 7], [4, 8, 13], [9, 11, 15], [12, 17, 20] ] price = 13 assert find_ticket_price(seats, price) == (1, 2) ``` # Additional Test Cases 1. **Case with the price not present**: ```python seats = [ [2, 5, 7], [4, 8, 13], [9, 11, 15], [12, 17, 20] ] price = 14 assert find_ticket_price(seats, price) == (-1, -1) ``` 2. **Case with the price being the smallest**: ```python seats = [ [2, 5, 7], [4, 8, 13], [9, 11, 15], [12, 17, 20] ] price = 2 assert find_ticket_price(seats, price) == (0, 0) ``` 3. **Case with the price being the largest**: ```python seats = [ [2, 5, 7], [4, 8, 13], [9, 11, 15], [12, 17, 20] ] price = 20 assert find_ticket_price(seats, price) == (3, 2) ```","solution":"from typing import List, Tuple def find_ticket_price(seats: List[List[int]], price: int) -> Tuple[int, int]: Finds the ticket price in a 2D grid of seat prices. Returns the position (row, column) of the price if found, otherwise returns (-1, -1). :param seats: List of lists representing the seat prices in the theater. :param price: The target price to search for. :return: A tuple of two integers representing the row and column index if the price is found, otherwise (-1, -1). if not seats or not seats[0]: return (-1, -1) rows = len(seats) cols = len(seats[0]) # Start from the top-right corner row = 0 col = cols - 1 while row < rows and col >= 0: if seats[row][col] == price: return (row, col) elif seats[row][col] > price: col -= 1 else: row += 1 return (-1, -1)"},{"question":"**Problem Description**: You are given a stack of integers. Your task is to switch successive pairs of elements starting from the bottom of the stack using the least possible auxiliary storage. If there is an odd number of elements in the stack, the element at the top should remain unchanged. You need to implement the function `optimized_switch_pairs(stack)` that switches the pairs. # Function Signature: ```python def optimized_switch_pairs(stack: list[int]) -> list[int]: ``` # Input: - A stack represented as a list of integers containing `n` integers, where `n` is in the range `[0, 10^4]`. # Output: - The stack with successive pairs of elements switched, maintaining the stack properties. # Constraints: 1. Avoid using additional lists or stacks for auxiliary storage. 2. The operations should be completed in linear time. 3. You are allowed to use other fundamental data structures like a deque for temporary storage but ensure efficient usage. # Examples: 1. **Example 1**: ```python stack = [3, 8, 17, 9, 1, 10] assert optimized_switch_pairs(stack) == [8, 3, 9, 17, 10, 1] ``` 2. **Example 2**: ```python stack = [3, 8, 17, 9, 1] assert optimized_switch_pairs(stack) == [8, 3, 9, 17, 1] ``` 3. **Example 3**: ```python stack = [] assert optimized_switch_pairs(stack) == [] ``` 4. **Example 4**: ```python stack = [1] assert optimized_switch_pairs(stack) == [1] ``` # Instructions: 1. Implement the function `optimized_switch_pairs` following the described input and output specifications. 2. Ensure your function handles all edge cases including empty stacks and stacks with an odd number of elements. 3. Strive for an efficient implementation in terms of time and space complexity.","solution":"def optimized_switch_pairs(stack): Switches successive pairs of elements starting from the bottom of the stack. If the stack has an odd number of elements, the top element remains unchanged. n = len(stack) i = 0 while i + 1 < n: # Swap elements at positions i and i+1 stack[i], stack[i + 1] = stack[i + 1], stack[i] # Move to the next pair of elements i += 2 return stack"},{"question":"# Flatten Nested Arrays Objective You are provided with a function to flatten nested arrays, which could additionally contain other iterable types including strings. Problem Description Implement a function `flatten(input_arr)` that takes a nested list (or similar iterable) and returns a flat list containing all the leaf elements, preserving their original order. Function Signature ```python def flatten(input_arr): pass ``` Input - `input_arr`: A nested list, which can contain integer, string, other iterables, or any mix thereof. Strings should be treated as atomic elements, not iterables. Output - Returns a flat list with all elements from the input iterable structure. Constraints - The input may include deeply nested arrays. - Strings should be treated as single elements and not flattened. Examples 1. **Example 1:** ```python input_arr = [1, [2, [3, 4], 5], 6] output = flatten(input_arr) # Output: [1, 2, 3, 4, 5, 6] ``` 2. **Example 2:** ```python input_arr = [[\'one\', \'two\'], [\'three\', [\'four\', \'five\']]] output = flatten(input_arr) # Output: [\'one\', \'two\', \'three\', \'four\', \'five\'] ``` 3. **Example 3:** ```python input_arr = [1, [2, [3, \'four\', [\'five\']]], \'six\'] output = flatten(input_arr) # Output: [1, 2, 3, \'four\', \'five\', \'six\'] ``` Additional Information - You should not use any external libraries to solve this problem. - Recursively process each element in the input to accommodate arbitrarily nested arrangements. **Note**: Define clear base and recursive cases to ensure effective handling of all possible nested structures without causing infinite recursion.","solution":"def flatten(input_arr): Flatten a nested list (or similar iterables) into a flat list. Args: input_arr (iterable): A nested list or iterable to flatten. Returns: list: A flat list containing all the leaf elements, preserving their original order. result = [] if not isinstance(input_arr, (list, tuple)): return [input_arr] for element in input_arr: if isinstance(element, (list, tuple)): result.extend(flatten(element)) else: result.append(element) return result"},{"question":"Problem Statement Given a list of integers, implement a sorting function `custom_exchange_sort(arr)` which sorts the list in ascending order using the Exchange Sort algorithm. Ensure your function handles various edge cases appropriately. # Function Signature ```python def custom_exchange_sort(arr: List[int]) -> List[int]: ``` # Input * `arr` (List[int]): A list of integers. # Output * (List[int]): A list of integers sorted in ascending order. # Constraints * The list `arr` can have up to 10^3 elements. * Integer values can be positive or negative and can range between -10^5 to 10^5. # Performance Requirements Your implementation must sort the list correctly but does not need to be optimized beyond the basic Exchange Sort algorithm. # Example ```python assert custom_exchange_sort([34, -2, 78, 3, 0, 56, -45]) == [-45, -2, 0, 3, 34, 56, 78] assert custom_exchange_sort([1, 3, 2, 5, 4]) == [1, 2, 3, 4, 5] assert custom_exchange_sort([]) == [] assert custom_exchange_sort([42]) == [42] ``` # Context Imagine you\'re an early software developer in the era before more efficient algorithms like Quick Sort or Merge Sort were discovered. Your task is to implement this basic sorting method to gain insights into fundamental sorting techniques.","solution":"def custom_exchange_sort(arr): Sorts a list of integers using the Exchange Sort algorithm. n = len(arr) for i in range(n): for j in range(i + 1, n): if arr[i] > arr[j]: arr[i], arr[j] = arr[j], arr[i] return arr"},{"question":"**Scenario**: You are tasked to design a network of roads connecting several towns in a region. To minimize cost, you want to ensure the total length of roads built is the smallest possible, yet every town is reachable from any other town. **Task**: Implement a function `network_optimization` that calculates the minimum cost to construct the roads using Prim\'s Algorithm. # Function Signature ```python def network_optimization(graph: Dict[int, List[Tuple[int, int]]]) -> int: pass ``` # Input * `graph`: A dictionary representing the weighted graph, where the key is an integer node, and the value is a list of tuples. Each tuple contains an integer (the weight/cost of the edge) and an adjacent node. Example: ```python graph = { 1: [(3, 2), (8, 3)], 2: [(3, 1), (5, 4)], 3: [(8, 1), (2, 4), (4, 5)], 4: [(5, 2), (2, 3), (6, 5)], 5: [(4, 3), (6, 4)], } ``` # Output * Return an integer, representing the minimum total weight required to connect all nodes in the given graph. # Constraints * 1 <= |V| <= 10^3 (number of vertices) * |E| <= 10^4 (number of edges) * 1 <= weight <= 10^6 (weight/cost of each edge) # Example ```python graph = { 0: [(3, 1), (8, 2)], 1: [(3, 0), (5, 3)], 2: [(8, 0), (2, 3), (4, 4)], 3: [(5, 1), (2, 2), (6, 4)], 4: [(4, 2), (6, 3)] } print(network_optimization(graph)) # Output: 14 ``` # Explanation In the example, the minimum spanning tree connects all the nodes (towns) with a total road cost of 14.","solution":"import heapq from typing import Dict, List, Tuple def network_optimization(graph: Dict[int, List[Tuple[int, int]]]) -> int: Implements Prim\'s Algorithm to calculate the minimum cost to construct roads connecting all towns. # Number of nodes num_nodes = len(graph) # Start with an arbitrary node (node 0 in this case) start_node = next(iter(graph)) # Min-Heap to store the edges with their respective weights min_heap = [(0, start_node)] # Set to keep track of the nodes which are included in MST in_mst = set() # Total weight of the MST total_cost = 0 while min_heap and len(in_mst) < num_nodes: weight, node = heapq.heappop(min_heap) if node in in_mst: continue # Include the node in MST in_mst.add(node) total_cost += weight # Add all neighbors to the heap for edge_weight, neighbor in graph[node]: if neighbor not in in_mst: heapq.heappush(min_heap, (edge_weight, neighbor)) # If all nodes are included in MST if len(in_mst) == num_nodes: return total_cost else: # If the graph is not connected and MST is not possible return float(\'inf\')"},{"question":"# Roman Numeral to Integer Roman numerals are represented by seven different symbols: I, V, X, L, C, D, and M. | Symbol | Value | |--------|-------| | I | 1 | | V | 5 | | X | 10 | | L | 50 | | C | 100 | | D | 500 | | M | 1000 | For example, two is written as II in Roman numeral, just two one\'s added together. Twelve is written as, XII, which is simply X + II. The number twenty-seven is written as XXVII, which is XX + V + II. Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used: * I can be placed before V (5) and X (10) to make 4 and 9. * X can be placed before L (50) and C (100) to make 40 and 90. * C can be placed before D (500) and M (1000) to make 400 and 900. Given a Roman numeral, convert it to an integer. # Function Signature ```python def roman_to_int(s: str) -> int: pass ``` # Input * A single string `s` representing a Roman numeral. * Guaranteed constraints: * 1 ≤ `len(s)` ≤ 15 * The input string `s` will be a valid Roman numeral in the range from 1 to 3999. # Output * An integer representing the converted value of the Roman numeral. # Example ```python assert roman_to_int(\\"III\\") == 3 assert roman_to_int(\\"IV\\") == 4 assert roman_to_int(\\"IX\\") == 9 assert roman_to_int(\\"LVIII\\") == 58 assert roman_to_int(\\"MCMXCIV\\") == 1994 ``` # Notes In the function `roman_to_int`: 1. You should iterate over the string `s` and use a lookup table (dictionary) to map Roman numerals to their integer values. 2. Pay attention to the subtraction rule and handle it appropriately as described.","solution":"def roman_to_int(s: str) -> int: Converts a Roman numeral to an integer. roman_to_value = { \'I\': 1, \'V\': 5, \'X\': 10, \'L\': 50, \'C\': 100, \'D\': 500, \'M\': 1000 } total = 0 prev_value = 0 for char in reversed(s): value = roman_to_value[char] if value < prev_value: total -= value else: total += value prev_value = value return total"},{"question":"Implement a Secure Diffie-Hellman Key Exchange You have been given the task to implement a secure key exchange protocol using the Diffie-Hellman algorithm. The objective is to generate a shared secret key between two parties (Alice and Bob) over an unsecured communication channel. # Requirements 1. **Prime Number Validation** - Implement a function `is_prime(n)` that checks if a given number `n` is a prime. - Time Complexity: O(sqrt(n)). 2. **Primitive Root Calculation** - Implement a function `find_primitive_root(p)` that finds and returns a list of all primitive roots for a prime number `p`. 3. **Private and Public Key Generation** - Implement functions `generate_private_key(p)` and `generate_public_key(private_key, primitive_root, p)` to generate private and public keys, respectively. 4. **Shared Key Generation** - Implement a function `compute_shared_key(public_key_other, private_key, p)` to compute the shared secret key. 5. **Complete Key Exchange Process** - Implement a function `diffie_hellman_key_exchange(p, primitive_root, verbose=False)` that uses the above functions to simulate Alice and Bob exchanging keys and computing the shared secret. # Function Signatures ```python def is_prime(n: int) -> bool: pass def find_primitive_root(p: int) -> list: pass def generate_private_key(p: int) -> int: pass def generate_public_key(private_key: int, primitive_root: int, p: int) -> int: pass def compute_shared_key(public_key_other: int, private_key: int, p: int) -> int: pass def diffie_hellman_key_exchange(p: int, primitive_root: int, verbose: bool = False) -> bool: pass ``` # Constraints - `p` will always be a prime number. - The `primitive_root` will always be a valid primitive root of `p`. - `1 <= p <= 2^31 - 1` - The random private keys should be in the range `[1, p-1]`. # Example ```python p = 23 primitive_root = 5 # Expected Output (keys will vary due to randomness): # Alice\'s private key, public key # Bob\'s private key, public key # shared key by Alice # shared key by Bob ``` **Note**: Ensure the shared keys computed by Alice and Bob match. # Evaluation Criteria - Correct implementation of the key exchange protocol. - Adherence to security aspects mentioned. - Efficient use of algorithms to handle large primes.","solution":"import random from math import gcd from sympy import isprime def is_prime(n: int) -> bool: Check if a number n is a prime number. Time Complexity: O(sqrt(n)) if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def find_primitive_root(p: int) -> int: Find a primitive root for prime p. if not is_prime(p): raise ValueError(\\"Provided number is not prime\\") phi = p - 1 factors = set() # Find all prime factors of phi n = phi for i in range(2, int(phi ** 0.5) + 1): if n % i == 0: factors.add(i) while n % i == 0: n //= i if n > 1: factors.add(n) for g in range(2, p): if all(pow(g, phi // factor, p) != 1 for factor in factors): return g return -1 def generate_private_key(p: int) -> int: Generate a private key in the range [1, p-1]. return random.randint(1, p - 1) def generate_public_key(private_key: int, primitive_root: int, p: int) -> int: Generate a public key using the private key and primitive root. return pow(primitive_root, private_key, p) def compute_shared_key(public_key_other: int, private_key: int, p: int) -> int: Compute the shared secret key using the other party\'s public key and own private key. return pow(public_key_other, private_key, p) def diffie_hellman_key_exchange(p: int, primitive_root: int, verbose: bool = False) -> bool: Simulate the Diffie-Hellman key exchange process. # Alice\'s private key and public key alice_private_key = generate_private_key(p) alice_public_key = generate_public_key(alice_private_key, primitive_root, p) # Bob\'s private key and public key bob_private_key = generate_private_key(p) bob_public_key = generate_public_key(bob_private_key, primitive_root, p) # Compute shared keys shared_key_alice = compute_shared_key(bob_public_key, alice_private_key, p) shared_key_bob = compute_shared_key(alice_public_key, bob_private_key, p) if verbose: print(f\\"Alice\'s Private Key: {alice_private_key}\\") print(f\\"Alice\'s Public Key: {alice_public_key}\\") print(f\\"Bob\'s Private Key: {bob_private_key}\\") print(f\\"Bob\'s Public Key: {bob_public_key}\\") print(f\\"Shared Key (Alice): {shared_key_alice}\\") print(f\\"Shared Key (Bob): {shared_key_bob}\\") # The shared keys should be the same return shared_key_alice == shared_key_bob"},{"question":"As a software engineer, you are given a task to manipulate a stack such that successive pairs of numbers are switched starting from the bottom of the stack. This task has practical relevance in systems where stack-based data interchange or transformation is required. Write a function `switch_pairs_using_stack` that: - Accepts a list representing a stack of integers. - Uses a stack as auxiliary storage to switch successive pairs of numbers starting at the bottom of the stack. Additionally, write a function `switch_pairs_using_queue` that: - Accepts a list representing a stack of integers. - Uses a queue as auxiliary storage to switch successive pairs of numbers starting at the bottom of the stack. Both functions should return the modified stack after the switching operation. # Function Signatures ```python def switch_pairs_using_stack(stack: List[int]) -> List[int]: pass def switch_pairs_using_queue(stack: List[int]) -> List[int]: pass ``` # Input - `stack`: A list of integers representing the stack, where the end of the list is considered the top of the stack. # Output - Returns the modified stack as a list of integers after performing the switch. # Constraints - The stack contains non-negative integers. - The stack has at most (10^4) elements. # Example ```python # Example 1 stack = [3, 8, 17, 9, 1, 10] # Output for both functions: [8, 3, 9, 17, 10, 1] # Example 2 stack = [3, 8, 17, 9, 1] # Output for both functions: [8, 3, 9, 17, 1] # Example 3 stack = [] # Output for both functions: [] # Example 4 stack = [7] # Output for both functions: [7] ``` # Additional Notes - Ensure that the performance is considered for large stacks within the given constraints. - Assume that your environment provides necessary stack and queue libraries if using special collections.","solution":"from typing import List def switch_pairs_using_stack(stack: List[int]) -> List[int]: aux_stack = [] while stack: aux_stack.append(stack.pop()) while aux_stack: if len(aux_stack) >= 2: first = aux_stack.pop() second = aux_stack.pop() stack.append(second) stack.append(first) else: stack.append(aux_stack.pop()) return stack def switch_pairs_using_queue(stack: List[int]) -> List[int]: from collections import deque aux_queue = deque() while stack: aux_queue.appendleft(stack.pop()) while aux_queue: if len(aux_queue) >= 2: first = aux_queue.popleft() second = aux_queue.popleft() stack.append(second) stack.append(first) else: stack.append(aux_queue.popleft()) return stack"},{"question":"# Question: Implement and Manipulate a Doubly Linked List The `DoublyLinkedListNode` class is provided to represent nodes in a doubly linked list. Your task is to implement a `DoublyLinkedList` class with the following functionalities: 1. **Insert at Beginning**: Insert a node at the beginning of the list. 2. **Insert at End**: Insert a node at the end of the list. 3. **Delete Node**: Delete a specified node from the list. 4. **Search**: Search for a node by value and return the node reference. # DoublyLinkedList Class Specification 1. **Class Name**: `DoublyLinkedList` 2. **Attributes**: * `head`: Reference to the first node. * `tail`: Reference to the last node. 3. **Methods**: * `insert_at_beginning(value)`: Inserts a node with the given value at the beginning of the list. * `insert_at_end(value)`: Inserts a node with the given value at the end of the list. * `delete_node(node)`: Deletes the specified node from the list. * `search(value)`: Searches for a node containing the given value and returns a reference to it. # Constraints * The list can initially be empty. * Any value can be an integer or string. * You should handle edge cases like empty lists gracefully. # Example ```python dll = DoublyLinkedList() dll.insert_at_beginning(10) dll.insert_at_end(20) dll.insert_at_beginning(5) node = dll.search(10) dll.delete_node(node) ``` # Expected Output After the above operations, the list should contain the nodes with values [5, 20].","solution":"class DoublyLinkedListNode: def __init__(self, value): self.value = value self.next = None self.prev = None class DoublyLinkedList: def __init__(self): self.head = None self.tail = None def insert_at_beginning(self, value): new_node = DoublyLinkedListNode(value) if not self.head: self.head = new_node self.tail = new_node else: new_node.next = self.head self.head.prev = new_node self.head = new_node def insert_at_end(self, value): new_node = DoublyLinkedListNode(value) if not self.tail: self.head = new_node self.tail = new_node else: new_node.prev = self.tail self.tail.next = new_node self.tail = new_node def delete_node(self, node): if not node: return if node.prev: node.prev.next = node.next else: self.head = node.next if node.next: node.next.prev = node.prev else: self.tail = node.prev def search(self, value): current = self.head while current: if current.value == value: return current current = current.next return None"},{"question":"# Question: Implement a Square Root Finder As a software engineer at a precision engineering firm, you have been tasked with developing a utility function that calculates the square root of a given positive integer with high precision. The function should accept a positive integer `N` and a very small positive number `P` representing the precision. Your implementation should adhere to the following requirements: 1. The function should be named `find_square_root` and take two parameters: `n` (the integer whose square root needs to be found) and `epsilon` (the precision factor). 2. The function should return a floating-point number that is the square root of `n` with an absolute error no greater than `epsilon`. 3. Ensure that your function handles edge cases appropriately. # Input - An integer `n` where (1 ≤ n ≤ 10^9). - A floating-point number ε where (0 < ε ≤ 1e-3). # Output - A floating-point number representing the square root of `n` with an absolute error not exceeding ε. # Constraints - You should use the Newton\'s method to achieve the result. - Ensure that the function is efficient and terminates in a reasonable time for the given input constraints. # Example ```python def find_square_root(n: int, epsilon: float) -> float: pass # Example usage: result = find_square_root(5, 0.001) print(result) # Should print a number close to 2.236 result = find_square_root(10, 0.0001) print(result) # Should print a number close to 3.1623 ```","solution":"def find_square_root(n: int, epsilon: float) -> float: Returns the square root of `n` using Newton\'s method with an absolute error no greater than `epsilon`. if n <= 0: raise ValueError(\\"n should be a positive integer\\") if epsilon <= 0 or epsilon > 1e-3: raise ValueError(\\"epsilon should be a positive number not exceeding 1e-3\\") # Initial guess guess = n / 2.0 while abs(guess * guess - n) > epsilon: guess = (guess + n / guess) / 2.0 return guess"},{"question":"# Singly Linked List Reversal with Tail Element Retrieval You are tasked to reverse a singly linked list and also retrieve the original tail element. Implement the function `reverse_and_tail` that accepts the head of a singly linked list and returns a tuple containing the head of the reversed list and the original tail element\'s value. Do this with both iterative and recursive methods. Function Signature ```python def reverse_and_tail(head: ListNode) -> (ListNode, int): Reverses linked list and returns the new head and the original tail element\'s value. # Implement iterative and recursive solutions within this function ``` Input: - `head`: A `ListNode` representing the head of the singly linked list. (1 <= length of the linked list <= 10^4). - Each node in the list contains a single integer value. Output: - A tuple where: - The first element is the head of the reversed linked list. - The second element is the integer value of the original tail element of the list. Constraints: - Your algorithm should have O(n) time complexity. - For recursive solution, you should consider Python\'s maximum recursion limit for very large linked lists. Example: ```python # Example Linked List Node Definition class ListNode: def __init__(self, x): self.val = x self.next = None # Example Usage head = ListNode(1) head.next = ListNode(2) head.next.next = ListNode(3) head.next.next.next = ListNode(4) # Calling reverse_and_tail function new_head, original_tail = reverse_and_tail(head) # Output: The linked list should be reversed and return 4 as the original tail value. print(new_head.val) # Output: 4 print(original_tail) # Output: 4 ``` Note: - Assume the provided `ListNode` class as defined in the example should be used to create linked list nodes.","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def reverse_and_tail(head: ListNode) -> (ListNode, int): Reverses the linked list and returns the new head and the original tail element\'s value. Implements both iterative and recursive methods. if not head or not head.next: return head, head.val if head else None # Iterative method def reverse_iterative(head: ListNode) -> (ListNode, int): prev = None current = head original_tail_value = head.val while current: original_tail_value = current.val next_node = current.next current.next = prev prev = current current = next_node return prev, original_tail_value # Using the iterative method here since it\'s generally more space-efficient return reverse_iterative(head)"},{"question":"# Scenario You are tasked with implementing a library management system where query performance is crucial. The database must handle frequent insertions, deletions, and searches efficiently due to the large volume of data. # Task Implement a B-Tree to manage the library\'s book collection. Specifically, you need to implement the following functionalities using a B-Tree: 1. **Insert a Book**: Adds a new book to the collection. 2. **Delete a Book**: Removes a book from the collection. 3. **Check Availability**: Checks if a book is available in the collection. 4. **Traverse Library**: Retrieves a sorted list of all books in the collection. # Requirements - Implement the following methods in the BTree class: ```python def insert_book(self, book_id: int) -> None: Inserts a book with the given book_id into the B-Tree. def delete_book(self, book_id: int) -> None: Deletes the book with the given book_id from the B-Tree. def is_book_available(self, book_id: int) -> bool: Checks if a book with the given book_id is available in the B-Tree. def list_books(self) -> List[int]: Traverses the B-Tree and returns a list of all book IDs in ascending order. ``` - You are provided with the `Node` and `BTree` classes structure above for reference. # Constraints - Each book has a unique integer identifier (book_id). - The B-Tree should have a minimum degree t (t >= 2). # Performance Requirements - Your implementation should ensure that insertions, deletions, and searches are optimized for large datasets.","solution":"class Node: def __init__(self, t, leaf=False): self.t = t self.leaf = leaf self.keys = [] self.children = [] class BTree: def __init__(self, t): self.root = Node(t, True) self.t = t def insert_book(self, book_id: int) -> None: root = self.root if len(root.keys) == 2 * self.t - 1: temp = Node(self.t) self.root = temp temp.children.insert(0, root) self._split_child(temp, 0) self._insert_non_full(temp, book_id) else: self._insert_non_full(root, book_id) def _insert_non_full(self, node, book_id): i = len(node.keys) - 1 if node.leaf: node.keys.append(None) while i >= 0 and book_id < node.keys[i]: node.keys[i + 1] = node.keys[i] i -= 1 node.keys[i + 1] = book_id else: while i >= 0 and book_id < node.keys[i]: i -= 1 i += 1 if len(node.children[i].keys) == 2 * self.t - 1: self._split_child(node, i) if book_id > node.keys[i]: i += 1 self._insert_non_full(node.children[i], book_id) def _split_child(self, parent, i): t = self.t y = parent.children[i] z = Node(t, y.leaf) parent.children.insert(i + 1, z) parent.keys.insert(i, y.keys[t - 1]) z.keys = y.keys[t:(2 * t - 1)] y.keys = y.keys[0:(t - 1)] if not y.leaf: z.children = y.children[t:(2 * t)] y.children = y.children[:t] def delete_book(self, book_id: int) -> None: self._delete(self.root, book_id) if len(self.root.keys) == 0 and not self.root.leaf: self.root = self.root.children[0] def _delete(self, node, book_id): t = self.t if book_id in node.keys: idx = node.keys.index(book_id) if node.leaf: node.keys.pop(idx) else: self._delete_internal_node(node, book_id, idx) elif node.leaf: return else: i = self._find_key_idx(node, book_id) flag = (i == len(node.keys)) if len(node.children[i].keys) < t: self._fill(node, i) if flag and i > len(node.keys): self._delete(node.children[i - 1], book_id) else: self._delete(node.children[i], book_id) def _find_key_idx(self, node, book_id): for i, key in enumerate(node.keys): if book_id < key: return i return len(node.keys) def _delete_internal_node(self, node, book_id, idx): t = self.t if len(node.children[idx].keys) >= t: pred = self._get_predecessor(node, idx) node.keys[idx] = pred self._delete(node.children[idx], pred) elif len(node.children[idx + 1].keys) >= t: succ = self._get_successor(node, idx) node.keys[idx] = succ self._delete(node.children[idx + 1], succ) else: self._merge(node, idx) self._delete(node.children[idx], book_id) def _get_predecessor(self, node, idx): current = node.children[idx] while not current.leaf: current = current.children[len(current.keys)] return current.keys[-1] def _get_successor(self, node, idx): current = node.children[idx + 1] while not current.leaf: current = current.children[0] return current.keys[0] def _fill(self, node, idx): t = self.t if idx != 0 and len(node.children[idx - 1].keys) >= t: self._borrow_from_prev(node, idx) elif idx != len(node.keys) and len(node.children[idx + 1].keys) >= t: self._borrow_from_next(node, idx) else: if idx != len(node.keys): self._merge(node, idx) else: self._merge(node, idx - 1) def _borrow_from_prev(self, node, idx): child = node.children[idx] sibling = node.children[idx - 1] child.keys.insert(0, node.keys[idx - 1]) if not child.leaf: child.children.insert(0, sibling.children.pop()) node.keys[idx - 1] = sibling.keys.pop() def _borrow_from_next(self, node, idx): child = node.children[idx] sibling = node.children[idx + 1] child.keys.append(node.keys[idx]) if not child.leaf: child.children.append(sibling.children.pop(0)) node.keys[idx] = sibling.keys.pop(0) def _merge(self, node, idx): child = node.children[idx] sibling = node.children[idx + 1] t = self.t child.keys.append(node.keys.pop(idx)) child.keys.extend(sibling.keys) if not child.leaf: child.children.extend(sibling.children) node.children.pop(idx + 1) def is_book_available(self, book_id: int) -> bool: return self._search(self.root, book_id) def _search(self, node, key): i = 0 while i < len(node.keys) and key > node.keys[i]: i += 1 if i < len(node.keys) and key == node.keys[i]: return True if node.leaf: return False return self._search(node.children[i], key) def list_books(self) -> list: return self._traverse(self.root) def _traverse(self, node): books = [] for i in range(len(node.keys)): if not node.leaf: books.extend(self._traverse(node.children[i])) books.append(node.keys[i]) if not node.leaf: books.extend(self._traverse(node.children[len(node.keys)])) return books"},{"question":"# Unique Character Filter You are tasked with creating a function that processes a given string to remove any recurring characters, retaining only the first occurrence of each character and preserving the order they appear in the original string. Function Signature ```python def delete_reoccurring_characters(string: str) -> str: pass ``` Input * `string`: A string consisting of any combination of characters, including spaces and punctuation. Output * A string that contains only the first occurrence of each character from the input string, with their original order preserved. Constraints * The input string length will be between 0 and 10000 characters. * Only ASCII characters will be considered. Example ```python assert delete_reoccurring_characters(\'programming\') == \'progamin\' assert delete_reoccurring_characters(\'mississippi\') == \'misp\' assert delete_reoccurring_characters(\'\') == \'\' assert delete_reoccurring_characters(\'aabbcc\') == \'abc\' ``` Performance Requirements * The solution should run in linear time, O(n), in relation to the length of the input string. * Space complexity should also be linear, O(n), proportional to the number of distinct characters in the input string. Scenario Imagine you are developing a feature for a social media platform that prevents people from repeatedly typing the same characters in a username. Before storing the username in the database, you need to remove any repeated characters to maintain unique identifiers. Your task is to implement the function `delete_reoccurring_characters` that fulfills this requirement efficiently.","solution":"def delete_reoccurring_characters(string: str) -> str: Returns a string that contains only the first occurrence of each character from the input string, preserving the original order of characters. seen = set() result = [] for char in string: if char not in seen: seen.add(char) result.append(char) return \'\'.join(result)"},{"question":"You have been given the task to compute the n-th Fibonacci number. The Fibonacci sequence is defined as: [ F(0) = 0, F(1) = 1 ] [ F(n) = F(n-1) + F(n-2) text{ for } n geq 2 ] Write a function `nth_fibonacci(n: int) -> int` to calculate the n-th Fibonacci number efficiently. Implement your function in an optimal manner considering time and space complexities. You must handle the input where ( n ) can be very large. # Input Format * `n` - a non-negative integer (0 ≤ n ≤ 10^6) # Output Format * Returns the n-th Fibonacci number. # Constraints * You must implement the function to handle values of `n` up to ( 10^6 ). * The function should be efficient in terms of both time and space complexities. # Example * Example 1: * Input: n = 0 * Output: 0 * Example 2: * Input: n = 10 * Output: 55 * Example 3: * Input: n = 1000000 * Output: [Output will be a very large number] # Performance Requirements * Time Complexity: O(n) * Space Complexity: O(1) # Implementation Challenge Your implementation must handle large input sizes efficiently without causing memory overflow or excessive computation delay. Consider the iterative approach focused on optimizing space usage.","solution":"def nth_fibonacci(n: int) -> int: Efficiently calculates the n-th Fibonacci number using an iterative approach. if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"# Prime Number Identification for Large Data Sets Context: In many applications, determining whether numbers in a large dataset are prime is crucial. For instance, in cryptography and secure communications, prime numbers play a vital role in encryption algorithms. Given the importance of efficiency in processing large datasets, an optimized algorithm is necessary for checking the primality of numbers. Task: Implement a function `prime_check(n)` that determines if a number `n` is a prime number. Use an optimized approach to ensure it performs efficiently even for larger inputs. Your solution should handle edge cases and provide accurate results across the number spectrum. Function Signature: ```python def prime_check(n: int) -> bool: Returns True if n is a prime number, otherwise False. ``` Input Format: - An integer `n` where: -10^6 ≤ n ≤ 10^6 Output Format: - A boolean value: `True` if `n` is prime, otherwise `False`. Constraints: - Consider performance with upper-bound numbers. - You should handle both positive and negative integers. - The function should handle edge cases robustly. Examples: - `prime_check(5)` should return `True` - `prime_check(10)` should return `False` - `prime_check(-5)` should return `False` - `prime_check(2)` should return `True` - `prime_check(17)` should return `True` Additional Points: Implementations with unnecessary complexity or those failing to handle edge cases will be penalized. Aim for a balance between readability and performance.","solution":"def prime_check(n: int) -> bool: Returns True if n is a prime number, otherwise False. if n <= 1: return False if n == 2 or n == 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True"},{"question":"# Task: Polynomial Simplification **Scenario**: You are part of a team working on a computer algebra system. One crucial feature of this system is the ability to simplify polynomial expressions by combining like terms. **Objectives**: Given two polynomials, your task is to write a function that takes two `Polynomial` objects, adds them together, and returns a simplified polynomial where all like terms are combined. # Requirements * Implement a function `simplify_polynomial(poly1: Polynomial, poly2: Polynomial) -> Polynomial`. * The function takes two `Polynomial` objects `poly1` and `poly2` and returns their sum, simplified by combining like terms. # Input * `poly1` and `poly2`: Two `Polynomial` objects. # Output * A `Polynomial` object representing the sum of `poly1` and `poly2` with all like terms combined. # Constraints * Polynomials can have coefficients that are integers, floats, or fractions. * Variables in the monomials are represented by integer identifiers starting from 1. # Example ```python monomial1 = Monomial({1: 2}, 3) # Represents 3(a_1)^2 monomial2 = Monomial({2: 1}, 4) # Represents 4(a_2) monomial3 = Monomial({1: 2}, -2) # Represents -2(a_1)^2 poly1 = Polynomial([monomial1, monomial2]) # Represents 3(a_1)^2 + 4(a_2) poly2 = Polynomial([monomial3]) # Represents -2(a_1)^2 simplified_poly = simplify_polynomial(poly1, poly2) print(simplified_poly) ``` **Output**: ```plaintext (a_1)^2 + 4(a_2) ``` # Instructions 1. Implement the function `simplify_polynomial`. 2. Ensure that the function can handle edge cases where coefficients are zero or the monomial terms cancel out completely. 3. Thoroughly test your function with various cases to ensure correctness.","solution":"from collections import defaultdict class Monomial: def __init__(self, variables, coefficient): self.variables = variables # Dictionary {variable: exponent} self.coefficient = coefficient # Numeric value def __eq__(self, other): return self.variables == other.variables and self.coefficient == other.coefficient def __hash__(self): # Allow Monomial to be used as a key in a dictionary return hash((frozenset(self.variables.items()), self.coefficient)) def __repr__(self): var_repr = \'\'.join(f\\"(a_{k})^{v}\\" for k, v in sorted(self.variables.items())) return f\\"{self.coefficient}{var_repr}\\" class Polynomial: def __init__(self, monomials): self.monomials = monomials # List of Monomial objects def __eq__(self, other): if len(self.monomials) != len(other.monomials): return False for m1, m2 in zip(self.monomials, other.monomials): if m1 != m2: return False return True def __repr__(self): return \' + \'.join(map(str, self.monomials)) def simplify_polynomial(poly1, poly2): combined_monomials = defaultdict(int) all_monomials = poly1.monomials + poly2.monomials for monomial in all_monomials: key = frozenset(monomial.variables.items()) combined_monomials[key] += monomial.coefficient simplified_monomials = [ Monomial(dict(key), coeff) for key, coeff in combined_monomials.items() if coeff != 0 ] return Polynomial(simplified_monomials)"},{"question":"# Unique Number Finder Description You are given an array of integers where every element appears exactly twice, except for one element that appears exactly once. Write a function that finds the single number that appears only once, using linear runtime complexity and without using extra memory. Function Signature ```python def find_unique_number(arr: List[int]) -> int: pass ``` Input * `arr`: a list of integers where every element appears exactly twice except for one element which appears exactly once. - The length of the list will always be an odd number. - Each number in the array fits in a 32-bit signed integer. Output * Return a single integer that is the unique element. Constraints * Perform the operation in O(n) time where n is the number of elements in the array. * Use constant O(1) extra space. Example ```python assert find_unique_number([4, 1, 2, 1, 2]) == 4 assert find_unique_number([2, 2, 1]) == 1 assert find_unique_number([1]) == 1 ``` Explanation 1. In the first example, every element except number 4 appears exactly twice, hence the output is 4. 2. In the second example, each element except number 1 appears twice, hence the output is 1. 3. In the third example, since there is only one element, that element itself is the unique one, hence the output is 1.","solution":"from typing import List def find_unique_number(arr: List[int]) -> int: Finds the single number that appears only once in the array. Every other number appears exactly twice. unique_number = 0 for num in arr: unique_number ^= num return unique_number"},{"question":"# **Scenario:** You are working on a string manipulation library and need to implement a feature that reverses strings. The library will be used in various scenarios including web applications, data preprocessing, and cryptographic algorithms. # **Problem Statement:** Write a function `custom_reverse(s: str) -> str` that reverses a given string `s`. Your function should handle the base cases efficiently without running into performance issues or stack overflows. # **Function Signature:** ```python def custom_reverse(s: str) -> str: pass ``` # **Input Format:** - A single string `s` with a maximum length of (10^5). # **Output Format:** - Return the reversed string. # **Constraints:** - The string can contain any printable ASCII characters. - Your solution should handle performance efficiently, taking into consideration both time and space complexities. # **Example:** - **Input:** `\\"hello\\"` - **Output:** `\\"olleh\\"` - **Input:** `\\"123456789\\"` - **Output:** `\\"987654321\\"` # **Additional Requirements:** * Ensure that your implementation performs well with large inputs. * Handle edge cases appropriately, such as an empty string or very short strings (one or two characters). # **Hints:** * Consider using an iterative approach for efficiency. * Optimize for both time complexity and memory usage.","solution":"def custom_reverse(s: str) -> str: Returns the reverse of the given string `s`. return s[::-1]"},{"question":"# Intersection of Two Singly Linked Lists **Background**: In many real-world applications, it can be useful to determine the point at which two routes intersect. For this question, we will consider such routes represented as singly linked lists. Your task is to write a function that identifies the node where two singly linked lists intersect by reference. # Problem Statement: You are given two singly linked lists. Each linked list represents a sequence of nodes. Your task is to write a function that returns the node at which the two lists intersect. If the lists do not intersect, the function should return `None`. **Function Signature:** ```python def get_intersection_node(head1: \'Node\', head2: \'Node\') -> \'Node\': ``` **Input:** * `head1` (Node): The head of the first linked list. * `head2` (Node): The head of the second linked list. **Output:** * `Node`: The node where the two linked lists intersect, or `None` if no intersection exists. # Constraints: * The linked lists will be acyclic. * Each list could potentially be empty (i.e., the head node could be `None`). * The nodes in the linked lists reference objects of the class `Node`, provided as part of the problem. **Sample Nodes Class Implementation:** Below is the basic implementation of the `Node` class which you will use for this problem: ```python class Node: def __init__(self, x): self.val = x self.next = None ``` # Example: 1. Consider the linked lists: ``` List A: 1 -> 3 -> 5 7 -> 9 -> 11 / List B: 2 -> 4 -> 6 ``` Intersection Point: Node with value 7 ```python a1 = Node(1) b1 = Node(3) c1 = Node(5) d = Node(7) a2 = Node(2) b2 = Node(4) c2 = Node(6) e = Node(9) f = Node(11) a1.next = b1 b1.next = c1 c1.next = d a2.next = b2 b2.next = c2 c2.next = d d.next = e e.next = f ``` For the function call: `get_intersection_node(a1, a2)`, the expected output would be the node with value 7. # Additional Notes: * If the input lists do not intersect, your function should return `None`. * While the function needs to be efficient, remember to write clear and understandable code.","solution":"class Node: def __init__(self, x): self.val = x self.next = None def get_intersection_node(head1: \'Node\', head2: \'Node\') -> \'Node\': if not head1 or not head2: return None # Find the lengths of both linked lists def get_length(head): length = 0 current = head while current: length += 1 current = current.next return length length1 = get_length(head1) length2 = get_length(head2) # Align the start of both linked lists current1 = head1 current2 = head2 if length1 > length2: for _ in range(length1 - length2): current1 = current1.next else: for _ in range(length2 - length1): current2 = current2.next # Move in tandem until we find the intersection or reach the end of lists while current1 and current2: if current1 == current2: return current1 current1 = current1.next current2 = current2.next return None"},{"question":"# Fibonacci Sequence Computation Problem Statement You are tasked with computing the n-th Fibonacci number. As highlighted, there are multiple strategies to implement this computation. For this assessment, you are required to: 1. Implement a function that computes the n-th Fibonacci number using dynamic programming. 2. Implement a function that computes the n-th Fibonacci number iteratively. Your solution should handle cases efficiently, especially for larger n, and must not exceed O(n) time complexity. Function Signature ```python def fib_dynamic(n: int) -> int: Computes the n-th Fibonacci number using dynamic programming. Arguments: n {int} -- The position in the Fibonacci sequence. Returns: int -- The n-th Fibonacci number. pass def fib_iterative(n: int) -> int: Computes the n-th Fibonacci number using an iterative approach. Arguments: n {int} -- The position in the Fibonacci sequence. Returns: int -- The n-th Fibonacci number. pass ``` Constraints - The input number `n` will be a non-negative integer (0 <= n <= 10^4). Example Input and Output 1. **Dynamic Programming Method**: * Input: `fib_dynamic(10)` * Output: `55` * Input: `fib_dynamic(50)` * Output: `12586269025` 2. **Iterative Method**: * Input: `fib_iterative(10)` * Output: `55` * Input: `fib_iterative(50)` * Output: `12586269025` Performance Requirements Your implementations should run efficiently for the upper limits of `n` and must adhere to a time complexity of O(n). The space complexity for the iterative method should be O(1) and for the dynamic programming method should be O(n).","solution":"def fib_dynamic(n: int) -> int: Computes the n-th Fibonacci number using dynamic programming. Arguments: n {int} -- The position in the Fibonacci sequence. Returns: int -- The n-th Fibonacci number. if n <= 1: return n fib = [0] * (n + 1) fib[1] = 1 for i in range(2, n + 1): fib[i] = fib[i - 1] + fib[i - 2] return fib[n] def fib_iterative(n: int) -> int: Computes the n-th Fibonacci number using an iterative approach. Arguments: n {int} -- The position in the Fibonacci sequence. Returns: int -- The n-th Fibonacci number. if n <= 1: return n a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"**Problem Statement:** You are working as a software engineer for a startup company. The company requires a simple sorting method for its small datasets. They have chosen \'Exchange Sort\' due to its straightforward implementation. Your task is to implement this sorting algorithm in Python. The function should be named `exchange_sort` and should take a list of integers and return a sorted list. **Function Signature:** ```python def exchange_sort(arr: list[int]) -> list[int]: pass ``` **Input:** * `arr`: A list of integers (`1 <= len(arr) <= 10^3`, `-10^3 <= arr[i] <= 10^3`). **Output:** * A sorted list of integers in ascending order. **Constraints and Specifics:** * Your implementation must sort the list in place, using O(1) additional space. * Ensure your implementation handles edge cases like an empty list or a list already sorted. * Although the implementation doesn\'t need to be optimized for large datasets, it should successfully sort lists up to 1000 elements in size. **Example:** ```python assert exchange_sort([3, 1, 2]) == [1, 2, 3] assert exchange_sort([-1, -3, -2]) == [-3, -2, -1] assert exchange_sort([]) == [] ``` Ensure your algorithm is thoroughly tested with a variety of input cases to verify its correctness and efficiency.","solution":"def exchange_sort(arr: list[int]) -> list[int]: Sorts a list of integers using exchange sort, also known as bubble sort. n = len(arr) for i in range(n): for j in range(i + 1, n): if arr[i] > arr[j]: arr[i], arr[j] = arr[j], arr[i] return arr"},{"question":"# Scenario You are developing a software tool to analyze and visualize various properties of binary trees. One of the required functionalities is to perform tree traversals to obtain nodes in specific orders. # Task Implement a function for postorder traversal of a binary tree without using recursion. # Instructions 1. Implement the function `postorder_traversal(root: Node) -> List[int]` where: * `root` is the root node of the binary tree. * The function should return a list of integers representing the nodes\' values in postorder sequence. 2. Constraints: * The binary tree can have up to 10^4 nodes. * Node values are unique integers. * Node class is defined as follows: ```python class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right ``` # Example ```python # Define the tree # 1 # / # 2 3 # / # 4 5 root = Node(1, Node(2, Node(4), Node(5)), Node(3)) # Call the function print(postorder_traversal(root)) # Output: [4, 5, 2, 3, 1] ``` # Important Notes * Do not use recursion directly or indirectly in your function. * Aim for an efficient implementation with a time complexity of O(n).","solution":"class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right def postorder_traversal(root: Node) -> list[int]: if root is None: return [] stack1 = [root] stack2 = [] result = [] while stack1: node = stack1.pop() stack2.append(node) if node.left: stack1.append(node.left) if node.right: stack1.append(node.right) while stack2: node = stack2.pop() result.append(node.val) return result"},{"question":"# Prime Number Check with Optimization You are required to write a Python function `optimized_prime_check` that determines if a given integer ( n ) is a prime number. However, this function should include further optimizations to handle very large integers efficiently, going beyond the basic method provided. # Detailed Requirements 1. **Function Signature**: ```python def optimized_prime_check(n: int) -> bool: pass ``` 2. **Input**: - A single integer ( n ) where ( 1 leq n leq 10^{18} ). 3. **Output**: - Return `True` if ( n ) is a prime number, otherwise return `False`. 4. **Constraints**: - The function must be able to handle very large integer inputs efficiently. - Utilize both deterministic and probabilistic checks for optimization. - Consider edge cases properly. 5. **Performance**: - Use advanced algorithms to ensure the time complexity remains as low as possible, avoiding naive approaches. # Example Usage ```python print(optimized_prime_check(17)) # Should output: True print(optimized_prime_check(18)) # Should output: False print(optimized_prime_check(7919)) # Should output: True print(optimized_prime_check(10000000019)) # Should output: True or use advanced checking ``` # Additional Notes * Make sure to document your approach and the chosen algorithms for optimization. * Consider the trade-offs between accuracy and performance for primality testing at such large scales.","solution":"def optimized_prime_check(n: int) -> bool: Check if n is a prime number using advanced optimizations. This function uses a combination of deterministic checks and Miller-Rabin probabilistic primality test for efficient performance. Parameters: n (int): The number to check for primality Returns: bool: True if n is a prime number, False otherwise if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True"},{"question":"# Question: Implement an Advanced Markov Chain Simulator Context You are tasked with implementing an advanced Markov Chain simulator. This will be used to model a random process where the system transitions from one state to another based on a set of probabilities. You need to implement functionalities to simulate the transitions for a given number of steps and to handle incomplete or invalid Markov Chains gracefully. Requirements Implement a class named `MarkovChainSimulator` that allows for the creation and simulation of a Markov Chain from a given dictionary of state transitions. Specifications 1. `__init__(self, chain: dict)`: Constructor that initializes the Markov Chain with the given state transitions dictionary. 2. `next_state(self, current_state: str) -> str`: Method to get the next state based on the current state. 3. `simulate(self, start_state: str, steps: int) -> list`: Method to simulate the Markov Chain starting from a given initial state for a certain number of steps. 4. `validate_chain(self) -> bool`: Method to validate the Markov Chain (e.g., ensure probabilities sum to 1 for all states). Input Format * `chain`: A dictionary representing the Markov Chain, where keys are states and values are dictionaries of possible next states with their respective transition probabilities. * `start_state`: A string representing the starting state for the simulation. * `steps`: An integer representing the number of steps to simulate. Output Format * `next_state`: A string representing the next state chosen based on the current state probabilities. * `simulate`: A list of strings representing the sequence of states from the start state over the specified number of steps. * `validate_chain`: A boolean value indicating whether the Markov Chain is valid. Constraints * The `chain` dictionary may be incomplete or contain invalid probabilities, which should be detected and handled by `validate_chain`. * The transition probabilities for a state should sum to 1. Performance Requirements * Ensure that the `simulate` method performs efficiently even for large chains.","solution":"import random class MarkovChainSimulator: def __init__(self, chain): self.chain = chain def next_state(self, current_state): if current_state not in self.chain or not self.chain[current_state]: raise ValueError(f\\"State \'{current_state}\' is not in the Markov Chain or has no transitions.\\") next_states = list(self.chain[current_state].keys()) probabilities = list(self.chain[current_state].values()) return random.choices(next_states, probabilities)[0] def simulate(self, start_state, steps): if not self.validate_chain(): raise ValueError(\\"Invalid Markov Chain. Ensure all state transitions have valid probabilities summing to 1.\\") current_state = start_state sequence = [current_state] for _ in range(steps): current_state = self.next_state(current_state) sequence.append(current_state) return sequence def validate_chain(self): for state, transitions in self.chain.items(): if not transitions: return False total_probability = sum(transitions.values()) if abs(total_probability - 1) > 1e-8: return False return True"},{"question":"# Priority Queue - Enhanced Implementation You are provided with a simple implementation of a priority queue using a linear array. However, the insertion operation of this implementation is inefficient, as it runs in O(n) time complexity. Your task is to enhance the priority queue implementation to achieve better performance. # Requirements: 1. Implement a priority queue that supports the following operations more efficiently: - `push(item, priority)`: Insert a new item with the given priority. - `pop()`: Remove and return the item with the highest priority. 2. Aim for an efficient insertion that runs in O(log n) time complexity. # Input/Output: - `push(item, priority)`: Inserts the item with the provided priority. * `item` is the data to be inserted. * `priority` is the priority of the item. - `pop()`: Removes and returns the item with the highest priority (maximum priority). * Raises an exception or returns `None` if the queue is empty. # Example Usage ```python pq = PriorityQueue() pq.push(\'task1\', priority=3) pq.push(\'task2\', priority=5) pq.push(\'task3\', priority=1) assert pq.pop() == \'task2\' # Highest priority assert pq.pop() == \'task1\' assert pq.pop() == \'task3\' ``` # Constraints: - All priorities are non-negative integers. - The priority value of each element is unique. # Performance Requirements - Aim for O(log n) insertion and O(log n) pop operations.","solution":"import heapq class PriorityQueue: def __init__(self): self._queue = [] def push(self, item, priority): heapq.heappush(self._queue, (-priority, item)) def pop(self): if self.is_empty(): raise IndexError(\\"pop from an empty priority queue\\") return heapq.heappop(self._queue)[1] def is_empty(self): return len(self._queue) == 0"},{"question":"# Resizable Hash Table Operations You are required to implement additional methods for the `ResizableHashTable` class. Specifically, you need to provide functionality for getting all keys and values currently stored in the table as two separate lists. # Task 1. **Methods to Implement**: - `get_all_keys`: This method should return a list of all keys currently present in the hash table. - `get_all_values`: This method should return a list of all values currently present in the hash table. # Constraints * The implementation needs to account for internal representation, avoiding the inclusion of placeholders for deleted or empty slots. # Input No explicit input is provided. You are required to augment the existing class with the specified methods. # Output * `get_all_keys` should output a list of all keys stored in the table. * `get_all_values` should output a list of all values stored in the table. # Example ```python htable = ResizableHashTable() htable.put(1, \'one\') htable.put(2, \'two\') htable.put(3, \'three\') # To retrieve the keys and values keys = htable.get_all_keys() values = htable.get_all_values() print(keys) # Output: [1, 2, 3] print(values) # Output: [\'one\', \'two\', \'three\'] ``` # Additional Notes * Ensure that both the methods handle the internal state of the hash table properly and exclude slots marked as empty or deleted. * Focus on maintaining average case O(n) complexity for listing keys and values.","solution":"class ResizableHashTable: def __init__(self): self.capacity = 8 self.size = 0 self.load_factor = 0.75 self.table = [None] * self.capacity self.tombstone = object() # A unique marker for deleted slots def put(self, key, value): if self.size / self.capacity >= self.load_factor: self._resize() idx = self._hash(key) while self.table[idx] is not None and self.table[idx] is not self.tombstone: if self.table[idx][0] == key: self.table[idx] = (key, value) return idx = (idx + 1) % self.capacity self.table[idx] = (key, value) self.size += 1 def get(self, key): idx = self._hash(key) while self.table[idx] is not None: if self.table[idx] is not self.tombstone and self.table[idx][0] == key: return self.table[idx][1] idx = (idx + 1) % self.capacity return None def delete(self, key): idx = self._hash(key) while self.table[idx] is not None: if self.table[idx] is not self.tombstone and self.table[idx][0] == key: self.table[idx] = self.tombstone self.size -= 1 return True idx = (idx + 1) % self.capacity return False def get_all_keys(self): keys = [entry[0] for entry in self.table if entry is not None and entry is not self.tombstone] return keys def get_all_values(self): values = [entry[1] for entry in self.table if entry is not None and entry is not self.tombstone] return values def _hash(self, key): return hash(key) % self.capacity def _resize(self): old_table = self.table self.capacity *= 2 self.table = [None] * self.capacity self.size = 0 for entry in old_table: if entry is not None and entry is not self.tombstone: self.put(entry[0], entry[1])"},{"question":"Implement a function `find_unique_number` that finds the unique number in a list of integers where every other number appears exactly twice. Use an efficient algorithm with O(n) time complexity and O(1) space complexity. # Input - A list of integers `nums` containing 1 ≤ len(nums) ≤ 10^5 where each integer appears exactly twice except for one integer that appears once. The list may contain both negative and positive integers. # Output - Return the integer that appears only once. # Example ```python assert find_unique_number([2, 2, 1]) == 1 assert find_unique_number([4, 1, 2, 1, 2]) == 4 assert find_unique_number([1]) == 1 ``` # Constraints - Your solution should be efficient in terms of both time and space. - Handle edge cases such as a single element list and a list with both negative and positive integers. # Guidelines - Your implementation must use the XOR operation to find the unique number. - Do not use extra space (i.e., extra lists, sets, etc.).","solution":"def find_unique_number(nums): Finds the unique number in a list where every other number appears exactly twice. Uses the XOR operation to achieve O(n) time complexity and O(1) space complexity. Args: nums (list): A list of integers. Returns: int: The unique integer in the list. unique_num = 0 for num in nums: unique_num ^= num return unique_num"},{"question":"# Scenario/Context You are working on a system that requires efficient transmission of data over a network. To detect and correct single-bit errors during the transmission, you need to measure the Hamming distance between two bit strings. The task involves determining the minimal number of bits to flip to convert one integer into another. Understanding this can help in designing protocols for error detection/correction. # Problem Statement Write a function that determines the minimal number of bits you would need to flip to convert integer `A` to integer `B`. **Function Signature:** ```python def count_flips_to_convert(a: int, b: int) -> int: ``` **Input:** * `a` (integer): The first integer. * `b` (integer): The second integer. **Output:** * (integer): The number of bits that need to be flipped to convert `A` to `B`. **Constraints:** * `0 <= a, b <= 2^31 - 1` (assuming 32-bit unsigned integers) * Performance should be optimal and handle edge cases effectively. **Examples:** 1. `count_flips_to_convert(29, 15)` should return `2` because: - Binary of 29: `11101` - Binary of 15: `01111` - Bits to flip: `11010` (2 bits) 2. `count_flips_to_convert(1, 2)` should return `2` because: - Binary of 1: `00001` - Binary of 2: `00010` - Bits to flip: `00011` (2 bits) 3. `count_flips_to_convert(0, 8)` should return `1` because: - Binary of 0: `00000` - Binary of 8: `01000` - Bits to flip: `01000` (1 bit) # Additional Notes: - Aim to achieve the most efficient solution with respect to both time and space. - Ensure that the function is robust and handles all specified edge cases.","solution":"def count_flips_to_convert(a: int, b: int) -> int: Returns the number of bits that need to be flipped to convert integer a to integer b. # XOR operation between a and b will result in bits set to 1 where a and b differ xor_result = a ^ b # Count the number of 1\'s (these are the bits that differ) count = 0 while xor_result: count += xor_result & 1 xor_result >>= 1 return count"},{"question":"# Scenario You are a software engineer at a startup developing a feature for sorting small datasets. Your feature must sort a list of integers efficiently and correctly. While doing a research, you came across Gnome Sort - a simple sorting algorithm. Now, you need to implement this algorithm and further validate its performance for small lists. # Function Implementation Implement the `gnome_sort` function as described, considering various edge cases and performance under different conditions. Function Signature ```python def gnome_sort(arr: List[int]) -> List[int]: pass ``` Input Format * `arr`: A list of integers `arr (1 <= len(arr) <= 1000, -10^5 <= arr[i] <= 10^5)` Output Format * The function should return a list of integers sorted in non-decreasing order. Constraints * The algorithm should handle empty arrays by returning an empty list. * The implementation must be done in-place; minimize additional space usage. # Examples 1. **Input**: `[34, 2, 78, 1, 98, 23, 45, 67, 89, 12]` **Output**: `[1, 2, 12, 23, 34, 45, 67, 78, 89, 98]` 2. **Input**: `[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]` **Output**: `[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]` 3. **Input**: `[10, 9, 8, 7, 6, 5, 4, 3, 2, 1]` **Output**: `[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]` 4. **Input**: `[]` **Output**: `[]` 5. **Input**: `[7, 7, 7, 7, 7, 7, 7]` **Output**: `[7, 7, 7, 7, 7, 7, 7]` Write a Python function that implements Gnome Sort based on the above scenario and format.","solution":"from typing import List def gnome_sort(arr: List[int]) -> List[int]: Sorts a list of integers using the Gnome sort algorithm. Parameters: arr (List[int]): The list of integers to be sorted. Returns: List[int]: The sorted list of integers in non-decreasing order. index = 0 while index < len(arr): if index == 0 or arr[index] >= arr[index - 1]: index += 1 else: arr[index], arr[index - 1] = arr[index - 1], arr[index] index -= 1 return arr"},{"question":"# Fibonacci Generator You are tasked with writing a function to compute the nth Fibonacci number using an optimized approach. Given the limitations of the recursive method in terms of performance, your goal is to implement an iterative solution that computes the result in O(n) time and O(1) space complexity. This function should handle edge cases efficiently and prevent common performance bottlenecks. # Input - An integer `n` (0 ≤ n ≤ 10^5) # Output - An integer representing the nth Fibonacci number. # Constraints - Your implementation should run in linear time O(n) and use constant space O(1). # Example Input ``` 10 ``` Output ``` 55 ``` # Function Signature ```python def fibonacci(n: int) -> int: pass ```","solution":"def fibonacci(n: int) -> int: Returns the nth Fibonacci number. The function uses an iterative approach to achieve O(n) time and O(1) space complexity. Parameters: n (int): The position in the Fibonacci sequence. Returns: int: The nth Fibonacci number. if n == 0: return 0 elif n == 1: return 1 prev, curr = 0, 1 for _ in range(2, n + 1): prev, curr = curr, prev + curr return curr"},{"question":"# Question You are given a list of file paths in different formats (URLs, Unix-style, Windows-style). Your task is to write a function `split_paths(paths)` that takes a list of paths and returns a list of tuples, where each tuple contains two elements: the directory path and the file name extracted from each input path. # Function Signature ```python def split_paths(paths: List[str]) -> List[Tuple[str, str]]: ``` # Input * `paths` - A list of strings, where each string is a file path. # Output * A list of tuples (pairs of strings), where each tuple corresponds to the directory path and the file name. # Constraints * Each element in `paths` is a valid file path or URL. * Paths may contain mixed separators (/, ). * Maximum length of any string in `paths` is 1000. * The input list `paths` will contain at most 100 elements. # Example ```python paths = [ \\"https://algorithms/unix/test.py\\", \\"C:UsersDocumentsfile.txt\\", \\"/usr/local/bin/python\\", \\"home/user/docs/file.md\\" ] print(split_paths(paths)) ``` # Output ```python [ (\'https://algorithms/unix\', \'test.py\'), (\'C:UsersDocuments\', \'file.txt\'), (\'/usr/local/bin\', \'python\'), (\'home/user/docs\', \'file.md\') ] ``` # Notes * Ensure your function handles various path formats and separators. * You should use the appropriate methods to split the paths while maintaining platform independence.","solution":"from typing import List, Tuple import os import ntpath def split_paths(paths: List[str]) -> List[Tuple[str, str]]: result = [] for path in paths: # Identify if the path is more like a Windows path or a Unix path by the presence of backslashes if \'\' in path: directory, filename = ntpath.split(path) else: directory, filename = os.path.split(path) result.append((directory.rstrip(\'/\'), filename)) return result"},{"question":"# Problem: Coin Change Problem with Detailed Constraints Given a value `value`, if we want to make change for `value` cents, and we have an infinite supply of each coin in the list `coins`, determine the number of ways to make the change. The order of coins does not matter. For example: - For `value` = 4 and `coins` = [1, 2, 3], there are four possible solutions: - [1, 1, 1, 1] - [1, 1, 2] - [2, 2] - [1, 3] Therefore, the output should be 4. - For `value` = 10 and `coins` = [2, 5, 3, 6], there are five solutions: - [2, 2, 2, 2, 2] - [2, 2, 3, 3] - [2, 2, 6] - [2, 3, 5] - [5, 5] Therefore, the output should be 5. # Function Signature ```python def count(coins: List[int], value: int) -> int: pass ``` # Input - `coins` (List[int]): A list of distinct integers representing the coin denominations. Each integer is positive. - `value` (int): An integer representing the total amount for which change must be made. This integer is non-negative. # Output - Returns an integer representing the number of ways to make change for the given `value` using the denominations provided in `coins`. # Constraints - 1 <= len(coins) <= 50 - 0 <= value <= 10^4 # Requirements - Implement the function in O(n * m) time complexity and O(n) space complexity where `n` is the `value` and `m` is the length of `coins`. # Example ```python print(count([1, 2, 3], 4)) # Output: 4 print(count([2, 5, 3, 6], 10)) # Output: 5 ``` # Notes - Ensure to handle all edge cases such as `value` being 0. - Consider the constraints carefully to optimize both time and space complexity. - Input validation is not required; assume all inputs are valid as per the problem statement.","solution":"from typing import List def count(coins: List[int], value: int) -> int: Returns the number of ways to make change for \'value\' using denominations provided in \'coins\'. # Initialize a list to store the count of solutions for each value up to the given value dp = [0] * (value + 1) dp[0] = 1 # Base case: There\'s 1 way to make change for 0 value # Loop through each coin in the list for coin in coins: # Update the dp array for all values from coin to value for x in range(coin, value + 1): dp[x] += dp[x - coin] return dp[value]"},{"question":"# Question: Implement and Extend Separate Chaining Hash Table Scenario: You are required to implement a robust hash table using separate chaining for collision resolution. Additionally, you will extend its functionality to handle resizing when the load factor reaches a specific threshold. Function to be Implemented: * `put(self, key, value)`: Inserts the key-value pair into the hash table, or updates the value if the key already exists. * `get(self, key)`: Retrieves the value associated with the key. * `del_(self, key)`: Deletes the key-value pair associated with the key. * `resize(self, new_size)`: Resizes the hash table to the new size and rehashes all existing key-value pairs. Constraints: * Use a load factor of 0.75 to trigger resizing. * The initial capacity of the hash table is 11. * Implement the resize function to allow dynamic resizing. * Assume the keys are immutable and hashable. * Use the built-in `hash` function to generate hash values. * Aim to maintain an average O(1) time complexity for put, get, and del_ operations. Input/Output Expectations: * `put(self, key, value)`: No explicit output (changes internal state of hash table). * `get(self, key)`: Returns the value if the key exists, otherwise returns `None`. * `del_(self, key)`: No explicit output (removes key-value pair if exists). * `resize(self, new_size)`: No explicit output (resizes and rehashes existing key-value pairs). Usage Example: ```python table = SeparateChainingHashTable() table.put(\'cat\', \'meow\') print(table.get(\'cat\')) # Output: \'meow\' table.put(\'dog\', \'bark\') print(len(table)) # Output: 2 table.del_(\'cat\') print(table.get(\'cat\')) # Output: None table.resize(20) print(len(table)) # Output: 1 ``` Notes: * Handle all edge cases such as inserting duplicate keys, deleting non-existent keys, and handling array resizing. * Ensure the hash table performs efficiently even with a high number of operations.","solution":"class SeparateChainingHashTable: def __init__(self, initial_capacity=11, load_factor_threshold=0.75): self.table = [[] for _ in range(initial_capacity)] self.size = 0 self.load_factor_threshold = load_factor_threshold def _hash(self, key): return hash(key) % len(self.table) def put(self, key, value): index = self._hash(key) bucket = self.table[index] for i, (k, v) in enumerate(bucket): if k == key: bucket[i] = (key, value) return bucket.append((key, value)) self.size += 1 if self.size / len(self.table) > self.load_factor_threshold: self.resize(len(self.table) * 2) def get(self, key): index = self._hash(key) bucket = self.table[index] for k, v in bucket: if k == key: return v return None def del_(self, key): index = self._hash(key) bucket = self.table[index] for i, (k, v) in enumerate(bucket): if k == key: bucket.pop(i) self.size -= 1 return def resize(self, new_size): new_table = [[] for _ in range(new_size)] old_table = self.table self.table = new_table self.size = 0 for bucket in old_table: for k, v in bucket: self.put(k, v) def __len__(self): return self.size"},{"question":"You are developing a tool that requires the computation of greatest common divisors and least common multiples for pairs of numbers. To ensure robust and efficient implementations, you are asked to: 1. Implement the `gcd` function using the Euclidean algorithm. 2. Implement the `lcm` function leveraging your `gcd` function. 3. Implement the `gcd_bit` function utilizing bitwise operations. # Function Definitions 1. **gcd**: ```python def gcd(a, b): Computes the greatest common divisor of integers a and b using Euclid\'s Algorithm. Arguments: a -- First integer b -- Second integer Returns: The greatest common divisor of a and b. Raises: ValueError if any of a or b are zero or not integers. ``` 2. **lcm**: ```python def lcm(a, b): Computes the least common multiple of integers a and b using gcd function. Arguments: a -- First integer b -- Second integer Returns: The least common multiple of a and b. Raises: ValueError if any of a or b are zero or not integers. ``` 3. **gcd_bit**: ```python def gcd_bit(a, b): Computes the greatest common divisor of integers a and b using bitwise operations. Arguments: a -- First integer b -- Second integer Returns: The greatest common divisor of a and b. Raises: ValueError if any of a or b are zero or not integers. ``` # Input and Output Formats - **Input**: - Two integers `a` and `b`. - **Output**: - For `gcd` and `gcd_bit`: An integer representing the greatest common divisor. - For `lcm`: An integer representing the least common multiple. # Constraints - Both integers `a` and `b` will be in the range `[-10^9, 10^9]`. - You must handle invalid input robustly, ensuring that appropriate exceptions are raised for zero or non-integer values. - Avoid using any external libraries for handling large integers. # Example ```python assert gcd(48, 18) == 6 assert gcd_bit(48, 18) == 6 assert lcm(48, 18) == 144 try: gcd(0, 0) except ValueError as e: print(e) # Expected output ``` Write the implementations for the above-specified functions.","solution":"def gcd(a, b): Computes the greatest common divisor of integers a and b using Euclid\'s Algorithm. if not isinstance(a, int) or not isinstance(b, int): raise ValueError(\\"Both a and b must be integers\\") if a == 0 and b == 0: raise ValueError(\\"Both a and b cannot be zero\\") a, b = abs(a), abs(b) while b: a, b = b, a % b return a def lcm(a, b): Computes the least common multiple of integers a and b using gcd function. if not isinstance(a, int) or not isinstance(b, int): raise ValueError(\\"Both a and b must be integers\\") if a == 0 or b == 0: raise ValueError(\\"Neither a nor b can be zero\\") return abs(a * b) // gcd(a, b) def gcd_bit(a, b): Computes the greatest common divisor of integers a and b using bitwise operations. if not isinstance(a, int) or not isinstance(b, int): raise ValueError(\\"Both a and b must be integers\\") if a == 0 and b == 0: raise ValueError(\\"Both a and b cannot be zero\\") a, b = abs(a), abs(b) if a == 0: return b if b == 0: return a # Both a and b are even shift = 0 while ((a | b) & 1) == 0: a >>= 1 b >>= 1 shift += 1 # a is odd, b is even while (a & 1) == 0: a >>= 1 # From here on, a is always odd while b != 0: while (b & 1) == 0: b >>= 1 if a > b: a, b = b, a b = b - a return a << shift"},{"question":"You are tasked with implementing functions for an AVL Tree, a self-balancing binary search tree (BST). The AVL tree should maintain proper balance after each insert operation to ensure the heights of two child subtrees of any node differ by at most one. Your tasks involve implementing methods for insertion (`insert`), rebalancing (`rebalance`), updating heights (`update_heights`), updating balance factors (`update_balances`), left rotation (`rotate_left`), right rotation (`rotate_right`), and in-order traversal (`in_order_traverse`). # Function Signatures 1. `def insert(self, key: int) -> None` - Inserts a key into the AVL tree and rebalances it if necessary. 2. `def rebalance(self) -> None` - Rebalances the AVL tree after insertion or deletion of a node. 3. `def update_heights(self, recursive: bool = True) -> None` - Updates the height of nodes in the AVL tree. 4. `def update_balances(self, recursive: bool = True) -> None` - Updates the balance factor of nodes in the AVL tree. 5. `def rotate_left(self) -> None` - Performs a left rotation to maintain tree balance. 6. `def rotate_right(self) -> None` - Performs a right rotation to maintain tree balance. 7. `def in_order_traverse(self) -> List[int]` - Returns a list of elements in the AVL tree in ascending order using in-order traversal. # Classes and Methods You will work with the following classes: **TreeNode Class**: Represents a node in the tree. ```python class TreeNode: def __init__(self, key: int): self.key = key self.left = None self.right = None ``` **AvlTree Class**: Implements the AVL tree operations. ```python class AvlTree: def __init__(self): self.node = None self.height = -1 self.balance = 0 def insert(self, key: int) -> None: # Your code here def rebalance(self) -> None: # Your code here def update_heights(self, recursive: bool = True) -> None: # Your code here def update_balances(self, recursive: bool = True) -> None: # Your code here def rotate_left(self) -> None: # Your code here def rotate_right(self) -> None: # Your code here def in_order_traverse(self) -> List[int]: # Your code here ``` # Constraints - Insert only integer keys. - Do not allow duplicate keys. - Ensure the AVL tree maintains its balance property after each insertion. # Example Usage ```python avl = AvlTree() avl.insert(10) avl.insert(20) avl.insert(30) avl.insert(40) bs.avl.insert(50) assert avl.in_order_traverse() == [10, 20, 30, 40, 50] avl.insert(25) assert avl.in_order_traverse() == [10, 20, 25, 30, 40, 50] ``` Implement these methods in the `AvlTree` class to complete the AVL tree functionality.","solution":"class TreeNode: def __init__(self, key: int): self.key = key self.left = None self.right = None self.height = 1 class AvlTree: def __init__(self): self.node = None def insert(self, key: int) -> None: if not self.node: self.node = TreeNode(key) else: self.node = self._insert(self.node, key) def _insert(self, current_node, key): if not current_node: return TreeNode(key) elif key < current_node.key: current_node.left = self._insert(current_node.left, key) elif key > current_node.key: current_node.right = self._insert(current_node.right, key) else: return current_node current_node.height = 1 + max(self._get_height(current_node.left), self._get_height(current_node.right)) balance = self._get_balance(current_node) if balance > 1 and key < current_node.left.key: return self.rotate_right(current_node) if balance < -1 and key > current_node.right.key: return self.rotate_left(current_node) if balance > 1 and key > current_node.left.key: current_node.left = self.rotate_left(current_node.left) return self.rotate_right(current_node) if balance < -1 and key < current_node.right.key: current_node.right = self.rotate_right(current_node.right) return self.rotate_left(current_node) return current_node def _get_height(self, node): if not node: return 0 return node.height def _get_balance(self, node): if not node: return 0 return self._get_height(node.left) - self._get_height(node.right) def rotate_left(self, z): y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def rotate_right(self, z): y = z.left T3 = y.right y.right = z z.left = T3 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def in_order_traverse(self): res = [] self._in_order_traverse(self.node, res) return res def _in_order_traverse(self, node, res): if not node: return self._in_order_traverse(node.left, res) res.append(node.key) self._in_order_traverse(node.right, res)"},{"question":"# Question: Implement a Compact Trie You are required to implement a compact trie (prefix tree), which minimizes the space usage by compressing chains of single-child nodes into a single edge. Implement a compact trie with the following operations: 1. `insert(word)`: Inserts the string `word` into the trie. 2. `search(word)`: Returns `True` if the word `word` is in the trie, otherwise returns `False`. 3. `starts_with(prefix)`: Returns `True` if there is any word in the trie that starts with the string `prefix`, otherwise returns `False`. Input and Output Formats * `insert(word: str) -> None`: Inserts the string `word` into the trie. * `search(word: str) -> bool`: Returns `True` if the `word` is in the trie, otherwise `False`. * `starts_with(prefix: str) -> bool`: Returns `True` if there is any word in the trie that starts with the string `prefix`, otherwise `False`. Constraints * `word` and `prefix` consist of only lowercase English letters (\'a\' - \'z\'). * Length of `word` and `prefix` is between 1 and 1000. * The number of words inserted into the trie is between 1 and 10^5. # Example ```python trie = CompactTrie() trie.insert(\\"apple\\") print(trie.search(\\"apple\\")) # Returns True print(trie.search(\\"app\\")) # Returns False print(trie.starts_with(\\"app\\")) # Returns True trie.insert(\\"app\\") print(trie.search(\\"app\\")) # Returns True ``` # Explanation * Insert the word \\"apple\\" into the trie. * Search for \\"apple\\" returns True because it was inserted. * Search for \\"app\\" returns False because \\"app\\" isn\'t a complete word in the trie. * startsWith(\\"app\\") returns True because \\"apple\\" starts with \\"app\\". * Insert the word \\"app\\" into the trie. * Search for \\"app\\" returns True because it was just inserted. **Note**: The compact trie should merge single-child chains to save memory. For example, if \\"apple\\" and \\"apples\\" are inserted, the common prefix \\"apple\\" should be stored efficiently.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class CompactTrie: def __init__(self): self.root = TrieNode() def insert(self, word: str) -> None: node = self.root for c in word: if c not in node.children: node.children[c] = TrieNode() node = node.children[c] node.is_end_of_word = True def search(self, word: str) -> bool: node = self._traverse(word) return node is not None and node.is_end_of_word def starts_with(self, prefix: str) -> bool: return self._traverse(prefix) is not None def _traverse(self, word: str) -> TrieNode: node = self.root for c in word: if c in node.children: node = node.children[c] else: return None return node"},{"question":"You are required to implement a variant of the HashTable called `ResizableHashTable` that supports dynamic resizing and collision handling using linear probing. We will test the implementation via an advanced scenario. # Details 1. **Function**: `__resize` - **Purpose**: Resize the hash table when load factor exceeds 2/3. - **Description**: When resizing, the capacity of the table should be doubled, and all existing key-value pairs should be rehashed to new positions. 2. **Input/Output Constraints**: - **Key**: Any integer value (positive, negative, or zero). - **Value**: Any data type. - The table should resize itself when `len(HashTable) >= 2/3 * size`. 3. **Implementation**: - Implement the `put` method to handle resizing. - Ensure collision handling using linear probing. - Provide methods for `get`, `put`, and `del`. 4. **Performance**: - Average case time complexity for operations should remain O(1). # Requirements 1. **put**: - Add a new key-value pair. - Replace old value if key already exists. - Resize the table if load factor exceeds threshold. 2. **get**: - Return the value associated with the key. - Return `None` if key is not found. 3. **del**: - Remove the key-value pair from the table. - Handle the deletion without breaking the probing sequence. # Input/Output Examples 1. **Example**: ```python table = ResizableHashTable() table.put(1, \'A\') table.put(2, \'B\') table.put(3, \'C\') print(table.get(1)) # Output: \'A\' print(len(table)) # Output: 3 ``` 2. **Example**: ```python table = ResizableHashTable() table.put(1, \'A\') table.put(2, \'B\') table.put(17, \'C\') # Assuming initial size = 11, 1 and 17 will hash to same index. table.del_(1) print(table.get(1)) # Output: None print(table.get(2)) # Output: \'B\' print(table.get(17)) # Output: \'C\' ``` # Scenario Consider a scenario where you need to store and manage a large dataset dynamically. Resizable hash tables are crucial here as they maintain efficient data retrieval through resizing and probing. Design your `ResizableHashTable` to handle insertion, deletion, and lookup with average time O(1), ensuring it scales gracefully.","solution":"class ResizableHashTable: def __init__(self, initial_capacity=11): self.capacity = initial_capacity self.size = 0 self.table = [None] * self.capacity def __resize(self): new_capacity = 2 * self.capacity new_table = [None] * new_capacity for item in self.table: if item: key, value = item self.__put_in_new_table(new_table, new_capacity, key, value) self.capacity = new_capacity self.table = new_table def __put_in_new_table(self, table, capacity, key, value): index = key % capacity while table[index] is not None: if table[index][0] == key: break index = (index + 1) % capacity table[index] = (key, value) def put(self, key, value): if self.size >= (2 * self.capacity) // 3: self.__resize() index = key % self.capacity while self.table[index] is not None: if self.table[index][0] == key: self.table[index] = (key, value) return index = (index + 1) % self.capacity self.table[index] = (key, value) self.size += 1 def get(self, key): index = key % self.capacity while self.table[index] is not None: if self.table[index][0] == key: return self.table[index][1] index = (index + 1) % self.capacity return None def del_(self, key): index = key % self.capacity while self.table[index] is not None: if self.table[index][0] == key: self.table[index] = None self.size -= 1 self.__rehash_from_index(index) return index = (index + 1) % self.capacity def __rehash_from_index(self, start_index): index = (start_index + 1) % self.capacity while self.table[index] is not None: key, value = self.table[index] self.table[index] = None self.size -= 1 self.put(key, value) index = (index + 1) % self.capacity def __len__(self): return self.size"},{"question":"# Question: **Roman Numeral Conversion** As a historian working on digitizing ancient manuscripts, you often come across dates and annotations written in Roman numerals. You need to convert these Roman numerals back into integers to make the data searchable and analyzable. **Task**: Write a function `roman_to_int` that converts a Roman numeral to an integer. The function should support input in the range from 1 to 3999 (inclusive). Function Signature: ```python def roman_to_int(s: str) -> int: :param s: the Roman numeral string to be converted :type s: str :return: integer representation of the Roman numeral :rtype: int ``` Input: * `s` (str): A string representing a Roman numeral, guaranteed to be a valid numeral in the range [1, 3999]. Output: * Return an integer representing the Roman numeral. Constraints: * The input string `s` will always represent a valid Roman numeral within the range 1 to 3999. Examples: ```python assert roman_to_int(\\"III\\") == 3 assert roman_to_int(\\"IX\\") == 9 assert roman_to_int(\\"LVIII\\") == 58 assert roman_to_int(\\"MCMXCIV\\") == 1994 ``` Scenario: You are implementing a digital archive tool. Users will input dates in Roman numerals, and your tool should convert them to standard integers for storage and fast retrieval. * You may assume the input numeral is always well-formed and within the aforementioned range. * Consider common conventions for Roman numerals - for example, IV is 4, IX is 9, but not IIII or VIV.","solution":"def roman_to_int(s: str) -> int: Convert a Roman numeral string to an integer. The function supports input in the range from 1 to 3999 (inclusive). :param s: the Roman numeral string to be converted :type s: str :return: integer representation of the Roman numeral :rtype: int roman_to_value = { \'I\': 1, \'V\': 5, \'X\': 10, \'L\': 50, \'C\': 100, \'D\': 500, \'M\': 1000 } total = 0 prev_value = 0 for char in reversed(s): value = roman_to_value[char] if value < prev_value: total -= value else: total += value prev_value = value return total"},{"question":"**Scenario**: You are developing a system which ensures data integrity in a linked list by verifying that data elements are stored in a non-decreasing order. In particular, the system must be capable of not only checking the current order but also identifying and providing feedback on any potential disruptions in the order. **Implementing the Function**: *Write a Python function `validate_list(head)` which returns a tuple containing:* 1. A boolean indicating if the list is sorted in non-decreasing order. 2. A list of tuples, each containing the first out-of-order pair identified during the traversal (i.e., such that the first element is greater than the second). If the list is sorted, this list should be empty. **Function Signature**: ```python def validate_list(head: ListNode) -> Tuple[bool, List[Tuple[int, int]]]: pass ``` **Input**: - `head (ListNode)`: A reference to the first node of a singly linked list where ListNode is defined as: ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next ``` **Output**: - A tuple with a boolean and a list of tuples as described above. **Constraints**: - The list may contain negative or positive integers, or the list could be empty. - You should not assume additional information about the list beyond what is defined. **Example**: ```python # Example 1: # Input: head = ListNode(1, ListNode(2, ListNode(3, ListNode(4)))) # Output: (True, []) # Example 2: # Input: head = ListNode(1, ListNode(2, ListNode(-1, ListNode(3)))) # Output: (False, [(2, -1)]) # Example 3: # Input: head = None # Output: (True, []) ``` **Guidelines**: - Account for edge cases, such as empty lists or single-element lists. - Ensure the function detects and collects all out-of-order elements if any, in the respective order they appear. **Performance Requirement**: - Aim for a time complexity of O(n) and a space complexity of O(1) (excluding the space used for the output list). Good luck!","solution":"from typing import Tuple, List class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def validate_list(head: ListNode) -> Tuple[bool, List[Tuple[int, int]]]: if not head or not head.next: return True, [] sorted = True out_of_order_pairs = [] curr = head while curr and curr.next: if curr.val > curr.next.val: sorted = False out_of_order_pairs.append((curr.val, curr.next.val)) curr = curr.next return sorted, out_of_order_pairs"},{"question":"Frequency Distribution Histogram # Objective: Given a list of elements, write a function to compute the frequency distribution histogram of the elements in the list. # Function Signature: ```python def get_histogram(input_list: list) -> dict: ``` # Input: * `input_list` (List of integers): A list containing n integers where 0 ≤ n ≤ 10^5. # Output: * A dictionary where the keys are the unique elements from the input list and the values are the counts of those elements. # Constraints: * The input list will only contain integer values. * Elements in the input list can appear multiple times. * The function should have a linear time complexity, O(n). # Performance Requirements: * Ensure the implementation is efficient both in terms of time and space complexity. # Example: ```python # Example 1 list_1 = [3, 3, 2, 1] # Expected output: {1: 1, 2: 1, 3: 2} # Example 2 list_2 = [2, 3, 5, 5, 5, 6, 4, 3, 7] # Expected output: {2: 1, 3: 2, 4: 1, 5: 3, 6: 1, 7: 1} ``` # Description: - You are required to implement a function `get_histogram` that aggregates the frequency of each element in the input list. - Ensure your function handles edge cases such as empty input lists. # Additional Notes: - Think about how you can optimize your solution if the input list contains a large number of elements. - Aim to make your code clear and concise, using appropriate variable names to enhance readability and maintainability.","solution":"def get_histogram(input_list: list) -> dict: Computes the frequency distribution histogram of the elements in the input list. Parameters: input_list (list of int): A list containing integers where 0 ≤ n ≤ 10^5. Returns: dict: A dictionary where keys are unique elements from the input list and values are their counts. histogram = {} for element in input_list: if element in histogram: histogram[element] += 1 else: histogram[element] = 1 return histogram"},{"question":"# Question: Rotate an Array to the Right by k Steps Objective: Implement a function to rotate an array to the right by a given number of steps, k. Analyze and compare different methods to achieve this. Scenario: Imagine you are managing a round-robin scheduling system where tasks need to be processed in a cyclic manner. To simulate this, you need to rotate an array of tasks to identify the next set of tasks in the cycle. Function Signature: ```python def rotate_array(array: List[int], k: int) -> List[int]: ``` Input: * `array`: A list of integers representing the tasks. * `k`: An integer, the number of steps to rotate the array. Output: A list of integers representing the rotated array. Constraints: * If the array is empty, return an empty array. * Assume k is a non-negative integer. * Optimize for both time and space complexity. Requirements: 1. Implement the function using at least two different methods: * **Method 1**: In-place rotation with O(n) time complexity and O(1) space complexity. * **Method 2**: Rotation using array slicing with O(n) time complexity but involving additional space. 2. Analyze and compare both methods in terms of: * Time complexity. * Space complexity. Example: ```python # Method 1 Example array = [1, 2, 3, 4, 5, 6, 7] k = 3 assert rotate_array(array, k) == [5, 6, 7, 1, 2, 3, 4] # Method 2 Example array = [1, 2, 3, 4, 5, 6, 7] k = 3 assert rotate_array(array, k) == [5, 6, 7, 1, 2, 3, 4] ``` Note: Clearly separate the implementations of both methods within your function.","solution":"def rotate_array(array, k): Rotates the array to the right by k steps and returns the rotated array. Provide both in-place and slicing methods for rotation. n = len(array) if n == 0: return array k = k % n # Method 1: In-place rotation def rotate_in_place(arr, k): def reverse(arr, start, end): while start < end: arr[start], arr[end] = arr[end], arr[start] start, end = start + 1, end - 1 reverse(arr, 0, n - 1) reverse(arr, 0, k - 1) reverse(arr, k, n - 1) return arr # Method 2: Rotation using array slicing def rotate_slicing(arr, k): return arr[-k:] + arr[:-k] # Choose the method to use: # Comment out one to use the other # rotated_array = rotate_in_place(array.copy(), k) rotated_array = rotate_slicing(array.copy(), k) return rotated_array"},{"question":"Implement a class `EfficientMovingAverage`, which efficiently calculates the moving average of a sliding window in a stream of integers. Unlike the straightforward implementation, optimize the computation to avoid summing the entire window at every operation. # Function Implementation You need to implement the following methods: * `__init__(self, size: int)`: Initializes the data structure with a given size. * `next(self, val: int) -> float`: Adds a new integer to the stream and returns the current moving average. # Input and Output Formats * `__init__(self, size: int)`: * **Input**: `size` is an integer representing the size of the sliding window (1 ≤ size ≤ 100). * **Output**: None. * `next(self, val: int) -> float`: * **Input**: `val` is an integer to be added to the stream (-10^4 ≤ val ≤ 10^4). * **Output**: A float representing the current moving average of the last `size` elements. # Constraints * The window size will always be a positive integer. * Values are bounded by the specified range. * Handling edge cases and optimizing for performance will be crucial for a successful solution. # Performance Requirements * The `next` method should run in O(1) time complexity. # Example ```python if __name__ == \'__main__\': m = EfficientMovingAverage(3) assert m.next(1) == 1.0 assert m.next(10) == 5.5 assert m.next(3) == 4.666666666666667 assert m.next(5) == 6.0 ``` # Additional Context You are designing an algorithm for a system that needs to process a continuous stream of data in real-time. Your implementation needs to be efficient and performant to handle potentially high-throughput scenarios without significant delays.","solution":"from collections import deque class EfficientMovingAverage: def __init__(self, size: int): Initializes the data structure with a given size. self.size = size self.window = deque() self.sum = 0 def next(self, val: int) -> float: Adds a new integer to the stream and returns the current moving average. if len(self.window) == self.size: self.sum -= self.window.popleft() self.window.append(val) self.sum += val return self.sum / len(self.window)"},{"question":"# Linked List Palindrome Checker **Background**: A palindrome is a sequence of characters that reads the same forwards and backwards. For example, the linked list [1, 2, 3, 2, 1] is a palindrome. **Task**: Implement a function that checks if a given singly linked list is a palindrome. You can use one of the following three methods presented: 1. **In-place Linked List Reversal** 2. **Stack-based Comparison** 3. **Dictionary-based Position Tracking** Choose whichever you find most comfortable or efficient and implement it. **Input**: - A singly linked list `head`. **Output**: - A boolean `True` if the linked list is a palindrome; otherwise, `False`. **Constraints**: - The number of nodes in the linked list will not exceed 100,000. - Node values are integers and can include negative values. **Performance Requirement**: - The solution should have O(n) time complexity, where n is the number of nodes in the linked list. - Aim for the least space complexity possible. **Function Signature**: ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def is_palindrome(head: ListNode) -> bool: # implement your solution here pass ``` **Example**: ```python # Example 1 Input: 1 -> 2 -> 3 -> 2 -> 1 Output: True # Example 2 Input: 1 -> 2 -> 2 -> 1 Output: True # Example 3 Input: 1 -> 2 -> 3 Output: False ``` Include unit tests and edge cases like an empty list or a list with the same repeated value nodes.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def is_palindrome(head: ListNode) -> bool: # Fast and slow pointer to find the middle of the list slow = head fast = head prev_slow = None while fast and fast.next: fast = fast.next.next prev_slow = slow slow = slow.next # Handle odd-sized list by moving slow one more step if fast: slow = slow.next # Reverse the second half of the list prev_reverse = None while slow: next_node = slow.next slow.next = prev_reverse prev_reverse = slow slow = next_node # Compare the first half and the reversed second half left, right = head, prev_reverse while right: if left.val != right.val: return False left = left.next right = right.next return True"},{"question":"Scenario You are working on a financial application where determining the number of digits in large transaction IDs (which are represented as integers) is crucial for formatting and display purposes. You need to implement a function that efficiently determines the number of digits in a given integer. Task Write a function `count_digits` that takes an integer `n` (which can be negative) and returns the number of digits in its absolute value. This function should have an efficient time complexity. Input and Output Formats - **Input**: A single integer `n` (where -10^18 <= n <= 10^18). - **Output**: An integer representing the number of digits in `n`. Constraints - The function should handle negative numbers properly. - Ensure the function correctly returns 1 for `n = 0`. - Handle the full range of possible integer values up to ±10^18. Example ```python count_digits(12345) # Output: 5 count_digits(-987654) # Output: 6 count_digits(0) # Output: 1 count_digits(-1000000000) # Output: 10 ``` Performance Requirements - Your solution should have O(1) time complexity. Implement the `count_digits` function to meet the above requirements.","solution":"def count_digits(n): Returns the number of digits in the absolute value of the integer n. return len(str(abs(n)))"},{"question":"# In-order Traversal Challenge **Context**: You are given a binary tree and you need to perform an in-order traversal of the tree. An in-order traversal visits the nodes in the following order: left child, parent, right child. **Objective**: You need to implement a function to perform an in-order traversal both iteratively and recursively. # Implementation Details 1. **Function 1**: `inorder(root)` - **Input**: The root node of the binary tree. - **Output**: A list of node values in in-order sequence. 2. **Function 2**: `inorder_rec(root)` - **Input**: The root node of the binary tree. - **Output**: A list of node values in in-order sequence, using a recursive approach. # Constraints - You may assume the binary tree\'s Node class is already defined as per the code provided. - Your solution should handle large trees without leading to recursion depth errors (for Function 1). # Examples - Example 1: ```python n1 = Node(3) n2 = Node(1) n3 = Node(2) n4 = Node(4) n1.left = n2 n2.right = n3 n1.right = n4 # The tree structure: # 3 # / # 1 4 # # 2 assert inorder(n1) == [1, 2, 3, 4] assert inorder_rec(n1) == [1, 2, 3, 4] ``` - Example 2: ```python n1 = Node(1) n2 = Node(2) n1.right = n2 # The tree structure: # 1 # # 2 assert inorder(n1) == [1, 2] assert inorder_rec(n1) == [1, 2] ``` Write your solutions ensuring they are efficient and handle edge cases gracefully.","solution":"class Node: def __init__(self, key): self.left = None self.right = None self.val = key def inorder(root): Perform in-order traversal iteratively. :param root: The root node of the binary tree. :return: A list of node values in in-order sequence. result, stack = [], [] current = root while current or stack: while current: stack.append(current) current = current.left current = stack.pop() result.append(current.val) current = current.right return result def inorder_rec(root): Perform in-order traversal recursively. :param root: The root node of the binary tree. :return: A list of node values in in-order sequence. def helper(node): if node: yield from helper(node.left) yield node.val yield from helper(node.right) return list(helper(root))"},{"question":"# Caesar Cipher - Enhanced Encryption Context Julius Caesar used a simple yet effective way to encrypt his confidential messages - by shifting each letter by a fixed number of positions in the alphabet. You are tasked with implementing a correct and optimized version of this algorithm with some extensions to handle cases beyond basic lowercase and uppercase letters. Task Write a function, `enhanced_caesar_cipher`, that: 1. Encrypts a given string `s` using a fixed integer shift `k`. 2. Retains the case of the letters (uppercase remains uppercase, lowercase remains lowercase). 3. Leaves non-letter characters (like digits, punctuation, spaces) unchanged. 4. Handles cases where `k` can be a very large integer (effectively rotating `\'k % 26\'` times). Function Signature ```python def enhanced_caesar_cipher(s: str, k: int) -> str: pass ``` Input * `s` (String): The string to be encrypted. Length: 1 <= len(s) <= 10^5 * `k` (Integer): The integer shift. -10^9 <= k <= 10^9 Output * Returns the encrypted string. Constraints * The string can contain any printable ASCII characters. Examples ```python assert enhanced_caesar_cipher(\\"Abc Xyz-123\\", 3) == \\"Def Abc-123\\" assert enhanced_caesar_cipher(\\"Hello, World!\\", 7) == \\"Olssv, Dvysk!\\" assert enhanced_caesar_cipher(\\"Secure123!\\", -3) == \\"Pbzrfv123!\\" assert enhanced_caesar_cipher(\\"No Change\\", 26) == \\"No Change\\" assert enhanced_caesar_cipher(\\"WrapAround\\", 52) == \\"WrapAround\\" ``` Explanation of Examples 1. `\\"Abc Xyz-123\\"`, shifted by 3 positions, reproduces `\\"Def Abc-123\\"`. 2. Non-alphabet characters remain unchanged. 3. The function correctly wraps around the alphabet and retains case sensitivity. 4. Negative shifts should effectively decrypt by the reverse shift. Your implementation should aim for clarity and efficiency. Think about handling edge cases robustly. Happy coding!","solution":"def enhanced_caesar_cipher(s: str, k: int) -> str: def shift_char(c, k): if \'a\' <= c <= \'z\': return chr(((ord(c) - ord(\'a\') + k) % 26) + ord(\'a\')) elif \'A\' <= c <= \'Z\': return chr(((ord(c) - ord(\'A\') + k) % 26) + ord(\'A\')) return c result = [] k = k % 26 # Normalize k to be within 0-25 for char in s: result.append(shift_char(char, k)) return \'\'.join(result)"},{"question":"# Scenario Imagine you are developing a text editor which allows users to undo and redo their actions. To achieve this, you need to implement a data structure that supports bidirectional traversal efficiently. A doubly linked list is a suitable choice for this task. # Task Your task is to implement a `DoublyLinkedList` class with the following functionalities: 1. `append(value)`: Add a new element with the specified value at the end of the list. 2. `prepend(value)`: Add a new element with the specified value at the beginning of the list. 3. `delete(value)`: Remove the first occurrence of the specified value from the list. 4. `find(value)`: Return the position (0-based index) of the first occurrence of the specified value, or -1 if not found. 5. `display()`: Print the entire list from head to tail. 6. `reverse_display()`: Print the entire list from tail to head. # Input and Output Formats **append(value)**: - Input: An integer value. - Output: None. **prepend(value)**: - Input: An integer value. - Output: None. **delete(value)**: - Input: An integer value. - Output: None. **find(value)**: - Input: An integer value. - Output: An integer representing the 0-based index or -1 if not present. **display()**: - Input: None. - Output: List of integers from head to tail. **reverse_display()**: - Input: None. - Output: List of integers from tail to head. # Constraints - Each element in the list is an integer. - Maximum number of elements to be stored in the linked list is 10^4. - The input value for any function will be a valid integer within the range of 32-bit signed integers. Here\'s the initial skeleton class to get you started: ```python class DoublyLinkedListNode: def __init__(self, value): self.value = value self.next = None self.prev = None class DoublyLinkedList: def __init__(self): self.head = None self.tail = None def append(self, value): pass def prepend(self, value): pass def delete(self, value): pass def find(self, value): pass def display(self): pass def reverse_display(self): pass ``` Implement the `DoublyLinkedList` class with the specified methods to fulfill the task requirements.","solution":"class DoublyLinkedListNode: def __init__(self, value): self.value = value self.next = None self.prev = None class DoublyLinkedList: def __init__(self): self.head = None self.tail = None def append(self, value): new_node = DoublyLinkedListNode(value) if self.tail is None: self.head = self.tail = new_node else: self.tail.next = new_node new_node.prev = self.tail self.tail = new_node def prepend(self, value): new_node = DoublyLinkedListNode(value) if self.head is None: self.head = self.tail = new_node else: new_node.next = self.head self.head.prev = new_node self.head = new_node def delete(self, value): current = self.head while current: if current.value == value: if current.prev: current.prev.next = current.next if current.next: current.next.prev = current.prev if current == self.head: self.head = current.next if current == self.tail: self.tail = current.prev return current = current.next def find(self, value): current = self.head position = 0 while current: if current.value == value: return position current = current.next position += 1 return -1 def display(self): current = self.head result = [] while current: result.append(current.value) current = current.next return result def reverse_display(self): current = self.tail result = [] while current: result.append(current.value) current = current.prev return result"},{"question":"You are tasked to implement a function that given two non-negative integers ( a ) and ( b ), computes their Greatest Common Divisor (gcd) and their Least Common Multiple (lcm) using bitwise operations efficiently. Also, you must count the number of trailing zeros of the given gcd and lcm results. Function Specifications: - **Function Name**: `gcd_lcm_trailing_zeros` - **Inputs**: Two non-negative integers ( a ) and ( b ). - **Outputs**: A tuple (gcd, lcm, trailing_zeros_gcd, trailing_zeros_lcm) where: - `gcd` is the greatest common divisor of ( a ) and ( b ). - `lcm` is the least common multiple of ( a ) and ( b ). - `trailing_zeros_gcd` is the number of trailing zeros in the binary representation of `gcd`. - `trailing_zeros_lcm` is the number of trailing zeros in the binary representation of `lcm`. Constraints: 1. (0 leq a, b leq 10^6) 2. Return 0 for `gcd` and `lcm` when both ( a ) and ( b ) are zero. Function Signature: ```python def gcd_lcm_trailing_zeros(a: int, b: int) -> tuple: pass ``` Example: ```python # Example 1 Input: a = 24, b = 36 Output: (12, 72, 2, 3) # Example 2 Input: a = 0, b = 5 Output: (5, 0, 0, 0) ``` Notes: - Utilize bitwise operations where possible to optimize calculations. - Consider efficient edge case handling, especially for zeros. - Ensure the function is optimal and handles large inputs within allowed constraints.","solution":"def gcd_lcm_trailing_zeros(a: int, b: int) -> tuple: def gcd(x, y): while y: x, y = y, x % y return x def lcm(x, y): return (x * y) // gcd(x, y) if x and y else 0 def count_trailing_zeros(n): count = 0 while n > 0 and (n & 1) == 0: count += 1 n >>= 1 return count if a == 0 and b == 0: return (0, 0, 0, 0) gcd_result = gcd(a, b) lcm_result = lcm(a, b) trailing_zeros_gcd = count_trailing_zeros(gcd_result) trailing_zeros_lcm = count_trailing_zeros(lcm_result) return (gcd_result, lcm_result, trailing_zeros_gcd, trailing_zeros_lcm)"},{"question":"# Question: Implement ZigZag Iterator for Multiple Lists You are required to implement a generalized ZigZag Iterator that can handle multiple input lists instead of just two. The iterator should provide elements in a zigzag order from all input lists until they are exhausted. Function Signatures ```python class ZigZagIterator: def __init__(self, lists: List[List[int]]): pass def next(self) -> int: pass def has_next(self) -> bool: pass ``` Input/Output: * **Initialization Input**: A list of lists of integers (`lists`), e.g. `[[1, 2], [3, 4, 5, 6], [7, 8, 9]]`. * **Output**: - `next()`: Returns the next element in zigzag order. - `has_next()`: Returns a boolean indicating if more elements are remaining. Constraints: * The input list of lists might contain empty lists, which should be handled gracefully. * Elements in the input lists can be negative or positive integers. # Example: ```python lists = [[1, 2], [3, 4, 5, 6], [7, 8, 9]] it = ZigZagIterator(lists) result = [] while it.has_next(): result.append(it.next()) print(result) # Expected Output: [1, 3, 7, 2, 4, 8, 5, 9, 6] ``` # Implementation Notes: 1. Ensure the iterator handles any number of lists, including edge cases where some lists might be empty. 2. Maintain good performance, ideally keeping each method call to O(1) operations.","solution":"from collections import deque class ZigZagIterator: def __init__(self, lists: list[list[int]]): Initialize the iterator with a list of lists. self.queue = deque((lst, 0) for lst in lists if lst) def next(self) -> int: Return the next element in zigzag order. if self.has_next(): lst, index = self.queue.popleft() value = lst[index] if index + 1 < len(lst): self.queue.append((lst, index + 1)) return value raise StopIteration(\\"No more elements in the iterator\\") def has_next(self) -> bool: Return True if there are more elements to iterate over, else False. return bool(self.queue)"},{"question":"# Zigzag Iterator Problem You are given two integer lists `v1` and `v2`. Your task is to implement a Zigzag Iterator class that iterates through these lists in a zigzag fashion. Specifically, you should create a class `ZigzagIterator` that supports the following methods: 1. `__init__(self, v1: List[int], v2: List[int])`: Initializes the iterator with the two lists. 2. `next(self) -> int`: Returns the next element in the zigzag sequence. 3. `has_next(self) -> bool`: Returns `True` if there are more elements to iterate, otherwise `False`. Implement the following class: ```python class ZigzagIterator: def __init__(self, v1: List[int], v2: List[int]): # Initialize your data structure here. pass def next(self) -> int: # Implement the logic to return the next element in zigzag order. pass def has_next(self) -> bool: # Implement the logic to determine whether there are more elements. pass ``` **Input/Output:** - **Input**: Two lists of integers, `v1` and `v2`. - **Output**: An instance of the `ZigzagIterator`, with methods to fetch the next element in zigzag order and to check if there are more elements. **Constraints:** - Each list can contain between 0 and 100 elements. - The elements of each list are integers between -10^9 and 10^9. **Scenario:** Consider the following scenario for better understanding: ```python l1 = [1, 2] l2 = [3, 4, 5, 6] it = ZigzagIterator(l1, l2) result = [] while it.has_next(): result.append(it.next()) print(result) # Output should be [1, 3, 2, 4, 5, 6] ``` You need to handle cases where one list is empty and cases where the lists have different lengths. **Note**: - Your implementation should handle the interleaving of items correctly. - Ensure the solution meets the performance requirements and handles edge cases effectively.","solution":"class ZigzagIterator: def __init__(self, v1, v2): self.v1 = v1 self.v2 = v2 self.i1 = 0 self.i2 = 0 self.turn = 0 # 0 for list1\'s turn, 1 for list2\'s turn def next(self): if self.i1 < len(self.v1) and (self.turn == 0 or self.i2 >= len(self.v2)): result = self.v1[self.i1] self.i1 += 1 else: result = self.v2[self.i2] self.i2 += 1 self.turn = 1 - self.turn # flip the turn return result def has_next(self): return self.i1 < len(self.v1) or self.i2 < len(self.v2)"},{"question":"# Context You are given a binary tree where each node contains an integer value and potentially two child nodes. Your task is to efficiently implement procedures to serialize this tree into a string and then deserialize the string back into the original binary tree structure. # Problem Statement Implement two functions `serialize(root: TreeNode) -> str` and `deserialize(data: str) -> TreeNode` to serialize and deserialize a binary tree. # Functions Details 1. `serialize(root: TreeNode) -> str` - **Input**: `root`, the root node of the binary tree. - **Output**: A string representing the binary tree using pre-order traversal with `#` denoting null nodes. 2. `deserialize(data: str) -> TreeNode` - **Input**: `data`, the string representation of the binary tree generated by `serialize`. - **Output**: The root node of the binary tree reconstructed from the string. # Constraints - The number of nodes in the binary tree will be in the range `[0, 10^4]`. - Node values are between `-10^5` and `10^5`. - Design your solution such that both functions run in `O(n)` time complexity where `n` is the number of nodes in the tree. # Example ```python # Example usage # Constructing the binary tree: # 1 # / # 2 3 # / # 4 5 root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.right.left = TreeNode(4) root.right.right = TreeNode(5) serialized = serialize(root) print(serialized) # Output should be similar to: \\"1 2 # # 3 4 # # 5 # #\\" deserialized_root = deserialize(serialized) print(deserialized_root.val) # Output: 1 print(deserialized_root.left.val) # Output: 2 print(deserialized_root.right.val) # Output: 3 print(deserialized_root.right.left.val) # Output: 4 print(deserialized_root.right.right.val) # Output: 5 ``` By completing these functions, you demonstrate your understanding of tree traversal, recursive methods, and handling edge cases in complex data structures.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def serialize(root: TreeNode) -> str: Encodes a tree to a single string. def dfs(node): if node is None: return \'#\' left_serialized = dfs(node.left) right_serialized = dfs(node.right) return f\\"{node.val} {left_serialized} {right_serialized}\\" return dfs(root) def deserialize(data: str) -> TreeNode: Decodes your encoded data to tree. def dfs(nodes): val = nodes.pop(0) if val == \'#\': return None node = TreeNode(int(val)) node.left = dfs(nodes) node.right = dfs(nodes) return node node_list = data.split() root = dfs(node_list) return root"},{"question":"# Question: You are provided with an array of integers. You need to implement the Comb Sort algorithm to sort the array. Comb Sort is a modified version of Bubble Sort which sorts elements further apart to eliminate turtles (small values near the end of the list) faster. Function Signature: ```python def comb_sort(arr: List[int]) -> List[int]: ``` Input: * A list of integers, `arr` (0 <= len(arr) <= 10^5) where elements can be any integer including negative numbers. Output: * The sorted list of integers in ascending order. Constraints: * You should aim to optimize the solution in terms of time and space complexity. * You must implement the Comb Sort algorithm as described. Example: ```python assert comb_sort([34, 8, 64, 51, 32, 21]) == [8, 21, 32, 34, 51, 64] assert comb_sort([5, 1, 4, 2, 8]) == [1, 2, 4, 5, 8] assert comb_sort([]) == [] assert comb_sort([1]) == [1] assert comb_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] ``` Make sure to handle edge cases appropriately, such as an empty list, lists with one element, or lists with large numbers of elements efficiently.","solution":"from typing import List def comb_sort(arr: List[int]) -> List[int]: Sorts the array using the Comb Sort algorithm. def get_next_gap(gap): Calculate the next gap. gap = (gap * 10) // 13 return max(gap, 1) n = len(arr) gap = n swapped = True while gap != 1 or swapped: gap = get_next_gap(gap) swapped = False for i in range(n - gap): if arr[i] > arr[i + gap]: arr[i], arr[i + gap] = arr[i + gap], arr[i] swapped = True return arr"},{"question":"You are required to write a function that calculates the extended Hailstone sequence for a given positive integer n. The extended version of the sequence also returns the length of the sequence and the peak value (the highest number encountered in the sequence). Function Signature ```python def extended_hailstone(n: int) -> (int, int, list): pass ``` Input - `n` (1 ≤ n ≤ 10^6): A positive integer representing the starting point of the Hailstone sequence. Output A tuple containing: - The length of the sequence. - The peak value of the sequence. - The complete sequence as a list of integers. Constraints 1. You must handle cases where n is already 1. 2. You should ensure your solution is efficient both in terms of time and space. 3. Avoid recursion to prevent stack overflow for large values of n. Example ```python # Example 1 extended_hailstone(5) # Expected Output: (6, 16, [5, 16, 8, 4, 2, 1]) # Example 2 extended_hailstone(1) # Expected Output: (1, 1, [1]) ``` Performance Requirements Your solution should be able to handle the upper constraint of n (10^6) within a reasonable time and should not exhaust memory resources.","solution":"def extended_hailstone(n: int) -> (int, int, list): Calculates the extended Hailstone sequence for a given positive integer n. Returns the length of the sequence, the peak value (highest number in sequence), and the complete sequence as a list of integers. sequence = [] peak = n current = n while current != 1: sequence.append(current) if current % 2 == 0: current = current // 2 else: current = 3 * current + 1 peak = max(peak, current) sequence.append(1) # Append the last number which is always 1 return (len(sequence), peak, sequence)"},{"question":"You are given a data structure to manage and manipulate intervals of real numbers. Your task is to enhance its functionality by adding a new method `find_gaps` that identifies gaps between a set of potentially overlapping or adjacent intervals, and an `expand` method that expands each interval by a given amount on both sides. Function Specification 1. `find_gaps(intervals: List[Interval]) -> List[Tuple[int, int]]` - **Input**: A list of `Interval` objects, which may overlap or be adjacent. - **Output**: A list of tuples representing the gaps between the intervals after they have been merged. 2. `expand(interval: Interval, amount: int) -> Interval` - **Input**: An `Interval` object and an integer `amount` specifying how much to expand the interval on both sides. - **Output**: A new `Interval` object that has been expanded by the given amount. # Implementation Guidance - The `find_gaps` method should first merge the input intervals and then identify the gaps. - The `expand` method should increase the start and end points of the interval appropriately without overlapping existing intervals. - For `find_gaps`, ensure the result list is ordered by the starting point of the gaps. - Handle edge cases like empty interval lists, intervals with negative bounds, and overlapping intervals carefully. # Example ```python intervals = [Interval(1, 5), Interval(8, 10), Interval(4, 9)] expanded_interval = expand(Interval(2, 4), 2) gaps = find_gaps(intervals) assert repr(expanded_interval) == \\"Interval (0, 6)\\" assert gaps == [(9, 10)] ``` # Constraints - Assume all intervals are valid with start < end. - Intervals can be negative, zero, or positive. - Focus on optimizing the merge and gap-finding algorithms for large input sizes. Implement the `find_gaps` and `expand` functions in Python to complete the task.","solution":"from typing import List, Tuple class Interval: def __init__(self, start: int, end: int): self.start = start self.end = end def __repr__(self): return f\\"Interval ({self.start}, {self.end})\\" def merge_intervals(intervals: List[Interval]) -> List[Interval]: if not intervals: return [] # Sort intervals based on the starting point sorted_intervals = sorted(intervals, key=lambda x: x.start) merged = [sorted_intervals[0]] for current in sorted_intervals[1:]: last = merged[-1] if current.start <= last.end: # Overlapping intervals, merge them last.end = max(last.end, current.end) else: merged.append(current) return merged def find_gaps(intervals: List[Interval]) -> List[Tuple[int, int]]: if not intervals: return [] merged_intervals = merge_intervals(intervals) gaps = [] for i in range(1, len(merged_intervals)): current_end = merged_intervals[i-1].end next_start = merged_intervals[i].start if current_end < next_start: gaps.append((current_end, next_start)) return gaps def expand(interval: Interval, amount: int) -> Interval: return Interval(interval.start - amount, interval.end + amount)"},{"question":"Context Alice is learning about number theory and cryptography. She is particularly fascinated by the concept of primitive roots and their importance in cryptographic algorithms. She needs to write a function to identify all the primitive roots of a given positive integer n. However, she encounters performance issues with larger values of n. Task Your task is to write a function `find_primitive_root_optimized` that efficiently finds all primitive roots of a given integer n using the provided code snippets. You must incorporate any optimizations to make the solution more efficient for larger values of n. Function Signature ```python def find_primitive_root_optimized(n: int) -> list: pass ``` Input Format * A single positive integer `n` (1 ≤ n ≤ 10^6). Output Format * A list of all primitive roots of the integer n in ascending order. If no primitive roots exist, return an empty list. Constraints * Your solution must have optimized performance to handle large values of n efficiently. Performance Requirements * Aim for a time complexity better than O(n^2 log n). Example ```python # Example 1 print(find_primitive_root_optimized(10)) # Output: [] # Example 2 print(find_primitive_root_optimized(13)) # Output: [2, 6, 7, 11] ``` Special Instructions * Handle all possible edge cases gracefully. * Use memoization or efficient computation techniques where applicable. * Avoid direct copying of the provided snippets; instead, incorporate necessary optimizations. Good luck!","solution":"def gcd(a, b): while b: a, b = b, a % b return a def is_primitive_root(n, candidate): required_set = {num for num in range(1, n) if gcd(num, n) == 1} actual_set = {pow(candidate, powers, n) for powers in range(1, n)} return required_set == actual_set def find_primitive_root_optimized(n: int) -> list: if n == 1: return [] # Check if n is prime if not any(n % i == 0 for i in range(2, int(n**0.5) + 1)): required_set = set(range(1, n)) primitive_roots = [g for g in range(2, n) if required_set == {pow(g, powers, n) for powers in range(1, n)}] return primitive_roots return [] # Example usage print(find_primitive_root_optimized(10)) # Output: [] print(find_primitive_root_optimized(13)) # Output: [2, 6, 7, 11]"},{"question":"# Question: Advanced Graph Pathfinding Challenge **Scenario**: You are a software developer working on a route planning application for a delivery service company. The company needs to find not only possible routes between locations but also the shortest route to optimize delivery times. Your task is to implement these functionalities based on a provided graph representation of the city. **Graph Representation**: The graph is represented as a dictionary where keys are node names (locations) and values are lists of neighboring nodes. **Task**: 1. Implement a function `find_path(graph, start, end)` to find any one path from the starting location to the ending location. 2. Implement a function `find_all_paths(graph, start, end)` to find all possible paths from the starting location to the ending location. 3. Implement a function `find_shortest_path(graph, start, end)` to find the shortest path from the starting location to the ending location. **Expected Input/Output**: - Input: ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'A\', \'D\', \'E\'], \'C\': [\'A\', \'F\'], \'D\': [\'B\'], \'E\': [\'B\', \'F\'], \'F\': [\'C\', \'E\'] } start = \'A\' end = \'F\' ``` - Output: - `find_path(graph, start, end)` should return any valid path, e.g., `[\'A\', \'B\', \'E\', \'F\']`. - `find_all_paths(graph, start, end)` should return all valid paths, e.g., `[[\'A\', \'B\', \'D\'], [\'A\', \'C\']]`. - `find_shortest_path(graph, start, end)` should return the shortest path, e.g., `[\'A\', \'C\', \'F\']`. **Constraints**: - You can assume all inputs are valid. - Consider edge cases like no path between start and end, start or end not present in the graph. - Optimize for performance where possible. ```python def find_path(graph, start, end): # Your implementation here pass def find_all_paths(graph, start, end): # Your implementation here pass def find_shortest_path(graph, start, end): # Your implementation here pass ``` **Performance Requirements**: - The solution should handle graphs with up to 10^3 nodes and 10^4 edges efficiently. **Additional Points**: - Document your code and explain the logic used in the comments. - Include test cases to verify the correctness of your implementation.","solution":"def find_path(graph, start, end, path=None): Finds any path from start node to end node. if path is None: path = [] path = path + [start] if start == end: return path if start not in graph: return None for node in graph[start]: if node not in path: new_path = find_path(graph, node, end, path) if new_path: return new_path return None def find_all_paths(graph, start, end, path=None): Finds all paths from start node to end node. if path is None: path = [] path = path + [start] if start == end: return [path] if start not in graph: return [] paths = [] for node in graph[start]: if node not in path: new_paths = find_all_paths(graph, node, end, path) for p in new_paths: paths.append(p) return paths def find_shortest_path(graph, start, end, path=None): Finds the shortest path from start node to end node. if path is None: path = [] path = path + [start] if start == end: return path if start not in graph: return None shortest = None for node in graph[start]: if node not in path: new_path = find_shortest_path(graph, node, end, path) if new_path: if shortest is None or len(new_path) < len(shortest): shortest = new_path return shortest"},{"question":"# Binary Search Tree Operations A Binary Search Tree (BST) is a fundamental data structure that supports key operations like insertion, searching, and deletion. For this challenge, you will implement specific operations for a BST based on the given class definition for `TreeNode`. Task Implement the following methods for the BST: 1. `insert(root, key)`: Insert a node with value `key` into the BST rooted at `root`. 2. `search(root, key)`: Search for a node with value `key` in the BST rooted at `root`. Return `True` if found, else `False`. 3. `delete(root, key)`: Delete a node with value `key` from the BST rooted at `root`. Method Signatures ```python class TreeNode: def __init__(self, val=0): self.val = val self.left = None self.right = None class BST: def insert(self, root: TreeNode, key: int) -> TreeNode: pass def search(self, root: TreeNode, key: int) -> bool: pass def delete(self, root: TreeNode, key: int) -> TreeNode: pass ``` Input and Output Formats * **`insert` method**: * **Input**: `root` (TreeNode) - root of the BST, `key` (int) - value to be inserted. * **Output**: Returns the root of the modified BST. * **`search` method**: * **Input**: `root` (TreeNode) - root of the BST, `key` (int) - value to be searched. * **Output**: `True` if the value is found, otherwise `False`. * **`delete` method**: * **Input**: `root` (TreeNode) - root of the BST, `key` (int) - value to be deleted. * **Output**: Returns the root of the modified BST. Constraints * All integer values are within the range `[-10^4, 10^4]`. * Assume that `key` is unique for `insert` and `delete` operations. Example ```python bst = BST() root = TreeNode(5) root = bst.insert(root, 3) root = bst.insert(root, 7) root = bst.insert(root, 2) # Search for a node assert bst.search(root, 7) == True assert bst.search(root, 4) == False # Delete a node root = bst.delete(root, 3) assert bst.search(root, 3) == False ``` Implement these methods and test them with various edge cases to ensure correctness.","solution":"class TreeNode: def __init__(self, val=0): self.val = val self.left = None self.right = None class BST: def insert(self, root: TreeNode, key: int) -> TreeNode: if root is None: return TreeNode(key) if key < root.val: root.left = self.insert(root.left, key) else: root.right = self.insert(root.right, key) return root def search(self, root: TreeNode, key: int) -> bool: if root is None: return False if root.val == key: return True elif key < root.val: return self.search(root.left, key) else: return self.search(root.right, key) def delete(self, root: TreeNode, key: int) -> TreeNode: if root is None: return None if key < root.val: root.left = self.delete(root.left, key) elif key > root.val: root.right = self.delete(root.right, key) else: # Node to be deleted found if root.left is None: return root.right elif root.right is None: return root.left # Node with both left and right children min_larger_node = self.find_min(root.right) root.val = min_larger_node.val root.right = self.delete(root.right, min_larger_node.val) return root def find_min(self, root: TreeNode) -> TreeNode: while root.left is not None: root = root.left return root"},{"question":"Problem Statement Implement the `enhanced_comb_sort` function which improves upon the standard comb sort algorithm by accommodating a dynamically adjustable shrinking factor based on the input array characteristics. The function should be efficient for both small and large datasets while maintaining the simplicity and adaptiveness of the comb sort algorithm. # Function Signature ```python def enhanced_comb_sort(arr: List[int]) -> List[int]: ``` # Input * A list of integers `arr` [1 ≤ len(arr) ≤ 10^5]. # Output * The function should return the sorted list of integers. # Constraints * The shrinking factor should be optimized for better performance than the constant 1.3. * The algorithm must use O(1) additional space (in-place sorting). * The function should handle negative numbers, zeros, and already sorted lists efficiently. * The output list should be sorted in non-decreasing order. # Performance Requirements The sorting algorithm should strive to achieve performance close to O(N log N) for average cases. # Example ```python print(enhanced_comb_sort([5, 3, 1, 9, 7, 2, 6, 8, -1, 0])) # Output: [-1, 0, 1, 2, 3, 5, 6, 7, 8, 9] print(enhanced_comb_sort([2, 2, 2, 2, 2])) # Output: [2, 2, 2, 2, 2] print(enhanced_comb_sort([1])) # Output: [1] ``` # Note In your analysis, describe how you chose the shrinking factor and why it improves upon the default value of 1.3.","solution":"from typing import List def enhanced_comb_sort(arr: List[int]) -> List[int]: Enhanced Comb Sort implementation which uses a dynamically adjustable shrinking factor based on the characteristics of the input array. def get_next_gap(gap): # Using 1.2473309 as the shrinking factor, which is a mathematical approximation # that tends to give better results compared to the original 1.3 new_gap = int(gap / 1.2473309) if new_gap < 1: return 1 return new_gap n = len(arr) gap = n swapped = True while gap != 1 or swapped: gap = get_next_gap(gap) swapped = False for i in range(0, n - gap): if arr[i] > arr[i + gap]: arr[i], arr[i + gap] = arr[i + gap], arr[i] swapped = True return arr"},{"question":"Given a list of positive integers, implement a function `find_lcm_of_list` that computes the Least Common Multiple (LCM) of the entire list. You will need to make use of the Euclidean algorithm for GCD and the relationship between GCD and LCM. Additionally, ensure efficient handling of large lists and integer values to avoid performance bottlenecks and potential overflow errors. Function Signature ```python def find_lcm_of_list(numbers: list) -> int: pass ``` Input - `numbers`: A list of positive integers (1 ≤ len(numbers) ≤ 10^5, 1 ≤ numbers[i] ≤ 10^9). Output - An integer representing the LCM of all integers in the list. Constraints - The list will contain at least one integer. - All integers in the list are positive. Example ```python numbers = [4, 6, 8] print(find_lcm_of_list(numbers)) # Output: 24 numbers = [1, 5, 10] print(find_lcm_of_list(numbers)) # Output: 10 ``` Hints - Use the relationship: `lcm(a, b) = abs(a * b) // gcd(a, b)` - Iteratively compute the LCM for the list: `lcm(a, lcm(b, lcm(c, ...)))` Notes - Efficiently handle potential large integers to avoid integer overflow by using appropriate techniques or data types. - Consider edge cases such as large lists and large individual numbers.","solution":"import math from functools import reduce def find_lcm_of_list(numbers): Returns the Least Common Multiple (LCM) of a list of positive integers. def lcm(a, b): return abs(a * b) // math.gcd(a, b) return reduce(lcm, numbers)"},{"question":"# Question: Advanced Inorder Traversal with Depth Indicator **Scenario**: As a software engineer working on a tree data structure visualization tool, you need to display the node values of a tree along with their respective depths. Given the importance of understanding tree accuracies and levels, you\'ll perform an inorder traversal, noting the depth of each node. **Task**: Implement a function `inorder_with_depth(root)` that performs an inorder traversal of a binary tree and returns a list of tuples, where each tuple contains a node\'s value and its depth. # Function Signature ```python def inorder_with_depth(root: Node) -> List[Tuple[int, int]]: pass ``` # Input * `root` (Node): The root of the binary tree. # Output * List of tuples: Each tuple contains two integers, the first being the node\'s value and the second its depth. # Constraints * Depth starts from 0 for the root node. * The tree can have a height of up to 1000, making both recursive and iterative solutions viable within typical constraints. # Example ```python class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right # Example binary tree root = Node(100, Node(50, Node(25), Node(75)), Node(150, Node(125), Node(175))) assert inorder_with_depth(root) == [(25, 2), (50, 1), (75, 2), (100, 0), (125, 2), (150, 1), (175, 2)] ``` **Notes**: - You are encouraged to think about both iterative and recursive approaches, although you only need to implement one. - Ensure your solution handles edge cases like an empty tree and trees with varying depths.","solution":"from typing import List, Tuple class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right def inorder_with_depth(root: Node) -> List[Tuple[int, int]]: def inorder(node, depth): if node: inorder(node.left, depth + 1) result.append((node.val, depth)) inorder(node.right, depth + 1) result = [] inorder(root, 0) return result"},{"question":"# String Segmentation and Formatting Background You are working on a software tool that manages license keys. These keys are to be formatted to be more readable by humans, ensuring every `k` characters have a dash in between. A typical input might come with existing dashes that should be ignored in the output. Objective Write a function `format_license_key(key: str, k: int) -> str` that: * Takes a string `key` composed of alphanumeric characters and dashes. * An integer `k` that determines the segment length. * Returns the reformatted string where alphanumeric characters are grouped into segments of `k` characters separated by dashes, and all alphabetic characters are converted to uppercase. Input * `key`: A string of length `n` where 1 <= n <= 10^6. * `k`: An integer within the range 1 <= k <= 10^3. Output * A formatted string with alphanumeric characters grouped in segments of length `k`, separated by dashes. All alphabetical characters should be uppercase. Examples ```python assert format_license_key(\\"2-4A0r7-4k\\", 4) == \\"24A0-R74K\\" assert format_license_key(\\"2-4A0r7-4k\\", 3) == \\"24-A0R-74K\\" assert format_license_key(\\"--a-a-a-a--\\", 2) == \\"AA-AA\\" assert format_license_key(\\"2-4A0r7474k\\", 2) == \\"24-A0-R7-47-4K\\" ``` Constraints * You cannot assume that the input string will have only valid characters. * Be mindful of the performance given the potential input size. Notes * All alphabetic characters should be converted to uppercase. * Ensure that the output string does not end with a dash.","solution":"def format_license_key(key: str, k: int) -> str: Formats the input license key string such that every k characters have a dash in between. Parameters: key (str): The input license key string composed of alphanumeric characters and dashes. k (int): The segment length. Returns: str: The reformatted license key string. # Remove existing dashes and convert all characters to uppercase key = key.replace(\'-\', \'\').upper() # Initialize variables length = len(key) result = [] # Process the string in reverse to group them in chunks of k for i in range(length): if i > 0 and i % k == 0: result.append(\'-\') result.append(key[length - 1 - i]) # Reverse again to get the correct order return \'\'.join(result[::-1])"},{"question":"# Cycle Detection in Communication Networks **Context**: You are hired to develop a network management system for a large communication network. The network communications are modeled as a directed graph where each node represents a communication device and each edge represents a direct communication link between two devices. One critical feature of the system is to detect any potential loops in the communication path to prevent infinite message forwarding. **Task**: Implement a function `detect_communication_cycle` that determines if there is a cycle in the given communication network. **Function Signature**: ```python def detect_communication_cycle(network: Dict[str, List[str]]) -> bool: ``` **Input**: * `network` (Dict[str, List[str]]): A dictionary representing a directed graph where keys are the device identifiers and values are lists of device identifiers directly reachable from the key device. **Output**: * `bool`: Returns `True` if there is at least one cycle in the communication network, otherwise returns `False`. **Constraints**: * The network graph will contain at most (10^4) nodes and (10^5) edges. * The device identifiers are strings consisting of lowercase English letters. **Example**: ```python network = { \'a\': [\'b\', \'c\'], \'b\': [\'d\'], \'c\': [\'f\'], \'d\': [\'e\', \'f\'], \'e\': [\'b\'], \'f\': [] } print(detect_communication_cycle(network)) # Output: True ``` **Considerations**: * Handle both small and large graphs efficiently. * Ensure your solution respects the given constraints and handles edge cases effectively. * Focus on maintaining clarity and robustness in your coding approach.","solution":"def detect_communication_cycle(network): Function to detect if there is a cycle in the given communication network. The network is represented as a dictionary where keys are device identifiers and values are lists of device identifiers directly reachable from the key device. :param network: Dict[str, List[str]] :return: bool: True if there is a cycle, otherwise False def dfs(node): # If the node is currently in the recursion stack, a cycle is detected if node in rec_stack: return True # If the node has already been visited, no need to reprocess it if node in visited: return False # Mark the node as visited and add to recursion stack visited.add(node) rec_stack.add(node) # Recur for all neighbors for neighbor in network.get(node, []): if dfs(neighbor): return True # Remove the node from recursion stack rec_stack.remove(node) return False # Keeping track of visited nodes and recursion stack visited = set() rec_stack = set() # Perform DFS for all nodes for device in network.keys(): if device not in visited: if dfs(device): return True return False"},{"question":"# Scenario You are tasked by a software engineering company to optimize their task-scheduling system. The current system uses a basic priority queue implementation where tasks are processed based on their priority. Each task has a priority, and the task with the lowest numerical priority is processed next. However, the system suffers from inefficiencies, especially under heavy load when new tasks are frequently added. # Task Write a function that efficiently implements a priority queue using a binary heap to improve insertion performance. Your priority queue should support the following operations: 1. **Insert Task**: Add a task with a given priority. 2. **Extract Minimum Priority Task**: Remove and return the task with the lowest priority. # Input and Output Formats - The priority queue operations will be tested via the following commands: ```plaintext insert <task> <priority> extract_min ``` - For the insert operation, `<task>` is a string representing the task, and `<priority>` is an integer representing the task\'s priority. - The extract_min operation returns the task with the lowest priority. If the queue is empty, it returns \\"QUEUE EMPTY\\". # Constraints - The number of operations will not exceed 10^5. - Priority values are integers within the range ([-10^6, 10^6]). - Tasks are unique and given as non-empty strings. # Performance Requirements - Insert operation should run in O(log n) time. - Extract_min operation should run in O(log n) time. # Implementation - Implement your solution as a Python class named `OptimizedPriorityQueue` with methods `insert` and `extract_min`. # Example ```python pq = OptimizedPriorityQueue() pq.insert(\\"task1\\", 5) pq.insert(\\"task2\\", 3) print(pq.extract_min()) # Output: task2 pq.insert(\\"task3\\", 4) print(pq.extract_min()) # Output: task3 print(pq.extract_min()) # Output: task1 print(pq.extract_min()) # Output: QUEUE EMPTY ```","solution":"import heapq class OptimizedPriorityQueue: def __init__(self): self.heap = [] self.task_map = {} def insert(self, task, priority): heapq.heappush(self.heap, (priority, task)) self.task_map[task] = priority def extract_min(self): while self.heap: priority, task = heapq.heappop(self.heap) if task in self.task_map and self.task_map[task] == priority: del self.task_map[task] return task return \\"QUEUE EMPTY\\""},{"question":"# String Reversal Challenge Context: You are given several methods to reverse a string, each demonstrating different concepts of algorithm design and performance characteristics. Your task is to implement a function to reverse a string using at least two distinct methods from the provided ones. Task: Implement a function `reverse_string` that takes a string `s` and a method name `method` as input and returns the reversed string using the specified method. The `method` can be \\"recursive\\", \\"iterative\\", \\"pythonic\\", or \\"ultra_pythonic\\". Input Format: - A string `s`. - A string `method` (one of `\\"recursive\\"`, `\\"iterative\\"`, `\\"pythonic\\"`, or `\\"ultra_pythonic\\"`). Output Format: - A string that is the reverse of `s` using the specified method. Constraints: - `1 <= len(s) <= 10^5` - The input string `s` consists of printable ASCII characters. Examples: ```python assert reverse_string(\\"hello\\", \\"recursive\\") == \\"olleh\\" assert reverse_string(\\"world\\", \\"iterative\\") == \\"dlrow\\" assert reverse_string(\\"python\\", \\"pythonic\\") == \\"nohtyp\\" assert reverse_string(\\"code\\", \\"ultra_pythonic\\") == \\"edoc\\" ``` Function Signature: ```python def reverse_string(s: str, method: str) -> str: pass ``` Implement the function `reverse_string` that meets the above specifications.","solution":"def reverse_string(s: str, method: str) -> str: if method == \\"recursive\\": return recursive_reverse(s) elif method == \\"iterative\\": return iterative_reverse(s) elif method == \\"pythonic\\": return pythonic_reverse(s) elif method == \\"ultra_pythonic\\": return ultra_pythonic_reverse(s) else: raise ValueError(\\"Unknown method\\") def recursive_reverse(s: str) -> str: if len(s) == 0: return s else: return s[-1] + recursive_reverse(s[:-1]) def iterative_reverse(s: str) -> str: reversed_string = \\"\\" for char in s: reversed_string = char + reversed_string return reversed_string def pythonic_reverse(s: str) -> str: return s[::-1] def ultra_pythonic_reverse(s: str) -> str: return \'\'.join(reversed(s))"},{"question":"Scenario You are working on a text processing tool that assists by checking minor errors in user inputs. Specifically, one module of your tool needs to verify whether two given strings are at an edit distance of exactly one. This functionality is crucial for providing quick suggestions for corrections or detecting typos effectively. Task You need to write a function `is_exactly_one_edit_distance` that determines whether two strings `S` and `T` are exactly one edit distance apart. An edit is defined as the insertion, deletion, or substitution of a single character. Input * `S` and `T`: Two input strings of length `n` and `m` respectively, where `0 <= n, m <= 10^4`. Output * Return `True` if `S` and `T` are exactly one edit distance apart, otherwise return `False`. Constraints * Strings are case-sensitive. * The solution must run with a time complexity of O(n) where n is the length of the shorter string between `S` and `T`. Examples ``` Input: S = \\"abc\\", T = \\"ab\\" Output: True (deletion of \'c\') Input: S = \\"abc\\", T = \\"adc\\" Output: True (substitution of \'b\' with \'d\') Input: S = \\"abcd\\", T = \\"abxcd\\" Output: False (more than one edit distance apart) Input: S = \\"abc\\", T = \\"abc\\" Output: False (no edits required) ``` Hint Consider handling the cases for insertion, deletion, and substitution separately. Use character-by-character comparison to identify differences early.","solution":"def is_exactly_one_edit_distance(S, T): Determines if the two strings S and T are exactly one edit distance apart. n, m = len(S), len(T) # If the length difference is greater than 1, they can\'t be one edit distance apart if abs(n - m) > 1: return False # Ensure that S is the shorter string if n > m: return is_exactly_one_edit_distance(T, S) # Now we know that n <= m for i in range(n): if S[i] != T[i]: # If lengths are the same, it must be a substitution if n == m: return S[i+1:] == T[i+1:] # If lengths are different, it must be a deletion or insertion else: return S[i:] == T[i+1:] # If there is no difference found, then the only way they are one edit apart # is if T has one more character than S return n + 1 == m"},{"question":"# Context You are tasked with processing data that needs to be summarized in terms of continuous ranges. Given a sorted list of unique integers, you should identify and summarize the consecutive number sequences within the list. # Problem Statement Write a function `summarize_ranges(array: List[int]) -> List[str]` that takes a sorted list of unique integers and returns a list of strings, where each string represents a consecutive range in the list. Each range should be represented in the format `\\"start-end\\"` if the range contains more than one number, and `\\"start\\"` if the range contains only one number. # Input Format - `array` (List[int]): A sorted list of unique integers. # Output Format - A list of strings where each string represents a range. # Constraints - All integers in the list are unique and sorted in ascending order. - The list can contain up to 10^5 elements, but it may also be empty. - Performance requirements: The solution must run in O(n) time complexity. # Examples 1. Given `[0, 1, 2, 4, 5, 7]`, return `[\\"0-2\\", \\"4-5\\", \\"7\\"]`. 2. Given `[1, 2, 3, 5, 6, 7, 10]`, return `[\\"1-3\\", \\"5-7\\", \\"10\\"]`. 3. Given `[3]`, return `[\\"3\\"]`. 4. Given `[]`, return `[]`. # Notes - Ensure to handle edge cases such as singleton arrays and empty arrays. - The input guarantees that the list is sorted and elements are unique. Implement the function: ```python from typing import List def summarize_ranges(array: List[int]) -> List[str]: res = [] if len(array) == 0: return [] it = iter(array) start = end = next(it) for num in it: if num - end == 1: end = num else: res.append(f\\"{start}-{end}\\" if start != end else str(start)) start = end = num res.append(f\\"{start}-{end}\\" if start != end else str(start)) return res ```","solution":"from typing import List def summarize_ranges(array: List[int]) -> List[str]: res = [] if len(array) == 0: return [] it = iter(array) start = end = next(it) for num in it: if num - end == 1: end = num else: res.append(f\\"{start}-{end}\\" if start != end else str(start)) start = end = num res.append(f\\"{start}-{end}\\" if start != end else str(start)) return res"},{"question":"Detect Cycle in a Directed Graph You are tasked with developing an algorithm to detect whether a given directed graph contains a cycle. This is crucial in scenarios such as detecting deadlocks in systems or checking circular dependencies in software packages. You will be provided with a directed graph represented as an adjacency list. Your task is to implement a function that will return `True` if the graph contains a cycle, and `False` otherwise. # Function Signature: ```python def contains_cycle(graph: Dict[str, List[str]]) -> bool: pass ``` # Input: * A dictionary `graph`, where the keys are nodes (represented as strings) and the values are lists of nodes (also strings) representing directed edges from the key node to each node in the list. # Output: * Return `True` if there is a cycle in the graph, otherwise return `False`. # Constraints: * The graph is directed. * The graph may have self-loops and disconnected components. * The input graph will fit into memory. * Node identifiers are case-sensitive. # Example: ```python graph1 = {\'A\': [\'B\', \'C\'], \'B\': [\'D\'], \'C\': [\'F\'], \'D\': [\'E\', \'F\'], \'E\': [\'B\'], \'F\': []} graph2 = {\'A\': [\'B\'], \'B\': [\'C\'], \'C\': []} assert contains_cycle(graph1) == True, \\"Test case 1 failed\\" assert contains_cycle(graph2) == False, \\"Test case 2 failed\\" ``` # Notes: * Consider edge cases such as graphs with no edges, self-loops, and disconnected graphs. * Performance should be efficient enough to handle large graphs within acceptable runtimes.","solution":"def contains_cycle(graph): Detect if the given directed graph contains a cycle. :param graph: dict - A dictionary where the keys are nodes and the values are lists of nodes representing directed edges. :return: bool - True if there is a cycle in the graph, False otherwise. def visit(node): if node in visiting: return True if node in visited: return False visiting.add(node) for neighbor in graph.get(node, []): if visit(neighbor): return True visiting.remove(node) visited.add(node) return False visited = set() visiting = set() for node in graph: if visit(node): return True return False"},{"question":"**Scenario**: You are a software engineer tasked with maintaining and updating a linked list data structure for a financial transaction tracking application. One of the operations frequently needed is the efficient deletion of a transaction record. Because of restrictions, you can only access the node that needs to be deleted, but not the preceding node or the head of the list. # Problem Statement Implement a function `delete_node(node)` to delete a node (except the tail) in a singly linked list, given only access to that node. # Function Signature ```python def delete_node(node): pass ``` # Input/Output Description: * **Input**: A node `node` within a linked list, to be deleted. * **Output**: This function should modify the linked list in-place and does not need to return anything. * **Constraints**: * The input node will not be the tail of the list. * Every node in the list has a unique, non-null integer value. # Example Suppose the linked list is `1 -> 2 -> 3 -> 4` and you are given the third node with value `3`, after calling `delete_node(3)`, the linked list should become `1 -> 2 -> 4`. # Implementation Guidance You should ensure proper error-checking for invalid inputs: 1. Ensure `node` and `node.next` are not `None`. 2. Raise an appropriate error (e.g., `ValueError`) if invalid conditions are encountered. # Test Case To validate your implementation, you need to perform unit testing. Write a complete unit test that constructs a linked list, calls the `delete_node` function, and verifies the list\'s correctness after deletion. Example unit test is provided below: ```python import unittest class Node: def __init__(self, x): self.val = x self.next = None def delete_node(node): if node is None or node.next is None: raise ValueError(\\"Cannot delete this node\\") node.val = node.next.val node.next = node.next.next class TestSuite(unittest.TestCase): def test_delete_node(self): # Construct linked list 1 -> 2 -> 3 -> 4 head = Node(1) head.next = Node(2) head.next.next = Node(3) head.next.next.next = Node(4) # Delete node with value 3 node_to_delete = head.next.next delete_node(node_to_delete) # Verify result should be 1 -> 2 -> 4 self.assertEqual(head.val, 1) self.assertEqual(head.next.val, 2) self.assertEqual(head.next.next.val, 4) self.assertIsNone(head.next.next.next) # Edge case: try to delete tail node (should raise ValueError) tail_node = head.next.next with self.assertRaises(ValueError): delete_node(tail_node) if __name__ == \'__main__\': unittest.main() ``` Write your function `delete_node` and test thoroughly using the provided test cases to ensure correctness.","solution":"class Node: def __init__(self, x): self.val = x self.next = None def delete_node(node): Deletes a node (except the tail) from a singly linked list, given only access to that node. Parameters: node (Node): The node to be deleted. if node is None or node.next is None: raise ValueError(\\"Cannot delete this node\\") node.val = node.next.val node.next = node.next.next"},{"question":"You are tasked with implementing an improved version of Dijkstra\'s Algorithm using a priority queue to optimize it. This involves reducing the time complexity from O(V^2) to O(E log V), making it more efficient for larger graphs. # Scenario A city planning department is creating a system to determine the shortest paths between various landmarks for navigation purposes. You need to implement a function that provides this capability efficiently, even for large city maps represented as weighted graphs. # Your Task Implement an optimized version of Dijkstra\'s single-source shortest-path algorithm using a priority queue (as a min-heap). The function should work efficiently with graphs represented as an adjacency list. # Function Signature ```python def dijkstra_optimized(graph: Dict[int, List[Tuple[int, int]]], src: int) -> List[int]: :param graph: A dictionary where keys are vertex indices and values are lists of tuples; each tuple contains a neighboring vertex index and the edge weight. :param src: The source vertex index. :return: A list of minimum distances from the source to each vertex. pass ``` # Input - `graph` is a dictionary where each key represents a vertex and the associated value is a list of (neighbor, weight) pairs. For example: ```python graph = { 0: [(1, 4), (2, 1)], 1: [(3, 1)], 2: [(1, 2), (3, 5)], 3: [] } ``` - The `src` is an integer representing the source vertex index. # Output - Return a list of the shortest distances from the source vertex to every other vertex. The list index represents the corresponding vertex. # Constraints - 1 <= V <= 10^5 (vertices) - 0 <= E <= 10^6 (edges) - Edge weights are non-negative. # Example ```python graph = { 0: [(1, 4), (2, 1)], 1: [(3, 1)], 2: [(1, 2), (3, 5)], 3: [] } src = 0 print(dijkstra_optimized(graph, src)) # Output: [0, 3, 1, 4] ``` # Notes - You must use a min-heap for efficient removal of the smallest distances. - Handle all edge cases such as isolated vertices and disconnected graphs.","solution":"import heapq from typing import Dict, List, Tuple def dijkstra_optimized(graph: Dict[int, List[Tuple[int, int]]], src: int) -> List[int]: Dijkstra\'s algorithm implementation using a priority queue to find the shortest path :param graph: A dictionary where keys are vertex indices and values are lists of tuples; each tuple contains a neighboring vertex index and the edge weight. :param src: The source vertex index. :return: A list of minimum distances from the source to each vertex. V = len(graph) dist = [float(\'inf\')] * V dist[src] = 0 priority_queue = [(0, src)] # (distance, vertex) while priority_queue: current_dist, u = heapq.heappop(priority_queue) if current_dist > dist[u]: continue for neighbor, weight in graph[u]: distance = current_dist + weight if distance < dist[neighbor]: dist[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return dist"},{"question":"Given an absolute Unix-style file path, write a function to simplify it. Your function should return the canonical path which is the simplification of the given absolute path. Input The input is a single string `path` which is an absolute path. An absolute path starts with a slash \'/\' and contains only lowercase letters, slashes, periods, and possibly some redundant or complex path components such as \'..\' or multiple slashes. Output Return a canonical string which is the simplified version of the given path. Constraints - The length of `path` will be in the range [1, 3000]. - The input path will be a valid Unix-style path. Example ```plaintext Example 1: Input: \\"/home/\\" Output: \\"/home\\" Example 2: Input: \\"/a/./b/../../c/\\" Output: \\"/c\\" Example 3: Input: \\"/../\\" Output: \\"/\\" Example 4: Input: \\"/home//foo/\\" Output: \\"/home/foo\\" ``` Edge Cases 1. Path containing only a single slash \\"/\\" should return \\"/\\". 2. Path containing excess slashes such as \\"/home///foo/\\" should return \\"/home/foo\\". 3. Path that tries to go up from the root directory like \\"/../\\" should return \\"/\\". 4. Path containing \\"...\\" or similar should be considered as regular directory names. Performance Ensure your implementation runs in O(n) time complexity and uses O(n) additional space for any path length `n`. Implementation Define your function according to the following signature: ```python def simplify_path(path: str) -> str: # Your implementation here ```","solution":"def simplify_path(path: str) -> str: Simplify a given Unix-style absolute path. Args: path (str): The Unix-style absolute path to be simplified. Returns: str: The simplified (canonical) path. stack = [] parts = path.split(\'/\') for part in parts: if part == \'\' or part == \'.\': continue elif part == \'..\': if stack: stack.pop() else: stack.append(part) return \'/\' + \'/\'.join(stack)"},{"question":"Scenario: You are working as a developer for a robotics company. One of your tasks is to sort an array of wheel diameters in ascending order using a unique sorting method. This method requires minimal space usage but accepts O(N^2) time complexity due to limited hardware capabilities in certain scenarios. Problem: Implement a function `pancake_sort` that sorts an array of integers using the pancake sort algorithm. Your implementation should: 1. Find the maximum element in the unsorted portion of the array. 2. Move it to the beginning if it\'s not already there, then to the correct position by reversing sections of the array. Input and Output: * **Input**: A list of integers `arr`. - Example: `[3, 6, 1, 10, 8]` * **Output**: The sorted list in ascending order. - Example: `[1, 3, 6, 8, 10]` Function Signature: ```python def pancake_sort(arr): # your code here ``` Constraints: * The input array `arr` will contain at most 10^3 elements. * Elements of the array will be integers ranging from -10^3 to 10^3. Example: ```python >>> pancake_sort([3, 6, 1, 10, 8]) [1, 3, 6, 8, 10] >>> pancake_sort([10, 9, 8, 7, 6]) [6, 7, 8, 9, 10] ``` **Note**: Ensure your solution handles edge cases like empty arrays and arrays with only one element gracefully without errors.","solution":"def pancake_sort(arr): Sorts an array using the pancake sorting algorithm, which sorts by flipping sections of the array. def flip(sub_arr, k): Reverses the order of the first k elements of sub_arr. start = 0 while start < k: sub_arr[start], sub_arr[k] = sub_arr[k], sub_arr[start] start += 1 k -= 1 n = len(arr) for size in range(n, 1, -1): # Find index of the maximum element in the current sub-array [0:size] max_index = max(range(size), key=arr.__getitem__) # Move the maximum element to the beginning of sub-array if it\'s not already there if max_index != size - 1: # Flip the maximum element to the front if it is not at the front if max_index != 0: flip(arr, max_index) # Then flip it to its correct position flip(arr, size - 1) return arr"},{"question":"# RSA Encryption and Decryption Implementation You are required to implement a simple RSA encryption and decryption system based on the provided RSA key generation algorithm. This exercise will test your understanding of encryption algorithms and your ability to work with large integers and modular arithmetic. # Problem Statement Implement the following functions: `rsa_generate_key`, `rsa_encrypt`, and `rsa_decrypt`. # Function Signatures ```python def rsa_generate_key(bits: int, seed: int = None) -> (int, int, int): pass def rsa_encrypt(data: int, e: int, n: int) -> int: pass def rsa_decrypt(data: int, d: int, n: int) -> int: pass ``` # Input Format and Constraints - `rsa_generate_key(bits, seed)`: Generates RSA keys where `bits` is the number of bits for the modulus (n), and `seed` is an optional value to seed the random number generator for reproducibility. - `bits`: integer in the range [16, 4096]. - `seed`: integer or None (default is None). - `rsa_encrypt(data, e, n)`: Encrypts the data using the public key components (e) and (n). - `data`: integer; (0 leq data < n). - `e`: integer; the public encryption exponent. - `n`: integer; the modulus derived from the product of two primes. - `rsa_decrypt(data, d, n)`: Decrypts the data using the private key components (d) and (n). - `data`: integer; the encrypted message. - `d`: integer; the private decryption exponent. - `n`: integer; the modulus derived from the product of two primes. # Output Format - `rsa_generate_key`: Returns a tuple ( (n, e, d) ). - `rsa_encrypt`: Returns the encrypted integer. - `rsa_decrypt`: Returns the decrypted integer. # Example ```python n, e, d = rsa_generate_key(32, seed=42) # Example with a 32-bit modulus data = 20 encrypted = rsa_encrypt(data, e, n) decrypted = rsa_decrypt(encrypted, d, n) assert decrypted == data ``` # Requirements - Your implementation should correctly generate RSA keys, encrypt and decrypt an integer message. - Ensure to handle edge cases, such as when the generated primes may be inclusive of factors of e, or if modular inverses fail to compute due to non-coprime values. - Use efficient algorithms to optimize prime generation and modular arithmetic operations.","solution":"import random from sympy import isprime, mod_inverse def rsa_generate_key(bits: int, seed: int = None) -> (int, int, int): Generates RSA keys: modulus n, public key e, and private key d. if seed is not None: random.seed(seed) # Generate two distinct prime numbers p and q p = q = 1 while not isprime(p): p = random.getrandbits(bits // 2) while not isprime(q) or p == q: q = random.getrandbits(bits // 2) # Calculate modulus n = p * q # Calculate Euler\'s totient function phi = (p - 1) * (q - 1) # Choose public exponent e e = 65537 # Commonly used prime exponent if phi % e == 0: return rsa_generate_key(bits, seed) # Restart if e and phi are not coprime # Calculate private exponent d d = mod_inverse(e, phi) return (n, e, d) def rsa_encrypt(data: int, e: int, n: int) -> int: Encrypts the data using the public key components (e, n). return pow(data, e, n) def rsa_decrypt(data: int, d: int, n: int) -> int: Decrypts the data using the private key components (d, n). return pow(data, d, n)"},{"question":"Scenario You have been hired by an automation company that uses stack-based data structures to manage their task sequences. One crucial task is to ensure that the sequence of tasks follows a specific order. You are required to write a function to validate the order of tasks represented by numbers in a stack. Task Implement a function `is_sorted(stack)` that accepts a stack as a parameter and returns `True` if the elements in the stack are in increasing order from the bottom of the stack to the top (i.e., the smallest element should be at the bottom), and `False` otherwise. ```python def is_sorted(stack): # Your code here ``` Input Format * A list of integers representing the stack, with the top of the stack being the last element of the list. Output Format * A boolean value: `True` if the stack is sorted in increasing order from bottom to top, `False` otherwise. Constraints * The stack can contain any number of integers, including zero. Each integer can be positive, negative, or zero. Performance Requirements * The function should efficiently determine the order of the stack with a time complexity of (O(n)) and space complexity of (O(n)). Examples 1. Input: `[6, 3, 5, 1, 2, 4]` Output: `False` 2. Input: `[1, 2, 3, 4, 5, 6]` Output: `True` 3. Input: `[1]` Output: `True` 4. Input: `[]` Output: `True` 5. Input: `[3, 5, 8, 10, 2]` Output: `False` Explanation * For the first example, the sequence starts with 6 and after some ups and downs reaches 4, which is not sorted in ascending order. * For the second example, the elements are already in ascending order from 1 to 6. * A single element or an empty stack is trivially sorted by definition.","solution":"def is_sorted(stack): Returns True if the stack is sorted in increasing order from bottom to top. # Edge cases: empty stack or single-element stack if len(stack) <= 1: return True # Iterate through the stack elements for i in range(1, len(stack)): if stack[i-1] > stack[i]: return False return True"},{"question":"Context You are given a square matrix of integers, and the matrix can be quite large. For a specific application, you need to analyze localized sections of this matrix efficiently. Given that computing the sum of sub-squares directly can be slow due to nested loops, you decide to utilize preprocessing to speed up the sum calculations. Task Write a function that preprocesses the matrix to build a helper structure which allows retrieving the sum of any k x k sub-square in constant time. Function Signature ```python def preprocess_matrix(matrix: List[List[int]]) -> List[List[int]]: pass def sum_sub_square_with_preprocessing(preprocessed: List[List[int]], top_left: Tuple[int, int], k: int) -> int: pass ``` Input 1. The function `preprocess_matrix` takes a 2D list `matrix` of size `n x n`. 2. The function `sum_sub_square_with_preprocessing` takes: * A preprocessed 2D list `preprocessed`. * A tuple `top_left` representing the coordinates (row, col) of the top-left corner of the sub-square. * An integer `k` representing the size of the sub-square. Output 1. The function `preprocess_matrix` should return the preprocessed 2D list. 2. The function `sum_sub_square_with_preprocessing` should return an integer which is the sum of the elements in the k x k sub-square starting from `top_left`. Constraints * 1 ≤ n ≤ 1000 * 1 ≤ k ≤ n * -10^4 ≤ matrix[i][j] ≤ 10^4 * Top left corner of the sub-square should always be valid, i.e., `0 ≤ top_left[0] ≤ n-k` and `0 ≤ top_left[1] ≤ n-k`. Example ```python matrix = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ] # Preprocess the matrix preprocessed = preprocess_matrix(matrix) # Calculate sum of sub-square from top-left (1, 1) with size k=2 result = sum_sub_square_with_preprocessing(preprocessed, (1, 1), 2) print(result) # Output should be 6+7+10+11 = 34 ``` Explanation 1. Develop the preprocessing step to create the necessary structure to allow quick summation. 2. Utilize the preprocessed information to compute the sum of any k x k sub-square efficiently.","solution":"from typing import List, Tuple def preprocess_matrix(matrix: List[List[int]]) -> List[List[int]]: n = len(matrix) preprocessed = [[0] * (n + 1) for _ in range(n + 1)] for i in range(1, n + 1): for j in range(1, n + 1): preprocessed[i][j] = (matrix[i-1][j-1] + preprocessed[i-1][j] + preprocessed[i][j-1] - preprocessed[i-1][j-1]) return preprocessed def sum_sub_square_with_preprocessing(preprocessed: List[List[int]], top_left: Tuple[int, int], k: int) -> int: (r, c) = top_left r1, c1 = r + k, c + k total = preprocessed[r1][c1] - preprocessed[r1][c] - preprocessed[r][c1] + preprocessed[r][c] return total"},{"question":"# Question: Implement AVL Tree Insert Operation with Rebalancing Scenario: You are tasked with implementing the insert operation for an AVL tree that automatically maintains balance after any insertion. Your goal is to ensure that the AVL tree remains height-balanced. Function Signature: ```python class AvlTree: def insert(self, key: int) -> None: Inserts a new key into the AVL tree and rebalances if necessary. Args: key (int): The key to be inserted into the AVL tree. ``` Input: * A single integer `key` that represents the node value to be inserted into the AVL tree. Output: * The function should modify the tree in-place and ensure it remains balanced. The function does not return anything. Constraints: * All keys are unique. * Keys are integers within the range [-10^5, 10^5]. Example: ```python # Example usage: tree = AvlTree() tree.insert(10) tree.insert(20) tree.insert(15) # Inorder traversal of the tree should give [10, 15, 20] print(tree.in_order_traverse()) # Output: [10, 15, 20] ``` Notes: - Assume that all helper methods such as rotations and balance factor updates are correctly implemented. - Focus on the `insert` and `rebalance` logic.","solution":"class Node: def __init__(self, key): self.key = key self.left = None self.right = None self.height = 1 def get_height(node): return node.height if node else 0 def update_height(node): node.height = 1 + max(get_height(node.left), get_height(node.right)) def get_balance(node): return get_height(node.left) - get_height(node.right) if node else 0 def right_rotate(y): x = y.left T2 = x.right x.right = y y.left = T2 update_height(y) update_height(x) return x def left_rotate(x): y = x.right T2 = y.left y.left = x x.right = T2 update_height(x) update_height(y) return y def rebalance(node): balance = get_balance(node) if balance > 1: if get_balance(node.left) < 0: node.left = left_rotate(node.left) return right_rotate(node) if balance < -1: if get_balance(node.right) > 0: node.right = right_rotate(node.right) return left_rotate(node) return node class AvlTree: def __init__(self): self.root = None def insert(self, key: int) -> None: def _insert(root, key): if not root: return Node(key) elif key < root.key: root.left = _insert(root.left, key) else: root.right = _insert(root.right, key) update_height(root) return rebalance(root) self.root = _insert(self.root, key) def in_order_traverse(self): def _in_order_traverse(root): return _in_order_traverse(root.left) + [root.key] + _in_order_traverse(root.right) if root else [] return _in_order_traverse(self.root)"},{"question":"# Question Given an undirected graph represented as an adjacency matrix, write a function `is_bipartite_graph(matrix)` that returns `True` if the graph is bipartite, and `False` otherwise. Input: * `matrix`: A list of lists representing the adjacency matrix of the graph. `matrix[i][j]` is `1` if there is an edge between vertex `i` and vertex `j`, and `0` otherwise. Output: * Return a boolean value: `True` if the graph is bipartite, `False` otherwise. Constraints: * The number of vertices V represented in the matrix lies between `1` and `1000`. * There are no negative edges or weights; the graph is unweighted. Example: Consider the following adjacency matrix: ``` 0 1 0 0 1 0 1 0 0 1 0 1 0 0 1 0 ``` ``` matrix = [ [0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 1], [0, 0, 1, 0] ] ``` Explanation: * The vertices can be divided into two sets: {0, 2} and {1, 3} with all edges running between these sets. Output: ``` is_bipartite_graph(matrix) -> True ``` Implementation Notes: * Consider using the Breadth-First Search (BFS) method as illustrated but feel free to optimize if necessary. * Ensure to handle edge-cases like single vertices, self-loops, and disconnected graphs accordingly.","solution":"from collections import deque def is_bipartite_graph(matrix): Determines if an undirected graph represented as an adjacency matrix is bipartite. :param matrix: List of lists representing the adjacency matrix of the graph. :return: True if the graph is bipartite, False otherwise. V = len(matrix) # Initial coloring array, -1 means uncolored color = [-1] * V def bfs_check(start): queue = deque([start]) color[start] = 0 while queue: node = queue.popleft() for neighbor in range(V): if matrix[node][neighbor]: # There is an edge # If the neighbor has not been colored, color it with opposite color if color[neighbor] == -1: color[neighbor] = 1 - color[node] queue.append(neighbor) # If the neighbor is colored with the same color, return False elif color[neighbor] == color[node]: return False return True # Check all components of the graph for i in range(V): if color[i] == -1: # Not colored yet if not bfs_check(i): return False return True"},{"question":"**Context**: Alice is working on a statistical model and frequently needs to compute binomial coefficients, which represents the number of ways to choose (k) elements from a set of (n) elements. Your task is to implement a more efficient method that avoids deep recursion to handle large values of (n) and (k). **Task**: Write a function `iterative_binomial_coefficient(n, k)` that computes the binomial coefficient (C(n, k)). **Function Signature**: ```python def iterative_binomial_coefficient(n: int, k: int) -> int: ``` **Input**: - `n` (integer): the total number of elements. - `k` (integer): the number of elements to choose. **Output**: - The binomial coefficient (C(n, k)) (integer). **Constraints**: - (0 leq k leq n leq 1000) **Performance Requirements**: - The solution should efficiently handle the input constraints without causing stack overflow due to deep recursion. **Example**: ```python print(iterative_binomial_coefficient(5, 0)) # Output: 1 print(iterative_binomial_coefficient(8, 2)) # Output: 28 print(iterative_binomial_coefficient(6, 3)) # Output: 20 print(iterative_binomial_coefficient(1000, 500)) # Output should be a large integer ``` **Note**: - Your implementation should ensure correct handling for edge cases such as (k = 0), (n = k), etc. - Consider using dynamic programming or an iterative approach to optimize the performance and avoid recursion depth issues.","solution":"def iterative_binomial_coefficient(n, k): Computes the binomial coefficient C(n, k) using an iterative (dynamic programming) approach. if k < 0 or k > n: return 0 if k == 0 or k == n: return 1 if k > n - k: # Using C(n, k) = C(n, n-k) for better performance. k = n - k result = 1 for i in range(1, k + 1): result = result * (n - (i - 1)) // i return result"},{"question":"# URL Query Parameter Processor # Context: You are working on an SEO tool that needs to clean up URLs by removing redundant query parameters and specified undesired parameters. URLs often contain repeated parameters or parameters that are irrelevant to the points being analyzed. # Objective: Write a function `strip_url_params` that accomplishes the following tasks: 1. Removes any duplicate query string parameters from the URL, keeping only the first occurrence. 2. Removes any query string parameters specified within the second argument (optional array). # Function Signature: ```python def strip_url_params(url: str, params_to_strip: list = None) -> str: Remove duplicate and unwanted query parameters from the URL. Parameters: - url (str): The URL string from which to remove query parameters. - params_to_strip (list): A list of parameter keys to remove from the URL query string. Returns: - str: The cleaned URL with specified and duplicate query parameters removed. ``` # Input: * `url (str)`: A URL that may contain query parameters. * `params_to_strip (list)`: (Optional) A list of parameter keys to remove from the URL. # Output: * `str`: A URL with duplicate parameters removed and any specified parameters stripped out. # Constraints: 1. The URL will always be a valid HTTP/HTTPS URL. 2. If there are no query parameters, the URL should remain unchanged. 3. If `params_to_strip` is `None` or an empty list, only duplicate parameters should be removed. # Examples: ```python assert strip_url_params(\\"www.saadbenn.com?a=1&b=2&a=2\\") == \\"www.saadbenn.com?a=1&b=2\\" assert strip_url_params(\\"www.saadbenn.com?a=1&b=2&a=2\\", [\\"b\\"]) == \\"www.saadbenn.com?a=1\\" assert strip_url_params(\\"www.saadbenn.com?a=1&b=2&a=2&b=3\\", [\\"a\\", \\"b\\"]) == \\"www.saadbenn.com\\" assert strip_url_params(\\"www.saadbenn.com\\") == \\"www.saadbenn.com\\" ``` # Notes: * Your function should be efficient and handle large query strings gracefully. * Ensure to handle edge cases, such as URLs with only stripped parameters or no query parameters.","solution":"from urllib.parse import urlparse, parse_qsl, urlencode, urlunparse def strip_url_params(url: str, params_to_strip: list = None) -> str: Remove duplicate and unwanted query parameters from the URL. Parameters: - url (str): The URL string from which to remove query parameters. - params_to_strip (list): A list of parameter keys to remove from the URL query string. Returns: - str: The cleaned URL with specified and duplicate query parameters removed. if params_to_strip is None: params_to_strip = [] # Parse the URL into components url_parts = urlparse(url) query_params = parse_qsl(url_parts.query, keep_blank_values=True) seen_params = set() filtered_params = [] for key, value in query_params: if key not in seen_params and key not in params_to_strip: filtered_params.append((key, value)) seen_params.add(key) # Rebuild the URL with the filtered query parameters new_query_string = urlencode(filtered_params) new_url_parts = url_parts._replace(query=new_query_string) return urlunparse(new_url_parts)"},{"question":"# Cooley-Tukey FFT Implementation Context: You are working with digital signal processing and need to convert a time-domain signal to the frequency domain using the Fast Fourier Transform (FFT). You will implement the Cooley-Tukey FFT algorithm to achieve this transformation. Task: Write a function `cooley_tukey_fft` that computes the Discrete Fourier Transform (DFT) of a given complex sequence using the Cooley-Tukey FFT algorithm. Requirements: - The input array will be a list of complex numbers and its length will always be a power of 2. - Your function should return a list of complex numbers representing the DFT of the input. Input: - A list of (N) complex numbers where (N) is a power of 2. Output: - A list of (N) complex numbers representing the DFT of the input sequence. Function Signature: ```python def cooley_tukey_fft(x: List[complex]) -> List[complex]: ``` Constraints: - (2 leq N leq 1024) - Each number in the input list will be a valid complex number. Example: ```python Input: [2.0+2j, 1.0+3j, 3.0+1j, 2.0+2j] Output: [(8+8j), 2j, (2-2j), (-2+0j)] ``` Notes: - Implement efficient merging and combination steps to ensure optimal performance. - Ensure the implementation handles complex arithmetic accurately.","solution":"from typing import List import cmath def cooley_tukey_fft(x: List[complex]) -> List[complex]: Computes the DFT of the given sequence using the Cooley-Tukey FFT algorithm. Parameters: x (List[complex]): The input sequence of complex numbers. Returns: List[complex]: The DFT of the input sequence. N = len(x) if N <= 1: return x even = cooley_tukey_fft(x[0::2]) odd = cooley_tukey_fft(x[1::2]) T = [cmath.exp(-2j * cmath.pi * k / N) * odd[k] for k in range(N // 2)] return [even[k] + T[k] for k in range(N // 2)] + [even[k] - T[k] for k in range(N // 2)]"},{"question":"You are tasked with implementing a function to determine if there exists a path between two nodes in a directed graph. The graph is represented using an adjacency list. # Function Signature ```python def is_path_exists(vertex_count: int, edges: List[Tuple[int, int]], source: int, target: int) -> bool: ``` # Input * `vertex_count` (int): The number of vertices in the graph. * `edges` (List[Tuple[int, int]]): A list of tuples where each tuple represents a directed edge from the first vertex to the second vertex. * `source` (int): The starting node. * `target` (int): The destination node to check if there is a path from the source. # Output * (bool): Return `True` if there is a path from `source` to `target`, otherwise return `False`. # Constraints * The graph can have up to 10,000 vertices. * Each vertex is labeled from 0 to vertex_count - 1. * The number of edges can be up to 50,000. * Assume there are no self-loops or multiple edges between the same two vertices. # Example ```python # Input vertex_count = 4 edges = [(0, 1), (1, 2), (2, 3), (3, 0)] source = 0 target = 3 # Output True # Explanation # There is a path 0 -> 1 -> 2 -> 3 ``` # Notes * Your implementation should be efficient enough to handle the constraints. * Ensure you handle edge cases such as disconnected vertices or no edges in the graph appropriately.","solution":"def is_path_exists(vertex_count, edges, source, target): from collections import deque, defaultdict # Create adjacency list graph = defaultdict(list) for u, v in edges: graph[u].append(v) # BFS to find if there is a path from source to target visited = [False] * vertex_count queue = deque([source]) while queue: node = queue.popleft() if node == target: return True if not visited[node]: visited[node] = True for neighbor in graph[node]: if not visited[neighbor]: queue.append(neighbor) return False"},{"question":"# Problem Description You have been provided with the abstract implementation of a Queue data structure along with two concrete implementations using arrays and linked lists. Your task is to implement a new type of queue called \\"CircularQueue\\" which behaves like a Queue but uses a circular buffer instead of a dynamic array. # CircularQueue Specifications 1. **Constructor**: - Initialize the queue with a fixed capacity. 2. **enqueue(value)**: - Adds a new item to the rear of the queue. Should raise an exception if the queue is full. 3. **dequeue()**: - Removes the front item from the queue. Should raise an exception if the queue is empty. 4. **peek()**: - Returns the front element of the queue without removing it. Should raise an exception if the queue is empty. 5. **__iter__()**: - Iterates over the elements of the queue from front to rear. # Input and Output Format - **Input**: The CircularQueue should be able to handle methods input as stated in the specifications. - **Output**: Each method should behave as specified returning appropriate results. # Constraints - **Capacity** of the CircularQueue is `n` where `1 <= n <= 1000`. - Operations should be handled within O(1) time complexity unless specified otherwise. # Example ```python queue = CircularQueue(5) queue.enqueue(10) # Adds 10 queue.enqueue(20) # Adds 20 print(queue.dequeue()) # Should output 10 print(queue.peek()) # Should output 20 for value in queue: print(value) # Should output 20 queue.enqueue(30) # Adds 30 queue.enqueue(40) # Adds 40 queue.enqueue(50) # Adds 50 queue.enqueue(60) # Raises exception since the queue is full ``` Note: Make sure to handle all the edge cases for operations like enqueue in a full queue or dequeue in an empty queue. # Implementation Environment The CircularQueue should be implemented in Python within the structure provided.","solution":"class CircularQueue: def __init__(self, capacity): self.capacity = capacity self.queue = [None] * capacity self.front = 0 self.rear = -1 self.size = 0 def enqueue(self, value): if self.size == self.capacity: raise Exception(\\"Queue is full\\") self.rear = (self.rear + 1) % self.capacity self.queue[self.rear] = value self.size += 1 def dequeue(self): if self.size == 0: raise Exception(\\"Queue is empty\\") value = self.queue[self.front] self.queue[self.front] = None self.front = (self.front + 1) % self.capacity self.size -= 1 return value def peek(self): if self.size == 0: raise Exception(\\"Queue is empty\\") return self.queue[self.front] def __iter__(self): idx = self.front count = 0 while count < self.size: yield self.queue[idx] idx = (idx + 1) % self.capacity count += 1"},{"question":"# Graph Component Detection Problem Statement You are given an undirected graph represented as an adjacency list. Your task is to implement a function `find_graph_components` that finds all connected components in the graph using either Depth-First Search (DFS) or Breadth-First Search (BFS). Function Signature ```python def find_graph_components(graph: Dict[int, List[int]]) -> List[Set[int]]: pass ``` Input * `graph`: A dictionary where the keys are integers representing the nodes of the graph, and the values are lists of integers representing the connected nodes (adjacency list). Output * A list of sets, where each set contains the nodes of a connected component in the graph. Constraints * Each node in the graph will have a unique integer identifier. * The graph can have 0 or more edges. * Disconnected graphs will have multiple components. Example ```python graph = { 0: [1], 1: [0, 2], 2: [1], 3: [4], 4: [3] } print(find_graph_components(graph)) # Output: [{0, 1, 2}, {3, 4}] ``` Notes * The order of components and nodes within each component in the result does not necessarily have to be sorted. * You may assume the graph is undirected and there are no self-loops. Requirements * Efficient traversal to explore all nodes. * Consider edge cases such as empty graph, graph with one node, or multiple disconnected nodes.","solution":"def find_graph_components(graph): Returns a list of sets, where each set contains the nodes of one connected component in the graph. def dfs(node, visited, component): stack = [node] while stack: current = stack.pop() if current not in visited: visited.add(current) component.add(current) for neighbor in graph[current]: if neighbor not in visited: stack.append(neighbor) visited = set() components = [] for node in graph: if node not in visited: component = set() dfs(node, visited, component) components.append(component) return components"},{"question":"# RSA Encryption with Enhanced Key Generation Problem Statement You are tasked with implementing an RSA encryption system with an improved prime generation algorithm. The existing code uses a simple brute force method, which is inefficient. Your goal is to: 1. Implement an optimized prime generation function using a probabilistic algorithm (like Miller-Rabin). 2. Use this function in the RSA key generation algorithm. 3. Ensure that the encryption and decryption functions utilize the generated keys correctly. # Requirements * Implement the `is_prime(num)` function using the Miller-Rabin primality test. * Update `gen_prime(k)` to use the optimized `is_prime` function. * Ensure the `generate_key(k)` function uses the updated `gen_prime`. # Function Signatures ```python def is_prime(num: int, k: int = 5) -> bool: pass def gen_prime(k: int, seed: int = None) -> int: pass def generate_key(k: int, seed: int = None) -> (int, int, int): pass def encrypt(data: int, e: int, n: int) -> int: pass def decrypt(data: int, d: int, n: int) -> int: pass ``` # Input/Output * **`is_prime(num: int, k: int = 5) -> bool`**: Determines if a number is prime using the Miller-Rabin test. - **Input**: An integer `num`, optionally an integer `k` representing the number of trials for the test. - **Output**: Boolean indicating if `num` is prime. * **`gen_prime(k: int, seed: int = None) -> int`**: Generates a prime number with `k` bits. - **Input**: An integer `k` representing the bit-length of the prime, optionally a seed for randomization. - **Output**: A `k`-bit prime number. * **`generate_key(k: int, seed: int = None) -> (int, int, int)`**: Generates RSA keys `(n, e, d)`. - **Input**: An integer `k` representing the bit length, optionally a seed. - **Output**: Tuple `(n, e, d)` of the keys. * **`encrypt(data: int, e: int, n: int) -> int`**: Encrypts data using keys. - **Input**: Data to encrypt, public key exponent `e`, modulo `n`. - **Output**: Encrypted integer. * **`decrypt(data: int, d: int, n: int) -> int`**: Decrypts data using keys. - **Input**: Encrypted data, private key exponent `d`, modulo `n`. - **Output**: Decrypted integer. # Constraints * Ensure primes are correctly generated. * Maintain efficient time complexity for generating primes. * Verify encryption and decryption processes achieve ( (x^e)^d mod n = x ). # Example ```python n, e, d = generate_key(16) data = 12345 encrypted = encrypt(data, e, n) decrypted = decrypt(encrypted, d, n) assert decrypted == data # Should be True if implemented correctly ```","solution":"import random def is_prime(num, k=5): Miller-Rabin primality test. num: Number to test for primality. k: Number of iterations for accuracy. if num <= 1 or num == 4: return False if num <= 3: return True # Find d such that d * 2^r = num-1 for some r >= 1 d = num - 1 r = 0 while d % 2 == 0: d //= 2 r += 1 # Witness loop for _ in range(k): a = random.randint(2, num - 2) x = pow(a, d, num) if x == 1 or x == num - 1: continue for _ in range(r - 1): x = pow(x, 2, num) if x == num - 1: break else: return False return True def gen_prime(k, seed=None): Generate a prime number with k bits. k: Bit length of the prime number. seed: Seed for random number generation (optional). if seed is not None: random.seed(seed) while True: # Generate potential prime candidate prime_candidate = random.getrandbits(k) # Apply a bit mask to ensure it has the desired bit length and is odd prime_candidate |= (1 << k - 1) | 1 if is_prime(prime_candidate): return prime_candidate def generate_key(k, seed=None): Generate RSA public and private keys. k: Bit length for prime numbers. seed: Seed for random number generation. p = gen_prime(k // 2, seed) q = gen_prime(k // 2, seed) n = p * q phi = (p - 1) * (q - 1) e = 65537 # Commonly used prime exponent d = pow(e, -1, phi) return (n, e, d) def encrypt(data, e, n): Encrypt data using RSA. data: The integer data to encrypt. e: The public key exponent. n: The modulus. return pow(data, e, n) def decrypt(data, d, n): Decrypt data using RSA. data: The integer data to decrypt. d: The private key exponent. n: The modulus. return pow(data, d, n)"},{"question":"# Assessing Union-Find Data Structure Understanding Problem Statement You are given a grid initialized with water (represented as 0) and a list of operations where each operation turns a specified water cell into land (represented as 1). An island is formed by connecting adjacent lands horizontally or vertically. Your task is to implement a function that processes the operations and returns the number of islands after each operation. Function Signature ```python def num_islands(positions): Given a list of positions to operate, count the number of islands after each addLand operation. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water. Parameters: positions (List[List[int]]): A list of [row, col] positions to be processed. Returns: List[int]: A list where the ith element is the number of islands after the ith operation. pass ``` Input/Output * **Input**: * `positions`: A list of lists, where each inner list contains two integers representing the row and column of the cell to be converted from water to land. * Example: `positions = [[0,0], [0,1], [1,2], [2,1]]` * **Output**: * A list of integers, where each element is the number of islands formed after the corresponding operation. * Example: For `positions = [[0,0], [0,1], [1,2], [2,1]]`, the expected output would be `[1, 1, 2, 3]`. Constraints * Perform operations on a grid where all cells are initially water. * Ensure operations are processed efficiently. Example ```python assert num_islands([[0,0], [0,1], [1,2], [2,1]]) == [1, 1, 2, 3] ``` Make sure your implementation correctly keeps track of islands using the union-find data structure covered in the analysis. Consider edge cases and optimize the performance wherever applicable.","solution":"def num_islands(positions): Given a list of positions to operate, count the number of islands after each addLand operation. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water. Parameters: positions (List[List[int]]): A list of [row, col] positions to be processed. Returns: List[int]: A list where the ith element is the number of islands after the ith operation. def find(parent, i): if parent[i] != i: parent[i] = find(parent, parent[i]) return parent[i] def union(parent, rank, x, y): rootX = find(parent, x) rootY = find(parent, y) if rootX != rootY: if rank[rootX] > rank[rootY]: parent[rootY] = rootX elif rank[rootX] < rank[rootY]: parent[rootX] = rootY else: parent[rootY] = rootX rank[rootX] += 1 return True return False if not positions: return [] m = max(position[0] for position in positions) + 1 n = max(position[1] for position in positions) + 1 parent = {} rank = {} count = 0 res = [] islands = set() for pos in positions: x, y = pos if (x, y) in islands: res.append(count) continue index = x * n + y parent[index] = index rank[index] = 0 count += 1 islands.add((x, y)) for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if (nx, ny) in islands: if union(parent, rank, index, nx * n + ny): count -= 1 res.append(count) return res"},{"question":"Context You are implementing a sorting algorithm as part of a larger data analysis pipeline. Your pipeline handles a variety of data sets, some of which are already sorted, partially sorted, or completely unsorted. You need a sorting function that can handle these scenarios effectively. Problem Statement Write a function `insertion_sort_optimized(arr: list) -> list` that implements the Insertion Sort algorithm. Your function should include the following features: 1. Early termination if the list is already sorted. 2. An option to print each iteration\'s result for debugging purposes. Function Signature ```python def insertion_sort_optimized(arr: list, simulation: bool = False) -> list: pass ``` Input - `arr`: A list of integers that need to be sorted. - `simulation` (optional): If set to `True`, the function should print the array at each iteration. Output - Returns a list of integers sorted in ascending order. Constraints - The list can be of any length, including an empty list. - The list may contain duplicate elements. - Optimize the algorithm to handle nearly sorted lists more efficiently, minimizing unnecessary comparisons whenever possible. Example ```python # Example 1 arr = [5, 2, 9, 1, 5, 6] print(insertion_sort_optimized(arr)) # Output: [1, 2, 5, 5, 6, 9] # Example 2 arr = [1, 2, 3, 4, 5] print(insertion_sort_optimized(arr, simulation=True)) # Expected Debug Output (for each iteration): # iteration 0 : 1 2 3 4 5 # Output: [1, 2, 3, 4, 5] ``` Notes - Ensure that your function handles edge cases gracefully. - Consider the performance and efficiency, especially for nearly sorted lists. - You may not use any other sorting functions or libraries.","solution":"def insertion_sort_optimized(arr: list, simulation: bool = False) -> list: Sorts a list using optimized insertion sort algorithm which detects if the list is already sorted for early termination and includes debug printing. :param arr: List of integers to be sorted :param simulation: If `True`, prints the list on each iteration :return: Sorted list of integers in ascending order n = len(arr) already_sorted = True for i in range(1, n): if arr[i - 1] > arr[i]: already_sorted = False break if already_sorted: return arr for i in range(1, n): key = arr[i] j = i - 1 while j >= 0 and key < arr[j]: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key if simulation: print(\\"iteration {}: {}\\".format(i - 1, \' \'.join(map(str, arr)))) return arr"},{"question":"# Matrix Chain Multiplication Problem Context You have been hired to optimize matrix operations in a graphics processing software. Matrix operations, especially multiplication and exponentiation, are crucial for graphics transformations but are currently a bottleneck due to their high computational cost. Your task is to implement an optimized matrix multiplication and exponentiation routine using dynamic programming approaches. Problem Statement 1. **Matrix Chain Multiplication**: Given a sequence of matrices, determine the most efficient way to multiply these matrices together. The problem is not to perform the multiplications but merely to decide the sequence of matrix multiplications. 2. **Matrix Exponentiation using Dynamic Programming**: Optimize the given matrix exponentiation method using a dynamic programming approach to store intermediate results and avoid redundant calculations. Function Signatures ```python def matrix_chain_order(p: list) -> tuple: Given a list p where p[i-1] and p[i] represent the dimensions of matrix i. Returns the minimum number of multiplications needed to multiply the chain and the optimal multiplication order. Parameters: p (list): List of dimensions such that the ith matrix has dimensions p[i-1] x p[i] Returns: tuple: Minimum number of multiplications needed and the optimal order as a string. pass def optimized_matrix_exponentiation(mat: list, n: int) -> list: Optimizes the matrix exponentiation process using dynamic programming techniques. Parameters: mat (list): A 2D list representing the square matrix to be exponentiated. n (int): The power to which the matrix should be raised. Returns: list: A 2D list representing the resultant matrix after exponentiation. pass ``` Input - **For `matrix_chain_order`**: * A list of integers `p` where the ith matrix has dimensions `p[i-1] x p[i]`. - **For `optimized_matrix_exponentiation`**: * A 2D list `mat` representing a square matrix. * An integer `n` representing the power to which the matrix `mat` should be raised. Output - **For `matrix_chain_order`**: * A tuple containing the minimum number of multiplications needed to multiply the chain and the optimal multiplication order as a string. - **For `optimized_matrix_exponentiation`**: * A 2D list representing the resultant matrix after exponentiation. Constraints - Matrices should be square matrices for the `optimized_matrix_exponentiation`. - 1 < len(p) ≤ 100 (for `matrix_chain_order`). - 1 ≤ len(mat) ≤ 50 and 1 ≤ n ≤ 10^9 (for `optimized_matrix_exponentiation`). Example ```python # Running the function with example inputs p = [30, 35, 15, 5, 10, 20, 25] min_mul, order = matrix_chain_order(p) # Expected Output: (15125, detailed multiplication order string) mat = [[1, 2], [3, 4]] n = 3 result = optimized_matrix_exponentiation(mat, n) # Expected Output: [[37, 54], [81, 118]] ``` **Note**: Ensure to handle large integers and recursion limits efficiently.","solution":"def matrix_chain_order(p): n = len(p) - 1 m = [[0 for _ in range(n)] for _ in range(n)] s = [[0 for _ in range(n)] for _ in range(n)] for L in range(2, n + 1): for i in range(n - L + 1): j = i + L - 1 m[i][j] = float(\'inf\') for k in range(i, j): q = m[i][k] + m[k + 1][j] + p[i] * p[k + 1] * p[j + 1] if q < m[i][j]: m[i][j] = q s[i][j] = k def build_order(s, i, j): if i == j: return f\\"M{i+1}\\" return f\\"({build_order(s, i, s[i][j])} x {build_order(s, s[i][j] + 1, j)})\\" order = build_order(s, 0, n - 1) return m[0][n - 1], order def optimized_matrix_exponentiation(mat, n): def matrix_mult(A, B): size = len(A) C = [[0] * size for _ in range(size)] for i in range(size): for j in range(size): C[i][j] = sum(A[i][k] * B[k][j] for k in range(size)) return C def matrix_power(mat, exp): size = len(mat) result = [[1 if i == j else 0 for j in range(size)] for i in range(size)] base = mat while exp > 0: if exp % 2 == 1: result = matrix_mult(result, base) base = matrix_mult(base, base) exp //= 2 return result return matrix_power(mat, n)"},{"question":"# Bogo Sort Enhancement Challenge **Objective**: In this challenge, you\'ll enhance the provided Bogo Sort algorithm to handle specific constraints and additional requirements. # Problem Statement Write a function `bogo_sort_enhanced(arr: list[int], max_iterations: int = 1000, simulation: bool = False) -> list[int]` that sorts an array using the Bogo Sort algorithm with an additional constraint. The function should only shuffle the array up to `max_iterations` times. If the array is not sorted within `max_iterations` shuffles, return the array as it is along with a flag indicating failure. # Function Signature ```python def bogo_sort_enhanced(arr: list[int], max_iterations: int = 1000, simulation: bool = False) -> tuple[list[int], bool]: pass ``` # Inputs - `arr`: List of integers to be sorted. - `max_iterations`: (Optional) Maximum number of allowed shuffles (default is 1000). - `simulation`: (Optional) If set to `True`, print intermediate steps (default is `False`). # Output - A tuple `(sorted_list, sorted_flag)`, where `sorted_list` is the sorted array and `sorted_flag` is a boolean indicating if the sorting was successful within the allowed iterations. # Constraints - Array elements are integers. - It should handle empty arrays and arrays with non-unique elements. - The sorting process must stop after `max_iterations` shuffles if the array is not sorted. # Examples ```python print(bogo_sort_enhanced([3, 2, 1])) # Output: ([1, 2, 3], True) print(bogo_sort_enhanced([5, 3, 8, 4], max_iterations=5)) # Output: (Array could be partially sorted or not sorted along with False as flag) print(bogo_sort_enhanced([1, 2, 3], simulation=True)) # it would print each iteration and return ([1, 2, 3], True) ``` # Performance Note Due to the nature of the Bogo Sort, the expected number of iterations to sort an array correctly is on average factorial of the length of the array. Setting a large `max_iterations` might still lead to poor performance for non-trivially sized arrays.","solution":"import random def bogo_sort_enhanced(arr: list[int], max_iterations: int = 1000, simulation: bool = False) -> tuple[list[int], bool]: Sorts an array using the Bogo Sort algorithm with constraints. Parameters: arr (list[int]): The array to be sorted. max_iterations (int): The maximum number of shuffles allowed. simulation (bool): If set to True, print intermediate steps. Returns: tuple: The sorted array and a boolean flag indicating if successful within the iterations. def is_sorted(array: list[int]) -> bool: Helper function to determine if an array is sorted. for i in range(len(array) - 1): if array[i] > array[i + 1]: return False return True iteration = 0 while iteration < max_iterations: if is_sorted(arr): return arr, True random.shuffle(arr) iteration += 1 if simulation: print(f\\"Iteration {iteration}: {arr}\\") return arr, False"},{"question":"# Two-Sum Problem with Constraints You are given an array of integers and a target integer. Your task is to write a function `two_sum(array, target)` that returns the indices of the two numbers in the array such that they add up to the target, with the following constraints: 1. Each input will have exactly one solution. 2. You may not use the same element twice. 3. The function should achieve a time complexity of (O(n)) and a space complexity of (O(n)). # Input * `array`: List of integers, where ( text{len(array)} geq 2 ) * `target`: Integer # Output * A tuple of two integers representing the indices of the two numbers that add up to the target. # Constraints * Each input array will have exactly one solution. * Elements in the array may be negative or zero. # Example Example 1: * Input: `array = [2, 7, 11, 15], target = 9` * Output: `(0, 1)` Example 2: * Input: `array = [3, 2, 4], target = 6` * Output: `(1, 2)` Example 3: * Input: `array = [3, 3], target = 6` * Output: `(0, 1)` # Notes * If the inputs do not meet the conditions (e.g., array length < 2), the function should raise a `ValueError`. # Code Template ```python def two_sum(array, target): :param array: List[int], the input array of integers :param target: int, the target sum for which two integer indices are to be found :return: Tuple[int, int], indices of the two numbers that add up to the target # Implement your solution here ``` Your task is to complete the `two_sum` function to meet the above specifications.","solution":"def two_sum(array, target): :param array: List[int], the input array of integers :param target: int, the target sum for which two integer indices are to be found :return: Tuple[int, int], indices of the two numbers that add up to the target num_to_index = {} for index, num in enumerate(array): complement = target - num if complement in num_to_index: return (num_to_index[complement], index) num_to_index[num] = index raise ValueError(\\"No two sum solution found\\")"},{"question":"Matrix Inversion Verification **Objective**: Implement a function that verifies the correctness of the matrix inversion algorithm provided in the code snippet by checking the product of the original matrix and its inverted matrix. Problem Statement Given a matrix `original_matrix`, implement a function `verify_inversion(original_matrix)` that: 1. Uses the provided `invert_matrix` function to compute the inverse of `original_matrix`. 2. Verifies the correctness of this inversion by multiplying `original_matrix` with its inverted version. 3. Checks if the product is approximately equal to the identity matrix of corresponding size. # Input - A 2D list `original_matrix` where `original_matrix` is an n x n matrix (integer or floating-point values). # Output - Return `True` if the product of `original_matrix` and its inverse is approximately equal to the identity matrix, otherwise `False`. # Constraints - The matrix will be non-singular. - The matrix will be square with dimensions between 2x2 and 10x10 inclusive. - Floating-point operations may require a tolerance level for checking equality due to precision. # Example ```python original_matrix = [ [4, 7], [2, 6] ] # The inverse of the matrix is: # [[0.6, -0.7], # [-0.2, 0.4]] # Multiplying original_matrix and its inverse should give: # [[1, 0], # [0, 1]] assert verify_inversion(original_matrix) == True original_matrix = [ [1, 2], [3, 4] ] # The inverse of the matrix is: # [-2, 1], # [1.5, -0.5] # Multiplying original_matrix and its inverse should give: # [[1, 0], # [0, 1]] assert verify_inversion(original_matrix) == True # Negative test case original_matrix = [ [1, 1], [1, 1] ] # This matrix is singular (determinant is 0), inversion is not possible # However, our constraints say the matrix will always be non-singular, so no need # for this negative check in this context. ``` # Function Signature ```python def verify_inversion(original_matrix: List[List[float]]) -> bool: # Your implementation here ```","solution":"import numpy as np def invert_matrix(matrix): return np.linalg.inv(matrix) def verify_inversion(original_matrix): Verify if the inverse of a matrix is correct. # Convert the matrix to numpy array matrix_np = np.array(original_matrix) # Compute the inverse using the given function inverse_matrix_np = invert_matrix(matrix_np) # Calculate the product of the matrix and its inverse product_matrix_np = np.dot(matrix_np, inverse_matrix_np) # Create an identity matrix of the same size size = len(original_matrix) identity_matrix_np = np.identity(size) # Check if the product is approximately the identity matrix return np.allclose(product_matrix_np, identity_matrix_np)"},{"question":"String Reversal Methods As a software developer at a text-processing company, you are tasked with implementing different string reversal algorithms to understand their performance characteristics. Function Implementations You need to provide implementations for the following four functions: 1. **Recursive String Reversal** 2. **Iterative String Reversal** 3. **Pythonic String Reversal** 4. **Ultra Pythonic String Reversal** Each function should take a single input, a string `s`, and return its reversed version. **Function Signatures**: ```python def reverse_recursive(s: str) -> str: # Implement the recursive reversal here pass def reverse_iterative(s: str) -> str: # Implement the iterative reversal here pass def reverse_pythonic(s: str) -> str: # Implement the pythonic reversal using reversed() here pass def reverse_ultra_pythonic(s: str) -> str: # Implement the ultra-pythonic reversal using slicing here pass ``` Constraints - Input string `s` can have up to `10^5` characters. - The functions should handle edge cases like empty strings, single-character strings, and strings with special characters. Performance Requirements - The time complexity should be O(n) for iterative, pythonic, and ultra-pythonic methods. - Ensure your recursive method handles large inputs efficiently within language recursion limits. Example ```python # Example Usage input_str = \\"hello\\" print(reverse_recursive(input_str)) # Output: \\"olleh\\" print(reverse_iterative(input_str)) # Output: \\"olleh\\" print(reverse_pythonic(input_str)) # Output: \\"olleh\\" print(reverse_ultra_pythonic(input_str)) # Output: \\"olleh\\" ``` Provide a brief explanation of the computational complexity of each approach and why one might be preferred over the others in certain scenarios.","solution":"def reverse_recursive(s: str) -> str: Returns the reverse of the string s using a recursive approach. if len(s) <= 1: return s return s[-1] + reverse_recursive(s[:-1]) def reverse_iterative(s: str) -> str: Returns the reverse of the string s using an iterative approach. result = [] for char in s: result.insert(0, char) return \'\'.join(result) def reverse_pythonic(s: str) -> str: Returns the reverse of the string s using the reversed() function. return \'\'.join(reversed(s)) def reverse_ultra_pythonic(s: str) -> str: Returns the reverse of the string s using slicing. return s[::-1]"},{"question":"You are given a list of numbers which represent various data points. Your task is to write a function called `get_histogram` that will take this list as input and return a histogram of the values. The histogram should be represented as a dictionary, where the keys are the unique numbers from the input list, and the values are the counts of how often each number occurs in the list. This exercise will assess your ability to implement a simple but efficient counting algorithm using dictionaries, which is a fundamental concept in data structures. Function Signature ```python def get_histogram(input_list: list) -> dict: ``` Input * A list of integers, `input_list` (0 ≤ len(input_list) ≤ 10^6), where each integer can range from -10^9 to 10^9. Output * A dictionary representing the histogram of the input list. Constraints * The function should be efficient with a time complexity of O(n), where n is the length of the input list. * You should not use additional libraries (e.g., collections.Counter). Edge Cases * The function should handle an empty list and return an empty dictionary. * The list may contain negative and positive integers. Example ```python input_list = [3, 3, 2, 1] # Should return {3: 2, 2: 1, 1: 1} input_list = [2, 3, 5, 5, 5, 6, 4, 3, 7] # Should return {2: 1, 3: 2, 4: 1, 5: 3, 6: 1, 7: 1} ``` Task Implement the `get_histogram` function to complete the task as described.","solution":"def get_histogram(input_list: list) -> dict: This function takes a list of integers and returns a dictionary representing the histogram of the values in the list. Args: input_list (list): List of integers. Returns: dict: A dictionary where keys are unique integers from the input list, and values are the counts of how often each integer occurs in the list. histogram = {} for num in input_list: if num in histogram: histogram[num] += 1 else: histogram[num] = 1 return histogram"},{"question":"# Roman to Integer Conversion Background Roman numerals are represented by seven different symbols: I, V, X, L, C, D, and M. Their values are listed in the table below: ``` Symbol Value I 1 V 5 X 10 L 50 C 100 D 500 M 1000 ``` Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not \\"IIII\\". Instead, the number four is written as \\"IV\\". Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as \\"IX\\". There are six instances where subtraction is used: - I can be placed before V (5) and X (10) to make 4 and 9. - X can be placed before L (50) and C (100) to make 40 and 90. - C can be placed before D (500) and M (1000) to make 400 and 900. Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999. Task Write a function `roman_to_int(s: str) -> int` that takes a Roman numeral string `s` as input and returns the integer it represents. # Input * A single string `s` containing a Roman numeral. * The input string is guaranteed to be a valid Roman numeral within the range from 1 to 3999. # Output * An integer representing the Roman numeral. # Constraints * The input string will contain only the characters (\'I\', \'V\', \'X\', \'L\', \'C\', \'D\', \'M\'). * The length of the input string will be between 1 and 15. # Example ```python assert roman_to_int(\\"III\\") == 3 assert roman_to_int(\\"IV\\") == 4 assert roman_to_int(\\"IX\\") == 9 assert roman_to_int(\\"LVIII\\") == 58 assert roman_to_int(\\"MCMXCIV\\") == 1994 ```","solution":"def roman_to_int(s: str) -> int: Convert a Roman numeral to an integer. roman_values = { \'I\': 1, \'V\': 5, \'X\': 10, \'L\': 50, \'C\': 100, \'D\': 500, \'M\': 1000 } total = 0 prev_value = 0 for char in reversed(s): value = roman_values[char] if value < prev_value: total -= value else: total += value prev_value = value return total"},{"question":"# Coding Challenge: Efficient Task Scheduler You are working on designing a task scheduler that should organize tasks based on their priorities. Tasks with higher priority should be executed before tasks with lower priority. Your current implementation uses a linear array-based priority queue which is not efficient for large datasets. You need to implement a more efficient priority queue using a binary heap (min-heap) to improve the performance of your task scheduler. **Task** Implement a priority queue using a binary heap that supports the following operations: - `push(item, priority)`: Add an item with the given priority to the queue. - `pop()`: Remove and return the item with the highest priority (lowest numerical value of priority). # Requirements: - The `push` operation should have an average time complexity of O(log n). - The `pop` operation should have an average time complexity of O(log n). - If multiple elements have the same priority, they can be ordered arbitrarily. - If `pop` is called on an empty queue, raise an exception. **Function Signatures:** ```python class MinHeapPriorityQueue: def __init__(self): Initialize your data structure here def push(self, item: Any, priority: int) -> None: Push an item with given priority into the priority queue. def pop(self) -> Any: Remove and return the item with the lowest priority. ``` **Input Format** - For `push`: an item of any data type and an integer priority. - For `pop`: no input. **Output Format** - For `push`: no output. - For `pop`: returns an item. **Constraints** - The priorities are integers which can be positive, negative, or zero. - You can assume that there will be no overflow for integers in Python (i.e., memory limits won\'t be a concern). **Example:** ```python pq = MinHeapPriorityQueue() pq.push(\'task1\', 3) pq.push(\'task2\', 1) pq.push(\'task3\', 2) print(pq.pop()) # Output: \'task2\' print(pq.pop()) # Output: \'task3\' print(pq.pop()) # Output: \'task1\' ```","solution":"import heapq class MinHeapPriorityQueue: def __init__(self): Initialize your data structure here. self.heap = [] def push(self, item, priority): Push an item with given priority into the priority queue. heapq.heappush(self.heap, (priority, item)) def pop(self): Remove and return the item with the lowest priority. if not self.heap: raise IndexError(\\"pop from an empty priority queue\\") return heapq.heappop(self.heap)[1]"},{"question":"# Question: Implement a `BSTIterator` class that represents an iterator over a BST. The iterator should return elements in ascending order. Your implementation must include the following: 1. **`__init__(self, root: TreeNode) -> None:`**: This constructor initializes the iterator object and should set up the internal stack to represent the state of an in-order traversal starting from the root. 2. **`has_next(self) -> bool:`**: This method returns `True` if there are further elements to be iterated over and `False` otherwise. 3. **`next(self) -> int:`**: This method returns the next element in the in-order traversal of the BST. # Constraints: - The number of nodes in the tree is in the range `[0, 10^4]`. - `-10^5 <= Node.val <= 10^5`. - You may assume `next()` will always be called when `has_next()` is `True`. # Input: - The `root` parameter is the root node of a BST. # Output: - `has_next()` returns a Boolean. - `next()` returns an integer value from the BST. # Example: ```python # Define the tree nodes # 7 # / # 3 15 # / # 9 20 root = TreeNode(7) root.left = TreeNode(3) root.right = TreeNode(15) root.right.left = TreeNode(9) root.right.right = TreeNode(20) # Initialize iterator object with root iterator = BSTIterator(root) iterator.has_next() # returns True iterator.next() # returns 3 iterator.next() # returns 7 iterator.has_next() # returns True iterator.next() # returns 9 iterator.has_next() # returns True iterator.next() # returns 15 iterator.has_next() # returns True iterator.next() # returns 20 iterator.has_next() # returns False ``` # Submission: Submit your implementation of the `BSTIterator` class, ensuring that each function operates efficiently and adheres to the time and space complexity constraints.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BSTIterator: def __init__(self, root): self.stack = [] self._push_left_branch(root) def _push_left_branch(self, node): while node: self.stack.append(node) node = node.left def has_next(self): return len(self.stack) > 0 def next(self): next_node = self.stack.pop() if next_node.right: self._push_left_branch(next_node.right) return next_node.val"},{"question":"You are given an undirected graph represented as an adjacency list. Your task is to implement two functions. The first function will find a path between two nodes. The second function should find the shortest path between the two nodes. # Function 1: Find Path Implement a function `find_path(graph, start, end)` to find any path between two nodes in the graph. If there is no path, the function should return `None`. # Definition ```python def find_path(graph: dict, start: str, end: str) -> list: pass ``` # Function 2: Find Shortest Path Implement a function `find_shortest_path(graph, start, end)` to find the shortest path between two nodes based on the number of edges. If there is no path, the function should return `None`. # Definition ```python def find_shortest_path(graph: dict, start: str, end: str) -> list: pass ``` # Input * `graph` (dict): The graph represented as an adjacency list where keys are node identifiers and values are lists of adjacent nodes. * `start` (str): The starting node identifier. * `end` (str): The ending node identifier. # Output * A list of nodes representing the path from `start` to `end`. Return `None` if there is no path. # Example ```python graph = {\'A\': [\'B\', \'C\'], \'B\': [\'A\', \'D\', \'E\'], \'C\': [\'A\', \'F\'], \'D\': [\'B\'], \'E\': [\'B\', \'F\'], \'F\': [\'C\', \'E\']} print(find_path(graph, \'A\', \'F\')) # Possible Output: [\'A\', \'C\', \'F\'] print(find_shortest_path(graph, \'A\', \'F\')) # Expected Output: [\'A\', \'C\', \'F\'] ``` # Constraints * The number of nodes in the graph will not exceed 1000. * Path length (number of edges) will not exceed 1000. # Performance * Aim for a time complexity around O(V + E) for both functions, where V is the number of vertices and E is the number of edges. # Notes * The graph is undirected, meaning if node `A` is connected to `B`, then `B` is also connected to `A`. * Handle graphs with cycles properly to avoid infinite recursion.","solution":"def find_path(graph: dict, start: str, end: str) -> list: Finds any path between start and end nodes in an undirected graph. def dfs(current, target, path, visited): if current == target: return path visited.add(current) for neighbor in graph[current]: if neighbor not in visited: result = dfs(neighbor, target, path + [neighbor], visited) if result is not None: return result return None return dfs(start, end, [start], set()) def find_shortest_path(graph: dict, start: str, end: str) -> list: Finds the shortest path between start and end nodes in an undirected graph. from collections import deque queue = deque([(start, [start])]) visited = set([start]) while queue: current, path = queue.popleft() if current == end: return path for neighbor in graph[current]: if neighbor not in visited: visited.add(neighbor) queue.append((neighbor, path + [neighbor])) return None"},{"question":"You are tasked with implementing a searching algorithm in Python called `ternary_search` which finds a given key in a sorted array using the ternary search approach. The array will be sorted in ascending order. Function Signature ```python def ternary_search(left: int, right: int, key: int, arr: List[int]) -> int: ``` Input * `left` (int): The starting index of the segment of the array to search within. * `right` (int): The ending index of the segment of the array to search within. * `key` (int): The value to search for within the array. * `arr` (List[int]): The array of integers, sorted in ascending order. Output * Returns the index of the key if it is found in the array segment, otherwise returns -1. Constraints * 0 <= left <= right < len(arr) * The array of integers, `arr`, will be sorted in ascending order. * The array can contain any integer values, both positive and negative. Example ```python # Example 1: arr = [1, 5, 8, 12, 20, 35, 48, 56] key = 20 left = 0 right = len(arr) - 1 print(ternary_search(left, right, key, arr)) # Output: 4 # Example 2: arr = [2, 3, 4, 10, 40] key = 10 left = 0 right = len(arr) - 1 print(ternary_search(left, right, key, arr)) # Output: 3 ``` Context Imagine you are working on an efficient search engine. You want to implement a faster search technique to quickly locate specific elements within large datasets that are sorted. Requirements - Implement the `ternary_search` function to search the key value. - Ensure your solution handles edge cases, such as when the array is very small or key is at the edge cases.","solution":"def ternary_search(left: int, right: int, key: int, arr: list) -> int: if right >= left: mid1 = left + (right - left) // 3 mid2 = right - (right - left) // 3 if arr[mid1] == key: return mid1 if arr[mid2] == key: return mid2 if key < arr[mid1]: return ternary_search(left, mid1 - 1, key, arr) elif key > arr[mid2]: return ternary_search(mid2 + 1, right, key, arr) else: return ternary_search(mid1 + 1, mid2 - 1, key, arr) return -1"},{"question":"**Context**: Particle physics simulation often involves calculations requiring powers of transformation matrices. In this context, you are tasked with implementing a utility that efficiently computes the power of a transformation matrix for a given exponent. **Problem**: Given a square matrix `mat` of dimension `d` and a non-negative integer `p`, write a function `matrix_power(mat: list, p: int) -> list` to compute the matrix raised to the power `p` using matrix exponentiation by squaring. **Function Signature**: ```python def matrix_power(mat: list, p: int) -> list: ``` **Input**: - `mat`: A 2D list representing a `d x d` square matrix where `2 <= d <= 100`. - `p`: A non-negative integer `0 <= p <= 10^9`. **Output**: - A 2D list representing the matrix `mat` raised to the power `p`. **Constraints**: - You can assume that the matrix elements are integers, and their absolute values do not exceed 10^9. - Performance considerations are critical due to the potential for high dimensions and large exponents. **Requirements**: - You must use matrix exponentiation by squaring for optimal performance. - Avoid unnecessary recomputations and manage intermediate results efficiently. **Example**: ```python mat = [ [1, 2], [3, 4] ] p = 2 matrix_power(mat, p) # should return # [ # [ 7, 10], # [15, 22] # ] ``` **Note**: Implement and test for other edge cases, such as (mat = [[1, 0], [0, 1]]) with (p = 0), or large (p).","solution":"def matrix_power(mat, p): def matrix_multiply(A, B): Helper function to multiply two matrices. d = len(A) res = [[0] * d for _ in range(d)] for i in range(d): for j in range(d): res[i][j] = sum(A[i][k] * B[k][j] for k in range(d)) return res def matrix_identity(size): Helper function to generate an identity matrix of given size. return [[1 if i == j else 0 for j in range(size)] for i in range(size)] def matrix_exponentiate(mat, p): Helper function to perform matrix exponentiation by squaring. if p == 0: return matrix_identity(len(mat)) if p == 1: return mat half_pow = matrix_exponentiate(mat, p // 2) half_sq = matrix_multiply(half_pow, half_pow) if p % 2 == 0: return half_sq else: return matrix_multiply(mat, half_sq) return matrix_exponentiate(mat, p)"},{"question":"**Problem: Sudoku Solver** You are tasked with writing a function to solve a Sudoku puzzle. The Sudoku board is represented by a 9x9 grid where empty cells are indicated by \'.\' and filled cells contain digits \'1\'-\'9\'. Your function should fill in the empty cells abiding by the Sudoku rules. # Function Signature: ```python def solve_sudoku(board: List[List[str]]) -> bool: ``` # Input: - `board`: A 9x9 grid of characters representing the Sudoku puzzle. Empty cells are represented as \'.\', and the grid contains characters \'1\' to \'9\'. # Output: - The function should modify the input `board` in-place to fill in the empty cells such that all constraints of Sudoku are met. It should return `True` if a solution is found, otherwise `False`. # Example: ```python board = [ [\'5\', \'3\', \'.\', \'.\', \'7\', \'.\', \'.\', \'.\', \'.\'], [\'6\', \'.\', \'.\', \'1\', \'9\', \'5\', \'.\', \'.\', \'.\'], [\'.\', \'9\', \'8\', \'.\', \'.\', \'.\', \'.\', \'6\', \'.\'], [\'8\', \'.\', \'.\', \'.\', \'6\', \'.\', \'.\', \'.\', \'3\'], [\'4\', \'.\', \'.\', \'8\', \'.\', \'3\', \'.\', \'.\', \'1\'], [\'7\', \'.\', \'.\', \'.\', \'2\', \'.\', \'.\', \'.\', \'6\'], [\'.\', \'6\', \'.\', \'.\', \'.\', \'.\', \'2\', \'8\', \'.\'], [\'.\', \'.\', \'.\', \'4\', \'1\', \'9\', \'.\', \'.\', \'5\'], [\'.\', \'.\', \'.\', \'.\', \'8\', \'.\', \'.\', \'7\', \'9\'] ] result = solve_sudoku(board) print(board) ``` # Constraints: - The given board will always be of size 9x9. - The board may only contain digits \'1\'-\'9\' and the character \'.\'. - The given Sudoku puzzle will have exactly one solution. # Performance Requirements: - Your solution should efficiently solve standard Sudoku puzzles within a reasonable timeframe. # Guidelines: - You may use the provided Backtracking algorithm, but you must aim to maximize efficiency. - Handle edge cases robustly. - Follow a clear, concise, and standard coding style.","solution":"from typing import List def solve_sudoku(board: List[List[str]]) -> bool: def is_valid(board: List[List[str]], row: int, col: int, num: str) -> bool: for i in range(9): if board[row][i] == num: return False if board[i][col] == num: return False if board[row - row % 3 + i // 3][col - col % 3 + i % 3] == num: return False return True def solve(): for row in range(9): for col in range(9): if board[row][col] == \'.\': for num in map(str, range(1, 10)): if is_valid(board, row, col, num): board[row][col] = num if solve(): return True board[row][col] = \'.\' return False return True return solve()"},{"question":"# Modular Exponential Algorithm Implementation in Cryptography Scenario Cryptography often requires efficient methods to perform operations on large numbers. One such operation is computing the modular exponentiation which is pivotal in algorithms like RSA. Given the need for efficiency and correctness in handling large integers securely, you are tasked with implementing an optimized modular exponential function. Problem Statement: Implement a function `modular_exponential(base, exponent, mod)` that computes `(base^exponent) % mod` efficiently. The algorithm should work correctly for large integers and must handle edge cases effectively. Input 1. **base**: An integer, the base value (0 <= base <= 10^9). 2. **exponent**: An integer, the exponent value (0 <= exponent <= 10^9). 3. **mod**: An integer, the modulus value (1 <= mod <= 10^9). Output - An integer representing the result of `(base^exponent) % mod`. Constraints - The exponent will not be negative. - The modulus will always be greater than zero. Examples 1. `modular_exponential(2, 10, 1000)` should return `24`. 2. `modular_exponential(2, 0, 1)` should return `0`. 3. `modular_exponential(2, 0, 2)` should return `1`. 4. `modular_exponential(10, 20, 13)` should return `9`. Notes - Ensure to handle cases when the modulus is very small and when the base or exponent is zero. - Make sure the solution is efficient and avoids overflow issues by using modular arithmetic where possible.","solution":"def modular_exponential(base, exponent, mod): Computes (base^exponent) % mod efficiently. Parameters: base (int): The base value. exponent (int): The exponent value. mod (int): The modulus value. Returns: int: The result of (base^exponent) % mod. if mod == 1: return 0 # Because any number mod 1 is 0 result = 1 base = base % mod while exponent > 0: if (exponent % 2) == 1: # If exponent is odd result = (result * base) % mod exponent = exponent >> 1 # Right shift exponent by 1 (divide by 2) base = (base * base) % mod # Square the base return result"},{"question":"# Problem Context You are the developer at a company that deals with high volumes of data in the form of sequences. To keep the data clean and prevent redundancy, you often need to remove duplicate entries from these sequences. Today, you\'re working specifically with sequences stored in linked lists. # Task Write a function `remove_duplicates(head: Node) -> Node` that removes duplicate values from an unsorted singly linked list. Ensure that your function runs efficiently in terms of time and space. You should provide two specific implementations that highlight time-space trade-offs explained below. # Function Signature ```python class Node: def __init__(self, val=None): self.val = val self.next = None def remove_duplicates(head: Node) -> Node: pass def remove_duplicates_no_extra_space(head: Node) -> Node: pass ``` # Input - **head**: A reference to the first node of the singly linked list. Each node has a `val` containing the value and `next` pointing to the next node. # Output The function should modify the linked list in place, removing duplicates and maintaining the original order of the first occurrences of each value. Return the head of the modified linked list. # Constraints * The values in the linked list nodes are strings of up to 100 characters. * The linked list can contain at most 10^6 nodes. # Example ```python # Create linked list A -> A -> B -> C -> D -> C -> F -> G a1 = Node(\'A\') a2 = Node(\'A\') b = Node(\'B\') c1 = Node(\'C\') d = Node(\'D\') c2 = Node(\'C\') f = Node(\'F\') g = Node(\'G\') a1.next = a2 a2.next = b b.next = c1 c1.next = d d.next = c2 c2.next = f f.next = g # Remove duplicates using extra space result_with_space = remove_duplicates(a1) # Expected Output: A -> B -> C -> D -> F -> G # Remove duplicates without extra space result_no_space = remove_duplicates_no_extra_space(a1) # Expected Output: A -> B -> C -> D -> F -> G ``` # Requirements: 1. Implement `remove_duplicates` using extra space efficiently. 2. Implement `remove_duplicates_no_extra_space` minimizing auxiliary space at the cost of execution time. 3. Consider edge cases and ensure your implementation handles them correctly. # Constraints and Optimization Considerations: - Aim for O(N) time complexity for `remove_duplicates`. - Aim for O(1) space complexity for `remove_duplicates_no_extra_space`. - Ensure your solution is optimized for large input sizes.","solution":"class Node: def __init__(self, val=None): self.val = val self.next = None def remove_duplicates(head: Node) -> Node: Remove duplicates using extra space. This approach uses a set to track seen values. if not head: return head current = head seen = set() seen.add(current.val) while current.next: if current.next.val in seen: current.next = current.next.next else: seen.add(current.next.val) current = current.next return head def remove_duplicates_no_extra_space(head: Node) -> Node: Remove duplicates without using extra space. This approach uses no extra space but requires nested loops. if not head: return head current = head while current: runner = current while runner.next: if runner.next.val == current.val: runner.next = runner.next.next else: runner = runner.next current = current.next return head"},{"question":"# Question: Path Simplifier Given a list of file path components, write a function `simplify_path` that simplifies the list to an absolute path string. * **Input**: A list of strings representing directory names, where: - `\\"..\\"` moves up one directory level. - `\\".\\"` represents the current directory and should be ignored. - any other string represents directory names. * **Output**: A simplified absolute path as a string. **Constraints**: - Your function should handle relative paths and not assume the starting point is any specific predefined directory. - An empty list should return the root path `\\"/\\"`. - Invalid path components should be ignored. **Performance Requirements**: - The solution should have linear time complexity, O(n), where n is the number of components in the input list. **Example**: ```python # Assume the system root is \\"/\\" Input: [\\"usr\\", \\"bin\\", \\"..\\", \\"local\\", \\".\\", \\"lib\\"] Output: \\"/usr/local/lib\\" Input: [\\"..\\", \\"home\\", \\".\\", \\"user\\", \\"docs\\"] Output: \\"/home/user/docs\\" Input: [\\"..\\", \\"..\\", \\"..\\"] Output: \\"/\\" Input: [\\"usr\\", \\"bin\\", \\"..\\", \\"local\\", \\"lib\\", \\"..\\", \\"..\\"] Output: \\"/usr\\" ``` **Python Function Signature**: ```python def simplify_path(path_components): # Your code here ```","solution":"def simplify_path(path_components): Simplifies a list of path components to an absolute path string. :param path_components: List of strings representing directory names. :return: Simplified absolute path as a string. stack = [] for component in path_components: if component == \\"..\\": if stack: stack.pop() elif component == \\".\\" or component == \\"\\": continue else: stack.append(component) return \\"/\\" + \\"/\\".join(stack)"},{"question":"# Unique Morse Code Transformations Scenario You are given a list of words. Each word can be written as a concatenation of the Morse code representations of its letters. To assess your understanding of hash sets for uniqueness and string transformations, you need to write a function that returns the number of unique Morse code transformations among the given words. Function Signature ```python def unique_morse_codes(words: List[str]) -> int: ``` Input - `words`: A list of strings, where each string is a word made up of lowercase English letters. For example, `words = [\\"gin\\", \\"zen\\", \\"gig\\", \\"msg\\"]`. Output - Returns an integer which is the count of unique Morse code transformations. Constraints - `1 <= words.length <= 100` - `1 <= words[i].length <= 12` - The words only contain lowercase English letters. Example 1. **Example 1:** - Input: `words = [\\"gin\\", \\"zen\\", \\"gig\\", \\"msg\\"]` - Output: `2` - Explanation: The transformation of each word is: - \\"gin\\" -> \\"--...-.\\" - \\"zen\\" -> \\"--...-.\\" - \\"gig\\" -> \\"--...--.\\" - \\"msg\\" -> \\"--...--.\\" There are 2 unique transformations: \\"--...-.\\" and \\"--...--.\\". 2. **Example 2:** - Input: `words = [\\"a\\", \\"b\\", \\"c\\", \\"a\\"]` - Output: `3` - Explanation: Each word translates to a unique Morse code: - \\"a\\" -> \\".-\\" - \\"b\\" -> \\"-...\\" - \\"c\\" -> \\"-.-.\\" \\"a\\" is repeated but its Morse code is counted only once. Detailed Description 1. Define the Morse code dictionary for the English alphabet. 2. Write a function to transform a word into its Morse code representation by concatenating the corresponding Morse code for each letter. 3. Use a hash set to collect all the unique transformations. 4. Implement the main function to return the size of the set, indicating how many unique Morse code transformations are present.","solution":"from typing import List def unique_morse_codes(words: List[str]) -> int: morse_codes = [ \\".-\\", \\"-...\\", \\"-.-.\\", \\"-..\\", \\".\\", \\"..-.\\", \\"--.\\", \\"....\\", \\"..\\", \\".---\\", \\"-.-\\", \\".-..\\", \\"--\\", \\"-.\\", \\"---\\", \\".--.\\", \\"--.-\\", \\".-.\\", \\"...\\", \\"-\\", \\"..-\\", \\"...-\\", \\".--\\", \\"-..-\\", \\"-.--\\", \\"--..\\" ] morse_dict = {chr(i + ord(\'a\')): morse_codes[i] for i in range(26)} unique_transformations = set() for word in words: transformation = \'\'.join(morse_dict[char] for char in word) unique_transformations.add(transformation) return len(unique_transformations)"},{"question":"**Problem Statement**: You are tasked with enhancing and extending a Markov Chain model for a text generation system where each state corresponds to a word, and transitions between states are based on the preceding word in a sentence. Given a dictionary structure of a Markov Chain for a text generation task, create necessary functions to: 1. **Validate the Markov Chain**: Check if the Markov Chain is valid, where all probability distributions sum up to 1. 2. **Generate Text**: Use the provided Markov Chain to generate a sequence of words of a specified length starting from a given initial word. Implement functions with the following signatures: - `def is_valid_chain(chain: dict) -> bool:` * **Input**: `chain` - dictionary representing a Markov Chain. * **Output**: Boolean value indicating whether the Markov Chain is valid. - `def generate_text(chain: dict, initial_state: str, length: int) -> str:` * **Input**: - `chain` - dictionary representing a Markov Chain. - `initial_state` - initial word starting the text. - `length` - the total number of words to generate. * **Output**: A string representing the generated sequence of words. **Constraints**: * The input dictionary will contain at most 10,000 states. * Each state will have transitions to at most 100 other states. * `initial_state` is always a valid state in the Markov Chain. * Length of the generated text will not exceed 1000 words. **Example**: ```python # Example input markov_chain = { \'hello\': {\'world\': 0.5, \'there\': 0.5}, \'world\': {\'hello\': 1.0}, \'there\': {\'world\': 1.0} } initial_state = \'hello\' length = 5 # Expected Output result = generate_text(markov_chain, initial_state, length) print(result) # Possible example output: \\"hello there world hello there\\" ``` **Additional Notes**: * Ensure to validate that each state\'s transitions probabilities sum to 1 in `is_valid_chain`. * Use the existing helper functions provided where applicable to reduce redundancy and improve code clarity.","solution":"import random def is_valid_chain(chain: dict) -> bool: Validates the Markov Chain by ensuring all probability distributions from each state sum to 1 (or nearly 1 due to floating-point precision). for state, transitions in chain.items(): if not (0.99 <= sum(transitions.values()) <= 1.01): return False return True def generate_text(chain: dict, initial_state: str, length: int) -> str: Generates a sequence of words using the given Markov Chain, starting from the initial state and generating a specified number of words. current_state = initial_state result = [current_state] for _ in range(length - 1): next_state = weighted_choice(chain[current_state]) result.append(next_state) current_state = next_state return \' \'.join(result) def weighted_choice(choices): Return a random element from the choices dictionary, where values represent the weights for probability distribution. total = sum(choices.values()) rand = random.uniform(0, total) upto = 0 for choice, weight in choices.items(): if upto + weight >= rand: return choice upto += weight"},{"question":"You are tasked with implementing the function `wiggle_sort(nums)` that reorders an array of integers such that it follows the pattern: nums[0] < nums[1] > nums[2] < nums[3]... Make sure your solution is efficient and handles all possible edge cases. **Function Signature**: ```python def wiggle_sort(nums: List[int]) -> None: pass ``` **Input**: * `nums`: A list of integers. **Output**: * The function should modify the list in place and does not return anything. **Constraints**: * The function should maintain O(n) time complexity. * The elements in the list `nums` may include negative numbers and duplicates. * The input list can be empty. **Performance Requirements**: * The algorithm should perform efficiently even for large arrays. # Context You are a software engineer at a company that processes real-time data. The data analysts want to see alternating high and low values in quick visualizations. Implementing this wiggle sort will help them get the desired pattern for their analysis. # Example Example 1 ```python Input: [3, 5, 2, 1, 6, 4] Output: The array should be modified to follow the pattern. Possible outputs can include: [3, 5, 1, 6, 2, 4] [2, 6, 1, 5, 3, 4] ``` Example 2 ```python Input: [1, 2, 3, 4, 5, 6] Output: The array should be modified to a wiggle pattern like: [1, 3, 2, 5, 4, 6] ``` Implement the `wiggle_sort(nums)` function to solve the problem as described.","solution":"from typing import List def wiggle_sort(nums: List[int]) -> None: Reorder the array to the pattern nums[0] < nums[1] > nums[2] < nums[3]... # Iterate through the array and re-arrange the elements in place for i in range(1, len(nums)): if (i % 2 == 1 and nums[i] < nums[i-1]) or (i % 2 == 0 and nums[i] > nums[i-1]): nums[i], nums[i-1] = nums[i-1], nums[i]"},{"question":"You are given a linked list. The linked list may contain a cycle (a node that points back to one of its previous nodes). Your task is to detect the node where the cycle begins. If the linked list has no cycle, return `None`. Implement the function `first_cyclic_node(head: Node) -> Node` that follows the given structure and requirements. Use Floyd\'s cycle-finding algorithm to achieve this. # Input - `head` (Node): The head node of the linked list. Each node will have a `.val` (holding the value of the node) and `.next` (holding the reference to the next node). # Output - The function should return the node where the cycle begins, or `None` if there is no cycle. # Constraints - The linked list can contain any number of nodes from `0` to `10^5`. - Node values will be unique integers or characters. # Example 1. Given the linked list 1 -> 2 -> 3 -> 4 -> 5 forming a cycle at node `1`: ```plaintext 1 -> 2 -> 3 -> 4 -> 5 -> 1 (cycle back to 1) ``` Should return the node with value `1`. 2. Given the linked list A -> B -> C -> D -> E forming a cycle back at node `C`: ```plaintext A -> B -> C -> D -> E -> C (cycle back to C) ``` Should return the node with value `C`. # Implementation You are required to implement the function `first_cyclic_node(head)` using Floyd\'s cycle-finding algorithm (Tortoise and Hare). # Unit Tests Your solution will be tested using a provided test suite that includes edge cases and typical scenarios of linked lists with and without cycles. ```python import unittest class Node: def __init__(self, x): self.val = x self.next = None def first_cyclic_node(head): :type head: Node :rtype: Node runner = walker = head while runner and runner.next: runner = runner.next.next walker = walker.next if runner is walker: break if runner is None or runner.next is None: return None walker = head while runner is not walker: runner, walker = runner.next, walker.next return runner class TestSuite(unittest.TestCase): def test_first_cyclic_node(self): # create linked list => A -> B -> C -> D -> E -> C head = Node(\'A\') head.next = Node(\'B\') curr = head.next cyclic_node = Node(\'C\') curr.next = cyclic_node curr = curr.next curr.next = Node(\'D\') curr = curr.next curr.next = Node(\'E\') curr = curr.next curr.next = cyclic_node self.assertEqual(\'C\', first_cyclic_node(head).val) if __name__ == \'__main__\': unittest.main() ```","solution":"class Node: def __init__(self, x): self.val = x self.next = None def first_cyclic_node(head): Detect the node where the cycle begins in the linked list using Floyd\'s cycle-finding algorithm. :type head: Node :rtype: Node slow = fast = head # Step 1: Determine if there is a cycle while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: break else: # No cycle found return None # Step 2: Find the start of the cycle slow = head while slow != fast: slow = slow.next fast = fast.next return slow"},{"question":"# Scenario You are designing a security management system for a museum that requires an algorithm to determine the optimal set of rooms to secure. Each room has a certain value of treasures. If two connected rooms are secured together, the alarm system will trigger. # Problem Statement Given a list of non-negative integers representing the value of treasures in each room, implement a function `museum_security(values)` that returns the maximum amount of treasures that can be secured without triggering the alarm. Function Signature ```python def museum_security(values: List[int]) -> int: pass ``` Input * `values`: A list of `n` non-negative integers where `0 <= n <= 10^4`. Each element represents the value of treasures in a specific room. Output * The maximum amount of treasures that can be secured without triggering the alarm. Example ```python assert museum_security([2, 3, 2]) == 4 assert museum_security([1, 2, 3, 1]) == 4 assert museum_security([5, 5, 10, 100, 10, 5]) == 110 assert museum_security([]) == 0 assert museum_security([1]) == 1 ``` Constraints and Performance Requirements * The function should handle cases where `n = 0`. * The function should have a time complexity of O(n) and a space complexity of O(1). Additional Notes * You do not need to handle input validation. Assume input meets the specified format. * Think about using a dynamic programming approach to solve this efficiently.","solution":"from typing import List def museum_security(values: List[int]) -> int: Returns the maximum amount of treasures that can be secured without triggering the alarm. if not values: return 0 n = len(values) if n == 1: return values[0] # Initialize previous two max values prev1 = 0 # Maximum value without the last processed room prev2 = 0 # Maximum value without the last two processed rooms for value in values: current = max(prev1, prev2 + value) prev2 = prev1 prev1 = current return prev1"},{"question":"# Question: You are required to implement multiple methods to reverse a given string, each with different constraints and methodologies. By doing this, you will understand and demonstrate multiple approaches to solving the same problem. Function 1: Recursive Approach Implement a function `reverse_recursive(s: str) -> str` that reverses the string using a recursive algorithm. Function 2: Iterative Approach Implement a function `reverse_iterative(s: str) -> str` that reverses the string using an iterative algorithm with two-pointers. Function 3: Pythonic Approach Implement a function `reverse_pythonic(s: str) -> str` that reverses the string using Python\'s built-in functions. Function 4: Ultra Pythonic Approach Implement a function `reverse_ultra_pythonic(s: str) -> str` that reverses the string using Python\'s slicing feature. Input: * A string `s` with length `0 <= len(s) <= 1000`. Output: * A string that is the reversed version of the input string `s`. Example: ```python reverse_recursive(\\"hello\\") -> \\"olleh\\" reverse_iterative(\\"world\\") -> \\"dlrow\\" reverse_pythonic(\\"example\\") -> \\"elpmaxe\\" reverse_ultra_pythonic(\\"coding\\") -> \\"gnidoc\\" ``` Requirements: * **Performance**: * Your recursive solution should handle strings of length up to 1000 efficiently. * Your iterative solution should not use additional space beyond O(N). * The pythonic and ultra pythonic solutions should leverage Python\'s built-in capabilities effectively.","solution":"def reverse_recursive(s: str) -> str: Reverse a string using recursion. if len(s) == 0: return s else: return reverse_recursive(s[1:]) + s[0] def reverse_iterative(s: str) -> str: Reverse a string using an iterative two-pointer approach. s_list = list(s) left, right = 0, len(s_list) - 1 while left < right: s_list[left], s_list[right] = s_list[right], s_list[left] left += 1 right -= 1 return \'\'.join(s_list) def reverse_pythonic(s: str) -> str: Reverse a string using Python built-in functions. return \'\'.join(reversed(s)) def reverse_ultra_pythonic(s: str) -> str: Reverse a string using Python\'s slicing feature. return s[::-1]"},{"question":"**Separate Chaining Hash Table - Advanced Implementation** Design a hash table with separate chaining using a linked list for collision handling. Your implementation should include the following features: 1. **Insertions (`put`)**: Adds a new key-value pair to the hash table. 2. **Retrievals (`get`)**: Retrieves the value associated with a given key. 3. **Deletions (`del_`)**: Removes the key-value pair associated with a given key. 4. **Load Factor Maintenance**: Automatically resizes the hash table when the load factor exceeds a specified threshold (e.g., 0.75). 5. **Iteration Support**: Enable iteration over all key-value pairs in the hash table. **Function Definitions**: 1. `put(key: Any, value: Any) -> None`: Insert or update the value associated with the key. 2. `get(key: Any) -> Any`: Retrieve the value for a given key. Return `None` if the key is not found. 3. `del_(key: Any) -> None`: Remove the key-value pair associated with the key. 4. `__iter__() -> Iterator[Tuple[Any, Any]]`: Return an iterator to iterate over all key-value pairs. **Input Constraints**: - The `key` can be any hashable type. - The `value` can be any type. - The initial size of the hash table should be a prime number (e.g., 11). - The load factor threshold for resizing should be 0.75. **Output Requirements**: - The table must maintain average-case time complexity of O(1) for insertion, deletion, and retrieval. - Upon resizing, the table should rehash existing keys to new indexes. You must provide the implementation in Python. Ensure you include separate methods for computing the hash function and resizing the table. **Example**: ```python table = SeparateChainingHashTable() table.put(\'hello\', \'world\') print(table.get(\'hello\')) # Output: \'world\' table.put(\'foo\', \'bar\') table.del_(\'hello\') print(table.get(\'hello\')) # Output: None for k, v in table: print(k, v) # Should print remaining key-value pairs ```","solution":"class Node: def __init__(self, key, value): self.key = key self.value = value self.next = None class SeparateChainingHashTable: def __init__(self, capacity=11): self.capacity = capacity self.size = 0 self.threshold = 0.75 self.buckets = [None] * self.capacity def _hash(self, key): return hash(key) % self.capacity def _resize(self): old_buckets = self.buckets self.capacity *= 2 # Doubling the table size self.buckets = [None] * self.capacity self.size = 0 for node in old_buckets: while node: self.put(node.key, node.value) node = node.next def put(self, key, value): if self.size / self.capacity >= self.threshold: self._resize() index = self._hash(key) node = self.buckets[index] if node is None: self.buckets[index] = Node(key, value) self.size += 1 else: while node: if node.key == key: node.value = value return if node.next is None: break node = node.next node.next = Node(key, value) self.size += 1 def get(self, key): index = self._hash(key) node = self.buckets[index] while node: if node.key == key: return node.value node = node.next return None def del_(self, key): index = self._hash(key) node = self.buckets[index] prev = None while node: if node.key == key: if prev: prev.next = node.next else: self.buckets[index] = node.next self.size -= 1 return prev = node node = node.next def __iter__(self): for i in range(self.capacity): node = self.buckets[i] while node: yield node.key, node.value node = node.next"},{"question":"You are required to write a function that calculates the factorial of an integer, optionally modulo another integer using an iterative and a recursive approach. Ensure your function handles edge cases and invalid inputs appropriately. Function Signature: ```python def factorial(n, mod=None): Calculates factorial iteratively. If mod is not None, then return (n! % mod). Parameters: n (int): A non-negative integer whose factorial is to be calculated mod (int, optional): A positive integer to take the result modulo Returns: int: The factorial of n, possibly modulo mod pass def factorial_recur(n, mod=None): Calculates factorial recursively. If mod is not None, then return (n! % mod). Parameters: n (int): A non-negative integer whose factorial is to be calculated mod (int, optional): A positive integer to take the result modulo Returns: int: The factorial of n, possibly modulo mod pass ``` Constraints: - 0 <= n <= 10^6 - 1 <= mod <= 10^9 (if provided) Requirements: 1. Implement two functions: * `factorial` - Iterative version * `factorial_recur` - Recursive version 2. Ensure that the functions raise a `ValueError` with the message \\"\'n\' must be a non-negative integer.\\" if n is a negative integer or not an integer. 3. Ensure that the functions raise a `ValueError` with the message \\"\'mod\' must be a positive integer\\" if mod is not None and not a positive integer. Example: ```python # Iterative Approach print(factorial(5)) # Output: 120 print(factorial(5, 3)) # Output: 0 # Recursive Approach print(factorial_recur(5)) # Output: 120 print(factorial_recur(5, 3)) # Output: 0 ``` Scenario: Assume you are developing a system for a mathematical software application that needs to perform various combinatorial calculations. Implement these critical functions to be efficient and robust, capable of handling edge cases and invalid input gracefully.","solution":"def factorial(n, mod=None): Calculates factorial iteratively. If mod is not None, then return (n! % mod). Parameters: n (int): A non-negative integer whose factorial is to be calculated mod (int, optional): A positive integer to take the result modulo Returns: int: The factorial of n, possibly modulo mod if not isinstance(n, int) or n < 0: raise ValueError(\\"\'n\' must be a non-negative integer.\\") if mod is not None and (not isinstance(mod, int) or mod <= 0): raise ValueError(\\"\'mod\' must be a positive integer\\") result = 1 for i in range(2, n + 1): result *= i if mod: result %= mod return result def factorial_recur(n, mod=None): Calculates factorial recursively. If mod is not None, then return (n! % mod). Parameters: n (int): A non-negative integer whose factorial is to be calculated mod (int, optional): A positive integer to take the result modulo Returns: int: The factorial of n, possibly modulo mod if not isinstance(n, int) or n < 0: raise ValueError(\\"\'n\' must be a non-negative integer.\\") if mod is not None and (not isinstance(mod, int) or mod <= 0): raise ValueError(\\"\'mod\' must be a positive integer\\") def recurse(n, mod): if n == 0 or n == 1: return 1 result = n * recurse(n - 1, mod) if mod: return result % mod return result return recurse(n, mod)"},{"question":"# Gnome Sort Algorithm – Coding Challenge Context You are managing a warehouse where items are stored in a long list. To streamline your inventory checking process, you need to ensure that the list of items is sorted in ascending order. Implement a sorting function based on the Gnome Sort algorithm to achieve this. Task Write a function `gnome_sort(arr)` that takes a list of integers `arr` and returns the sorted list in non-decreasing order using the Gnome Sort approach. Input - `arr`: A list of integers, where (1 leq text{len}(arr) leq 10^4) and each integer (-10^9 leq text{arr[i]} leq 10^9). Output - A list of integers sorted in non-decreasing order. Constraints - You are not allowed to use built-in sort functions. - The implementation must be based on the principles and operational steps of Gnome Sort. Example ```python print(gnome_sort([34, 2, 78, 1, 56])) # Output: [1, 2, 34, 56, 78] ``` Edge Cases 1. Empty list – should return an empty list. 2. List of one element – should return the single element. 3. List with duplicates – should properly sort with repeated elements. Requirements - Ensure that your solution is efficient for the provided constraint. - Make sure the function handles edge cases correctly and adheres to the principles of the Gnome Sort algorithm.","solution":"def gnome_sort(arr): Sorts the input list using the Gnome Sort algorithm. Parameters: arr (list): A list of integers to be sorted. Returns: List: A sorted list in non-decreasing order. index = 0 while index < len(arr): if index == 0 or arr[index] >= arr[index - 1]: index += 1 else: arr[index], arr[index - 1] = arr[index - 1], arr[index] index -= 1 return arr"},{"question":"# Remove Duplicates from a Linked List You are tasked with removing duplicates from a singly-linked list. Your task is to implement two functions: 1. `remove_dups(head)`: This function should remove duplicates using an additional data structure (hash set). The time complexity should be O(N) and the space complexity should be O(N). 2. `remove_dups_without_set(head)`: This function should remove duplicates without using any additional data structures, only using constant extra memory. The time complexity should be O(N^2). Input: Each function will receive the `head` of a singly-linked list defined by the `Node` class. ```python class Node(): def __init__(self, val = None): self.val = val self.next = None ``` Output: Both functions should modify the provided linked list in-place to remove any duplicate values. Constraints: * The provided linked list will have at most 10^4 nodes. * Node values will be strings consisting of lowercase or uppercase Latin letters. Performance Requirements: * `remove_dups`: O(N) time complexity and O(N) space complexity. * `remove_dups_without_set`: O(N^2) time complexity and O(1) space complexity. Example: ```python # Example linked list: A -> A -> B -> C -> D -> C -> F -> G a1 = Node(\\"A\\") a2 = Node(\\"A\\") b = Node(\\"B\\") c1 = Node(\\"C\\") d = Node(\\"D\\") c2 = Node(\\"C\\") f = Node(\\"F\\") g = Node(\\"G\\") a1.next = a2 a2.next = b b.next = c1 c1.next = d d.next = c2 c2.next = f f.next = g remove_dups(a1) # Modified linked list should be: A -> B -> C -> D -> F -> G print_linked_list(a1) # Reinitialize the linked list to original state a1 = Node(\\"A\\") a2 = Node(\\"A\\") b = Node(\\"B\\") c1 = Node(\\"C\\") d = Node(\\"D\\") c2 = Node(\\"C\\") f = Node(\\"F\\") g = Node(\\"G\\") a1.next = a2 a2.next = b b.next = c1 c1.next = d d.next = c2 c2.next = f f.next = g remove_dups_without_set(a1) # Modified linked list should be: A -> B -> C -> D -> F -> G print_linked_list(a1) ``` Implement both `remove_dups` and `remove_dups_without_set`.","solution":"class Node: def __init__(self, val=None): self.val = val self.next = None def remove_dups(head): Removes duplicates from the linked list using a hash set. Time complexity: O(N) Space complexity: O(N) if not head: return current = head seen = set([current.val]) while current.next: if current.next.val in seen: current.next = current.next.next else: seen.add(current.next.val) current = current.next def remove_dups_without_set(head): Removes duplicates from the linked list without using extra data structures. Time complexity: O(N^2) Space complexity: O(1) current = head while current: runner = current while runner.next: if runner.next.val == current.val: runner.next = runner.next.next else: runner = runner.next current = current.next"},{"question":"**Problem Context**: Hamming weight, or the number of set bits (1s) in a binary representation of a number, is a fundamental concept in computer science with multiple applications ranging from error detection to cryptography. In this problem, you\'ll use an efficient bit manipulation technique to determine the Hamming weight of a given unsigned integer. **Problem Statement**: Write a function `hamming_weight` that takes an unsigned integer and returns the number of set bits (\'1\'s) it has in its binary representation. **Function Signature**: ```python def hamming_weight(n: int) -> int: pass ``` **Input**: - `n` (integer): An unsigned integer (0 <= n <= 2^31 - 1). **Output**: - Return the number of \'1\' bits in the binary representation of `n`. **Constraints**: - Do not use built-in functions that directly count the number of set bits. **Example**: ```python assert hamming_weight(11) == 3 # Binary representation: 00000000000000000000000000001011 assert hamming_weight(128) == 1 # Binary representation: 00000000000000000000000010000000 assert hamming_weight(255) == 8 # Binary representation: 00000000000000000000000011111111 ``` **Requirements**: - Your algorithm should have a time complexity better than O(log n). - Optimize for both time and space. **Hint**: Consider how you can systematically remove set bits and count them using bitwise operations.","solution":"def hamming_weight(n: int) -> int: Returns the number of set bits (1s) in the binary representation of n. count = 0 while n: count += n & 1 n >>= 1 return count"},{"question":"# Question: Count Integer Decompositions You are tasked to implement a function that computes the number of ways a given positive integer can be decomposed into the sum of non-negative integers. This function should utilize dynamic programming to efficiently count the decompositions. Function Signature: ```python def count_decompositions(n: int) -> int: pass ``` Input: - `n`: An integer, ( 1 leq n leq 100 ). Output: - An integer representing the number of decompositions of `n` into the sum of non-negative integers. Explanation: You must implement a dynamic programming solution that uses a 2D array to count the number of decompositions. Consider the integer matrix `arr` where `arr[i][j]` denotes the number of ways to decompose `i` using numbers up to `j`. Your function should follow these rules: - ( arr[i][j] = arr[i][j-1] ) if `i < j`. - ( arr[i][j] = 1 + arr[i][j-1] ) if `i == j`. - ( arr[i][j] = arr[i][j-1] + arr[i-j][j] ) if `i > j`. Example: ```python print(count_decompositions(4)) # Output: 5 # Explanation: # 4 can be decomposed as: [4], [3+1], [2+2], [2+1+1], [1+1+1+1] print(count_decompositions(7)) # Output: 15 # Explanation: # 7 can be decomposed as: [7], [6+1], [5+2], [5+1+1], [4+3], [4+2+1], [4+1+1+1], [3+3+1], # [3+2+2], [3+2+1+1], [3+1+1+1+1], [2+2+2+1], [2+2+1+1+1], [2+1+1+1+1+1], [1+1+1+1+1+1+1] ```","solution":"def count_decompositions(n: int) -> int: # Initialize a 2D DP table where dp[i][j] represents the number of ways to decompose i with numbers up to j dp = [[0] * (n + 1) for _ in range(n + 1)] # Base case: There\'s exactly one way to decompose 0 -- using no parts at all. for j in range(n + 1): dp[0][j] = 1 # Fill the DP table for i in range(1, n + 1): for j in range(1, n + 1): if i < j: dp[i][j] = dp[i][j-1] elif i == j: dp[i][j] = 1 + dp[i][j-1] else: # i > j dp[i][j] = dp[i][j-1] + dp[i-j][j] # The answer we want is dp[n][n] return dp[n][n]"},{"question":"# Combinatorial Challenge You are given the task to calculate the number of ways to choose `r` items from `n` distinct items, which is mathematically represented as nCr (also known as binomial coefficient). Implement an efficient solution to compute this value, leveraging dynamic programming concepts to optimize performance. Function Signature ```python def compute_nCr(n: int, r: int) -> int: pass ``` Input - `n` (integer): Total number of items, where (0 leq n leq 10^5). - `r` (integer): Number of items to choose, where (0 leq r leq n). Output - Return an integer representing nCr, the number of ways to choose `r` items from `n` items. Constraints 1. For all inputs, the result should fit within a 64-bit integer. 2. Use dynamic programming principles to achieve efficient computation. 3. Consider edge case where ( r > n ), and return 0 accordingly. Examples ```python # Example 1 compute_nCr(5, 2) # Should return 10 # Example 2 compute_nCr(10, 0) # Should return 1 # Example 3 compute_nCr(10, 10) # Should return 1 # Example 4 compute_nCr(50, 25) # Should return a large number, within 64-bit integer limits ``` Note Your implementation should be optimized to handle large values efficiently, making sure to minimize both time and space complexity where possible.","solution":"def compute_nCr(n: int, r: int) -> int: if r > n: return 0 if r == 0 or r == n: return 1 if r > n - r: # Taking advantage of symmetry property nCr == nC(n-r) r = n - r dp = [0] * (r + 1) dp[0] = 1 for i in range(1, n + 1): for j in range(min(i, r), 0, -1): dp[j] = dp[j] + dp[j - 1] return dp[r]"},{"question":"You are working on a command-line tool that processes various file paths entered by users. To ensure that all file paths used by the tool are in a consistent format, you need to implement a utility function that converts any file path provided by the user to its full absolute path. This includes expanding any user directory aliases like `~`. **Function Specification** Implement the following function: ```python def get_absolute_path(file_path: str) -> str: Given a file path, convert it to its full absolute path and expand any user directory aliases. :param file_path: str, a file path provided by the user. :return: str, the full absolute path of the file. ``` **Input** * `file_path` (str): A file path which may be relative, contain user directory aliases (`~`), or be in any form. **Output** * Returns a string representing the full absolute path of the input file. **Constraints** * The input path can be of any length reasonable within system limits. * The function should handle empty strings gracefully by raising an appropriate error. * Avoid using direct shell commands or libraries outside of `os`. **Performance Requirements** * The function should execute in O(n) time complexity, where n is the length of the input path string. * Minimize memory usage, prioritizing space complexity of O(1). **Example** ```python # Returns the absolute path, e.g., \'/home/user/file.txt\' print(get_absolute_path(\\"~/file.txt\\")) # Returns the absolute path without any changes print(get_absolute_path(\\"/usr/local/bin\\")) # Returns the absolute path in expanded form, e.g., \'/current/directory/docs\' print(get_absolute_path(\\"../docs\\")) ``` Implement the `get_absolute_path` function ensuring it handles the specified requirements and edge cases.","solution":"import os def get_absolute_path(file_path: str) -> str: Given a file path, convert it to its full absolute path and expand any user directory aliases. :param file_path: str, a file path provided by the user. :return: str, the full absolute path of the file. if not file_path: raise ValueError(\\"File path cannot be an empty string\\") # Expand user directory aliases like \'~\' expanded_path = os.path.expanduser(file_path) # Get absolute path absolute_path = os.path.abspath(expanded_path) return absolute_path"},{"question":"# Scenario: You are tasked with creating a high-performance Fibonacci number calculator for a math modeling software expected to handle very large inputs efficiently. # Task: Write a function `efficient_fib(n: int) -> int` that calculates the nth Fibonacci number using an approach that is both time and space efficient. Your function should avoid using excessive memory and should perform well even for large input values of `n`. # Requirements: - The function should compute the nth Fibonacci number in O(n) time complexity. - The function should use O(1) additional space (excluding input and output). # Input Format: - An integer `n` (0 ≤ n ≤ 10^6). # Output Format: - An integer representing the nth Fibonacci number. # Constraints: - The provided integer `n` will always be within the specified range. - The solution should be optimized for both time and space usage. # Example: ```python # Input n = 50 # Output 12586269025 # Input n = 10 # Output 55 ``` # Note: For very large values, such as `n = 1,000,000`, ensure the function computes the result efficiently without running into memory or performance issues.","solution":"def efficient_fib(n: int) -> int: Returns the nth Fibonacci number in O(n) time and O(1) space. if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"# RSA Encryption Key Generation and Encryption/Decryption Functions **Context**: You will be designing and implementing secure digital communication using the RSA algorithm. The RSA algorithm is widely used for securing sensitive data, especially in internet-based communications. Your task is to implement key components of the RSA algorithm: key generation, encryption, and decryption. **Objective**: Create a Python program that generates RSA keys, and provides encryption and decryption functionality using the RSA algorithm. **Functional Requirements**: 1. **Key Generation**: - Function: `generate_key(k: int, seed: int = None) -> (int, int, int)` - Input: An integer `k` specifying the number of bits in the modulus `n`, and an optional `seed` to initialize the random number generator. - Output: A tuple of three integers `(n, e, d)` where `n` is the modulus, `e` is the public exponent, and `d` is the private exponent. 2. **Encryption**: - Function: `encrypt(data: int, e: int, n: int) -> int` - Input: An integer `data` to be encrypted, a public exponent `e`, and a modulus `n`. - Output: An encrypted integer. 3. **Decryption**: - Function: `decrypt(data: int, d: int, n: int) -> int` - Input: An encrypted integer `data`, a private exponent `d`, and a modulus `n`. - Output: The decrypted original integer. **Constraints**: 1. `k` will be at least 16. 2. The method for finding prime numbers should ensure that they are indeed prime. 3. `e` should be a small prime number such as 3 or 65537 to balance security and performance. 4. Your algorithm should handle the situation where `e` is not coprime with ( varphi(n) ) and regenerate `p` and `q` if necessary. **Example**: ```python n, e, d = generate_key(16) data = 42 encrypted_data = encrypt(data, e, n) decrypted_data = decrypt(encrypted_data, d, n) assert decrypted_data == data print(\\"Original:\\", data) print(\\"Encrypted:\\", encrypted_data) print(\\"Decrypted:\\", decrypted_data) ``` **Edge Cases**: 1. Verify that `e` and ( varphi(n) ) are coprime. 2. Check if large primes are correctly generated. 3. Ensure that decrypted output matches the original input data.","solution":"import random from sympy import isprime, mod_inverse def generate_prime_candidate(length): p = random.getrandbits(length) p |= (1 << length - 1) | 1 return p def generate_prime_number(length): p = generate_prime_candidate(length) while not isprime(p): p = generate_prime_candidate(length) return p def gcd(a, b): while b != 0: a, b = b, a % b return a def generate_key(k: int, seed: int = None): if seed is not None: random.seed(seed) e = 65537 while True: p = generate_prime_number(k // 2) q = generate_prime_number(k // 2) if p != q: n = p * q phi = (p - 1) * (q - 1) if gcd(e, phi) == 1: d = mod_inverse(e, phi) return (n, e, d) def encrypt(data: int, e: int, n: int) -> int: return pow(data, e, n) def decrypt(data: int, d: int, n: int) -> int: return pow(data, d, n)"},{"question":"# Island Count with Terrain Types and Traversal Restrictions Question You are given a 2D grid representing different terrain types where: - \'1\' denotes land. - \'0\' denotes water. - \'R\' denotes a restricted area that cannot be traversed. Design a function `count_islands(grid)` that will count the number of islands consisting of only \'1\'s (land) while avoiding \'R\' (restricted areas). An island is formed by connecting adjacent lands horizontally or vertically, and it must be surrounded by water or restricted areas. **Input**: - `grid`: A list of lists of characters (with \'1\', \'0\', and \'R\'). **Output**: - Returns an integer indicating the number of islands. Constraints - The number of rows in the grid will be at most 300. - The number of columns in the grid will be at most 300. - Grid cells with \'R\' should be treated as boundaries similar to \'0\'. Example ```python grid = [ [\'1\', \'1\', \'0\', \'1\', \'0\'], [\'1\', \'0\', \'R\', \'1\', \'1\'], [\'0\', \'0\', \'1\', \'0\', \'R\'], [\'R\', \'0\', \'1\', \'1\', \'0\'], ] print(count_islands(grid)) # Output: 3 grid = [ [\'0\', \'0\', \'R\'], [\'R\', \'1\', \'0\'], [\'0\', \'1\', \'1\'], ] print(count_islands(grid)) # Output: 1 ``` Notes - The function should efficiently handle the grid within the provided constraints. - Take into account that \'R\'-restricted cells block traversal similarly to water cells.","solution":"def count_islands(grid): Counts the number of islands in the grid. An island consists of \'1\'s (land) and is surrounded by \'0\'s (water) or \'R\'s (restricted areas) and can only be connected horizontally or vertically. if not grid or not grid[0]: return 0 rows, cols = len(grid), len(grid[0]) visited = [[False] * cols for _ in range(rows)] def dfs(r, c): if r < 0 or r >= rows or c < 0 or c >= cols or grid[r][c] != \'1\' or visited[r][c]: return visited[r][c] = True dfs(r - 1, c) # up dfs(r + 1, c) # down dfs(r, c - 1) # left dfs(r, c + 1) # right island_count = 0 for r in range(rows): for c in range(cols): if grid[r][c] == \'1\' and not visited[r][c]: dfs(r, c) island_count += 1 return island_count"},{"question":"# Question You are given a sorted list of integers, and you need to implement a function `improved_jump_search` that efficiently finds the first occurrence of a target value within the list. The list is guaranteed to be sorted in ascending order. The function should follow these requirements: 1. **Input**: - A sorted list of integers `arr`. - An integer `target` which is the value to be searched. 2. **Output**: - The index of the first occurrence of the target value in the array if it is present. - Return -1 if the target value is not in the array. 3. **Constraints**: - The length of the array `n` is in the range `[1, 10^6]`. - The values in the array are within the range of `[-10^9, 10^9]`. 4. **Performance**: - The algorithm should work efficiently with a time complexity of O(√n) and a space complexity of O(1). Function Signature ```python def improved_jump_search(arr: List[int], target: int) -> int: pass ``` Example ```python # Example 1 arr = [1, 3, 4, 5, 9, 12, 15, 21, 28, 30] target = 15 assert improved_jump_search(arr, target) == 6 # Example 2 arr = [1, 3, 4, 5, 9, 12, 15, 21, 28, 30] target = 22 assert improved_jump_search(arr, target) == -1 # Example 3 arr = [8] target = 8 assert improved_jump_search(arr, target) == 0 ``` Feel free to optimize the block size or improve the algorithm to increase the performance.","solution":"import math from typing import List def improved_jump_search(arr: List[int], target: int) -> int: length = len(arr) jump = int(math.sqrt(length)) prev = 0 # Finding the block where element is present (if it is present) while arr[min(jump, length) - 1] < target: prev = jump jump += int(math.sqrt(length)) if prev >= length: return -1 # Doing a linear search for target in the block starting with prev while arr[prev] < target: prev += 1 if prev == min(jump, length): return -1 # If element is found if arr[prev] == target: return prev return -1"},{"question":"You are given an unsorted list of integers. Your task is to implement the Selection Sort algorithm to sort the list in ascending order. The implementation should also include an optional simulation mode that prints the state of the list after each iteration of the outer loop. # Function Signature ```python def selection_sort(arr: List[int], simulation: bool = False) -> List[int]: ``` # Input * `arr`: A list of integers `arr` with length up to (10^3). * `simulation`: A boolean `simulation` which optionally prints intermediate states of the list during the sorting process. # Output Returns the sorted list of integers. # Example Example 1 ```python selection_sort([64, 25, 12, 22, 11]) ``` Output: ``` [11, 12, 22, 25, 64] ``` Example 2 ```python selection_sort([29, 10, 14, 37, 13], simulation=True) ``` Output: ``` iteration 0 : 29 10 14 37 13 iteration 1 : 10 29 14 37 13 iteration 2 : 10 14 29 37 13 iteration 3 : 10 14 13 37 29 iteration 4 : 10 14 13 29 37 [10, 14, 13, 29, 37] ``` # Constraints * List `arr` contains integers (-10^3 ≤ element ≤ 10^3). * 0 ≤ len(arr) ≤ 1000 * Avoid using any built-in sort functions. # Notes * Ensure your function does not modify the input list but returns a new sorted list instead (regardless of the simulation flag).","solution":"from typing import List def selection_sort(arr: List[int], simulation: bool = False) -> List[int]: Sorts a list of integers using the Selection Sort algorithm. If simulation is True, prints the state of the list after each iteration of the outer loop. Args: arr: List[int] - The list of integers to sort. simulation: bool - If True, prints intermediate states of the list during the sorting process. Returns: List[int] - The sorted list of integers. n = len(arr) sorted_arr = arr[:] for i in range(n): min_idx = i for j in range(i + 1, n): if sorted_arr[j] < sorted_arr[min_idx]: min_idx = j # Swap the found minimum element with the first element sorted_arr[i], sorted_arr[min_idx] = sorted_arr[min_idx], sorted_arr[i] if simulation: print(f\\"iteration {i} : {\' \'.join(map(str, sorted_arr))}\\") return sorted_arr"},{"question":"Question **Next Lexicographical Permutation** Given a number, your task is to find the next higher number which has the exact same set of digits as the original number. If no such number exists, return -1. # Function Signature ```python def next_bigger(num: int) -> int: ``` # Input - **num**: an integer (1 ≤ num ≤ 10^9) # Output - Return the next higher number with the same set of digits as `num`. Return -1 if no such number exists. # Example ```python assert next_bigger(38276) == 38627 assert next_bigger(12345) == 12354 assert next_bigger(54321) == -1 ``` # Constraints 1. You must implement the solution with a linear time algorithm. 2. Consider edge cases such as single-digit numbers and numbers that are already in the highest possible permutation. # Implementation Details - Implement the algorithm in a function called`next_bigger`. - Handle the cases where no higher permutation exists by returning -1. - Consider and handle edge cases to ensure robustness of the solution.","solution":"def next_bigger(num: int) -> int: num_str = list(str(num)) length = len(num_str) # Step 1: Find the largest index i such that num_str[i] < num_str[i + 1]. for i in range(length - 2, -1, -1): if num_str[i] < num_str[i + 1]: break else: return -1 # If no such index exists, the number is the largest permutation. # Step 2: Find the largest index j greater than i such that num_str[i] < num_str[j]. for j in range(length - 1, i, -1): if num_str[i] < num_str[j]: break # Step 3: Swap the values of num_str[i] and num_str[j]. num_str[i], num_str[j] = num_str[j], num_str[i] # Step 4: Reverse the sub-array from num_str[i + 1] to the end. num_str = num_str[:i + 1] + num_str[i + 1:][::-1] # Convert list back to integer next_num = int(\'\'.join(num_str)) return next_num"},{"question":"**Scenario:** You are tasked with developing a set of algorithms to find the most cost-effective way to cover all elements in a universe (representing various points of interest, servers, etc.) using predefined subsets that each have an associated cost. This problem has applications in network design, resource allocation, and more. **Objective:** Implement two functions: 1. `optimal_set_cover(universe, subsets, costs)`: An optimal but computationally expensive approach to solving the set cover problem. 2. `greedy_set_cover(universe, subsets, costs)`: A more efficient but approximate greedy approach. # **Function Specifications:** 1. **optimal_set_cover** ```python def optimal_set_cover(universe, subsets, costs): Finds the minimum cost subcollection that covers all elements of the universe. Args: universe (set): Universe of elements. subsets (dict): Dictionary where keys are subset identifiers and values are sets of elements in those subsets. costs (dict): Dictionary where keys are subset identifiers and values are costs associated with them. Returns: list: List of subset identifiers that form the minimum cost cover of the universe. # Your implementation here ``` 2. **greedy_set_cover** ```python def greedy_set_cover(universe, subsets, costs): Finds an approximate minimum cost subcollection that covers all elements of the universe using a greedy approach. Args: universe (set): Universe of elements. subsets (dict): Dictionary where keys are subset identifiers and values are sets of elements in those subsets. costs (dict): Dictionary where keys are subset identifiers and values are costs associated with them. Returns: list: List of subset identifiers that form the approximate minimum cost cover of the universe. # Your implementation here ``` **Input and Output Formats:** - **Input:** * `universe`: A set of integers representing the universe of elements (U). * `subsets`: A dictionary where keys are strings (subset identifiers like \'S1\', \'S2\', etc.) and values are sets of integers representing elements in each subset. * `costs`: A dictionary where keys are strings (subset identifiers) and values are integers representing the cost associated with each subset. - **Output:** * A list of strings representing the subset identifiers that form the minimum/approximate minimum cost cover of the universe. **Constraints:** - Single-element sets should be included as edge cases. - Ensure that each subset identifier in `costs` matches those in `subsets`. - Assume universe elements can be large, but subsets may vary in size and distribution. **Performance Requirements:** - The `optimal_set_cover` should return the correct minimum cost cover but can have a higher computational complexity. - The `greedy_set_cover` should compute quickly, providing an approximation to the minimum cost cover. **Example:** ```python universe = {1, 2, 3, 4, 5} subsets = {\'S1\': {4, 1, 3}, \'S2\': {2, 5}, \'S3\': {1, 4, 3, 2}} costs = {\'S1\': 5, \'S2\': 10, \'S3\': 3} optimal_cover = optimal_set_cover(universe, subsets, costs) print(f\'Optimal Cover: {optimal_cover}, Cost: {sum(costs[s] for s in optimal_cover)}\') greedy_cover = greedy_set_cover(universe, subsets, costs) print(f\'Greedy Cover: {greedy_cover}, Cost: {sum(costs[s] for s in greedy_cover)}\') # Expected Output: # Optimal Cover: [\'S3\', \'S2\'], Cost: 13 # Greedy Cover: [\'S3\', \'S2\'], Cost: 13 ```","solution":"import itertools def optimal_set_cover(universe, subsets, costs): Finds the minimum cost subcollection that covers all elements of the universe. Args: universe (set): Universe of elements. subsets (dict): Dictionary where keys are subset identifiers and values are sets of elements in those subsets. costs (dict): Dictionary where keys are subset identifiers and values are costs associated with them. Returns: list: List of subset identifiers that form the minimum cost cover of the universe. min_cost = float(\'inf\') best_cover = None keys = list(subsets.keys()) for r in range(1, len(keys) + 1): for combination in itertools.combinations(keys, r): combined_set = set() for key in combination: combined_set |= subsets[key] if combined_set == universe: cost = sum(costs[key] for key in combination) if cost < min_cost: min_cost = cost best_cover = combination return list(best_cover) def greedy_set_cover(universe, subsets, costs): Finds an approximate minimum cost subcollection that covers all elements of the universe using a greedy approach. Args: universe (set): Universe of elements. subsets (dict): Dictionary where keys are subset identifiers and values are sets of elements in those subsets. costs (dict): Dictionary where keys are subset identifiers and values are costs associated with them. Returns: list: List of subset identifiers that form the approximate minimum cost cover of the universe. uncovered = universe.copy() cover = [] while uncovered: best_subset = None best_cost_effectiveness = float(\'inf\') for subset in subsets: if subsets[subset] & uncovered: cost_effectiveness = costs[subset] / len(subsets[subset] & uncovered) if cost_effectiveness < best_cost_effectiveness: best_cost_effectiveness = cost_effectiveness best_subset = subset if best_subset is None: break cover.append(best_subset) uncovered -= subsets[best_subset] return cover"},{"question":"# Problem Description You are given a list of integers. Your task is to sort this list using the exchange sort algorithm and implement a function named `exchange_sort`. Additionally, enhance the algorithm to handle common issues such as handling empty lists and improving code efficiency for this specific question. # Function Signature ```python def exchange_sort(arr: List[int]) -> List[int]: ``` # Input * A list of integers `arr` where `1 <= len(arr) <= 10^3`. * Each integer in `arr` could be in the range `-10^5` to `10^5`. # Output * The function should return a list of integers sorted in non-decreasing order. # Examples ```python assert exchange_sort([3, 1, 4, 5, 2]) == [1, 2, 3, 4, 5] assert exchange_sort([]) == [] assert exchange_sort([1, 1, 1]) == [1, 1, 1] assert exchange_sort([10, -1, 2, -3, 0]) == [-3, -1, 0, 2, 10] ``` # Constraints * You must use the exchange sort algorithm as the base for your solution. * Consider using any subtle enhancements that maintain the algorithm\'s principles but improve clarity or handle edge cases efficiently. # Notes * Carefully consider and handle edge situations like empty input. * Code clarity and efficiency within the defined constraints will be considered.","solution":"from typing import List def exchange_sort(arr: List[int]) -> List[int]: Sorts the list using the exchange sort algorithm. Exchange sort repeatedly goes through the list and swaps elements that are out of order. This continues until the list is sorted. n = len(arr) for i in range(n): for j in range(i + 1, n): if arr[i] > arr[j]: arr[i], arr[j] = arr[j], arr[i] return arr"},{"question":"Imagine you are building a library for number analysis, and one of the functionalities you need to implement is counting the number of digits in an integer. Your goal is to implement a function that efficiently calculates the number of digits of a given integer, including handling edge cases such as zero and negative numbers. Function Signature ```python def num_digits(n: int) -> int: ... ``` Input * `n (int)`: An integer, which can be positive, negative, or zero. The integer can be very large but of manageable size for typical 32-bit or 64-bit integer ranges. Output * Returns an integer representing the number of digits in the given integer `n`. Constraints 1. Do not use any string manipulations to directly count digits (e.g., converting the number to a string and checking its length). 2. Ensure the function works correctly for zero and negative numbers. Example ```python print(num_digits(12345)) # Output: 5 print(num_digits(-12345)) # Output: 5 print(num_digits(0)) # Output: 1 print(num_digits(100000)) # Output: 6 ``` Propose a robust and efficient solution that meets the above requirements.","solution":"def num_digits(n: int) -> int: Return the count of digits in the integer n. This function handles the cases where n is zero and when n is negative. if n == 0: return 1 count = 0 n = abs(n) while n != 0: n //= 10 count += 1 return count"},{"question":"Scenario You are given a linked list containing some duplicate elements. Your task is to implement a function that removes all duplicates from the linked list while preserving the order of the elements. You have to provide two methods: one that uses extra space for efficiency, and another that doesn’t use any extra space but might be less efficient in terms of time complexity. Function Specifications 1. **remove_dups**: * **Input**: A singly linked list head node. * **Output**: The head node of the modified list with all duplicates removed (using extra space). 2. **remove_dups_without_set**: * **Input**: A singly linked list head node. * **Output**: The head node of the modified list with all duplicates removed (without using extra space). Input Format - The input for both functions will be a `Node` object representing the head of the linked list, where each `Node` has: - `val`: the value of the node - `next`: pointer to the next node Output Format - The modified linked list with duplicates removed, which should be representable by `print_linked_list(head)` function provided above. Constraints - The list can contain up to 10^5 nodes. - Values in the nodes are non-negative integers and can go up to 10^5. Example ```python # Constructing the linked list: A -> A -> B -> C -> D -> C -> F -> G a1 = Node(\\"A\\") a2 = Node(\\"A\\") b = Node(\\"B\\") c1 = Node(\\"C\\") d = Node(\\"D\\") c2 = Node(\\"C\\") f = Node(\\"F\\") g = Node(\\"G\\") a1.next = a2 a2.next = b b.next = c1 c1.next = d d.next = c2 c2.next = f f.next = g # Removing duplicates with extra space remove_dups(a1) print_linked_list(a1) # Output: A -> B -> C -> D -> F -> G # Removing duplicates without extra space remove_dups_without_set(a1) print_linked_list(a1) # Output: A -> B -> C -> D -> F -> G ```","solution":"class Node: def __init__(self, val=0, next=None): self.val = val self.next = next def remove_dups(head): Remove duplicates from the linked list using extra space. if not head: return head seen = set() current = head seen.add(current.val) while current.next: if current.next.val in seen: current.next = current.next.next else: seen.add(current.next.val) current = current.next return head def remove_dups_without_set(head): Remove duplicates from the linked list without using extra space. if not head: return head current = head while current: runner = current while runner.next: if runner.next.val == current.val: runner.next = runner.next.next else: runner = runner.next current = current.next return head def print_linked_list(head): Helper function to print the linked list. current = head elements = [] while current: elements.append(str(current.val)) current = current.next print(\\" -> \\".join(elements))"},{"question":"Bit Manipulation Toolkit You are tasked with implementing functions that enable operations on individual bits within a given integer. These operations are useful in systems where memory and performance optimizations are critical, such as embedded systems or low-level device drivers. Task Implement the following bit manipulation functions: 1. **get_bit(num, i)**: Returns the value of the bit at position `i` in the integer `num`. 2. **set_bit(num, i)**: Sets the bit at position `i` in the integer `num` to 1. 3. **clear_bit(num, i)**: Clears the bit at position `i` in the integer `num` (sets it to 0). 4. **update_bit(num, i, bit)**: Updates the bit at position `i` in the integer `num` to `bit` (which will be either 0 or 1). Input/Output Constraints * `num` will be an integer. * `i` will be a non-negative integer representing the bit position. * `bit` will be either 0 or 1. * Assume `i` is always within the valid range of `num`\'s bit positions. Input/Output Examples 1. `get_bit(5, 0)` should return `1` (binary representation of 5 is `101`). 2. `set_bit(5, 1)` should return `7` (binary representation of 7 is `111`). 3. `clear_bit(7, 1)` should return `5` (binary representation of 5 is `101`). 4. `update_bit(5, 1, 0)` should return `5` (binary representation of 5 remains `101`). Function Definitions ```python def get_bit(num, i): # Your implementation here pass def set_bit(num, i): # Your implementation here pass def clear_bit(num, i): # Your implementation here pass def update_bit(num, i, bit): # Your implementation here pass ``` Performance Requirements All operations should be performed in constant time, i.e., O(1).","solution":"def get_bit(num, i): Returns the value of the bit at position i in the integer num. return (num >> i) & 1 def set_bit(num, i): Sets the bit at position i in the integer num to 1. return num | (1 << i) def clear_bit(num, i): Clears the bit at position i in the integer num (sets it to 0). return num & ~(1 << i) def update_bit(num, i, bit): Updates the bit at position i in the integer num to bit (which will be either 0 or 1). mask = ~(1 << i) return (num & mask) | (bit << i)"},{"question":"Scenario You are given a binary tree with nodes containing integer values. Your task is to implement functions to insert values into the tree, perform an in-order traversal, and return the in-order sequence of the tree nodes\' values. Function to Implement 1. **Function Name**: `insert_into_tree` * **Input**: `TreeNode root`, `int val` * **Output**: `TreeNode root` * **Description**: Inserts a value into the binary tree following Binary Search Tree (BST) properties. If the tree is empty, the function will create a new root node with the given value. 2. **Function Name**: `in_order_traversal` * **Input**: `TreeNode root` * **Output**: `List[int]` * **Description**: Performs in-order traversal on the given tree and returns the sequence of node values. Constraints * The value to be inserted is guaranteed to be unique for simplicity. * The tree might initially be empty (root is None). * The tree can have up to 10^4 nodes. Example ```python # Initial tree root = TreeNode(5) root = insert_into_tree(root, 3) root = insert_into_tree(root, 7) root = insert_into_tree(root, 2) root = insert_into_tree(root, 4) root = insert_into_tree(root, 6) root = insert_into_tree(root, 8) # In-order traversal print(in_order_traversal(root)) # Output: [2, 3, 4, 5, 6, 7, 8] ``` Performance Requirements * Ensure that the tree maintains BST properties after each insertion. * The in-order traversal should be implemented in O(n) time complexity with O(h) space complexity, where n is the number of nodes and h is the tree height.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def insert_into_tree(root, val): if root is None: return TreeNode(val) if val < root.val: root.left = insert_into_tree(root.left, val) else: root.right = insert_into_tree(root.right, val) return root def in_order_traversal(root): result = [] def inorder(node): if not node: return inorder(node.left) result.append(node.val) inorder(node.right) inorder(root) return result"},{"question":"Stooge Sort Implementation and Analysis Scenario You have been given an array of integers by your research team leader to sort using the Stooge Sort algorithm. While Stooge Sort is not practically efficient, this exercise will test your understanding of recursive sorting algorithms and their intricacies. Task Implement the Stooge Sort algorithm and validate its correctness by sorting an array of integers. Function Signature ```python def stoogesort(arr: List[int], l: int, h: int) -> None: Sorts the array from index l to h using the Stooge Sort algorithm in-place. pass ``` Input and Output Formats * **Inputs**: * `arr`: List[int] - The array to be sorted. * `l`: int - The starting index of the array segment to be sorted. * `h`: int - The ending index of the array segment to be sorted. * **Output**: * The function should sort the array `arr` in-place from index `l` to `h`. Constraints * `0 <= l, h < len(arr)` * The array contains at least 1 and at most 100 elements. * Each integer in the array is within the range `-10^4 <= arr[i] <= 10^4`. Example ```python from typing import List # Example implementation based on the provided function signature def stoogesort(arr: List[int], l: int, h: int) -> None: if l >= h: return # If first element is smaller than last, swap them if arr[l] > arr[h]: arr[l], arr[h] = arr[h], arr[l] # If there are more than 2 elements in the array if h - l + 1 > 2: t = (h - l + 1) // 3 # Recursively sort first 2 / 3 elements stoogesort(arr, l, h - t) # Recursively sort last 2 / 3 elements stoogesort(arr, l + t, h) # Recursively sort first 2 / 3 elements again to confirm stoogesort(arr, l, h - t) # Example usage: array = [1, 3, 64, 5, 7, 8] stoogesort(array, 0, len(array) - 1) print(array) # Expected Output: [1, 3, 5, 7, 8, 64] ``` Performance Requirements While this algorithm is not efficient, ensure your implementation handles edge cases such as: * Arrays already in sorted order. * Arrays in reverse sorted order. * Arrays with duplicate elements. * Ensure there is no out-of-bounds access. Write a thorough test suite to demonstrate the correctness and handle edge cases of your implementation.","solution":"from typing import List def stoogesort(arr: List[int], l: int, h: int) -> None: if l >= h: return # If first element is greater than last, swap them if arr[l] > arr[h]: arr[l], arr[h] = arr[h], arr[l] # If the array contains more than 2 elements, proceed with recursive steps if h - l + 1 > 2: t = (h - l + 1) // 3 # Recursively sort first 2/3 of the array stoogesort(arr, l, h - t) # Recursively sort last 2/3 of the array stoogesort(arr, l + t, h) # Recursively sort first 2/3 of the array again stoogesort(arr, l, h - t)"},{"question":"# Problem: Integer Decomposition Count Given a positive integer `n`, write a function `countDecompositions(n)` that returns the number of different ways `n` can be decomposed into the sum of smaller positive integers. Each decomposition is a distinct set of numbers that add up to `n`. Input Format: * An integer `n` where ( 1 leq n leq 1000 ). Output Format: * An integer representing the number of ways to decompose `n`. Example: ```python Input: 4 Output: 5 Explanation: The decompositions are: 4 = 4 4 = 3 + 1 4 = 2 + 2 4 = 2 + 1 + 1 4 = 1 + 1 + 1 + 1 Input: 7 Output: 15 Explanation: The decompositions include: 7 = 7 7 = 6 + 1 7 = 5 + 2 7 = 5 + 1 + 1 7 = 4 + 3 7 = 4 + 2 + 1 7 = 4 + 1 + 1 + 1 7 = 3 + 3 + 1 7 = 3 + 2 + 2 7 = 3 + 2 + 1 + 1 7 = 3 + 1 + 1 + 1 + 1 7 = 2 + 2 + 2 + 1 7 = 2 + 2 + 1 + 1 + 1 7 = 2 + 1 + 1 + 1 + 1 + 1 7 = 1 + 1 + 1 + 1 + 1 + 1 + 1 ``` Constraints: 1. **Performance**: Your solution should be efficient and should not use excessive memory. 2. **Edge Cases**: You should handle edge cases such as the smallest and largest possible values of `n`.","solution":"def countDecompositions(n): Returns the number of different ways n can be decomposed into the sum of smaller positive integers. # Initialize a table to store results of subproblems dp = [0] * (n + 1) dp[0] = 1 # Dynamic programming approach for i in range(1, n + 1): for j in range(i, n + 1): dp[j] += dp[j - i] return dp[n]"},{"question":"You are given a hierarchical structure represented as nested dictionaries (trees). The structure can have varying depths and lengths of nested elements, including strings, integers, and lists. Your task is to write a function `enhanced_tree_print(tree)` that prints the tree structure in a hierarchical format, ensuring proper indenting to represent the nested levels. Input - `tree`: A dictionary where the key is a string, and the value can be another dictionary, list, or a string representing nested items or sub-categories. Output - The function should print the tree structure with proper indenting for each nested level. Performance - Your algorithm should run efficiently with a complexity close to O(n) in time, where n is the number of elements in the tree. Example Given the tree structure: ```python { \\"a\\": [\\"Adam\\", {\\"Book\\": 4}], \\"b\\": [\\"Bill\\", {\\"Computer\\": 5, \\"TV\\": 6}, \\"Jill\\", {\\"Sports\\": 1}], \\"c\\": [\\"Bill\\", {\\"Sports\\": 3}], \\"d\\": [\\"Adam\\", {\\"Computer\\": 3}, \\"Quin\\", {\\"Computer\\": 3}], \\"e\\": [\\"Quin\\", {\\"Book\\": 5, \\"TV\\": 2}], \\"f\\": [\\"Adam\\", {\\"Computer\\": 7}] } ``` Your function `enhanced_tree_print(tree)` should output: ``` a -> Adam -> Book -> 4 b -> Bill -> Computer -> 5 TV -> 6 Jill -> Sports -> 1 c -> Bill -> Sports -> 3 d -> Adam -> Computer -> 3 Quin -> Computer -> 3 e -> Quin -> Book -> 5 TV -> 2 f -> Adam -> Computer -> 7 ``` Constraints - Depth of nesting will be <= 10. - Each tree node value will be < 100. ```python def enhanced_tree_print(tree): # Your implementation here pass ```","solution":"def enhanced_tree_print(tree): def print_tree(t, indent): for key, value in t.items(): if isinstance(value, dict): print(\' \' * indent + f\'{key} ->\') print_tree(value, indent + 2) elif isinstance(value, list): print(\' \' * indent + f\'{key} ->\') for item in value: if isinstance(item, dict): print_tree(item, indent + 2) else: print(\' \' * (indent + 2) + str(item) + \' ->\') else: print(\' \' * indent + f\'{key} -> {value}\') print_tree(tree, 0)"},{"question":"Run-length encoding (RLE) is a form of lossless data compression in which runs of data (i.e., sequences in which the same data value occurs in many consecutive data elements) are stored as a single data value and count. Write a function to encode a string using RLE and another function to decode an RLE string back to its original form. # Requirements 1. Implement a function `encode_rle(input: str) -> str` which takes a string and returns its RLE encoded form. 2. Implement a function `decode_rle(input: str) -> str` which takes a RLE encoded string and returns its original form. Encoded String Format The encoded string format should be: counts and characters in a single combined string. # Input 1. A string `input` for the `encode_rle` function (1 <= len(input) <= 10^4). 2. A string `input` for the `decode_rle` function, which includes pairs of count and corresponding character. # Output 1. A string that represents the compressed form for `encode_rle`. 2. A string that represents the decompressed form for `decode_rle`. # Function Signature ```python def encode_rle(input: str) -> str: # implementation here def decode_rle(input: str) -> str: # implementation here ``` # Examples ```python assert encode_rle(\\"aaaabbbcca\\") == \\"4a3b2c1a\\" assert decode_rle(\\"4a3b2c1a\\") == \\"aaaabbbcca\\" assert encode_rle(\\"abcd\\") == \\"1a1b1c1d\\" assert decode_rle(\\"1a1b1c1d\\") == \\"abcd\\" ``` # Constraints 1. The input strings will only contain lowercase alphabets. 2. The encoded string for `decode_rle` will be valid. # Note Ensure optimal runtime performance without the complexity increasing excessively with input size.","solution":"def encode_rle(input: str) -> str: Encodes the input string using Run-Length Encoding (RLE). if not input: return \\"\\" result = [] count = 1 for i in range(1, len(input)): if input[i] == input[i-1]: count += 1 else: result.append(f\\"{count}{input[i-1]}\\") count = 1 result.append(f\\"{count}{input[-1]}\\") return \\"\\".join(result) def decode_rle(input: str) -> str: Decodes the RLE encoded string back to its original form. result = [] count = \\"\\" for char in input: if char.isdigit(): count += char else: result.append(char * int(count)) count = \\"\\" return \\"\\".join(result)"},{"question":"You are tasked to implement a Binary Search Tree (BST) with basic functionalities: insertion, search, and deletion. Additionally, you should implement a function to find the kth smallest element in the BST. # Requirements 1. **Insertion**: ```python def insert(root: TreeNode, key: int) -> TreeNode: ``` - **Input**: * `root` - The root of the BST. * `key` - The value to be inserted. - **Output**: The root of the updated BST. 2. **Search**: ```python def search(root: TreeNode, key: int) -> bool: ``` - **Input**: * `root` - The root of the BST. * `key` - The value to be searched. - **Output**: Returns `True` if the key is found, otherwise `False`. 3. **Deletion**: ```python def delete(root: TreeNode, key: int) -> TreeNode: ``` - **Input**: * `root` - The root of the BST. * `key` - The value to be deleted. - **Output**: The root of the updated BST. 4. **Kth Smallest Element**: ```python def kth_smallest(root: TreeNode, k: int) -> int: ``` - **Input**: * `root` - The root of the BST. * `k` - The position of the smallest element to find. - **Output**: The kth smallest element in the BST. # Constraints * Assume there are no duplicate keys in the BST. * The number of nodes in the tree is at most 10^4. * All keys are unique in the input. # Example ```python root = None root = insert(root, 5) root = insert(root, 3) root = insert(root, 7) root = insert(root, 2) root = insert(root, 4) print(search(root, 3)) # Output: True print(search(root, 6)) # Output: False root = delete(root, 3) print(search(root, 3)) # Output: False root = insert(root, 6) print(kth_smallest(root, 2)) # Output: 4 ``` # Notes * For `kth_smallest`, you may assume that `1 <= k <= number of nodes in the BST`.","solution":"class TreeNode: def __init__(self, key): self.val = key self.left = None self.right = None def insert(root, key): if root is None: return TreeNode(key) else: if key < root.val: root.left = insert(root.left, key) else: root.right = insert(root.right, key) return root def search(root, key): if root is None or root.val == key: return root is not None if key < root.val: return search(root.left, key) return search(root.right, key) def minValueNode(node): current = node while current.left is not None: current = current.left return current def delete(root, key): if root is None: return root if key < root.val: root.left = delete(root.left, key) elif key > root.val: root.right = delete(root.right, key) else: if root.left is None: return root.right elif root.right is None: return root.left temp = minValueNode(root.right) root.val = temp.val root.right = delete(root.right, temp.val) return root def inorderTraversal(root): return inorderTraversal(root.left) + [root.val] + inorderTraversal(root.right) if root else [] def kth_smallest(root, k): return inorderTraversal(root)[k-1]"},{"question":"# Bubble Sort Extension with an Early Termination Condition Problem Statement You are required to extend the current implementation of the bubble sort algorithm to improve its efficiency. Specifically, implement an additional feature that stops sorting when the array is identified as already sorted during an iteration cycle. Additionally, add a feature that counts and returns the total number of basic operations (comparisons and swaps) performed by the algorithm. Task Write a function `optimized_bubble_sort(arr: List[int], simulation: bool = False) -> Tuple[List[int], int]` that extends the provided `bubble_sort` function with: 1. An enhancement to detect and terminate early if the array is already sorted in any of the iterations. 2. A counter for the number of comparisons and swaps to measure algorithm efficiency. Input * `arr`: A list of integers to be sorted. * `simulation` (default: False): If set to True, the function should print each iteration of the array state. Output * A tuple containing: * The sorted array. * The total count of basic operations (comparisons and swaps). Example ```python result, operations = optimized_bubble_sort([5, 1, 4, 2, 8], simulation=True) print(result) # Output: [1, 2, 4, 5, 8] print(operations) # Output: The total number of comparisons and swaps performed. ``` Constraints * The array can contain up to 10^3 elements. * Elements of the array are integers within the range [-10^3, 10^3]. Notes 1. Ensure that the function is optimized to handle early termination if no swaps occur in a complete iteration. 2. The function should count both comparisons and swaps as operations. Happy coding!","solution":"from typing import List, Tuple def optimized_bubble_sort(arr: List[int], simulation: bool = False) -> Tuple[List[int], int]: n = len(arr) operations = 0 for i in range(n): swapped = False if simulation: print(f\'Iteration {i+1}: {arr}\') for j in range(0, n - i - 1): operations += 1 # count comparison if arr[j] > arr[j + 1]: arr[j], arr[j + 1] = arr[j + 1], arr[j] swapped = True operations += 1 # count swap if not swapped: break return arr, operations"},{"question":"# Advanced Data Structures - Segment Tree Objective Develop a Python implementation to perform efficient range queries and updates on an array using a segment tree. Problem Statement You are to implement a `SegmentTree` class that allows range queries and point updates efficiently. The provided `SegmentTree` class includes the following functionalities: 1. **Constructor method `__init__`**: Initializes the segment tree with a given array and a commutative function. 2. **Build Tree method `build_tree`**: Constructs the tree using the commutative function. 3. **Update method `update`**: Updates an element in the array. 4. **Query method `query`**: Performs a range query on the array. Given the existing class definition of `SegmentTree`, you are tasked with the following: Implementation Requirements: 1. Implement the `__init__`, `build_tree`, `update`, and `query` methods in the `SegmentTree` class. 2. Address edge cases such as empty arrays and out-of-bounds queries. Constraints: * The length of the input array will be between 1 and 10^5. * The commutative function will always return the same type as its inputs. * Update positions will be within the bounds of the array. * Query ranges will be within the bounds of the array. Input Format: * The constructor will take in a list of elements `arr` and a function `fn` (used for the segment tree\'s operations). * The `update` method will take an index `p` and a value `v`. * The `query` method will take two indices `l` and `r`. Output Format: * The `query` method will return the result of applying the commutative function to the range `[l, r]` in the segment tree. Example Input/Output: ```python # Sample usage mytree = SegmentTree([2, 4, 5, 3, 4], max) print(mytree.query(2, 4)) # Output: 5 mytree.update(3, 6) print(mytree.query(0, 3)) # Output: 6 mytree = SegmentTree([4, 5, 2, 3, 4, 43, 3], lambda a, b: a + b) print(mytree.query(0, 6)) # Output: 64 mytree.update(2, -10) print(mytree.query(0, 6)) # Output: 52 mytree = SegmentTree([(1, 2), (4, 6), (4, 5)], lambda a, b: (a[0] + b[0], a[1] + b[1])) print(mytree.query(0, 2)) # Output: (9, 13) mytree.update(2, (-1, 2)) print(mytree.query(0, 2)) # Output: (4, 10) ``` Notes: * Ensure you handle edge cases for query ranges. * Consider performance implications when updating elements frequently. * Maintain clarity and thorough documentation in your implementation.","solution":"class SegmentTree: def __init__(self, arr, fn): Initializes the Segment Tree. Args: arr (list): The initial array of elements. fn (function): The commutative function to be used in the segment tree. self.n = len(arr) self.fn = fn self.tree = [None] * (2 * self.n) # Build the tree self.build_tree(arr) def build_tree(self, arr): Builds the segment tree with the provided array. Args: arr (list): The initial array of elements. # Initialize the leaves for i in range(self.n): self.tree[i + self.n] = arr[i] # Build the tree by calculating parents for i in range(self.n - 1, 0, -1): self.tree[i] = self.fn(self.tree[i * 2], self.tree[i * 2 + 1]) def update(self, p, value): Updates the value at index p and rebuilds the segment tree. Args: p (int): The index to be updated. value (any): The new value at index p. # Update the value at the leaf node p += self.n self.tree[p] = value # Recalculate the values for the parent nodes while p > 1: p //= 2 self.tree[p] = self.fn(self.tree[p * 2], self.tree[p * 2 + 1]) def query(self, l, r): Performs a range query from index l to r inclusive. Args: l (int): The starting index of the range. r (int): The ending index of the range. Returns: any: The result of applying the function to the range [l, r]. result = None l += self.n r += self.n + 1 while l < r: if l % 2 == 1: result = self.tree[l] if result is None else self.fn(result, self.tree[l]) l += 1 if r % 2 == 1: r -= 1 result = self.tree[r] if result is None else self.fn(result, self.tree[r]) l //= 2 r //= 2 return result"},{"question":"Consider an array of unique positive integers `nums` and a positive integer `target`. Your task is to write a function that returns the number of distinct combinations of numbers from `nums` that sum up to `target`. Each number in `nums` can be used unlimited times in the combination. Two approaches should be implemented: 1. Top-Down Dynamic Programming with Memoization. 2. Bottom-Up Dynamic Programming. Input * An array of positive integers `nums` (1 ≤ `nums.length` ≤ 200, 1 ≤ `nums[i]` ≤ 200). * A positive integer `target`. Output * A single integer representing the number of combinations that sum up to `target`. Examples ```python nums = [1, 2, 3] target = 4 # The possible combination ways are: # (1, 1, 1, 1) # (1, 1, 2) # (1, 2, 1) # (1, 3) # (2, 1, 1) # (2, 2) # (3, 1) # Therefore the output is 7. ``` Constraints * The input array `nums` contains unique numbers. * Assume all numbers and the target are positive. Follow-up questions 1. What if negative numbers are allowed in the given array? How does it change the problem? 2. What limitation do we need to add to the question to allow negative numbers? # Coding Task Implement the following two functions: 1. `combination_sum_topdown(nums, target)`: - Uses top-down dynamic programming with memoization. - Returns the number of combinations that sum up to `target`. 2. `combination_sum_bottom_up(nums, target)`: - Uses bottom-up dynamic programming. - Returns the number of combinations that sum up to `target`. # Function Signature ```python def combination_sum_topdown(nums: List[int], target: int) -> int: pass def combination_sum_bottom_up(nums: List[int], target: int) -> int: pass ``` # Notes - Ensure that your solution adheres to the constraints. - Test your functions with various edge cases and scenarios.","solution":"from typing import List def combination_sum_topdown(nums: List[int], target: int) -> int: memo = {} def dp(remaining): if remaining in memo: return memo[remaining] if remaining == 0: return 1 if remaining < 0: return 0 count = 0 for num in nums: count += dp(remaining - num) memo[remaining] = count return count return dp(target) def combination_sum_bottom_up(nums: List[int], target: int) -> int: dp = [0] * (target + 1) dp[0] = 1 for total in range(1, target + 1): for num in nums: if total - num >= 0: dp[total] += dp[total - num] return dp[target]"},{"question":"# Stutter Stack Elements You need to write a function that takes a stack represented by a list and duplicates each element. Implement two versions of this function. The first version should use an auxiliary stack while the second version should use an auxiliary queue. Function Signature ```python def first_stutter(stack: list) -> list: Duplicates each element in the stack using an auxiliary stack. :param stack: A list representing the stack where index 0 is the bottom and the last index is the top. :return: The modified stack with each element duplicated. pass def second_stutter(stack: list) -> list: Duplicates each element in the stack using an auxiliary queue. :param stack: A list representing the stack where index 0 is the bottom and the last index is the top. :return: The modified stack with each element duplicated. pass ``` Input/Output Format * Input: A list of integers representing a stack. * Output: A list of integers with each original element appearing twice consecutively in the same order. Constraints * The stack has at most `10^4` elements. * Each element in the stack fits into a 32-bit signed integer. Example * `Input: [3, 7, 1, 14, 9]` * `Output: [3, 3, 7, 7, 1, 1, 14, 14, 9, 9]` * `Input: []` * `Output: []` Performance Requirements The solution should have a time complexity of O(n) and a space complexity of O(n) in the worst case, where n is the number of elements in the stack.","solution":"def first_stutter(stack: list) -> list: Duplicates each element in the stack using an auxiliary stack. :param stack: A list representing the stack where index 0 is the bottom and the last index is the top. :return: The modified stack with each element duplicated. auxiliary_stack = [] # First pass: pop from original stack and push twice to auxiliary stack while stack: element = stack.pop() auxiliary_stack.append(element) auxiliary_stack.append(element) # Second pass: pop from auxiliary stack and push back to original stack while auxiliary_stack: stack.append(auxiliary_stack.pop()) return stack def second_stutter(stack: list) -> list: Duplicates each element in the stack using an auxiliary queue. :param stack: A list representing the stack where index 0 is the bottom and the last index is the top. :return: The modified stack with each element duplicated. from collections import deque auxiliary_queue = deque() # Empty the stack into the queue, duplicating each element while stack: element = stack.pop() auxiliary_queue.appendleft(element) auxiliary_queue.appendleft(element) # Refill the stack from the queue while auxiliary_queue: stack.append(auxiliary_queue.popleft()) return stack"},{"question":"# Fenwick Tree / Binary Indexed Tree Implementation and Usage You are working for a data analysis company, and one of the tasks is to frequently calculate the prefix sums and update elements of large datasets. You have decided to use a Fenwick Tree due to its efficient update and query capabilities. Task Implement the Fenwick Tree with the following functionalities: 1. **Constructor**: Initialize the tree with a given frequency array. 2. **Get Sum**: Method to calculate and return the sum of the elements from index 0 to a given index `i`. 3. **Update**: Method to add a given value to an element at index `i`. Given the class skeleton, complete the missing parts to ensure the tree constructs correctly and can perform both prefix sum queries and updates efficiently. # Function Signatures ```python class Fenwick_Tree: def __init__(self, freq: List[int]): pass # initialization logic here def get_sum(self, bit_tree: List[int], i: int) -> int: pass # logic to get the sum here def update_bit(self, bit_tree: List[int], i: int, val: int): pass # logic to update the BIT here def construct(self) -> List[int]: pass # logic to construct the BIT here ``` # Constraints - The input array `freq` will have `1 <= len(freq) <= 10^5` elements. - Each element of the array will be an integer in the range `-10^9` to `10^9`. - Queries and updates will be confined within the array bounds. # Example ```python # Example Usage freq = [3, 2, -1, 6, 5, 4, -3] fenwick_tree = Fenwick_Tree(freq) # Constructing the BIT bit_tree = fenwick_tree.construct() # Querying the sum of the first 4 elements print(fenwick_tree.get_sum(bit_tree, 3)) # Output: 10 # Updating the 2nd element (zero-based index) fenwick_tree.update_bit(bit_tree, 1, 4) # freq[1] becomes 2 + 4 = 6 # Querying again after the update print(fenwick_tree.get_sum(bit_tree, 3)) # Output: 14 ``` Write valid, efficient, and robust implementation code that aligns with the described logic and constraints.","solution":"from typing import List class Fenwick_Tree: def __init__(self, freq: List[int]): self.freq = freq self.bit_tree = self.construct() def get_sum(self, bit_tree: List[int], i: int) -> int: # Convert to 1-based index for BIT operations i += 1 s = 0 while i > 0: s += bit_tree[i] i -= i & (-i) return s def update_bit(self, bit_tree: List[int], i: int, val: int): # Convert to 1-based index for BIT operations i += 1 while i < len(bit_tree): bit_tree[i] += val i += i & (-i) def construct(self) -> List[int]: bit_tree = [0] * (len(self.freq) + 1) for i in range(len(self.freq)): self.update_bit(bit_tree, i, self.freq[i]) return bit_tree"},{"question":"**Scenario**: Imagine you are developing a software tool that helps users generate abbreviations for long words or phrases, commonly used to create unique but short identifiers in large codebases. **Task**: Write a Python function named `generate_abbreviations` that takes a single string `word` as input and returns a list of all possible abbreviations for the word. Each character in the word can either be kept as is, or represented by a numeric count of consecutive characters. **Function Signature**: ```python def generate_abbreviations(word: str) -> List[str]: ``` **Input**: * `word` (a non-empty string): The word for which abbreviations need to be generated. **Output**: * List of strings: All possible abbreviations of the input word, including the original word itself. **Constraints**: * You must use a backtracking approach to generate the abbreviations. * Avoid generating duplicate abbreviations. * The function should work efficiently for the word length up to 15 characters. **Example**: ```python assert generate_abbreviations(\\"word\\") == [ \\"word\\", \\"wor1\\", \\"wo1d\\", \\"wo2\\", \\"w1rd\\", \\"w1r1\\", \\"w2d\\", \\"w3\\", \\"1ord\\", \\"1or1\\", \\"1o1d\\", \\"1o2\\", \\"2rd\\", \\"2r1\\", \\"3d\\", \\"4\\" ] ``` **Notes**: * The sequence of the resulting list may vary due to the nature of the backtracking approach, but all possible abbreviations must be included. * Ensure you handle edge cases such as single character words and input with repetitive characters appropriately.","solution":"from typing import List def generate_abbreviations(word: str) -> List[str]: def backtrack(pos: int, cur: str, count: int): if pos == len(word): if count > 0: cur += str(count) results.append(cur) else: backtrack(pos + 1, cur, count + 1) backtrack(pos + 1, cur + (str(count) if count > 0 else \\"\\") + word[pos], 0) results = [] backtrack(0, \\"\\", 0) return results"},{"question":"Implementing a Robust RSA Key Generator Given your understanding of the RSA encryption algorithm, write a Python program to generate RSA keys (`n`, `e`, `d`), and ensure robust handling of edge cases and performance pitfalls. # Problem Requirements * Implement a function `generate_rsa_keys(k: int) -> Tuple[int, int, int]` which generates the key components: `n`, `e`, and `d` where `k` is the number of bits in `n`. * Implement a function `is_prime(num: int) -> bool` to check the primality of a given number. * Implement a function `modinv(a: int, m: int) -> int` to compute the modular inverse of `a` mod `m`. * Optimize the prime generation for larger `k` values. # Constraints * `k` will be in the range 32 to 2048 (inclusive). * Primes should have a high probability of being correct (use probabilistic prime testing). * Ensure `e` is commonly chosen as a small constant (e.g., 65537). # Input * `k`: An integer representing the number of bits in the modulus `n`. # Output * Returns a tuple `(n, e, d)` where: * `n` is the modulus. * `e` is the public exponent. * `d` is the private exponent. # Example ```python k = 16 keys = generate_rsa_keys(k) print(keys) # Output might look like: (3233, 65537, 2753) ``` # Additional Notes * Do not use any external libraries for prime checking; implement the probabilistic checking from scratch. * Implement modular exponentiation efficiently. * Ensure to handle edge cases like prime `p` being nearly equal to `q`. You are required to test your solution with various bit sizes and ensure robustness and correctness.","solution":"import random from typing import Tuple def is_prime(num: int, k: int = 5) -> bool: Miller-Rabin primality test to check if a number is prime. if num <= 1: return False if num <= 3: return True if num % 2 == 0: return False # Write (num - 1) as 2^r * d r, d = 0, num - 1 while d % 2 == 0: r += 1 d //= 2 for _ in range(k): a = random.randint(2, num - 2) x = pow(a, d, num) if x == 1 or x == num - 1: continue for _ in range(r - 1): x = pow(x, 2, num) if x == num - 1: break else: return False return True def generate_prime_candidate(bits: int) -> int: Generate an odd integer randomly. p = random.getrandbits(bits) p |= (1 << bits - 1) | 1 return p def generate_prime(bits: int) -> int: Generate a prime number with specified bit size. p = generate_prime_candidate(bits) while not is_prime(p): p = generate_prime_candidate(bits) return p def gcd(a: int, b: int) -> int: Compute the greatest common divisor of a and b. while b: a, b = b, a % b return a def modinv(a: int, m: int) -> int: Compute the modular inverse of a under modulus m using Extended Euclidean Algorithm. m0, x0, x1 = m, 0, 1 if m == 1: return 0 while a > 1: q = a // m m, a = a % m, m x0, x1 = x1 - q * x0, x0 if x1 < 0: x1 += m0 return x1 def generate_rsa_keys(k: int) -> Tuple[int, int, int]: Generate RSA key components (n, e, d) for a given bit length k. assert k >= 32 and k <= 2048, \\"The number of bits k must be between 32 and 2048 inclusive.\\" e = 65537 p = generate_prime(k // 2) q = generate_prime(k // 2) while p == q: q = generate_prime(k // 2) n = p * q phi = (p - 1) * (q - 1) while gcd(e, phi) != 1: e += 2 d = modinv(e, phi) return (n, e, d)"},{"question":"# Question Context You are working with pattern matching in text strings and need to implement a function that validates if a given pattern correctly maps to a string using a one-to-one relationship. The problem assumes the pattern contains only lowercase letters, and the string is composed of lowercase letters separated by single spaces. Problem Statement Write a function `word_pattern(pattern: str, string: str) -> bool` that returns `True` if the string follows the same pattern as the given pattern string, otherwise returns `False`. Input * `pattern`: A string of lowercase letters (1 ≤ len(pattern) ≤ 200). * `string`: A string of lowercase words separated by single spaces (1 ≤ len(string) ≤ 2000). Output * Boolean value `True` or `False`. Constraints * There is a bijection between a letter in pattern and a non-empty word in the string. Examples ```python word_pattern(\\"abba\\", \\"dog cat cat dog\\") # Output: True word_pattern(\\"abba\\", \\"dog cat cat fish\\") # Output: False word_pattern(\\"aaaa\\", \\"dog cat cat dog\\") # Output: False word_pattern(\\"abba\\", \\"dog dog dog dog\\") # Output: False ``` Explanation * In the first example, \'a\' maps to \'dog\', \'b\' maps to \'cat\', and both \'a\'s map to \'dog\' and the \'b\'s map to \'cat\' respectively which satisfies the pattern. * In the second example, \'a\' maps to \'dog\' and \'b\' maps to \'fish\' which breaks the pattern. * In the third example, \'a\' should map to a single word which is not possible here as different words are repeating. * In the fourth example, each \'a\' and \'b\' should map to different words, but in this case all \'dog\' are mapped which breaks the bijection rule.","solution":"def word_pattern(pattern: str, string: str) -> bool: words = string.split() if len(pattern) != len(words): return False char_to_word = {} word_to_char = {} for char, word in zip(pattern, words): if char in char_to_word: if char_to_word[char] != word: return False else: char_to_word[char] = word if word in word_to_char: if word_to_char[word] != char: return False else: word_to_char[word] = char return True"},{"question":"You are tasked with finding the nth digit of the sequence formed by concatenating all decimal digits in the natural number order: \\"123456789101112...\\". Write a function `find_nth_digit(n)` that computes this efficiently. # Requirements 1. **Function Signature**: `def find_nth_digit(n: int) -> int` 2. **Input**: - An integer `n` (1 ≤ n ≤ 10^9), representing the position in the infinite sequence of all decimal digits concatenated. 3. **Output**: - An integer representing the nth digit in the sequence. 4. **Performance**: - The solution should have a time complexity of O(log(n)) and space complexity of O(1). # Constraints 1. Consider all possible values within given constraint (1 ≤ n ≤ 10^9). 2. Ensure the function handles edge cases like when n is at the boundary of changing lengths (e.g., from 9 to 10, 99 to 100). # Example ```python assert find_nth_digit(3) == 3 # Sequence is \\"123\\", the 3rd digit is 3. assert find_nth_digit(11) == 0 # Sequence starts \\"12345678910...\\", the 11th digit is 0. ```","solution":"def find_nth_digit(n: int) -> int: Returns the nth digit in the sequence of all decimal digits in natural number order. length = 1 # The current length of numbers we are counting (1 for 1-9, 2 for 10-99...) count = 9 # The current count of numbers of that `length` in the sequence start = 1 # The starting number of current `length` while n > length * count: n -= length * count length += 1 count *= 10 start *= 10 # Determine the exact number and the digit within that number start += (n - 1) // length s = str(start) return int(s[(n - 1) % length])"},{"question":"You are provided with a Markov Chain simulation function. A Markov Chain in this context is defined by a dictionary where keys represent states and values are dictionaries that map from the current state to the probabilities of transitioning to other states. Your task is to implement a function that: 1. Validates the Markov Chain to ensure all probabilities in the state transitions sum up to 1. 2. Simulates the Markov Chain and returns a list of states visited after a specified number of steps starting from a given initial state. # Function Definitions ```python def validate_chain(chain): Validate the Markov chain. Args: chain (dict): The Markov chain represented as a dictionary. Returns: bool: True if valid, False otherwise. pass def simulate_markov_chain(chain, start_state, steps): Simulate the Markov Chain from the start state for \\"steps\\" steps. Args: chain (dict): The Markov chain represented as a dictionary. start_state (str): The initial state to start the simulation. steps (int): The number of steps to simulate. Returns: list: The list of states visited during the simulation. pass ``` # Input and Output - `validate_chain(chain)`: Should return `True` if the Markov Chain is valid (i.e., all probabilities for a given state\'s transitions sum to 1), otherwise `False`. - `simulate_markov_chain(chain, start_state, steps)`: Should return a list of states visited during the simulation starting from `start_state` for `steps` transitions. # Constraints 1. The sum of the transition probabilities for any state should not exceed floating-point precision errors (e.g., sum between `0.999` and `1.001` can be considered valid). 2. The number of states and steps will fit in memory. # Example ```python chain = { \'A\': {\'A\': 0.6, \'E\': 0.4}, \'E\': {\'A\': 0.7, \'E\': 0.3} } assert validate_chain(chain) == True steps_output = simulate_markov_chain(chain, \'A\', 3) print(steps_output) # Example output: [\'E\', \'A\', \'E\'] (output will vary due to randomness) ``` # Note Use the `random` module for the random state transition.","solution":"import random def validate_chain(chain): Validate the Markov chain. Args: chain (dict): The Markov chain represented as a dictionary. Returns: bool: True if valid, False otherwise. for state, transitions in chain.items(): total_prob = sum(transitions.values()) if not (0.999 <= total_prob <= 1.001): return False return True def simulate_markov_chain(chain, start_state, steps): Simulate the Markov Chain from the start state for \\"steps\\" steps. Args: chain (dict): The Markov chain represented as a dictionary. start_state (str): The initial state to start the simulation. steps (int): The number of steps to simulate. Returns: list: The list of states visited during the simulation. if start_state not in chain: raise ValueError(\\"Invalid start state\\") if steps <= 0: return [] current_state = start_state visited_states = [current_state] for _ in range(steps): next_state = _next_state(chain[current_state]) visited_states.append(next_state) current_state = next_state return visited_states def _next_state(transitions): Helper function to get the next state based on current state\'s transition probabilities. Args: transitions (dict): Dictionary containing state transition probabilities. Returns: str: The next state. states = list(transitions.keys()) probabilities = list(transitions.values()) return random.choices(states, probabilities)[0]"},{"question":"# Maximum Water Flow in a Pipe Network Scenario You are given a network of pipes linking various reservoirs. Each pipe has a certain capacity which denotes the maximum amount of water it can transfer per unit time. Your task is to determine the maximum possible amount of water that can flow from the main reservoir (source) to the terminal reservoir (sink). Problem Statement Implement the function `maximum_water_flow(pipes)` that calculates the maximum flow in a given pipe network. Function Specification - **Function Name**: `maximum_water_flow` - **Input**: - `pipes`: A list of lists (2D list/adjacency matrix) where `pipes[i][j]` represents the capacity of the pipe from reservoir `i` to reservoir `j`. If `pipes[i][j]` is 0, there is no direct pipe between these reservoirs. - **Output**: - Return an integer representing the maximum flow from the source (first reservoir) to the sink (last reservoir). Constraints - The network is represented by a square matrix of size `n` x `n`, where 2 ≤ n ≤ 100. - Capacities are non-negative integers. Example Consider the following adjacency matrix representation of the pipe network: ```python pipes = [ [0, 16, 13, 0, 0, 0], [0, 0, 10, 12, 0, 0], [0, 4, 0, 0, 14, 0], [0, 0, 9, 0, 0, 20], [0, 0, 0, 7, 0, 4], [0, 0, 0, 0, 0, 0] ] ``` The function `maximum_water_flow(pipes)` should return `23`, as that is the maximum flow possible from the source (reservoir 0) to the sink (reservoir 5). Note Ensure your implementation efficiently finds the augmenting paths and updates the flow and residual capacities accordingly.","solution":"from collections import deque def bfs(rGraph, s, t, parent): visited = [False] * len(rGraph) queue = deque([s]) visited[s] = True while queue: u = queue.popleft() for v, capacity in enumerate(rGraph[u]): if visited[v] == False and capacity > 0: queue.append(v) visited[v] = True parent[v] = u if v == t: return True return False def maximum_water_flow(pipes): n = len(pipes) source = 0 sink = n - 1 rGraph = [row[:] for row in pipes] parent = [-1] * n max_flow = 0 while bfs(rGraph, source, sink, parent): path_flow = float(\'Inf\') s = sink while s != source: path_flow = min(path_flow, rGraph[parent[s]][s]) s = parent[s] v = sink while v != source: u = parent[v] rGraph[u][v] -= path_flow rGraph[v][u] += path_flow v = parent[v] max_flow += path_flow return max_flow"},{"question":"You are given a list of integers where every integer appears exactly twice, except for one integer which appears only once. Your task is to identify the integer that appears only once. Write a function `find_single(nums)` to find this unique integer. # Function Signature ```python def find_single(nums: List[int]) -> int: pass ``` # Input * `nums` : A list of integers (List[int]) where: - All elements appear exactly twice except for one which appears only once. - Constraints: - 1 <= len(nums) <= 10^5 - -3 * 10^4 <= nums[i] <= 3 * 10^4 # Output * Return the integer that appears only once in the list. # Example ```python find_single([2, 2, 1]) -> 1 find_single([4, 1, 2, 1, 2]) -> 4 find_single([1]) -> 1 ``` # Requirements * The solution should have a linear runtime complexity (O(n)). * The solution should not use any extra memory beyond constant space. # Constraints - All elements will appear exactly twice except one. - The number of elements in the array will be odd. # Scenario In a game involving a series of operations, you need to find out which operation was done exactly once while all others were performed in pairs. Identifying this unique operation efficiently will significantly enhance the overall performance of your game function.","solution":"from typing import List def find_single(nums: List[int]) -> int: Finds the single integer in the list that does not appear twice. Args: nums: List of integers where every integer appears exactly twice, except for one integer which appears only once. Returns: The integer that appears only once in the list. unique_num = 0 for num in nums: unique_num ^= num # XOR-ing all numbers will cancel out the numbers appearing in pairs. return unique_num"},{"question":"# Context Suppose you are helping a colleague build a system that needs to traverse binary trees for a variety of operations including data extraction, visualization, and analytics. One fundamental task they need is to perform an inorder traversal of the binary tree to list the nodes’ values in sorted order. # Task Implement two functions that perform an inorder traversal of a binary tree. One should use an iterative approach and the other should use a recursive approach. # Requirements Your function should have the following signature: ```python def inorder_iterative(root: Optional[Node]) -> List[int]: pass def inorder_recursive(root: Optional[Node], res: Optional[List[int]] = None) -> List[int]: pass ``` # Input * The `root` is the root node of a binary tree. * Each `Node` is an object with `val`, `left`, and `right` attributes (each Node or None). # Output * Both functions should return a list of integers containing the node values in inorder sequence (left, root, right). # Constraints * Node values are unique integers. * The tree can have up to 10^4 nodes. * Heights of up to 10^4 (highly unbalanced). # Example ```python class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right if __name__ == \\"__main__\\": n1 = Node(100) n2 = Node(50) n3 = Node(150) n4 = Node(25) n5 = Node(75) n6 = Node(125) n7 = Node(175) n1.left, n1.right = n2, n3 n2.left, n2.right = n4, n5 n3.left, n3.right = n6, n7 assert inorder_iterative(n1) == [25, 50, 75, 100, 125, 150, 175] assert inorder_recursive(n1) == [25, 50, 75, 100, 125, 150, 175] ``` # Notes - Ensure your solution handles empty trees. - Test your solution with balanced as well as unbalanced trees to validate efficiency and correctness. - Aim for an efficient solution with minimal space overhead.","solution":"from typing import Optional, List class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right def inorder_iterative(root: Optional[Node]) -> List[int]: Performs an inorder traversal of a binary tree using an iterative approach. :param root: The root node of the binary tree. :return: A list of integers containing the node values in inorder sequence. result = [] stack = [] current = root while current or stack: while current: stack.append(current) current = current.left current = stack.pop() result.append(current.val) current = current.right return result def inorder_recursive(root: Optional[Node], res: Optional[List[int]] = None) -> List[int]: Performs an inorder traversal of a binary tree using a recursive approach. :param root: The root node of the binary tree. :param res: The list to store the result, used internally during recursion. :return: A list of integers containing the node values in inorder sequence. if res is None: res = [] if root: inorder_recursive(root.left, res) res.append(root.val) inorder_recursive(root.right, res) return res"},{"question":"Implement a Priority Queue Using a Red-Black Tree A Priority Queue (PQ) maintains a collection of elements, each with a priority assigned. In this task, you are required to implement a priority queue using a Red-Black tree. Specifically, your implementation should support the following operations: 1. **Insert**: Add an element with a specific priority value. 2. **Extract Max**: Remove the element with the highest priority and return it. 3. **Peek Max**: Return the element with the highest priority without removing it. 4. **Update Priority**: Update the priority of an element. The provided `RBTree` class should be utilized to maintain the priority queue. You may need to extend or modify the `RBTree` class where necessary. Function Specifications: * **`insert(self, value, priority)`**: Inserts a new element with the given value and priority. * *Input*: Two integers `value` and `priority`. * *Output*: None. * **`extract_max(self)`**: Removes and returns the element with the highest priority. * *Input*: None. * *Output*: Integer representing the value with the highest priority. * **`peek_max(self)`**: Returns the element with the highest priority without removing it. * *Input*: None. * *Output*: Integer representing the value with the highest priority. * **`update_priority(self, value, new_priority)`**: Updates the priority of the given element. * *Input*: An integer `value` and an integer `new_priority`. * *Output*: None. Constraints: 1. All elements will have unique values. 2. Priority values are integers and can be negative. 3. The updates will always ensure valid operations. 4. Python\'s native data types and structures should be used. # Example Usage: ```python priority_queue = PriorityQueueUsingRBTree() priority_queue.insert(10, 15) priority_queue.insert(20, 18) priority_queue.insert(30, 8) print(priority_queue.peek_max()) # Output should be 20 priority_queue.update_priority(10, 19) print(priority_queue.peek_max()) # Output should be 10 print(priority_queue.extract_max()) # Output should be 10 print(priority_queue.peek_max()) # Output should be 20 ``` You need to complete the implementation of the `PriorityQueueUsingRBTree` class by integrating and/or extending the provided `RBTree` class.","solution":"class Node: def __init__(self, key, value, color): self.key = key self.value = value self.color = color self.left = None self.right = None self.parent = None RED = True BLACK = False class RBTree: def __init__(self): self.NIL = Node(0, 0, BLACK) self.root = self.NIL def insert(self, key, value): new_node = Node(key, value, RED) new_node.left = self.NIL new_node.right = self.NIL if self.root == self.NIL: self.root = new_node self.root.color = BLACK self.root.parent = self.NIL else: parent = None current = self.root while current != self.NIL: parent = current if new_node.key < current.key: current = current.left else: current = current.right new_node.parent = parent if new_node.key < parent.key: parent.left = new_node else: parent.right = new_node self.fix_insert(new_node) def fix_insert(self, k): while k != self.root and k.parent.color == RED: if k.parent == k.parent.parent.left: u = k.parent.parent.right if u.color == RED: # Case 1 u.color = BLACK k.parent.color = BLACK k.parent.parent.color = RED k = k.parent.parent else: if k == k.parent.right: # Case 2 k = k.parent self.left_rotate(k) k.parent.color = BLACK # Case 3 k.parent.parent.color = RED self.right_rotate(k.parent.parent) else: u = k.parent.parent.left if u.color == RED: # Case 1 u.color = BLACK k.parent.color = BLACK k.parent.parent.color = RED k = k.parent.parent else: if k == k.parent.left: # Case 2 k = k.parent self.right_rotate(k) k.parent.color = BLACK # Case 3 k.parent.parent.color = RED self.left_rotate(k.parent.parent) self.root.color = BLACK def left_rotate(self, x): y = x.right x.right = y.left if y.left != self.NIL: y.left.parent = x y.parent = x.parent if x.parent == None: self.root = y elif x == x.parent.left: x.parent.left = y else: x.parent.right = y y.left = x x.parent = y def right_rotate(self, x): y = x.left x.left = y.right if y.right != self.NIL: y.right.parent = x y.parent = x.parent if x.parent == None: self.root = y elif x == x.parent.right: x.parent.right = y else: x.parent.left = y y.right = x x.parent = y def max_node(self, node): while node.right != self.NIL: node = node.right return node def find_node(self, node, key): if node == self.NIL or key == node.key: return node if key < node.key: return self.find_node(node.left, key) return self.find_node(node.right, key) def delete_node(self, key): node_to_delete = self.find_node(self.root, key) if node_to_delete == self.NIL: return None y = node_to_delete y_original_color = y.color if node_to_delete.left == self.NIL: x = node_to_delete.right self.transplant(node_to_delete, node_to_delete.right) elif node_to_delete.right == self.NIL: x = node_to_delete.left self.transplant(node_to_delete, node_to_delete.left) else: y = self.max_node(node_to_delete.left) y_original_color = y.color x = y.left if y.parent == node_to_delete: x.parent = y else: self.transplant(y, y.left) y.left = node_to_delete.left y.left.parent = y self.transplant(node_to_delete, y) y.right = node_to_delete.right y.right.parent = y y.color = node_to_delete.color if y_original_color == BLACK: self.fix_delete(x) def transplant(self, u, v): if u.parent == None: self.root = v elif u == u.parent.left: u.parent.left = v else: u.parent.right = v v.parent = u.parent def fix_delete(self, x): while x != self.root and x.color == BLACK: if x == x.parent.left: w = x.parent.right if w.color == RED: w.color = BLACK x.parent.color = RED self.left_rotate(x.parent) w = x.parent.right if w.left.color == BLACK and w.right.color == BLACK: w.color = RED x = x.parent else: if w.right.color == BLACK: w.left.color = BLACK w.color = RED self.right_rotate(w) w = x.parent.right w.color = x.parent.color x.parent.color = BLACK w.right.color = BLACK self.left_rotate(x.parent) x = self.root else: w = x.parent.left if w.color == RED: w.color = BLACK x.parent.color = RED self.right_rotate(x.parent) w = x.parent.left if w.right.color == BLACK and w.right.color == BLACK: w.color = RED x = x.parent else: if w.left.color == BLACK: w.right.color = BLACK w.color = RED self.left_rotate(w) w = x.parent.left w.color = x.parent.color x.parent.color = BLACK w.left.color = BLACK self.right_rotate(x.parent) x = self.root x.color = BLACK def get_max(self): return self.max_node(self.root).value def update_node_key(self, node, new_key): self.delete_node(node.key) self.insert(new_key, node.value) class PriorityQueueUsingRBTree: def __init__(self): self.tree = RBTree() self.value_to_key = {} self.key_increment = 0 def generate_new_key(self): self.key_increment += 1 return self.key_increment def insert(self, value, priority): key = self.generate_new_key() self.tree.insert(priority, value) self.value_to_key[value] = key def extract_max(self): max_value = self.tree.get_max() max_node = self.tree.max_node(self.tree.root) self.tree.delete_node(max_node.key) del self.value_to_key[max_value] return max_value def peek_max(self): return self.tree.get_max() def update_priority(self, value, new_priority): if value in self.value_to_key: old_key = self.value_to_key[value] self.tree.delete_node(old_key) self.insert(value, new_priority)"},{"question":"**Binary Tree Level Order Traversal** You are given the `Node` class and an example binary tree which you can create as described below. Your task is to implement a function `level_order(root)` that performs a level-order traversal (also known as a Breadth-First Search) of the binary tree. The function should return a list of values for each level of the tree, from top to bottom. # Function Definition ```python def level_order(root: Node) -> List[List[int]]: ``` # Input * `root` (Node) - The root node of the binary tree. # Output * Returns a list of lists, where each sub-list contains the values of the nodes at that level of the tree, from left to right. # Constraints: * The number of nodes in the tree is between 0 and 10^5. * The tree can be composed of left children, right children, or no children at each node. # Example: ```python n1 = Node(100) n2 = Node(50) n3 = Node(150) n4 = Node(25) n5 = Node(75) n6 = Node(125) n7 = Node(175) n1.left, n1.right = n2, n3 n2.left, n2.right = n4, n5 n3.left, n3.right = n6, n7 assert level_order(n1) == [ [100], [50, 150], [25, 75, 125, 175] ] ``` # Explanation: * `level_order(n1)` processes the nodes level by level: - The first level contains the root node `[100]`. - The second level contains the left and right children of the root `[50, 150]`. - The third level contains the children of the nodes in the second level `[25, 75, 125, 175]`. # Note: * Implement the function iteratively using a queue data structure for efficiency. * Include appropriate edge case checks for trees with no nodes or only one node.","solution":"from typing import List, Optional from collections import deque class Node: def __init__(self, value: int, left: \'Node\' = None, right: \'Node\' = None): self.value = value self.left = left self.right = right def level_order(root: Optional[Node]) -> List[List[int]]: if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) level_values = [] for _ in range(level_size): node = queue.popleft() level_values.append(node.value) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level_values) return result"},{"question":"# Remove Duplicates from a Linked List Given a singly linked list, your task is to write a function that removes duplicates from the list. There are two versions of the function you need to implement: one using extra memory (a hash set) and one without. Function Signature ```python def remove_dups(head: Node) -> None: pass def remove_dups_without_set(head: Node) -> None: pass ``` # Input - **head**: The head node of the singly linked list. The node has the following structure: ```python class Node: def __init__(self, val=None): self.val = val self.next = None ``` # Output - Both functions should modify the linked list in place and do not return anything. # Constraints - The number of nodes in the linked list is in the range [0, 10^5]. - Node values are not `None`. - The node values can be strings or integers and are not sorted. # Performance Requirements - For `remove_dups`, aim for a time complexity of O(N) and space complexity of O(N). - For `remove_dups_without_set`, aim for a time complexity of O(N^2) and space complexity of O(1). # Examples 1. **Example 1**: - **Input**: ``` head = (1 -> 2 -> 3 -> 2 -> 4) ``` - **Output** subsequent to running `remove_dups(head)`: ``` (1 -> 2 -> 3 -> 4) ``` 2. **Example 2**: - **Input**: ``` head = (5 -> 5 -> 5 -> 5) ``` - **Output** subsequent to running `remove_dups_without_set(head)`: ``` (5) ``` # Implementation Start by implementing a helper function to print the linked list for debugging purposes if needed. Then, focus on the `remove_dups` function, leveraging a hash set to track seen values. Finally, implement `remove_dups_without_set` using the nested traversal approach.","solution":"class Node: def __init__(self, val=None): self.val = val self.next = None def remove_dups(head: Node) -> None: Removes duplicates from a linked list using a hash set. :param head: The head of the singly linked list if head is None: return current = head seen = set() seen.add(current.val) while current.next is not None: if current.next.val in seen: current.next = current.next.next else: seen.add(current.next.val) current = current.next def remove_dups_without_set(head: Node) -> None: Removes duplicates from a linked list without extra memory (hash set). :param head: The head of the singly linked list if head is None: return current = head while current is not None: runner = current while runner.next is not None: if runner.next.val == current.val: runner.next = runner.next.next else: runner = runner.next current = current.next # Helper function to convert list to linked list def list_to_linked_list(values): if not values: return None head = Node(values[0]) current = head for val in values[1:]: current.next = Node(val) current = current.next return head # Helper function to convert linked list to list def linked_list_to_list(head): values = [] current = head while current: values.append(current.val) current = current.next return values"},{"question":"# Verify Sorted Linked List **Scenario:** You are given a singly linked list containing integer values. Your task is to determine if the list is sorted in increasing order. **Function Signature:** ```python def is_sorted(head: ListNode) -> bool: ``` **Inputs:** - `head`: The head node of a singly linked list. Each node contains an integer value (`val`) and a pointer to the next node (`next`). **Outputs:** - Returns `True` if the list is sorted in non-decreasing (increasing) order, else returns `False`. **Constraints:** - The number of nodes in the linked list can range from 0 to 10^5. - The values of nodes are integers within the range `[-10^9, 10^9]`. **Performance Requirements:** - The solution should operate within O(n) time complexity and O(1) space complexity. # Examples: 1. **Input:** `head = None` **Output:** `True` **Explanation:** An empty list is trivially sorted. 2. **Input:** `head = ListNode(1, ListNode(2, ListNode(3, ListNode(4))))` **Output:** `True` **Explanation:** The list `1 -> 2 -> 3 -> 4` is sorted in increasing order. 3. **Input:** `head = ListNode(1, ListNode(2, ListNode(-1, ListNode(3))))` **Output:** `False` **Explanation:** The list `1 -> 2 -> -1 -> 3` is not sorted because `2 > -1`. 4. **Input:** `head = ListNode(5, ListNode(5, ListNode(5, ListNode(5))))` **Output:** `True` **Explanation:** The list `5 -> 5 -> 5 -> 5` is non-decreasing and thus sorted. **Instructions:** - Implement the function `is_sorted(head: ListNode) -> bool` with the required functionality. - Ensure to test your implementation with edge cases such as empty lists, single-element lists, and fully equal element lists.","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def is_sorted(head: ListNode) -> bool: if not head or not head.next: return True current = head while current.next: if current.val > current.next.val: return False current = current.next return True"},{"question":"# BST Iterator Implementation: Coding Challenge # Scenario You are provided with a `BSTIterator` class that simulates in-order iteration over a Binary Search Tree (BST). The class uses a stack-based iterative approach to traverse the tree lazily. Your task is to complete the implementation of this iterator. Function to Implement Implement a function that returns a list of values of BST nodes in ascending order using the `BSTIterator` class as described below. ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BSTIterator: def __init__(self, root: Optional[TreeNode]): Initializes an iterator object for the given BST root. self.stack = [] while root: self.stack.append(root) root = root.left def has_next(self) -> bool: Returns true if there is a next element in the iterator. return bool(self.stack) def next(self) -> int: Returns the next element in the iterator. node = self.stack.pop() tmp = node if tmp.right: tmp = tmp.right while tmp: self.stack.append(tmp) tmp = tmp.left return node.val ``` Task **Implement the function:** ```python def inorder_bst_traversal(root: Optional[TreeNode]) -> List[int]: Given the root of a binary search tree, return its elements in increasing order. ``` Input: * `root`: Root of the BST (type `TreeNode`). Output: * A list of integers representing the in-order traversal of BST. Constraints: * The number of nodes in the tree is in the range [0, 1000]. * -10^6 <= Node value <= 10^6 Example: ```python # Example input root = TreeNode(7, TreeNode(3), TreeNode(15, TreeNode(9), TreeNode(20))) # Calling the function result = inorder_bst_traversal(root) # Expected output print(result) # Output: [3, 7, 9, 15, 20] ``` Ensure that your implementation handles all the edge cases and performs efficiently.","solution":"from typing import Optional, List class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BSTIterator: def __init__(self, root: Optional[TreeNode]): Initializes an iterator object for the given BST root. self.stack = [] while root: self.stack.append(root) root = root.left def has_next(self) -> bool: Returns true if there is a next element in the iterator. return bool(self.stack) def next(self) -> int: Returns the next element in the iterator. node = self.stack.pop() tmp = node if tmp.right: tmp = tmp.right while tmp: self.stack.append(tmp) tmp = tmp.left return node.val def inorder_bst_traversal(root: Optional[TreeNode]) -> List[int]: Given the root of a binary search tree, return its elements in increasing order. result = [] iterator = BSTIterator(root) while iterator.has_next(): result.append(iterator.next()) return result"},{"question":"Jump Search is an algorithm designed to find an element in a sorted array. Given the algorithm\'s approach as described in the analysis, write a function to implement it. Your task is to enhance the Jump Search algorithm so that it handles edge cases robustly and efficiently. # Function Signature ```python def jump_search(arr: List[int], target: int) -> int: ``` # Input * `arr` (List[int]): A list of integers sorted in ascending order. * `target` (int): The integer value to search for in the array. # Output * `int`: The index of the target value if found; otherwise, return -1. # Constraints * The input list can have up to `10^6` elements. * Elements in the list are sorted. * The target value is an integer within typical integer range. # Requirements - Ensure that your function handles edge cases, such as: - An empty array. - An array where all elements are identical. - An array where the target element appears multiple times (return the first occurrence). - Optimize for both time and space complexity. # Example ```python arr = [1, 3, 5, 7, 9, 11] target = 7 assert jump_search(arr, target) == 3 arr = [10, 20, 30, 40, 50] target = 25 assert jump_search(arr, target) == -1 ``` # Additional Scenarios 1. Search element in an empty array. 2. Search the smallest and largest elements in a large dataset. 3. Evaluate performance on a large array where the target does not exist.","solution":"import math from typing import List def jump_search(arr: List[int], target: int) -> int: n = len(arr) if n == 0: return -1 step = int(math.sqrt(n)) prev = 0 while arr[min(step, n)-1] < target: prev = step step += int(math.sqrt(n)) if prev >= n: return -1 for i in range(prev, min(step, n)): if arr[i] == target: return i return -1"},{"question":"Minimal Bit Flips to Convert Integers # Objective You are given two integers, A and B, and you need to determine the minimal number of bit flips required to convert integer A to integer B. # Problem Description Write a function `count_flips_to_convert(a: int, b: int) -> int` that takes two integers, `a` and `b`, as input and returns the minimum number of bits that need to be flipped to convert `a` to `b`. # Input - Two integers `a` and `b`, where: - `0 <= a, b <= 10^9`. # Output - An integer representing the minimal number of bit flips required. # Constraints - You need to consider the efficiency of your function. Ideally, it should run in linear time relative to the number of bits in the larger of the two integers. - The function should use a constant amount of extra space. # Detailed Explanation The steps to solve the problem: 1. Use the XOR operation to find differing bits between `a` and `b`. 2. Count the number of differing bits by counting the number of `1s` in the result of the XOR operation. # Example Test Cases Test Case 1: - Input: `a = 29` (`11101`), `b = 15` (`01111`) - Output: `2` - Explanation: The differing bits are at positions 3 and 4. Test Case 2: - Input: `a = 1`, `b = 2` - Output: `2` - Explanation: `1` (0001) and `2` (0010), differing bits are at positions 1 and 2. Test Case 3: - Input: `a = 1023`, `b = 255` - Output: 2 - Explanation: Binary of 1023 is `1111111111` and binary of 255 is `0111111111`, differing bits are at the highest bit. # Implementation Template ```python def count_flips_to_convert(a, b): diff = a ^ b # count number of ones in diff count = 0 while diff: diff &= (diff - 1) count += 1 return count ``` # Explanation of the Implementation - **XOR Operation**: `diff = a ^ b` computes the differences in bits. - **Counting Set Bits**: `while diff` loop counts the number of ones in the binary representation of `diff`. Implement the function as per the provided template and ensure you handle edge cases effectively.","solution":"def count_flips_to_convert(a, b): Returns the minimum number of bit flips required to convert integer a to integer b. diff = a ^ b count = 0 while diff: diff &= (diff - 1) count += 1 return count"},{"question":"# Digital Sequence Extraction Problem You are tasked to implement an algorithm that finds the `n`th digit in an infinitely concatenated sequence of positive integers starting from 1. This sequence looks like: 1234567891011121314... **Function Signature**: ```python def find_nth_digit(n: int) -> int: Given \'n\', return the nth digit in the continuously concatenated sequence of numbers starting from 1. Parameters: n (int): The position of the digit required in the concatenated sequence. Returns: int: The digit at the nth position. ``` **Input**: * An integer, `n` (1 ≤ n ≤ 10^9). **Output**: * An integer representing the `n`th digit in the sequence. **Constraints**: * Handle up to 1 billion (10^9) digit look-ups efficiently. * Implementations should ensure integer arithmetic precision, particularly when dealing with divisions. **Examples**: 1. `find_nth_digit(3)` should return `3` (The sequence is \\"123\\"). 2. `find_nth_digit(11)` should return `0` (The sequence is \\"12345678910\\"). **Performance**: The solution should strive for O(log n) time complexity to adapt for very large values of `n`. **Edge Cases to Consider**: * Positions at the transitions (e.g., 9 to 10, 99 to 100). * Large values close to the upper limit of `n`.","solution":"def find_nth_digit(n: int) -> int: Given \'n\', return the nth digit in the continuously concatenated sequence of numbers starting from 1. Parameters: n (int): The position of the digit required in the concatenated sequence. Returns: int: The digit at the nth position. # Initialize variables to track the range of digits length = 1 # Initial length of digits we are considering (1 for digits 1-9, 2 for 10-99, etc.) count = 9 # Number of numbers in the current \'length\' range (e.g. 9 single-digit numbers) start = 1 # Starting number of current range # Find the range where the nth digit falls into while n > length * count: n -= length * count length += 1 count *= 10 start *= 10 # Identify the exact number in the sequence that contains the nth digit num = start + (n - 1) // length # Convert number to string and find the precise digit needed digit = str(num)[(n - 1) % length] return int(digit)"},{"question":"Scenario Given two binary trees, determine if one is a subtree of the other. A subtree of a binary tree `t` is a tree consisting of a node in `t` and all of that node\'s descendants. The subtree should replicate the structure and node values of the target subtree exactly. Task Implement a function `is_subtree` that takes in two binary trees `big` and `small` and returns `True` if `small` is a subtree of `big` and `False` otherwise. Input and Output * **Input**: * `big`: The root node of the larger binary tree. * `small`: The root node of the smaller binary tree. * **Output**: * A boolean value `True` if `small` is a subtree of `big` and `False` otherwise. Constraints * The number of nodes in `big` is at most 10^4. * The number of nodes in `small` is at most 10^4. * Both `big` and `small` trees will only contain integer values. # Example ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right # Example 1: # Input: big = [3,4,5,1,2], small = [4,1,2] # Representation: # big: # 3 # / # 4 5 # / # 1 2 # # small: # 4 # / # 1 2 # Output: True # Example 2: # Input: big = [3,4,5,1,2,null,null,null,null,0], small = [4,1,2] # Representation: # big: # 3 # / # 4 5 # / # 1 2 # / # 0 # # small: # 4 # / # 1 2 # Output: False ``` Implementation ```python def is_subtree(big, small): # Define a helper function to compare two trees def comp(p, q): if p is None and q is None: return True if p is not None and q is not None: return p.val == q.val and comp(p.left, q.left) and comp(p.right, q.right) return False if not small: return True if not big: return False # Use a queue to perform BFS on the larger tree import collections queue = collections.deque([big]) while queue: node = queue.popleft() if node and node.val == small.val and comp(node, small): return True if node: queue.append(node.left) queue.append(node.right) return False ```","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_subtree(big, small): Determine if small is a subtree of big. def comp(p, q): if p is None and q is None: return True if p is not None and q is not None: return p.val == q.val and comp(p.left, q.left) and comp(p.right, q.right) return False if not small: return True if not big: return False import collections queue = collections.deque([big]) while queue: node = queue.popleft() if node and node.val == small.val and comp(node, small): return True if node: queue.append(node.left) queue.append(node.right) return False"},{"question":"Dynamic Programming Combinations You are given an integer array of unique positive numbers and a target integer `target`. Your task is to write a function that computes the number of possible combinations that add up exactly to `target`. Implement both a top-down and a bottom-up dynamic programming approach in Python. # Function Signature ```python def combination_sum_topdown(nums: List[int], target: int) -> int: pass def combination_sum_bottom_up(nums: List[int], target: int) -> int: pass ``` # Input * `nums`: a list of unique positive integers [1, 2, ..., n] * `target`: a positive integer # Output * An integer representing the number of unique combinations that add up to `target`. # Constraints * 1 ≤ len(nums) ≤ 200 * 1 ≤ nums[i] ≤ 1000 * 1 ≤ target ≤ 1000 # Examples ```python nums = [1, 2, 3] target = 4 combination_sum_topdown(nums, target) >>> 7 combination_sum_bottom_up(nums, target) >>> 7 ``` # Follow-Up 1. If negative numbers are allowed in the given array, how does it change the problem? * Introduction of negative numbers can lead to infinite loops in recursive algorithms without proper constraints. 2. What limitations need to be added to allow negative numbers? * Constraints on the maximum number of times a negative number can be used. * Limitations on the size of combinations to avoid infinite solutions. # Notes * Your implementation should correctly handle different sequences. * Optimize for both time and space where possible. * Ensure edge cases are handled carefully, such as empty array input and target of zero.","solution":"from typing import List def combination_sum_topdown(nums: List[int], target: int) -> int: memo = {} def dp(rem): if rem == 0: return 1 if rem in memo: return memo[rem] count = 0 for num in nums: if rem - num >= 0: count += dp(rem - num) memo[rem] = count return count return dp(target) def combination_sum_bottom_up(nums: List[int], target: int) -> int: dp = [0] * (target + 1) dp[0] = 1 for i in range(1, target + 1): for num in nums: if i - num >= 0: dp[i] += dp[i - num] return dp[target]"},{"question":"# Cosine Similarity Implementation **Objective**: Implement a function to calculate the cosine similarity between two one-dimensional lists of numerical data. **Function Signature**: ```python def cosine_similarity(vec1: List[float], vec2: List[float]) -> float: ``` **Input**: * `vec1`: A list of floats, representing the first vector. * `vec2`: A list of floats, representing the second vector. **Output**: * Returns a float value representing the cosine similarity between the two vectors. **Constraints**: * Both input lists will have the same length. * Input lists\' length will be between 1 and 10^5. * Elements of input lists will be real numbers. **Example**: ```python cosine_similarity([1, 1, 1], [1, 2, -1]) # output : 0.47140452079103173 ``` **Scenario**: You are working on a recommendation system that compares user interest profiles. Each profile is represented as a vector indicating strengths of interest in various categories. To compare user profiles, use cosine similarity to ascertain their similarity and suggest connections or content recommendations accordingly. Make sure to handle edge cases such as divisions by zero carefully. **Note**: Implement the helper function `_l2_distance(vec: List[float]) -> float` to calculate the L2 norm of a vector, and use it inside your `cosine_similarity` function.","solution":"from typing import List import math def _l2_distance(vec: List[float]) -> float: Helper function to calculate the L2 norm (Euclidean norm) of a vector. return math.sqrt(sum(x ** 2 for x in vec)) def cosine_similarity(vec1: List[float], vec2: List[float]) -> float: Calculate the cosine similarity between two vectors. numerator = sum(a * b for a, b in zip(vec1, vec2)) denominator = _l2_distance(vec1) * _l2_distance(vec2) if denominator == 0: return 0.0 return numerator / denominator"},{"question":"# Introduction You are tasked with implementing a word dictionary that supports adding words and searching for words where the search query can include dots (\\".\\") as wildcards representing any letter. # Problem Statement Implement a class `WordDictionary` using the Trie data structure which supports the following operations: - **add_word(word: str) -> None**: Adds a word to the dictionary. - **search(word: str) -> bool**: Returns true if the word (or pattern) exists in the dictionary. A word pattern may contain dots (\\".\\") where each dot can match any letter. # Function Signature ```python class WordDictionary: def __init__(self): # Initialize the WordDictionary pass def add_word(self, word: str) -> None: Adds a word to the dictionary. :param word: String representing the word to add. pass def search(self, word: str) -> bool: Searches for a word or pattern in the dictionary. :param word: String representing the word or pattern to search. :return: True if the word or pattern is found, otherwise False. pass ``` # Constraints 1. All words are lowercase English letters. 2. The word dictionary must handle up to `10^6` operations. # Example ```python wd = WordDictionary() wd.add_word(\\"bad\\") wd.add_word(\\"dad\\") wd.add_word(\\"mad\\") print(wd.search(\\"pad\\")) # Output: False print(wd.search(\\"bad\\")) # Output: True print(wd.search(\\".ad\\")) # Output: True print(wd.search(\\"b..\\")) # Output: True ``` # Explanation - Words \\"bad\\", \\"dad\\", \\"mad\\" were added to the dictionary. - The search for \\"pad\\" returns False as it was not added. - The search for \\"bad\\" returns True as it matches an added word. - The search for \\".ad\\" returns True as it matches \\"bad\\", \\"dad\\", or \\"mad\\". - The search for \\"b..\\" returns True as it matches \\"bad\\" or any other 3-letter word starting with \'b\'. # Notes - Avoid using library-specific features that simplify the problem. - Focus on optimizing both time and space complexity. - Handle edge cases such as searching with multiple wildcards efficiently.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class WordDictionary: def __init__(self): self.root = TrieNode() def add_word(self, word: str) -> None: node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, word: str) -> bool: return self._search_in_node(word, self.root) def _search_in_node(self, word: str, node: TrieNode) -> bool: for i, char in enumerate(word): if char == \'.\': for child in node.children.values(): if self._search_in_node(word[i + 1:], child): return True return False else: if char not in node.children: return False node = node.children[char] return node.is_end_of_word"},{"question":"# Question: Non-recursive Postorder Traversal of a Binary Tree **Context:** Postorder traversal of a binary tree is a type of depth-first traversal where the nodes are recursively visited in the order of left subtree, right subtree, and then root node. In this problem, you need to write a non-recursive (iterative) version of a postorder traversal algorithm. **Task:** Implement a non-recursive function `postorder_iterative` that performs postorder traversal on a binary tree. You are provided with a `Node` class representing the nodes of the binary tree. # Function Signature: ```python def postorder_iterative(root: \'Node\') -> List[int]: pass ``` # Input: * `root` (Node): The root node of the binary tree. # Output: * `List[int]` : A list containing the values of the nodes as per postorder traversal. # Constraints: * Assume the binary tree does not contain any cycles. * Each node\'s value is unique. * The number of nodes in the tree can range from 0 to 10^4. # Example: ```python class Node: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right # Example Tree: # 1 # / # 2 3 # / # 4 5 n1 = Node(1) n2 = Node(2) n3 = Node(3) n4 = Node(4) n5 = Node(5) n1.left, n1.right = n2, n3 n2.left, n2.right = n4, n5 assert postorder_iterative(n1) == [4, 5, 2, 3, 1] ``` # Notes: - You should not use recursion in your implementation. - Aim to achieve O(n) time complexity and O(h) space complexity, where h is the height of the tree.","solution":"class Node: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def postorder_iterative(root: Node) -> list[int]: Perform a non-recursive postorder traversal of a binary tree. :param root: Root node of the binary tree. :return: List of node values in postorder. if root is None: return [] stack = [] output = [] current = root while stack or current: if current: stack.append(current) output.append(current.val) # Note: Add the node value to output here current = current.right # Move to right child (reverse the postorder logic) else: node = stack.pop() current = node.left # After right subtree, move to left subtree return output[::-1] # Reverse the process to fit postorder traversal"},{"question":"Problem Implement four functions to compute the `n`-th Fibonacci number using different methods: recursive without memoization, dynamic programming with a list, iteration, and recursive with memoization. # Requirements 1. **Recursive Approach without Memoization**: - Function signature: `def fib_recursive(n: int) -> int` - Time Complexity: O(2^n) - Space Complexity: O(n) 2. **Dynamic Programming with a List**: - Function signature: `def fib_list(n: int) -> int` - Time Complexity: O(n) - Space Complexity: O(n) 3. **Iterative Approach**: - Function signature: `def fib_iter(n: int) -> int` - Time Complexity: O(n) - Space Complexity: O(1) 4. **Recursive Approach with Memoization**: - Function signature: `def fib_memo(n: int) -> int` - Time Complexity: O(n) - Space Complexity: O(n) # Example: ```python n = 10 print(fib_recursive(n)) # Output: 55 print(fib_list(n)) # Output: 55 print(fib_iter(n)) # Output: 55 print(fib_memo(n)) # Output: 55 ``` # Constraints: - Inputs `n` will be a non-negative integer and `n <= 100`. - Each function should handle edge cases appropriately. - The recursive approach without memoization and the dynamic programming approach should have assertions to check that `n` is a non-negative integer. # Performance Requirements: - The recursive approach with memoization and the iterative approach should handle `n = 100` efficiently. - The dynamic programming approach should manage up to `n = 100` without running out of memory. Consider efficiency and readability in your implementation.","solution":"def fib_recursive(n: int) -> int: Compute the n-th Fibonacci number recursively without memoization. assert isinstance(n, int), \\"n must be a non-negative integer\\" assert n >= 0, \\"n must be a non-negative integer\\" if n == 0: return 0 elif n == 1: return 1 else: return fib_recursive(n-1) + fib_recursive(n-2) def fib_list(n: int) -> int: Compute the n-th Fibonacci number using dynamic programming with a list. assert isinstance(n, int), \\"n must be a non-negative integer\\" assert n >= 0, \\"n must be a non-negative integer\\" if n == 0: return 0 fibs = [0, 1] for i in range(2, n + 1): fibs.append(fibs[i-1] + fibs[i-2]) return fibs[n] def fib_iter(n: int) -> int: Compute the n-th Fibonacci number iteratively. if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b def fib_memo(n: int, memo: dict = None) -> int: Compute the n-th Fibonacci number recursively with memoization. if memo is None: memo = {} if n in memo: return memo[n] if n == 0: return 0 elif n == 1: return 1 memo[n] = fib_memo(n-1, memo) + fib_memo(n-2, memo) return memo[n]"},{"question":"# Decoding Nested Strings Using Stack Objective Implement a function `decode_string` that decodes a given encoded string according to the specified encoding rule. The encoded string uses the format `k[encoded_string]`, where `k` is a positive integer representing the number of times the `encoded_string` should be repeated. # Problem Statement You are given a string `s` consisting of lowercase English letters, digits, and square brackets. The string conforms to the following encoding rule: - `k[encoded_string]` where `k` is a positive integer and `encoded_string` can be another encoded string nested within. Your task is to write a function that decodes this string and returns the decoded version. # Function Signature ```python def decode_string(s: str) -> str: Decodes the given encoded string. :param s: Encoded string (str) :return: Decoded string (str) ``` # Input - `s` (string): The encoded string, which contains only digits, lowercase English letters, square brackets, and follows the rule `k[encoded_string]`. # Output - Returns a decoded string following the described encoding rules. # Constraints - 1 <= `len(s)` <= 30. - The input string is guaranteed to be valid and follows the encoding rules. # Example Example 1 ```python s = \\"3[a]2[bc]\\" print(decode_string(s)) # Output: \\"aaabcbc\\" ``` Example 2 ```python s = \\"3[a2[c]]\\" print(decode_string(s)) # Output: \\"accaccacc\\" ``` Example 3 ```python s = \\"2[abc]3[cd]ef\\" print(decode_string(s)) # Output: \\"abcabccdcdcdef\\" ``` # Description 1. Parse through the string `s` character by character. 2. Use a stack data structure to manage nested encoded strings. 3. When a digit is encountered, determine the repeat count. 4. On encountering `[`, push the current context (current string and repeat count) onto the stack. 5. On encountering `]`, pop from the stack, reconstruct the current context, and apply the repeat operation. 6. Regular alphabetic characters are appended directly to the current working string. 7. Return the final decoded string after processing all characters in `s`. # Hints - The use of a stack is crucial to manage nested structures efficiently. - Keep track of current working string and the repeat count separately.","solution":"def decode_string(s: str) -> str: stack = [] current_string = \'\' current_num = 0 for char in s: if char.isdigit(): current_num = current_num * 10 + int(char) elif char == \'[\': stack.append((current_string, current_num)) current_string = \'\' current_num = 0 elif char == \']\': last_string, num = stack.pop() current_string = last_string + num * current_string else: current_string += char return current_string"},{"question":"# Question: You are provided with the definitions of two data structures: `Monomial` and `Polynomial`. These structures represent algebraic monomials and polynomials, respectively. The core functionalities provided include addition, subtraction, multiplication, division, and variable substitution. Using these classes, you are tasked with implementing a new method named `simplify` for the `Polynomial` class and a new method named `power` in the `Monomial` class. Method 1: `Polynomial.simplify()` The `simplify` method should reduce the polynomial by: - Merging like terms (those sharing the same variables). - Removing any monomials with a zero coefficient. Method 2: `Monomial.power(n: int)` The `power` method should compute the monomial raised to a given integer power \'n\'. For instance, raising `(2a^2b^3)` to power 2 should result in `(4a^4b^6)`. **Function Signatures**: ```python class Polynomial: ... def simplify(self) -> Polynomial: ... class Monomial: ... def power(self, n: int) -> Monomial: ... ``` Requirements: - **Input/Output Formats**: - For `Polynomial.simplify()`: - **Input**: None. - **Output**: A new Polynomial object representing the simplified polynomial. - For `Monomial.power(n)`: - **Input**: An integer `n`. - **Output**: A new Monomial object representing the monomial raised to the nth power. - **Constraints**: - `Polynomial.simplify()`: - Ensure monomials in the polynomial are combined correctly. - `Monomial.power(n)`: - `n` can be any integer, including zero and negative values. - **Performance**: - Efficiently handle polynomials with a large number of monomials and variables. - Ensure that operations are correctly optimized for minimal computational overhead. Example Usage: ```python # Example for Monomial.power m1 = Monomial({1:2, 2:3}, 2) # Represents 2(a_1)^2(a_2)^3 m1_powered = m1.power(2) print(m1_powered) # Should output (4(a_1)^4(a_2)^6) # Example for Polynomial.simplify p1 = Polynomial([ Monomial({1:1}, 2), Monomial({1:1}, -2), Monomial({2:3, 1:1}, 1) ]) # Represents 2(a_1) - 2(a_1) + (a_1)(a_2)^3 p1_simplified = p1.simplify() print(p1_simplified) # Should output (a_1)(a_2)^3 ``` **Note**: Ensure that your implementation maintains the existing methods and behaviors of the provided classes.","solution":"class Monomial: def __init__(self, degrees, coefficient): self.degrees = degrees # e.g., {1: 2, 2: 3} means a_1^2 * a_2^3 self.coefficient = coefficient # e.g., 2 in 2(a_1)^2(a_2)^3 def power(self, n: int): new_degrees = {var: exp * n for var, exp in self.degrees.items()} new_coefficient = self.coefficient ** n return Monomial(new_degrees, new_coefficient) class Polynomial: def __init__(self, monomials): self.monomials = monomials # List of Monomial objects def simplify(self): simplified_monomials = {} for mon in self.monomials: key = tuple(sorted(mon.degrees.items())) if key in simplified_monomials: simplified_monomials[key].coefficient += mon.coefficient else: simplified_monomials[key] = Monomial(mon.degrees, mon.coefficient) # Filter out monomials with a zero coefficient simplified_monomials = [mon for mon in simplified_monomials.values() if mon.coefficient != 0] return Polynomial(simplified_monomials)"},{"question":"Context You have been hired as a data scientist to improve a basic recommendation system. This system uses the nearest neighbor algorithm to identify the closest items based on feature vectors. Your task is to enhance the `nearest_neighbor` function to handle different distance metrics and improve its efficiency using KD-Tree for neighborhoods. Problem Statement Implement an enhanced nearest neighbor function that supports multiple distance metrics (Euclidean, Manhattan, and Cosine distance) and leverages a KD-Tree for efficient searching. You are provided with a basic implementation using Euclidean distance, and you need to extend it according to the requirements. Function Signature ```python from typing import Tuple, Dict, Union, List def enhanced_nearest_neighbor(x: Tuple[float], tSet: Dict[Tuple[float], str], metric: str = \'euclidean\') -> str: Find the nearest neighbor using a specified distance metric enhanced with KD-Tree structure. Arguments: x : Tuple[float] -- The test vector. tSet : Dict[Tuple[float], str] -- The training set as a dictionary of vector to label pairs. metric : str -- The distance metric to be used (\'euclidean\', \'manhattan\', \'cosine\'). Returns: str -- The label of the nearest neighbor. pass ``` Distance Metrics * **Euclidean Distance**: ( sqrt{sum (x_i - y_i)^2} ) * **Manhattan Distance**: ( sum |x_i - y_i| ) * **Cosine Distance**: ( 1 - frac{x cdot y}{||x|| times ||y||} ) Input Constraints * `x` and keys of `tSet` are tuples of floats of the same length (1 <= length <= 100). * Values of `tSet` are strings representing labels. * `tSet` contains at least one vector-label pair. * `metric` is one of \'euclidean\', \'manhattan\', \'cosine\'. Output * A string label of the nearest neighbor found in the training set. Examples ```python # Example 1 x = (1.0, 2.0) tSet = {(1.0, 3.0): \\"A\\", (4.0, 2.0): \\"B\\"} metric = \\"euclidean\\" print(enhanced_nearest_neighbor(x, tSet, metric)) # should return \\"A\\" # Example 2 x = (1.0, 2.0) tSet = {(1.0, 3.0): \\"A\\", (4.0, 2.0): \\"B\\"} metric = \\"manhattan\\" print(enhanced_nearest_neighbor(x, tSet, metric)) # should return \\"A\\" # Example 3 x = (1.0, 0.0) tSet = {(1.0, 1.0): \\"A\\", (0.0, 1.0): \\"B\\"} metric = \\"cosine\\" print(enhanced_nearest_neighbor(x, tSet, metric)) # should return \\"A\\" ``` You are required to: 1. Implement the `distance` function supporting the specified metrics. 2. Implement the KD-Tree structure for efficient nearest neighbor search. 3. Ensure the nearest neighbor computation uses the specified metric for distance calculation. Consider edge cases such as empty training set (which won’t happen here due to constraints), different vector lengths (assertion needed), and non-supported metrics.","solution":"import numpy as np from scipy.spatial import KDTree from typing import Tuple, Dict, Union, List def euclidean_distance(a, b): return np.sqrt(np.sum((np.array(a) - np.array(b))**2)) def manhattan_distance(a, b): return np.sum(np.abs(np.array(a) - np.array(b))) def cosine_distance(a, b): a, b = np.array(a), np.array(b) return 1 - np.dot(a, b) / (np.linalg.norm(a) * np.linalg.norm(b)) def enhanced_nearest_neighbor(x: Tuple[float], tSet: Dict[Tuple[float], str], metric: str = \'euclidean\') -> str: Find the nearest neighbor using a specified distance metric enhanced with KD-Tree structure. Arguments: x : Tuple[float] -- The test vector. tSet : Dict[Tuple[float], str] -- The training set as a dictionary of vector to label pairs. metric : str -- The distance metric to be used (\'euclidean\', \'manhattan\', \'cosine\'). Returns: str -- The label of the nearest neighbor. if metric not in [\'euclidean\', \'manhattan\', \'cosine\']: raise ValueError(\\"Unsupported metric\\") # Prepare training data and labels samples = list(tSet.keys()) labels = list(tSet.values()) kdtree = KDTree(samples) # Find the nearest neighbor using the KD-Tree (with Euclidean distance easiest to adapt) _, idx = kdtree.query(x) nearest_sample = samples[idx] if metric == \'euclidean\': dist_func = euclidean_distance elif metric == \'manhattan\': dist_func = manhattan_distance elif metric == \'cosine\': dist_func = cosine_distance nearest_label = labels[idx] nearest_distance = dist_func(x, nearest_sample) for i, sample in enumerate(samples): if i == idx: continue distance = dist_func(x, sample) if distance < nearest_distance: nearest_distance = distance nearest_label = labels[i] return nearest_label"},{"question":"**Title**: Find the Missing Side of a Right-Angled Triangle Problem Statement You are given the lengths of two sides of a right-angled triangle. However, one of these side lengths is unknown and is represented by the symbol \\"?\\". Write a function `find_triangle_side(opposite, adjacent, hypotenuse)` which calculates and returns the length of the missing side. The function should handle the following input cases: - The unknown side could be the opposite side, the adjacent side, or the hypotenuse. - Only one side will be represented as \\"?\\", and the other two will be positive numeric values. - If the input values do not form a valid right-angled triangle, the function should raise a `ValueError`. Input - `opposite` (string or number): The length of the opposite side or \\"?\\" if unknown. - `adjacent` (string or number): The length of the adjacent side or \\"?\\" if unknown. - `hypotenuse` (string or number): The length of the hypotenuse or \\"?\\" if unknown. Output - Returns a string indicating the calculated length of the missing side in one of the following formats: - \\"Opposite = [length]\\" - \\"Adjacent = [length]\\" - \\"Hypotenuse = [length]\\" Function Signature ```python def find_triangle_side(opposite, adjacent, hypotenuse): pass ``` Constraints - Only one side will be marked as unknown (\\"?\\"). - The provided lengths must be positive numbers. - If the provided values do not form a valid right-angled triangle, the function should raise a `ValueError` with the message \\"Invalid triangle dimensions\\". Example ```python # Example 1 # opposite = 3, adjacent = 4, hypotenuse = \\"?\\" # Result: \\"Hypotenuse = 5.0\\" assert find_triangle_side(3, 4, \\"?\\") == \\"Hypotenuse = 5.0\\" # Example 2 # opposite = \\"?\\", adjacent = 4, hypotenuse = 5 # Result: \\"Opposite = 3.0\\" assert find_triangle_side(\\"?\\", 4, 5) == \\"Opposite = 3.0\\" # Example 3 # opposite = 3, adjacent = \\"?\\", hypotenuse = 5 # Result: \\"Adjacent = 4.0\\" assert find_triangle_side(3, \\"?\\", 5) == \\"Adjacent = 4.0\\" ```","solution":"import math def find_triangle_side(opposite, adjacent, hypotenuse): Calculate the length of the missing side of a right-angled triangle. if opposite == \\"?\\": if isinstance(adjacent, (int, float)) and isinstance(hypotenuse, (int, float)) and adjacent < hypotenuse: opposite = math.sqrt(hypotenuse**2 - adjacent**2) return f\\"Opposite = {opposite:.1f}\\" elif adjacent == \\"?\\": if isinstance(opposite, (int, float)) and isinstance(hypotenuse, (int, float)) and opposite < hypotenuse: adjacent = math.sqrt(hypotenuse**2 - opposite**2) return f\\"Adjacent = {adjacent:.1f}\\" elif hypotenuse == \\"?\\": if isinstance(opposite, (int, float)) and isinstance(adjacent, (int, float)): hypotenuse = math.sqrt(opposite**2 + adjacent**2) return f\\"Hypotenuse = {hypotenuse:.1f}\\" raise ValueError(\\"Invalid triangle dimensions\\")"},{"question":"You are given a directed graph class with the ability to add edges and check if there is a path between two nodes using Depth First Search (DFS). However, the existing implementation has some issues and inefficiencies. Your task is to correctly implement the path detection algorithm using DFS iteratively to handle potential recursion depth issues on large graphs. # Instructions 1. **Implement an iterative DFS method** to determine if a path exists between two nodes (`source` and `target`). 2. Ensure that your method handles the following: * Graph containing cycles. * Disconnected graph where some nodes don’t have any paths to others. * Large graphs without running into stack overflow issues. 3. **Optimize for early exit** as soon as the target is found. # Function Signature: ```python def is_reachable(graph: Dict[int, List[int]], vertex_count: int, source: int, target: int) -> bool: ``` # Input: - `graph`: A dictionary where keys are nodes and values are lists of adjacent nodes (representing the directed edges). - `vertex_count`: An integer (`V`) representing the number of vertices in the graph. - `source`: An integer representing the starting node. - `target`: An integer representing the target node. # Output: - Return `True` if there is a path from `source` to `target`, otherwise return `False`. # Constraints: - The graph assumes nodes are 0-indexed. - 1 <= `vertex_count` <= 10000 - Edges are directed. # Example: ```python graph = { 0: [1, 2], 1: [2], 2: [0, 3], 3: [3] } vertex_count = 4 print(is_reachable(graph, vertex_count, 1, 3)) # Output: True print(is_reachable(graph, vertex_count, 3, 1)) # Output: False ``` # Tips: * Use an explicit stack if implementing the iterative version of DFS. * Ensure all nodes are visited and handle cases where nodes are isolated or disconnected.","solution":"def is_reachable(graph, vertex_count, source, target): Returns True if there is a path from source to target using an iterative DFS approach. if source == target: return True visited = [False] * vertex_count stack = [source] while stack: current = stack.pop() if not visited[current]: visited[current] = True for neighbor in graph.get(current, []): if neighbor == target: return True stack.append(neighbor) return False"},{"question":"# Problem: Find K Closest Points to the Origin **Scenario:** You are working on a location-based recommendation system where you need to find the nearest k places from a given user\'s current location (taken as origin). Utilizing more efficient algorithms is crucial due to the potentially large number of location points to evaluate. **Task:** Implement a function `k_closest(points, k, origin=(0, 0))` to find the k closest points to the origin from the list of points. **Detailed Requirements:** 1. **Function Signature**: `def k_closest(points, k, origin=(0, 0)):` 2. **Input**: - `points`: List of tuples, where each tuple is a point `(x, y)` representing a location in 2D space. - `k`: Integer, the number of closest points to find. - `origin`: Tuple `(x, y)`, the origin point from which distances are measured (default `(0, 0)`). 3. **Output**: - List of `k` tuples representing the closest points to the origin. 4. **Constraints**: - Points in the input list are distinct. - The number of points will be between 1 and 10^4. - `k` will be a positive integer and no greater than the number of points. **Example**: ```python # Example 1 points = [(1, 2), (1, 3), (3, 4), (6, 1), (2, 2)] k = 3 origin = (0, 0) assert k_closest(points, k, origin) == [(1, 2), (1, 3), (2, 2)] # Example 2 points = [(5, 8), (3, 4), (4, 3), (1, -2)] k = 2 origin = (0, 0) assert k_closest(points, k, origin) == [(1, -2), (3, 4)] ``` **Performance Requirements**: - The solution should run efficiently with a complexity optimized for time. - Consider edge cases such as `k` being equal to the number of points, or the points\' list containing one element. You may assume the input is always valid and no need for further validation of inputs is necessary.","solution":"import heapq import math def k_closest(points, k, origin=(0, 0)): Find k closest points to the origin. :param points: List of tuples representing the coordinates of the points. :param k: Number of closest points to find. :param origin: Tuple representing the origin point. :return: List of k closest points to the origin. def euclidean_distance(point, origin): return math.sqrt((point[0] - origin[0]) ** 2 + (point[1] - origin[1]) ** 2) # Use a max heap of size k to keep track of the k closest points max_heap = [] for point in points: distance = euclidean_distance(point, origin) if len(max_heap) < k: heapq.heappush(max_heap, (-distance, point)) else: heapq.heappushpop(max_heap, (-distance, point)) return [point for _, point in max_heap]"},{"question":"# Integer Partitioning Challenge Consider a positive integer `n`. Your task is to write a function `integer_partitions(n)` that returns the number of distinct ways in which `n` can be partitioned into sums of non-negative integers. An integer partition is a way of writing `n` as a sum of non-negative integers where the order of addends does not matter. Function Signature ```python def integer_partitions(n: int) -> int: ``` Input - `n` (1 ≤ n ≤ 1000): A positive integer `n` that needs to be partitioned. Output - An integer representing the number of ways to partition `n`. Constraints 1. Ensure your function works efficiently to handle the upper constraint. 2. The solution should be implemented using dynamic programming to ensure optimal performance. Example ```python assert integer_partitions(4) == 5 # Explanation: # 4 can be partitioned as follows: [4], [3,1], [2,2], [2,1,1], [1,1,1,1] assert integer_partitions(7) == 15 # Explanation: # 7 can be partitioned as follows: # [7], [6,1], [5,2], [5,1,1], [4,3], [4,2,1], [4,1,1,1], [3,3,1], [3,2,2], # [3,2,1,1], [3,1,1,1,1], [2,2,2,1], [2,2,1,1,1], [2,1,1,1,1,1], [1,1,1,1,1,1,1] ``` Write your solution to the function `integer_partitions` which follows the above requirements and works within the given constraints.","solution":"def integer_partitions(n: int) -> int: Returns the number of distinct ways in which `n` can be partitioned into sums of non-negative integers. # Initialize the memoization table dp = [[0 for _ in range(n+1)] for _ in range(n+1)] # There\'s exactly one way to partition 0 - using an empty set for i in range(n+1): dp[i][0] = 1 # Fill the dp table for i in range(1, n+1): for j in range(1, n+1): if j >= i: dp[i][j] = dp[i-1][j] + dp[i][j-i] else: dp[i][j] = dp[i-1][j] return dp[n][n]"},{"question":"# Question: Advanced Histogram Representation Given a list of integers `input_list`, implement a function `get_advanced_histogram(input_list: list) -> dict` that not only counts the occurrence of each integer but also provides additional information including: 1. `position`: A list of indices where the integer is found in the input list. 2. `proportion`: The proportion (frequency/length of input list) of each integer. **Function Signature**: ```python def get_advanced_histogram(input_list: list) -> dict: ... ``` # Input: - A list of integers, `input_list` (1 <= len(input_list) <= 10^5, -10^5 <= input_list[i] <= 10^5). # Output: - A dictionary where each key is a unique integer from `input_list` and the value is another dictionary containing: - `\\"frequency\\"`: The count of occurrences of that integer. - `\\"position\\"`: A list of indices indicating where this integer is found in the input list. - `\\"proportion\\"`: The proportion of this integer in the list. # Example: ```python input_list = [2, 3, 5, 5, 5, 6, 4, 3, 7] # Expected Output: # { # 2: {\'frequency\': 1, \'position\': [0], \'proportion\': 0.1111111111111111}, # 3: {\'frequency\': 2, \'position\': [1, 7], \'proportion\': 0.2222222222222222}, # 4: {\'frequency\': 1, \'position\': [6], \'proportion\': 0.1111111111111111}, # 5: {\'frequency\': 3, \'position\': [2, 3, 4], \'proportion\': 0.3333333333333333}, # 6: {\'frequency\': 1, \'position\': [5], \'proportion\': 0.1111111111111111}, # 7: {\'frequency\': 1, \'position\': [8], \'proportion\': 0.1111111111111111} # } input_list = [1, 1, 1, 1] # Expected Output: # { # 1: {\'frequency\': 4, \'position\': [0, 1, 2, 3], \'proportion\': 1.0} # } ``` **Constraints**: - The `input_list` will contain elements ranging from -10^5 to 10^5. - You should handle edge cases such as an empty list. **Hint**: You may consider using dictionaries to store intermediate states, such as frequencies and positions, while iterating through the list efficiently.","solution":"def get_advanced_histogram(input_list: list) -> dict: histogram = {} length = len(input_list) for idx, num in enumerate(input_list): if num not in histogram: histogram[num] = {\\"frequency\\": 0, \\"position\\": [], \\"proportion\\": 0.0} histogram[num][\\"frequency\\"] += 1 histogram[num][\\"position\\"].append(idx) for num in histogram: histogram[num][\\"proportion\\"] = histogram[num][\\"frequency\\"] / length return histogram"},{"question":"# Task Write a function, `level_order_k` that executes a level-order traversal on a binary tree but returns only the nodes at level \\"k\\" of the tree. # Function Signature ```python def level_order_k(root: TreeNode, k: int) -> List[int]: pass ``` # Input * `root`: The root of the binary tree, can be `None`. * `k`: An integer, where `0 <= k`. # Output * A list of integers representing node values at level `k`. * If the level `k` does not exist in the tree, return an empty list. # Constraints * The tree can have at most `10^4` nodes. # Example ```python # Definition for a binary tree node. class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right # Example Usage root = TreeNode(3) root.left = TreeNode(9) root.right = TreeNode(20) root.right.left = TreeNode(15) root.right.right = TreeNode(7) print(level_order_k(root, 0)) # Output: [3] print(level_order_k(root, 1)) # Output: [9, 20] print(level_order_k(root, 2)) # Output: [15, 7] print(level_order_k(root, 3)) # Output: [] ``` # Considerations * Ensure the function handles edge cases such as an empty tree or a very unbalanced tree. * Pay attention to the time and space complexity constraints to ensure the solution performs efficiently.","solution":"from typing import List, Optional # Definition for a binary tree node. class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_order_k(root: Optional[TreeNode], k: int) -> List[int]: Perform a level-order traversal and return the values at level k. :param root: Root of the binary tree. :param k: The level to retrieve values from. :return: List of values at level k. if not root: return [] queue = [(root, 0)] result = [] while queue: node, level = queue.pop(0) if level == k: result.append(node.val) if level > k: break if node.left: queue.append((node.left, level + 1)) if node.right: queue.append((node.right, level + 1)) return result"},{"question":"Clone an Undirected Graph Given an undirected graph represented by a reference node, write a function to clone the graph. Each node in the graph contains a unique label and a list of its neighbors. The graph has self-cycles and interconnected components. Input: - A reference node `node` of type `UndirectedGraphNode`. The node can possibly be `None`, indicating an empty graph. Output: - A reference node to the cloned graph. Constraints: - The number of nodes in the graph is in the range [0, 1000]. - Node values are represented as unique integers. Function Signature: ```python def clone_graph(node: \'UndirectedGraphNode\') -> \'UndirectedGraphNode\': ``` # Example: ```python Input: Graph serialization: {0,1,2#1,2#2,2} Visual representation: 1 / / 0 --- 2 / _/ Output: A new graph with exact structure as the input graph. ``` # Notes: - Implement the function using one of the traversal methods discussed: BFS, iterative DFS, or recursive DFS. - Ensure you handle all the edge cases such as empty graphs, self-cycles, and interconnected nodes. - Provide necessary helper functions if required (e.g., a DFS helper function). - Ensure your solution properly tracks visited nodes to avoid infinite loops. Good luck and happy coding!","solution":"class UndirectedGraphNode: def __init__(self, x): self.label = x self.neighbors = [] def clone_graph(node: \'UndirectedGraphNode\') -> \'UndirectedGraphNode\': if node is None: return None node_map = {} def dfs(old_node): if old_node in node_map: return node_map[old_node] # Clone the node new_node = UndirectedGraphNode(old_node.label) node_map[old_node] = new_node # Clone all the neighbors for neighbor in old_node.neighbors: new_node.neighbors.append(dfs(neighbor)) return new_node return dfs(node)"},{"question":"You are tasked with implementing a function to find the depth (or height) of a Binary Search Tree (BST). The depth of a tree is defined as the length of the longest path from the root node to a leaf node. # Input A binary search tree (BST) object. # Output An integer representing the depth of the BST. # Constraints 1. The input BST can contain up to 10^4 nodes. 2. Tree nodes contain integers within the range [-10^5, 10^5]. # Function Signature ```python def find_depth(bst: BST) -> int: ``` # Example ```python # Example of usage: bst = BST() bst.insert(10) bst.insert(5) bst.insert(2) bst.insert(1) bst.insert(3) bst.insert(7) bst.insert(6) bst.insert(8) bst.insert(15) bst.insert(12) bst.insert(20) depth = find_depth(bst) print(depth) # Output should be 4 class TestSuite: def __init__(self): pass def run_tests(self): bst = BST() bst.insert(10) bst.insert(15) bst.insert(6) bst.insert(4) bst.insert(9) bst.insert(12) bst.insert(24) bst.insert(7) bst.insert(20) bst.insert(30) bst.insert(18) assert find_depth(bst) == 4, \\"Test Case 1 Failed\\" bst = BST() assert find_depth(bst) == 0, \\"Test Case 2 Failed\\" bst.insert(1) assert find_depth(bst) == 1, \\"Test Case 3 Failed\\" print(\\"All test cases pass\\") if __name__ == \'__main__\': TestSuite().run_tests() ``` # Explanation 1. The `find_depth` function calculates the depth of the BST. 2. You can assume that the BST class and its methods (insert, search, etc.) are already implemented and correctly working. 3. The depth of a tree with only one node (i.e., the root node) is 1. # Notes - Consider the empty tree as having a depth of 0. - Apply recursive or iterative strategies to find depth, ensuring that you consider all paths from the root to leaf nodes.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BST: def __init__(self): self.root = None def insert(self, val): if not self.root: self.root = TreeNode(val) else: self._insert_recur(self.root, val) def _insert_recur(self, node, val): if val < node.val: if node.left is None: node.left = TreeNode(val) else: self._insert_recur(node.left, val) else: if node.right is None: node.right = TreeNode(val) else: self._insert_recur(node.right, val) def find_depth(bst: BST) -> int: def depth(node): if not node: return 0 left_depth = depth(node.left) right_depth = depth(node.right) return max(left_depth, right_depth) + 1 return depth(bst.root)"},{"question":"# Question: Implement an Improved Selection Sort Scenario The current selection sort algorithm is straightforward but not efficient for large datasets. Imagine you\'re developing software for sorting a small catalog of items and need an optimized version of selection sort that can stop early when the list is already sorted in any iteration. Task Implement a more efficient version of the `selection_sort` algorithm that stops the sorting process if the list is detected to be sorted after any full pass (i.e., if no swaps occur in a pass, the array is already sorted). Function Signature ```python def improved_selection_sort(arr, simulation=False): Sort the array using an optimized selection sort algorithm. Args: arr (list[int]): The list of integers to be sorted. simulation (bool): If True, prints the state of the list after each pass for visualization. Returns: list[int]: The sorted list of integers. ``` Input * A list of integers, `arr`, to be sorted. * A boolean, `simulation`, defaulted to `False`. When `True`, print the state of the list after each iteration. Output * The function should return the sorted list of integers. Constraints 1. The length of `arr` will be between 0 and 10^3. 2. Each element in the `arr` will have its value between -10^6 and 10^6. Performance Requirements - The optimized algorithm should aim to complete in less time when possible (early exit if the list is already sorted). Example ```python # Test Case 1: arr = [64, 25, 12, 22, 11] print(improved_selection_sort(arr)) # Output: [11, 12, 22, 25, 64] # Test Case 2: arr = [10, 20, 30, 40, 50] print(improved_selection_sort(arr, simulation=True)) # Output: # iteration 0 : 10 20 30 40 50 # [10, 20, 30, 40, 50] # Test Case 3: arr = [] print(improved_selection_sort(arr)) # Output: [] ```","solution":"def improved_selection_sort(arr, simulation=False): Sort the array using an optimized selection sort algorithm. Args: arr (list[int]): The list of integers to be sorted. simulation (bool): If True, prints the state of the list after each pass for visualization. Returns: list[int]: The sorted list of integers. n = len(arr) if n == 0: return arr for i in range(n): min_idx = i swapped = False for j in range(i + 1, n): if arr[j] < arr[min_idx]: min_idx = j swapped = True # Swap the found minimum element with the first element arr[i], arr[min_idx] = arr[min_idx], arr[i] if simulation: print(f\\"iteration {i} : {\' \'.join(map(str, arr))}\\") # If there was no swap in this iteration, the array is already sorted if not swapped: break return arr"},{"question":"# Matrix Key Search Algorithm Question: Given a matrix of integers where each row and each column is sorted in non-decreasing order, write a function `search_matrix(matrix, rows, columns, key)` that returns the position of the key within the matrix. If the key is not found, return `(-1, -1)`. Your function should be efficient and handle edge cases appropriately. Input Format: 1. `matrix`: A list of lists of integers representing the matrix. 2. `rows`: An integer indicating the number of rows in the matrix. 3. `columns`: An integer indicating the number of columns in the matrix. 4. `key`: An integer representing the value to search for in the matrix. Output Format: - A tuple `(row_index, col_index)` where `row_index` and `col_index` are the 0-based indices of the matrix where the key is found. If the key is not found, return `(-1, -1)`. Constraints: - The matrix dimensions `(rows, columns)` will range from 0 to 1000. - The elements in matrix are guaranteed to be integers. - The key is an integer. Performance: Aim for an O(m + n) time complexity solution where m is the number of rows and n is the number of columns. Example: ```python def search_matrix(matrix, rows, columns, key): # Your code here # Example matrices matrix1 = [ [2, 5, 7], [4, 8, 13], [9, 11, 15], [12, 17, 20] ] print(search_matrix(matrix1, 4, 3, 13)) # Output: (1, 2) print(search_matrix(matrix1, 4, 3, 10)) # Output: (-1, -1) matrix2 = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] print(search_matrix(matrix2, 3, 3, 5)) # Output: (1, 1) print(search_matrix(matrix2, 3, 3, 11)) # Output: (-1, -1) ``` Notes: - Clearly comment your code to explain your approach. - Consider edge cases properly, such as empty matrices or single-row/column matrices. - Ensure your solution is robust and handles all specified input conditions.","solution":"def search_matrix(matrix, rows, columns, key): Searches for the key in a given matrix where each row and column is sorted in non-decreasing order. Args: matrix (list of lists of int): The matrix to search in. rows (int): Number of rows in the matrix. columns (int): Number of columns in the matrix. key (int): The value to search for in the matrix. Returns: tuple: A tuple (row_index, col_index) where the key is found or (-1, -1) if the key is not found. if rows == 0 or columns == 0: return (-1, -1) # Start from the top-right corner of the matrix row = 0 col = columns - 1 while row < rows and col >= 0: if matrix[row][col] == key: return (row, col) elif matrix[row][col] > key: col -= 1 else: row += 1 return (-1, -1)"},{"question":"# Coding Assessment: Implement Secure Diffie-Hellman Key Exchange Objective This task assesses your understanding of cryptographic techniques, particularly the Diffie-Hellman key exchange algorithm. You need to implement the core components of the algorithm and ensure secure key exchange between two parties. # Problem Statement Two parties, Alice and Bob, want to share a secret key over an insecure channel using the Diffie-Hellman key exchange. The task requires you to write a series of functions to perform this secure key exchange. **Functions to Implement**: 1. `is_prime(num)`: Checks if a given number is prime. 2. `get_primitive_root(prime)`: Finds the smallest primitive root of a given prime. 3. `generate_private_key(max_val)`: Generates a private key between 1 and `max_val - 1`. 4. `generate_public_key(private_key, base, prime)`: Computes the public key using the private key, a base, and a prime. 5. `generate_shared_secret(other_public_key, private_key, prime)`: Generates the shared secret key using the other party\'s public key and the local private key. # Input Format * A prime number `p` and its primitive root `a` (you have to identify or derive `a` if it\'s not given). * Random private keys for Alice and Bob generated in the range `[1, p-1]`. # Output Format * The public keys of both Alice and Bob. * The shared secret keys calculated by both Alice and Bob. * A boolean indicating whether the shared secret keys are the same. # Constraints * `p` should be a prime number. * `2 <= p <= 10^9` # Example ```python # Given p = 23, a primitive root of 23 is 5 alice_private = generate_private_key(23) alice_public = generate_public_key(alice_private, 5, 23) bob_private = generate_private_key(23) bob_public = generate_public_key(bob_private, 5, 23) alice_shared_secret = generate_shared_secret(bob_public, alice_private, 23) bob_shared_secret = generate_shared_secret(alice_public, bob_private, 23) print(\\"Alice\'s Public Key:\\", alice_public) print(\\"Bob\'s Public Key:\\", bob_public) print(\\"Alice\'s Shared Secret:\\", alice_shared_secret) print(\\"Bob\'s Shared Secret:\\", bob_shared_secret) print(\\"Shared Secret Match:\\", alice_shared_secret == bob_shared_secret) ``` # Requirements 1. Correctly implement the provided functions. 2. Print outputs correctly as stated in the example. 3. Ensure efficiency to handle large prime numbers up to (10^9).","solution":"import random def is_prime(num): Check if a number is prime. if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def get_primitive_root(prime): Get the smallest primitive root of a given prime. if not is_prime(prime): raise ValueError(\\"The number must be prime.\\") required_set = {num for num in range(1, prime) if gcd(num, prime) == 1} for g in range(1, prime): actual_set = {pow(g, powers, prime) for powers in range(1, prime)} if required_set == actual_set: return g return None def gcd(a, b): Calculate the greatest common divisor of a and b while b: a, b = b, a % b return a def generate_private_key(max_val): Generate a private key return random.randint(1, max_val - 1) def generate_public_key(private_key, base, prime): Generate a public key return pow(base, private_key, prime) def generate_shared_secret(other_public_key, private_key, prime): Generate shared secret key return pow(other_public_key, private_key, prime)"},{"question":"Given an integer `n`, write a function `extended_totient_sieve(n)` to calculate the Euler\'s Totient function values for all integers from 1 to `n` inclusive. Your function should return a list where the `i`-th index represents the value of Euler\'s Totient function ϕ(i). # Input * An integer `n` (1 ≤ n ≤ 10^6). # Output * A list of integers where the i-th element is the value of ϕ(i). # Requirements * **Time Complexity**: O(n log log n) * **Space Complexity**: O(n) * The solution should be efficient enough to handle the upper input limit within reasonable time. # Example ```python # Input n = 10 # Output [0, 1, 1, 2, 2, 4, 2, 6, 4, 6, 4] ``` Explanation: The list returned for `n = 10` shows that: * ϕ(1) = 1 * ϕ(2) = 1 * ϕ(3) = 2 * ϕ(4) = 2 * ϕ(5) = 4 * ϕ(6) = 2 * ϕ(7) = 6 * ϕ(8) = 4 * ϕ(9) = 6 * ϕ(10) = 4 # Constraints * Ensure that the function handles the upper limit efficiently. * No direct built-in mathematical functions allowed except basic arithmetic (i.e., no using `math.gcd`).","solution":"def extended_totient_sieve(n): Calculates the Euler\'s Totient function values for all integers from 1 to n inclusive. # Initialize the list for totients phi = list(range(n + 1)) for i in range(2, n + 1): if phi[i] == i: # i is a prime number for j in range(i, n + 1, i): phi[j] = phi[j] * (i - 1) // i phi[0] = 0 # As Euler\'s Totient function is not defined for 0 return phi"},{"question":"Scenario You have been hired by a data streaming company to implement a real-time monitoring tool. This tool will process streams of transactions represented as tuples where each tuple contains a number and a sign (\'+\' or \'-\'). Your task is to determine if the stream is \\"1-sparse,\\" meaning all the elements in the stream cancel each other out such that there is only one unique non-zero value remaining. Task Given a list of tuples representing a stream, write a function `unique_number` to assess if the stream is 1-sparse. If it is, return the unique number remaining; otherwise, return `None`. Requirements 1. Implement the core 1-sparse checking algorithm. 2. Use bitwise operations for bit-level details. 3. Ensure efficient time and space complexity suitable for real-time streaming. Function Signature ```python def unique_number(stream: List[Tuple[int, str]]) -> Optional[int]: pass ``` Input - `stream`: List of tuples where each tuple is `(number: int, sign: str)` with sign being either `\'+\'` or `\'-\'`. Output - If the stream is 1-sparse, return the unique non-zero number. - Otherwise, return `None`. Constraints - Each number in the stream is a non-negative integer. - The total number of tuples in the stream can be up to (10^6). Examples ```python # Example 1: # Explanation: Since 2 and 3 get cancelled out. assert unique_number([(4,\'+\'), (2,\'+\'), (2,\'-\'), (4,\'+\'), (3,\'+\'), (3,\'-\')]) == 4 # Example 2: # Explanation: No other numbers are present. assert unique_number([(2,\'+\'), (2,\'+\'), (2,\'+\'), (2,\'+\'), (2,\'+\'), (2,\'+\'), (2,\'+\')]) == 2 # Example 3: # Explanation: Not 1-sparse. assert unique_number([(2,\'+\'), (2,\'+\'), (2,\'+\'), (2,\'+\'), (2,\'+\'), (2,\'+\'), (1,\'+\')]) == None ``` Note To handle the bitwise operations efficiently and check the 1-sparse characteristics, you may utilize helper functions as deem fit, inspired by the provided example.","solution":"from typing import List, Tuple, Optional def unique_number(stream: List[Tuple[int, str]]) -> Optional[int]: balance = {} for number, sign in stream: if sign == \'+\': balance[number] = balance.get(number, 0) + 1 elif sign == \'-\': balance[number] = balance.get(number, 0) - 1 remaining_numbers = [number for number, count in balance.items() if count != 0] if len(remaining_numbers) == 1: return remaining_numbers[0] else: return None"},{"question":"As a software developer working on a search engine for word puzzles, you are tasked with implementing a function to find all valid words from a given list that can be formed in a given board. The board consists of letters and allows forming words by consecutively connecting adjacent letters horizontally or vertically. Each letter cell can be used only once per word. # Function Specification Implement the function: ```python def find_valid_words(board: List[List[str]], words: List[str]) -> List[str]: ``` Input * `board`: A 2D list of characters, representing the board. * `board[i][j]` is a character (\'a\'-\'z\'). * Each cell can be connected to adjacent cells horizontally or vertically. * `words`: A list of strings, representing the words to search. * Each word contains only lowercase \'a\'-\'z\'. Output Return a list of words found in the board. The list can be in any order. Constraints * 1 <= len(board), len(board[0]) <= 12 * 1 <= len(words) <= 3 * 10^4 * 1 <= len(words[i]) <= 10 * All strings provided contain only lowercase letters \'a\'-\'z\'. # Example Input ```python board = [ [\'o\',\'a\',\'a\',\'n\'], [\'e\',\'t\',\'a\',\'e\'], [\'i\',\'h\',\'k\',\'r\'], [\'i\',\'f\',\'l\',\'v\'] ] words = [\\"oath\\",\\"pea\\",\\"eat\\",\\"rain\\"] ``` Output ```python [\\"oath\\", \\"eat\\"] ``` # Notes Use a Trie data structure for storing the `words` list and backtracking to explore possible word formations on the board, ensuring efficiency with these techniques. Consider edge cases such as repetitive path exploration and handling no valid words scenarios effectively.","solution":"class TrieNode: def __init__(self): self.children = {} self.end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word): current_node = self.root for char in word: if char not in current_node.children: current_node.children[char] = TrieNode() current_node = current_node.children[char] current_node.end_of_word = True def find_valid_words(board, words): def dfs(node, x, y, path, visited, result): if node.end_of_word: result.append(path) node.end_of_word = False # to avoid duplicate word additions for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < len(board) and 0 <= ny < len(board[0]) and (nx, ny) not in visited: next_char = board[nx][ny] if next_char in node.children: visited.add((nx, ny)) dfs(node.children[next_char], nx, ny, path + next_char, visited, result) visited.remove((nx, ny)) if not board or not words: return [] trie = Trie() for word in words: trie.insert(word) result = [] for i in range(len(board)): for j in range(len(board[0])): start_char = board[i][j] if start_char in trie.root.children: dfs(trie.root.children[start_char], i, j, start_char, set([(i, j)]), result) return result"},{"question":"Coding Problem: Digit Counter # Problem Statement You are tasked with writing a function that determines the number of digits in a given integer. The function should efficiently compute the result using mathematical operations. # Function Signature ```python def num_digits(n: int) -> int: ``` # Input - An integer `n` where `-10^18 <= n <= 10^18`. # Output - Return an integer representing the number of digits in `n`. # Constraints - You must consider both positive and negative numbers. - If the number is zero, your function should return 1 as zero has one digit. - Ensure that your function runs in constant time `O(1)`. # Examples ```python assert num_digits(4567) == 4 assert num_digits(-123) == 3 assert num_digits(0) == 1 assert num_digits(987654321012345678) == 18 ``` # Additional test cases - Input `n = -1000000000` should return `10` - Input `n = 1` should return `1` - Input `n = -5` should return `1` - Input `n = 1000000000000000000` should return `19` # Scenario Imagine you are developing a digital signage application that displays a variety of information in numeric form, including large integers. For proper layout and formatting, you need to determine the number of digits in these integer values quickly. Implementing this digit counter function will help in dynamically setting up display formats.","solution":"def num_digits(n: int) -> int: Returns the number of digits in the given integer n. # Convert the number to a string and deal with the negative sign if present return len(str(abs(n)))"},{"question":"You are given an array of integers `arr` and an integer `target`. Write a function `find_second_occurrence(arr, target)` that returns the index of the second occurrence of `target` in `arr`. If `target` appears less than twice in `arr`, return -1. # Input Format: * `arr`: A list of integers where the length of the list can range from 0 to 10^6. * `target`: An integer to find the second occurrence of. # Output Format: Return a single integer indicating the index of the second occurrence of `target` in `arr`. If `target` does not occur at least twice, return -1. # Constraints: * The elements of `arr` are not sorted. * The function should consider edge cases, such as an empty array or when the `target` appears only once or not at all. # Example: ```python print(find_second_occurrence([1, 2, 3, 4, 2, 5], 2)) # Output: 4 print(find_second_occurrence([1, 2, 3, 4, 5], 6)) # Output: -1 print(find_second_occurrence([1, 2, 2, 2, 2], 2)) # Output: 2 print(find_second_occurrence([], 1)) # Output: -1 print(find_second_occurrence([1, 2, 3], 3)) # Output: -1 ``` **Note** - Ensure your solution runs efficiently for large inputs. - Handle all specified edge cases diligently.","solution":"def find_second_occurrence(arr, target): Returns the index of the second occurrence of target in arr. If the target does not appear at least twice, return -1. count = 0 # Initialize the count of occurrences for index, value in enumerate(arr): if value == target: count += 1 if count == 2: return index return -1"},{"question":"Problem: Frequent Elements Finder You are working as a data analyst and need to process survey results. One of the common tasks is to determine the most frequent responses given in a survey. Your task is to write a function that receives a list of responses and returns the most frequently occurring elements. If there are multiple elements with the same highest frequency, include all of them in the result. # Function Signature ```python def most_frequent_elements(arr: List[int]) -> List[int]: ``` # Input - A list of integers `arr` representing survey responses. The list can contain up to 10^6 elements, with the value of each element falling within the integer range. # Output - A list of integers representing the most frequent responses. # Constraints - The input list will not be empty. # Performance Requirements - The function should complete with a time complexity of O(n). # Example ```python # Example 1 input: [1, 1, 2, 2, 3, 4] output: [1, 2] # Example 2 input: [1, 3, 3, 2, 1, 2, 3] output: [3] # Example 3 input: [4, 4, 4, 4, 4, 4] output: [4] ``` # Note - In the first example, both 1 and 2 have the highest frequency of 2, so the result is [1, 2]. - In the second example, 3 has the highest frequency of 3, so the result is [3]. - In the third example, 4 is the only element and it appears 6 times, so the result is [4]. Use this function for processing large data sets to quickly and efficiently determine the most frequent elements.","solution":"from typing import List from collections import Counter def most_frequent_elements(arr: List[int]) -> List[int]: Given a list of integers `arr`, returns the most frequently occurring elements. If there are multiple elements with the same highest frequency, it includes all of them in the result. frequency = Counter(arr) max_count = max(frequency.values()) return [key for key, count in frequency.items() if count == max_count]"},{"question":"# Anagram Validation Function Objective Write a function `is_anagram` that determines if one string is an anagram of another. Function Signature ```python def is_anagram(s: str, t: str) -> bool: Parameters: s (str): The first string. t (str): The second string, potentially an anagram of the first. Returns: bool: True if `t` is an anagram of `s`, False otherwise. ``` Input/Output Format - **Input**: - `s`: A string containing only lowercase alphabets (1 <= len(s) <= 10^5). - `t`: A string containing only lowercase alphabets (1 <= len(t) <= 10^5). - **Output**: - A boolean value (`True` or `False`). Constraints - The strings `s` and `t` may contain only lowercase English letters (\'a\' to \'z\'). Performance - The solution should aim for O(n) time complexity and O(1) space complexity considering the fixed character set. Scenario Consider a situation where you are developing a feature for a text-based game that checks for scrambled words or anagram-based puzzles. Implementing this efficient anagram checker will help verify user inputs quickly and accurately. Example ```python is_anagram(\'anagram\', \'nagaram\') # Output: True is_anagram(\'rat\', \'car\') # Output: False is_anagram(\'a\', \'a\') # Output: True is_anagram(\'ab\', \'a\') # Output: False ```","solution":"def is_anagram(s: str, t: str) -> bool: Determine if one string is an anagram of another. Parameters: s (str): The first string. t (str): The second string, potentially an anagram of the first. Returns: bool: True if `t` is an anagram of `s`, False otherwise. if len(s) != len(t): return False count_s = [0] * 26 count_t = [0] * 26 for char in s: count_s[ord(char) - ord(\'a\')] += 1 for char in t: count_t[ord(char) - ord(\'a\')] += 1 return count_s == count_t"},{"question":"Bit Manipulation Challenge Scenario You are given a 32-bit integer which represents a set of boolean flags. Each bit in this integer corresponds to a particular feature flag in a software system, where `1` means the feature is enabled and `0` means it is disabled. Your task is to implement several functions to manipulate these flags. Task Write a class `FlagManipulator` that includes the following methods: 1. **`get_flag(number: int, index: int) -> bool`**: - **Input**: A 32-bit integer `number` and an integer `index` (0 through 31). - **Output**: A boolean indicating whether the bit at the specified index is set. 2. **`set_flag(number: int, index: int) -> int`**: - **Input**: A 32-bit integer `number` and an integer `index` (0 through 31). - **Output**: The new integer value after setting the bit at the specified index. 3. **`clear_flag(number: int, index: int) -> int`**: - **Input**: A 32-bit integer `number` and an integer `index` (0 through 31). - **Output**: The new integer value after clearing the bit at the specified index. 4. **`update_flag(number: int, index: int, value: bool) -> int`**: - **Input**: A 32-bit integer `number`, an integer `index` (0 through 31), and a boolean `value` (True to set the bit, False to clear it). - **Output**: The new integer value after updating the bit at the specified index to the given value. Constraints & Limitations - All inputs are valid integers. - The index will always be between 0 and 31, inclusive. - You need to handle potential issues caused by incorrect indexing and provide appropriate error messages for these cases. Performance Requirements - The functions must operate in O(1) time complexity. ```python class FlagManipulator: @staticmethod def get_flag(number: int, index: int) -> bool: # Implement the get_flag method pass @staticmethod def set_flag(number: int, index: int) -> int: # Implement the set_flag method pass @staticmethod def clear_flag(number: int, index: int) -> int: # Implement the clear_flag method pass @staticmethod def update_flag(number: int, index: int, value: bool) -> int: # Implement the update_flag method pass # Example usage: # number = 5 (binary: 0000 0101) # index = 1 # get_flag(number, index) should return True # set_flag(number, index) should return 7 (binary: 0000 0111) # clear_flag(number, index) should return 5 (binary: 0000 0101) # update_flag(number, index, False) should return 5 (binary: 0000 0101) ```","solution":"class FlagManipulator: @staticmethod def get_flag(number: int, index: int) -> bool: if index < 0 or index >= 32: raise ValueError(\\"Index out of range: 0 to 31\\") return (number & (1 << index)) != 0 @staticmethod def set_flag(number: int, index: int) -> int: if index < 0 or index >= 32: raise ValueError(\\"Index out of range: 0 to 31\\") return number | (1 << index) @staticmethod def clear_flag(number: int, index: int) -> int: if index < 0 or index >= 32: raise ValueError(\\"Index out of range: 0 to 31\\") return number & ~(1 << index) @staticmethod def update_flag(number: int, index: int, value: bool) -> int: if index < 0 or index >= 32: raise ValueError(\\"Index out of range: 0 to 31\\") if value: return FlagManipulator.set_flag(number, index) else: return FlagManipulator.clear_flag(number, index)"},{"question":"Problem Statement Implement a Trie with methods for insertion, word search, and prefix search. The Trie should facilitate the following operations: 1. **insert(word)** - Inserts a word into the Trie. 2. **search(word)** - Returns `True` if the word is in the Trie (exact match), else returns `False`. 3. **starts_with(prefix)** - Returns `True` if there is any word in the Trie that starts with the given prefix, otherwise returns `False`. Your implementation should be efficient both in terms of time and space. The Trie only needs to handle lowercase a-z letters. Function Signatures ```python class Trie: def __init__(self): Initialize your data structure here. pass def insert(self, word: str) -> None: Inserts a word into the Trie. :param word: Word to be inserted into the Trie pass def search(self, word: str) -> bool: Returns if the word is in the Trie. :param word: Word to search in the Trie :return: True if word is found in the Trie, else False pass def starts_with(self, prefix: str) -> bool: Returns if there is any word in the Trie that starts with the given prefix. :param prefix: Prefix to search in the Trie :return: True if there is any word in the Trie that starts with the prefix, else False pass ``` Constraints - You may assume that all inputs are consist of lowercase letters a-z. - The `insert` and `search` functions will be called multiple times. - Ensure your solution is optimized for both space and time efficiency. Example ```python trie = Trie() trie.insert(\\"apple\\") assert(trie.search(\\"apple\\") == True) # returns True assert(trie.search(\\"app\\") == False) # returns False assert(trie.starts_with(\\"app\\") == True) # returns True trie.insert(\\"app\\") assert(trie.search(\\"app\\") == True) # returns True ``` Notes - You are expected to implement all methods from scratch without using any pre-built libraries specific to Trie operations. - Thoroughly test edge cases such as searching for an empty string, prefix that does not exist, etc.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): Initialize your data structure here. self.root = TrieNode() def insert(self, word: str) -> None: Inserts a word into the Trie. :param word: Word to be inserted into the Trie node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, word: str) -> bool: Returns if the word is in the Trie. :param word: Word to search in the Trie :return: True if word is found in the Trie, else False node = self.root for char in word: if char not in node.children: return False node = node.children[char] return node.is_end_of_word def starts_with(self, prefix: str) -> bool: Returns if there is any word in the Trie that starts with the given prefix. :param prefix: Prefix to search in the Trie :return: True if there is any word in the Trie that starts with the prefix, else False node = self.root for char in prefix: if char not in node.children: return False node = node.children[char] return True"},{"question":"# Context You have been hired by a cryptographic firm to improve their coding library. One of the preliminary functions they need is an optimized primality test function. Your task is to write and improve a function that checks if a given number is prime. # Task Design a function `is_prime(n: int) -> bool` that returns `True` if `n` is a prime number, and `False` otherwise. # Input and Output * **Input**: An integer `n` (1 ≤ `n` ≤ 10^12) * **Output**: Return `True` if `n` is a prime, otherwise `False`. # Requirements * You must ensure the function is efficient with a clear attempt to minimize time complexity. * Handle very large values within the input constraints given. * Consider edge cases and ensure the function does not use excessive memory. * Avoid using Python\'s inbuilt functions for primality checking. # Example ```python def test(): assert is_prime(1) == False assert is_prime(2) == True assert is_prime(17) == True assert is_prime(25) == False assert is_prime(101) == True test() ``` # Constraint * Aim for a time complexity close to O(√n). * Consider the 6k ± 1 optimization pattern for efficient checking.","solution":"def is_prime(n: int) -> bool: Check if a given number is prime. Parameters: n (int): The number to check for primality. Returns: bool: True if n is a prime number, else False. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True"},{"question":"# Bubble Sort Implementation and Analysis You are given the task of implementing the Bubble Sort algorithm, which is a straightforward sorting technique but not very efficient for large datasets. Your goal is to understand and implement this algorithm as well as to consider its edge cases and performance aspects. Problem Statement Implement the `bubble_sort` function that sorts an array of integers in ascending order using the Bubble Sort algorithm. ```python def bubble_sort(arr, simulation=False): # Your code here ``` Requirements 1. **Function Signature**: ```python def bubble_sort(arr, simulation=False): ... return arr ``` 2. **Input**: - `arr`: A list of integers to sort. Example: [4, 2, 7, 1, 3]. - `simulation` (optional): A boolean that, when set to True, will print the state of the array after each iteration of the sort. By default, it is set to False. 3. **Output**: - Returns the sorted array. Example: [1, 2, 3, 4, 7]. Constraints - The input list can be empty. - The elements in the list can be either positive or negative integers. - The input list can have up to 10^3 elements. Example ```python print(bubble_sort([64, 34, 25, 12, 22, 11, 90])) # [11, 12, 22, 25, 34, 64, 90] print(bubble_sort([], simulation=True)) # [] print(bubble_sort([3, 2, 1], simulation=True)) # Iteration process should be printed # Iteration 1: 2 3 1 # Iteration 2: 2 1 3 # Iteration 3: 1 2 3 # Final output: [1, 2, 3] ``` Performance Considerations - Think about the situations where Bubble Sort might be inefficient and how you can check for the best-case scenario where the list is already sorted (already implemented through the `swapped` variable). - Ensure that your function can handle the edge cases such as an already sorted list, a list with all identical elements, or a reverse-sorted list efficiently.","solution":"def bubble_sort(arr, simulation=False): Sorts an array of integers in ascending order using the Bubble Sort algorithm. n = len(arr) for i in range(n): swapped = False for j in range(0, n-i-1): if arr[j] > arr[j + 1]: arr[j], arr[j + 1] = arr[j + 1], arr[j] swapped = True if simulation: print(f\'Iteration {i + 1}.{j + 1}:\', arr) if not swapped: break return arr"},{"question":"# Scenario You are tasked with implementing a linked list data structure from scratch. You must implement both singly and doubly linked lists. As part of the assessment, you will add methods that perform the essential operations on these lists. # Requirements Implement the following methods for both `SinglyLinkedList` and `DoublyLinkedList` classes: 1. **Initialization**: - `__init__(self)`: * Initializes the list with head (and tail for doubly linked list) set to None. 2. **Insertion**: - `insert_at_head(self, value)`: * Inserts a new node with the given value at the beginning of the list. 3. **Deletion**: - `delete_at_head(self)`: * Removes the node at the beginning of the list. 4. **Access/Search**: - `search(self, value)`: * Returns True if a node with the given value exists, otherwise False. # Input and Output Formats - The methods will be tested by calling them with various inputs. - The `insert_at_head` and `delete_at_head` methods do not return any value. - The `search` method returns a boolean. # Constraints - The list can contain any number of elements (including zero initially). - Node values will be integers. # Example ```python # Example usage: # Singly Linked List sll = SinglyLinkedList() sll.insert_at_head(10) sll.insert_at_head(20) print(sll.search(10)) # True print(sll.search(30)) # False sll.delete_at_head() # Deletes 20 print(sll.search(20)) # False # Doubly Linked List dll = DoublyLinkedList() dll.insert_at_head(10) dll.insert_at_head(20) print(dll.search(10)) # True print(dll.search(30)) # False dll.delete_at_head() # Deletes 20 print(dll.search(20)) # False ``` # Implementation Stubs ```python class SinglyLinkedListNode: def __init__(self, value): self.value = value self.next = None class SinglyLinkedList: def __init__(self): self.head = None def insert_at_head(self, value): # Your code here def delete_at_head(self): # Your code here def search(self, value): # Your code here class DoublyLinkedListNode: def __init__(self, value): self.value = value self.next = None self.prev = None class DoublyLinkedList: def __init__(self): self.head = None self.tail = None def insert_at_head(self, value): # Your code here def delete_at_head(self): # Your code here def search(self, value): # Your code here ```","solution":"class SinglyLinkedListNode: def __init__(self, value): self.value = value self.next = None class SinglyLinkedList: def __init__(self): self.head = None def insert_at_head(self, value): new_node = SinglyLinkedListNode(value) new_node.next = self.head self.head = new_node def delete_at_head(self): if self.head is not None: self.head = self.head.next def search(self, value): current = self.head while current is not None: if current.value == value: return True current = current.next return False class DoublyLinkedListNode: def __init__(self, value): self.value = value self.next = None self.prev = None class DoublyLinkedList: def __init__(self): self.head = None self.tail = None def insert_at_head(self, value): new_node = DoublyLinkedListNode(value) if self.head is None: self.head = new_node self.tail = new_node else: new_node.next = self.head self.head.prev = new_node self.head = new_node def delete_at_head(self): if self.head is not None: if self.head.next is None: self.head = None self.tail = None else: self.head = self.head.next self.head.prev = None def search(self, value): current = self.head while current is not None: if current.value == value: return True current = current.next return False"},{"question":"# Question **Insertion Sort Implementation** Your task is to implement the Insertion Sort algorithm. The function should take an unsorted list of integers and return a sorted version of the list. Additionally, you should provide an optional feature to simulate and print each iteration of the sorting process. Function Signature ```python def insertion_sort(arr: List[int], simulation: bool = False) -> List[int]: ``` Input - `arr`: A list of integers, `arr`, where `1 <= len(arr) <= 1000` - `simulation`: A boolean flag, which if set to `True`, will print out the state of the array after each outer loop iteration. Output - A new list of integers, sorted in ascending order. Constraints - You should perform the sorting in-place. - You should not use Python\'s built-in sort functions. Example Given the following input: ```python insertion_sort([4, 3, 2, 1], simulation=True) ``` Expected output (to the console): ``` iteration 0 : 4 3 2 1 iteration 1 : 3 4 2 1 iteration 2 : 2 3 4 1 iteration 3 : 1 2 3 4 ``` Returned list: ```python [1, 2, 3, 4] ``` Use thorough testing to ensure that your implementation handles all edge cases correctly, including but not limited to: - Empty lists - Lists with one element - Lists with repeating elements - Already sorted lists - Large lists up to the maximum length of 1000 elements","solution":"from typing import List def insertion_sort(arr: List[int], simulation: bool = False) -> List[int]: Performs an insertion sort on a list of integers. Parameters: arr (List[int]): The list of integers to be sorted. simulation (bool): If True, prints the state of array after each iteration. Default is False. Returns: List[int]: The sorted list of integers. for i in range(1, len(arr)): key = arr[i] j = i - 1 while j >= 0 and arr[j] > key: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key if simulation: print(f\\"iteration {i} : {\' \'.join(map(str, arr))}\\") return arr"},{"question":"# Graph Cloning with a Twist Background Suppose you are working on a simulation of a network of interconnected devices. Each device can connect to multiple other devices, forming an undirected graph. Your task is to clone this network structure precisely, including any self-cyclical connections a device might have. Problem Statement You are provided with the `UndirectedGraphNode` class and the following function skeleton. Your task is to implement the function `clone_graph_with_counters`. This function should clone the given graph while also counting the number of distinct nodes and total edges in the original graph. # Function Signature ```python def clone_graph_with_counters(node: \'UndirectedGraphNode\') -> (\'UndirectedGraphNode\', int, int): pass ``` # Input - `node` (UndirectedGraphNode): A reference to any node in the original undirected graph. # Output - Returns a tuple (`new_node`, `num_nodes`, `num_edges`): - `new_node` (UndirectedGraphNode): A reference to the starting node of the cloned graph. - `num_nodes` (int): The total number of distinct nodes in the original graph. - `num_edges` (int): The total number of unique edges in the original graph. # Constraints 1. Nodes are uniquely labeled within the graph. 2. The graph may contain self-cycles (nodes connected to themselves). 3. Duplicate edges between the same pair of nodes should be counted once. # Performance Requirements The solution should efficiently clone the graph and count the nodes and edges in O(V + E) time complexity, where V is the number of vertices and E is the number of edges. # Example Given the serialized graph {0,1,2#1,2#2,2}, the graph appears as: 1 / / 0 --- 2 / _/ For this graph: - `num_nodes` = 3 - `num_edges` = 3 Implementation Notes Feel free to use the provided cloning strategies (BFS, iterative DFS, recursive DFS) as references. You are required to implement a function that considers the additional metrics of node and edge counts.","solution":"class UndirectedGraphNode: def __init__(self, x): self.label = x self.neighbors = [] def clone_graph_with_counters(node: \'UndirectedGraphNode\') -> (\'UndirectedGraphNode\', int, int): if node is None: return None, 0, 0 # A map to hold cloned nodes cloned_nodes = {} # A set to hold visited connections to count unique edges visited_edges = set() def clone(node): if node in cloned_nodes: return cloned_nodes[node] # Clone the node clone_node = UndirectedGraphNode(node.label) cloned_nodes[node] = clone_node for neighbor in node.neighbors: clone_node_neighbor = clone(neighbor) clone_node.neighbors.append(clone_node_neighbor) return clone_node # Clone the graph clone_node = clone(node) # Count edges node_queue = [node] visited_nodes = set([node]) while node_queue: current_node = node_queue.pop() for neighbor in current_node.neighbors: # Create an edge identifier (smallest first to avoid duplicates) edge = tuple(sorted((current_node.label, neighbor.label))) if edge not in visited_edges: visited_edges.add(edge) if neighbor not in visited_nodes: visited_nodes.add(neighbor) node_queue.append(neighbor) num_nodes = len(cloned_nodes) num_edges = len(visited_edges) return clone_node, num_nodes, num_edges"},{"question":"# Secure Communication with Diffie-Hellman Key Exchange You are assigned the task of implementing part of a secure communication protocol based on the Diffie-Hellman key exchange algorithm. Your goal is to write functions that perform the key operations needed for Alice and Bob to securely establish a shared key. Requirements 1. **Prime Checking**: Write a function `is_prime(num)` that determines if a number `num` is prime. ```python def is_prime(num: int) -> bool: pass ``` * **Input**: A single integer `num` where 1 <= num <= 10^6. * **Output**: Return `True` if `num` is prime, otherwise `False`. 2. **Euler\'s Totient Function**: Write a function `euler_totient(n)` that computes the Euler\'s Totient function ϕ(n). ```python def euler_totient(n: int) -> int: pass ``` * **Input**: A single integer `n` where 1 <= n <= 10^6. * **Output**: Return the count of integers between 1 and `n` inclusive that are coprime with `n`. 3. **Finding Primitive Roots**: Write a function `find_primitive_root(n)` to find the primitive roots of a given integer `n`. ```python def find_primitive_root(n: int) -> list: pass ``` * **Input**: A single integer `n` where 1 <= n <= 10^6. * **Output**: Return a list of all primitive roots of `n`. 4. **Diffie-Hellman Key Exchange**: Write a function `diffie_hellman_key_exchange(a, p)` following these steps: ```python def diffie_hellman_key_exchange(a: int, p: int) -> bool: pass ``` * **Input**: * `a`: A large integer that is a primitive root of `p`. * `p`: A large prime number. * **Output**: The function should return `True` if the key exchange is successful and `Alice\'s` and `Bob\'s` shared keys match. Else return `False`. * **Constraints**: * Alice and Bob must generate their private keys within the range 1 to p-1. * Public keys must be calculated correctly using modular exponentiation. * Alice and Bob must then calculate the shared secret keys correctly. # Example Usage ```python # Prime checking print(is_prime(17)) # should return True print(is_prime(18)) # should return False # Euler\'s Totient function print(euler_totient(10)) # should return 4 # Finding primitive roots print(find_primitive_root(19)) # should return a list of primitive roots. # Diffie-Hellman key exchange print(diffie_hellman_key_exchange(3, 23)) # should print shared keys and return True if they match. ``` # Performance Considerations The functions should handle input size efficiently and return correct results within a reasonable time.","solution":"import random def is_prime(num: int) -> bool: Determines if a number num is prime. if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def euler_totient(n: int) -> int: Computes the Euler\'s Totient function ϕ(n). if n == 1: return 1 result = n p = 2 while (p * p <= n): if (n % p == 0): while (n % p == 0): n //= p result -= result // p p += 1 if (n > 1): result -= result // n return result def find_primitive_root(n: int) -> int: Finds a single primitive root of a given prime number n. if not is_prime(n): return None phi = n - 1 factors = set() i = 2 while i * i <= phi: if phi % i == 0: factors.add(i) while phi % i == 0: phi //= i i += 1 if phi > 1: factors.add(phi) phi = n - 1 def is_primitive_root(g, n, factors): for factor in factors: if pow(g, (n - 1) // factor, n) == 1: return False return True for g in range(2, n): if is_primitive_root(g, n, factors): return g return None def diffie_hellman_key_exchange(a: int, p: int) -> bool: Implements the Diffie-Hellman key exchange and returns True if shared keys match. if not is_prime(p): return False # Private keys private_key_A = random.randint(1, p - 1) private_key_B = random.randint(1, p - 1) # Public keys public_key_A = pow(a, private_key_A, p) public_key_B = pow(a, private_key_B, p) # Shared secret keys shared_key_A = pow(public_key_B, private_key_A, p) shared_key_B = pow(public_key_A, private_key_B, p) return shared_key_A == shared_key_B"},{"question":"# Question: Unique Permutations **Context**: Given a collection of numbers that might contain duplicates, your task is to return all possible unique permutations of the numbers. We want to assess your understanding of generating permutations and handling duplicates efficiently. **Function Signature**: ```python def permute_unique(nums: List[int]) -> List[List[int]]: ``` **Input**: - A list `nums` containing `n` integers (1 <= n <= 8), where elements can be positive, negative, or zero and may contain duplicates. **Output**: - A list of lists, where each inner list is a unique permutation of `nums`. **Constraints**: - The permutations should be unique, even if the input list contains duplicates. - The order of permutations in the output list does not matter. **Examples**: ```python assert permute_unique([1, 1, 2]) == [ [1, 1, 2], [1, 2, 1], [2, 1, 1] ] assert permute_unique([1, 2, 3]) == [ [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1] ] assert permute_unique([3, 3, 0, 3]) == [ [3, 3, 0, 3], [3, 3, 3, 0], [3, 0, 3, 3], [0, 3, 3, 3] ] ``` **Performance Requirements**: - The solution should be efficient enough to handle the upper constraints. Pay attention to avoid generating duplicate permutations by evaluating this during the permutation process. # Hints: 1. Consider using recursion or iteration with backtracking to reduce redundancy. 2. Sorting the input list might help in detecting duplicates during the permutation generation.","solution":"from typing import List def permute_unique(nums: List[int]) -> List[List[int]]: def backtrack(start): # If we\'ve reached the end, append the permutation if start == len(nums): result.append(nums[:]) return seen = set() for i in range(start, len(nums)): # Skip duplicates if nums[i] in seen: continue seen.add(nums[i]) # Swap to put a different element at the current start nums[start], nums[i] = nums[i], nums[start] # Recurse to next position backtrack(start + 1) # Swap back for backtracking nums[start], nums[i] = nums[i], nums[start] result = [] nums.sort() # Sort to handle duplicates backtrack(0) return result"},{"question":"**Problem Statement**: You are given a stack of integers. Your task is to implement a function `is_sorted_with_min_ops(stack)` that verifies whether the elements in the stack are sorted in ascending order from bottom to top. The function must ensure that the original order of the stack is preserved after the check. # Function Signature ```python def is_sorted_with_min_ops(stack: List[int]) -> bool: ``` # Input - A stack represented by a list of integers where the last element in the list is the top of the stack, and the first element is the bottom. # Output - Return `True` if the stack is sorted in ascending order from bottom to top. Otherwise, return `False`. # Constraints - The stack can have up to (10^4) elements. - Each element in the stack is an integer within the range [−(10^9), (10^9)]. # Performance Requirements - Your solution must perform the check in O(n) time. - Space complexity should ideally be O(n). However, optimized solutions minimizing additional space usage are encouraged. # Scenario Imagine you are given the task of verifying sorted records in a database system that manages data in a LIFO manner. Before performing certain critical operations, you need to ensure that the data remains sorted to maintain consistency and integrity within the system. # Example 1. **Example 1:** - Input: `[1, 2, 3, 4, 5]` - Output: `True` 2. **Example 2:** - Input: `[3, 2, 1, 4, 5]` - Output: `False` 3. **Example 3:** - Input: `[1]` - Output: `True` 4. **Example 4:** - Input: `[]` - Output: `True` # Key Considerations - The function should not alter the input stack\'s element order. - Consider special cases such as empty stack or stack with single element which are trivially sorted.","solution":"def is_sorted_with_min_ops(stack): Checks if the elements in the stack are sorted in ascending order from bottom to top. The original stack\'s order is preserved after checking. :param stack: List[int] - A list representing the stack with the last element as the top of the stack :return: bool - True if stack is sorted in ascending order from bottom to top, False otherwise if not stack: return True temp_stack = [] sorted = True # Push all elements to a temporary stack to preserve the original stack for i in range(len(stack)): temp_stack.append(stack[i]) # Check if stack is sorted in ascending order for i in range(1, len(temp_stack)): if temp_stack[i] < temp_stack[i - 1]: sorted = False break return sorted"},{"question":"# Next Higher Permutation Given a number `num`, find the next higher permutation of its digits in lexicographic order, and return it as an integer. If no such permutation exists (i.e., the given number is the highest possible permutation of its digits), return `-1`. Input * An integer `num` where `1 <= num <= 10^15`. Output * An integer representing the next higher permutation or `-1` if no such permutation exists. # Constraints * Do not use built-in functions that directly generate permutations. * The solution should be efficient both in terms of time and space complexity. # Examples 1. **Input**: `38276`<br> **Output**: `38627` 2. **Input**: `99999`<br> **Output**: `-1` 3. **Input**: `12345`<br> **Output**: `12354` 4. **Input**: `54321`<br> **Output**: `-1` # Explanation To solve this problem: 1. Identify the largest index `i` such that `array[i-1] < array[i]`. If no such index exists, return `-1`. 2. Identify the largest index `j` such that `j >= i` and `array[j] > array[i-1]`. 3. Swap `array[j]` and `array[i-1]`. 4. Reverse the suffix starting at `array[i]`. Implement the function `next_bigger(num: int) -> int` in Python to accomplish this.","solution":"def next_bigger(num): digits = list(str(num)) n = len(digits) # Step 1: Identify the largest index i such that digits[i-1] < digits[i] i = n - 1 while i > 0 and digits[i - 1] >= digits[i]: i -= 1 # If no such index exists, return -1 if i == 0: return -1 # Step 2: Identify the largest index j such that j >= i and digits[j] > digits[i-1] j = n - 1 while digits[j] <= digits[i - 1]: j -= 1 # Step 3: Swap digits[j] and digits[i-1] digits[i - 1], digits[j] = digits[j], digits[i - 1] # Step 4: Reverse the suffix starting at digits[i] digits = digits[:i] + digits[i:][::-1] # Convert the list of digits back to an integer next_perm = int(\'\'.join(digits)) return next_perm"},{"question":"# Scenario You are working with a data store represented as a Binary Search Tree (BST). The data store needs a utility function to quickly find the data point closest to a given target value. This function will be utilized frequently, so it needs to be efficient in both time and space. # Task Implement a function `closest_value` that finds the value in a given non-empty BST that is closest to a specified target value. **Function Signature**: `def closest_value(root, target):` # Implementation Details 1. **Input**: - `root` (TreeNode): A TreeNode representing the root of the BST. - `target` (float): The target value you want to find the closest value to. 2. **Output**: - Returns the integer value from the BST that is closest to the target. 3. **Constraints**: - The BST is non-empty. - The target is a floating-point value. - There is exactly one unique value in the BST closest to the target. # Example ```python # Definition for a binary tree node. # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.right = None # Example BST: # 4 # / # 2 5 # / # 1 3 root = TreeNode(4) root.left = TreeNode(2) root.right = TreeNode(5) root.left.left = TreeNode(1) root.left.right = TreeNode(3) target = 3.714286 assert closest_value(root, target) == 4 ``` **Notes**: - You can define the `TreeNode` class if needed for testing purposes. - Ensure your implementation handles edge cases such as the BST having a single node or the target being equal to a node value.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def closest_value(root, target): Finds the value in the BST closest to the target value. Parameters: root (TreeNode): The root of the BST. target (float): The target value. Returns: int: The closest value in the BST. closest = root.val current_node = root while current_node: # Update closest if the current node is closer to the target if abs(current_node.val - target) < abs(closest - target): closest = current_node.val # Move to the appropriate subtree if target < current_node.val: current_node = current_node.left else: current_node = current_node.right return closest"},{"question":"# Question: Implement a Custom Randomized Data Structure You are to design a data structure that efficiently supports the following operations in average O(1) time: 1. `insert(val)`: Adds an item `val` to the set if it is not already present. 2. `remove(val)`: Removes an item `val` from the set if it is present. 3. `get_random()`: Returns a random element from the current set. Each element must have an equal probability of being returned. Implementation Requirements * **Input/Output Formats**: - The `insert` method should return `True` if the element was successfully added and `False` if it was already present. - The `remove` method should return `True` if the element was successfully removed and `False` if it was not present. - The `get_random` method should return a random element from the set. * **Constraints**: - No duplicate elements in the set. - The `get_random()` method must guarantee all elements have the same probability of being chosen. * **Performance Requirements**: - Ensure all methods have average O(1) time complexity. Scenario Imagine you are maintaining a set of users participating in a lottery. You need to insert new participants, remove those who opted out, and randomly select winners. Your task is to implement this custom data structure to manage users efficiently. ```python import random class RandomizedSet: def __init__(self): self.nums = [] self.idxs = {} def insert(self, val: int) -> bool: Inserts a value to the set if not already present. Args: - val (int): Element to be inserted. Returns: - bool: True if the element was successfully inserted, False otherwise. if val not in self.idxs: self.nums.append(val) self.idxs[val] = len(self.nums) - 1 return True return False def remove(self, val: int) -> bool: Removes a value from the set if present. Args: - val (int): Element to be removed. Returns: - bool: True if the element was successfully removed, False otherwise. if val in self.idxs: idx, last = self.idxs[val], self.nums[-1] self.nums[idx], self.idxs[last] = last, idx self.nums.pop() self.idxs.pop(val) return True return False def get_random(self) -> int: Returns a random element from the set. Returns: - int: A randomly selected element. idx = random.randint(0, len(self.nums) - 1) return self.nums[idx] ```","solution":"import random class RandomizedSet: def __init__(self): self.nums = [] self.idxs = {} def insert(self, val: int) -> bool: Inserts a value to the set if not already present. Args: - val (int): Element to be inserted. Returns: - bool: True if the element was successfully inserted, False otherwise. if val not in self.idxs: self.nums.append(val) self.idxs[val] = len(self.nums) - 1 return True return False def remove(self, val: int) -> bool: Removes a value from the set if present. Args: - val (int): Element to be removed. Returns: - bool: True if the element was successfully removed, False otherwise. if val in self.idxs: idx, last = self.idxs[val], self.nums[-1] self.nums[idx], self.idxs[last] = last, idx self.nums.pop() del self.idxs[val] return True return False def get_random(self) -> int: Returns a random element from the set. Returns: - int: A randomly selected element. idx = random.randint(0, len(self.nums) - 1) return self.nums[idx]"},{"question":"**Scenario**: You are tasked with improving the operation efficiency of a tree-based database index. The current binary search tree sometimes deteriorates to poor performance due to unbalanced inserts and deletes. You decide to implement an AVL tree to maintain balance and ensure logarithmic time complexity for operations. **Question**: Implement the core functionality of the AVL Tree data structure with the following methods: 1. `insert(key: int) -> None`: Inserts a new key into the AVL tree. 2. `delete(key: int) -> None`: Deletes a key from the AVL tree. 3. `search(key: int) -> bool`: Returns whether a key exists in the AVL tree. 4. `in_order_traverse() -> List[int]`: Returns the keys in the AVL tree in in-order traversal. *Expected Input and Output*: - For `insert`, the input is a single integer `key`. No output is expected. - For `delete`, the input is a single integer `key`. No output is expected. - For `search`, the input is a single integer `key`, and the output is `True` if the key exists, otherwise `False`. - For `in_order_traverse`, the output is a list of integers representing the keys in in-order traversal. *Constraints*: - Keys are unique integers. - Your implementation must handle the tree being empty and perform balancing correctly after insertions and deletions. - Aim for ensuring the operations maintain their logarithmic time complexity. ```python class AvlTree(object): Complete the AVL Tree with the required methods def __init__(self): # Initialization code here pass def insert(self, key: int) -> None: # Insertion logic here pass def delete(self, key: int) -> None: # Deletion logic here pass def search(self, key: int) -> bool: # Searching logic here return False def in_order_traverse(self) -> list: # In-order traversal logic here return [] # You may define additional helper methods as needed. ```","solution":"class AvlTree(object): class Node: def __init__(self, key): self.key = key self.left = None self.right = None self.height = 1 def __init__(self): self.root = None def _get_height(self, node): if not node: return 0 return node.height def _get_balance(self, node): if not node: return 0 return self._get_height(node.left) - self._get_height(node.right) def _right_rotate(self, y): x = y.left T2 = x.right x.right = y y.left = T2 y.height = max(self._get_height(y.left), self._get_height(y.right)) + 1 x.height = max(self._get_height(x.left), self._get_height(x.right)) + 1 return x def _left_rotate(self, x): y = x.right T2 = y.left y.left = x x.right = T2 x.height = max(self._get_height(x.left), self._get_height(x.right)) + 1 y.height = max(self._get_height(y.left), self._get_height(y.right)) + 1 return y def _insert(self, node, key): if not node: return self.Node(key) if key < node.key: node.left = self._insert(node.left, key) else: node.right = self._insert(node.right, key) node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) balance = self._get_balance(node) if balance > 1 and key < node.left.key: return self._right_rotate(node) if balance < -1 and key > node.right.key: return self._left_rotate(node) if balance > 1 and key > node.left.key: node.left = self._left_rotate(node.left) return self._right_rotate(node) if balance < -1 and key < node.right.key: node.right = self._right_rotate(node.right) return self._left_rotate(node) return node def insert(self, key: int) -> None: self.root = self._insert(self.root, key) def _min_value_node(self, node): if node is None or node.left is None: return node return self._min_value_node(node.left) def _delete(self, root, key): if not root: return root if key < root.key: root.left = self._delete(root.left, key) elif key > root.key: root.right = self._delete(root.right, key) else: if root.left is None: return root.right elif root.right is None: return root.left temp = self._min_value_node(root.right) root.key = temp.key root.right = self._delete(root.right, temp.key) if root is None: return root root.height = 1 + max(self._get_height(root.left), self._get_height(root.right)) balance = self._get_balance(root) if balance > 1 and self._get_balance(root.left) >= 0: return self._right_rotate(root) if balance > 1 and self._get_balance(root.left) < 0: root.left = self._left_rotate(root.left) return self._right_rotate(root) if balance < -1 and self._get_balance(root.right) <= 0: return self._left_rotate(root) if balance < -1 and self._get_balance(root.right) > 0: root.right = self._right_rotate(root.right) return self._left_rotate(root) return root def delete(self, key: int) -> None: self.root = self._delete(self.root, key) def _search(self, node, key): if node is None or node.key == key: return node if key < node.key: return self._search(node.left, key) return self._search(node.right, key) def search(self, key: int) -> bool: return self._search(self.root, key) is not None def _in_order_traverse(self, node, res): if node is not None: self._in_order_traverse(node.left, res) res.append(node.key) self._in_order_traverse(node.right, res) def in_order_traverse(self) -> list: res = [] self._in_order_traverse(self.root, res) return res"},{"question":"# Coding Challenge You are given a sorted array of integers and a new integer `val` that needs to be inserted into the array. The aim is to maintain the sorted order after the insertion. Write a function `insertion_sort_with_search(array, val)` that returns a new sorted array with `val` inserted in its correct position using the helper function provided. Function Signature: ```python def insertion_sort_with_search(array: List[int], val: int) -> List[int]: pass ``` Input: * `array`: A list of integers, `[a1, a2, ..., an]`, sorted in non-decreasing order. Constraints: `1 <= len(array) <= 10^4`, `-10^6 <= array[i] <= 10^6` * `val`: An integer `v`, `-10^6 <= v <= 10^6` Output: * A new list of integers with `val` inserted in its correct position maintaining sorted order. Example: ```plaintext insertion_sort_with_search([1, 3, 5, 6], 2) -> [1, 2, 3, 5, 6] insertion_sort_with_search([1, 3, 5, 6], 5) -> [1, 3, 5, 5, 6] insertion_sort_with_search([1, 3, 5, 6], 7) -> [1, 3, 5, 6, 7] insertion_sort_with_search([1, 3, 5, 6], 0) -> [0, 1, 3, 5, 6] ``` Constraints: * You should not use any built-in sorting methods. * The implementation should leverage the helper function `search_insert` to determine the insertion point.","solution":"from typing import List def search_insert(array: List[int], val: int) -> int: Helper function to find the index at which val should be inserted to maintain sorted order. left, right = 0, len(array) - 1 while left <= right: mid = left + (right - left) // 2 if array[mid] == val: return mid elif array[mid] < val: left = mid + 1 else: right = mid - 1 return left def insertion_sort_with_search(array: List[int], val: int) -> List[int]: Returns a new sorted array with val inserted in the correct position. insert_pos = search_insert(array, val) return array[:insert_pos] + [val] + array[insert_pos:]"},{"question":"# Question: Implement Advanced Operations on a Binary Heap You are given the implementation of a Binary Heap class that supports basic operations such as insertion and removal of the minimum element. Your task is to enhance this class by implementing additional functionalities to further utilize the heap properties. Functionality to Implement: 1. **find_min()**: Return the minimum element without removing it. 2. **build_heap(lst)**: Build a heap from an initial list of integers. 3. **kth_smallest_element(k)**: Return the k-th smallest element in the heap without altering the heap structure. Function Definitions - **find_min(self) -> int**: This function should return the smallest element in the heap in O(1) time. If the heap is empty, raise an appropriate exception. - **build_heap(self, lst: List[int]) -> None**: This function should convert a given list into a valid binary heap in O(N) time. - **kth_smallest_element(self, k: int) -> int**: Given an integer k, this function should return the k-th smallest element of the heap in O(k log N) time without modifying the heap contents. If k is larger than the number of elements in the heap, raise an appropriate exception. Constraints: - 1 <= k <= N where N is the number of elements in the heap. - The given list \\"lst\\" for building the heap will contain integers in the range [-10^6, 10^6] and can be of maximum length 10^4. - The heap initially does not contain any elements when `build_heap` is called. Example Usage: ```python heap = BinaryHeap() heap.build_heap([7, 12, 11, 5, 6, 2, 8, 9]) print(heap.find_min()) # Output: 2 print(heap.kth_smallest_element(3)) # Output: 6 ``` Implement the required functions in the `BinaryHeap` class.","solution":"import heapq class BinaryHeap: def __init__(self): self.heap = [] def insert(self, x): heapq.heappush(self.heap, x) def remove_min(self): if not self.heap: raise IndexError(\\"remove_min(): heap is empty\\") return heapq.heappop(self.heap) def find_min(self): if not self.heap: raise IndexError(\\"find_min(): heap is empty\\") return self.heap[0] def build_heap(self, lst): self.heap = lst[:] heapq.heapify(self.heap) def kth_smallest_element(self, k): if k < 1 or k > len(self.heap): raise IndexError(\\"kth_smallest_element(): k is out of bounds\\") # Use a temporary heap to extract the k-th smallest element temp_heap = self.heap[:] kth_smallest = None for _ in range(k): kth_smallest = heapq.heappop(temp_heap) return kth_smallest"},{"question":"You are given a directed graph represented by an adjacency list and two nodes, `start` and `end`. Your task is to write a Python function that returns the longest path between these two nodes. If no path exists, it should return an empty list. # Function Signature ```python def find_longest_path(graph: Dict[int, List[int]], start: int, end: int) -> List[int]: ``` # Input * `graph`: A dictionary representing the adjacency list of the graph. Keys are node identifiers (integers), and values are lists of neighboring node identifiers. * `start` (int): The starting node identifier. * `end` (int): The ending node identifier. # Output * A list of node identifiers that represents the longest path from `start` to `end`. If no path exists, return an empty list. # Constraints * The graph will have at least one node and at most 1000 nodes with corresponding edges. * The nodes will be represented by unique integers. * The graph can contain cycles. * 1 ≤ number of nodes ≤ 1000 # Example ```python graph = { 1: [2, 3], 2: [3, 4], 3: [4], 4: [] } start = 1 end = 4 # Example call print(find_longest_path(graph, start, end)) # Output: [1, 2, 3, 4] ``` # Notes * Ensure that your solution efficiently handles graphs containing cycles. * Provide an explanation of your approach and the time complexity of your solution.","solution":"def find_longest_path(graph, start, end): Find and return the longest path from start to end in the directed graph. If no path exists, return an empty list. def dfs(node, visited): if node == end: return [node] if node in visited: return None visited.add(node) longest_path = None for neighbor in graph.get(node, []): path = dfs(neighbor, visited) if path: path = [node] + path if (longest_path is None) or (len(path) > len(longest_path)): longest_path = path visited.remove(node) return longest_path return dfs(start, set()) or []"},{"question":"**Title: Pattern and String Bijective Mapping Checker** **Objective:** Write a function that checks if a given string follows the same pattern, ensuring a bijection between characters of the pattern and non-empty substrings of the string. **Problem Description:** Given a pattern and a string, determine if the string can be split such that each character in the pattern maps to exactly one unique substring of the string, and vice versa. **Function Signature:** ```python def pattern_match(pattern: str, string: str) -> bool: :param pattern: A string representing the pattern. Each character represents a unique segment. :param string: A string representing the target string to be split according to the pattern. :return: Boolean value. True if there exists a bijection between the pattern and the string segments; False otherwise. ``` **Input and Output constraints:** - Assume both pattern and string consist only of lowercase English letters. - The input strings `pattern` and `string` have lengths between 1 and 1000. - The function should return `True` if the pattern matches the string as described, otherwise `False`. **Examples:** 1. `pattern = \\"abab\\", string = \\"redblueredblue\\"` should return `True`. 2. `pattern = \\"aaaa\\", string = \\"asdasdasdasd\\"` should return `True`. 3. `pattern = \\"aabb\\", string = \\"xyzabcxzyabc\\"` should return `False`. **Constraints:** - Each character in the pattern must map to a non-empty substring in the string. - The bijection must be one-to-one. **Edge Cases:** - Consider scenarios where the pattern or string is empty. - Handle situations where the pattern length is greater than the string length efficiently. **Implementation Note:** Implement the function using a recursive backtracking approach. Use a dictionary to keep track of current mappings of pattern characters to string substrings. Ensure to check and update these mappings correctly as you iterate through possible substring splits.","solution":"def pattern_match(pattern, string): def backtrack(p_index, s_index, p_to_s_map, s_to_p_map): if p_index == len(pattern) and s_index == len(string): return True if p_index >= len(pattern) or s_index >= len(string): return False pattern_char = pattern[p_index] for end_index in range(s_index + 1, len(string) + 1): sub = string[s_index:end_index] if pattern_char in p_to_s_map: if p_to_s_map[pattern_char] == sub: if backtrack(p_index + 1, s_index + len(sub), p_to_s_map, s_to_p_map): return True elif sub not in s_to_p_map: p_to_s_map[pattern_char] = sub s_to_p_map[sub] = pattern_char if backtrack(p_index + 1, s_index + len(sub), p_to_s_map, s_to_p_map): return True del p_to_s_map[pattern_char] del s_to_p_map[sub] return False return backtrack(0, 0, {}, {}) # Example test cases print(pattern_match(\\"abab\\", \\"redblueredblue\\")) # True print(pattern_match(\\"aaaa\\", \\"asdasdasdasd\\")) # True print(pattern_match(\\"aabb\\", \\"xyzabcxzyabc\\")) # False"},{"question":"# Task You are required to implement a `CustomResizableHashTable` class that extends the given `HashTable` class. Your implementation must include the following extensions: 1. **Quadratic Probing**: Implement quadratic probing for collision resolution instead of linear probing. 2. **Custom Resizing Strategy**: Double the size of the hash table if the load factor exceeds 0.7, and reduce the size of the hash table by half if the load factor falls below 0.2, ensuring the size does not fall below the initial size. 3. **Dynamic Hash Function**: Use a better hashing function to handle a varied range of possible keys. # Input and Output * **Input**: The input will be provided as a series of operations on the `CustomResizableHashTable` class. * **Output**: The output should reflect the state of the hash table after each operation (if applicable) or the result of retrieval operations. # Function Signature ```python class CustomResizableHashTable(HashTable): def put(self, key, value): # your code here def get(self, key): # your code here def del_(self, key): # your code here def hash(self, key): # your code here def _rehash(self, old_hash, attempt): # your code here def __resize(self, new_size): # your code here ``` # Example ```python ht = CustomResizableHashTable() ht.put(1, \'A\') ht.put(12, \'B\') # This should trigger quadratic probing assert ht.get(1) == \'A\' assert ht.get(12) == \'B\' ht.put(23, \'C\') assert ht.get(23) == \'C\' ht.del_(12) assert ht.get(12) == None ``` # Constraints * Keys are integers. * Values can be of any type. * Initial size of the hash table should be 8. # Performance Requirements Your implementation should ensure efficient average-case operations for insertion, deletion, and lookup, and adapt to changes dynamically to maintain performance.","solution":"class CustomResizableHashTable: def __init__(self, initial_size=8): self.size = initial_size self.count = 0 self.table = [None] * self.size self.load_factor_threshold_expand = 0.7 self.load_factor_threshold_shrink = 0.2 self.initial_size = initial_size def hash(self, key): # Using a more sophisticated hash function return (key * 2654435761) % self.size def _rehash(self, old_hash, attempt): # Implementing quadratic probing return (old_hash + attempt + attempt**2) % self.size def put(self, key, value): if (self.count / self.size) > self.load_factor_threshold_expand: self.__resize(self.size * 2) idx = self.hash(key) attempt = 0 while self.table[idx] is not None and self.table[idx][0] != key: attempt += 1 idx = self._rehash(idx, attempt) if self.table[idx] is None: self.count += 1 self.table[idx] = (key, value) def get(self, key): idx = self.hash(key) attempt = 0 while self.table[idx] is not None: if self.table[idx][0] == key: return self.table[idx][1] attempt += 1 idx = self._rehash(idx, attempt) return None def del_(self, key): idx = self.hash(key) attempt = 0 while self.table[idx] is not None: if self.table[idx][0] == key: self.table[idx] = None self.count -= 1 break attempt += 1 idx = self._rehash(idx, attempt) if (self.count / self.size) < self.load_factor_threshold_shrink and self.size > self.initial_size: self.__resize(max(self.size // 2, self.initial_size)) def __resize(self, new_size): old_table = self.table self.size = new_size self.count = 0 self.table = [None] * self.size for item in old_table: if item is not None: self.put(item[0], item[1])"},{"question":"# Reversing a String using Different Algorithms Problem Statement You are provided with four different methods for reversing a string: recursive, iterative, pythonic, and ultra pythonic. You need to implement the following Python function that takes a string `s` as input and uses all these methods to reverse the string. Function Signature ```python def reverse_string(s: str) -> dict: This function takes a string s and returns a dictionary with the reversed string obtained by different algorithms. The dictionary should have the following structure: { \\"recursive\\": <reversed_string_by_recursive>, \\"iterative\\": <reversed_string_by_iterative>, \\"pythonic\\": <reversed_string_by_pythonic>, \\"ultra_pythonic\\": <reversed_string_by_ultra_pythonic> } pass ``` Constraints * Strings will only contain printable ASCII characters. * The maximum length of `s` is 10^5 characters. * Avoid using any library functions other than those used in the description (e.g., `reversed` in pythonic). Example Usage ```python reverse_string(\'hello\') # Output: # { # \\"recursive\\": \\"olleh\\", # \\"iterative\\": \\"olleh\\", # \\"pythonic\\": \\"olleh\\", # \\"ultra_pythonic\\": \\"olleh\\" # } ``` Implement the individual string reversal methods as outlined in the provided code snippets, and aggregate the results into a dictionary as specified. Ensure your solution handles edge cases such as: * Empty string * Strings with spaces or special characters * Strings with maximum length constraints effectively Performance Requirements: * The function should execute within the constraints for strings up to a length of 10^5 efficiently.","solution":"def reverse_recursive(s: str) -> str: if len(s) == 0: return s else: return s[-1] + reverse_recursive(s[:-1]) def reverse_iterative(s: str) -> str: reversed_s = [] for char in s: reversed_s.insert(0, char) return \'\'.join(reversed_s) def reverse_pythonic(s: str) -> str: return \'\'.join(reversed(s)) def reverse_ultra_pythonic(s: str) -> str: return s[::-1] def reverse_string(s: str) -> dict: return { \\"recursive\\": reverse_recursive(s), \\"iterative\\": reverse_iterative(s), \\"pythonic\\": reverse_pythonic(s), \\"ultra_pythonic\\": reverse_ultra_pythonic(s) }"},{"question":"# Euler\'s Totient Function Advanced Application **Objective**: Implement a function to find the least common multiple (LCM) of all numbers from 1 to `n`, and use Euler\'s Totient Function within your implementation. **Problem Statement**: Given an integer `n`, write a function `lcm_of_numbers(upto_n: int) -> int` that computes the least common multiple (LCM) of all integers from 1 to `n`. To help with this, also write a helper function `euler_totient(x: int) -> int` to compute Euler\'s Totient Function, which will be used within the LCM calculation. # Input * An integer `n` (1 ≤ n ≤ 10^6). # Output * An integer which is the LCM of all integers from 1 to `n`. # Constraints * Calculations beyond standard integer ranges should take care of overflow issues. * Efficient use of Euler\'s Totient Function is expected for large `n`. # Performance Requirement Implement an efficient solution that should not exceed O(n log log n) complexity overall by leveraging the properties of both LCM and Euler\'s Totient function. # Example Input ```python 5 ``` Output ```python 60 ``` Explanation The LCM of numbers from 1 to 5 is calculated as: * LCM(1, 2, 3, 4, 5) = 60. # Notes 1. You need to handle the large result computation without overflowing. 2. Euler\'s Totient Function will assist in efficiently determining the necessary multiplicative relations.","solution":"from math import gcd from functools import reduce from sympy.ntheory import totient def lcm(a, b): Helper function to compute LCM of two numbers a and b. return a * b // gcd(a, b) def lcm_of_numbers(upto_n): Compute the least common multiple (LCM) of all integers from 1 to upto_n. return reduce(lcm, range(1, upto_n + 1))"},{"question":"**Context**: You are developing a security system simulation for a smart city project. One of the critical features is optimizing the monitoring of house robberies, considering that adjacent houses cannot both be broken into on the same night due to a connected security system. Your task is to implement this optimization feature. **Problem Statement**: Write a function `max_robbery(houses)` that determines the maximum amount of money you can rob tonight without alerting the police. Each house\'s money value is provided in an array, where each element represents the amount of money stashed in each house. You cannot break into two adjacent houses on the same night. **Input**: * A list `houses` of non-negative integers, where `houses[i]` is the amount of money in the i-th house. **Output**: * An integer representing the maximum amount of money that can be robbed without alerting the police. **Constraints**: * The length of the list `houses` is at most 10^4. * Each value in `houses` is between 0 and 10^4, inclusive. **Example**: ```python def max_robbery(houses): last, now = 0, 0 for house in houses: last, now = now, max(last + house, now) return now # Example Usage: print(max_robbery([2, 7, 9, 3, 1])) # Output: 12 print(max_robbery([1, 2, 3, 1])) # Output: 4 print(max_robbery([0])) # Output: 0 ``` **Explanation**: * In the first example, the maximum money that can be robbed is by robbing the first, third, and fifth houses (2 + 9 + 1 = 12). * In the second example, the optimal solution is to rob the second and fourth houses (2 + 2 = 4). * In the third example, there\'s only one house with 0 money, so the answer is 0. **Special Notes**: - Ensure that your implementation runs efficiently for large input sizes. - Consider edge cases such as an empty list or a list with one house.","solution":"def max_robbery(houses): Determines the maximum amount of money you can rob tonight without alerting the police. last, now = 0, 0 for house in houses: last, now = now, max(last + house, now) return now"},{"question":"You are provided with an implementation of a Markov chain as described. Markov chain models can be extremely powerful for predicting sequences of events, but they often need enhancements based on practical requirements. Your task is to extend the functionality of the given Markov chain model by implementing the following feature: # Task: Implement a function `limited_iterating_markov_chain(chain, state, limit)` that generates a sequence of states, but only for a specified number of transitions, `limit`. This function should yield each state in the sequence up to the defined limit. # Function Signature ```python def limited_iterating_markov_chain(chain: dict, state: str, limit: int) -> list: pass ``` # Input * **chain**: A dictionary representing the Markov chain, where keys are state names and values are dictionaries that map to possible next states and their respective transition probabilities. * **state**: A string representing the initial state. * **limit**: An integer representing the number of transitions to generate. # Output * A list of states, representing the sequence of `limit` states starting from the initial state. # Constraints 1. The sum of transition probabilities for each state always equals 1. 2. The number of transitions is a positive integer (1 ≤ limit ≤ 10^5). 3. State names are strings, transition probabilities are floating-point numbers between 0 and 1. # Example Given the following Markov chain: ```python chain = { \'A\': {\'A\': 0.6, \'B\': 0.4}, \'B\': {\'A\': 0.2, \'B\': 0.8} } ``` Starting from state \'A\' and with a limit of 3, an example sequence might look like: ```python limited_iterating_markov_chain(chain, \'A\', 3) ``` Possible output: ```python [\'A\', \'B\', \'B\'] ``` **Note**: The output may vary since state transitions are probabilistic. # Assessment Criteria Your solution will be evaluated on: * Correctness: The function should accurately implement the described behavior. * Efficiency: The solution should handle large inputs within reasonable time constraints. * Handling of edge cases: Properly consider and manage edge cases and invalid inputs. Please write your implementation in the function `limited_iterating_markov_chain`.","solution":"import random def limited_iterating_markov_chain(chain, state, limit): Generates a sequence of states using a Markov chain for a specified number of transitions. Args: chain (dict): A dictionary representing the Markov chain. state (str): The initial state. limit (int): The number of transitions to generate. Returns: list: A list of states representing the sequence of states. if limit < 1: return [] states = [state] current_state = state for _ in range(limit): next_state = random.choices( population=list(chain[current_state].keys()), weights=list(chain[current_state].values()) )[0] states.append(next_state) current_state = next_state return states"},{"question":"You are provided with a singly linked list where each node contains an integer. You need to develop a function to remove a consecutive range of nodes from the list. Your function should remove nodes between the start index and end index (inclusive). # Function Signature ```python def remove_range(head, start, end): Removes nodes from indices start to end (inclusive) in the linked list. :param head: ListNode | The first node of the linked list :param start: int | The starting index (inclusive) of the range to remove :param end: int | The ending index (inclusive) of the range to remove :return: ListNode | The head node of the modified linked list ``` # Input 1. `head`: The head node of the singly linked list where each node has the structure `class ListNode` with two attributes - `val` (int) and `next` (ListNode/null). 2. `start`: An integer representing the starting index of the range (inclusive). 3. `end`: An integer representing the ending index of the range (inclusive). # Output * Return the head of the modified linked list after removing the specified range of nodes. # Constraints * 0 ≤ start ≤ end < size of the linked list. * The input list will contain at least one element. * The function should modify the list in place, maintaining any nodes not within the specified range. # Example Input: ``` List: [8, 13, 17, 4, 9, 12, 98, 41, 7, 23, 0, 92] start: 3 end: 8 ``` Output: ``` List: [8, 13, 17, 23, 0, 92] ``` # Additional Information 1. The given list is referenced by its head node. 2. Indices start from 0. # Implementation Notes Your solution should ensure optimized execution and handle edge cases like the range including the head of the linked list or the range extending to the last elements of the list.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def remove_range(head, start, end): Removes nodes from indices start to end (inclusive) in the linked list. :param head: ListNode | The first node of the linked list :param start: int | The starting index (inclusive) of the range to remove :param end: int | The ending index (inclusive) of the range to remove :return: ListNode | The head node of the modified linked list if start == 0: for _ in range(end - start + 1): head = head.next return head dummy = ListNode(0) dummy.next = head current = dummy for i in range(start): current = current.next range_end = current.next for i in range(end - start + 1): range_end = range_end.next current.next = range_end return dummy.next"},{"question":"# Objective Implement a resizable separate chaining hash table. This hash table should be capable of automatically resizing itself to maintain performance as more elements are added. # Problem Statement Design and implement a class called `ResizableSeparateChainingHashTable` that uses separate chaining to resolve collisions and dynamically resizes the table to maintain efficient operations. # Your Task Implement the `ResizableSeparateChainingHashTable` with the following functionalities: 1. `put(key, value)`: Insert the key-value pair into the hash table. If the key already exists, update the value. 2. `get(key)`: Retrieve the value associated with the key. Return `None` if the key does not exist. 3. `del_(key)`: Delete the key-value pair from the hash table if it exists. 4. Ensure that the table resizes (doubles in size) when the load factor (number of elements/size of table) exceeds 0.7. 5. Ensure that the table resizes (halves in size) when the load factor drops below 0.2. # Constraints & Requirements 1. Implement a `resize()` method that handles the resizing operation. 2. Handle all edge cases gracefully, such as non-existent keys for get and delete operations. 3. Optimize for performance and ensure average case O(1) operations. 4. The hash table should support dynamic insertion/updating, retrieval, and deletion of key-value pairs. # Example ```python # Initialize the hash table hash_table = ResizableSeparateChainingHashTable() # Put some key-value pairs hash_table.put(\'apple\', \'fruit\') hash_table.put(\'carrot\', \'vegetable\') # Retrieve values assert hash_table.get(\'apple\') == \'fruit\' assert hash_table.get(\'carrot\') == \'vegetable\' assert hash_table.get(\'banana\') is None # Update an existing key hash_table.put(\'apple\', \'green fruit\') assert hash_table.get(\'apple\') == \'green fruit\' # Delete a key hash_table.del_(\'carrot\') assert hash_table.get(\'carrot\') is None # Insert more elements to trigger resizing for i in range(20): hash_table.put(f\'key{i}\', f\'value{i}\') print(\\"All tests passed!\\") ``` # Performance Requirements - The class should ensure average O(1) time complexity for the put, get, and delete operations. - The resizing operation should be efficient and rehash all keys into the new table.","solution":"class Node: A node to store key-value pairs in the separate chaining linked list def __init__(self, key, value): self.key = key self.value = value self.next = None class ResizableSeparateChainingHashTable: def __init__(self, initial_size=8): self.table = [None] * initial_size self.size = 0 self.capacity = initial_size def _hash(self, key): return hash(key) % self.capacity def _resize(self, new_capacity): old_table = self.table self.table = [None] * new_capacity self.capacity = new_capacity self.size = 0 # reset size and rehash elements for head in old_table: while head: self.put(head.key, head.value) head = head.next def put(self, key, value): if self.size / self.capacity >= 0.7: self._resize(2 * self.capacity) index = self._hash(key) head = self.table[index] # Check if key exists and update while head: if head.key == key: head.value = value return head = head.next # Insert new key-value pair new_node = Node(key, value) new_node.next = self.table[index] self.table[index] = new_node self.size += 1 def get(self, key): index = self._hash(key) head = self.table[index] while head: if head.key == key: return head.value head = head.next return None def del_(self, key): index = self._hash(key) head = self.table[index] prev = None while head: if head.key == key: if prev: prev.next = head.next else: self.table[index] = head.next self.size -= 1 if self.capacity > 8 and self.size / self.capacity <= 0.2: self._resize(self.capacity // 2) return prev = head head = head.next return None # Key not found"},{"question":"**Scenario:** You are given a list of jobs where each job is represented by a start time, finish time, and profit. Your task is to maximize the total profit by selecting a subset of non-overlapping jobs. **Challenge:** Write a Python function `max_profit(jobs)` which takes a list of jobs as input and returns the maximum profit achievable. Each job should be represented as a dictionary with `start`, `finish`, and `profit` keys. **Function Signature:** ```python def max_profit(jobs: List[Dict[str, int]]) -> int: ``` **Input:** - `jobs`: A list of dictionaries where each dictionary contains: * `start` (int): the start time of the job. * `finish` (int): the finish time of the job. * `profit` (int): the profit of the job. **Output:** - Returns an integer representing the maximum profit achievable from the given jobs. **Constraints:** - (1 leq text{len(jobs)} leq 10^4) - (0 leq text{start}, text{finish}, text{profit} leq 10^6) **Example:** ```python jobs = [ {\\"start\\": 1, \\"finish\\": 3, \\"profit\\": 50}, {\\"start\\": 3, \\"finish\\": 5, \\"profit\\": 20}, {\\"start\\": 0, \\"finish\\": 6, \\"profit\\": 60}, {\\"start\\": 4, \\"finish\\": 7, \\"profit\\": 30}, {\\"start\\": 5, \\"finish\\": 9, \\"profit\\": 50}, {\\"start\\": 6, \\"finish\\": 10, \\"profit\\": 40}, {\\"start\\": 8, \\"finish\\": 11, \\"profit\\": 70} ] assert max_profit(jobs) == 150 ``` **Notes:** - Assume that a job\'s `finish` time is always greater than its `start` time. - The input list is unsorted, you are required to sort it within the function. - You may use additional helper functions as needed.","solution":"from typing import List, Dict def max_profit(jobs: List[Dict[str, int]]) -> int: # Sort jobs based on finish time jobs.sort(key=lambda x: x[\'finish\']) # Function to find the last non-overlapping job def find_last_non_overlapping(jobs, i): for j in range(i - 1, -1, -1): if jobs[j][\'finish\'] <= jobs[i][\'start\']: return j return -1 # Create a DP array to store the maximum profit up to each job n = len(jobs) dp = [0] * n for i in range(n): # Including the current job\'s profit include_profit = jobs[i][\'profit\'] last_non_overlap = find_last_non_overlapping(jobs, i) if last_non_overlap != -1: include_profit += dp[last_non_overlap] # Max profit up to the current job dp[i] = max(include_profit, dp[i - 1] if i > 0 else 0) return dp[n - 1] if n > 0 else 0"},{"question":"# Unique Binary Search Trees Given `n`, you are required to count how many structurally unique Binary Search Trees (BSTs) store values 1 through `n`. **Function Signature:** ```python def num_trees(n: int) -> int: pass ``` **Input:** - An integer `n` representing the number of nodes (1 <= n <= 19). **Output:** - An integer representing the number of structurally unique BSTs that can be built using numbers from 1 to `n`. **Example:** ```plaintext >>> num_trees(3) 5 ``` **Explanation:** Given `n = 3`, there are 5 possible unique BSTs: ``` 1 3 3 2 1 / / / 3 2 1 1 3 2 / / 2 1 2 3 ``` **Requirements:** - Implement the function using a dynamic programming approach. - Ensure your solution handles edge cases like `n = 0` and `n = 1` correctly. - The solution must be efficient in terms of time and space complexity. **Additional Notes:** - Consider that for larger values of `n`, the solution should not exceed reasonable time limits in standard programming environments.","solution":"def num_trees(n: int) -> int: Function to count how many structurally unique BSTs store values 1 through `n`. if n == 0 or n == 1: return 1 # Initialize the list to store the number of unique BSTs dp = [0] * (n + 1) dp[0] = 1 dp[1] = 1 # Fill dp array for i in range(2, n + 1): for j in range(1, i + 1): dp[i] += dp[j - 1] * dp[i - j] return dp[n]"},{"question":"# KMP String Search Problem Given a text string `text` and a pattern string `pattern`, implement the Knuth-Morris-Pratt (KMP) algorithm to return the starting indices of all occurrences of `pattern` in `text`. Detailed Description: 1. **Create a Prefix Table**: - This table (also known as \\"partial match\\" table) will help indicate the next positions to compare after a mismatch has occurred. 2. **Search Using KMP**: - Utilize the prefix table to perform the searching, skipping unnecessary comparisons for faster results. Function Signature: ```python def knuth_morris_pratt(text: str, pattern: str) -> List[int]: Finds all occurrences of the pattern in the given text using the KMP algorithm. Args: text (str): The text to search within. pattern (str): The pattern to search for. Returns: List[int]: A list containing starting indices of each pattern match in the text. Example: >>> knuth_morris_pratt(\'hello there hero!\', \'he\') [0, 7, 12] ``` # Constraints: - `0 <= len(text) <= 10^6` - `0 <= len(pattern) <= 10^5` - The text and pattern will only consist of lowercase English letters. # Example Input/Output: 1. **Input**: - `text`: \'abababca\' - `pattern`: \'abca\' 2. **Output**: `[4]` 3. **Input**: - `text`: \'aaaa\' - `pattern`: \'aa\' 4. **Output**: `[0, 1, 2]` # Performance Requirements: - The solution should have a time complexity of O(N+M) and a space complexity closer to O(M). # Tips: - Carefully handle cases where the pattern is partially matched. - Verify the prefix table generation using smaller examples to ensure correctness. - Remember edge cases like empty text or pattern.","solution":"from typing import List def knuth_morris_pratt(text: str, pattern: str) -> List[int]: Finds all occurrences of the pattern in the given text using the KMP algorithm. Args: text (str): The text to search within. pattern (str): The pattern to search for. Returns: List[int]: A list containing starting indices of each pattern match in the text. if not text or not pattern: return [] # Step 1: Create the prefix table for the pattern def build_prefix_table(pattern: str) -> List[int]: m = len(pattern) prefix_table = [0] * m j = 0 # length of the previous longest prefix suffix for i in range(1, m): while (j > 0 and pattern[i] != pattern[j]): j = prefix_table[j - 1] if pattern[i] == pattern[j]: j += 1 prefix_table[i] = j else: prefix_table[i] = 0 return prefix_table # Step 2: Use the prefix table to search the pattern in the text def kmp_search(text: str, pattern: str) -> List[int]: n = len(text) m = len(pattern) prefix_table = build_prefix_table(pattern) result = [] j = 0 # index for pattern for i in range(n): # index for text while (j > 0 and text[i] != pattern[j]): j = prefix_table[j - 1] if text[i] == pattern[j]: j += 1 if j == m: result.append(i - m + 1) j = prefix_table[j - 1] return result return kmp_search(text, pattern)"},{"question":"# Linked List Intersection Finder You are given two singly linked lists that may, or may not, intersect at some point. Your task is to implement a function that determines the first common node (by reference) between the two lists. If there is no intersection, return `None`. Function Signature ```python def find_intersection(head1: Node, head2: Node) -> Node: ``` Inputs * `head1`: The head of the first linked list (`Node`). * `head2`: The head of the second linked list (`Node`). Output * The function should return the intersecting node (`Node`) or `None` if there is no intersection. Constraints * Each linked list node contains a unique reference, not just a value. * The lengths of the two lists can vary. * List nodes consist of an integer value and a next pointer to the next node in the list. Example * Given: ``` 1 -> 3 -> 5 7 -> 9 -> 11 / 2 -> 4 -> 6 ``` * The intersection node is `7`. Thus, `find_intersection(head1, head2).val` should return `7`. Notes 1. You must not change the structure of the input lists. 2. Aim for a solution that runs in linear time and uses constant space. # Write your function below: ```python class Node: def __init__(self, val=None): self.val = val self.next = None def find_intersection(head1: Node, head2: Node) -> Node: pass # Your implementation here # You can use this below main function for testing, it is not needed for final submission if __name__ == \'__main__\': # Linked list example for testing: # 1 -> 3 -> 5 # # 7 -> 9 -> 11 # / # 2 -> 4 -> 6 a1, a2 = Node(1), Node(2) b1, b2 = Node(3), Node(4) c1, c2 = Node(5), Node(6) d = Node(7) e = Node(9) f = Node(11) a1.next = b1 b1.next = c1 c1.next = d a2.next = b2 b2.next = c2 c2.next = d d.next = e e.next = f intersection_node = find_intersection(a1, a2) if intersection_node: print(intersection_node.val) else: print(\\"No intersection.\\") ``` Write your `find_intersection` function to complete the above implementation such that it passes the provided test scenario.","solution":"class Node: def __init__(self, val=None): self.val = val self.next = None def find_intersection(head1: Node, head2: Node) -> Node: # Helper function to get the length of the list def get_length(head): length = 0 current = head while current: length += 1 current = current.next return length # Calculate the lengths of both linked lists len1 = get_length(head1) len2 = get_length(head2) # Align the start positions for both linked lists cur1 = head1 cur2 = head2 if len1 > len2: for _ in range(len1 - len2): cur1 = cur1.next else: for _ in range(len2 - len1): cur2 = cur2.next # Traverse the lists together until an intersection is found while cur1 and cur2: if cur1 is cur2: return cur1 cur1 = cur1.next cur2 = cur2.next # No intersection found return None"},{"question":"# Question Consider the following scenario: You are working on a system to optimize data transmission over a network by analyzing binary representations of data packets. One key metric needed for this analysis is the Hamming weight of the packet data, i.e., the number of \'1\' bits in a binary number. Your task is to implement an efficient function to calculate the Hamming weight of a given unsigned integer using Brian Kernighan\'s Algorithm. You are required to implement both the recursive and iterative approaches without directly copying the provided example code. Function Signatures - Recursive approach: `def count_ones_recur(n: int) -> int:` - Iterative approach: `def count_ones_iter(n: int) -> int:` Input - An unsigned integer `n` where 0 <= n <= 2^31 - 1. Output - An integer representing the number of \'1\' bits in the binary representation of `n`. Constraints - You must use Brian Kernighan\'s Algorithm. - Avoid using Python\'s built-in functions like `bin()` to convert numbers to binary. Performance - For the recursive approach, ensure it efficiently handles cases with a large number of \'1\' bits. - For the iterative approach, strive for constant space complexity. Example: ```python assert count_ones_recur(11) == 3 # Binary: 1011 assert count_ones_recur(128) == 1 # Binary: 10000000 assert count_ones_iter(11) == 3 # Binary: 1011 assert count_ones_iter(128) == 1 # Binary: 10000000 assert count_ones_recur(0) == 0 # Binary: 0 assert count_ones_iter(0) == 0 # Binary: 0 ``` *Note*: Focus on ensuring your functions are well-optimized and handle edge cases correctly.","solution":"def count_ones_recur(n: int) -> int: Returns the number of \'1\' bits in the binary representation of n using Brian Kernighan\'s Algorithm recursively. if n == 0: return 0 return 1 + count_ones_recur(n & (n - 1)) def count_ones_iter(n: int) -> int: Returns the number of \'1\' bits in the binary representation of n using Brian Kernighan\'s Algorithm iteratively. count = 0 while n: n &= (n - 1) count += 1 return count"},{"question":"# Question **Scenario:** You are working as a software engineer on a large-scale data analytics platform that frequently processes vast amounts of sorted numerical data. One common task is to determine the frequency of specific values within these datasets. To optimize this, you need to efficiently locate the position of the last occurrence of any given query number. **Problem Statement:** Write a function `last_occurrence` that finds the index of the last occurrence of a given number in a sorted array of integers. The array is guaranteed to be sorted in increasing order. If the target number does not exist in the array, your function should return `-1`. **Function Signature:** ```python def last_occurrence(array: List[int], query: int) -> int: # Your code here ``` **Inputs:** * `array`: A list of integers (`List[int]`), sorted in increasing order. * `query`: An integer (`int`) representing the number you want to find the last occurrence of. **Outputs:** * Returns the index (`int`) of the last occurrence of `query` in the array, or `-1` if the query is not in the array. **Constraints:** * The length of the array can be as large as (10^6). * The elements in the array are within the range ([-10^9, 10^9]). * Efficient performance is critical due to potentially large input sizes. **Example:** ```python # Example 1: Standard Case array = [1, 2, 2, 2, 3, 4, 5] query = 2 print(last_occurrence(array, query)) # Expected Output: 3 (index of last 2) # Example 2: Element Not Present array = [1, 2, 3, 4, 5] query = 6 print(last_occurrence(array, query)) # Expected Output: -1 (6 not in array) # Example 3: Single Element Array array = [1] query = 1 print(last_occurrence(array, query)) # Expected Output: 0 (index of 1) # Example 4: Empty Array array = [] query = 1 print(last_occurrence(array, query)) # Expected Output: -1 (empty array) ```","solution":"from typing import List def last_occurrence(array: List[int], query: int) -> int: Returns the index of the last occurrence of query in array, or -1 if query is not in array. low, high = 0, len(array) - 1 result = -1 while low <= high: mid = (low + high) // 2 if array[mid] == query: result = mid low = mid + 1 # move right to find the last occurrence elif array[mid] < query: low = mid + 1 else: high = mid - 1 return result"},{"question":"# Question: Implement an Iterative Cooley-Tukey FFT Algorithm You are given a sequence of complex numbers of length N, where N is always a power of two. Implement an iterative version of the Cooley-Tukey FFT algorithm to compute the Discrete Fourier Transform (DFT) of the input sequence. # Function Signature: ```python def iterative_fft(x: List[complex]) -> List[complex]: pass ``` # Input - `x`: A list of complex numbers of size N, where N is a power of two. # Output - A list of complex numbers representing the DFT of the input sequence. # Constraints - `1 <= len(x) <= 2^20` (i.e., `x` can have up to 1,048,576 elements) # Example ```python assert iterative_fft([2.0+2j, 1.0+3j, 3.0+1j, 2.0+2j]) == [8+8j, 2j, 2-2j, -2+0j] ``` # Notes - Do **not** use the recursive approach shown in the provided code snippet. - Ensure your solution has a time complexity of O(N log N) and a space complexity of O(N). - You may use any libraries for complex number arithmetic, but the core algorithm must be implemented by you.","solution":"def iterative_fft(x): from cmath import exp, pi N = len(x) # Bit-reversal permutation def bit_reverse(a, n): result = 0 for i in range(n): if a & (1 << i): result |= 1 << (n - 1 - i) return result n = N.bit_length() - 1 X = [x[bit_reverse(i, n)] for i in range(N)] # Iterative Cooley-Tukey FFT m = 2 while m <= N: omega_m = exp(-2j * pi / m) for k in range(0, N, m): omega = 1 for j in range(m // 2): t = omega * X[k + j + m // 2] u = X[k + j] X[k + j] = u + t X[k + j + m // 2] = u - t omega *= omega_m m *= 2 return X"},{"question":"You are tasked with implementing the `modular_exponential` function used for cryptographic purposes in a secure messaging platform. The function will be used to compute large power values of numbers under a given modulus, ensuring that results do not overflow standard data types. Function Signature ```python def modular_exponential(base: int, exponent: int, mod: int) -> int: Computes (base ^ exponent) % mod with efficient handling of large numbers. Parameters: base (int): the base number, must be an integer. exponent (int): the exponent, must be a non-negative integer. mod (int): the modulus, must be a positive integer. Returns: int: result of (base ^ exponent) % mod computed efficiently. ``` Input * `base`: an integer representing the base (0 <= base <= 10^9). * `exponent`: a non-negative integer representing the exponent (0 <= exponent <= 10^9). * `mod`: a positive integer representing the modulus (1 <= mod <= 10^9). Output * Return an integer representing the result of `(base ^ exponent) % mod`. Constraints * The function should be highly efficient and capable of handling the largest inputs within a reasonable timeframe. * Ensure to account for edge cases, including zero exponents and bases. You may assume the inputs are valid integers within the specified ranges, but ensure to throw a `ValueError` for invalid exponents (e.g., negative integers). Example ```python print(modular_exponential(2, 10, 1000)) # Output: 24 print(modular_exponential(3, 200, 13)) # Output: 9 print(modular_exponential(10, 0, 7)) # Output: 1 print(modular_exponential(0, 0, 1)) # Output: 1 ``` Explanation 1. `modular_exponential(2, 10, 1000)` calculates to (2^10) % 1000 = 1024 % 1000 = 24. 2. `modular_exponential(3, 200, 13)` calculates to (3^200) % 13; through repeated squaring, the answer is derived to be 9. 3. `modular_exponential(10, 0, 7)` computes to 1 since any number to the power of zero is 1. 4. `modular_exponential(0, 0, 1)` traditionally computes to 1 for zero-based exponentiation context. Implement the function to meet the needs of time and space efficiency reflective of its use case in secure cryptographic systems.","solution":"def modular_exponential(base: int, exponent: int, mod: int) -> int: Computes (base ^ exponent) % mod with efficient handling of large numbers. Parameters: base (int): the base number, must be an integer. exponent (int): the exponent, must be a non-negative integer. mod (int): the modulus, must be a positive integer. Returns: int: result of (base ^ exponent) % mod computed efficiently. if exponent < 0: raise ValueError(\\"Exponent must be a non-negative integer\\") if mod <= 0: raise ValueError(\\"Modulus must be a positive integer\\") result = 1 base = base % mod while exponent > 0: if (exponent % 2) == 1: # If exponent is odd, multiply the current result with the base result = (result * base) % mod exponent = exponent >> 1 # Divide the exponent by 2 base = (base * base) % mod # Square the base return result"},{"question":"# Edit Distance Computation Problem Description You are given two strings, `str1` and `str2`. Your goal is to compute the minimum number of operations required to transform `str1` into `str2`. The only operations allowed are: 1. **Insertion** of a character. 2. **Deletion** of a character. 3. **Substitution** of one character for another. Write a function `min_edit_distance` that implements this algorithm using dynamic programming. Function Signature ```python def min_edit_distance(str1: str, str2: str) -> int: pass ``` Expected Input and Output * **Input**: - `str1` (a string of length n, 0 ≤ n ≤ 1000) - `str2` (a string of length m, 0 ≤ m ≤ 1000) * **Output**: - Return an integer representing the minimum number of operations required. Constraints * Treat an empty string as a valid input. * Consider the case sensitivity of the strings. Performance Requirements * Time Complexity: O(n * m) * Space Complexity: O(n * m) Example 1. **Input**: ```python str1 = \\"kitten\\" str2 = \\"sitting\\" ``` **Output**: `3` *Explanation*: - kitten -> sitten (substitution of \'s\' for \'k\') - sitten -> sittin (substitution of \'i\' for \'e\') - sittin -> sitting (insertion of \'g\') 2. **Input**: ```python str1 = \\"intention\\" str2 = \\"execution\\" ``` **Output**: `5` *Explanation*: - intention -> exention (substitution of \'e\' for \'i\') - exention -> exection (substitution of \'c\' for \'n\') - exection -> executon (substitution of \'u\' for \'o\') - executon -> execution (insertion of \'i\') ---","solution":"def min_edit_distance(str1: str, str2: str) -> int: n = len(str1) m = len(str2) # Create a table to store results of subproblems dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)] # Fill dp[][] in a bottom up manner for i in range(n + 1): for j in range(m + 1): # If first string is empty, only option is to # insert all characters of second string if i == 0: dp[i][j] = j # Min. operations = j # If second string is empty, only option is to # remove all characters of the first string elif j == 0: dp[i][j] = i # Min. operations = i # If last characters are the same, ignore last characters # and get count for the remaining strings. elif str1[i-1] == str2[j-1]: dp[i][j] = dp[i-1][j-1] # If last characters are different, consider all # possibilities and find the minimum else: dp[i][j] = 1 + min(dp[i][j-1], # Insert dp[i-1][j], # Remove dp[i-1][j-1]) # Replace return dp[n][m]"},{"question":"# Anagram Checker with Extended Functionality Problem Statement Write a function `is_anagram` that determines if two given strings are anagrams of each other. An anagram is a word formed by rearranging the letters of another word, using all the original letters exactly once. Your function should handle: - Mixed case letters (\'A\' is considered the same as \'a\'). - Non-alphabetical characters should be ignored. - Unicode characters should be considered in their lowercase form. Function Signature ```python def is_anagram(s1: str, s2: str) -> bool: ``` Input - `s1` (string): The first input string. - `s2` (string): The second input string. Output - (bool): Return `True` if `s1` and `s2` are anagrams, `False` otherwise. Constraints - The input strings can contain both alphabetical and non-alphabetical characters. - The input strings can contain Unicode characters. Examples ```python assert is_anagram(\\"apple\\", \\"Pleap\\") == True assert is_anagram(\\"apple!\\", \\"Elapp\\") == True assert is_anagram(\\"apple\\", \\"cherry\\") == False assert is_anagram(\\"abc\\", \\"bbc\\") == False assert is_anagram(\\"你好\\", \\"好你\\") == True ``` Hints - Normalize the strings by converting them to a consistent case (e.g., lowercase). - Use a dictionary or a set to count character frequencies, considering only alphabetical characters. - Think about how to handle and ignore non-alphabetical characters.","solution":"def is_anagram(s1: str, s2: str) -> bool: from collections import Counter import re # Normalize the strings by removing non-alphabet characters and converting to lowercase def normalize_string(s): return re.sub(r\'[^a-zA-Z0-9u4e00-u9fff]\', \'\', s).lower() s1_normalized = normalize_string(s1) s2_normalized = normalize_string(s2) # Use Counter to count character frequencies return Counter(s1_normalized) == Counter(s2_normalized)"},{"question":"# Scenario You are tasked with sorting an array representing scores from a game tournament. Given its simplicity and optimal performance on average, you decide to use Comb Sort for this purpose. Implement the Comb Sort algorithm keeping in mind the described principles and efficiently handle larger gaps to expedite sorting. # Task Write a function `comb_sort_scores` that sorts an array of integers using the Comb Sort algorithm. Ensure that the function takes an array of integers as input and returns a sorted array. # Function Signature ```python def comb_sort_scores(arr: List[int]) -> List[int]: ``` # Input * `arr`: A list of integers representing the scores to be sorted. The list can be of any length, including zero. # Output * A list of integers sorted in non-decreasing order. # Constraints * The function should sort the array in-place. * The function should handle all edge cases gracefully (e.g., empty list, list with one element, list with all equal elements). # Example ```python # Example 1 input_array = [5, 3, 8, 4, 2] sorted_array = comb_sort_scores(input_array) print(sorted_array) # Output: [2, 3, 4, 5, 8] # Example 2 input_array = [20, 10, 30, 50, 40] sorted_array = comb_sort_scores(input_array) print(sorted_array) # Output: [10, 20, 30, 40, 50] # Example 3 input_array = [] sorted_array = comb_sort_scores(input_array) print(sorted_array) # Output: [] ``` # Notes * Avoid using any built-in sort functions. * Aim to maintain the average time complexity performance by carefully managing gap reduction and swaps.","solution":"from typing import List def comb_sort_scores(arr: List[int]) -> List[int]: def get_next_gap(gap: int) -> int: # Shrink gap by shrink factor (1.3) gap = int(gap / 1.3) if gap < 1: return 1 return gap n = len(arr) gap = n swapped = True while gap != 1 or swapped: gap = get_next_gap(gap) swapped = False for i in range(n - gap): if arr[i] > arr[i + gap]: arr[i], arr[i + gap] = arr[i + gap], arr[i] swapped = True return arr"},{"question":"# Coding Problem: Custom Exchange Sort with Edge Cases Problem Statement: You are given an array of integers. Implement a function that sorts the array using a custom version of the exchange sort algorithm. This custom version should handle various edge cases, such as arrays with duplicate elements, single-element arrays, and already sorted arrays. Additionally, your implementation should report if no swaps were made for an already sorted array. Function Signature: ```python def custom_exchange_sort(arr: List[int]) -> Tuple[List[int], bool]: pass ``` Input: * A list `arr` of integers, where ( 0 leq text{len}(arr) leq 1000 ). * The integers within the array can range from (-10^6) to (10^6). Output: * A tuple where: * The first element is the sorted list. * The second element is a boolean indicating if the array was already sorted in non-decreasing order (True if no swaps were made, False otherwise). Constraints: * You must use the exchange sort algorithm as described. * Do not use built-in sort functions. * Try to be mindful of edge cases and efficient use of memory. Example: ```python assert custom_exchange_sort([3, 1, 4, 1, 5]) == ([1, 1, 3, 4, 5], False) assert custom_exchange_sort([1, 2, 3, 4, 5]) == ([1, 2, 3, 4, 5], True) assert custom_exchange_sort([5, 4, 3, 2, 1]) == ([1, 2, 3, 4, 5], False) assert custom_exchange_sort([]) == ([], True) assert custom_exchange_sort([42]) == ([42], True) assert custom_exchange_sort([3, 3, 2, 2, 1, 1]) == ([1, 1, 2, 2, 3, 3], False) ```","solution":"from typing import List, Tuple def custom_exchange_sort(arr: List[int]) -> Tuple[List[int], bool]: Sorts the array using the exchange sort algorithm and checks if the array was already sorted in non-decreasing order. n = len(arr) if n <= 1: return arr, True # An empty array or single-element array is trivially sorted is_sorted = True # Assume the array is sorted until proven otherwise for i in range(n-1): for j in range(i+1, n): if arr[i] > arr[j]: arr[i], arr[j] = arr[j], arr[i] is_sorted = False # Found at least one swap, so it\'s not sorted initially return arr, is_sorted"},{"question":"# **Coding Assessment Question: Lowest Common Ancestor in a Binary Tree** Objective Implement a function to determine the Lowest Common Ancestor (LCA) of two given nodes in a binary tree. The task will assess your understanding of depth-first search and tree-based recursion. Description Given the root of a binary tree and two nodes, `p` and `q`, write a function `findLCA` to find and return their LCA. A node is considered a descendant of itself. Function Signature ```python def findLCA(root: Optional[TreeNode], p: TreeNode, q: TreeNode) -> Optional[TreeNode]: pass ``` Input * `root` (Optional[TreeNode]): The root of the binary tree. * `p` (TreeNode): The first target node. * `q` (TreeNode): The second target node. Output * (Optional[TreeNode]): The lowest common ancestor of nodes `p` and `q`. Constraints * The number of nodes in the tree ranges from 0 to 10^4. * All TreeNode values are unique. * `p`, `q` are different and both values exist in the binary tree. Example ``` Input: root: [3, 5, 1, 6, 2, 0, 8, null, null, 7, 4] p: 5 q: 1 Output: 3 Explanation: The LCA of nodes 5 and 1 is node 3. ``` Performance Requirements * Time complexity should be O(N), where N is the number of nodes in the tree. * Space complexity should be O(H), where H is the height of the tree. Hints * Consider using a recursive approach to solve this problem. * Make sure to handle edge cases, such as the scenario of one or both nodes not being present in the tree.","solution":"from typing import Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def findLCA(root: Optional[TreeNode], p: TreeNode, q: TreeNode) -> Optional[TreeNode]: if not root: return None if root == p or root == q: return root left = findLCA(root.left, p, q) right = findLCA(root.right, p, q) if left and right: return root return left if left else right"},{"question":"Isomorphic Strings Checker Scenario Imagine you are developing a feature for a text analysis tool. You need to verify if two given strings are isomorphic. Two strings are isomorphic if you can transform one string into the other by replacing each character of the first string with a unique character from the second string, maintaining the sequence. Task Your task is to write a function `are_isomorphic_strings(s1, s2)` that checks whether the given strings `s1` and `s2` are isomorphic. # Function Signature: ```python def are_isomorphic_strings(s1: str, s2: str) -> bool: pass ``` # Input: - `s1` (string): A string containing at least one character. - `s2` (string): A string containing at least one character. # Output: - Return `True` if `s1` and `s2` are isomorphic. Otherwise, return `False`. # Constraints: - Length of `s1` and `s2` does not exceed 100,000 characters. - `s1` and `s2` contain only printable ASCII characters from space (32) to tilde (126). # Examples: Example 1: ```python are_isomorphic_strings(\'egg\', \'add\') # Output: True ``` Example 2: ```python are_isomorphic_strings(\'foo\', \'bar\') # Output: False ``` Example 3: ```python are_isomorphic_strings(\'paper\', \'title\') # Output: True ``` Example 4: ```python are_isomorphic_strings(\'ab\', \'aa\') # Output: False ``` # Explanation 1. In the first example, \'e\' -> \'a\', \'g\' -> \'d\', thus maintaining the structure. 2. In the second example, \'f\' and \'b\' should both map to \'o\', causing conflict. 3. In the third example, maintain the structure as \'p\' -> \'t\', \'a\' -> \'i\', \'e\' -> \'l\', \'r\' -> \'e\' 4. In the fourth example, both \'a\' cannot map to different characters \'a\' and \'b\' Ensure to handle edge cases such as strings of different lengths or where multiple mappings are not possible.","solution":"def are_isomorphic_strings(s1: str, s2: str) -> bool: Checks if two strings s1 and s2 are isomorphic. if len(s1) != len(s2): return False mapping_s1_to_s2 = {} mapping_s2_to_s1 = {} for char1, char2 in zip(s1, s2): if char1 in mapping_s1_to_s2: if mapping_s1_to_s2[char1] != char2: return False else: if char2 in mapping_s2_to_s1: return False mapping_s1_to_s2[char1] = char2 mapping_s2_to_s1[char2] = char1 return True"},{"question":"Context You are tasked to implement a feature that computes the shortest path from a starting node to an ending node in the directed graph. If no path exists, the function should return an appropriate indication of such. This will require a breadth-first search (BFS) approach due to the unweighted nature of the edges. Problem Statement *Implement a function `shortest_path` which takes a `DirectedGraph` object and two node names (as strings) representing the start and end nodes. Your function should return a list of node names representing the shortest path from the start node to the end node. If no path exists, return an empty list.* **Function Signature**: ```python def shortest_path(graph: DirectedGraph, start: str, end: str) -> list: ``` Input - **graph**: An instance of the `DirectedGraph` class. - **start**: A string representing the starting node name. - **end**: A string representing the ending node name. Output - **Return**: A list of strings representing the shortest path from the start node to the end node. If no path exists, return an empty list. Constraints - Assume node names are unique within the graph. - The graph can contain up to 10,000 nodes and up to 100,000 edges. Example ```python # Example graph represented as a dictionary for clarity connections = { \\"A\\": [\\"B\\", \\"C\\"], \\"B\\": [\\"D\\"], \\"C\\": [\\"E\\"], \\"D\\": [\\"E\\"], \\"E\\": [] } graph = DirectedGraph(connections) print(shortest_path(graph, \\"A\\", \\"E\\")) # Output: [\\"A\\", \\"C\\", \\"E\\"] or [\\"A\\", \\"B\\", \\"D\\", \\"E\\"] print(shortest_path(graph, \\"A\\", \\"F\\")) # Output: [] ``` Requirements - Efficient BFS implementation to find the shortest path. - Consider all edge cases noted in the analysis. - Ensure the implementation handles up to the maximum constraints effectively.","solution":"from collections import deque class DirectedGraph: def __init__(self, connections): self.graph = connections def get_neighbors(self, node): return self.graph.get(node, []) def shortest_path(graph: DirectedGraph, start: str, end: str) -> list: Returns the shortest path from start to end in the given directed graph. Uses BFS for path finding. if start == end: return [start] visited = set() queue = deque([(start, [start])]) # stores (current_node, path_to_current) while queue: current, path = queue.popleft() if current in visited: continue visited.add(current) for neighbor in graph.get_neighbors(current): if neighbor == end: return path + [end] queue.append((neighbor, path + [neighbor])) return [] # Example usage: connections = { \\"A\\": [\\"B\\", \\"C\\"], \\"B\\": [\\"D\\"], \\"C\\": [\\"E\\"], \\"D\\": [\\"E\\"], \\"E\\": [] } graph = DirectedGraph(connections) print(shortest_path(graph, \\"A\\", \\"E\\")) # Output: [\\"A\\", \\"C\\", \\"E\\"] or [\\"A\\", \\"B\\", \\"D\\", \\"E\\"] print(shortest_path(graph, \\"A\\", \\"F\\")) # Output: []"},{"question":"# Question: Filter Array within Specified Limits You are given an array of integers and two optional bounds: a lower bound `min_lim` and an upper bound `max_lim`. Your task is to write a function `bounded_filter` that returns a new list that includes all elements from the input array that are greater than or equal to `min_lim` and less than or equal to `max_lim`. If `min_lim` is not provided, consider the minimum value of the array as the lower bound. If `max_lim` is not provided, consider the maximum value of the array as the upper bound. If both are not provided, return the array as it is. # Function Signature ```python def bounded_filter(arr: List[int], min_lim: Optional[int]=None, max_lim: Optional[int]=None) -> List[int]: ``` # Input * `arr` – List of integers (1 <= len(arr) <= 10^6) * `min_lim` – Optional integer, default is None (if not provided, no lower limit). * `max_lim` – Optional integer, default is None (if not provided, no upper limit). # Output * A list of integers, containing elements of `arr` that lie within the specified range. # Constraints * The elements of `arr` are within the range [1, 10^9]. * If `arr` is empty, return an empty list. * If `min_lim` or `max_lim` is `None`, override them with the minimum or maximum possible values of the array respectively. # Example ```python assert bounded_filter([4, 2, 6, 8, 3], min_lim=2, max_lim=6) == [4, 2, 6, 3] assert bounded_filter([4, 2, 6, 8, 3], min_lim=5) == [6, 8] assert bounded_filter([4, 2, 6, 8, 3], max_lim=4) == [4, 2, 3] assert bounded_filter([1, 5, 3, 2, 4], None, None) == [1, 5, 3, 2, 4] assert bounded_filter([], min_lim=1, max_lim=10) == [] ``` # Note * Remember to handle cases where `min_lim` or `max_lim` or both are None. * Optimize for time and space complexity to handle large input arrays efficiently.","solution":"from typing import List, Optional def bounded_filter(arr: List[int], min_lim: Optional[int]=None, max_lim: Optional[int]=None) -> List[int]: if not arr: return arr if min_lim is None: min_lim = min(arr) if max_lim is None: max_lim = max(arr) return [x for x in arr if min_lim <= x <= max_lim]"},{"question":"You are given an undirected graph as an adjacency list and a starting node. Your task is to implement three separate functions for graph traversal: 1. **Depth-First Search (DFS)** using an iterative approach. 2. **Breadth-First Search (BFS)** using a queue. 3. **Recursive Depth-First Search (DFS)**. Your implementations should keep track of the nodes visited during the traversal and return them in the order of their visitation. # Function Signatures ```python def dfs_traverse(graph: dict, start: int) -> set: pass def bfs_traverse(graph: dict, start: int) -> set: pass def dfs_traverse_recursive(graph: dict, start: int, visited: set = None) -> set: pass ``` # Input - `graph`: A dictionary representing the undirected graph where the keys are node identifiers and the values are lists of adjacent nodes. - `start`: The node from which the traversal starts. # Output - Each function should return a set containing the nodes visited in the order they were first encountered. # Constraints - The graph may have up to 10,000 nodes. - Each node in the graph has a unique integer identifier. - Assume the graph is connected and does not contain self-loops or parallel edges. # Example ```python graph = { 0: [1, 2], 1: [0, 3, 4], 2: [0, 4], 3: [1], 4: [1, 2, 5], 5: [4] } # Starting from node 0. assert dfs_traverse(graph, 0) == {0, 1, 3, 4, 2, 5} assert bfs_traverse(graph, 0) == {0, 1, 2, 3, 4, 5} assert dfs_traverse_recursive(graph, 0) == {0, 1, 3, 4, 2, 5} ``` # Performance Requirements - Ensure your implementations are efficient and fit within the given constraints.","solution":"def dfs_traverse(graph: dict, start: int) -> set: Iterative Depth-First Search (DFS) traversal of the graph. visited = set() stack = [start] while stack: node = stack.pop() if node not in visited: visited.add(node) # Add neighbors to stack stack.extend(neighbor for neighbor in graph[node] if neighbor not in visited) return visited def bfs_traverse(graph: dict, start: int) -> set: Breadth-First Search (BFS) traversal of the graph. visited = set() queue = [start] while queue: node = queue.pop(0) if node not in visited: visited.add(node) # Add neighbors to queue queue.extend(neighbor for neighbor in graph[node] if neighbor not in visited) return visited def dfs_traverse_recursive(graph: dict, start: int, visited: set = None) -> set: Recursive Depth-First Search (DFS) traversal of the graph. if visited is None: visited = set() visited.add(start) for neighbor in graph[start]: if neighbor not in visited: dfs_traverse_recursive(graph, neighbor, visited) return visited"},{"question":"# Scenario You are tasked with developing a simple classification model using the nearest neighbor algorithm. Your function will receive a vector to classify and a labeled training set. The functionality should accurately match the provided vector to its nearest neighbor in the training set using the Euclidean distance metric and return the associated class label. # Task Implement a function `classify_vector(x, tSet)`. Input - A vector `x` as a tuple (e.g., `(2.5, 3.6, 4.1)`). - A training set `tSet` as a dictionary where the keys are tuples (vectors) and values are class labels (e.g., `{(1.0, 2.0): \'A\', (4.5, 3.2): \'B\'}`). Output - The class label (string) of the nearest neighbor to vector `x` from the training set `tSet`. Constraints - The training set will contain at least one vector. - All vectors `x` and training tuples will have the same length (dimensionality). - Each vector may have integer or floating-point values. Performance - Optimize the function for efficiency in both time and space, considering preprocessing and potential edge cases. Example Usage ```python x = (2.5, 3.6) tSet = { (1.0, 2.0): \'A\', (4.5, 3.2): \'B\', (2.5, 4.0): \'C\' } print(classify_vector(x, tSet)) # Expected output: \'C\' ```","solution":"import math def euclidean_distance(v1, v2): Compute the Euclidean distance between two vectors v1 and v2. return math.sqrt(sum((a - b) ** 2 for a, b in zip(v1, v2))) def classify_vector(x, tSet): Classify the vector x based on the nearest neighbor in the training set tSet. Args: x : tuple Vector to classify. tSet : dict Training set where the keys are vectors and values are class labels. Returns: str The class label of the nearest neighbor in the training set. nearest_neighbor = None min_distance = float(\'inf\') for vector, label in tSet.items(): distance = euclidean_distance(x, vector) if distance < min_distance: min_distance = distance nearest_neighbor = label return nearest_neighbor"},{"question":"# Context You are given the task of generating all unique permutations of a list that may contain duplicate elements. The goal is to eliminate any duplicate permutations so that each unique permutation appears exactly once in the output. # Problem Statement Write a function `permute_unique(nums: List[int]) -> List[List[int]]` that takes a list of integers `nums` and returns a list of lists, where each list contains one unique permutation of the numbers in `nums`. # Input - `nums`: A list of integers, potentially containing duplicates. The length of the list can be up to 8. # Output - A list of lists, where each inner list is a unique permutation of `nums`. # Constraints 1. The length of `nums` (n) is between 0 and 8 inclusive. 2. The integers in `nums` can be both positive and negative. # Performance Requirements - The algorithm should efficiently handle the generation of permutations. The solution should aim to minimize redundancy and excess computations. # Examples - Input: `[1, 1, 2]` - Output: `[[1, 1, 2], [1, 2, 1], [2, 1, 1]]` - Input: `[1, 2, 2]` - Output: `[[1, 2, 2], [2, 1, 2], [2, 2, 1]]` - Input: `[0, -1, -1, 2]` - Output: `[[0, -1, -1, 2], [0, -1, 2, -1], [0, 2, -1, -1], [-1, 0, -1, 2], [-1, 0, 2, -1], [-1, -1, 0, 2], [-1, -1, 2, 0], [-1, 2, 0, -1], [-1, 2, -1, 0], [2, 0, -1, -1], [2, -1, 0, -1], [2, -1, -1, 0]]` # Instructions - Implement the function `permute_unique` in Python. - Ensure the function passes the given test cases. - Pay attention to edge cases described in the analysis.","solution":"from typing import List from itertools import permutations def permute_unique(nums: List[int]) -> List[List[int]]: Returns a list of unique permutations of the input list `nums`, which may contain duplicates. return list(map(list, {tuple(p) for p in permutations(nums)}))"},{"question":"Design a function `clone_graph` that takes as input a node of an undirected graph and returns a deep copy of the graph using iterative Breadth-First Search (BFS). The graph is represented by `UndirectedGraphNode` objects where each node has a unique label and a list of its neighbours. Input - `node` (UndirectedGraphNode): The starting node of the graph to be cloned. Output - `UndirectedGraphNode`: The cloned graph\'s starting node. Example Here\'s a more detailed serialization of the given example: Serialized graph format: `{0,1,2#1,2#2,2}` - First node has label 0: Connect node 0 to nodes 1 and 2. - Second node has label 1: Connect node 1 to node 2. - Third node has label 2: Connect node 2 to itself. Given this graph, a deep copy needs to be created which maintains the same connectivity and labels. Constraints - Graph should have unique node labels. - The maximum number of nodes in the graph is 1000. Function Signature ```python def clone_graph(node: \'UndirectedGraphNode\') -> \'UndirectedGraphNode\': ``` Requirements and Expectations - The solution must use iterative BFS. - The copied graph should have the same structure, labels, and connectivity as the original graph. - Proper handling of edge cases like: * Empty graph (input node is None). * Single node without any neighbours. * Self-looped nodes. - Maintain a dictionary to store visited nodes and their copies for efficient traversal and cloning. Example Code ```python class UndirectedGraphNode: def __init__(self, label): self.label = label self.neighbors = [] # Students should implement the clone_graph function using iterative BFS here # ... (students\' code here) ... def test_clone_graph(): # Helper functions to create and serialize graphs can be used for testing pass # Example testing procedures can be added here # ... (students\' test code here) ... ```","solution":"class UndirectedGraphNode: def __init__(self, label): self.label = label self.neighbors = [] def clone_graph(node: \'UndirectedGraphNode\') -> \'UndirectedGraphNode\': if not node: return None from collections import deque copies = {node: UndirectedGraphNode(node.label)} queue = deque([node]) while queue: current = queue.popleft() for neighbor in current.neighbors: if neighbor not in copies: copies[neighbor] = UndirectedGraphNode(neighbor.label) queue.append(neighbor) copies[current].neighbors.append(copies[neighbor]) return copies[node]"},{"question":"# Question You are provided with a basic implementation of a Red-Black Tree. This tree currently supports insertion, deletion, and in-order traversal (to list all elements maintaining sorted order). Your task is to enhance this functionality by implementing a method to check if the tree is a valid Red-Black Tree. The Red-Black Tree properties must hold after any insertion or deletion operations. Write a function `is_valid_rb_tree(self)` in the `RBTree` class to verify if the tree meets all Red-Black Tree properties. # Function Signature ```python def is_valid_rb_tree(self) -> bool ``` # Expected Input and Output * **Input**: The function takes no parameters since it operates on the instance of the `RBTree` class. * **Output**: The function should return a boolean value (`True` if the tree is a valid Red-Black Tree, `False` otherwise). # Constraints - You do not need to worry about external input as the function interacts only with the class\'s internal state. - The tree structure and operations must comply with the Red-Black Tree properties at all times. # Performance Requirements - The function should efficiently check the tree properties with no assumptions on the tree\'s initial state. # Example Consider the Red-Black Tree implemented in the provided code snippet. After the following operations: ```python rb = RBTree() children = [11, 2, 14, 1, 7, 15, 5, 8, 4] for child in children: node = RBNode(child, 1) rb.insert(node) ``` You will have constructed a Red-Black Tree. Calling `rb.is_valid_rb_tree()` should return `True` if the tree is valid or `False` if any properties are violated. # Scenario Context This test is meant to evaluate your understanding of tree data structures, particularly self-balancing trees like the Red-Black tree. Ensuring that the tree maintains its properties after operations is critical for the efficiency and correctness of the data structure. # Deliverables 1. Implement the `is_valid_rb_tree` function in the `RBTree` class. 2. Ensure robustness in checking all relevant properties associated with Red-Black Trees. **Note**: Assume that the class `RBNode` and its basic operations (for insertion/deletion) are available in the implementation.","solution":"class RBNode: def __init__(self, val, color, left=None, right=None, parent=None): self.val = val self.color = color # 0 for black, 1 for red self.left = left self.right = right self.parent = parent class RBTree: def __init__(self): self.NIL_LEAF = RBNode(val=None, color=0) self.root = self.NIL_LEAF def insert(self, node): # Simplified insert function, assumes additional fix-up code is present for balancing pass def delete(self, node): # Simplified delete function, assumes additional fix-up code is present for balancing pass def in_order_traversal(self, node, arr=[]): if node != self.NIL_LEAF: self.in_order_traversal(node.left, arr) arr.append(node.val) self.in_order_traversal(node.right, arr) return arr def is_valid_rb_tree(self): def check_black_height(node): if node == self.NIL_LEAF: return 1 left_black_height = check_black_height(node.left) right_black_height = check_black_height(node.right) if left_black_height == 0 or right_black_height == 0: return 0 if left_black_height != right_black_height: return 0 return left_black_height + (1 if node.color == 0 else 0) def check_node_properties(node): if node == self.NIL_LEAF: return True if node.color == 1: if (node.left.color == 1 or node.right.color == 1): return False if node.parent is None and node.color == 1: return False return check_node_properties(node.left) and check_node_properties(node.right) if self.root.color != 0: return False if check_black_height(self.root) == 0: return False if not check_node_properties(self.root): return False return True"},{"question":"Coding Assessment Question You are tasked with writing a function that determine if a given string `str_a` matches a specified pattern `str_b` which includes the special characters `.` and `*`. **Function Signature**: ```python def is_match(str_a: str, str_b: str) -> bool: ``` **Input**: - `str_a` (a string): The input string that needs to be matched. - `str_b` (a string): The pattern that may contain the characters `.` and `*`. **Output**: - Return `True` if `str_a` matches `str_b` totally according to the rules of `.` and `*`. - Return `False` otherwise. **Example**: ```plaintext is_match(\\"aa\\", \\"a\\") → False is_match(\\"aa\\", \\"aa\\") → True is_match(\\"aaa\\", \\"aa\\") → False is_match(\\"aa\\", \\"a*\\") → True is_match(\\"aa\\", \\".*\\") → True is_match(\\"ab\\", \\".*\\") → True is_match(\\"aab\\", \\"c*a*b\\") → True ``` **Constraints**: - Both input strings `str_a` and `str_b` are composed only of lowercase English letters. - The length of `str_a` and `str_b` will not exceed 100. **Hints**: - Think of using a dynamic programming approach by maintaining a 2D array `matches`. - Make sure to consider both the zero and one-or-more occurrence cases when dealing with `*` in the pattern. **Performance Requirements**: The solution should efficiently handle the inputs ensuring time complexity linear in terms of length of strings within the provided constraints.","solution":"def is_match(str_a: str, str_b: str) -> bool: # DP table with dimensions (len(str_a) + 1) x (len(str_b) + 1) dp = [[False] * (len(str_b) + 1) for _ in range(len(str_a) + 1)] dp[0][0] = True # Base case: empty string matches empty pattern # Initialization for patterns with \\"*\\" for j in range(2, len(str_b) + 1): if str_b[j - 1] == \'*\': dp[0][j] = dp[0][j - 2] # Matches zero occurrence of the character before \'*\' for i in range(1, len(str_a) + 1): for j in range(1, len(str_b) + 1): if str_b[j - 1] == \'.\' or str_b[j - 1] == str_a[i - 1]: dp[i][j] = dp[i - 1][j - 1] elif str_b[j - 1] == \'*\': dp[i][j] = dp[i][j - 2] # zero occurrence if str_b[j - 2] == \'.\' or str_b[j - 2] == str_a[i - 1]: dp[i][j] = dp[i][j] or dp[i - 1][j] # one or more occurrences return dp[len(str_a)][len(str_b)]"},{"question":"# Task: You are given a directed graph represented by an adjacency list, and your task is to implement the function `is_reachable` to determine if there exists a path between two nodes `source` and `target`. # Function Signature: ```python def is_reachable(graph, source, target): :param graph: Dictionary representing the adjacency list of the graph :param source: Integer representing the starting node :param target: Integer representing the target node :return: Boolean indicating if a path exists from source to target ``` # Input: * `graph`: A dictionary where keys are node integers and values are lists of integers representing directed edges from the key node. * `source`: An integer representing the starting node. * `target`: An integer representing the target node. # Output: * Return `True` if there is a path from `source` to `target`, otherwise `False`. # Constraints: * The graph can have up to 10^3 nodes and 10^4 edges. * Node values will be non-negative integers. * `source` and `target` nodes will always be valid nodes within the graph. # Example: ```python graph = { 0: [1, 2], 1: [2], 2: [0, 3], 3: [3] } print(is_reachable(graph, 1, 3)) # Output: True print(is_reachable(graph, 3, 1)) # Output: False ``` # Note: Ensure your implementation efficiently handles large graphs and avoids recursion depth issues.","solution":"from collections import deque def is_reachable(graph, source, target): Determines if there exists a path between two nodes in the directed graph. :param graph: Dictionary representing the adjacency list of the graph :param source: Integer representing the starting node :param target: Integer representing the target node :return: Boolean indicating if a path exists from source to target if source == target: return True visited = set() queue = deque([source]) while queue: node = queue.popleft() if node in visited: continue visited.add(node) for neighbor in graph.get(node, []): if neighbor == target: return True if neighbor not in visited: queue.append(neighbor) return False"},{"question":"Linked List Addition with Negatives # Problem Statement: You are given two linked lists representing two integers. The digits are stored in reverse order and each of their nodes contain a single digit. You need to add the two numbers and return the result as a new linked list. The twist is that the integers can now be negative as well. This means you need to incorporate handling of negative numbers during addition. # Example: - Input: (3 -> 4 -> 2) + (-9 -> 1 -> 5) - Represents numbers: 243 and -519 - Output: (4 -> 5 -> 3) - Represents number: -276 # Input & Output Formats: **Input**: 1. Two linked lists representing integers. Each node contains a single digit. 2. The integers can be positive or negative, represented by a boolean associated with each linked list. **Output**: The function should return a linked list representing the sum of the input numbers. # Constraints: - Nodes contain digits from 0 to 9. - The length of both linked lists is in the range [1, 100]. # Notes: - You should handle carry-overs correctly. - Handle the sign of the numbers (`+` or `-`) correctly in the final result. - Ensure that your solution is optimized both for time and space complexity. # Function Signature: ```python class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def add_linked_lists(left: ListNode, left_neg: bool, right: ListNode, right_neg: bool) -> ListNode: pass ``` # Example Usage: ```python # Building linked lists for numbers 243 and -519 left = ListNode(2, ListNode(4, ListNode(3))) right = ListNode(9, ListNode(1, ListNode(5))) # Indicating that right linked list represents a negative number result = add_linked_lists(left, False, right, True) # The resulting linked list should represent -276 (4 -> 5 -> 3) while result: print(result.value, end=\\" -> \\") result = result.next ```","solution":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def linked_list_to_number(node: ListNode) -> int: num = 0 place = 1 while node: num += node.value * place place *= 10 node = node.next return num def number_to_linked_list(num: int) -> ListNode: if num == 0: return ListNode(0) head = None current = None if num < 0: num = -num while num > 0: digit = num % 10 num //= 10 if head is None: head = ListNode(digit) current = head else: current.next = ListNode(digit) current = current.next return head def add_linked_lists(left: ListNode, left_neg: bool, right: ListNode, right_neg: bool) -> ListNode: left_num = linked_list_to_number(left) right_num = linked_list_to_number(right) if left_neg: left_num = -left_num if right_neg: right_num = -right_num result_num = left_num + right_num return number_to_linked_list(result_num)"},{"question":"# Merge Strings Challenge You are given two strings, `part1` and `part2`, and a target string `s`. You need to check if `s` can be formed by interleaving the characters from `part1` and `part2` while preserving the order of characters within each part. **Function Signature**: ```python def is_merge(s: str, part1: str, part2: str) -> bool: ``` # Input Format 1. `s`: A string representing the target string. 2. `part1` and `part2`: Two strings that need to be interleaved to form `s`. # Output Format - Returns `True` if `s` can be formed by interleaving `part1` and `part2`. Otherwise, return `False`. # Constraints - The length of the strings `s`, `part1`, and `part2` will be between 0 and 100. - All strings will consist of lowercase English letters only. # Examples **Example 1:** ```text Input: s = \\"codewars\\" part1 = \\"cdw\\" part2 = \\"oears\\" Output: True ``` **Example 2:** ```text Input: s = \\"abc\\" part1 = \\"a\\" part2 = \\"b\\" Output: False ``` **Example 3:** ```text Input: s = \\"abcdef\\" part1 = \\"abc\\" part2 = \\"def\\" Output: True ``` # Edge Cases to Consider - Either `part1` or `part2` being empty. - All combinations being empty. - `s` containing characters not in `part1` or `part2`. Write a function `is_merge` to solve the problem using either a recursive or an iterative approach.","solution":"def is_merge(s: str, part1: str, part2: str) -> bool: Determines if the string \'s\' can be formed by interleaving the characters of \'part1\' and \'part2\' preserving the order of characters within each part. len_s, len_p1, len_p2 = len(s), len(part1), len(part2) if len_s != len_p1 + len_p2: return False dp = [[False] * (len_p2 + 1) for _ in range(len_p1 + 1)] dp[0][0] = True for i in range(1, len_p1 + 1): dp[i][0] = dp[i - 1][0] and part1[i - 1] == s[i - 1] for j in range(1, len_p2 + 1): dp[0][j] = dp[0][j - 1] and part2[j - 1] == s[j - 1] for i in range(1, len_p1 + 1): for j in range(1, len_p2 + 1): dp[i][j] = (dp[i - 1][j] and part1[i - 1] == s[i + j - 1]) or (dp[i][j - 1] and part2[j - 1] == s[i + j - 1]) return dp[len_p1][len_p2]"},{"question":"# Question Given two binary trees, write a function to check if they are equal or not without using recursion. Instead, use an iterative approach to validate the structural identity and node value equality of the two trees. Two binary trees are considered equal if they are structurally identical and the nodes have the same value. Function Signature ```python def is_same_tree_iterative(tree_p, tree_q) -> bool: # Your code here ``` Input - `tree_p`: The root node of the first binary tree. - `tree_q`: The root node of the second binary tree. Output - A boolean indicating whether the two binary trees are structurally identical and their nodes have the same value. Constraints - Tree node values will be integers. - The trees might be empty or non-empty. Examples ```python # Example 1: # Input: tree_p = [1,2,3], tree_q = [1,2,3] # Output: True # Example 2: # Input: tree_p = [1,2], tree_q = [1,None,2] # Output: False # Example 3: # Input: tree_p = [], tree_q = [] # Output: True ```","solution":"from collections import deque class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def is_same_tree_iterative(tree_p, tree_q) -> bool: Checks if two binary trees are the same using an iterative approach. if not tree_p and not tree_q: return True if not tree_p or not tree_q: return False queue = deque([(tree_p, tree_q)]) while queue: node1, node2 = queue.popleft() if not node1 and not node2: continue if not node1 or not node2: return False if node1.val != node2.val: return False queue.append((node1.left, node2.left)) queue.append((node1.right, node2.right)) return True"},{"question":"You are tasked with implementing a function to calculate the Hamming weight—the number of \'1\' bits—in the binary representation of an unsigned integer. This needs to be done efficiently using bit manipulation. # Function Signature ```python def hamming_weight(n: int) -> int: Calculate the number of \'1\' bits in the binary representation of an unsigned integer. :param n: an unsigned integer :return: the number of \'1\' bits Time Complexity: O(k) where k is the number of \'1\' bits Space Complexity: O(1) ``` # Input - An unsigned integer `n`. # Output - An integer indicating the number of \'1\' bits in the binary representation of `n`. # Constraints - `0 <= n <= 2^32 - 1` - Ensure to handle edge cases like `0` appropriately. - You must use bitwise operations to achieve this. # Example ```python assert hamming_weight(0) == 0 assert hamming_weight(11) == 3 # binary: 1011 assert hamming_weight(128) == 1 # binary: 10000000 assert hamming_weight(255) == 8 # binary: 11111111 ``` # Requirements - Implement both a recursive and an iterative approach within the function. - Ensure the function does not excessively use stack space (prefer iterative approach in practice). - The solution should be efficient and should run within the provided constraints. # Context This problem is crucial for understanding bitwise operations and provides a practical use case for counting set bits, often required in low-level programming, error detection/correction codes, and optimizing data structures.","solution":"def hamming_weight(n: int) -> int: Calculate the number of \'1\' bits in the binary representation of an unsigned integer. :param n: an unsigned integer :return: the number of \'1\' bits Time Complexity: O(k) where k is the number of \'1\' bits Space Complexity: O(1) count = 0 while n: count += n & 1 n >>= 1 return count"},{"question":"# Binary Search Practical Application Context You are working on developing a search function for a stock trading platform. To quickly check prices and make decisions, you need to implement an efficient search functionality to find specific stock prices within a sorted list of prices. Task Your task is to implement a function using Binary Search to efficiently find if a given stock price exists in the sorted list of prices. Requirements 1. Implement both iterative and recursive versions of Binary Search in Python. 2. Ensure your solution handles edge cases effectively. Input Format - A list of integers `prices` where the integers are sorted in ascending order. - An integer `target` representing the stock price to be searched. Output Format - Return the index of `target` in the list `prices` if it exists, otherwise return -1. Constraints - The length of the list `prices` can be from `0` to `100,000`. - Each price value and target will be between `-10^9` and `10^9`. Example ```python # Iterative version call index = binary_search([10, 20, 30, 40, 50], 30) print(index) # Output: 2 # Recursive version call index = binary_search_recursive([10, 20, 30, 40, 50], 0, 4, 30) print(index) # Output: 2 ``` Implementation ```python def binary_search(prices, target): low, high = 0, len(prices) - 1 while low <= high: mid = (high + low) // 2 val = prices[mid] if val == target: return mid if val < target: low = mid + 1 else: high = mid - 1 return -1 def binary_search_recursive(prices, low, high, target): if low > high: return -1 mid = low + (high - low) // 2 if prices[mid] == target: return mid if prices[mid] > target: return binary_search_recursive(prices, low, mid - 1, target) return binary_search_recursive(prices, mid + 1, high, target) # Example use-cases: prices = [10, 20, 30, 40, 50] print(binary_search(prices, 30)) # Output: 2 print(binary_search_recursive(prices, 0, len(prices) - 1, 30)) # Output: 2 ```","solution":"def binary_search(prices, target): Iterative version of binary search to find the index of target in the sorted list prices. Returns the index of target if found, else returns -1. low, high = 0, len(prices) - 1 while low <= high: mid = (high + low) // 2 val = prices[mid] if val == target: return mid if val < target: low = mid + 1 else: high = mid - 1 return -1 def binary_search_recursive(prices, low, high, target): Recursive version of binary search to find the index of target in the sorted list prices. Returns the index of target if found, else returns -1. if low > high: return -1 mid = low + (high - low) // 2 if prices[mid] == target: return mid if prices[mid] > target: return binary_search_recursive(prices, low, mid - 1, target) return binary_search_recursive(prices, mid + 1, high, target)"},{"question":"Scenario You are working as a software developer at a company that processes large volumes of texts. A common task is to search for specific keyword patterns within documents. Given the high volume of data, an efficient string matching algorithm is essential. You decide to use the Rabin-Karp algorithm due to its efficient average-case performance. Problem Statement Write a function `find_pattern_positions(pattern: str, text: str) -> List[int]` that finds all occurrences of a given `pattern` in the `text` using the Rabin-Karp algorithm and returns a list of starting indices where the pattern is found. If the pattern is not found, the function should return an empty list. Input * `pattern` (str): The substring to be searched for in `text`. * `text` (str): The larger string in which to search for `pattern`. Output * Returns a list of integers representing the starting positions of each occurrence of `pattern` in `text`. Constraints * 0 <= len(pattern) <= 10^5 * 0 <= len(text) <= 10^6 Performance Requirements * The solution should have an average-case time complexity of O(n + m), where `n` is the length of the text and `m` is the length of the pattern. Example ```python assert find_pattern_positions(\\"abc\\", \\"ababcabc\\") == [2, 5] assert find_pattern_positions(\\"\\", \\"abc\\") == [] assert find_pattern_positions(\\"abc\\", \\"\\") == [] assert find_pattern_positions(\\"abc\\", \\"defghijkl\\") == [] assert find_pattern_positions(\\"ab\\", \\"abababab\\") == [0, 2, 4, 6] ``` Implementation Notes * Consider edge cases such as the pattern being an empty string, or the pattern being longer than the text. * The function should efficiently handle texts and patterns of considerable lengths as stated by the constraints.","solution":"from typing import List def find_pattern_positions(pattern: str, text: str) -> List[int]: Find all occurrences of a pattern in the given text using the Rabin-Karp algorithm. Parameters: pattern (str): The substring to be searched for in text. text (str): The larger string in which to search for pattern. Returns: List[int]: List of starting indices where the pattern is found. if not pattern or not text or len(pattern) > len(text): return [] base = 256 prime = 101 n = len(text) m = len(pattern) pattern_hash = 0 text_hash = 0 h = 1 result = [] for i in range(m-1): h = (h * base) % prime for i in range(m): pattern_hash = (base * pattern_hash + ord(pattern[i])) % prime text_hash = (base * text_hash + ord(text[i])) % prime for i in range(n - m + 1): if pattern_hash == text_hash: if text[i:i+m] == pattern: result.append(i) if i < n - m: text_hash = (base * (text_hash - ord(text[i]) * h) + ord(text[i + m])) % prime if text_hash < 0: text_hash += prime return result"},{"question":"# Question You are given the definition of a binary tree node and an implementation of the postorder traversal algorithm (both iterative and recursive). Postorder traversal involves traversing the left subtree, then the right subtree, and then visiting the root node. Write a function to perform postorder traversal using one of the methods outlined (either iterative or recursive). # Function Signature ```python def postorder_traversal(root: Node) -> List[int]: # Implement your solution here ``` # Input - `root` (Node): The root node of a binary tree. # Output - A list of integers representing the values of the nodes in postorder traversal. # Constraints - The number of nodes in the binary tree is in the range [0, 10^4]. - -100 <= Node.val <= 100 # Example ```python # Given the binary tree: # 1 # / # 2 3 # / # 4 5 # The postorder traversal should be [4, 5, 2, 3, 1] root = Node(1) root.left = Node(2, Node(4), Node(5)) root.right = Node(3) print(postorder_traversal(root)) # Output: [4, 5, 2, 3, 1] ``` # Notes - Consider edge cases such as an empty tree or a single node tree. - Discuss the time and space complexity of your approach in the comments.","solution":"from typing import List, Optional class Node: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def postorder_traversal(root: Optional[Node]) -> List[int]: Perform postorder traversal of a binary tree iteratively. Postorder traversal: Left subtree, Right subtree, Root :param root: Root node of the binary tree :return: List of node values in postorder traversal if root is None: return [] stack = [] result = [] last_node_visited = None while stack or root: if root: stack.append(root) root = root.left else: peek_node = stack[-1] if peek_node.right and last_node_visited != peek_node.right: root = peek_node.right else: result.append(peek_node.val) last_node_visited = stack.pop() return result"},{"question":"**Shortest Path Finder** As an engineer for a logistics company, you are tasked with implementing an optimized shortest path finder for delivery routes among warehouses. Consider a weighted, directed graph where nodes represent warehouses and edges represent the available routes with associated distances. Design and implement a function `shortest_paths(matrix, source)` that uses Dijkstra\'s Algorithm to find the shortest path from `source` warehouse to all other warehouses. The function should return a list of shortest distances. # Function Signature ```python def shortest_paths(matrix: List[List[int]], source: int) -> List[int]: ``` # Input - `matrix`: A list of lists of integers representing the adjacency matrix of the graph, where `matrix[i][j]` is the distance from warehouse `i` to warehouse `j`. If there is no direct route from `i` to `j`, the value is `0`. - `source`: The index of the warehouse from which to calculate the shortest paths. # Output - Returns a list of integers where the ith element is the shortest distance from the source to warehouse i. # Constraints - `1 <= len(matrix) <= 100`: The total number of warehouses. - The weights are positive integers or zero. # Example ```python matrix = [ [0, 10, 20], [10, 0, 30], [20, 30, 0] ] source = 0 shortest_paths(matrix, source) # Returns [0, 10, 20] ``` Write clear, idiomatic code and handle any edge cases according to the guidelines above. You may assume that the input matrix will be well-formed and that there will always be a valid path from the source to at least some other nodes in the graph.","solution":"import heapq from typing import List def shortest_paths(matrix: List[List[int]], source: int) -> List[int]: Implements Dijkstra\'s Algorithm to find the shortest paths from the source warehouse to all other warehouses. Parameters: matrix (List[List[int]]): The adjacency matrix representation of the graph. source (int): The index of the source warehouse. Returns: List[int]: A list of shortest distances from the source to each warehouse. n = len(matrix) # The number of warehouses distances = [float(\'inf\')] * n distances[source] = 0 priority_queue = [(0, source)] visited = set() while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_node in visited: continue visited.add(current_node) for neighbor in range(n): if matrix[current_node][neighbor] != 0: # Only considering valid routes distance = matrix[current_node][neighbor] new_distance = current_distance + distance if new_distance < distances[neighbor]: distances[neighbor] = new_distance heapq.heappush(priority_queue, (new_distance, neighbor)) return distances"},{"question":"Problem Statement You are tasked with implementing the optimized bucket sort algorithm to sort an array of integers. Bucket sort is generally more effective when the input array is uniformly distributed over a known range. # Objective Create a function `optimized_bucket_sort(arr: List[int]) -> List[int]` that takes a list of integers and returns a sorted list using the bucket sort approach. The function should handle empty inputs and work efficiently for large datasets. # Requirements 1. **Input**: The function will receive an array of integers `arr` (`1 <= len(arr) <= 10^5`), where the elements are in the range `0 <= arr[i] <= 10^6`. 2. **Output**: Return a sorted list of integers. 3. **Constraints**: * Ideally, implement a bucket sort, but feel free to utilize a more efficient sub-sorting algorithm for individual buckets. * Ensure the implementation handles edge cases like empty input and arrays with identical elements. # Performance Expectation The implementation must be optimized for large input sizes and should work within reasonable time limits considering real-world machine performance. # Example ```python assert optimized_bucket_sort([4, 2, 2, 8, 3, 3, 1]) == [1, 2, 2, 3, 3, 4, 8] assert optimized_bucket_sort([]) == [] assert optimized_bucket_sort([5]) == [5] ``` # Hints - Consider using a more efficient sort within each bucket such as merge sort or quicksort when the bucket sizes are large. - The number of buckets may directly impact the performance. Dynamically adjust bucket sizes based on the input distribution.","solution":"from typing import List def optimized_bucket_sort(arr: List[int]) -> List[int]: if not arr: return [] # Find the maximum value to determine bucket ranges max_value = max(arr) # Number of buckets bucket_count = len(arr) buckets = [[] for _ in range(bucket_count)] # Distribute the elements into the buckets for num in arr: index = num * (bucket_count - 1) // max_value buckets[index].append(num) # Sort individual buckets using Python\'s built-in sort for bucket in buckets: bucket.sort() # Concatenate the buckets into a single list sorted_arr = [] for bucket in buckets: sorted_arr.extend(bucket) return sorted_arr"},{"question":"# Absolute Path Resolver You are asked to develop a utility function that gets the absolute path of a given file. This utility will ensure that all relative paths and user directory shorthands are converted into their absolute path equivalents. This is crucial for applications dealing with file operations where absolute paths are required to avoid any ambiguity. # Function Specification Implement the function `resolve_file_path(file: str) -> str` which takes a string input representing the file path and returns a string representing the absolute path of the file. # Input * `file` (str): A string representing the relative path or path with the user directory shorthand (`~`). # Output * A string representing the absolute path to the file. # Constraints * The input string can be empty or `None`. In such cases, return an empty string. * Assume the file paths are valid in terms of format but may not exist in the file system. # Performance Requirements * The function should handle typical file paths efficiently. * Consider edge cases and handle invalid inputs gracefully. # Example ```python assert resolve_file_path(\\"~\\") == \\"/home/username\\" assert resolve_file_path(\\"~/Documents/test.txt\\") == \\"/home/username/Documents/test.txt\\" assert resolve_file_path(\\"some/relative/path\\") == \\"/home/username/some/relative/path\\" assert resolve_file_path(\\"\\") == \\"\\" assert resolve_file_path(None) == \\"\\" ``` # Notes * Replace `/home/username` with the actual home directory of the user running the script. * Ensure that the function uses Python\'s `os` module to perform the path resolution.","solution":"import os def resolve_file_path(file: str) -> str: Converts a relative file path or a path with user directory shorthand to its absolute path equivalent. Args: file (str): A string representing the relative path or path with the user directory shorthand (\'~\'). Returns: str: A string representing the absolute path to the file. if not file: return \\"\\" return os.path.abspath(os.path.expanduser(file))"},{"question":"# Climbing Stairs with Constraints (Advanced) You are climbing a staircase that has `steps` number of steps to reach the top. Each time you can either climb 1, 2, or 3 steps. You need to find out in how many distinct ways you can climb to the top. **Function Signature**: ```python def climb_stairs_advanced(steps: int) -> int: ``` Input: - `steps` (1 <= steps <= 10^5): The total number of steps to reach the top. Output: - The total number of distinct ways to climb to the top. Constraints: - The result will be a large number, return it modulo 10^9 + 7. Your task is to write an optimized solution that meets the above constraints and performs efficiently for the given input size. Example 1: ```plaintext Input: 3 Output: 4 Explanation: 1. 1 step + 1 step + 1 step 2. 1 step + 2 steps 3. 2 steps + 1 step 4. 3 steps ``` Example 2: ```plaintext Input: 4 Output: 7 Explanation: 1. 1 step + 1 step + 1 step + 1 step 2. 1 step + 1 step + 2 steps 3. 1 step + 2 steps + 1 step 4. 1 step + 3 steps 5. 2 steps + 1 step + 1 step 6. 2 steps + 2 steps 7. 3 steps + 1 step ``` Write an efficient algorithm to solve the problem, ensuring you handle all specified constraints.","solution":"def climb_stairs_advanced(steps: int) -> int: MOD = 10**9 + 7 if steps == 1: return 1 elif steps == 2: return 2 elif steps == 3: return 4 ways = [0] * (steps + 1) ways[1] = 1 ways[2] = 2 ways[3] = 4 for i in range(4, steps + 1): ways[i] = (ways[i-1] + ways[i-2] + ways[i-3]) % MOD return ways[steps]"},{"question":"# Linked List Operations Given the implementation details of Singly Linked List and Doubly Linked List data structures, you are required to implement the following operations for a Doubly Linked List: 1. **Insertion at Head**: * Input: An integer value. * Output: None. * Description: Insert a new node with the given value at the head of the doubly linked list. 2. **Insertion at Tail**: * Input: An integer value. * Output: None. * Description: Insert a new node with the given value at the tail of the doubly linked list. 3. **Deletion by Value**: * Input: An integer value. * Output: Boolean indicating whether a node with the given value was found and deleted. * Description: Delete the first node with the matching value from the doubly linked list. 4. **Traversal**: * Input: None. * Output: A list containing all node values from head to tail. * Description: Traverse the doubly linked list from head to tail and return a list of values. # Function Signatures ```python class DoublyLinkedListNode(object): def __init__(self, value): self.value = value self.next = None self.prev = None class DoublyLinkedList(object): def __init__(self): self.head = None self.tail = None def insert_at_head(self, value: int) -> None: # Your code here def insert_at_tail(self, value: int) -> None: # Your code here def delete_by_value(self, value: int) -> bool: # Your code here def traverse(self) -> list: # Your code here ``` # Constraints * All values inserted into the list will be unique integers. * You may use helper methods as needed. * Aim for efficient time complexity in your operations. # Example ```python dll = DoublyLinkedList() dll.insert_at_head(1) dll.insert_at_tail(2) dll.insert_at_head(0) dll.insert_at_tail(3) print(dll.traverse()) # Output: [0, 1, 2, 3] print(dll.delete_by_value(2)) # Output: True print(dll.traverse()) # Output: [0, 1, 3] print(dll.delete_by_value(4)) # Output: False ```","solution":"class DoublyLinkedListNode(object): def __init__(self, value): self.value = value self.next = None self.prev = None class DoublyLinkedList(object): def __init__(self): self.head = None self.tail = None def insert_at_head(self, value: int) -> None: new_node = DoublyLinkedListNode(value) if not self.head: self.head = new_node self.tail = new_node else: new_node.next = self.head self.head.prev = new_node self.head = new_node def insert_at_tail(self, value: int) -> None: new_node = DoublyLinkedListNode(value) if not self.tail: self.head = new_node self.tail = new_node else: self.tail.next = new_node new_node.prev = self.tail self.tail = new_node def delete_by_value(self, value: int) -> bool: current = self.head while current: if current.value == value: if current.prev: current.prev.next = current.next else: self.head = current.next if current.next: current.next.prev = current.prev else: self.tail = current.prev return True current = current.next return False def traverse(self) -> list: result = [] current = self.head while current: result.append(current.value) current = current.next return result"}]'),O={name:"App",components:{PoemCard:A},data(){return{searchQuery:"",visibleCount:4,poemsData:S,isLoading:!1}},computed:{filteredPoems(){const r=this.searchQuery.trim().toLowerCase();return r?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(r)||e.solution&&e.solution.toLowerCase().includes(r)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(r=>setTimeout(r,1e3)),this.visibleCount+=4,this.isLoading=!1}}},C={class:"search-container"},F={class:"card-container"},L={key:0,class:"empty-state"},z=["disabled"],R={key:0},j={key:1};function Y(r,e,l,c,s,a){const f=g("PoemCard");return n(),i("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",C,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),y(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>s.searchQuery=o),placeholder:"Search..."},null,512),[[_,s.searchQuery]]),s.searchQuery?(n(),i("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>s.searchQuery="")}," ✕ ")):u("",!0)]),t("div",F,[(n(!0),i(b,null,v(a.displayedPoems,(o,m)=>(n(),w(f,{key:m,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(n(),i("div",L,' No results found for "'+d(s.searchQuery)+'". ',1)):u("",!0)]),a.hasMorePoems?(n(),i("button",{key:0,class:"load-more-button",disabled:s.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[s.isLoading?(n(),i("span",j,"Loading...")):(n(),i("span",R,"See more"))],8,z)):u("",!0)])}const P=p(O,[["render",Y],["__scopeId","data-v-2c89723b"]]),M=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"library/49.md","filePath":"library/49.md"}'),D={name:"library/49.md"},G=Object.assign(D,{setup(r){return(e,l)=>(n(),i("div",null,[x(P)]))}});export{M as __pageData,G as default};
