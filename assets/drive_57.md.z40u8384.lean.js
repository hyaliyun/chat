import{_ as c,o as n,c as i,a as t,m as h,t as d,C as g,M as _,U as y,f as u,F as b,p as v,e as w,q as x}from"./chunks/framework.B1z0IdBH.js";const k={name:"PoemCard",props:{poem:{type:Object,required:!0}}},T={class:"poem-container"},q={class:"review"},I={class:"review-title"},E={class:"review-content"};function A(r,e,l,p,a,s){return n(),i("div",T,[t("div",q,[t("div",I,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),h(d(l.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",E,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),h(d(l.poem.solution),1)])])])}const N=c(k,[["render",A],["__scopeId","data-v-8d0a73ce"]]),S=JSON.parse('[{"question":"Problem Statement You are required to implement a class `WordDictionary` with the following functions: 1. `add_word(word)`: Adds a word to the dictionary. 2. `search(word)`: Searches for a word in the dictionary. Word can contain the \'.\' character which can match any letter. Your implementation should make use of a Trie and efficiently handle both exact matches and searches containing wildcards. # Input Format 1. `add_word(word)` function will be called multiple times with a string `word` consisting of lowercase English letters and having a length of 1 to 100. 2. `search(word)` function will be called multiple times with a string `word` consisting of lowercase English letters and \'.\' character and having a length of 1 to 100. # Output Format - For `search(word)`, return `True` if the word or pattern exists in the dictionary, otherwise return `False`. # Constraints 1. The total number of words added will not exceed `5*10^4`. 2. Wildcard character `.` in `search(word)` can replace any single letter, and words will ensure at least one non-dot character for valid searches. # Example ```python dictionary = WordDictionary() dictionary.add_word(\\"bad\\") dictionary.add_word(\\"dad\\") dictionary.add_word(\\"mad\\") assert dictionary.search(\\"pad\\") == False assert dictionary.search(\\"bad\\") == True assert dictionary.search(\\".ad\\") == True assert dictionary.search(\\"b..\\") == True ``` # Implementation Define the `WordDictionary` class using a Trie for efficient add and search operations, following the methods outlined. Consider edge cases and ensure performance meets the constraints.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class WordDictionary: def __init__(self): self.root = TrieNode() def add_word(self, word): current = self.root for char in word: if char not in current.children: current.children[char] = TrieNode() current = current.children[char] current.is_end_of_word = True def search(self, word): def search_in_node(word, node): for i, char in enumerate(word): if char == \'.\': for child in node.children.values(): if search_in_node(word[i+1:], child): return True return False else: if char not in node.children: return False node = node.children[char] return node.is_end_of_word return search_in_node(word, self.root)"},{"question":"# Context In many applications, you may need to determine if two words or phrases are composed of the same letters in the same quantity, essentially checking if they are anagrams. This can be useful in fields like cryptography and text analysis. # Task Write a function that determines if two strings are anagrams of each other. The input strings are guaranteed to consist of lowercase English letters only. # Function Signature ```python def are_anagrams(s1: str, s2: str) -> bool: # Your code here ``` # Input * `s1`: A string of lowercase letters (1 <= len(s1) <= 100) * `s2`: A string of lowercase letters (1 <= len(s2) <= 100) # Output * Return `True` if `s1` and `s2` are anagrams, `False` otherwise. # Constraints * The function should run in O(n) time complexity, where n is the maximum length of the input strings. * Space complexity should be O(1), not considering input and output. # Examples * Example 1: - Input: s1 = \\"listen\\", s2 = \\"silent\\" - Output: True * Example 2: - Input: s1 = \\"apple\\", s2 = \\"pale\\" - Output: False # Notes * Consider edge cases such as strings of different lengths. * Performance should be efficient due to real-time application potential. > **Hint**: Think about using arrays to count occurrences of each character.","solution":"def are_anagrams(s1: str, s2: str) -> bool: Returns True if s1 and s2 are anagrams, False otherwise. # Early exit if lengths differ if len(s1) != len(s2): return False # Initialize a list to count occurrences of each character count = [0] * 26 # there are 26 letters in English alphabet # Count occurrences of each character in s1 for char in s1: count[ord(char) - ord(\'a\')] += 1 # Subtract counts according to s2 for char in s2: count[ord(char) - ord(\'a\')] -= 1 # If all counts return to zero, the strings are anagrams return all(c == 0 for c in count)"},{"question":"# Question: Array Filtering within Specified Range You are tasked with implementing a function `limit` that filters the elements of an array, retaining only those that fall within a specified minimum and maximum limit. This function should be versatile, handling cases where only one limit is provided or neither is provided. Function Signature ```python def limit(arr: list, min_lim: int = None, max_lim: int = None) -> list: pass ``` Input - `arr` (list): A list of integers. - `min_lim` (int): The lower bound to filter values (inclusive). If `None`, consider no lower bound. - `max_lim` (int): The upper bound to filter values (inclusive). If `None`, consider no upper bound. Output - Returns a list of integers from `arr` that fall within the specified range. Constraints - The length of the array will not exceed `10^6`. - The values in the array will be between `-10^9` and `10^9`. Example ```python # Example 1: assert limit([1, 2, 3, 4, 5], None, 3) == [1, 2, 3] # Example 2: assert limit([10, 15, 20, 25, 30], 12, 28) == [15, 20, 25] # Example 3: assert limit([100, 200, 300, 400, 500], 250, None) == [300, 400, 500] # Example 4: assert limit([], None, None) == [] ``` Explanation - In the first example, `None` for `min_lim` implies no lower limit, and `3` for `max_lim` means all values must be less than or equal to 3. - In the second example, values between 12 and 28 (inclusive) are retained. - In the third example, `None` for `max_lim` implies no upper limit, so values greater than or equal to 250 are retained. - An empty array naturally returns an empty array as there are no elements to filter. Ensure your function handles edge cases and large data efficiently.","solution":"def limit(arr: list, min_lim: int = None, max_lim: int = None) -> list: Filters the elements of the array, retaining only those that fall within the specified minimum and maximum limits. Parameters: arr (list): A list of integers. min_lim (int): The lower bound to filter values (inclusive). If None, consider no lower bound. max_lim (int): The upper bound to filter values (inclusive). If None, consider no upper bound. Returns: list: A list of integers from arr that fall within the specified range. if min_lim is not None and max_lim is not None: return [x for x in arr if min_lim <= x <= max_lim] elif min_lim is not None: return [x for x in arr if x >= min_lim] elif max_lim is not None: return [x for x in arr if x <= max_lim] else: return arr"},{"question":"# Truncated Mean Calculation You are given a list of numbers and a percentage. Your task is to write a function that calculates the mean of the list after removing a certain percentage of the largest and smallest values. The percentage given will be divided equally to trim the smallest and largest values. Function Signature ```python def trimmean(arr: List[float], per: float) -> float: ``` Input - `arr`: a list of floats. (1 <= len(arr) <= 10^5) - `per`: a float percentage between 0 and 100. Output - Returns a float, representing the trimmed mean of the list. Constraints - The list will contain at least one element. - The percentage will be a valid float between 0 and 100. - The number of elements to trim on both sides combined will always be rounded down to the nearest integer. Example Consider the following example to understand the requirement: ```python arr = [7, 8, 6, 9, 10, 4, 5] per = 20 result = trimmean(arr, per) print(result) # Should print 7.0 ``` In this example, after sorting: [4, 5, 6, 7, 8, 9, 10], trimming 20% means removing the lowest 10% (1 element) and the highest 10% (1 element), leaving [5, 6, 7, 8, 9]. The mean of these numbers is 7.0. Implement the function `trimmean(arr, per)` to compute this correctly. Be sure to handle edge cases such as percentages resulting in zero removals and minimal input lists.","solution":"from typing import List def trimmean(arr: List[float], per: float) -> float: Calculate the mean of the list after removing a certain percentage of the largest and smallest values. Args: arr (List[float]): a list of floats. per (float): a float percentage between 0 and 100. Returns: float: the trimmed mean of the list. n = len(arr) trim_count = int(n * per / 100 // 2) sorted_arr = sorted(arr) trimmed_arr = sorted_arr[trim_count:n-trim_count] return sum(trimmed_arr) / len(trimmed_arr)"},{"question":"**Scenario**: You have been hired to work on a logging system for a software application that maintains a linked list of user activities. At any given point, your manager might ask you to retrieve the k-th to last user activity for analysis purposes. To implement this functionality efficiently, you need to write code that retrieves the k-th to last element in the linked list representing user activities. **Problem Statement**: Given a singly linked list, write a function `kth_to_last(head, k)` that returns the k-th to last element. If k is greater than the number of elements in the list or if the list is empty, the function should raise an appropriate error. **Function Signature**: ```python def kth_to_last(head: Node, k: int) -> Node: pass ``` **Input**: * `head`: The head node of the singly linked list. * `k`: An integer indicating the k-th position from the last. **Output**: * Returns the node that is k-th from the last. **Constraints**: * The linked list can have up to (10^5) elements. * Each list node contains a value and a reference to the next node. * (0 leq k < n), where n is the number of nodes in the list. **Example**: ```python # Define the Node class class Node: def __init__(self, val=None): self.val = val self.next = None # Example linked list: A -> B -> C -> D -> E a = Node(\\"A\\") b = Node(\\"B\\") c = Node(\\"C\\") d = Node(\\"D\\") e = Node(\\"E\\") a.next = b b.next = c c.next = d d.next = e print(kth_to_last(a, 2).val) # Output: D ``` **Notes**: * You cannot modify the input linked list. * Handle the edge cases appropriately, like if the list is empty or if `k` is invalid.","solution":"class Node: def __init__(self, val=None): self.val = val self.next = None def kth_to_last(head: Node, k: int) -> Node: Returns the k-th to last element in a linked list. Parameters: head (Node): The head node of the linked list. k (int): The k-th position from the last. Returns: Node: The node that is k-th from the last. Raises: IndexError: If k is out of range. if head is None: raise IndexError(\\"The linked list is empty\\") # Initialize two pointers ptr1 = head ptr2 = head # Move ptr2 ahead by k nodes for _ in range(k): if ptr2 is None: raise IndexError(\\"k is larger than the length of the linked list\\") ptr2 = ptr2.next if ptr2 is None: raise IndexError(\\"k is larger than the length of the linked list\\") # Move both pointers until ptr2 reaches the end while ptr2.next is not None: ptr1 = ptr1.next ptr2 = ptr2.next if ptr1 is None: raise IndexError(\\"k is larger than the length of the linked list\\") return ptr1"},{"question":"# Postorder Traversal Problem **Objective**: Write a function that performs a postorder traversal on a given binary tree and returns the values in postorder sequence. **Function Signature**: ```python def postorder_traversal(root: Node) -> List[int]: pass ``` **Input**: - The function accepts one parameter `root` which is the root node of the binary tree. - The `Node` class is already defined with attributes `val`, `left`, and `right`. **Output**: - Return a list of integers representing the values of nodes visited in postorder traversal. **Constraints**: - Tree can have 0 to (10^4) nodes. - Node values are unique integers. **Example**: ```python # Example usage: # Constructing the following tree: # 1 # / # 2 3 # / # 4 5 root = Node(1, Node(2, Node(4), Node(5)), Node(3)) assert postorder_traversal(root) == [4, 5, 2, 3, 1] # Edge Case: # Constructing an empty tree root = None assert postorder_traversal(root) == [] ``` **Scenario**: Suppose you are working on a compiler that processes expression trees. One of the tasks involves generating postfix expressions from a given expression tree. Implementing the postorder traversal will help you achieve the correct output sequence required for postfix notation. **Focus Areas**: - Your solution should efficiently handle both small and large trees. - Make sure to consider edge cases such as trees with single-node, imbalanced left-skewed or right-skewed structures.","solution":"from typing import List, Optional class Node: def __init__(self, val: int, left: \'Node\' = None, right: \'Node\' = None): self.val = val self.left = left self.right = right def postorder_traversal(root: Optional[Node]) -> List[int]: def helper(node: Optional[Node], res: List[int]): if node: helper(node.left, res) helper(node.right, res) res.append(node.val) result = [] helper(root, result) return result"},{"question":"# Customer Data Deduplication In a customer management system, duplicate entries of customer actions need to be limited for system optimization. Given a list of customer actions represented by numerical IDs, write a function `limit_repeated_actions` that ensures no action ID is repeated more than a specified number of times (`N`), while maintaining the original order of actions. Your task is to implement this function efficiently. Below is the function signature: ```python def limit_repeated_actions(action_ids: List[int], N: int) -> List[int]: Limits the occurrences of each action ID to at most N times in the given list. Parameters: action_ids: List[int] - a list of integers representing action IDs. N: int - maximum number of occurrences allowed for each action ID. Returns: List[int] - the list with a limited number of occurrences for each action ID while preserving order. ``` # Input and Output Examples: ```python # Example 1: # Input: action_ids = [1,2,3,1,2,1,2,3], N = 2 # Output: [1,2,3,1,2,3] # Example 2: # Input: action_ids = [1,1,1,1], N = 2 # Output: [1,1] # Example 3: # Input: action_ids = [], N = 3 # Output: [] # Example 4: # Input: action_ids = [4,4,4,4], N = 0 # Output: [] ``` # Constraints: 1. `0 <= len(action_ids) <= 10^5` 2. `0 <= action_ids[i] <= 10^6` for each ID in action_ids. 3. `0 <= N <= 10^5` **Note**: Consider edge cases where the input list is empty or `N` is zero. Ensure your solution is efficient and can handle the upper constraints.","solution":"def limit_repeated_actions(action_ids, N): Limits the occurrences of each action ID to at most N times in the given list. Parameters: action_ids: List[int] - a list of integers representing action IDs. N: int - maximum number of occurrences allowed for each action ID. Returns: List[int] - the list with a limited number of occurrences for each action ID while preserving order. from collections import defaultdict if N == 0: return [] action_count = defaultdict(int) result = [] for action_id in action_ids: if action_count[action_id] < N: result.append(action_id) action_count[action_id] += 1 return result"},{"question":"# Problem You are given a string and you need to compress it using Run-Length Encoding (RLE). Additionally, you should be able to decompress an RLE-encoded string back to its original form. Implement the following two functions: 1. **encode_rle(input)**: - **Input**: A string `input` consisting of alphabetic characters (both lowercase and uppercase). - **Output**: A Run-Length Encoded string. - **Constraints**: * The string length `0 <= len(input) <= 10^5` 2. **decode_rle(input)**: - **Input**: A string `input` consisting of encoded characters using Run-Length Encoding. - **Output**: The original uncompressed string. - **Constraints**: * The string length `0 <= len(input) <= 2 * 10^5` # Example ```python # Example 1 encoded_string = encode_rle(\\"aaabccdddd\\") print(encoded_string) # Output: \\"3a1b2c4d\\" decoded_string = decode_rle(\\"3a1b2c4d\\") print(decoded_string) # Output: \\"aaabccdddd\\" # Example 2 encoded_string = encode_rle(\\"helloo\\") print(encoded_string) # Output: \\"1h1e2l2o\\" decoded_string = decode_rle(\\"1h1e2l2o\\") print(decoded_string) # Output: \\"helloo\\" ``` # Constraints * For `encode_rle`, assume that the given input will always be alphabetic characters only. * For `decode_rle`, assume that the given input will always be a valid encoded string.","solution":"def encode_rle(input): Encode the input string using Run-Length Encoding (RLE). Parameters: input (str): The input string consisting of alphabetic characters. Returns: str: A Run-Length Encoded string. if not input: return \\"\\" encoded_str = \\"\\" count = 1 for i in range(1, len(input)): if input[i] == input[i - 1]: count += 1 else: encoded_str += str(count) + input[i - 1] count = 1 # Adding the last character and its count encoded_str += str(count) + input[-1] return encoded_str def decode_rle(input): Decode the Run-Length Encoded string back to its original form. Parameters: input (str): The RLE encoded string. Returns: str: The original uncompressed string. if not input: return \\"\\" decoded_str = \\"\\" count = \\"\\" for char in input: if char.isdigit(): count += char else: decoded_str += char * int(count) count = \\"\\" return decoded_str"},{"question":"You are given a sorted array of integers. Your task is to implement a function that integrates elements into this sorted array while maintaining the order. You need to determine the index where a given target value should be inserted to keep the array sorted. # Function Signature ```python def search_insert(array: list[int], val: int) -> int: Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. Args: array (list of int): A sorted list of integers. val (int): A target integer that should be inserted. Returns: int: The index where the target value should be inserted. # Input * `array`: A sorted list of integers (0 <= len(array) <= 10^6). * `val`: An integer value to be inserted into the sorted list of integers. # Output * An integer representing the insertion index for `val` in the sorted `array`. # Constraints - The array is sorted in non-decreasing order. - The array can be empty. # Examples ```python assert search_insert([1, 3, 5, 6], 5) == 2 assert search_insert([1, 3, 5, 6], 2) == 1 assert search_insert([1, 3, 5, 6], 7) == 4 assert search_insert([1, 3, 5, 6], 0) == 0 assert search_insert([], 1) == 0 ``` # Explanation Your function should efficiently find the position where the target value `val` fits to maintain the sorted order. Given the sorted nature of the array, a binary search algorithm is recommended for optimal performance. # Performance Requirements The function should ideally have a logarithmic time complexity O(log n).","solution":"def search_insert(array, val): Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. Args: array (list of int): A sorted list of integers. val (int): A target integer that should be inserted. Returns: int: The index where the target value should be inserted. left, right = 0, len(array) while left < right: mid = (left + right) // 2 if array[mid] < val: left = mid + 1 else: right = mid return left"},{"question":"Generate Abbreviations Problem You are tasked with writing a function that generates all possible abbreviations of a given word using a backtracking strategy. The goal is to replace any number of non-overlapping substrings of the word with their lengths, while keeping the rest of the characters in their original positions. Function Signature ```python def generate_abbreviations(word: str) -> List[str]: ``` **Input:** * `word`: A string consisting of lowercase English letters. **Output:** * Returns a list of strings representing all possible abbreviations of the input word. Constraints: * The length of `word` will not exceed 15 characters. Examples: ```python generate_abbreviations(\\"word\\") # Expected Output: [\'word\', \'wor1\', \'wo1d\', \'wo2\', \'w1rd\', \'w1r1\', \'w2d\', \'w3\', \'1ord\', \'1or1\', \'1o1d\', \'1o2\', \'2rd\', \'2r1\', \'3d\', \'4\'] generate_abbreviations(\\"\\") # Expected Output: [\\"\\"] generate_abbreviations(\\"a\\") # Expected Output: [\\"a\\", \\"1\\"] ``` Performance Tips: 1. Ensure your solution can handle the worst-case input efficiently within the constraints. 2. Pay careful attention to recursion and backtracking to avoid unnecessary recomputation. Scenario: Imagine you are developing a text abbreviation system where every word in an email needs to be condensed to its shortened forms for quick search and indexing. Your function will generate all possible abbreviations of a word, allowing you to store multiple searchable variants. Complete the function `generate_abbreviations` following the specified input-output format and constraints.","solution":"from typing import List def generate_abbreviations(word: str) -> List[str]: result = [] def backtrack(pos, cur, count): if pos == len(word): if count > 0: cur += str(count) result.append(cur) else: # Skip the current character and increase the abbreviation count backtrack(pos + 1, cur, count + 1) # Include the current character and reset the abbreviation count if count > 0: cur += str(count) backtrack(pos + 1, cur + word[pos], 0) backtrack(0, \\"\\", 0) return result"},{"question":"Given a sorted list of unique lowercase letters and a target lowercase letter, implement a function to find the smallest element in the list that is larger than the target. The list of letters also wrap around. For example, if the target is \'z\' and the list is [\'a\', \'b\'], the answer should be \'a\'. # Input - `letters` (List[str]): A sorted list of unique lowercase letters (1 <= len(letters) <= 1,000). - `target` (str): A single lowercase letter. # Output - Return a single lowercase letter (str). # Constraints - All letters in the list are unique. - Wrap-around must be considered. # Example ```python # Example 1 letters = [\\"c\\", \\"f\\", \\"j\\"] target = \\"a\\" Output: \\"c\\" # Example 2 letters = [\\"c\\", \\"f\\", \\"j\\"] target = \\"c\\" Output: \\"f\\" # Example 3 letters = [\\"c\\", \\"f\\", \\"j\\"] target = \\"d\\" Output: \\"f\\" ``` # Function Signature ```python def next_greatest_letter(letters: List[str], target: str) -> str: # Your code here ``` # Requirements - You are expected to use either the bisect library, binary search, or a brute-force algorithm. - Your solution should be efficient, aiming for a time complexity of O(log N) where possible. - You must handle edge cases, including the wrap-around scenario.","solution":"from typing import List def next_greatest_letter(letters: List[str], target: str) -> str: Given a sorted list of unique lowercase letters and a target lowercase letter, find the smallest element in the list that is larger than the target. The list of letters also wrap around. left, right = 0, len(letters) while left < right: mid = (left + right) // 2 if letters[mid] > target: right = mid else: left = mid + 1 # Since the list wraps around, if we end up outside the list bounds, we wrap around to the start return letters[left % len(letters)]"},{"question":"# Question: Optimized Bubble Sort Implementation (Advanced) Given the fundamental Bubble Sort algorithm provided, your task is to implement an optimized version of the Bubble Sort algorithm. This enhanced version should include the following improvements: 1. **Early Exit Mechanism**: Identify if the array is already sorted early and exit to avoid unnecessary iterations. 2. **Bidirectional Pass**: Implement a \\"cocktail shaker sort\\" or \\"bidirectional bubble sort,\\" which sorts the array in both the forward and backward directions in alternating passes. # Function Specification Input * `arr`: A list of integers to be sorted. * `simulation` (optional): A boolean flag (default `False`). If set to `True`, print the array at the end of each forward and backward pass to show the intermediate steps. Output * Return the sorted list of integers. Constraints * `1 <= len(arr) <= 1000` * `-10^6 <= arr[i] <= 10^6` Performance requirements * Your solution should be optimal for small to moderately sized input arrays. * Utilize the enhancements properly to improve the overall performance compared to the basic Bubble Sort. # Examples ```python # Example 1 input: [3, 1, 5, 2, 4], simulation=False output: [1, 2, 3, 4, 5] # Example 2: Demonstrate steps input: [3, 1, 5, 2, 4], simulation=True # Output should demonstrate the intermediate steps of sorting ``` Implementation Notes: * Ensure handling of edge cases like empty arrays, arrays with one element, and arrays that are already sorted. * Carefully manage the print statements to reflect the sorting process when `simulation=True`.","solution":"def optimized_bubble_sort(arr, simulation=False): Optimized Bubble Sort using early exit mechanism and bidirectional pass. Parameters: arr (list): List of integers to be sorted. simulation (bool): Flag to print the array at each step (default is False). Returns: list: Sorted list of integers. n = len(arr) start = 0 end = n - 1 swapped = True while swapped: swapped = False # Forward pass for i in range(start, end): if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] swapped = True if simulation: print(f\\"Forward pass: {arr}\\") if not swapped: break swapped = False end -= 1 # Backward pass for i in range(end, start, -1): if arr[i] < arr[i - 1]: arr[i], arr[i - 1] = arr[i - 1], arr[i] swapped = True if simulation: print(f\\"Backward pass: {arr}\\") start += 1 return arr"},{"question":"You need to implement a function to determine if there is a path between two nodes in a directed graph. Your function should use Depth First Search (DFS) to traverse the graph and check for connectivity. The graph will be represented as an adjacency list. # Function Signature ```python def is_reachable(graph, source, target): Determines if there is a path from source to target in the given graph. :param graph: Dictionary representing the adjacency list of the graph {node1: [neighbor1, neighbor2, ...], ...} :param source: The source node from which to start the search :param target: The target node to search for :return: Boolean indicating if there is a path from source to target pass ``` # Input - `graph`: A dictionary representing the adjacency list of the graph, where keys are node integers and values are lists of adjacent nodes. - `source`: An integer representing the starting node. - `target`: An integer representing the destination node to check connectivity. # Output - Returns `True` if there is a path from `source` to `target`, otherwise `False`. # Constraints - Each node in the graph will be a non-negative integer. - The number of nodes, `V`, can be up to `1000`. - The number of edges, `E`, can be up to `2000`. # Example ```python graph = { 0: [1, 2], 1: [2], 2: [3], 3: [3] } source = 1 target = 3 print(is_reachable(graph, source, target)) # Output: True source = 3 target = 1 print(is_reachable(graph, source, target)) # Output: False ``` # Notes - Consider possible edge cases such as: * The graph being empty. * Source or target nodes not existing in the graph. * Cyclic paths within the graph. - Be mindful of potential stack overflow issues with deep recursion and consider implementing an iterative version using a stack for very large graphs.","solution":"def is_reachable(graph, source, target): Determines if there is a path from source to target in the given graph using DFS. :param graph: Dictionary representing the adjacency list of the graph {node1: [neighbor1, neighbor2, ...], ...} :param source: The source node from which to start the search :param target: The target node to search for :return: Boolean indicating if there is a path from source to target if source not in graph: return False visited = set() stack = [source] while stack: node = stack.pop() if node == target: return True if node not in visited: visited.add(node) stack.extend(graph.get(node, [])) return False"},{"question":"# Context In data transfer and error correction, determining bit differences between sequences is crucial for diagnosing and correcting errors. This problem will assess your ability to manipulate and analyze binary data representations effectively. # Task Implement a function `count_min_flips_to_convert` that returns the minimal number of bit flips required to convert integer `A` to integer `B`. # Function Signature ```python def count_min_flips_to_convert(a: int, b: int) -> int: ``` # Input * `a (int)`: A non-negative integer. * `b (int)`: A non-negative integer. # Output * `int`: The minimal number of bit flips required to convert `a` to `b`. # Constraints * `0 <= a, b <= 10^9` # Example ```python # Example 1 Input: 29 (or: 11101), 15 (or: 01111) Output: 2 # Example 2 Input: 10 (or: 1010), 20 (or: 10100) Output: 4 ``` # Explanation - For the first example, flipping bits at index positions 1 and 3 (0-based index) in 11101 (binary representation of 29) will convert it to 01111 (binary representation of 15). # Additional Notes Consider edge cases such as when `a` and `b` are identical, or when one or both are zero.","solution":"def count_min_flips_to_convert(a: int, b: int) -> int: Returns the minimal number of bit flips required to convert integer `a` to integer `b`. # XOR of a and b will give a number with bits set at positions where a and b differ xor_result = a ^ b # Count the number of set bits in the result count_of_flips = bin(xor_result).count(\'1\') return count_of_flips"},{"question":"# Scenario: You have been hired by a company to assess their understanding of sorting algorithms. You decide to present a fun and educational challenge using the notorious Bogo Sort, hoping to illustrate the inefficiency of brute-force algorithms. # Task: Implement a function `is_sorted(arr)` that checks if an array is sorted in ascending order. Then, implement another function `improved_bogo_sort(arr)`. The function should: 1. Use the `is_sorted(arr)` function to check if the array is sorted. 2. If not sorted, perform random shuffling of the array until it becomes sorted. 3. Track the number of iterations it takes to sort the array and return both the sorted array and the iteration count. # Input and Output: * **Input**: A list of integers `arr`. * **Output**: A tuple comprised of: * The sorted list of integers `arr`. * An integer representing the number of iterations it took to sort the array. # Constraints: * You can assume that the array will have no more than 10 elements. * You should not use built-in sort functions. # Example: ```python input_array = [3, 1, 4, 1, 5] # Function call sorted_array, iteration_count = improved_bogo_sort(input_array) # Output example (exact number of iterations might vary) (sorted_array, iteration_count) = ([1, 1, 3, 4, 5], 34) ``` *Note*: While `improved_bogo_sort` is intentionally inefficient, ensure that your implementation leverages randomness appropriately and effectively to shuffle the array.","solution":"import random def is_sorted(arr): Checks if the array is sorted in ascending order. Parameters: arr (list): List of integers to check. Returns: bool: True if the list is sorted in ascending order, False otherwise. return all(arr[i] <= arr[i+1] for i in range(len(arr) - 1)) def improved_bogo_sort(arr): Sorts the array using the Bogo Sort algorithm. Parameters: arr (list): List of integers to sort. Returns: tuple: Sorted list of integers and the iteration count. iterations = 0 while not is_sorted(arr): random.shuffle(arr) iterations += 1 return arr, iterations"},{"question":"Scenario As a software developer in a company that processes large datasets daily, you are tasked with implementing a stable and efficient sorting algorithm. The key requirement is that the algorithm must handle very large arrays efficiently while ensuring that the relative order of equal elements is preserved. Task Implement the `merge_sort` function, which uses the merge sort algorithm to sort a list of integers in non-decreasing order. Write an efficient and correct implementation of the `merge_sort` and `merge` functions. Function Signatures ```python def merge_sort(arr: list) -> list: Sorts the input list using the Merge Sort algorithm. Args: arr (list): A list of integers to sort. Returns: list: A sorted list of integers in non-decreasing order. pass def merge(left: list, right: list, merged: list) -> None: Merges two sorted lists into the original list in non-decreasing order. Args: left (list): The sorted left half of the list. right (list): The sorted right half of the list. merged (list): The list where the merged output is stored. Returns: None pass ``` Input * A list of integers `arr` where `1 <= len(arr) <= 10^5`. * The values within the list are integers: `-10^6 <= arr[i] <= 10^6`. Output * Return a sorted list of integers in non-decreasing order. Constraints * The implementation should make efficient use of memory. * The merge function should be optimized to handle large arrays efficiently. * The algorithm should maintain stability (the relative order of equal elements should remain unchanged). Performance Requirements * Expected time complexity: O(n log(n)). * Expected space complexity: O(n). Example ```python # Input arr = [38, 27, 43, 3, 9, 82, 10] # Output result = [3, 9, 10, 27, 38, 43, 82] ``` Implement the `merge_sort` and `merge` functions to pass the given example and meet the performance requirements.","solution":"def merge_sort(arr: list) -> list: Sorts the input list using the Merge Sort algorithm. Args: arr (list): A list of integers to sort. Returns: list: A sorted list of integers in non-decreasing order. if len(arr) <= 1: return arr # Find the mid-point mid = len(arr) // 2 # Recursively split and merge left_half = merge_sort(arr[:mid]) right_half = merge_sort(arr[mid:]) # Merge the sorted halves merged = [] merge(left_half, right_half, merged) return merged def merge(left: list, right: list, merged: list) -> None: Merges two sorted lists into the original list in non-decreasing order. Args: left (list): The sorted left half of the list. right (list): The sorted right half of the list. merged (list): The list where the merged output is stored. Returns: None left_index, right_index = 0, 0 while left_index < len(left) and right_index < len(right): if left[left_index] <= right[right_index]: merged.append(left[left_index]) left_index += 1 else: merged.append(right[right_index]) right_index += 1 # Append any remaining elements from left or right list while left_index < len(left): merged.append(left[left_index]) left_index += 1 while right_index < len(right): merged.append(right[right_index]) right_index += 1"},{"question":"# Path Splitting Function for Various File Systems You\'ve been asked to implement a robust function that splits a given path into two parts: the base path and the final component. This scenario is common in file system management and URL parsing. Input * A single string `path` that could represent a URL or a file system path. Output * A list of two strings, where: * The first element is the base path (`base_path`). * The second element is the final component (`final_component`). Constraints * The separator may be `\'/\'` or `\'\'`. * Consider edge cases like root paths (`\'/\'`, `\'C:\'`) and paths without separators. Requirements * Write a function `split_path(path: str) -> [str, str]`. * The implementation should handle both types of path separators. * Do not use the `os` module for path splitting. Example ```python assert split_path(\\"https://algorithms/unix/test.py\\") == [\\"https://algorithms/unix\\", \\"test.py\\"] assert split_path(\\"algorithms/unix/test.py\\") == [\\"algorithms/unix\\", \\"test.py\\"] assert split_path(\\"C:usersdocumentsfile.txt\\") == [\\"C:usersdocuments\\", \\"file.txt\\"] assert split_path(\\"/\\") == [\\"\\", \\"\\"] assert split_path(\\"\\") == [\\"\\", \\"\\"] ``` Performance * Your solution should run efficiently with a time complexity of O(n), where `n` is the length of the input string.","solution":"def split_path(path: str) -> [str, str]: Splits the given path into base path and the final component. Args: path (str): The path to be split, which can include \'/\' or \'\' separators. Returns: list: A list containing the base path and the final component. if not path: return [\\"\\", \\"\\"] # Consider both forward slash and backslash as possible separators separators = [\'/\', \'\'] # Find the last occurrence of any separator last_index = -1 for sep in separators: if path.rfind(sep) > last_index: last_index = path.rfind(sep) # Split the path into base path and final component if last_index == -1: return [\\"\\", path] base_path = path[:last_index] final_component = path[last_index + 1:] return [base_path, final_component]"},{"question":"# Decoding Encoded Strings with Nested Patterns Context: You are given a string representing encoded messages. The encoding rule is defined as k[encoded_string], where the encoded_string inside the square brackets is repeated exactly k times. Your task is to implement a function to decode such encoded strings. # Problem Statement: Write a function `decode_string(encoded_str: str) -> str` that takes an encoded string and returns its decoded string version following the specified encoding rule. # Function Signature: ```python def decode_string(encoded_str: str) -> str ``` # Input: * `encoded_str`: a valid encoded string containing digits, letters, and square brackets, following the encoding rules. # Output: * Return the decoded string. # Constraints: * The input string will always be a well-formed encoded string with no whitespaces. * The original data will not contain any digits; digits are exclusively for repeat counts. # Examples: 1. For `encoded_str = \\"3[a]2[bc]\\"`, the function should return `\\"aaabcbc\\"`. 2. For `encoded_str = \\"3[a2[c]]\\"`, the function should return `\\"accaccacc\\"`. 3. For `encoded_str = \\"2[abc]3[cd]ef\\"`, the function should return `\\"abcabccdcdcdef\\"`. # Performance Requirements: * The solution should operate with a time complexity of O(n) and a space complexity of O(n), where n is the length of the input string. # Additional Challenge: Consider discussing with your peers or instructor: * How the algorithm might handle large or deeply nested inputs and any practical limitations that may arise. * Potential mechanisms to streamline the stack operations or manage memory more effectively for extreme cases.","solution":"def decode_string(encoded_str: str) -> str: This function takes an encoded string and returns the decoded string. The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is repeated exactly k times. :param encoded_str: A well-formed encoded string. :return: A decoded string. stack = [] current_num = 0 current_str = \\"\\" for char in encoded_str: if char.isdigit(): current_num = current_num * 10 + int(char) elif char == \'[\': stack.append(current_str) stack.append(current_num) current_str = \\"\\" current_num = 0 elif char == \']\': num = stack.pop() prev_str = stack.pop() current_str = prev_str + num * current_str else: current_str += char return current_str"},{"question":"# Flattening Nested Arrays Given an array that may contain nested arrays or other collections, write a function that flattens it into a single-level array. You must provide two implementations: one that returns a flattened list, and another that returns a generator for lazy evaluation. **Function Signatures** ```python def flatten(input_arr: list) -> list: pass def flatten_iter(iterable: Iterable) -> Iterable: pass ``` **Input** * `input_arr` (for `flatten`): A list that may contain integers, strings, other lists, or any combination thereof. * `iterable` (for `flatten_iter`): A multi-dimensional iterable. **Output** * `flatten`: Returns a list flattened into a single level. * `flatten_iter`: Returns an iterator yielding elements in a flattened structure. **Constraints** * Strings should not be treated as iterables. * The input lists can have mixed types (e.g., [1, \'a\', [2, [3, \'b\']], 4]). * Aim for a time complexity of O(n) for both implementations. * `flatten`: Ensure no limit on depth of nested arrays (avoid stack overflow). * `flatten_iter`: Use lazy evaluation to minimize memory usage. **Performance Requirements** * You should efficiently handle deeply nested arrays. * For `flatten`, avoid excessive memory usage and stack overflow. * For `flatten_iter`, ensure minimal memory consumption by leveraging generators. **Scenario** Consider a company processing multi-level hierarchical data structures containing various data types. They need an efficient way to transform these structures into flat lists for streamlined data handling and simple algorithms that cannot handle complex nested collections. You have been asked to provide both a direct approach (for simpler use cases) and an efficient lazy approach (for large-scale or memory-limited operations). **Examples** Example 1: ```python input_arr = [1, [2, [3, 4]], 5] print(flatten(input_arr)) # Output: [1, 2, 3, 4, 5] print(list(flatten_iter(input_arr))) # Output: [1, 2, 3, 4, 5] ``` Example 2: ```python input_arr = [\'a\', [\'b\', [\'c\', \'d\']], \'e\'] print(flatten(input_arr)) # Output: [\'a\', \'b\', \'c\', \'d\', \'e\'] print(list(flatten_iter(input_arr))) # Output: [\'a\', \'b\', \'c\', \'d\', \'e\'] ``` Example 3: ```python input_arr = [1, \'a\', [2, [3, \'b\']], 4] print(flatten(input_arr)) # Output: [1, \'a\', 2, 3, \'b\', 4] print(list(flatten_iter(input_arr))) # Output: [1, \'a\', 2, 3, \'b\', 4] ```","solution":"from collections.abc import Iterable def flatten(input_arr): Flattens a nested list into a single-level list. flattened_list = [] for item in input_arr: if isinstance(item, list): flattened_list.extend(flatten(item)) else: flattened_list.append(item) return flattened_list def flatten_iter(iterable): Lazily flattens a multi-dimensional iterable. for item in iterable: if isinstance(item, Iterable) and not isinstance(item, (str, bytes)): yield from flatten_iter(item) else: yield item"},{"question":"**Cycle Sort Algorithm Implementation** You are given an array of integers. Your task is to implement the Cycle Sort algorithm to sort the array in ascending order. The Cycle Sort algorithm minimizes the number of write operations, making it useful in scenarios where writing data is costly. # Function Signature ```python def cycle_sort(arr: List[int]) -> List[int]: pass ``` # Input - `arr`: A list of `n` integers, where `1 <= n <= 10^4`. The list can contain duplicate entries. # Output - Returns the sorted list of integers in ascending order. # Constraints - Focus on minimizing the number of writes. - Do not use any additional space except the input array (in-place sorting). # Scenarios - The array may be empty or contain one integer, in which case it should return the same array. - There might be duplicate integers; handle them correctly while finding cycles. # Example ```python assert cycle_sort([8, 3, 2, 5, 9, 1]) == [1, 2, 3, 5, 8, 9] assert cycle_sort([4, 4, 4, 4]) == [4, 4, 4, 4] assert cycle_sort([3, 3, 2, 2, 1, 1]) == [1, 1, 2, 2, 3, 3] assert cycle_sort([]) == [] assert cycle_sort([100]) == [100] ``` Implement the `cycle_sort` function to solve the above problem effectively while adhering to the mentioned constraints and minimizing the number of write operations.","solution":"def cycle_sort(arr): Sorts the array in-place using Cycle Sort algorithm and returns the sorted array. # Find the length of the array n = len(arr) # Traverse the array elements to find cycles for cycle_start in range(0, n - 1): item = arr[cycle_start] # Find the position where we put the element pos = cycle_start for i in range(cycle_start + 1, n): if arr[i] < item: pos += 1 # If the item is already in the correct position if pos == cycle_start: continue # Ignore all-the-same elements while item == arr[pos]: pos += 1 # Put the item to its correct position arr[pos], item = item, arr[pos] # Rotate the rest of the cycle while pos != cycle_start: pos = cycle_start for i in range(cycle_start + 1, n): if arr[i] < item: pos += 1 while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] return arr"},{"question":"# Keeping Element Frequency Under Control Objective Given a list of integers `lst` and a positive integer `N`, create a function `delete_nth(lst, N)` that returns a new list containing each number in `lst` at most `N` times without reordering the elements. Input * `lst`: A list of integers, where 0 <= len(lst) <= 10^6. * `N`: A positive integer (1 <= N <= 10^9). Output * A new list with each integer appearing at most `N` times. Function Signature ```python def delete_nth(lst, N): pass ``` Constraints * Maintain the original order of elements in `lst`. * The function should be efficient in terms of time complexity. Examples ```python # Example 1: # Input: lst = [1, 2, 3, 1, 2, 1, 2, 3] N = 2 # Output: # [1, 2, 3, 1, 2, 3] # Example 2: # Input: lst = [1, 1, 1, 1] N = 2 # Output: # [1, 1] # Example 3: # Input: lst = [20, 37, 20, 21] N = 1 # Output: # [20, 37, 21] ``` Additional Notes * Consider edge cases such as empty lists and lists where each element\'s required frequency is already compliant with `N`. * The implementation should handle large inputs efficiently, ensuring performance requirements are met.","solution":"def delete_nth(lst, N): Returns a new list where each number in lst appears at most N times, without reordering the elements. from collections import defaultdict result = [] counts = defaultdict(int) for number in lst: if counts[number] < N: result.append(number) counts[number] += 1 return result"},{"question":"You are given a task to design an efficient algorithm to encode a list of strings into a single string and then decode it back to the original list of strings. This encoded string can be sent over a network and later decoded, ensuring that the original data is retained accurately. Requirements 1. Implement two functions: * `encode(strs)`: Encodes a list of strings `strs` to a single string. * `decode(s)`: Decodes the single encoded string `s` back to a list of strings. 2. Ensure that the process can handle any characters contained within the strings, including the delimiter `:` used in the encoding process. # Function Specifications 1. **encode** ```python def encode(strs: List[str]) -> str: ``` - **Input**: A list of strings `strs`, where `strs[i]` is a string. - **Output**: A single string that is the encoded representation of the input list. 2. **decode** ```python def decode(s: str) -> List[str]: ``` - **Input**: A single encoded string `s`. - **Output**: A list of strings that were originally encoded into the input string. # Constraints * The input list may contain any ASCII character, including the delimiter `:`. * You may assume that the strings in the list are non-empty to simplify the logic. # Example ```python strs = [\\"hello\\", \\"world\\"] encoded_str = encode(strs) print(encoded_str) # Output: \\"5:hello5:world\\" decoded_list = decode(encoded_str) print(decoded_list) # Output: [\\"hello\\", \\"world\\"] ``` # Additional Notes - Ensure that your solution handles edge cases, such as lists containing empty strings or strings with special characters. - Optimize your solution where possible to handle large datasets efficiently.","solution":"from typing import List def encode(strs: List[str]) -> str: Encodes a list of strings to a single string. Each string is encoded with its length followed by the \':\' character and then the string itself. Example: [\\"hello\\", \\"world\\"] -> \\"5:hello5:world\\" encoded_str = \'\'.join(f\'{len(s)}:{s}\' for s in strs) return encoded_str def decode(s: str) -> List[str]: Decodes a single string back to a list of strings. Each string is prefixed with its length followed by the \':\' character. Example: \\"5:hello5:world\\" -> [\\"hello\\", \\"world\\"] i, n = 0, len(s) decoded = [] while i < n: j = i while s[j] != \':\': j += 1 length = int(s[i:j]) decoded.append(s[j+1:j+1+length]) i = j + 1 + length return decoded"},{"question":"# Fibonacci Number Calculation Challenge Objective You are to implement a function that computes the n-th Fibonacci number using an optimized approach that efficiently handles very large values of n. Description The Fibonacci sequence is defined as follows: - F(0) = 0 - F(1) = 1 - F(n) = F(n-1) + F(n-2) for n > 1 You need to write a function `optimized_fib(n)` that calculates the n-th Fibonacci number. Function Signature ```python def optimized_fib(n: int) -> int: ``` Input - An integer `n` (0 <= n <= 10^18) Output - An integer representing the n-th Fibonacci number. Constraints 1. The function should run in O(log n) time complexity. 2. Use constant space O(1). Examples ```python assert optimized_fib(0) == 0 assert optimized_fib(1) == 1 assert optimized_fib(10) == 55 assert optimized_fib(50) == 12586269025 ``` Note: - Think through the performance implications of standard approaches and aim to leverage matrix exponentiation or fast doubling algorithm.","solution":"def optimized_fib(n: int) -> int: Computes the n-th Fibonacci number using an optimized approach. def matrix_mult(A, B): return [ [A[0][0]*B[0][0] + A[0][1]*B[1][0], A[0][0]*B[0][1] + A[0][1]*B[1][1]], [A[1][0]*B[0][0] + A[1][1]*B[1][0], A[1][0]*B[0][1] + A[1][1]*B[1][1]] ] def matrix_pow(M, p): res = [[1, 0], [0, 1]] # Identity matrix while p > 0: if p % 2 == 1: res = matrix_mult(res, M) M = matrix_mult(M, M) p //= 2 return res if n == 0: return 0 if n == 1: return 1 F = [[1, 1], [1, 0]] result = matrix_pow(F, n-1) return result[0][0]"},{"question":"Question: Design a Resizable and Thread-Safe HashTable # Context You are tasked with enhancing a basic hash table implementation by introducing the capability to handle concurrent accesses using thread synchronization in Python. The current hash table needs to be able to handle concurrent inserts, deletions, and searches without data corruption or racing conditions. Your modified data structure should support dynamic resizing when the load factor exceeds a certain threshold. # Task Implement a thread-safe and resizable hash table in Python. You need to provide a solution that properly synchronizes access to the hash table to handle multiple threads performing operations on the hash table concurrently. # Requirements 1. **Class Definition**: Define a class `ThreadSafeHashTable` which extends the existing `ResizableHashTable`. 2. **Thread Safety**: - Use appropriate synchronization primitives such as `threading.Lock` or `threading.RLock`. - Ensure that all public methods (`put`, `get`, `del_`) are thread-safe. 3. **Resizing**: Preserve the dynamic resizing behavior when the load factor exceeds 2/3. 4. **Testing**: Implement a function to test the concurrent accesses to the hash table. # Function Signatures ```python class ThreadSafeHashTable(ResizableHashTable): def __init__(self): super().__init__() def put(self, key, value): # implement with thread safety def get(self, key): # implement with thread safety def del_(self, key): # implement with thread safety def test_thread_safe_hash_table(): # function to test concurrent accesses ``` # Constraints 1. **Key Constraints**: Keys are integers. 2. **Value Constraints**: Values can be any Python object. 3. **Concurrency**: At least 1000 concurrent operations. 4. **Performance**: Ensure minimal performance overhead added by synchronization. # Example Usage ```python import threading def test_operations(hash_table): for i in range(10000): hash_table.put(i, i*2) assert hash_table.get(i) == i*2 hash_table.del_(i) assert hash_table.get(i) is None if __name__ == \\"__main__\\": hash_table = ThreadSafeHashTable() threads = [threading.Thread(target=test_operations, args=(hash_table,)) for _ in range(10)] for thread in threads: thread.start() for thread in threads: thread.join() print(\\"All tests passed.\\") ``` You must ensure that the `ThreadSafeHashTable` handles the concurrent read and write operations correctly by implementing proper synchronization. Write the complete class implementation and the test function.","solution":"import threading class ResizableHashTable: def __init__(self): self.capacity = 8 self.size = 0 self.buckets = [[] for _ in range(self.capacity)] self.load_factor_threshold = 2 / 3 def _hash(self, key): return key % self.capacity def _resize(self): old_buckets = self.buckets self.capacity *= 2 self.size = 0 self.buckets = [[] for _ in range(self.capacity)] for bucket in old_buckets: for key, value in bucket: self.put(key, value) def put(self, key, value): if self.size / self.capacity > self.load_factor_threshold: self._resize() bucket_index = self._hash(key) bucket = self.buckets[bucket_index] for i, (k, v) in enumerate(bucket): if k == key: bucket[i] = (key, value) return bucket.append((key, value)) self.size += 1 def get(self, key): bucket_index = self._hash(key) bucket = self.buckets[bucket_index] for k, v in bucket: if k == key: return v return None def del_(self, key): bucket_index = self._hash(key) bucket = self.buckets[bucket_index] for i, (k, v) in enumerate(bucket): if k == key: del bucket[i] self.size -= 1 return True return False class ThreadSafeHashTable(ResizableHashTable): def __init__(self): super().__init__() self.lock = threading.RLock() def put(self, key, value): with self.lock: super().put(key, value) def get(self, key): with self.lock: return super().get(key) def del_(self, key): with self.lock: return super().del_(key)"},{"question":"# Question Context: You are given a list of integers, and you need to handle multiple range queries efficiently. Each query can be one of the following: 1. Get the maximum value in a specified range. 2. Update the value of an element at a specified index. To facilitate these operations efficiently, you decide to use a Segment Tree data structure. Task: Implement a class `SegmentTree` that supports the following methods: - **`__init__(self, arr)`**: Initializes the Segment Tree with the given array `arr`. - **`update(self, index, value)`**: Updates the element at the given index to the new value. - **`query(self, left, right)`**: Returns the maximum value in the array segment between indices `left` and `right` (inclusive). Method Specifications: - **`__init__(self, arr)`**: - **Input**: List of integers `(arr)` - **Output**: None. - **`update(self, index, value)`**: - **Input**: - `index`: Integer representing the index to be updated. - `value`: New value to be set at the specified index. - **Output**: None. - **`query(self, left, right)`**: - **Input**: - `left`: Starting index of the query range. - `right`: Ending index of the query range. - **Output**: Integer indicating the maximum value in the specified range. Constraints: - The input list will have at most `10^5` elements. - Each element in the list will be a non-negative integer. - Each update and query operation should be executed in logarithmic time complexity. Example: ```python arr = [2, 1, 5, 3, 4] seg_tree = SegmentTree(arr) print(seg_tree.query(1, 3)) # Output: 5 seg_tree.update(1, 6) print(seg_tree.query(1, 3)) # Output: 6 ``` Implementation: Implement the `SegmentTree` class as described above.","solution":"class SegmentTree: def __init__(self, arr): self.n = len(arr) self.tree = [0] * (2 * self.n) self.build(arr) def build(self, arr): # Initialize leaves in the segment tree for i in range(self.n): self.tree[self.n + i] = arr[i] # Initialize the internal nodes for i in range(self.n - 1, 0, -1): self.tree[i] = max(self.tree[i * 2], self.tree[i * 2 + 1]) def update(self, index, value): # Set value at the position index pos = index + self.n self.tree[pos] = value # Move upward and update the values while pos > 1: pos //= 2 self.tree[pos] = max(self.tree[2 * pos], self.tree[2 * pos + 1]) def query(self, left, right): # Initialize pointers and result result = 0 left += self.n right += self.n + 1 # Traverse and find the maximum value while left < right: if left % 2 == 1: result = max(result, self.tree[left]) left += 1 if right % 2 == 1: right -= 1 result = max(result, self.tree[right]) left //= 2 right //= 2 return result"},{"question":"Background You have been provided a singly linked list of integers where some values may repeat. Your task is to implement a function to remove duplicate values from the linked list without using additional data structures (like sets or dictionaries). Objectives - Implement a function `remove_dups_optimized(head: Node) -> None` in Python which removes duplicates directly within the provided linked list. - You must adhere to O(N^2) time complexity and O(1) extra space complexity constraints. Constraints 1. The linked list contains integers. 2. The values could range between -10^5 to 10^5. 3. The number of nodes (N) is at most 10^4. Input/Output Format - **Input**: - A singly linked list represented as `Node` objects where each Node has a `.val` attribute (integer) and a `.next` attribute (pointer to the next node or None). - **Output**: - The function should return `None`. - Modify the linked list in place to remove the duplicate values. - The linked list should maintain the order of the first occurrence of each element. Example Given the linked list: ``` 3 -> 3 -> 1 -> 2 -> 2 -> 3 -> 4 -> 4 ``` After `remove_dups_optimized`, the list should be: ``` 3 -> 1 -> 2 -> 4 ``` Edge Cases to Consider 1. The linked list is empty. 2. The linked list has only one element. 3. All elements in the list are the same. Function Signature ```python def remove_dups_optimized(head: Node) -> None: pass ``` Scenario/Context Imagine you\'re working on a system that processes large datasets, where unique values need to be maintained and memory usage is critical. This function will aid in efficiently cleaning the data for further processing.","solution":"class Node: def __init__(self, val=0, next=None): self.val = val self.next = next def remove_dups_optimized(head: Node) -> None: if not head: return current = head while current: runner = current while runner.next: if runner.next.val == current.val: runner.next = runner.next.next else: runner = runner.next current = current.next"},{"question":"# Context A Red-Black Tree is a self-balancing binary search tree that ensures the tree\'s height remains balanced, guaranteeing efficient operations. Your task is to enhance the above-provided Red-Black Tree implementation with additional functionality. # Problem Statement Implement a method in the given `RBTree` class to find the rank of a given node within the Red-Black Tree. The rank of a node is defined as the number of nodes that are less than or equal to this node. # Function Signature ```python def get_rank(self, val: int) -> int: Get the rank of the node with value `val` in the Red-Black Tree. :param val: The value of the node whose rank needs to be found. :return: The rank of the node. ``` # Input - `val` (int): The value of the node whose rank needs to be found. # Output - Return an integer representing the rank of the node with value `val`. # Constraints - Assume the given value `val` exists in the tree. - The method will be called on a valid Red-Black Tree instance. # Example ```python rb = RBTree() values = [11, 2, 14, 1, 7, 15, 5, 8, 4] for value in values: rb.insert(RBNode(value, 1)) # Find ranks print(rb.get_rank(7)) # Output should be 5 print(rb.get_rank(14)) # Output should be 8 print(rb.get_rank(1)) # Output should be 1 ``` # Hint Consider using an in-order traversal of the tree to determine the rank, or keep track of subtree sizes during tree modifications to achieve it more efficiently.","solution":"class RBNode: def __init__(self, val, color, left=None, right=None, parent=None): self.val = val self.color = color self.left = left self.right = right self.parent = parent self.size = 1 # Size of the subtree rooted with this node class RBTree: def __init__(self): self.TNULL = RBNode(None, 0) self.root = self.TNULL def insert(self, node): # Standard BST insert # (this is a simplified version; omitting the balancing part) node.left = self.TNULL node.right = self.TNULL node.color = 1 # New node must be red y = None x = self.root while x != self.TNULL: y = x x.size += 1 # Increment size of ancestors if node.val < x.val: x = x.left else: x = x.right node.parent = y if y is None: self.root = node elif node.val < y.val: y.left = node else: y.right = node if node.parent is None: node.color = 0 return if node.parent.parent is None: return # Balancing part omitted for brevity def get_rank(self, val: int) -> int: def get_size(node): if node == self.TNULL: return 0 else: return node.size def find_rank(node, val): if node == self.TNULL: return 0 if val == node.val: return get_size(node.left) + 1 elif val < node.val: return find_rank(node.left, val) else: return get_size(node.left) + 1 + find_rank(node.right, val) return find_rank(self.root, val)"},{"question":"**Question: Increment a Large Integer Represented as an Array of Digits** You are given a non-negative integer represented as a list of digits, stored in big-endian order (the most significant digit is at the head of the list). Implement a function that adds one to this integer. If the list is empty or includes any non-digit elements, return an empty list. # Function Signature ```python def increment_digit_array(digits: List[int]) -> List[int]: :param digits: List[int] - A list of single digit integers representing the number. :return: List[int] - The result of adding one to the number. ``` # Input * `digits`: A list of integers (0 <= digits[i] <= 9), representing the digits of a non-negative integer. # Output * Return a list of integers representing the incremented number. # Constraints * Your function should handle lists with up to 10^4 digits. * If input list is empty or contains elements that are not single-digit integers, return an empty list. # Example ```python # Example 1: digits = [1, 2, 3] # After adding one, it becomes [1, 2, 4] assert increment_digit_array(digits) == [1, 2, 4] # Example 2: digits = [9, 9, 9] # After adding one, it becomes [1, 0, 0, 0] assert increment_digit_array(digits) == [1, 0, 0, 0] # Example 3: digits = [] # An empty list should return an empty list assert increment_digit_array(digits) == [] # Example 4: digits = [0] # Adding one to [0] gives [1] assert increment_digit_array(digits) == [1] # Example 5: digits = [1, 2, \'a\'] # Invalid input should return an empty list assert increment_digit_array(digits) == [] ``` # Performance Requirements * Time complexity should be O(n), where `n` is the number of digits. * Space complexity should be O(1), meaning the function optimally modifies the input list in place without using additional storage proportional to the list size. # Main Points to Consider * Ensure your function handles carry-over properly. * Validate input to meet constraints (only single digits allowed). * Optimize for in-place modification to minimize memory usage.","solution":"from typing import List def increment_digit_array(digits: List[int]) -> List[int]: This function takes a list of integers representing the digits of a number and increments the number by one. Validates input to only contain single digit integers and handles carry-over. if not digits or any(not isinstance(digit, int) or digit < 0 or digit > 9 for digit in digits): return [] n = len(digits) for i in range(n-1, -1, -1): if digits[i] < 9: digits[i] += 1 return digits digits[i] = 0 return [1] + digits"},{"question":"# Linked List Duplicate Removal Problem Statement You are given a singly linked list where each node contains an alphanumeric character. Implement a function to remove all duplicate elements from the linked list. Function Signature ```python def remove_duplicates(head: Node) -> Node: # Your code here ``` Input - `head`: The head node of the singly linked list. Output - Returns the head node of the modified linked list with duplicates removed. Example Consider the following linked list: ``` A -> A -> B -> C -> D -> C -> F -> G ``` After removing duplicates, the linked list should be: ``` A -> B -> C -> D -> F -> G ``` Constraints - The input linked list can contain up to `100,000` nodes. - Only alphanumeric characters (both uppercase and lowercase) are considered. - Try to optimize for both time and space where possible. Performance Requirements - Aim for linear time complexity with moderate space usage. - Avoid quadratic time complexity if possible. Existing Code You can use the following code to define the `Node` class and helper functions for testing: ```python class Node(): def __init__(self, val = None): self.val = val self.next = None def print_linked_list(head): string = \\"\\" while head: string += head.val + \\" -> \\" head = head.next string = string[:-4] # Remove the last arrow print(string) a1 = Node(\\"A\\") a2 = Node(\\"A\\") b = Node(\\"B\\") c1 = Node(\\"C\\") d = Node(\\"D\\") c2 = Node(\\"C\\") f = Node(\\"F\\") g = Node(\\"G\\") a1.next = a2 a2.next = b b.next = c1 c1.next = d d.next = c2 c2.next = f f.next = g updated_head = remove_duplicates(a1) print_linked_list(updated_head) ```","solution":"class Node(): def __init__(self, val = None): self.val = val self.next = None def remove_duplicates(head: Node) -> Node: if not head: return head seen = set() current = head seen.add(current.val) while current and current.next: if current.next.val in seen: current.next = current.next.next else: seen.add(current.next.val) current = current.next return head"},{"question":"Context: You are working on a data analysis project that involves processing large hierarchical data stored in binary search trees (BSTs). One of the tasks requires determining how many nodes in the tree are left children. As an experienced programming instructor, you are asked to design a function that counts the number of left children in a BST. This exercise will help students understand tree traversal and conditional logic. Task: Write a function `count_left_nodes(root)` that returns the number of left children in a binary search tree. Input Format: * A reference to the root node of a BST, where each node has attributes: * `val`: The value stored in the node. * `left`: A reference to the left child node or `None`. * `right`: A reference to the right child node or `None`. Constraints: * The BST can contain up to 10,000 nodes. * Node values are unique and within the range [-10^5, 10^5]. Output Format: * An integer representing the count of left children in the BST. Example: Consider the following BST: ``` 9 / 6 12 / / 3 8 10 15 / 7 18 ``` For this BST, `count_left_nodes(root)` should return `4`. Function Signature: ```python def count_left_nodes(root): pass ``` Assessment Criteria: * Correctly identifies left children and counts them. * Handles edge cases such as empty trees or trees with only one node. * Efficiency in terms of time and space complexity. * Proper handling of recursive and base cases.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def count_left_nodes(root): Returns the number of left children in a binary search tree. if root is None: return 0 left_count = 1 if root.left else 0 return left_count + count_left_nodes(root.left) + count_left_nodes(root.right)"},{"question":"You are given a list of integers `numbers` already sorted in ascending order, and an integer `target`. Your task is to find two numbers such that they add up to `target` and return their indices as a list `[index1, index2]`. The returned indices are not zero-based and should be in increasing order. Each input will have exactly one solution, and you may not use the same element twice. # Requirements: 1. Implement the function `two_sum3` to solve the problem using any method of your choice. 2. Consider edge cases and handle them appropriately. 3. Ensure that your solution is at least (O(n log n)) in time complexity. ```python def two_sum3(numbers, target): Given a list of numbers sorted in ascending order, find the indices of two numbers such that their sum is the given target. Args: numbers (List[int]): A list of integers sorted in non-decreasing order. target (int): An integer representing the target sum. Returns: List[int]: A list containing two elements, which are the 1-based indices of the two numbers summing up to target. # implement your solution here ``` # Input: - `numbers`: A list of integers sorted in non-decreasing order. (2 <= len(numbers) <= 10^4) - `target`: An integer (target <= 2 * 10^4) # Output: - A list of two integers, which are the 1-based indices of the two numbers summing up to the target. `[index1, index2]` # Constraints: - The input list `numbers` will contain at least two elements. - There will always be exactly one solution. # Example: Input: ```python numbers = [2, 7, 11, 15] target = 9 ``` Output: ```python [1, 2] ``` # Explanation: In the provided input, numbers[0] + numbers[1] = 2 + 7 = 9. Therefore, the 1-based index answer is `[1, 2]`.","solution":"def two_sum3(numbers, target): Given a list of numbers sorted in ascending order, find the indices of two numbers such that their sum is the given target. Args: numbers (List[int]): A list of integers sorted in non-decreasing order. target (int): An integer representing the target sum. Returns: List[int]: A list containing two elements, which are the 1-based indices of the two numbers summing up to target. left, right = 0, len(numbers) - 1 while left < right: current_sum = numbers[left] + numbers[right] if current_sum == target: return [left + 1, right + 1] elif current_sum < target: left += 1 else: right -= 1 return [] # As per the problem statement, there will always be exactly one solution so this line should never be reached."},{"question":"# Question: You are given a nested dictionary-like structure representing a tree and your task is to implement a function `enhanced_tree_print` that traverses this tree and prints its elements in a defined formatted manner. The tree structure for the example might look something like: ```python tree = { \'a\': [\'Adam\', \'Book\', 4], \'b\': [\'Bill\', \'Computer\', 5, \'TV\', 6, \'Jill\', \'Sports\', 1], \'c\': [\'Bill\', \'Sports\', 3], \'d\': [\'Adam\', \'Computer\', 3, \'Quin\', \'Computer\', 3], \'e\': [\'Quin\', \'Book\', 5, \'TV\', 2], \'f\': [\'Adam\', \'Computer\', 7] } ``` Your function `enhanced_tree_print` should print this tree\'s content in a specific format, ensuring to handle the nested elements correctly and maintaining the structure. For example, within each key-value pair, every element should be connected via arrows (`->`). Input - A dictionary-like tree structure where: - Key is a string. - Value is a list that can contain a mix of strings and integers. Output - Prints the tree structure in the formatted manner as described. Example For the input tree: ```python tree = { \'a\': [\'Adam\', \'Book\', 4], \'b\': [\'Bill\', \'Computer\', 5, \'TV\', 6, \'Jill\', \'Sports\', 1], \'c\': [\'Bill\', \'Sports\', 3], \'d\': [\'Adam\', \'Computer\', 3, \'Quin\', \'Computer\', 3], \'e\': [\'Quin\', \'Book\', 5, \'TV\', 2], \'f\': [\'Adam\', \'Computer\', 7] } ``` The output should be: ``` a -> Adam -> Book -> 4 b -> Bill -> Computer -> 5 -> TV -> 6 -> Jill -> Sports -> 1 c -> Bill -> Sports -> 3 d -> Adam -> Computer -> 3 -> Quin -> Computer -> 3 e -> Quin -> Book -> 5 -> TV -> 2 f -> Adam -> Computer -> 7 ``` ***Note***: Ensure that there is a new line after printing each key\'s elements and properly handle indentation. Constraints - Assume all inputs are valid dictionaries with correctly nested lists. Implement the function `enhanced_tree_print(tree)` in Python. ```python def enhanced_tree_print(tree): # Your code here # Example usage: tree = { \'a\': [\'Adam\', \'Book\', 4], \'b\': [\'Bill\', \'Computer\', 5, \'TV\', 6, \'Jill\', \'Sports\', 1], \'c\': [\'Bill\', \'Sports\', 3], \'d\': [\'Adam\', \'Computer\', 3, \'Quin\', \'Computer\', 3], \'e\': [\'Quin\', \'Book\', 5, \'TV\', 2], \'f\': [\'Adam\', \'Computer\', 7] } enhanced_tree_print(tree) ```","solution":"def enhanced_tree_print(tree): Prints the tree structure in a formatted manner where each element is connected via arrows (->). for key, values in tree.items(): elements = \' -> \'.join(map(str, values)) print(f\\"{key} -> {elements}\\") # Example usage: tree = { \'a\': [\'Adam\', \'Book\', 4], \'b\': [\'Bill\', \'Computer\', 5, \'TV\', 6, \'Jill\', \'Sports\', 1], \'c\': [\'Bill\', \'Sports\', 3], \'d\': [\'Adam\', \'Computer\', 3, \'Quin\', \'Computer\', 3], \'e\': [\'Quin\', \'Book\', 5, \'TV\', 2], \'f\': [\'Adam\', \'Computer\', 7] } enhanced_tree_print(tree)"},{"question":"Your task is to implement a function to decode a given encoded string according to the specific encoding rule provided. The encoding rule is: `k[encoded_string]`, where the `encoded_string` inside the square brackets is repeated exactly `k` times. You are guaranteed that `k` is a positive integer. The input string is always valid with well-formed square brackets and no extra spaces. # Function Signature ```python def decode_string(s: str) -> str: :param s: encoded string :type s: str :return: decoded string :rtype: str ``` # Input * A single string `s` which is the encoded string. The string is guaranteed to contain only digits, square brackets, and lowercase alphabetic characters. # Output * A single string which is the decoded output of the given input string. # Constraints * The length of the input string (1 leq |s| leq 30). # Examples ```python assert decode_string(\\"3[a]2[bc]\\") == \\"aaabcbc\\" assert decode_string(\\"3[a2[c]]\\") == \\"accaccacc\\" assert decode_string(\\"2[abc]3[cd]ef\\") == \\"abcabccdcdcdef\\" ``` # Notes * The input string does not contain any digits other than those used for the repeat numbers (`k`). * Only the repeat numbers (`k`) are digits; the rest of the parts of the string are alphabetic characters in lowercase or valid square brackets. Implement the function `decode_string` to decode the given encoded string and return the fully expanded string.","solution":"def decode_string(s: str) -> str: Decodes the given encoded string as per the `k[encoded_string]` rule. :param s: encoded string :type s: str :return: decoded string :rtype: str stack = [] current_num = 0 current_string = \'\' for char in s: if char.isdigit(): current_num = current_num * 10 + int(char) elif char == \'[\': stack.append(current_string) stack.append(current_num) current_string = \'\' current_num = 0 elif char == \']\': num = stack.pop() prev_string = stack.pop() current_string = prev_string + num * current_string else: current_string += char return current_string"},{"question":"# Scenario: Imagine you are working on a software application that processes large logs of user interactions which contain a lot of repeated patterns. To optimize storage and transmission, the logs are compressed using Run-Length Encoding (RLE). However, you need to extend the capabilities of your system by implementing functions that not only encode but also decode the data to its original form. # Task: Write two functions, `encode_rle` and `decode_rle`, to handle the encoding and decoding of strings using the Run-Length Encoding method. # Details: 1. **encode_rle**: * **Input**: A string that may contain repeated characters. * **Output**: A compressed string using Run-Length Encoding. * **Examples**: * `encode_rle(\'aaabbbcc\')` -> `\'3a3b2c\'` * `encode_rle(\'abc\')` -> `\'1a1b1c\'` 2. **decode_rle**: * **Input**: A string that represents data compressed with Run-Length Encoding. * **Output**: The original uncompressed string. * **Examples**: * `decode_rle(\'3a3b2c\')` -> `\'aaabbbcc\'` * `decode_rle(\'1a1b1c\')` -> `\'abc\'` # Constraints: * The encoded string will only contain characters and digits, no special characters or spaces. * The maximum length of the input string for encoding/decoding will be 10^6 characters. Implementations should aim for optimal performance and handle edge cases robustly.","solution":"def encode_rle(input_string): Encodes the input string using Run-Length Encoding (RLE). :param input_string: string to be encoded :return: RLE encoded string if not input_string: return \'\' encoded_string = \'\' current_char = input_string[0] count = 1 for char in input_string[1:]: if char == current_char: count += 1 else: encoded_string += str(count) + current_char current_char = char count = 1 encoded_string += str(count) + current_char return encoded_string def decode_rle(encoded_string): Decodes a RLE encoded string back to its original form. :param encoded_string: RLE encoded string :return: decoded original string if not encoded_string: return \'\' decoded_string = \'\' count = \'\' for char in encoded_string: if char.isdigit(): count += char else: decoded_string += char * int(count) count = \'\' return decoded_string"},{"question":"# Gnome Sort Implementation Task **Scenario**: You have been given a sorting problem where simplicity and minimal space usage are more important than execution speed. Your task is to implement the Gnome Sort algorithm, maintaining an in-place sorting mechanism. **Problem Statement**: Write a function `gnome_sort(arr)` that sorts a list of integers in non-decreasing order using the Gnome Sort algorithm. The function should modify the list in place and return it. **Function Signature**: ```python def gnome_sort(arr: List[int]) -> List[int]: ``` **Input**: * `arr`: A list of integers (e.g., `[3, 2, 5, 1, 4]`) **Output**: * The function should return the same list `arr`, sorted in non-decreasing order. **Constraints**: * The list length can be between `0` and `10^4`. * The integers can be any value between `-10^9` and `10^9`. **Performance Requirements**: * The algorithm should run with a time complexity of O(n) in the best case and O(n^2) in the worst case. * The space complexity should remain O(1). **Example**: ```python arr = [34, 2, 10, -9] result = gnome_sort(arr) print(result) # Output: [-9, 2, 10, 34] ``` **Notes**: * Consider edge cases such as empty arrays and arrays with one element. * Focus on ensuring the algorithm is implemented in place without using extra space.","solution":"def gnome_sort(arr): Sorts a list of integers in-place using the Gnome Sort algorithm. Parameters: arr (List[int]): The list of integers to be sorted. Returns: List[int]: The same list, sorted in non-decreasing order. index = 0 while index < len(arr): if index == 0 or arr[index] >= arr[index - 1]: index += 1 else: arr[index], arr[index - 1] = arr[index - 1], arr[index] index -= 1 return arr"},{"question":"Problem Statement Implement a function to flatten an array of arrays into a single flat array. You need to handle both recursive nested arrays and deep levels of nesting without exhausting memory for large input sizes. This should be done using a generator that yields elements one at a time. # Function Signature ```python def flatten_generator(nested_array): # your code here pass ``` # Input * `nested_array`: A list that may contain nested lists. The nested elements can vary in depth. # Output The function should be a generator that yields each element of the nested list in a flattened format. # Requirements * You must use a generator (`yield from` or `yield`) and cannot use additional data structures that store intermediate results. * The function should handle arbitrarily deeply nested structures without exceeding Python\'s maximum recursion depth. # Constraints * The elements of the array will be of type int or list. No other types or empty arrays will be tested. * The result should maintain the order of the elements as they appear in the nested structure. # Example For example, given the input array: ```python nested_array = [1, [2, [3, 4]], 5, [[6]], [[[7], 8], 9]] ``` Calling your function should yield elements in the following order: ```python 1, 2, 3, 4, 5, 6, 7, 8, 9 ``` # Edge Cases 1. Simple arrays without nesting: `[1, 2, 3]`. 2. Deeply nested single element: `[[[[[1]]]]]`. 3. Empty nested structures: `[[], [[[[]]]]]`.","solution":"def flatten_generator(nested_array): A generator function that yields elements from a nested array structure. Parameters: nested_array (list): A list that may contain nested lists. Yields: int: The next element in a flat sequence of the nested structure. for element in nested_array: if isinstance(element, list): yield from flatten_generator(element) else: yield element"},{"question":"**Context**: You are tasked with developing a system that requires determining the greatest common divisor (GCD) of two non-negative integers using different methods. Based on the requirements provided, your task is to implement a function that computes the GCD efficiently for large datasets. Additionally, you should compute the least common multiple (LCM) and handle input variations gracefully. # Problem: Efficient GCD and LCM Calculation Write a Python function `compute_values(a, b)` that computes and returns the following: 1. Greatest common divisor (GCD) using Euclid\'s Algorithm. 2. Lowest common multiple (LCM) derived from the GCD result. 3. Greatest common divisor using bitwise operators. Input - `a`: non-negative integer (0 ≤ a ≤ 10^9) - `b`: non-negative integer (0 ≤ b ≤ 10^9) Output A dictionary with the following key-value pairs: ```python { \\"gcd\\": gcd_result, \\"lcm\\": lcm_result, \\"gcd_bit\\": gcd_bit_result } ``` where `gcd_result` is the GCD using Euclid\'s Algorithm, `lcm_result` is the LCM derived from GCD, and `gcd_bit_result` is the GCD using bitwise operations. Constraints - If both `a` and `b` are zeros, return a dictionary with values set to `None`. - Expected to handle edge cases and optimize for large values. # Function Signature ```python def compute_values(a: int, b: int) -> dict: pass ``` Example ```python compute_values(48, 18) # Output: {\'gcd\': 6, \'lcm\': 144, \'gcd_bit\': 6} compute_values(0, 0) # Output: {\'gcd\': None, \'lcm\': None, \'gcd_bit\': None} ```","solution":"def compute_values(a: int, b: int) -> dict: if a == 0 and b == 0: return {\\"gcd\\": None, \\"lcm\\": None, \\"gcd_bit\\": None} def gcd_euclidean(x, y): while y: x, y = y, x % y return x def gcd_bitwise(x, y): if x == 0: return y if y == 0: return x # Finding common factors of 2 shift = 0 while ((x | y) & 1) == 0: x >>= 1 y >>= 1 shift += 1 while (x & 1) == 0: x >>= 1 while y != 0: while (y & 1) == 0: y >>= 1 if x > y: x, y = y, x y -= x return x << shift gcd_result = gcd_euclidean(a, b) gcd_bit_result = gcd_bitwise(a, b) lcm_result = (a * b) // gcd_result if gcd_result != 0 else 0 return { \\"gcd\\": gcd_result, \\"lcm\\": lcm_result, \\"gcd_bit\\": gcd_bit_result, }"},{"question":"**Objective**: In this challenge, you will implement a function to convert file paths into their full absolute paths, ensuring they are correctly expanded and evaluated. This is fundamental for many systems that manage files and directories. **Scenario**: You are working on a file management system that needs to handle various file path formats. Users can input paths that are relative or use shortcuts like `~` for their home directory. Your task is to convert these paths into absolute paths for consistent file handling. **Task**: Implement a function `resolve_path(path)` that takes a string `path` representing a file path and returns its absolute path equivalent. You should handle paths that use `~` to denote the home directory and ensure the returned path is absolute. If the input path is invalid or contains only whitespace characters, raise a `ValueError`. **Input and Output**: - **Input**: A single string `path` representing the file path. - **Output**: An absolute path string. **Constraints**: - Do not attempt to access the filesystem to check if the file exists. - Assume the user running the script has permission to the directories involved. - The input path will be a string of length between 1 and 255 characters. **Examples**: ```python resolve_path(\\"~/docs/file.txt\\") # Should return an absolute path like \'/home/user/docs/file.txt\' resolve_path(\\"./scripts/run.sh\\") # Should return an absolute path like \'/current/dir/scripts/run.sh\' resolve_path(\\" \\") # Should raise ValueError ``` **Function Signature**: ```python def resolve_path(path: str) -> str: pass ``` **Notes**: 1. You can use the `os.path` module to help with path manipulations. 2. Ensure to handle edge cases like empty strings or strings containing only whitespace characters appropriately.","solution":"import os def resolve_path(path: str) -> str: Converts given file path to its absolute path. Parameters: - path (str): String representing the file path. Returns: - str: Absolute path equivalent of the input path. Raises: - ValueError: If the input path is invalid or contains only whitespace characters. if not path or path.strip() == \\"\\": raise ValueError(\\"Input path is invalid or contains only whitespace characters\\") return os.path.abspath(os.path.expanduser(path))"},{"question":"You are given the root of a binary tree. Implement a function that returns its values in zigzag level order traversal (i.e., left-to-right, then right-to-left for the next level and alternate between). # Function Signature: ```python def zigzag_level_order(root: TreeNode) -> List[List[int]]: ``` # Input: - `root`: The root node of the binary tree (TreeNode). # Output: - The function should return a list of lists, where each sublist contains the values of nodes at that level in zigzag order. # Constraints: - The number of nodes in the tree is in the range [0, 2000]. - Node values are integer values. # Example: Example 1: Input: ```plaintext 3 / 9 20 / 15 7 Output: [[3], [20, 9], [15, 7]] ``` Example 2: Input: ```plaintext 1 / 2 3 / 4 5 Output: [[1], [3, 2], [4, 5]] ``` # Explanation: In Example 1, the tree structure is such that: - Level 1: traverse left-to-right => [3]. - Level 2: traverse right-to-left => [20, 9]. - Level 3: traverse left-to-right => [15, 7]. In Example 2, the tree structure is: - Level 1: traverse left-to-right => [1]. - Level 2: traverse right-to-left => [3, 2]. - Level 3: traverse left-to-right => [4, 5]. # Note: Ensure that your solution handles all edge cases including empty trees, and trees with only left or right subtrees. # Evaluation Criteria: - Correctness: The function must return the correct zigzag level order traversal for all given test cases. - Efficiency: The implementation must be efficient in terms of both time and space complexity. - Code Quality: Your code should be well-documented and readable, with clear variable names and modular structure.","solution":"from collections import deque from typing import List, Optional class TreeNode: def __init__(self, val: int = 0, left: \'TreeNode\' = None, right: \'TreeNode\' = None): self.val = val self.left = left self.right = right def zigzag_level_order(root: Optional[TreeNode]) -> List[List[int]]: if not root: return [] result = [] nodes_queue = deque([root]) left_to_right = True while nodes_queue: level_size = len(nodes_queue) current_level = deque() for _ in range(level_size): node = nodes_queue.popleft() if left_to_right: current_level.append(node.val) else: current_level.appendleft(node.val) if node.left: nodes_queue.append(node.left) if node.right: nodes_queue.append(node.right) result.append(list(current_level)) left_to_right = not left_to_right return result"},{"question":"**Context**: You are tasked with implementing and testing a data structure that supports efficient insertions, deletions, and retrievals of random elements. This data structure is crucial for various applications such as gaming, simulations, and randomized algorithms. **Problem**: Design and implement a class `RandomizedSet` that supports the following operations: 1. `insert(val)`: Inserts an item `val` to the set if not already present. 2. `remove(val)`: Removes an item `val` from the set if present. 3. `random_element()`: Returns a random element from the current set of elements. Each element must have the same probability of being returned. **Input/Output Formats**: * `insert(val: int) -> None`: Insert the element `val` into the set if it\'s not already present. * `remove(val: int) -> None`: Remove the element `val` from the set if it exists. * `random_element() -> int`: Returns a random element from the current set. **Constraints**: * Each `val` is guaranteed to be within the integer range. * Ensure all operations perform in constant average time complexity O(1). **Performance Requirements**: * The average time complexity for each operation should be O(1). **Example**: ```python rs = RandomizedSet() rs.insert(1) # Inserts 1 to the set. rs.insert(2) # Inserts 2 to the set. print(rs.random_element()) # Returns either 1 or 2 randomly. rs.remove(1) # Removes 1 from the set. print(rs.random_element()) # Returns 2 as it\'s the only element present. ``` Write the implementation of the `RandomizedSet` class.","solution":"import random class RandomizedSet: def __init__(self): self.data = [] self.val_to_index = {} def insert(self, val: int) -> None: if val not in self.val_to_index: self.val_to_index[val] = len(self.data) self.data.append(val) def remove(self, val: int) -> None: if val in self.val_to_index: index = self.val_to_index[val] last_val = self.data[-1] self.data[index] = last_val self.val_to_index[last_val] = index self.data.pop() del self.val_to_index[val] def random_element(self) -> int: if not self.data: return None return random.choice(self.data)"},{"question":"**Problem Statement**: You are given the root node of a binary tree. Your task is to implement a function `height(root)` that calculates the height of the binary tree. The height is defined as the number of edges on the longest path from the root node to a leaf node. If the tree is empty, the height is considered to be `0`. **Function Signature**: ```python def height(root: Node) -> int: ``` **Input**: - `root`: The root node of the binary tree. **Output**: - Returns an integer representing the height of the tree. **Constraints**: - The number of nodes (`n`) in the tree is (0 leq n leq 10^4). **Example**: 1. Given the tree: ``` 9 / 6 12 / / 3 8 10 15 / 7 18 ``` `height(root)` should return `4`. 2. Given the tree: ``` 1 / 2 / 3 / 4 / 5 ``` `height(root)` should return `5`. 3. Given the tree: ``` 1 2 3 4 5 ``` `height(root)` should return `5`. **Explanation**: - For an empty tree, the height is 0. - For a tree with only one node, the height is 1. **Hint**: Use a recursive approach, where you find the height of the left and right subtrees and return 1 plus the maximum of these heights. **Scenario**: Consider a binary tree structure that represents a family genealogy tree, decision trees in machine learning, or directory structures in a file system. Being able to find the height helps in understanding the \\"depth\\" or complexity of the underlying structure.","solution":"class Node: def __init__(self, value): self.value = value self.left = None self.right = None def height(root: Node) -> int: if root is None: return 0 left_height = height(root.left) right_height = height(root.right) return 1 + max(left_height, right_height)"},{"question":"**Objective**: Given an array of integers and optional minimum and maximum bounds, write a function that filters the array to only include values within the specified bounds. **Function Signature**: ```python def limit(arr: List[int], min_lim: Optional[int] = None, max_lim: Optional[int] = None) -> List[int]: ``` # Example: ```python assert limit([1, 2, 3, 4, 5], None, 3) == [1, 2, 3] assert limit([1, 2, 3, 4, 5, 10, 20], 5, 15) == [5, 10] assert limit([5, 3, 8, 12, 7], 4, None) == [5, 8, 12, 7] assert limit([], 5, 15) == [] assert limit([1, 2, 3], 0, 99) == [1, 2, 3] ``` # Input: * `arr`: A list of integers, with a potential size up to 10^6. The elements of the array can be positive or negative. * `min_lim`: An optional integer, which specifies the minimum bound. If it is not provided, the smallest value in the array should be used. * `max_lim`: An optional integer, which specifies the maximum bound. If it is not provided, the largest value in the array should be used. # Output: * A list of integers which contains all the elements in `arr` within the range `[min_lim, max_lim]`. # Constraints: * The function should have a time complexity of O(n). * Elements in the resulting list should appear in the same order as they do in the input array. # Guidelines: 1. Handle edge cases such as empty arrays and arrays where all elements do not meet the bounds. 2. Ensure the implementation uses a single pass over the array to maintain O(n) complexity. --- # Task: Implement the `limit` function based on the provided signature and guidelines.","solution":"from typing import List, Optional def limit(arr: List[int], min_lim: Optional[int] = None, max_lim: Optional[int] = None) -> List[int]: Filters the array to only include values within the specified bounds. if min_lim is None: min_lim = float(\'-inf\') if max_lim is None: max_lim = float(\'inf\') return [x for x in arr if min_lim <= x <= max_lim]"},{"question":"Problem Statement You are given items with values and weights and a knapsack with a fixed capacity. Write a function `max_knapsack_value` that calculates the maximum value that can be obtained by placing a subset of the given items into the knapsack without exceeding its capacity. Function Signature ```python def max_knapsack_value(items: List[Tuple[int, int]], capacity: int) -> int: ``` Input * `items`: A list of tuples where each tuple contains two integers `(value, weight)` representing the value and weight of an item. * `capacity`: An integer representing the maximum capacity of the knapsack. Output * Returns an integer representing the maximum value that can be achieved within the given capacity. Constraints * `0 <= len(items) <= 1000` * `1 <= capacity <= 2000` * `0 <= value, weight <= 1000` Example ```python assert max_knapsack_value([(60, 5), (50, 3), (70, 4), (30, 2)], 5) == 80 assert max_knapsack_value([(10, 1), (20, 2), (30, 3), (40, 4)], 5) == 50 assert max_knapsack_value([], 0) == 0 ``` Performance Requirements * The solution should have a time complexity of O(n * m) and space complexity of O(m) where `n` is the number of items and `m` is the capacity of the knapsack. * The solution should handle edge cases appropriately, producing correct results.","solution":"from typing import List, Tuple def max_knapsack_value(items: List[Tuple[int, int]], capacity: int) -> int: Function to calculate the maximum value that can be obtained by placing a subset of given items into the knapsack without exceeding its capacity. Args: items (List[Tuple[int, int]]): List of tuples where each tuple contains: (value, weight) of an item. capacity (int): Maximum capacity of the knapsack. Returns: int: Maximum value that can be achieved within the given capacity. dp = [0] * (capacity + 1) for value, weight in items: for c in range(capacity, weight - 1, -1): dp[c] = max(dp[c], dp[c - weight] + value) return dp[capacity]"},{"question":"**Scenario**: In a computer network, data packets are transmitted in a pattern that may occasionally form a loop, causing infinite cycling of packets. You have been tasked to detect such loops in the network by analyzing a linked list representation of packet paths. **Task**: Given a linked list representing sequential transmission path of packets, write a function to detect the starting node of a cycle, if there is one. If there is no cycle, return `None`. **Function Signature**: ```python def detect_cycle_start(head: Node) -> Optional[Node]: pass ``` **Input/Output**: * Input: A singly linked list `head` of type `Node`. - Each `Node` has an attribute `val` (holding the data value) and an attribute `next` (which points to the next node). * Output: The node at the beginning of the cycle, or `None` if no cycle exists. **Constraints**: * The list may contain up to `1000` nodes. * Node values are unique (except for circular references). # Example: 1. Given Linked List: `1 -> 2 -> 3 -> 4 -> 5 -> 2` (cycle starting at node with value `2`): ```python head = Node(1) node2 = Node(2) head.next = node2 head.next.next = Node(3) head.next.next.next = Node(4) head.next.next.next.next = Node(5) head.next.next.next.next.next = node2 # cycle ``` Output: `Node(2)` 2. Given Linked List: `A -> B -> C -> D -> E -> C` (cycle starting at node with value `C`): ```python head = Node(\'A\') nodeB = Node(\'B\') head.next = nodeB nodeC = Node(\'C\') nodeB.next = nodeC nodeC.next = Node(\'D\') nodeC.next.next = Node(\'E\') nodeC.next.next.next = nodeC # cycle ``` Output: `Node(\'C\')` 3. Given Linked List with no cycle: `1 -> 2 -> 3 -> 4 -> 5`: Output: `None` Please ensure your function passes these scenarios and handles edge cases effectively. **Note**: Use `Floyd\'s Tortoise and Hare` algorithm for detecting the cycle.","solution":"class Node: def __init__(self, val: int): self.val = val self.next = None def detect_cycle_start(head: Node) -> Node: Detects the node at the beginning of the cycle in a linked list. Uses Floyd\'s Tortoise and Hare algorithm to detect the cycle. If no cycle is detected, returns None. :param head: The head node of the linked list. :return: The node where the cycle begins, or None if no cycle exists. if not head or not head.next: return None slow = head fast = head # Detect if a cycle exists while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: break # If no cycle detected if not fast or not fast.next: return None # Find the start of the cycle slow = head while slow != fast: slow = slow.next fast = fast.next return slow"},{"question":"# Cycle Sort Implementation and Analysis You are tasked with implementing the `cycle_sort` function to efficiently sort an array with minimum write operations. The function should follow the principles of Cycle Sort, as mentioned in the provided analysis. Function Signature ```python def cycle_sort(arr: list) -> list: ``` Input - `arr`: A list of integers (not necessarily unique). Output - Return the sorted list of integers. Constraints - Do not use any built-in sorting functions. - The algorithm must perform in-place sorting, so no additional lists or arrays should be created. - The number of write operations (swaps) should be minimized. Examples 1. Input: `[3, 2, 1]` Output: `[1, 2, 3]` 2. Input: `[5, 5, 3, 2, 8]` Output: `[2, 3, 5, 5, 8]` 3. Input: `[1]` Output: `[1]` Additional Requirements - Handle edge cases such as empty arrays or arrays with duplicate elements. - Ensure that the algorithm still functions correctly for both small and large datasets (within practical limits of Python execution time for a single assessment task).","solution":"def cycle_sort(arr: list) -> list: This function sorts an array using the cycle sort algorithm. writes = 0 # Counts the number of writes n = len(arr) # Traversing the array to find cycles to rotate. for cycle_start in range(0, n - 1): item = arr[cycle_start] # Find the position where we put the element. pos = cycle_start for i in range(cycle_start + 1, n): if arr[i] < item: pos += 1 # If the item is already in the correct position: if pos == cycle_start: continue # Otherwise, put the item to the right position while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] writes += 1 # Rotate the rest of the cycle while pos != cycle_start: pos = cycle_start for i in range(cycle_start + 1, n): if arr[i] < item: pos += 1 while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] writes += 1 return arr"},{"question":"**Scenario:** You are a software developer at a company specializing in document processing. One of the client requirements is to check if a document string `doc` can be composed using two given smaller document fragments `frag1` and `frag2` while maintaining the order of characters in the fragments. Write a function to validate whether the document `doc` can be formed from `frag1` and `frag2`. **Function Signature:** ```python def is_merge(doc: str, frag1: str, frag2: str) -> bool: pass ``` **Input:** * `doc`: A string representing the target document. * `frag1`: The first part from which characters should appear in order. * `frag2`: The second part from which characters should appear in order. **Output:** * Return `True` if `doc` can be formed by merging `frag1` and `frag2`; otherwise, return `False`. **Constraints:** * All input strings will have lengths between `0` and `100` inclusive. * The characters are case-sensitive. **Examples:** ```python assert is_merge(\\"codewars\\", \\"cdw\\", \\"oears\\") == True assert is_merge(\\"codewars\\", \\"code\\", \\"wars\\") == True assert is_merge(\\"codewar\\", \\"code\\", \\"wars\\") == False assert is_merge(\\"\\", \\"\\", \\"\\") == True assert is_merge(\\"a\\", \\"a\\", \\"\\") == True assert is_merge(\\"a\\", \\"\\", \\"a\\") == True assert is_merge(\\"ab\\", \\"a\\", \\"b\\") == True assert is_merge(\\"ac\\", \\"a\\", \\"b\\") == False ``` **Additional Notes:** * Your function should handle edge cases efficiently, focusing on optimized solutions if possible. * Consider using dynamic programming to avoid redundant checks. **Challenge:** Optimize for space complexity by reducing additional memory usage if possible.","solution":"def is_merge(doc: str, frag1: str, frag2: str) -> bool: Determine if the document `doc` can be formed by merging `frag1` and `frag2` while keeping the order of characters in `frag1` and `frag2`. len_doc, len_frag1, len_frag2 = len(doc), len(frag1), len(frag2) # Early exit if the lengths don\'t match if len_doc != len_frag1 + len_frag2: return False # Create a DP table to store solutions to sub-problems dp = [[False] * (len_frag2 + 1) for _ in range(len_frag1 + 1)] # Initialize the first cell dp[0][0] = True # Fill the table for i in range(len_frag1 + 1): for j in range(len_frag2 + 1): if i > 0 and doc[i + j - 1] == frag1[i - 1]: dp[i][j] = dp[i][j] or dp[i - 1][j] if j > 0 and doc[i + j - 1] == frag2[j - 1]: dp[i][j] = dp[i][j] or dp[i][j - 1] return dp[len_frag1][len_frag2]"},{"question":"# Segment Tree Implementation for Range Minimum Queries You are required to implement a segment tree data structure to handle range minimum queries efficiently. The segment tree will allow updating an element in the array and querying the minimum value over a specific range in logarithmic time. # Function Specification - **Function 1**: `update(self, index: int, value: int) -> None` - Updates the element at the given index to the new value. - **Function 2**: `range_min_query(self, left: int, right: int) -> int` - Returns the minimum value in the array within the index range `[left, right]` inclusive. # Input and Output - **Input**: A list of integers and a series of operations `update` and `range_min_query`. - **Output**: The results of the `range_min_query` calls. # Constraints - Elements of the array and indices are non-negative integers. - You are guaranteed that all indices used in `update` and `range_minquery` are valid. - Array size can be up to 100,000. - The number of operations will not exceed 10^5. # Example Usage ```python # Initialize segment tree with array mytree = SegmentTree([2, 4, 5, 3, 4]) # Perform range queries print(mytree.range_min_query(1, 3)) # Output: 3 # Update an element mytree.update(1, 1) # Perform range queries again print(mytree.range_min_query(1, 3)) # Output: 1 ``` # Implementation Details 1. The segment tree should be built using a non-recursive approach to minimize memory overhead. 2. The update method should efficiently update the element and propagate the change through the tree. 3. The range_min_query method should return the minimum element within the given range.","solution":"class SegmentTree: def __init__(self, data): self.n = len(data) self.tree = [0] * (2 * self.n) # Build the tree for i in range(self.n): self.tree[self.n + i] = data[i] for i in range(self.n - 1, 0, -1): self.tree[i] = min(self.tree[i * 2], self.tree[i * 2 + 1]) def update(self, index, value): pos = index + self.n self.tree[pos] = value while pos > 1: pos //= 2 self.tree[pos] = min(self.tree[2 * pos], self.tree[2 * pos + 1]) def range_min_query(self, left, right): # Convert range to segment tree indices left += self.n right += self.n + 1 minimum = float(\'inf\') while left < right: if left % 2 == 1: minimum = min(minimum, self.tree[left]) left += 1 if right % 2 == 1: right -= 1 minimum = min(minimum, self.tree[right]) left //= 2 right //= 2 return minimum"},{"question":"# Two Sum - Sorted Array You have been given an array of integers `numbers` that is sorted in ascending order and a target sum `target`. Your task is to identify two unique indices in the array where the sum of the elements at these indices equals the target. You must solve this problem using three different approaches: binary search, hash table, and two pointers. Implement and compare these methods to understand their differences in complexity and usage scenarios. # Function Signature ```python def two_sum_binary_search(numbers: List[int], target: int) -> List[int]: pass def two_sum_hash_table(numbers: List[int], target: int) -> List[int]: pass def two_sum_two_pointers(numbers: List[int], target: int) -> List[int]: pass ``` # Input * `numbers`: A list of integers sorted in ascending order (1 ≤ numbers.length ≤ 10^4). * `target`: An integer representing the target sum (−10^3 ≤ numbers[i], target ≤ 10^3). # Output * A list with two integers [index1, index2] representing the indices (1-based) of the elements that sum up to the target. # Constraints * Each input will have exactly one solution. * You may not use the same element twice. # Example ```python numbers = [2, 7, 11, 15] target = 9 result = two_sum_binary_search(numbers, target) # Output: [1, 2] result = two_sum_hash_table(numbers, target) # Output: [1, 2] result = two_sum_two_pointers(numbers, target) # Output: [1, 2] ``` # Notes 1. Clearly comment on the initialization and process of each method. 2. Ensure your implementation handles edge cases effectively. 3. Compare the performance of each method for various sizes and values of input, noting their strengths and limitations.","solution":"from typing import List # Method 1: Using Binary Search def two_sum_binary_search(numbers: List[int], target: int) -> List[int]: def binary_search(low, high, value): while low <= high: mid = (low + high) // 2 if numbers[mid] == value: return mid elif numbers[mid] < value: low = mid + 1 else: high = mid - 1 return -1 for i in range(len(numbers)): complement = target - numbers[i] j = binary_search(i + 1, len(numbers) - 1, complement) if j != -1: return [i + 1, j + 1] return [] # Method 2: Using Hash Table def two_sum_hash_table(numbers: List[int], target: int) -> List[int]: num_to_index = {} for i, num in enumerate(numbers): complement = target - num if complement in num_to_index: return [num_to_index[complement] + 1, i + 1] num_to_index[num] = i return [] # Method 3: Using Two Pointers def two_sum_two_pointers(numbers: List[int], target: int) -> List[int]: left, right = 0, len(numbers) - 1 while left < right: current_sum = numbers[left] + numbers[right] if current_sum == target: return [left + 1, right + 1] elif current_sum < target: left += 1 else: right -= 1 return []"},{"question":"# Question: Implement Enhanced Cocktail Shaker Sort You are required to implement an enhanced version of the Cocktail Shaker Sort, a comparison-based sorting algorithm that passes through the array in both directions alternatively. However, you should incorporate early exit for optimized sorting by checking if the array is already sorted in both the forward and backward passes. Function Signature: ```python def enhanced_cocktail_shaker_sort(arr: List[int]) -> List[int]: pass ``` Input: * A list of integers `arr` where `1 <= len(arr) <= 1000` and `-1000 <= arr[i] <= 1000`. Output: * A list of integers sorted in ascending order. Constraints: 1. You must use the cocktail shaker sort technique, but incorporate checks to stop sorting early if the array is already sorted. 2. Your solution should not use any built-in sort functions. 3. Ensure the function works efficiently for the provided constraints. Example: ```python assert enhanced_cocktail_shaker_sort([3, 0, 2, 5, -1, 4, 1]) == [-1, 0, 1, 2, 3, 4, 5] assert enhanced_cocktail_shaker_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] assert enhanced_cocktail_shaker_sort([-2, 7, -5, 2, -1, 4, 1]) == [-5, -2, -1, 1, 2, 4, 7] ``` Notes: * Consider edge cases such as already sorted arrays or arrays with all elements the same. * Ensure your implementation handles both positive and negative integers correctly. * Aim for clarity in your code and comments explaining each step.","solution":"def enhanced_cocktail_shaker_sort(arr): Sorts the array using an enhanced version of the Cocktail Shaker Sort algorithm. Optimized to incorporate early exits if the array becomes sorted before completion. if not arr: return [] n = len(arr) start = 0 end = n - 1 while start < end: swapped = False # Traverse the array from left to right for i in range(start, end): if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] swapped = True if not swapped: break # Last swapped element is in its correct position end -= 1 swapped = False # Traverse the array from right to left for i in range(end, start, -1): if arr[i] < arr[i - 1]: arr[i], arr[i - 1] = arr[i - 1], arr[i] swapped = True if not swapped: break # First swapped element is in its correct position start += 1 return arr"},{"question":"Scenario You are tasked with sorting a list of floating-point numbers that represent scores achieved by students in a coding competition. The scores range uniformly from 0 to 100. Given the nature of the scores, a suitable approach for sorting is Bucket Sort, with an efficient secondary sorting mechanism. For this task, use Insertion Sort for sorting individual buckets. Problem Statement Implement the `bucket_sort` function that sorts an array of floating-point numbers using the Bucket Sort algorithm. Here is the function signature: ```python def bucket_sort(arr: list) -> list: Sorts an array of floating-point numbers using Bucket Sort ``` Inputs and Outputs * **Input**: A list of floating-point numbers within the range [0, 100]. * **Output**: A sorted list of floating-point numbers. Requirements 1. Distribute numbers into appropriate buckets. 2. Sort each bucket using Insertion Sort. 3. Merge the sorted buckets to produce the final sorted array. Constraints 1. The length of the array `arr` will be between 1 and (10^5). 2. All elements in the `arr` will be within the range [0, 100]. Example ```python # Example Input: arr = [78.23, 98.01, 26.78, 34.56, 50.11] # Example Output: [26.78, 34.56, 50.11, 78.23, 98.01] ``` Implement the `bucket_sort` function to solve this problem. Ensure that your implementation is efficient for handling up to (10^5) elements.","solution":"def insertion_sort(bucket): Helper function to perform insertion sort on a bucket. for i in range(1, len(bucket)): key = bucket[i] j = i - 1 while j >= 0 and key < bucket[j]: bucket[j + 1] = bucket[j] j -= 1 bucket[j + 1] = key return bucket def bucket_sort(arr): Sorts an array of floating-point numbers using Bucket Sort. if not arr: return [] num_buckets = len(arr) max_value = 100 buckets = [[] for _ in range(num_buckets)] for num in arr: index = int(num_buckets * num / (max_value + 1)) buckets[index].append(num) sorted_arr = [] for bucket in buckets: sorted_arr.extend(insertion_sort(bucket)) return sorted_arr"},{"question":"You are tasked with implementing a Fibonacci number calculator, but with a particular constraint. The goal is to compute the n-th Fibonacci number using the most efficient approach in terms of both time and space. Write a function that adheres to these constraints. # Function Signature ```python def fib_optimized(n: int) -> int: ``` # Input * An integer `n` where `0 <= n <= 10^6`. # Output * The function should return an integer, which is the n-th Fibonacci number. # Constraints * Your solution must be efficient both in terms of time and space. * Aim for a time complexity of O(n). * Aim for a space complexity of O(1). # Performance Requirements * The implementation must handle very large values of n efficiently. The response time should be within acceptable limits for n up to 10^6. # Example ```python assert fib_optimized(0) == 0 assert fib_optimized(1) == 1 assert fib_optimized(10) == 55 assert fib_optimized(50) == 12586269025 ``` # Context Fibonacci numbers often appear in computer science and mathematics, and their efficient calculation can sometimes be crucial. Approaches vary in efficiency, and selecting the best-fit algorithm is key to performance, especially when dealing with large inputs.","solution":"def fib_optimized(n: int) -> int: Returns the n-th Fibonacci number using an optimized solution with O(n) time complexity and O(1) space complexity. if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"# B-Tree Implementation and Operations As a software engineer, you are tasked to implement a system that handles large datasets efficiently. You have chosen to use a B-Tree for its balanced structure and efficient operations suitable for applications like databases and file systems. Below is the partial implementation of a B-Tree. Your goal is to complete the implementation by adding a method to count the total number of keys in the B-Tree. # Task Implement a method `count_keys` in the `BTree` class that returns the total number of keys currently stored in the B-Tree. # Function Signature ```python class BTree: # existing methods... def count_keys(self) -> int: pass ``` # Expected Input and Output * **Input**: None (the method is called on an instance of the BTree class). * **Output**: An integer representing the count of all keys in the B-Tree. # Constraints * You may assume that the B-Tree node structure and other methods like insert, find, and delete are already implemented correctly. * The method should work efficiently for trees with a large number of keys. # Example ```python b_tree = BTree(t_val=3) b_tree.insert_key(10) b_tree.insert_key(20) b_tree.insert_key(5) b_tree.insert_key(6) b_tree.insert_key(12) count = b_tree.count_keys() print(count) # Output should be 5 ``` # Notes * Think carefully about the traversal method to ensure all keys are counted efficiently. * Ensure that your solution works for edge cases such as an empty tree or a tree with only one node.","solution":"class BTreeNode: def __init__(self, t, leaf=False): self.t = t self.leaf = leaf self.keys = [] self.children = [] def __len__(self): count = len(self.keys) if not self.leaf: for child in self.children: count += len(child) return count class BTree: def __init__(self, t): self.t = t self.root = BTreeNode(t, leaf=True) def insert_key(self, k): # Simplified insert method for standalone solution if len(self.root.keys) == (2 * self.t) - 1: new_root = BTreeNode(self.t) new_root.children.append(self.root) new_root.leaf = False self.root = new_root self._split_child(new_root, 0) self._insert_non_full(self.root, k) def _insert_non_full(self, node, k): if node.leaf: node.keys.append(k) node.keys.sort() else: i = len(node.keys) - 1 while i >= 0 and k < node.keys[i]: i -= 1 i += 1 if len(node.children[i].keys) == (2 * self.t) - 1: self._split_child(node, i) if k > node.keys[i]: i += 1 self._insert_non_full(node.children[i], k) def _split_child(self, parent, i): t = self.t node = parent.children[i] new_node = BTreeNode(t, leaf=node.leaf) parent.keys.insert(i, node.keys[t - 1]) parent.children.insert(i + 1, new_node) new_node.keys = node.keys[t: (2 * t) - 1] if not node.leaf: new_node.children = node.children[t: 2 * t] node.keys = node.keys[: t - 1] node.children = node.children[: t] def count_keys(self) -> int: # Traverse from root to count keys return len(self.root)"},{"question":"# Question: Computing and Using Bézout\'s Coefficients You are tasked with writing a function to compute the Bézout coefficients ( s ) and ( t ) such that for two given integers `num1` and `num2`: [ num1 cdot s + num2 cdot t = text{GCD}(num1, num2) ] Using the Extended Euclidean Algorithm provided, implement a function that computes and returns the coefficients ( s ) and ( t ). Additionally, utilize these coefficients to check if a third integer can be expressed using these coefficients. Function Signature ```python def bezout_and_check(num1: int, num2: int, check_val: int) -> (int, int, bool): ``` Input - `num1`: an integer, the first number. - `num2`: an integer, the second number. - `check_val`: an integer that you need to check if it can be expressed using the Bézout identity with `num1` and `num2`. Output - Return a tuple of three values: - Two integers representing the Bézout coefficients ( s ) and ( t ). - A boolean value indicating whether `check_val` can be expressed as ( num1 cdot s + num2 cdot t ). Constraints - Input integers are non-zero. - Ensure that the number fits within the standard range of integers in Python. Example ```python bezout_and_check(30, 20, 10) ``` # Expected Output ```python (-1, 2, True) ``` Explanation: - The Bézout coefficients ( s ) and ( t ) for 30 and 20 are -1 and 2 respectively. - ( 30 cdot (-1) + 20 cdot 2 = 10 ), which implies that it is possible to express the number 10 using these coefficients.","solution":"def extended_euclidean_algorithm(a, b): Uses the Extended Euclidean Algorithm to find the integers x and y such that: ax + by = gcd(a, b) if a == 0: return b, 0, 1 else: gcd, x1, y1 = extended_euclidean_algorithm(b % a, a) x = y1 - (b // a) * x1 y = x1 return gcd, x, y def bezout_and_check(num1, num2, check_val): Finds the Bézout coefficients for num1 and num2, and checks if check_val can be expressed as a linear combination of num1 and num2 using these coefficients. gcd, s, t = extended_euclidean_algorithm(num1, num2) can_express = (check_val % gcd == 0) return s, t, can_express"},{"question":"You are tasked with creating a function to determine the minimum number of deletions required to make two given strings identical. This can be achieved by leveraging the Longest Common Subsequence (LCS) in a dynamic programming manner. Function Signature ```python def min_distance_dp(word1: str, word2: str) -> int: ``` Input - `word1`: A string of length `n` (1 <= n <= 1000) - `word2`: A string of length `m` (1 <= m <= 1000) Output - An integer representing the minimum number of steps to make `word1` and `word2` identical through deletions. Example ```python assert min_distance_dp(\\"sea\\", \\"eat\\") == 2 assert min_distance_dp(\\"abc\\", \\"def\\") == 6 assert min_distance_dp(\\"hello\\", \\"hll\\") == 2 ``` Constraints - `1 <= len(word1), len(word2) <= 1000` - Both words consist only of lowercase English letters. Hints 1. Consider leveraging the concept of the Longest Common Subsequence (LCS). 2. Use a dynamic programming approach to get the minimum deletion steps. 3. Think about initializing the DP table properly and filling it based on character matches or mismatches. Performance Requirements - Optimize for both time and space complexity wherever possible. Edge Cases - Ensure your solution handles cases where one or both strings are empty. - Consider scenarios where there are no common characters between the strings. - Handle cases where the strings are initially identical. Good luck!","solution":"def min_distance_dp(word1: str, word2: str) -> int: Calculate the minimum number of deletions required to make two strings identical by leveraging the concept of the Longest Common Subsequence (LCS). n, m = len(word1), len(word2) # Create a DP table with (n+1) x (m+1) dimensions dp = [[0] * (m + 1) for _ in range(n + 1)] # Fill the DP table for i in range(1, n + 1): for j in range(1, m + 1): if word1[i - 1] == word2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) # Calculate the length of the longest common subsequence lcs_length = dp[n][m] # Minimum deletions = sum of the characters not in LCS return (n - lcs_length) + (m - lcs_length)"},{"question":"Reverse Every k Nodes in a Singly Linked List Given a singly linked list, write a function that reverses every `k` nodes in the list. If the number of nodes is not a multiple of `k`, then reverse the remaining nodes as well. The reversal should preserve the original order of the nodes outside each group of `k`. # Function Signature ```python def reverse_k_group(head: ListNode, k: int) -> ListNode: :type head: ListNode :type k: int :rtype: ListNode ``` # Input - `head`: The head of a singly linked list. - `k`: An integer denoting the group size for reversal (1 <= k <= n, where n is the number of nodes in the list). # Output - The head of the list after performing the specified k-group reversals. # Constraints - The list might be empty. - Each ListNode has an `int` value and `next` pointer. # Example 1. **Input:** - List: `1 -> 2 -> 3 -> 4 -> 5` - k: `2` **Output:** `2 -> 1 -> 4 -> 3 -> 5` 2. **Input:** - List: `1 -> 2 -> 3 -> 4 -> 5` - k: `3` **Output:** `3 -> 2 -> 1 -> 4 -> 5` # Explanation For the first example, every 2 nodes are reversed: - The first two nodes `1 -> 2` become `2 -> 1`. - The next two nodes `3 -> 4` become `4 -> 3`. - The last node `5` remains as it is because it\'s less than k. For the second example, every 3 nodes are reversed: - The first three nodes `1 -> 2 -> 3` become `3 -> 2 -> 1`. - The remaining nodes `4 -> 5` do not form a group of 3, hence remain unchanged. # Notes - Consider edge cases such as empty list, single node list, and where k is 1. - Your solution should be efficient in terms of both time and space, aiming for O(n) time complexity.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_k_group(head: ListNode, k: int) -> ListNode: def get_kth(curr, k): while curr and k > 0: curr = curr.next k -= 1 return curr dummy = ListNode(0, head) group_prev = dummy while True: kth = get_kth(group_prev, k) if not kth: break group_next = kth.next # reverse the group prev, curr = kth.next, group_prev.next for _ in range(k): tmp = curr.next curr.next = prev prev = curr curr = tmp tmp = group_prev.next group_prev.next = prev group_prev = tmp return dummy.next"},{"question":"Given a singly linked list, write a function `swap_pairs` that swaps every two adjacent nodes in place and returns the head of the modified list. The function should maintain the original node values and only change the node pointers. The `Node` class is already provided for you. You should not use additional space proportional to the input size and only swap nodes themselves. Input and Output Format * **Input**: A singly linked list represented by its head node. * **Output**: The head of the modified linked list. Constraints * The output linked list should be correctly formed even if the input list has: * Zero nodes (empty list). * An odd number of nodes. * An even number of nodes. Function Signature ```python def swap_pairs(head: Node) -> Node: pass ``` # Scenario Imagine you\'re working on a text editor that represents the text as a linked list of characters. One feature being added is the ability to flip the positions of every two adjacent characters in a partially selected portion of the text. You decide to prototype this by first implementing a basic swapper for the entire text represented as a linked list. # Examples Example 1 * **Input**: `1 -> 2 -> 3 -> 4` * **Output**: `2 -> 1 -> 4 -> 3` Example 2 * **Input**: `1 -> 2 -> 3` * **Output**: `2 -> 1 -> 3` Example 3 * **Input**: (empty list) * **Output**: (empty list) You may use the following `Node` class in your implementation. ```python class Node: def __init__(self, x): self.val = x self.next = None ```","solution":"class Node: def __init__(self, x): self.val = x self.next = None def swap_pairs(head: Node) -> Node: # Edge case for empty list or single node list if not head or not head.next: return head # Dummy node to handle edge cases smoothly dummy = Node(0) dummy.next = head current = dummy while current.next and current.next.next: first = current.next second = current.next.next # Swapping the nodes first.next = second.next current.next = second current.next.next = first # Move to the next pair current = current.next.next return dummy.next"},{"question":"You are tasked with implementing a specialized **Priority Queue** using a Min-Heap data structure (binary heap). Unlike the basic Queue, a Priority Queue is a type of queue in which each element is assigned a priority, and elements are dequeued in priority order (lowest priority first). Requirements: 1. Implement a class, `PriorityQueue`, which should include the following operations: - `insert(item, priority)`: Adds the given item with the specified priority to the queue. - `delete()`: Removes and returns the item with the highest priority (lowest numerical priority). - `peek()`: Returns the item with the highest priority without removing it. - `is_empty()`: Returns True if the queue is empty. - `size()`: Returns the number of elements in the queue. 2. Your implementation should adhere to the following constraints: - The priority is an integer where a lower number indicates higher priority. - The queue should maintain efficient operations with respect to time complexity: - Insertion O(log n) - Deletion O(log n) - Peek O(1) 3. Optimize your solution to handle the edge cases: - Handling an empty queue for `delete` and `peek` operations. - Maintain the heap property after every operation. # Example: ```python pq = PriorityQueue() pq.insert(\\"Task1\\", 3) pq.insert(\\"Task2\\", 1) pq.insert(\\"Task3\\", 2) assert pq.peek() == \\"Task2\\" assert pq.delete() == \\"Task2\\" assert pq.delete() == \\"Task3\\" assert pq.delete() == \\"Task1\\" assert pq.is_empty() == True assert pq.size() == 0 ``` The above should inform students on the gravity of the problem they are solving while ensuring they handle edge cases and performance concerns as discussed in the analysis. # Input and Output formats: - **Input**: You do not have to handle input as all operations will be performed on the PriorityQueue object via method calls. - **Output**: Appropriate elements or boolean checks as returned by the methods.","solution":"import heapq class PriorityQueue: def __init__(self): self.heap = [] self.count = 0 # to handle same priority elements in FIFO manner def insert(self, item, priority): heapq.heappush(self.heap, (priority, self.count, item)) self.count += 1 def delete(self): if self.is_empty(): raise IndexError(\\"delete from an empty priority queue\\") return heapq.heappop(self.heap)[2] def peek(self): if self.is_empty(): raise IndexError(\\"peek from an empty priority queue\\") return self.heap[0][2] def is_empty(self): return len(self.heap) == 0 def size(self): return len(self.heap)"},{"question":"**Title**: Increment a Number Represented as an Array of Digits **Objective**: Given a non-negative integer represented as an array of digits, write a function that adds one to the number. The digits are stored such that the most significant digit is at the head of the list and each element in the array contains a single digit (0-9). **Function Signature**: ```python def increment_digit_array(digits: List[int]) -> List[int]: :param digits: List[int] - A list of non-negative digits representing a non-negative integer :return: List[int] - The resultant list after incrementing the integer by one ``` **Constraints**: 1. The input array will not be empty and will contain only non-negative single digits (0-9). 2. Leading zeroes are not allowed except for the number zero itself. 3. The function should handle large numbers that cannot be represented by standard data types. **Input/Output Examples**: 1. **Example 1**: ```python print(increment_digit_array([1, 2, 3])) # Expected Output: [1, 2, 4] ``` 2. **Example 2**: ```python print(increment_digit_array([4, 3, 2, 1])) # Expected Output: [4, 3, 2, 2] ``` 3. **Example 3**: ```python print(increment_digit_array([9])) # Expected Output: [1, 0] ``` 4. **Example 4**: ```python print(increment_digit_array([9, 9, 9])) # Expected Output: [1, 0, 0, 0] ``` **Scenario/Context**: This function simulates a very simplified version of operations in arbitrary-precision arithmetic, which is a common feature in many mathematical libraries. It also familiarizes students with handling carry-over in addition operations.","solution":"from typing import List def increment_digit_array(digits: List[int]) -> List[int]: Add one to the number represented by the digits array. :param digits: List[int] - A list of non-negative digits representing a non-negative integer :return: List[int] - The resultant list after incrementing the integer by one n = len(digits) # Start from the last element and work backwards for i in reversed(range(n)): if digits[i] < 9: digits[i] += 1 return digits # if the digit is 9, it becomes 0 and carry over to the next digit digits[i] = 0 # If all digits were 9, we need an extra 1 at the beginning return [1] + digits"},{"question":"# Objective Write and test a function that sorts an array using an altered version of the Stooge Sort algorithm, called \\"Selective Stooge Sort\\". # Selective Stooge Sort Selective Stooge Sort should perform the stooge sort recursively only for arrays where the length of the array is greater than or equal to `threshold_length`. For arrays shorter than `threshold_length`, use the Bubble Sort algorithm. This adjustment aims to assess the students\' ability to modify the given algorithm for particular conditions while understanding its performance impacts. # Input 1. **arr**: A list of integers that needs to be sorted. 2. **threshold_length**: An integer specifying the minimum length of subarrays for which Stooge Sort should be used. # Output A list of sorted integers in non-descending order. # Function Signature ```python def selective_stooge_sort(arr: List[int], threshold_length: int) -> List[int]: ``` # Constraints * The length of `arr` will be between 1 and 10^3. * The values of the elements in `arr` will be between -10^4 and 10^4. * The `threshold_length` will be between 1 and 10^3. * Sorting alterable areas only if exceeding `threshold_length`. # Example ```python arr = [1, 3, 64, 5, 7, 8] threshold_length = 3 print(selective_stooge_sort(arr, threshold_length)) # Output: [1, 3, 5, 7, 8, 64] ``` # Notes * Consider how the alteration to use Bubble Sort for smaller chunks affects both the implementation and performance of the function. * Ensure your solution handles edge cases appropriately.","solution":"from typing import List def selective_stooge_sort(arr: List[int], threshold_length: int) -> List[int]: def bubble_sort(sub_array): n = len(sub_array) for i in range(n): for j in range(0, n-i-1): if sub_array[j] > sub_array[j+1]: sub_array[j], sub_array[j+1] = sub_array[j+1], sub_array[j] return sub_array def stooge_sort(sub_array, l, h): if l >= h: return if sub_array[l] > sub_array[h]: sub_array[l], sub_array[h] = sub_array[h], sub_array[l] if h-l+1 > 2: t = (h-l+1) // 3 stooge_sort(sub_array, l, h-t) stooge_sort(sub_array, l+t, h) stooge_sort(sub_array, l, h-t) def selective_sort(sub_array, threshold_length): if len(sub_array) < threshold_length: return bubble_sort(sub_array) else: stooge_sort(sub_array, 0, len(sub_array) - 1) return sub_array return selective_sort(arr, threshold_length)"},{"question":"# Question: Implement Modular Exponential with Custom Constraints You are tasked with implementing a function that calculates (base^exponent) % mod efficiently using the modular exponentiation method. This function will be useful in large-number calculations and cryptographic algorithms. Function Signature ```python def modular_exponential_custom(base: int, exponent: int, mod: int) -> int: ``` Input * An integer `base` (0 <= base <= 10^9) * An integer `exponent` (0 <= exponent <= 10^9) * An integer `mod` (1 <= mod <= 10^9) Output * An integer representing the result of (base^exponent) % mod. Constraints * Return 1 when the exponent is 0. * Return 0 when the base is 0 and the exponent is greater than 0. * Assume all inputs are non-negative and within the specified range. * Raise a `ValueError` if `mod` is less than or equal to 0 or `exponent` is negative. Examples ```python print(modular_exponential_custom(2, 10, 1000)) # Output: 24 print(modular_exponential_custom(3, 0, 100)) # Output: 1 print(modular_exponential_custom(0, 5, 3)) # Output: 0 print(modular_exponential_custom(5, 3, 13)) # Output: 8 ``` Write a function `modular_exponential_custom` to solve the problem. Ensure you consider edge cases and handle errors appropriately.","solution":"def modular_exponential_custom(base: int, exponent: int, mod: int) -> int: Computes (base^exponent) % mod using efficient modular exponentiation. # Check for constraints if mod <= 0: raise ValueError(\\"Modulus must be greater than 0\\") if exponent < 0: raise ValueError(\\"Exponent must be non-negative\\") # Handle special cases if exponent == 0: return 1 if base == 0: return 0 result = 1 current_power = base % mod while exponent > 0: if exponent % 2 == 1: result = (result * current_power) % mod current_power = (current_power * current_power) % mod exponent //= 2 return result"},{"question":"You are given a binary tree and need to implement a function to calculate its height. The height of a binary tree is defined as the number of levels it contains. An empty tree has a height of 0, a tree with just one node has a height of 1, and so forth. For example, given the following binary tree: ``` 9 / 6 12 / / 3 8 10 15 / 7 18 ``` The height of this tree is 4. # Function Signature ```python def height(root: Node) -> int: ``` # Input - `root` (Node): The root node of the binary tree. # Output - `int`: An integer representing the height of the tree. # Constraints - The number of nodes in the tree will be between `0` and `10^4`. - The value of each node will be a unique integer. # Requirements - The function should be implemented using a recursive approach. - Aim for optimal performance considering time and space complexity. # Example ```python # Implementation of Node class for reference class Node: def __init__(self, value): self.value = value self.left = None self.right = None # Using the provided function in a unittest setup import unittest class TestHeightFunction(unittest.TestCase): def setUp(self): self.tree = Node(9) self.tree.left = Node(6) self.tree.right = Node(12) self.tree.left.left = Node(3) self.tree.left.right = Node(8) self.tree.left.right.left = Node(7) self.tree.right.left = Node(10) self.tree.right.right = Node(15) self.tree.right.right.right = Node(18) def test_height(self): self.assertEqual(4, height(self.tree)) if __name__ == \'__main__\': unittest.main() ```","solution":"class Node: def __init__(self, value): self.value = value self.left = None self.right = None def height(root: Node) -> int: Returns the height of the binary tree rooted at `root`. if root is None: return 0 left_height = height(root.left) right_height = height(root.right) return max(left_height, right_height) + 1"},{"question":"You are tasked to implement a function that inverts a given n x n matrix. Given the matrix `m` of size `n x n`, return its inverse matrix if it exists. If the matrix cannot be inverted, return an appropriate error code. # Function Signature ```python def invert_matrix(m: List[List[int]]) -> List[List[int]]: ``` # Input - `m`: A list of lists of integers `[[a11, a12, ..., a1n], [a21, a22, ..., a2n], ..., [an1, an2, ..., ann]]` representing an n x n matrix. # Output - Return the inverted matrix of the same size if it exists. If the matrix cannot be inverted, return a specific error code using the criteria below: - If `m` is not a matrix (unequal row lengths), return `[[ -1 ]]`. - If `m` is not square, return `[[ -2 ]]`. - If the matrix is too small (e.g., 0x0 or 1x1), return `[[ -3 ]]`. - If the matrix is singular (determinant is 0), return `[[ -4 ]]`. # Constraints - Matrix elements `m[i][j]` are integers. - Matrix `m` can have up to 10 rows and columns. # Performance Requirements The implemented function should be efficient and able to handle up to `10 x 10` matrices within reasonable time limits. # Example ```python m = [ [2, 5], [1, 3] ] print(invert_matrix(m)) # Output: [[3, -5], [-1, 2]] (or equivalent floating-point precision results) ``` Consider implementing helper functions for determinant calculation, matrix of minors, matrix of cofactors, and adjugation where applicable. # Edge Cases to Consider - Validate for non-matrix input. - Handle non-square matrices appropriately. - Ensure singualrity is checked (zero determinant).","solution":"from typing import List def invert_matrix(m: List[List[int]]) -> List[List[int]]: def is_matrix(m): row_length = len(m[0]) for row in m: if len(row) != row_length: return False return True def determinant(matrix, mul): width = len(matrix) if width == 1: return mul * matrix[0][0] else: sign = -1 det = 0 for i in range(width): m = [] for j in range(1, width): buff = [] for k in range(width): if k != i: buff.append(matrix[j][k]) m.append(buff) sign *= -1 det += mul * determinant(m, sign * matrix[0][i]) return det def matrix_minor(matrix, i, j): return [row[:j] + row[j+1:] for row in (matrix[:i] + matrix[i+1:])] def matrix_inverse(matrix): det = determinant(matrix, 1) if det == 0: return [[-4]] width = len(matrix) cofactors = [] for r in range(width): cofactorRow = [] for c in range(width): minor = matrix_minor(matrix, r, c) cofactorRow.append(((-1)**(r+c)) * determinant(minor, 1)) cofactors.append(cofactorRow) cofactors = list(map(list, zip(*cofactors))) for r in range(width): for c in range(width): cofactors[r][c] = cofactors[r][c] / det return cofactors n = len(m) if n == 0 or (n == 1 and len(m[0]) == 0): return [[-3]] if not all(isinstance(row, list) and all(isinstance(item, int) for item in row) for row in m): return [[-1]] if not is_matrix(m): return [[-1]] if any(len(row) != n for row in m): return [[-2]] if n == 1: return [[-3]] return matrix_inverse(m)"},{"question":"# Scenario Imagine you\'re working on a software system that requires using a stack data structure to control operations with Last-In-First-Out (LIFO) access patterns. Depending on the specific use case, you may need options for different stack implementations like array-based stacks or linked list-based stacks. Given this context, implement and test two stack variants: an array-based stack called `ArrayStack` and a linked-list based stack called `LinkedListStack`. # Task 1. Implement the methods for both `ArrayStack` and `LinkedListStack` based on the provided `AbstractStack` class. The implementations should handle fundamental stack operations (`push`, `pop`, `peek`, and `is_empty`). 2. Write a function that uses either stack to perform operations as specified by a sequence of commands. # Function Signature ```python def perform_stack_operations(commands: list[str], stack_type: str) -> list: Perform a sequence of stack operations on either ArrayStack or LinkedListStack. :param commands: List of string commands to perform on the stack. Commands can be: \'push <value>\': To push an integer value onto the stack. \'pop\': To pop the top value from the stack. \'peek\': To peek at the top value of the stack. \'is_empty\': To check if the stack is empty. :param stack_type: A string specifying the type of stack to use (\'array\' or \'linked\'). :return: List of results for the commands that produce output (like \'pop\', \'peek\', \'is_empty\'). ``` # Example Input ```python commands = [\'push 10\', \'push 20\', \'push 30\', \'pop\', \'peek\', \'is_empty\'] stack_type = \'array\' ``` # Example Output ```python [30, 20, False] ``` # Constraints * You can assume that the commands are well-formed. * The commands list will contain at most 1000 commands. * The values to be pushed will be integers in the range 1 to 1000. * The `stack_type` parameter will always be either \'array\' or \'linked\'. # Requirements * Your solution should handle edge cases like popping or peeking from an empty stack gracefully. # Notes * For `ArrayStack`, the internal array should double its size whenever it runs out of space. * For `LinkedListStack`, ensure proper handling of memory by linking and unlinking nodes correctly.","solution":"class AbstractStack: def push(self, value): raise NotImplementedError def pop(self): raise NotImplementedError def peek(self): raise NotImplementedError def is_empty(self): raise NotImplementedError class ArrayStack(AbstractStack): def __init__(self): self.stack = [] self.size = 0 self.capacity = 1 # initial capacity self._resize(self.capacity) def _resize(self, new_capacity): new_stack = [None] * new_capacity for i in range(self.size): new_stack[i] = self.stack[i] self.stack = new_stack def push(self, value): if self.size == self.capacity: self.capacity *= 2 self._resize(self.capacity) self.stack[self.size] = value self.size += 1 def pop(self): if self.is_empty(): raise IndexError(\\"pop from empty stack\\") self.size -= 1 value = self.stack[self.size] self.stack[self.size] = None # avoid loitering return value def peek(self): if self.is_empty(): raise IndexError(\\"peek from empty stack\\") return self.stack[self.size - 1] def is_empty(self): return self.size == 0 class LinkedListStack(AbstractStack): class Node: def __init__(self, value, next=None): self.value = value self.next = next def __init__(self): self.head = None def push(self, value): new_node = self.Node(value, self.head) self.head = new_node def pop(self): if self.is_empty(): raise IndexError(\\"pop from empty stack\\") value = self.head.value self.head = self.head.next return value def peek(self): if self.is_empty(): raise IndexError(\\"peek from empty stack\\") return self.head.value def is_empty(self): return self.head is None def perform_stack_operations(commands: list[str], stack_type: str) -> list: if stack_type == \'array\': stack = ArrayStack() elif stack_type == \'linked\': stack = LinkedListStack() else: raise ValueError(f\\"Unknown stack type: {stack_type}\\") results = [] for command in commands: parts = command.split() action = parts[0] if action == \'push\': value = int(parts[1]) stack.push(value) elif action == \'pop\': results.append(stack.pop()) elif action == \'peek\': results.append(stack.peek()) elif action == \'is_empty\': results.append(stack.is_empty()) else: raise ValueError(f\\"Unknown command: {command}\\") return results"},{"question":"# Problem Context You\'re contributing to a library for efficient search algorithms. One of the algorithms in your repertoire is the Interpolation Search algorithm, which works optimally when the dataset is large and uniformly distributed. To ensure the reliability of this algorithm and to cover edge cases, you are tasked with implementing a robust version of the Interpolation Search. # Problem Statement Implement the function `optimized_interpolation_search`. Given a sorted array of integers and a search key, this function should utilize the Interpolation Search algorithm to find the position of the search key in the array. # Requirements - **Function Signature**: ```python def optimized_interpolation_search(array: List[int], search_key: int) -> int: ``` - **Input**: - `array` (List[int]): A sorted list of integers. It\'s guaranteed to be sorted in non-decreasing order. - `search_key` (int): An integer value to search for within the array. - **Output**: - Returns the index of `search_key` if it is present in the array; otherwise, returns `-1`. - **Constraints**: - The function should handle arrays of size up to (10^6). - Elements of the array and the search key are within the range ([-10^9, 10^9]). # Performance Requirements - The function must maintain the time complexity (O(log log n)) on average and space complexity (O(1)). # Example Usage Your implementation should work as follows: ```python print(optimized_interpolation_search([5, 10, 12, 14, 17, 20, 21], 14)) # Output should be 3 print(optimized_interpolation_search([2, 4, 5, 8, 10, 13, 18, 21], 6)) # Output should be -1 print(optimized_interpolation_search([1, 2, 3, 4, 5], 1)) # Output should be 0 print(optimized_interpolation_search([], 1)) # Output should be -1 print(optimized_interpolation_search([5], 5)) # Output should be 0 ``` # Additional Notes - Consider edge cases like an empty array or non-existence of the search key within the array. - Your implementation must gracefully handle and avoid potential divide-by-zero exceptions. Provide clear and maintainable code to ensure readability and make future updates easier.","solution":"from typing import List def optimized_interpolation_search(array: List[int], search_key: int) -> int: Perform Interpolation Search to find the position of search_key in the array. :param array: List of sorted integers. :param search_key: Integer to search for. :return: Index of search_key in array if present, else -1. if not array: return -1 low, high = 0, len(array) - 1 while low <= high and search_key >= array[low] and search_key <= array[high]: if low == high: if array[low] == search_key: return low return -1 pos = low + ((search_key - array[low]) * (high - low)) // (array[high] - array[low]) if array[pos] == search_key: return pos if array[pos] < search_key: low = pos + 1 else: high = pos - 1 return -1"},{"question":"# Question Given an array of integers, every element appears twice except for one. Find that single one using a linear runtime algorithm without using extra memory. **Input**: A list of integers where every element appears exactly twice except for one integer which appears exactly once. **Output**: Return that single integer. **Constraints**: - The array can have negative numbers. - You must implement the solution within O(n) time complexity and O(1) space complexity. **Examples**: 1. Input: `[2, 2, 1]` Output: `1` 2. Input: `[4, 1, 2, 1, 2]` Output: `4` 3. Input: `[1]` Output: `1` **Implementation**: Define a function `single_number(nums: List[int]) -> int` to solve the problem. Here is a prototype for your solution: ```python def single_number(nums): Returns single number, if found. Else, if all numbers appear twice, returns 0. :type nums: List[int] :rtype: int i = 0 for num in nums: i ^= num return i ``` Think carefully about how the XOR operation is used to solve this problem efficiently and without additional space.","solution":"def single_number(nums): Returns the single number in a list where every other number appears twice. :type nums: List[int] :rtype: int result = 0 for num in nums: result ^= num return result"},{"question":"# Merge Sort Implementation Challenge Scenario: You are given an array of integers that may contain both negative and positive values. Your task is to sort this array in ascending order using the Merge Sort algorithm. Merge Sort separates the list into halves, recursively sorts each half, and then merges the sorted halves back together. Function Signature: ```python def merge_sort(arr: List[int]) -> List[int]: ``` Input: * An array `arr` of integers (0 ≤ len(arr) ≤ 10^5) Output: * A sorted array of integers. Constraints: * The solution should maintain a time complexity of O(n log(n)). * The solution should handle arrays with up to 10^5 elements efficiently. * You must not use built-in sort functions. Performance Requirements: * Ensure that the sorting function handles edge cases like empty arrays and single-element arrays. * Make sure your function works for arrays with varying ranges of negative and positive integers. Example: ```python assert merge_sort([38, 27, 43, 3, 9, 82, 10]) == [3, 9, 10, 27, 38, 43, 82] assert merge_sort([3, -2, -1, 5, 0]) == [-2, -1, 0, 3, 5] assert merge_sort([]) == [] assert merge_sort([2]) == [2] ``` Write the function `merge_sort` that meets the above specification. Provide your implementation in Python.","solution":"from typing import List def merge_sort(arr: List[int]) -> List[int]: Sorts an array of integers in ascending order using the merge sort algorithm. Parameters: arr (List[int]): The array of integers to be sorted. Returns: List[int]: The sorted array of integers. if len(arr) <= 1: return arr mid = len(arr) // 2 left_half = merge_sort(arr[:mid]) right_half = merge_sort(arr[mid:]) return merge(left_half, right_half) def merge(left: List[int], right: List[int]) -> List[int]: Merges two sorted arrays into one sorted array. Parameters: left (List[int]): The first sorted array. right (List[int]): The second sorted array. Returns: List[int]: The merged and sorted array. sorted_array = [] left_index, right_index = 0, 0 while left_index < len(left) and right_index < len(right): if left[left_index] < right[right_index]: sorted_array.append(left[left_index]) left_index += 1 else: sorted_array.append(right[right_index]) right_index += 1 # If there are remaining elements in left half while left_index < len(left): sorted_array.append(left[left_index]) left_index += 1 # If there are remaining elements in right half while right_index < len(right): sorted_array.append(right[right_index]) right_index += 1 return sorted_array"},{"question":"# Path Resolution Utility Implementation You are tasked with implementing a utility function that constructs an absolute path from a given file path. The function should handle paths that start with the user\'s home directory symbol (`~`) and convert them to the corresponding absolute paths. Additionally, if a relative path is provided, it should be converted into an absolute path. Function Signature: ```python def full_path(file: str) -> str: ``` Parameters: - `file` (str): A string representing the file path, which could be relative, absolute, or contain a home directory symbol (`~`). Returns: - `str`: An absolute path corresponding to the given file path. Constraints: - You must use the `os.path` module from the Python Standard Library. - The function should handle edge cases such as empty strings and paths with invalid characters gracefully. Performance Requirements: - The solution should operate within linear time relative to the length of the file path. # Example Usage: ```python # Example 1: result = full_path(\\"~/docs/file.txt\\") # Expected: \'/home/username/docs/file.txt\' (where /home/username is the user\'s home directory) # Example 2: result = full_path(\\"docs/file.txt\\") # Expected: \'/current/working/directory/docs/file.txt\' (where /current/working/directory is the absolute path of the current working directory) # Example 3: result = full_path(\\"\\") # Expected: (Implementation-defined handling of empty string input) ```","solution":"import os def full_path(file: str) -> str: Converts a given file path to an absolute path. Handles paths starting with \'~\' (home directory) and relative paths. Parameters: file (str): A string representing the file path. Returns: str: An absolute path corresponding to the given file path. if not file: return os.getcwd() # Return the current working directory if file is an empty string. # Expand \'~\' to the user\'s home directory file = os.path.expanduser(file) # Convert the path to an absolute path return os.path.abspath(file)"},{"question":"# Question: Matrix Decomposition Validation You are tasked with implementing a matrix decomposition function to validate whether a given Hermitian positive-definite matrix can be decomposed using Cholesky decomposition. Specifications: - **Function Name**: `is_cholesky_decomposable` - **Input**: A square matrix (A) of size (n times n) provided as a list of lists containing float values. - **Output**: A boolean value - `True` if the matrix can be decomposed using Cholesky decomposition, `False` otherwise. Requirements: - The function must verify the matrix is: 1. Square (all rows have the same length as the number of columns). 2. Hermitian (symmetric if the matrix consists of real numbers). 3. Positive-Definite (all principal minors are positive). Input Constraints: - Matrix elements will be float values. - Matrix size (n leq 1000). Function Signature: ```python def is_cholesky_decomposable(A: List[List[float]]) -> bool: ``` Example: ```python # Example 1 A1 = [ [4, 12, -16], [12, 37, -43], [-16, -43, 98] ] assert is_cholesky_decomposable(A1) == True # Example 2 A2 = [ [1, 2], [2, 1] ] assert is_cholesky_decomposable(A2) == False ``` Constraints: - The matrix size will not exceed (1000 times 1000). - Matrix elements will be in the range of (-10^9) to (10^9). Performance Requirements: - Aim for an efficient implementation considering the provided constraints.","solution":"import numpy as np def is_cholesky_decomposable(A: list[list[float]]) -> bool: Determines if a matrix A can be decomposed using Cholesky decomposition. Args: A (list[list[float]]): A square matrix. Returns: bool: True if the matrix can be decomposed, False otherwise. # Check if A is a square matrix n = len(A) for row in A: if len(row) != n: return False # Convert matrix to NumPy array for easier manipulation and checks A_np = np.array(A, dtype=np.float64) # Check if A is symmetric if not np.allclose(A_np, A_np.T): return False # Check if A is positive-definite try: # Attempt Cholesky decomposition using numpy np.linalg.cholesky(A_np) return True except np.linalg.LinAlgError: return False"},{"question":"Scenario You have been appointed as a developer for a GPS company that needs to find the shortest path between various locations in a city. The city is represented as a weighted, directed graph where intersections are nodes, and roads between them are edges with non-negative weights indicating travel time. Task Implement Dijkstra\'s algorithm to find the shortest path from a given source intersection to all other intersections. Requirements * Define a `CityMap` class with a method `find_shortest_paths` that implements Dijkstra\'s algorithm. * The input graph will be represented as an adjacency matrix. * Your solution should be efficient and consider potential performance improvements. Input Format * `vertex_count` (integer): The number of intersections in the city. * `edges` (list of tuples): Each tuple `(u, v, w)` represents a directed edge from intersection `u` to intersection `v` with weight `w`. * `source` (integer): The source intersection from which shortest paths are to be calculated. Output Format * A list of integers where the `i-th` integer represents the shortest time from the source to the `i-th` intersection. If an intersection is unreachable, its value should be `float(\'inf\')`. Constraints * `1 <= vertex_count <= 100` * `0 <= weight <= 1000` * No negative weights will be provided. Example ```python input: vertex_count = 4 edges = [(0, 1, 1), (0, 2, 4), (1, 2, 2), (1, 3, 6), (2, 3, 3)] source = 0 output: [0, 1, 3, 6] ``` Note * Intersection labels range from `0` to `vertex_count - 1`. * Implement your solution considering the optimizations discussed. ```python class CityMap: def __init__(self, vertex_count): # initialize graph as an adjacency matrix self.vertex_count = vertex_count self.graph = [[0 for _ in range(vertex_count)] for _ in range(vertex_count)] def add_edges(self, edges): for u, v, w in edges: self.graph[u][v] = w def find_shortest_paths(self, source): # your implementation here pass ```","solution":"import heapq class CityMap: def __init__(self, vertex_count): # initialize graph as a list of lists (adjacency list) self.vertex_count = vertex_count self.graph = [[] for _ in range(vertex_count)] def add_edges(self, edges): for u, v, w in edges: self.graph[u].append((v, w)) def find_shortest_paths(self, source): # Initialize distances with infinity distances = [float(\'inf\')] * self.vertex_count # Distance to the source is 0 distances[source] = 0 # Use a priority queue for the min heap priority_queue = [(0, source)] # (distance, vertex) while priority_queue: current_distance, current_vertex = heapq.heappop(priority_queue) # Skip processing if we\'ve already found a better way if current_distance > distances[current_vertex]: continue # Visit all neighbors of the current vertex for neighbor, weight in self.graph[current_vertex]: distance = current_distance + weight # Only consider this new path if it\'s better if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances"},{"question":"# Question: Single Source Shortest Path in a Directed Graph Scenario You are a software developer working for a company that provides a mapping application. Your task is to implement an efficient route-finding feature that computes the shortest paths from a single location to all other locations in a given city. Problem Statement Write a function `shortest_paths(graph, src)` that implements Dijkstra\'s Algorithm to find the shortest path from the given source node to all other nodes in a directed graph with non-negative edge weights. Input * `graph`: a 2D list representing the adjacency matrix of the graph. `graph[i][j]` is the weight of the edge from node `i` to node `j`. If there is no edge, the weight will be 0. * `src`: an integer representing the source node index (0-based). Output * A list of distances where the value at index `i` represents the shortest distance from the source node `src` to the node `i`. Constraints * The number of vertices in the graph, `V`, is between 1 and 1000. * All edge weights are non-negative integers. * The graph is directed. * A node has a 0 distance to itself. Performance Requirements * Aim to write an efficient solution. Using a priority queue for the min-distance step is encouraged. Example ```python def shortest_paths(graph, src): # Your implementation here # Example usage: graph = [ [0, 10, 0, 30, 100], [0, 0, 50, 0, 0], [0, 0, 0, 0, 10], [0, 0, 20, 0, 60], [0, 0, 0, 0, 0], ] src = 0 print(shortest_paths(graph, src)) # Output: [0, 10, 50, 30, 60] ``` Note Ensure your function accurately handles graphs with vertices that have no outgoing edges and graphs with multiple routes between nodes.","solution":"import heapq def shortest_paths(graph, src): Implements Dijkstra\'s algorithm to find the shortest path from the given source node to all other nodes in a directed graph with non-negative edge weights. Parameters: graph (list of list of int): adjacency matrix representation of the graph src (int): index of the source node (0-based) Returns: list of int: list of shortest distances from src to each node V = len(graph) dist = [float(\'inf\')] * V dist[src] = 0 min_heap = [(0, src)] # (distance, node) while min_heap: current_dist, u = heapq.heappop(min_heap) if current_dist > dist[u]: continue for v in range(V): if graph[u][v] > 0: distance = current_dist + graph[u][v] if distance < dist[v]: dist[v] = distance heapq.heappush(min_heap, (distance, v)) return dist"},{"question":"Advanced Polynomial Algebra Context: You are employed by a company that specializes in symbolic computation software and have been tasked with improving the current polynomial handling capabilities of the system. The system uses Polynomials and Monomials classes as shared above for representing and performing algebraic operations such as addition, subtraction, multiplication, and division of polynomials and monomials. Task: Implement a function named `evaluate_polynomial` that takes a polynomial and a dictionary of values (substitution dictionary). The function should substitute the provided values into the polynomial and return the resulting evaluated value. Function Signature: ```python def evaluate_polynomial(poly: Polynomial, values: Dict[int, Union[int, float, Fraction]]) -> Fraction: pass ``` # Input: 1. `poly` (Polynomial): A polynomial object to be evaluated. 2. `values` (Dict[int, Union[int, float, Fraction]]): A dictionary where keys represent variable indices, and values represent the numbers (integers, floats, or fractions) to be substituted for those variables. # Output: - `Fraction`: The result of substituting the given values into the polynomial, rationalized if possible. # Constraints: - Each monomial within the polynomial will have unique combinations of variable indices. - The substitution dictionary will contain values for each variable present in the polynomial’s monomials. Example: ```python from fractions import Fraction poly = Polynomial([ Monomial({1: 1}, 2), # 2(a_1) Monomial({2: 3, 1: -1}, -1), # -1(a_2)^3(a_1)^(-1) Fraction(-1, 2) # -1/2 ]) values = {1: 2, 2: 3} result = evaluate_polynomial(poly, values) # Expected output: Fraction(169, 8) print(result) ``` **Explanation**: - The provided polynomial is `2(a_1) - 1(a_2)^3(a_1)^(-1) - 1/2`. - Substituting `a_1 = 2` and `a_2 = 3`: - `2(a_1)`: 2 * 2 = 4. - `-1(a_2)^3(a_1)^(-1)`: -1 * (3^3) * (2)^(-1) = -27/2 = -13.5. - Sum them up: 4 - 13.5 - 0.5 = -10. Implement the `evaluate_polynomial` function to ensure basic polynomial evaluations are efficient and correct.","solution":"from fractions import Fraction from typing import Dict, Union, List, Any class Monomial: def __init__(self, variables: Dict[int, int], coefficient: Union[int, float, Fraction]) -> None: self.variables = variables # Ex: {1: 2, 2: 1} -> x1^2 * x2 self.coefficient = Fraction(coefficient) def evaluate(self, values: Dict[int, Union[int, float, Fraction]]) -> Fraction: result = self.coefficient for var, power in self.variables.items(): if var in values: result *= Fraction(values[var]) ** power else: raise ValueError(f\\"Value for variable {var} not provided\\") return result class Polynomial: def __init__(self, monomials: List[Union[Monomial, Fraction]]) -> None: self.monomials = monomials def evaluate_polynomial(poly: Polynomial, values: Dict[int, Union[int, float, Fraction]]) -> Fraction: result = Fraction(0) for monomial in poly.monomials: if isinstance(monomial, Monomial): result += monomial.evaluate(values) elif isinstance(monomial, Fraction): result += monomial else: raise ValueError(\\"Invalid monomial type in polynomial\\") return result # Example usage if __name__ == \\"__main__\\": poly = Polynomial([ Monomial({1: 1}, 2), # 2(a_1) Monomial({2: 3, 1: -1}, -1), # -1(a_2)^3(a_1)^(-1) Fraction(-1, 2) # -1/2 ]) values = {1: 2, 2: 3} print(evaluate_polynomial(poly, values)) # Expected output: Fraction(169, 8)"},{"question":"# Question: Implement Radix Sort with Negative Numbers Support Radix sort as implemented above only handles non-negative integers. Adapt this algorithm to be capable of handling both positive and negative integers within the given list. Task Write a function `radix_sort_with_negatives(arr)` that sorts an array of integers in ascending order using the radix sort mechanism and handles both negative and positive integers. # Input * An unsorted list of integers, `arr` with `1 <= len(arr) <= 10^6`. # Output * A list of integers, sorted in ascending order. # Constraints * The elements of the input list `arr` are integer numbers in the range `-10^6 <= arr[i] <= 10^6`. # Example Function call: ```python assert radix_sort_with_negatives([-17, 543, -998, 0, 14, -5, 4000, -4001]) == [-4001, -998, -17, -5, 0, 14, 543, 4000] ``` Explanation Your task is to adapt the radix sort algorithm to segregate negative and positive numbers and apply radix sort on both segments appropriately before merging the results into a single sorted array.","solution":"def counting_sort(arr, exp): A helper function to perform counting sort on arr based on the digit at exp (1, 10, 100, ...), suitable for positive integers. n = len(arr) output = [0] * n count = [0] * 10 for i in range(n): index = abs(arr[i]) // exp count[index % 10] += 1 for i in range(1, 10): count[i] += count[i - 1] for i in range(n - 1, -1, -1): index = abs(arr[i]) // exp output[count[index % 10] - 1] = arr[i] count[index % 10] -= 1 for i in range(n): arr[i] = output[i] def radix_sort(arr): A helper function to perform radix sort on arr containing positive integers. max1 = max(arr) exp = 1 while max1 // exp > 0: counting_sort(arr, exp) exp *= 10 def radix_sort_with_negatives(arr): This function sorts an array of integers in ascending order using the radix sort mechanism and can handle both negative and positive integers. if not arr: return [] negative_numbers = [num for num in arr if num < 0] positive_numbers = [num for num in arr if num >= 0] if negative_numbers: max_negative = abs(min(negative_numbers)) for i in range(len(negative_numbers)): negative_numbers[i] = max_negative - abs(negative_numbers[i]) radix_sort(negative_numbers) for i in range(len(negative_numbers)): negative_numbers[i] = -(max_negative - negative_numbers[i]) if positive_numbers: radix_sort(positive_numbers) return negative_numbers + positive_numbers"},{"question":"# Question: Removing Duplicates from a Linked List Scenario: You are given an unsorted linked list, and your task is to write two functions to remove duplicates from it, depending on the constraints: one that utilizes extra space for faster processing, and another that uses only constant extra space for processing but is less efficient in terms of time. Objective: Implement and compare the following two functions: 1. `remove_duplicates_with_set(head)`: This function should remove duplicates from the linked list by using a set to track seen values. 2. `remove_duplicates_without_set(head)`: This function should remove duplicates without using any additional data structures for tracking. Function Signatures: ```python def remove_duplicates_with_set(head: Node) -> None: pass def remove_duplicates_without_set(head: Node) -> None: pass class Node: def __init__(self, val: int = None): self.val = val self.next = None ``` Constraints: * Your functions should handle an empty list. * Input list can have up to 10^6 nodes. * Values in the linked list nodes are integers and can have up to 10^7 unique values. * Your implementation should not modify the values of any nodes, only the structure of the list. Example: Assume the list is constructed as below. ```python a1 = Node(1) a2 = Node(1) b = Node(2) c1 = Node(3) d = Node(4) c2 = Node(3) f = Node(5) g = Node(6) a1.next = a2 a2.next = b b.next = c1 c1.next = d d.next = c2 c2.next = f f.next = g ``` 1. After running `remove_duplicates_with_set(a1)`, the list should become: ``` 1 -> 2 -> 3 -> 4 -> 5 -> 6 ``` 2. Same result is expected when `remove_duplicates_without_set(a1)` is executed with the initial list. Performance Notes: * `remove_duplicates_with_set` should complete in O(N) time and O(N) space. * `remove_duplicates_without_set` should complete in O(N^2) time and O(1) space.","solution":"class Node: def __init__(self, val: int = None): self.val = val self.next = None def remove_duplicates_with_set(head: Node) -> None: if not head: return seen = set() current = head prev = None while current: if current.val in seen: prev.next = current.next else: seen.add(current.val) prev = current current = current.next def remove_duplicates_without_set(head: Node) -> None: current = head while current: runner = current while runner.next: if runner.next.val == current.val: runner.next = runner.next.next else: runner = runner.next current = current.next"},{"question":"# Hamming Weight Calculation Scenario In digital communications, error detection can often be implemented using simple checksum calculations. One such calculation involves counting the number of set bits (1s) in binary representations of data. You are tasked with writing a function to calculate this efficiently for use in a new communications protocol. Problem Statement Write a function `count_hamming_weight` that takes an unsigned integer and returns the number of \'1\' bits in its binary representation. Constraints 1. The function should handle integers up to 32-bits. 2. Input is guaranteed to be a non-negative integer. Input * An unsigned integer `n` (0 <= n <= 2^32-1). Output * The function should return an integer representing the number of \'1\' bits in the binary representation of `n`. Examples ```python assert count_hamming_weight(11) == 3 # Binary: 00000000000000000000000000001011 assert count_hamming_weight(128) == 1 # Binary: 00000000000000000000000010000000 assert count_hamming_weight(255) == 8 # Binary: 00000000000000000000000011111111 assert count_hamming_weight(1023) == 10 # Binary: 00000000000000000000001111111111 ``` Make sure to handle typical edge cases such as the smallest and largest possible values within the mentioned constraints effectively.","solution":"def count_hamming_weight(n): Returns the number of \'1\' bits in the binary representation of the given non-negative integer n. count = 0 while n: count += n & 1 n >>= 1 return count"},{"question":"# Context You are working on implementing an efficient search function to find specific elements in a database. The database stores records in sorted order. You need to implement an algorithm to find the first occurrence of a query element from this sorted database array. # Problem Statement Write a function `first_occurrence` that takes in a sorted array of integers and an integer query, and returns the index of the first occurrence of the query in the array. If the query is not present in the array, return -1. # Function Signature ```python def first_occurrence(array: List[int], query: int) -> int: pass ``` # Input and Output Formats - The function will receive: - `array`: List of integers sorted in increasing order. - `query`: A single integer to search for in the array. - The function should return a single integer indicating the index of the first occurrence of `query` in `array`. If `query` is not found, return `-1`. # Constraints - The length of `array` is between 0 and 10^5. - Each element in `array` is an integer between -10^9 and 10^9. - The array can contain duplicate entries. # Example ```python assert first_occurrence([1,2,2,2,3,4], 2) == 1 assert first_occurrence([1,2,3,4,5], 6) == -1 assert first_occurrence([], 1) == -1 assert first_occurrence([1,1,1,1,1], 1) == 0 ``` # Performance Requirements - Aim for O(log n) time complexity. - Ensure O(1) space complexity. # Edge Cases - Handle empty arrays and unpresent values correctly. - Ensure correct handling of arrays with only one element.","solution":"from typing import List def first_occurrence(array: List[int], query: int) -> int: Finds the first occurrence of query in a sorted array. Parameters: array (List[int]): A list of integers sorted in increasing order. query (int): The integer value to search for. Returns: int: The index of the first occurrence of query in the array. Returns -1 if query is not found. left, right = 0, len(array) - 1 result = -1 while left <= right: mid = (left + right) // 2 if array[mid] == query: result = mid right = mid - 1 elif array[mid] < query: left = mid + 1 else: right = mid - 1 return result"},{"question":"Extended Operations on Min-Heap A min-heap is a binary heap where each parent node is smaller than or equal to its child nodes. We have a basic min-heap implementation provided that supports insertion and removal of the minimum element. **Your task is to extend the current `BinaryHeap` class with additional functionalities:** 1. **Decrease a key value**: Given an index and a new value, update the element at that index with the new value and ensure the heap property is maintained. 2. **Heapify a given array**: Given an arbitrary array, transform it into a valid min-heap. Implement the following methods in the `BinaryHeap` class: ```python class BinaryHeap(AbstractHeap): # other methods... def decrease_key(self, index, new_val): Decreases the value of the element at index \'index\' to \'new_val\' and ensure the min-heap property is maintained. :param index: The index of the element whose value is to be decreased. :param new_val: The new value of the element. pass def heapify_array(self, array): Transform an arbitrary array into a valid min-heap. :param array: List of elements to be transformed into a min-heap. :return: None, transforms the array in place. pass ``` # Function Requirements 1. **decrease_key(index, new_val)**: - **Input**: - `index`: an integer representing the index in the heap array (1-based indexing as per the provided heap code). - `new_val`: the new value to be assigned, which is guaranteed to be smaller than the current value at the specified index. - **Output**: None. Modify the heap in place. 2. **heapify_array(array)**: - **Input**: - `array`: a list of integers. - **Output**: None. Modify the input array in place to make it satisfy the min-heap property. # Constraints 1. The new value in `decrease_key` will always be smaller than the current value at the provided index. 2. The input array for `heapify_array` will have at least one element. # Example ```python heap = BinaryHeap() heap.heapify_array([5, 3, 8, 4]) print(heap.heap) # Example transformed heap might look like [0, 3, 4, 8, 5] heap.decrease_key(3, 2) print(heap.heap) # Heap after decreasing key at index 3 to 2 might look like [0, 2, 4, 3, 5] ``` # Notes 1. Ensure your solution is efficient (aim for O(N) complexity for `heapify_array` and O(log N) for `decrease_key`).","solution":"class BinaryHeap: def __init__(self): self.heap = [0] self.current_size = 0 def perc_up(self, i): while i // 2 > 0: if self.heap[i] < self.heap[i // 2]: self.heap[i], self.heap[i // 2] = self.heap[i // 2], self.heap[i] i //= 2 def perc_down(self, i): while (i * 2) <= self.current_size: mc = self.min_child(i) if self.heap[i] > self.heap[mc]: self.heap[i], self.heap[mc] = self.heap[mc], self.heap[i] i = mc def min_child(self, i): if i * 2 + 1 > self.current_size: return i * 2 else: if self.heap[i * 2] < self.heap[i * 2 + 1]: return i * 2 else: return i * 2 + 1 def insert(self, k): self.heap.append(k) self.current_size += 1 self.perc_up(self.current_size) def del_min(self): retval = self.heap[1] self.heap[1] = self.heap[self.current_size] self.current_size -= 1 self.heap.pop() self.perc_down(1) return retval def decrease_key(self, index, new_val): Decreases the value of the element at index \'index\' to \'new_val\' and ensure the min-heap property is maintained. :param index: The index of the element whose value is to be decreased (1-based indexing). :param new_val: The new value of the element. if index < 1 or index > self.current_size: raise IndexError(\\"Index out of range\\") if new_val >= self.heap[index]: raise ValueError(\\"New value must be smaller than the current value\\") self.heap[index] = new_val self.perc_up(index) def heapify_array(self, array): Transform an arbitrary array into a valid min-heap. :param array: List of elements to be transformed into a min-heap. :return: None, transforms the array in place. self.heap = [0] + array[:] self.current_size = len(array) i = len(array) // 2 while i > 0: self.perc_down(i) i -= 1"},{"question":"# Sudoku Solver with Heuristic Backtracking Background Sudoku is a popular number puzzle that requires filling a 9x9 grid in such a way that each row, column, and each of the 9 3x3 subgrids contains all digits from 1 to 9 exactly once. Given a partially filled grid, we need to fill the rest and complete the puzzle. Task Implement a Sudoku solver in Python using backtracking with a heuristic approach of selecting the cell with the fewest possible values first. Function Signature ```python def sudoku_solver(board: List[List[str]]) -> bool: Solves the given Sudoku puzzle in-place. Parameters: board (List[List[str]]): 2D list representing a partially filled 9x9 Sudoku grid. Empty cells are represented by \'.\'. Returns: bool: True if the board is successfully solved, False otherwise. ``` Input - `board`: A list of lists where each sublist represents a row of the Sudoku grid, containing numbers (\'1\'-\'9\') or \'.\' for empty cells. Output - Return `True` if the board is successfully solved in-place, `False` if the board cannot be solved. Constraints - The given board will have exactly 9 rows and 9 columns. - Each cell will be either filled with a digit (\'1\'-\'9\') or an empty cell denoted by \'.\'. - The grid will be partially filled and always will have at least one solution. Example ```python board = [ [\\"5\\",\\"3\\",\\".\\",\\".\\",\\"7\\",\\".\\",\\".\\",\\".\\",\\".\\"], [\\"6\\",\\".\\",\\".\\",\\"1\\",\\"9\\",\\"5\\",\\".\\",\\".\\",\\".\\"], [\\".\\",\\"9\\",\\"8\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\"], [\\"8\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\"3\\"], [\\"4\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\"3\\",\\".\\",\\".\\",\\"1\\"], [\\"7\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\".\\",\\".\\",\\".\\",\\"6\\"], [\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\"8\\",\\".\\"], [\\".\\",\\".\\",\\".\\",\\"4\\",\\"1\\",\\"9\\",\\".\\",\\".\\",\\"5\\"], [\\".\\",\\".\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\".\\",\\"7\\",\\"9\\"] ] assert sudoku_solver(board) == True # board should be modified in-place to a valid solved state ``` Hints 1. Use a dictionary to keep track of potential values for each empty cell. 2. Select cells with the fewest options first to reduce the search space and improve efficiency. 3. Carefully implement the backtracking approach to undo changes when a potential solution path does not work out.","solution":"from typing import List, Tuple def find_unassigned_cell(board: List[List[str]]) -> Tuple[int, int]: min_options = float(\'inf\') best_cell = (-1, -1) for r in range(9): for c in range(9): if board[r][c] == \'.\': options = get_possible_values(board, r, c) if len(options) < min_options: min_options = len(options) best_cell = (r, c) if min_options == 1: return best_cell return best_cell def get_possible_values(board: List[List[str]], row: int, col: int) -> List[str]: possible = set(\'123456789\') for k in range(9): if board[row][k] in possible: possible.remove(board[row][k]) if board[k][col] in possible: possible.remove(board[k][col]) start_row, start_col = 3 * (row // 3), 3 * (col // 3) for r in range(start_row, start_row + 3): for c in range(start_col, start_col + 3): if board[r][c] in possible: possible.remove(board[r][c]) return list(possible) def sudoku_solver(board: List[List[str]]) -> bool: def solve(): row, col = find_unassigned_cell(board) if row == -1 and col == -1: return True for num in get_possible_values(board, row, col): board[row][col] = num if solve(): return True board[row][col] = \'.\' return False return solve()"},{"question":"Maximum Flow in Transportation Network **Context**: In a city transportation network, various intersections are linked by roads with a certain capacity representing the maximum number of vehicles that can pass through per unit time. The goal is to determine the maximum number of vehicles that can travel from a designated start intersection to an end intersection. **Task**: You are provided three different algorithms to compute the maximum flow: Ford-Fulkerson, Edmonds-Karp, and Dinic\'s Algorithm. Your task is to implement the `maximum_flow` using one of these algorithms of your choice. **Function Signature**: ```python def maximum_flow(capacity: List[List[int]], source: int, sink: int) -> int: pass ``` **Input**: * `capacity`: A 2D list of integers where `capacity[i][j]` is the capacity of the road from intersection `i` to intersection `j` (0 <= i, j < V). If there\'s no road, `capacity[i][j]` will be 0. * `source`: An integer representing the start intersection. * `sink`: An integer representing the end intersection. **Output**: * Returns the maximum number of vehicles that can be transported from `source` to `sink`. **Constraints**: * 2 <= V <= 100 * 0 <= capacity[i][j] <= 10^4 * 0 <= source, sink < V **Example**: ```python capacity = [ [0, 16, 13, 0, 0, 0], [0, 0, 10, 12, 0, 0], [0, 4, 0, 0, 14, 0], [0, 0, 9, 0, 0, 20], [0, 0, 0, 7, 0, 4], [0, 0, 0, 0, 0, 0] ] source = 0 sink = 5 print(maximum_flow(capacity, source, sink)) # Output: 23 ``` **Special Notes**: * Efficiency is key, so choose an algorithm that handles large graphs within the constraints efficiently. * Be mindful of edge cases such as no possible path between source and sink.","solution":"from collections import deque from typing import List def bfs(capacity: List[List[int]], source: int, sink: int, parent: List[int]) -> bool: visited = [False] * len(capacity) queue = deque([source]) visited[source] = True while queue: u = queue.popleft() for v, cap in enumerate(capacity[u]): if not visited[v] and cap > 0: # not visited and there is available capacity queue.append(v) visited[v] = True parent[v] = u if v == sink: return True return False def maximum_flow(capacity: List[List[int]], source: int, sink: int) -> int: parent = [-1] * len(capacity) max_flow = 0 while bfs(capacity, source, sink, parent): path_flow = float(\'Inf\') s = sink while s != source: path_flow = min(path_flow, capacity[parent[s]][s]) s = parent[s] max_flow += path_flow v = sink while v != source: u = parent[v] capacity[u][v] -= path_flow capacity[v][u] += path_flow v = parent[v] return max_flow"},{"question":"# Scenario You are working on a codebase related to a simulation system where you need to ensure that certain operations on stacks only proceed when the stack elements are ordered correctly. To implement this functionality, you need a function to verify if a given stack is sorted in ascending order from bottom to top. # Problem Statement Write a function `is_sorted_stack(stack)` that determines if the elements in a given stack are in ascending order from bottom to top. You must not use any additional stacks or arrays beyond temporary variables and must restore the original stack to its initial state after checking. # Input * `stack`: A list representing a stack structure (you can assume that all elements in the stack are integers). # Output * Return `True` if the elements are sorted in ascending order from bottom to top, otherwise return `False`. # Constraints 1. You may only use temporary variables (not additional data structures like lists or stacks) to facilitate the checking process. 2. The stack must be restored to its original state after the function execution. # Performance Requirements * Time complexity should be O(n). * Space complexity should be minimized, ideally O(1) excluding the input stack. # Function Signature ```python def is_sorted_stack(stack): # Your code here pass ``` # Example ```python assert is_sorted_stack([1, 2, 3, 4, 5]) == True assert is_sorted_stack([5, 4, 3, 2, 1]) == False assert is_sorted_stack([3, 1, 4, 2, 5]) == False assert is_sorted_stack([7, 10, 14, 21]) == True ```","solution":"def is_sorted_stack(stack): Determines if the elements in a given stack are in ascending order from bottom to top. :param stack: List representing a stack; element at the end is the top of the stack. :return: True if elements are sorted in ascending order from bottom to top, False otherwise. if not stack: return True # Create a copy of the stack to avoid modifying the original stack. temp_stack = stack[:] # Remove the first element to start the comparison. prev = temp_stack.pop() while temp_stack: curr = temp_stack.pop() if curr > prev: return False prev = curr return True"},{"question":"# Scenario You have been hired to develop a feature for a gaming application that manages a dynamic set of online players. The set should support adding a new player, removing a player, and retrieving a random player quickly to implement matchmaking. # Problem Statement Design and implement a data structure named `PlayerSet` that supports the following operations efficiently: 1. **`add_player(player_id)`**: Adds a player to the set if not already present. 2. **`remove_player(player_id)`**: Removes a player from the set if present. 3. **`get_random_player()`**: Returns a random player from the current set of players. Each player must have an equal probability of being returned. # Function Signatures ```python class PlayerSet: def __init__(self): # Initializes an empty PlayerSet def add_player(self, player_id: int) -> None: # Adds a player to the set. If player_id already exists, do nothing. def remove_player(self, player_id: int) -> None: # Removes a player from the set. If player_id does not exist, do nothing. def get_random_player(self) -> int: # Returns a random player from the set. ``` # Constraints - All player IDs are unique integers. - You should aim for O(1) average time complexity for `add_player`, `remove_player`, and `get_random_player` operations. - The total number of players (`n`) is at most 10^5. # Performance Requirements - Ensure that your solution is optimized for both time and space. - Handle the edge cases such as trying to remove a player that does not exist or getting a random player from an empty set gracefully. # Example ```python # Example usage: pset = PlayerSet() pset.add_player(1) pset.add_player(2) pset.add_player(3) print(pset.get_random_player()) # Should return 1, 2, or 3 randomly. pset.remove_player(2) print(pset.get_random_player()) # Should return 1 or 3 randomly. ```","solution":"import random class PlayerSet: def __init__(self): self.players = {} self.player_list = [] def add_player(self, player_id: int) -> None: Adds a player to the set if not already present. if player_id not in self.players: self.players[player_id] = len(self.player_list) self.player_list.append(player_id) def remove_player(self, player_id: int) -> None: Removes a player from the set if present. if player_id in self.players: # Move the last element to the place idx of the element to delete last_player = self.player_list[-1] idx = self.players[player_id] self.player_list[idx] = last_player self.players[last_player] = idx # Remove the last element self.player_list.pop() del self.players[player_id] def get_random_player(self) -> int: Returns a random player from the set. if not self.player_list: raise ValueError(\\"No players in the set\\") return random.choice(self.player_list)"},{"question":"# Question: Finding Two Unique Numbers in an Array Given an array `nums` containing `2N + 2` integers where `N` is a non-negative integer, and all integers except two appear exactly twice. Implement a function `single_number3`. This function should find the two numbers that appear only once in the array. **Function Signature** ```python def single_number3(nums: List[int]) -> List[int]: ``` **Input** - `nums` (List[int]): List of integers where all elements except two appear exactly twice. **Output** - List[int]: List of the two integers that appear only once. The order does not matter. **Constraints** 1. `nums` will have a length of `2N + 2`. 2. The solution must run in O(N) time and use O(1) extra space. **Example** ```python assert single_number3([1, 2, 1, 3, 2, 5]) in [[3, 5], [5, 3]] assert single_number3([4, 6, 4, 7]) in [[6, 7], [7, 6]] ``` # Explanation Consider the example `nums = [1, 2, 1, 3, 2, 5]`. 1. **Step 1**: Utilize the XOR operation to isolate the combined result of the two unique numbers: ```python ab = 1 ^ 2 ^ 1 ^ 3 ^ 2 ^ 5 # = 6 ``` 2. **Step 2**: Identify the rightmost differing bit in `ab`: ```python right_most = ab & (-ab) # = 2 ``` 3. **Step 3**: Divide numbers into two groups based on the identified bit and XOR them to find the two unique numbers: ```python group1: [2, 2, 3] -> 3 group2: [1, 1, 5] -> 5 ``` Thus, the unique numbers are `[3, 5]`. The result order does not matter, so `[5, 3]` is also correct. Write the `single_number3` function to ensure it meets the above requirements.","solution":"from typing import List def single_number3(nums: List[int]) -> List[int]: # Step 1: XOR all numbers to get the XOR of the two unique numbers xor_all = 0 for num in nums: xor_all ^= num # Step 2: Find the rightmost set bit rightmost_set_bit = xor_all & (-xor_all) # Step 3: Separate the numbers into two groups based on the rightmost set bit num1, num2 = 0, 0 for num in nums: if num & rightmost_set_bit: num1 ^= num else: num2 ^= num return [num1, num2]"},{"question":"# Question: Single Non-Repeating Element Finder Given an array of integers, each element in the array appears exactly three times except for one unique element which appears exactly once. Your task is to implement a function `find_single_number(nums)` that returns the unique element. Your solution must: - Have a time complexity of O(N). - Use constant space, i.e., O(1) additional memory. # Input - An array of integers `nums` of length N (1 ≤ N ≤ 10^6) where every element appears exactly three times except for one element which appears exactly once. # Output - Return the single integer that appears only once in the array. # Constraints - You can assume that the lonely integer does exist and is unique. - The array will contain at least one element. # Example ```python def find_single_number(nums): # Your code here # Test cases: print(find_single_number([2, 2, 3, 2])) # Output: 3 print(find_single_number([0, 1, 0, 1, 0, 1, 99])) # Output: 99 print(find_single_number([-2, -2, 1, -2])) # Output: 1 ``` # Note Your implementation should use bitwise operations to achieve the desired space and time complexity requirements effectively.","solution":"def find_single_number(nums): Finds the single number that appears exactly once in the array where every other element appears exactly three times. :param nums: List of integers :return: The single unique integer ones, twos = 0, 0 for num in nums: # Update ones and twos such that bits that have appeared thrice are cleared ones = (ones ^ num) & ~twos twos = (twos ^ num) & ~ones return ones"},{"question":"You are given the implementation of Bitonic Sort. Your task is to modify the provided algorithm to handle arrays whose sizes are not powers of two by padding the array with `float(\'inf\')` values to the next power of two, then sorting the padded array, and finally returning the sorted non-inf part. # Function Signature ```python def custom_bitonic_sort(arr, reverse=False): Sorts the given array using Bitonic Sort, supporting array lengths that are not powers of two. Parameters: arr (list): List of comparable elements to be sorted. reverse (bool): If True, sort the array in ascending order; if False, sort in descending order. Returns: list: Sorted list in the specified order. pass # Implement the function ``` # Input * `arr`: A list of comparable elements (integers, floats, etc.) to be sorted. `1 <= len(arr) <= 10^6`. * `reverse`: A boolean flag indicating the sorting order. `True` for ascending, `False` for descending. # Output * A list with elements sorted as per the `reverse` flag. # Constraints 1. The length of the input array is between 1 and (10^6). 2. Elements in the array can be any type that supports comparison operations. # Example ```python assert custom_bitonic_sort([3, 7, 2, 5, 1], reverse=True) == [1, 2, 3, 5, 7] assert custom_bitonic_sort([3, 7, 2, 5, 1], reverse=False) == [7, 5, 3, 2, 1] assert custom_bitonic_sort([10, 2, 3], reverse=True) == [2, 3, 10] assert custom_bitonic_sort([10, 2, 3], reverse=False) == [10, 3, 2] ``` # Detailed Requirements: * Adjust the list to the next power of two by padding with `float(\'inf\')`. * Use the given `bitonic_sort` function after padding to sort the array. * Remove the padded `float(\'inf\')` values from the result before returning.","solution":"def next_power_of_two(n): Returns the next power of two greater than or equal to n if n == 0: return 1 n -= 1 n |= n >> 1 n |= n >> 2 n |= n >> 4 n |= n >> 8 n |= n >> 16 n += 1 return n def bitonic_merge(arr, low, cnt, direction): Helper function to merge bitonic sequence if cnt > 1: k = cnt // 2 for i in range(low, low + k): if (direction == (arr[i] > arr[i + k])): arr[i], arr[i + k] = arr[i + k], arr[i] bitonic_merge(arr, low, k, direction) bitonic_merge(arr, low + k, k, direction) def bitonic_sort_recursive(arr, low, cnt, direction): Helper function to sort bitonic sequence recursively if cnt > 1: k = cnt // 2 bitonic_sort_recursive(arr, low, k, True) bitonic_sort_recursive(arr, low + k, k, False) bitonic_merge(arr, low, cnt, direction) def bitonic_sort(arr, direction=True): Main function to sort the array using bitonic sort bitonic_sort_recursive(arr, 0, len(arr), direction) def custom_bitonic_sort(arr, reverse=False): Sorts the given array using Bitonic Sort, supporting array lengths that are not powers of two. Parameters: arr (list): List of comparable elements to be sorted. reverse (bool): If True, sort the array in ascending order; if False, sort in descending order. Returns: list: Sorted list in the specified order. n = len(arr) next_pow_two = next_power_of_two(n) padded_array = arr + [float(\'inf\')] * (next_pow_two - n) bitonic_sort(padded_array, direction=reverse) sorted_arr = [x for x in padded_array if x != float(\'inf\')] return sorted_arr"},{"question":"# Zigzag Level Order Traversal of a Binary Tree **Objective**: Write a function that takes the root node of a binary tree and returns its zigzag level order traversal (alternating between left-to-right and right-to-left at each level). **Function Signature**: ```python def zigzag_level(root): pass ``` **Input**: - `root`: TreeNode - The root node of a binary tree. **Output**: - `List[List[int]]`: A list of integer lists, each representing the values of nodes at respective levels in zigzag order. **Constraints**: - The number of nodes in the tree is in the range [0, 2000]. - Node values are integers and can be negative. **Requirements**: - Must use a BFS approach for level-wise traversal. - Must handle alternating order by using a flag or similar mechanism. **Example**: ```python # Representing the tree: # 3 # / # 9 20 # / # 15 7 # Input: root = TreeNode(3) root.left = TreeNode(9) root.right = TreeNode(20) root.right.left = TreeNode(15) root.right.right = TreeNode(7) # Output: [[3], [20, 9], [15, 7]] print(zigzag_level(root)) ``` **Edge Cases to Consider**: - A tree with no nodes should return an empty list. - A tree with a single node should return a list containing one list with that node\'s value. - A linear tree (all nodes have only one child) should handle alternating traversal correctly.","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def zigzag_level(root): Function to perform zigzag level order traversal of a binary tree. if not root: return [] results = [] queue = deque([root]) left_to_right = True while queue: level_size = len(queue) level_nodes = deque() for _ in range(level_size): node = queue.popleft() if left_to_right: level_nodes.append(node.val) else: level_nodes.appendleft(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) results.append(list(level_nodes)) left_to_right = not left_to_right return results"},{"question":"You are given an array of integers. Your task is to implement the merge sort algorithm as specified below to sort the array in ascending order. **Function Signature**: ```python def merge_sort(arr: List[int]) -> List[int]: pass ``` **Input**: - `arr`: A list of integers `arr` (0 <= len(arr) <= 10^5). **Output**: - A list of integers sorted in ascending order. # Constraints - The function should handle empty lists. - The function should leverage divide-and-conquer via recursive splitting and merging. - You are required to sort the array in-place within the merge function to optimize space complexity. # Example ```python >>> arr = [34, 7, 23, 32, 5, 62] >>> merge_sort(arr) [5, 7, 23, 32, 34, 62] >>> arr = [] >>> merge_sort(arr) [] ``` Ensure your implementation is efficient and can handle the provided constraints effectively. The performance of your merge_sort function will be evaluated based on its correctness and efficiency.","solution":"from typing import List def merge_sort(arr: List[int]) -> List[int]: if len(arr) <= 1: return arr def merge(left: List[int], right: List[int]) -> List[int]: merged = [] left_index = right_index = 0 # Compare elements from left and right list and merge them in sorted order while left_index < len(left) and right_index < len(right): if left[left_index] < right[right_index]: merged.append(left[left_index]) left_index += 1 else: merged.append(right[right_index]) right_index += 1 # Append remaining elements from left sublist if any merged.extend(left[left_index:]) # Append remaining elements from right sublist if any merged.extend(right[right_index:]) return merged mid = len(arr) // 2 left_sorted = merge_sort(arr[:mid]) right_sorted = merge_sort(arr[mid:]) return merge(left_sorted, right_sorted)"},{"question":"You are given an array of integers that need to be sorted in non-decreasing order. To test your understanding of sorting algorithms, especially Selection Sort, write a function that implements this algorithm. # Function Signature ```python def selection_sort(arr: List[int], simulation: bool = False) -> List[int]: pass ``` # Input * `arr` (List[int]): A list of `n` integers where (0 leq n leq 1000). * `simulation` (bool): A boolean flag that indicates whether to print the state of the array after each iteration of Selection Sort. # Output * (List[int]): The sorted list of integers. # Constraints 1. The function should sort the list in-place. 2. If the `simulation` flag is set to `True`, the function should print the state of the array after each iteration in the following format: ``` iteration <number>: <array elements separated by space> ``` # Examples ```python >>> selection_sort([64, 25, 12, 22, 11]) iteration 0: 11 25 12 22 64 iteration 1: 11 12 25 22 64 iteration 2: 11 12 22 25 64 iteration 3: 11 12 22 25 64 iteration 4: 11 12 22 25 64 [11, 12, 22, 25, 64] >>> selection_sort([38, 27, 43, 3, 9, 82, 10]) iteration 0: 3 27 43 38 9 82 10 iteration 1: 3 9 43 38 27 82 10 iteration 2: 3 9 10 38 27 82 43 iteration 3: 3 9 10 27 38 82 43 iteration 4: 3 9 10 27 38 82 43 iteration 5: 3 9 10 27 38 43 82 iteration 6: 3 9 10 27 38 43 82 [3, 9, 10, 27, 38, 43, 82] ``` # Note 1. Ensure the output format for each iteration is exactly as shown in the examples. 2. Pay special attention to handle all edge cases such as empty lists or single-element lists efficiently.","solution":"from typing import List def selection_sort(arr: List[int], simulation: bool = False) -> List[int]: Sorts a list of integers in non-decreasing order using Selection Sort algorithm. Parameters: arr (List[int]): The list of integers to be sorted. simulation (bool): If True, prints the state of the array after each iteration. Returns: List[int]: The sorted list of integers. n = len(arr) for i in range(n): # Find the minimum element in remaining unsorted array min_idx = i for j in range(i+1, n): if arr[j] < arr[min_idx]: min_idx = j # Swap the found minimum element with the first element arr[i], arr[min_idx] = arr[min_idx], arr[i] # If simulation flag is True, print the array\'s current state if simulation: print(f\\"iteration {i}: {\' \'.join(map(str, arr))}\\") return arr"},{"question":"# Background You are tasked to manage tasks in a system based on their priorities using a priority queue. The priority queue needs to efficiently insert new tasks while maintaining order and allow quick extraction of the highest priority task. # Task Implement a Priority Queue where tasks are managed based on their priorities using a more efficient data structure than a linear array. # Requirements 1. **Insertion**: Insert tasks into the priority queue such that the complexity of insertion is improved from O(n). 2. **Extract Min**: Extract the task with the lowest priority in O(1) time. 3. **Extract Max** (Optional): Implement this if you have the capacity. # Input and Output Format 1. Implement the following methods in the class `PriorityQueue`: - `push(item, priority)`: Insert an item with a given priority. - `pop_min()`: Remove and return the item with the lowest priority. - `pop_max()` (Optional): Remove and return the item with the highest priority. # Example ```python pq = PriorityQueue() pq.push(\\"task1\\", 5) pq.push(\\"task2\\", 3) pq.push(\\"task3\\", 4) print(pq.pop_min()) # Output: task2 ``` # Constraints - You can assume priorities will be distinct integers. - Ensure your implementation handles edge cases such as popping from an empty queue.","solution":"import heapq class PriorityQueue: def __init__(self): self.min_heap = [] self.min_heap_count = 0 def push(self, item, priority): heapq.heappush(self.min_heap, (priority, self.min_heap_count, item)) self.min_heap_count += 1 def pop_min(self): if not self.min_heap: raise IndexError(\\"pop_min from an empty priority queue\\") return heapq.heappop(self.min_heap)[-1] def pop_max(self): # Optional raise NotImplementedError(\\"pop_max method not implemented\\")"},{"question":"# Question: Sort Colors Challenge **Objective**: You are given an array containing integers `0`, `1`, and `2` representing the colors red, white, and blue respectively. Write a function to sort the array so that all instances of `0` come before `1`s and all `1`s come before `2`s. You must implement this function without using any built-in sort functions and ensure it works in linear time and uses constant extra space. # Function Signature ```python def sort_colors(nums: List[int]) -> None: pass ``` # Input * A list of integers `nums` where each element is `0`, `1`, or `2`. # Output * The function should modify the list `nums` in-place, sorting it so that all `0`s appear first, followed by all `1`s, and then all `2`s. # Constraints * Do not use any library\'s sort function. * The algorithm should run in O(n) time with O(1) extra space. * The list `nums` has a length of n where `0 <= n <= 2 * 10^4`. # Examples Example 1: Input: nums = [2, 0, 2, 1, 1, 0] Output: nums = [0, 0, 1, 1, 2, 2] Example 2: Input: nums = [2, 0, 1] Output: nums = [0, 1, 2] Example 3: Input: nums = [0] Output: nums = [0] Example 4: Input: nums = [1] Output: nums = [1] # Additional Information Consider edge cases such as already sorted arrays, arrays with all identical elements, and empty arrays. Our goal is to ensure the implemented function addresses these scenarios effectively while maintaining the specified performance constraints.","solution":"def sort_colors(nums): Sorts the list nums in-place so that all 0\'s come first, followed by all 1\'s, and then all 2\'s. low, mid, high = 0, 0, len(nums) - 1 while mid <= high: if nums[mid] == 0: nums[low], nums[mid] = nums[mid], nums[low] low += 1 mid += 1 elif nums[mid] == 1: mid += 1 else: # nums[mid] == 2 nums[high], nums[mid] = nums[mid], nums[high] high -= 1"},{"question":"You are given an array of integers `arr` and need to efficiently support the following operations: 1. **Range Sum Query**: Get the cumulative sum of elements up to a given index `i`. 2. **Update Operation**: Update the value of a specified element of the array `arr[i]` to a new value `x`. Your task is to implement these operations using a Fenwick Tree / Binary Indexed Tree. You need to provide the following functions: 1. **`__init__(self, arr)`**: - Initialize the Fenwick Tree with the given array. 2. **`get_sum(self, i)`:** - Return the sum of the array elements up to index `i`. 3. **`update(self, i, x)`:** - Update the value at index `i` to `x`. 4. **`construct(self)`:** - Construct the Fenwick Tree based on the initial array. # Input and Output Formats **Constructor Input**: - `arr`: A list of integers representing the array. Constraints: (1 leq text{len(arr)} leq 10^5), (-10^4 leq arr[i] leq 10^4). **Function Signatures**: - `__init__(self, arr)`: No return value. - `get_sum(self, i) -> int`: Returns an integer representing the cumulative sum up to index `i`. - `update(self, i, x)`: No return value. - `construct(self)`: No return value (constructs the tree internally). # Example ```python # Initialize the Fenwick Tree with the array [1, 2, 3, 4, 5] ft = Fenwick_Tree([1, 2, 3, 4, 5]) ft.construct() # Get the sum of the first 3 elements print(ft.get_sum(2)) # Output should be 6 (1+2+3) # Update the value at index 3 to 6 ft.update(3, 6) # Get the new sum of the first 3 elements print(ft.get_sum(3)) # Output should be 12 (1+2+3+6) ``` # Constraints - Ensure your solution handles edge cases, such as: - Queries and updates on the first element. - Queries and updates on the last element. - Values being zero or negative. - Performance requirements: - All operations (queries and updates) must run in O(log n) time. - Initial construction must run in O(n log n) time.","solution":"class FenwickTree: def __init__(self, arr): Initialize the Fenwick Tree with the given array. self.n = len(arr) self.arr = arr self.tree = [0] * (self.n + 1) self.construct() def construct(self): Construct the Fenwick Tree based on the initial array. for i in range(self.n): self.update_tree(i + 1, self.arr[i]) def update_tree(self, i, delta): Update the Fenwick Tree with the delta at the given 1-based index. while i <= self.n: self.tree[i] += delta i += i & -i def get_sum(self, i): Return the sum of the array elements up to index i. Accepts 0-based index and converts it to a 1-based index. i += 1 summation = 0 while i > 0: summation += self.tree[i] i -= i & -i return summation def update(self, i, x): Update the value at index i to x. delta = x - self.arr[i] self.arr[i] = x self.update_tree(i + 1, delta)"},{"question":"# Question Title: Efficient Square Root Calculation with Custom Precision # Problem Statement You are to implement a function that computes the square root of a positive integer using a numerical approximation method, specifically Newton’s Method. The function should be able to return a value with a specified maximum error. Your task is to write a function that performs this calculation efficiently. # Function Signature ```python def square_root(n: int, epsilon: float = 0.001) -> float: pass ``` # Input - `n`: An integer (1 ≤ n ≤ 10^9), the number for which the square root must be computed. - `epsilon`: A float (0 < epsilon ≤ 1), the allowed maximum absolute error. # Output - A float which is the approximate square root of `n` within an absolute error of `epsilon`. # Constraints - You must use Newton’s Method for the approximation. - Your solution should handle edge cases such as when `n` is 1 or very large numbers efficiently. # Examples 1. Input: `n = 5`, `epsilon = 0.001` Output: A float `x` such that `2.235 < x < 2.237` (since actual square root is approximately 2.236). 2. Input: `n = 9`, `epsilon = 0.0001` Output: A float `x` such that `2.9999 < x < 3.0001` (since actual square root is 3). # Notes - Consider performance and edge cases in your solution. - You may assume that `epsilon` will not be zero. # Requirements - Your function must have a time complexity of O(log(N)) and a space complexity of O(1).","solution":"def square_root(n: int, epsilon: float = 0.001) -> float: Computes the square root of a given number using Newton\'s method with specified precision. Parameters: n (int): The number to find the square root of (1 ≤ n ≤ 10^9). epsilon (float): The allowed maximum absolute error (0 < epsilon ≤ 1). Returns: float: The approximate square root of n within an absolute error of epsilon. if n == 1: return 1.0 x = n while True: root = 0.5 * (x + (n / x)) if abs(root - x) < epsilon: break x = root return root"},{"question":"# Cycle Sort Implementation Cycle Sort is an efficient sorting algorithm that is particularly useful when we wish to minimize memory writes. Given that it is in-place and does not use extra memory, it can be extremely valuable in memory-constrained environments. Task You are required to implement the cycle sort algorithm in Python. Your implementation should follow the below signature: ```python def cycle_sort(arr): Sorts an array using the cycle sort algorithm. Parameters: arr (list): List of integers to be sorted. Returns: list: Sorted version of the input list. # your code here ``` Input and Output * **Input**: A list of integers `arr` where `1 <= len(arr) <= 10^2` and each integer `-10^4 <= arr[i] <= 10^4`. * **Output**: A list of integers `arr` sorted in non-decreasing order. Constraints * Your algorithm should be in-place, i.e., it should have O(1) extra space complexity. * You are not allowed to use built-in sorting functions. * The performance requirement is focused on being both correct and meeting the specified time complexity. Example ```python # Example 1 input: [4, 3, 2, 1] output: [1, 2, 3, 4] # Example 2 input: [1, 3, 2, 1, 4, 2] output: [1, 1, 2, 2, 3, 4] # Example 3 input: [] output: [] ``` Scenario Imagine you are working on a project involving sorting large datasets but working within a constrained memory environment. Using Cycle Sort can significantly optimize memory usage in such situations.","solution":"def cycle_sort(arr): Sorts an array using the cycle sort algorithm. Parameters: arr (list): List of integers to be sorted. Returns: list: Sorted version of the input list. n = len(arr) # Traverse the array elements and place them to the correct position for cycle_start in range(0, n - 1): item = arr[cycle_start] # Find the position where we put the element pos = cycle_start for i in range(cycle_start + 1, n): if arr[i] < item: pos += 1 # If the item is already in the correct position if pos == cycle_start: continue # Skip duplicate elements while item == arr[pos]: pos += 1 # Put the item to its correct position arr[pos], item = item, arr[pos] # Rotate the rest of the cycle while pos != cycle_start: pos = cycle_start for i in range(cycle_start + 1, n): if arr[i] < item: pos += 1 while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] return arr"},{"question":"# Question: Duplicate Removal in a Singly Linked List Given a singly linked list, write two different functions to remove duplicate values from the list. The first function should use additional memory to achieve a linear time complexity, and the second function should avoid using extra memory and achieve this in quadratic time complexity. Function Specifications **Function 1: remove_dups** * **Input**: A linked list head node. * **Output**: The head of the modified linked list with duplicates removed. * **Constraints**: * Utilize extra space. * Time complexity should be (O(N)). **Function 2: remove_dups_without_set** * **Input**: A linked list head node. * **Output**: The head of the modified linked list with duplicates removed. * **Constraints**: * Do not use extra space. * Time complexity should be (O(N^2)). Implementation Details * Implement a helper class `Node` to create list nodes with attributes `val` and `next`. * Implement a helper function `print_linked_list` to print the linked list in a readable format. Example ```python class Node: def __init__(self, val=None): self.val = val self.next = None def remove_dups(head): # Implement this method def remove_dups_without_set(head): # Implement this method def print_linked_list(head): string = \\"\\" while head.next: string += head.val + \\" -> \\" head = head.next string += head.val print(string) # Example a1 = Node(\\"A\\") a2 = Node(\\"A\\") b = Node(\\"B\\") c1 = Node(\\"C\\") d = Node(\\"D\\") c2 = Node(\\"C\\") f = Node(\\"F\\") g = Node(\\"G\\") a1.next = a2 a2.next = b b.next = c1 c1.next = d d.next = c2 c2.next = f f.next = g remove_dups(a1) print_linked_list(a1) remove_dups_without_set(a1) print_linked_list(a1) ``` Use this example to test your implementations.","solution":"class Node: def __init__(self, val=None): self.val = val self.next = None def remove_dups(head): Removes duplicates from the linked list using additional memory (set). Time complexity: O(N) Space complexity: O(N) if not head: return head current = head seen_values = set() seen_values.add(current.val) while current.next: if current.next.val in seen_values: current.next = current.next.next else: seen_values.add(current.next.val) current = current.next return head def remove_dups_without_set(head): Removes duplicates from the linked list without using additional memory. Time complexity: O(N^2) Space complexity: O(1) if not head: return head current = head while current: runner = current while runner.next: if runner.next.val == current.val: runner.next = runner.next.next else: runner = runner.next current = current.next return head"},{"question":"# Context Matrix Chain Multiplication is a classic problem in dynamic programming with applications in optimizing the cost of multiplying multiple matrices. Given a sequence of matrices, the order in which pairs of matrices are multiplied greatly affects the number of operations needed. # Task You are tasked with writing a function `optimal_matrix_chain_multiplication(p)` that computes the minimum number of scalar multiplications needed to multiply matrices A1, A2, ..., An where the dimensions of the matrices are given in array `p` such that the dimensions of matrix Ai are `p[i-1]` by `p[i]`. # Function Signature: ```python def optimal_matrix_chain_multiplication(p: List[int]) -> Tuple[int, List[List[int]]]: pass ``` # Inputs: * `p`: A list of integers of length `n+1`, where `n` is the number of matrices. Each consecutive pair `(p[i-1], p[i])` represents the dimensions of a matrix Ai. # Outputs: * Returns a tuple: * The minimum number of scalar multiplications needed. * Optimal solution matrix, a 2D list of integers indicating the optimal split points. # Constraints: * 2 ≤ len(p) ≤ 100 * 1 ≤ p[i] ≤ 1000 # Example: ```python p = [30, 35, 15, 5, 10, 20, 25] ops, solution = optimal_matrix_chain_multiplication(p) print(ops) # Output: 15125 print(solution) # Output: [ # [0, 0, 0, 0, 0, 0, 0], # [0, 0, 15750, 7875, 9375, 11875, 15125], # [0, 0, 0, 2625, 4375, 7125, 10500], # [0, 0, 0, 0, 750, 2500, 5375], # [0, 0, 0, 0, 0, 1000, 3500], # [0, 0, 0, 0, 0, 0, 5000]] # ] def optimal_matrix_chain_multiplication(p: List[int]) -> Tuple[int, List[List[int]]]: # Implement your solution here. pass ``` # Note: * You can leverage the given `matrix_chain_order` function as a guideline, but your implementation should not directly use it. * Ensure your solution handles edge cases and optimally uses space and time complexity.","solution":"from typing import List, Tuple def optimal_matrix_chain_multiplication(p: List[int]) -> Tuple[int, List[List[int]]]: n = len(p) - 1 m = [[0] * (n + 1) for _ in range(n + 1)] s = [[0] * (n + 1) for _ in range(n + 1)] for l in range(2, n + 1): for i in range(1, n - l + 2): j = i + l - 1 m[i][j] = float(\'inf\') for k in range(i, j): q = m[i][k] + m[k + 1][j] + p[i - 1] * p[k] * p[j] if q < m[i][j]: m[i][j] = q s[i][j] = k return m[1][n], m"},{"question":"# Objective Design a function to find the skyline of a set of buildings represented by their dimensions (left, right, height). The function needs to efficiently compute the contour formed by these buildings from a side view. # Function Signature ```python def find_skyline(buildings: List[List[int]]) -> List[List[int]]: pass ``` # Inputs - `buildings`: A list of lists `List[List[int]]` where each sublist contains three integers `[Li, Ri, Hi]`. - `Li` is the x-coordinate of the left edge of the `i-th` building. - `Ri` is the x-coordinate of the right edge of the `i-th` building. - `Hi` is the height of the `i-th` building. - Constraints: `0 ≤ Li, Ri ≤ INT_MAX`, `0 < Hi ≤ INT_MAX`, and `Ri - Li > 0`. # Outputs - A list of lists `List[List[int]]`, where each sublist contains two integers `[x, y]`. - `x` is the x-coordinate of a key point where the skyline height changes. - `y` is the height of the skyline at that x-coordinate. # Example ```python buildings = [[2, 9, 10], [3, 7, 15], [5, 12, 12], [15, 20, 10], [19, 24, 8]] result = find_skyline(buildings) # Expected: [[2, 10], [3, 15], [7, 12], [12, 0], [15, 10], [20, 8], [24, 0]] ``` # Constraints - The number of buildings is between 0 and 10000. - The input list is sorted in ascending order by the left x position `Li`. - There must be no consecutive horizontal lines of equal height in the output. # Guidelines * Implement the central idea of sorting building positions and using a priority queue (max-heap) to track the live buildings. * Ensure efficient time and space complexity. * Handle edge cases, such as overlapping buildings and nested structures.","solution":"import heapq from typing import List def find_skyline(buildings: List[List[int]]) -> List[List[int]]: Function to compute the skyline formed by a set of buildings. Args: buildings (List[List[int]]): A list of buildings represented as [Li, Ri, Hi]. Returns: List[List[int]]: A list of key points representing the skyline. # Edge case: if no buildings, return an empty list if not buildings: return [] # Initialize the events list events = [] for L, R, H in buildings: events.append((L, -H, R)) # Building starts events.append((R, 0, 0)) # Building ends # Sort the events based on the x-coordinate, break ties using height events.sort() # Initialize the result and the heap result = [[0, 0]] heap = [(0, float(\\"inf\\"))] # (-height, end) # Process the events for x, negH, R in events: while heap[0][1] <= x: heapq.heappop(heap) if negH: heapq.heappush(heap, (negH, R)) if result[-1][1] != -heap[0][0]: result.append([x, -heap[0][0]]) # Remove the initial default point [0, 0] return result[1:]"},{"question":"# Advanced Coding Question: Implementing Ternary Search on a Sorted Unknown-sized Array Scenario A software engineer needs to find a target element within a large, sorted array. Due to memory constraints, the array is stored externally, and its size is unknown up front. This necessitates an efficient search algorithm that minimizes the number of accesses to this external storage. You are tasked with developing a function that uses the ternary search algorithm to find the target element while handling the issue of unknown array size. Task Write a function **ternary_search_unknown_size** that takes a sorted array (or a structure representing it) and a target element, and returns the index of the target element if present, or -1 if the target is not found. The function should handle the array as if its size is unknown (like an external file or a stream). # Function Signature ```python def ternary_search_unknown_size(is_less_than, get_element, key): Parameters: - is_less_than: function that takes an index and returns whether the index is less than the size of the array. - get_element: function that takes an index and returns the element at that index in the array. - key: the target element to find. Returns: - int: The index of the target element if found, otherwise -1. pass ``` # Constraints and Limitations 1. You are provided: - `is_less_than(index)`: A function that returns true if the index is within bounds of the array. - `get_element(index)`: A function that returns the element at the given index. 2. If `is_less_than(index)` returns false for the first index (implying an empty array), return -1. 3. Optimize the function to minimize the number of calls to both `is_less_than` and `get_element`. 4. The time complexity should remain O(log₃(N)) relative to the position of the target element, and space complexity should be O(1). # Example Assume the following helper functions are given: ```python def is_less_than_example(index): array = [1, 3, 4, 6, 8, 9, 11] return index < len(array) def get_element_example(index): array = [1, 3, 4, 6, 8, 9, 11] return array[index] ``` Calling `ternary_search_unknown_size` ```python index = ternary_search_unknown_size(is_less_than_example, get_element_example, 6) print(index) # Output: 3, since 6 is at index 3 in the array ``` If the element is not found, return -1.","solution":"def ternary_search_unknown_size(is_less_than, get_element, key): def find_boundaries(): index = 1 while is_less_than(index): index *= 2 return index def ternary_search(left, right): while left <= right: mid1 = left + (right - left) // 3 mid2 = right - (right - left) // 3 mid1_element = get_element(mid1) if is_less_than(mid1) else None mid2_element = get_element(mid2) if is_less_than(mid2) else None if mid1_element == key: return mid1 if mid2_element == key: return mid2 if mid1_element is not None and key < mid1_element: right = mid1 - 1 elif mid2_element is not None and key > mid2_element: left = mid2 + 1 else: left = mid1 + 1 right = mid2 - 1 return -1 if not is_less_than(0): return -1 right_boundary = find_boundaries() return ternary_search(0, right_boundary)"},{"question":"# Question: Generate All Possible Subsets of a Set Write a function `generate_subsets` that takes a list of distinct integers and returns all possible subsets (the power set) of the given list as a set of tuples. Function Signature ```python def generate_subsets(nums: List[int]) -> Set[Tuple[int]]: ``` Input * `nums` (List[int]): A list of distinct integers, where 0 <= len(nums) <= 20. Output * `Set[Tuple[int]]`: A set of tuples, where each tuple represents a subset of the input list. Constraints * The solution set must not contain duplicate subsets. * The order of elements within the subsets does not matter. * The input list may contain integers both positive and negative. Performance Requirements * The solution should handle the largest possible input size within a reasonable time limit. Example ```python # Example 1: nums = [1, 2, 3] # Expected Output: { # (1,), (1, 2), (1, 3), (2,), (2, 3), (1, 2, 3), (3,), () # } # Example 2: nums = [4, -1, 0] # Expected Output: { # (4,), (4, 0), (-1,), (4, -1), (0,), (-1, 0), (4, -1, 0), () # } ``` # Constraints * You must use an iterative approach utilizing bitwise operations to solve this problem. * You may assume that the input list contains at most 20 elements. Note You should not use any built-in library functions or itertools to generate the subsets.","solution":"from typing import List, Set, Tuple def generate_subsets(nums: List[int]) -> Set[Tuple[int]]: Return a set of all possible subsets of the given list of distinct integers. Each subset is represented as a tuple. subsets = set() n = len(nums) # Loop through all numbers from 0 to 2^n (exclusive) # Each number represents a subset (using bitmask) for i in range(2**n): subset = [] for j in range(n): # Check if the j-th bit is set in the integer i if i & (1 << j): subset.append(nums[j]) subsets.add(tuple(subset)) return subsets"},{"question":"# Grouped Character Formatter Background You have been tasked to design a formatter for alphanumeric strings, particularly useful in scenarios like formatting license keys where groups of characters need specific delimiters inserted at regular intervals. Problem Statement Write a function `grouped_formatter(input_str, k)` that takes a string `input_str` of alphanumeric characters and existing delimiters (`-`), and re-formats it by grouping the alphanumeric characters into chunks of size `k`, inserting the delimiter `-` between each group. Extra delimiters and other non-alphanumeric characters are omitted in the process. Function Signature ```python def grouped_formatter(input_str: str, k: int) -> str: ``` Input - `input_str` (str): A string consisting of alphanumeric characters and delimiters (\'-\'). - `k` (int): A positive integer indicating the size of each group. Output - Returns a formatted string with characters grouped in chunks of size `k`, separated by the delimiter `-`. Example ```python assert grouped_formatter(\\"2-5g-3-J\\", 2) == \\"2-5G-3J\\" assert grouped_formatter(\\"2-4A0r7-4k\\", 3) == \\"24-A0R-74K\\" ``` Constraints - Assume `1 <= k <= len(input_str)`. - The input string may include only alphanumeric characters and `-`. Additional Notes - The function should be case-insensitive, meaning it should return the result in uppercase. - Ensure the performance is efficient for large input strings.","solution":"def grouped_formatter(input_str, k): Re-formats the input_str by grouping alphanumeric characters into chunks of size k, inserting the delimiter \'-\' between each group. The result is returned in uppercase. Parameters: input_str (str): The input alphanumeric string that may contain delimiters (\'-\') k (int): The group size for formatting Returns: str: The formatted string # Remove existing delimiters and convert to uppercase cleaned_str = \'\'.join(c.upper() for c in input_str if c.isalnum()) # Group characters in chunks of size k grouped_result = \'-\'.join(cleaned_str[i:i+k] for i in range(0, len(cleaned_str), k)) return grouped_result"},{"question":"# Coding Challenge Problem Statement You are tasked with writing a function that calculates the number of ways an integer can be decomposed into sums of non-negative integers. Function Signature ```python def int_divide(decompose: int) -> int: ``` Input - `decompose`: A positive integer `n` (1 ≤ n ≤ 10^3). Output - Returns an integer representing the number of ways `decompose` can be split into sums of non-negative integers. Constraints - The algorithm should efficiently handle the input within the provided constraint. - You may assume that the input will always be a valid positive integer. Example 1. Input: `4` - Output: `5` - Explanation: ``` 4 = 4 4 = 3 + 1 4 = 2 + 2 4 = 2 + 1 + 1 4 = 1 + 1 + 1 + 1 ``` 2. Input: `7` - Output: `15` - Explanation: ``` 7 = 7 7 = 6 + 1 7 = 5 + 2 7 = 5 + 1 + 1 7 = 4 + 3 7 = 4 + 2 + 1 7 = 4 + 1 + 1 + 1 7 = 3 + 3 + 1 7 = 3 + 2 + 2 7 = 3 + 2 + 1 + 1 7 = 3 + 1 + 1 + 1 + 1 7 = 2 + 2 + 2 + 1 7 = 2 + 2 + 1 + 1 + 1 7 = 2 + 1 + 1 + 1 + 1 + 1 7 = 1 + 1 + 1 + 1 + 1 + 1 + 1 ``` Implement the function `int_divide` to solve this problem.","solution":"def int_divide(decompose: int) -> int: Calculate the number of ways an integer can be decomposed into sums of non-negative integers. :param decompose: int - The integer to decompose. :return: int - The number of ways to decompose the integer. # dp array to store the number of ways to decompose each integer from 0 to \'decompose\' dp = [1] + [0] * decompose for i in range(1, decompose + 1): for j in range(i, decompose + 1): dp[j] += dp[j - i] # The result is the number of ways to decompose the integer \'decompose\' return dp[decompose]"},{"question":"# Question **Scenario**: You are working on a microcontroller-based project where memory and processing power are constrained. You have various sensors and actuators connected to your microcontroller, and their states need to be efficiently managed using a control register (an integer value). Each bit in the control register represents the state (on or off) of a particular sensor or actuator. **Task**: Implement a `ControlRegister` class to manage a 32-bit control register using bit manipulation. The class should provide methods to set, clear, get, and update the state of individual bits. # Requirements: 1. **Method `get_state(self, index: int) -> int:`** - Input: `index` (0-based) indicating which bit to retrieve. - Output: `1` if the bit at `index` is set, otherwise `0`. 2. **Method `turn_on(self, index: int):` - Input: `index` (0-based) indicating which bit to set to 1. - Output: None (Modifies the control register). 3. **Method `turn_off(self, index: int):` - Input: `index` (0-based) indicating which bit to set to 0. - Output: None (Modifies the control register). 4. **Method `update_state(self, index: int, state: int):` - Input: - `index` (0-based) indicating which bit to update. - `state` (1 or 0) indicating the new state of the bit. - Output: None (Modifies the control register). 5. **Initialization:** - The register should be initialized to 0. # Constraints: - `index` will always be in the range `[0, 31]`. - `state` will always be either `0` or `1`. # Example Usage: ```python reg = ControlRegister() # Initially all bits should be off assert reg.get_state(0) == 0 # Turning on bit 3 reg.turn_on(3) assert reg.get_state(3) == 1 # Turning off bit 3 reg.turn_off(3) assert reg.get_state(3) == 0 # Updating state of bit 2 to 1 reg.update_state(2, 1) assert reg.get_state(2) == 1 # Updating state of bit 2 to 0 reg.update_state(2, 0) assert reg.get_state(2) == 0 ```","solution":"class ControlRegister: def __init__(self): # Initialize 32-bit control register to 0 self.register = 0 def get_state(self, index: int) -> int: # Return the state of the bit at the given index return (self.register >> index) & 1 def turn_on(self, index: int): # Set the bit at the given index to 1 self.register |= (1 << index) def turn_off(self, index: int): # Set the bit at the given index to 0 self.register &= ~(1 << index) def update_state(self, index: int, state: int): if state: self.turn_on(index) else: self.turn_off(index)"},{"question":"# Graph Shortest Path Challenge **Context**: You are helping a small town\'s local government to improve their road network management system. Currently, they have detailed data about the distances between important locations in their town, but they need to optimize the routing system for emergency services. **Objective**: Implement Dijkstra\'s algorithm to find the shortest path from a given starting point to all other locations within the town. Your task is to return the shortest distances from the start location to every other location in the town. # Function Signature ```python def find_shortest_paths(vertex_count: int, edges: List[Tuple[int, int, int]], start: int) -> List[int]: pass ``` # Input 1. **vertex_count** (int): The number of locations (vertices). 2. **edges** (List[Tuple[int, int, int]]): A list of tuples (u, v, w) representing an edge from location u to location v with distance w. 3. **start** (int): The starting location (vertex). # Output - **distances** (List[int]): A list where the ith element represents the shortest distance from the start location to the ith location. If a location is unreachable, return float(\'inf\') for that location. # Constraints 1. All distances are non-negative integers. 2. The total number of edges is at most vertex_count^2. 3. 1 <= vertex_count <= 1000 4. The maximum distance between any two locations <= 10^6 # Example ```python print(find_shortest_paths(5, [(0, 1, 10), (0, 3, 5), (1, 2, 1), (2, 4, 2), (3, 1, 2), (3, 2, 9), (3, 4, 2)], 0)) # Output: [0, 7, 8, 5, 7] ``` - **Explanation**: The function finds the shortest path from vertex 0 to all other vertices. Your Task - Implement the function `find_shortest_paths` that computes the shortest path distances from the starting vertex to all other vertices using Dijkstra\'s algorithm.","solution":"from typing import List, Tuple import heapq def find_shortest_paths(vertex_count: int, edges: List[Tuple[int, int, int]], start: int) -> List[int]: graph = [[] for _ in range(vertex_count)] for u, v, w in edges: graph[u].append((v, w)) distances = [float(\'inf\')] * vertex_count distances[start] = 0 min_heap = [(0, start)] while min_heap: current_distance, current_vertex = heapq.heappop(min_heap) if current_distance > distances[current_vertex]: continue for neighbor, weight in graph[current_vertex]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(min_heap, (distance, neighbor)) return distances"},{"question":"Given an array, write a Python function that removes all duplicates from the array and returns a new array containing only unique elements. The order of the elements in the new array should be the same as their first occurrence in the original array. # Input Format - A list `array` of elements which can be of any data type (integer, string, boolean, etc.) # Output Format - A list containing unique elements from the input list, in the order of their first appearance. # Constraints - The input list can contain up to 10^6 elements. - The elements in the list can be of mixed types and are comparable using equality (`==`). # Performance Requirements - The solution should be optimized to handle large input sizes efficiently. # Example Input ```python [1, 1 ,1 ,2 ,2 ,3 ,4 ,4 ,\\"hey\\", \\"hey\\", \\"hello\\", True, True] ``` Output ```python [1, 2, 3, 4, \'hey\', \'hello\'] ``` **Function Signature**: ```python def remove_duplicates(array: list) -> list: # Your code here ``` # Hints - Consider using a set to track elements that have already been added to the new list to reduce time complexity.","solution":"def remove_duplicates(array): Removes duplicates from the array and returns a new array containing only unique elements. The order of the elements in the new array is the same as their first occurrence in the original array. Parameters: - array: list of elements (can be of mixed data types) Returns: - A list containing unique elements from the input list, in the order of their first appearance. seen = set() unique_array = [] for item in array: if item not in seen: unique_array.append(item) seen.add(item) return unique_array"},{"question":"# Selection Sort Implementation with Edge Case Handling Background Selection Sort is a simple and intuitive comparison-based sorting algorithm. Despite its inefficiency on larger arrays, it remains a good example to understand basic sorting principles and operations. Problem Statement Write a function `selection_sort` that sorts an array of integers using the selection sort algorithm. Additionally, modify the function to handle some edge cases and include functionality to simulate the sorting process by printing the intermediate states of the array after each iteration. # Function Signature ```python def selection_sort(arr: list, simulation: bool=False) -> list: Sorts an array using Selection Sort algorithm. Parameters: arr (list): list of integers to sort simulation (bool): optional; if True, print the array after each iteration (default is False) Returns: list: sorted list of integers ``` # Input - A list of integers `arr` - An optional boolean parameter `simulation` # Output - Returns the sorted list of integers. # Constraints - The input list `arr` should contain integers and can be empty. - Running the function with an already sorted list should process correctly without errors. - Simulation should be printed in the format: `iteration <iteration_number>: <current_state_of_array>` # Edge Cases - An empty array should return an empty array. - An array with a single element should return the array itself. - Arrays that are already sorted or in reverse order should be sorted correctly. # Example Usage ```python print(selection_sort([64, 25, 12, 22, 11], True)) # Output should show intermediate steps: # iteration 0: 11 25 12 22 64 # iteration 1: 11 12 25 22 64 # iteration 2: 11 12 22 25 64 # iteration 3: 11 12 22 25 64 # iteration 4: 11 12 22 25 64 print(selection_sort([3, 1, 2])) # Output: [1, 2, 3] print(selection_sort([])) # Output: [] print(selection_sort([10])) # Output: [10] ```","solution":"def selection_sort(arr: list, simulation: bool=False) -> list: Sorts an array using Selection Sort algorithm. Parameters: arr (list): list of integers to sort simulation (bool): optional; if True, print the array after each iteration (default is False) Returns: list: sorted list of integers n = len(arr) for i in range(n): min_idx = i for j in range(i+1, n): if arr[j] < arr[min_idx]: min_idx = j arr[i], arr[min_idx] = arr[min_idx], arr[i] if simulation: print(f\\"iteration {i}: {\' \'.join(map(str, arr))}\\") return arr"},{"question":"You are given a modified min heap class implemented in Python. Mimic the general functionality but add two new features: (1) the ability to build a heap from an unsorted array, and (2) a method to return the k smallest elements as a heap. Requirements: 1. Implement a `build_heap(self, array)` method that transforms an unsorted array into a min heap efficiently. 2. Implement a `k_smallest_elements(self, k)` method that returns the k smallest elements in the heap while maintaining the heap properties. Function Signature: ```python class BinaryHeap: def build_heap(self, array: List[int]) -> None: # Your code here def k_smallest_elements(self, k: int) -> List[int]: # Your code here ``` Input and Output Formats - **Input**: - `build_heap(array: List[int])` where `array` is a list of integers. - `k_smallest_elements(k: int)` where `k` is an integer specifying the number of smallest elements to return. - **Output**: - `build_heap` should modify the internal heap state of the object. - `k_smallest_elements` should return a list containing the k smallest elements. Constraints: - The heap operations should work efficiently with a large number of elements (up to 100,000). - `k` will always be less than or equal to the number of elements in the heap. - Values in the heap will be unique for this question\'s context. Example Usage: ```python # Create an instance of the BinaryHeap heap = BinaryHeap() # Build the heap from an unsorted array heap.build_heap([10, 20, 30, 5, 6, 7, 8, 3]) # Retrieve the 3 smallest elements result = heap.k_smallest_elements(3) # Output: [3, 5, 6] ```","solution":"import heapq class BinaryHeap: def __init__(self): self.heap = [] def build_heap(self, array): Builds a heap from the given unsorted array. self.heap = array[:] heapq.heapify(self.heap) def k_smallest_elements(self, k): Returns a list of the k smallest elements from the heap. return heapq.nsmallest(k, self.heap)"},{"question":"# Question Context You have observed the behavior of Bogo Sort and understood its working principle and performance pitfalls. Now, let\'s work on an enhanced version of a sorting function that avoids the inefficiencies of Bogo Sort. Task Write a function named `enhanced_sort` that sorts an array of integers. To make this task more meaningful, let\'s consider using the Quicksort algorithm: # Function Signature ```python def enhanced_sort(arr: List[int]) -> List[int]: pass ``` # Input * `arr`: A list of integers, where 1 <= len(arr) <= 10^5. # Output * Returns a new sorted list of integers. Constraints * The function should efficiently handle the average case of sorting. * Utilize the Quicksort algorithm for sorting, avoiding the inefficiencies of Bogo Sort. * Implement error handling for empty or single-element lists (trivial cases). Example ```python >>> arr = [3, 6, 8, 10, 1, 2, 1] >>> print(enhanced_sort(arr)) [1, 1, 2, 3, 6, 8, 10] ``` ```python >>> arr = [1] >>> print(enhanced_sort(arr)) [1] ``` ```python >>> arr = [3, -2, 5, 0] >>> print(enhanced_sort(arr)) [-2, 0, 3, 5] ```","solution":"from typing import List def enhanced_sort(arr: List[int]) -> List[int]: Sorts a list of integers using the Quicksort algorithm. if len(arr) <= 1: return arr pivot = arr[len(arr) // 2] left = [x for x in arr if x < pivot] middle = [x for x in arr if x == pivot] right = [x for x in arr if x > pivot] return enhanced_sort(left) + middle + enhanced_sort(right)"},{"question":"# Simplify Unix-Style File Path You are given an absolute path for a file (Unix-style), and you need to simplify it. Write a function `simplify_path` that takes a string path and returns the simplified canonical path. # Objective The function should handle the following scenarios: 1. Consecutive slashes are treated as a single slash, e.g., `\\"/home//foo/\\"` should simplify to `\\"/home/foo\\"`. 2. References to the current directory (`\\".\\"`) should not affect the path. 3. References to the parent directory (`\\"..\\"`) should move one level up, unless it\'s at the root, in which case it remains the root. 4. Leading and trailing slashes should be maintained, but the resulting path should not end with a slash unless it is the root. # Constraints - The path string is a non-empty string with a length of at most `3000`. - The path will always begin with a \'/\' (indicating it\'s an absolute path). # Input - A string `path` representing the Unix-style absolute file path. # Output - A string representing the simplified canonical path. # Example ```plaintext Input: \\"/home/\\" Output: \\"/home\\" Input: \\"/a/./b/../../c/\\" Output: \\"/c\\" Input: \\"/../\\" Output: \\"/\\" Input: \\"/home//foo/\\" Output: \\"/home/foo\\" Input: \\"/a/b/c/../../d/e/./..\\" Output: \\"/a/d\\" ```","solution":"def simplify_path(path): Simplifies a given Unix-style absolute file path. stack = [] components = path.split(\'/\') for component in components: if component == \\"\\" or component == \\".\\": continue elif component == \\"..\\": if stack: stack.pop() else: stack.append(component) return \\"/\\" + \\"/\\".join(stack)"},{"question":"Enhanced Run-Length Encoding Implementation You have been provided with a code snippet implementing the run-length encoding (RLE) and decoding algorithm. You are required to: 1. **Enhance** the current `encode_rle` function to handle edge cases more effectively. 2. **Optimize** the `encode_rle` function for better efficiency, particularly in terms of string manipulation. 3. **Write** new test cases to thoroughly assess the functionality of both the encoding and decoding functions. # Detailed Requirements 1. **Enhanced Encoding Function**: - Modify the `encode_rle` function to handle an additional edge case where the input string is empty more gracefully and to efficiently manage string concatenations. - Input: A string `input` that needs to be encoded using RLE. - Output: The encoded string. - Constraints: - The input string will only contain alphanumeric characters. - The input can be empty or very large. 2. **New Test Cases**: - Write at least five new test cases for both `encode_rle` and `decode_rle` functions. - Ensure to cover common edge cases (e.g., empty string, single character strings, strings with no consecutive characters, etc.). # Implementation Below are the updated signatures for the encoding function and placeholders for new test cases. You should only complete the functions marked with ` TODO` comments: ```python def encode_rle(input): Gets a stream of data and compresses it under a Run-Length Encoding. :param input: The data to be encoded. :return: The encoded string. TODO: Implement the enhancements and optimizations. pass def decode_rle(input): Gets a stream of data and decompresses it under a Run-Length Decoding. :param input: The data to be decoded. :return: The decoded string. Provided as-is; no changes required # Test cases def test_encode_rle(): # Example placeholders for test cases - provide 5 test cases TODO: Add test cases assert encode_rle(\\"aaabbc\\") == \\"3a2b1c\\" assert encode_rle(\\"\\") == \\"\\" assert encode_rle(\\"a\\") == \\"1a\\" assert encode_rle(\\"abc\\") == \\"1a1b1c\\" assert encode_rle(\\"abcccccaaa\\") == \\"1a1b5c3a\\" print(\\"All test_encode_rle cases passed\\") def test_decode_rle(): # Example placeholders for test cases - provide 5 test cases TODO: Add test cases assert decode_rle(\\"3a2b1c\\") == \\"aaabbc\\" assert decode_rle(\\"\\") == \\"\\" assert decode_rle(\\"1a\\") == \\"a\\" assert decode_rle(\\"1a1b1c\\") == \\"abc\\" assert decode_rle(\\"5c3a\\") == \\"cccccaaa\\" print(\\"All test_decode_rle cases passed\\") # Run tests test_encode_rle() test_decode_rle() ```","solution":"def encode_rle(input): Gets a stream of data and compresses it under a Run-Length Encoding. :param input: The data to be encoded. :return: The encoded string. if not input: return \\"\\" encoded = [] count = 1 for i in range(1, len(input)): if input[i] == input[i - 1]: count += 1 else: encoded.append(f\\"{count}{input[i - 1]}\\") count = 1 encoded.append(f\\"{count}{input[-1]}\\") return \'\'.join(encoded) def decode_rle(input): Gets a stream of data and decompresses it under a Run-Length Decoding. :param input: The data to be decoded. :return: The decoded string. if not input: return \\"\\" decoded = [] count = 0 for char in input: if char.isdigit(): count = count * 10 + int(char) else: decoded.append(char * count) count = 0 return \'\'.join(decoded)"},{"question":"Ordered Stack with Enhanced Operation Context You have an `OrderedStack` class that maintains elements in a sorted order such that the highest value is always at the top of the stack and the lowest value is at the bottom. You need to implement an additional feature to this class. Task Implement a method named `merge_sorted_stack` inside the `OrderedStack` class that takes another `OrderedStack` instance as input and merges it with the current stack while maintaining the sorted order. The merged result should be a single ordered stack without sorting explicitly. Input and Output * **Input**: `OrderedStack` instance to be merged (assume another stack object). * **Output**: The current stack merged with the input stack maintaining the sorted order. Constraints - Do not use any explicit sorting function. - Utilize the properties of the `OrderedStack` class to maintain order. Example ```python stack1 = OrderedStack() stack1.push(3) stack1.push(1) stack1.push(5) stack2 = OrderedStack() stack2.push(4) stack2.push(2) stack1.merge_sorted_stack(stack2) ``` After merging, the elements in `stack1` should maintain the order: `[1, 2, 3, 4, 5]`. Implementation Challenges - Handling cases when one stack is empty. - Merging stacks without explicit sorting while maintaining correct order. - Ensuring no auxiliary data structure or minimal extra space usage for merging. Implement the `merge_sorted_stack` method in the `OrderedStack` class provided above. ```python class OrderedStack: def __init__(self): self.items = [] def is_empty(self): return self.items == [] def push_t(self, item): self.items.append(item) # push method to maintain order when pushing new elements def push(self, item): temp_stack = OrderedStack() if self.is_empty() or item > self.peek(): self.push_t(item) else: while item < self.peek() and not self.is_empty(): temp_stack.push_t(self.pop()) self.push_t(item) while not temp_stack.is_empty(): self.push_t(temp_stack.pop()) def pop(self): if self.is_empty(): raise IndexError(\\"Stack is empty\\") return self.items.pop() def peek(self): return self.items[len(self.items) - 1] def size(self): return len(self.items) # Method to be implemented def merge_sorted_stack(self, other_stack): # Your code here ```","solution":"class OrderedStack: def __init__(self): self.items = [] def is_empty(self): return self.items == [] def push_t(self, item): self.items.append(item) def push(self, item): temp_stack = OrderedStack() if self.is_empty() or item > self.peek(): self.push_t(item) else: while not self.is_empty() and item < self.peek(): temp_stack.push_t(self.pop()) self.push_t(item) while not temp_stack.is_empty(): self.push_t(temp_stack.pop()) def pop(self): if self.is_empty(): raise IndexError(\\"Stack is empty\\") return self.items.pop() def peek(self): if self.is_empty(): raise IndexError(\\"Stack is empty\\") return self.items[-1] def size(self): return len(self.items) def merge_sorted_stack(self, other_stack): temp_stack = [] while not self.is_empty() and not other_stack.is_empty(): if self.peek() >= other_stack.peek(): temp_stack.append(self.pop()) else: temp_stack.append(other_stack.pop()) while not self.is_empty(): temp_stack.append(self.pop()) while not other_stack.is_empty(): temp_stack.append(other_stack.pop()) while temp_stack: self.push(temp_stack.pop())"},{"question":"Question: Implement a Secure Communication Protocol Using Modular Arithmetic You are working on designing a secure communication protocol that relies on modular arithmetic to encode and decode messages. An essential part of this protocol involves finding modular inverses to decrypt messages. # Task Your task is to implement two functions based on the extended Euclidean algorithm: 1. `extended_gcd(a, b)`: This function should return a tuple ((x, y, gcd(a, b))) where (x) and (y) satisfy the equation (ax + by = gcd(a, b)). 2. `modular_inverse(a, m)`: This function should return the modular inverse of (a) modulo (m), if (a) and (m) are coprime. # Function Specifications Function 1: `extended_gcd(a, b)` * **Input**: Two integers (a) and (b). - Constraints: (a) and (b) are non-zero integers. * **Output**: A tuple of three integers ((x, y, gcd(a, b))). - Description: (x) and (y) such that (ax + by = gcd(a, b)). Function 2: `modular_inverse(a, m)` * **Input**: Two integers (a) and (m). - Constraints: (a) and (m) must be coprime. * **Output**: An integer (x) such that ( (a cdot x) % m = 1 ). - Conditions: If (a) and (m) are not coprime, raise a `ValueError` with the message \\"a and m must be coprime\\". # Example ```python # Example for `extended_gcd` assert extended_gcd(30, 20) == (1, -1, 10) # Example for `modular_inverse` assert modular_inverse(3, 11) == 4 ``` # Notes 1. You must use the `extended_gcd` function in your `modular_inverse` implementation. 2. Ensure that the `extended_gcd` function correctly reduces the initial equation in each iteration to maintain accuracy for large integer inputs. # Constraints * (1 leq |a|, |b| leq 10^9) * (1 leq m leq 10^9) # Hints 1. Validate that (a) and (m) are coprime by checking if (gcd(a, m) = 1). 2. Use the extended Euclidean algorithm to find coefficients that help determine the modular inverse.","solution":"def extended_gcd(a, b): Returns a tuple (x, y, gcd(a, b)) where x and y satisfy the equation ax + by = gcd(a, b). if b == 0: return (1, 0, a) else: x1, y1, gcd = extended_gcd(b, a % b) x = y1 y = x1 - (a // b) * y1 return (x, y, gcd) def modular_inverse(a, m): Returns the modular inverse of a modulo m. If a and m are not coprime, raises a ValueError. x, y, gcd = extended_gcd(a, m) if gcd != 1: raise ValueError(\\"a and m must be coprime\\") return x % m"},{"question":"# Rotating an Array: Performance and Optimization Challenge You are provided three different methods to rotate an array `k` steps to the right. Your goal is to implement your own method that combines the efficiency of these methods to handle large arrays and arbitrary rotation steps optimally. Task Implement a function `optimal_rotate(array, k)` that rotates the input array `k` steps to the right efficiently. Input - `array`: A list of integers. It can be empty. - `k`: A non-negative integer representing the number of steps to rotate the array. Output - The function should return a new array which is the result of rotating the given array by `k` positions to the right. Constraints - The function should aim for a time complexity of (O(n)) and a space complexity of (O(1)), if possible, or provide a rationale for design choices if these constraints are not met. - `k` may be very large, so use appropriate optimizations (e.g., modulo operations). Examples ```python assert optimal_rotate([1, 2, 3, 4, 5, 6, 7], 3) == [5, 6, 7, 1, 2, 3, 4] assert optimal_rotate([1, 2, 3], 4) == [3, 1, 2] assert optimal_rotate([], 10) == [] assert optimal_rotate([1], 0) == [1] ``` Hints 1. Consider the properties of array slicing and reversal for performing rotations. 2. The number of actual rotations needed for a given `k` can be minimized using the modulo operation.","solution":"def optimal_rotate(array, k): Rotates the input array k steps to the right. :param array: List[int], the array to rotate :param k: int, the number of steps to rotate the array :return: List[int], the rotated array n = len(array) if n == 0: return array # Effective rotations needed k %= n # Rotation using array slicing return array[-k:] + array[:-k]"},{"question":"# Sparse Matrix Multiplication Scenario You are working on a scientific computing project that involves handling large datasets. Specifically, you need to handle operations involving large sparse matrices. Sparse matrices have a lot of zero elements and storing all zeroes explicitly is inefficient. You aim to write a function to multiply two sparse matrices efficiently. Task Write a function `sparse_matrix_multiply` that multiplies two sparse matrices `A` and `B`, and returns the result matrix `C`. Given that `A` and `B` are represented as lists of lists of integers. Function Signature ```python def sparse_matrix_multiply(A: List[List[int]], B: List[List[int]]) -> List[List[int]]: pass ``` Input - `A`: A list of lists where each sublist represents a row of matrix A. - Dimension: m x n - Constraints: 1 <= m, n <= 1000 - `B`: A list of lists where each sublist represents a row of matrix B. - Dimension: n x p - Constraints: 1 <= n, p <= 1000 Output - `C`: A list of lists where each sublist represents a row of the product matrix C (m x p). Constraints - You may assume that the number of columns in `A` is equal to the number of rows in `B`. Requirements - Time efficiency in handling sparse matrices by avoiding unnecessary zero multiplications. - Space efficiency by optimizing storage of non-zero elements only. Example ```python A = [ [ 1, 0, 0], [-1, 0, 3] ] B = [ [ 7, 0, 0 ], [ 0, 0, 0 ], [ 0, 0, 1 ] ] print(sparse_matrix_multiply(A, B)) # Output: # [ # [ 7, 0, 0 ], # [-7, 0, 3 ] # ] ``` Notes - Ensure to handle edge cases such as empty matrices and matrices full of zeroes. - Focus on optimizing the solution to handle large sparse matrices efficiently.","solution":"from typing import List def sparse_matrix_multiply(A: List[List[int]], B: List[List[int]]) -> List[List[int]]: Multiplies two sparse matrices A and B efficiently. Args: A: List[List[int]] - a matrix with dimensions m x n. B: List[List[int]] - a matrix with dimensions n x p. Returns: List[List[int]] - the product matrix C with dimensions m x p. if not A or not A[0] or not B or not B[0]: return [] m, n, p = len(A), len(A[0]), len(B[0]) # Initialize the result matrix with zeros C = [[0] * p for _ in range(m)] # Convert B into a form suitable for sparse matrix multiplication B_transpose = [[B[row][col] for row in range(len(B))] for col in range(len(B[0]))] for i in range(m): for k in range(n): if A[i][k] != 0: for j in range(p): if B[k][j] != 0: C[i][j] += A[i][k] * B[k][j] return C"},{"question":"# Problem Context Implement a custom data structure to manage transaction history in a banking application. Given the frequent need to add, delete, and access transactions, a Linked List is an ideal choice. You are required to implement a basic version of Doubly Linked List to store and manage transaction details. # Problem Statement Write a class, `DoublyLinkedList`, which implements common linked list functionalities with a focus on transaction records. Each transaction will have a unique ID and an amount. The linked list should support the following operations: 1. **Adding a Transaction**: Append a transaction to the end of the list. 2. **Removing a Transaction**: Remove a transaction by its unique ID. 3. **Retrieving a Transaction**: Retrieve details of a transaction by its unique ID. 4. **Display Transactions**: Print the list of transactions in the order they were added. # Input and Output Formats - The `add_transaction` method will receive two parameters: an integer `transaction_id` and a float `amount`. - The `remove_transaction` method will receive one parameter: an integer `transaction_id`. - The `retrieve_transaction` method will receive one parameter: an integer `transaction_id`, and should return a tuple `(transaction_id, amount)`. - The `display_transactions` method does not take any parameters and should print all transactions in the order they were added. # Constraints - Transaction IDs are unique. - A transaction ID provided for removal or retrieval is always valid (you do not need to handle cases where the transaction ID does not exist). # Example ```python # Example Usage dll = DoublyLinkedList() dll.add_transaction(1, 100.0) dll.add_transaction(2, 250.75) dll.add_transaction(3, 3030.5) dll.display_transactions() # Output: # 1: 100.0 # 2: 250.75 # 3: 3030.5 id, amount = dll.retrieve_transaction(2) print(id, amount) # Output: # 2 250.75 dll.remove_transaction(2) dll.display_transactions() # Output: # 1: 100.0 # 3: 3030.5 ``` # Class Outline ```python class DoublyLinkedListNode: def __init__(self, transaction_id, amount): self.transaction_id = transaction_id self.amount = amount self.next = None self.prev = None class DoublyLinkedList: def __init__(self): self.head = None self.tail = None def add_transaction(self, transaction_id, amount): # Implement this method def remove_transaction(self, transaction_id): # Implement this method def retrieve_transaction(self, transaction_id): # Implement this method def display_transactions(self): # Implement this method ```","solution":"class DoublyLinkedListNode: def __init__(self, transaction_id, amount): self.transaction_id = transaction_id self.amount = amount self.next = None self.prev = None class DoublyLinkedList: def __init__(self): self.head = None self.tail = None def add_transaction(self, transaction_id, amount): new_node = DoublyLinkedListNode(transaction_id, amount) if not self.head: self.head = self.tail = new_node else: self.tail.next = new_node new_node.prev = self.tail self.tail = new_node def remove_transaction(self, transaction_id): current = self.head while current: if current.transaction_id == transaction_id: if current.prev: current.prev.next = current.next if current.next: current.next.prev = current.prev if current == self.head: self.head = current.next if current == self.tail: self.tail = current.prev del current return current = current.next def retrieve_transaction(self, transaction_id): current = self.head while current: if current.transaction_id == transaction_id: return (current.transaction_id, current.amount) current = current.next def display_transactions(self): current = self.head while current: print(f\\"{current.transaction_id}: {current.amount}\\") current = current.next"},{"question":"# Context In combinatorial mathematics, the binomial coefficient C(n, k) is significant for determining the number of ways to choose k items from n items without considering the order of selection. This problem can be optimized and managed through recursion with symmetry properties. # Problem Statement Write a function `binomial_coefficient` that calculates the binomial coefficient C(n, k) efficiently using an iterative approach instead of recursion to optimize performance and handle larger inputs. # Input and Output Formats - **Input**: Two integers `n` and `k` (0 <= k <= n <= 1000). - **Output**: Returns the binomial coefficient C(n, k) as an integer. # Constraints 1. The function should handle edge cases appropriately, such as k = 0 or k = n. 2. Avoid recursion to prevent stack overflow for larger inputs. 3. Implement optimizations whenever possible to improve execution time and memory usage. # Performance Requirements - Aim to achieve a time complexity better than straightforward recursion. - Ensure the solution handles the upper limits of the given constraints efficiently. # Example ```python # Example 1 n = 5 k = 3 output = binomial_coefficient(n, k) print(output) # 10 # Example 2 n = 8 k = 2 output = binomial_coefficient(n, k) print(output) # 28 # Example 3 n = 10 k = 0 output = binomial_coefficient(n, k) print(output) # 1 ``` Implement the function `binomial_coefficient`: ```python def binomial_coefficient(n, k): # Your code here pass ```","solution":"def binomial_coefficient(n, k): Calculate the binomial coefficient C(n, k) using an iterative approach. if k > n - k: # Take advantage of the symmetry property k = n - k result = 1 for i in range(k): result = result * (n - i) // (i + 1) return result"},{"question":"**Scenario**: A puzzle master includes different types of magic number validations in their puzzles. Your task is to create a function that determines if a given number is a magic number, according to the specific rules where the number is considered magical if the repeated digit sum eventually equals 1. **Function to Implement**: ```python def is_magic_number(num: int) -> bool: This function checks whether the provided integer is a magic number. Args: num (int): The integer to check Returns: bool: True if num is a magic number, False otherwise. # Write your implementation here ``` **Input**: - **num**: an integer `n` (0 <= n <= 10^18) **Output**: - Return `True` if `num` is a magic number, otherwise return `False`. **Constraints**: - The number can be as large as 18 digits. - Ensure negative numbers or non-integers are not considered. - Aim for an efficient solution within linearithmic time. **Examples**: ```python assert is_magic_number(50113) == True # 5+0+1+1+3 = 10, 1+0 = 1 assert is_magic_number(1234) == True # 1+2+3+4 = 10, 1+0 = 1 assert is_magic_number(199) == True # 1+9+9 = 19, 1+9 = 10, 1+0 = 1 assert is_magic_number(111) == False # 1+1+1 = 3 assert is_magic_number(0) == False # Not considered a magic number ``` **Implementation Notes**: - Your solution must handle the provided constraints effectively. - Ensure your function validates input correctness before processing.","solution":"def is_magic_number(num: int) -> bool: This function checks whether the provided integer is a magic number. Args: num (int): The integer to check Returns: bool: True if num is a magic number, False otherwise. if num < 1: return False def digit_sum(n): return sum(int(digit) for digit in str(n)) while num >= 10: num = digit_sum(num) return num == 1"},{"question":"# Task Implement the `flatten_iter` generator function that returns an iterator to produce a flattened array. Given an array that may contain nested arrays, ensure your function correctly handles deeply nested structures and string elements that should not be expanded as arrays. # Constraints * The input array may contain nested arrays to arbitrary depth. * Elements may include different types such as integers, strings, etc. * Strings should not be expanded individually into characters. # Input * A single parameter: `input_arr` (a potentially nested array). # Output * A generator that yields elements from the original array in a flattened structure. # Example ```python input_arr = [1, [2, [3, [4]], 5], \\"hello\\", [6, [7]]] output = list(flatten_iter(input_arr)) # Expected output [1, 2, 3, 4, 5, \\"hello\\", 6, 7] ``` # Constraints * The input size is arbitrarily large; consider both time and space complexity. * Ensure the solution handles edge cases such as empty arrays, and mixed data types within arrays. # Performance Requirements * The solution should be efficient in terms of both time and space complexity. * Leverage lazy evaluation for space efficiency. Implement the function `flatten_iter(input_arr)` to meet these requirements.","solution":"def flatten_iter(input_arr): A generator function that returns a flattened iterator for the nested array input. Args: - input_arr: A potentially nested array. Yields: Individual elements in a flattened structure. for item in input_arr: if isinstance(item, list): yield from flatten_iter(item) else: yield item"},{"question":"# Question: Implement and Extend Jump Search You are given a sorted array of integers and you need to find the index of a target value using the Jump Search algorithm. Extend the given Jump Search algorithm to: 1. Return the index of the first occurrence of the target value. 2. Modify the algorithm to also work in descending sorted arrays. 3. Handle scenarios where the array is empty. **Input Format**: * `arr` - Sorted list of integers (can be ascending or descending order, possibly empty). * `target` - An integer value which needs to be searched in the list. **Output Format**: * Return the index of the first occurrence of the `target`. If the `target` is not present in the array, return `-1`. **Constraints**: * The length of the array can be up to `10^6`. * The elements of the array are within the range `-10^6` to `10^6`. **Performance Requirements**: * Your solution should handle the worst-case time complexity efficiently and not exceed O(√n). **Example**: 1. Input: `arr = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]`, `target = 7` Output: `3` 2. Input: `arr = [20, 18, 16, 14, 12, 10, 8, 6, 4, 2]`, `target = 10` Output: `5` 3. Input: `arr = [1, 2, 2, 2, 4, 4, 6, 8, 10, 12]`, `target = 2` Output: `1` **Note**: If the target appears multiple times in the array, ensure you return the index of its first occurrence.","solution":"import math def jump_search(arr, target): Perform a Jump Search on the sorted array `arr` to find the index of the first occurrence of `target`. Handles both ascending and descending sorted arrays, including empty arrays. Parameters: arr (list): A list of sorted integers. target (int): The integer value to search for in the list. Returns: int: The index of the first occurrence of the `target`, or -1 if the `target` is not present. length = len(arr) if length == 0: return -1 # Determine if array is sorted in ascending or descending order ascending = arr[0] <= arr[-1] # Calculate the jump size step = int(math.sqrt(length)) prev = 0 # Find the block where the target may reside while (ascending and prev < length and arr[min(length, prev + step) - 1] < target) or (not ascending and prev < length and arr[min(length, prev + step) - 1] > target): prev += step # Perform linear search within the block for idx in range(prev, min(prev + step, length)): if arr[idx] == target: return idx return -1"},{"question":"You are given an integer base `a`, an integer exponent `n`, and an optional integer modulus `mod`. Implement two functions to compute the result of `a` raised to the power `n`, with an optional modulus operation: 1. **Iterative Method** (`power`) 2. **Recursive Method** (`power_recur`) # Function Specifications Function 1: `power(a: int, n: int, mod: int = None) -> int` - **Input**: - `a` (int): The base value. - `n` (int): The exponent value. - `mod` (int, optional): The modulus value. If not provided, calculations should be done without modulus. - **Output**: - Returns the result of `a`^`n` (mod `mod` if provided). Function 2: `power_recur(a: int, n: int, mod: int = None) -> int` - **Input**: - `a` (int): The base value. - `n` (int): The exponent value. - `mod` (int, optional): The modulus value. If not provided, calculations should be done without modulus. - **Output**: - Returns the result of `a`^`n` (mod `mod` if provided). # Constraints - `0 <= n <= 10^9` - `1 <= a <= 10^9` - If `mod` is provided, `1 <= mod <= 10^9` # Edge Cases 1. Consider scenarios with n=0, n=1. 2. Scenarios where `mod` is not provided. 3. Large values of `n` to test performance and stack utilization. # Examples Example 1: ```python assert power(2, 10) == 1024 assert power(2, 10, 1000) == 24 # 1024 % 1000 = 24 ``` Example 2: ```python assert power_recur(3, 5) == 243 # 3^5 = 243 assert power_recur(3, 5, 100) == 43 # 243 % 100 = 43 ``` # Note While implementing, ensure that your solution handles large numbers efficiently, especially with maximum constraints of `n`.","solution":"def power(a: int, n: int, mod: int = None) -> int: Computes a raised to the power n using an iterative method. If mod is provided, returns (a^n) % mod. result = 1 base = a exponent = n if mod is not None: base = base % mod while exponent > 0: if exponent % 2 == 1: result = (result * base) % mod if mod is not None else result * base exponent = exponent >> 1 base = (base * base) % mod if mod is not None else base * base return result def power_recur(a: int, n: int, mod: int = None) -> int: Computes a raised to the power n using a recursive method. If mod is provided, returns (a^n) % mod. if n == 0: return 1 if n == 1: return a % mod if mod is not None else a half_power = power_recur(a, n // 2, mod) half_power = (half_power * half_power) % mod if mod is not None else half_power * half_power if n % 2 != 0: return (half_power * a) % mod if mod is not None else half_power * a return half_power"},{"question":"# Binary Search Tree Operations and Analysis Context: A Binary Search Tree (BST) is a node-based binary tree data structure that has the following properties: - Left subtree of a node contains only nodes with keys less than the node’s key. - Right subtree of a node contains only nodes with keys greater than the node’s key. - Both left and right subtrees must also be binary search trees. You are required to implement additional functionalities in a BST and perform related operations. The existing implementation supports insertion, search, size calculation, and traversal operations. Your task is to extend this implementation, analyze its performance, and handle the given scenario. Task: 1. **Implement a `delete` method** to remove a specific value from the BST if it exists. 2. **Implement a `find_min` method** to return the minimum value stored in the BST. 3. **Implement a `find_max` method** to return the maximum value stored in the BST. Requirements: - **Delete Method**: - Inputs: Integer value `data` to be deleted. - Outputs: Boolean value - `True` if deletion was successful, `False` otherwise. - Operation should handle all three possible standard cases in BST deletion (node to be deleted is a leaf, has one child, or has two children). - **Find Min/Max Methods**: - Inputs: None. - Outputs: Integer value representing the minimum/maximum node\'s value. - If the tree is empty, return `None`. - **Performance**: Aim for optimal performance with time complexity considerations. Example of the tree: ``` 10 / 6 15 / / 4 9 12 24 / / 7 20 30 / 18 ``` # Function Signatures: ```python class BST(object): # Other methods as given in the code snippet def delete(self, data): # Implement this method def find_min(self): # Implement this method def find_max(self): # Implement this method ``` # Constraints: - The tree will initially contain at most 1000 nodes. - The values are unique integers in the range -10^5 to 10^5. # Validations: You should write tests to validate your implementations. # Example Usage: ```python tree = BST() tree.insert(10) tree.insert(15) tree.delete(10) # Should return True if 10 is successfully deleted print(tree.find_min()) # Should return the minimum element in tree print(tree.find_max()) # Should return the maximum element in tree ```","solution":"class TreeNode: def __init__(self, key): self.left = None self.right = None self.val = key class BST: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = TreeNode(key) else: self._insert(self.root, key) def _insert(self, node, key): if key < node.val: if node.left is None: node.left = TreeNode(key) else: self._insert(node.left, key) else: if node.right is None: node.right = TreeNode(key) else: self._insert(node.right, key) def delete(self, key): self.root, deleted = self._delete(self.root, key) return deleted def _delete(self, node, key): if node is None: return node, False if key < node.val: node.left, deleted = self._delete(node.left, key) elif key > node.val: node.right, deleted = self._delete(node.right, key) else: if node.left is None: return node.right, True elif node.right is None: return node.left, True temp_val = self._find_min(node.right).val node.val = temp_val node.right, _ = self._delete(node.right, temp_val) deleted = True return node, deleted def find_min(self): if self.root is None: return None return self._find_min(self.root).val def _find_min(self, node): current = node while current.left is not None: current = current.left return current def find_max(self): if self.root is None: return None return self._find_max(self.root).val def _find_max(self, node): current = node while current.right is not None: current = current.right return current"},{"question":"# Prime Number Identification Function You are tasked with creating a function that identifies whether a given number is a prime number. As part of this task, you will implement a primality test based on advanced primality checking principles. Function Signature ```python def advanced_prime_check(n: int) -> bool: ``` Input - `n` (int): An integer number where (1 le |n| le 10^6). Output - Returns a boolean value: - `True`: if `n` is a prime number. - `False`: if `n` is not a prime number. Constraints - Your solution should be optimized in terms of both time and space complexity. - Consider edge cases such as small numbers, negative numbers, and large prime numbers. Performance Requirements - The function should ideally operate within (O(√n)) time complexity. Example ```python print(advanced_prime_check(11)) # Output: True print(advanced_prime_check(15)) # Output: False print(advanced_prime_check(29)) # Output: True print(advanced_prime_check(1)) # Output: False print(advanced_prime_check(0)) # Output: False ``` Scenario A digital security firm needs an efficient primality test to enhance their cryptographic algorithms. Your function will be integrated into their cryptographic systems to ensure only prime numbers are used for key generation and validation, thus enhancing security. Put your algorithmic skills to test and implement the `advanced_prime_check` function accurately.","solution":"import math def advanced_prime_check(n: int) -> bool: Determines if the given number n is a prime number. Args: n (int): The number to check Returns: bool: True if n is a prime number, False otherwise # Edge cases if n <= 1: return False if n <= 3: return True # Eliminate multiples of 2 and 3 if n % 2 == 0 or n % 3 == 0: return False # Check for factors from 5 to sqrt(n) with step of 6 i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True"},{"question":"Problem Statement You are provided with a non-empty string. Your task is to write a function `is_repeated_substring` that determines if the string can be created by repeating a substring multiple times. # Input Format * The function `is_repeated_substring` takes a single input parameter: * `s` (a non-empty string). # Output Format * The function should return a boolean value: * `True` if the string can be constructed by repeating a substring multiple times. * `False` otherwise. # Constraints * The length of the string `s` is at least 1 and at most 10^4. * The function should handle large input sizes efficiently within linear time complexity. # Sample Input/Output Example 1 * Input: `\\"abab\\"` * Output: `True` * Explanation: The input can be split into the substring `\\"ab\\"` repeated twice. Example 2 * Input: `\\"aba\\"` * Output: `False` * Explanation: The input cannot be constructed by repeating any substring multiple times. Example 3 * Input: `\\"abcabcabcabc\\"` * Output: `True` * Explanation: The input can be split into the substring `\\"abc\\"` repeated four times. # Implementation Guide 1. Consider concatenating the string `s` with itself to form a new string. 2. Remove the first and last character from this concatenated string. 3. Check if the original string `s` is a substring of this manipulated string. ```python def is_repeated_substring(s): :type s: str :rtype: bool doubled_string = (s + s)[1:-1] return s in doubled_string ```","solution":"def is_repeated_substring(s): Determines if the string can be created by repeating a substring multiple times. :param s: str - A non-empty string. :return: bool - Returns True if the string can be constructed by repeating a substring, False otherwise. doubled_string = (s + s)[1:-1] return s in doubled_string"},{"question":"# Context You are working on a process that requires optimizing memory allocation in a system based on sequences of operations on binary data, specifically focusing on maximizing the run-length encoding of binary digits. Given a non-negative integer, your task is to determine the longest possible sequence of 1s that can be created by flipping exactly one bit from 0 to 1 in its binary representation. # Task Write a function `find_longest_consecutive_ones(num)` that takes an integer `num` as input and returns the length of the longest sequence of 1s achievable by flipping exactly one bit from 0 to 1. Input * **num**: A non-negative integer (0 ≤ num ≤ 2^31 - 1) Output * An integer representing the longest sequence of consecutive 1s after flipping one bit from 0 to 1. # Constraints * Ensure your solution is efficient with regards to time and space complexity. * Consider edge cases such as 0, 1, and large integers close to 2^31 - 1. Examples 1. **Input**: 1775 (binary: `11011101111`) **Output**: 8 2. **Input**: 0 (binary: `0`) **Output**: 1 3. **Input**: 15 (binary: `1111`) **Output**: 5 Hints: * Utilize bitwise operations like AND (`&`) and bit shifts (`>>`). * Keep track of current and previous sequence counts to determine potential max sequence lengths when flipping bits.","solution":"def find_longest_consecutive_ones(num): Returns the length of the longest sequence of 1s achievable by flipping exactly one bit from 0 to 1. if num == 0: return 1 current_length = 0 previous_length = 0 max_length = 0 while num != 0: if (num & 1) == 1: current_length += 1 else: previous_length = current_length if (num & 2) != 0 else 0 current_length = 0 max_length = max(max_length, previous_length + current_length + 1) num >>= 1 return max_length"},{"question":"# Coding Task Problem Statement You are given an integer array `nums` where `nums` contains exactly two elements that appear exactly once, and all other elements appear exactly twice. Your task is to write a function that returns the two elements that appear only once. Input * A list of integers `nums` of length `N` where N is even. * Constraints: - All numbers in nums are integers. - Exactly two elements in `nums` appear once. - All other elements in `nums` appear exactly twice. Output * A list of two integers where the integers are the elements in `nums` that appear only once. * The order of the output does not matter. Example ```python Input: nums = [1, 2, 1, 3, 2, 5] Output: [3, 5] or [5, 3] ``` Requirements * Time Complexity: O(N) * Space Complexity: O(1) Function Signature ```python def single_number3(nums: List[int]) -> List[int]: # your code here ``` Implementation Details 1. Perform an XOR operation over all elements to find `A XOR B` where A and B are the elements appearing only once. 2. Identify the rightmost set bit in `A XOR B`, which can be used as a pivot to differentiate A and B. 3. Perform XOR operations based on the identified bit to isolate A and B. 4. Return the result as a list containing A and B.","solution":"from typing import List def single_number3(nums: List[int]) -> List[int]: Finds the two elements that appear exactly once in the array where all other elements appear exactly twice. # Step 1: Find XOR of all elements. This should give us A XOR B where A and B are the unique numbers. xor_all = 0 for num in nums: xor_all ^= num # Step 2: Find the rightmost set bit in the xor_all to differentiate the two numbers rightmost_set_bit = xor_all & -xor_all # Step 3: Initialize A and B num1, num2 = 0, 0 # Step 4: Divide the array elements into two groups and find unique numbers for num in nums: if num & rightmost_set_bit: num1 ^= num # XOR of one group else: num2 ^= num # XOR of the other group return [num1, num2]"},{"question":"# ZigZag Iterator Challenge Background: You are given data from two different modules that need to be processed in a round-robin fashion. To facilitate this, you are to implement a ZigZag Iterator which allows you to traverse two lists alternately. Objective: Implement a class `ZigZagIterator` that will allow you to iterate over two lists `v1` and `v2` alternately. After one list is exhausted, continue with the remaining elements of the other list. Function Signatures: 1. **`__init__(self, v1: List[int], v2: List[int]) -> None`**: Initialize the data structure with two lists. 2. **`next(self) -> int`**: Return the next element in the zigzag order. 3. **`has_next(self) -> bool`**: Return `True` if there are still elements to be processed, `False` otherwise. Example Usage: ```python l1 = [1, 2] l2 = [3, 4, 5, 6] it = ZigZagIterator(l1, l2) result = [] while it.has_next(): result.append(it.next()) print(result) # Output should be [1, 3, 2, 4, 5, 6] ``` Constraints: - Elements in the lists are non-negative integers. - One of the lists can be empty. - The total number of elements in both lists is less than 1000.","solution":"class ZigZagIterator: def __init__(self, v1, v2): self.v1 = v1 self.v2 = v2 self.index1 = 0 self.index2 = 0 self.turn = 0 # 0 for v1\'s turn, 1 for v2\'s turn def next(self): if self.turn == 0 and self.index1 < len(self.v1): result = self.v1[self.index1] self.index1 += 1 self.turn = 1 if self.index2 < len(self.v2) else 0 elif self.turn == 1 and self.index2 < len(self.v2): result = self.v2[self.index2] self.index2 += 1 self.turn = 0 if self.index1 < len(self.v1) else 1 elif self.index1 < len(self.v1): result = self.v1[self.index1] self.index1 += 1 else: result = self.v2[self.index2] self.index2 += 1 return result def has_next(self): return self.index1 < len(self.v1) or self.index2 < len(self.v2)"},{"question":"You are tasked with implementing a sorting feature in a small educational software. To align with the requirements, the selected algorithm should demonstrate foundational sorting mechanism without utilizing extensive system resources. Given the nature of the data, implement the Gnome Sort algorithm. Function Signature Implement the following function: ```python def gnome_sort(arr: List[int]) -> List[int]: pass ``` Input * A list of integers, `arr` (0 ≤ len(arr) ≤ 10^5). Output * A sorted list of integers in ascending order. Constraints * All integers in the list are guaranteed to fit within standard integer ranges (-10^9 ≤ arr[i] ≤ 10^9). Example * Input: `[34, 2, 78, 3, 14]` * Output: `[2, 3, 14, 34, 78]` Performance Requirements * Ensure the function can handle up to 100,000 elements within reasonable time limits for educational tools, even if Gnome Sort is not the most performant for large datasets. Edge Cases * Consider lists that are already sorted. * Handle lists with elements in reverse order. * Lists with duplicated elements. * Empty lists and single-element lists.","solution":"def gnome_sort(arr): Sorts the given list of integers using the Gnome Sort algorithm. Parameters: arr (List[int]): The list of integers to sort. Returns: List[int]: The sorted list of integers in ascending order. index = 0 while index < len(arr): if index == 0 or arr[index] >= arr[index - 1]: index += 1 else: arr[index], arr[index - 1] = arr[index - 1], arr[index] index -= 1 return arr"},{"question":"# Ternary Search Implementation You are provided with a basic implementation of the Ternary Search algorithm. Your understanding of this algorithm will be assessed through modifications and enhancements. Problem Statement 1. Implement a revised version of `ternary_search` that addresses potential edge cases and optimizes the algorithm. 2. Additionally, implement a helper function to validate whether the array is sorted in ascending order. Function Details 1. **search_in_sorted_array** * **input**: * `arr` (List of integers): the array to be searched, expected to be sorted in ascending order. * `key` (integer): the element to search for. * **output**: * the index of the element if found, -1 otherwise. * **constraint**: You should utilize the ternary search logic for your search implementation. 2. **is_sorted** * **input**: * `arr` (List of integers): the array to be checked. * **output**: * `True` if the array is sorted in ascending order, `False` otherwise. * **note**: This function assures that the `ternary_search` function is called only on sorted arrays. Example ```python def search_in_sorted_array(arr, key): # Your implementation here def is_sorted(arr): # Your implementation here # Example usage: arr = [1, 2, 3, 4, 5, 6] key = 4 if is_sorted(arr): print(search_in_sorted_array(arr, key)) # Output: 3 else: print(\\"Array is not sorted\\") ``` Constraints * The array `arr` will contain at most `10^6` elements. * Avoid using Python\'s in-built sorting function. * Ensure all comparisons are efficient for large data sets. * Strive for a time complexity of O(log3(N)) for the search operation. Edge Cases to Consider * Empty array (`arr = []`) * Array with one element (e.g., `arr = [5]`) * Key not present in the array (e.g., `arr = [1, 2, 3, 5]` with `key = 4`) Provide a tested and fully functional solution.","solution":"def ternary_search(arr, key, left, right): if right >= left: mid1 = left + (right - left) // 3 mid2 = right - (right - left) // 3 if arr[mid1] == key: return mid1 if arr[mid2] == key: return mid2 if key < arr[mid1]: return ternary_search(arr, key, left, mid1 - 1) elif key > arr[mid2]: return ternary_search(arr, key, mid2 + 1, right) else: return ternary_search(arr, key, mid1 + 1, mid2 - 1) return -1 def search_in_sorted_array(arr, key): if not arr: return -1 return ternary_search(arr, key, 0, len(arr) - 1) def is_sorted(arr): return all(arr[i] <= arr[i + 1] for i in range(len(arr) - 1))"},{"question":"You are provided with two large sparse vectors. A sparse vector predominantly contains zero elements and very few non-zero elements. Efficient representations of such vectors use lists of index-value pairs where the value at a specific index is non-zero. Write Python functions to: 1. Convert a dense vector into its sparse representation. 2. Compute the dot product of two sparse vectors represented in the form of lists of index-value pairs. # Functions to Implement 1. `vector_to_index_value_list(vector: List[float]) -> List[Tuple[int, float]]` * **Input**: A list of floats representing a dense vector. * **Output**: A list of `(index, value)` tuples where the value is not zero. 2. `dot_product(iv_list1: List[Tuple[int, float]], iv_list2: List[Tuple[int, float]]) -> float` * **Input**: Two lists of `(index, value)` tuples representing sparse vectors. * **Output**: A float representing the dot product of the given vectors. # Requirements * **Constraints**: * The input dense vectors can have lengths up to 10^6. * The number of non-zero elements in the dense vectors is significantly less than the total length. * Both sparse vectors will have their indices sorted in ascending order. * **Edge cases** to consider: * Both input vectors are empty. * Vectors with no overlapping non-zero elements. * Vectors of different lengths. # Performance * Your solution should handle the input size efficiently both in terms of time and space. # Example Usage ```python dense_vector1 = [0.0, 3.0, 0.0, 4.0, 0.0] dense_vector2 = [1.0, 0.0, 0.0, 4.0, 2.0] # Convert to sparse representation sparse_vector1 = vector_to_index_value_list(dense_vector1) # [(1, 3.0), (3, 4.0)] sparse_vector2 = vector_to_index_value_list(dense_vector2) # [(0, 1.0), (3, 4.0), (4, 2.0)] # Compute dot product of the sparse vectors result = dot_product(sparse_vector1, sparse_vector2) # 16.0 (3.0*0.0 + 4.0*4.0) ``` Implement the `vector_to_index_value_list` and `dot_product` functions and test them with different scenarios to ensure their correctness and efficiency.","solution":"from typing import List, Tuple def vector_to_index_value_list(vector: List[float]) -> List[Tuple[int, float]]: Converts a dense vector to its sparse representation (index-value pairs). Args: vector (List[float]): A list of floats representing a dense vector. Returns: List[Tuple[int, float]]: A list of tuples where each tuple contains the index and value of non-zero elements. return [(i, value) if value != 0 else None for i, value in enumerate(vector) if value != 0] def dot_product(iv_list1: List[Tuple[int, float]], iv_list2: List[Tuple[int, float]]) -> float: Computes the dot product of two sparse vectors represented as index-value pairs. Args: iv_list1 (List[Tuple[int, float]]): First sparse vector. iv_list2 (List[Tuple[int, float]]): Second sparse vector. Returns: float: The dot product of the two vectors. index1, index2 = 0, 0 result = 0.0 while index1 < len(iv_list1) and index2 < len(iv_list2): if iv_list1[index1][0] == iv_list2[index2][0]: result += iv_list1[index1][1] * iv_list2[index2][1] index1 += 1 index2 += 1 elif iv_list1[index1][0] < iv_list2[index2][0]: index1 += 1 else: index2 += 1 return result"},{"question":"You are required to implement a function for a data-intensive application that keeps a self-balancing binary search tree. Specifically, you’ll be working with AVL tree data structure. Your task is to modify the existing AVL tree class to add functionalities for deletion and to validate if the tree is balanced after multiple operations. # Task 1. **Extend the AVL Tree Class** with: * A method `delete(key)` to remove the nodes appropriately and re-balancing the tree thereafter. 2. **Implement a method `is_balanced()`** to validate if the tree is currently balanced, returning `True` if it is and `False` otherwise. # Function Signature ```python class AvlTree: # Existing implementation def delete(self, key): pass def is_balanced(self): pass ``` # Input 1. `delete` method input: * `key` - An integer representing the key to be deleted. 2. `is_balanced` method: * No input; just validates the current state of AVL tree. # Output 1. `delete` method: * No return; modifies the tree structure internally. 2. `is_balanced` method: * Boolean `True` or `False` indicating if the tree is balanced or not. # Constraints * AVL tree contains distinct integer keys. * Operations include a sequence of insertions and deletions. # Performance Requirements * The implemented `delete` and `is_balanced` methods should maintain O(log n) operational complexity. # Example ```python # Create AVL Tree instance avl = AvlTree() # Insert elements avl.insert(10) avl.insert(20) avl.insert(30) # Tree should rotate assert avl.is_balanced() == True # Delete a node avl.delete(20) # Tree should rebalance assert avl.is_balanced() == True ``` # Note Handle all possible edge cases: rebalancing from the root, empty tree deletions, single child node deletions, multiple rotations, etc.","solution":"class Node: def __init__(self, key): self.key = key self.height = 1 self.left = None self.right = None class AvlTree: def __init__(self): self.root = None def insert(self, key): self.root = self._insert(self.root, key) def _insert(self, node, key): if not node: return Node(key) elif key < node.key: node.left = self._insert(node.left, key) else: node.right = self._insert(node.right, key) node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) balance = self._get_balance(node) if balance > 1 and key < node.left.key: return self._right_rotate(node) if balance < -1 and key > node.right.key: return self._left_rotate(node) if balance > 1 and key > node.left.key: node.left = self._left_rotate(node.left) return self._right_rotate(node) if balance < -1 and key < node.right.key: node.right = self._right_rotate(node.right) return self._left_rotate(node) return node def delete(self, key): self.root = self._delete(self.root, key) def _delete(self, node, key): if not node: return node if key < node.key: node.left = self._delete(node.left, key) elif key > node.key: node.right = self._delete(node.right, key) else: if not node.left: return node.right elif not node.right: return node.left temp = self._get_min_value_node(node.right) node.key = temp.key node.right = self._delete(node.right, temp.key) if not node: return node node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) balance = self._get_balance(node) if balance > 1 and self._get_balance(node.left) >= 0: return self._right_rotate(node) if balance > 1 and self._get_balance(node.left) < 0: node.left = self._left_rotate(node.left) return self._right_rotate(node) if balance < -1 and self._get_balance(node.right) <= 0: return self._left_rotate(node) if balance < -1 and self._get_balance(node.right) > 0: node.right = self._right_rotate(node.right) return self._left_rotate(node) return node def is_balanced(self): return self._is_balanced(self.root) def _is_balanced(self, node): if not node: return True lh = self._get_height(node.left) rh = self._get_height(node.right) if abs(lh - rh) > 1: return False return self._is_balanced(node.left) and self._is_balanced(node.right) def _left_rotate(self, z): y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def _right_rotate(self, z): y = z.left T3 = y.right y.right = z z.left = T3 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def _get_height(self, node): if not node: return 0 return node.height def _get_balance(self, node): if not node: return 0 return self._get_height(node.left) - self._get_height(node.right) def _get_min_value_node(self, node): current = node while current.left is not None: current = current.left return current"},{"question":"You are provided with a function `join_with_slash` that joins two parts of a string using a single slash. Your task is to extend this function to handle a third optional part. This optional part should also be joined using slashes, and should be handled similarly to the base and suffix. Carefully handle scenarios where this third part might be empty or might have leading/trailing slashes. # Function Signature ```python def join_with_slash_extended(base: str, suffix: str, optional_part: str = \\"\\") -> str: ``` # Input * `base`: A non-empty string representing the first part of the path/URL. * `suffix`: A non-empty string representing the second part of the path/URL. * `optional_part`: An optional string that, if provided, represents an additional part to be joined. # Output * Returns a single string representing the properly joined parts by slashes. # Constraints * The inputs can be of lengths up to 10^4. * Each input may contain leading/trailing spaces that should be trimmed. * Ensure that there are no redundant slashes where the segments are joined. * The inputs consist of printable ASCII characters only. # Examples 1. `join_with_slash_extended(\\"path/to/dir\\", \\"file\\", \\"extra\\")` should return `\\"path/to/dir/file/extra\\"` 2. `join_with_slash_extended(\\"http://example.com/\\", \\"/part\\", \\"\\")` should return `\\"http://example.com/part\\"` 3. `join_with_slash_extended(\\"http://example.com\\", \\"part\\", \\"another\\")` should return `\\"http://example.com/part/another\\"` # Notes Make sure to handle cases where: * `optional_part` is empty. * Trailing and leading slashes are managed correctly.","solution":"def join_with_slash_extended(base: str, suffix: str, optional_part: str = \\"\\") -> str: Joins three parts of a URL/path using a single slash. Arguments: base -- The base part of the URL/path. suffix -- The suffix part of the URL/path. optional_part -- The optional additional part of the URL/path. Default is an empty string. Returns: A single string representing the properly joined parts by slashes. # Clean the inputs by stripping leading/trailing whitespaces and slashes base = base.strip().strip(\'/\') suffix = suffix.strip().strip(\'/\') optional_part = optional_part.strip().strip(\'/\') # Join the parts with slashes if optional_part: return f\\"{base}/{suffix}/{optional_part}\\" else: return f\\"{base}/{suffix}\\""},{"question":"# Question: Counting Islands using Union-Find In a 2D grid map of integers, 0 represents water and 1 represents land. A cell is a part of an island if it has the value 1, and all cells connected horizontally or vertically create an island. You need to determine the number of islands that form as land is added. Write a class `IslandsCounter` which uses the Union-Find data structure to realize the functionality. The class should support the operations: 1. `addLand(row: int, col: int) -> int`: This function turns the water at the specified position `(row, col)` into land and returns the number of islands formed after this operation. 2. `currentNumberOfIslands() -> int`: Returns the current number of islands. Initial Conditions * The map is initialized as all water (0s). * Rows and columns can have a value between 0 and 999 inclusive. Constraints * `addLand` will be called with valid row and col such that the initial position was water and not land. * `addLand` will be called for a finite number of times. Example ```python # Example operations: ic = IslandsCounter() print(ic.addLand(0, 0)) # -> 1 (1 island by turning G[0][0] into land) print(ic.addLand(0, 1)) # -> 1 (land at G[0][0] connected to land at G[0][1]) print(ic.addLand(1, 2)) # -> 2 (new island by turning G[1][2] into land) print(ic.addLand(2, 1)) # -> 3 (new island by turning G[2][1] into land) print(ic.currentNumberOfIslands()) # -> 3 (Current number of islands) ``` The goal is to ensure your implementation handles the dynamic nature of adding land at various positions efficiently using the Union-Find data structure.","solution":"class IslandsCounter: def __init__(self): self.parent = {} self.rank = {} self.count = 0 def find(self, x): if self.parent[x] != x: self.parent[x] = self.find(self.parent[x]) return self.parent[x] def union(self, x, y): rootX = self.find(x) rootY = self.find(y) if rootX != rootY: if self.rank[rootX] > self.rank[rootY]: self.parent[rootY] = rootX elif self.rank[rootX] < self.rank[rootY]: self.parent[rootX] = rootY else: self.parent[rootY] = rootX self.rank[rootX] += 1 self.count -= 1 def addLand(self, row: int, col: int) -> int: pos = (row, col) if pos in self.parent: return self.count self.parent[pos] = pos self.rank[pos] = 0 self.count += 1 for dr, dc in [(0, 1), (1, 0), (0, -1), (-1, 0)]: nr, nc = row + dr, col + dc adj_pos = (nr, nc) if adj_pos in self.parent: self.union(pos, adj_pos) return self.count def currentNumberOfIslands(self) -> int: return self.count"},{"question":"You are given a list `lst` and an integer `N`. Your task is to write a function `limit_element_frequency(lst, N)` which returns a new list where each element appears at most `N` times without reordering elements. If `N` is 0, return an empty list. # Implementation Details: - **Function Signature:** ```python def limit_element_frequency(lst: List[int], N: int) -> List[int]: ``` - **Input:** - `lst` (List[int]): A list of integers. - `N` (int): Maximum allowed frequency for each distinct element. - **Output:** - List[int]: A new list with elements appearing at most `N` times in the same order as they appear in `lst`. # Example Input/Output: 1. **Example 1:** - Input: `lst = [1, 2, 3, 1, 2, 1, 2, 3]`, `N = 2` - Output: `[1, 2, 3, 1, 2, 3]` 2. **Example 2:** - Input: `lst = [20, 37, 20, 21, 37, 22, 20, 37, 21]`, `N = 1` - Output: `[20, 37, 21, 22]` 3. **Example 3:** - Input: `lst = [1, 1, 1, 1]`, `N = 0` - Output: `[]` # Constraints and Considerations: - The function should handle large input sizes efficiently. - Maintain the original order of elements. - Consider edge cases such as empty list, N = 0, and all elements being the same. - The solution must have a time complexity of O(n).","solution":"from typing import List def limit_element_frequency(lst: List[int], N: int) -> List[int]: if N == 0: return [] frequency = {} result = [] for item in lst: if item not in frequency: frequency[item] = 0 if frequency[item] < N: result.append(item) frequency[item] += 1 return result"},{"question":"# Question: String Reversal Using Different Methods You are tasked with implementing different methods to reverse a string. Specifically, you will write functions to reverse a string using recursion, iteration, and Python\'s built-in functionalities. Part 1: Recursive String Reversal Implement a function `reverse_recursive(s)` that reverses a string `s` using recursion. * **Input**: A single string, `s`. * **Output**: The reversed string. ```python def reverse_recursive(s): pass # Your code here ``` Part 2: Iterative String Reversal Implement a function `reverse_iterative(s)` that reverses a string `s` using an iterative approach. * **Input**: A single string, `s`. * **Output**: The reversed string. ```python def reverse_iterative(s): pass # Your code here ``` Part 3: Pythonic String Reversal Implement two functions for reversing a string in Pythonic ways. One function should use the built-in `reversed()` function, and the other should use slicing. * **Input**: A single string, `s`. * **Output**: The reversed string. ```python def reverse_pythonic(s): pass # Your code here def reverse_ultra_pythonic(s): pass # Your code here ``` # Constraints and Performance Requirements * The input string `s` will have a length of at most (10^6). * Each solution should handle large inputs efficiently within a reasonable time frame. * You should consider edge cases such as empty strings and single-character strings in your implementation. Example ```python assert reverse_recursive(\\"hello\\") == \\"olleh\\" assert reverse_iterative(\\"world\\") == \\"dlrow\\" assert reverse_pythonic(\\"example\\") == \\"elpmaxe\\" assert reverse_ultra_pythonic(\\"string\\") == \\"gnirts\\" ```","solution":"def reverse_recursive(s): Reverse a string s using recursion. if len(s) == 0: return s else: return reverse_recursive(s[1:]) + s[0] def reverse_iterative(s): Reverse a string s using an iterative approach. reversed_string = \\"\\" for char in s: reversed_string = char + reversed_string return reversed_string def reverse_pythonic(s): Reverse a string s using Python\'s built-in reversed() function. return \'\'.join(reversed(s)) def reverse_ultra_pythonic(s): Reverse a string s using Python\'s slicing. return s[::-1]"},{"question":"# Priority Queue Creation and Management As a software developer at a task management company, you are tasked with implementing a priority queue to manage tasks based on their priority. Each task has an associated priority, and tasks with higher priorities should be processed before tasks with lower priorities. Implement a priority queue using a linear array as described below: You are required to implement the following two functionalities for the priority queue: 1. `push(item: Any, priority: int) -> None`: - Adds the item to the queue. If no priority is given, use the item itself as the priority. - Ensure the internal list is sorted so that the highest priority task is at the start of the list. 2. `pop() -> Any`: - Removes and returns the item with the highest priority. - If the queue is empty, raise an `IndexError` with the message `\\"pop from empty priority queue\\"`. You should also implement a `size() -> int` method that returns the number of items in the priority queue. Input: The input consists of multiple operations formatted as follows: - `\\"push <item> <priority>\\"` (priority is optional) - `\\"pop\\"` Output: For every `pop` operation, output the item with the highest priority. Constraints: - The priority queue should handle tasks in a way that `push` operations are O(n) and `pop` operations are O(1). - You can assume the items pushed will be valid hashable objects in Python. Example: ```python # Sample Input push A 2 push B 5 push C 1 pop push D 3 pop pop pop # Sample Output B D A C ``` You can use the given class `PriorityQueue` above as a starting point. Ensure that the implementation respects the time complexity constraints and handles all edge cases properly.","solution":"class PriorityQueue: def __init__(self): self.queue = [] def push(self, item, priority=None): # If priority is not given, use item itself as priority if priority is None: priority = item # Insert the item based on its priority, ensuring the list remains sorted for i, (p, it) in enumerate(self.queue): if priority > p: self.queue.insert(i, (priority, item)) break else: self.queue.append((priority, item)) def pop(self): if not self.queue: raise IndexError(\\"pop from empty priority queue\\") return self.queue.pop(0)[1] def size(self): return len(self.queue)"},{"question":"# Matrix Transformations and Analysis You have been given several functions to perform transformations (rotations and inversions) on a 2D matrix. Your task is to create an enhanced version of these functions that addresses potential performance issues and gracefully handles edge cases. Your task is to implement the function `rotate_matrix(matrix, direction)`. The function should take a 2D matrix and a direction (either \\"clockwise\\" or \\"counterclockwise\\") and return the transformed matrix. Additionally, implement another function `invert_matrix(matrix, corner)`, which takes a 2D matrix and a corner (either \\"top-left\\" or \\"bottom-left\\") and returns the inverted matrix. # Input * `matrix`: A list of lists representing the 2D matrix. The matrix is guaranteed to be non-empty with at least one row and one column. * `direction`: A string either \\"clockwise\\" or \\"counterclockwise\\". * `corner`: A string either \\"top-left\\" or \\"bottom-left\\". # Output * Returns the transformed matrix based on the specified direction or corner. # Constraints * You must handle matrices of varying sizes, including single-element matrices. * Your solution must be efficient and avoid unnecessary operations. * Optimize to avoid common pitfalls such as invalid index access. # Performance Requirements: * Your function should run efficiently within the constraints provided, handling matrices up to size 1000 x 1000 within reasonable time limits. # Example ```python def rotate_matrix(matrix, direction): # Implement the optimized rotation here def invert_matrix(matrix, corner): # Implement the optimized inversion here if __name__ == \'__main__\': matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9], ] print(rotate_matrix(matrix, \'clockwise\')) print(rotate_matrix(matrix, \'counterclockwise\')) print(invert_matrix(matrix, \'top-left\')) print(invert_matrix(matrix, \'bottom-left\')) ``` # Example Output: ``` # For rotate_matrix [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] [ [3, 6, 9], [2, 5, 8], [1, 4, 7] ] # For invert_matrix [ [1, 4, 7], [2, 5, 8], [3, 6, 9] ] [ [9, 6, 3], [8, 5, 2], [7, 4, 1] ] ``` Note: Your solution will involve optimizing list operations and careful index handling to avoid performance issues and ensure correctness in all edge cases.","solution":"def rotate_matrix(matrix, direction): Rotates the given matrix by 90 degrees in the specified direction. :param matrix: List[List[int]], the 2D matrix. :param direction: str, either \\"clockwise\\" or \\"counterclockwise\\". :return: List[List[int]], the rotated matrix. if direction not in {\\"clockwise\\", \\"counterclockwise\\"}: raise ValueError(\\"Invalid direction. Must be \'clockwise\' or \'counterclockwise\'\\") if direction == \\"clockwise\\": # Transpose and then reverse each row rotated = [list(row) for row in zip(*matrix[::-1])] else: # counterclockwise # Reverse each row and then transpose rotated = [list(row) for row in zip(*matrix)][::-1] return rotated def invert_matrix(matrix, corner): Inverts the given matrix based on the specified corner (diagonal reflection). :param matrix: List[List[int]], the 2D matrix. :param corner: str, either \\"top-left\\" or \\"bottom-left\\". :return: List[List[int]], the inverted matrix. if corner not in {\\"top-left\\", \\"bottom-left\\"}: raise ValueError(\\"Invalid corner. Must be \'top-left\' or \'bottom-left\'\\") inverted = [] rows = len(matrix) cols = len(matrix[0]) if corner == \\"top-left\\": inverted = [[matrix[j][i] for j in range(rows)] for i in range(cols)] else: # bottom-left inverted = [[matrix[j][cols - 1 - i] for j in range(rows - 1, -1, -1)] for i in range(cols)] return inverted"},{"question":"**Context**: You\'re working on a comment filtering system that removes spam while preserving important comments. An important task in this system involves moving flagged spam comments (represented by zero) to the end of the list, while preserving the order of other comments. The order of flagged spam comments does not matter. **Task**: Write a function `move_zeros_inplace` that takes a list of integers and other objects (which can include zeros and booleans) and moves all zero elements to the end of the list in place, while keeping the order of non-zero elements unchanged. Your implementation should modify the input list directly and must be done in O(1) additional space complexity. # Function Signature ```python def move_zeros_inplace(array: list) -> None: pass ``` # Input * `array` (list): A list of integers and other objects. Elements may include boolean values, strings, or other data types. The list can have both positive and negative integers but prioritize integers and zeros for movement. # Output * The function should modify the `array` list in place and return `None`. # Constraints * Use O(1) additional space — in-place modification only. * The algorithm should have a time complexity of O(n). # Example ```python array = [False, 1, 0, 1, 2, 0, 1, 3, \\"a\\"] move_zeros_inplace(array) print(array) # Output should be [False, 1, 1, 2, 1, 3, \'a\', 0, 0] ``` # Notes: * Do not use additional lists or arrays for this task. * Ensure boolean values are preserved and not treated as zeros. # Hints: * Consider maintaining two pointers to approach this problem efficiently. * Think about the swapping operation to achieve in-place modification.","solution":"def move_zeros_inplace(array: list) -> None: Move all zeros in the list to the end, preserving the order of other elements. n = len(array) non_zero_index = 0 # Pointer to place the next non-zero element for current in range(n): if isinstance(array[current], bool) or array[current] != 0: array[non_zero_index], array[current] = array[current], array[non_zero_index] non_zero_index += 1"},{"question":"**Context:** You are working on a low-level programming task that requires efficient manipulation of binary representations of numbers. You need to write functions that can insert bits into specific positions within a binary number. **Problem Statement:** Write two functions – one for inserting a single bit and another for inserting multiple bits into a given integer\'s binary representation at specified positions. 1. **Function 1**: `insert_one_bit(num, bit, i)` **Description**: Insert a single bit into a specific position within a binary number. **Input**: - `num` (integer): The original number. - `bit` (integer): The bit (0 or 1) to be inserted. - `i` (integer): The zero-based position at which to insert the new bit starting from the least significant bit. **Output**: - Return the new number obtained after inserting the bit. **Constraints**: - `0 <= num <= 10^9` - `bit` is either 0 or 1 - `0 <= i <= floor(log2(num)) + 1` 2. **Function 2**: `insert_mult_bits(num, bits, length, i)` **Description**: Insert multiple bits into a specific position within a binary number. **Input**: - `num` (integer): The original number. - `bits` (integer): The bits to be inserted. - `length` (integer): The number of bits in `bits`. - `i` (integer): The zero-based position at which to insert the new bits starting from the least significant bit. **Output**: - Return the new number obtained after inserting the bits. **Constraints**: - `0 <= num <= 10^9` - `0 <= bits < 2^length` - `1 <= length <= 31` - `0 <= i <= floor(log2(num)) + 1` Write the code for both functions as described above. Ensure that you handle edge cases and validate inputs within the given constraints. **Examples**: ```python # Example for insert_one_bit print(insert_one_bit(21, 1, 2)) # Output: 45 print(insert_one_bit(21, 0, 2)) # Output: 41 print(insert_one_bit(21, 1, 5)) # Output: 53 print(insert_one_bit(21, 1, 0)) # Output: 43 # Example for insert_mult_bits print(insert_mult_bits(5, 7, 3, 1)) # Output: 47 print(insert_mult_bits(5, 7, 3, 0)) # Output: 47 print(insert_mult_bits(5, 7, 3, 3)) # Output: 61 ``` **Note**: Make sure your solution exhibits proper handling of bit manipulation to ensure correctness of the results.","solution":"def insert_one_bit(num, bit, i): Inserts a bit into a specific position i in the binary representation of num. :param num: The original number. :param bit: The bit (0 or 1) to be inserted. :param i: The zero-based position at which to insert the bit. :return: The new number after inserting the bit. # Create a mask to isolate the part where the bit will be inserted mask = (1 << i) - 1 # Capture the lower part of num up to position i lower_part = num & mask # Capture the upper part of num from position i upper_part = num & ~mask # Shift upper part to make room for the new bit upper_part <<= 1 # Insert the new bit new_num = upper_part | (bit << i) | lower_part return new_num def insert_mult_bits(num, bits, length, i): Inserts multiple bits into a specific position i in the binary representation of num. :param num: The original number. :param bits: The bits to be inserted. :param length: The number of bits in `bits`. :param i: The zero-based position at which to insert the bits. :return: The new number after inserting the bits. # Create a mask to isolate the part where bits will be inserted mask = (1 << i) - 1 # Capture the lower part of num up to position i lower_part = num & mask # Capture the upper part of num from position i upper_part = num & ~mask # Shift upper part to make room for the new bits upper_part <<= length # Insert the new bits new_num = upper_part | (bits << i) | lower_part return new_num"},{"question":"**Find the Unique Number** You are given an array of integers, where every element appears exactly twice except for one element which appears only once. Your task is to find the unique element that appears only once. **Input:** - An array of integers `nums` where `1 <= len(nums) <= 10^5` and each integer in the array `-3 * 10^4 <= nums[i] <= 3 * 10^4`. - It is guaranteed that exactly one integer in `nums` appears only once and all others appear twice. **Output:** - Return the integer that appears only once in the array. **Constraints:** - Your solution should have a linear runtime complexity, O(n). - Your solution should not use extra memory beyond a few integer variables, O(1) space complexity. **Example:** ``` Input: [4, 1, 2, 1, 2] Output: 4 Input: [2, 2, 1] Output: 1 ``` **Function Signature:** ```python def single_number(nums: List[int]) -> int: This function takes a list of integers as input and returns the single integer that appears only once. If all integers appear twice, the function should return 0. ``` **Additional Notes:** Consider potential edge cases such as: - Minimal array with two elements, e.g., `[1, 1]`. - Array where the unique number is at the beginning, middle, or end. - Large arrays up to the constraint limits. In your implementation, make sure to: - Iterate through each element exactly once. - Carefully manage the XOR operations to ensure the correct result is derived.","solution":"from typing import List def single_number(nums: List[int]) -> int: This function takes a list of integers as input and returns the single integer that appears only once. If all integers appear twice, the function should return 0. unique_num = 0 for num in nums: unique_num ^= num return unique_num"},{"question":"**Objective**: Demonstrate understanding of searching algorithms with an implementation that handles edge cases and optimizes performance within given constraints. # Scenario: Imagine you are a software engineer at a company dealing with products in different categories. You are frequently asked to find the index of a product based on its ID number within an unsorted list of product IDs. Since the product IDs list updates frequently, sorting it every time before searching isn\'t efficient. # Task: Write a function `find_product_index` that efficiently finds the index of a target product ID in a given list of product IDs. The function should handle edge cases gracefully. # Function Signature: ```python def find_product_index(product_ids: list[int], target_id: int) -> int: Searches for the target_id in the list of product_ids. Returns the index if found, otherwise returns -1. Constraints: - The product_ids list has at most 10^6 elements. - The product_ids list contains integers between 1 and 10^9. - The target_id is an integer between 1 and 10^9. Performance Requirement: - The function should have a time complexity of O(n) and space complexity of O(1). Example: >>> find_product_index([23, 45, 1, 67, 34], 67) 3 >>> find_product_index([23, 45, 1, 67, 34], 100) -1 ``` # Constraints: - You are not allowed to sort the list. - The function should be able to handle empty lists and should return -1 in such cases. # Additional Information: - Think about edge cases such as when the target product ID is at the beginning, middle, or end of the list. - Consider the performance and ensure that the function adheres to the specified time and space complexity. Write clear and efficient code that not only meets the requirements but also handles all possible edge cases.","solution":"def find_product_index(product_ids: list[int], target_id: int) -> int: Searches for the target_id in the list of product_ids. Returns the index if found, otherwise returns -1. Constraints: - The product_ids list has at most 10^6 elements. - The product_ids list contains integers between 1 and 10^9. - The target_id is an integer between 1 and 10^9. Performance Requirement: - The function should have a time complexity of O(n) and space complexity of O(1). Example: >>> find_product_index([23, 45, 1, 67, 34], 67) 3 >>> find_product_index([23, 45, 1, 67, 34], 100) -1 for index, product_id in enumerate(product_ids): if product_id == target_id: return index return -1"},{"question":"# Matrix Transformation Challenge Objective: You are provided with a matrix represented as a list of lists. The task is to perform various transformations on this matrix as specified. Transformation Functions: 1. **rotate_clockwise(matrix)**: - Rotates the matrix 90 degrees clockwise. - **Input**: A 2D matrix (list of lists). - **Output**: A new 2D matrix rotated 90 degrees clockwise. 2. **rotate_counterclockwise(matrix)**: - Rotates the matrix 90 degrees counterclockwise. - **Input**: A 2D matrix (list of lists). - **Output**: A new 2D matrix rotated 90 degrees counterclockwise. 3. **top_left_invert(matrix)**: - Inverts the matrix top-left-wise. - **Input**: A 2D matrix (list of lists). - **Output**: A new 2D matrix where rows are reversed. 4. **bottom_left_invert(matrix)**: - Inverts the matrix bottom-left-wise. - **Input**: A 2D matrix (list of lists). - **Output**: A new 2D matrix where rows and columns are reversed. Task: 1. Implement the above four transformation functions. 2. Ensure your solutions handle edge cases such as empty matrices and are efficient in both time and space. Constraints: - The matrix dimensions will not exceed 1000x1000. - Each element in the matrix is an integer between -10^9 and 10^9. Example: ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9], ] # Expected Outputs print(rotate_clockwise(matrix)) # Output -> [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3], # ] print(rotate_counterclockwise(matrix)) # Output -> [ # [3, 6, 9], # [2, 5, 8], # [1, 4, 7], # ] print(top_left_invert(matrix)) # Output -> [ # [1, 2, 3], # [4, 5, 6], # [7, 8, 9], # ] print(bottom_left_invert(matrix)) # Output -> [ # [9, 8, 7], # [6, 5, 4], # [3, 2, 1], # ] ```","solution":"def rotate_clockwise(matrix): Rotates a given 2D matrix 90 degrees clockwise. return [list(row) for row in zip(*matrix[::-1])] def rotate_counterclockwise(matrix): Rotates a given 2D matrix 90 degrees counterclockwise. return [list(row) for row in zip(*matrix)][::-1] def top_left_invert(matrix): Inverts the matrix top-left-wise, i.e., each row is reversed. return [row[::-1] for row in matrix] def bottom_left_invert(matrix): Inverts the matrix bottom-left-wise, i.e., both rows and columns are reversed. return [row[::-1] for row in matrix[::-1]]"},{"question":"# Scenario You are tasked with implementing a network routing system for a telecommunication company, ensuring optimal bandwidth utilization without any data loss. The network is modeled as a directed graph where nodes represent network routers/switches and edges represent communication channels with specific bandwidth capacities. # Coding Task Implement a function `max_flow` to determine the maximum flow from a given source node to a sink node in the network using each of the three algorithms - Ford-Fulkerson, Edmonds-Karp, and Dinic\'s Algorithm. # Function Signature ```python def max_flow(capacity: List[List[int]], source: int, sink: int, algorithm: str) -> int: Determines the maximum flow in the network from source to sink using the specified algorithm. Args: capacity: 2D list representing the capacity matrix of the graph (capacity[i][j] is the capacity of edge from i to j). source: Integer representing the source node. sink: Integer representing the sink node. algorithm: String specifying which algorithm to use (\\"ford_fulkerson\\", \\"edmonds_karp\\", \\"dinic\\"). Returns: An integer representing the maximum flow from source to sink. ``` # Inputs * `capacity` (List[List[int]]): A 2D list (n x n) where `capacity[i][j]` represents the capacity of the channel from router `i` to router `j`. * `source` (int): Index of the source node in the graph. * `sink` (int): Index of the sink node in the graph. * `algorithm` (str): Specifies the algorithm to use for computing maximum flow. It can be either \\"ford_fulkerson\\", \\"edmonds_karp\\", or \\"dinic\\". # Outputs * An integer representing the maximum flow from the source node to the sink node. # Constraints * The graph will have at most 500 vertices. * All capacities are non-negative integers. * Nodes are 0-indexed. # Performance Requirements * The function should efficiently compute the maximum flow for graphs up to the constraint limits. * Analyze and report the time and space complexities for each algorithm in the implementation. # Example Usage ```python capacity = [ [0, 10, 10, 0, 0, 0], [0, 0, 5, 15, 0, 0], [0, 0, 0, 10, 10, 0], [0, 0, 0, 0, 10, 10], [0, 0, 0, 15, 0, 10], [0, 0, 0, 0, 0, 0] ] source = 0 sink = 5 assert max_flow(capacity, source, sink, \\"ford_fulkerson\\") == 20 assert max_flow(capacity, source, sink, \\"edmonds_karp\\") == 20 assert max_flow(capacity, source, sink, \\"dinic\\") == 20 ```","solution":"from collections import deque def bfs(C, F, source, sink, P): visited = [False] * len(C) queue = deque([source]) visited[source] = True while queue: u = queue.popleft() for v, cap in enumerate(C[u]): if not visited[v] and cap - F[u][v] > 0: # Residual capacity available queue.append(v) P[v] = u visited[v] = True if v == sink: return True return False def dfs(C, F, u, sink, P): visited = [False] * len(C) stack = [(u, float(\'Inf\'))] while stack: v, flow = stack.pop() visited[v] = True if v == sink: return flow for next_v in range(len(C)): if not visited[next_v] and C[v][next_v] - F[v][next_v] > 0: stack.append((next_v, min(flow, C[v][next_v] - F[v][next_v]))) P[next_v] = v return 0 def ford_fulkerson(C, source, sink): n = len(C) F = [[0] * n for _ in range(n)] max_flow = 0 while True: P = [-1] * n found_flow = dfs(C, F, source, sink, P) if found_flow == 0: break max_flow += found_flow v = sink while v != source: u = P[v] F[u][v] += found_flow F[v][u] -= found_flow v = u return max_flow def edmonds_karp(C, source, sink): n = len(C) F = [[0] * n for _ in range(n)] max_flow = 0 while True: P = [-1] * n if not bfs(C, F, source, sink, P): break path_cap = float(\'Inf\') s = sink while s != source: path_cap = min(path_cap, C[P[s]][s] - F[P[s]][s]) s = P[s] v = sink while v != source: u = P[v] F[u][v] += path_cap F[v][u] -= path_cap v = u max_flow += path_cap return max_flow def dinic_bfs(C, F, source, sink, level): queue = deque([source]) level[source] = 0 while queue: u = queue.popleft() for v in range(len(C)): if level[v] < 0 and C[u][v] - F[u][v] > 0: level[v] = level[u] + 1 queue.append(v) return level[sink] >= 0 def dinic_dfs(C, F, u, sink, flow, level): if u == sink: return flow for v in range(len(C)): if level[v] == level[u] + 1 and C[u][v] - F[u][v] > 0: min_flow = min(flow, C[u][v] - F[u][v]) pushed_flow = dinic_dfs(C, F, v, sink, min_flow, level) if pushed_flow > 0: F[u][v] += pushed_flow F[v][u] -= pushed_flow return pushed_flow return 0 def dinic(C, source, sink): n = len(C) F = [[0] * n for _ in range(n)] max_flow = 0 while True: level = [-1] * n if not dinic_bfs(C, F, source, sink, level): break while True: flow = dinic_dfs(C, F, source, sink, float(\'Inf\'), level) if flow == 0: break max_flow += flow return max_flow def max_flow(capacity, source, sink, algorithm): if algorithm == \\"ford_fulkerson\\": return ford_fulkerson(capacity, source, sink) elif algorithm == \\"edmonds_karp\\": return edmonds_karp(capacity, source, sink) elif algorithm == \\"dinic\\": return dinic(capacity, source, sink) else: raise ValueError(\\"Unknown algorithm specified\\")"},{"question":"You are tasked with writing a function `two_sum_indices` that finds the indices of two numbers in an array such that they add up to a given target. You need to ensure that the solution is efficient and correctly handles edge cases. Function Signature ```python def two_sum_indices(array: List[int], target: int) -> Tuple[int, int]: ``` # Input * `array` - A list of integers, for example `[2, 7, 11, 15]`. * `target` - An integer representing the target sum, e.g. `9`. # Output * Returns a tuple of two integers indicating the indices of the two numbers that add up to the target. * If there are no such indices, return `None`. # Constraints * Each input will have exactly one solution. * The same element cannot be used twice. # Examples 1. **Example 1:** ```python array = [2, 7, 11, 15] target = 9 two_sum_indices(array, target) ``` - Output: `(0, 1)` 2. **Example 2:** ```python array = [3, 2, 4] target = 6 two_sum_indices(array, target) ``` - Output: `(1, 2)` 3. **Example 3:** ```python array = [3, 3] target = 6 two_sum_indices(array, target) ``` - Output: `(0, 1)` # Guidance * Consider edge cases such as: * Arrays with one element or empty arrays (though the problem guarantees one solution, discussing edge cases is a good practice). * Negative numbers in the array. * Multiple pairs satisfying the condition — the solution must adhere to the first pair found. * Aim to solve the problem in O(n) time complexity with O(n) auxiliary space using a hash table.","solution":"from typing import List, Tuple, Optional def two_sum_indices(array: List[int], target: int) -> Optional[Tuple[int, int]]: Finds indices of the two numbers in the array that add up to the given target sum. num_to_index = {} for index, num in enumerate(array): complement = target - num if complement in num_to_index: return (num_to_index[complement], index) num_to_index[num] = index return None"},{"question":"# Problem: Insertion Sort with Binary Search Helper You are tasked with implementing the `insertion_sort` algorithm, which sorts an array of integers in ascending order. To achieve this efficiently, you will use the provided `search_insert` function to find the appropriate index for each element. Function Signature ```python def insertion_sort(array: List[int]) -> List[int]: ``` Input - A single list `array` of integers (1 ≤ len(array) ≤ 10^4). Output - A list of integers representing the sorted array. Constraints - The array may contain duplicate elements. - Solve the problem with a focus on clarity and efficiency. - You are required to use the `search_insert` function to help determine the insertion index. Example ```python # Example 1 input = [4, 3, 2, 1] output = [1, 2, 3, 4] # Example 2 input = [10, 8, 12, 5, 6, 2] output = [2, 5, 6, 8, 10, 12] ``` Explanation 1. For each element in the input list, find its appropriate index in the partially sorted list. 2. Insert the element at the identified index. 3. Continue the process until the entire list is sorted. Details The method `search_insert` has been provided to help identify the correct position for insertion: ```python def search_insert(array, val): low = 0 high = len(array) - 1 while low <= high: mid = low + (high - low) // 2 if val > array[mid]: low = mid + 1 else: high = mid - 1 return low ``` Use this method within your `insertion_sort` function to help place each element correctly. Below is a placeholder for your function: ```python from typing import List def insertion_sort(array: List[int]) -> List[int]: result = [] for value in array: index = search_insert(result, value) result.insert(index, value) return result ``` Implement and test the `insertion_sort` function to ensure it works correctly.","solution":"from typing import List def search_insert(array: List[int], val: int) -> int: low = 0 high = len(array) - 1 while low <= high: mid = low + (high - low) // 2 if val > array[mid]: low = mid + 1 else: high = mid - 1 return low def insertion_sort(array: List[int]) -> List[int]: result = [] for value in array: index = search_insert(result, value) result.insert(index, value) return result"},{"question":"--- Scenario: You are working on a data normalization task where the input is a string containing characters that may reoccur. Your goal is to implement a function that processes the given string and returns a new string with all reoccurring characters removed, maintaining the order of their first occurrence. Task: Write a function `normalize_string(input_string: str) -> str` that takes a single string as input and returns a new string with all duplicate characters removed, retaining only the first occurrence of each character in the original order. Input: - A single string `input_string` (1 ≤ len(input_string) ≤ 10^6). Assume the string contains only ASCII characters. Output: - A single string with no duplicate characters, in the order of their first appearance. Constraints: - The solution should efficiently handle strings up to 1 million characters in length. - Maintain the order of characters as they first appear. Example: ```python normalize_string(\\"abracadabra\\") # Returns \\"abrcd\\" normalize_string(\\"google\\") # Returns \\"gole\\" normalize_string(\\"abcabcabc\\") # Returns \\"abc\\" normalize_string(\\"\\") # Returns \\"\\" ``` Function Signature: ```python def normalize_string(input_string: str) -> str: # Your code here ``` ---","solution":"def normalize_string(input_string: str) -> str: Returns a string with all duplicate characters removed, retaining their first occurrence in the original order. seen = set() result = [] for char in input_string: if char not in seen: seen.add(char) result.append(char) return \'\'.join(result)"},{"question":"You are given a directed graph represented as an adjacency list in the form of a dictionary. Your task is to implement a function to detect if there is at least one cycle in the graph. Your solution should make use of Depth-First Search (DFS) and follow the principles of the provided traversal states. Function Signature ```python def contains_cycle(graph: dict) -> bool: ``` # Input - `graph`: A dictionary where keys are vertex identifiers (strings) and values are lists of identifiers (strings) representing directed edges. # Output - Return `True` if the graph contains a cycle, `False` otherwise. # Constraints - The graph will have at most 1000 vertices. - Each vertex identifier is a non-empty string of lowercase and uppercase English letters (up to 10 characters). - The graph may have no edges or self-loops. # Performance Requirement - The solution must handle graphs with up to 1000 vertices efficiently. # Example ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'D\'], \'C\': [\'F\'], \'D\': [\'E\', \'F\'], \'E\': [\'B\'], \'F\': [] } print(contains_cycle(graph)) # Output: True graph = { \'A\': [\'B\'], \'B\': [\'C\'], \'C\': [\'D\'], \'D\': [] } print(contains_cycle(graph)) # Output: False graph = {} print(contains_cycle(graph)) # Output: False graph = { \'A\': [\'A\'] } print(contains_cycle(graph)) # Output: True ``` Scenario Imagine you are tasked with analyzing the dependencies in a system\'s job processing queue to detect potential deadlocks. Each job and its required dependencies are provided in the form of a directed graph. Implementing this cycle detection function will help ensure the job queue doesn\'t have any circular dependencies causing the system to hang.","solution":"def contains_cycle(graph: dict) -> bool: Function to detect if there is any cycle in the given directed graph. Uses Depth-First Search (DFS) to identify cycles. WHITE, GRAY, BLACK = 0, 1, 2 color = {node: WHITE for node in graph} def dfs(node): if color[node] == GRAY: return True if color[node] == BLACK: return False color[node] = GRAY for neighbor in graph.get(node, []): if dfs(neighbor): return True color[node] = BLACK return False for node in graph: if color[node] == WHITE: if dfs(node): return True return False"},{"question":"Scenario You are part of a team developing a text decoder for a messaging application. The messages are encoded in a specific format to compress the text and save space. Your task is to implement the decoding functionality based on the given rules. Problem Statement Design a function `decode_string` that takes an encoded string `s` and returns its decoded version. The encoding format follows the specified rule: `k[encoded_string]`, where the `encoded_string` inside the square brackets is to be repeated exactly `k` times. The input is guaranteed to be valid, meaning no extra whitespaces or malformed brackets. # Function Signature ```python def decode_string(s: str) -> str: pass ``` # Input - A single string `s` (1 <= len(s) <= 30,000) which represents the encoded string. # Output - A single string representing the decoded version of the input. # Constraints - The input string `s` will always be well-formed. - `k` is a positive integer. - No extraneous digits or whitespaces are present in the input string. # Examples ```python assert decode_string(\\"3[a]2[bc]\\") == \\"aaabcbc\\" assert decode_string(\\"3[a2[c]]\\") == \\"accaccacc\\" assert decode_string(\\"2[abc]3[cd]ef\\") == \\"abcabccdcdcdef\\" ``` # Requirements: - The solution should efficiently handle the decoding process even for large strings with deeply nested encodings. - Be mindful of the stack size and ensure it is optimized for memory usage.","solution":"def decode_string(s: str) -> str: stack = [] current_num = 0 current_string = \'\' for char in s: if char.isdigit(): current_num = current_num * 10 + int(char) elif char == \'[\': stack.append((current_string, current_num)) current_string = \'\' current_num = 0 elif char == \']\': last_string, num = stack.pop() current_string = last_string + num * current_string else: current_string += char return current_string"},{"question":"**Problem Description:** You have been tasked with creating a more efficient sorting algorithm inspired by Bogo Sort\'s conceptual simplicity but without its inefficiencies. Specifically, implement a sorting algorithm that uses randomness to its advantage. You must write a Python function that sorts an array efficiently while incorporating a randomized element. Your task is to implement **\'Randomized Quick Sort\'**, a variant of the well-known Quick Sort algorithm that uses a random element to select the pivot. # Input * A list `arr` of `n` integers where `1 ≤ n ≤ 10^5` and `-10^9 ≤ arr[i] ≤ 10^9` for all `i`. # Output * A sorted list of integers in ascending order. # Constraints * Your implementation should have an expected time complexity of O(n log n). * You should handle edge cases such as empty arrays or arrays with duplicate values gracefully. # Function Signature ```python def randomized_quick_sort(arr: List[int]) -> List[int]: pass ``` # Example ```python assert randomized_quick_sort([3, 6, 2, 9, 0]) == [0, 2, 3, 6, 9] assert randomized_quick_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] assert randomized_quick_sort([]) == [] assert randomized_quick_sort([3]) == [3] assert randomized_quick_sort([3, 2, 3, 1, 2]) == [1, 2, 2, 3, 3] ``` # Performance Requirements * Your function should be efficient and able to handle arrays close to the upper constraint in reasonable time. # Note * You may not use Python’s built-in sort functionality. * Think carefully about the choice of pivot and how to partition the array efficiently.","solution":"import random from typing import List def randomized_quick_sort(arr: List[int]) -> List[int]: Sorts the input list `arr` using the Randomized Quick Sort algorithm. if len(arr) <= 1: return arr def partition(arr, low, high): pivot_index = random.randint(low, high) arr[pivot_index], arr[high] = arr[high], arr[pivot_index] pivot = arr[high] i = low - 1 for j in range(low, high): if arr[j] < pivot: i += 1 arr[i], arr[j] = arr[j], arr[i] arr[i + 1], arr[high] = arr[high], arr[i + 1] return i + 1 def quick_sort(arr, low, high): if low < high: pi = partition(arr, low, high) quick_sort(arr, low, pi - 1) quick_sort(arr, pi + 1, high) quick_sort(arr, 0, len(arr) - 1) return arr"},{"question":"You are working on a search application to efficiently locate ranges of user activity in a log file that is sorted by timestamp. Write a function that, given a sorted list of integers `nums` and an integer `target`, returns the starting and ending position of the target value in the list. Your function should return `[-1, -1]` if the target is not found. # Input: - `nums`: A list of integers sorted in ascending order. - `target`: An integer representing the element to be searched for in `nums`. # Output: - A list of two integers representing the starting and ending positions of the target in `nums`. If the target is not present in the list, return `[-1, -1]`. # Constraints: - The length of `nums` will be in the range `[0, 10^5]`. - `-10^9 <= nums[i] <= 10^9` - `-10^9 <= target <= 10^9` # Performance Requirements: - Your algorithm should run in O(log n) time for the search phase and O(n) for the potential subsequent scan. # Example: ```python Input: nums = [5,7,7,8,8,8,10], target = 8 Output: [3,5] Input: nums = [5,7,7,8,8,8,10], target = 11 Output: [-1, -1] ``` # Function Signature: ```python def search_range(nums, target): :type nums: List[int] :type target: int :rtype: List[int] ``` Notes: - Ensure your solution handles empty arrays effectively. - Optimize the search for both the starting and ending index of the target element.","solution":"def search_range(nums, target): Returns the starting and ending position of the target value in the list nums. If the target is not found, returns [-1, -1]. def find_bound(nums, target, find_first): left, right = 0, len(nums) - 1 bound = -1 while left <= right: mid = (left + right) // 2 if nums[mid] == target: bound = mid if find_first: right = mid - 1 else: left = mid + 1 elif nums[mid] < target: left = mid + 1 else: right = mid - 1 return bound start = find_bound(nums, target, True) if start == -1: return [-1, -1] end = find_bound(nums, target, False) return [start, end]"},{"question":"You are given a sorted list of integers in increasing order. Your task is to implement a function that finds the index of the last occurrence of a given target number. # Function Signature ```python def find_last_occurrence(arr: List[int], target: int) -> int: ``` # Input * `arr` (List[int]): A list of integers sorted in increasing order. (1 <= len(arr) <= 10^5, -10^6 <= arr[i] <= 10^6) * `target` (int): The integer whose last occurrence we want to find. (-10^6 <= target <= 10^6) # Output * `int`: The index of the last occurrence of the target in the list. If the target is not found, return -1. # Constraints * The list is sorted in increasing order. * Optimize for time complexity, ideally aiming for O(log n). # Example ```python assert find_last_occurrence([1, 2, 2, 2, 3, 4, 5], 2) == 3 assert find_last_occurrence([1, 1, 1, 1, 1, 1, 1], 1) == 6 assert find_last_occurrence([1, 2, 3, 4, 5, 6, 7], 10) == -1 assert find_last_occurrence([1, 2, 3, 3, 3, 3, 4], 3) == 5 ``` # Constraints and Edge Cases * Handle scenarios where the target is not present. * Handle scenarios where the entire array is the target number. * Handle large inputs efficiently. You are required to write the complete function based on the above specifications. Do not use built-in functions that directly solve the problem (e.g., `index`, `find`, etc.).","solution":"from typing import List def find_last_occurrence(arr: List[int], target: int) -> int: Returns the index of the last occurrence of the target in the sorted list arr. If the target is not found, returns -1. left, right = 0, len(arr) - 1 result = -1 while left <= right: mid = left + (right - left) // 2 if arr[mid] == target: result = mid left = mid + 1 elif arr[mid] < target: left = mid + 1 else: right = mid - 1 return result"},{"question":"# Coding Problem: Maximize Sequence of 1s by Flipping a Bit Context You are given an integer which, when represented in binary, may contain a series of 0s and 1s. By flipping exactly one 0 to 1, you want to determine the maximum length of the contiguous sequence of 1s that can be achieved. Task Write a function `flip_bit_longest_seq(num: int) -> int` that takes an integer as input and returns the length of the longest sequence of 1s possible by flipping exactly one bit from 0 to 1. Input - An integer `num`. Output - An integer representing the maximum length of contiguous sequence of 1s after flipping one bit. Constraints - The input integer is non-negative. Example 1. **Input**: `1775` - **Binary Representation**: `11011101111` - **Output**: `8` because flipping the second 0 from the right would result in `11011111111`. 2. **Input**: `12` - **Binary Representation**: `1100` - **Output**: `3` because flipping the second 0 would result in `1110`. Edge Cases - If the input integer is `0`, the output should be `1` as flipping the only bit will result in `1`. - For integers that already have all bits set to `1`, the result should account for the length of this sequence plus one (e.g., `15` or `1111` will result in `5`). Constraints and Assumptions - Consider the bit length to be the necessary number of digits to represent the number in binary. Here, students are expected to demonstrate familiarity with bitwise operations while efficiently managing data at the bit level for optimized performance.","solution":"def flip_bit_longest_seq(num: int) -> int: Returns the length of the longest sequence of 1s that can be achieved by flipping one bit from 0 to 1. if num == 0: return 1 current_length = 0 previous_length = 0 max_length = 0 while num != 0: if (num & 1) == 1: # Current bit is 1 current_length += 1 else: # Current bit is 0 previous_length = 0 if (num & 2) == 0 else current_length current_length = 0 max_length = max(max_length, previous_length + current_length + 1) num >>= 1 return max_length"},{"question":"# Scenario: You are working with datasets where most elements occur in pairs except for two unique elements that appear only once. Your goal is to find these two unique elements efficiently. # Coding Question: Implement a function `find_unique_elements(nums)` that takes a list `nums` of integers, where exactly two integers appear only once and all other integers appear exactly twice. The function should return a list containing the two unique integers. Your solution must have a time complexity of O(N) and a space complexity of O(1). # Function Signature: ```python def find_unique_elements(nums: List[int]) -> List[int]: ``` # Parameters: * `nums` (List[int]): A list of integers, where all integers except two appear exactly twice. The list will contain at least two unique elements. # Output: * Returns a List[int] containing the two integers that appear only once. The order of elements in the result list is not important. # Constraints: * Time complexity must be O(N). * Space complexity must be O(1). * The input list will always contain exactly two unique elements and at least 2 elements total. # Example: ```python nums = [1, 2, 1, 3, 2, 5] print(find_unique_elements(nums)) # Output: [3, 5] or [5, 3] ``` # Explanation: 1. Use XOR operations to identify `A ^ B`, where `A` and `B` are the two unique numbers. 2. Find a significant bit to separate `A` and `B`. 3. Using the identified bit, partition the list into two groups and isolate `A` and `B` by further XOR operations within each group. # Requirements: Ensure to handle edge cases like: * Very large or very small input sizes. * Lists where elements are not necessarily in sorted order. **Good Luck!**","solution":"from typing import List def find_unique_elements(nums: List[int]) -> List[int]: xor_result = 0 for num in nums: xor_result ^= num # Find a significant bit position where A and B differ significant_bit = 1 while (xor_result & significant_bit) == 0: significant_bit <<= 1 A = 0 B = 0 for num in nums: if num & significant_bit: A ^= num else: B ^= num return [A, B]"},{"question":"Given the implementation of a BST Iterator, your task is to extend its functionality to include a method that returns the K-th smallest element in the Binary Search Tree (BST). The method `kth_smallest(self, k: int) -> int` should be implemented. # Function Specifications * Method signature: `def kth_smallest(self, k: int) -> int` * Input: - `self`: The instance of the BSTIterator class. - `k` (int): An integer representing the position (1-indexed) of the smallest element required. * Output: - An integer representing the K-th smallest element in the BST if it exists, or -1 if it does not. # Input and Output Examples ```python # Example 1: # Let\'s assume the BST is structured as follows: # 5 # / # 3 7 # / / # 2 4 6 8 # BSTIterator should return the nodes in the order: 2, 3, 4, 5, 6, 7, 8 root = TreeNode(5) root.left = TreeNode(3) root.right = TreeNode(7) root.left.left = TreeNode(2) root.left.right = TreeNode(4) root.right.left = TreeNode(6) root.right.right = TreeNode(8) iterator = BSTIterator(root) print(iterator.kth_smallest(3)) # Output: 4 # Example 2: # For edge case of a tree with a single node: root = TreeNode(10) iterator = BSTIterator(root) print(iterator.kth_smallest(1)) # Output: 10 print(iterator.kth_smallest(2)) # Output: -1 ``` # Constraints * The binary tree is a BST. * Tree nodes contain unique values. * `k` ranges from 1 to the number of nodes in the tree. * You may assume the BST will contain at least one node. # Notes * Your implementation should ensure that the iterator traversal still works as intended after using `kth_smallest()`. * Consider how your iterator state management (using stack) will handle repeated calls gracefully.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None class BSTIterator: def __init__(self, root: TreeNode): self.stack = [] self.push_all(root) def next(self) -> int: node = self.stack.pop() self.push_all(node.right) return node.val def has_next(self) -> bool: return len(self.stack) > 0 def push_all(self, node: TreeNode): while node: self.stack.append(node) node = node.left def kth_smallest(self, k: int) -> int: count = 0 stack_backup = list(self.stack) # backup the stack state while self.has_next(): val = self.next() count += 1 if count == k: # Restore the stack state for the iterator self.stack = stack_backup return val # Restore the stack state for the iterator self.stack = stack_backup return -1"},{"question":"You\'re tasked with developing a simulation for a navigational app. The app needs to handle undo and redo operations efficiently using stack data structures. Requirements: 1. **Design a Class called `NavigationStack`**: - Utilize both array and linked list-based stack implementations provided. - Manage `undo` and `redo` operations separately. 2. **Methods to Implement**: - `move_to(new_location)`: Moves to a new location, pushing the state to the undo stack and clearing the redo stack. - `undo()`: Reverts to the last location, pushing the current state to the redo stack. - `redo()`: Re-applies the last undone move, pushing the current state to the undo stack. - `current_location()`: Returns the current location. - `print_history()`: Prints both undo and redo histories (states only). Input/Output: - **Input**: * No direct input as it\'s class methods. - **Output**: * Method calls with relevant parameters. * Example States: - `NavigationStack.move_to(\'A\')` - `NavigationStack.move_to(\'B\')` - `NavigationStack.undo()` -> should move back to \'A\'. - `NavigationStack.redo()` -> should move forward to \'B\'. - `NavigationStack.current_location()` -> returns \'B\'. - `NavigationStack.print_history()` -> prints states in undo and redo. Constraints: - Assume all locations are strings. - Undo and redo stacks must use different stack implementations (one using ArrayStack, another using LinkedListStack). # Implementation: ```python class NavigationStack: def __init__(self): self.undo_stack = ArrayStack() self.redo_stack = LinkedListStack() self.current = None def move_to(self, new_location): if self.current is not None: self.undo_stack.push(self.current) self.current = new_location self.redo_stack = LinkedListStack() # Clear redo stack def undo(self): if self.undo_stack.is_empty(): raise IndexError(\\"No moves to undo\\") self.redo_stack.push(self.current) self.current = self.undo_stack.pop() def redo(self): if self.redo_stack.is_empty(): raise IndexError(\\"No moves to redo\\") self.undo_stack.push(self.current) self.current = self.redo_stack.pop() def current_location(self): return self.current def print_history(self): print(\\"Undo history: \\", list(self.undo_stack)) print(\\"Redo history: \\", list(self.redo_stack)) ``` Testing Scenarios: - Test basic move, undo, and redo operations. - Verify the history printout and current location. - Handle edge cases like multiple undoes/redoes beyond available state.","solution":"class Stack: def __init__(self): self.items = [] def push(self, item): self.items.append(item) def pop(self): if self.is_empty(): raise IndexError(\\"Pop from empty stack\\") return self.items.pop() def peek(self): if self.is_empty(): raise IndexError(\\"Peek from empty stack\\") return self.items[-1] def is_empty(self): return len(self.items) == 0 def __iter__(self): return iter(self.items) def __repr__(self): return repr(self.items) class Node: def __init__(self, data=None, next=None): self.data = data self.next = next class LinkedListStack: def __init__(self): self.head = None def push(self, item): new_node = Node(item, self.head) self.head = new_node def pop(self): if self.is_empty(): raise IndexError(\\"Pop from empty stack\\") popped_item = self.head.data self.head = self.head.next return popped_item def peek(self): if self.is_empty(): raise IndexError(\\"Peek from empty stack\\") return self.head.data def is_empty(self): return self.head is None def __iter__(self): current = self.head while current: yield current.data current = current.next def __repr__(self): return repr([item for item in self]) class NavigationStack: def __init__(self): self.undo_stack = Stack() # Array stack self.redo_stack = LinkedListStack() # Linked list stack self.current = None def move_to(self, new_location): if self.current is not None: self.undo_stack.push(self.current) self.current = new_location self.redo_stack = LinkedListStack() # Clear redo stack def undo(self): if self.undo_stack.is_empty(): raise IndexError(\\"No moves to undo\\") self.redo_stack.push(self.current) self.current = self.undo_stack.pop() def redo(self): if self.redo_stack.is_empty(): raise IndexError(\\"No moves to redo\\") self.undo_stack.push(self.current) self.current = self.redo_stack.pop() def current_location(self): return self.current def print_history(self): print(\\"Undo history: \\", list(self.undo_stack)) print(\\"Redo history: \\", list(self.redo_stack))"},{"question":"# Question: Implement a Stack in Python Context You\'re given the task of implementing a stack data structure which could either be based on arrays or linked lists. A stack is a fundamental data structure that operates on the principle of Last In, First Out (LIFO). You will need to implement the core functionalities of the stack as well as consider edge cases to ensure robustness. Objective - Implement the `ArrayStack` and `LinkedListStack` classes by extending the `AbstractStack` class provided, focusing on the methods `push`, `pop`, `peek`, and `is_empty`. Requirements 1. Define the `ArrayStack` class. - Initialize it with a fixed size. - Ensure it dynamically expands when the capacity is reached. - Implement `push`, `pop`, `peek`, and `is_empty` methods. 2. Define the `LinkedListStack` class. - Implement it using linked nodes. - Ensure it operates efficiently with push and pop operations. - Implement `push`, `pop`, `peek`, and `is_empty` methods. Input and Output - Ensure the implemented methods adhere to the following: - `push(item)`: takes any element and adds it to the stack. - `pop()`: returns the most recently added element and removes it from the stack. - `peek()`: returns the most recently added element without removing it. - `is_empty()`: returns a boolean indicating whether the stack is empty. Constraints - Do not use Python\'s built-in list methods like `append` or `pop` directly. - Ensure both implementations handle edge cases like stack overflows and underflows where applicable. Example ```python # ArrayStack usage as_stack = ArrayStack(size=3) as_stack.push(1) as_stack.push(2) as_stack.push(3) print(as_stack.pop()) # Output: 3 print(as_stack.peek()) # Output: 2 print(as_stack.is_empty()) # Output: False # LinkedListStack usage ll_stack = LinkedListStack() ll_stack.push(10) ll_stack.push(20) print(ll_stack.peek()) # Output: 20 print(ll_stack.pop()) # Output: 20 print(ll_stack.is_empty()) # Output: False ``` Guidelines - Ensure your stack correctly handles edge cases such as popping from an empty stack. - Write clear and concise implementations. - Comment your code if necessary to explain your logic.","solution":"class AbstractStack: def push(self, item): raise NotImplementedError def pop(self): raise NotImplementedError def peek(self): raise NotImplementedError def is_empty(self): raise NotImplementedError class ArrayStack(AbstractStack): def __init__(self, size=10): self.size = size self.stack = [None] * self.size self.top = -1 def push(self, item): if self.top + 1 >= self.size: self._resize() self.top += 1 self.stack[self.top] = item def pop(self): if self.is_empty(): raise IndexError(\\"Pop from empty stack\\") item = self.stack[self.top] self.stack[self.top] = None self.top -= 1 return item def peek(self): if self.is_empty(): raise IndexError(\\"Peek from empty stack\\") return self.stack[self.top] def is_empty(self): return self.top == -1 def _resize(self): new_size = self.size * 2 new_stack = [None] * new_size for i in range(self.size): new_stack[i] = self.stack[i] self.size = new_size self.stack = new_stack class LinkedListStack(AbstractStack): class Node: def __init__(self, data): self.data = data self.next = None def __init__(self): self.top = None def push(self, item): new_node = self.Node(item) new_node.next = self.top self.top = new_node def pop(self): if self.is_empty(): raise IndexError(\\"Pop from empty stack\\") item = self.top.data self.top = self.top.next return item def peek(self): if self.is_empty(): raise IndexError(\\"Peek from empty stack\\") return self.top.data def is_empty(self): return self.top is None"},{"question":"# Matrix Transformation Challenge You are given a task to implement four different types of matrix transformations as part of an image processing application. The transformations are rotation and inversion operations on a 2D matrix (list of lists in Python). Your implementation should efficiently handle various sizes and shapes of matrices. Write four functions to perform the following transformations: 1. **rotate_clockwise(matrix)** - Rotates the input matrix by 90 degrees clockwise. 2. **rotate_counterclockwise(matrix)** - Rotates the input matrix by 90 degrees counterclockwise. 3. **top_left_invert(matrix)** - Reflects the matrix over its main diagonal (top-left to bottom-right). 4. **bottom_left_invert(matrix)** - Reflects the matrix over its antidiagonal (bottom-left to top-right). # Requirements: - Each function should take a 2D list `matrix` as input and return a new 2D list representing the transformed matrix. - The input matrix can be of size `n x m` (non-square matrices should be handled). - The functions should not modify the original matrix. # Constraints: - (1 leq n, m leq 100) - Matrix elements can be any integer values. # Input and Output: - **Input**: A 2D list `matrix` of size `n x m`. - **Output**: A new 2D list representing the transformed matrix according to the specified operation. # Example: ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] ``` - `rotate_clockwise(matrix)` should return: ```python [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] ``` - `rotate_counterclockwise(matrix)` should return: ```python [ [3, 6, 9], [2, 5, 8], [1, 4, 7] ] ``` - `top_left_invert(matrix)` should return: ```python [ [1, 4, 7], [2, 5, 8], [3, 6, 9] ] ``` - `bottom_left_invert(matrix)` should return: ```python [ [9, 6, 3], [8, 5, 2], [7, 4, 1] ] ``` Write the functions `rotate_clockwise`, `rotate_counterclockwise`, `top_left_invert`, and `bottom_left_invert` to complete this task.","solution":"def rotate_clockwise(matrix): Rotates the input matrix by 90 degrees clockwise. return [list(row) for row in zip(*matrix[::-1])] def rotate_counterclockwise(matrix): Rotates the input matrix by 90 degrees counterclockwise. return [list(row) for row in zip(*matrix)][::-1] def top_left_invert(matrix): Reflects the matrix over its main diagonal (top-left to bottom-right). return [list(row) for row in zip(*matrix)] def bottom_left_invert(matrix): Reflects the matrix over its antidiagonal (bottom-left to top-right). return [list(row) for row in zip(*matrix[::-1])][::-1]"},{"question":"# Problem: Serialize and Deserialize Binary Search Tree You need to implement two functions `serialize_bst` and `deserialize_bst` to convert a Binary Search Tree (BST) into a string and vice versa. 1. `serialize_bst(root: TreeNode) -> str`: This function takes the root of a BST and returns a string representation of the BST, using preorder traversal and `#` for nulls. 2. `deserialize_bst(data: str) -> TreeNode`: This function takes a string representation of a BST (as produced by `serialize_bst`), and reconstructs the original BST structure. # Input and Output 1. **serialize_bst** - **Input**: `TreeNode` – the root of the binary search tree. - **Output**: a `str` – a single space-separated string containing serialized values of the BST. 2. **deserialize_bst** - **Input**: `str` – the string representation of the BST. - **Output**: `TreeNode` – the root of the reconstructed binary search tree. # Constraints - The values of `TreeNode.val` are unique. - The number of nodes in the tree is in the range [0, 10^4]. - Allowed values for `TreeNode.val` are in the range [-10^4, 10^4]. - You must implement both methods to work in O(n) time complexity. # Example ```python # Construct the following BST # 4 # / # 2 6 # / / # 1 3 5 7 bst = TreeNode(4) bst.left = TreeNode(2) bst.right = TreeNode(6) bst.left.left = TreeNode(1) bst.left.right = TreeNode(3) bst.right.left = TreeNode(5) bst.right.right = TreeNode(7) # Serialization: serialized = serialize_bst(bst) print(serialized) # Example Output: \\"4 2 1 # # 3 # # 6 5 # # 7 # #\\" # Deserialization: reconstructed_bst = deserialize_bst(serialized) assert serialize_bst(reconstructed_bst) == serialized # Should be True ``` The solution requires careful handling of input formatting and efficient traversal, adhering to BST properties.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def serialize_bst(root): Encodes a tree to a single string. def helper(node): if not node: return \\"#\\" return f\\"{node.val} {helper(node.left)} {helper(node.right)}\\" return helper(root) def deserialize_bst(data): Decodes your encoded data to tree. def helper(values): val = next(values) if val == \\"#\\": return None node = TreeNode(int(val)) node.left = helper(values) node.right = helper(values) return node values = iter(data.split()) return helper(values)"},{"question":"**Pattern Search in Large Text using Rabin-Karp Algorithm** You are given a lengthy text document and need to find the first occurrence of a given pattern within this text. Implement the Rabin-Karp pattern matching algorithm to return the starting index of this first occurrence, or `None` if the pattern is not found. # Function Signature ```python def find_pattern(pattern: str, text: str) -> int: # Your implementation here ``` # Input - `pattern`(str): The pattern to search for within the text. (1 ≤ len(pattern) ≤ 10^5) - `text`(str): The large text where the pattern must be searched. (1 ≤ len(text) ≤ 10^6) # Output - An integer representing the starting index of the first occurrence of the pattern in the text, or `None` if the pattern is not found. # Constraints - The text and the pattern will only consist of lowercase English letters. # Example ```python assert find_pattern(\\"abc\\", \\"abdabcbabc\\") == 3 assert find_pattern(\\"aaa\\", \\"aaabaa\\") == 0 assert find_pattern(\\"xyz\\", \\"abcabcabc\\") == None ``` Write a well-tested function demonstrating: 1. Efficient rolling hash calculation. 2. Proper handling of edge cases. 3. Confirmation of pattern matches despite possible hash collisions.","solution":"def find_pattern(pattern: str, text: str) -> int: Finds the first occurrence of a pattern in the given text using the Rabin-Karp algorithm. Returns the starting index of the first occurrence, or None if not found. # Base cases if pattern == \\"\\": return 0 if text == \\"\\" else None if len(pattern) > len(text): return None # Constants base = 256 # Number of characters in the input alphabet prime_mod = 101 # A prime number for hashing pat_len = len(pattern) text_len = len(text) # Compute the hash value of the pattern and the first window of text pat_hash = 0 text_hash = 0 h = 1 # The value of base^(pat_len-1) for i in range(pat_len - 1): h = (h * base) % prime_mod for i in range(pat_len): pat_hash = (base * pat_hash + ord(pattern[i])) % prime_mod text_hash = (base * text_hash + ord(text[i])) % prime_mod # Slide the pattern over text one by one for i in range(text_len - pat_len + 1): if pat_hash == text_hash: # If the hash values match, check the actual characters if text[i:i + pat_len] == pattern: return i # Compute the hash value for the next window of text if i < text_len - pat_len: text_hash = (base * (text_hash - ord(text[i]) * h) + ord(text[i + pat_len])) % prime_mod # We might get a negative value of text_hash, converting it to positive if text_hash < 0: text_hash += prime_mod return None"},{"question":"# Matrix Multiplication Implementation Problem: You are tasked with implementing a function to multiply two matrices. The matrices will be given as a list of lists, where each inner list represents a row in the matrix. Your function should handle basic validation, such as ensuring the matrices can be multiplied (the number of columns in the first matrix should be equal to the number of rows in the second matrix). If they can\'t be multiplied, your function should raise an appropriate exception. Input: - Two matrices in the form of lists of lists (`multiplicand` and `multiplier`). - `multiplicand`: List[List[int]], dimensions `m x n` - `multiplier`: List[List[int]], dimensions `n x p` Output: - A resulting matrix in the form of a list of lists with dimensions `m x p`. Example: ```python multiplicand = [ [1, 2], [3, 4] ] multiplier = [ [2, 0], [1, 2] ] # Result should be: # [ # [4, 4], # [10, 8] # ] ``` Constraints: - Each element of the matrices will be an integer. - Matrices will be well-formed (rectangular with consistent row lengths). Performance Requirements: - Ensure that the function runs within a reasonable time for matrices up to dimensions 100x100. - You may not use third-party libraries like `NumPy`. Function Signature: ```python def multiply(multiplicand: list, multiplier: list) -> list: :type multiplicand: List[List[int]] :type multiplier: List[List[int]] :rtype: List[List[int]] # Implement your code here ``` Implement the `multiply` function that executes the described matrix multiplication logic.","solution":"def multiply(multiplicand, multiplier): Multiplies two matrices and returns the resultant matrix :param multiplicand: List[List[int]], the first matrix with dimensions m x n :param multiplier: List[List[int]], the second matrix with dimensions n x p :return: List[List[int]], resulting matrix with dimensions m x p # Get dimensions of the matrices m = len(multiplicand) n = len(multiplicand[0]) p = len(multiplier[0]) # Check if the multiplication is possible if n != len(multiplier): raise ValueError(\\"The number of columns in the first matrix must equal the number of rows in the second matrix\\") # Initialize the result matrix with zeros result = [[0] * p for _ in range(m)] # Perform matrix multiplication for i in range(m): for j in range(p): for k in range(n): result[i][j] += multiplicand[i][k] * multiplier[k][j] return result"},{"question":"You are tasked with implementing a sorting algorithm described below and composing a function that can integrate this process within a larger application. # Task Write a Python function `custom_bubble_sort(arr: List[int], k: int) -> List[int]` that performs a variant of bubble sort. This variant will sort only the first `k` elements in the provided list `arr` while the rest of the list should remain in its original order. # Input * `arr`: A list of integers. For example, `[6, 2, 9, 3, 5, 8, 7]`. * `k`: An integer indicating the number of elements to sort in the list. For example, `4`. # Output * A list of integers where only the first `k` elements are sorted in non-decreasing order and the rest of the elements appear in their original order. # Constraints * `0 <= len(arr) <= 10^3` * `1 <= k <= len(arr)` # Example ```python >>> custom_bubble_sort([6, 2, 9, 3, 5, 8, 7], 4) [2, 3, 6, 9, 5, 8, 7] ``` # Requirements * Ensure that the sorting is stable. * Your solution should have a time complexity of O(k^2).","solution":"from typing import List def custom_bubble_sort(arr: List[int], k: int) -> List[int]: Sorts only the first k elements of the list arr using a bubble sort variant. Args: - arr (List[int]): The list of integers to be partially sorted. - k (int): The number of elements to sort within the list. Returns: - List[int]: The list with the first k elements sorted. for i in range(k): for j in range(0, k-i-1): if arr[j] > arr[j+1]: arr[j], arr[j+1] = arr[j+1], arr[j] return arr"},{"question":"# Coding Challenge: Custom Base Conversion Functions Given two functions, `int_to_base` and `base_to_int`, which facilitate number conversions between integers and their string representations in various bases, your task is to implement a customized version of these functions that meet specific constraints and handle edge cases effectively. # Function Specifications `custom_int_to_base(num, base)` **Input:** - `num` (int): The integer number to be converted. It can be zero, positive, or negative. - `base` (int): The base to which the number should be converted. It varies from 2 to 36. **Output:** - Returns (str): A string representation of `num` in the specified `base`. **Constraints:** - `1 <= abs(num) <= 10^6`. - `2 <= base <= 36`. **Requirements:** - Handle zero and negative numbers correctly. - Ensure the resulting string uses case-insensitive characters (if applicable). `custom_base_to_int(str_to_convert, base)` **Input:** - `str_to_convert` (string): The string representation of a number in the given `base`. The string can include digits and alphabetical characters. - `base` (int): The base of the provided `str_to_convert`. It varies from 2 to 36. **Output:** - Returns (int): An integer representing the converted value of `str_to_convert` in base 10. **Constraints:** - The input string correctly conforms to the specified base. - `2 <= base <= 36`. **Requirements:** - Handle edge cases such as incorrect character input. # Example ```python print(custom_int_to_base(5, 2)) # \'101\' print(custom_int_to_base(-15, 16)) # \'-F\' print(custom_base_to_int(\'101\', 2)) # 5 print(custom_base_to_int(\'F\', 16)) # 15 ``` # Additional Notes - Make sure your functions are efficient and handle the constraints effectively. - Think about edge cases like zero and negative numbers for `int_to_base`. - For `base_to_int`, consider how to handle and validate inputs correctly.","solution":"def custom_int_to_base(num, base): Convert an integer to its string representation in the specified base. if base < 2 or base > 36: raise ValueError(\\"Base must be between 2 and 36\\") if num == 0: return \\"0\\" negative = num < 0 num = abs(num) digits = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" result = \\"\\" while num > 0: result = digits[num % base] + result num = num // base if negative: result = \\"-\\" + result return result def custom_base_to_int(str_to_convert, base): Convert a string representation of a number in the given base to an integer. if base < 2 or base > 36: raise ValueError(\\"Base must be between 2 and 36\\") str_to_convert = str_to_convert.strip().upper() if str_to_convert[0] == \'-\': negative = True str_to_convert = str_to_convert[1:] else: negative = False digits = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" value = 0 for char in str_to_convert: if char not in digits[:base]: raise ValueError(f\\"Invalid character for base {base}: {char}\\") value = value * base + digits.index(char) if negative: value = -value return value"},{"question":"# Question: Optimized Counting Sort Background You have been given an array of integers that includes both positive and negative numbers. Your task is to implement an optimized version of the Counting Sort algorithm to handle this scenario efficiently. Function Signature ```python def custom_counting_sort(arr: List[int]) -> List[int]: pass ``` Input * `arr`: A list of integers containing both positive and negative numbers. Output * A sorted list of integers in non-decreasing order. Constraints * The elements of the input array can range between -1000 and 1000. * The input array length will be at most 100,000. Example 1. Input: `[3, -2, -1, 0, -2, 3, 4, 2]` Output: `[-2, -2, -1, 0, 2, 3, 3, 4]` Explanation 1. Input: `[3, -2, -1, 0, -2, 3, 4, 2]` - There are negative numbers in the array. - You need to handle the negative numbers by shifting the range of the values to always be positive during the counting process. - Finally, shift back to reconstruct the sorted array. Notes * You may use an auxiliary array for counting the occurrences of each integer within the given range. * Ensure that your implementation is optimized for both time and space efficiency.","solution":"def custom_counting_sort(arr): Performs an optimized counting sort on the input list containing both positive and negative integers. Parameters: arr (list of int): The list of integers to be sorted. Returns: list of int: The sorted list of integers in non-decreasing order. # Edge case: if the array is empty, simply return it if not arr: return arr # Determine the range of the array min_val = min(arr) max_val = max(arr) # Initialize the counting array range_of_numbers = max_val - min_val + 1 count = [0] * range_of_numbers # Store the count of each number in the count array for num in arr: count[num - min_val] += 1 # Create the output array sorted_arr = [] for i in range(range_of_numbers): sorted_arr.extend([i + min_val] * count[i]) return sorted_arr"},{"question":"Optimized Search in Sorted Dynamic Arrays You are given a sorted array `arr` consisting of unique integers and an integer `key`. Implement the function `dynamic_ternary_search` that searches the array for `key` using an optimized ternary search algorithm. In cases where the array size increases dynamically (max N+1000), your implementation should ensure the search efficiency maintains its logarithmic characteristics. Function Signature ```python def dynamic_ternary_search(arr: List[int], key: int) -> int: ``` Input - `arr` (List[int]): A sorted list of unique integers. - `key` (int): The integer value to search for in the array. Output - Returns an integer representing the index of `key` in the array. If `key` is not found, returns -1. Constraints - The array size can dynamically increase up to 1000 extra elements. - Array will be sorted in ascending order. - Efficient search performance is critical. Examples Example 1: ```python arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] key = 5 print(dynamic_ternary_search(arr, key)) # Output: 4 ``` Example 2: ```python arr = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100] key = 35 print(dynamic_ternary_search(arr, key)) # Output: -1 ``` Example 3: ```python arr = [1, 5, 9, 13, 17, 21, 25, 29] key = 21 print(dynamic_ternary_search(arr, key)) # Output: 5 ``` Performance Requirement - Your implementation should maintain the efficiency of ternary search. - Ensure handling of dynamically increasing array size up to N+1000 elements gracefully without compromising expected performance.","solution":"from typing import List def dynamic_ternary_search(arr: List[int], key: int) -> int: Performs a ternary search on a sorted array to find the key. Returns the index of the key if found, otherwise returns -1. def ternary_search(l, r): if r >= l: third = (r - l) // 3 mid1 = l + third mid2 = r - third if arr[mid1] == key: return mid1 if arr[mid2] == key: return mid2 if key < arr[mid1]: return ternary_search(l, mid1 - 1) elif key > arr[mid2]: return ternary_search(mid2 + 1, r) else: return ternary_search(mid1 + 1, mid2 - 1) return -1 return ternary_search(0, len(arr) - 1)"},{"question":"You are tasked with implementing a function `string_multiply` that multiplies two non-negative integers represented as strings and returns the product as a string. You should not use any built-in big integer libraries nor convert the strings directly to integers. # Function Signature: ```python def string_multiply(num1: str, num2: str) -> str: ``` # Input: * `num1`: A non-negative integer represented as a string. The length of `num1` is less than 110. * `num2`: A non-negative integer represented as a string. The length of `num2` is less than 110. # Output: * A string representing the product of the two integers `num1` and `num2`. # Constraints: 1. The length of both `num1` and `num2` is less than 110. 2. Both `num1` and `num2` contain only digits 0-9. 3. Both `num1` and `num2` do not contain any leading zero except when the number is zero itself. # Performance Requirements: The solution should optimally handle the given constraints and efficiently compute the product for the maximum possible input sizes. # Example: ```python print(string_multiply(\\"123\\", \\"456\\")) # Output: \\"56088\\" print(string_multiply(\\"2\\", \\"3\\")) # Output: \\"6\\" print(string_multiply(\\"0\\", \\"12345\\")) # Output: \\"0\\" ``` # Scenario and Context: You are developing an ancient calculator that does not support large numbers using built-in libraries. Instead, the calculator processes numbers given as strings. Implement a `string_multiply` function similarly to the traditional multiplication method you learned in school. The solution should handle large inputs efficiently without converting them directly into integers. # Notes: * Pay special attention to handling edge cases like multiplication by zero. * Consider memory and performance optimizations where appropriate.","solution":"def string_multiply(num1: str, num2: str) -> str: if num1 == \\"0\\" or num2 == \\"0\\": return \\"0\\" n, m = len(num1), len(num2) result = [0] * (n + m) num1, num2 = num1[::-1], num2[::-1] for i in range(n): for j in range(m): product = int(num1[i]) * int(num2[j]) result[i + j] += product result[i + j + 1] += result[i + j] // 10 result[i + j] %= 10 while len(result) > 1 and result[-1] == 0: result.pop() return \'\'.join(map(str, result[::-1]))"},{"question":"Imagine you are working on a text processing toolkit that needs to identify common patterns between two strings. One of these strings, `pattern`, contains all unique characters to simplify the matching process. Your task is to write a function that finds the length of the longest common subsequence between the input strings `text` and `pattern`. # Function Signature ```python def longest_common_subsequence_length(text: str, pattern: str) -> int: pass ``` # Input * `text` (string, 1 <= len(text) <= 10^5): The primary string in which we need to find the subsequence. * `pattern` (string, 1 <= len(pattern) <= 10^5): The reference string with unique characters. # Output * Returns an integer, representing the length of the longest common subsequence. # Constraints * The `pattern` string is guaranteed to contain all unique characters. * Your solution should aim to have a time complexity in the order of (O(n log n)). # Examples ```python assert longest_common_subsequence_length(\\"abc\\", \\"aebdcf\\") == 3 assert longest_common_subsequence_length(\\"abcdxyz\\", \\"xyzabcd\\") == 4 assert longest_common_subsequence_length(\\"abcde\\", \\"fghij\\") == 0 assert longest_common_subsequence_length(\\"abcdefghij\\", \\"jihgfedcba\\") == 1 ``` # Guidelines 1. Analyze the structure of both strings to devise an efficient matching scheme. 2. Consider optimizing string lookups and matches using efficient data structures or algorithms like binary search. 3. Ensure to handle edge cases, such as non-overlapping characters.","solution":"def longest_common_subsequence_length(text: str, pattern: str) -> int: def binary_search(seq, x): l, r = 0, len(seq) while l < r: mid = (l + r) // 2 if seq[mid] < x: l = mid + 1 else: r = mid return l index_map = {char: i for i, char in enumerate(pattern)} filtered_indices = [index_map[char] for char in text if char in index_map] if not filtered_indices: return 0 lis = [] for idx in filtered_indices: pos = binary_search(lis, idx) if pos == len(lis): lis.append(idx) else: lis[pos] = idx return len(lis)"},{"question":"K-th Smallest Element in a Binary Search Tree Given a binary search tree (BST), implement a function to find the k-th smallest element in the BST. You are provided with class definitions for a `Node` and a BST. Your task is to write a function `kth_smallest` within the `Solution` class that adheres to the following specifications: Function Signature ```python def kth_smallest(self, root: Node, k: int) -> int: ``` Input - `root`: the root node of a binary search tree. - `k`: an integer, k-th smallest element to find. Output - Returns an integer, the value of the k-th smallest element in the BST. Constraints - Each node in the BST will have a unique value. - All elements are integers. - Assume k is valid (1 ≤ k ≤ number of nodes in the BST), but handle cases where `k` may be incorrect gracefully by returning -1 or raising a meaningful exception. Performance Requirements - The solution should be efficient in both time and space, ideally utilizing in-order traversal properties of the BST. Example Consider the following BST: ``` 10 / 5 15 / / 3 7 12 17 ``` For k = 3, the 3rd smallest element is 7. Implementation Constraints - Do not use any built-in sorting functions. - Use traversal methods to determine the k-th smallest element. Scenario Imagine you are implementing a search feature for an e-commerce website that uses a BST to store product ratings. You need to quickly find the k-th smallest rating to show in user reviews.","solution":"class Node: def __init__(self, value): self.value = value self.left = None self.right = None class Solution: def kth_smallest(self, root: Node, k: int) -> int: Returns the k-th smallest element in the BST. self.k = k self.result = None def in_order_traversal(node): if node is None: return in_order_traversal(node.left) self.k -= 1 if self.k == 0: self.result = node.value return in_order_traversal(node.right) in_order_traversal(root) if self.result is not None: return self.result else: return -1 # Handling of invalid k (if required)"},{"question":"# Scenario You have been hired as a software engineer at a company that processes large datasets. One of your tasks is to clean up the data by ensuring there are no duplicate entries in linked lists representing various datasets. # Task Implement an efficient function to remove duplicates from a singly linked list. You need to implement both of the following methods and analyze their trade-offs: 1. `remove_dups(head)`: This method should use a hash set to facilitate removing duplicates. 2. `remove_dups_without_set(head)`: This method should not use any extra data structures to remove duplicates. # Function Signature ```python class Node: def __init__(self, val=None): self.val = val self.next = None def remove_dups(head: Node) -> None: pass def remove_dups_without_set(head: Node) -> None: pass ``` # Input - A Node object `head` representing the head of a linked list. Each node contains an integer value. - The linked list can have up to 10^5 nodes. # Output - Both functions should modify the linked list in place to remove duplicates. - The functions do not need to return any value. # Constraints - The elements in the linked list are integers in the range [-10^6, 10^6]. - You must meet the given time and space complexity requirements for each function. # Example ```python # Linked list: 1 -> 2 -> 2 -> 3 -> 4 -> 4 -> 5 # Using remove_dups remove_dups(head) # Resulting Linked list: 1 -> 2 -> 3 -> 4 -> 5 # Using remove_dups_without_set remove_dups_without_set(head) # Resulting Linked list: 1 -> 2 -> 3 -> 4 -> 5 ``` # Note Focus on handling edge cases such as: - Empty linked list (head is None). - Linked list with a single element. - Linked list where all elements are identical.","solution":"class Node: def __init__(self, val=None): self.val = val self.next = None def remove_dups(head: Node) -> None: if not head: return current = head seen = set() seen.add(current.val) while current.next: if current.next.val in seen: current.next = current.next.next else: seen.add(current.next.val) current = current.next def remove_dups_without_set(head: Node) -> None: if not head: return current = head while current: runner = current while runner.next: if runner.next.val == current.val: runner.next = runner.next.next else: runner = runner.next current = current.next"},{"question":"Objective: Implement an enhanced version of Prim\'s algorithm that returns not only the minimum spanning tree cost but also the edges in the minimum spanning tree. Problem Description: You are given a connected, undirected graph `graph` represented as a dictionary. The keys are nodes, and the values are lists of tuples where each tuple contains a connection cost and an adjacent node. Implement the function `prims_minimum_spanning_with_edges` to find the minimum spanning tree of the graph. The function should return a tuple where the first element is the total cost of the minimum spanning tree, and the second element is a list of all edges (as tuples) in the minimum spanning tree. Each edge should be represented as a tuple `(node1, node2, cost)` where `node1` and `node2` are the connected nodes, and `cost` is the connection cost. Function Signature: ```python def prims_minimum_spanning_with_edges(graph: dict) -> tuple: pass ``` Input: * `graph`: A dictionary where each key-value pair represents a node and its adjacency list of tuples `[(cost, adjacent_node), ...]`. Output: * Return a tuple `(min_cost, edges)` where: * `min_cost` is an integer representing the total cost of the minimum spanning tree. * `edges` is a list of tuples `(node1, node2, cost)` representing all edges in the minimum spanning tree. Constraints: * The graph is connected. * The graph does not have negative edge weights. * Use a priority queue for optimal performance. Example: ```python graph = { \'a\': [(7, \'b\'), (8, \'c\')], \'b\': [(7, \'a\'), (3, \'c\'), (6, \'d\')], \'c\': [(8, \'a\'), (3, \'b\'), (4, \'d\')], \'d\': [(6, \'b\'), (4, \'c\')] } print(prims_minimum_spanning_with_edges(graph)) # Expected output: (14, [(\'a\', \'b\', 7), (\'b\', \'c\', 3), (\'c\', \'d\', 4)]) ``` Notes: * The order of edges in the result does not matter. * Make sure to handle all edge cases efficiently and ensure the optimal performance of the algorithm.","solution":"import heapq def prims_minimum_spanning_with_edges(graph: dict) -> tuple: Returns the total cost of the minimum spanning tree and the list of edges in the MST using Prim\'s algorithm. if not graph: return 0, [] # Start with an arbitrary node, we\'ll use the first key in the dictionary. start_node = next(iter(graph)) visited = set([start_node]) min_edges = [] total_cost = 0 # Priority queue to select the edge with the minimum cost edges = [(cost, start_node, adj) for cost, adj in graph[start_node]] heapq.heapify(edges) while edges: cost, frm, to = heapq.heappop(edges) if to not in visited: visited.add(to) total_cost += cost min_edges.append((frm, to, cost)) for next_cost, next_adj in graph[to]: if next_adj not in visited: heapq.heappush(edges, (next_cost, to, next_adj)) return total_cost, min_edges"},{"question":"# Lowest Common Ancestor in a Binary Search Tree **Scenario:** You are working on a project involving a hierarchical organizational chart stored as a binary search tree (BST). Given this hierarchical structure, you are often required to determine the lowest common ancestor (LCA) of two employees in the company to understand the minimum level of supervision they both require. **Task:** Write a function `lowest_common_ancestor` that finds the LCA of two given nodes in a Binary Search Tree (BST). **Function Signature:** ```python def lowest_common_ancestor(root, p, q): :type root: Node :type p: Node :type q: Node :rtype: Node ``` **Input:** - `root`: the root node of the BST. - `p`: the first node. - `q`: the second node. **Output:** - Return the node that is the lowest common ancestor of nodes `p` and `q`. **Constraints:** - Assume all Node values are unique. - The BST is valid, and it contains `p` and `q`. **Example:** ```python class Node: def __init__(self, key): self.left = None self.right = None self.val = key # Define the tree structure root = Node(6) root.left = Node(2) root.right = Node(8) root.left.left = Node(0) root.left.right = Node(4) root.left.right.left = Node(3) root.left.right.right = Node(5) root.right.left = Node(7) root.right.right = Node(9) # Define nodes to find LCA for p = root.left # Node 2 q = root.right # Node 8 # Expected Output: Node 6 print(lowest_common_ancestor(root, p, q).val) ``` Create a function that behaves according to the above specification and passes the given example.","solution":"class Node: def __init__(self, key): self.left = None self.right = None self.val = key def lowest_common_ancestor(root, p, q): Returns the lowest common ancestor (LCA) of nodes p and q in the BST rooted at root. :type root: Node :type p: Node :type q: Node :rtype: Node # Start from the root node of the tree current = root while current: # If both p and q are greater than current node, LCA lies in right subtree if p.val > current.val and q.val > current.val: current = current.right # If both p and q are smaller than current node, LCA lies in left subtree elif p.val < current.val and q.val < current.val: current = current.left else: return current"},{"question":"# Problem Description You are required to implement a data structure `RandomizedSet` that supports the following operations in average O(1) time: 1. **insert(val)**: Inserts an item `val` to the set if not already present. 2. **remove(val)**: Removes an item `val` from the set if present. 3. **random_element**: Returns a random element from the current set of elements. Each element must have the same probability of being returned. # Input - The operations will be provided in sequence. - The inputs to the operations will be provided as a list of tuples, where the first item is a string representing the operation name (`\\"insert\\"`, `\\"remove\\"`, or `\\"random_element\\"`) and the second item (if any) is the integer value to be inserted or removed. # Output - The output should be a list containing the results of `\\"random_element\\"`. Other operations (`\\"insert\\"`, `\\"remove\\"`) should return `None`. # Constraints - Do not use any built-in Python set or dictionary methods that violate the O(1) constraint. - The values passed to insert and remove operations will be integers within the range -1000000 to 1000000. - There will be at most 10^5 operations. # Example Consider the following sequence of operations: ```python operations = [ (\\"insert\\", 1), (\\"insert\\", 2), (\\"random_element\\",), (\\"remove\\", 1), (\\"random_element\\",), (\\"remove\\", 2) ] ``` The expected output is a list of integers, which are the results of the `random_element` operations. # Function Signature ```python def process_operations(operations: List[Tuple[str, Optional[int]]]) -> List[int]: pass ```","solution":"from random import choice class RandomizedSet: def __init__(self): self.vals = [] self.val_to_index = {} def insert(self, val: int) -> None: if val not in self.val_to_index: self.vals.append(val) self.val_to_index[val] = len(self.vals) - 1 def remove(self, val: int) -> None: if val in self.val_to_index: last_val = self.vals[-1] idx = self.val_to_index[val] self.vals[idx] = last_val self.val_to_index[last_val] = idx self.vals.pop() del self.val_to_index[val] def random_element(self) -> int: return choice(self.vals) def process_operations(operations): randomized_set = RandomizedSet() result = [] for operation in operations: if operation[0] == \\"insert\\": randomized_set.insert(operation[1]) elif operation[0] == \\"remove\\": randomized_set.remove(operation[1]) elif operation[0] == \\"random_element\\": result.append(randomized_set.random_element()) return result"},{"question":"You are part of a team developing an intelligent recommendation system. Your task involves implementing the nearest neighbor algorithm to help categorize new data points based on existing labeled data. Implement a function `nearest_neighbor_classify` that, given an input vector and a labeled dataset, identifies the closest vector in the dataset using the Euclidean distance, and returns the label associated with that vector. Make sure your solution handles edge cases and runs efficiently for relatively large datasets. Function Signature ```python def nearest_neighbor_classify(x: Tuple[float], tSet: Dict[Tuple[float], Any]) -> Any: pass ``` Input * `x`: A tuple representing the input vector of `m` floats. * `tSet`: A dictionary where the keys are tuples representing labeled vectors of the same dimensionality `m` as `x`, and the values are the labels for these vectors. Output * Returns the label of the vector in `tSet` that is nearest to the vector `x`. Constraints * All vectors (including `x` and keys in `tSet`) have the same length. * The dataset (`tSet`) contains at least one vector. * All vector elements are float numbers. * `x` and keys of `tSet` are tuples with a length between 1 and 1000 (inclusive). Performance Requirements * Your solution should execute efficiently for datasets where the number of vectors in `tSet` can be up to 10^5. Example: ```python # Given a data vector and a labeled training set data_vector = (1.0, 2.0) training_set = { (1.1, 2.1): \\"A\\", (1.0, 2.2): \\"B\\", (0.9, 2.0): \\"C\\" } # The output should be \\"C\\" as the vector (0.9, 2.0) is closest to (1.0, 2.0) print(nearest_neighbor_classify(data_vector, training_set)) ``` **Note**: Consider all edge cases and ensure your implementation passes various test cases.","solution":"from typing import Tuple, Dict, Any import math def nearest_neighbor_classify(x: Tuple[float, ...], tSet: Dict[Tuple[float, ...], Any]) -> Any: Identifies the closest vector in the training set to the input vector using Euclidean distance, and returns the label associated with that vector. nearest_label = None min_distance = float(\'inf\') for t_vector, label in tSet.items(): distance = euclidean_distance(x, t_vector) if distance < min_distance: min_distance = distance nearest_label = label return nearest_label def euclidean_distance(vec1: Tuple[float, ...], vec2: Tuple[float, ...]) -> float: Helper function to calculate the Euclidean distance between two vectors return math.sqrt(sum((a - b) ** 2 for a, b in zip(vec1, vec2)))"},{"question":"**Problem Statement** You are given an array of integers `nums` where every element appears exactly twice, except for one element which appears only once. Write a function to find that single one. **Function Signature** ```python def find_unique(nums: List[int]) -> int: Finds the unique number in a list where every other number appears exactly twice. :param nums: List[int] - The list of integers :return: int - The single unique number ``` **Input** * `nums` is a list of integers where `2n + 1` elements are present (`n >= 0`). * Every element except one appears exactly twice. * The elements are guaranteed to fit within the integer range. **Output** * Return the single integer that appears exactly once in the array. **Constraints** * You must implement the solution with a linear runtime complexity. * Use constant extra space. **Example** ```python assert find_unique([2,2,1]) == 1 assert find_unique([4,1,2,1,2]) == 4 assert find_unique([1]) == 1 ``` **Notes** * The input array is non-empty and contains integers where only one integer appears a single time. Your algorithm should efficiently handle input arrays of varying sizes.","solution":"from typing import List def find_unique(nums: List[int]) -> int: Finds the unique number in a list where every other number appears exactly twice. :param nums: List[int] - The list of integers :return: int - The single unique number unique_number = 0 for num in nums: unique_number ^= num return unique_number"},{"question":"# Question You are tasked with creating a function `matrix_chain_order` to determine the optimal way to multiply a given chain of matrices. This function should minimize the total number of scalar multiplications required. This should be done using a bottom-up dynamic programming approach. The input to the function will be a list of integers, where each integer represents the dimension of the matrix sequence such that the matrix Ai has dimensions array[i-1] x array[i]. The output should be a tuple where the first element is a 2D list containing the minimum number of multiplications needed to compute the matrix product for each subproblem, and the second element is a 2D list that shows the index at which the optimal split occurs for each subproblem. Additionally, write a function `print_optimal_solution` to print the optimal sequence of matrix multiplications. # Requirements: * Implement the function `matrix_chain_order(array: List[int]) -> Tuple[List[List[int]], List[List[int]]]`. - **Input**: array (a list of integers representing matrix dimensions). - **Output**: A tuple of two 2D lists. The first list contains the computed minimum number of multiplications. The second contains split indices. * Implement the function `print_optimal_solution(optimal_solution: List[List[int]], i: int, j: int) -> None`. - **Input**: optimal_solution (2D list of split indices), i (starting index), j (ending index). - **Output**: None (but prints the optimal multiplication sequence). # Constraints: * The size of the input list `array` will not exceed 100. * The integers in the input list `array` will range between 1 and 1000. # Example: ```python array = [30, 35, 15, 5, 10, 20, 25] matrix, optimal_solution = matrix_chain_order(array) print(\\"No. of Operation required:\\", matrix[1][len(array) - 1]) print(\\"Optimal multiplication sequence:\\") print_optimal_solution(optimal_solution, 1, len(array) - 1) ``` Expected Output: ``` No. of Operation required: 15125 Optimal multiplication sequence: ((A1 (A2 A3)) ((A4 A5) A6)) ```","solution":"from typing import List, Tuple def matrix_chain_order(array: List[int]) -> Tuple[List[List[int]], List[List[int]]]: n = len(array) - 1 m = [[0 for _ in range(n + 1)] for _ in range(n + 1)] s = [[0 for _ in range(n + 1)] for _ in range(n + 1)] for l in range(2, n + 1): # l is the chain length for i in range(1, n - l + 2): j = i + l - 1 m[i][j] = float(\'inf\') for k in range(i, j): q = m[i][k] + m[k + 1][j] + array[i - 1] * array[k] * array[j] if q < m[i][j]: m[i][j] = q s[i][j] = k return m, s def print_optimal_solution(s: List[List[int]], i: int, j: int) -> None: if i == j: print(f\\"A{i}\\", end=\\"\\") else: print(\\"(\\", end=\\"\\") print_optimal_solution(s, i, s[i][j]) print(\\" \\", end=\\"\\") print_optimal_solution(s, s[i][j] + 1, j) print(\\")\\", end=\\"\\")"},{"question":"You\'re given a sorted list of integers in non-decreasing order and a target integer. Your task is to implement the Interpolation Search algorithm to efficiently find the target in the list. Return the index of the target if found, otherwise return -1. # Function Signature ```python def optimized_interpolation_search(array: List[int], search_key: int) -> int: ``` # Input - `array` (List[int]): A list of sorted integers in non-decreasing order (1 ≤ len(array) ≤ 10^5, -10^9 ≤ array[i] ≤ 10^9). - `search_key` (int): The integer to search for in the array. # Output - Return the index of the `search_key` in the array if found; otherwise, return -1. # Examples ```python print(optimized_interpolation_search([-25, -12, -1, 10, 12, 15, 20, 41, 55], -1)) # Output: 2 print(optimized_interpolation_search([5, 10, 12, 14, 17, 20, 21], 55)) # Output: -1 print(optimized_interpolation_search([5, 10, 12, 14, 17, 20, 21], -5)) # Output: -1 ``` # Constraints 1. Ensure your solution runs in the average case time complexity of O(log log n). 2. Handle edge cases such as an empty array and uniform data points efficiently. # Additional Requirements - Do not use any built-in search functions. - Optimize your solution to handle large inputs promptly. # Hint Consider how the initial formula for calculating the position adapts based on the uniform distribution of data and the specific constraints of the problem.","solution":"from typing import List def optimized_interpolation_search(array: List[int], search_key: int) -> int: low, high = 0, len(array) - 1 while low <= high and search_key >= array[low] and search_key <= array[high]: if low == high: if array[low] == search_key: return low return -1 pos = low + ((high - low) // (array[high] - array[low]) * (search_key - array[low])) if array[pos] == search_key: return pos if array[pos] < search_key: low = pos + 1 else: high = pos - 1 return -1"},{"question":"Consider two strings, `s` and `t`, which consist only of lowercase letters. String `t` is generated by randomly shuffling string `s` and adding one extra letter at a random position. Your task is to find the letter that was added to `t`. # Input: - Two strings `s` and `t` such that the length of `t` is `len(s) + 1`. - `1 <= len(s) <= 10^5` - Both strings `s` and `t` contain only lowercase English letters. # Output: - A single character representing the added letter. # Example: ```python Input: s = \\"abcd\\" t = \\"abecd\\" Output: \'e\' ``` # Explanation: The algorithm should identify that \'e\' is the extra character in `t` that is not present in `s`. # Constraints: - Both `s` and `t` consist of only lowercase alphabets. - The length of `t` is exactly one more than the length of `s`. # Implementation Hint: - You might want to use bitwise operations to find the differing character as efficiently as possible. # Function Signature: ```python def find_difference(s: str, t: str) -> str: # your implementation here ```","solution":"def find_difference(s: str, t: str) -> str: Find the extra letter that was added to t. result = 0 # XOR all characters of s for char in s: result ^= ord(char) # XOR all characters of t for char in t: result ^= ord(char) return chr(result)"},{"question":"Context In an attempt to deepen your understanding of various sorting algorithms and their efficiency, you have come across the concept of Exchange Sort. Exchange Sort is a straightforward algorithm but not the most efficient for large datasets. You will be implementing a variant of Exchange Sort that also allows for custom comparison functions, adding flexibility to the sorting process. Task Write a function `custom_exchange_sort(arr, compare)` that takes as input: 1. **arr**: A list of elements to be sorted. 2. **compare**: A comparison function that takes two arguments (`a` and `b`) and returns: - A negative number if `a` should come before `b`. - Zero if the order of `a` and `b` does not matter. - A positive number if `a` should come after `b`. Your task is to implement Exchange Sort using this comparison function. Function Signature ```python def custom_exchange_sort(arr, compare): pass ``` Input * **arr**: List of elements to be sorted. (1 <= len(arr) <= 1000) * **compare**: A comparison function for determining order. Output * A sorted list of elements based on the comparison function provided. Constraints * The comparison function will be provided as a correct callable function. * Elements in the list may be of any type that the comparison function can handle. Example ```python def compare_asc(a, b): return a - b def compare_desc(a, b): return b - a arr = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5] print(custom_exchange_sort(arr, compare_asc)) # Output: [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9] print(custom_exchange_sort(arr, compare_desc)) # Output: [9, 6, 5, 5, 5, 4, 3, 3, 2, 1, 1] ``` Performance Requirements * Time complexity must be no worse than O(n^2). * Space complexity must be O(1) - no additional list or array allocations allowed. Good luck, and be concise in your implementation!","solution":"def custom_exchange_sort(arr, compare): Sorts the given array using the Exchange Sort algorithm based on a custom comparison function. Parameters: arr (list): A list of elements to be sorted. compare (function): A comparison function that defines the order between elements. Returns: list: The sorted list. n = len(arr) for i in range(n - 1): for j in range(i + 1, n): if compare(arr[i], arr[j]) > 0: arr[i], arr[j] = arr[j], arr[i] return arr"},{"question":"# RSA Key Generation and Message Encryption/Decryption Given the RSA encryption system, your task is to implement the functions needed to generate an RSA key pair (public and private keys) and use these to encrypt and decrypt a given message. Task Implement the following functions: 1. `generate_key(k, seed=None)`: Generates an RSA public-private key pair where k is the number of bits in the modulus n. - **Input**: An integer `k`, and an optional integer `seed`. - **Output**: A tuple `(n, e, d)` where `n` is the modulus, `e` is the public exponent, and `d` is the private exponent. 2. `encrypt(data, e, n)`: Encrypts a given data using the public key `(e, n)`. - **Input**: An integer `data` to encrypt, public exponent `e`, and modulus `n`. - **Output**: The encrypted data as an integer. 3. `decrypt(data, d, n)`: Decrypts a given encrypted data using the private key `(d, n)`. - **Input**: An integer `data` to decrypt, private exponent `d`, and modulus `n`. - **Output**: The decrypted data as an integer. # Example ```python n, e, d = generate_key(16) data = 20 encrypted = encrypt(data, e, n) decrypted = decrypt(encrypted, d, n) assert data == decrypted ``` # Constraints * **Bit length (k)**: Must be at least 8 bits. * **Performance**: The function should be capable of generating keys and encrypting/decrypting data within a reasonable time for k ≤ 64. **You are encouraged to use libraries and built-in functions for efficiency, particularly for modular arithmetic operations.**","solution":"import random from sympy import isprime, mod_inverse def generate_key(k, seed=None): Generates an RSA public-private key pair where k is the number of bits in the modulus n. if seed: random.seed(seed) # Ensure k is at least 8 bits if k < 8: raise ValueError(\\"Bit length k must be at least 8 bits\\") # Generate two distinct k/2 bit primes, p and q t = k // 2 p = get_prime(t) q = get_prime(t) while q == p: q = get_prime(t) # Compute n and φ(n) n = p * q phi_n = (p - 1) * (q - 1) # Choose e such that 1 < e < φ(n) and gcd(e, φ(n)) = 1 e = get_coprime(phi_n) # Compute d such that e*d ≡ 1 (mod φ(n)) d = mod_inverse(e, phi_n) return n, e, d def get_prime(bits): while True: num = random.getrandbits(bits) if isprime(num): return num def get_coprime(phi_n): while True: e = random.randrange(2, phi_n) if gcd(e, phi_n) == 1: return e def gcd(a, b): while b: a, b = b, a % b return a def encrypt(data, e, n): Encrypts a given data using the public key (e, n). return pow(data, e, n) def decrypt(data, d, n): Decrypts a given encrypted data using the private key (d, n). return pow(data, d, n)"},{"question":"You are given a string `num` containing only digits from \'0\' to \'9\' and an integer `target`. Your task is to write a function `find_expressions` that generates all possible binary operator expressions (using operators +, -, *) between the digits of `num` such that they evaluate to the given `target`. # Input Format - `num`: A string of digits, length 1 <= len(num) <= 10. - `target`: An integer, the target value for the expressions. # Output Format - A list of strings where each string is a valid expression that evaluates to the target. # Constraints - All digits in `num` must be used exactly once in every expression. - Leading zeros in any number except for 0 itself are invalid and should be ignored. # Performance Requirements - Optimal solutions should aim to avoid unnecessary recalculations and terminate branches of calculations early if they cannot meet the target. # Example Given the string \\"123\\" and target 6, your function should return: ```python [\\"1+2+3\\", \\"1*2*3\\"] ``` Given the string \\"232\\" and target 8, your function should return: ```python [\\"2*3+2\\", \\"2+3*2\\"] ``` # Function Signature ```python def find_expressions(num: str, target: int) -> List[str]: pass ``` # Notes - Ensure that your solution efficiently handles edge cases like \\"00\\" with target 0. - Consider the use of helper functions and recursive solutions to generate possible expressions.","solution":"from typing import List def find_expressions(num: str, target: int) -> List[str]: def helper(path, pos, expr, prev_num, curr_total): if pos == len(num): if curr_total == target: results.append(path) return for i in range(pos, len(num)): current_str = num[pos:i + 1] current_num = int(current_str) if i != pos and num[pos] == \'0\': # Skip numbers with leading zero break if pos == 0: helper(current_str, i + 1, current_str, current_num, current_num) else: helper(path + \'+\' + current_str, i + 1, expr + \'+\' + current_str, current_num, curr_total + current_num) helper(path + \'-\' + current_str, i + 1, expr + \'-\' + current_str, -current_num, curr_total - current_num) helper(path + \'*\' + current_str, i + 1, expr + \'*\' + current_str, prev_num * current_num, curr_total - prev_num + prev_num * current_num) results = [] helper(\\"\\", 0, \\"\\", 0, 0) return results"},{"question":"Shell Sort Implementation **Scenario**: You are part of a team developing a high-performance custom sorting library for a financial application. You are tasked with implementing an efficient sorting algorithm that can handle nearly sorted datasets with a mixture of numerical values efficiently while maintaining low memory usage. **Objective**: Implement the Shell Sort algorithm in Python. **Function Signature**: ```python def shell_sort(arr: List[int]) -> List[int]: pass ``` **Input**: - `arr`: List of integers `(-10^6 <= arr[i] <= 10^6)` representing the array to be sorted. **Output**: - Returns the sorted list of integers in ascending order. **Constraints**: - The input list can contain between `0` and `10^5` elements. **Performance Requirements**: - Your solution should aim to achieve better performance than O(n^2) for reasonably sized datasets. **Instructions**: 1. Implement the Shell Sort algorithm using a gap sequence of your choice (consider using an efficient sequence like Knuth\'s sequence if possible). 2. Handle edge cases appropriately: empty list, single-element list, etc. 3. Ensure that your function modifies the input list in-place and returns the sorted list. 4. Test your implementation with various datasets to verify correctness and performance. **Example**: ```python assert shell_sort([64, 34, 25, 12, 22, 11, 90]) == [11, 12, 22, 25, 34, 64, 90] assert shell_sort([5, 2, 9, 1, 5, 6]) == [1, 2, 5, 5, 6, 9] assert shell_sort([]) == [] assert shell_sort([3]) == [3] assert shell_sort([10, 2, -5, -8, 0]) == [-8, -5, 0, 2, 10] ```","solution":"from typing import List def shell_sort(arr: List[int]) -> List[int]: Sorts an array using the Shell Sort algorithm. n = len(arr) gap = n // 2 while gap > 0: for i in range(gap, n): temp = arr[i] j = i while j >= gap and arr[j - gap] > temp: arr[j] = arr[j - gap] j -= gap arr[j] = temp gap //= 2 return arr"},{"question":"Scenario You are tasked to implement your own sorting algorithm for a digital card-collector application. This application often processes events where users want to see their collection in sorted order. The dataset of card values can sometimes be nearly sorted, but might also include random distributions. Context You need to implement the `insertion_sort` function, a sorting algorithm known for its good performance on nearly sorted data and its simplicity. Requirements Write a function `insertion_sort` that takes an array of integers and returns the array sorted in non-decreasing order. Ensure that the function works efficiently and correctly handles various edge cases. Input and Output Formats * **Input**: * The function should take a single parameter: - `arr`: A list of integers to be sorted. * **Output**: * The function should return a list of integers sorted in non-decreasing order. Constraints * The array size can be up to 10^4 elements. * Each integer in the array can be between -10^6 and 10^6. Performance Requirements * The algorithm should ideally run in O(n^2) time complexity for the worst-case scenario and O(n) for the best-case scenario. * The space complexity should be O(1) as the sorting should be done in-place. Function Signature ```python def insertion_sort(arr: List[int]) -> List[int]: pass ``` Example ```python # Example 1: input_arr = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5] sorted_arr = insertion_sort(input_arr) print(sorted_arr) # Output: [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9] # Example 2: input_arr = [10, -1, 0, 7, 4, 2, 5, 3] sorted_arr = insertion_sort(input_arr) print(sorted_arr) # Output: [-1, 0, 2, 3, 4, 5, 7, 10] ```","solution":"def insertion_sort(arr): Sorts the array arr using the insertion sort algorithm and returns the sorted array. :param arr: List[int] - list of integers to be sorted :return: List[int] - sorted list of integers in non-decreasing order for i in range(1, len(arr)): key = arr[i] j = i - 1 while j >= 0 and key < arr[j]: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key return arr"},{"question":"# Scenario In machine learning, especially in text analysis or recommendation systems, one often needs to determine the similarity between entities represented as vectors. One of the most commonly used similarity measures is **cosine similarity**. # Problem Statement Given two non-null 1D vectors (in form of lists) of equal length, implement a function `cosine_similarity` to calculate the cosine similarity between these vectors. # Input Format * Two lists of floating-point or integer numbers representing the vectors, `vec1` and `vec2`. * You can assume that both vectors are non-null and contain at least one element. # Output Format * A single floating-point number representing the cosine similarity, rounded to 6 decimal places. # Constraints 1. The lengths of the lists `vec1` and `vec2` will always be the same. 2. The lists may contain both positive and negative numbers. # Performance Requirements - Time Complexity: (O(n)), where (n) is the length of the input vectors. - Space Complexity: (O(1)) (ignoring input storage). # Example ```python cosine_similarity([1, 1, 1], [1, 2, -1]) # Output: 0.471405 ``` # Function Signature ```python def cosine_similarity(vec1: list, vec2: list) -> float: pass ``` * Ensure the output is rounded to 6 decimal places. * Raise a `ValueError` if the lengths of the two vectors are not equal.","solution":"import math def cosine_similarity(vec1: list, vec2: list) -> float: Calculate the cosine similarity between two vectors. Args: vec1 (list of float or int): The first vector. vec2 (list of float or int): The second vector. Returns: float: The cosine similarity between vec1 and vec2, rounded to 6 decimal places. Raises: ValueError: If vec1 and vec2 have different lengths. if len(vec1) != len(vec2): raise ValueError(\\"The vectors must be of equal length.\\") dot_product = 0.0 norm_vec1 = 0.0 norm_vec2 = 0.0 for v1, v2 in zip(vec1, vec2): dot_product += v1 * v2 norm_vec1 += v1 ** 2 norm_vec2 += v2 ** 2 if norm_vec1 == 0 or norm_vec2 == 0: return 0.0 cosine_similarity = dot_product / (math.sqrt(norm_vec1) * math.sqrt(norm_vec2)) return round(cosine_similarity, 6)"},{"question":"# Insertion Sort with Custom Comparison Context Insertion Sort is a simple and intuitive sorting algorithm that builds the final sorted array one item at a time. This question aims to assess your understanding of the insertion sort algorithm and your ability to extend it to handle more complex scenarios by using custom comparison functions. Task Implement the insertion sort algorithm, but this time allow for a custom comparison function that determines the ordering of elements. 1. The sorting function should accept a comparison function that takes two arguments (elements from the list) and returns `True` if the first argument should come before the second in the sorted order, and `False` otherwise. 2. The sorting function should sort the array in-place based on the provided comparison function. Function Signature ```python def custom_insertion_sort(arr, compare): Sort an array in-place using insertion sort and a custom comparison function. Parameters: arr (list): The list of elements to be sorted. compare (function): A comparison function. Returns: list: The sorted list. # Example comparison function # def ascending_compare(a, b): # return a < b # def descending_compare(a, b): # return a > b ``` Input and Output Formats - **Input**: A list `arr` of elements and a comparison function `compare`. - **Output**: The sorted list `arr`. Constraints 1. The elements of the list and the comparison function are such that the function will not run into any type errors. 2. The list can include integers, floats, or strings (assuming the comparison function can handle these types). Examples 1. Sorting integers in ascending order: ```python arr = [5, 2, 9, 1, 5, 6] compare = lambda a, b: a < b custom_insertion_sort(arr, compare) # Output: [1, 2, 5, 5, 6, 9] ``` 2. Sorting integers in descending order: ```python arr = [5, 2, 9, 1, 5, 6] compare = lambda a, b: a > b custom_insertion_sort(arr, compare) # Output: [9, 6, 5, 5, 2, 1] ``` 3. Sorting strings by length: ```python arr = [\\"apple\\", \\"fig\\", \\"banana\\", \\"kiwi\\"] compare = lambda a, b: len(a) < len(b) custom_insertion_sort(arr, compare) # Output: [\'fig\', \'kiwi\', \'apple\', \'banana\'] ```","solution":"def custom_insertion_sort(arr, compare): Sort an array in-place using insertion sort and a custom comparison function. Parameters: arr (list): The list of elements to be sorted. compare (function): A comparison function. Returns: list: The sorted list. for i in range(1, len(arr)): key = arr[i] j = i - 1 # Move elements of arr[0..i-1], that are greater (or smaller) than key, # to one position ahead of their current position based on the comparison function. while j >= 0 and not compare(arr[j], key): arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key return arr"},{"question":"Context: Gnome Sort, although not commonly used in industry due to its inefficiency with large data sets, serves as an excellent tool to understand sorting mechanics. It operates by comparing and moving elements in a manner akin to how a gnome would sort a line of flower pots by walking back and forth adjusting the order when necessary. Problem: You are given an array of integers. Your task is to implement the Gnome Sort algorithm to sort this array in ascending order. The function should work in-place, and you should not use any built-in sort functions. Requirements: - Implement a function `gnome_sort` that sorts the given array. - The function should take a list of integers as input and return the sorted list. - Ensure that the function handles all edge cases such as empty arrays, arrays with one element, and arrays with all identical elements. Input: - A list `arr` of integers, with 0 <= len(arr) <= 10^4 and -10^9 <= arr[i] <= 10^9. Output: - The sorted list of integers in ascending order. Example: ```python def gnome_sort(arr): # Your implementation here # Example usage: arr1 = [34, 2, 78, 1, 56, 45] sorted_arr1 = gnome_sort(arr1) print(f\\"Sorted array: {sorted_arr1}\\") # Expected Output: [1, 2, 34, 45, 56, 78] arr2 = [5, 3, 2, 2, 8, 1, 0] sorted_arr2 = gnome_sort(arr2) print(f\\"Sorted array: {sorted_arr2}\\") # Expected Output: [0, 1, 2, 2, 3, 5, 8] arr3 = [] sorted_arr3 = gnome_sort(arr3) print(f\\"Sorted array: {sorted_arr3}\\") # Expected Output: [] arr4 = [4] sorted_arr4 = gnome_sort(arr4) print(f\\"Sorted array: {sorted_arr4}\\") # Expected Output: [4] ``` Constraints: - Your implementation should have a time complexity of O(n^2) in the worst case. - The function should be implemented purely, without relying on any external libraries for sorting.","solution":"def gnome_sort(arr): Sorts the given array using Gnome Sort algorithm. Args: arr (list): List of integers to be sorted. Returns: list: Sorted list of integers. n = len(arr) index = 0 while index < n: if index == 0 or arr[index] >= arr[index - 1]: index += 1 else: arr[index], arr[index - 1] = arr[index - 1], arr[index] index -= 1 return arr # Example usage: arr1 = [34, 2, 78, 1, 56, 45] sorted_arr1 = gnome_sort(arr1) print(f\\"Sorted array: {sorted_arr1}\\") arr2 = [5, 3, 2, 2, 8, 1, 0] sorted_arr2 = gnome_sort(arr2) print(f\\"Sorted array: {sorted_arr2}\\") arr3 = [] sorted_arr3 = gnome_sort(arr3) print(f\\"Sorted array: {sorted_arr3}\\") arr4 = [4] sorted_arr4 = gnome_sort(arr4) print(f\\"Sorted array: {sorted_arr4}\\")"},{"question":"Context You are working on a project to develop a library of functions related to number theory and integer operations. One of the components that you need to implement involves efficiently determining the greatest common divisor (GCD), least common multiple (LCM), and handling other related bitwise operations. Task Implement the following functions fulfilling the specified requirements: 1. **gcd(a: int, b: int) -> int**: * Compute the greatest common divisor of two non-zero integers `a` and `b` using the Euclidean algorithm. * **Input**: Two integers `a` and `b`, with ( -10^9 leq a, b leq 10^9 ). * **Output**: An integer which is the GCD of `a` and `b`. 2. **lcm(a: int, b: int) -> int**: * Compute the least common multiple of two non-zero integers `a` and `b`. * **Input**: Two integers `a` and `b`, with ( 1 leq |a|, |b| leq 10^4 ). * **Output**: An integer which is the LCM of `a` and `b`. 3. **trailing_zero(x: int) -> int**: * Compute the number of trailing zero bits in a non-negative integer `x`. * **Input**: A non-negative integer `x`, with ( 0 leq x leq 10^9 ). * **Output**: An integer representing the number of trailing zero bits in `x`. 4. **gcd_bit(a: int, b: int) -> int**: * Compute the gcd using bitwise operations. * **Input**: Two non-negative integers `a` and `b`, with ( 1 leq a, b leq 10^9 ). * **Output**: An integer which is the GCD of `a` and `b`. Constraints * You should ensure that the input types and values are valid within the given ranges and constraints. * Optimize each function for the best performance considering both time and space complexities. Performance Requirements * Ensure all functions operate within a time complexity of (O(log(min(a, b)))) for GCD calculations and related operations. Example *Example 1*: ```python print(gcd(48, 18)) # Output: 6 print(gcd(-48, -18)) # Output: 6 print(lcm(4, 6)) # Output: 12 print(trailing_zero(40)) # Output: 3 print(gcd_bit(48, 18)) # Output: 6 ``` *Example 2*: ```python print(gcd(0, 18)) # Output: ValueError print(lcm(0, 4)) # Output: ValueError print(trailing_zero(0)) # Output: 0 print(gcd_bit(0, 18)) # Output: ValueError ``` **Note**: The examples highlight how your function should behave under ordinary and error-prone conditions. Good luck, and ensure your implementation adheres to clean code principles and best practices for optimized performance!","solution":"def gcd(a: int, b: int) -> int: Returns the greatest common divisor of a and b using the Euclidean algorithm. if a == 0 or b == 0: raise ValueError(\\"Inputs must be non-zero integers.\\") a, b = abs(a), abs(b) while b != 0: a, b = b, a % b return a def lcm(a: int, b: int) -> int: Returns the least common multiple of a and b. if a == 0 or b == 0: raise ValueError(\\"Inputs must be non-zero integers.\\") a, b = abs(a), abs(b) return a * b // gcd(a, b) def trailing_zero(x: int) -> int: Returns the number of trailing zero bits in the binary representation of x. if x == 0: return 0 count = 0 while (x & 1) == 0: x >>= 1 count += 1 return count def gcd_bit(a: int, b: int) -> int: Returns the greatest common divisor of a and b using bitwise operations. if a == 0 or b == 0: raise ValueError(\\"Inputs must be non-zero integers.\\") a, b = abs(a), abs(b) # GCD using the binary method if a == b: return a if a == 0: return b if b == 0: return a # a and b are both even if (a & 1) == 0 and (b & 1) == 0: return gcd_bit(a >> 1, b >> 1) << 1 # a is even, b is odd elif (a & 1) == 0: return gcd_bit(a >> 1, b) # a is odd, b is even elif (b & 1) == 0: return gcd_bit(a, b >> 1) # both a and b are odd, reduce larger number elif a > b: return gcd_bit(a - b, b) else: return gcd_bit(a, b - a)"},{"question":"Scenario You are managing a software system that frequently needs to verify the order of elements stored in linked lists, such as timestamps of events or ordered data entries. To ensure the correctness of these datasets, you need to implement a function that determines if a linked list of integers is sorted in non-decreasing order. Problem Statement Write a function `is_sorted(head)` that takes the head of a singly linked list of integers and returns `True` if the list is sorted in non-decreasing order, and `False` otherwise. Expected Input and Output Formats * **Input**: A singly linked list defined by a `ListNode` class. ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next ``` * **Output**: A boolean value (`True` or `False`). Constraints * You cannot modify the node values or the structure of the list. * The solution should have a time complexity of O(n) and space complexity of O(1). Example ```python # Example Linked List Node Class class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next # Example 1: # Input: head = ListNode(1, ListNode(2, ListNode(3, ListNode(4)))) # Output: True # Example 2: # Input: head = ListNode(1, ListNode(3, ListNode(2, ListNode(4)))) # Output: False # Implementation def is_sorted(head): if not head: return True current = head while current.next: if current.val > current.next.val: return False current = current.next return True ``` Implementation Notes: * Ensure to handle edge cases such as an empty list or a list with one element. * Assume the `ListNode` definition is provided. * The function must run within the specified time and space complexity constraints.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def is_sorted(head): Check if the linked list is sorted in non-decreasing order. if not head: return True current = head while current and current.next: if current.val > current.next.val: return False current = current.next return True"},{"question":"# FizzBuzz Algorithm Enhancement Problem Statement You are given a positive integer `N`. Write a function `enhanced_fizzbuzz(N)` that returns a list of strings representing the numbers from 1 to N under the following conditions: 1. If the number is a multiple of 3, replace it with \\"Fizz\\". 2. If the number is a multiple of 5, replace it with \\"Buzz\\". 3. If the number is a multiple of both 3 and 5, replace it with \\"FizzBuzz\\". 4. Otherwise, keep the number as a string. Additionally, enhance the function to handle the following: 1. If `N` is less than 1, raise a `ValueError` with the message \\"N must be greater than or equal to 1\\". 2. If `N` is `None`, raise a `TypeError` with the message \\"N cannot be None\\". Function Signature ```python def enhanced_fizzbuzz(N: int) -> List[str]: pass ``` Input * `N` (integer): A positive integer (N >= 1). Output * Return a list of strings reflecting the transformations described above. Constraints * `1 <= N <= 10^6` Example ```python assert enhanced_fizzbuzz(15) == [\'1\', \'2\', \'Fizz\', \'4\', \'Buzz\', \'Fizz\', \'7\', \'8\', \'Fizz\', \'Buzz\', \'11\', \'Fizz\', \'13\', \'14\', \'FizzBuzz\'] assert enhanced_fizzbuzz(1) == [\'1\'] assert enhanced_fizzbuzz(0) # Raises ValueError with message \\"N must be greater than or equal to 1\\" assert enhanced_fizzbuzz(None) # Raises TypeError with message \\"N cannot be None\\" ``` Constraints and Performance Requirements * Your solution should efficiently handle a very large value of N, up to 10^6. * Consider the readability and structure of your code. * Ensure your solution passes all edge cases and handles error scenarios appropriately.","solution":"def enhanced_fizzbuzz(N: int): if N is None: raise TypeError(\\"N cannot be None\\") if N < 1: raise ValueError(\\"N must be greater than or equal to 1\\") result = [] for i in range(1, N + 1): if i % 15 == 0: result.append(\\"FizzBuzz\\") elif i % 3 == 0: result.append(\\"Fizz\\") elif i % 5 == 0: result.append(\\"Buzz\\") else: result.append(str(i)) return result"},{"question":"# Coding Challenge: Enhanced Counting Sort **Context** You\'ve been selected to enhance the current implementation of the Counting Sort in a library dealing with large integer datasets. To make this algorithm more versatile and efficient, especially when input range \'k\' is large, you will implement an optimized version of Counting Sort. **Task** Write a function `optimized_counting_sort(arr: List[int]) -> List[int]` that sorts an array of integers using counting sort while minimizing memory usage. # Input Format - `arr`: List of integers. It can contain positive, zero, and negative integers. The size of the array can be large (up to 10^6 elements). # Output Format - A sorted list of integers in ascending order. # Constraints - Do not use built-in sorting functions. - The algorithm should be able to handle negative integers efficiently. - Optimize for memory usage when the range of numbers (k) is very large. # Example: ```python input: [-5, -10, 0, -3, 8, 5, -1, 10] output: [-10, -5, -3, -1, 0, 5, 8, 10] ``` **Requirements** - Demonstrate your understanding of counting sort. - Handle negative integers effectively. - Use memory efficiently. Good luck!","solution":"def optimized_counting_sort(arr): Sorts the input array using an optimized counting sort algorithm. Parameters: arr (List[int]): List of integers that may include negative numbers Returns: List[int]: Sorted list of integers in ascending order if len(arr) == 0: return arr # Find the maximum and minimum value in the array max_val = max(arr) min_val = min(arr) # Range of the numbers in the array range_of_numbers = max_val - min_val + 1 # Creating count array with the size of the range of numbers count = [0] * range_of_numbers # Count the occurrences of each number in the array for number in arr: count[number - min_val] += 1 # Populate the sorted array sorted_arr = [] for i in range(range_of_numbers): sorted_arr.extend([i + min_val] * count[i]) return sorted_arr"},{"question":"# Prime Number Generation using Sieve of Eratosthenes (Modified Version) **Objective**: Write a function `find_primes(m)` that implements the Sieve of Eratosthenes to return a list of prime numbers less than `m` using minimal space and optimal time complexity. **Function Signature**: ```python def find_primes(m: int) -> list[int]: ``` **Input**: * `m` (integer): A positive integer (`1 <= m <= 10^6`). **Output**: * List of integers: A list containing all prime numbers less than `m`. **Constraints**: * Your algorithm should handle the space efficiently by excluding even numbers from the sieve preprocessing. * You must return the list of primes in ascending order. * You should implement proper error checking for invalid values of `m` (e.g., non-positive values should raise an error). * When `m` is `1` or `2`, the function should return an empty list since no prime numbers exist below these values. **Performance Requirements**: * Your solution should be able to handle the upper constraint `m = 10^6` efficiently. **Example**: ```python >>> find_primes(10) [2, 3, 5, 7] >>> find_primes(20) [2, 3, 5, 7, 11, 13, 17, 19] >>> find_primes(1) [] ``` **Notes**: * Carefully consider edge cases where `m` might be very small (`m = 1` or `m = 2`). * Ensure your algorithm efficiently skips marking even numbers and only operates on necessary indices. **Test Case for Self-validation**: Use the following test cases to validate your implementation: ```python assert find_primes(10) == [2, 3, 5, 7] assert find_primes(25) == [2, 3, 5, 7, 11, 13, 17, 19, 23] assert find_primes(1) == [] assert find_primes(2) == [] assert find_primes(50) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47] ```","solution":"def find_primes(m): if m <= 1: return [] sieve = [True] * m sieve[0] = sieve[1] = False for i in range(2, int(m**0.5) + 1): if sieve[i]: for j in range(i*i, m, i): sieve[j] = False return [i for i in range(m) if sieve[i]]"},{"question":"**Objective**: Write a function that sorts an array of integers using the Selection Sort algorithm. You are also required to implement a feature to simulate and print each iteration of the sorting process, showing the state of the array at each step. Furthermore, analyze its efficiency in terms of time and space complexity. **Function Signature**: ```python def selection_sort(arr: list[int], simulation: bool = False) -> list[int]: ``` **Input**: - **arr**: A list of integers to be sorted. - **simulation**: A boolean flag to indicate whether to print the array at each step of the sorting process. **Output**: - A sorted list of integers in ascending order. **Constraints**: - 1 <= len(arr) <= 1000 - -10^6 <= arr[i] <= 10^6 for any integer i in the array **Performance Requirement**: - The algorithm should operate with a time complexity of O(n^2) and a space complexity of O(1). **Scenario**: Imagine you are building a visualization tool for teaching sorting algorithms. Your task is to ensure that the Selection Sort implementation not only sorts the array but also provides a clear view of the array\'s state at each step of the sorting process when the simulation flag is set to True. **Example**: ```python arr = [64, 25, 12, 22, 11] sorted_arr = selection_sort(arr, simulation=True) # Expected Output: # iteration 0 : 64 25 12 22 11 # iteration 1 : 11 25 12 22 64 # iteration 2 : 11 12 25 22 64 # iteration 3 : 11 12 22 25 64 # iteration 4 : 11 12 22 25 64 # sorted_arr = [11, 12, 22, 25, 64] ``` Remember to handle edge cases and consider the performance implications of your implementation.","solution":"def selection_sort(arr: list[int], simulation: bool = False) -> list[int]: n = len(arr) for i in range(n): # Find the minimum element in remaining unsorted array min_idx = i for j in range(i+1, n): if arr[j] < arr[min_idx]: min_idx = j # Swap the found minimum element with the first element of unsorted part arr[i], arr[min_idx] = arr[min_idx], arr[i] # Print the array at each step if simulation is True if simulation: print(f\\"iteration {i} :\\", \\" \\".join(map(str, arr))) return arr"},{"question":"You are tasked with implementing two functions, `encode` and `decode`, to transform a list of strings for network transmission and retrieve it back. Function Specifications **Function 1: encode** * **Input**: List of strings, `strs`. * Type: `List[str]` * **Output**: Encoded single string. * Type: `str` **Function 2: decode** * **Input**: Encoded string, `s`. * Type: `str` * **Output**: List of strings. * Type: `List[str]` Constraints and Requirements * The encoded string format is critical: `<length>:<string>`. E.g., for [\\"hello\\", \\"world\\"], it should be `5:hello5:world`. * The encoded string should be easily parsable back to the original list. * Handling of edge cases such as empty string or list. * Performance considerations for large datasets. Example ```python # Example: strs = [\\"hello\\", \\"world\\"] encoded_str = encode(strs) # encoded_str should be \'5:hello5:world\' decoded_list = decode(encoded_str) # decoded_list should be [\'hello\', \'world\'] ``` Additional Notes * You may assume that the list of strings will only contain ASCII characters. * Focus on implementing efficient concatenation and parsing strategies to ensure optimal performance. Now, go ahead and implement the `encode` and `decode` functions.","solution":"def encode(strs): Encodes a list of strings to a single string. Parameters: strs (List[str]): List of strings to encode. Returns: str: Encoded string. encoded_string = \'\' for string in strs: length = len(string) encoded_string += f\\"{length}:{string}\\" return encoded_string def decode(s): Decodes a single string to a list of strings. Parameters: s (str): Encoded string. Returns: List[str]: Decoded list of strings. decoded_list = [] i = 0 while i < len(s): # Find the separator j = i while s[j] != \':\': j += 1 # Extract the length length = int(s[i:j]) # Extract the string decoded_string = s[j+1:j+1+length] decoded_list.append(decoded_string) # Move to the next segment i = j + 1 + length return decoded_list"},{"question":"You are tasked with implementing a function to compute the binomial coefficient (n choose k) using recursion. The binomial coefficient is defined for two non-negative integers n and k, where n >= k. The provided recursive solution should take advantage of symmetry to reduce the problem size when possible. Function Signature ```python def recursive_binomial_coefficient(n: int, k: int) -> int: pass ``` # Input - `n` (integer): The total number of items (n >= k). - `k` (integer): The number of items to choose (k >= 0). # Output - An integer representing the binomial coefficient C(n, k). # Constraints - 0 <= k <= n <= 10^18 (Consider performance implications). - Use of recursion is mandatory. Avoid using loops or direct combinatorial functions from Python\'s libraries. # Example - Example 1: - Input: n = 8, k = 2 - Output: 28 - Example 2: - Input: n = 5, k = 0 - Output: 1 - Example 3: - Input: n = 500, k = 300 - Output: 5054949849935535817667719165973249533761635252733275327088189563256013971725761702359997954491403585396607971745777019273390505201262259748208640 # Additional Notes - Be cautious of performance and memory usage with very large values of n and k. - Ensure that invalid input scenarios (like n < k) are properly handled by raising appropriate errors. - Think about potential optimization techniques such as memoization but refrain from altering the recursive framework.","solution":"def recursive_binomial_coefficient(n: int, k: int) -> int: Compute the binomial coefficient C(n, k) using recursion. :param n: Total number of items, n (n >= k). :param k: Number of items to choose, k (k >= 0). :return: Binomial coefficient C(n, k). if k > n: raise ValueError(\\"k must be less than or equal to n.\\") if k == 0 or k == n: return 1 if k > n - k: # Take advantage of symmetry property k = n - k return recursive_binomial_coefficient(n - 1, k - 1) + recursive_binomial_coefficient(n - 1, k)"},{"question":"Given an array of complex numbers, implement an iterative version of the Cooley-Tukey Fast Fourier Transform (FFT) algorithm. The function should take a single list of complex numbers as input, and it should output a list of complex numbers that represents the discrete Fourier transform of the input. # Input: - A list of complex numbers where the length of the list is an integer power of 2. # Output: - A list of complex numbers representing the DFT of the input. # Constraints: 1. The length of the input list will always be a power of 2. 2. You need to implement an efficient iterative version to avoid the recursion depth issue. # Performance Requirements: - Time Complexity: O(N log N) - Space Complexity: O(N) # Example: ```python >>> fft_iterative([2.0+2j, 1.0+3j, 3.0+1j, 2.0+2j]) [(8+8j), 2j, (2-2j), (-2+0j)] ``` # Scenario: You are developing a real-time signal processing application where performance is critical. To ensure that your system can handle large datasets efficiently, you need to implement an iterative version of the FFT algorithm that avoids the limitations of recursive depth. # Additional Points: Explain how you would handle inputs that are not a power of 2, and provide any enhancements or improvements to your iterative implementation.","solution":"import cmath def fft_iterative(input_data): Perform Iterative Fast Fourier Transform input_data: List of complex numbers where the length of the list is an integer power of 2. Returns a list of complex numbers representing the DFT of the input. n = len(input_data) if n <= 1: return input_data # Bit-reversal permutation bit_reversed_indices = [int(f\'{i:0{n.bit_length() - 1}b}\'[::-1], 2) for i in range(n)] data = [input_data[i] for i in bit_reversed_indices] # Iterative FFT m = 2 while m <= n: wm = cmath.exp(-2j * cmath.pi / m) for k in range(0, n, m): w = 1 for j in range(m // 2): t = w * data[k + j + m // 2] u = data[k + j] data[k + j] = u + t data[k + j + m // 2] = u - t w *= wm m *= 2 return data"},{"question":"# Scenario You are developing a cross-platform network application that requires sending and receiving integers in a specific byte order. To ensure compatibility across different systems, you need to implement conversion functions for both big-endian and little-endian formats. # Task Your task is to implement two functions: 1. `int_to_bytes(num: int, byte_order: str) -> bytes`: - **Input**: - `num`: a non-negative integer. - `byte_order`: a string indicating the byte order, either `\'big\'` for big-endian or `\'little\'` for little-endian. - **Output**: A `bytes` object representing the integer in the specified byte order. 2. `bytes_to_int(byte_sequence: bytes, byte_order: str) -> int`: - **Input**: - `byte_sequence`: a `bytes` object. - `byte_order`: a string indicating the byte order, either `\'big\'` for big-endian or `\'little\'` for little-endian. - **Output**: The integer value represented by the bytes object in the specified byte order. # Constraints - You can assume that the input integer is non-negative and fits within standard integer limits of Python. - You must handle different endianness conversions correctly. - Your solution should be efficient in terms of both time and space. # Performance Requirements - The time complexity of the conversion functions should be `O(log(num))`. - The space complexity should be `O(n)`, where `n` is the number of bytes required for the integer representation. # Examples Example 1: **Input**: `num = 305419896, byte_order = \'big\'` for `int_to_bytes` **Output**: `b\'x12x34x56x78\'` Example 2: **Input**: `byte_sequence = b\'x12x34x56x78\', byte_order = \'big\'` for `bytes_to_int` **Output**: `305419896`","solution":"def int_to_bytes(num: int, byte_order: str) -> bytes: Converts an integer to bytes in specified byte order. :param num: integer to convert. :param byte_order: \'big\' for big-endian, \'little\' for little-endian. :return: bytes object representing the integer in the specified byte order. if byte_order not in [\'big\', \'little\']: raise ValueError(\\"byte_order must be either \'big\' or \'little\'\\") # Determining the minimum number of bytes required to represent the number byte_length = (num.bit_length() + 7) // 8 return num.to_bytes(byte_length, byte_order) def bytes_to_int(byte_sequence: bytes, byte_order: str) -> int: Converts a bytes object to an integer in specified byte order. :param byte_sequence: bytes object to convert. :param byte_order: \'big\' for big-endian, \'little\' for little-endian. :return: integer represented by the bytes object in the specified byte order. if byte_order not in [\'big\', \'little\']: raise ValueError(\\"byte_order must be either \'big\' or \'little\'\\") return int.from_bytes(byte_sequence, byte_order)"},{"question":"# String Search Optimization Challenge In text processing, efficiently finding the occurrences of a substring within a larger string is crucial. You are required to implement an optimized version of the `contain_string` function that accurately locates the index of the first occurrence of `needle` within `haystack`. Objective Write a function `optimized_strStr(haystack: str, needle: str) -> int` that implements an efficient string search algorithm, with the following specifications: # Specifications - **Function**: `optimized_strStr(haystack: str, needle: str) -> int` - **Input**: - `haystack` (string): The string in which to search for `needle`. - `needle` (string): The substring to be searched for in `haystack`. - **Output**: - An integer representing the index of the first occurrence of `needle` in `haystack`. - Return -1 if `needle` is not found in `haystack`. - If `needle` is an empty string, return 0. - **Constraints**: - The length of `haystack` does not exceed (10^4). - The length of `needle` does not exceed (10^3). # Example ```python assert optimized_strStr(\\"hello\\", \\"ll\\") == 2 assert optimized_strStr(\\"aaaaa\\", \\"bba\\") == -1 assert optimized_strStr(\\"\\", \\"\\") == 0 assert optimized_strStr(\\"abc\\", \\"\\") == 0 assert optimized_strStr(\\"abcdef\\", \\"def\\") == 3 assert optimized_strStr(\\"abcdef\\", \\"gh\\") == -1 ``` # Requirements - Utilize an optimized string search algorithm (e.g., KMP, Boyer-Moore). - Ensure the solution handles edge cases and efficiently processes inputs up to the specified constraints. - Minimize the time complexity to better than O(n * m) if possible. # Notes - Your solution will be evaluated based on correctness and efficiency. - Demonstrate the effectiveness of your solution through comprehensive test cases.","solution":"def optimized_strStr(haystack: str, needle: str) -> int: if not needle: return 0 n, m = len(haystack), len(needle) # KMP algorithm to create the longest prefix suffix (LPS) array lps = [0] * m j = 0 i = 1 while i < m: if needle[i] == needle[j]: j += 1 lps[i] = j i += 1 else: if j != 0: j = lps[j - 1] else: lps[i] = 0 i += 1 # KMP Search i, j = 0, 0 while i < n: if needle[j] == haystack[i]: i += 1 j += 1 if j == m: return i - j elif i < n and needle[j] != haystack[i]: if j != 0: j = lps[j - 1] else: i += 1 return -1"},{"question":"You are tasked with writing a function `minimum_swaps_to_sort(arr)` that uses the Bubble Sort algorithm to sort the given integer list `arr`. Additionally, it should return the number of swaps required to sort the array. Your task is to: 1. Implement a Bubble Sort that tracks and counts the swaps. 2. Ensure the function returns the total count of swaps once the sorting is complete. # Input - `arr`: List of integers, 0 ≤ len(arr) ≤ 10^3, -10^6 ≤ arr[i] ≤ 10^6. # Output - An integer representing the total number of swaps performed to sort the array. # Constraints - The function should handle large ranges of integer values efficiently. - The function should work in O(N^2) time complexity. # Example ```python assert minimum_swaps_to_sort([4, 3, 2, 1]) == 6 assert minimum_swaps_to_sort([1, 2, 3, 4]) == 0 assert minimum_swaps_to_sort([2, 1, 3, 1, 2]) == 4 ``` # Note Your solution should be able to handle edge cases such as an empty list or a list that is already sorted. You do not have to print the sorted array, only return the number of swaps used to achieve the sorted order.","solution":"def minimum_swaps_to_sort(arr): This function uses Bubble Sort to sort an array and counts the number of swaps needed. n = len(arr) swap_count = 0 # Bubble Sort Algorithm for i in range(n): for j in range(0, n-i-1): if arr[j] > arr[j+1]: # Swap the elements arr[j], arr[j+1] = arr[j+1], arr[j] # Increment the swap count swap_count += 1 return swap_count"},{"question":"# Roman Numeral Conversion Design a function named `int_to_roman` which converts a given integer within the range 1 to 3999 into its corresponding Roman numeral representation. Input - An integer `num` (1 <= num <= 3999) Output - A string representing the Roman numeral equivalent of the given integer. Constraints - The input integer is guaranteed to be within the specified range. - Your solution should aim for efficiency in both time and space. # Example ```python assert int_to_roman(3) == \'III\' assert int_to_roman(58) == \'LVIII\' assert int_to_roman(1994) == \'MCMXCIV\' ``` Additional Notes - Ensure your code correctly handles edge cases for 1 and 3999. - The solution should not utilize built-in libraries beyond basic operations. - Focus on readability and efficiency of your code. **Scenario**: Imagine a historical text rendering application that requires formatting years into their corresponding Roman numeral representation for visibility in ancient-style documents.","solution":"def int_to_roman(num): Converts an integer to its Roman numeral equivalent. Parameters: num (int): an integer between 1 and 3999 inclusive Returns: str: the Roman numeral representation of the integer # Mapping of integers to roman numerals val = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ] syb = [ \\"M\\", \\"CM\\", \\"D\\", \\"CD\\", \\"C\\", \\"XC\\", \\"L\\", \\"XL\\", \\"X\\", \\"IX\\", \\"V\\", \\"IV\\", \\"I\\" ] roman_num = \'\' i = 0 while num > 0: for _ in range(num // val[i]): roman_num += syb[i] num -= val[i] i += 1 return roman_num # Example usage assert int_to_roman(3) == \'III\' assert int_to_roman(58) == \'LVIII\' assert int_to_roman(1994) == \'MCMXCIV\'"},{"question":"# Question: Implementing Kruskal\'s Algorithm for Minimum Spanning Tree (MST) You are tasked with designing a system that can efficiently determine the Minimum Spanning Tree (MST) for a given undirected, weighted graph using Kruskal\'s algorithm. This algorithm must handle multiple input graphs and ensure optimal performance through efficient data structures. Requirements 1. **Input**: - An integer `n` (number of vertices) and `m` (number of edges). - Next `m` lines each containing three integers `u`, `v`, and `weight` where `u` and `v` are vertices connected by an edge with the associated weight. 2. **Output**: - For each graph, print the sum of the weights of the MST. Constraints - (1 leq n leq 10^5) - (0 leq m leq 2 times 10^5) - (1 leq text{weight} leq 10^9) - Ensure the input graph is connected and undirected. Performance Requirements - Your solution should be efficient enough to handle large inputs within a reasonable timeframe. Scenario You are a network engineer tasked to minimize the cost of laying cables between various offices. You must determine the optimal set of connections (edges) that connect all offices (vertices) with the minimum total cable length (sum of weights). Function Signature ```python def minimum_spanning_tree(n: int, edges: List[Tuple[int, int, int]]) -> int: Return the sum of weights of the Minimum Spanning Tree (MST) for given graph. Parameters: n (int): Number of vertices edges (List[Tuple[int, int, int]]): Edges of the graph in the format (u, v, weight) Returns: int: Sum of weights of the MST ```","solution":"def minimum_spanning_tree(n, edges): Return the sum of weights of the Minimum Spanning Tree (MST) for given graph. Parameters: n (int): Number of vertices edges (List[Tuple[int, int, int]]): Edges of the graph in the format (u, v, weight) Returns: int: Sum of weights of the MST # Sorting edges based on their weights edges.sort(key=lambda x: x[2]) parent = list(range(n)) rank = [0] * n def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: if rank[rootX] > rank[rootY]: parent[rootY] = rootX elif rank[rootX] < rank[rootY]: parent[rootX] = rootY else: parent[rootY] = rootX rank[rootX] += 1 mst_weight = 0 for u, v, weight in edges: if find(u) != find(v): union(u, v) mst_weight += weight return mst_weight"},{"question":"- Robot Circle Judge with Input Validation You are required to implement a function that determines if a sequence of robot moves returns the robot to its original position on a 2D grid, but with additional constraints: 1. The move sequence is represented by a string. Valid moves are - \\"R\\" (Right), \\"L\\" (Left), \\"U\\" (Up), and \\"D\\" (Down). 2. Any move string containing characters outside of \\"RLUD\\" should return `false` immediately. 3. Implement the function to handle long sequences efficiently and perform early exit checks if possible. Function Signature ```python def judge_circle(moves: str) -> bool: ``` # Input - `moves`: A string consisting of characters \\"R\\", \\"L\\", \\"U\\", \\"D\\". # Output - Returns `True` if the moves return the robot to the origin, `False` otherwise. # Examples Example 1: ```python print(judge_circle(\\"UD\\")) # Output: True ``` Example 2: ```python print(judge_circle(\\"LL\\")) # Output: False ``` Example 3: ```python print(judge_circle(\\"RULDDLUURRD\\")) # Output: False ``` Example 4: ```python print(judge_circle(\\"RRLUUDDLxx\\")) # Output: False - Invalid characters \'x\' present ``` # Constraints - The input string can have up to 10^6 characters. - The function should validate the input and only perform counting for valid sequences. - Optimize for early exit if opposite moves are disproportional.","solution":"def judge_circle(moves: str) -> bool: Determines if a sequence of robot moves returns the robot to its original position. # Initial positions if not all(move in \\"RLUD\\" for move in moves): return False x, y = 0, 0 for move in moves: if move == \'R\': x += 1 elif move == \'L\': x -= 1 elif move == \'U\': y += 1 elif move == \'D\': y -= 1 # Checking final position return x == 0 and y == 0"},{"question":"# Binary Tree Preorder Traversal You are given the following class definition for a Binary Tree node: ```python class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right ``` # Task Implement a function `preorder(root)` that performs preorder traversal on a binary tree and returns a list of values of nodes visited in preorder sequence (root, left, right). # Function Signature ```python def preorder(root: Optional[Node]) -> List[int]: ``` # Input * `root`: The root node of the binary tree. It can be `None`. # Output * A list of integers representing the node values in preorder traversal. # Example Input ```python # Creating a binary tree # 1 # / # 2 3 # / / # 4 5 6 root = Node(1) root.left = Node(2) root.right = Node(3) root.left.left = Node(4) root.left.right = Node(5) root.right.left = Node(6) ``` Output ```python [1, 2, 4, 5, 3, 6] ``` # Constraints * The number of nodes in the tree is between 0 and 1000. * The value of each node is a unique integer. # Performance Requirements * The function must run in O(n) time complexity. * Use an iterative approach (using a stack) within provided constraints. Note: Please ensure to validate the tree structure before performing the traversal.","solution":"from typing import List, Optional class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right def preorder(root: Optional[Node]) -> List[int]: Perform a preorder traversal of a binary tree and return the list of node values. if root is None: return [] stack = [root] result = [] while stack: node = stack.pop() result.append(node.val) # Push right child first so that left child is processed first if node.right: stack.append(node.right) if node.left: stack.append(node.left) return result"},{"question":"You are given an (n times n) matrix of integers. Your task is to write a function `invert_matrix(matrix: List[List[int]]) -> List[List[float]]` that returns the inverse of the matrix. If the matrix is not invertible, return an error code inside a nested list. # Guidelines 1. Implement the inversion process for square matrices (2x2 and general (n times n)). 2. Return specific error codes if: - The input is not a valid matrix: `[[ -1 ]]` - The matrix is not square: `[[ -2 ]]` - The matrix is too small (0x0 or 1x1): `[[ -3 ]]` - The matrix is singular (determinant is 0): `[[ -4 ]]` # Input - matrix - a list of lists of integers representing an (n times n) matrix (2 <= n <= 10). # Output - A list of lists of floats representing the inverse matrix if invertible. - Specific error codes within a nested list for invalid matrices. # Constraints - You should not use libraries like `numpy` or `scipy` for matrix inversion. - Time complexity should be analyzed, and your code should be as efficient as possible for (n leq 10). # Example **Input** ```python matrix = [ [4, 7], [2, 6] ] ``` **Output** ```python [ [0.6, -0.7], [-0.2, 0.4] ] ``` **Input** ```python matrix = [ [2, 1, 1], [1, 2, 1], [1, 1, 2] ] ``` **Output** ```python [ [0.75, -0.25, -0.25], [-0.25, 0.75, -0.25], [-0.25, -0.25, 0.75] ] ``` **Input** ```python matrix = [ [1, 2], [2, 4] ] ``` **Output** ```python [[-4]] ``` **Input** ```python matrix = [ [1, 2, 3], [1, 4, 7] ] ``` **Output** ``` [[-2]] ``` Your solution should demonstrate an efficient handle of the matrix inversion process, considering all edge cases.","solution":"from typing import List def determinant(matrix: List[List[int]], n: int) -> int: Helper function to compute determinant of given matrix of size n x n if n == 1: return matrix[0][0] if n == 2: return matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0] det = 0 for c in range(n): minor_matrix = [row[:c] + row[c + 1:] for row in (matrix[:0] + matrix[1:])] det += ((-1)**c) * matrix[0][c] * determinant(minor_matrix, n - 1) return det def get_cofactor(matrix: List[List[int]], p: int, q: int, n: int) -> List[List[int]]: Helper function to get cofactor of matrix[p][q] temp = [[0 for _ in range(n - 1)] for _ in range(n - 1)] i = j = x = y = 0 for row in range(n): for col in range(n): if row != p and col != q: temp[i][j] = matrix[row][col] j += 1 if j == n - 1: j = 0 i += 1 return temp def adjoint(matrix: List[List[int]], n: int) -> List[List[int]]: Function to get adjoint of matrix of size n x n if n == 1: return [[1]] adj = [[0 for _ in range(n)] for _ in range(n)] for i in range(n): for j in range(n): cofactor = get_cofactor(matrix, i, j, n) adj[j][i] = ((-1) ** (i + j)) * determinant(cofactor, n - 1) return adj def invert_matrix(matrix: List[List[int]]) -> List[List[float]]: if not matrix or not matrix[0]: return [[-1]] n = len(matrix) if any(len(row) != n for row in matrix): return [[-2]] if n < 2: return [[-3]] det = determinant(matrix, n) if det == 0: return [[-4]] adj = adjoint(matrix, n) inverse_matrix = [[adj[i][j] / det for j in range(n)] for i in range(n)] return inverse_matrix"},{"question":"# Question: You are given an array of integers and a non-negative integer k. Your task is to write a function that rotates the array to the right by k steps and returns the rotated array. Implement the function using three different methods and analyze their performance. Function Signature: ```python def rotate_array_v1(array: List[int], k: int) -> List[int]: # Method 1 def rotate_array_v2(array: List[int], k: int) -> List[int]: # Method 2 def rotate_array_v3(array: List[int], k: int) -> List[int]: # Method 3 ``` Input: * `array` is a list of integers (0 <= len(array) <= 10^5) * `k` is a non-negative integer (0 <= k <= 10^5) Output: * Return a rotated list of integers after k steps of rotation. Constraints: * The array should be rotated in-place if possible. * Minimize space complexity where possible. Performance Requirements: * Aim for the time complexity of O(n) per method. * Strive to use O(1) additional space for in-place rotations. Examples: ```python assert rotate_array_v1([1, 2, 3, 4, 5, 6, 7], 3) == [5, 6, 7, 1, 2, 3, 4] assert rotate_array_v2([1, 2, 3, 4, 5, 6, 7], 3) == [5, 6, 7, 1, 2, 3, 4] assert rotate_array_v3([1, 2, 3, 4, 5, 6, 7], 3) == [5, 6, 7, 1, 2, 3, 4] assert rotate_array_v1([1, 2], 0) == [1, 2] assert rotate_array_v2([1, 2], 2) == [1, 2] assert rotate_array_v3([1, 2], 1) == [2, 1] ``` Notes: * Implement each method focusing on different algorithmic approaches mentioned above. * Ensure that your implementations handle edge cases appropriately.","solution":"def rotate_array_v1(array, k): Rotate array using slicing. n = len(array) if n == 0: return array k = k % n # In case k is larger than the length of the array return array[-k:] + array[:-k] def rotate_array_v2(array, k): Rotate array using reversal. def reverse(arr, start, end): while start < end: arr[start], arr[end] = arr[end], arr[start] start += 1 end -= 1 n = len(array) if n == 0: return array k = k % n # In case k is larger than the length of the array reverse(array, 0, n-1) reverse(array, 0, k-1) reverse(array, k, n-1) return array def rotate_array_v3(array, k): Rotate array using additional list for space complexity O(n). n = len(array) if n == 0: return array k = k % n # In case k is larger than the length of the array result = [0] * n for i in range(n): result[(i + k) % n] = array[i] return result"},{"question":"Optimized Shell Sort Implementation Scenario You\'ve been hired by a cutting-edge tech company to optimize their sorting functions for better performance in medium-sized arrays used frequently in their operations. While they are satisfied with Shell Sort\'s in-place nature, they are concerned about its performance compared to more efficient algorithms. You\'ve been asked to implement an optimized version of Shell Sort by improving the gap sequence based on empirical research. Task Write an improved version of Shell Sort called `optimized_shell_sort`, which uses a more efficient gap sequence such as the one developed by Ciura (1, 4, 10, 23, 57, 132, 301, 701, 1750...). Function Signature Your function should match this signature: ```python def optimized_shell_sort(arr: list) -> list: # Implementation goes here pass ``` Input - `arr` (List[int]): An unsorted list of integers 0 ≤ len(arr) ≤ 10^5. Output - A sorted list in ascending order Constraints - You may assume that the input list contains only integers. - Optimize for performance with the introduced gap sequence. - Sorting should be done in-place, hence avoid using extra memory other than what is required. Example ```python # Input example_list = [23, 42, 4, 16, 8, 15] # Call the function sorted_list = optimized_shell_sort(example_list) # Output print(sorted_list) # Output should be [4, 8, 15, 16, 23, 42] ``` Performance Requirements - The function should handle up to 100,000 elements efficiently. Your task is to complete the `optimized_shell_sort` function to meet the specified requirements.","solution":"def optimized_shell_sort(arr: list) -> list: Optimized Shell Sort using Ciura\'s gap sequence. n = len(arr) gaps = [701, 301, 132, 57, 23, 10, 4, 1] # Ciura\'s gap sequence for gap in gaps: for i in range(gap, n): temp = arr[i] j = i while j >= gap and arr[j - gap] > temp: arr[j] = arr[j - gap] j -= gap arr[j] = temp return arr"},{"question":"# Euler\'s Totient Function Calculation **Scenario**: You are involved in cryptographic applications and need to implement a function that computes the Euler\'s Totient Function, which is crucial for your encryption algorithms. **Objective**: Write a Python function `calculate_totient(n)` that calculates the number of integers between 1 and ( n ) inclusive, that are coprime with ( n ). **Input**: - A single integer ( n ) (1 ≤ ( n ) ≤ 10^6). **Output**: - An integer representing the result of Euler\'s Totient Function for the given ( n ). **Constraints**: - Input ( n ) will always be a positive integer. - The function should have a time complexity of O(√n). **Example**: ```python calculate_totient(9) # Output: 6 calculate_totient(30) # Output: 8 calculate_totient(1) # Output: 1 calculate_totient(50) # Output: 20 ``` **Explanation**: - For ( n = 9 ), the integers 1, 2, 4, 5, 7, 8 are coprime with 9, thus result is 6. - For ( n = 30 ), the integers 1, 7, 11, 13, 17, 19, 23, 29 are coprime with 30, thus result is 8. Write the function `calculate_totient()` implementing the above logic accurately. ```python def calculate_totient(n): result = n for i in range(2, int(n ** 0.5) + 1): if n % i == 0: while n % i == 0: n //= i result -= result // i if n > 1: result -= result // n return result ```","solution":"def calculate_totient(n): Calculates Euler\'s Totient Function for the given integer n. Args: - n (int): The integer for which the totient function is to be calculated. Returns: - int: The value of the totient function for n. result = n p = 2 while p * p <= n: if n % p == 0: while n % p == 0: n //= p result -= result // p p += 1 if n > 1: result -= result // n return result"},{"question":"Matrix Rotation and Inversion You are given a matrix (2D list) representing a square grid of integers. Implement the following functions to perform various transformations on the matrix: 1. **rotate_90_clockwise(matrix)**: Rotate the matrix 90 degrees clockwise. 2. **rotate_90_counterclockwise(matrix)**: Rotate the matrix 90 degrees counterclockwise. 3. **invert_top_left_to_bottom_right(matrix)**: Reflect the elements across the top-left to bottom-right diagonal (principal diagonal). 4. **invert_bottom_left_to_top_right(matrix)**: Reflect the elements across the bottom-left to top-right diagonal (anti-diagonal). # Input and Output Formats - **Input**: A 2D list `matrix` of size `n x n`, where `n` is the number of rows/columns in the matrix. Each element in the matrix is an integer. - **Output**: A new 2D list which is a transformed version of the input matrix. # Constraints - `1 <= n <= 100` for the input matrix size. - The matrix will always be a square matrix with integer elements. # Function Signatures ```python def rotate_90_clockwise(matrix): # Implement this def rotate_90_counterclockwise(matrix): # Implement this def invert_top_left_to_bottom_right(matrix): # Implement this def invert_bottom_left_to_top_right(matrix): # Implement this ``` # Example If you have the following matrix: ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] ``` - After **rotate_90_clockwise(matrix)**: ```python [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] ``` - After **rotate_90_counterclockwise(matrix)**: ```python [ [3, 6, 9], [2, 5, 8], [1, 4, 7] ] ``` - After **invert_top_left_to_bottom_right(matrix)**: ```python [ [1, 4, 7], [2, 5, 8], [3, 6, 9] ] ``` - After **invert_bottom_left_to_top_right(matrix)**: ```python [ [9, 6, 3], [8, 5, 2], [7, 4, 1] ] ``` Write the implementations of the functions specified to perform the described matrix transformations.","solution":"def rotate_90_clockwise(matrix): Rotate the matrix 90 degrees clockwise. n = len(matrix) return [[matrix[n - 1 - j][i] for j in range(n)] for i in range(n)] def rotate_90_counterclockwise(matrix): Rotate the matrix 90 degrees counterclockwise. n = len(matrix) return [[matrix[j][n - 1 - i] for j in range(n)] for i in range(n)] def invert_top_left_to_bottom_right(matrix): Invert the matrix across the top-left to bottom-right diagonal (principal diagonal). n = len(matrix) return [[matrix[j][i] for j in range(n)] for i in range(n)] def invert_bottom_left_to_top_right(matrix): Invert the matrix across the bottom-left to top-right diagonal (anti-diagonal). n = len(matrix) return [[matrix[n - 1 - j][n - 1 - i] for j in range(n)] for i in range(n)]"},{"question":"# Question: Move All Zeros to the End Context You are working on a data processing application where you need to cleanse dataset arrays by moving all zero values to the end. The task is to implement a function that does this efficiently. The order of non-zero elements should be preserved, and boolean values should be treated as distinct from zeros. Problem Write a function `move_zeros` that takes an array and moves all of the zeros to the end, preserving the order of the other elements. The function should not use any additional array for storing results, i.e., it should modify the array in place. Input - An array `arr` of various types (e.g., integers, strings, booleans). Output - The modified array with all zeros moved to the end. Constraints - Do not use any extra space for another array (in-place modification required). - Handle different types properly (e.g., `False` should not be treated as zero). Examples ```python move_zeros([False, 1, 0, 1, 2, 0, 1, 3, \\"a\\"]) # Output: [False, 1, 1, 2, 1, 3, \\"a\\", 0, 0] move_zeros([0, 0, 0, False, 0]) # Output: [False, 0, 0, 0, 0] move_zeros([1, 2, 3]) # Output: [1, 2, 3] ``` Requirements - The function should have a time complexity of O(n). - The function should not use any additional space except for a few extra variables. You may assume the input list will not contain any nested lists. Function Signature ```python def move_zeros(arr: list) -> None: pass ```","solution":"def move_zeros(arr: list) -> None: Moves all zeros to the end of the list, preserving the order of the other elements. Modifies the list in place and does not return anything. zero_pos = 0 # Index to place the non-zero element for i in range(len(arr)): if arr[i] != 0 or isinstance(arr[i], bool): arr[zero_pos] = arr[i] zero_pos += 1 for i in range(zero_pos, len(arr)): arr[i] = 0"},{"question":"You are tasked with implementing a secure key exchange protocol between two parties, Alice and Bob. Specifically, you will use the Diffie-Hellman key exchange algorithm, while ensuring the primality and suitability of the given numbers. Problem Statement Implement the function `secure_key_exchange(a: int, p: int) -> bool`. This function will: 1. Verify that ( p ) is a large prime number. 2. Verify that ( a ) is a primitive root modulo ( p ). 3. Simulate the Diffie-Hellman key exchange process: - Generate private and public keys for both Alice and Bob. - Calculate the shared secret key using each party\'s private key and the other party\'s public key. 4. Return `True` if both parties generate the same shared secret key, otherwise `False`. Function Signature ```python def secure_key_exchange(a: int, p: int) -> bool: pass ``` Constraints - ( 2 leq p leq 10^9 ) - ( 2 leq a < p ) Input * `a`: An integer representing a candidate primitive root. * `p`: An integer representing a candidate prime number. Output * `True` if both parties generate the same shared secret key. * `False` otherwise. # Example ```python print(secure_key_exchange(2, 23)) # Example output: True ``` # Requirements - Implement supportive functionalities such as primality check, primitive root detection, and order finding. - Ensure robust handling of edge cases and conform to the constraints. Good luck, and ensure your solution is efficient and secure!","solution":"import random def is_prime(n): if n <= 1: return False if n == 2 or n == 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def gcd(a, b): while b: a, b = b, a % b return a def find_primitive_root(p): if not is_prime(p): return -1 phi = p - 1 prime_factors = set() n = phi i = 2 while i * i <= n: while n % i == 0: prime_factors.add(i) n //= i i += 1 if n > 1: prime_factors.add(n) for r in range(2, p): flag = False for factor in prime_factors: if pow(r, phi // factor, p) == 1: flag = True break if not flag: return r return -1 def secure_key_exchange(a, p): if not is_prime(p): return False primitive_root = find_primitive_root(p) if primitive_root != a: return False alice_private_key = random.randint(2, p-2) bob_private_key = random.randint(2, p-2) alice_public_key = pow(a, alice_private_key, p) bob_public_key = pow(a, bob_private_key, p) alice_shared_secret = pow(bob_public_key, alice_private_key, p) bob_shared_secret = pow(alice_public_key, bob_private_key, p) return alice_shared_secret == bob_shared_secret"},{"question":"# Problem: Sort Students by Scores Using Cycle Sort You are given a list of student dictionaries where each dictionary contains the `name` and `score` of a student. Your task is to implement the **Cycle Sort** algorithm to sort these students by their scores in ascending order. # Example: ```python students = [ {\\"name\\": \\"Alice\\", \\"score\\": 88}, {\\"name\\": \\"Bob\\", \\"score\\": 75}, {\\"name\\": \\"Charlie\\", \\"score\\": 93}, {\\"name\\": \\"Dave\\", \\"score\\": 85} ] ``` # Expected Output: ```python [ {\\"name\\": \\"Bob\\", \\"score\\": 75}, {\\"name\\": \\"Dave\\", \\"score\\": 85}, {\\"name\\": \\"Alice\\", \\"score\\": 88}, {\\"name\\": \\"Charlie\\", \\"score\\": 93} ] ``` # Constraints: 1. Ensure that the list is sorted in-place. 2. The function should handle an empty list and return it as is. 3. Each dictionary in the list has the keys `name` and `score`. 4. Scores are integer values and unique. # Function Signature: ```python def cycle_sort_students(students: list) -> list: pass ``` # Additional Information: * You should not use any built-in sorting functions. * Aim to write a solution that carefully manages in-place operations with minimal writes. * Comment your code to explain the implementation steps.","solution":"def cycle_sort_students(students: list) -> list: Sorts a list of student dictionaries by their scores using the Cycle Sort algorithm. Args: students (list): List of dictionaries where each dict has \'name\' and \'score\' keys. Returns: list: The same list sorted by the \'score\' key in ascending order. if not students: return students n = len(students) # Traverse through each element and if it\'s not in the correct position, # place it in the correct position by performing rotation. for cycle_start in range(n - 1): item = students[cycle_start] pos = cycle_start for i in range(cycle_start + 1, n): if students[i][\'score\'] < item[\'score\']: pos += 1 if pos == cycle_start: continue while item[\'score\'] == students[pos][\'score\']: pos += 1 students[pos], item = item, students[pos] while pos != cycle_start: pos = cycle_start for i in range(cycle_start + 1, n): if students[i][\'score\'] < item[\'score\']: pos += 1 while item[\'score\'] == students[pos][\'score\']: pos += 1 students[pos], item = item, students[pos] return students"},{"question":"Implement an Enhanced Moving Average You need to write a class `EnhancedMovingAverage` that extends the basic functionality of a moving average with some additional features. # Requirements: 1. Implement the `__init__` method to initialize the data structure with a given window size. 2. Implement the `next` method that takes an integer value and returns the updated moving average. 3. Add a method `get_max` that returns the maximum value in the current window. 4. Add a method `get_min` that returns the minimum value in the current window. 5. Handle edge cases where the window is not yet full. # Input and Output Formats: - **`__init__(size: int)`**: Initializes the moving average with a window size. - **`next(val: int) -> float`**: Adds a new element and returns the current moving average. - **`get_max() -> int`**: Returns the maximum value in the current window. - **`get_min() -> int`**: Returns the minimum value in the current window. # Constraints: - The size for the window is always greater than 0. - The value provided to `next` is a valid integer. - You must ensure efficient computation for all methods, especially considering the continuous stream of input. # Example: ```python if __name__ == \'__main__\': ma = EnhancedMovingAverage(3) print(ma.next(1)) # Output: 1.0 print(ma.next(10)) # Output: 5.5 print(ma.get_max())# Output: 10 print(ma.get_min())# Output: 1 print(ma.next(3)) # Output: 4.6667 print(ma.get_max())# Output: 10 print(ma.get_min())# Output: 1 print(ma.next(5)) # Output: 6.0 print(ma.get_max())# Output: 10 print(ma.get_min())# Output: 3 ``` # Expectations: - Your solution should demonstrate understanding of deque operations and efficient computation. - Handle edge cases where the window size is not reached. - Ensure the methods `get_max` and `get_min` are optimized for performance.","solution":"from collections import deque class EnhancedMovingAverage: def __init__(self, size: int): self.size = size self.window = deque() self.sum = 0 self.current_max = float(\'-inf\') self.current_min = float(\'inf\') def next(self, val: int) -> float: # Add new value to the window sum self.window.append(val) self.sum += val # Update max and min if val > self.current_max: self.current_max = val if val < self.current_min: self.current_min = val # If window is full, remove the oldest value if len(self.window) > self.size: removed = self.window.popleft() self.sum -= removed # Recalculate max and min if the removed element was one of them if removed == self.current_max or removed == self.current_min: self.current_max = max(self.window) self.current_min = min(self.window) return self.sum / len(self.window) def get_max(self) -> int: return self.current_max def get_min(self) -> int: return self.current_min"},{"question":"**Question: Find the Extra Character** # Background In computer systems, finding discrepancies or differences between sets of data can be crucial for debugging and maintaining consistency. One common problem involves determining which element has been added to a dataset. In this assessment, you will address a simplified version of this problem using string inputs. # Problem Statement Given two strings `s` and `t` which consist of only lowercase letters, string `t` is generated by random shuffling string `s` and then adding one more letter at a random position. Your task is to write a function that finds the letter that was added in `t`. # Function Signature ```python def find_difference(s: str, t: str) -> str: ``` # Input * `s`: A string consisting of lowercase letters with length `n`. * `t`: A string consisting of lowercase letters with length `n + 1`. # Output * Returns a single character representing the added letter in `t`. # Constraints * `s` and `t` only contain lowercase English letters. * The length of `t` is exactly one more than the length of `s`. # Examples ```python assert find_difference(\\"abcd\\", \\"abecd\\") == \'e\' assert find_difference(\\"xyz\\", \\"xzyzr\\") == \'r\' assert find_difference(\\"\\", \\"z\\") == \'z\' ``` # Notes * Given the nature of the problem, ensure your solution handles edge cases such as empty input or strings with repetitive characters efficiently. * Aim for a solution with a linear time complexity `O(n)` and constant space complexity `O(1)`.","solution":"def find_difference(s: str, t: str) -> str: Find the letter that was added to string `t` which is one character more than string `s`. # Initialize variable to store the result result = 0 # XOR all characters of both strings for char in s: result ^= ord(char) for char in t: result ^= ord(char) return chr(result)"},{"question":"You are given a Binary Search Tree (BST) and an integer value `k`. Your task is to find the k-th smallest element in the BST using two different approaches and compare their efficiencies. # Input Format * A root node of the BST. * An integer `k` (1 ≤ k ≤ the number of nodes in the tree). # Output Format * The k-th smallest element in the BST. # Constraints * The BST will have at least one node and all nodes will have unique values. * You must implement both methods: iterative and recursive. * Analyze and compare the performance of each method. # Requirements 1. Implement the function `iterative_kth_smallest(root, k)` using an iterative approach. 2. Implement the function `recursive_kth_smallest(root, k)` using a recursive approach. # Example ```python class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right # Example Usage if __name__ == \'__main__\': n1 = Node(100) n2 = Node(50) n3 = Node(150) n4 = Node(25) n5 = Node(75) n6 = Node(125) n7 = Node(175) n1.left, n1.right = n2, n3 n2.left, n2.right = n4, n5 n3.left, n3.right = n6, n7 k = 2 # Expected Output: 50 print(iterative_kth_smallest(n1, k)) # Expected Output: 50 print(recursive_kth_smallest(n1, k)) ``` # Your Task 1. Implement the `iterative_kth_smallest(root, k)` function. 2. Implement the `recursive_kth_smallest(root, k)` function. 3. Compare their time and space complexities.","solution":"class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right def iterative_kth_smallest(root, k): Find the k-th smallest element in the BST using an iterative approach. stack = [] current = root while True: while current: stack.append(current) current = current.left current = stack.pop() k -= 1 if k == 0: return current.val current = current.right def recursive_kth_smallest(root, k): Find the k-th smallest element in the BST using a recursive approach. def inorder_traversal(node): if node is None: return [] return inorder_traversal(node.left) + [node.val] + inorder_traversal(node.right) inorder = inorder_traversal(root) return inorder[k - 1]"},{"question":"# Context You are asked to develop an algorithm for inverting (reversing) a binary tree. This means you need to swap every left child with its corresponding right child recursively for the whole tree. # Problem Statement Write a function `invert_binary_tree(root)` that takes the root of a binary tree and inverts it in place. The function should modify the tree so that every left child is swapped with its right child. # Requirements * Input format: a TreeNode representing the root of the binary tree. * Output format: the same TreeNode that represents the root of the inverted binary tree. # Constraints 1. The nodes of the binary tree contain integer values. 2. The number of nodes in the tree is between 1 and 10^4. 3. Assuming the structure of the tree is provided by a class `TreeNode` with attributes `val`, `left`, and `right`. # Example Input A binary tree like this: ``` 4 / 2 7 / / 1 3 6 9 ``` Output The tree should be inverted as: ``` 4 / 7 2 / / 9 6 3 1 ``` # Additional Notes * Do not use additional data structures to assist in the tree inversion. * Ensure to handle edge cases such as empty trees.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def invert_binary_tree(root): if root is None: return None # Swap the left and right children root.left, root.right = root.right, root.left # Recursively invert the subtrees invert_binary_tree(root.left) invert_binary_tree(root.right) return root"},{"question":"**Scenario**: You are given an array of integers, which can have duplicate elements. Your task is to sort this array using an efficient in-place algorithm that minimizes the number of write operations. **Task**: Write a Python function `cycle_sort(arr)` that sorts the given array using the Cycle Sort algorithm. The function should modify the input array in-place and return it. **Function Signature**: ```python def cycle_sort(arr: List[int]) -> List[int]: ``` **Input**: * `arr`: A list of integers, where 1 <= len(arr) <= 10^5 and -10^6 <= arr[i] <= 10^6. **Output**: * The function should return the sorted list of integers. **Constraints**: * You must use the Cycle Sort algorithm. * The function should sort the list in-place (without using extra space for another array). * The number of write operations should be minimized. **Example**: ```python arr = [4, 3, 2, 1, 5] print(cycle_sort(arr)) # Output: [1, 2, 3, 4, 5] arr = [3, 3, 1, 2, 2] print(cycle_sort(arr)) # Output: [1, 2, 2, 3, 3] ``` **Notes**: * Consider edge cases such as arrays that are already sorted or contain multiple duplicate elements. * Make sure your implementation does not go into infinite loops when handling duplicates.","solution":"from typing import List def cycle_sort(arr: List[int]) -> List[int]: n = len(arr) for cycle_start in range(n - 1): item = arr[cycle_start] pos = cycle_start for i in range(cycle_start + 1, n): if arr[i] < item: pos += 1 if pos == cycle_start: continue while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] while pos != cycle_start: pos = cycle_start for i in range(cycle_start + 1, n): if arr[i] < item: pos += 1 while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] return arr"},{"question":"# Question: Implement an Efficient Sorted Array Insertion Function You are tasked with implementing a function that takes a sorted array and an unsorted array of values. The goal is to insert each value from the unsorted array into the sorted array while maintaining the sorted order in the most efficient manner possible. Input: * `sorted_array`: A list of integers sorted in non-decreasing order. (0 ≤ length ≤ 10^5) * `unsorted_array`: A list of integers that need to be inserted into the sorted array. (0 ≤ length ≤ 10^5) Output: * The function should return a new list of integers which includes all the original elements of the `sorted_array` and all elements from the `unsorted_array`, sorted in non-decreasing order. Example: ```python sorted_array = [1, 3, 5, 7] unsorted_array = [2, 6, 0, 8] result = insert_and_sort(sorted_array, unsorted_array) print(result) # Output: [0, 1, 2, 3, 5, 6, 7, 8] ``` Constraints: 1. Elements of `sorted_array` and `unsorted_array` can be any integer within the range of -10^6 to 10^6. 2. The result should be the most efficient merge of both arrays, utilizing the binary search technique where applicable. Performance Requirements: * Ensure the implementation remains efficient (e.g., use an O(n log n) or better approach).","solution":"import bisect def insert_and_sort(sorted_array, unsorted_array): Inserts elements from the unsorted_array into the sorted_array while maintaining sorted order. Parameters: sorted_array (list): A list of integers sorted in non-decreasing order. unsorted_array (list): A list of integers to be inserted into the sorted array. Returns: list: A new sorted list containing all elements from both input arrays. for num in unsorted_array: bisect.insort(sorted_array, num) return sorted_array"},{"question":"**Scenario**: You are a software developer tasked with optimizing a search functionality in an application. The current implementation uses a linear search to find user IDs in a list. Due to performance concerns with large datasets, you need to implement an enhanced version of the search function. **Task**: Write a function `enhanced_linear_search` that not only finds the index of a user ID but also handles certain specific requirements: 1. If the same user ID appears multiple times, your function should return a list of all indexes where the user ID is found. 2. Optimize for the case where the list is extremely large by implementing an early exit if the user ID is not found after a certain number of checks (this limit will be provided as a parameter). **Function Signature**: ```python def enhanced_linear_search(array: list, query: int, max_checks: int) -> list: Parameters: array (list of int): The list of user IDs. query (int): The user ID to search for. max_checks (int): The maximum number of elements to check before exiting early. Returns: list of int: A list of indexes where the user ID is found. If not found after max_checks elements, return an empty list. pass ``` **Examples**: 1. `enhanced_linear_search([1, 2, 3, 4, 3, 5], 3, 6)` should return `[2, 4]`. 2. `enhanced_linear_search([1, 2, 3, 4, 5], 3, 3)` should return `[2]`. 3. `enhanced_linear_search([1, 2, 3, 4, 3, 5], 6, 6)` should return `[]`. 4. `enhanced_linear_search([1, 2, 3, 4, 3, 5], 3, 2)` should return `[]` (since early exit limit is 2). **Constraints**: - Do not use any built-in functions that provide the same functionality as this exercise. - Aim for clear and readable code. - The list can contain up to 10^6 elements.","solution":"def enhanced_linear_search(array: list, query: int, max_checks: int) -> list: Searches for all occurrences of the query in the array up to max_checks elements. Parameters: array (list of int): The list of user IDs. query (int): The user ID to search for. max_checks (int): The maximum number of elements to check before exiting early. Returns: list of int: A list of indexes where the user ID is found. If not found after max_checks elements, return an empty list. result = [] checks = 0 for index, element in enumerate(array): if checks >= max_checks: break if element == query: result.append(index) checks += 1 return result"},{"question":"# Question: Implement an Efficient Bucket Sort Algorithm Background Bucket Sort is a sorting algorithm that distributes elements of an array into a number of buckets. Each bucket is then sorted individually using a different sorting algorithm. Finally, the sorted buckets are concatenated to form a sorted array. Here you are required to implement an efficient version of Bucket Sort with constraints. Function Signature ```python def efficient_bucket_sort(arr: List[int], bucket_size: int) -> List[int]: ``` Input * **arr**: A list of non-negative integers. * **bucket_size**: An integer value that represents the size of each bucket. Output * **Returns**: A sorted list of integers. Constraints * The input list `arr` can contain up to 10^5 integers. * The range of integers within `arr` is from 0 to 10^6. * You need to ensure the sorting algorithm inside each bucket is efficient for the given constraints. * You are not allowed to use Python\'s built-in sort or any other library sort function. Example ```python assert efficient_bucket_sort([3, 1, 9, 7, 5], 2) == [1, 3, 5, 7, 9] assert efficient_bucket_sort([10, 20, 15, 25, 5, 2], 5) == [2, 5, 10, 15, 20, 25] ``` Notes: Consider using a more efficient sorting algorithm for the bucket sorting process instead of Insertion Sort, like Quick Sort or Merge Sort.","solution":"from typing import List import math def efficient_bucket_sort(arr: List[int], bucket_size: int) -> List[int]: Sorts a list of non-negative integers using the bucket sort algorithm. Parameters: arr (List[int]): List of non-negative integers to sort. bucket_size (int): The size of each bucket. Returns: List[int]: Sorted list of integers. if len(arr) == 0: return [] # Step 1: Find the min and max values in the array min_value, max_value = min(arr), max(arr) # Step 2: Calculate the number of buckets bucket_count = math.ceil((max_value - min_value + 1) / bucket_size) buckets = [[] for _ in range(bucket_count)] # Step 3: Distribute the elements into the buckets for num in arr: index = (num - min_value) // bucket_size buckets[index].append(num) # Step 4: Sort each bucket and concatenate the results sorted_array = [] for bucket in buckets: sorted_bucket = quicksort(bucket) sorted_array.extend(sorted_bucket) return sorted_array def quicksort(arr: List[int]) -> List[int]: Sorts a list of integers using the quicksort algorithm. Parameters: arr (List[int]): List of integers to sort. Returns: List[int]: Sorted list of integers. if len(arr) <= 1: return arr pivot = arr[len(arr) // 2] left = [x for x in arr if x < pivot] middle = [x for x in arr if x == pivot] right = [x for x in arr if x > pivot] return quicksort(left) + middle + quicksort(right)"},{"question":"**Question: Combination Sum with Dynamic Programming** You are given an array of positive integers `nums` and a target integer `target`. Write a function that returns the number of distinct combinations of elements in `nums` that add up to `target`. Note that different sequences are counted as different combinations. # Function Signature: ```python def combination_sum(nums: List[int], target: int) -> int: ``` # Input: * `nums`: A list of positive integers without duplicates. (1 ≤ len(nums) ≤ 100, 1 ≤ nums[i] ≤ 50) * `target`: A positive integer. (1 ≤ target ≤ 1000) # Output: * Return the number of distinct combinations that sum up to `target`. # Constraints: * You can use each element in `nums` as many times as needed. * Consider sequences with the same elements in different orders as different combinations. # Examples: ```python nums = [1, 2, 3] target = 4 combination_sum(nums, target) # should return 7. ``` # Explanation: The different combinations that add up to 4 are: (1, 1, 1, 1), (1, 1, 2), (1, 2, 1), (1, 3), (2, 1, 1), (2, 2), (3, 1) # Follow-up: If negative numbers were allowed in the given array, how might that change the problem? What conditions or limitations would you need to add to manage negative numbers correctly? # Additional Considerations: 1. Consider edge cases like empty array or zero target. 2. Optimize your solution for efficiency. 3. Document your code and approach briefly. Write your implementation below: ```python def combination_sum(nums, target): # Your implementation here ```","solution":"from typing import List def combination_sum(nums: List[int], target: int) -> int: Returns the number of distinct combinations that add up to the target. # Create a list `dp` to store the number of ways to get to each amount from 0 to target dp = [0] * (target + 1) dp[0] = 1 # There\'s 1 way to make 0, by choosing nothing # For every amount from 1 to the target for t in range(1, target + 1): # For each number in nums for num in nums: if t - num >= 0: dp[t] += dp[t - num] return dp[target]"},{"question":"You are given an integer array `arr`. Your task is to write a function `max_contiguous_subsequence_sum` that returns the maximum sum of a contiguous subsequence in the given array. # Input * An integer array `arr` of length n (0 <= n <= 10^5). * The elements of the array can range from -10^5 to 10^5. # Output * An integer which is the maximum sum of a contiguous subsequence from the input array. # Constraints * If the array is empty, return 0. * The subsequence must contain at least one element (an element itself can be a subsequence). # Performance Requirements * Your solution should have a time complexity of O(n) and a space complexity of O(1). # Examples Example 1 Input: ``` arr = [-2, 3, 8, -1, 4] ``` Output: ``` 14 ``` Explanation: The maximum sum of a contiguous subsequence is 14, which is obtained by the subsequence [3, 8, -1, 4]. Example 2 Input: ``` arr = [-1, 1, 0] ``` Output: ``` 1 ``` Explanation: The maximum sum of a contiguous subsequence is 1, which is obtained by the subsequence [1]. Example 3 Input: ``` arr = [-1, -3, -4] ``` Output: ``` -1 ``` Explanation: The maximum sum of a contiguous subsequence is -1, which is obtained by the single element [-1]. Example 4 Input: ``` arr = [-2, 3, 8, -12, 8, 4] ``` Output: ``` 12 ``` Explanation: The maximum sum of a contiguous subsequence is 12, which is obtained by the subsequence [8, 4]. # Function Signature ```python def max_contiguous_subsequence_sum(arr) -> int: # your code here ```","solution":"def max_contiguous_subsequence_sum(arr) -> int: Returns the maximum sum of a contiguous subsequence in the given array. if not arr: return 0 max_current = max_global = arr[0] for num in arr[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"# Question: Finding the Unique Number with Bitwise Operations Background In an array of integers, every element appears three times except for one, which appears exactly once. Your task is to find that single unique integer. Given the constraints, your solution should be efficient in both time and space. Objective Write a function `find_unique(nums)` that takes a list of integers `nums` where every element appears three times except for one element that appears exactly once. Your function should return the unique element. Requirements * **Time Complexity**: O(n) * **Space Complexity**: O(1) * **Constraints**: * Elements in the array are integers. * The array can contain both positive and negative integers. * All elements except one appear exactly three times. # Input * `nums` (List[int]): A list of integers. # Output * Returns an integer which is the unique element that does not appear three times. # Example ```python assert find_unique([2, 2, 3, 2]) == 3 assert find_unique([0, 1, 0, 1, 0, 1, 99]) == 99 assert find_unique([-2, -2, 1, -2]) == 1 assert find_unique([30000, 500, 100, 30000, 100, 30000, 100]) == 500 ``` # Implementation Implement the function using bitwise operations optimized for minimal space usage.","solution":"def find_unique(nums): This function finds the unique number in a list where every element appears three times except for one which appears exactly once. ones = 0 twos = 0 for num in nums: # \'ones & num\' gives the bits that are there in both \'ones\' and \'num\' # We add these bits to \'twos\' using bitwise OR twos |= ones & num # XOR the new number with \'ones\' to maintain the numbers seen odd number of times ones ^= num # The common bit mask between \'ones\' and \'twos\' common_bit_mask = ~(ones & twos) # Remove the common bits from \'ones\' and \'twos\' ones &= common_bit_mask twos &= common_bit_mask return ones"},{"question":"# Quick Sort Optimization and Implementation Quick Sort is a widely used sorting algorithm known for its efficiency in average cases while having potential performance pitfalls with poor pivot choices. Your task is to implement a hybrid version of Quick Sort that improves upon the traditional algorithm by optimizing pivot selection and managing small sub-arrays more efficiently. Task Write a Python function `hybrid_quick_sort(arr, threshold=10, simulation=False)` that takes the following parameters: * `arr`: A list of integers to be sorted. * `threshold`: An integer that determines when to switch to insertion sort for small sub-arrays (default is 10). * `simulation`: A boolean flag to print the array at each iteration (useful for debugging, default is False). Your function should: 1. Use the median-of-three method to choose a pivot. 2. Switch to insertion sort when the size of the sub-array is less than or equal to the threshold. 3. Sort the array in place and return the sorted array. Input * A list of integers: `arr`. * An integer: `threshold` (optional). * A boolean: `simulation` (optional). Output * A list of integers: The sorted list. Constraints * 1 <= len(arr) <= 10^5 * -10^9 <= arr[i] <= 10^9 Example ```python # Example 1: arr = [3, 6, 8, 10, 1, 2, 1] print(hybrid_quick_sort(arr)) # Output: [1, 1, 2, 3, 6, 8, 10] # Example 2: arr = [3, 6, 8, 10, 1, 2, 1] print(hybrid_quick_sort(arr, 2, True)) # Output (example with simulation): # iteration 1 : [3, 1, 2, 1, 6, 8, 10] # iteration 2 : [2, 1, 1, 3, 6, 8, 10] # ... ``` Implementation Notes * Handle small arrays by switching to insertion sort, which can be more efficient for tiny data sets. * Use the median of the first, middle, and last elements as the pivot to improve partitioning. * Ensure the function handles empty arrays and arrays with a single element gracefully. * Your implementation should efficiently manage recursive calls and avoid stack overflow issues on large inputs.","solution":"def median_of_three(arr, low, high): mid = (low + high) // 2 if arr[low] > arr[mid]: arr[low], arr[mid] = arr[mid], arr[low] if arr[low] > arr[high]: arr[low], arr[high] = arr[high], arr[low] if arr[mid] > arr[high]: arr[mid], arr[high] = arr[high], arr[mid] return mid def insertion_sort(arr, low, high): for i in range(low + 1, high + 1): key = arr[i] j = i - 1 while j >= low and key < arr[j]: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key def quick_sort_helper(arr, low, high, threshold, simulation): if low < high: if high - low + 1 <= threshold: insertion_sort(arr, low, high) else: pivot_index = median_of_three(arr, low, high) arr[pivot_index], arr[high] = arr[high], arr[pivot_index] pivot = arr[high] i = low - 1 for j in range(low, high): if arr[j] <= pivot: i += 1 arr[i], arr[j] = arr[j], arr[i] arr[i + 1], arr[high] = arr[high], arr[i + 1] pivot_index = i + 1 if simulation: print(f\\"Iteration: {arr}\\") quick_sort_helper(arr, low, pivot_index - 1, threshold, simulation) quick_sort_helper(arr, pivot_index + 1, high, threshold, simulation) def hybrid_quick_sort(arr, threshold=10, simulation=False): quick_sort_helper(arr, 0, len(arr) - 1, threshold, simulation) return arr"},{"question":"# Coding Task You are given a sorted array of integers and a target integer. Your task is to implement a function that efficiently finds the position of the target using the Jump Search algorithm. If the target is not found, the function should return `-1`. Function Signature ```python def jump_search(arr: List[int], target: int) -> int: ``` Input * `arr` (List[int]): A list of sorted integers where each integer follows `-10^6 <= arr[i] <= 10^6`. * `target` (int): An integer to be searched within the array `arr`. Output * Returns the index of the target if found; otherwise, returns `-1`. Constraints * The array `arr` will be of size `n`, where `0 <= n <= 10^5`. * The elements in the array `arr` are sorted in non-decreasing order. Performance Requirements * Aim for an algorithm that operates with worst-case time complexity of `O(√n)`. # Example ```python assert jump_search([0, 1, 2, 4, 8, 16, 32, 64, 128], 4) == 3 assert jump_search([0, 1, 2, 4, 8, 16, 32, 64, 128], 10) == -1 assert jump_search([], 1) == -1 assert jump_search([1], 1) == 0 ``` # Notes * You need to determine the optimal block size based on the length of the array and ensure the function performs efficiently even for edge cases such as very small or large arrays. * Handle array bounds carefully to avoid `IndexError`. * Ensure the solution is robust and handles all specified edge cases gracefully.","solution":"import math from typing import List def jump_search(arr: List[int], target: int) -> int: Performs Jump Search to find the target in the sorted array. Parameters: arr (List[int]): A list of sorted integers. target (int): The integer to find in the array. Returns: int: The index of the target if found, otherwise -1. n = len(arr) if n == 0: return -1 # calculating the optimal block size step = int(math.sqrt(n)) prev = 0 # finding the block where target may be present while arr[min(step, n) - 1] < target: prev = step step += int(math.sqrt(n)) if prev >= n: return -1 # linear search within the block for i in range(prev, min(step, n)): if arr[i] == target: return i return -1"},{"question":"Scenario You are tasked with implementing a function that efficiently finds the first occurrence of a given number in a sorted list of integers. This function will be used as part of a larger application where searching speed is critical, and the list is generally very large but always sorted. Function Specification Write a function `find_first_occurrence(array, query)` that identifies the first occurrence of `query` in the sorted list `array`. If the `query` is not present in the list, return `-1`. Input * `array` (list of integers): A sorted list in ascending order. * Constraints: `1 <= len(array) <= 10^5` * Each integer in the `array` will be in the range `−10^6` to `10^6`. * `query` (integer): An integer to search for in the `array`. * Constraints: `−10^6 <= query <= 10^6` Output * Return the zero-based index of the first occurrence of the `query`. If the `query` is not present, return `-1`. Example ```python # Example 1 array = [1, 2, 2, 3, 4] query = 2 # Expected Output: 1 # Example 2 array = [1, 2, 2, 3, 4] query = 5 # Expected Output: -1 # Example 3 array = [1, 1, 1, 1, 1] query = 1 # Expected Output: 0 # Example 4 array = [] query = 1 # Expected Output: -1 ``` Constraints * You should ensure that your solution is optimal and runs in O(log n) time complexity. * Consider edge cases such as an empty array, non-existing query, or multiple occurrences of the same query. Function Signature ```python def find_first_occurrence(array: list, query: int) -> int: Returns the index of the first occurrence of the given element in an array. The array has to be sorted in increasing order. ```","solution":"def find_first_occurrence(array, query): Returns the index of the first occurrence of the given element in an array. The array has to be sorted in increasing order. Parameters: array (list of int): A sorted list of integers query (int): The integer to search for in the array Returns: int: The index of the first occurrence of query in array, or -1 if it is not present left, right = 0, len(array) - 1 result = -1 while left <= right: mid = (left + right) // 2 if array[mid] == query: result = mid right = mid - 1 # Continue to search in the left half elif array[mid] < query: left = mid + 1 else: right = mid - 1 return result"},{"question":"# Question You are tasked with implementing an optimized version of the square root calculation for a given number, using the Babylonian method. This method is iterative and requires precision control through an epsilon parameter. Function Signature ```python def optimized_square_root(n: float, epsilon: float = 0.001) -> float: pass ``` Input * `n`: A positive decimal number `n` (1 <= n <= 10^6) representing the number for which the square root is to be calculated. * `epsilon`: A positive decimal number `epsilon` representing the maximum absolute error allowed in the output (1e-12 <= epsilon <= 1e-1). Output * Returns the square root of `n` such that the absolute error in the result is at most `epsilon`. # Example ```python # Example 1 n = 25 epsilon = 0.0001 print(optimized_square_root(n, epsilon)) # should print a value close to 5 # Example 2 n = 2 epsilon = 0.000001 print(optimized_square_root(n, epsilon)) # should print a value close to 1.414213 ``` # Constraints * Ensure the function operates efficiently within the given constraints. * Handle possible edge cases. * Optimize for performance bottlenecks where possible. # Hints * Consider refining the initial guess for better performance. * Ensure proper handling of both large and small values for `n` and `epsilon`.","solution":"def optimized_square_root(n: float, epsilon: float = 0.001) -> float: Calculate the square root of a number using the Babylonian method. Parameters: n (float): The number to find the square root of. epsilon (float): The maximum absolute error allowed in the output. Returns: float: The square root of n with an error of at most epsilon. if n < 0: raise ValueError(\\"Cannot compute square root of a negative number\\") guess = n / 2.0 while True: new_guess = 0.5 * (guess + n / guess) if abs(new_guess - guess) < epsilon: return new_guess guess = new_guess"},{"question":"Problem Statement: You need to implement a doubly linked list with specific functionalities to handle a list of integers. This doubly linked list should support the following operations: 1. **Insert at Head**: Insert a new node with a given value at the head of the list. 2. **Insert at Tail**: Insert a new node with a given value at the tail of the list. 3. **Delete by Value**: Delete the first node that matches the provided value. 4. **Find Middle**: Find the middle node of the list. If the list has an even number of elements, return the first of the two middle elements. 5. **Reverse List**: Reverse the order of the nodes in the list. Constraints: - All values in the list will be integers. - You cannot use any additional data structures such as arrays or lists. Function Specifications: You need to implement a class `DoublyLinkedList` with the following methods: - `__init__(self)`: Initializes an empty list. - `insert_head(self, value: int) -> None`: Inserts a node with the given value at the head of the list. - `insert_tail(self, value: int) -> None`: Inserts a node with the given value at the tail of the list. - `delete_value(self, value: int) -> bool`: Deletes the first node with the given value from the list and returns `True` if the node was found and deleted, otherwise `False`. - `find_middle(self) -> DoublyLinkedListNode`: Returns the middle node of the list. - `reverse(self) -> None`: Reverses the list in place. Example Usage: ```python dll = DoublyLinkedList() dll.insert_head(10) dll.insert_tail(20) dll.insert_head(30) # Current List: 30 <-> 10 <-> 20 middle_node = dll.find_middle() print(middle_node.value) # Output: 10 dll.delete_value(10) # Current List: 30 <-> 20 dll.reverse() # Current List: 20 <-> 30 ``` Evaluation Criteria: - Correctness of implemented functionalities. - Handling edge cases. - Efficient management of node references.","solution":"class DoublyLinkedListNode: def __init__(self, value): self.value = value self.next = None self.prev = None class DoublyLinkedList: def __init__(self): self.head = None self.tail = None def insert_head(self, value: int) -> None: new_node = DoublyLinkedListNode(value) if not self.head: self.head = self.tail = new_node else: new_node.next = self.head self.head.prev = new_node self.head = new_node def insert_tail(self, value: int) -> None: new_node = DoublyLinkedListNode(value) if not self.tail: self.head = self.tail = new_node else: new_node.prev = self.tail self.tail.next = new_node self.tail = new_node def delete_value(self, value: int) -> bool: current = self.head while current: if current.value == value: if current.prev: current.prev.next = current.next if current.next: current.next.prev = current.prev if current == self.head: self.head = current.next if current == self.tail: self.tail = current.prev return True current = current.next return False def find_middle(self) -> DoublyLinkedListNode: slow = fast = self.head while fast and fast.next: slow = slow.next fast = fast.next.next return slow def reverse(self) -> None: current = self.head previous = None self.tail = self.head while current: previous = current.prev current.prev = current.next current.next = previous current = current.prev if previous: self.head = previous.prev"},{"question":"# Atbash Cipher Implementation Scenario You are working as a software engineer and are asked to implement a historical encryption method known as the **Atbash Cipher** for educational purposes. This method maps each letter of the alphabet to its reverse (i.e., \'a\' to \'z\', \'b\' to \'y\', etc.). Your task is to create an encoding function capable of this transformation. Task Write a function `atbash_cipher(text: str) -> str` that takes a single string `text` as its input and returns the Atbash cipher equivalent of the string. Non-alphabetic characters should be left unchanged. Example ```python assert atbash_cipher(\\"Attack at dawn\\") == \\"Zggzxp zg wzdm\\" assert atbash_cipher(\\"Hello, World!\\") == \\"Svool, Dliow!\\" assert atbash_cipher(\\"\\") == \\"\\" ``` Constraints * Input `text` can contain letters (both uppercase and lowercase), digits, punctuation, and whitespace. * The function must handle both empty strings and non-alphabetic characters correctly. * Ensure your solution has time complexity O(n) where n is the number of characters in the input string. Performance Requirements * Your function should run efficiently within the constraints provided.","solution":"def atbash_cipher(text: str) -> str: Returns the Atbash cipher equivalent of the input text. The Atbash cipher maps each letter of the alphabet to its reverse (i.e., \'a\' to \'z\', \'b\' to \'y\', etc.). Non-alphabetic characters are left unchanged. transformed = [] for char in text: if char.isalpha(): if char.islower(): # For lowercase letters transformed_char = chr(219 - ord(char)) # 219 = ord(\'a\') + ord(\'z\') else: # For uppercase letters transformed_char = chr(155 - ord(char)) # 155 = ord(\'A\') + ord(\'Z\') transformed.append(transformed_char) else: # Non-alphabetic characters are not transformed transformed.append(char) return \'\'.join(transformed)"},{"question":"**Problem Statement**: You are tasked with writing a function `unique_chars_preserved_order(s)` that takes a string `s` as input and returns a new string containing only the first occurrence of each character from `s`, preserving their original order. **Function Signature**: ```python def unique_chars_preserved_order(s: str) -> str: ``` **Input**: - `s`: a string where (1 leq |s| leq 10^6). **Output**: - A string containing only the first occurrence of each character from the input string `s`, preserving their original order. **Constraints**: - The input string `s` can consist of any printable ASCII characters, including spaces and punctuation marks. **Example**: ```python assert unique_chars_preserved_order(\\"programming\\") == \\"progamin\\" assert unique_chars_preserved_order(\\"mississippi\\") == \\"misp\\" assert unique_chars_preserved_order(\\"abca\\") == \\"abc\\" assert unique_chars_preserved_order(\\"\\") == \\"\\" ``` **Performance Requirements**: - The algorithm must run in (O(n)) time complexity and (O(n)) space complexity, where (n) is the length of the string. **Scenario**: Imagine you are working on a text processing tool that extracts unique characters from user inputs without losing their original order. Your function will help in cleaning the text data by removing duplicate characters efficiently.","solution":"def unique_chars_preserved_order(s: str) -> str: Returns a new string containing only the first occurrence of each character from the input string s, preserving their original order. seen = set() result = [] for char in s: if char not in seen: seen.add(char) result.append(char) return \'\'.join(result)"},{"question":"Context You are given a sequence of temperature readings, and you need to find the highest temperature recorded in each continuous sub-window of size K. This will help in analyzing maximum temperature trends over different periods. Problem Description Implement a function `max_temperatures_in_windows` that takes an array of integers representing temperature readings and an integer K, representing the size of the sliding window, and returns an array of integers where each element is the maximum temperature recorded in that window. Function Signature ```python def max_temperatures_in_windows(temperatures: List[int], K: int) -> List[int]: ``` Input - `temperatures`: List of integers, the temperature readings. (1 <= len(temperatures) <= 10^5, -10^3 <= temperatures[i] <= 10^3) - `K`: Integer, the size of the sliding window (1 <= K <= len(temperatures)) Output - A list of integers indicating the highest temperature in each continuous sub-array of length K. Constraints - Time complexity should be O(N), with N being the length of the temperature readings list. - Space complexity should be O(K). Example ```python # Example 1 temperatures = [34, 28, 29, 31, 35, 30, 32, 33] K = 3 # Explanation: The windows are [34, 28, 29], [28, 29, 31], [29, 31, 35], [31, 35, 30], [35, 30, 32], [30, 32, 33] # Max in each window: 34, 31, 35, 35, 35, 33 print(max_temperatures_in_windows(temperatures, K)) # Output: [34, 31, 35, 35, 35, 33] # Example 2 temperatures = [23, 23, 23, 23] K = 2 # Explanation: The windows are [23, 23], [23, 23], [23, 23] # Max in each window: 23, 23, 23 print(max_temperatures_in_windows(temperatures, K)) # Output: [23, 23, 23] ``` Notes - Your implementation should handle the edge case when the temperatures array is empty by returning an empty list. - Make sure to test your solution against varied inputs to ensure it handles different scenarios effectively.","solution":"from collections import deque from typing import List def max_temperatures_in_windows(temperatures: List[int], K: int) -> List[int]: Finds the highest temperature in each continuous sub-window of size K. Args: temperatures (List[int]): List of temperature readings. K (int): The size of the sliding window. Returns: List[int]: List of the highest temperatures in each sub-window of size K. if not temperatures or K == 0: return [] deque_index = deque() result = [] for i in range(len(temperatures)): # Remove indices that are out of the current window if deque_index and deque_index[0] < i - K + 1: deque_index.popleft() # Remove elements that are smaller than the current element while deque_index and temperatures[deque_index[-1]] <= temperatures[i]: deque_index.pop() # Add current element index to the deque deque_index.append(i) # The element at the front of the deque is the largest element of # the window, so add it to the result list after the first K-1 elements. if i >= K - 1: result.append(temperatures[deque_index[0]]) return result"},{"question":"# Absolute Path Normalization Scenario: You are building a file management tool that needs to handle and process file paths provided by users. To ensure all file operations occur correctly regardless of how paths are entered (e.g., `~/file`, `./file`, `/absolute/path`), you need a utility function that will correctly convert any given file path into its full absolute path. Task: Write a function `normalize_path(path: str) -> str` that accepts a file path as input and returns its full absolute path. Implementation Details: - Use Python’s `os.path` module to handle path manipulations. - Ensure that any user directory shortcuts like `~` or `~user` are correctly expanded. - Convert any relative paths to absolute paths based on the current working directory from where the script is run. - Your function should handle edge cases like empty strings and malformed paths gracefully. Constraints: - The input `path` will be a string with a maximum length of 1000 characters. - Assume the input path follows Unix-style formatting (use of `/` as the directory separator). - Consider the script is run from a valid environment where user directory shortcuts can be expanded. Example Input/Output: ```python assert normalize_path(\\"~/documents\\") == \\"/home/user/documents\\" # Assuming /home/user is the home directory assert normalize_path(\\"./file.txt\\") == \\"/current/directory/file.txt\\" # Assuming /current/directory is where the script runs assert normalize_path(\\"/absolute/path\\") == \\"/absolute/path\\" assert normalize_path(\\"\\") == \\"/current/directory\\" # Assuming an empty path resolves to current directory ```","solution":"import os def normalize_path(path: str) -> str: Converts the given file path into its full absolute path. # If the path is empty, use the current working directory if not path: return os.getcwd() # Expand to absolute path using correct methods expanded_path = os.path.expanduser(path) absolute_path = os.path.abspath(expanded_path) return absolute_path"},{"question":"# Scenario: You are managing a grid where land and water patches are constantly changing. You need to keep track of the number of distinct islands after each transformation. # Problem Statement: Given a grid filled with water, and a series of addLand operations that convert specific grid positions from water to land, implement a function that returns the number of distinct islands after each operation. An island is defined as a group of horizontally or vertically adjacent lands. # Input Format: - A 2D list of integers, `positions`, where each `positions[i]` contains two integers representing the row and column indices of the grid position to convert from water to land. # Output Format: - A list of integers, representing the number of distinct islands after each addLand operation. # Constraints: - The grid size is not provided explicitly but can be inferred from the positions. - Positions in `positions` are unique and within reasonable practical limits. # Example: ```python positions = [[0,0], [0,1], [1,2], [2,1]] # Initially, the 2x3 grid (or more reasonably 3x3) would be: # 0 0 0 # 0 0 0 # 0 0 0 # After positions[0], the grid would be: # 1 0 0 # 0 0 0 Number of islands = 1 # 0 0 0 # After positions[1], the grid would be: # 1 1 0 # 0 0 0 Number of islands = 1 # 0 0 0 # After positions[2], the grid would be: # 1 1 0 # 0 0 1 Number of islands = 2 # 0 0 0 # After positions[3], the grid would be: # 1 1 0 # 0 0 1 Number of islands = 3 # 0 1 0 # The function should return: [1, 1, 2, 3] ``` # Function Signature: ```python def num_islands(positions: List[List[int]]) -> List[int]: pass ``` # Requirements: - Implement the function `num_islands` using the Union-Find data structure described. - Your function should handle dynamic connectivity efficiently to determine the number of islands after each operation.","solution":"from typing import List, Tuple def num_islands(positions: List[Tuple[int, int]]) -> List[int]: def find(x): if parent[x] != x: parent[x] = find(parent[x]) # path compression return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: parent[rootY] = rootX # union nonlocal count count -= 1 # Helper function to get neighbors def get_neighbors(x, y): for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if (nx, ny) in land_positions: yield (nx, ny) parent = {} land_positions = set() results = [] count = 0 for pos in positions: x, y = pos if (x, y) in land_positions: results.append(count) continue # Mark as land land_positions.add((x, y)) parent[(x, y)] = (x, y) count += 1 # We add a new land, so we increase our island count # Union with neighboring lands for nx, ny in get_neighbors(x, y): union((x, y), (nx, ny)) results.append(count) return results"},{"question":"# ZigZag Iterator Implementation You are given two lists of integers `v1` and `v2`. Implement a ZigZag Iterator class that returns elements from `v1` and `v2` in alternating order until all elements have been returned. The iterator should handle lists of different lengths and empty lists as well. Function Specifications: 1. `__init__(self, v1: List[int], v2: List[int]) -> None`: - Initializes the iteration with two input lists `v1` and `v2`. 2. `next(self) -> int`: - Returns the next element in the zigzag order. 3. `has_next(self) -> bool`: - Returns `True` if there are more elements to return, else `False`. Constraints: - Both input lists can have lengths ranging from 0 to 1000. - Values in the lists are integers in the range [-10000, 10000]. Example: ```python # Example usage: v1 = [1, 2, 3, 7] v2 = [4, 5, 6] iterator = ZigZagIterator(v1, v2) result = [] while iterator.has_next(): result.append(iterator.next()) print(result) # Output: [1, 4, 2, 5, 3, 6, 7] ``` Notes: - The `next` and `has_next` methods should operate in O(1) time. - Handle edge cases where one or both lists are empty, or lists of uneven lengths. Implement the `ZigZagIterator` class according to the specifications above.","solution":"from typing import List class ZigZagIterator: def __init__(self, v1: List[int], v2: List[int]) -> None: self.queue = [] if v1: self.queue.append((v1, 0)) if v2: self.queue.append((v2, 0)) def next(self) -> int: if not self.has_next(): raise Exception(\\"No more elements\\") v, idx = self.queue.pop(0) value = v[idx] if idx + 1 < len(v): self.queue.append((v, idx + 1)) return value def has_next(self) -> bool: return len(self.queue) > 0"},{"question":"Context In many applications, it\'s essential to ensure that two different sequences (a pattern and a string) follow analogous structures. This is usually solved by establishing a bijection between characters in a pattern and words in the string. Task Write a function `word_pattern(pattern: str, s: str) -> bool` that verifies if the given string `s` follows the same pattern described by `pattern`. Input and Output Format - **Input**: - `pattern` (a string of lowercase letters): The pattern to follow. - `s` (a string of words separated by a single space): The string to verify against the pattern. - **Output**: - Return `True` if `s` follows the pattern described by `pattern`, otherwise return `False`. Constraints - You may assume `pattern` contains only lowercase letters. - The `s` string contains only lowercase letters separated by a single space. Example Cases **Case 1**: ``` Input: \\"abba\\", \\"dog cat cat dog\\" Output: True ``` **Case 2**: ``` Input: \\"abba\\", \\"dog cat cat fish\\" Output: False ``` **Case 3**: ``` Input: \\"aaaa\\", \\"dog cat cat dog\\" Output: False ``` **Case 4**: ``` Input: \\"abba\\", \\"dog dog dog dog\\" Output: False ``` # Implementation Notes Consider the potential edge cases and ensure your function handles them properly: - Different lengths between pattern and split words. - Repeated words that may not conform to a unique character mapping. Good luck!","solution":"def word_pattern(pattern: str, s: str) -> bool: words = s.split() if len(pattern) != len(words): return False char_to_word = {} word_to_char = {} for c, w in zip(pattern, words): if c in char_to_word: if char_to_word[c] != w: return False else: if w in word_to_char and word_to_char[w] != c: return False char_to_word[c] = w word_to_char[w] = c return True"},{"question":"Problem Statement You are tasked with verifying if a given string follows a specified pattern. The function should determine if there is a bijection between characters in the `pattern` and non-empty words in the `string`. Requirements - Implement a function `word_pattern(pattern: str, string: str) -> bool` that returns True if the string follows the given pattern, otherwise False. Input - `pattern`: A string containing only lowercase letters (1 ≤ len(pattern) ≤ 10^4). - `string`: A string containing lowercase letters separated by a single space (1 ≤ len(string) ≤ 10^4). Output - Return `True` if `string` follows the `pattern`. - Return `False` otherwise. Constraints - You may assume pattern contains only lowercase letters. - `string` contains lowercase letters separated by a single space. Examples 1. `word_pattern(\\"abba\\", \\"dog cat cat dog\\")` returns `True` 2. `word_pattern(\\"abba\\", \\"dog cat cat fish\\")` returns `False` 3. `word_pattern(\\"aaaa\\", \\"dog cat cat dog\\")` returns `False` 4. `word_pattern(\\"abba\\", \\"dog dog dog dog\\")` returns `False` Notes - Consider edge cases where the `pattern` and `string` lengths mismatch. - Ensure that the bijection between pattern characters and words is maintained strictly without deviation.","solution":"def word_pattern(pattern, string): Determine if the string follows the given pattern. words = string.split() # If lengths of pattern and words do not match, return False if len(pattern) != len(words): return False # Maps for pattern to word and word to pattern char_to_word = {} word_to_char = {} for ch, word in zip(pattern, words): if ch in char_to_word: if char_to_word[ch] != word: return False if word in word_to_char: if word_to_char[word] != ch: return False char_to_word[ch] = word word_to_char[word] = ch return True"},{"question":"You are required to implement the `comb_sort` function to sort a list of integers using the Comb Sort algorithm. # Function Signature ```python def comb_sort(arr: List[int]) -> List[int]: pass ``` # Input * `arr` - A list of integers of length `n` where `1 <= n <= 10^4`. # Output * Return the sorted list of integers in ascending order. # Constraints * The elements in the list are integers in the range `-10^6` to `10^6`. # Example ```python assert comb_sort([32, 24, 5, -4, 78, 3, 19, 0]) == [-4, 0, 3, 5, 19, 24, 32, 78] assert comb_sort([1, 0, -1, -1, 3, 4]) == [-1, -1, 0, 1, 3, 4] assert comb_sort([100]) == [100] assert comb_sort([]) == [] ``` # Performance Considerations * Ensure your solution handles edge cases such as single-element lists or empty lists efficiently. * Optimize the gap reduction strategy to reduce the number of passes over the list. # Explanation Comb Sort improves on Bubble Sort by comparing elements that are far apart, then gradually reducing the gap between elements being compared. The initial gap is typically set to the size of the list divided by a shrink factor (generally 1.3), and this gap is reduced by dividing by the shrink factor each time until it reaches 1. At that point, the list is bubble-sorted traditionally. Implement the Comb Sort algorithm with the principles outlined above and ensure that the function adheres to the stated constraints and returns correct results for the given examples.","solution":"def comb_sort(arr): Sorts a list of integers using the Comb Sort algorithm. def get_next_gap(gap): # Shrink gap by Shrink factor 1.3 gap = (gap * 10) // 13 if gap < 1: return 1 return int(gap) n = len(arr) gap = n sorted = False while gap != 1 or not sorted: gap = get_next_gap(gap) sorted = True for i in range(0, n - gap): if arr[i] > arr[i + gap]: arr[i], arr[i + gap] = arr[i + gap], arr[i] sorted = False return arr"},{"question":"Implementing Enhancements in Merge Sort Merge Sort is a commonly used sorting algorithm that uses a divide-and-conquer approach to arrange elements in a sorted order. Given its fundamental importance, understanding its intricacies and improving on its basic implementation is critical. One typical shortcoming in the traditional implementation of Merge Sort is its additional memory usage. Your task is to enhance the existing Merge Sort code to efficiently handle larger datasets by optimizing memory usage without changing its basic operational principles. Task Implement an improved version of Merge Sort that minimizes additional memory usage while maintaining its sorting stability and time complexity. Requirements 1. **Function to Implement**: `optimized_merge_sort(arr: List[int]) -> List[int]` 2. **Input Format**: A list of integers `arr` with size `n` where `0 <= n <= 10^6`. 3. **Output Format**: A new sorted list of integers derived from the input list `arr`. Constraints - Ensure the algorithm maintains an average time complexity of O(n log(n)). - Try to minimize the additional space usage beyond what is required for recursion. - Your solution should handle edge cases such as an empty array or an already sorted array efficiently. Performance Requirements - The function should efficiently handle the worst-case input arrays with a constraint of `10^6` elements. - The function should not result in a stack overflow error for large inputs due to recursion. # Example **Input** ```python arr = [38, 27, 43, 3, 9, 82, 10] ``` **Output** ```python [3, 9, 10, 27, 38, 43, 82] ```","solution":"def optimized_merge_sort(arr): Sorts an array of integers using the merge sort algorithm with optimized memory usage. def merge(left, right): sorted_list = [] i = j = 0 # Merge the two halves while maintaining order while i < len(left) and j < len(right): if left[i] <= right[j]: sorted_list.append(left[i]) i += 1 else: sorted_list.append(right[j]) j += 1 # Append any remaining elements sorted_list.extend(left[i:]) sorted_list.extend(right[j:]) return sorted_list def merge_sort(arr): # Base case: Single element is already sorted if len(arr) <= 1: return arr # Split the array into halves mid = len(arr) // 2 left = arr[:mid] right = arr[mid:] # Recursively split and merge return merge(merge_sort(left), merge_sort(right)) # Perform merge sort return merge_sort(arr)"},{"question":"# Question: Bit Masking Utility Functions Write a collection of functions for bit manipulation that will be used to manage device configurations in an embedded system. The system configuration is represented as a 32-bit integer, where each bit can be individually set, cleared, or queried to control specific features or settings. Functions to Implement: 1. **get_bit(num: int, i: int) -> bool**: Returns the boolean value of the bit at index `i`. 2. **set_bit(num: int, i: int) -> int**: Returns the integer resulting from setting the bit at index `i`. 3. **clear_bit(num: int, i: int) -> int**: Returns the integer resulting from clearing the bit at index `i`. 4. **update_bit(num: int, i: int, bit: bool) -> int**: Returns the integer resulting from setting the bit at index `i` to the given boolean value. Constraints: * `num` is a 32-bit unsigned integer (0 <= `num` <= 2^32 - 1). * `i` is a valid bit index (0 <= `i` <= 31). * `bit` is a boolean value. Input and Output Examples: ```python assert get_bit(5, 0) == True # 5 => 000...0101 (LSB is 1) assert get_bit(5, 1) == False # 5 => 000...0101 (Second bit is 0) assert set_bit(5, 1) == 7 # Setting second bit of 5 => 000...0111 (7) assert clear_bit(5, 0) == 4 # Clearing LSB of 5 => 000...0100 (4) assert update_bit(5, 1, True) == 7 # Setting second bit to 1 => 7 assert update_bit(5, 0, False) == 4 # Setting LSB to 0 => 4 ``` Implement these functions to ensure exact control over specific bits in the 32-bit integer.","solution":"def get_bit(num: int, i: int) -> bool: Returns the boolean value of the bit at index `i`. return (num & (1 << i)) != 0 def set_bit(num: int, i: int) -> int: Returns the integer resulting from setting the bit at index `i`. return num | (1 << i) def clear_bit(num: int, i: int) -> int: Returns the integer resulting from clearing the bit at index `i`. return num & ~(1 << i) def update_bit(num: int, i: int, bit: bool) -> int: Returns the integer resulting from setting the bit at index `i` to the given boolean value. mask = ~(1 << i) return (num & mask) | (int(bit) << i)"},{"question":"You are tasked with implementing a custom algorithm to encode and decode a list of strings. This will help in situations where you need to transmit or store a collection of strings securely. **Encode Function**: - **Input**: A list of strings `List[str]`. - **Output**: A single encoded string `str`. **Decode Function**: - **Input**: A single encoded string `str`. - **Output**: A list of strings `List[str]`. # Requirements: 1. Implement the `encode` function that converts a list of strings into a single encoded string. 2. Implement the `decode` function that decodes the encoded string back into the original list of strings. 3. Ensure your solution handles edge cases such as empty strings within the list and the list being empty. # Function Definitions: ```python def encode(strs): Encodes a list of strings to a single string. :type strs: List[str] :rtype: str pass def decode(s): Decodes a single string to a list of strings. :type s: str :rtype: List[str] pass ``` # Constraints: - The elements in the list `strs` are guaranteed to be valid strings. - Do not use any built-in serialization libraries (e.g., `json`, `pickle`). - Assume input sizes are reasonable for a single pass solution. # Example: ```python # Example original_strings = [\\"hello\\", \\"world\\"] encoded_string = encode(original_strings) print(encoded_string) # \\"5:hello5:world\\" decoded_strings = decode(encoded_string) print(decoded_strings) # [\\"hello\\", \\"world\\"] ``` Considerations: - Pay attention to handling strings that include special characters like `:` or digits. - Ensure robust handling of edge cases like empty strings or completely empty lists.","solution":"def encode(strs): Encodes a list of strings to a single string. :type strs: List[str] :rtype: str return \'\'.join(f\'{len(s)}:{s}\' for s in strs) def decode(s): Decodes a single string to a list of strings. :type s: str :rtype: List[str] strs = [] i = 0 while i < len(s): j = i while s[j] != \':\': j += 1 length = int(s[i:j]) strs.append(s[j + 1: j + 1 + length]) i = j + 1 + length return strs"},{"question":"# Objective Write a function to implement matrix multiplication and handle edge cases effectively. Task Given two 2D lists representing matrices, return their product if they are conformable. If not, raise an appropriate exception. # Function Signature ```python def multiply(multiplicand: list[list[int]], multiplier: list[list[int]]) -> list[list[int]]: ``` # Input * **multiplicand**: A 2D list of integers representing the first matrix with dimensions (m x n). * **multiplier**: A 2D list of integers representing the second matrix with dimensions (n x p). # Output * A 2D list of integers representing the resultant matrix with dimensions (m x p). # Constraints 1. The elements of the matrices will be integers in the range [-100, 100]. 2. The number of columns in the multiplicand should match the number of rows in the multiplier. # Scenarios and Context Matrix multiplication is frequently used in science and engineering applications such as simulations and processing of transformations. Understanding the algorithm is crucial in various fields, including machine learning, robotics, and graphics. # Example ```python multiplicand = [ [1, 2], [3, 4] ] multiplier = [ [5, 6], [7, 8] ] print(multiply(multiplicand, multiplier)) # Output: [[19, 22], [43, 50]] ``` # Additional Requirements * Ensure your function raises an exception when the matrices are not compatible. * You must handle cases where the input matrices are empty or not properly formatted.","solution":"def multiply(multiplicand: list[list[int]], multiplier: list[list[int]]) -> list[list[int]]: # Check if either matrix is empty if not multiplicand or not multiplier: raise ValueError(\\"Input matrices cannot be empty.\\") # Validate the dimensions num_rows_multiplicand = len(multiplicand) num_cols_multiplicand = len(multiplicand[0]) num_rows_multiplier = len(multiplier) num_cols_multiplier = len(multiplier[0]) if num_cols_multiplicand != num_rows_multiplier: raise ValueError(\\"Number of columns in the multiplicand must equal the number of rows in the multiplier.\\") # Initialize the resulting matrix with zeros result = [[0 for _ in range(num_cols_multiplier)] for _ in range(num_rows_multiplicand)] # Perform matrix multiplication for i in range(num_rows_multiplicand): for j in range(num_cols_multiplier): for k in range(num_cols_multiplicand): # num_cols_multiplicand is same as num_rows_multiplier result[i][j] += multiplicand[i][k] * multiplier[k][j] return result"},{"question":"# Question: Implement a Custom Sort with Trace You are tasked with implementing a custom sorting function that extends the selection sort algorithm. Your modified function should not only sort an array of integers but also trace and print the steps of the sorting process, similar to a simulation. # Requirements: 1. **Input**: - An unsorted list of integers, `arr`. - A Boolean flag `trace` that when set to `True`, a step-by-step execution trace should be printed. 2. **Output**: - A sorted list of integers (in ascending order). 3. **Constraints**: - You should use the selection sort algorithm. - If `trace` is `True`, print the array at the start and after each iteration of the outer loop. - Ensure minimal auxiliary space is used; the sort must be in-place. 4. **Performance**: - The algorithm must be O(n^2) with O(1) extra space complexity. # Function Signature ```python def custom_selection_sort(arr: List[int], trace: bool) -> List[int]: pass ``` # Example: ```python # Example 1 arr = [64, 25, 12, 22, 11] trace = True custom_selection_sort(arr, trace) # Output: # iteration 0: 64 25 12 22 11 # iteration 1: 11 25 12 22 64 # iteration 2: 11 12 25 22 64 # iteration 3: 11 12 22 25 64 # iteration 4: 11 12 22 25 64 # Example 2 arr = [3, 1, 2] trace = True custom_selection_sort(arr, trace) # Output: # iteration 0: 3 1 2 # iteration 1: 1 3 2 # iteration 2: 1 2 3 ``` Write the function `custom_selection_sort` that follows these requirements and tests the functionality with the given examples.","solution":"from typing import List def custom_selection_sort(arr: List[int], trace: bool) -> List[int]: n = len(arr) for i in range(n): min_idx = i if trace: print(f\\"iteration {i}: {\' \'.join(map(str, arr))}\\") for j in range(i + 1, n): if arr[j] < arr[min_idx]: min_idx = j arr[i], arr[min_idx] = arr[min_idx], arr[i] if trace: print(f\\"iteration {n-1}: {\' \'.join(map(str, arr))}\\") return arr"},{"question":"# Interval Management and Merging **Scenario**: You are tasked with managing appointment times at a clinic, which can have overlapping times. Your goal is to merge overlapping intervals to ensure there are no conflicts in the schedule. Function Specification **Function Name**: `merge_appointments` **Input**: - A list of tuples, each representing an interval with start and end times, e.g., `[(1, 3), (2, 4), (5, 7)]`. **Output**: - A list of merged intervals, returned as tuples, e.g., `[(1, 4), (5, 7)]`. **Constraints**: - The list can contain any number of intervals, including zero. - Interval start and end times are integers, and start ≤ end. # Tasks 1. Implement the `merge_appointments` function to correctly merge overlapping intervals. 2. Write test cases to demonstrate your function works on typical cases, edge cases, and large inputs. # Implementation Guidelines - Sort the intervals by their start time before merging. - Use an efficient strategy with a complexity of O(n log n) for sorting followed by O(n) for merging. - Consider edge cases like completely non-overlapping intervals or fully contained intervals. # Example ```python def merge_appointments(intervals): # Function implementation goes here # Example usage: intervals = [(1, 3), (2, 4), (5, 7)] merged_intervals = merge_appointments(intervals) print(merged_intervals) # Output should be: [(1, 4), (5, 7)] ``` Constraints: - Performance should be optimal for large lists of intervals. - Handle edge cases with non-overlapping, fully overlapping, empty inputs, etc. **HINT**: Use sorting and careful interval management to achieve accurate merging.","solution":"def merge_appointments(intervals): Given a list of appointment intervals, merge all overlapping intervals. :param intervals: List of tuples where each tuple represents an interval (start, end) :return: List of merged intervals as tuples # Step 1: Sort the intervals by start time intervals.sort(key=lambda x: x[0]) merged_intervals = [] for interval in intervals: # If merged_intervals is empty or no overlap, add the current interval if not merged_intervals or merged_intervals[-1][1] < interval[0]: merged_intervals.append(interval) else: # There is overlap, merge the current interval with the previous one merged_intervals[-1] = (merged_intervals[-1][0], max(merged_intervals[-1][1], interval[1])) return merged_intervals"},{"question":"You are given a singly linked list where each node contains an integer value. Your task is to implement a function that removes all duplicates from the list while maintaining the order of the nodes. Implement two functions: 1. `remove_duplicates(head: Node) -> Node`: This function should remove duplicates using O(N) extra space (by leveraging a hashset). 2. `remove_duplicates_in_place(head: Node) -> Node`: This function should remove duplicates without using any extra space, with O(1) space complexity. # Input and Output Input * `head`: The head of the singly linked list. Output * Return the head of the modified linked list with duplicates removed. # Constraints * The number of nodes in the list will be between 0 and 10^5. * Each node\'s value will be an integer between -10^9 and 10^9. # Performance Requirements * For `remove_duplicates`, the time complexity should be O(N) and the space complexity should be O(N). * For `remove_duplicates_in_place`, the time complexity should be O(N^2) and the space complexity should be O(1). # Examples ```python # Example 1: # Input: A -> B -> C -> A -> B -> D # Output from remove_duplicates: A -> B -> C -> D # Output from remove_duplicates_in_place: A -> B -> C -> D # Example 2: # Input: 1 -> 1 -> 1 -> 1 -> 1 # Output from remove_duplicates: 1 # Output from remove_duplicates_in_place: 1 # Example 3: # Input: Empty List (head is None) # Output from remove_duplicates and remove_duplicates_in_place: None ``` # Function Signature ```python class Node: def __init__(self, val=None): self.val = val self.next = None def remove_duplicates(head: Node) -> Node: # implement the function def remove_duplicates_in_place(head: Node) -> Node: # implement the function ```","solution":"class Node: def __init__(self, val=None): self.val = val self.next = None def remove_duplicates(head: Node) -> Node: if not head: return head current = head seen = set() seen.add(current.val) while current.next: if current.next.val in seen: current.next = current.next.next else: seen.add(current.next.val) current = current.next return head def remove_duplicates_in_place(head: Node) -> Node: if not head: return head current = head while current: runner = current while runner.next: if runner.next.val == current.val: runner.next = runner.next.next else: runner = runner.next current = current.next return head"},{"question":"Scenario You have been hired to optimize a warehouse inventory system. The system must keep an ordered list of product prices; however, products arrive in an arbitrary order. You need to implement an optimized insertion sort algorithm that leverages binary search to find the correct insertion points to minimize the number of comparisons. Question **Optimized Insertion Sort** You are required to implement an optimized insertion sort function called `optimized_insertion_sort` which sorts an array of integers in ascending order. To find the correct insertion position, use the `search_insert` function provided. Your task is to: 1. Implement the `optimized_insertion_sort` function with the following signature: ```python def optimized_insertion_sort(array: list) -> list: pass ``` 2. Use the `search_insert` helper function to determine the insertion index. 3. Ensure the original order of equal elements is maintained (i.e., the sort should be stable). Input * A list of integers, `array`, of length `n` where 1 <= n <= 1000. Output * A sorted list of integers in ascending order. Example ```python assert optimized_insertion_sort([4, 2, 3, 1]) == [1, 2, 3, 4] assert optimized_insertion_sort([7, 2, 5, 3, 9]) == [2, 3, 5, 7, 9] ``` Constraints * Ensure the function completes within a reasonable time for the upper limit of n. **Hints**: - Make use of the `search_insert` function to find the correct position for each element. - Remember that inserting an element involves shifting the elements at and after the insertion point.","solution":"from bisect import bisect_left def search_insert(array, value): Find the index where value should be inserted to keep array sorted. return bisect_left(array, value) def optimized_insertion_sort(array: list) -> list: Perform an optimized insertion sort on the input array using binary search. if not array: return array sorted_array = [] for value in array: # Find the position where the current value should be inserted pos = search_insert(sorted_array, value) # Insert the value at the found position, list.insert() maintains order sorted_array.insert(pos, value) return sorted_array"},{"question":"Question: Sum of Digits Raised to Powers # Problem Statement Given an range of integers between `low` and `high` (inclusive), write a function `sum_dig_pow(low, high)` that returns a list of numbers whose digits raised to consecutive powers sum to the original number. These numbers are known as \\"Eureka numbers.\\" # Input - `low` (int): The lower bound of the range (1 <= low <= high <= 1000). - `high` (int): The upper bound of the range. # Output - List of integers that satisfy the given property within the provided range. # Constraints - The function should not use more than O(n * d) time complexity, where n is the number of integers in the range and d is the number of digits in the largest number in the range. # Performance Requirements - Your solution should be able to handle ranges where the difference between `low` and `high` is up to 1000. # Example ```python def sum_dig_pow(low, high): result = [] for number in range(low, high + 1): exponent = 1 summation = 0 number_as_string = str(number) tokens = list(map(int, number_as_string)) for k in tokens: summation += (k ** exponent) exponent += 1 if summation == number: result.append(number) return result # Test Cases print(sum_dig_pow(1, 10)) # Expected Output: [1, 2, 3, 4, 5, 6, 7, 8, 9] print(sum_dig_pow(1, 100)) # Expected Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 89] print(sum_dig_pow(90, 150)) # Expected Output: [135] print(sum_dig_pow(1, 1000)) # Expected Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 89, 135, 175, 518, 598] ``` Create a function `sum_dig_pow` that follows the given constraints and passes the provided test cases. Ensure your implementation is efficient and handles edge cases effectively.","solution":"def sum_dig_pow(low, high): Returns a list of numbers whose digits raised to consecutive powers sum to the original number. result = [] for number in range(low, high + 1): summation = sum(int(digit) ** (idx + 1) for idx, digit in enumerate(str(number))) if summation == number: result.append(number) return result # Example usage print(sum_dig_pow(1, 10)) # Expected Output: [1, 2, 3, 4, 5, 6, 7, 8, 9] print(sum_dig_pow(1, 100)) # Expected Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 89] print(sum_dig_pow(90, 150)) # Expected Output: [135] print(sum_dig_pow(1, 1000)) # Expected Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 89, 135, 175, 518, 598]"},{"question":"**Problem Statement**: You are given a non-empty string `word`, and your task is to write a function `generate_abbreviations` that returns all possible general abbreviations of the string. Each abbreviation is formed by replacing any number of non-overlapping substrings with their lengths. For example, the string `\\"word\\"` can be abbreviated as `[w, wo, wor, word, w1, w2, ..., 1ord, 1or1, ... 4]`. **Function Signature**: ```python def generate_abbreviations(word: str) -> List[str]: pass ``` **Input Format**: * A single string `word` with lowercase English letters (1 ≤ len(word) ≤ 20). **Output Format**: * A list of strings containing all possible abbreviations of `word`. **Constraints**: * The length of `word` will be between 1 and 20, inclusive. * The output list can be in any order. **Example**: ```python word = \\"word\\" # output can be in any order print(generate_abbreviations(word)) # Output: [\'word\', \'wor1\', \'wo1d\', \'wo2\', \'w1rd\', \'w1r1\', \'w2d\', \'w3\', \'1ord\', \'1or1\', \'1o1d\', \'1o2\', \'2rd\', \'2r1\', \'3d\', \'4\'] ``` **Scenarios and Context**: Consider a scenario where you are working on developing a software that generates all possible mnemonics for a given input word. The solution should explore all different ways of creating mnemonics by abbreviating parts of the word.","solution":"from typing import List def generate_abbreviations(word: str) -> List[str]: def backtrack(pos: int, cur: str, count: int): if pos == len(word): if count > 0: cur += str(count) result.append(cur) else: # Option 1: Abbreviate the current character backtrack(pos + 1, cur, count + 1) # Option 2: Keep the current character if count > 0: cur += str(count) backtrack(pos + 1, cur + word[pos], 0) result = [] backtrack(0, \\"\\", 0) return result"},{"question":"# Problem Description You are tasked with implementing a Segment Tree to handle a series of range query and update operations over an array using a commutative function. The Segment Tree should efficiently manage these operations in logarithmic time. # Requirements 1. Implement a SegmentTree class with the following methods: - `__init__(self, arr, function)`: - `arr` (List): The input array. - `function` (Callable): A commutative binary function applied to the array elements for range queries. - `update(self, index, value)`: - `index` (int): The position in the array to update. - `value` (Any): The new value to update at the array position. - `query(self, left, right)`: - `left` (int): The start index of the range (inclusive). - `right` (int): The end index of the range (inclusive). # Input 1. An array of integers (or tuples of integers) `arr` (1 <= len(arr) <= 10^5). 2. A query or update operation to be applied on the Segment Tree. # Output The result of the range query operation when called. Update operations will only adjust the internal state without any output. # Constraints - The commutative function must be applicable and should follow the properties of commutativity. - Aligned to handle edge cases such as invalid indices or empty input arrays. # Task You need to design the `SegmentTree` class that satisfies the given requirements and constraints. # Example ```python # Commutative function: max arr = [2, 4, 5, 3, 4] mytree = SegmentTree(arr, max) print(mytree.query(2, 4)) # Output: 5 mytree.update(3, 6) print(mytree.query(0, 3)) # Output: 6 # Commutative function: sum arr = [4, 5, 2, 3, 4, 43, 3] mytree = SegmentTree(arr, lambda a, b: a + b) print(mytree.query(0, 6)) # Output: 64 mytree.update(2, -10) print(mytree.query(0, 6)) # Output: 52 # Commutative function: tuple addition arr = [(1, 2), (4, 6), (4, 5)] mytree = SegmentTree(arr, lambda a, b: (a[0] + b[0], a[1] + b[1])) print(mytree.query(0, 2)) # Output: (9, 13) mytree.update(2, (-1, 2)) print(mytree.query(0, 2)) # Output: (4, 10) ``` Your implementation should correctly generate outputs for the example cases and handle various edge conditions efficiently.","solution":"class SegmentTree: def __init__(self, arr, function): self.n = len(arr) self.function = function self.tree = [None] * (2 * self.n) self.build(arr) def build(self, arr): # Initialize leaves for i in range(self.n): self.tree[self.n + i] = arr[i] # Initialize internal nodes for i in range(self.n - 1, 0, -1): self.tree[i] = self.function(self.tree[i * 2], self.tree[i * 2 + 1]) def update(self, index, value): # Set value at position index index += self.n self.tree[index] = value # Update the Segment Tree nodes while index > 1: index //= 2 self.tree[index] = self.function(self.tree[index * 2], self.tree[index * 2 + 1]) def query(self, left, right): # Range query left += self.n right += self.n + 1 result = None while left < right: if left % 2 == 1: if result is None: result = self.tree[left] else: result = self.function(result, self.tree[left]) left += 1 if right % 2 == 1: right -= 1 if result is None: result = self.tree[right] else: result = self.function(result, self.tree[right]) left //= 2 right //= 2 return result"},{"question":"You are a systems programmer tasked with designing a high-performance sorting module for a distributed computing system. Your job is to implement the `bitonic_sort` function, capable of sorting arrays both in ascending and descending order. The `bitonic_sort` function must accept arrays whose sizes are a power of two and handle them efficiently using the Bitonic Sort algorithm. # Function Signature: ```python def bitonic_sort(arr: List[int], reverse: bool = False) -> List[int]: ``` # Input: * `arr` (List[int]): A list of integers where the size is a power of two; 1 <= len(arr) <= 2^10. * `reverse` (bool): If `True`, the function should return the array in descending order; if `False`, in ascending order. (default is `False`) # Output: * Returns the sorted list (List[int]). # Constraints: * You must use the Bitonic Sort algorithm. * You should handle arrays whose sizes are powers of two. # Example: ```python assert bitonic_sort([3, 7, 4, 8, 6, 2, 1, 5]) == [1, 2, 3, 4, 5, 6, 7, 8] assert bitonic_sort([3, 7, 4, 8, 6, 2, 1, 5], reverse=True) == [8, 7, 6, 5, 4, 3, 2, 1] ``` # Notes: * Consider the function should raise an error `ValueError` if the size of the input array is not a power of two. * Include error handling for invalid input sizes and provide detailed tests for edge cases, such as arrays of length 1 or lengths that are not a power of two. * Assess the possible improvements your implementation would need if it were to be optimized for a parallel execution environment.","solution":"from typing import List def bitonic_sort(arr: List[int], reverse: bool = False) -> List[int]: Sorts a list of integers using the Bitonic Sort algorithm. Parameters: - arr (List[int]): The list of integers to sort. Length must be a power of two. - reverse (bool): If True, sorts the list in descending order. Default is False, which sorts in ascending order. Returns: - List[int]: The sorted list. Raises: - ValueError: If the size of arr is not a power of two. # Helper function to check if the length of the array is a power of two def is_power_of_two(n: int) -> bool: return (n != 0) and (n & (n - 1)) == 0 # Raise an error if the size of the array is not a power of two if not is_power_of_two(len(arr)): raise ValueError(\\"The size of the array must be a power of two\\") def compare_and_swap(arr, i, j, direction): if (direction == (arr[i] > arr[j])): arr[i], arr[j] = arr[j], arr[i] def bitonic_merge(arr, low, cnt, direction): if cnt > 1: k = cnt // 2 for i in range(low, low + k): compare_and_swap(arr, i, i + k, direction) bitonic_merge(arr, low, k, direction) bitonic_merge(arr, low + k, k, direction) def bitonic_sort_recursive(arr, low, cnt, direction): if cnt > 1: k = cnt // 2 bitonic_sort_recursive(arr, low, k, True) bitonic_sort_recursive(arr, low + k, k, False) bitonic_merge(arr, low, cnt, direction) # Sorting in the specified direction bitonic_sort_recursive(arr, 0, len(arr), not reverse) return arr"},{"question":"Context You have been tasked with writing a function to determine whether a given number is prime. A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself. Specification Your task is to implement the function `is_prime(n: int) -> bool` as described below: ```python def is_prime(n: int) -> bool: Determine if the provided integer is a prime number. Parameters: n (int): The number to check for primality. Returns: bool: True if n is a prime number, False otherwise. pass ``` Input and Output - **Input**: * An integer `n` where -2^31 ≤ n ≤ 2^31 - 1. - **Output**: * Returns `True` if `n` is a prime number, `False` otherwise. Examples ```python is_prime(5) -> True is_prime(10) -> False is_prime(1) -> False is_prime(13) -> True is_prime(25) -> False ``` Constraints 1. You need to implement this function without using any libraries specifically designed for number theory. 2. Performance requirements expect that your algorithm efficiently handles numbers up to several million. 3. Consider edge cases such as negative numbers, zero and one, and handle non-positive numbers gracefully. Performance Requirements - The algorithm should generally run in O(√n) time complexity. - The space complexity should be O(1).","solution":"def is_prime(n: int) -> bool: Determine if the provided integer is a prime number. Parameters: n (int): The number to check for primality. Returns: bool: True if n is a prime number, False otherwise. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True"},{"question":"**Problem Statement**: Mitzy is a linguistics student who is investigating the completeness of certain texts. A complete text is defined as one that includes every letter of the English alphabet at least once, irrespective of case. Write a function that determines whether a given string is a pangram. Your task is to implement the function `is_pangram(input_string)` that: - **Input**: A single string `input_string` (1 ≤ len(input_string) ≤ 10^6). - **Output**: A boolean value `True` if the input string is a pangram, and `False` otherwise. # Constraints: - The function should ignore case; treat \\"A\\" and \\"a\\" as the same. - The input may contain non-alphabetic characters, which should be ignored in the determination. # Examples: ```python assert is_pangram(\\"The quick brown fox jumps over the lazy dog\\") == True assert is_pangram(\\"Hello World\\") == False assert is_pangram(\\"Pack my box with five dozen liquor jugs.\\") == True assert is_pangram(\\"\\") == False ``` # Context: Mitzy needs an efficient way to verify large amounts of text data for completeness. Ensure your solution is optimized for performance.","solution":"def is_pangram(input_string): Determines if the input string is a pangram. Args: input_string (str): The string to check. Returns: bool: True if the string is a pangram, False otherwise. alphabet_set = set(\'abcdefghijklmnopqrstuvwxyz\') input_set = set(input_string.lower()) return alphabet_set <= input_set"},{"question":"You are given a string as your input. Your task is to write a function that removes any reoccurring character and returns a new string with only the first occurrence of each character kept, while preserving the original order. # Input Format * A single string `s`, where: * 1 <= len(s) <= 10^5 * `s` consists of only ASCII characters. # Output Format * A single string that represents the input string with reoccurring characters removed. # Constraints * The function should process the string in linear time. * You are not allowed to use any built-in functions that directly solve the problem (like `OrderedDict` from the collections module). # Examples **Example 1:** ``` Input: \\"abracadabra\\" Output: \\"abrcd\\" ``` **Example 2:** ``` Input: \\"google\\" Output: \\"gole\\" ``` **Example 3:** ``` Input: \\"aabbcc\\" Output: \\"abc\\" ``` # Function Signature ```python def delete_reoccurring_characters(s: str) -> str: # Your code here pass ``` # Explanation * In Example 1, \'abracadabra\', the characters \'a\', \'b\', \'r\', \'c\', and \'d\' are kept in the order of their first appearance. * In Example 2, \'google\', the characters \'g\', \'o\', \'l\', \'e\' are kept. * In Example 3, \'aabbcc\', the characters \'a\', \'b\', and \'c\' are kept. # Notes * Ensure your solution is efficient and consider edge cases such as an empty string or strings with no reoccurring characters. * Aim for a clear and readable implementation that makes use of appropriate data structures.","solution":"def delete_reoccurring_characters(s: str) -> str: Removes any reoccurring characters and returns a new string with only the first occurrence of each character kept. seen = set() result = [] for char in s: if char not in seen: seen.add(char) result.append(char) return \'\'.join(result)"},{"question":"Implement Enhanced Shell Sort Scenario You are working as a software developer at a financial analytics company. One of your current tasks is to optimize the financial data processing pipeline. Sorting financial transaction records efficiently is critical for your application which updates in real-time. Given the importance of in-place sorting due to memory constraints, an enhanced version of Shell Sort is recommended. Task Write a function `enhanced_shell_sort` that implements Shell Sort using Hibbard\'s gap sequence. This sequence is determined by the formula: `gap = 2^k - 1` for k = 1, 2, 3, ... Function Signature ```python def enhanced_shell_sort(arr: List[int]) -> List[int]: pass ``` Input - A list of integers `arr` where `1 <= len(arr) <= 10^5` and each integer in `arr` is between `-10^9` and `10^9`. Output - A sorted list of integers. Constraints - Optimize the sorting for time and space complexity. - Your implementation should use Hibbard\'s gap sequence. Example ```python assert enhanced_shell_sort([5, 2, 9, 1, 5, 6]) == [1, 2, 5, 5, 6, 9] assert enhanced_shell_sort([-3, 0, -1, -7, 2, 1, 0]) == [-7, -3, -1, 0, 0, 1, 2] ``` Implement the function considering the characteristics, edge cases, and performance aspects analyzed. Focus on the correct application of Hibbard\'s gap sequence to achieve efficient sorting.","solution":"from typing import List def enhanced_shell_sort(arr: List[int]) -> List[int]: Sorts a list of integers using the Enhanced Shell Sort algorithm with Hibbard\'s gap sequence. n = len(arr) # Generate Hibbard\'s gap sequence gaps = [] k = 1 while (2 ** k - 1) < n: gaps.append(2 ** k - 1) k += 1 # Perform Shell Sort with generated gap sequence for gap in reversed(gaps): for i in range(gap, n): temp = arr[i] j = i while j >= gap and arr[j - gap] > temp: arr[j] = arr[j - gap] j -= gap arr[j] = temp return arr"},{"question":"You are required to implement an **OrderedDeque** data structure which maintains its elements in sorted order, just like the provided Ordered Stack, but with the following extended functionalities: 1. `push_front(item)`: Inserts elements at the front while maintaining order. 2. `push_back(item)`: Inserts elements at the back while maintaining order. 3. `pop_front()`: Removes and returns the smallest element. 4. `pop_back()`: Removes and returns the largest element. 5. `peek_front()`: Retrieves without removing the smallest element. 6. `peek_back()`: Retrieves without removing the largest element. # Input and Output: * Implement the following methods for the `OrderedDeque` class: ```python class OrderedDeque: def __init__(self): pass # Implementations here def push_front(self, item): pass def push_back(self, item): pass def pop_front(self): pass def pop_back(self): pass def peek_front(self): pass def peek_back(self): pass ``` # Constraints: * The `OrderedDeque` should handle integer values. * Assume all inputs are valid integers. * Efficiently handle up to (10^4) operations. # Example Usage: ```python deque = OrderedDeque() deque.push_back(5) deque.push_back(10) deque.push_front(1) print(deque.pop_front()) # Outputs: 1 print(deque.peek_back()) # Outputs: 10 print(deque.pop_back()) # Outputs: 10 print(deque.peek_front()) # Outputs: 5 ``` Make sure to handle edge cases such as popping from an empty deque, and maintaining optimal performance within the constraints.","solution":"import bisect class OrderedDeque: def __init__(self): self.items = [] def push_front(self, item): bisect.insort_left(self.items, item) def push_back(self, item): bisect.insort_right(self.items, item) def pop_front(self): if not self.items: raise IndexError(\\"pop from empty deque\\") return self.items.pop(0) def pop_back(self): if not self.items: raise IndexError(\\"pop from empty deque\\") return self.items.pop() def peek_front(self): if not self.items: raise IndexError(\\"peek from empty deque\\") return self.items[0] def peek_back(self): if not self.items: raise IndexError(\\"peek from empty deque\\") return self.items[-1]"},{"question":"International Morse Code defines a standard encoding where each letter is mapped to a series of dots and dashes: ```plaintext \'a\':\\".-\\", \'b\':\\"-...\\", \'c\':\\"-.-.\\", \'d\': \\"-..\\", \'e\':\\".\\", \'f\':\\"..-.\\", \'g\':\\"--.\\", \'h\':\\"....\\", \'i\':\\"..\\", \'j\':\\".---\\", \'k\':\\"-.-\\", \'l\':\\".-..\\", \'m\':\\"--\\", \'n\':\\"-.\\", \'o\':\\"---\\", \'p\':\\".--.\\", \'q\':\\"--.-\\", \'r\':\\".-.\\", \'s\':\\"...\\", \'t\':\\"-\\", \'u\':\\"..-\\", \'v\':\\"...-\\", \'w\':\\".--\\", \'x\':\\"-..-\\", \'y\':\\"-.--\\", \'z\':\\"--..\\" ``` Each word can be written as a concatenation of the Morse code of each letter. Given a list of words, obtain the number of different Morse code transformations. For example, if the word \\"cab\\" is provided, it should be written as \\"-.-.-....-\\", which is the concatenation of \\"-.-.\\" (for \'c\'), \\"-...\\" (for \'a\'), and \\".-\\" (for \'b\'). # Input The input is a list of strings, where each string is a word made up of lowercase English letters only. # Output An integer representing the count of distinct Morse code transformations. # Constraints - Each word is from 1 to 12 characters long. - The input list will contain at most 100 words. # Function Signature ```python def unique_morse(words: List[str]) -> int: pass ``` # Example **Input**: ```python words = [\\"gin\\", \\"zen\\", \\"gig\\", \\"msg\\"] ``` **Output**: ```python 2 ``` **Explanation**: Transformation of each word: - \\"gin\\" -> \\"--...-.\\" - \\"zen\\" -> \\"--...-.\\" - \\"gig\\" -> \\"--...--.\\" - \\"msg\\" -> \\"--...--.\\" There are 2 unique transformations: \\"--...-.\\" and \\"--...--.\\" # Implementation Write the function `unique_morse(words: List[str]) -> int` such that it satisfies the problem statement.","solution":"def unique_morse(words): morse_code = { \'a\': \\".-\\", \'b\': \\"-...\\", \'c\': \\"-.-.\\", \'d\': \\"-..\\", \'e\': \\".\\", \'f\': \\"..-.\\", \'g\': \\"--.\\", \'h\': \\"....\\", \'i\': \\"..\\", \'j\': \\".---\\", \'k\': \\"-.-\\", \'l\': \\".-..\\", \'m\': \\"--\\", \'n\': \\"-.\\", \'o\': \\"---\\", \'p\': \\".--.\\", \'q\': \\"--.-\\", \'r\': \\".-.\\", \'s\': \\"...\\", \'t\': \\"-\\", \'u\': \\"..-\\", \'v\': \\"...-\\", \'w\': \\".--\\", \'x\': \\"-..-\\", \'y\': \\"-.--\\", \'z\': \\"--..\\" } # Helper function to convert a word to morse code def word_to_morse(word): return \'\'.join(morse_code[char] for char in word) # Use set to track unique morse transformations transformations = set(word_to_morse(word) for word in words) return len(transformations)"},{"question":"# Scenario You are tasked with managing a priority queue for a printer queue in an office environment. Print jobs have different priorities based on their urgency. # Task Create a PriorityQueue class that supports the following functionalities: 1. **Initialization**: Initialize an empty priority queue or with given items and their priorities. 2. **Size**: Return the number of elements in the priority queue. 3. **Push**: Add a new element with a given priority. If no priority is provided, use the element\'s value as its priority. 4. **Pop**: Remove and return the element with the highest priority. # Additional Requirements 1. Ensure that the pop operation handles the scenario where the queue is empty by raising an appropriate exception. 2. Optimize the `push` method to handle insertion in less than O(n) time complexity if possible. # Constraints - The elements in the priority queue are integers. - The priorities are also integers (positive or negative). - The queue should hold up to 10^5 elements. # Function Signatures ```python class PriorityQueue: def __init__(self, items=None, priorities=None): pass # Initialize the priority queue. def size(self): pass # Return the size of the priority queue. def push(self, item, priority=None): pass # Insert an element into the priority queue. def pop(self): pass # Remove and return the element with the highest priority. ``` # Example ```python pq = PriorityQueue() pq.push(10) pq.push(5, 1) pq.push(20, 3) assert pq.size() == 3 assert pq.pop() == 20 assert pq.pop() == 10 assert pq.pop() == 5 try: pq.pop() except IndexError: print(\\"Queue is empty\\") ```","solution":"import heapq class PriorityQueue: def __init__(self, items=None, priorities=None): Initialize an empty priority queue or with given items and their priorities. self.heap = [] if items and priorities: for item, priority in zip(items, priorities): heapq.heappush(self.heap, (-priority, item)) def size(self): Return the number of elements in the priority queue. return len(self.heap) def push(self, item, priority=None): Add a new element with a given priority. If no priority is provided, use the element\'s value as its priority. if priority is None: priority = item heapq.heappush(self.heap, (-priority, item)) def pop(self): Remove and return the element with the highest priority. if not self.heap: raise IndexError(\\"Queue is empty\\") return heapq.heappop(self.heap)[1]"},{"question":"Problem Description: You are given two words, `begin_word` and `end_word`, and a dictionary of words called `word_list`. All the words in the dictionary and the given words are of the same length and contain only lowercase alphabets. You are to find the length of the shortest transformation sequence from `begin_word` to `end_word` such that only one letter can be changed at a time and each intermediate word must still exist in the dictionary. If no such transformation sequence exists, return `-1`. Example: ```plaintext Input: begin_word = \\"hit\\" end_word = \\"cog\\" word_list = [\\"hot\\",\\"dot\\",\\"dog\\",\\"lot\\",\\"log\\",\\"cog\\"] Output: 5 Explanation: One shortest transformation is \\"hit\\" -> \\"hot\\" -> \\"dot\\" -> \\"dog\\" -> \\"cog\\", and its length is 5. ``` Function Signature: ```python def ladder_length(begin_word, end_word, word_list): :type begin_word: str :type end_word: str :type word_list: List[str] :rtype: int ``` Constraints: 1. All the words in the word list are of the same length as `begin_word`. 2. All the words contain only lowercase alphabetic characters. 3. There can be no duplicate words in the list. 4. The length of `begin_word` and `end_word` will be at most 100. Detailed Requirements: 1. Implement the bi-directional BFS algorithm to find the shortest path. 2. Your solution should handle the initial edge cases: - If `begin_word` and `end_word` are the same, return 0. - If `begin_word` and `end_word` have different lengths, return -1. 3. Each word in the word list must be removed once used to avoid cycles and redundant checks. 4. Carefully handle cases where there are no possible transformations, ensuring to return `-1` if no transformation is found. Hints: - You may find it useful to implement a helper function to generate all possible one-letter transformations of a word. - Consider using sets for faster membership checks and BFS queue operations.","solution":"from collections import deque from typing import List def ladder_length(begin_word: str, end_word: str, word_list: List[str]) -> int: Finds the shortest transformation sequence from begin_word to end_word, changing only one letter at a time, using words from word_list. if end_word not in word_list: return -1 word_set = set(word_list) if begin_word == end_word: return 0 # Bidirectional BFS initialization forward_queue = deque([(begin_word, 1)]) backward_queue = deque([(end_word, 1)]) forward_visited = {begin_word: 1} backward_visited = {end_word: 1} while forward_queue and backward_queue: result = visit_word_node(forward_queue, forward_visited, backward_visited, word_set) if result != -1: return result result = visit_word_node(backward_queue, backward_visited, forward_visited, word_set) if result != -1: return result return -1 def visit_word_node(queue, visited, other_visited, word_set): current_word, current_level = queue.popleft() for i in range(len(current_word)): for c in \'abcdefghijklmnopqrstuvwxyz\': transformed_word = current_word[:i] + c + current_word[i+1:] if transformed_word in other_visited: return current_level + other_visited[transformed_word] if transformed_word in word_set and transformed_word not in visited: visited[transformed_word] = current_level + 1 queue.append((transformed_word, current_level + 1)) return -1"},{"question":"# Question You are given a weighted graph represented by an adjacency matrix `adjacency_matrix`. Your task is to implement a function `prim_mst(adjacency_matrix)` that computes the Minimum Spanning Tree (MST) of the given graph using Prim\'s algorithm. # Function Signature ```python def prim_mst(adjacency_matrix: List[List[float]]) -> float: pass ``` # Parameters - `adjacency_matrix` (List[List[float]]): A 2D list representing the weighted adjacency matrix of the graph. The value `adjacency_matrix[i][j]` indicates the weight of the edge between nodes `i` and `j`. A value of `float(\'inf\')` indicates that there is no direct edge between the nodes. # Expected Output - Returns the total weight of the MST (float). # Constraints - The graph will have at least 2 vertices. - The weights of the edges are non-negative. # Example ```python adjacency_matrix = [ [0, 2, float(\'inf\'), 6, float(\'inf\')], [2, 0, 3, 8, 5], [float(\'inf\'), 3, 0, float(\'inf\'), 7], [6, 8, float(\'inf\'), 0, 9], [float(\'inf\'), 5, 7, 9, 0] ] result = prim_mst(adjacency_matrix) print(result) # Output: 16.0 ``` # Explanation The function `prim_mst` computes the minimum spanning tree of a given weighted graph and returns its total weight. In the example, the minimum spanning tree would include edges (0,1), (1,2), (1,4), and (0,3) with a total weight of 16.0. # Notes - You may use any efficient data structures, such as priority queues, to implement Prim\'s algorithm. - Handle edge cases appropriately, including disconnected graphs, though it’s guaranteed by constraints the graph will be connected.","solution":"from typing import List import heapq def prim_mst(adjacency_matrix: List[List[float]]) -> float: Computes the total weight of the Minimum Spanning Tree (MST) using Prim\'s algorithm. Parameters: adjacency_matrix (List[List[float]]): 2D list representing the weighted adjacency matrix of the graph. Returns: float: Total weight of the MST. N = len(adjacency_matrix) visited = [False] * N min_heap = [(0, 0)] # Start with node 0 and edge weight 0 total_weight = 0 edges_in_mst = 0 # Number of edges included in MST while min_heap and edges_in_mst < N: weight, u = heapq.heappop(min_heap) if visited[u]: continue visited[u] = True total_weight += weight edges_in_mst += 1 for v in range(N): if not visited[v] and adjacency_matrix[u][v] < float(\'inf\'): heapq.heappush(min_heap, (adjacency_matrix[u][v], v)) return total_weight"},{"question":"# Context: You are tasked to implement a Shell Sort function for sorting a list of integers. However, this time we will enhance your understanding by focusing on variations in gap sequences used in the algorithm. # Task: Implement the `shell_sort` function, which sorts an array of integers using Shell Sort. Your implementation should allow for different sequences of gaps provided as input to the function. The default sequence is the one used in the given code snippet (`n//2`). # Function Specification: Input: * An unsorted list of integers `arr` of length `n` where `1 <= n <= 1000`. * An optional list of integers `gaps` representing the gap sequence to be used. If gaps are not provided, default to `n//2`. Output: * A sorted list of integers in non-decreasing order. Constraints: * Each element in `arr` will be an integer such that `-10^6 <= arr[i] <= 10^6`. # Requirements: 1. Your function should handle edge cases including small arrays, already sorted arrays, and arrays with duplicate elements. 2. Ensure an efficient implementation considering both time and space complexity. ```python def shell_sort(arr, gaps=None): \'\'\' Shell Sort implementation with customizable gap sequence. Parameters: arr: list of int - The array to be sorted gaps: list of int (optional) - Gap sequence to be used Returns: list of int - Sorted array \'\'\' n = len(arr) if gaps is None: gaps = [n // 2] while gaps[-1] > 0: gaps.append(gaps[-1] // 2) gaps = gaps[:-1] # removing the last useless 0 for gap in gaps: y_index = gap while y_index < len(arr): y = arr[y_index] x_index = y_index - gap while x_index >= 0 and y < arr[x_index]: arr[x_index + gap] = arr[x_index] x_index = x_index - gap arr[x_index + gap] = y y_index = y_index + 1 return arr # Example Usage: # sorted_array = shell_sort([5, 2, 9, 1, 5, 6]) # sorted_array_with_gaps = shell_sort([5, 2, 9, 1, 5, 6], gaps=[5,3,1]) ``` # Evaluation: Your implementation will be evaluated for correctness, efficiency, and robustness against various test cases.","solution":"def shell_sort(arr, gaps=None): \'\'\' Shell Sort implementation with customizable gap sequence. Parameters: arr: list of int - The array to be sorted gaps: list of int (optional) - Gap sequence to be used Returns: list of int - Sorted array \'\'\' n = len(arr) if gaps is None: gaps = [] gap = n // 2 while gap > 0: gaps.append(gap) gap //= 2 for gap in gaps: for i in range(gap, n): temp = arr[i] j = i while j >= gap and arr[j - gap] > temp: arr[j] = arr[j - gap] j -= gap arr[j] = temp return arr # Example Usage: # sorted_array = shell_sort([5, 2, 9, 1, 5, 6]) # sorted_array_with_gaps = shell_sort([5, 2, 9, 1, 5, 6], gaps=[5, 3, 1])"},{"question":"You are given an implementation of the RSA key generation algorithm and the procedures for encryption and decryption. Your task is to complete the function `rsa_encryption` which takes in a string message and a bit length `k`, and returns the encrypted message using RSA encryption. You need to generate the RSA keys (with a given key length `k`), encrypt the message, and return both the encrypted message and the keys. **Input Format**: - A string `message` (1 <= len(message) <= 100) consisting of printable ASCII characters. - An integer `k` (16 <= k <= 512), representing the bit length of the keys. **Output Format**: - A tuple `(n, e, d, encrypted_message)` where: - `n`: modulus used in RSA. - `e`: public exponent used for encryption. - `d`: private exponent used for decryption. - `encrypted_message`: the encrypted representation of the input message. **Constraints**: - Use the provided RSA implementation for key generation. - The encrypted message should be a list of integers representing each character in the original message encrypted. **Example**: ```plaintext Input: message = \\"HELLO\\" k = 64 Output: (n, e, d, encrypted_message) ``` where: - `encrypted_message` is an array of encrypted integers for each character in \\"HELLO\\". # Function Signature ```python def rsa_encryption(message: str, k: int) -> tuple: pass ``` # Requirements 1. Ensure the RSA keys are generated correctly. 2. Encrypt each character in the message. 3. Handle all the constraints and edge cases mentioned.","solution":"import random from sympy import isprime, gcd from sympy.ntheory.generate import randprime import math def modinv(a, m): m0, x0, x1 = m, 0, 1 if m == 1: return 0 while a > 1: q = a // m m, a = a % m, m x0, x1 = x1 - q * x0, x0 return x1 + m0 if x1 < 0 else x1 def generate_rsa_keys(k): Generate RSA keys given a bit length `k`. Returns (n, e, d) for modulus n, public exponent e, and private exponent d. e = 65537 # Commonly used prime exponent half_k = k // 2 # Generate two distinct prime numbers p and q p = randprime(2**(half_k-1), 2**half_k) q = randprime(2**(half_k-1), 2**half_k) while p == q: q = randprime(2**(half_k-1), 2**half_k) n = p * q phi = (p - 1) * (q - 1) # Ensure that e is relatively prime to phi(n) while gcd(e, phi) != 1: e += 2 d = modinv(e, phi) return (n, e, d) def rsa_encrypt(message, n, e): Encrypt a message using RSA encryption with public key (n, e). Returns a list of encrypted integers. encrypted_message = [(pow(ord(char), e, n)) for char in message] return encrypted_message def rsa_encryption(message: str, k: int) -> tuple: n, e, d = generate_rsa_keys(k) encrypted_message = rsa_encrypt(message, n, e) return (n, e, d, encrypted_message)"},{"question":"# Scenario Consider you\'ve been hired by a tech company to optimize the queue data structure in their backend systems since it is a critical part of their job scheduling and buffering systems. You are tasked to implement both `ArrayQueue` and `LinkedListQueue` versions of the Queue Abstract Data Type (ADT) with specific optimizations to handle different scenarios effectively. # Task 1. **Implement `ArrayQueue` with a Circular Buffer**: - Circular buffer will resolve the issue of unnecessary space due to front movement in the array. 2. **Implement `LinkedListQueue` with Efficient Memory Management**: - Make sure to manage memory efficiently to handle large number of enqueues and dequeues without memory leaks. # Function Templates Implement the following classes with all required methods (`enqueue`, `dequeue`, `peek`, etc.): ```python class CircularArrayQueue(AbstractQueue): def __init__(self, capacity=10): pass def enqueue(self, value): pass def dequeue(self): pass def peek(self): pass def __iter__(self): pass class OptimizedLinkedListQueue(AbstractQueue): def __init__(self): pass def enqueue(self, value): pass def dequeue(self): pass def peek(self): pass def __iter__(self): pass ``` # Input and Output Format * **Input Format**: - No explicit input, but consider usage scenarios would involve calling the methods of your queue classes. * **Output Format**: - Ensure the correct outputs or raised exceptions for operations. # Constraints * Implement memory-efficient solutions. * Handle all edge cases including empty queue operations. # Performance Requirement * Ensure that your circular buffer operations run in average O(1) time. * The linked list queue should minimize memory overhead. # Example ```python cq = CircularArrayQueue(5) cq.enqueue(1) cq.enqueue(2) print(cq.dequeue()) # Outputs: 1 llq = OptimizedLinkedListQueue() llq.enqueue(10) llq.enqueue(20) print(llq.peek()) # Outputs: 10 ```","solution":"class CircularArrayQueue: def __init__(self, capacity=10): self.array = [None] * capacity self.capacity = capacity self.front = 0 self.size = 0 def enqueue(self, value): if self.size == self.capacity: raise OverflowError(\\"Queue is full\\") rear = (self.front + self.size) % self.capacity self.array[rear] = value self.size += 1 def dequeue(self): if self.size == 0: raise IndexError(\\"Dequeuing from empty queue\\") value = self.array[self.front] self.array[self.front] = None self.front = (self.front + 1) % self.capacity self.size -= 1 return value def peek(self): if self.size == 0: raise IndexError(\\"Peeking into empty queue\\") return self.array[self.front] def __iter__(self): index = self.front num_elements = self.size for _ in range(num_elements): yield self.array[index] index = (index + 1) % self.capacity class ListNode: def __init__(self, value=None, next=None): self.value = value self.next = next class OptimizedLinkedListQueue: def __init__(self): self.front = self.rear = None self.size = 0 def enqueue(self, value): new_node = ListNode(value) if self.rear: self.rear.next = new_node self.rear = new_node if not self.front: self.front = new_node self.size += 1 def dequeue(self): if self.size == 0: raise IndexError(\\"Dequeuing from empty queue\\") value = self.front.value self.front = self.front.next if not self.front: self.rear = None self.size -= 1 return value def peek(self): if self.size == 0: raise IndexError(\\"Peeking into empty queue\\") return self.front.value def __iter__(self): current = self.front while current: yield current.value current = current.next"},{"question":"Context Given a positive integer `n`, you need to determine the number of ways to partition `n` into the sum of positive integers. These partitions are compositions, which means order matters. Function Signature ```python def int_partition(n: int) -> int: ``` Input * An integer `n` such that `1 <= n <= 1000`. Output * An integer representing the number of ways to partition `n`. Examples ```python assert int_partition(4) == 5 assert int_partition(7) == 15 ``` Explanation * Example 1: * Input: 4 * Output: 5 * Explanation: There are 5 different partitions of 4: 4=4 4=3+1 4=2+2 4=2+1+1 4=1+1+1+1 * Example 2: * Input: 7 * Output: 15 * Explanation: There are 15 different partitions of 7. # Constraints * Implement the solution with a time complexity of O(n^2) and space complexity of O(n^2).","solution":"def int_partition(n: int) -> int: Returns the number of ways to partition n into the sum of positive integers. # Create a table to store results of sub-problems dp = [[0 for _ in range(n + 1)] for _ in range(n + 1)] # There is exactly one way to partition zero into an empty set for i in range(n + 1): dp[i][0] = 1 # Fill the table in bottom-up manner for i in range(1, n + 1): for j in range(1, n + 1): # If the current integer is included if i <= j: dp[i][j] = dp[i - 1][j] + dp[i][j - i] else: # If the current integer is not included dp[i][j] = dp[i - 1][j] return dp[n][n] # Example usage and result verification print(int_partition(4)) # Output: 5 print(int_partition(7)) # Output: 15"},{"question":"# Pancake Sort Challenge Background: Pancake sorting involves flipping sub-arrays to sort the entire array. Your job is to write a function that takes an unsorted array and sorts it using the pancake sorting algorithm. Problem Statement: Write a function `pancake_sort(arr)` that sorts an input list of integers using the pancake sorting technique. This function should modify the original list in-place and return the sorted list. Implementation Requirements: * Your implementation must use the principles of pancake sorting, which means you will perform a series of sub-array reversals (flips). * Optimally handle edge cases such as arrays of length 0 or 1. * Minimize unnecessary flips to enhance performance where possible. Constraints: * Input array size `n` will be in the range: (0 leq n leq 10^3) * The elements of the array, `arr[i]`, will be integers such that (-10^3 leq arr[i] leq 10^3) Input: * `arr` (List[int]): An unsorted array of integers. Output: * Returns the sorted array `arr`. The sorting should be done in place, i.e., modifying the original array. Function Signature: ```python def pancake_sort(arr: List[int]) -> List[int]: pass ``` Example: ```python # Example 1 input_arr = [3, 2, 4, 1] print(pancake_sort(input_arr)) # Output: [1, 2, 3, 4] # Example 2 input_arr = [10, 5, 8, 3] print(pancake_sort(input_arr)) # Output: [3, 5, 8, 10] ``` Notes: * Ensure the function handles edge cases like empty arrays or arrays of length 1 correctly. * Pay attention to performance, and avoid unnecessary operations where possible.","solution":"def pancake_sort(arr): Sorts an array using the pancake sorting technique. def flip(sub_arr, k): Reverses the order of the first k elements in the array. start = 0 while start < k: sub_arr[start], sub_arr[k] = sub_arr[k], sub_arr[start] start += 1 k -= 1 def find_max_index(sub_arr, n): Finds the index of the maximum element in the first n elements of the array. max_idx = 0 for i in range(1, n): if sub_arr[i] > sub_arr[max_idx]: max_idx = i return max_idx n = len(arr) for size in range(n, 1, -1): max_idx = find_max_index(arr, size) if max_idx != size - 1: # Flip max element to the front if it\'s not already at the position if max_idx != 0: flip(arr, max_idx) # Flip max element to its correct position flip(arr, size - 1) return arr"},{"question":"Context You are asked to help implement a function for an expression evaluator. Given a string of digits and a target value, you\'re to return all possible ways to place the binary operators (+, -, *) between the digits so that the resultant expression evaluates to the target value. Problem Statement Write a function `add_operators(num: str, target: int) -> List[str]` that, given a string of digits and an integer target, returns all possible valid combinations of the digits with the binary operators \'+\', \'-\', and \'*\' such that the expressions evaluate to the target value. Input * `num`: A string consisting of digits from 0-9. * `target`: An integer which is the target value. Output * A list of strings representing all possible ways to insert binary operators between digits in `num` string to result in the value `target`. Constraints * The input string will contain only digits. * The length of `num` will not exceed 10. * The integers in operations will be in the range of 32-bit signed integers. Expected Function Signature ```python def add_operators(num: str, target: int) -> List[str]: ``` Example ```python add_operators(\\"123\\", 6) # Output: [\\"1+2+3\\", \\"1*2*3\\"] add_operators(\\"232\\", 8) # Output: [\\"2*3+2\\", \\"2+3*2\\"] add_operators(\\"105\\", 5) # Output: [\\"1*0+5\\", \\"10-5\\"] add_operators(\\"00\\", 0) # Output: [\\"0+0\\", \\"0-0\\", \\"0*0\\"] add_operators(\\"3456237490\\", 9191) # Output: [] ``` Notes 1. Ensure all digits are used in the same order as they appear in the input string. 2. Consider edge cases such as leading zeros (e.g., \\"0009\\").","solution":"from typing import List def add_operators(num: str, target: int) -> List[str]: def backtrack(expr, prev_operand, current_operand, value, index): if index == len(num): if value == target and current_operand == 0: results.append(\\"\\".join(expr[1:])) return current_operand = current_operand * 10 + int(num[index]) str_operand = str(current_operand) if current_operand > 0: backtrack(expr, prev_operand, current_operand, value, index + 1) expr.append(\'+\') expr.append(str_operand) backtrack(expr, current_operand, 0, value + current_operand, index + 1) expr.pop() expr.pop() if expr: expr.append(\'-\') expr.append(str_operand) backtrack(expr, -current_operand, 0, value - current_operand, index + 1) expr.pop() expr.pop() expr.append(\'*\') expr.append(str_operand) backtrack(expr, prev_operand * current_operand, 0, value - prev_operand + (prev_operand * current_operand), index + 1) expr.pop() expr.pop() results = [] backtrack([], 0, 0, 0, 0) return results"},{"question":"# Euler\'s Totient Function Calculation Challenge **Scenario**: You\'re tasked with implementing a function that computes Euler\'s Totient function, often denoted as ϕ(n), for any positive integer n. This function counts the number of integers up to n that are coprime with n (i.e., the greatest common divisor (GCD) of each integer and n equals 1). **Objective**: Implement the function `euler_totient_optimized` that takes a positive integer `n` as an argument and returns the number of integers from 1 to n that are coprime with n. **Input**: * An integer `n` (1 ≤ n ≤ 10^6). **Output**: * An integer representing ϕ(n). **Function Signature**: ```python def euler_totient_optimized(n: int) -> int: pass ``` # Constraints: * The algorithm should run efficiently for n up to 10^6. * Avoid using brute force methods with a complexity worse than O(sqrt(n)). # Example: ```python assert euler_totient_optimized(9) == 6 assert euler_totient_optimized(10) == 4 assert euler_totient_optimized(1) == 1 assert euler_totient_optimized(100) == 40 assert euler_totient_optimized(997) == 996 ``` # Notes: * For the given examples: * ϕ(9) = 6 because the integers 1, 2, 4, 5, 7, and 8 are coprime with 9. * ϕ(10) = 4 because the integers 1, 3, 7, and 9 are coprime with 10. Implement this function considering the edge cases and performance requirements to ensure that your solution is optimal and efficient.","solution":"def euler_totient_optimized(n: int) -> int: Computes Euler\'s Totient function ϕ(n) for a given positive integer n. The function returns the number of integers from 1 to n that are coprime with n. if n == 1: return 1 result = n p = 2 while p * p <= n: if n % p == 0: while n % p == 0: n //= p result -= result // p p += 1 if n > 1: result -= result // n return result"},{"question":"# Reversing a Doubly Linked List Objective In this exercise, you are required to write a function to reverse a doubly linked list. Unlike singly linked lists, each node in a doubly linked list has two pointers: `next` pointing to the next node, and `prev` pointing to the previous node. Requirements * Implement both an iterative and a recursive function to reverse a doubly linked list. * Ensure the solutions handle edge cases such as an empty list or a single element list. Input and Output Formats # Input * A doubly linked list defined by its head node. Each node has the properties `val` (integer), `next` (pointer to the next node), and `prev` (pointer to the previous node). # Output * A head node of the reversed doubly linked list. Constraints - The list can have up to (10^5) nodes. - Node values are integers. Example ```python class ListNode: def __init__(self, val=0, next=None, prev=None): self.val = val self.next = next self.prev = prev def reverse_doubly_list_iterative(head): # Your code here def reverse_doubly_list_recursive(head): # Your code here # Example: # Input: 1 <-> 2 <-> 3 <-> 4 # Output: 4 <-> 3 <-> 2 <-> 1 ``` Tips 1. **Iterative Approach**: * Traverse through the list swapping `next` and `prev` pointers for each node. * Keep track of the new head node during the traversal. 2. **Recursive Approach**: * Recursively reverse the next node and adjust `next` and `prev` pointers. Make sure to test your implementation with various cases including edge cases like an empty list or a list with a single node.","solution":"class ListNode: def __init__(self, val=0, next=None, prev=None): self.val = val self.next = next self.prev = prev def reverse_doubly_list_iterative(head): if not head: return None current = head new_head = None while current: new_head = current current.next, current.prev = current.prev, current.next current = current.prev return new_head def reverse_doubly_list_recursive(head): if not head: return None def _reverse(node): if not node: return None node.next, node.prev = node.prev, node.next if not node.prev: return node return _reverse(node.prev) return _reverse(head)"},{"question":"# Segment Tree - Range Sum Updates **Task**: Write a function that uses a Segment Tree data structure to efficiently handle a series of range sum queries and updates on an initial array of integers. **Function Specification**: 1. **Initialization**: `__init__(self, nums: List[int])` Construct a segment tree using the given list `nums` of integers. Each internal node should store the sum of its child nodes. 2. **Update**: `update(self, idx: int, val: int) -> None` Update the element at index `idx` to `val` and propagate the changes up the tree. 3. **Range Query**: `sumRange(self, left: int, right: int) -> int` Return the sum of elements between indices `left` and `right` inclusive. **Input Format**: * The initialization will be conducted with a list of `nums` containing up to `10^5` integers. * Updates will be given as a series of tuples `(idx, val)`, where `idx` is the index to update and `val` is the new value. * Range queries will be given as a series of tuples `(left, right)`, where `left` and `right` define the range for sum query. **Output Format**: * For each range query, return the sum of the elements within the specified range. **Constraints**: * 1 ≤ len(nums) ≤ (10^5) * -(10^4) ≤ nums[i] ≤ (10^4) * Updates and queries are frequent and distributed across the entire array length. Example ```python # Your function calls should look like: segTree = SegmentTree([2, 4, 5, 3, 4], lambda a, b: a + b) print(segTree.sumRange(2, 4)) # Output: 12 (5+3+4) segTree.update(3, 6) print(segTree.sumRange(0, 3)) # Output: 17 (2+4+5+6) ``` **Explanation**: On creating the Segment Tree, `[2, 4, 5, 3, 4]` initializes nodes with their sums. The sum range query `(2, 4)` returns `5+3+4=12`. Updating index `3` to `6` changes the array to `[2, 4, 5, 6, 4]`. The subsequent range query `(0, 3)` sums up `2+4+5+6=17`.","solution":"class SegmentTree: def __init__(self, nums): self.n = len(nums) self.tree = [0] * (2 * self.n) # Build the tree self.build(nums) def build(self, nums): # Insert leaf nodes in tree for i in range(self.n): self.tree[self.n + i] = nums[i] # Build the segment tree by calculating parents for i in range(self.n - 1, 0, -1): self.tree[i] = self.tree[i * 2] + self.tree[i * 2 + 1] def update(self, idx, val): # Update value at leaf node pos = idx + self.n self.tree[pos] = val # Move up and update the parents while pos > 1: pos //= 2 self.tree[pos] = self.tree[2 * pos] + self.tree[2 * pos + 1] def sumRange(self, left, right): # Get the sum in the range [left, right] left += self.n right += self.n + 1 sum = 0 while left < right: if left % 2 == 1: sum += self.tree[left] left += 1 if right % 2 == 1: right -= 1 sum += self.tree[right] left //= 2 right //= 2 return sum"},{"question":"# Question **Bitwise Addition of Large Integers** You are developing a system that must perform addition of very large positive integers efficiently. However, the system you are working on does not support the `+` operator for arithmetic operations. Instead, bitwise operations must be used, similar to the constraints found in some embedded systems or specialized hardware environments. **Objective**: Write a Python function `bitwise_addition(a: int, b: int) -> int` that adds two large positive integers using only bitwise operations. **Input**: - `a` and `b` (0 ≤ a, b ≤ 10^18): Two large positive integers. **Output**: - Integer representing the sum of `a` and `b`. **Constraints**: - You cannot use the `+`, `-`, or any other arithmetic operators. - You should handle cases where `a` or `b` is zero. **Function Signature**: ```python def bitwise_addition(a: int, b: int) -> int: pass ``` **Performance Requirement**: - The solution should efficiently handle numbers as large as 10^18. # Example ```python assert bitwise_addition(2, 3) == 5 assert bitwise_addition(123456789012345678, 987654321098765432) == 1111111110111111110 ``` **Edge Cases to Consider**: - Adding zero to another number should return the other number. - Large numbers should be handled without overflow errors. Implement the function `bitwise_addition` to satisfy the above constraints and requirements.","solution":"def bitwise_addition(a: int, b: int) -> int: Adds two large positive integers using bitwise operations only. while b != 0: carry = a & b # Calculate carry bits a = a ^ b # Add a and b without considering carry b = carry << 1 # Shift carry to the left return a"},{"question":"# Question: You are given two strings representing segments of a file path or URL. The first string, `base`, is the initial segment, possibly ending with a slash. The second string, `suffix`, is the segment to append, possibly starting with a slash. Write a function called `join_with_slash` that concatenates these segments correctly by ensuring that exactly one slash separates them, without extraneous leading/trailing slashes in the result. Function Signature: ```python def join_with_slash(base: str, suffix: str) -> str: ``` Input: * `base` (str): The initial string segment. * `suffix` (str): The string segment to append. Output: * (str): The resulting string after joining the base and suffix with exactly one slash in between. Constraints: * Both `base` and `suffix` are non-empty strings. * The strings may contain spaces or special characters but only standard slashes (/) should be used as delimiters. Performance Requirements: * The function should not exceed O(n + m) time complexity and O(n + m) space complexity, where n and m are the lengths of the `base` and `suffix` respectively. Examples: ```python # Example 1: base = \\"http://algorithms.com\\" suffix = \\"part\\" output = join_with_slash(base, suffix) print(output) # Expected output: \\"http://algorithms.com/part\\" # Example 2: base = \\"http://algorithms.com/\\" suffix = \\"part\\" output = join_with_slash(base, suffix) print(output) # Expected output: \\"http://algorithms.com/part\\" # Example 3: base = \\"path/to/dir/\\" suffix = \\"file\\" output = join_with_slash(base, suffix) print(output) # Expected output: \\"path/to/dir/file\\" # Example 4: base = \\"path/to/dir\\" suffix = \\"/file\\" output = join_with_slash(base, suffix) print(output) # Expected output: \\"path/to/dir/file\\" ```","solution":"def join_with_slash(base: str, suffix: str) -> str: Joins two string segments with exactly one slash in between. if base.endswith(\'/\') and suffix.startswith(\'/\'): return base[:-1] + suffix elif not base.endswith(\'/\') and not suffix.startswith(\'/\'): return base + \'/\' + suffix else: return base + suffix"},{"question":"# Coding Challenge: Implement Enhanced Rabin-Karp Algorithm **Problem Statement**: You are to implement an enhanced version of the Rabin-Karp algorithm for finding all occurrences of a pattern string within a given text string. Instead of returning the first occurrence, your task is to return a list of starting indices of all occurrences of the pattern. **Input**: - A string `text` (1 <= length of text <= 10^6) - A string `word` (1 <= length of word <= 10^6) Both `text` and `word` are composed of lowercase English alphabets. **Output**: - A list of integers representing the starting indices of all occurrences of `word` in `text`. **Constraints**: - If `word` is not found in `text`, return an empty list. - The solution should handle large inputs efficiently. **Example**: ```python text = \\"abracadabra\\" word = \\"abra\\" Output = [0, 7] text = \\"aaaaa\\" word = \\"aa\\" Output = [0, 1, 2, 3] ``` **Function Signature**: ```python def enhanced_rabin_karp(word: str, text: str) -> List[int]: pass ``` # Implementation Guidelines: 1. Reuse the `RollingHash` class for hash computations. 2. Modify the `rabin_karp` function to gather all starting indices. 3. Ensure proper handling of edge cases and optimize for performance.","solution":"from typing import List def enhanced_rabin_karp(word: str, text: str) -> List[int]: if not word or not text: return [] word_len = len(word) text_len = len(text) if word_len > text_len: return [] base = 256 prime = 101 def get_hash(s: str, length: int) -> int: h = 0 for i in range(length): h = (h * base + ord(s[i])) % prime return h def recompute_hash(old_hash: int, left_char: str, right_char: str, highest_pow: int) -> int: new_hash = (old_hash - ord(left_char) * highest_pow) * base + ord(right_char) return new_hash % prime word_hash = get_hash(word, word_len) text_hash = get_hash(text, word_len) highest_pow = pow(base, word_len - 1, prime) result_indices = [] for i in range(text_len - word_len + 1): if word_hash == text_hash: if text[i:i + word_len] == word: result_indices.append(i) if i < text_len - word_len: text_hash = recompute_hash(text_hash, text[i], text[i + word_len], highest_pow) return result_indices"},{"question":"# Question: Subset Generation You have been assigned a task to generate all possible subsets of a given set of distinct integers using different approaches. Problem Statement Write two functions to generate all possible subsets (power set) of a distinct integer array `nums`. 1. **Backtracking Approach**: * Function Signature: `def generate_subsets_backtracking(nums: List[int]) -> List[List[int]]` * Description: Should implement the backtracking method to generate subsets. 2. **Iterative Approach**: * Function Signature: `def generate_subsets_iterative(nums: List[int]) -> List[List[int]]` * Description: Should implement an iterative method to generate subsets by progressively building from existing subsets. Input * A list of distinct integers `nums` with the constraint (0 leq |nums| leq 20). Output * A list of lists, where each list is a distinct subset of `nums`. Example: ```python # Example 1: nums = [1, 2, 3] # Output: # [ # [], # [1], # [2], # [3], # [1, 2], # [1, 3], # [2, 3], # [1, 2, 3] # ] # Example 2: nums = [] # Output: # [ # [] # ] ``` Constraints: * Your solutions should not generate duplicate subsets. * You need to ensure the time and space complexity are acceptable for the given input size.","solution":"from typing import List def generate_subsets_backtracking(nums: List[int]) -> List[List[int]]: def backtrack(start, path): result.append(path) for i in range(start, len(nums)): backtrack(i + 1, path + [nums[i]]) result = [] backtrack(0, []) return result def generate_subsets_iterative(nums: List[int]) -> List[List[int]]: result = [[]] for num in nums: result += [curr + [num] for curr in result] return result"},{"question":"# Coding Challenge: Find In-Order Predecessor in a Binary Search Tree Your task is to write a function that finds the in-order predecessor of a given node in a Binary Search Tree (BST). The predecessor of a node is the node that appears immediately before it in an in-order traversal of the BST. Function Signature ```python def find_predecessor(root: TreeNode, node: TreeNode) -> Optional[TreeNode]: pass ``` Input * `root`: A reference to the root node of the BST. * `node`: A reference to the target node whose in-order predecessor we need to find. Output * Returns the in-order predecessor node if it exists, else returns `None`. Constraints * All node values in the BST are unique. * The `TreeNode` class is defined as follows: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` Example Consider the following BST: ``` 20 / 15 30 / 10 17 40 ``` * Input: `root = [20, 15, 30, 10, 17, None, 40]`, `node = 30` * Output: Node with value 20 Explanation The in-order traversal of the BST is [10, 15, 17, 20, 30, 40]. The node that immediately precedes the node with value 30 is the node with value 20. Additional Notes 1. If the given node is the smallest element in the tree, the result should be `None`. 2. Your solution should traverse the tree in O(h) time where h is the height of the tree.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find_predecessor(root: TreeNode, node: TreeNode) -> TreeNode: # If node has left subtree, predecessor is the rightmost node in left subtree if node.left: pred = node.left while pred.right: pred = pred.right return pred # If no left subtree, traverse from root to find the predecessor predecessor = None current = root while current: if node.val > current.val: predecessor = current current = current.right elif node.val < current.val: current = current.left else: break return predecessor"},{"question":"Scenario You are tasked with implementing a sorting function using the cocktail shaker sort algorithm. The function will sort a given list of integers in non-decreasing order. This function is intended to be part of a larger module in a library that handles various sorting algorithms. Objective Implement the `cocktail_shaker_sort` function to sort the input list in place. Function Signature ```python def cocktail_shaker_sort(arr): Sort the input list of integers in non-decreasing order using cocktail shaker sort algorithm. Parameters: arr (list of int): List of integers to be sorted. Returns: list of int: Sorted list in non-decreasing order. ``` Requirements 1. **Input**: A list `arr` of integers where `1 <= len(arr) <= 10^4` and `-10^6 <= arr[i] <= 10^6` for any valid `i`. 2. **Output**: A list sorted in non-decreasing order. 3. **Constraints**: * The function should sort the list in place. * Expected worst-case time complexity is O(n^2). * Expected space complexity is O(1). Example ```python arr = [5, 1, 4, 2, 8, 0, 2] cocktail_shaker_sort(arr) print(arr) # Output should be: [0, 1, 2, 2, 4, 5, 8] ``` Edge Cases * Test with an empty list. * Test with a list containing a single element. * Test with sorted lists and reverse sorted lists. * Test with lists containing duplicate elements. Additional Notes * Ensure that the function does not return a new list but modifies the input list in place. * Handle edge cases without using any additional libraries or sorting functions.","solution":"def cocktail_shaker_sort(arr): Sort the input list of integers in non-decreasing order using cocktail shaker sort algorithm. Parameters: arr (list of int): List of integers to be sorted. Returns: None n = len(arr) if n < 2: return start = 0 end = n - 1 swapped = True while swapped: swapped = False # Forward pass for i in range(start, end): if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] swapped = True # If no elements were swapped, the list is sorted if not swapped: break # Otherwise, reset the swapped flag for the backward pass swapped = False end -= 1 # Backward pass for i in range(end, start, -1): if arr[i] < arr[i - 1]: arr[i], arr[i - 1] = arr[i - 1], arr[i] swapped = True start += 1"},{"question":"# Problem: Minimum Deletions to Make Two Strings Identical You are given two strings, `word1` and `word2`. Your task is to write a function that calculates the minimum number of deletions required to make the two strings identical. A deletion means removing a single character from either of the two strings. # Function Signature ```python def min_deletions(word1: str, word2: str) -> int: pass ``` # Input * `word1`: A string of length ( n ) (1 ≤ ( n ) ≤ 1000) consisting of lowercase English letters. * `word2`: A string of length ( m ) (1 ≤ ( m ) ≤ 1000) consisting of lowercase English letters. # Output * An integer representing the minimum number of deletions needed to make `word1` and `word2` identical. # Examples Example 1 ``` Input: word1 = \\"sea\\", word2 = \\"eat\\" Output: 2 Explanation: You need to delete \'s\' from \\"sea\\" and \'t\' from \\"eat\\" to make both strings \\"ea\\". ``` Example 2 ``` Input: word1 = \\"abc\\", word2 = \\"def\\" Output: 6 Explanation: You need to delete all the characters from both strings (3 deletions from each) as they share no common subsequence. ``` # Constraints * The strings will consist of lowercase English letters only. * The length of each string will be between 1 and 1000. # Notes * Focus on implementing a solution with a time complexity of ( O(n times m) ) where ( n ) and ( m ) are the lengths of `word1` and `word2`, respectively. * Consider dynamic programming for an efficient approach to solving this problem.","solution":"def min_deletions(word1: str, word2: str) -> int: Returns the minimum number of deletions required to make the two strings identical. n, m = len(word1), len(word2) # Create a DP table where dp[i][j] represents the length of longest common subsequence of word1[0..i-1] and word2[0..j-1] dp = [[0] * (m + 1) for _ in range(n + 1)] # Fill the DP table for i in range(1, n + 1): for j in range(1, m + 1): if word1[i - 1] == word2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) # The length of the longest common subsequence lcs_length = dp[n][m] # The deletions required to make both strings identical return (n - lcs_length) + (m - lcs_length)"},{"question":"Scenario: As a software engineer, you are tasked with designing a robust word dictionary that supports efficient addition and searching of words. The dictionary should be capable of handling search queries with wildcard characters (`.`) that can represent any letter. Objective: Implement a class `WordDictionary` using a Trie. Requirements: 1. **Class Name**: `WordDictionary` 2. **Methods**: - `add_word(word: str)`: Adds a word into the data structure. - `search(word: str) -> bool`: Returns if the word is in the data structure. A word could contain the dot character \'.\' which can represent any one letter. Constraints: - `word` consists only of lowercase English letters and the dot character `.`. - All strings are non-empty and have a length up to 100. - The word dictionary should ideally support up to 10^4 calls to `add_word` and `search`. Example: ```python wd = WordDictionary() wd.add_word(\\"bad\\") wd.add_word(\\"dad\\") wd.add_word(\\"mad\\") assert wd.search(\\"pad\\") == False assert wd.search(\\"bad\\") == True assert wd.search(\\".ad\\") == True assert wd.search(\\"b..\\") == True ``` Implementation Hints: 1. Implement a Trie Node class that supports the fundamental Trie operations. 2. Ensure the `search` method is able to handle the `.` wildcard character efficiently. 3. Account for edge cases where the search word may consist only of wildcard characters.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class WordDictionary: def __init__(self): self.root = TrieNode() def add_word(self, word: str): node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, word: str) -> bool: return self._search_in_node(word, 0, self.root) def _search_in_node(self, word, index, node): if index == len(word): return node.is_end_of_word char = word[index] if char == \'.\': for child in node.children.values(): if self._search_in_node(word, index + 1, child): return True return False else: if char in node.children: return self._search_in_node(word, index + 1, node.children[char]) else: return False"},{"question":"# Shortest Path Detection with Negative Weight Cycles **Objective**: Implement a function to determine if a given directed weighted graph contains any negative-weight cycle reachable from a given source vertex. Use the Bellman-Ford algorithm principles to guide your solution. Function Signature ```python def detect_negative_cycle(graph, source): Determine if the graph contains a negative-weight cycle reachable from the source. Args: graph (dict): A graph represented as an adjacency list with edge weights. source (str): The starting vertex. Returns: bool: True if a negative weight cycle exists reachable from the source, False otherwise. ``` Input and Output * **Input**: * `graph`: A dictionary where keys are vertex identifiers and values are dictionaries of adjacent vertices with edge weights. * `source`: A string representing the source vertex. * **Output**: * A boolean value indicating whether a negative-weight cycle reachable from the source exists. Constraints * The graph may contain negative weight edges but no self-loops. * The graph is represented as a dict in the following format: ```python graph = { \'a\': {\'b\': 6, \'e\': 7}, \'b\': {\'c\': 5, \'d\': -4, \'e\': 8}, \'c\': {\'b\': -2}, \'d\': {\'a\': 2, \'c\': 7}, \'e\': {\'b\': -3} } ``` * The graph is guaranteed to be a directed graph. # Example Given the following graph: ```python graph = { \'a\': {\'b\': 6, \'e\': 7}, \'b\': {\'c\': 5, \'d\': -4, \'e\': 8}, \'c\': {\'b\': -2}, \'d\': {\'a\': 2, \'c\': 7}, \'e\': {\'b\': -3} } ``` With the source `\'a\'`, the function should return `False` indicating no reachable negative-weight cycle. If a negative-weight cycle exists, e.g.: ```python graph = { \'a\': {\'b\': 10}, \'b\': {\'c\': 5}, \'c\': {\'d\': -15}, \'d\': {\'b\': 1} } ``` With source `\'a\'`, the function should return `True`. # Implementation Strategy 1. Initialize the distance of all vertices to infinity except for the source which is set to 0. 2. Perform `V-1` iterations to relax all edges. 3. After `V-1` iterations, check for any further relaxation; if any edge is further relaxed, a negative-weight cycle exists. 4. Return the result based on the above checks.","solution":"def detect_negative_cycle(graph, source): Determine if the graph contains a negative-weight cycle reachable from the source. Args: graph (dict): A graph represented as an adjacency list with edge weights. source (str): The starting vertex. Returns: bool: True if a negative weight cycle exists reachable from the source, False otherwise. # Initialize distances from source to all other vertices as infinite # and distance to the source itself as 0. distances = {vertex: float(\'inf\') for vertex in graph} distances[source] = 0 # Number of vertices V = len(graph) # Relax all edges V-1 times for _ in range(V - 1): for u in graph: for v in graph[u]: if distances[u] != float(\'inf\') and distances[u] + graph[u][v] < distances[v]: distances[v] = distances[u] + graph[u][v] # Check for negative-weight cycles for u in graph: for v in graph[u]: if distances[u] != float(\'inf\') and distances[u] + graph[u][v] < distances[v]: return True # Found a negative cycle return False"},{"question":"# Task Description You are required to implement a stack-based algorithm to evaluate a given mathematical expression in postfix notation (Reverse Polish Notation). This involves utilizing the stack operations effectively to ensure the correct order of operations and result. Function Signature ```python def evaluate_postfix(expression: str) -> int: pass ``` Input - **expression**: A string representing a postfix notation mathematical expression. The expression contains single-digit integers and the operators `+`, `-`, `*`, `/`. Each element (number/operator) is separated by a space. Output - **Return Value**: An integer which is the result of the evaluated expression. Constraints - The expression is valid and contains at least one operator and two operands. - Division will be integer division (i.e., result of `3 / 2` will be `1`). # Example Example 1 - **Input**: `\\"2 3 1 * + 9 -\\"` - **Output**: `-4` - **Explanation**: Equivalent to ((2 + (3 * 1)) - 9) => (2 + 3) - 9 => 5 - 9 => -4. Example 2 - **Input**: `\\"5 1 2 + 4 * + 3 -\\"` - **Output**: `14` - **Explanation**: Equivalent to (5 + ((1 + 2) * 4) - 3) => (5 + 12 - 3) => 17 - 3 => 14. # Detailed Requirements - Use the stack data structure to manage the operands and perform operations as you traverse the input expression. - Handle edge cases such as insufficient operands for an operator and unary operations. # Hints - You may use a stack from Python\'s `list` type or implement your own utilizing the given `ArrayStack` or `LinkedListStack`. - Be mindful of operator precedence implicitly managed by the postfix notation. # Example usage ```python print(evaluate_postfix(\\"2 3 1 * + 9 -\\")) # Output: -4 print(evaluate_postfix(\\"5 1 2 + 4 * + 3 -\\")) # Output: 14 ```","solution":"def evaluate_postfix(expression: str) -> int: Evaluates a given postfix expression and returns the result. stack = [] tokens = expression.split() for token in tokens: if token in \'+-*/\': b = stack.pop() a = stack.pop() if token == \'+\': result = a + b elif token == \'-\': result = a - b elif token == \'*\': result = a * b elif token == \'/\': result = int(a / b) # Use int() to ensure integer division stack.append(result) else: stack.append(int(token)) return stack[0] # Example usage print(evaluate_postfix(\\"2 3 1 * + 9 -\\")) # Output: -4 print(evaluate_postfix(\\"5 1 2 + 4 * + 3 -\\")) # Output: 14"},{"question":"# Question: Subtree Validation Given two binary trees represented by their root nodes `big` and `small`, write a function `is_subtree(big, small)` to determine if `small` is a subtree of `big`. A subtree of a node in a binary tree should consist of that node and all its descendants in the exact structure. # Function Signature ```python def is_subtree(big: TreeNode, small: TreeNode) -> bool: ``` # Input Format - `big` and `small` are the root nodes of the binary trees. - Each `TreeNode` object has the following attributes: * `val`: an integer value. * `left`: a `TreeNode` representing the left child. * `right`: a `TreeNode` representing the right child. # Output Format - Return a boolean value `True` if `small` is a subtree of `big`, otherwise `False`. # Constraints - The number of nodes in `big` will range from `0` to `10^4`. - The number of nodes in `small` will range from `0` to `10^4`. - All node values are integers. # Examples Example 1 ```plaintext big: 3 / 4 5 / 1 2 small: 4 / 1 2 Output: True ``` Example 2 ```plaintext big: 3 / 4 5 / 1 2 / 0 small: 3 / 4 / 1 2 Output: False ``` # Additional Scenario Consider potential optimization for large tree sizes. Discuss how hashing or other methods might improve efficiency and analyze how they would integrate into the proposed solution.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_subtree(big: TreeNode, small: TreeNode) -> bool: if not small: return True if not big: return False if same_tree(big, small): return True return is_subtree(big.left, small) or is_subtree(big.right, small) def same_tree(node1: TreeNode, node2: TreeNode) -> bool: if not node1 and not node2: return True if not node1 or not node2: return False if node1.val != node2.val: return False return same_tree(node1.left, node2.left) and same_tree(node1.right, node2.right)"},{"question":"**Scenario**: You are tasked with developing a software solution for a delivery company. The company uses different routes with varying distances, including some routes with a negative cost (representing benefits or shortcuts that reduce the overall travel cost). It is crucial to determine whether the delivery routes contain any negative-weight cycles to ensure accurate route planning without falling into infinite loops. **Objective**: Implement the Bellman-Ford algorithm to determine if there\'s a negative-weight cycle reachable from a given source vertex. **Function Specification**: Write a function `detect_negative_cycle(graph, source)` that confirms if there is no negative-weight cycle reachable from the starting vertex. **Input**: * `graph`: A dictionary representing an adjacency list of the graph where keys are vertex identifiers and values are dictionaries with adjacent vertices as keys and edge weights as values. - Example: `{\'a\': {\'b\': 6, \'e\': 7}, \'b\': {\'c\': 5, \'d\': -4, \'e\': 8}, \'c\': {\'b\': -2}, \'d\': {\'a\': 2, \'c\': 7}, \'e\': {\'b\': -3}}` * `source`: A string representing the starting vertex. **Output**: * Return `True` if no negative-weight cycle is reachable from the source, otherwise return `False`. **Constraints**: * The graph may contain negative weights. * The graph does not contain any negative self-loops. **Example**: Input: ```python graph = { \'a\': {\'b\': 6, \'e\': 7}, \'b\': {\'c\': 5, \'d\': -4, \'e\': 8}, \'c\': {\'b\': -2}, \'d\': {\'a\': 2, \'c\': 7}, \'e\': {\'b\': -3} } source = \'a\' ``` Output: ```python True ``` Explanation: There is no negative-weight cycle reachable from vertex \'a\'. **Implementation Requirements**: * Apply the Bellman-Ford algorithm. * Initialize weights and predecessor nodes appropriately. * Perform edge relaxation. * Check for negative-weight cycles in the end. **Assessment Criteria**: * Correctness of the implementation. * Adherence to time complexity. * Handling of edge cases. * Code readability and documentation.","solution":"def detect_negative_cycle(graph, source): Detects if there is a negative-weight cycle in the graph reachable from the source. :param graph: Dictionary representing the adjacency list of the graph. :param source: The starting vertex. :return: True if there\'s no negative-weight cycle reachable from the source, otherwise False. # Step 1: Initialize distances from source to all vertices as infinite and distance to source itself as 0 distance = {vertex: float(\'inf\') for vertex in graph} distance[source] = 0 # Step 2: Relax all edges |V| - 1 times for _ in range(len(graph) - 1): for u in graph: for v, weight in graph[u].items(): if distance[u] != float(\'inf\') and distance[u] + weight < distance[v]: distance[v] = distance[u] + weight # Step 3: Check for negative-weight cycles for u in graph: for v, weight in graph[u].items(): if distance[u] != float(\'inf\') and distance[u] + weight < distance[v]: return False # Found a negative-weight cycle return True # No negative-weight cycle found"},{"question":"# Combination Sum Problem Using Dynamic Programming Problem Statement Given an integer array `nums` consists of distinct positive integers, and a target integer value `target`, your task is to find out the number of possible unique combinations (considering different orders as unique) that add up exactly to the target value using the elements from `nums`. Additionally, think about how the problem would change if negative numbers were allowed in the array. How should you modify your approach and what constraints need to be enforced? Function Signature ```python def combination_sum_topdown(nums: List[int], target: int) -> int: Find number of possible unique combinations in nums that add up to the target value using top-down dynamic programming approach. :param nums: List[int] -- The list of distinct positive integers. :param target: int -- The target integer sum you want to achieve. :return: int -- Number of possible unique combinations that sum up to target value. pass def combination_sum_bottom_up(nums: List[int], target: int) -> int: Find number of possible unique combinations in nums that add up to the target value using bottom-up dynamic programming approach. :param nums: List[int] -- The list of distinct positive integers. :param target: int -- The target integer sum you want to achieve. :return: int -- Number of possible unique combinations that sum up to target value. pass ``` Input Constraints * The array `nums` will have no duplicate elements and contains only positive integers. * The `target` will be a positive integer. * Constraints: (1 leq text{len(nums)} leq 200), (1 leq text{nums[i]}, text{target} leq 1000). Output * An integer representing the number of unique combinations of numbers from `nums` that add up to `target`. Examples Example 1: ```python nums = [1, 2, 3] target = 4 combination_sum_topdown(nums, target) # should return 7 combination_sum_bottom_up(nums, target) # should return 7 ``` Explanation: The possible combination ways are: (1, 1, 1, 1), (1, 1, 2), (1, 2, 1), (1, 3), (2, 1, 1), (2, 2), and (3, 1). Follow-Up Questions 1. What if negative numbers are allowed in the array? How does it change the problem? 2. What limitations need to be added to handle the problem with negative numbers? **Answer**: 1. Allowing negative numbers introduces an infinite loop of results because positive and negative numbers can sum to the same value in infinite ways. Constraints should be enforced to limit input size and combination length, or modify the approach to ensure termination. 2. One possible constraint can be to limit the number of times any number can be used. Alternatively, combinations should be checked for previously visited states to avoid cycles.","solution":"from typing import List def combination_sum_topdown(nums: List[int], target: int) -> int: memo = {} def helper(remaining: int) -> int: if remaining < 0: return 0 if remaining == 0: return 1 if remaining in memo: return memo[remaining] count = 0 for num in nums: count += helper(remaining - num) memo[remaining] = count return count return helper(target) def combination_sum_bottom_up(nums: List[int], target: int) -> int: dp = [0] * (target + 1) dp[0] = 1 for i in range(1, target + 1): for num in nums: if i - num >= 0: dp[i] += dp[i - num] return dp[target]"},{"question":"# RSA Encryption/Decryption Implementation You are tasked with securing a communication channel using RSA encryption. You need to create functions to securely transmit numeric data using RSA. Below is the RSA key generation and encryption code provided for your reference. You need to implement the necessary wrapper functions to simulate secure communication. # Goal 1. Implement the function `rsa_generate_keys(bit_length)` that generates RSA keys of the specified bit length. 2. Implement the function `rsa_encrypt(data, public_key)` that encrypts the given data using the provided public key. 3. Implement the function `rsa_decrypt(data, private_key, n)` that decrypts the given data using the private key and modulus `n`. # Requirements - **Function**: `rsa_generate_keys(bit_length)` - **Input**: `bit_length` - an integer representing the bit length of the RSA modulus `n`. - **Output**: Return a tuple `(public_key, private_key, modulus)`: - `public_key`: A tuple `(e, n)` where `e` is the encryption exponent and `n` is the modulus. - `private_key`: Integer representing the decryption exponent `d`. - `modulus`: Integer representing the modulus `n`. - **Function**: `rsa_encrypt(data, public_key)` - **Input**: - `data`: An integer representing the data to be encrypted. - `public_key`: A tuple `(e, n)` where `e` is the encryption exponent and `n` is the modulus. - **Output**: Return the encrypted data as an integer. - **Function**: `rsa_decrypt(data, private_key, n)` - **Input**: - `data`: An integer representing the encrypted data. - `private_key`: An integer representing the decryption exponent `d`. - `n`: An integer representing the modulus `n`. - **Output**: Return the decrypted data as an integer. # Example ```python # Generating the keys public_key, private_key, modulus = rsa_generate_keys(16) # Encrypting the data data = 20 encrypted_data = rsa_encrypt(data, public_key) # Decrypting the data decrypted_data = rsa_decrypt(encrypted_data, private_key, modulus) assert decrypted_data == data ``` # Constraints - `bit_length`: You may assume `bit_length` to be a multiple of 8 and not less than 16. - `data`: The data to be encrypted must be a non-negative integer. - Implement the solution in Python using efficient methods for prime number checks and modular arithmetic.","solution":"import random from sympy import isprime, gcd, mod_inverse def generate_prime(bit_length): while True: p = random.getrandbits(bit_length) if isprime(p): return p def rsa_generate_keys(bit_length): Generates RSA keys of the specified bit length. e = 65537 # common choice for e # Generate two distinct prime numbers p and q p = generate_prime(bit_length // 2) q = generate_prime(bit_length // 2) while p == q: q = generate_prime(bit_length // 2) n = p * q phi = (p - 1) * (q - 1) # Ensure e is coprime to phi assert gcd(e, phi) == 1, \\"e must be coprime to phi\\" d = mod_inverse(e, phi) public_key = (e, n) private_key = d return (public_key, private_key, n) def rsa_encrypt(data, public_key): Encrypts the data using the provided public key. e, n = public_key return pow(data, e, n) def rsa_decrypt(data, private_key, n): Decrypts the data using the provided private key. return pow(data, private_key, n)"},{"question":"# Unique Morse Code Transformations Context International Morse Code defines a standard encoding where each letter is mapped to a series of dots and dashes, as follows: ``` \'a\': \\".-\\", \'b\': \\"-...\\", \'c\': \\"-.-.\\", \'d\': \\"-..\\", \'e\': \\".\\", \'f\': \\"..-.\\", \'g\': \\"--.\\", \'h\': \\"....\\", \'i\': \\"..\\", \'j\': \\".---\\", \'k\': \\"-.-\\", \'l\': \\".-..\\", \'m\': \\"--\\", \'n\': \\"-.\\", \'o\': \\"---\\", \'p\': \\".--.\\", \'q\': \\"--.-\\", \'r\': \\".-.\\", \'s\': \\"...\\", \'t\': \\"-\\", \'u\': \\"..-\\", \'v\': \\"...-\\", \'w\': \\".--\\", \'x\': \\"-..-\\", \'y\': \\"-.--\\", \'z\': \\"--..\\" ``` Given a list of words, each word can be written as a concatenation of the Morse code of each letter. For example, the word \\"cab\\" can be written as \\"-.-.-....-\\". We\'ll call such a concatenation the transformation of a word. Write a function that takes a list of words and returns the number of different transformations among these words. Input: * A list of words (1 <= len(words) <= 100) where each word is a string with a length between 1 and 12 characters (inclusive). * Each word contains only lowercase English letters. Output: * An integer representing the number of unique Morse code transformations. Example: ```python Input: words = [\\"gin\\", \\"zen\\", \\"gig\\", \\"msg\\"] Output: 2 Explanation: The transformation of each word is: \\"gin\\" -> \\"--...-.\\" \\"zen\\" -> \\"--...-.\\" \\"gig\\" -> \\"--...--.\\" \\"msg\\" -> \\"--...--.\\" There are 2 different transformations: \\"--...-.\\" and \\"--...--.\\". ``` Constraints: * The function should handle edge cases like an empty list or a list with one word. * Consider performance optimizations for handling large lists and words. Implementation: ```python def unique_morse(words): morse_code = { \'a\':\\".-\\", \'b\':\\"-...\\", \'c\':\\"-.-.\\", \'d\': \\"-..\\", \'e\':\\".\\", \'f\':\\"..-.\\", \'g\':\\"--.\\", \'h\':\\"....\\", \'i\':\\"..\\", \'j\':\\".---\\", \'k\':\\"-.-\\", \'l\':\\".-..\\", \'m\':\\"--\\", \'n\':\\"-.\\", \'o\':\\"---\\", \'p\':\\".--.\\", \'q\':\\"--.-\\", \'r\':\\".-.\\", \'s\':\\"...\\", \'t\':\\"-\\", \'u\':\\"..-\\", \'v\':\\"...-\\", \'w\':\\".--\\", \'x\':\\"-..-\\", \'y\':\\"-.--\\", \'z\':\\"--..\\" } def convert_morse_word(word): morse_word = \\"\\".join(morse_code[char] for char in word) return morse_word unique_morse_words = set(convert_morse_word(word) for word in words) return len(unique_morse_words) # Example usage words = [\\"gin\\", \\"zen\\", \\"gig\\", \\"msg\\"] print(unique_morse(words)) # Output: 2 ```","solution":"def unique_morse(words): morse_code = { \'a\': \\".-\\", \'b\': \\"-...\\", \'c\': \\"-.-.\\", \'d\': \\"-..\\", \'e\': \\".\\", \'f\': \\"..-.\\", \'g\': \\"--.\\", \'h\': \\"....\\", \'i\': \\"..\\", \'j\': \\".---\\", \'k\': \\"-.-\\", \'l\': \\".-..\\", \'m\': \\"--\\", \'n\': \\"-.\\", \'o\': \\"---\\", \'p\': \\".--.\\", \'q\': \\"--.-\\", \'r\': \\".-.\\", \'s\': \\"...\\", \'t\': \\"-\\", \'u\': \\"..-\\", \'v\': \\"...-\\", \'w\': \\".--\\", \'x\': \\"-..-\\", \'y\': \\"-.--\\", \'z\': \\"--..\\" } def convert_morse_word(word): morse_word = \\"\\".join(morse_code[char] for char in word) return morse_word unique_morse_words = set(convert_morse_word(word) for word in words) return len(unique_morse_words) # Example usage words = [\\"gin\\", \\"zen\\", \\"gig\\", \\"msg\\"] print(unique_morse(words)) # Output: 2"},{"question":"You are given two strings: `haystack` and `needle`. Your task is to implement the function `find_needle_in_haystack(haystack: str, needle: str) -> int` which should return the index of the first occurrence of `needle` in `haystack`, or -1 if `needle` is not part of `haystack`. # Example ```python # Example 1 input: haystack = \\"hello\\", needle = \\"ll\\" output: 2 # Example 2 input: haystack = \\"aaaaa\\", needle = \\"bba\\" output: -1 # Example 3 input: haystack = \\"mississippi\\", needle = \\"issi\\" output: 1 ``` # Constraints - If `needle` is an empty string, return 0. - Both `haystack` and `needle` consist only of lower-case English characters. # Performance Requirements - Aim for an efficient solution. Ideally, optimize the solution to linear time complexity, i.e., O(N), where N is the length of `haystack`. # Edge Cases - An empty `needle` string. - A `needle` string longer than the `haystack` string. - Situations where the `needle` does not occur in the `haystack`. # Function Signature ```python def find_needle_in_haystack(haystack: str, needle: str) -> int: pass ``` Implement the function `find_needle_in_haystack` according to the given specification and ensure that it handles all edge cases and performance requirements effectively.","solution":"def find_needle_in_haystack(haystack: str, needle: str) -> int: Returns the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack. if not needle: return 0 len_haystack = len(haystack) len_needle = len(needle) if len_needle > len_haystack: return -1 for i in range(len_haystack - len_needle + 1): if haystack[i:i+len_needle] == needle: return i return -1"},{"question":"You are given a target value `value` and an array of coin denominations `coins`. Your task is to write a function that determines how many different combinations of coins sum up to the target `value`. Order of the coins in each combination does not matter. Assume you have an unlimited supply of each type of coin. The function signature is: ```python def count(coins: List[int], value: int) -> int: Given a list of integers representing coin denominations and a target value, return the number of different ways to make that value using any number of coins. Parameters: coins (List[int]): A list of integers representing the coin denominations. value (int): The target value to be achieved. Returns: int: The number of different ways to make the target value. ``` # Input * `coins`: A list of distinct integers representing the available coins. (1 ≤ len(coins) ≤ 50, 1 ≤ coins[i] ≤ 100) * `value`: An integer representing the target value. (0 ≤ value ≤ 1000) # Output * The function should return a single integer representing the number of different combinations that add up to `value`. # Constraints * Assume that you have infinite supply of each type of coin. * The answer is guaranteed to fit within a 32-bit integer. # Example ```python count([1, 2, 3], 4) # returns 4 because there are four combinations: [1, 1, 1, 1], [1, 1, 2], [2, 2], [1, 3] count([2, 5, 3, 6], 10) # returns 5 because there are five combinations: [2, 2, 2, 2, 2], [2, 2, 3, 3], [2, 2, 6], [2, 3, 5], [5, 5] ``` # Notes: * Make sure to handle edge cases, such as when the `value` is 0 or when no `coins` are provided. * Optimize for both time and space complexity as much as possible.","solution":"from typing import List def count(coins: List[int], value: int) -> int: Given a list of integers representing coin denominations and a target value, return the number of different ways to make that value using any number of coins. Parameters: coins (List[int]): A list of integers representing the coin denominations. value (int): The target value to be achieved. Returns: int: The number of different ways to make the target value. dp = [0] * (value + 1) dp[0] = 1 # There\'s one way to make the value 0, which is to use no coins. for coin in coins: for x in range(coin, value + 1): dp[x] += dp[x - coin] return dp[value]"},{"question":"# Linked List Cycle Detection You are an engineer tasked with maintaining a large system that involves numerous data structures, one of which is a linked list. Cycles in linked lists can cause unintended infinite loops and system crashes. Your task is to implement a function to detect whether a given linked list contains a cycle. Function Signature ```python def detect_cycle(head: Node) -> bool: Determines whether the linked list has a cycle. :param head: The head node of the linked list :return: True if there is a cycle in the linked list, False otherwise ``` Input * `head` (Node): The head node of the linked list. Output * Returns `True` if the linked list contains a cycle, `False` otherwise. Constraints * You must solve the problem using constant extra space, i.e., O(1) space complexity. * Each node in the linked list contains an integer value and a reference to the next node. Examples *Example 1:* ``` Input: head = [3 -> 2 -> 0 -> -4], tail connects to node index 1 Output: True Explanation: There is a cycle in the linked list where tail connects to the second node. 3 / 2 - 0 -4 ``` *Example 2:* ``` Input: head = [1 -> 2], tail connects to node index 0 Output: True Explanation: There is a cycle in the linked list where tail connects to the first node. 1 / 2 - ``` *Example 3:* ``` Input: head = [1] Output: False Explanation: There is no cycle in the linked list. 1 X ``` Notes * You can assume that the linked list nodes are structured with a class `Node` where: ```python class Node: def __init__(self, x): self.val = x self.next = None ``` * Focus on writing the function `detect_cycle` which utilizes Floyd’s Cycle-Finding Algorithm efficiently within specified constraints.","solution":"class Node: def __init__(self, x): self.val = x self.next = None def detect_cycle(head: Node) -> bool: Determines whether the linked list has a cycle. :param head: The head node of the linked list :return: True if there is a cycle in the linked list, False otherwise slow = head fast = head while fast is not None and fast.next is not None: slow = slow.next fast = fast.next.next if slow == fast: return True return False"},{"question":"You are required to implement a min-heap that supports efficient insertion and removal operations while maintaining the heap property. The heap should be capable of dynamically resizing as elements are added, and allow quick retrieval and deletion of the smallest element. Function to Implement You need to implement a class called `MinHeap` with the following methods: 1. `__init__()`: Initializes the heap. 2. `insert(val)`: Inserts a new value `val` into the heap maintaining the min-heap property. 3. `remove_min()`: Removes and returns the minimum value from the heap. Input Format * `insert(val)`: - `val` (integer): The value to be inserted into the heap. * `remove_min()`: - No parameters. Output Format * `insert(val)`: None * `remove_min()`: Returns the integer value representing the removed minimum element from the heap. Constraints * You can assume there will be at least one element in the heap when `remove_min()` is called. * Values inserted into the heap are between `-10^6` and `10^6`. # Example ```python # Example usage of the MinHeap class heap = MinHeap() heap.insert(4) heap.insert(50) heap.insert(7) heap.insert(55) heap.insert(90) heap.insert(87) heap.insert(2) print(heap.remove_min()) # Output: 2 print(heap.remove_min()) # Output: 4 heap.insert(3) print(heap.remove_min()) # Output: 3 ``` # Implementation Note * Ensure that you handle the edge cases such as removing from a single-element heap. * Use efficient techniques to maintain the heap property during insertions and deletions. * Optimize performance by minimizing unnecessary swaps during heap operations.","solution":"class MinHeap: def __init__(self): self.heap = [] def insert(self, val): self.heap.append(val) self._bubble_up(len(self.heap) - 1) def remove_min(self): if len(self.heap) == 1: return self.heap.pop() min_val = self.heap[0] self.heap[0] = self.heap.pop() self._bubble_down(0) return min_val def _bubble_up(self, index): parent_index = (index - 1) // 2 if index > 0 and self.heap[index] < self.heap[parent_index]: self.heap[index], self.heap[parent_index] = self.heap[parent_index], self.heap[index] self._bubble_up(parent_index) def _bubble_down(self, index): child_index = 2 * index + 1 if child_index >= len(self.heap): return if child_index + 1 < len(self.heap) and self.heap[child_index + 1] < self.heap[child_index]: child_index += 1 if self.heap[index] > self.heap[child_index]: self.heap[index], self.heap[child_index] = self.heap[child_index], self.heap[index] self._bubble_down(child_index)"},{"question":"Problem Statement You are provided with a string containing lowercase Latin characters. Your task is to write a function that finds and returns the length of the longest substring without repeating characters. Additionally, you should return the substring itself. Function Signature ```python def longest_non_repeating_substring(s: str) -> Tuple[int, str]: Parameters: - s (str): The input string containing lowercase Latin characters. Returns: - Tuple[int, str]: A tuple containing the length of the longest substring and the longest substring itself without repeating characters. ``` Input and Output * **Input**: - A string `s` of length n (0 ≤ n ≤ 10^4), consisting of lowercase Latin characters. * **Output**: - A tuple (int, str), where the first element is the length of the longest non-repeating substring, and the second element is the longest substring itself. Constraints * The function should handle cases where the input string is empty by returning (0, \'\'). * The function should perform efficiently even for the maximum input size. Example ```python assert longest_non_repeating_substring(\\"abcabcbb\\") == (3, \\"abc\\") assert longest_non_repeating_substring(\\"bbbbb\\") == (1, \\"b\\") assert longest_non_repeating_substring(\\"pwwkew\\") == (3, \\"wke\\") assert longest_non_repeating_substring(\\"\\") == (0, \\"\\") ``` Hints 1. Use the sliding window approach with two pointers. 2. Utilize a dictionary to keep track of characters\' last seen positions. 3. Make sure to adjust the window start correctly when a duplicate character is encountered. Good luck, and think through the problem carefully before starting your implementation!","solution":"from typing import Tuple def longest_non_repeating_substring(s: str) -> Tuple[int, str]: Finds the length of the longest substring without repeating characters and returns the substring itself. Parameters: - s (str): The input string containing lowercase Latin characters. Returns: - Tuple[int, str]: A tuple containing the length of the longest substring and the longest substring itself without repeating characters. n = len(s) if n == 0: return (0, \\"\\") char_index = {} max_length = 0 start = 0 longest_substring = \\"\\" for end in range(n): if s[end] in char_index and char_index[s[end]] >= start: start = char_index[s[end]] + 1 char_index[s[end]] = end current_length = end - start + 1 if current_length > max_length: max_length = current_length longest_substring = s[start:end+1] return (max_length, longest_substring)"},{"question":"# Advanced Binary Search Tree (BST) Implementation You are tasked to enhance the given Binary Search Tree (BST) algorithm by adding new functionalities and ensuring efficiency. The enhanced BST should include: 1. **Delete Node**: Implement a method to delete a node from the BST. 2. **Find Minimum and Maximum**: Implement methods to find the minimum and maximum values in the BST. 3. **Height Calculation**: Implement a method to calculate the height of the BST. 4. **Self-Balancing**: Optional for extra credit - Implement a self-balancing feature such as AVL rotations to maintain a balanced BST. Expected input and output formats: - **Delete Node**: - Input: `int (value to be deleted)` - Output: `bool (True if deleted, False if value not found)` - **Find Minimum and Maximum**: - Input: `None` - Output: `int (minimum or maximum value)` - **Height Calculation**: - Input: `None` - Output: `int (height of the tree)` - **Self-Balancing**: - Input and output should handle insertions and deletions maintaining the balance property. Constraints: - Node values will be integers. - Duplicate values should not be inserted into the BST. - Submissions should handle invalid operations gracefully. # Example Usage: ```python bst = BST() bst.insert(10) bst.insert(20) bst.insert(5) print(bst.find_min()) # Output: 5 print(bst.find_max()) # Output: 20 print(bst.height()) # Output: 2 print(bst.delete(20)) # Output: True print(bst.delete(30)) # Output: False ``` # Requirements: 1. Ensure all operations (insert, delete, search, traverse) maintain O(log N) average complexity. 2. Properly handle edge cases as described in the implementation challenges. 3. Bonus: Implement AVL rotation methodology to keep the tree height balanced. --- Best of luck, and make sure to test your implementation thoroughly!","solution":"class TreeNode: def __init__(self, key): self.left = None self.right = None self.val = key self.height = 1 # height is used for AVL balancing class BST: def __init__(self): self.root = None def insert(self, key): if not self.root: self.root = TreeNode(key) else: self.root = self._insert(self.root, key) def _insert(self, node, key): if not node: return TreeNode(key) if key < node.val: node.left = self._insert(node.left, key) elif key > node.val: node.right = self._insert(node.right, key) node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) return self._balance(node) def delete(self, key): if self.root: self.root, deleted = self._delete(self.root, key) return deleted return False def _delete(self, node, key): if not node: return node, False if key < node.val: node.left, deleted = self._delete(node.left, key) elif key > node.val: node.right, deleted = self._delete(node.right, key) else: deleted = True if not (node.left and node.right): node = node.left if node.left else node.right else: min_larger_node = self._get_min(node.right) node.val = min_larger_node.val node.right, _ = self._delete(node.right, min_larger_node.val) if not node: return node, deleted node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) node = self._balance(node) return node, deleted def find_min(self): if not self.root: return None return self._get_min(self.root).val def _get_min(self, node): while node.left: node = node.left return node def find_max(self): if not self.root: return None return self._get_max(self.root).val def _get_max(self, node): while node.right: node = node.right return node def height(self): if not self.root: return 0 return self.root.height def _get_height(self, node): if not node: return 0 return node.height def _balance(self, node): balance_factor = self._get_balance(node) if balance_factor > 1: if self._get_balance(node.left) < 0: node.left = self._rotate_left(node.left) return self._rotate_right(node) if balance_factor < -1: if self._get_balance(node.right) > 0: node.right = self._rotate_right(node.right) return self._rotate_left(node) return node def _get_balance(self, node): if not node: return 0 return self._get_height(node.left) - self._get_height(node.right) def _rotate_right(self, y): x = y.left T2 = x.right x.right = y y.left = T2 y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) x.height = 1 + max(self._get_height(x.left), self._get_height(x.right)) return x def _rotate_left(self, x): y = x.right T2 = y.left y.left = x x.right = T2 x.height = 1 + max(self._get_height(x.left), self._get_height(x.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y"},{"question":"# Sorting Validation in a Singly Linked List Objective Implement a function to verify if a singly linked list is sorted in non-decreasing order. Problem Statement Write a function `is_sorted` that checks if a singly linked list is sorted in non-decreasing order. A singly linked list is said to be sorted if for every node `i` with a value `val[i]`, the value of the next node `val[i+1]` is greater than or equal to `val[i]`. # Function Signature ```python def is_sorted(head: Optional[ListNode]) -> bool: pass ``` Input - `head`: The head node of the singly linked list. Each node in the list has the following structure: ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next ``` Output - Return `True` if the list is sorted in non-decreasing order; otherwise, return `False`. Constraints - The list can be empty. An empty list is considered sorted. - Assume `ListNode` values are integers. Example ```python # Example 1: # Input: head = [1, 2, 3, 4] # Output: True # Explanation: The list is sorted in non-decreasing order. # Example 2: # Input: head = [1, 3, 2, 4] # Output: False # Explanation: The list is not sorted as 3 is followed by 2. # Example 3: # Input: head = None # Output: True # Explanation: An empty list is considered sorted. # Example 4: # Input: head = [1] # Output: True # Explanation: A single element list is considered sorted. ``` Notes - Maintain an efficient solution with (O(n)) time complexity. - Ensure that your function handles edge cases appropriately. - Do not mutate the original linked list.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def is_sorted(head: ListNode) -> bool: Check if a singly linked list is sorted in non-decreasing order. :param head: The head node of the singly linked list. :return: True if sorted in non-decreasing order, otherwise False. if not head: return True current = head while current.next: if current.val > current.next.val: return False current = current.next return True"},{"question":"# Pattern Matching with Backtracking Objective You need to implement a function that checks whether a given string follows a specified pattern using backtracking. Function Signature ```python def pattern_match(pattern: str, string: str) -> bool: :param pattern: A string representing the pattern of lowercase letters. :param string: A target string containing only lowercase letters. :return: A boolean indicating if the string follows the pattern. ``` Input - `pattern` : A string containing only lowercase letters, representing the pattern. - `string` : A string containing only lowercase letters, representing the target string. Output - Returns a boolean value `True` if the string follows the given pattern, otherwise `False`. Constraints - Both `pattern` and `string` will only contain lowercase letters. - You can assume that both `pattern` and `string` are non-empty. Example ```python assert pattern_match(\\"abab\\", \\"redblueredblue\\") == True assert pattern_match(\\"aaaa\\", \\"asdasdasdasd\\") == True assert pattern_match(\\"aabb\\", \\"xyzabcxzyabc\\") == False ``` Performance Requirements The function should handle patterns and strings of moderate size efficiently, but extreme edge cases may exceed acceptable runtime limits due to the inherent complexity of the problem. Detailed Description Implement the function `pattern_match` that follows these steps: 1. If the entire pattern is matched with substrings of the string, return True. 2. For each character in the pattern, try all possible substrings in the string, map them in a dictionary, and recursively verify the remaining segments. 3. Ensure a bijection between a pattern character and a non-empty substring of the string. 4. Backtrack if a certain partitioning doesn\'t lead to a valid matching and explore other potential partitions.","solution":"def pattern_match(pattern: str, string: str) -> bool: def is_match(p_index, s_index, p_to_s, s_to_p): # Base case: If both pattern and string are fully matched if p_index == len(pattern) and s_index == len(string): return True # If one is matched but not the other if p_index == len(pattern) or s_index == len(string): return False # Get current pattern character current_pattern_char = pattern[p_index] # Try all possible substrings starting from current string index for end in range(s_index + 1, len(string) + 1): sub_str = string[s_index:end] if current_pattern_char not in p_to_s and sub_str not in s_to_p: # Try to map pattern char to substring p_to_s[current_pattern_char] = sub_str s_to_p[sub_str] = current_pattern_char # Continue to match the rest if is_match(p_index + 1, end, p_to_s, s_to_p): return True # Backtrack del p_to_s[current_pattern_char] del s_to_p[sub_str] elif current_pattern_char in p_to_s and p_to_s[current_pattern_char] == sub_str: # Continue to match the rest if is_match(p_index + 1, end, p_to_s, s_to_p): return True return False return is_match(0, 0, {}, {}) # Examples for testing print(pattern_match(\\"abab\\", \\"redblueredblue\\")) # Should return True print(pattern_match(\\"aaaa\\", \\"asdasdasdasd\\")) # Should return True print(pattern_match(\\"aabb\\", \\"xyzabcxzyabc\\")) # Should return False"},{"question":"# Decoding Messages: Advanced Coding Assessment Problem Statement A message containing letters from A-Z is encoded to numbers using the following mapping: - \'A\' -> 1 - \'B\' -> 2 - ... - \'Z\' -> 26 You are given an encoded message consisting of digits. Your task is to determine the total number of ways to decode it. For example, the encoded message \\"12\\" can be decoded to \\"AB\\" (1 2) or \\"L\\" (12). Therefore, the number of ways to decode \\"12\\" is 2. Function Signature ```python def count_decodings(encoded_message: str) -> int: pass ``` Input: - A single string `encoded_message` consisting of digits (0-9) with a length of at most 1000. Output: - An integer representing the total number of ways to decode the encoded message. Constraints: - The input string will not be empty. - The string may contain leading \'0\'s which need to be handled carefully. - You should consider all possible valid decodings. Performance Requirements: - Your solution should have a time complexity of O(n) and a space complexity of O(1). Scenarios: - Decode \\"226\\": The valid decodings are \\"BZ\\" (2 26), \\"VF\\" (22 6), and \\"BBF\\" (2 2 6). Thus, the number of ways to decode \\"226\\" is 3. - Decode \\"0\\": As \'0\' does not map to any letter, there are 0 valid ways to decode \\"0\\". - Decode \\"10\\": Can only be decoded as \\"J\\" (10). Example Test Cases ```python encoded_message = \\"12\\" assert count_decodings(encoded_message) == 2 encoded_message = \\"226\\" assert count_decodings(encoded_message) == 3 encoded_message = \\"0\\" assert count_decodings(encoded_message) == 0 encoded_message = \\"10\\" assert count_decodings(encoded_message) == 1 ``` Implement the function `count_decodings` to pass all test cases based on the given example and constraints. Additional Notes: Ensure your solution handles edge cases, such as multiple consecutive zeros and large input sizes efficiently.","solution":"def count_decodings(encoded_message: str) -> int: if not encoded_message or encoded_message[0] == \'0\': return 0 # Initialize ways to decode for previous two values n = len(encoded_message) prev_decodings, current_decodings = 1, 1 for i in range(1, n): current = int(encoded_message[i]) prev = int(encoded_message[i - 1]) temp = 0 # If current character is non-zero, it can stand alone as a valid character if current > 0: temp += current_decodings # If the two-character string is between 10 and 26, it\'s a valid character combined = prev * 10 + current if combined >= 10 and combined <= 26: temp += prev_decodings # Update decodings (move window forward) prev_decodings, current_decodings = current_decodings, temp return current_decodings"},{"question":"# Scenario A logistics company needs to efficiently plan delivery routes. They have realized that sorting their delivery addresses in a specific order can significantly optimize their delivery scheduling algorithm. You are tasked with implementing an efficient sorting algorithm (Merge Sort) to help them achieve this. # Problem Statement Implement the Merge Sort algorithm to sort an array of integers in non-decreasing order. # Function Signature ```python def merge_sort(arr: list) -> list: Perform an in-place merge sort on the input list. Parameters: arr (list): A list of integers. Returns: list: The input list sorted in non-decreasing order. ``` # Input Format * A list `arr` of integers. # Output Format * A list `arr` sorted in non-decreasing order. # Constraints * 0 <= len(arr) <= 10^5 * -10^9 <= arr[i] <= 10^9 for all valid i. # Performance Requirements * The solution should handle the worst-case time complexity of O(n log n). # Example ```python # Example 1: input_list = [5, 2, 9, 1, 5, 6] output_list = merge_sort(input_list) print(output_list) # Output: [1, 2, 5, 5, 6, 9] # Example 2: input_list = [0, -4, 3, 3, -2] output_list = merge_sort(input_list) print(output_list) # Output: [-4, -2, 0, 3, 3] ``` # Additional Notes * Your implementation should be as efficient as possible. * Aim to minimize additional memory usage. Good luck! Your implementation will be evaluated on its correctness, efficiency, and adherence to the constraints and performance requirements.","solution":"def merge_sort(arr: list) -> list: if len(arr) <= 1: return arr def merge(left, right): merged, left_index, right_index = [], 0, 0 while left_index < len(left) and right_index < len(right): if left[left_index] <= right[right_index]: merged.append(left[left_index]) left_index += 1 else: merged.append(right[right_index]) right_index += 1 # If there are remaining elements in left or right, add them merged.extend(left[left_index:]) merged.extend(right[right_index:]) return merged mid = len(arr) // 2 left_half = merge_sort(arr[:mid]) right_half = merge_sort(arr[mid:]) return merge(left_half, right_half)"},{"question":"# Invert a Binary Tree In this exercise, you will implement a function to invert a binary tree. This involves swapping the left and right children of every node in the tree. Given a binary tree where each node contains an integer value, write a function `invert_tree` that returns the root of the inverted tree. Implementation Details - **Input**: A binary tree represented by its root node. - **Output**: The root node of the binary tree after inverting it. Constraints: - The tree can contain up to (10^4) nodes. - Each node\'s value is a unique integer. Example: ```plaintext Input: 4 / 2 7 / / 1 3 6 9 Output: 4 / 7 2 / / 9 6 3 1 ``` Function Signature: ```python class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def invert_tree(root: TreeNode) -> TreeNode: # Your implementation here pass ``` 使用给定的类定义来创建用于测试的树。例如: ```python # Example of creating the input tree root = TreeNode(4) root.left = TreeNode(2) root.right = TreeNode(7) root.left.left = TreeNode(1) root.left.right = TreeNode(3) root.right.left = TreeNode(6) root.right.right = TreeNode(9) # Function call to invert the tree new_root = invert_tree(root) ```","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def invert_tree(root: TreeNode) -> TreeNode: Function to invert a binary tree by swapping the left and right children of every node. if root is None: return None # Swap the left and right children root.left, root.right = root.right, root.left # Recur for left and right subtree invert_tree(root.left) invert_tree(root.right) return root"},{"question":"Given a positive integer `n`, devise an algorithm to determine the number of ways to partition `n` as a sum of positive integers. Ensure that your solution uses dynamic programming to achieve an optimal time complexity of O(n^2) and space complexity of O(n^2). Your task is to implement the function `integer_partitions(n: int) -> int` which meets the specification below: # Function Specification Input * `n (int)`: A positive integer (1 <= n <= 1000) Output * Returns an integer representing the number of different ways to partition `n` as a sum of positive integers. # Constraints * Time complexity should be O(n^2) * Space complexity should be O(n^2) # Example ```python assert integer_partitions(4) == 5 # Explanation: [4], [3+1], [2+2], [2+1+1], [1+1+1+1] assert integer_partitions(7) == 15 # Explanation: [7], [6+1], [5+2], [5+1+1], [4+3], [4+2+1], [4+1+1+1], [3+3+1], [3+2+2], [3+2+1+1], [3+1+1+1+1], [2+2+2+1], [2+2+1+1+1], [2+1+1+1+1+1], [1+1+1+1+1+1+1] ``` # Additional Information * Consider edge cases where `n` is small (e.g., 1 or 2) * Your function should be efficient when `n` is large up to 1000. Implement the function as specified above.","solution":"def integer_partitions(n): Returns the number of ways to partition a positive integer n as the sum of positive integers. dp = [[0 for _ in range(n+1)] for _ in range(n+1)] # Base case: There is one way to partition 0 (using no parts). dp[0][0] = 1 for i in range(1, n+1): for j in range(0, n+1): if j >= i: dp[i][j] = dp[i-1][j] + dp[i][j-i] else: dp[i][j] = dp[i-1][j] return dp[n][n]"},{"question":"**Scenario:** Given the task of improving the codebase for a word puzzle application, you need to efficiently check whether two given words are anagrams. An anagram of a word is a rearrangement of its letters to form another word. **Function Implementation:** Write a function `check_anagram(s, t)` that takes in two strings s and t and returns `True` if t is an anagram of s, and `False` otherwise. **Input:** - `s` (string): A non-empty string containing only lowercase alphabets. - `t` (string): A non-empty string containing only lowercase alphabets. **Output:** - Boolean value: Returns `True` if the string `t` is an anagram of the string `s`, and `False` otherwise. **Constraints:** - All characters in the input strings will be lowercase English letters. - The length of the strings will be in the range [1, 10^5]. **Performance Requirements:** - The solution should have a time complexity of O(n) and a space complexity of O(1), where n is the length of the longest input string. **Examples:** 1. `check_anagram(\\"listen\\", \\"silent\\")` should return `True`. 2. `check_anagram(\\"triangle\\", \\"integral\\")` should return `True`. 3. `check_anagram(\\"apple\\", \\"pale\\")` should return `False`. **Edge Cases to Consider:** 1. If the lengths of `s` and `t` are different, they cannot be anagrams. 2. Strings with the same characters but in different frequencies are not anagrams. 3. Handling empty string scenarios effectively.","solution":"def check_anagram(s, t): Returns True if t is an anagram of s, and False otherwise. if len(s) != len(t): return False from collections import Counter return Counter(s) == Counter(t)"},{"question":"Implement the function `first_cyclic_node` using Floyd\'s Cycle-Finding Algorithm. The function will take a linked list and return the first node of the cycle if one exists. If there is no cycle, it should return `None`. # Function Signature ```python class Node: def __init__(self, val: int): self.val = val self.next = None def first_cyclic_node(head: Node) -> Node: ``` # Input * `head` (`Node`): The head node of the linked list. # Output * `Node`: The first node in the cycle. If no cycle exists, return `None`. # Constraints 1. The linked list could be of any length, including 0. 2. Node values are unique, except for cycle nodes. # Example ```python # create linked list => A -> B -> C -> D -> E -> C head = Node(\'A\') head.next = Node(\'B\') curr = head.next cyclic_node = Node(\'C\') curr.next = cyclic_node curr = curr.next curr.next = Node(\'D\') curr = curr.next curr.next = Node(\'E\') curr = curr.next curr.next = cyclic_node # Expected output: The node with value \'C\' assert first_cyclic_node(head).val == \'C\' ``` # Additional Notes 1. The function must handle edge cases such as empty lists and lists with no cycles. 2. Ensure the function does not modify the input list. 3. Aim for an optimal solution in terms of time and space complexity.","solution":"class Node: def __init__(self, val: int): self.val = val self.next = None def first_cyclic_node(head: Node) -> Node: if not head or not head.next: return None slow = fast = head # Detect if a cycle exists while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: break else: return None # No cycle found # Find the entry point of the cycle slow = head while slow != fast: slow = slow.next fast = fast.next return slow"},{"question":"You are provided with an integer array `arr`. Your task is to implement the Shell Sort algorithm to sort the array in ascending order. Shell Sort is an optimization over Insertion Sort that allows the exchange of far apart elements, significantly reducing the overall number of swaps needed in some cases. # Function Signature ```python def shell_sort(arr: List[int]) -> List[int]: ``` # Input - `arr`: A list of integers (0 ≤ len(arr) ≤ 10^5, -10^9 ≤ arr[i] ≤ 10^9) # Output - The function should return a list of integers sorted in ascending order. # Constraints - You must use the Shell Sort algorithm. - You should avoid using built-in sort functions. # Example ```python Example 1: Input: arr = [64, 34, 25, 12, 22, 11, 90] Output: [11, 12, 22, 25, 34, 64, 90] Example 2: Input: arr = [5, 3, 2, 6, 4, 1] Output: [1, 2, 3, 4, 5, 6] ``` # Notes - You need to implement an in-place version with O(1) extra space. - Choose the gap sequence wisely for optimal performance.","solution":"from typing import List def shell_sort(arr: List[int]) -> List[int]: Sorts an array of integers using the Shell Sort algorithm. Parameters: arr (List[int]): The list of integers to be sorted. Returns: List[int]: The sorted list of integers. n = len(arr) gap = n // 2 while gap > 0: # Perform a gapped insertion sort for i in range(gap, n): temp = arr[i] j = i while j >= gap and arr[j - gap] > temp: arr[j] = arr[j - gap] j -= gap arr[j] = temp gap //= 2 return arr"},{"question":"# Matrix Exponentiation Programming Assessment Context: Matrix exponentiation is a fundamental technique used in various applications ranging from computer graphics to solving linear recurrence relations efficiently. The core algorithm leverages repeated squaring to achieve logarithmic reduction in the number of matrix multiplications required. Task: Write a function `power_matrix(mat: list, p: int) -> list` that takes a square matrix `mat` of dimension `d x d` and an integer `p`, then returns the matrix raised to the power `p`. Function Signature: ```python def power_matrix(mat: list, p: int) -> list: pass ``` Input: 1. `mat` (List[List[int]]): A square matrix of integers (`d x d` dimensions where 1 <= d <= 50). 2. `p` (int): A non-negative integer (0 <= p <= 10^9). Output: - A list of lists representing the matrix `mat` raised to the power `p`. Constraints: - Carefully manage the time complexity due to the large possible values of `p`. - Ensure correct identity matrix handling for the base case where `p = 0`. Example: # Example 1: **Input**: ```python mat = [ [1, 2], [3, 4] ] p = 2 ``` **Output**: ```python [ [7, 10], [15, 22] ] ``` # Example 2: **Input**: ```python mat = [ [1, 0], [0, 1] ] p = 1000000000 ``` **Output**: ```python [ [1, 0], [0, 1] ] ``` Notes: - Use the provided matrix multiplication and identity matrix functions or implement them efficiently. - Consider edge cases carefully, especially the identity matrix for `p = 0`.","solution":"def matrix_multiply(mat1, mat2): size = len(mat1) result = [[0] * size for _ in range(size)] for i in range(size): for j in range(size): for k in range(size): result[i][j] += mat1[i][k] * mat2[k][j] return result def identity_matrix(size): return [[1 if i == j else 0 for j in range(size)] for i in range(size)] def power_matrix(mat, p): if p == 0: return identity_matrix(len(mat)) result = identity_matrix(len(mat)) base = mat while p > 0: if p % 2 == 1: result = matrix_multiply(result, base) base = matrix_multiply(base, base) p //= 2 return result"},{"question":"# Binary Search Problem: Last Occurrence in Sorted Array You are given a sorted array of integers in increasing order and a target value. Your task is to implement a function that finds the last occurrence of the target value in the array using binary search. If the target value is not present in the array, return `-1`. # Function Signature ```python def last_occurrence(array: List[int], target: int) -> int: pass ``` # Input * `array`: A list of integers sorted in increasing order. `1 <= len(array) <= 10^6` * `target`: An integer value to search for in the array. `-10^9 <= target <= 10^9` # Output * Return the index of the last occurrence of the target value in the array. If the target is not present in the array, return `-1`. # Constraints * The algorithm must run in O(log n) time complexity. * Use of additional storage (beyond a few integers) should be kept to a minimum to ensure O(1) space complexity. # Example ```python # Example 1 array = [1, 2, 2, 2, 3, 4, 5] target = 2 Output: 3 # The last occurrence of 2 is at index 3 # Example 2 array = [1, 2, 2, 2, 3, 4, 5] target = 6 Output: -1 # The target 6 is not present in the array # Example 3 array = [1, 2, 2, 2, 3, 4, 5] target = 1 Output: 0 # The last occurrence of 1 is at index 0 ``` **Note**: * You should handle edge cases such as empty arrays, arrays where all elements are the same, and targets that do not exist in the array. # Hints 1. Pay special attention to the condition for determining the last occurrence of the target. 2. Consider handling scenarios where consecutive elements are equal. 3. Ensure the mid calculation uses integer division for accuracy.","solution":"from typing import List def last_occurrence(array: List[int], target: int) -> int: left, right = 0, len(array) - 1 result = -1 while left <= right: mid = left + (right - left) // 2 if array[mid] == target: result = mid left = mid + 1 elif array[mid] < target: left = mid + 1 else: right = mid - 1 return result"},{"question":"# Context Red-Black Trees are fundamental data structures meeting the needs for balanced search trees. They ensure operations like insertions, deletions, and search are performed in logarithmic time. You\'ve been tasked with improving the efficiency of data handling in a large-scale application by replacing its current unbalanced BST with a Red-Black Tree. # Task Implement an efficient algorithm to handle the insertion operation in a Red-Black Tree. Ensure that all the red-black properties are maintained and the tree remains balanced after each insertion. # Function to Implement Implement the method `insert` within the `RBTree` class. This method should accept a node and insert it into the tree, ensuring all Red-Black Tree properties are maintained. # Input - `node`: An instance of `RBNode` with its initial value and color set (color should always be red at the time of creation). # Output - The function should update the tree structure in place. No return value is expected. # Constraints - Do not assume a balanced input order during insertion. - Always keep the root black. - Ensure the tree remains balanced after each insertion. # Example Consider a sequence of nodes to be inserted: [11, 2, 14, 1, 7, 15, 5, 8, 4] After inserting these nodes, traversing the tree in-order should yield a list of node values with their respective colors. Example format for output: ```python rb = RBTree() children = [11, 2, 14, 1, 7, 15, 5, 8, 4] for child in children: node = RBNode(child, 1) # All nodes start as red (1) rb.insert(node) print(rb.inorder()) # Example output: # [{\'val\': 1, \'color\': 1}, {\'val\': 2, \'color\': 0}, {\'val\': 4, \'color\': 1}, {\'val\': 5, \'color\': 0}, {\'val\': 7, \'color\': 1}, # {\'val\': 8, \'color\': 0}, {\'val\': 11, \'color\': 0}, {\'val\': 14, \'color\': 0}, {\'val\': 15, \'color\': 1}] ``` # Notes 1. Remember that Red-Black Trees provide guarantees that keep the tree height balanced under dynamic data inputs. 2. Ensure that, after insertion, the Red-Black properties are not violated and rotations are correctly performed if necessary.","solution":"class RBNode: def __init__(self, val, color=1): self.val = val self.color = color # 1 for red, 0 for black self.left = None self.right = None self.parent = None class RBTree: def __init__(self): self.TNULL = RBNode(0) self.TNULL.color = 0 # Black color for TNULL self.root = self.TNULL def inorder(self, node, res): if node != self.TNULL: self.inorder(node.left, res) res.append({\'val\': node.val, \'color\': node.color}) self.inorder(node.right, res) return res def left_rotate(self, x): y = x.right x.right = y.left if y.left != self.TNULL: y.left.parent = x y.parent = x.parent if x.parent is None: self.root = y elif x == x.parent.left: x.parent.left = y else: x.parent.right = y y.left = x x.parent = y def right_rotate(self, x): y = x.left x.left = y.right if y.right != self.TNULL: y.right.parent = x y.parent = x.parent if x.parent is None: self.root = y elif x == x.parent.right: x.parent.right = y else: x.parent.left = y y.right = x x.parent = y def insert_fix(self, k): while k.parent.color == 1: if k.parent == k.parent.parent.left: u = k.parent.parent.right if u.color == 1: u.color = 0 k.parent.color = 0 k.parent.parent.color = 1 k = k.parent.parent else: if k == k.parent.right: k = k.parent self.left_rotate(k) k.parent.color = 0 k.parent.parent.color = 1 self.right_rotate(k.parent.parent) else: u = k.parent.parent.left if u.color == 1: u.color = 0 k.parent.color = 0 k.parent.parent.color = 1 k = k.parent.parent else: if k == k.parent.left: k = k.parent self.right_rotate(k) k.parent.color = 0 k.parent.parent.color = 1 self.left_rotate(k.parent.parent) if k == self.root: break self.root.color = 0 def insert(self, key): node = RBNode(key) node.parent = None node.left = self.TNULL node.right = self.TNULL node.color = 1 y = None x = self.root while x != self.TNULL: y = x if node.val < x.val: x = x.left else: x = x.right node.parent = y if y is None: self.root = node elif node.val < y.val: y.left = node else: y.right = node if node.parent is None: node.color = 0 return if node.parent.parent is None: return self.insert_fix(node)"},{"question":"Context: You are developing a system that requires precise manipulation of data at the bit level to perform efficient computations. You need to implement a set of operations that can read, modify, or clear specific bits within an integer to manage configuration flags and other bit-level data structures effectively. Problem Statement: Implement the following four bit manipulation functions that operate on a single 32-bit integer: 1. `get_bit(num: int, i: int) -> bool`: Returns `True` if the bit at index `i` in `num` is 1, otherwise returns `False`. 2. `set_bit(num: int, i: int) -> int`: Sets the bit at index `i` in `num` to 1 and returns the new integer. 3. `clear_bit(num: int, i: int) -> int`: Clears the bit at index `i` in `num` to 0 and returns the new integer. 4. `update_bit(num: int, i: int, bit: bool) -> int`: Updates the bit at index `i` in `num` to the value of `bit` (either 0 or 1) and returns the new integer. Input and Output: - `get_bit(num, i)` should return `True` or `False`. - `set_bit(num, i)`, `clear_bit(num, i)`, and `update_bit(num, i, bit)` should return an integer. Constraints: - `num` is a 32-bit signed integer. - `0 <= i <= 31` (index `i` refers to the bit position within the 32-bit integer). - For `update_bit`, `bit` can only be `0` or `1`. Example: ```python num = 29 # Binary: 11101 i = 2 get_bit(num, i) # Returns: True (since the third bit is 1) set_bit(num, i) # Returns: 29 (since the third bit is already set) clear_bit(num, i) # Returns: 25 (Binary: 11001) update_bit(num, i, 0) # Returns: 25 (Binary: 11001) update_bit(num, i, 1) # Returns: 29 (Binary: 11101) ``` Requirements: Ensure your implementation efficiently manipulates the bits using basic bitwise operations.","solution":"def get_bit(num: int, i: int) -> bool: Returns True if the bit at index i in num is 1, otherwise returns False. return (num & (1 << i)) != 0 def set_bit(num: int, i: int) -> int: Sets the bit at index i in num to 1 and returns the new integer. return num | (1 << i) def clear_bit(num: int, i: int) -> int: Clears the bit at index i in num to 0 and returns the new integer. return num & ~(1 << i) def update_bit(num: int, i: int, bit: bool) -> int: Updates the bit at index i in num to the value of bit (either 0 or 1) and returns the new integer. clear_mask = ~(1 << i) num = num & clear_mask if bit: return num | (1 << i) else: return num"},{"question":"# Scenario: Office Furniture Sorting An office supplies store needs to sort a catalog of furniture items based on their prices. The prices are stored in an array, and your task is to implement a sorting function using Gnome Sort to sort the prices in ascending order. Given an array of integers representing the prices of the furniture items, write a function `sort_prices` using the Gnome Sort algorithm to sort the array. # Function Signature ```python def sort_prices(prices: List[int]) -> List[int]: pass ``` Input * `prices` (List[int]): A list of integers representing the prices of items. Output * `List[int]`: A list of integers representing the sorted prices in ascending order. Constraints * The number of elements in `prices` will be in the range [1, 10^4]. * Each element of `prices` will be a non-negative integer less than or equal to 10^6. # Example ```python from typing import List def sort_prices(prices: List[int]) -> List[int]: n = len(prices) index = 0 while index < n: if index == 0 or prices[index] >= prices[index-1]: index = index + 1 else: prices[index], prices[index-1] = prices[index-1], prices[index] index = index - 1 return prices # Example usage: # Input: [34, 2, 78, 1, 56] # Output: [1, 2, 34, 56, 78] print(sort_prices([34, 2, 78, 1, 56])) ``` The example function should sort the given list `[34, 2, 78, 1, 56]` to `[1, 2, 34, 56, 78]`. # Performance Expectations The solution should be efficient enough to handle the upper limits of the input size within a reasonable amount of time.","solution":"from typing import List def sort_prices(prices: List[int]) -> List[int]: n = len(prices) index = 0 while index < n: if index == 0 or prices[index] >= prices[index - 1]: index += 1 else: prices[index], prices[index - 1] = prices[index - 1], prices[index] index -= 1 return prices # Example usage: # Input: [34, 2, 78, 1, 56] # Output: [1, 2, 34, 56, 78] print(sort_prices([34, 2, 78, 1, 56]))"},{"question":"Scenario A DNA analysis software needs an efficient way to find all occurrences of a specific DNA sequence (pattern) within a larger DNA strand (text). You are asked to implement this functionality using the Knuth-Morris-Pratt algorithm. Task Write a function `find_dna_sequence` which determines all start indices where the pattern exists in the text. Function Signature ```python def find_dna_sequence(text: str, pattern: str) -> List[int]: ``` Input * `text` (str): A non-empty string that represents the larger DNA strand. * `pattern` (str): A non-empty string that represents the DNA sequence to be found in the larger DNA strand. Output * Returns a list of integers representing the starting indices of each occurrence of the pattern within the text. Constraints * The text and pattern will only contain characters \'A\', \'C\', \'G\', \'T\'. * Length of the text `N` will be from 1 to 10^5. * Length of the pattern `M` will be from 1 to 10^3. Example ```python text = \\"ACGTACGTGACG\\" pattern = \\"ACGT\\" find_dna_sequence(text, pattern) ``` Expected Output: ```[0, 4]``` *Explanation*: The pattern \\"ACGT\\" appears at indices 0 and 4 in the text. Note * The implemented solution should be efficient and able to handle large texts and patterns within the constraint limits. * Consider edge cases such as very short or repeated patterns.","solution":"from typing import List def find_dna_sequence(text: str, pattern: str) -> List[int]: Finds all occurrences of the pattern in the text using the Knuth-Morris-Pratt (KMP) algorithm. Args: text (str): The larger DNA strand. pattern (str): The DNA sequence to find. Returns: List[int]: A list of starting indices where pattern is found in text. def compute_lps(pattern: str) -> List[int]: Computes the Longest Prefix Suffix (LPS) array used in the KMP algorithm. Args: pattern (str): The pattern for which to compute the LPS array. Returns: List[int]: The LPS array. lps = [0] * len(pattern) length = 0 # length of the previous longest prefix suffix i = 1 while i < len(pattern): if pattern[i] == pattern[length]: length += 1 lps[i] = length i += 1 else: if length != 0: length = lps[length - 1] else: lps[i] = 0 i += 1 return lps if not text or not pattern: return [] # Precompute the LPS array lps = compute_lps(pattern) occurrences = [] i = 0 # index for text j = 0 # index for pattern while i < len(text): if pattern[j] == text[i]: i += 1 j += 1 if j == len(pattern): occurrences.append(i - j) j = lps[j - 1] elif i < len(text) and pattern[j] != text[i]: if j != 0: j = lps[j - 1] else: i += 1 return occurrences"},{"question":"Context You are tasked with implementing a more efficient variant of the Insertion Sort algorithm to handle larger datasets. You will modify the traditional Insertion Sort to use binary search to locate the position where the current element should be inserted. Task Write a function `binary_injection_sort(arr)` that sorts an array using an optimized Insertion Sort algorithm. In this modified version, use binary search to find the appropriate position for inserting the current element, reducing the number of comparisons. Input * A list of integers `arr` (1 ≤ len(arr) ≤ 10^3). Output * The list should be sorted in ascending order. Constraints * You should maintain the in-place sorting characteristic (space complexity O(1)). * You cannot use any built-in sort functions. * The array can contain duplicate elements. * Performance should not exceed O(n^2) comparisons wherever possible. Example ```python def binary_injection_sort(arr: List[int]) -> List[int]: # Your code here # Example usage: arr = [4, 2, 8, 5, 7] print(binary_injection_sort(arr)) # Output: [2, 4, 5, 7, 8] ``` Hints * Consider implementing a helper function for binary search to find the correct insertion point. * Ensure that elements are shifted correctly after finding the insertion point.","solution":"def binary_search(arr, val, start, end): while start < end: mid = (start + end) // 2 if arr[mid] < val: start = mid + 1 else: end = mid return start def binary_injection_sort(arr): for i in range(1, len(arr)): val = arr[i] pos = binary_search(arr, val, 0, i) arr = arr[:pos] + [val] + arr[pos:i] + arr[i+1:] return arr"},{"question":"# Question You are given a singly linked list and an integer `k`. Your task is to rotate the list to the right by `k` places. Function signature: ```python def rotate_right(head, k): :type head: ListNode :type k: int :rtype: ListNode ``` Input: * `head`: The head node of the singly linked list. It can be `None` which signifies an empty list. * `k`: A non-negative integer representing the number of places to rotate the list. Output: * Return the head node of the rotated list. Constraints: * `0 <= k <= 2 * 10^5` * The total number of nodes in the list will be between `0` and `500`. Example: * Given `head = [1, 2, 3, 4, 5]` and `k = 2`, the function should return the list `[4, 5, 1, 2, 3]`. * Given `head = [0, 1, 2]` and `k = 4`, the function should return the list `[2, 0, 1]`. Notes: * Ensure that your solution handles all edge cases efficiently. * Consider the situation when `k` is greater than the length of the list. # Problem Context Imagine a situation where you have a circular train track with several carriages. Sometimes, carriages need to be rotated to the right by a certain number of positions. For instance, to facilitate maintenance or loading. Similarly, you have to rotate the linked list nodes efficiently. Implement the `rotate_right` function to solve this problem.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def rotate_right(head, k): Rotates the linked list to the right by k places. if not head or not head.next or k == 0: return head # First, determine the length of the list length = 1 tail = head while tail.next: tail = tail.next length += 1 # Find the effective rotations needed k %= length if k == 0: return head # To get new head, we need to find the (length - k)th node new_tail = head for _ in range(length - k - 1): new_tail = new_tail.next new_head = new_tail.next new_tail.next = None tail.next = head return new_head"},{"question":"# Red-Black Tree Implementation and Validation You have studied the principles and operations of Red-Black trees. Your task is to implement a balanced tree with the properties ensuring the self-balancing after each insertion. **Input and Output Requirements**: 1. Implement a `RBTree` class with methods for insertion and in-order traversal. 2. Ensure that each node insertion keeps the red-black properties intact. 3. Provide an in-order traversal method to verify the tree\'s structure. 4. Include a method to validate the red-black properties of the tree. **Constraints**: - Nodes have integer values. - Valid operations: insert, in-order traversal. - No duplicate insertions. # Implement the following methods: 1. **insert(self, val: int) -> None**: - Inserts a value into the Red-Black tree such that the tree remains balanced. 2. **inorder(self) -> List[Dict[str, int]]**: - Returns an in-order traversal list of dictionaries with the format {\\"val\\": int_value, \\"color\\": int_color}, where `color` is `0` for black and `1` for red. 3. **is_valid_red_black_tree(self) -> bool**: - Checks if the Red-Black tree adheres to all the required properties: 1. Root node must be black. 2. Red nodes cannot have red children. 3. Every path from a node to null leaves must have the same number of black nodes. **Example**: ```python rb = RBTree() values = [11, 2, 14, 1, 7, 15, 5, 8, 4] for value in values: rb.insert(value) print(rb.inorder()) assert rb.is_valid_red_black_tree() == True ``` Given the insertions, your in-order traversal, and the validity check should confirm a balanced Red-Black tree.","solution":"class Node: def __init__(self, val, color=0): self.val = val self.color = color # 0 for black, 1 for red self.left = None self.right = None self.parent = None class RBTree: def __init__(self): self.TNULL = Node(0) self.TNULL.color = 0 self.root = self.TNULL def insert(self, key): node = Node(key) node.parent = None node.val = key node.left = self.TNULL node.right = self.TNULL node.color = 1 # New node must be red y = None x = self.root while x != self.TNULL: y = x if node.val < x.val: x = x.left else: x = x.right node.parent = y if y is None: self.root = node elif node.val < y.val: y.left = node else: y.right = node if node.parent is None: node.color = 0 return if node.parent.parent is None: return self.fix_insert(node) def inorder(self): res = [] self._inorder_helper(self.root, res) return res def _inorder_helper(self, node, res): if node != self.TNULL: self._inorder_helper(node.left, res) res.append({\\"val\\": node.val, \\"color\\": node.color}) self._inorder_helper(node.right, res) def is_valid_red_black_tree(self): if self.root.color != 0: return False return self.is_bst() and self.is_balanced() def is_bst(self): res = self.inorder() return all(res[i][\\"val\\"] < res[i + 1][\\"val\\"] for i in range(len(res) - 1)) def is_balanced(self): def count_black_nodes(path): return sum(1 for node in path if node.color == 0) def _is_balanced(node, black_count, path_black_count): if node == self.TNULL: if path_black_count is None: path_black_count = black_count return path_black_count == black_count if node.color == 0: black_count += 1 if node.color == 1: if node.left.color == 1 or node.right.color == 1: return False return _is_balanced(node.left, black_count, path_black_count) and _is_balanced(node.right, black_count, path_black_count) return _is_balanced(self.root, 0, None) def fix_insert(self, k): while k.parent.color == 1: if k.parent == k.parent.parent.right: u = k.parent.parent.left if u.color == 1: u.color = 0 k.parent.color = 0 k.parent.parent.color = 1 k = k.parent.parent else: if k == k.parent.left: k = k.parent self.right_rotate(k) k.parent.color = 0 k.parent.parent.color = 1 self.left_rotate(k.parent.parent) else: u = k.parent.parent.right if u.color == 1: u.color = 0 k.parent.color = 0 k.parent.parent.color = 1 k = k.parent.parent else: if k == k.parent.right: k = k.parent self.left_rotate(k) k.parent.color = 0 k.parent.parent.color = 1 self.right_rotate(k.parent.parent) if k == self.root: break self.root.color = 0 def left_rotate(self, x): y = x.right x.right = y.left if y.left != self.TNULL: y.left.parent = x y.parent = x.parent if x.parent is None: self.root = y elif x == x.parent.left: x.parent.left = y else: x.parent.right = y y.left = x x.parent = y def right_rotate(self, x): y = x.left x.left = y.right if y.right != self.TNULL: y.right.parent = x y.parent = x.parent if x.parent is None: self.root = y elif x == x.parent.right: x.parent.right = y else: x.parent.left = y y.right = x x.parent = y"},{"question":"# Profound Sudoku Solver In this coding assignment, you are required to create a Python class that solves a given Sudoku puzzle using backtracking and depth-first search. The algorithm should leverage constraint propagation by considering the cell with the fewest possible numbers to place next. Objective Implement a class `SudokuSolver` with methods to: 1. Initialize with a Sudoku board. 2. Calculate possible values for each cell. 3. Use DFS and backtracking to solve the board. Input - A 9x9 2D list `board` where empty cells are represented as \\".\\" and filled cells with digits `\\"1\\"` to `\\"9\\"`. Output - Modify the input `board` in-place to fill in the solution. Constraints - The input board configuration will always be valid and have at least one solution. Example ```python board = [ [\\"5\\",\\"3\\",\\".\\",\\".\\",\\"7\\",\\".\\",\\".\\",\\".\\",\\".\\"], [\\"6\\",\\".\\",\\".\\",\\"1\\",\\"9\\",\\"5\\",\\".\\",\\".\\",\\".\\"], [\\".\\",\\"9\\",\\"8\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\"], [\\"8\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\"3\\"], [\\"4\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\"3\\",\\".\\",\\".\\",\\"1\\"], [\\"7\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\".\\",\\".\\",\\".\\",\\"6\\"], [\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\"8\\",\\".\\"], [\\".\\",\\".\\",\\".\\",\\"4\\",\\"1\\",\\"9\\",\\".\\",\\".\\",\\"5\\"], [\\".\\",\\".\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\".\\",\\"7\\",\\"9\\"] ] solver = SudokuSolver(board) solver.solve() print(solver) ``` Requirements - Implement the following methods: - `__init__(self, board): Initialize the class with the provided board and calculate possible values. - `def possible_values(self):` Calculate and return a dictionary of possible values for each cell. - `def solve(self):` Main method to solve the board using DFS and backtracking. - `def valid_one(self, n, kee, update):` Check and update validity of placing a number `n` in cell `kee`. - `def undo(self, kee, update):` Undo the updates for backtracking. - `def __str__(self):` String representation of the current board.","solution":"class SudokuSolver: def __init__(self, board): self.board = board self.empty = \'.\' def solve(self): empty_cells = [(r, c) for r in range(9) for c in range(9) if self.board[r][c] == self.empty] self.dfs(empty_cells) def possible_values(self, r, c): values = set(\'123456789\') for i in range(9): if self.board[r][i] in values: values.remove(self.board[r][i]) if self.board[i][c] in values: values.remove(self.board[i][c]) start_row, start_col = 3 * (r // 3), 3 * (c // 3) for i in range(start_row, start_row + 3): for j in range(start_col, start_col + 3): if self.board[i][j] in values: values.remove(self.board[i][j]) return values def dfs(self, empty_cells): if not empty_cells: return True r, c = empty_cells.pop(0) values = self.possible_values(r, c) for val in values: self.board[r][c] = val if self.dfs(empty_cells): return True self.board[r][c] = self.empty empty_cells.insert(0, (r, c)) return False def __str__(self): return \'n\'.join(\' \'.join(self.board[r][c] for c in range(9)) for r in range(9)) # Example usage: board = [ [\\"5\\",\\"3\\",\\".\\",\\".\\",\\"7\\",\\".\\",\\".\\",\\".\\",\\".\\"], [\\"6\\",\\".\\",\\".\\",\\"1\\",\\"9\\",\\"5\\",\\".\\",\\".\\",\\".\\"], [\\".\\",\\"9\\",\\"8\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\"], [\\"8\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\"3\\"], [\\"4\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\"3\\",\\".\\",\\".\\",\\"1\\"], [\\"7\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\".\\",\\".\\",\\".\\",\\"6\\"], [\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\"8\\",\\".\\"], [\\".\\",\\".\\",\\".\\",\\"4\\",\\"1\\",\\"9\\",\\".\\",\\".\\",\\"5\\"], [\\".\\",\\".\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\".\\",\\"7\\",\\"9\\"] ] solver = SudokuSolver(board) solver.solve() print(solver)"},{"question":"<|Analysis Begin|> # Algorithm/Data Structure: This algorithm implements a **Trie** (Prefix Tree) combined with **Backtracking** to solve the \\"Word Search II\\" problem, which involves finding all words from a list that exist in a given board. # Complexity: - **Time Complexity**: O(M * (4 * 3^L)), where M is the number of cells in the board, and L is the length of the longest word. This includes generating all possible paths through backtracking and checking each path against the Trie. - **Space Complexity**: O(N), where N is the total number of letters in the Trie, which correlates to all the words in the list collectively. # Principles: 1. **Trie Construction**: A Trie is built from the list of words to facilitate efficient prefix checking. 2. **Backtracking**: For each starting cell in the board, the algorithm explores all possible words using DFS, while marking cells as visited to avoid reusing them in the current path. # Characteristics & Applications: - **Properties**: - Supports efficient search operations with prefix matching. - Ensures no repeated words are found due to the set collection. - **Common Use Cases**: - Word search problems. - Auto-complete features in text editors. - **Strengths**: - Efficient prefix checking due to Trie usage. - Reduces redundant computations by backtracking and marking cells. - **Limitations**: - High memory usage for large boards or dictionaries. - Potential performance issues for highly dense boards. # Implementation Challenges: - **Edge Cases**: - Empty board or word list should return an empty result. - Words that partially match but are not fully constructible from the board. - **Performance Bottlenecks**: - Excessive recursion depths may lead to stack overflow for very large boards. - Non-recognition of overlapping paths without proper visited tracking. - **Error Scenarios**: - Invalid board setup (e.g., non-rectangular). - Words composed of characters not present in the board. - **Optimization Points**: - Prune search paths early when encountering characters not present in the Trie from the current path. - Optimize memory usage by reusing the used matrix across function calls. <|Analysis End|> <|Question Begin|> # Problem Description You are given a 2D board containing characters and a list of words. Your task is to write a function `find_words_in_board(board, words)` which returns a list of words from the given list that can be formed in the board. The words must be constructed from letters of sequentially adjacent cells (horizontally or vertically neighboring). Each cell can only be used once per word. # Function Signature ```python def find_words_in_board(board: List[List[str]], words: List[str]) -> List[str]: pass ``` # Input - `board`: A list of lists of characters (2D grid). - `1 <= len(board), len(board[0]) <= 12` - Each element of `board` is a single lowercase English letter. - `words`: A list of strings. - `1 <= len(words) <= 1000` - `1 <= len(words[i]) <= 10` - Each string in the list `words` is a single lowercase English word. # Output - Returns a list of strings representing all words found in the board. # Constraints - Words may be found diagonally, horizontally, or vertically adjacent but not reused. # Example ```python board = [ [\'o\',\'a\',\'a\',\'n\'], [\'e\',\'t\',\'a\',\'e\'], [\'i\',\'h\',\'k\',\'r\'], [\'i\',\'f\',\'l\',\'v\'] ] words = [\\"oath\\", \\"pea\\", \\"eat\\", \\"rain\\"] assert find_words_in_board(board, words) == [\\"oath\\", \\"eat\\"] ``` # Detailed Requirements - Ensure the algorithm efficiently checks for words using a combination of Trie structure and backtracking. - Handle edge cases such as empty word lists or boards without valid paths. - Avoid excessive memory use and performance bottlenecks by optimizing the search path pruning and visited cell tracking. # Context Imagine you are developing a feature for a word puzzle game. Users are presented with a board of letters and a list of target words. This function will help validate if the words can be formed, ensuring the game\'s word search functionality operates correctly.","solution":"class TrieNode: def __init__(self): self.children = {} self.word = None def build_trie(words): root = TrieNode() for word in words: node = root for letter in word: if letter not in node.children: node.children[letter] = TrieNode() node = node.children[letter] node.word = word return root def find_words_in_board(board, words): def dfs(node, x, y): letter = board[y][x] current_node = node.children.get(letter) if current_node is None: return if current_node.word is not None: result.add(current_node.word) current_node.word = None # Avoid duplicate entries board[y][x] = \'#\' # Mark the board position as visited for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < len(board[0]) and 0 <= ny < len(board): dfs(current_node, nx, ny) board[y][x] = letter # Restore the board position result = set() trie = build_trie(words) for y in range(len(board)): for x in range(len(board[0])): dfs(trie, x, y) return list(result)"},{"question":"Implement a function to find the single integer in an array where every element appears exactly three times, except for one which appears exactly once. Your implementation should achieve this in linear time complexity and without using extra memory space. # Function Signature ```python def find_single_number(arr: List[int]) -> int: ``` # Input * `arr`: A list of integers where every integer appears exactly three times except for one unique integer. # Output * Returns the unique integer that exists only once in the array. # Constraints * You must not use extra memory like a list or a set to solve this. * Expected time complexity: O(n) * Expected space complexity: O(1) # Example ```python assert find_single_number([2, 2, 3, 2]) == 3 assert find_single_number([0, 1, 0, 1, 0, 1, 99]) == 99 assert find_single_number([-2, -2, 1, -2]) == 1 ``` # Clarifications * An empty list should return None. * The list will always contain at least one unique number and exactly two duplicates for each duplicate element. * The input can contain negative numbers and zero. Write the function `find_single_number` based on the above specifications and submit your implementation.","solution":"from typing import List def find_single_number(arr: List[int]) -> int: Finds the single integer in an array where every element appears exactly three times, except for one which appears exactly once. Args: arr (List[int]): The input list of integers. Returns: int: The single integer that appears exactly once in the array. if not arr: return None ones, twos = 0, 0 for number in arr: # `ones` keeps track of bits which have appeared 1st time # `twos` keeps track of bits which have appeared 2nd time # and are not present in `ones` # Add this number to `twos` if it is in `ones` twos = twos | (ones & number) # This number is added to `ones` ones = ones ^ number # common_bit_mask contains all the bits appearing three times common_bit_mask = ~(ones & twos) # Remove common bits (appearing 3 times) from `ones` and `twos` ones &= common_bit_mask twos &= common_bit_mask return ones"},{"question":"# Scenario You are tasked with developing a computational feature for a high-performance scientific application that requires calculating large power values effectively. Long sequences of multiplications for such operations would be computationally expensive and impractical due to time constraints and potential for overflow. Your mission is to implement a function that calculates the power of a number using an efficient algorithm. # Problem Statement Implement an efficient function to compute the power of a given base raised to a specified integer exponent. Your solution must handle large exponents and provide an option for modular exponentiation to avoid overflow. # Function Signature ```python def efficient_power(base: int, exponent: int, mod: int = None) -> int: pass ``` # Specifications 1. **Input**: - `base` (int): the base number which is an integer. (1 <= |base| <= 10^9) - `exponent` (int): the exponent which is an integer. (0 <= exponent <= 10^9) - `mod` (int): an optional modulus (None <= mod <= 10^9) Note: If `mod` is not provided, return the standard result of base^exponent. 2. **Output**: - Return an integer which is the result of base raised to the power of exponent. If mod is provided, return the result modulo mod. 3. **Constraints**: - Optimize for time complexity. - Ensure minimal memory footprint. - Handle edge cases as specified in the analysis above. # Requirements & Performance - The solution should efficiently handle very large values for base and exponent. - Time Complexity: O(log(n)) - Space Complexity: O(1) for iterative, O(log(n)) for recursive implementation. Example Input/Output: ```python # Example 1 efficient_power(2, 10) # Should return 1024 # Example 2 efficient_power(2, 10, 1000) # Should return 24 (since 2^10 % 1000 = 1024 % 1000 = 24) # Example 3 efficient_power(12345, 0) # Should return 1 (by definition, any number raised to the power of 0 is 1) ```","solution":"def efficient_power(base: int, exponent: int, mod: int = None) -> int: This function computes the power of a given base raised to a specified integer exponent using exponentiation by squaring, which is efficient for large exponents. It optionally performs modular exponentiation to avoid overflow. :param base: Integer base (1 <= |base| <= 10^9) :param exponent: Integer exponent (0 <= exponent <= 10^9) :param mod: Optional modulus (None <= mod <= 10^9) :return: Result of base^exponent or (base^exponent) % mod if mod is provided result = 1 base = base % mod if mod else base while exponent > 0: if exponent % 2 == 1: # If exponent is odd result = (result * base) % mod if mod else result * base exponent = exponent >> 1 # Divide exponent by 2 base = (base * base) % mod if mod else base * base return result"},{"question":"# Binary Heap Implementation and Testing Problem Statement You are tasked with implementing a Min Heap using the given class structure. Your implementation should focus on ensuring that the heap properties (complete binary tree, each node smaller than its children) are maintained after any modification. Implement the following methods in the `BinaryHeap` class to ensure the min-heap properties: 1. `insert(val: int)`: Inserts an integer `val` into the heap. 2. `remove_min() -> int`: Removes and returns the minimum element from the heap. Method Descriptions 1. **Insert**: - Inserts the element at the end of the heap. - Percolates the value up to ensure the min-heap property is maintained. 2. **Remove Min**: - Removes the root element (the minimum element). - Replaces it with the last element in the heap. - Percolates the value down to restore the min-heap property. Input and Output 1. `insert(val: int)`: No return value. 2. `remove_min() -> int`: Returns the minimum element which is removed from the heap. Constraints - `1 <= val <= 10^6` - Assume a reasonable maximum number of elements in the heap (up to 10^5). Example Scenario ```python # Create a BinaryHeap object min_heap = BinaryHeap() # Insert elements min_heap.insert(7) min_heap.insert(3) min_heap.insert(5) # The heap should rearrange to maintain the property # Expected heap array (considering internal array representation): [0, 3, 7, 5] # Remove the minimum element (which is 3) assert min_heap.remove_min() == 3 # The new heap after removal and reheapifying # Expected heap array: [0, 5, 7] ``` Task Complete the `BinaryHeap` class by implementing the `insert()` and `remove_min()` methods.","solution":"class BinaryHeap: def __init__(self): self.heap = [0] # Start with a dummy element at index 0 def insert(self, val: int): Insert an integer into the heap. self.heap.append(val) self._percolate_up(len(self.heap) - 1) def remove_min(self) -> int: Remove the minimum element from the heap and return it. if len(self.heap) == 1: raise IndexError(\\"remove_min() called on empty heap\\") if len(self.heap) == 2: return self.heap.pop() root = self.heap[1] self.heap[1] = self.heap.pop() self._percolate_down(1) return root def _percolate_up(self, index): Percolate the value at the given index up to maintain heap property. while index // 2 > 0: parent = index // 2 if self.heap[index] < self.heap[parent]: self.heap[index], self.heap[parent] = self.heap[parent], self.heap[index] index = parent def _percolate_down(self, index): Percolate the value at the given index down to maintain heap property. while (index * 2) < len(self.heap): min_child_index = self._min_child(index) if self.heap[index] > self.heap[min_child_index]: self.heap[index], self.heap[min_child_index] = self.heap[min_child_index], self.heap[index] index = min_child_index def _min_child(self, index): Return the index of the smaller child. if (index * 2 + 1) >= len(self.heap): return index * 2 else: if self.heap[index * 2] < self.heap[index * 2 + 1]: return index * 2 else: return index * 2 + 1"},{"question":"You are given three functions: `find_order`, `euler_totient`, and `find_primitive_root`, which are used to determine the primitive roots of a given integer `n` based on advanced number theory concepts. **Objectives**: 1. Implement the `find_order` function, which finds the smallest positive integer `k` such that `a^k % n == 1`. 2. Implement the `euler_totient` function to compute Euler\'s Totient function `φ(n)`, which counts integers up to `n` that are coprime with `n`. 3. Implement the `find_primitive_root` function that identifies the primitive roots of `n`. # Tasks 1. **find_order(a, n)**: - Input: Two integers, `a` and `n`. - Output: Smallest positive integer `k` such that `a^k % n == 1`, or `-1` if no such integer exists. 2. **euler_totient(n)**: - Input: An integer `n`. - Output: Number of integers up to `n` that are coprime with `n`. 3. **find_primitive_root(n)**: - Input: An integer `n`. - Output: List of integers that are primitive roots of `n`. # Constraints 1. `1 <= a, n <= 10^6` 2. For `find_order`, ensure that gcd(a, n) = 1. # Performance Requirements 1. Aim for efficient implementations to handle inputs up to the maximum constraint effectively. 2. Consider optimizations to minimize redundant calculations in all three functions. # Example ```python print(find_order(10, 7)) # Output: 6 print(euler_totient(9)) # Output: 6 print(find_primitive_root(13)) # Output: [2, 6, 7, 11] ``` # Explanation 1. For `find_order` with inputs `(10, 7)`: - We find the smallest `k` such that `10^k % 7 == 1`, which is `6`. 2. For `euler_totient` with input `9`: - The integers less than 9 that are coprime with 9 are `1, 2, 4, 5, 7, 8`, resulting in count `6`. 3. For `find_primitive_root` with input `13`: - Primitive roots of 13 are `2, 6, 7, 11`.","solution":"import math from functools import reduce from sympy import gcd def find_order(a, n): Returns the smallest positive integer k such that a^k % n == 1, or -1 if no such integer exists. if gcd(a, n) != 1: return -1 k = 1 ak = a % n while ak != 1: ak = (ak * a) % n k += 1 if k > n: # safety check to avoid infinite loops return -1 return k def euler_totient(n): Computes Euler\'s Totient function φ(n), which counts integers up to n that are coprime with n. result = n p = 2 while p * p <= n: if n % p == 0: while n % p == 0: n //= p result -= result // p p += 1 if n > 1: result -= result // n return result def find_primitive_root(n): Returns a list of primitive roots of n. if n <= 1: return [] phi = euler_totient(n) factors = prime_factors(phi) primitive_roots = [] for r in range(2, n): if all(pow(r, phi // factor, n) != 1 for factor in factors): primitive_roots.append(r) return primitive_roots def prime_factors(n): Computes the prime factors of the given number n. factors = set() while n % 2 == 0: factors.add(2) n //= 2 for i in range(3, int(math.sqrt(n)) + 1, 2): while n % i == 0: factors.add(i) n //= i if n > 2: factors.add(n) return factors"},{"question":"# Question: Longest Increasing Subsequence with Multiple Implementations You are given an unsorted array of integers. Your task is to implement a function that finds the length of the longest increasing subsequence (LIS). Write a function `find_LIS_length(sequence: List[int]) -> int` that accomplishes this task. Your implementation should: 1. Include at least two approaches: - A straightforward dynamic programming solution with O(n^2) time complexity. - An optimized approach leveraging segment trees to achieve better performance. Input Format - A list of integers `sequence` where 1 <= len(sequence) <= 10^5 and -10^5 <= sequence[i] <= 10^5. Output Format - An integer representing the length of the longest increasing subsequence in the given list. Constraints - Ensure your function is efficient enough to handle the upper limits of the input constraints. - Handle edge cases such as an empty array or arrays with repeated elements. Example ```python # Example 1 input_sequence = [10, 9, 2, 5, 3, 7, 101, 18] # Longest increasing subsequence: [2, 3, 7, 101] output = 4 # Example 2 input_sequence = [0, 1, 0, 3, 2, 3] # Longest increasing subsequence: [0, 1, 2, 3] output = 4 # Example 3 input_sequence = [] # Longest increasing subsequence: [] output = 0 # Example 4 input_sequence = [7, 7, 7, 7, 7, 7, 7] # Longest increasing subsequence: [7] output = 1 ``` Performance Requirements - For the naive approach, the time complexity should be O(n^2). - For the optimized approach, the time complexity should be O(n log n). Implement the function `find_LIS_length` according to the specified requirements and examples.","solution":"from typing import List import bisect def find_LIS_length_dp(sequence: List[int]) -> int: Returns the length of the longest increasing subsequence using dynamic programming. Time complexity: O(n^2) if not sequence: return 0 n = len(sequence) lis = [1] * n for i in range(1, n): for j in range(i): if sequence[i] > sequence[j]: lis[i] = max(lis[i], lis[j] + 1) return max(lis) def find_LIS_length_optimized(sequence: List[int]) -> int: Returns the length of the longest increasing subsequence using a more optimized method. Time complexity: O(n log n) if not sequence: return 0 tail = [] for num in sequence: index = bisect.bisect_left(tail, num) if index == len(tail): tail.append(num) else: tail[index] = num return len(tail) def find_LIS_length(sequence: List[int]) -> int: Returns the length of the longest increasing subsequence. Uses the optimized method with O(n log n) time complexity. return find_LIS_length_optimized(sequence)"},{"question":"Given an integer `N`, write a function `find_min_perfect_squares(N)` that finds the minimum number of perfect squares whose sum equals N, where a perfect square is defined as k^2 for some integer k. The function should return an integer between 1 and 4 as guaranteed by Lagrange\'s four-square theorem. # Input - A single integer `N` (1 <= N <= 10^5). # Output - A single integer representing the minimum number of perfect squares that sum up to `N`. # Constraints - Your solution should be efficient, ideally with a time complexity of O(sqrt(N)). - Handle all edge cases appropriately. # Examples 1. **Example 1**: - Input: 9 - Output: 1 - Explanation: 9 = 3^2. 2. **Example 2**: - Input: 10 - Output: 2 - Explanation: 10 = 3^2 + 1^2. 3. **Example 3**: - Input: 12 - Output: 3 - Explanation: 12 = 2^2 + 2^2 + 2^2. 4. **Example 4**: - Input: 31 - Output: 4 - Explanation: 31 = 5^2 + 2^2 + 1^2 + 1^2. # Constraints - 1 <= N <= 10^5 # Notes Ensure that your function handles edge cases such as small numbers, exactly perfect squares, large numbers and numbers in the form of 4^a(8b + 7). Your input will always be a positive integer, so there\'s no need to validate that.","solution":"import math def is_square(n): sq = int(math.sqrt(n)) return sq * sq == n def find_min_perfect_squares(n): Returns the minimum number of perfect squares whose sum equals n. # Check if n is a perfect square if is_square(n): return 1 # Check if n can be decomposed into the sum of two perfect squares for i in range(1, int(math.sqrt(n)) + 1): if is_square(n - i * i): return 2 # Check if n can be decomposed into the sum of three perfect squares while n % 4 == 0: n //= 4 if n % 8 == 7: return 4 return 3"},{"question":"The city hall needs an efficient way to manage updates and queries on daily population changes for different districts. They have data for daily population counts for `n` districts, and they need a system that can quickly update the population count for a specific district and also quickly compute the total population for the first `i` districts for any given day. Implement a solution using a Fenwick Tree (Binary Indexed Tree). # Your Task: Implement the `FenwickTree` class with the following methods: 1. **`__init__(self, population: List[int]) -> None`**: Initializes the Fenwick Tree with the daily population data `population`. 2. **`update_population(self, district: int, new_population: int) -> None`**: Updates the population of the `district` to `new_population`. 3. **`total_population(self, upto_district: int) -> int`**: Returns the total population count from district 0 to `upto_district`. # Function Signatures: ```python class FenwickTree: def __init__(self, population: List[int]) -> None: # Initialize your data structure here. def update_population(self, district: int, new_population: int) -> None: # Update the population of specified district. def total_population(self, upto_district: int) -> int: # Return total population from start to specified district. ``` # Input: - The class will be initiated with an array of integers `population` where each element `population[i]` represents the population count of the i-th district. - The `update_population` method will be called to update the population for a specific district. - The `total_population` method will be called to get the total population from district 0 to a specified district. # Output: - The `total_population` method should return an integer representing the total population for the queried range. # Constraints: - `1 <= n <= 10^5` (number of districts) - `0 <= district <= n-1` - `0 <= population[i], new_population <= 10^6` # Example: ```python # Example usage: population = [20, 30, 40, 50, 60] ft = FenwickTree(population) # Query total population from district 0 to 2 print(ft.total_population(2)) # Output: 90 # Update population of district 1 to 35 ft.update_population(1, 35) # Query total population from district 0 to 2 again print(ft.total_population(2)) # Output: 95 ``` # Explanation: - Initially, the total population from district 0 to 2 is 20 + 30 + 40 = 90. - After updating the population of district 1 to 35, the new total population from district 0 to 2 is 20 + 35 + 40 = 95.","solution":"class FenwickTree: def __init__(self, population): Initializes the Fenwick Tree with the daily population data `population`. self.n = len(population) self.tree = [0] * (self.n + 1) self.population = [0] * self.n for i, value in enumerate(population): self.update_population(i, value) def update_population(self, district, new_population): Updates the population of the `district` to `new_population`. # Find the delta to update the difference in population delta = new_population - self.population[district] self.population[district] = new_population index = district + 1 while index <= self.n: self.tree[index] += delta index += index & -index def total_population(self, upto_district): Returns the total population count from district 0 to `upto_district`. index = upto_district + 1 result = 0 while index > 0: result += self.tree[index] index -= index & -index return result"},{"question":"# Question: Implementing and Enhancing Insertion Sort Objective As an advanced exercise, you are required to implement the Insertion Sort algorithm. Additionally, you should modify the algorithm to count and return the number of swaps performed during the sorting process. Problem Statement Create a function `insertion_sort_count_swaps(arr)` that sorts a list of integers in ascending order using the Insertion Sort algorithm and counts the number of swaps performed. Function Signature ```python def insertion_sort_count_swaps(arr: List[int]) -> Tuple[List[int], int]: pass ``` Input * `arr`: A list of integers, where `1 <= len(arr) <= 10^4` and `-10^6 <= arr[i] <= 10^6`. Output * A tuple containing: 1. The sorted list of integers. 2. The number of swaps performed during sorting. Constraints 1. Optimize the code to handle the given range efficiently. 2. The algorithm must maintain O(n^2) worst-case time complexity. Example ```python # Example 1 input: [4, 3, 2, 1] output: ([1, 2, 3, 4], 6) # Example 2 input: [1, 2, 3, 4] output: ([1, 2, 3, 4], 0) # Example 3 input: [2, 3, 4, 1] output: ([1, 2, 3, 4], 3) ``` Notes * Ensure to handle empty lists without errors. * Edge cases such as already sorted lists or lists with identical elements should be managed correctly. * Count only the distinct swaps made between elements, not transitions through array assignments.","solution":"from typing import List, Tuple def insertion_sort_count_swaps(arr: List[int]) -> Tuple[List[int], int]: Sorts the list using the insertion sort algorithm and counts the number of swaps made. Parameters: arr (List[int]): The list of integers to be sorted. Returns: Tuple[List[int], int]: A tuple containing the sorted list and the number of swaps performed. n = len(arr) swap_count = 0 for i in range(1, n): key = arr[i] j = i - 1 while j >= 0 and arr[j] > key: arr[j + 1] = arr[j] j -= 1 swap_count += 1 arr[j + 1] = key return arr, swap_count"},{"question":"# **Bitwise Inversion Based Difference** Write a function `subtract_bitwise_operator(x, y)` that subtracts two non-negative integers `x` and `y` using bitwise operations only. Do not use the `-` operator or any other arithmetic operators directly for subtraction. # Function Signature: ```python def subtract_bitwise_operator(x: int, y: int) -> int: ``` # Input: * Two non-negative integers `x` and `y`. # Output: * A single integer, which is the difference between `x` and `y`. # Constraints: * 0 <= x, y <= 10^9 * x >= y (it is guaranteed that x will always be greater than or equal to y). # Example: ```python subtract_bitwise_operator(5, 3) # Output: 2 subtract_bitwise_operator(15, 10) # Output: 5 ``` # Explanation: * To compute the difference `x - y` using bitwise operations, consider the following approach: 1. Compute the two\'s complement of `y` (negate `y`). 2. Add the two\'s complement of `y` to `x` using the bitwise addition technique provided above.","solution":"def subtract_bitwise_operator(x: int, y: int) -> int: Subtracts two non-negative integers x and y using bitwise operations only. while y != 0: borrow = (~x) & y x = x ^ y y = borrow << 1 return x"},{"question":"# Scenario You are working on a research project involving a series of linear transformations in computer graphics. You need a reliable function that can handle matrix multiplication efficiently, as this operation is central to your project. # Task Write a function `matrix_multiply` which multiplies two compatible matrices and returns the result. # Function Signature ```python def matrix_multiply(multiplicand: list[list[int]], multiplier: list[list[int]]) -> list[list[int]]: pass ``` # Input * `multiplicand`: A two-dimensional list representing the multiplicand matrix of size m x n. * `multiplier`: A two-dimensional list representing the multiplier matrix of size n x p. # Output * Returns a two-dimensional list representing the resulting m x p matrix after multiplication. # Constraints * Each sub-list in the input lists will have the same length. * Dimensions of the input matrices will be such that they can be multiplied (i.e., the number of columns in the multiplicand matrix will always equal the number of rows in the multiplier matrix). # Requirements * Your implementation should handle large matrices efficiently. * Consider edge cases such as empty matrices or incompatible dimensions and handle them appropriately. * Aim for a solution that maintains clarity and readability. # Examples 1. `matrix_multiply([[1, 2]], [[3], [4]])` * Output: `[[11]]` 2. `matrix_multiply([[1, 2, 3], [4, 5, 6]], [[7, 8], [9, 10], [11, 12]])` * Output: `[[58, 64], [139, 154]]`","solution":"def matrix_multiply(multiplicand, multiplier): Multiplies two compatible matrices and returns the result. :param multiplicand: list of lists, where each list represents a row of the multiplicand matrix. :param multiplier: list of lists, where each list represents a row of the multiplier matrix. :return: list of lists, representing the resulting matrix after multiplication. if not multiplicand or not multiplier or not multiplicand[0] or not multiplier[0]: raise ValueError(\\"Input matrices cannot be empty.\\") # Number of rows in the multiplicand m = len(multiplicand) # Number of columns in the multiplicand (and number of rows in the multiplier) n = len(multiplicand[0]) # Number of columns in the multiplier p = len(multiplier[0]) # Initialize the resulting matrix with zeros result = [[0] * p for _ in range(m)] for i in range(m): for j in range(p): for k in range(n): result[i][j] += multiplicand[i][k] * multiplier[k][j] return result"},{"question":"**Scenario** You are a software engineer for a financial company that maintains various binary search trees representing historical financial data. A common task is to approximate a given target value for analysis based on existing data. **Task** Write a function that, given the root of a non-empty binary search tree (BST) and a target value, returns the value in the BST that is closest to the target. **Function Signature** ```python def closest_value(root, target): :type root: TreeNode :type target: float :rtype: int ``` **Constraints** * The target is a floating point (decimal) value. * The BST is guaranteed to have only one unique value closest to the target. * TreeNode is defined as follows: ```python # Definition for a binary tree node. class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None ``` **Input** * `root`: Root node of a non-empty binary search tree. * `target`: A floating point value representing the target. **Output** * Return the integer value in the BST that is closest to the target. **Examples** ```python # Example 1 # Binary Search Tree structure: # 4 # / # 2 5 # / # 1 3 root = TreeNode(4) root.left = TreeNode(2) root.right = TreeNode(5) root.left.left = TreeNode(1) root.left.right = TreeNode(3) target = 3.714286 assert closest_value(root, target) == 4 # Example 2 # Binary Search Tree structure: # 4 # / # 2 5 # / # 1 3 root = TreeNode(4) root.left = TreeNode(2) root.right = TreeNode(5) root.left.left = TreeNode(1) root.left.right = TreeNode(3) target = 3.3 assert closest_value(root, target) == 3 ``` **Notes** * Pay careful attention to the edge cases, such as when the tree consists of a single node. * Consider converting the recursive solution into an iterative one to manage space complexity better.","solution":"# Definition for a binary tree node. class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def closest_value(root, target): Returns the value in the BST that is closest to the target. :type root: TreeNode :type target: float :rtype: int closest = root.val while root: if abs(root.val - target) < abs(closest - target): closest = root.val if target < root.val: root = root.left else: root = root.right return closest"},{"question":"# Context: You are a software engineer tasked with optimizing search performance in a database system where insertions, deletions, and lookups are frequent. You decide to implement a Red-Black Tree to maintain balanced operations. # Problem: Implement a method `find_kth_smallest` in the given `RBTree` class that returns the k-th smallest element (0-indexed) in the Red-Black Tree. The method should have the following signature: ```python def find_kth_smallest(self, k: int) -> int: ``` * **Input**: * `k`: An integer representing the k-th position (0-indexed) to find. * Assumed that 0 <= k < number of nodes in the Red-Black Tree. * **Output**: * Returns the value of the k-th smallest element in the tree. * **Constraints**: * The tree can have up to 10^5 nodes. * **Performance Requirements**: * The solution should run in O(k) to O(log n + k) time complexity for efficiency. # Example: Given the Red-Black Tree: ``` 11B / 2B 14B / / 1B 7R N 15R / 5B 8B 4R ``` * `rb_tree.find_kth_smallest(3)` → 5 **Note**: You can leverage the `inorder` method provided to get the values in sorted order, but your goal is to implement it in an optimized manner without directly relying on storing all elements in a list. # Task: 1. Properly analyze the provided Red-Black Tree code to understand its workings. 2. Develop an efficient solution to find the k-th smallest element. 3. Ensure to test for various k-values including edge cases like the smallest k (k=0) and the largest k (k=n-1).","solution":"class Node: def __init__(self, key, color, left=None, right=None, parent=None): self.key = key self.color = color # \'R\' for red, \'B\' for black self.left = left self.right = right self.parent = parent self.size = 1 # size of the subtree rooted with this node class RBTree: def __init__(self): self.TNULL = Node(0, \'B\') self.root = self.TNULL def update_size(self, node): if node != self.TNULL: node.size = 1 + self.size(node.left) + self.size(node.right) def size(self, node): if node == self.TNULL: return 0 return node.size def insert(self, key): node = Node(key, \'R\', self.TNULL, self.TNULL) parent = None current = self.root while current != self.TNULL: parent = current parent.size += 1 # increment the size of the subtree rooted by parent if key < current.key: current = current.left else: current = current.right node.parent = parent if parent is None: self.root = node elif key < parent.key: parent.left = node else: parent.right = node self.fix_insert(node) self.update_size(self.root) def left_rotate(self, x): y = x.right x.right = y.left if y.left != self.TNULL: y.left.parent = x y.parent = x.parent if x.parent is None: self.root = y elif x == x.parent.left: x.parent.left = y else: x.parent.right = y y.left = x x.parent = y self.update_size(x) self.update_size(y) def right_rotate(self, x): y = x.left x.left = y.right if y.right != self.TNULL: y.right.parent = x y.parent = x.parent if x.parent is None: self.root = y elif x == x.parent.right: x.parent.right = y else: x.parent.left = y y.right = x x.parent = y self.update_size(x) self.update_size(y) def fix_insert(self, k): # fixing insert violations while k.parent and k.parent.color == \'R\': if k.parent == k.parent.parent.left: u = k.parent.parent.right if u.color == \'R\': u.color = \'B\' k.parent.color = \'B\' k.parent.parent.color = \'R\' k = k.parent.parent else: if k == k.parent.right: k = k.parent self.left_rotate(k) k.parent.color = \'B\' k.parent.parent.color = \'R\' self.right_rotate(k.parent.parent) else: u = k.parent.parent.left if u.color == \'R\': u.color = \'B\' k.parent.color = \'B\' k.parent.parent.color = \'R\' k = k.parent.parent else: if k == k.parent.left: k = k.parent self.right_rotate(k) k.parent.color = \'B\' k.parent.parent.color = \'R\' self.left_rotate(k.parent.parent) self.root.color = \'B\' def find_kth_smallest(self, k: int) -> int: def kth_smallest(node, k): if node == self.TNULL: return None left_size = self.size(node.left) if left_size == k: return node.key elif left_size > k: return kth_smallest(node.left, k) else: return kth_smallest(node.right, k - left_size - 1) return kth_smallest(self.root, k)"},{"question":"# Multiplying Large Strings Given two non-negative integers `num1` and `num2` represented as strings, write a function `multiply` to return the product of `num1` and `num2`. You should not use any built-in BigInteger library or convert the inputs to integer directly. **Function Signature**: ```python def multiply(num1: str, num2: str) -> str: pass ``` # Input * The length of both `num1` and `num2` is less than 110. * Both `num1` and `num2` contain only digits `0-9`. * Both `num1` and `num2` do not contain any leading zero. # Output * A string representing the product of `num1` and `num2`. # Constraints * You must not use any built-in BigInteger library or convert the inputs to integers directly. * Handle edge cases like multiplication with `0`. # Example ```python assert multiply(\\"123\\", \\"45\\") == \\"5535\\" assert multiply(\\"0\\", \\"0\\") == \\"0\\" assert multiply(\\"1\\", \\"23\\") == \\"23\\" assert multiply(\\"100\\", \\"10000\\") == \\"1000000\\" ``` # Explanation In the first example, multiplying 123 by 45 results in 5535. In the second example, multiplying 0 by 0 results in 0. In the third example, multiplying 1 by 23 results in 23. In the fourth example, multiplying 100 by 10000 results in 1000000. Use the manual long multiplication method. Carefully perform the positional multiplications and sum the intermediate results to get the final product.","solution":"def multiply(num1: str, num2: str) -> str: Multiplies two non-negative integers num1 and num2 represented as strings and returns their product as a string. if num1 == \'0\' or num2 == \'0\': return \'0\' len1, len2 = len(num1), len(num2) result = [0] * (len1 + len2) for i in range(len1 - 1, -1, -1): for j in range(len2 - 1, -1, -1): product = (ord(num1[i]) - ord(\'0\')) * (ord(num2[j]) - ord(\'0\')) p1, p2 = i + j, i + j + 1 summation = product + result[p2] result[p2] = summation % 10 result[p1] += summation // 10 # Skip leading zeros result_str = \'\'.join(map(str, result)).lstrip(\'0\') return result_str"},{"question":"# Coin Change Problem Context You are working on automated vending machines that need to calculate the number of ways to give change for a given input amount with multiple denominations of coins. Your task is to write a function that determines the possible number of ways to give the exact change using any combination of given coin denominations. Task Write a function `count(coins: List[int], value: int) -> int` that takes a list of integers `coins` representing the denominations of the coins available and an integer `value` representing the amount for which we need to find the change. The function should return an integer representing the number of different ways to make the change. Expected Input and Output Formats **Input**: * `coins`: List of integers [S1, S2, ..., Sm]. Each `Si` represents the value of a coin denomination (1 <= Si <= 10,000). * `value`: Integer n (0 <= value <= 10,000). **Output**: * Returns an integer representing the number of ways to make change for the given value. Example: ```python coins = [1, 2, 3] value = 4 count(coins, value) # Output: 4 coins = [2, 5, 3, 6] value = 10 count(coins, value) # Output: 5 ``` Constraints 1. All coin denominations will be different and greater than 0. 2. The available coins and the target value will be positive integers. Performance Requirements 1. The solution should run efficiently with O(n * m) time complexity and O(n) space complexity. Scenario You are responsible for ensuring that the vending machines can always calculate the number of possible ways to make the change with the given set of coins, enabling the machine to prompt user\'s options accordingly.","solution":"from typing import List def count(coins: List[int], value: int) -> int: # Create a list to store the number of ways to make change for each amount dp = [0] * (value + 1) # There is only one way to make 0 value: use no coins dp[0] = 1 # Traverse through all coins for coin in coins: # Update the dp list for values that can be made with the current coin for x in range(coin, value + 1): dp[x] += dp[x - coin] return dp[value]"},{"question":"# Task Write a function that joins multiple parts of a file path or URL into a single, normalized path. Each part should be separated by a single slash (`/`), ensuring no extra slashes between parts. This function will accept a variable number of parts. # Function Signature ```python def join_multiple_with_slash(*parts: str) -> str: pass ``` # Input - `*parts` (variadic `str` arguments): A sequence of strings representing different parts of a path. # Output - `str`: A single string representing the joined path with exactly one slash between each part. # Constraints - Each part may have leading or trailing slashes which should be normalized. - The function should handle an arbitrary number of parts. - Performance requirement: The function should perform efficiently even when up to 1000 parts are provided. # Examples ```python # Example 1 print(join_multiple_with_slash(\\"http://example.com\\", \\"path\\", \\"to\\", \\"resource\\")) # Output: \\"http://example.com/path/to/resource\\" # Example 2 print(join_multiple_with_slash(\\"/usr\\", \\"/bin\\", \\"/python3\\")) # Output: \\"/usr/bin/python3\\" # Example 3 print(join_multiple_with_slash(\\"folder\\", \\"subfolder/\\", \\"/file\\")) # Output: \\"folder/subfolder/file\\" # Example 4 print(join_multiple_with_slash(\\"\\")) # Output: \\"\\" # Example 5 print(join_multiple_with_slash(\\"base/\\", \\"/suffix\\")) # Output: \\"base/suffix\\" ``` # Explanation - **Example 1**: Each part is concatenated with a single slash between them, forming a valid URL. - **Example 2**: Multiple absolute file paths are joined with single slashes. - **Example 3**: A mix of leading and trailing slashes in parts are normalized. - **Example 4**: An empty input results in an empty output. - **Example 5**: Normalizes slashes between the given parts. # Edge Cases - Ensure that leading and trailing slashes in parts are handled correctly. - An empty string should be recognized as a valid input part.","solution":"def join_multiple_with_slash(*parts: str) -> str: Joins multiple parts of a file path or URL into a single, normalized path. Each part is separated by a single slash. if not parts: return \\"\\" return \\"/\\".join(part.strip(\\"/\\") for part in parts if part).strip(\\"/\\")"},{"question":"Scenario You are given a special class of numbers called \\"power sum numbers.\\" These numbers possess a unique property where the sum of their digits, each raised to a consecutive power starting from 1, equals the original number. For example, 89 satisfies this property because 8^1 + 9^2 = 89. Task Write a function `find_power_sum_numbers(low, high)` that returns a list of all power sum numbers within the specified range [low, high] inclusive. Input Format * `low`: An integer representing the lower bound of the range (1 ≤ `low` < `high`). * `high`: An integer representing the upper bound of the range (`high` < 10^6). Output Format * A list of integers that are power sum numbers within the given range. If there are no such numbers, return an empty list. Constraints * Both `low` and `high` are positive integers and `low` is less than `high`. Performance Requirements * The solution should handle ranges up to 10^6 efficiently within reasonable time limits for an interview setting. Example ```python assert find_power_sum_numbers(1, 10) == [1, 2, 3, 4, 5, 6, 7, 8, 9] assert find_power_sum_numbers(1, 100) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 89] assert find_power_sum_numbers(90, 150) == [135] assert find_power_sum_numbers(100, 1000) == [135, 175, 518, 598] ``` * Write your function `find_power_sum_numbers(low, high)` below:","solution":"def is_power_sum_number(n): Check if a number n is a power sum number. digits = list(map(int, str(n))) sum_of_powers = sum(d ** (i + 1) for i, d in enumerate(digits)) return sum_of_powers == n def find_power_sum_numbers(low, high): Find all power sum numbers in the range [low, high] inclusive. return [n for n in range(low, high + 1) if is_power_sum_number(n)]"},{"question":"You are given an array of integers where every element appears exactly three times except for one, which appears exactly once. Your task is to write a function that finds that single distinct element. To accomplish this, you need to ensure your solution has a linear runtime complexity and does not use extra memory beyond a constant amount. # Function Signature ```python def find_single_number(nums: List[int]) -> int: ``` # Input * `nums`: List[int] - A list of integers where each integer appears exactly three times except for one. # Output * `int` - The single integer that appears exactly once. # Constraints * You must solve the problem in linear time complexity O(n). * The algorithm should use constant extra space O(1). # Example ```python assert find_single_number([2, 2, 3, 2]) == 3 assert find_single_number([0, 1, 0, 1, 0, 1, 99]) == 99 ``` # Performance Requirements Your solution should be efficient with an expected runtime complexity of O(n) and should be implementable with a constant amount of extra space O(1). # Scenario Consider you are working with a dataset of sensor readings where each value appears exactly three times due to redundancy protocols, except for measurement errors introduced exactly once per dataset cycle. Your task is to identify these erroneous single readings efficiently. Write a function using the provided function signature to solve this problem.","solution":"from typing import List def find_single_number(nums: List[int]) -> int: This function finds the single number in a list where every element appears exactly three times except for one. The implementation uses bitwise operations to achieve this in linear time and constant space. # Initialize bit counters ones = 0 twos = 0 for num in nums: # \'twos\' will hold the bits that appear twice twos |= ones & num # \'ones\' will hold the bits that appear once ones ^= num # \'threes\' will have the bits that appear three times threes = ones & twos # If a bit has appeared three times, clear the \'ones\' and \'twos\' for this bit ones &= ~threes twos &= ~threes return ones # The result is in \'ones\', as it\'s the number that appears exactly once"},{"question":"# Question: Enhanced GCD and Trailing Zero Count You are asked to implement a new function that combines the calculation of GCD using bitwise operations and also provides the count of trailing zeros in binary representation of the inputs and the result. The function should handle edge cases such as zero inputs and optimize performance for large integers using bitwise operations. Function Specification - **Function Signature**: ```python def advanced_gcd_and_trailing_zeros(a: int, b: int) -> (int, int, int, int): ``` - **Parameters**: - `a` (int): A non-negative integer. - `b` (int): A non-negative integer. - **Returns**: - A tuple `(gcd_val, trailing_a, trailing_b, trailing_gcd)` containing: - `gcd_val` (int): The GCD of `a` and `b`. - `trailing_a` (int): Number of trailing zeroes in binary representation of `a`. - `trailing_b` (int): Number of trailing zeroes in binary representation of `b`. - `trailing_gcd` (int): Number of trailing zeroes in binary representation of the GCD value. Constraints - Both `a` and `b` are non-negative integers (0 ≤ a, b ≤ 10^9). Example ```python # Input a = 40 b = 24 # Advanced GCD and Trailing Zeros result = advanced_gcd_and_trailing_zeros(a, b) # Output (8, 3, 3, 3) # Explanation: GCD(40, 24) is 8, with 3 trailing zeroes in 40, 3 in 24, and 3 in 8. ```","solution":"def count_trailing_zeros(n): Counts the number of trailing zeroes in the binary representation of n. if n == 0: return 0 count = 0 while (n & 1) == 0: n >>= 1 count += 1 return count def gcd(a, b): Computes the GCD of a and b using bitwise operations. if a == 0: return b if b == 0: return a # Count the number of trailing zeros in a and b shift = count_trailing_zeros(a | b) # Remove all trailing zeros a >>= count_trailing_zeros(a) while b != 0: b >>= count_trailing_zeros(b) if a > b: a, b = b, a b -= a return a << shift def advanced_gcd_and_trailing_zeros(a, b): gcd_val = gcd(a, b) trailing_a = count_trailing_zeros(a) trailing_b = count_trailing_zeros(b) trailing_gcd = count_trailing_zeros(gcd_val) return (gcd_val, trailing_a, trailing_b, trailing_gcd)"},{"question":"# Context You are designing a data processing application that requires sending lists of strings over a network. To do this efficiently, you need a way to encode these lists into a single string format and decode them back to their original form. # Task Implement two functions: 1. `encode(strs)`: Encodes a list of strings to a single string. 2. `decode(s)`: Decodes a single string back to a list of strings. # Specifications * `encode(strs: List[str]) -> str` * **Input**: A list of strings `strs` (1 ≤ len(strs), len(strs[i]) ≤ 1000). * **Output**: A single encoded string representing the list of strings. * `decode(s: str) -> List[str]` * **Input**: A single encoded string `s`. * **Output**: A list of strings decoded from the input string. # Constraints * Your solution should handle lists of various lengths, including edge cases such as an empty list or strings containing special characters like colons. * Ensure your implementation runs efficiently with respect to both time and space complexities. # Example ```python # Example 1: strs = [\\"hello\\", \\"world\\"] encoded_str = encode(strs) print(encoded_str) # expected output could be \\"5:hello5:world\\" decoded_list = decode(encoded_str) print(decoded_list) # expected output is [\\"hello\\", \\"world\\"] # Example 2: strs = [\\"3.14\\", \\":\\", \\";\\", \\"\\"] encoded_str = encode(strs) print(encoded_str) # expected output could be \\"4:3.142:::;;0:\\" decoded_list = decode(encoded_str) print(decoded_list) # expected output is [\\"3.14\\", \\":\\", \\";;\\", \\"\\"] ``` In this problem, you will implement functions that demonstrate encoding and decoding of strings, which verify your comprehension of working with string manipulation and handling edge cases in coding algorithms.","solution":"def encode(strs): Encodes a list of strings to a single string by prefixing each string\'s length and a delimiter. encoded_str = \'\'.join(f\'{len(s)}:{s}\' for s in strs) return encoded_str def decode(s): Decodes a single string back to a list of strings by using the prefixed length information. strs = [] i = 0 while i < len(s): j = s.find(\':\', i) length = int(s[i:j]) i = j + 1 strs.append(s[i:i + length]) i += length return strs"},{"question":"Scenario You are tasked with analyzing a geographical terrain using a 2D matrix where each cell represents the height above sea level. The Pacific Ocean touches the left and top edges of the matrix, while the Atlantic Ocean touches the bottom and right edges. Water can flow from a cell to another cell that is either adjacent (up, down, left, or right) and has an equal or lower height. The goal is to identify all cells from which water can flow to both the Pacific and Atlantic oceans. Task Implement a function `pacific_atlantic(matrix)` that returns a list of coordinates where water can flow to both the Pacific and Atlantic oceans. The order of the coordinates in the list does not matter. Input * `matrix`: A 2D list of non-negative integers representing the height of each cell. (1 <= len(matrix), len(matrix[0]) <= 150) Output * A list of lists, where each inner list represents the coordinates `[i, j]` of the cells meeting the criteria. Example ```python # Input: matrix = [ [1, 2, 2, 3, 5], [3, 2, 3, 4, 4], [2, 4, 5, 3, 1], [6, 7, 1, 4, 5], [5, 1, 1, 2, 4] ] # Output: # Cells where water flows to both oceans: [[0, 4], [1, 3], [1, 4], # [2, 2], [3, 0], [3, 1], [4, 0]] ``` Constraints * The function should handle edge cases like empty matrices and matrices with minimal dimensions. * Performance should be optimized to handle matrices up to the defined size limits. To assist with your implementation and testing, you have additional guidance: * Think about how you can mark cells as reachable from each ocean. * Consider using additional data structures to keep track of visited cells and avoid revisiting. * Pay attention to the order and boundary conditions while scanning the matrix.","solution":"def pacific_atlantic(matrix): if not matrix or not matrix[0]: return [] rows, cols = len(matrix), len(matrix[0]) pacific_reachable = [[False] * cols for _ in range(rows)] atlantic_reachable = [[False] * cols for _ in range(rows)] def dfs(r, c, reachable, prev_height): # Return if out of bounds or current cell is lower than previous cell if (r < 0 or c < 0 or r >= rows or c >= cols or reachable[r][c] or matrix[r][c] < prev_height): return reachable[r][c] = True directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] for dr, dc in directions: dfs(r + dr, c + dc, reachable, matrix[r][c]) # Perform DFS for each cell adjacent to the oceans for i in range(rows): dfs(i, 0, pacific_reachable, matrix[i][0]) # Pacific Ocean (left edge) dfs(i, cols - 1, atlantic_reachable, matrix[i][cols - 1]) # Atlantic Ocean (right edge) for j in range(cols): dfs(0, j, pacific_reachable, matrix[0][j]) # Pacific Ocean (top edge) dfs(rows - 1, j, atlantic_reachable, matrix[rows - 1][j]) # Atlantic Ocean (bottom edge) result = [] # Collect cells that are reachable by both the Pacific and Atlantic oceans for r in range(rows): for c in range(cols): if pacific_reachable[r][c] and atlantic_reachable[r][c]: result.append([r, c]) return result"},{"question":"# Sorting an Array using Stooge Sort Objective Your task is to implement the Stooge Sort algorithm to sort an entire array of integers in ascending order. Function Signature ```python def stoogesort(arr: list, l: int, h: int) -> None: # Implementation here ``` Input * A list of integers (`arr`) which needs to be sorted. * Two indices, `l` and `h`, representing the starting and ending indices of the subarray to be sorted. Output * The function does not return anything. It should sort the list in place. Constraints * The input array can have up to 10,000 elements. * All integers in the array will be in the range ([-10^6, 10^6]). Performance Requirement * Due to the inefficiency of Stooge Sort, the function\'s practical applicability is limited to relatively small arrays (as the time complexity is (O(n^{2.709}))). * Use in-place sorting to ensure minimal space consumption. # Example ```python # Example usage arr = [2, 4, 5, 3, 1] stoogesort(arr, 0, len(arr) - 1) print(arr) # Output should be [1, 2, 3, 4, 5] ``` # Description The Stooge Sort algorithm sorts segments of the array and then confirms the sorting through additional recursive steps. Ensure that your implementation handles edge cases like: empty arrays, arrays with a single element, and arrays with duplicate values smoothly.","solution":"def stoogesort(arr: list, l: int, h: int) -> None: Sorts the array \'arr\' in place using the Stooge Sort algorithm from index \'l\' to \'h\'. if l >= h: return # If the element at l is greater than the element at h, swap them if arr[l] > arr[h]: arr[l], arr[h] = arr[h], arr[l] # If there are more than 2 elements in the array, apply the Stooge Sort if h - l + 1 > 2: third = (h - l + 1) // 3 stoogesort(arr, l, h - third) # Sort the first 2/3 of the array stoogesort(arr, l + third, h) # Sort the last 2/3 of the array stoogesort(arr, l, h - third) # Sort the first 2/3 again to confirm"},{"question":"# Problem: Efficient Sparse Matrix Multiplication Objective Write a function `sparse_matrix_multiply` that efficiently multiplies two sparse matrices and returns the result. The solution should optimize performance by avoiding computations with zero elements. Input 1. `A`: A 2D list representing the first sparse matrix with dimensions (M times N). 2. `B`: A 2D list representing the second sparse matrix with dimensions (N times L). Output * A 2D list representing the product matrix (C) with dimensions (M times L). Constraints * (1 leq M, N, L leq 300) * Elements of (A) and (B) are integers. Example Given the matrices: ```plaintext A = [ [1, 0, 0], [-1, 0, 3] ] B = [ [7, 0, 0], [0, 0, 0], [0, 0, 1] ] ``` The function should return: ```plaintext [ [7, 0, 0], [-7, 0, 3] ] ``` Performance Requirements * The implementation should handle the given constraints efficiently, minimizing redundant computations with zero elements. Function Signature ```python def sparse_matrix_multiply(A: List[List[int]], B: List[List[int]]) -> List[List[int]]: pass ``` Scenario You are working with large-scale sparse data in a machine learning application where you need to compute feature interactions efficiently. Given the sparsity of your feature matrices, a regular matrix multiplication is computationally expensive and infeasible. Implement an optimized solution to multiply these sparse matrices to maintain efficiency.","solution":"def sparse_matrix_multiply(A, B): Multiply two sparse matrices A and B, returning the resulting matrix. M, N = len(A), len(A[0]) N_B, L = len(B), len(B[0]) # Verify dimensions match for matrix multiplication if N != N_B: raise ValueError(\\"The number of columns in A must match the number of rows in B\\") C = [[0] * L for _ in range(M)] # Optimization: Only iterate through non-zero values of A and B non_zero_A = [] for i in range(M): for k in range(N): if A[i][k] != 0: non_zero_A.append((i, k, A[i][k])) non_zero_B = [] for k in range(N): for j in range(L): if B[k][j] != 0: non_zero_B.append((k, j, B[k][j])) # Efficiently compute the multiplication for i, k, val_A in non_zero_A: for kk, j, val_B in non_zero_B: if k == kk: C[i][j] += val_A * val_B return C # Example usage A = [ [1, 0, 0], [-1, 0, 3] ] B = [ [7, 0, 0], [0, 0, 0], [0, 0, 1] ] print(sparse_matrix_multiply(A, B)) # Output: [[7, 0, 0], [-7, 0, 3]]"},{"question":"You have been appointed to a team that is developing a geography-based application that finds points of interest closest to a user\'s location. Your task is to implement a function `k_closest(points: List[Tuple[int, int]], k: int, origin: Tuple[int, int] = (0, 0)) -> List[Tuple[int, int]]` that finds the k closest points to the origin in a 2D plane. # Input: * `points`: A list of tuples, where each tuple represents coordinates `(x, y)` of a point. * `k`: An integer, representing the number of closest points to find. * `origin`: A tuple representing the coordinates `(x, y)` from which distances are measured. By default, this is `(0, 0)`. # Output: * Returns a list of k tuples representing the k points closest to the origin. # Constraints: * `1 <= len(points) <= 10^4` * `k >= 1` and `k <= len(points)` * Points coordinates can be both positive and negative integers. # Performance Requirements: * The solution should efficiently handle large datasets (up to 10,000 points). # Example: ```python points = [(1, 2), (2, 2), (3, 3), (-1, -1), (1, -1)] k = 2 origin = (0, 0) print(k_closest(points, k, origin)) # Output: [(1, 2), (-1, -1)] or any k closest points ``` # Additional Notes: * Ensure your function is robust with edge cases, such as where there are less than k points or all points are equidistant from the origin. * You may use the distance function provided or implement your own version.","solution":"from typing import List, Tuple import heapq def k_closest(points: List[Tuple[int, int]], k: int, origin: Tuple[int, int] = (0, 0)) -> List[Tuple[int, int]]: Finds the k closest points to the origin in a 2D plane. :param points: A list of tuples representing coordinates (x, y) of points. :param k: An integer representing the number of closest points to find. :param origin: A tuple (x, y) from which distances are measured. Default is (0, 0). :return: A list of k tuples representing the k points closest to the origin. def distance(point): return (point[0] - origin[0]) ** 2 + (point[1] - origin[1]) ** 2 return heapq.nsmallest(k, points, key=distance)"},{"question":"You are tasked with implementing a regular expression matching function that supports two special characters, `.` and `*`. The `.` character matches any single character, while `*` matches zero or more occurrences of the preceding element. Your solution should determine whether the entire input string matches the given pattern. # Detailed Requirements * **Function Signature**: `bool is_match(const char *s, const char *p)` * **Input**: * `s`: A string consisting of lowercase letters. * `p`: A pattern string which includes lowercase letters, `.` and `*`. * **Output**: A boolean value indicating whether the string `s` matches the pattern `p` in its entirety. # Examples ```python assert is_match(\\"aa\\", \\"a\\") == False # \\"a\\" does not match \\"aa\\" assert is_match(\\"aa\\", \\"aa\\") == True # \\"aa\\" matches \\"aa\\" assert is_match(\\"aaa\\", \\"aa\\") == False # \\"aa\\" does not match \\"aaa\\" assert is_match(\\"aa\\", \\"a*\\") == True # \\"a*\\" matches \\"aa\\" assert is_match(\\"aa\\", \\".*\\") == True # \\".*\\" matches \\"aa\\" assert is_match(\\"ab\\", \\".*\\") == True # \\".*\\" matches \\"ab\\" assert is_match(\\"aab\\", \\"c*a*b\\") == True # \\"c*a*b\\" matches \\"aab\\" ``` # Constraints 1. The input string `s` has a maximum length of 1000 characters. 2. The input pattern `p` has a maximum length of 1000 characters. 3. The pattern will not start with the `*` character. # Performance Considerations * Ensure that your solution is optimized for time and space as much as possible. * The solution should efficiently handle edge cases like empty strings or patterns with multiple wildcards. # Task Implement the function `is_match` which determines if the input string `s` matches the entire pattern `p`.","solution":"def is_match(s, p): dp = [[False] * (len(p) + 1) for _ in range(len(s) + 1)] dp[0][0] = True for j in range(1, len(p) + 1): if p[j - 1] == \'*\': dp[0][j] = dp[0][j - 2] for i in range(1, len(s) + 1): for j in range(1, len(p) + 1): if p[j - 1] == s[i - 1] or p[j - 1] == \'.\': dp[i][j] = dp[i - 1][j - 1] elif p[j - 1] == \'*\': dp[i][j] = dp[i][j - 2] or (dp[i - 1][j] and (p[j - 2] == s[i - 1] or p[j - 2] == \'.\')) return dp[-1][-1]"},{"question":"# Question: Decode Encoded String Given a string `s` that follows the encoding rule `k[encoded_string]`, where `k` is a positive integer and `encoded_string` is a substring that should be repeated `k` times, implement a function to decode the string. # Function Signature ```python def decode_string(s: str) -> str: ``` # Input Format - `s`: A string following the encoding rule, where the encoded_string inside the square brackets is to be repeated exactly `k` times. # Output Format - A string that represents the decoded version of the input string. # Constraints - The input string `s` will always be valid and well-formed. - Digits in the string `s` will only be for repeat numbers `k` and not part of any substrings. # Examples ```python # Example 1: # Input: \\"3[a]2[bc]\\" # Output: \\"aaabcbc\\" # Example 2: # Input: \\"3[a2[c]]\\" # Output: \\"accaccacc\\" # Example 3: # Input: \\"2[abc]3[cd]ef\\" # Output: \\"abcabccdcdcdef\\" ``` # Edge Cases to Consider - Nested encodings: `3[a2[c]]` should return `accaccacc`. - Multiple segments: Ensure segments are correctly concatenated. In your implementation, make use of appropriate data structures to handle nesting and repetition efficiently. Think about how to maintain the context of nested encoded substrings using a stack and apply the decoding step-by-step as you parse through the string.","solution":"def decode_string(s: str) -> str: Decodes the given encoded string by expanding the encoded substrings. Parameters: - s (str): The encoded string, where encoding follows the pattern k[encoded_string]. Returns: - str: The decoded version of the input string. stack = [] current_num = 0 current_string = \'\' for char in s: if char.isdigit(): current_num = current_num * 10 + int(char) elif char == \'[\': stack.append((current_string, current_num)) current_string = \'\' current_num = 0 elif char == \']\': prev_string, num = stack.pop() current_string = prev_string + current_string * num else: current_string += char return current_string"},{"question":"# Sudoku Solver with Prioritized Moves You are tasked with developing a function that solves Sudoku puzzles efficiently using a backtracking algorithm with a prioritization heuristic. A Sudoku puzzle is represented by a 9x9 grid, where empty cells are represented by the character `\'.\'`. Your goal is to fill the empty cells with digits from \'1\' to \'9\' such that each row, column, and 3x3 subbox contains every digit exactly once. Input - A 9x9 list of lists containing the board\'s cells. Each cell is a string: either `\'.\'` for an empty cell or a digit `\'1\'` to `\'9\'`. Output - The same 9x9 list of lists with cells filled to solve the Sudoku puzzle. Constraints - The input board will always be a valid 9x9 grid. - There is exactly one solution to the puzzle. Performance Requirements - Your solution should efficiently handle typical Sudoku puzzles. A well-optimized backtracking approach with a least-choice-first heuristic is expected. Example ```python board = [ [\\"5\\",\\"3\\",\\".\\",\\".\\",\\"7\\",\\".\\",\\".\\",\\".\\",\\".\\"], [\\"6\\",\\".\\",\\".\\",\\"1\\",\\"9\\",\\"5\\",\\".\\",\\".\\",\\".\\"], [\\".\\",\\"9\\",\\"8\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\"], [\\"8\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\"3\\"], [\\"4\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\"3\\",\\".\\",\\".\\",\\"1\\"], [\\"7\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\".\\",\\".\\",\\".\\",\\"6\\"], [\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\"8\\",\\".\\"], [\\".\\",\\".\\",\\".\\",\\"4\\",\\"1\\",\\"9\\",\\".\\",\\".\\",\\"5\\"], [\\".\\",\\".\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\".\\",\\"7\\",\\"9\\"] ] sudoku_solver(board) # The board should be modified in-place, resulting in: [ [\\"5\\",\\"3\\",\\"4\\",\\"6\\",\\"7\\",\\"8\\",\\"9\\",\\"1\\",\\"2\\"], [\\"6\\",\\"7\\",\\"2\\",\\"1\\",\\"9\\",\\"5\\",\\"3\\",\\"4\\",\\"8\\"], [\\"1\\",\\"9\\",\\"8\\",\\"3\\",\\"4\\",\\"2\\",\\"5\\",\\"6\\",\\"7\\"], [\\"8\\",\\"5\\",\\"9\\",\\"7\\",\\"6\\",\\"1\\",\\"4\\",\\"2\\",\\"3\\"], [\\"4\\",\\"2\\",\\"6\\",\\"8\\",\\"5\\",\\"3\\",\\"7\\",\\"9\\",\\"1\\"], [\\"7\\",\\"1\\",\\"3\\",\\"9\\",\\"2\\",\\"4\\",\\"8\\",\\"5\\",\\"6\\"], [\\"9\\",\\"6\\",\\"1\\",\\"5\\",\\"3\\",\\"7\\",\\"2\\",\\"8\\",\\"4\\"], [\\"2\\",\\"8\\",\\"7\\",\\"4\\",\\"1\\",\\"9\\",\\"6\\",\\"3\\",\\"5\\"], [\\"3\\",\\"4\\",\\"5\\",\\"2\\",\\"8\\",\\"6\\",\\"1\\",\\"7\\",\\"9\\"] ] ``` Function Signature ```python def sudoku_solver(board: List[List[str]]) -> None: # Implement the function to solve the Sudoku puzzle. ``` * Implement the function `sudoku_solver` to modify the input board in-place and solve the Sudoku puzzle.","solution":"def sudoku_solver(board): Solves the given Sudoku puzzle in place. Uses backtracking algorithm with least choice first heuristic. def is_valid(board, row, col, num): # Check if num is not in the given row, column, and 3x3 sub-box box_row, box_col = 3 * (row // 3), 3 * (col // 3) for i in range(9): if board[row][i] == num or board[i][col] == num: return False if board[box_row + i // 3][box_col + i % 3] == num: return False return True def find_empty(board): # Finds an empty cell for i in range(9): for j in range(9): if board[i][j] == \'.\': return (i, j) return None def solve(board): empty_spot = find_empty(board) if not empty_spot: return True # No more empty spaces, puzzle solved row, col = empty_spot for num in map(str, range(1, 10)): # Try numbers from \'1\' to \'9\' if is_valid(board, row, col, num): board[row][col] = num if solve(board): # Recursively attempt to solve return True board[row][col] = \'.\' # Backtrack return False solve(board)"},{"question":"# Question Description You are provided with a list of IP addresses in dotted-decimal representation. Your task is to write a function to convert each IP address into its binary representation. Each segment of the IP should be represented as an 8-bit binary string separated by dots. # Function Signature ```python def convert_ip_list_to_binary(ip_list: List[str]) -> List[str]: Converts a list of IP addresses in dotted-decimal format to their respective binary representations. :param ip_list: List[str] - List of IP addresses in dotted-decimal format (e.g., \'192.168.0.1\'). :return: List[str] - List of IP addresses in binary format (e.g., \'11000000.10101000.00000000.00000001\'). ``` # Input - `ip_list`: A list of n IP addresses, each as a string in dotted-decimal format. * Each IP address is a valid IPv4 address (e.g., \\"192.168.0.1\\"). # Output - Returns a list of binary string representations of the input IP addresses. # Example ```python ip_list = [\\"255.0.0.5\\", \\"192.168.1.1\\"] convert_ip_list_to_binary(ip_list) # Output: [\'11111111.00000000.00000000.00000101\', \'11000000.10101000.00000001.00000001\'] ``` # Constraints - The function should handle up to 10^5 IP addresses. - Each IP address follows the IPv4 format and contains exactly four fields separated by dots (e.g., a.b.c.d). # Hints - Utilize helper functions to handle individual 8-bit segment conversions. - Efficiently split and concatenate strings for optimal performance. # Evaluation Criteria - **Correctness**: The output format must match the requirements. - **Efficiency**: The solution should handle a large number of IP addresses efficiently. - **Edge Cases**: Proper handling of boundary values like 0 and 255 per segment.","solution":"def convert_ip_list_to_binary(ip_list): Converts a list of IP addresses in dotted-decimal format to their respective binary representations. :param ip_list: List[str] - List of IP addresses in dotted-decimal format (e.g., \'192.168.0.1\'). :return: List[str] - List of IP addresses in binary format (e.g., \'11000000.10101000.00000000.00000001\'). def convert_segment_to_binary(segment): Convert a decimal segment to 8-bit binary string return f\'{int(segment):08b}\' def convert_ip_to_binary(ip): Convert a dotted-decimal IP to dotted-binary IP return \'.\'.join(convert_segment_to_binary(seg) for seg in ip.split(\'.\')) return [convert_ip_to_binary(ip) for ip in ip_list]"},{"question":"# Context You are working on an application that involves manipulating images represented as matrices. You need to create efficient functions for rotating and inverting these matrices. # Task Implement the following functions based on the given descriptions: 1. **rotate_clockwise(matrix)**: Rotates the input matrix 90 degrees clockwise. 2. **rotate_counterclockwise(matrix)**: Rotates the input matrix 90 degrees counterclockwise. 3. **top_left_invert(matrix)**: Transposes the matrix (interchanges rows and columns). 4. **bottom_left_invert(matrix)**: Reflects the matrix across the bottom-left to top-right diagonal. # Input - `matrix`: A 2D list of integers representing an n by m matrix. # Output - Return a new matrix that has been transformed according to the specific function description. # Constraints - 1 ≤ n, m ≤ 1000 (number of rows and columns). # Performance Requirements - Time Complexity: O(n*m) - Space Complexity: O(n*m) # Examples Example 1: ``` matrix = [ [1, 2], [3, 4] ] rotate_clockwise(matrix) should return: [ [3, 1], [4, 2] ] rotate_counterclockwise(matrix) should return: [ [2, 4], [1, 3] ] top_left_invert(matrix) should return: [ [1, 3], [2, 4] ] bottom_left_invert(matrix) should return: [ [4, 2], [3, 1] ] ``` Example 2: ``` matrix = [ [1] ] rotate_clockwise(matrix) should return: [ [1] ] rotate_counterclockwise(matrix) should return: [ [1] ] top_left_invert(matrix) should return: [ [1] ] bottom_left_invert(matrix) should return: [ [1] ] ``` Example 3: ``` matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate_clockwise(matrix) should return: [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] rotate_counterclockwise(matrix) should return: [ [3, 6, 9], [2, 5, 8], [1, 4, 7] ] top_left_invert(matrix) should return: [ [1, 4, 7], [2, 5, 8], [3, 6, 9] ] bottom_left_invert(matrix) should return: [ [9, 6, 3], [8, 5, 2], [7, 4, 1] ] ``` # Notes - Ensure that your functions handle edge cases such as single-element matrices and non-square matrices. - Aim for clarity and efficiency in your implementations.","solution":"def rotate_clockwise(matrix): Rotates the input matrix 90 degrees clockwise. n, m = len(matrix), len(matrix[0]) rotated = [[0] * n for _ in range(m)] for i in range(n): for j in range(m): rotated[j][n - 1 - i] = matrix[i][j] return rotated def rotate_counterclockwise(matrix): Rotates the input matrix 90 degrees counterclockwise. n, m = len(matrix), len(matrix[0]) rotated = [[0] * n for _ in range(m)] for i in range(n): for j in range(m): rotated[m - 1 - j][i] = matrix[i][j] return rotated def top_left_invert(matrix): Transposes the matrix (interchanges rows and columns). n, m = len(matrix), len(matrix[0]) transposed = [[0] * n for _ in range(m)] for i in range(n): for j in range(m): transposed[j][i] = matrix[i][j] return transposed def bottom_left_invert(matrix): Reflects the matrix across the bottom-left to top-right diagonal. n, m = len(matrix), len(matrix[0]) reflected = [[0] * n for _ in range(m)] for i in range(n): for j in range(m): reflected[m - 1 - j][n - 1 - i] = matrix[i][j] return reflected"},{"question":"Scenario You have been contracted by a cybersecurity firm where generating and verifying prime numbers quickly is crucial for encryption purposes. They require a function that checks whether a given integer is prime using the specified algorithm due to its balance between simplicity and performance. Task Write a function `is_prime(n: int) -> bool` that determines if an integer ( n ) is a prime number. Follow the specifications of the given algorithm closely to ensure industry standards are met. Input * An integer ( n ), where ( 1 leq n leq 10^9 ). Output * Return `True` if ( n ) is a prime number, otherwise return `False`. Constraints * Must handle worst-case scenario within ( n = 10^9 ). * Consider and account for edge cases (e.g., very small numbers, even numbers). Performance Requirements * Time complexity should not exceed ( O(sqrt{n}) ). * Space complexity should remain ( O(1) ). Additional Notes * Do not use libraries or built-in functions directly related to primality testing to encourage understanding of the underlying algorithm. # Example ```python assert is_prime(97) == True assert is_prime(100) == False assert is_prime(2) == True assert is_prime(1) == False assert is_prime(23) == True assert is_prime(25) == False ```","solution":"def is_prime(n: int) -> bool: Determines if a given integer n is a prime number. Returns True if n is prime, otherwise returns False. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True"},{"question":"# Coding Problem: BST Iterator with Extended Functionality Scenario You are working with binary search trees (BST) and need to implement an iterator that iterates over the tree in in-order traversal (\\"ascending sorted order\\"). The current implementation supports in-order traversal but needs additional functionality for real-world applications. Task Extend the `BSTIterator` class to support: 1. The ability to peek at the next element without moving the iterator forward (`peek` method). 2. Efficient space-saving strategy to minimize the memory usage beyond the required for the standard in-order traversal. Function Implementations 1. **peek**: Return the value of the next smallest element in the BST without advancing the iterator. Input - The `BSTIterator` is initialized with the root of a BST Tree, with nodes having `val`, `left`, and `right` attributes. Output - The `peek` method should return an integer representing the next smallest value without moving the traversal pointer. Constraints - The tree contains unique values. - The number of nodes in the tree is in the range [0, 10^4]. - Node values are within the range [-10^5, 10^5]. Implementation Requirements 1. Provide initialization with the root of the BST. 2. Implement `has_next` to determine if there are more nodes to visit. 3. Implement `next` to return the next node in in-order traversal. 4. Implement `peek` to return the next node\'s value without advancing the iterator.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BSTIterator: def __init__(self, root: TreeNode): self.stack = [] self._leftmost_inorder(root) def _leftmost_inorder(self, root: TreeNode): while root is not None: self.stack.append(root) root = root.left def has_next(self) -> bool: return len(self.stack) > 0 def next(self) -> int: topmost_node = self.stack.pop() if topmost_node.right is not None: self._leftmost_inorder(topmost_node.right) return topmost_node.val def peek(self) -> int: if not self.has_next(): raise StopIteration(\\"No more elements in the BST Iterator\\") return self.stack[-1].val"},{"question":"# Fibonacci Calculation Challenge Given a number n, compute the n-th Fibonacci number using an efficient approach that optimizes both time and space complexity. # Input * An integer `n` (0 ≤ n ≤ 10^7) # Output * An integer denoting the n-th Fibonacci number. # Constraints * Compute the Fibonacci number for large values efficiently. * Ensure that your solution runs in O(n) time complexity and O(1) space complexity. # Function Signature ```python def fibonacci(n: int) -> int: pass ``` # Example ```python fibonacci(10) # returns 55 fibonacci(20) # returns 6765 fibonacci(1000) # returns the 1000-th Fibonacci number fibonacci(0) # returns 0 fibonacci(1) # returns 1 ``` *Note*: Your solution should handle very large values of n efficiently and should not use excessive memory.","solution":"def fibonacci(n: int) -> int: Returns the n-th Fibonacci number using an efficient iterative approach. if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"# Question Gnome Sort Variation Your task is to implement a variation of the Gnome Sort algorithm that sorts an array of integers into descending order. The algorithm should use a similar approach to the classic Gnome Sort described in the code snippets provided, but modify it to arrange the elements in descending order instead of ascending. Input Format - **arr**: A list of integers, ( 0 leq text{len}(arr) leq 1000 ). Each integer can be within the range of ( -10^6 ) to ( 10^6 ). Output Format - The list of integers sorted in descending order. Constraints - The function should handle edge cases such as an empty list or a list with a single element properly. - You must not use Python\'s built-in sorting functions. Function Signature ```python def gnome_sort_desc(arr: list[int]) -> list[int]: # your code here ``` # Example ```python # Example 1 input_arr = [34, 2, 78, 1, 25, 45, 13] output_arr = gnome_sort_desc(input_arr) print(output_arr) # Output should be [78, 45, 34, 25, 13, 2, 1] # Example 2 input_arr = [5, 8, 3, 9, 4, 2] output_arr = gnome_sort_desc(input_arr) print(output_arr) # Output should be [9, 8, 5, 4, 3, 2] # Example 3 input_arr = [] output_arr = gnome_sort_desc(input_arr) print(output_arr) # Output should be [] # Example 4 input_arr = [10] output_arr = gnome_sort_desc(input_arr) print(output_arr) # Output should be [10] ```","solution":"def gnome_sort_desc(arr): Sorts a list of integers in descending order using a modified Gnome Sort algorithm. index = 0 n = len(arr) while index < n: if index == 0 or arr[index] <= arr[index - 1]: index += 1 else: arr[index], arr[index - 1] = arr[index - 1], arr[index] index -= 1 return arr"},{"question":"# Question: Palindrome Validation in Singly Linked Lists with Two Pointers Scenario You are tasked with developing an efficient algorithm for validating whether a given singly linked list is a palindrome. A list is considered a palindrome if reading the list’s elements from left to right is the same as reading them from right to left. Given three methods (using two pointers, a stack, and a dictionary), optimize for space efficiency. Assume the structure of the linked list and list nodes is predefined as follows: ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next ``` Function to Implement ```python def is_palindrome_optimized(head: ListNode) -> bool: # Your implementation here ``` Expected Input and Output * **Input**: - `head`: A pointer to the head of the singly linked list. * **Output**: - Returns `True` if the linked list is a palindrome, otherwise `False`. Constraints * The list has at most `10^5` elements. * Each element in the linked list is an integer within the range `-10^6` to `10^6`. Performance Requirements * Optimize for O(1) space complexity while ensuring an O(n) time complexity. Example * **Example 1**: - Input: `1 -> 2 -> 3 -> 2 -> 1` - Output: `True` * **Example 2**: - Input: `1 -> 2 -> 3` - Output: `False` Hints - Utilize the two-pointers method to split the list into two parts. - Reverse the second half of the list. - Compare the first half and the reversed second half of the list for equality.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def is_palindrome_optimized(head: ListNode) -> bool: if not head or not head.next: return True # Find the middle of the linked list slow, fast = head, head while fast and fast.next: slow = slow.next fast = fast.next.next # Reverse the second half of the linked list prev = None curr = slow while curr: next_temp = curr.next curr.next = prev prev = curr curr = next_temp # Compare the first and second halves first_half, second_half = head, prev while second_half: if first_half.val != second_half.val: return False first_half = first_half.next second_half = second_half.next return True"},{"question":"# Question: Implement Enhanced sorted Linked List Checker You are given a singly linked list. Write a function `enhanced_is_sorted` that not only checks if the linked list is sorted in increasing order but also detects if it is sorted in decreasing order. If the list is sorted in increasing order, return `\\"asc\\"`; if it is sorted in decreasing order, return `\\"desc\\"`; if it is not sorted, return `\\"none\\"`. An empty list is considered to be sorted in both increasing and decreasing order. Input: * A `ListNode` object representing the head of the singly linked list. Output: * A string: `\\"asc\\"`, `\\"desc\\"`, or `\\"none\\"`. Example: ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next # Example 1: # Input: 1 -> 2 -> 3 -> 4 # Output: \\"asc\\" # Example 2: # Input: 4 -> 3 -> 2 -> 1 # Output: \\"desc\\" # Example 3: # Input: 1 -> 3 -> 2 -> 4 # Output: \\"none\\" def enhanced_is_sorted(head): # Implement this function pass ``` Constraints: * The linked list can have up to (10^5) nodes. * Node values are integers ranging from ( -10^9 ) to ( 10^9 ).","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def enhanced_is_sorted(head): if not head or not head.next: return \\"asc\\" # An empty list or a single-element list can be considered sorted in both directions is_asc = is_desc = True current = head while current.next: if current.val < current.next.val: is_desc = False elif current.val > current.next.val: is_asc = False current = current.next if is_asc: return \\"asc\\" if is_desc: return \\"desc\\" return \\"none\\""},{"question":"You are given the implementation of a `DirectedGraph` class as well as supporting classes `Node` and `DirectedEdge`. The graph is represented using adjacency lists, and allows adding nodes and directed edges between them. Your task is to implement a function in the `DirectedGraph` class that detects cycles in the graph. A cycle exists if a node can be visited again by following the directed edges starting from that node. # Function Signature ```python def has_cycle(self) -> bool: Check if the directed graph contains any cycle. Returns: bool: True if there is a cycle, False otherwise ``` # Input - The method uses the current instance of the `DirectedGraph` which holds nodes and edges. # Output - Returns `True` if the graph contains any cycle, `False` otherwise. # Constraints - The graph can potentially contain thousands of nodes and edges. - Consider both small and large graphs, including edge cases with isolated nodes, self-loops, and disjoint subgraphs. # Performance Requirements - The solution should efficiently handle large graphs. Aim for a time complexity of O(n + e), where n is the number of nodes and e is the number of edges. # Example ```python # Example Graph: # A --> B # ^ | # | v # D <-- C graph_data = { \'A\': [\'B\'], \'B\': [\'C\'], \'C\': [\'D\'], \'D\': [\'A\'] } graph = DirectedGraph(graph_data) print(graph.has_cycle()) # Output: True # Example Graph: # A --> B --> C # D graph_data = { \'A\': [\'B\'], \'B\': [\'C\'], \'C\': [], \'D\': [] } graph = DirectedGraph(graph_data) print(graph.has_cycle()) # Output: False ``` # Implementation Notes - You can use Depth First Search (DFS) for cycle detection. - Keep track of visited nodes to avoid reprocessing. - Use recursion stack to detect back edges, which indicate cycles.","solution":"class DirectedGraph: def __init__(self, adjacency_list): self.adjacency_list = adjacency_list def has_cycle(self) -> bool: Check if the directed graph contains any cycle. Returns: bool: True if there is a cycle, False otherwise def dfs(node, visited, rec_stack): visited.add(node) rec_stack.add(node) for neighbor in self.adjacency_list.get(node, []): if neighbor not in visited: if dfs(neighbor, visited, rec_stack): return True elif neighbor in rec_stack: return True rec_stack.remove(node) return False visited = set() rec_stack = set() for node in self.adjacency_list: if node not in visited: if dfs(node, visited, rec_stack): return True return False"},{"question":"# Question: Maximum Sum Subarray with Constraints You are given an array of integers, which can be both positive and negative. The array may contain large values, and you need to find the maximum sum of a contiguous subarray with a constraint that the sum should not exceed a given value K. Implement a function `max_subarray_with_constraint(array, k)` that returns the maximum sum of a subarray with the sum not exceeding K. If all possible subarrays have sums greater than K, return 0. Function Signature ```python def max_subarray_with_constraint(array: List[int], k: int) -> int: ``` Input * `array` - List of integers, where 1 <= len(array) <= 10^5 and -10^6 <= array[i] <= 10^6. * `k` - An integer constraint value, where 1 <= k <= 10^9. Output * Return the maximum sum of a contiguous subarray such that the sum does not exceed `k`. Constraints * The returned value must be the highest possible valid subarray sum that meets the constraint. * If no valid subarray exists that meets the constraint, return 0. Example ```python assert max_subarray_with_constraint([1, 2, -3, 4, 5, -7, 23], 10) == 9 # [4,5] assert max_subarray_with_constraint([1, 2, -3, 4, 5, -7, 23], 4) == 4 # [4] assert max_subarray_with_constraint([-2, -3, -4], 1) == 0 ``` Additional Notes * You should consider edge cases like all negative numbers, excessively large array sizes, and situations where no subarray meets the constraint.","solution":"from typing import List def max_subarray_with_constraint(array: List[int], k: int) -> int: max_sum = 0 current_sum = 0 start = 0 for end in range(len(array)): current_sum += array[end] while current_sum > k and start <= end: current_sum -= array[start] start += 1 if current_sum <= k: max_sum = max(max_sum, current_sum) return max_sum"},{"question":"# Missing Number Finder You work for a company that ensures the correctness of transmitted sequences of numbers. Your task is to write a function that identifies the missing number from a sequence of unique integers within the range [0..n]. The sequence may not necessarily be in order, but the difference between consecutive integers cannot be more than 1. If the sequence is already complete, the function should return the next integer in the sequence. **Input**: - A list of unique integers, `nums`, of length `n`. **Output**: - The integer that is missing from the range `[0..n]`. If no number is missing, return the next sequential integer that should follow. **Constraints**: - The list can be in any order. - All values are within the range `[0..n]` without any duplicates. **Function Signature**: ```python def find_missing_number(nums: List[int]) -> int: // your code here ``` **Examples**: 1. Input: `nums = [4, 1, 3, 0, 6, 5, 2]` Output: `7` 2. Input: `nums = [0, 1, 2, 3, 4]` Output: `5` 3. Input: `nums = [1]` Output: `0` **Explanation**: - For the first example, number 7 is the next number in the sequence 0-7. - For the second example, the sequence is already complete, thus the next number 5 should follow. - For a single element list [1], the number 0 is missing in the sequence starting from 0. Write an efficient implementation leveraging either the XOR operation or sum approach discussed above.","solution":"from typing import List def find_missing_number(nums: List[int]) -> int: Finds the missing number in the sequence of unique integers from 0 to n. If no number is missing, it returns the next integer that should follow. n = len(nums) expected_sum = n * (n + 1) // 2 actual_sum = sum(nums) missing_number = expected_sum - actual_sum return missing_number"},{"question":"# Coding Challenge You are provided with a hierarchical data structure represented as a tree, with the data formatted in the form of a dictionary where each key represents a node, and the value is a list of its sub-elements. You need to implement a function `tree_print(tree)` that prints the tree in a formatted manner, as shown in the example. The focus should be on maintaining proper formatting, especially indentations when numerical values appear as sub-elements. Sample Data Structure ```python # Example Tree tree = { \'a\': [\'Adam\', \'Book\', 4], \'b\': [\'Bill\', \'Computer\', 5, \'TV\', 6, \'Jill\', \'Sports\', 1], \'c\': [\'Bill\', \'Sports\', 3], \'d\': [\'Adam\', \'Computer\', 3, \'Quin\', \'Computer\', 3], \'e\': [\'Quin\', \'Book\', 5, \'TV\', 2], \'f\': [\'Adam\', \'Computer\', 7] } ``` Expected Output When you pass the above tree to `tree_print(tree)`, it should produce: ``` a -> Adam -> Book -> 4 b -> Bill -> Computer -> 5 -> TV -> 6 -> Jill -> Sports -> 1 c -> Bill -> Sports -> 3 d -> Adam -> Computer -> 3 -> Quin -> Computer -> 3 e -> Quin -> Book -> 5 -> TV -> 2 f -> Adam -> Computer -> 7 ``` # Task **Implement the function `tree_print(tree)` in Python.** Function Signature: ```python def tree_print(tree): pass ``` Input: - `tree` (dict): A dictionary representing the tree with keys as nodes and values as lists of sub-elements. Constraints: - Each key in the dictionary is unique. - Sub-elements within the lists may contain strings or integers. - Handle and print any valid hierarchical structures with proper indentation. Notes: - Be mindful of performance considerations with lookups. - Take care to handle mixed data types within the sub-elements. - Ensure the output format strictly adheres to the example provided. # Hints - Consider how you can optimize repeated lookups. - Think about the proper conditional logic for handling the indentation of different data types.","solution":"def tree_print(tree): for key, elements in tree.items(): print(f\\"{key} -> {\' -> \'.join(map(str, elements))}\\")"},{"question":"You are tasked with implementing the radix sort algorithm for sorting a list of non-negative integers. Your implementation will help sort a large data set of user IDs efficiently. # Function Signature ```python def custom_radix_sort(arr: List[int]) -> List[int]: pass ``` # Input - `arr`: A list of non-negative integers that you need to sort. # Output - A list of integers sorted in ascending order. # Constraints - All values in `arr` are non-negative integers. - The length of `arr` (`n`) does not exceed 100,000. - The maximum value in `arr` (`max_number`) does not exceed 1,000,000. # Requirements - Implement a function `custom_radix_sort` which uses the radix-sort algorithm. - Your implementation should be efficient and able to handle the constraints provided. - Do not use any built-in sorting functions. # Example ```python assert custom_radix_sort([53, 89, 150, 36, 633, 233]) == [36, 53, 89, 150, 233, 633] assert custom_radix_sort([170, 45, 75, 90, 802, 24, 2, 66]) == [2, 24, 45, 66, 75, 90, 170, 802] ``` # Hints - Pay attention to how you extract digits and how digits are used to organize the queues. - Remember to handle different lengths of digits correctly. - Consider edge cases such as an empty array or arrays with elements of significantly different digit lengths.","solution":"from typing import List def custom_radix_sort(arr: List[int]) -> List[int]: def counting_sort(arr: List[int], exp: int) -> List[int]: n = len(arr) output = [0] * n count = [0] * 10 for i in range(n): index = arr[i] // exp count[index % 10] += 1 for i in range(1, 10): count[i] += count[i - 1] for i in range(n - 1, -1, -1): index = arr[i] // exp output[count[index % 10] - 1] = arr[i] count[index % 10] -= 1 for i in range(n): arr[i] = output[i] return arr max_value = max(arr) if arr else 0 exp = 1 while max_value // exp > 0: arr = counting_sort(arr, exp) exp *= 10 return arr"},{"question":"Problem Statement: You are given a cost matrix representing the costs of moving from one station to another in a directed acyclic transportation network. Your task is to implement a function that computes the minimum cost to travel from station 0 to the last station N-1. The cost[i][j] represents the travel cost from station i to station j where i < j. Costs where i > j are irrelevant and will be given as -1 or INF. Function Signature: ```python def min_cost(cost: List[List[int]]) -> int: pass ``` Input: - `cost`: A matrix of size N x N where cost[i][j] denotes the cost from station i to j (i < j) and unimportant invalid values for i > j. Output: - Return an integer representing the minimum cost to reach the last station from the first station. Constraints: - 1 ≤ N ≤ 100 - 0 ≤ cost[i][j] ≤ 1000 for valid i, j - cost[i][j] is INF or -1 for i ≥ j Performance Requirements: - Your solution should be efficient enough to handle the upper constraint limits within a reasonable time frame. Example: ```python cost = [ [ 0, 15, 80, 90], [-1, 0, 40, 50], [-1, -1, 0, 70], [-1, -1, -1, 0] ] assert min_cost(cost) == 65 # min path: 0 -> 1 -> 3 ``` Edge Cases: - All paths have large costs. - No valid path from 0 to N-1, should return INF or a clear indication as per requirements. **Implementation Tip**: Think about initializing your cost array and iteratively updating it by considering each possible path progressively in a dynamic approach.","solution":"from typing import List def min_cost(cost: List[List[int]]) -> int: N = len(cost) # Initialize the minimum cost array to store minimum cost to reach each station min_cost_to_reach = [float(\'inf\')] * N min_cost_to_reach[0] = 0 # Process the cost matrix for i in range(N): for j in range(i + 1, N): if cost[i][j] != -1 and cost[i][j] != float(\'inf\'): min_cost_to_reach[j] = min(min_cost_to_reach[j], min_cost_to_reach[i] + cost[i][j]) return min_cost_to_reach[-1]"},{"question":"**Problem Statement**: You are given a string `s`. Your task is to find the longest palindromic substring contained in `s`. The substrings are case-sensitive, and the longest one needs to be returned. If there are multiple longest palindromic substrings of the same length, return the one that appears first. # Input: - A single string `s` where 0 ≤ len(s) ≤ 1000 # Output: - A single string representing the longest palindromic substring. # Constraints: 1. The input string `s` consists of printable ASCII characters. 2. In case of multiple valid outputs, return the one which appears first. # Example1: ``` Input: \\"dasdasdasdasdasdadsa\\" Output: \\"asdadsa\\" ``` # Example2: ``` Input: \\"acdbbdaa\\" Output: \\"dbbd\\" ``` # Example3: ``` Input: \\"abccba\\" Output: \\"abccba\\" ``` You need to implement a function `def longest_palindrome(s):` which takes a single argument: - `s` (a string) and returns the longest palindromic substring.","solution":"def longest_palindrome(s): Finds the longest palindromic substring in the given string s. If there are multiple longest palindromic substrings of the same length, return the one that appears first. :param s: A string where 0 ≤ len(s) ≤ 1000 :return: A string representing the longest palindromic substring. if len(s) == 0: return \\"\\" def expand_around_center(left, right): while left >= 0 and right < len(s) and s[left] == s[right]: left -= 1 right += 1 return s[left + 1:right] longest = \\"\\" for i in range(len(s)): # Odd length palindromes temp = expand_around_center(i, i) if len(temp) > len(longest): longest = temp # Even length palindromes temp = expand_around_center(i, i + 1) if len(temp) > len(longest): longest = temp return longest"},{"question":"# Problem: Counting Bit Flips to Convert Integer A to Integer B Description You are provided with two integers, `A` and `B`. Your task is to write a function that computes the number of bits that need to be flipped to convert integer `A` to integer `B`. Function Signature ```python def count_flips_to_convert(a: int, b: int) -> int: ``` Input - `a`: An integer, represented as `A` (0 <= `a` <= 2^31 - 1). - `b`: An integer, represented as `B` (0 <= `b` <= 2^31 - 1). Output - An integer representing the number of bits that need to be flipped to convert `A` to `B`. Constraints - Both `a` and `b` are non-negative integers. - You may assume the standard integer size (32 bits). Example ```python # Example 1 a = 29 # binary: 11101 b = 15 # binary: 01111 # Expected output: 2 # Explanation: The bit positions (2 and 3 from right) are different. # Example 2 a = 1 # binary: 00001 b = 2 # binary: 00010 # Expected output: 2 # Explanation: The bit positions 0 and 1 are different. assert count_flips_to_convert(29, 15) == 2 assert count_flips_to_convert(1, 2) == 2 ``` Performance Requirements Your solution should efficiently handle the bit manipulation in constant time O(1) given the fixed integer size.","solution":"def count_flips_to_convert(a: int, b: int) -> int: Returns the number of bits needed to be flipped to convert integer a to integer b. # XOR the two numbers to find differing bits xor_result = a ^ b # Count the number of set bits (1s) in XOR result count = 0 while xor_result: # Check last bit and add to count if it\'s set count += xor_result & 1 # Shift right by 1 to check the next bit xor_result >>= 1 return count"},{"question":"You are given a directed graph represented as an adjacency list in the form of a dictionary. Implement a function to determine whether the graph contains a cycle. If a cycle exists, return `True`; otherwise, return `False`. Input: - `graph`: A dictionary where keys are node identifiers and values are lists of neighbors (nodes to which the key node has directed edges). Output: - A boolean value `True` if the graph contains a cycle, `False` otherwise. Constraints: - The graph has at most 1000 nodes. - Node identifiers are strings of alphabetical characters (uppercase or lowercase). - Self-loops (e.g., `A` -> `A`) are allowed. Examples: ```python # Example 1: graph = { \'A\': [\'B\', \'C\'], \'B\': [\'D\'], \'C\': [\'F\'], \'D\': [\'E\', \'F\'], \'E\': [\'B\'], \'F\': [] } Output: True # Cycle: B -> D -> E -> B # Example 2: graph = { \'A\': [\'B\'], \'B\': [\'C\'], \'C\': [\'D\'], \'D\': [] } Output: False # No cycle # Example 3: graph = {} Output: False # Empty graph ``` Note: - Apply a Depth-First Search (DFS) method and utilize a three-state marking system (WHITE, GRAY, BLACK) to track the state of each node during traversal. # Function Signature: ```python def contains_cycle(graph: dict) -> bool: pass ``` # Hints: - Use a recursive function to explore each vertex’s neighbors. - Mark nodes as GRAY when visiting, and BLACK when fully explored. - If you encounter a GRAY node during the DFS, a cycle exists.","solution":"def contains_cycle(graph): WHITE, GRAY, BLACK = 0, 1, 2 def dfs(node): if colors[node] == GRAY: return True # Found a cycle if colors[node] == BLACK: return False # Already fully processed colors[node] = GRAY # Mark the node as being processed (in progress) for neighbor in graph.get(node, []): if dfs(neighbor): return True colors[node] = BLACK # Mark the node as fully processed return False colors = {node: WHITE for node in graph} for node in graph: if colors[node] == WHITE: if dfs(node): return True return False"},{"question":"# Message Decoding Challenge Description You are given a string encoded with a mapping from letters to numbers as follows: \'A\' -> 1, \'B\' -> 2, ..., \'Z\' -> 26. Given an encoded message containing digits, write a function to determine the total number of ways to decode it. Example For example, given encoded message \\"123\\", it could be decoded in 3 ways: - \\"ABC\\" (1 2 3) - \\"LC\\" (12 3) - \\"AW\\" (1 23) Hence, the function should return 3. Input Format - A single string `enc_mes` consisting of digits only representing the encoded message. - The length of `enc_mes` will be in the range [1, 100]. Output Format - An integer representing the total number of ways to decode the given `enc_mes`. Constraints - The input string will not contain characters other than digits. - The input string can contain leading zeroes, but these should be handled as invalid decodings. Performance Requirement - Your solution should run efficiently for input lengths up to 100. Function Signature ```python def decode_ways(enc_mes: str) -> int: pass ``` # Example ```python assert decode_ways(\\"123\\") == 3 assert decode_ways(\\"226\\") == 3 assert decode_ways(\\"0\\") == 0 assert decode_ways(\\"06\\") == 0 ``` Your task is to implement the `decode_ways` function which returns the number of ways to decode the given message.","solution":"def decode_ways(enc_mes: str) -> int: Determines the number of ways to decode a string containing digits where \'A\'->1, \'B\'->2, ..., \'Z\'->26. :param enc_mes: The encoded message as a string of digits. :return: The number of ways to decode the message. if not enc_mes or enc_mes[0] == \'0\': return 0 # DP array to store the subproblem results dp = [0] * (len(enc_mes) + 1) dp[0] = 1 for i in range(1, len(enc_mes) + 1): # Single digit decode if enc_mes[i-1] != \'0\': dp[i] += dp[i-1] # Two digit decode if i > 1 and enc_mes[i-2] != \'0\' and 10 <= int(enc_mes[i-2:i]) <= 26: dp[i] += dp[i-2] return dp[-1]"},{"question":"# Intersection Detection in Linked Lists As a software engineer at a data analytics company, you are tasked with developing a utility to detect common nodes in given user activity paths represented by linked lists. Your algorithm should find the first node where two activity paths intersect. Problem: Given two singly linked lists that represent activity paths of two users, identify the first common node (if any). A node is considered common if it is exactly the same node in memory. Function Signature: ```python class Node(object): def __init__(self, val=None): self.val = val self.next = None def find_intersection(head1: Node, head2: Node) -> Node: pass ``` Input: - Two **Node** objects representing the heads of two singly linked lists. Output: - The **Node** object where the two linked lists intersect. If there is no intersection, return `None`. Constraints: - The lists may be of different lengths. - You may assume that cycles don\'t exist in the input lists. - The nodes\' values are not unique descriptors; instead, the node instances themselves are compared for determining intersection. - Optimize the solution to run in linear time and use constant auxiliary space. Example Scenario: Consider two linked lists: 1 -> 3 -> 5 -> 7 -> 9 -> 11 and 2 -> 4 -> 6 7 -> 9 -> 11 `find_intersection` on the heads of these lists should return the node with value `7`. Testing: You should write unit tests to validate your solution using the typical `unittest` framework. The example above should be one of the test cases in your suite.","solution":"class Node(object): def __init__(self, val=None): self.val = val self.next = None def find_intersection(head1: Node, head2: Node) -> Node: # Calculate the lengths of both linked lists def get_length(head: Node) -> int: length = 0 current = head while current: length += 1 current = current.next return length length1 = get_length(head1) length2 = get_length(head2) # Set pointers to the start of each linked list current1 = head1 current2 = head2 # Adjust the starting point of the longer list if length1 > length2: for _ in range(length1 - length2): current1 = current1.next else: for _ in range(length2 - length1): current2 = current2.next # Move both pointers until they meet at the intersection point while current1 and current2: if current1 is current2: return current1 current1 = current1.next current2 = current2.next # If no intersection, return None return None"},{"question":"Secure Messaging System You have been tasked to implement a secure messaging system that uses the Diffie-Hellman key exchange protocol to establish a shared secret key between two parties, Alice and Bob. Follow the given steps and constraints to correctly perform the key exchange and verify the computed shared keys. Requirements & Constraints 1. **Prime Checker Implementation**: - Write a function `prime_check(num: int) -> bool` to verify if a given number `num` is prime. - Input: An integer `num` ( (2 leq num leq 10^6) ). - Output: Return `True` if `num` is a prime number, otherwise `False`. 2. **Finding Primitive Roots**: - Implement a function `find_primitive_root(n: int) -> List[int]` to find all primitive roots of a given prime number `n`. - Input: A prime number `n` ( (2 leq n leq 10^5) ). - Output: Return a list of all primitive roots of `n`. 3. **Diffie-Hellman Key Exchange**: - `diffie_hellman_key_exchange(a: int, p: int) -> Tuple[int, int, int, int, int, bool]` - Input: - `a`: A primitive root of `p`. - `p`: A prime number. - Perform key exchange securely: 1. Generate Alice\'s private key between (1) and (p-1). 2. Compute Alice\'s public key using the private key and base `a`. 3. Generate Bob’s private key between (1) and (p-1). 4. Compute Bob’s public key using the private key and base `a`. - Output: Return a tuple containing: - Alice\'s private key - Alice\'s public key - Bob\'s private key - Bob\'s public key - The shared key that both computed (it should be the same for both) - A boolean indicating whether the shared keys match. Testing and Performance: Ensure your implementation is robust and efficient. Consider the performance implications of your solution and handle large inputs gracefully. Example: ```python # Implementation example (subset of the problem to give students an idea): prime_check(11) # Should return True find_primitive_root(11) # Should return [2, 6, 7, 8] # To execute the key exchange diffie_hellman_key_exchange(2, 11) # Expected Output: # (Alice\'s private key, Alice\'s public key, # Bob\'s private key, Bob\'s public key, # Shared key, True) ```","solution":"import random from typing import List, Tuple def prime_check(num: int) -> bool: Checks if a number is prime. if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def find_primitive_root(n: int) -> List[int]: Finds all primitive roots of a given prime number n. if not prime_check(n): return [] def gcd(a: int, b: int) -> int: while b != 0: a, b = b, a % b return a def power(x: int, y: int, p: int) -> int: res = 1 x = x % p while y > 0: if y & 1: res = (res * x) % p y = y >> 1 x = (x * x) % p return res def is_primitive_root(g: int, p: int) -> bool: required_set = set(num for num in range(1, p) if gcd(num, p) == 1) actual_set = set(power(g, k, p) for k in range(1, p)) return required_set == actual_set roots = [g for g in range(2, n) if is_primitive_root(g, n)] return roots def diffie_hellman_key_exchange(a: int, p: int) -> Tuple[int, int, int, int, int, bool]: Performs the Diffie-Hellman key exchange. if not prime_check(p): raise ValueError(\\"p must be a prime number\\") alice_priv = random.randint(1, p - 1) alice_pub = pow(a, alice_priv, p) bob_priv = random.randint(1, p - 1) bob_pub = pow(a, bob_priv, p) alice_shared_key = pow(bob_pub, alice_priv, p) bob_shared_key = pow(alice_pub, bob_priv, p) return (alice_priv, alice_pub, bob_priv, bob_pub, alice_shared_key, alice_shared_key == bob_shared_key)"},{"question":"# Question: Maximum Flow in a Network with BFS (Edmonds-Karp Algorithm) **Context**: You are working as a network engineer for a company that manages extensive data networks. One of your tasks is to ensure efficient data transfer from a source server to a sink server through the network. To do so, you need to calculate the maximum possible data transfer (maximum flow) that can occur in this network. **Objective**: Implement a function that computes the maximum flow in a given flow network using the Breadth-First Search based Edmonds-Karp algorithm. **Function Signature**: ```python def maximum_flow_bfs(adjacency_matrix: List[List[int]]) -> int: ``` # Input * `adjacency_matrix`: A 2D list of integers representing the n x n adjacency matrix of the network graph. Each element `adjacency_matrix[i][j]` indicates the capacity of the edge between nodes `i` and `j`. # Output * An integer representing the maximum flow from the source node (0) to the sink node (n-1). # Constraints * `1 <= n <= 100` # number of nodes in the network * `0 <= adjacency_matrix[i][j] <= 10^5` # capacity of a single edge # Example ```python graph = [ [0, 16, 13, 0, 0, 0], [0, 0, 10, 12, 0, 0], [0, 4, 0, 0, 14, 0], [0, 0, 9, 0, 0, 20], [0, 0, 0, 7, 0, 4], [0, 0, 0, 0, 0, 0] ] print(maximum_flow_bfs(graph)) # Output: 23 ``` # Approach 1. Use BFS to find the paths with available capacity from source to sink. 2. Track the capacity of the path with the minimum flow using BFS. 3. Update the capacities of the edges and the reverse edges in the residual graph. 4. Repeat until there are no more augmenting paths. 5. Sum up all the flows found by BFS to get the maximum flow. # Edge Cases to Consider * Networks with isolated nodes * Networks where multiple paths have the same flow capacity * Networks with zero capacity on certain edges","solution":"from collections import deque from typing import List def bfs(residual_graph: List[List[int]], source: int, sink: int, parent: List[int]) -> bool: visited = [False] * len(residual_graph) queue = deque([source]) visited[source] = True while queue: node = queue.popleft() for idx, capacity in enumerate(residual_graph[node]): if not visited[idx] and capacity > 0: # Check for an unvisited node with capacity queue.append(idx) visited[idx] = True parent[idx] = node if idx == sink: return True return False def maximum_flow_bfs(adjacency_matrix: List[List[int]]) -> int: n = len(adjacency_matrix) source, sink = 0, n - 1 residual_graph = [r[:] for r in adjacency_matrix] parent = [-1] * n max_flow = 0 while bfs(residual_graph, source, sink, parent): path_flow = float(\'Inf\') s = sink while s != source: path_flow = min(path_flow, residual_graph[parent[s]][s]) s = parent[s] # update residual capacities of the edges and reverse edges along the path v = sink while v != source: u = parent[v] residual_graph[u][v] -= path_flow residual_graph[v][u] += path_flow v = parent[v] max_flow += path_flow return max_flow"},{"question":"# Bucket Sort Implementation **Objective**: Implement a bucket sort function to sort an array of integers using a more efficient secondary sorting algorithm for the buckets, ensuring that it handles negative integers correctly. # Function Signature ```python def optimized_bucket_sort(arr): Sorts an array of integers using the bucket sort algorithm. pass ``` # Input * An array of integers `arr`. # Output * A sorted array of integers. # Constraints * The array can contain negative as well as positive integers. * The function should handle empty arrays and arrays with a single element gracefully. * Performance should be optimized compared to the given bucket sort implementation. # Requirements 1. Replace `insertion_sort` in the original implementation with a more efficient sorting algorithm. 2. Ensure the bucket range calculations take into account both positive and negative integers. 3. Maintain stability in the sorting process. # Example ```python print(optimized_bucket_sort([4, 2, -2, 5, 3, 1, 0, -5])) # Output: [-5, -2, 0, 1, 2, 3, 4, 5] print(optimized_bucket_sort([])) # Output: [] print(optimized_bucket_sort([5])) # Output: [5] print(optimized_bucket_sort([3,3,3,3])) # Output: [3, 3, 3, 3] ``` # Notes * Consider using an efficient sorting algorithm in place of `insertion_sort` (e.g., `quicksort` or `mergesort`). * The function should be well-documented and handle edge cases explicitly.","solution":"def optimized_bucket_sort(arr): Sorts an array of integers using the bucket sort algorithm. This function handles both positive and negative integers. if not arr: return arr # Get the minimum and maximum values from the array min_val = min(arr) max_val = max(arr) # Calculate the range of the buckets bucket_range = (max_val - min_val) / len(arr) + 1 # Initialize buckets buckets = [[] for _ in range(len(arr))] # Distribute the elements into buckets for num in arr: index = int((num - min_val) / bucket_range) buckets[index].append(num) # Sort each bucket and merge them into the result sorted_arr = [] for bucket in buckets: sorted_arr.extend(sorted(bucket)) return sorted_arr"},{"question":"# Scenario: In data visualization applications, it is sometimes required to manipulate matrix layouts to achieve different perspectives. Given the necessity of this ability, you are asked to implement transformations of a given N x N matrix. # Task: Write a function that merges the four provided transformation algorithms into one. Your function should take the following inputs: - A matrix of size N x N. - A string specifying one of the following operations: \\"rotate_clockwise\\", \\"rotate_counterclockwise\\", \\"top_left_invert\\", and \\"bottom_left_invert\\". You need to validate the input and apply the specified transformation to the given matrix, returning the transformed matrix. # Constraints: - The matrix size will not exceed 1000 x 1000. - The input will always be either \\"rotate_clockwise\\", \\"rotate_counterclockwise\\", \\"top_left_invert\\", or \\"bottom_left_invert\\". # Input Format: ```python def transform_matrix(matrix: List[List[int]], operation: str) -> List[List[int]]: pass ``` # Output Format: The function should return a new matrix that has been transformed as specified. # Example: ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9], ] operation = \\"rotate_clockwise\\" Output = [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] ``` # Note: - Ensure correctness by handling edge cases like empty matrices. - Aim for an efficient solution keeping in mind both time and space complexities.","solution":"from typing import List def transform_matrix(matrix: List[List[int]], operation: str) -> List[List[int]]: def rotate_clockwise(matrix): return [list(row) for row in zip(*matrix[::-1])] def rotate_counterclockwise(matrix): return [list(row) for row in zip(*matrix)][::-1] def top_left_invert(matrix): return [row[::-1] for row in matrix][::-1] def bottom_left_invert(matrix): return matrix[::-1] if operation == \\"rotate_clockwise\\": return rotate_clockwise(matrix) elif operation == \\"rotate_counterclockwise\\": return rotate_counterclockwise(matrix) elif operation == \\"top_left_invert\\": return top_left_invert(matrix) elif operation == \\"bottom_left_invert\\": return bottom_left_invert(matrix) else: raise ValueError(\\"Invalid operation\\")"},{"question":"Radix Sort Implementation We need to implement the radix sort algorithm. Your task is to write a function that takes a list of non-negative integers and sorts it using the radix sort method. # Input - A list `arr` of non-negative integers `arr = [n1, n2, n3, ..., nk]` where `0 <= ni <= 10^9` - An optional boolean parameter `simulation`. If `simulation` is set to `True`, print the array\'s state after each iteration of sorting. # Output - The function should return the sorted list of integers. # Constraints - The list will have at most `10^6` elements. - Each integer in the list is non-negative and less than `10^9`. # Function Signature ```python def radix_sort(arr: List[int], simulation: bool = False) -> List[int]: ``` # Example ```python # Example 1: input_list = [170, 45, 75, 90, 802, 24, 2, 66] print(radix_sort(input_list, simulation=False)) # Output: [2, 24, 45, 66, 75, 90, 170, 802] # Example 2 (with simulation): input_list = [170, 45, 75, 90, 802, 24, 2, 66] print(radix_sort(input_list, simulation=True)) # Expected Iterations: # iteration 0 : 170 45 75 90 802 24 2 66 # iteration 1 : 802 2 24 45 66 170 75 90 # iteration 2 : 2 170 24 45 75 802 66 90 # iteration 3 : 2 24 45 66 75 90 170 802 # Output: [2, 24, 45, 66, 75, 90, 170, 802] ``` # Notes - Ensure that the function correctly handles edge cases such as an empty list or a list with a single element. - The simulation part is for debugging and understanding purposes, make it optional by default. Good luck and happy coding!","solution":"from typing import List def counting_sort(arr, exp, simulation): n = len(arr) output = [0] * n count = [0] * 10 for i in range(n): index = (arr[i] // exp) count[index % 10] += 1 for i in range(1, 10): count[i] += count[i - 1] i = n - 1 while i >= 0: index = (arr[i] // exp) output[count[index % 10] - 1] = arr[i] count[index % 10] -= 1 i -= 1 for i in range(n): arr[i] = output[i] if simulation: print(f\\"iteration {exp}: \\", \' \'.join(map(str, arr))) def radix_sort(arr: List[int], simulation: bool = False) -> List[int]: if len(arr) == 0: return [] max1 = max(arr) exp = 1 while max1 // exp > 0: counting_sort(arr, exp, simulation) exp *= 10 return arr"},{"question":"Scenario You are working on a software project that involves sorting data retrieved from various sensors. The data points often arrive sporadically, and you need to implement an efficient way to sort the data when it becomes available. Task Implement a function `smart_sort(arr)` that takes a list of integers and sorts it in ascending order using the cocktail shaker sort algorithm. Additionally, optimize your implementation to recognize when the list is already sorted, exiting early if no swaps are needed during a complete pass. Function Signature ```python def smart_sort(arr: List[int]) -> List[int]: pass ``` Input * `arr`: A list of integers where (0 leq text{len(arr)} leq 10^5). Output * Return a sorted list of integers in ascending order. Example ```python assert smart_sort([5, 3, 1, 4, 2]) == [1, 2, 3, 4, 5] assert smart_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] assert smart_sort([]) == [] assert smart_sort([4, 3, 3, 1]) == [1, 3, 3, 4] ``` Constraints * Aim to optimize for both performance and clarity. * Ensure your function performs no more swaps than necessary. * Handle edge cases such as empty lists and already sorted lists efficiently. Performance Requirements * The solution should be able to handle up to (10^5) elements efficiently, leveraging the optimized cocktail shaker sort.","solution":"from typing import List def smart_sort(arr: List[int]) -> List[int]: Sorts the list using an optimized cocktail shaker sort algorithm. n = len(arr) if n <= 1: return arr start = 0 end = n - 1 while start < end: swapped = False # forward pass for i in range(start, end): if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] swapped = True if not swapped: break end -= 1 swapped = False # backward pass for i in range(end, start, -1): if arr[i] < arr[i - 1]: arr[i], arr[i - 1] = arr[i - 1], arr[i] swapped = True if not swapped: break start += 1 return arr"},{"question":"Consider an integer where you need to efficiently swap the bits in each pair of adjacent bits. You are required to implement a function `swap_pair(num)` that performs this operation. Here the odd-position bits are swapped with the even-position bits (0-indexed). # Function Signature ```python def swap_pair(num: int) -> int: ``` # Input - `num` (int): A non-negative integer within the 32-bit unsigned integer range (0 ≤ num ≤ 2^32 - 1). # Output - (int): The integer resulting from swapping adjacent bits of the input integer. # Constraints - The input integer will fit into a 32-bit unsigned integer. - You must perform this transformation using bitwise operations for optimal efficiency. - Aim for a constant-time and constant-space solution. # Example 1. **Input**: `22` - **Binary Representation**: `010110` - **Expected Output**: `41` - **Binary Representation**: `101001` 2. **Input**: `10` - **Binary Representation**: `1010` - **Expected Output**: `5` - **Binary Representation**: `0101` # Detailed Explanation You can achieve this by masking all odd bits and shifting them to the right by one position, and masking all even bits and shifting them to the left by one position, and then combining the results using a bitwise OR operation. # Testing You should validate your function with edge cases such as: - The smallest input `0` or `1`. - Inputs with alternating bits such as `0xAAAAAAAA` and `0x55555555`. - The largest input in the range `0xFFFFFFFF`.","solution":"def swap_pair(num: int) -> int: Swap adjacent bits of the input integer. Args: num (int): A non-negative integer within 32-bit unsigned integer range. Returns: int: The integer resulting from swapping adjacent bits. # Mask all odd bits to the right half and even bits to the left half odd_bits = num & 0xAAAAAAAA even_bits = num & 0x55555555 # Swap odd bits to even positions and even bits to odd positions swapped_num = (odd_bits >> 1) | (even_bits << 1) return swapped_num"},{"question":"# Symmetric Tree Check **Objective**: Given a binary tree, determine if it is symmetric around its center. **Scenario**: Consider a simple binary tree data structure where each node contains an integer value. Two binary trees are considered *mirror images* of each other if: 1. Their root values are identical. 2. The left subtree of each tree is a mirror image of the right subtree of the other tree. Your task is to implement two functions: 1. **`is_symmetric_recursive(root)`**: A recursive function to determine if the tree is symmetric. 2. **`is_symmetric_iterative(root)`**: An iterative function to determine symmetry utilizing a stack. Function Signatures ```python def is_symmetric_recursive(root): # Implement this function def is_symmetric_iterative(root): # Implement this function ``` Input - `root`: The root node of the binary tree. Output - Return `True` if the tree is symmetric; otherwise, return `False`. Constraints - The number of nodes in the tree will be in the range [0, 1000]. - Node values are integers. Points to Consider - The mirror symmetry check should correctly handle trees that include null nodes as shown in the provided examples. - Ensure that edge cases such as empty trees and single-node trees are correctly identified. - Optimize the solution to handle large but shallow trees efficiently. Examples 1. Given a binary tree `[1,2,2,3,4,4,3]`: ``` 1 / 2 2 / / 3 4 4 3 ``` Output: `True` 2. Given a binary tree `[1,2,2,null,3,null,3]`: ``` 1 / 2 2 3 3 ``` Output: `False` **Note**: Bonus points if you could solve it both recursively and iteratively.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_symmetric_recursive(root): if not root: return True def is_mirror(left, right): if not left and not right: return True if not left or not right: return False return (left.val == right.val) and is_mirror(left.left, right.right) and is_mirror(left.right, right.left) return is_mirror(root.left, root.right) def is_symmetric_iterative(root): if not root: return True stack = [(root.left, root.right)] while stack: left, right = stack.pop() if not left and not right: continue if not left or not right: return False if left.val != right.val: return False stack.append((left.left, right.right)) stack.append((left.right, right.left)) return True"},{"question":"# Question: You are tasked with creating a function to generate the hailstone sequence for a given integer n, as well as calculating a few metrics about the sequence. The hailstone or Collatz sequence is generated as follows: * Start with a positive integer n. * If n is even, the next number in the sequence is n/2. * If n is odd, the next number in the sequence is 3n + 1. * Repeat the process until n equals 1. # Function Requirements: You need to implement a function `analyze_hailstone(n)` that: 1. Returns the hailstone sequence starting with the given integer n. 2. Returns the length of the sequence. 3. Returns the maximum value encountered in the sequence. # Input: * A single positive integer n (1 ≤ n ≤ 100,000). # Output: * The function should return a tuple containing three elements: * A list of integers representing the hailstone sequence. * An integer representing the length of the sequence. * An integer representing the maximum value encountered in the sequence. # Example: ```python def analyze_hailstone(n): # Your implementation here # Example Usage: sequence, length, max_value = analyze_hailstone(7) print(sequence) # Output: [7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1] print(length) # Output: 17 print(max_value) # Output: 52 ``` # Constraints & Performance Requirements: 1. The function must handle large inputs efficiently. 2. The function should avoid unnecessary calculations and ensure that the sequence and statistics are computed in linear time with respect to the sequence length.","solution":"def analyze_hailstone(n): Returns the hailstone sequence, its length, and the maximum value encountered in the sequence. Args: n (int): A positive integer (1 ≤ n ≤ 100,000). Returns: tuple: A tuple containing: - A list of integers representing the hailstone sequence. - An integer representing the length of the sequence. - An integer representing the maximum value encountered in the sequence. sequence = [] max_value = n while n != 1: sequence.append(n) if n % 2 == 0: n = n // 2 else: n = 3 * n + 1 if n > max_value: max_value = n sequence.append(1) return (sequence, len(sequence), max_value)"},{"question":"# Priority Queue Using Linear Array **Context**: You are working on a task scheduler system that needs to manage tasks based on their priority. The scheduler must be able to insert tasks dynamically and quickly get the task with the highest priority to execute it. Your Task: Implement a class `PriorityQueue` that represents a priority queue using a linear array. You need to implement the following methods: - `__init__(self, items=None, priorities=None)`: Constructor to initialize the priority queue with optional initial elements and their corresponding priorities. If no priorities are given, the items themselves should be used as priorities. - `size(self) -> int`: Returns the number of elements in the priority queue. - `push(self, item, priority=None)`: Inserts an element into the priority queue with an optional priority. If the priority is not provided, the item\'s value should be used as its priority. - `pop(self) -> Any`: Removes and returns the element with the highest priority from the priority queue. Input/Output Format: - Initialization (`__init__`): - `items` (optional): A list or iterable of elements to be added to the priority queue. - `priorities` (optional): A list or iterable of priorities corresponding to the elements. - `size()`: - Input: None - Output: Integer, current size of the priority queue. - `push(item, priority=None)`: - Input: `item` (any), `priority` (optional, any) - Output: None - `pop()`: - Input: None - Output: The element with the highest priority Constraints: - The priority queue should allow for the correct handling of priorities and must return elements in the order of their priorities. - The implementation should handle empty queue scenarios gracefully. Example: ```python pq = PriorityQueue() pq.push(\\"high\\", 3) pq.push(\\"medium\\", 2) pq.push(\\"low\\", 1) print(pq.size()) # Output: 3 print(pq.pop()) # Output: \\"high\\" print(pq.pop()) # Output: \\"medium\\" print(pq.pop()) # Output: \\"low\\" ``` **Note**: Your implementation should be optimized to ensure that the `pop` operation is O(1) and the `push` operation should correctly maintain the order based on priority.","solution":"class PriorityQueue: def __init__(self, items=None, priorities=None): if items is None: items = [] if priorities is None: priorities = items if len(items) != len(priorities): raise ValueError(\\"Items and priorities must be of the same length\\") self.queue = [] for item, priority in zip(items, priorities): self.push(item, priority) def size(self): return len(self.queue) def push(self, item, priority=None): if priority is None: priority = item self.queue.append((priority, item)) self.queue.sort(key=lambda x: x[0], reverse=True) def pop(self): if self.size() == 0: raise IndexError(\\"pop from empty priority queue\\") return self.queue.pop(0)[1]"},{"question":"# Context You are tasked with creating a function for a text processing system. The system uses a Deterministic Finite Automaton (DFA) to validate whether specific patterns exist in the input text. # Problem Statement Implement a function `is_pattern_valid` that determines if a given string is accepted by a DFA. You will be provided with the DFA\'s transition table, start state, and acceptable final states. # Function Signature ```python def is_pattern_valid(transitions, start, final, string): Determines if a string is accepted by a DFA. Args: transitions (dict of dict): A dictionary where keys are state labels and values are dictionaries mapping input characters to the next state. start (str): The start state of the DFA. final (list): A list of acceptable final states. string (str): The input string to verify. Returns: bool: True if the string is accepted by the DFA, False otherwise. ``` # Input 1. `transitions`: A dictionary representing the state transitions of the DFA. Each key is a state, and each value is another dictionary with input characters as keys and resulting states as values. 2. `start`: A string representing the start state of the DFA. 3. `final`: A list of strings representing the acceptable final states of the DFA. 4. `string`: The input string to be checked. # Output - Return `True` if the string is accepted by the DFA, `False` otherwise. # Constraints 1. All states and input characters assumed to be strings. 2. The input string can be empty. 3. The DFA transition table will always have defined transitions for valid inputs. # Example ```python transitions = { \'q0\': {\'a\': \'q1\', \'b\': None}, \'q1\': {\'a\': \'q1\', \'b\': \'q2\'}, \'q2\': {\'a\': None, \'b\': None} } start = \'q0\' final = [\'q2\'] string = \'aab\' result = is_pattern_valid(transitions, start, final, string) print(result) # Should output: True string = \'aa\' result = is_pattern_valid(transitions, start, final, string) print(result) # Should output: False ``` # Notes - Consider edge cases like an empty string, undefined transitions, and non-final end states. - Ensure the function handles invalid inputs gracefully.","solution":"def is_pattern_valid(transitions, start, final, string): Determines if a string is accepted by a DFA. Args: transitions (dict of dict): A dictionary where keys are state labels and values are dictionaries mapping input characters to the next state. start (str): The start state of the DFA. final (list): A list of acceptable final states. string (str): The input string to verify. Returns: bool: True if the string is accepted by the DFA, False otherwise. current_state = start for char in string: if char in transitions[current_state]: next_state = transitions[current_state][char] if next_state is None: return False current_state = next_state else: return False return current_state in final"},{"question":"# Levenshtein Distance Given two words, `word_a` and `word_b`, the Levenshtein distance between them is defined as the minimum number of single-character edits (insertions, deletions, or substitutions) required to change one word into the other. Task Implement the `edit_distance` function to compute the Levenshtein distance between two words. Function Signature ```python def edit_distance(word_a: str, word_b: str) -> int: Compute the Levenshtein distance between two strings Args: word_a (str): The first word. word_b (str): The second word. Returns: int: The Levenshtein distance between the two words. pass ``` Input * `word_a` and `word_b`, both are strings with lengths between 0 and 5000 inclusive. Output * Return a single integer representing the Levenshtein distance between the two words. Constraints * The operation count is limited to O(n*m). * Space utilization is limited to O(n*m). Example ```python assert edit_distance(\\"kitten\\", \\"sitting\\") == 3 assert edit_distance(\\"flaw\\", \\"lawn\\") == 2 assert edit_distance(\\"intention\\", \\"execution\\") == 5 ``` Each of the assertions should pass, representing the correct Levenshtein distances. To achieve this, you may use a dynamic programming table where `edit[i][j]` denotes the Levenshtein distance between the first `i` characters of `word_a` and the first `j` characters of `word_b`.","solution":"def edit_distance(word_a: str, word_b: str) -> int: Compute the Levenshtein distance between two strings Args: word_a (str): The first word. word_b (str): The second word. Returns: int: The Levenshtein distance between the two words. len_a = len(word_a) len_b = len(word_b) # Create a 2D array to store the distances dp = [[0] * (len_b + 1) for _ in range(len_a + 1)] # Initialize the first row and first column for i in range(len_a + 1): dp[i][0] = i for j in range(len_b + 1): dp[0][j] = j # Calculate the rest of the distances for i in range(1, len_a + 1): for j in range(1, len_b + 1): if word_a[i - 1] == word_b[j - 1]: dp[i][j] = dp[i - 1][j - 1] # No operation needed if characters are the same else: dp[i][j] = min( dp[i - 1][j] + 1, # Deletion dp[i][j - 1] + 1, # Insertion dp[i - 1][j - 1] + 1 # Substitution ) # Return the distance between the full lengths of the two words return dp[len_a][len_b]"},{"question":"# Scenario You are a logistics manager tasked with maximizing the value of goods shipped in a container with limited capacity. Each item has a specified weight and value, and you can carry only an entire item or none at all. Your goal is to determine the maximum possible value of items that can fit within the container\'s capacity. # Problem Statement Implement the function `get_maximum_value(items, capacity)` where: - `items` is a list of tuples, each tuple containing two integers where the first integer is the value and the second integer is the weight of the item. - `capacity` is an integer representing the maximum weight the container can hold. The function should return the maximum value of the items that can be fit into the container. If no items can fit, return 0. # Constraints 1. 1 ≤ len(items) ≤ 1000 2. 1 ≤ capacity ≤ 1000 3. 1 ≤ value, weight ≤ 1000 # Example ```python class Item: def __init__(self, value, weight): self.value = value self.weight = weight def get_maximum_value(items, capacity): dp = [0] * (capacity + 1) for item in items: for cur_weight in reversed(range(item.weight, capacity+1)): dp[cur_weight] = max(dp[cur_weight], item.value + dp[cur_weight - item.weight]) return dp[capacity] # Sample Input items = [Item(60, 5), Item(50, 3), Item(70, 4), Item(30, 2)] capacity = 5 # Sample Output print(get_maximum_value(items, capacity)) # Output: 80 ``` # Notes - Ensure the code handles edge cases such as when the capacity is zero, or when all items are too heavy to fit into the capacity. - The implementation should be efficient in time and space complexity as per the given constraints.","solution":"def get_maximum_value(items, capacity): Determines the maximum value of items that can be fit into the container with a given capacity. :param items: List of tuples, where each tuple contains (value, weight) of an item :param capacity: Integer representing the maximum weight the container can hold :return: Maximum value of items that can be fit into the container dp = [0] * (capacity + 1) for value, weight in items: for cur_weight in reversed(range(weight, capacity + 1)): dp[cur_weight] = max(dp[cur_weight], value + dp[cur_weight - weight]) return dp[capacity]"},{"question":"Objective Design and implement a function to detect the first common node between two singly linked lists. Problem Description Given two singly linked lists, write a function `find_intersection` that returns the node where the two lists intersect. If there is no intersection, return `None`. The intersection is defined based on node identity, not value. Input - Two singly linked lists `headA` and `headB`. Output - The node at which the two lists intersect, or `None` if there is no intersection. Constraints 1. Each linked list is non-cyclic. 2. The linked lists retain their individual structures and not be changed. Example Consider the following linked lists: ``` List 1: 1 -> 3 -> 5 7 -> 9 -> 11 / List 2: 2 -> 4 -> 6 ``` Call: `find_intersection(1, 2)` should return the node with value `7`. Function Signature ```python class Node: def __init__(self, val=None): self.val = val self.next = None def find_intersection(headA: Node, headB: Node) -> Node: pass ``` Unit Test Include a unit test class `TestFindIntersection` inheriting from `unittest.TestCase` that thoroughly tests the function with different scenarios, including edge cases.","solution":"class Node: def __init__(self, val=None): self.val = val self.next = None def find_intersection(headA: Node, headB: Node) -> Node: if not headA or not headB: return None pointerA, pointerB = headA, headB while pointerA != pointerB: pointerA = pointerA.next if pointerA else headB pointerB = pointerB.next if pointerB else headA return pointerA"},{"question":"# Question You are tasked with implementing the encode and decode functions for a compression algorithm using Huffman coding. Your implementation should be able to read data from files, compress it, and then decompress it back to its original form. You should complete the methods `encode_file` and `decode_file` inside the `HuffmanCoding` class. # Input Format - For `encode_file`: - `file_in_name`: A string representing the name of the input file containing the data to be encoded. - `file_out_name`: A string representing the name of the output file where the encoded data will be written. - For `decode_file`: - `file_in_name`: A string representing the name of the input file containing the encoded data. - `file_out_name`: A string representing the name of the output file where the decoded data will be written. # Output Format - The encoded file should contain the compressed data along with the Huffman tree for decoding. - The decoded file should contain the original data that was compressed. # Constraints 1. `file_in_name` and `file_out_name` are valid file paths. 2. The content of the files will consist of binary data. 3. Maximum file size is assumed to be 100MB for this task. # Performance Requirements - The implementation should efficiently handle input files up to the maximum size. - Ensure the correctness of the implementation such that the decoded data matches the original input data. ```python from collections import defaultdict, deque import heapq class Node: def __init__(self, frequency=0, sign=None, left=None, right=None): self.frequency = frequency self.sign = sign self.left = left self.right = right def __lt__(self, other): return self.frequency < other.frequency class HuffmanCoding: @staticmethod def encode_file(file_in_name, file_out_name): Encode the content of the file `file_in_name` using Huffman coding and save the encoded result in the file `file_out_name`. # Your implementation here @staticmethod def decode_file(file_in_name, file_out_name): Decode the content of the file `file_in_name` which is encoded using Huffman coding and save the decoded result in the file `file_out_name`. # Your implementation here # Note: Additional helper functions and classes may be necessary to complete this task. ``` **Scenario**: Suppose you are working with a company that handles large volumes of text data. To optimize storage, the company decides to implement Huffman coding for compressing and decompressing files. Your task is to implement the encoding and decoding functions as specified. Consider edge cases and ensure the solution efficiently manages the data within the provided constraints.","solution":"from collections import defaultdict, deque import heapq import pickle class Node: def __init__(self, frequency=0, sign=None, left=None, right=None): self.frequency = frequency self.sign = sign self.left = left self.right = right def __lt__(self, other): return self.frequency < other.frequency class HuffmanCoding: @staticmethod def build_frequency_table(data): frequency = defaultdict(int) for char in data: frequency[char] += 1 return frequency @staticmethod def build_huffman_tree(frequency): priority_queue = [Node(freq, char) for char, freq in frequency.items()] heapq.heapify(priority_queue) while len(priority_queue) > 1: left = heapq.heappop(priority_queue) right = heapq.heappop(priority_queue) merged = Node(left.frequency + right.frequency, None, left, right) heapq.heappush(priority_queue, merged) return priority_queue[0] @staticmethod def build_codes_table(node, prefix=\\"\\", codes={}): if node is None: return if node.sign is not None: codes[node.sign] = prefix else: HuffmanCoding.build_codes_table(node.left, prefix + \\"0\\", codes) HuffmanCoding.build_codes_table(node.right, prefix + \\"1\\", codes) return codes @staticmethod def encode_file(file_in_name, file_out_name): with open(file_in_name, \'rb\') as file: data = file.read() frequency = HuffmanCoding.build_frequency_table(data) huffman_tree = HuffmanCoding.build_huffman_tree(frequency) huffman_codes = HuffmanCoding.build_codes_table(huffman_tree) encoded_data = \\"\\".join(huffman_codes[byte] for byte in data) # Pad encoded_data to make its length a multiple of 8 extra_padding = 8 - len(encoded_data) % 8 for _ in range(extra_padding): encoded_data += \\"0\\" padded_info = \\"{0:08b}\\".format(extra_padding) encoded_data = padded_info + encoded_data byte_array = bytearray() for i in range(0, len(encoded_data), 8): byte = encoded_data[i:i+8] byte_array.append(int(byte, 2)) with open(file_out_name, \'wb\') as file: pickle.dump((huffman_tree, byte_array), file) @staticmethod def decode_file(file_in_name, file_out_name): with open(file_in_name, \'rb\') as file: huffman_tree, byte_array = pickle.load(file) bit_string = \\"\\" for byte in byte_array: bit_string += \\"{0:08b}\\".format(byte) padded_info = bit_string[:8] extra_padding = int(padded_info, 2) bit_string = bit_string[8:] encoded_data = bit_string[:-extra_padding] decoded_data = [] current_node = huffman_tree for bit in encoded_data: if bit == \\"0\\": current_node = current_node.left else: current_node = current_node.right if current_node.sign is not None: decoded_data.append(current_node.sign) current_node = huffman_tree with open(file_out_name, \'wb\') as file: file.write(bytes(decoded_data))"},{"question":"You are required to implement a **MinStack** which extends the functionality of a standard stack. The MinStack should support push, pop, peek, and is_empty operations in addition to providing a **get_min()** operation that gets the smallest element present in the stack in O(1) time. You need to implement this with an array-based stack and a linked list-based stack. Use the provided abstract class and the implementations of `ArrayStack` and `LinkedListStack` as a starting point. # Function Signature: ```python class MinArrayStack(ArrayStack): def __init__(self, size=10): # Initialize your MinStack with the given size. pass def push(self, value): # Override the push method to keep track of the minimum value. pass def pop(self): # Override the pop method to maintain the minimum value when an element is removed. pass def get_min(self): # Return the minimum value in the stack. pass class MinLinkedListStack(LinkedListStack): def __init__(self): # Initialize your MinStack. pass def push(self, value): # Override the push method to keep track of the minimum value. pass def pop(self): # Override the pop method to maintain the minimum value when an element is removed. pass def get_min(self): # Return the minimum value in the stack. pass ``` # Input: - **No direct input**: instead, you will make calls to respective stack operations. # Output: - The expected output is based on the operations performed on the stack: - For `get_min()`, return the minimum value from the stack. # Constraints: 1. All operations (push, pop, get_min, etc.) must be completed in constant time, O(1). 2. The stack will contain only integer values. 3. Stack size is guaranteed to be large enough to accommodate all pushes in provided test cases. # Example Usage: ```python # Example of using the MinArrayStack stack = MinArrayStack() stack.push(3) stack.push(5) print(stack.get_min()) # Output: 3 stack.push(2) stack.push(1) print(stack.get_min()) # Output: 1 stack.pop() print(stack.get_min()) # Output: 2 stack.pop() print(stack.peek()) # Output: 5 # Example of using the MinLinkedListStack stack = MinLinkedListStack() stack.push(3) stack.push(5) print(stack.get_min()) # Output: 3 stack.push(2) stack.push(1) print(stack.get_min()) # Output: 1 stack.pop() print(stack.get_min()) # Output: 2 stack.pop() print(stack.peek()) # Output: 5 ``` # Notes: - You must ensure the `get_min` operation runs in O(1) time. - You can use additional data structures if needed to track the minimum value efficienctly.","solution":"class ArrayStack: def __init__(self, size=10): self.stack = [] self.size = size def push(self, value): if len(self.stack) < self.size: self.stack.append(value) else: raise OverflowError(\\"Stack overflow\\") def pop(self): if self.stack: return self.stack.pop() else: raise IndexError(\\"Pop from empty stack\\") def peek(self): if self.stack: return self.stack[-1] else: raise IndexError(\\"Peek from empty stack\\") def is_empty(self): return len(self.stack) == 0 class LinkedListStack: class Node: def __init__(self, value): self.value = value self.next = None def __init__(self): self.head = None def push(self, value): new_node = self.Node(value) new_node.next = self.head self.head = new_node def pop(self): if self.head: value = self.head.value self.head = self.head.next return value else: raise IndexError(\\"Pop from empty stack\\") def peek(self): if self.head: return self.head.value else: raise IndexError(\\"Peek from empty stack\\") def is_empty(self): return self.head is None class MinArrayStack(ArrayStack): def __init__(self, size=10): super().__init__(size) self.min_stack = [] def push(self, value): super().push(value) if not self.min_stack or value <= self.min_stack[-1]: self.min_stack.append(value) def pop(self): value = super().pop() if value == self.min_stack[-1]: self.min_stack.pop() return value def get_min(self): if not self.min_stack: raise IndexError(\\"Get_min from empty stack\\") return self.min_stack[-1] class MinLinkedListStack(LinkedListStack): def __init__(self): super().__init__() self.min_stack = LinkedListStack() def push(self, value): super().push(value) if self.min_stack.is_empty() or value <= self.min_stack.peek(): self.min_stack.push(value) def pop(self): value = super().pop() if value == self.min_stack.peek(): self.min_stack.pop() return value def get_min(self): if self.min_stack.is_empty(): raise IndexError(\\"Get_min from empty stack\\") return self.min_stack.peek()"},{"question":"You are asked to implement the binomial coefficient function using an iterative approach to avoid the limitations of recursive call stack overflow for large values. The binomial coefficient ( C(n,k) ) is a fundamental combinatorial function frequently used in statistics and probability. Function Signature: ```python def iterative_binomial_coefficient(n: int, k: int) -> int: pass ``` Input: - `n` (integer): The size of the set (1 ≤ n ≤ 1000). - `k` (integer): The size of the subset (0 ≤ k ≤ n). Output: - An integer representing the binomial coefficient ( C(n,k) ). Example: ```python # Example 1 print(iterative_binomial_coefficient(5, 0)) # Output: 1 # Example 2 print(iterative_binomial_coefficient(8, 2)) # Output: 28 # Example 3 print(iterative_binomial_coefficient(500, 300)) ``` Constraints: 1. Ensure the function executes efficiently for the given range constraints. 2. The implementation should be iterative to counter recursive depth and performance issues. # Notes: - The function should handle invalid inputs gracefully where `k > n` by raising a `ValueError`. - The function should handle large integer values correctly, leveraging Python\'s arbitrary-precision arithmetic.","solution":"def iterative_binomial_coefficient(n: int, k: int) -> int: if k > n: raise ValueError(\\"k should not be greater than n\\") if k == 0 or k == n: return 1 k = min(k, n - k) # Take advantage of symmetry properties c = 1 for i in range(k): c = c * (n - i) // (i + 1) return c"},{"question":"<|Analysis Begin|> # Algorithm Analysis: Cholesky Matrix Decomposition Core Identification * **Algorithm/Data Structure**: Cholesky matrix decomposition. * **Type**: Numerical algorithm for matrix factorization. * **Main Purpose**: Decompose a Hermitian positive-definite matrix ( A ) into lower triangular matrix ( V ) such that ( V cdot V^T = A ). Complexity * **Time Complexity**: ( O(n^3) ) - Each iteration requires summing up to ( n ) elements and multiplication of up to ( n ) elements. * **Space Complexity**: ( O(n^2) ) - For storing the lower triangular matrix. Principles 1. **Initialization**: Create a zero matrix ( V ) of the same dimension as ( A ). 2. **Decomposition**: * For each diagonal and lower-triagonal element ( V[i][j] ): * Calculate cumulative sums required for the diagonal element. * Update diagonal and non-diagonal elements accordingly. Characteristics & Applications * **Properties**: - Applies to Hermitian (symmetric if real numbers) and positive-definite matrices. - Produces a lower triangular matrix ( V ). - ( V ) can be used to solve systems of linear equations efficiently. * **Common Use Cases**: - Solutions of linear systems ( Ax = b ). - Matrix inversion and determinants for positive-definite matrices. - Applied in optimization problems, including least squares. * **Strengths/Limitations**: - **Strengths**: Simplifies solving linear systems and performing various matrix operations for specific matrix types. - **Limitations**: Only applicable to positive-definite matrices. Fails for indefinite or singular matrices. Implementation Challenges * **Edge Cases**: - Non-square matrices. - Matrices with non-positive-definite property (leading to non-positive diagonal elements in decomposition). * **Performance Bottlenecks**: - Recursive calculations for sum of squares might be computationally intensive for larger matrices. * **Error Scenarios**: - Negative or zero diagonal elements leading to non-real matrix entries. * **Optimization Points**: - Parallelizing summation computations. - Early termination if non-positive elements are encountered. <|Analysis End|> <|Question Begin|> # Question: Cholesky Decomposition Verification Hermitian positive-definite matrices have unique properties allowing their decomposition into a lower triangular matrix times its conjugate transpose. Given a Hermitian matrix ( M ), write a function `cholesky_decomposition` that computes and returns its Cholesky decomposition into matrix ( V ) such that ( M = V cdot V^T ). Implementation Write and implement the `cholesky_decomposition` function that adheres to the following requirements: # Input * A Hermitian positive-definite matrix `M` with dimensions ( n times n ). - Format: List[List[float]] # Output * Returns the resulting lower triangular matrix `V`. - Format: List[List[float]] * If `M` is not positive-definite or is not square, return `None`. # Constraints 1. ( 1 le n le 1000 ) 2. Elements of `M` range from ( -10^3 ) to ( 10^3 ). # Example ```python def cholesky_decomposition(M): # Your implementation here # Input M = [ [ 4, 12, -16], [12, 37, -43], [-16, -43, 98] ] # Output # Expected V # [ # [2.0, 0.0, 0.0], # [6.0, 1.0, 0.0], # [-8.0, 5.0, 3.0] # ] result = cholesky_decomposition(M) print(result) ``` Analyze the provided example and constraints. Implement the function ensuring it efficiently handles input size and edge cases.","solution":"def cholesky_decomposition(M): import math n = len(M) # Check if M is a square matrix if any(len(row) != n for row in M): return None # Initialize the resulting lower triangular matrix with zeros V = [[0.0] * n for _ in range(n)] # Perform the Cholesky decomposition for i in range(n): for j in range(i + 1): sum_val = sum(V[i][k] * V[j][k] for k in range(j)) if i == j: # Diagonal elements if M[i][i] - sum_val <= 0: return None # M is not positive-definite V[i][j] = math.sqrt(M[i][i] - sum_val) else: # Non-diagonal elements if V[j][j] == 0: return None V[i][j] = (M[i][j] - sum_val) / V[j][j] return V"},{"question":"You are tasked with implementing a function to determine if there is a path between two nodes in a directed graph. This graph can have any number of vertices and edges, and may include self-loops and disconnected components. # Function Signature ```python def is_path(graph, source, target) -> bool: Determines if there is a path from `source` to `target` in the given graph. :param graph: A dictionary where keys are nodes, and values are lists of adjacent nodes. :param source: The starting node. :param target: The target node. :return: True if a path exists from `source` to `target`, False otherwise. ``` # Input - `graph`: A dictionary representing the directed graph, where keys are integer node identifiers and values are lists of adjacent nodes (`dict[int, List[int]]`). Each node may have zero or more outgoing edges. - `source` (int): The starting node. - `target` (int): The target node. # Output - Returns `True` if there is a path from `source` to `target` in the graph, `False` otherwise. # Constraints - The graph can have up to 10^4 nodes and 10^5 edges. - Nodes are represented as integers [0, 10^4 - 1]. - There could be isolated nodes with no outgoing or incoming edges. - `source` and `target` are valid nodes in the graph. # Example ```python graph = { 0: [1, 2], 1: [2], 2: [0, 3], 3: [3] } assert is_path(graph, 0, 3) == True assert is_path(graph, 3, 1) == False assert is_path(graph, 2, 1) == True assert is_path(graph, 0, 4) == False # Node 4 doesn\'t exist in the graph ``` # Performance Requirements - Your solution should efficiently handle the constraints, avoiding deep recursion issues and unnecessary computations. # Notes - You should handle graphs that might contain cycles and disconnected components. - Be careful with cases where `source` is equal to `target`.","solution":"def is_path(graph, source, target) -> bool: Determines if there is a path from `source` to `target` in the given graph. :param graph: A dictionary where keys are nodes, and values are lists of adjacent nodes. :param source: The starting node. :param target: The target node. :return: True if a path exists from `source` to `target`, False otherwise. visited = set() stack = [source] while stack: node = stack.pop() if node == target: return True if node not in visited: visited.add(node) stack.extend(graph.get(node, [])) return False"},{"question":"Scenario You are implementing a system to manage balanced binary search trees to ensure efficient operations such as insertion, deletion, and lookup. One crucial check you need to perform regularly is to ensure that the tree remains height-balanced. Task Write a function `is_balanced(root)` that accepts the root of a binary tree and returns `True` if the tree is balanced, and `False` otherwise. A binary tree is said to be height-balanced if the depth of the two subtrees of every node never differs by more than one. Input and Output Format * **Input**: - `root` (TreeNode): A reference to the root node of the binary tree. * **Output**: - A boolean value `True` if the tree is height-balanced, otherwise `False`. Constraints * A binary tree can have a maximum of (10^4) nodes. * Values in nodes are unique and integers. Performance Requirements * The function should run in O(N) time complexity, where N is the number of nodes in the tree. * The space complexity should be O(H), where H is the height of the tree. Example ```python # Example 1: # Input: root = [3, 9, 20, None, None, 15, 7] # Output: True # Example 2: # Input: root = [1, 2, 2, 3, 3, None, None, 4, 4] # Output: False ```","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_balanced(root): Returns True if the binary tree with the given root is height-balanced, otherwise returns False. def check_balance(node): if not node: return 0, True left_height, is_left_balanced = check_balance(node.left) right_height, is_right_balanced = check_balance(node.right) current_balance = abs(left_height - right_height) <= 1 current_height = 1 + max(left_height, right_height) is_current_balanced = is_left_balanced and is_right_balanced and current_balance return current_height, is_current_balanced _, is_bal = check_balance(root) return is_bal"},{"question":"**Context**: You are working with a calculator application that can transform a string of digits by inserting binary operators to form valid mathematical expressions. Your task is to implement a function that generates all such expressions that evaluate to a given target value. **Problem Definition:** Write a function `generate_expressions` to achieve the following: **Function Signature**: ```python def generate_expressions(digits: str, target: int) -> List[str]: :param digits: A string containing only digits (0-9). :param target: An integer representing the target value. :return: A list of strings representing valid expressions that evaluate to the target value. ``` **Input**: * `digits` (string): A non-empty string containing only digits from \'0\' to \'9\'. * `target` (integer): The target value that the expressions should evaluate to. **Output**: * A list of strings where each string is a valid mathematical expression formed by inserting binary operators (+, -, *) between the digits of the input string. These expressions must evaluate to the target value. **Constraints**: * The input string will have a length between 1 and 12. * The target value is within the range of a standard 32-bit integer. **Examples**: ```python generate_expressions(\\"123\\", 6) -> [\\"1+2+3\\", \\"1*2*3\\"] generate_expressions(\\"232\\", 8) -> [\\"2*3+2\\", \\"2+3*2\\"] generate_expressions(\\"105\\", 5) -> [\\"1*0+5\\",\\"10-5\\"] generate_expressions(\\"00\\", 0) -> [\\"0+0\\", \\"0-0\\", \\"0*0\\"] generate_expressions(\\"3456237490\\", 9191) -> [] ``` **Submission Requirements**: * Your solution should handle leading zeros in the input correctly. * The function should return the expressions in lexicographical order. * Ensure the implementation is efficient enough to handle the upper limit of the input size. **Performance Considerations**: * Avoid excessive recursion depth by optimizing the recursive calls when possible. * Consider potential early termination conditions to enhance efficiency.","solution":"from typing import List def generate_expressions(digits: str, target: int) -> List[str]: def helper(pos, expr, val, last): if pos == len(digits): if val == target: result.append(expr) return for i in range(pos, len(digits)): if i != pos and digits[pos] == \'0\': # Skip leading zero number break num_str = digits[pos:i + 1] num = int(num_str) if pos == 0: helper(i + 1, num_str, num, num) else: helper(i + 1, expr + \\"+\\" + num_str, val + num, num) helper(i + 1, expr + \\"-\\" + num_str, val - num, -num) helper(i + 1, expr + \\"*\\" + num_str, val - last + last * num, last * num) result = [] helper(0, \\"\\", 0, 0) return result"},{"question":"# Question: Find the Unique Number You are given an array of integers where every element appears three times except for one, which appears exactly once. Your task is to find that single unique number. Your solution should have a linear runtime complexity and should not use any additional memory beyond the inherent constants. Input - A list of integers `nums` where every element appears three times except for one which appears exactly once. - The size of the list is guaranteed to be of the form 3n + 1. Output - Return the unique integer that only appears once. Example ```python find_unique_number([2, 2, 3, 2]) # Output: 3 find_unique_number([0, 1, 0, 1, 0, 1, 99]) # Output: 99 ``` Constraints - The algorithm should have a linear time complexity O(n). - Extra space usage should be constant O(1). Guidelines 1. Consider how bit manipulation could be used to determine the unique number, based on how bits aggregate across multiple appearances. 2. Ensure to handle all potential edge cases as described in the analysis. 3. Do not use additional memory like hash maps or extra lists. ```python def find_unique_number(nums): ones, twos = 0, 0 for num in nums: ones = (ones ^ num) & ~twos twos = (twos ^ num) & ~ones return ones # Test your implementation against the provided examples and additional cases. ```","solution":"def find_unique_number(nums): Find the element in the list that appears exactly once while all other elements appear exactly three times. ones, twos = 0, 0 for num in nums: ones = (ones ^ num) & ~twos twos = (twos ^ num) & ~ones return ones"},{"question":"You are tasked with implementing an algorithm to find the longest common prefix (LCP) among a given array of strings. The assessment aims to evaluate your understanding of string processing and efficiency analysis using different strategies to solve the problem. Function Signature ```python def longest_common_prefix(arr: List[str]) -> str: This function should take a list of strings and return the longest common prefix string. Parameters: arr (List[str]): A list of strings. Returns: str: The longest common prefix. If no common prefix exists, return an empty string. ``` # Constraints: - The number of strings (1 leq |arr| leq 200) - The length of each string (0 leq |s| leq 200) - All given strings contain only lowercase English letters. # Performance Requirements: - Optimize the solution to handle the maximum input size efficiently while minimizing the space complexity. # Example: Input ```python print(longest_common_prefix([\\"flower\\",\\"flow\\",\\"flight\\"])) ``` Output ```python \\"fl\\" ``` Input ```python print(longest_common_prefix([\\"dog\\",\\"racecar\\",\\"car\\"])) ``` Output ```python \\"\\" ``` # Notes: - Consider edge cases such as empty input arrays, arrays with one string, or arrays with no common prefixes. - The function should be robust and perform well with respect to both time and space constraints.","solution":"from typing import List def longest_common_prefix(arr: List[str]) -> str: This function takes a list of strings and returns the longest common prefix string. Parameters: arr (List[str]): A list of strings. Returns: str: The longest common prefix. If no common prefix exists, return an empty string. if not arr: return \\"\\" # Find the shortest string in the array as potential result can\'t be longer than it shortest_str = min(arr, key=len) for i in range(len(shortest_str)): current_char = shortest_str[i] for string in arr: if string[i] != current_char: return shortest_str[:i] return shortest_str"},{"question":"You are given the root node of a binary tree. Implement both iterative and recursive functions to perform a post-order traversal of the tree. Function Signatures: ```python def postorder_iterative(root: Node) -> List[int]: pass def postorder_recursive(root: Node) -> List[int]: pass ``` Input: * `Node`: The root node of a binary tree where each node contains an integer value. Output: * List of integers representing the values of the nodes visited in a post-order traversal sequence. Examples: *Example 1:* ```python # Given binary tree: # 1 # / # 2 3 # / # 4 5 6 # postorder_iterative(Node(1)) should return [4, 5, 2, 6, 3, 1] root = Node(1, Node(2, Node(4), Node(5)), Node(3, None, Node(6))) print(postorder_iterative(root)) # Output: [4, 5, 2, 6, 3, 1] ``` *Example 2:* ```python # Given binary tree: # 10 # # 20 # postorder_recursive(Node(10)) should return [20, 10] root = Node(10, None, Node(20)) print(postorder_recursive(root)) # Output: [20, 10] ``` Constraints: * The number of nodes in the binary tree is in the range [0, 10000]. * The value of each node is a unique integer in the range [-10000, 10000]. Notes: 1. The solutions must handle all specified edge cases robustly. 2. Efficient traversal is crucial, especially for large binary trees. 3. Ensure your code is well-documented to explain the logic and handling of edge cases.","solution":"class Node: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def postorder_iterative(root: Node): Perform an iterative post-order traversal of the binary tree. :param root: Root node of the binary tree :return: List of node values in post-order if root is None: return [] stack, output = [], [] last_node_visited = None while stack or root: if root: stack.append(root) root = root.left else: peek_node = stack[-1] if peek_node.right and last_node_visited != peek_node.right: root = peek_node.right else: output.append(peek_node.val) last_node_visited = stack.pop() root = None return output def postorder_recursive(root: Node): Perform a recursive post-order traversal of the binary tree. :param root: Root node of the binary tree :return: List of node values in post-order def traverse(node, result): if node: traverse(node.left, result) traverse(node.right, result) result.append(node.val) result = [] traverse(root, result) return result"},{"question":"# Scenario: You are tasked with implementing a cash register system that calculates the number of possible ways to give change to customers using a specified set of coin denominations. To ensure efficiency, you need to implement this in a manner that accurately counts all possible combinations without redundancy. # Problem Statement: Given a target value `value`, and a list of coin denominations `coins`, write a function that returns the number of ways to make the specified amount using the provided coin denominations. The order of coins does not matter. Write a function `count(coins, value)` that will: - Take a parameter `coins` which is a list of integers representing the denominations of coins available. - Take a parameter `value` which is a single integer representing the target value you want to obtain. - Return an integer representing the number of ways to make change for the target value using the given coin denominations. # Input: - `coins`: A list of integers `[S1, S2, ..., Sm]` where `1 <= m <= 100` and `1 <= Si <= 100`. - `value`: A single integer `value` where `0 <= value <= 10000`. # Output: - An integer representing the number of ways to make change for the target value using the given coin denominations. # Constraints: - You have an infinite supply of each of the coin denominations. - The given coin denominations are unique and greater than 0. # Example: ```python count([1, 2, 3], 4) # Returns: 4 # Explanation: There are four ways to make change for 4 using [1, 2, 3] -> [1, 1, 1, 1], [1, 1, 2], [2, 2], and [1, 3]. count([2, 5, 3, 6], 10) # Returns: 5 # Explanation: There are five ways to make change for 10 using [2, 5, 3, 6] -> [2, 2, 2, 2, 2], [2, 2, 3, 3], [2, 2, 6], [2, 3, 5], and [5, 5]. ``` # Notes: - Ensure that your implementation is efficient, especially in terms of time and space complexity.","solution":"def count(coins, value): Calculate the number of ways to make change for a given value using the given coin denominations. Parameters: coins (list of int): List of coin denominations. value (int): The target value for which change is to be made. Returns: int: Number of ways to make change for the target value using the given coin denominations. dp = [0] * (value + 1) dp[0] = 1 # There\'s one way to create the value 0: use no coins. for coin in coins: for i in range(coin, value + 1): dp[i] += dp[i - coin] return dp[value]"},{"question":"# Question: Implement a Robust Path Resolution Function **Context**: File handling is a fundamental aspect of many programs. It\'s crucial to deal with file paths in a consistent and predictable manner, specifically when you need to ensure that all paths used in your program\'s operation are absolute paths. Absolute paths are essential for file operations because they point directly to the file within the file system, reducing ambiguity. **Task**: Write a function `resolve_path` that takes a single string argument representing a file path and returns its absolute path. The function should robustly handle various edge cases, such as the presence of user directory symbols (`~`), leading/trailing whitespace, and invalid characters. Additionally, the function should raise an appropriate exception if the input is not a valid path. **Specifications**: - The function should process the input by: 1. Stripping leading and trailing whitespace. 2. Expanding the user directory symbol (`~`) using `os.path.expanduser`. 3. Converting the relative path to an absolute path using `os.path.abspath`. 4. Handling invalid paths by raising a `ValueError` with an appropriate error message. **Input Format**: - A single string representing the file path. **Output Format**: - A single string representing the absolute file path. **Constraints**: - The input string length will be between 0 and 1000 characters. - The function should handle both relative and absolute paths. - The function should raise exceptions for invalid path cases. **Performance Requirements**: - Aim for distinct simplicity and code clarity, maintaining efficiency within the constraints. **Function Signature**: ```python def resolve_path(file: str) -> str: pass ``` **Examples**: ```python # Example 1 print(resolve_path(\\"~/documents/myfile.txt\\")) # Outputs: \\"/home/user/documents/myfile.txt\\" # Example 2 print(resolve_path(\\" documents /myfile.txt \\")) # Outputs: \\"/current/working/directory/documents/myfile.txt\\" # Example 3 try: print(resolve_path(\\"///:invalid?.txt\\")) except ValueError as e: print(e) # Outputs: \\"Invalid file path.\\" ``` Note: The exact output for these examples may vary based on the actual current working directory and user directory of the executing environment.","solution":"import os def resolve_path(file: str) -> str: Resolves a given file path into an absolute path. Parameters: file (str): The input file path Returns: str: The absolute path Raises: ValueError: If the input is not a valid path # Check for invalid paths if not file.strip(): raise ValueError(\\"Invalid file path.\\") # Strip leading and trailing whitespace file = file.strip() # Expand the user directory symbol (~) file = os.path.expanduser(file) # Convert the relative path to an absolute path abs_path = os.path.abspath(file) # Validate the absolute path (basic check for invalid characters) if any(char in abs_path for char in \'<>:\\"|?*\'): raise ValueError(\\"Invalid file path.\\") return abs_path"},{"question":"Write a function `generateParentheses(n: int) -> List[str]` that generates all combinations of well-formed parentheses, given `n` pairs of parentheses. You should focus on implementing an efficient solution using backtracking. # Detailed Requirements 1. **Function**: `generateParentheses(n: int) -> List[str]` - **Input**: A single integer `n` which is the number of pairs of parentheses. - **Output**: A list of strings where each string is a valid combination of well-formed parentheses. 2. **Constraints**: - `1 <= n <= 8` for testing computational limits within reasonable bounds. 3. **Example**: - Input: `n = 3` - Output: `[\'((()))\', \'(()())\', \'(())()\', \'()(())\', \'()()()\']` 4. **Performance**: - Ensure the solution works efficiently for `n` up to 8. # Context You are designing a tool to help developers generate valid combinations of parentheses pairs for creating templates or parsing expressions. Your function will assist in automatically generating all such combinations, ensuring valid pairing at each nested level. # Notes - The function must ensure every opening parenthesis `(` has a corresponding closing parenthesis `)`. - Care should be taken to handle edge cases such as no pairs (`n = 0`). - Consider using a recursive backtracking approach to explore all possible combinations. # Example Test Cases 1. **Test Case 1**: - Input: `n = 2` - Output: `[\'(())\', \'()()\']` 2. **Test Case 2**: - Input: `n = 4` - Output: `[\'(((())))\', \'((()()))\', \'((())())\', \'((()))()\', \'(()(()))\', \'(()()())\', \'(()())()\', \'(())(())\', \'(())()()\', \'()((()))\', \'()(()())\', \'()(())()\', \'()()(())\', \'()()()()\']`","solution":"def generateParentheses(n: int) -> list: Generates all combinations of well-formed parentheses given n pairs of parentheses. result = [] def backtrack(current, open, close): if len(current) == n * 2: result.append(current) return if open < n: backtrack(current + \\"(\\", open + 1, close) if close < open: backtrack(current + \\")\\", open, close + 1) backtrack(\\"\\", 0, 0) return result"},{"question":"# Task: Byte Conversion Robustness **Context**: In systems programming and networking applications, you may frequently need to convert between integer representations and byte arrays. Byte order (endianness) and handling large integers without overflow are crucial aspects of such tasks. **Task**: Implement robust byte conversion functions that support both little-endian and big-endian formats, capable of handling edge cases such as zero and very large integers without overflow or memory excess. # Requirements 1. **Function**: `robust_int_to_bytes_big_endian(num: int) -> bytes` 2. **Function**: `robust_int_to_bytes_little_endian(num: int) -> bytes` 3. **Function**: `robust_bytes_big_endian_to_int(bytestr: bytes) -> int` 4. **Function**: `robust_bytes_little_endian_to_int(bytestr: bytes) -> int` **Constraints**: - Functions should handle integers up to 10^18 efficiently. - Zero should correctly convert to `b\'0\'`. - Negative integers are not required to be handled. - Minimize memory allocations and ensure efficient operations. # Input Format: - `num` - Integer to be converted (0 <= num <= 10^18). - `bytestr` - Byte string to be converted back to an integer. # Output Format: - For integer to bytes conversion: A bytes object representing the integer in specified endianness. - For bytes to integer conversion: An integer equivalent of the byte string in specified endianness. # Example: ```python # Big Endian Conversion print(robust_int_to_bytes_big_endian(4294967296)) # Output: b\'x01x00x00x00x00\' print(robust_bytes_big_endian_to_int(b\'x01x00x00x00x00\')) # Output: 4294967296 # Little Endian Conversion print(robust_int_to_bytes_little_endian(4294967296)) # Output: b\'x00x00x00x00x01\' print(robust_bytes_little_endian_to_int(b\'x00x00x00x00x01\')) # Output: 4294967296 ``` Make sure your solution is optimized and handles all provided edge cases effectively.","solution":"def robust_int_to_bytes_big_endian(num: int) -> bytes: Converts an integer to bytes in big-endian format. if num == 0: return b\'0\' length = (num.bit_length() + 7) // 8 return num.to_bytes(length, \'big\') def robust_int_to_bytes_little_endian(num: int) -> bytes: Converts an integer to bytes in little-endian format. if num == 0: return b\'0\' length = (num.bit_length() + 7) // 8 return num.to_bytes(length, \'little\') def robust_bytes_big_endian_to_int(bytestr: bytes) -> int: Converts bytes in big-endian format to an integer. return int.from_bytes(bytestr, \'big\') def robust_bytes_little_endian_to_int(bytestr: bytes) -> int: Converts bytes in little-endian format to an integer. return int.from_bytes(bytestr, \'little\')"},{"question":"Given a string `num` that contains only digits (0-9) and a target integer `target`, write a function to generate all combinations of valid expressions by inserting binary operators (\'+\', \'-\', \'*\') between the digits in `num`, such that when evaluated, they equal the `target` value. Return all such possible expressions. # Function Signature ```python def generate_expressions(num: str, target: int) -> List[str]: ``` **Input** - `num` : a string consisting of digits (0-9) without any leading zeros except zero itself (1 ≤ len(num) ≤ 10). - `target` : an integer value (-2^31 ≤ target ≤ 2^31 - 1). **Output** - A list of strings where each string is a valid expression that evaluates to the target value. # Constraints - Avoid using any built-in eval functions in your solution. - Handle the order of operations correctly (multiplication before addition/subtraction). # Examples ```python assert generate_expressions(\\"123\\", 6) == [\\"1+2+3\\", \\"1*2*3\\"] assert generate_expressions(\\"232\\", 8) == [\\"2*3+2\\", \\"2+3*2\\"] assert generate_expressions(\\"105\\", 5) == [\\"1*0+5\\",\\"10-5\\"] assert generate_expressions(\\"00\\", 0) == [\\"0+0\\", \\"0-0\\", \\"0*0\\"] assert generate_expressions(\\"3456237490\\", 9191) == [] ``` # Requirements 1. Clearly handle leading zeros: \\"05\\" is not a valid integer. 2. Efficient recursion management to avoid excessive state exploration. 3. Adhere to standard operator precedence.","solution":"from typing import List def generate_expressions(num: str, target: int) -> List[str]: def backtrack(index, path, value, prev_num): if index == len(num): if value == target: result.append(path) return for i in range(index, len(num)): # Take the current number from index to i current_str = num[index:i+1] current_num = int(current_str) # Avoid numbers with leading zeros if len(current_str) > 1 and current_str[0] == \'0\': continue if index == 0: # If it\'s the first number, it cannot be preceded by any operator backtrack(i + 1, current_str, current_num, current_num) else: backtrack(i + 1, path + \'+\' + current_str, value + current_num, current_num) backtrack(i + 1, path + \'-\' + current_str, value - current_num, -current_num) backtrack(i + 1, path + \'*\' + current_str, value - prev_num + prev_num * current_num, prev_num * current_num) result = [] backtrack(0, \\"\\", 0, 0) return result"},{"question":"You are given a binary tree. Your task is to implement a function `zonal_traversal(root)` that performs a **zonal traversal** of the tree, which is a modified version of the standard level-order traversal. In a zonal traversal, the nodes are grouped into zones based on their depth from the root, but all nodes within each zone must be sorted in ascending order (by node value) before being added to the output list. Function Signature: ```python def zonal_traversal(root: TreeNode) -> List[List[int]]: pass ``` # Input: - `root`: The root node of the binary tree. Each node has the following structure: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` # Output: - Return a list of lists where each sublist contains the node values for a specific zone (level), with values sorted in ascending order. # Constraints: - The number of nodes in the tree will be in the range [0, 10^4]. - The node values will be in the range [-10^5, 10^5]. # Example: ```python # Example Tree: # 3 # / # 9 20 # / # 15 7 # TreeNode definitions root = TreeNode(3) root.left = TreeNode(9) root.right = TreeNode(20) root.right.left = TreeNode(15) root.right.right = TreeNode(7) # Function Call zonal_traversal(root) # Output [ [3], [9, 20], [7, 15] ] ``` # Note: Your implementation should efficiently handle the traversal and sorting within each zone. Ensure that the sorting operation does not degrade performance significantly.","solution":"from collections import deque from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def zonal_traversal(root: Optional[TreeNode]) -> List[List[int]]: if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) current_level = [] for _ in range(level_size): node = queue.popleft() # Dequeue element current_level.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) current_level.sort() # Sort the current level result.append(current_level) return result"},{"question":"Problem Statement: You are provided with a binary search tree (BST) and need to perform inorder traversal on it to obtain the sorted order of its elements. You will write two functions to achieve this: one using an iterative approach and another using a recursive approach. Function Definitions: 1. `inorder_iterative(root: Node) -> List[int]`: - This function performs an inorder traversal of the BST iteratively. - **Input**: The root node of the BST. - **Output**: A list of integers representing the inorder traversal of the tree. - **Constraints**: The function should handle an edge case where the tree is empty. 2. `inorder_recursive(root: Node) -> List[int]`: - This function performs an inorder traversal of the BST recursively. - **Input**: The root node of the BST. - **Output**: A list of integers representing the inorder traversal of the tree. - **Constraints**: The function should handle an edge case where the tree is empty. Example: Consider the following binary search tree: ``` 100 / 50 150 / / 25 75 125 175 ``` - **Function Call**: `inorder_iterative(n1)` - **Expected Output**: `[25, 50, 75, 100, 125, 150, 175]` - **Function Call**: `inorder_recursive(n1)` - **Expected Output**: `[25, 50, 75, 100, 125, 150, 175]` Requirements: - You must only use the space complexity required for the stack in the iterative version and the call stack in the recursive version. - The functions must work efficiently even for large trees. Write the functions `inorder_iterative` and `inorder_recursive` based on the above requirements.","solution":"class Node: def __init__(self, key: int): self.key = key self.left = None self.right = None def inorder_iterative(root: Node): result = [] stack = [] current = root while stack or current: if current: stack.append(current) current = current.left else: current = stack.pop() result.append(current.key) current = current.right return result def inorder_recursive(root: Node): def _inorder(node: Node, result: list): if node is not None: _inorder(node.left, result) result.append(node.key) _inorder(node.right, result) result = [] _inorder(root, result) return result"},{"question":"# Context You are working for a financial tech company building a sophisticated digital wallet feature. One challenge of the system is to compute the number of ways to make a specific transaction value using different denominations of virtual coins. This problem can help ensure the new feature is both efficient and correct. # Task Write a Python function that calculates the number of ways to make a given value using an infinite supply of given coin denominations. Your solution should utilize a dynamic programming approach to ensure efficiency. # Function Signature ```python def count_combinations(coins: List[int], value: int) -> int: Find the number of combinations of given coins that sum up to a given value. Args: coins (List[int]): A list of integers representing the coin denominations. value (int): The target value to make change for. Returns: int: The number of ways to make the change. ``` # Input and Output * **Input**: * `coins`: a list of integers representing the denominations of the coins (1 ≤ len(coins) ≤ 100, 1 ≤ coins[i] ≤ 10,000). * `value`: an integer representing the target value (0 ≤ value ≤ 10,000). * **Output**: * Return an integer representing the number of ways to make change for the given `value` using any combination of the given `coins`. # Example ```python assert count_combinations([1, 2, 3], 4) == 4 assert count_combinations([2, 5, 3, 6], 10) == 5 assert count_combinations([5, 10], 3) == 0 assert count_combinations([], 0) == 1 ``` # Constraints * The order of coins used does not matter. * The function must run efficiently within a reasonable time for the given constraints.","solution":"from typing import List def count_combinations(coins: List[int], value: int) -> int: Find the number of combinations of given coins that sum up to a given value. Args: coins (List[int]): A list of integers representing the coin denominations. value (int): The target value to make change for. Returns: int: The number of ways to make the change. dp = [0] * (value + 1) dp[0] = 1 for coin in coins: for i in range(coin, value + 1): dp[i] += dp[i - coin] return dp[value]"},{"question":"# Objective: Given a natural number `n`, return the nth digit in the infinite sequence of numbers \\"12345678910111213...\\". # Function Signature: ```python def find_nth_digit(n: int) -> int: ``` # Input: * An integer `n` representing the position of the digit in the concatenated sequence of natural numbers. # Output: * An integer representing the nth digit in the sequence. # Constraints: * `1 ≤ n ≤ 10^9` # Example: ```python assert find_nth_digit(3) == 3 # 1, 2, **3** assert find_nth_digit(11) == 0 # 1, 2, 3, 4, 5, 6, 7, 8, 9, 1**0** assert find_nth_digit(15) == 2 # 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, **1**, **2** ``` # Explanation: 1. **Input**: `n = 3` * The first 3 digits are `1, 2, 3`. The 3rd digit is `3`. * **Output**: `3` 2. **Input**: `n = 11` * The first 11 digits are `1, 2, 3, 4, 5, 6, 7, 8, 9, 10`. The 11th digit is `0`. * **Output**: `0` 3. **Input**: `n = 15` * The first 15 digits are `1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12`. The 15th digit is `2`. * **Output**: `2` **Note**: This task challenges students to implement a logarithmic time algorithm to efficiently compute the desired digit without explicitly constructing the concatenated sequence.","solution":"def find_nth_digit(n: int) -> int: length = 1 # current number length count = 9 # number of such digits (from 1 to 9 for length 1) start = 1 # Determine the length of the number that the nth digit is part of while n > length * count: n -= length * count length += 1 count *= 10 start *= 10 # Determine the actual number that contains the nth digit start += (n - 1) // length s = str(start) # Determine the position of the nth digit in the number return int(s[(n - 1) % length])"},{"question":"# Scenario You are asked to implement and enhance a depth-first search (DFS) algorithm for a directed graph. The goal is to improve the current implementation, ensure correctness, and handle various edge cases. # Challenge Implement the `is_reachable` method which determines whether there is a path between two given nodes in a directed graph. Enhance the existing DFS logic to correctly track visits and handle edge cases thoroughly. # Task Given a directed graph represented using an adjacency list, complete the implementation of the `Graph` class such that it correctly determines if there is a path between two nodes. ```python class Graph: def __init__(self, vertex_count): self.vertex_count = vertex_count self.graph = defaultdict(list) def add_edge(self, source, target): Adds a directed edge from source to target. self.graph[source].append(target) def dfs(self, source, target): Perform depth-first search to determine if there\'s a path from source to target. visited = [False] * self.vertex_count return self.dfs_util(visited, source, target) def dfs_util(self, visited, source, target): DFS utility function to check for a path from source to target. visited[source] = True if source == target: return True for neighbor in self.graph[source]: if not visited[neighbor]: if self.dfs_util(visited, neighbor, target): return True return False def is_reachable(self, source, target): Determine if target is reachable from source using DFS. return self.dfs(source, target) ``` # Input Format 1. `vertex_count`: An integer representing the number of vertices in the graph. 2. `edges`: A list of tuples, where each tuple (u, v) represents a directed edge from node `u` to node `v`. 3. `source`: The source node from where the path search starts. 4. `target`: The target node where the path search ends. # Output Format Return `True` if there is a path from `source` to `target`; otherwise, return `False`. # Constraints * 1 <= vertex_count <= 10^5 * 0 <= u, v < vertex_count * Multiple edges between the same nodes and self-loops are allowed. # Example ```python graph = Graph(4) graph.add_edge(0, 1) graph.add_edge(0, 2) graph.add_edge(1, 2) graph.add_edge(2, 0) graph.add_edge(2, 3) graph.add_edge(3, 3) print(graph.is_reachable(1, 3)) # Output: True print(graph.is_reachable(3, 1)) # Output: False ``` Ensure your solution handles all edge cases, optimizes for performance, and correctly returns the desired output.","solution":"from collections import defaultdict class Graph: def __init__(self, vertex_count): self.vertex_count = vertex_count self.graph = defaultdict(list) def add_edge(self, source, target): Adds a directed edge from source to target. self.graph[source].append(target) def dfs(self, source, target): Perform depth-first search to determine if there\'s a path from source to target. visited = [False] * self.vertex_count return self.dfs_util(visited, source, target) def dfs_util(self, visited, source, target): DFS utility function to check for a path from source to target. visited[source] = True if source == target: return True for neighbor in self.graph[source]: if not visited[neighbor]: if self.dfs_util(visited, neighbor, target): return True return False def is_reachable(self, source, target): Determine if target is reachable from source using DFS. if source == target: return True return self.dfs(source, target)"},{"question":"Problem Statement A database system uses a binary search tree (BST) to maintain a dynamically changing index. Developers need to retrieve the indices in sorted form frequently. You are tasked with implementing an in-order traversal function for this BST. Given a binary tree node structure and a tree, complete the in-order traversal function to return the tree\'s elements in ascending order. Input - A binary tree represented by the root node. Output - A list of integers representing the in-order traversal of the tree. Function Signature ```python def inorder(root: Node) -> list: ``` Constraints - The number of nodes in the tree can be up to (10^4). - Node values are distinct integers. - You need to handle both odd-shaped and balanced trees. Example ```python class Node: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right # Example Tree: # 4 # / # 2 5 # / # 1 3 n1 = Node(1) n2 = Node(2, n1, Node(3)) n3 = Node(5) root = Node(4, n2, n3) # Example output assert inorder(root) == [1, 2, 3, 4, 5] ``` Instructions - Implement the `inorder` function using an iterative approach avoiding recursion to handle maximum tree depth efficiently. - Consider edge cases such as an empty tree and trees with only left or right children. - Ensure the function runs efficiently within the given constraints.","solution":"class Node: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def inorder(root: Node) -> list: Perform in-order traversal of a binary search tree iteratively. :param root: The root node of the binary search tree. :return: A list of integers in ascending order. result = [] stack = [] current = root while current or stack: while current: stack.append(current) current = current.left current = stack.pop() result.append(current.val) current = current.right return result"},{"question":"# Context Imagine you\'re developing a navigation system for a robot traversing a grid. Each cell in the grid can be easily represented as a node in a binary tree, where each parent node can have up to two children corresponding to possible movements (down and right). The robot needs to list all possible paths from the starting point (root) to any endpoint (leaf). # Task Write a function `robot_paths(grid)` that takes a binary tree represented by the root of the tree and returns all the possible paths from the root to each leaf node as strings formatted \\"cell1->cell2->...->cellN\\". # Input Format - `grid`: A binary tree where each node has an integer value representing its position in the grid. # Output Format - A list of strings, each representing a path from the root to a leaf. # Constraints - Each node\'s value is a positive integer. - The tree may be imbalanced, but it does not contain cycles. - The input tree will have at most 1000 nodes. # Performance Requirements - The solution should complete in O(N) time complexity where N is the number of nodes in the binary tree. - Should handle potentially deep trees efficiently with considerations for recursion stack limits or alternative iteration mechanisms. # Example ```python # Given the binary tree: # 1 # / # 2 3 # / # 4 5 6 class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right # Construct the binary tree root = TreeNode(1) root.left = TreeNode(2, TreeNode(4), TreeNode(5)) root.right = TreeNode(3, None, TreeNode(6)) print(robot_paths(root)) # Output: [\\"1->2->4\\", \\"1->2->5\\", \\"1->3->6\\"] ```","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def robot_paths(root): def construct_paths(node, path, paths): if node: path += str(node.val) if not node.left and not node.right: # It\'s a leaf node paths.append(path) else: path += \\"->\\" construct_paths(node.left, path, paths) construct_paths(node.right, path, paths) paths = [] construct_paths(root, \\"\\", paths) return paths"},{"question":"# Scenario: You are given a maze represented as a grid. The maze has cells that are either open or blocked. You need to find if there exists a path from the top-left to the bottom-right corner of the grid. You will use graph traversal techniques to achieve this. # Problem Statement: Given a 2D grid representing a maze, implement a function to determine if there exists a path from the top-left corner (grid[0][0]) to the bottom-right corner (grid[n-1][m-1]), where both corners are open. You can only move up, down, left, or right. # Function Signature: ```python def is_path_exists(maze: List[List[int]]) -> bool: pass ``` # Input: - `maze`: A list of lists of integers where `0` represents an open cell, and `1` represents a blocked cell. - The dimensions of the maze are guaranteed to be at least 1x1. # Output: - Return a boolean indicating whether a path exists from `maze[0][0]` to `maze[n-1][m-1]`. # Constraints: - You can assume that the maze is always a valid 2D grid. - Cells adjacent to each other are the ones with a shared edge (horizontal or vertical). - If `maze[0][0]` or `maze[n-1][m-1]` is blocked (i.e., equal to 1), return `False`. # Example: ```python maze = [ [0, 1, 0, 0], [0, 1, 0, 1], [0, 0, 0, 1], [1, 1, 0, 0] ] print(is_path_exists(maze)) # Output: True maze = [ [0, 1, 1, 1], [1, 1, 0, 1], [1, 0, 0, 1], [0, 1, 0, 0] ] print(is_path_exists(maze)) # Output: False ``` You can choose to implement this using DFS or BFS and provide a clear explanation for your chosen approach. Consider edge cases such as the starting or ending cell being blocked.","solution":"from typing import List from collections import deque def is_path_exists(maze: List[List[int]]) -> bool: Determines if there exists a path from the top-left to the bottom-right of the maze. The maze is represented as a grid where 0 indicates an open cell and 1 indicates a blocked cell. if not maze or maze[0][0] == 1 or maze[-1][-1] == 1: return False n, m = len(maze), len(maze[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # right, down, left, up visited = [[False] * m for _ in range(n)] queue = deque([(0, 0)]) visited[0][0] = True while queue: x, y = queue.popleft() if x == n - 1 and y == m - 1: return True for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and maze[nx][ny] == 0 and not visited[nx][ny]: visited[nx][ny] = True queue.append((nx, ny)) return False"},{"question":"# Question You are required to implement a postfix expression evaluator using the Stack Abstract Data Type (ADT). A postfix expression, also known as Reverse Polish Notation (RPN), is a mathematical notation where every operator follows all of its operands. For example, the expression \\"3 4 + 2 * 7 /\\" corresponds to ((3 + 4) * 2) / 7. # Objectives * Implement a function `evaluate_postfix(expression: str) -> float` that evaluates the given postfix expression and returns the result as a float. # Input * `expression`: A string containing the postfix expression. Each token (operand or operator) is separated by a space. # Output * Returns the evaluated result as a float. # Constraints * The expression is well-formed and contains only integers, floats, and operators `+`, `-`, `*`, `/`. * It is guaranteed that there are no errors in the expression (e.g., division by zero or malformed expressions). # Example ```python expression = \\"3 4 + 2 * 7 /\\" assert evaluate_postfix(expression) == 2.0 expression = \\"5 1 2 + 4 * + 3 -\\" assert evaluate_postfix(expression) == 14.0 ``` Performance Requirements * The solution must use an efficient stack implementation and manage memory effectively. * Ensure all operations (push, pop, peek) maintain O(1) time complexity. # Additional Notes * Utilize the `Stack` ADT for implementing your algorithm. You may choose either `ArrayStack` or `LinkedListStack` implementation for the stack operations. * Pay attention to edge cases such as handling empty stack scenarios.","solution":"def evaluate_postfix(expression: str) -> float: Evaluates the given postfix expression and returns the result as a float. stack = [] # Tokenize the input expression by splitting on spaces tokens = expression.split() # Define operations operations = { \'+\': lambda a, b: a + b, \'-\': lambda a, b: a - b, \'*\': lambda a, b: a * b, \'/\': lambda a, b: a / b } for token in tokens: if token in operations: # Pop the top two elements from the stack b = stack.pop() a = stack.pop() # Perform the operation and push the result back on the stack result = operations[token](a, b) stack.append(result) else: # Push operand to stack (convert token to float) stack.append(float(token)) # The final result should be the only element in the stack return stack.pop()"},{"question":"# Question: Count Bit Flips to Convert Integers You are given two integers, `A` and `B`. Your task is to determine the minimal number of bits you would need to flip to convert integer `A` to integer `B`. **Function Signature**: ```python def count_flips_to_convert(a: int, b: int) -> int: ``` **Input**: - Two integers `a` and `b`. **Output**: - An integer representing the minimal number of bit flips required. **Constraints**: - (0 leq a, b leq 10^9) **Examples**: 1. Input: `a = 29`, `b = 15` - Output: `2` - Explanation: - Binary representation of `29` is `11101` - Binary representation of `15` is `01111` - Bit flips needed: change the 4th bit and the 5th bit (2 flips in total). 2. Input: `a = 0`, `b = 0` - Output: `0` - Explanation: Both numbers are the same, so no bits need to be flipped. 3. Input: `a = 1`, `b = 4` - Output: `2` - Explanation: - Binary of `1` is `0001` - Binary of `4` is `0100` - Bit flips needed: change the 1st bit and 3rd bit (2 flips in total). **Explanation**: - Use bitwise XOR to find the differing bits between `a` and `b`. - Count the number of 1s in the result to determine the number of bit flips needed. **Focus**: - Ensure your implementation is efficient. - Handle edge cases where either of the integers could be zero or both are the same. **Note**: Do not use any built-in binary conversion functions other than bitwise operations.","solution":"def count_flips_to_convert(a: int, b: int) -> int: This function returns the number of bits that need to be flipped to convert integer a to integer b. xor = a ^ b count = 0 while xor: count += xor & 1 xor >>= 1 return count"},{"question":"**String Matching with Wildcards** Given a text string and a pattern string, write a function `wildcard_search` to find all starting indices of substrings in the text that match the pattern. The pattern can contain wildcards represented by the character `?`, which matches any single character. Return the list of starting indices. You should use the Knuth-Morris-Pratt (KMP) algorithm as a basis and modify it to handle wildcards. Consider the potential edge cases and performance implications discussed in the analysis. **Input**: - text: str - The text string to search within. - pattern: str - The pattern string to search for, which may contain wildcard characters `?`. **Output**: - List[int] - The list of starting indices where the pattern matches a substring in the text. **Example**: ```python def wildcard_search(text: str, pattern: str) -> List[int]: pass print(wildcard_search(\'hello there hero!\', \'he?lo\')) # [0] print(wildcard_search(\'abcabcabcabc\', \'a?c\')) # [0, 3, 6, 9] print(wildcard_search(\'aaaa\', \'a?\')) # [0, 1, 2] ``` **Constraints**: - The text and pattern can be empty strings (handle gracefully). - The length of the text and pattern will not exceed ( 10^5 ). **Tips**: - You will need to modify the pi table construction and the search phase to account for the wildcard character `?`.","solution":"from typing import List def kmp_partial_match_table(pattern: str) -> List[int]: Generates the KMP partial match table (also known as the \\"pi\\" table). m = len(pattern) pi = [0] * m k = 0 for q in range(1, m): while k > 0 and (pattern[k] != pattern[q] and pattern[k] != \'?\' and pattern[q] != \'?\'): k = pi[k - 1] if pattern[k] == pattern[q] or pattern[k] == \'?\' or pattern[q] == \'?\': k += 1 pi[q] = k return pi def wildcard_search(text: str, pattern: str) -> List[int]: Finds all starting indices of substrings in the text that match the pattern with wildcards. n = len(text) m = len(pattern) if m == 0: return list(range(n + 1)) if n == 0: return [] if m > 0 else [0] pi = kmp_partial_match_table(pattern) q = 0 result = [] for i in range(n): while q > 0 and (pattern[q] != text[i] and pattern[q] != \'?\'): q = pi[q - 1] if pattern[q] == text[i] or pattern[q] == \'?\': q += 1 if q == m: result.append(i - m + 1) q = pi[q - 1] return result"},{"question":"Scenario The encryption system you are developing requires prime numbers for its secure encryption keys. To ensure efficiency, you need to write a function that can quickly verify if numbers generated are prime. Task Implement a function `efficient_prime_check(n: int) -> bool` that returns `True` if the given number (n) is a prime number, and `False` otherwise. The function should efficiently handle input as large as (10^9) while maintaining optimal performance. Requirements * You must optimize the function to handle large `n` within ideal time limits. * Avoid using excessive memory allocations. * Handle the following constraints: * (0 leq n leq 10^9) Output The function returns a boolean value: * `True` if (n) is prime. * `False` otherwise. Function Signature ```python def efficient_prime_check(n: int) -> bool: # Your implementation here ``` Examples ```python print(efficient_prime_check(29)) # True print(efficient_prime_check(4)) # False print(efficient_prime_check(1)) # False print(efficient_prime_check(2)) # True print(efficient_prime_check(1000000007)) # True print(efficient_prime_check(1000000000)) # False ```","solution":"import math def efficient_prime_check(n: int) -> bool: Returns True if the given number n is a prime number, and False otherwise. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True"},{"question":"# Scenario You are given the task of implementing a feature in a contact manager. The contacts are stored in a singly linked list, and you need to find the k-th to last contact when the user searches for it. This is a feature often required for user navigation within contact lists, where accessing from the end can be faster. # Problem Statement Implement a function `find_kth_to_last(head, k)` that takes the `head` of a singly linked list and an integer `k` as input, and returns the value of the k-th to last node. If k is out of bounds (larger than the list length), return `None`. Assume that the list nodes each hold a `string` value. # Input * `head` (Node): The head of the singly linked list. * `k` (int): The 0-based index indicating the k-th to last element in the list. # Output * (str or None): The value of the k-th to last node, or `None` if k is out of bounds. # Constraints * The linked list may contain between 0 and 10^6 nodes. * The value of each node in the linked list is a non-empty string. * 0 ≤ k < 10^6. # Function Signature ```python class Node: def __init__(self, val=None): self.val = val self.next = None def find_kth_to_last(head, k): pass ``` # Example ```python # Creating a linked list: A -> B -> C -> D -> E node_a = Node(\\"A\\") node_b = Node(\\"B\\") node_c = Node(\\"C\\") node_d = Node(\\"D\\") node_e = Node(\\"E\\") node_a.next = node_b node_b.next = node_c node_c.next = node_d node_d.next = node_e # Example 1 assert find_kth_to_last(node_a, 2) == \\"D\\" # Example 2 assert find_kth_to_last(node_a, 5) == None ``` # Explanation * In Example 1, the k-th to last node when k=2 is \\"D\\". Hence, the output is `\\"D\\"`. * In Example 2, k=5 is out of bounds since the list length is 5. Hence, the output is `None`. # Note Optimize your solution for both time and space complexity. The function should run in O(n) time and use O(1) extra space.","solution":"class Node: def __init__(self, val=None): self.val = val self.next = None def find_kth_to_last(head, k): Finds the k-th to last element in a singly linked list. Parameters: - head (Node): The head of the singly linked list. - k (int): The 0-based index indicating the k-th to last element. Returns: - (str or None): The value of the k-th to last node, or None if k is out of bounds. if head is None: return None slow = fast = head # Move fast k steps ahead for _ in range(k): if fast is None: return None fast = fast.next # Check if the k steps moved fast beyond the list length if fast is None: return None # Move both slow and fast until fast reaches the end while fast.next is not None: slow = slow.next fast = fast.next return slow.val"},{"question":"# Problem: Substring Search with Knuth-Morris-Pratt Context: You are developing a text-processing software suite, and one of the essential features is efficient substring search. Users will frequently search for numerous occurrences of a specific pattern within large text documents. To meet this need, you decide to implement the Knuth-Morris-Pratt (KMP) algorithm due to its efficiency in handling such operations. Task: Implement the `knuth_morris_pratt` function that takes two parameters: * A string `text` * A string `pattern` The function should return a list of starting indices where the pattern is found within the text. Input: * `text` (string): The text where the search is to be performed. * `pattern` (string): The pattern to search within the text. * 1 ≤ len(text) ≤ 10^5 * 1 ≤ len(pattern) ≤ 10^5 Output: * Return a list of integers representing the starting indices where the pattern matches the text exactly. Constraints: * The search should be case-sensitive. * Handle edge cases appropriately, such as when the pattern is longer than the text. * Performance is critical; aim for an efficient solution with linear complexity. Example: ```python >>> knuth_morris_pratt(\'ababcabcabababd\', \'ababd\') [10] >>> knuth_morris_pratt(\'hello there hero!\', \'he\') [0, 7, 12] >>> knuth_morris_pratt(\'abc\', \'d\') [] ``` Note: * Ensure your solution handles varying lengths of text and patterns efficiently. * Validate your implementation with multiple test cases, including edge cases such as empty strings or special characters.","solution":"def knuth_morris_pratt(text, pattern): Returns the starting indices of all occurrences of the pattern in the text using the KMP algorithm. def compute_lps(pattern): Computes the Longest Prefix that is also a Suffix (LPS) array for the given pattern. lps = [0] * len(pattern) length = 0 # length of the previous longest prefix suffix i = 1 while i < len(pattern): if pattern[i] == pattern[length]: length += 1 lps[i] = length i += 1 else: if length != 0: length = lps[length - 1] else: lps[i] = 0 i += 1 return lps # Edge case handling if not text or not pattern or len(pattern) > len(text): return [] lps = compute_lps(pattern) result = [] i = 0 # index for text j = 0 # index for pattern while i < len(text): if text[i] == pattern[j]: i += 1 j += 1 if j == len(pattern): result.append(i - j) j = lps[j - 1] elif i < len(text) and text[i] != pattern[j]: if j != 0: j = lps[j - 1] else: i += 1 return result"},{"question":"You are tasked with implementing a custom encoding and decoding algorithm for lists of strings. The solution must be both efficient and robust, handling various edge cases. Function Requirements: 1. **Function Name**: `encode` 1. **Input**: - `strs`: A list of strings (`List[str]`). 2. **Output**: - A single encoded string (`str`). 2. **Function Name**: `decode` 1. **Input**: - `s`: An encoded string (`str`). 2. **Output**: - A list of strings (`List[str]`). Example Usage: ```python encoded = encode([\\"hello\\", \\"world\\"]) # Expected Output: \'5:hello5:world\' decoded = decode(encoded) # Expected Output: [\'hello\', \'world\'] ``` Constraints and Considerations: - The input list `strs` may contain empty strings. - You must ensure the encoded string can be perfectly decoded back to the original list. - Avoid using any delimiters that could be present in the input strings (e.g., `:`) to avoid ambiguity. - Aim for linear time complexity both for encoding and decoding. Implement `encode` and `decode` methods based on the requirements specified above. Good luck!","solution":"def encode(strs): Encodes a list of strings to a single string. encoded_str = \\"\\".join(f\\"{len(s)}:{s}\\" for s in strs) return encoded_str def decode(s): Decodes a single string to a list of strings. decoded_list = [] i = 0 while i < len(s): j = i while s[j] != \':\': j += 1 length = int(s[i:j]) decoded_list.append(s[j + 1:j + 1 + length]) i = j + 1 + length return decoded_list"},{"question":"**Context:** You are required to design a pair of functions for encoding a list of strings into a single string and decoding that single string back into the original list of strings. This functionality is useful for transmitting a list of strings over a network, where the boundaries of each string need to be well-defined within a single string message. **Task:** Implement the `encode` and `decode` methods. 1. **Function Signature:** - `encode(strs: List[str]) -> str` - `decode(s: str) -> List[str]` 2. **Input and Output Formats:** - `encode` takes a list of strings `strs` and returns a single encoded string. - `decode` takes the encoded string `s` and returns the original list of strings. 3. **Constraints:** - Each string in the list may contain letters, digits, or other characters. - You may assume that no integer in the encoded string will be more than 100 digits long. - The encoded string should handle cases where the list contains empty strings or is itself empty. **Examples:** ```python # Example 1: strs1 = [\\"car\\", \\"bike\\", \\"plane\\"] encoded1 = encode(strs1) print(encoded1) # Expected output format could look like \\"3:car4:bike5:plane\\" decoded1 = decode(encoded1) print(decoded1) # Expected output: [\\"car\\", \\"bike\\", \\"plane\\"] # Example 2: strs2 = [\\"hello\\", \\"\\", \\"world\\"] encoded2 = encode(strs2) print(encoded2) # Expected output could look like \\"5:hello0:5:world\\" decoded2 = decode(encoded2) print(decoded2) # Expected output: [\\"hello\\", \\"\\", \\"world\\"] # Example 3: strs3 = [] encoded3 = encode(strs3) print(encoded3) # Expected output: \\"\\" decoded3 = decode(encoded3) print(decoded3) # Expected output: [] ``` **Note:** Ensure your code handles edge cases such as empty strings and lists efficiently. Pay attention to the length prefixing in the encoded string to avoid potential parsing issues during decoding.","solution":"def encode(strs): Encodes a list of strings to a single string. Args: strs: List of strings to be encoded. Returns: A single encoded string. encoded_str = \'\' for s in strs: encoded_str += f\'{len(s)}:{s}\' return encoded_str def decode(s): Decodes a single string to a list of strings. Args: s: Encoded string. Returns: Original list of strings. decoded_strs = [] i = 0 while i < len(s): # Find the position of the separator j = s.find(\':\', i) # Extract the length of the next string length = int(s[i:j]) # Extract the string decoded_strs.append(s[j + 1: j + 1 + length]) # Move to the next encoded part i = j + 1 + length return decoded_strs"},{"question":"Context You are given a task to identify \\"magic numbers\\" based on a specific definition. A magic number is defined as a number that reduces to 1 when repeatedly summing its digits until a single digit is obtained. Problem Statement Write a function `is_magic_number(n)` that determines if a given integer `n` is a magic number. Your function should return a Boolean value: `True` if the number is a magic number, `False` otherwise. Input - An integer `n` where (1 leq n leq 10^9). Output - A Boolean `True` or `False`. Constraints - Handle edge cases for very large values within the given range. - Implement the solution with optimal time and space complexity. Example ```python def is_magic_number(n): Determines if n is a magic number # Your code here print(is_magic_number(50113)) # Output: True print(is_magic_number(1234)) # Output: True print(is_magic_number(199)) # Output: True print(is_magic_number(111)) # Output: False print(is_magic_number(0)) # Output: False ``` Performance Requirements - Ensure the function runs efficiently within the provided input constraints. - The space complexity should be minimal (constant extra space usage). Hints - Consider how you might handle the summing and reduction of digits efficiently. - Think about the base cases and edge cases. - Try using mathematical properties to simplify the number of operations needed.","solution":"def is_magic_number(n): Determines if n is a magic number. A magic number is a number that reduces to 1 when repeatedly summing its digits until a single digit is obtained. if n < 1: return False while n > 9: n = sum(map(int, str(n))) return n == 1"},{"question":"# Scenario You are asked to develop a new sorting feature for a small application that manages a list of student grades. Due to limited resources, a simple in-place sorting algorithm is preferred. # Task Implement a function that sorts a list of integers using the Selection Sort algorithm. Your implementation must include a simulation mode that provides a step-by-step output of each iteration. To make it more challenging, handle an additional requirement to count the total number of comparisons made during sorting. # Requirements * **Function Name**: `enhanced_selection_sort` * **Inputs**: * `arr` (List[int]): A list of integers representing the grades. * `simulation` (Bool): A boolean flag to enable step-by-step printout. * **Output**: * The function should return a tuple `sorted_array` (List[int]) and `comparison_count` (int): The sorted array and the total number of comparisons made. * **Constraints**: * The list will have at most 1000 elements. * All elements in the list will be integers between -10^3 and 10^3. # Example ```python def enhanced_selection_sort(arr: List[int], simulation: bool = False) -> Tuple[List[int], int]: # Your implementation here # Sample Input arr = [64, 25, 12, 22, 11] simulation = True # Sample Output # iteration 0 : 64 25 12 22 11 # iteration 1 : 11 25 12 22 64 # iteration 2 : 11 12 25 22 64 # iteration 3 : 11 12 22 25 64 # iteration 4 : 11 12 22 25 64 # Result: ([11, 12, 22, 25, 64], 10) ``` # Hints: 1. Make sure to count each comparison in the inner loop. 2. Print the list after each iteration if the simulation flag is `True`. 3. Handle edge cases like empty lists and already sorted lists.","solution":"def enhanced_selection_sort(arr, simulation=False): Sorts a list of integers using the Selection Sort algorithm. Returns the sorted array and the total number of comparisons made during sorting. If simulation is True, prints the array at each iteration. n = len(arr) comparison_count = 0 for i in range(n): min_idx = i for j in range(i+1, n): comparison_count += 1 if arr[j] < arr[min_idx]: min_idx = j arr[i], arr[min_idx] = arr[min_idx], arr[i] if simulation: print(f\\"iteration {i} :\\", \' \'.join(map(str, arr))) return arr, comparison_count"},{"question":"<|Analysis Begin|> # Algorithm/Data Structure * **Name**: Interpolation Search * **Type**: Search algorithm * **Purpose**: To efficiently find the position of a target element within a uniformly distributed, sorted array. # Complexity * **Time Complexity**: * Average case: (O(log log n)) * Worst case: (O(n)) (When elements are not uniformly distributed) * **Space Complexity**: (O(1)) (In-place search algorithm) # Principles * **Key Mechanism**: Interpolation search calculates the probable position of the search key within the sorted array by estimating its position using linear interpolation. # Characteristics & Applications * **Properties**: * Requires a sorted array. * Best suited for uniformly distributed data. * Real-time adaptation of search bounds. * **Common Use Cases**: * Applications dealing with uniformly distributed keys in a sorted array, such as database indexing, telephone directories, and statistical software. * **Strengths/Limitations**: * **Strengths**: Highly efficient for uniformly distributed data, more efficient than binary search in such cases. * **Limitations**: Performance degrades to (O(n)) if the data is not uniformly distributed, which is less efficient than linear or binary searches in such scenarios. # Implementation Challenges * **Edge Cases**: * Search key is smaller or larger than all elements in the array. * Array containing duplicate elements. * Empty arrays. * **Performance Bottlenecks**: * When the array elements are skewed or not uniformly distributed, leading to linear search performance. * **Error Scenarios**: * Dividing by zero if all elements are the same. * Finding positions that are out of bounds. * **Optimization Points**: * Pre-sorting the array (if not already sorted). * Combining with binary search for non-uniformly distributed data. <|Analysis End|> <|Question Begin|> # Problem Description You are given a sorted array of integers and a target value. Write a function to perform an interpolation search on this array to find the index of the target value. The function should return the index of the target value if present in the array; otherwise, it should return -1. # Function Signature ```python def interpolation_search(array: List[int], search_key: int) -> int: ``` # Input * `array` (List[int]): A sorted list of integers in non-decreasing order. * `search_key` (int): The integer value to search in the array. # Output * Return the index (int) of `search_key` if found in `array`, otherwise return -1. # Constraints * The array is guaranteed to be sorted. * All elements in the array are integers within the range [-10^6, 10^6]. * The length of the array does not exceed 10^6. # Example ```python assert interpolation_search([-25, -12, -1, 10, 12, 15, 20, 41, 55], -1) == 2 assert interpolation_search([5, 10, 12, 14, 17, 20, 21], 55) == -1 assert interpolation_search([5, 10, 12, 14, 17, 20, 21], -5) == -1 ``` # Performance * Ensure that the implementation can handle the upper constraint limits efficiently. * Aim for average-case time complexity of (O(log log n)). # Hints Consider the edge cases in the array, such as when the search key is less than the smallest element or greater than the largest element, and create test cases to validate these scenarios.","solution":"from typing import List def interpolation_search(array: List[int], search_key: int) -> int: Perform interpolation search to find the index of search_key in array. Args: array (List[int]): A sorted list of integers. search_key (int): The integer value to search in the array. Returns: int: The index of search_key if found; otherwise, -1. low = 0 high = len(array) - 1 while low <= high and search_key >= array[low] and search_key <= array[high]: if low == high: if array[low] == search_key: return low return -1 # Estimate the position using interpolation formula pos = low + ((high - low) // (array[high] - array[low] + 1) * (search_key - array[low])) if array[pos] == search_key: return pos if array[pos] < search_key: low = pos + 1 else: high = pos - 1 return -1"},{"question":"# Special Numbers in a Range **Problem Statement**: You need to write a function that identifies all numbers in a given range `[low, high]` such that the sum of their digits raised to consecutive powers equals the number itself. For example, the number `89` satisfies this property because `8^1 + 9^2 = 89`. **Function Signature**: ```python def sum_dig_pow(low: int, high: int) -> List[int]: ``` **Input**: - `low` (int): The start of the range. - `high` (int): The end of the range. **Output**: - Return a list of integers that satisfy the special property from `low` to `high`. **Constraints**: - `0 <= low <= high <= 10^4` **Example**: ```python assert sum_dig_pow(1, 10) == [1, 2, 3, 4, 5, 6, 7, 8, 9] assert sum_dig_pow(1, 100) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 89] assert sum_dig_pow(90, 150) == [135] ``` **Notes**: - Ensure your function handles and returns an empty list when no numbers in the range satisfy the property. - Consider the performance implications if you need to extend the range beyond the provided constraints.","solution":"from typing import List def sum_dig_pow(low: int, high: int) -> List[int]: Return a list of numbers in the given range [low, high] such that the sum of their digits raised to consecutive powers equals the number itself. def is_special_number(n: int) -> bool: digits = list(map(int, str(n))) return n == sum(digit ** (i + 1) for i, digit in enumerate(digits)) return [n for n in range(low, high + 1) if is_special_number(n)]"},{"question":"# Polynomial Arithmetic Task **Objective**: Design and implement a `Polynomial` class using the `Monomial` class provided, complete with methods that correctly perform arithmetic operations between polynomials. You need to implement the following methods for the `Polynomial` class: 1. **Addition** (`__add__`): Add two polynomials. 2. **Subtraction** (`__sub__`): Subtract one polynomial from another. 3. **Multiplication** (`__mul__`): Multiply two polynomials. 4. **String Representation** (`__str__`): Display a polynomial in a human-readable format. Your implementation must handle edge cases such as operations with zero polynomials, polynomials with no variables, and combinations of polynomials and scalar values. Expected Input and Output 1. **__add__**: - **Input**: Two `Polynomial` objects. - **Output**: A new `Polynomial` object representing their sum. 2. **__sub__**: - **Input**: Two `Polynomial` objects. - **Output**: A new `Polynomial` object representing the result of subtraction. 3. **__mul__**: - **Input**: Two `Polynomial` objects. - **Output**: A new `Polynomial` object representing their product. 4. **__str__**: - **Input**: A `Polynomial` object. - **Output**: A string representing the polynomial in standard algebraic notation. Constraints * Your methods should be optimized to minimize unnecessary computations. * Handle the edge cases and invalid inputs gracefully. * Ensure that the Monomial and Polynomial objects involved in operations are properly simplified after the operations. Example Usage ```python # Assume Monomial class is already implemented above # Creating Monomials m1 = Monomial({1:1}, 2) m2 = Monomial({2:3, 1:-1}, -1) m3 = Monomial({}, 3.14) # Creating Polynomials with Monomials p1 = Polynomial([m1, m2]) p2 = Polynomial([m2, m3]) # Performing operations p3 = p1 + p2 # Polynomial addition p4 = p1 - p2 # Polynomial subtraction p5 = p1 * p2 # Polynomial multiplication print(p3) # Expected Output: \\"2a_1 + -1a_2^3a_1^-1 + -1a_2^3a_1^-1 + 3.14\\" print(p4) # Expected Output: \\"2a_1 - -1a_2^3a_1^-1 - -1a_2^3a_1^-1 - 3.14\\" print(p5) # Expected Output: \\"Actual algebraic product string\\" ```","solution":"from collections import defaultdict class Monomial: def __init__(self, exponents, coefficient): self.exponents = exponents # Dictionary representing exponents of variables self.coefficient = coefficient # Coefficient of the monomial def __eq__(self, other): return self.exponents == other.exponents and self.coefficient == other.coefficient def __add__(self, other): if self.exponents == other.exponents: return Monomial(self.exponents, self.coefficient + other.coefficient) else: raise ValueError(\\"Monomials with different exponents can\'t be added directly\\") def __sub__(self, other): if self.exponents == other.exponents: return Monomial(self.exponents, self.coefficient - other.coefficient) else: raise ValueError(\\"Monomials with different exponents can\'t be subtracted directly\\") def __mul__(self, other): new_exponents = defaultdict(int) for var, exp in self.exponents.items(): new_exponents[var] += exp for var, exp in other.exponents.items(): new_exponents[var] += exp return Monomial(new_exponents, self.coefficient * other.coefficient) def __str__(self): terms = [f\\"{self.coefficient}\\"] for var, exp in sorted(self.exponents.items()): terms.append(f\\"a_{var}^{exp}\\") return \'\'.join(terms) class Polynomial: def __init__(self, monomials=None): self.monomials = monomials or [] self.simplify() def simplify(self): combined = defaultdict(int) for m in self.monomials: key = frozenset(m.exponents.items()) combined[key] += m.coefficient self.monomials = [Monomial(dict(key), coeff) for key, coeff in combined.items() if coeff != 0] def __add__(self, other): return Polynomial(self.monomials + other.monomials) def __sub__(self, other): negated_monomials = [Monomial(m.exponents, -m.coefficient) for m in other.monomials] return Polynomial(self.monomials + negated_monomials) def __mul__(self, other): product_monomials = [] for m1 in self.monomials: for m2 in other.monomials: product_monomials.append(m1 * m2) return Polynomial(product_monomials) def __str__(self): if not self.monomials: return \\"0\\" return \' + \'.join(str(m) for m in self.monomials)"},{"question":"# Question: String Manipulation with Reversal and Palindrome Check You are tasked with creating a function that takes a string and performs two core manipulations: reversing the string and checking if it is a palindrome (a string that reads the same forward and backward). Your function must implement specifically two methods from the provided snippets: the iterative reversal and one additional method of your choice (either recursive, Pythonic, or Ultra Pythonic). Function Signature: ```python def reverse_and_check_palindrome(s: str) -> (str, bool): ``` Input: * **s**: A string consisting of lowercase and uppercase letters. The length of the string will be between 0 and 10^5. Output: * **return**: A tuple where the first element is the reversed string and the second element is a boolean indicating whether the original string is a palindrome. Constraints: * Ensure your function handles edge cases such as empty strings and single-character strings. * Aim to balance performance and readability. Performance requirements: * Your implementation should handle strings up to the maximum length within reasonable execution time and without exceeding memory limits. Example: ```python assert reverse_and_check_palindrome(\\"level\\") == (\\"level\\", True) assert reverse_and_check_palindrome(\\"abc\\") == (\\"cba\\", False) assert reverse_and_check_palindrome(\\"\\") == (\\"\\", True) assert reverse_and_check_palindrome(\\"Aba\\") == (\\"abA\\", False) ``` Notes: 1. `s[::-1]` should be avoided if `Ultra Pythonic` method is not used as one of the chosen methods. 2. For the palindrome check, the comparison should be case-sensitive. Good luck, and ensure your code is clean and well-documented.","solution":"def reverse_and_check_palindrome(s: str) -> (str, bool): Reverses the input string and checks if it is a palindrome. Parameters: s (str): The input string. Returns: (str, bool): A tuple where the first element is the reversed string and the second element is a boolean indicating whether the original string is a palindrome. # Iterative Reversal def reverse_string_iteratively(s: str) -> str: reversed_string = \'\' for char in s: reversed_string = char + reversed_string return reversed_string # Checking if the string is a palindrome def is_palindrome(s: str) -> bool: return s == reverse_string_iteratively(s) reversed_str = reverse_string_iteratively(s) palindrome_check = is_palindrome(s) return (reversed_str, palindrome_check)"},{"question":"# Binary Tree Inversion **Scenario**: In the world of binary trees, mirror images of trees have special significance. Transforming an existing binary tree into its mirror image is a common task, especially in graphics and symmetry validation applications. Task You are given a binary tree. Write a function `invert_tree(root)` that inverts the binary tree, making it a mirror image of itself. Function Signature ```python def invert_tree(root: TreeNode) -> TreeNode: ``` Input - `root`: The root node of a binary tree of type `TreeNode`. Output - The function should return the root of the inverted binary tree of type `TreeNode`. Constraints - The number of nodes in the tree is in the range [0, 100]. - The value of each node is an integer in the range [-100, 100]. Example Given the binary tree: ``` 4 / 2 7 / / 1 3 6 9 ``` Inverting the tree should result in: ``` 4 / 7 2 / / 9 6 3 1 ``` Notes - Ensure that you correctly handle edge cases such as an empty tree or a tree with only one node. - The implementation should be optimized for both time and space complexity. Testing - Test your function with trees of varying sizes and structures. - Analyze the performance and ensure no stack overflow occurs for large heights.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def invert_tree(root: TreeNode) -> TreeNode: if root is None: return None root.left, root.right = root.right, root.left # swap the left and right children invert_tree(root.left) # invert the left subtree invert_tree(root.right) # invert the right subtree return root"},{"question":"# Question: Increment Big Integer Array **Context**: You are working on a software for a financial institution that deals with very large numbers. These numbers are represented as arrays of single-digit integers, stored in big-endian order. For example, the number 123 is represented as `[1, 2, 3]`. **Problem**: Write a function `increment_large_number(digits: List[int]) -> List[int]` that increments the number by 1. Your function should return a new list representing the incremented number. **Input Format**: - A non-empty list of non-negative integers where each element is a digit (0-9). **Output Format**: - A list of non-negative integers representing the incremented number. **Constraints**: - The list length (n) can be between 1 and 10^4. - Digits are stored in big-endian order (most significant digit at the head of list). - Leading zeros do not exist in the input list except for the number 0 itself. **Examples**: ```python # Example 1 input: [1, 2, 3] output: [1, 2, 4] # Example 2 input: [4, 3, 2, 1] output: [4, 3, 2, 2] # Example 3 input: [9, 9, 9] output: [1, 0, 0, 0] # Example 4 input: [0] output: [1] ``` **Edge Cases to Consider**: - Handling of carry over, e.g., when the input has all 9s. - Correctly returning results for single-element arrays. - Efficiently processing maximum length arrays within the constraints. **Additional Notes**: - It is important to ensure that the solution performs efficiently within the time and space complexity constraints. - Avoid creating new arrays unless necessary to reduce space complexity.","solution":"from typing import List def increment_large_number(digits: List[int]) -> List[int]: Increments the large number represented as a list of digits by one and returns the new list of digits. n = len(digits) # Traverse the list from the end for i in range(n-1, -1, -1): if digits[i] < 9: digits[i] += 1 return digits else: # Set the current digit to 0 and move to the next digit digits[i] = 0 # If all digits were 9, we need an extra digit at the beginning return [1] + [0] * n"},{"question":"# Question: Minimum Number of Perfect Squares Given a positive integer `n`, write a Python function `min_num_perfect_squares(n)` that returns the smallest number of perfect squares that sum to `n`. Input - A single integer `n` where 1 ≤ n ≤ 10^4. Output - An integer between 1 and 4 representing the smallest number of perfect squares that sum to the specified number `n`. Constraints - The input number will always be a positive integer within the range specified. - Expected time complexity is O(√n) and space complexity is O(1). Example 1. For n = 9 - The perfect squares representation: (3^2), so the output should be 1. 2. For n = 10 - The perfect squares representation: (3^2 + 1^2), so the output should be 2. 3. For n = 12 - The perfect squares representation: (2^2 + 2^2 + 2^2), so the output should be 3. 4. For n = 31 - The perfect squares representation: (5^2 + 2^2 + 1^2 + 1^2), so the output should be 4. Code Template ```python import math def min_num_perfect_squares(n): Returns the smallest number of perfect squares that sum to the specified number. :param n: int, the number to be summed to using smallest number of perfect squares :return: int between 1 - 4, the minimum number of perfect squares that sum to the specified number # If the number is a perfect square then we only need 1 number. if int(math.sqrt(n))**2 == n: return 1 # Reducing the number by continually dividing by 4. while n > 0 and n % 4 == 0: n = n // 4 # If n is of the form 8b + 7. if n % 8 == 7: return 4 for i in range(1, int(math.sqrt(n)) + 1): if int(math.sqrt(n - i**2))**2 == n - i**2: return 2 return 3 # Example usage: print(min_num_perfect_squares(9)) # Output: 1 print(min_num_perfect_squares(10)) # Output: 2 print(min_num_perfect_squares(12)) # Output: 3 print(min_num_perfect_squares(31)) # Output: 4 ```","solution":"import math def min_num_perfect_squares(n): Returns the smallest number of perfect squares that sum to the specified number. :param n: int, the number to be summed to using smallest number of perfect squares :return: int between 1 - 4, the minimum number of perfect squares that sum to the specified number if int(math.sqrt(n))**2 == n: return 1 while n > 0 and n % 4 == 0: n = n // 4 if n % 8 == 7: return 4 for i in range(1, int(math.sqrt(n)) + 1): if int(math.sqrt(n - i**2))**2 == n - i**2: return 2 return 3"},{"question":"You are provided with an array of words and an array of symbols. Your task is to write a function that finds the symbol that matches inside each word. If a word matches multiple symbols, choose the one with the longest length. Then, surround the matched symbol within square brackets in the word. If no symbols match, return the word unaltered. # Function Signature ```python def match_symbol(words: List[str], symbols: List[str]) -> List[str]: ``` # Input * `words`: A list of words (strings) (e.g., `[\\"Amazon\\", \\"Microsoft\\", \\"Google\\"]`). * `symbols`: A list of symbols (strings) (e.g., `[\\"i\\", \\"Am\\", \\"cro\\", \\"Na\\", \\"le\\", \\"abc\\"]`). # Output * A list of transformed words (strings) with the matched symbol surrounded by square brackets. # Constraints * Each word and symbol length is between 1 and 100. * The total number of words is between 1 and 1000. * The total number of symbols is between 1 and 1000. * Symbols are case-sensitive. # Example ```python words = [\\"Amazon\\", \\"Microsoft\\", \\"Google\\"] symbols = [\\"i\\", \\"Am\\", \\"cro\\", \\"Na\\", \\"le\\", \\"abc\\"] Expected Output: [\\"[Am]azon\\", \\"Mi[cro]soft\\", \\"Goog[le]\\"] ``` # Notes * The function should be efficient in terms of time and space complexity. * Consider edge cases such as empty arrays and overlapping symbols. * You may choose any suitable algorithm or data structure for efficient matching.","solution":"from typing import List def match_symbol(words: List[str], symbols: List[str]) -> List[str]: sorted_symbols = sorted(symbols, key=lambda s: -len(s)) # Sort symbols by length in descending order def find_and_replace(word: str) -> str: for symbol in sorted_symbols: index = word.find(symbol) if index != -1: return word[:index] + \\"[\\" + symbol + \\"]\\" + word[index+len(symbol):] return word return [find_and_replace(word) for word in words]"},{"question":"You are given a singly linked list. Your task is to write a function that identifies the first node of a cycle in the linked list (if a cycle exists). If no cycle is present, the function should return `None`. **Function Signature**: ```python def find_cycle_start(head: Node) -> Node: # your code here ``` # Input - The function `find_cycle_start` takes a single argument, `head`, which is the head node of a singly linked list. # Output - The function should return the node where the cycle begins, or `None` if no cycle exists. # Constraints - The linked list can contain up to 10^4 nodes. - Node values are arbitrary and can be of any data type. # Performance Requirements - Time Complexity: O(n), where n is the number of nodes in the linked list. - Space Complexity: O(1). # Example 1. **Input**: A -> B -> C -> D -> E -> C (cycle) **Output**: Node with value \'C\' 2. **Input**: 1 -> 2 -> 3 -> 4 -> 5 -> 1 (cycle) **Output**: Node with value 1 3. **Input**: 1 -> 2 -> 3 -> 4 -> 5 -> None (no cycle) **Output**: None # Testing We provide a basic testing framework. Write additional tests as necessary. ```python class Node: def __init__(self, val): self.val = val self.next = None def find_cycle_start(head: Node) -> Node: # Your implementation here using Floyd\'s Tortoise and Hare Algorithm pass import unittest class TestCycleEntryPoint(unittest.TestCase): def test_cycle_present(self): head = Node(\'A\') second = Node(\'B\') third = Node(\'C\') fourth = Node(\'D\') fifth = Node(\'E\') head.next = second second.next = third third.next = fourth fourth.next = fifth fifth.next = third # creates cycle starting at \'C\' self.assertEqual(find_cycle_start(head).val, \'C\') def test_no_cycle(self): head = Node(1) head.next = Node(2) head.next.next = Node(3) self.assertIsNone(find_cycle_start(head)) def test_single_node_no_cycle(self): head = Node(1) self.assertIsNone(find_cycle_start(head)) def test_single_node_cycle(self): head = Node(1) head.next = head # single node cycle self.assertEqual(find_cycle_start(head).val, 1) if __name__ == \'__main__\': unittest.main() ```","solution":"class Node: def __init__(self, val): self.val = val self.next = None def find_cycle_start(head: Node) -> Node: Detects the beginning of the cycle in a linked list if it exists. Uses Floyd\'s Tortoise and Hare (Cycle Detection) algorithm. :param head: The head node of the linked list. :return: The node where the cycle begins, or None if no cycle exists. if not head or not head.next: return None slow = head fast = head # Detect cycle using Floyd\'s Tortoise and Hare approach while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: break # Check if there is no cycle if not fast or not fast.next: return None # Find the start of the cycle slow = head while slow != fast: slow = slow.next fast = fast.next return slow"},{"question":"You are given two strings, `original_str` and `modified_str`, which consist of only lowercase letters. String `modified_str` is generated by randomly shuffling `original_str` and adding one more letter at a random position. Your task is to write a function that finds the extra letter added in `modified_str`. Function Signature ```python def find_extra_letter(original_str: str, modified_str: str) -> str: Args: - original_str (str): original string containing lowercase letters. - modified_str (str): modified string (a shuffled version of original_str with one additional lowercase letter). Returns: - str: the extra letter added to `modified_str`. ``` Example ```python original_str = \\"abc\\" modified_str = \\"cabd\\" ``` Output: ```python \'d\' ``` Explanation The only additional letter in `modified_str` compared to `original_str` is \'d\'. Constraints - The length of `modified_str` will always be one more than the length of `original_str`. - Both strings will include only lowercase English letters. - Input strings are non-empty and contain at most 10000 characters. Requirements - Your solution should be efficient with a time complexity of O(n), where n is the length of `modified_str`. - The space complexity should be O(1). - Ensure your code handles all edge cases, including strings with just one character difference or maximum input size.","solution":"def find_extra_letter(original_str, modified_str): Finds the extra letter added to the modified_str. Parameters: - original_str (str): original string containing lowercase letters. - modified_str (str): modified string (a shuffled version of original_str with one additional lowercase letter). Returns: - str: the extra letter added to `modified_str`. # Using XOR bitwise operation to find the extra character extra_char = 0 for char in original_str: extra_char ^= ord(char) for char in modified_str: extra_char ^= ord(char) return chr(extra_char)"},{"question":"# Maximum Flow Problem in Flow Network In this task, you are required to implement the **Edmonds-Karp** algorithm to compute the maximum flow in a flow network. The implementation must demonstrate an understanding of BFS for finding augmenting paths and augmenting the flow according to the flow capacities. Function Signature ```python def edmonds_karp(capacity: List[List[int]], source: int, sink: int) -> int: pass ``` # Input * `capacity`: A two-dimensional list of integers where `capacity[i][j]` represents the capacity of the edge from node `i` to node `j`. If there is no edge, `capacity[i][j]` will be `0`. * `source`: An integer representing the source node. * `sink`: An integer representing the sink node. # Output * An integer representing the maximum flow from the source to the sink. # Constraints * All capacities are non-negative integers. * The number of nodes, `V` is `1 <= V <= 1000`. * The capacities are in the range `[0, 10^6]`. # Performance Requirements * Your function should handle networks with up to `1000` nodes efficiently. Example ```python capacity = [ [0, 16, 13, 0, 0, 0], [0, 0, 10, 12, 0, 0], [0, 4, 0, 0, 14, 0], [0, 0, 9, 0, 0, 20], [0, 0, 0, 7, 0, 4], [0, 0, 0, 0, 0, 0] ] source = 0 sink = 5 assert edmonds_karp(capacity, source, sink) == 23 ```","solution":"from collections import deque from typing import List def bfs(capacity, flow, source, sink, parent): visited = set() queue = deque([source]) visited.add(source) while queue: u = queue.popleft() for v in range(len(capacity)): if v not in visited and capacity[u][v] - flow[u][v] > 0: queue.append(v) visited.add(v) parent[v] = u if v == sink: return True return False def edmonds_karp(capacity: List[List[int]], source: int, sink: int) -> int: n = len(capacity) flow = [[0] * n for _ in range(n)] parent = [-1] * n max_flow = 0 while bfs(capacity, flow, source, sink, parent): path_flow = float(\'Inf\') s = sink while s != source: path_flow = min(path_flow, capacity[parent[s]][s] - flow[parent[s]][s]) s = parent[s] v = sink while v != source: u = parent[v] flow[u][v] += path_flow flow[v][u] -= path_flow v = parent[v] max_flow += path_flow return max_flow"},{"question":"You are required to implement a 3D extended version of the Cholesky Matrix Decomposition algorithm provided. Given a 3D symmetric positive-definite tensor ( T ), implement a function `cholesky_decomposition_3d` that computes the Cholesky Decomposition of ( T ) such that ( T = V cdot V^* ), where ( V^* ) is the conjugate transpose of ( V ). # Function Signature ```python def cholesky_decomposition_3d(T: List[List[List[float]]]) -> List[List[List[float]]]: ``` # Input * `T`: A three-dimensional tensor (a list of lists of lists) where each 2D matrix `T[k]` is a symmetric positive-definite matrix of dimension ( n times n ). # Output * Returns a three-dimensional tensor (a list of lists of lists) where each 2D matrix `V[k]` is the lower triangular matrix obtained from Cholesky Decomposition of `T[k]`. # Constraints * ( T ) contains at least one matrix and no more than 100 (1 <= k <= 100). * Each 2D matrix in ( T ) is symmetric and positive-definite. * The dimensions of each 2D matrix in ( T ) are between 1 and 50 (1 <= n <= 50). # Example ```python T = [ [[4.0, 12.0, -16.0], [12.0, 37.0, -43.0], [-16.0, -43.0, 98.0]], [[25.0, 15.0, -5.0], [15.0, 18.0, 0.0], [-5.0, 0.0, 11.0]] ] result = cholesky_decomposition_3d(T) print(result) \'\'\' [ [[2.0, 0.0, 0.0], [6.0, 1.0, 0.0], [-8.0, 5.0, 3.0]], [[5.0, 0.0, 0.0], [3.0, 3.0, 0.0], [-1.0, 1.0, 3.0]] ] \'\'\' # Performance Requirements * The solution should handle large matrices within given constraints efficiently. * Aim to maintain the general ( O(n^3) ) time complexity per 2D matrix while handling extra tensor dimension efficiently.","solution":"from typing import List def cholesky_decomposition_3d(T: List[List[List[float]]]) -> List[List[List[float]]]: import math def cholesky_decomposition(matrix): n = len(matrix) L = [[0.0] * n for _ in range(n)] for i in range(n): for j in range(i + 1): sum = matrix[i][j] for k in range(j): sum -= L[i][k] * L[j][k] if i == j: if sum <= 0.0: raise ValueError(\\"Matrix is not positive definite\\") L[i][j] = math.sqrt(sum) else: L[i][j] = sum / L[j][j] return L result = [] for matrix in T: result.append(cholesky_decomposition(matrix)) return result"},{"question":"Implement and validate a function to check if two strings are isomorphic Given two strings `s` and `t`, write a function `are_isomorphic(s, t)` that determines if they are isomorphic. Two strings are isomorphic if the characters in `s` can be replaced to get `t`. All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself. # Function Signature: ```python def are_isomorphic(s: str, t: str) -> bool: pass ``` # Input: - `s`: a string (1 ≤ length of s ≤ 5 * 10^4) - `t`: a string (1 ≤ length of t ≤ 5 * 10^4) # Output: - Return `True` if `s` and `t` are isomorphic, `False` otherwise. # Constraints: - Each string can contain ASCII characters only. - Consider all edge cases. # Examples: Example 1: ```python s = \\"egg\\" t = \\"add\\" print(are_isomorphic(s, t)) # Output: True ``` Explanation: Replace \'e\' with \'a\' and \'g\' with \'d\'. Example 2: ```python s = \\"foo\\" t = \\"bar\\" print(are_isomorphic(s, t)) # Output: False ``` Explanation: No mapping of characters can transform \'foo\' into \'bar\'. Example 3: ```python s = \\"paper\\" t = \\"title\\" print(are_isomorphic(s, t)) # Output: True ``` Explanation: Replace \'p\' with \'t\', \'a\' with \'i\', \'p\' with \'t\', \'e\' with \'l\', and \'r\' with \'e\'. Example 4: ```python s = \\"ab\\" t = \\"aa\\" print(are_isomorphic(s, t)) # Output: False ``` Explanation: \'a\' and \'b\' cannot both be mapped to \'a\'. # Notes: 1. Consider edge cases like empty strings or single character strings. 2. Pay attention to the constraint that no two characters may map to the same character. # Additional Task: Implement a custom test harness that generates diverse and comprehensive test cases to validate the function for performance and edge case handling.","solution":"def are_isomorphic(s: str, t: str) -> bool: Determine if two strings s and t are isomorphic. if len(s) != len(t): return False # Dictionaries to store the isomorphic mappings s_to_t, t_to_s = {}, {} for char_s, char_t in zip(s, t): if char_s not in s_to_t: s_to_t[char_s] = char_t if char_t not in t_to_s: t_to_s[char_t] = char_s if s_to_t[char_s] != char_t or t_to_s[char_t] != char_s: return False return True"},{"question":"You are working on an embedded system where storage and processing efficiency are critical. You need to implement an efficient compression algorithm that uses bit manipulation to compress and decompress data. Given the functions `get_bit`, `set_bit`, `clear_bit`, and `update_bit`, extend their usage to implement a function that compresses a list of binary numbers into a single integer and another to decompress the integer back into the original list of binary numbers. # Task 1. **Function to Implement**: ```python def compress_data(bin_list): Compress a list of binary numbers (represented as strings) into a single integer. Parameters: - bin_list: List of strings, where each string is a binary representation of a number. Returns: int: A single integer representing all binary numbers compressed together. pass def decompress_data(compressed_int, num_bits, list_length): Decompress an integer back into a list of binary numbers. Parameters: - compressed_int: Integer, representing the compressed binary data. - num_bits: Integer, number of bits used for each binary number in the original list. - list_length: Integer, the number of binary numbers in the original list. Returns: List of strings: The original list of binary numbers. pass ``` 2. **Input Format**: - `compress_data`: A list of binary string (e.g., [\\"101\\", \\"011\\", \\"110\\"]). - `decompress_data`: An integer, number of bits, and list length. 3. **Output Format**: - `compress_data`: Returns a single integer. - `decompress_data`: Returns a list of binary strings. 4. **Constraints**: - Each binary number in the list contains the same number of bits. - You can assume that total number of bits of all the numbers to be compressed is less than or equal to the bit length of an integer. # Example ```python # Example Input bin_list = [\\"101\\", \\"011\\", \\"110\\"] compressed_int = compress_data(bin_list) # Expected compressed value print(compressed_int) # A single integer representing the compressed data # Example Decompression num_bits = 3 # Each binary string is 3 bits long list_length = 3 # Original list has 3 elements decompressed_list = decompress_data(compressed_int, num_bits, list_length) # Expected Output: The original list of binary strings print(decompressed_list) # Should print [\\"101\\", \\"011\\", \\"110\\"] ``` # Requirements: - Use the given bit manipulation functions (`get_bit`, `set_bit`, `clear_bit`, `update_bit`) to implement the compression and decompression. - Ensure your implementation is efficient, leveraging bit-level operations.","solution":"def get_bit(num, bit): return (num >> bit) & 1 def set_bit(num, bit): return num | (1 << bit) def clear_bit(num, bit): return num & ~(1 << bit) def update_bit(num, bit, value): mask = ~(1 << bit) return (num & mask) | ((value & 1) << bit) def compress_data(bin_list): Compress a list of binary numbers (represented as strings) into a single integer. Parameters: - bin_list: List of strings, where each string is a binary representation of a number. Returns: int: A single integer representing all binary numbers compressed together. compressed = 0 bit_position = 0 for binary in bin_list: for bit in binary[::-1]: if bit == \'1\': compressed = set_bit(compressed, bit_position) else: compressed = clear_bit(compressed, bit_position) bit_position += 1 return compressed def decompress_data(compressed_int, num_bits, list_length): Decompress an integer back into a list of binary numbers. Parameters: - compressed_int: Integer, representing the compressed binary data. - num_bits: Integer, number of bits used for each binary number in the original list. - list_length: Integer, the number of binary numbers in the original list. Returns: List of strings: The original list of binary numbers. bin_list = [] for _ in range(list_length): binary = [] for i in range(num_bits): bit = get_bit(compressed_int, i) binary.append(str(bit)) bin_list.append(\'\'.join(binary[::-1])) compressed_int >>= num_bits return bin_list"},{"question":"# Question: Find All Unique N-Sum Tuples Given an array of integers, write a function that finds all unique n-tuples in the array that sum up to a given target value. Extend the base 2-sum logic to handle arbitrary n using recursion. Function Signature ```python def find_n_sum_tuples(n: int, nums: List[int], target: int) -> List[List[int]]: pass ``` Input - **n**: An integer representing the number of elements to sum (n > 1). - **nums**: A list of integers. - **target**: An integer representing the target sum. Output - Return a list of lists, where each inner list represents an n-tuple that sums up to the target. Ensure that all returned n-tuples are unique. Constraints - Ensure to handle edge cases such as: - `n` is greater than the length of `nums`. - `nums` containing duplicate elements. - Target sum is zero. - Time complexity requirements: Aim for efficiency using recursion for dividing problems and two-pointer technique for the base case. Example ```python # Example 1 find_n_sum_tuples(4, [1, 0, -1, 0, -2, 2], 0) # Expected Output: [[-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1]] # Example 2 find_n_sum_tuples(2, [-3, 0, -2, 1, 2, 3, -9, 8], -5) # Expected Output: [[-9, 4]] # Example 3 find_n_sum_tuples(3, [0, 0, 0, 0], 0) # Expected Output: [[0, 0, 0]] ``` **Notes**: - Ensure the function is general enough to handle `n` greater than 2. - Utilize sorting and other key optimizations attained from the provided analysis. - Return the results in a consistent and sorted order to ensure uniqueness.","solution":"from typing import List def find_n_sum_tuples(n: int, nums: List[int], target: int) -> List[List[int]]: def n_sum_recursive(nums: List[int], target: int, n: int, current_path: List[int], results: List[List[int]]): if len(nums) < n or n < 2: return if n == 2: # Base case for two sum problem left, right = 0, len(nums) - 1 while left < right: total = nums[left] + nums[right] if total == target: results.append(current_path + [nums[left], nums[right]]) left += 1 right -= 1 while left < right and nums[left] == nums[left - 1]: left += 1 while left < right and nums[right] == nums[right + 1]: right -= 1 elif total < target: left += 1 else: right -= 1 else: for i in range(len(nums) - n + 1): if i == 0 or nums[i - 1] != nums[i]: n_sum_recursive(nums[i + 1:], target - nums[i], n - 1, current_path + [nums[i]], results) nums.sort() results = [] n_sum_recursive(nums, target, n, [], results) return results"},{"question":"# Objective Write a function that determines the number of decimal digits in a given integer. Your solution should be efficient and handle various edge cases. # Function Signature ```python def count_digits(n: int) -> int: ``` # Input * `n`: An integer value where `-10^18 < n < 10^18`. # Output * Return an integer representing the number of digits in the given integer. # Examples ```python assert count_digits(12345) == 5 assert count_digits(-9876) == 4 assert count_digits(0) == 1 assert count_digits(100000) == 6 assert count_digits(-1000000000) == 10 ``` # Constraints * Your function should execute in constant time, O(1). * The space complexity should also be constant, O(1). # Performance Requirements * Your function should handle both positive and negative integers correctly. * Ensure that the edge case where `n` is `0` returns `1` as it contains one digit. **Context**: This problem is typical in scenarios where digit-based manipulation or constraints are involved. Examples include formatting numbers for display, validating input length, and various problems in number theory where the digit-length of numbers needs to be computed efficiently.","solution":"def count_digits(n: int) -> int: Returns the number of decimal digits in the given integer. Parameters: n (int): The integer to count the digits of. Can be negative or positive. Returns: int: The number of digits in the integer. return len(str(abs(n)))"},{"question":"Matrix Inversion Context Matrix inversion is a fundamental tool in various areas of mathematics, computer science, and engineering. It involves finding a matrix that, when multiplied by the original matrix, yields the identity matrix. This process is essential for solving linear systems, computational graphics, cryptographic algorithms, and more. Given an n x n matrix, your task is to write a function to compute its inverse. Specifically, the function must handle the following scenarios: invalid matrices, non-square matrices, singular matrices (non-invertible), and standard n x n matrices. Task Implement the `invert_matrix` function to compute the inverse of a given n x n matrix. Function Signature ```python def invert_matrix(m: List[List[float]]) -> List[List[float]]: pass ``` Input - `m`: A list of lists representing an n x n matrix, where each element is a floating-point number. Output - A list of lists representing the inverse matrix if it exists. - The function should return `-1`: if the input is not a valid matrix. - The function should return `-2`: if the matrix is not square. - The function should return `-3`: if the matrix size is less than 2. - The function should return `-4`: if the matrix is singular (non-invertible). Constraints 1. The input matrix `m` will always contain floating-point numbers. 2. The size of the matrix `n` will be at most 10 for this assessment. Example Scenarios ```python # Example 1 matrix_1 = [[1, 2], [3, 4]] print(invert_matrix(matrix_1)) # Expected output: [[-2.0, 1.0], [1.5, -0.5]] # Example 2 matrix_2 = [[1, 2], [2, 4]] print(invert_matrix(matrix_2)) # Expected output: -4 (singular matrix) # Example 3 matrix_3 = [1, 2, 3] print(invert_matrix(matrix_3)) # Expected output: -1 (not a valid matrix) # Example 4 matrix_4 = [[1, 2, 3], [4, 5, 6]] print(invert_matrix(matrix_4)) # Expected output: -2 (not a square matrix) ``` Notes - Ensure your implementation is efficient and handles all specified edge cases. - Clearly handle all invalid input scenarios as per the instructions. - Optimize your solution to the best of your ability within the given constraints.","solution":"from typing import List import numpy as np def invert_matrix(m: List[List[float]]) -> List[List[float]]: try: # Check if `m` is a list of lists and not an empty list if not all(isinstance(row, list) for row in m) or len(m) == 0: return -1 # Check if all rows have the same length (for a square matrix) row_len = len(m[0]) if any(len(row) != row_len for row in m): return -2 # Check if the matrix is square if len(m) != row_len: return -2 # Check if the matrix size is less than 2 n = len(m) if n < 2: return -3 matrix = np.array(m) # Check if the matrix is singular if np.linalg.det(matrix) == 0: return -4 # Compute the inverse inv_matrix = np.linalg.inv(matrix) # Convert result back to list of lists return inv_matrix.tolist() except: return -1"},{"question":"# Problem: Iterative and Recursive Preorder Traversal of a Binary Tree You are given a binary tree and need to implement both iterative and recursive functions for preorder traversal. Preorder traversal visits the nodes of a tree in the \'root-left-right\' order. Your task is to write two functions: 1. **Iterative Preorder Traversal** ```python def preorder_iterative(root: Node) -> List[int]: ``` 2. **Recursive Preorder Traversal** ```python def preorder_recursive(root: Node) -> List[int]: ``` Input * The input is the root node of the binary tree, which can be `None` (representing an empty tree) or a tree with nodes. * Each node has the structure `Node(val, left, right)` where `val` is an integer, and `left` and `right` are child nodes (which can be `None`). Output * Both functions should return a list of integers representing the preorder traversal of the tree. Example ```python # Example Tree # 1 # / # 2 3 # / # 4 5 # Input root = Node(1, Node(2, Node(4), Node(5)), Node(3)) # Expected Output assert preorder_iterative(root) == [1, 2, 4, 5, 3] assert preorder_recursive(root) == [1, 2, 4, 5, 3] ``` Constraints * It is guaranteed that the tree does not contain any cycles. Requirements * The time complexity of both implementation should be `O(n)`, where `n` is the number of nodes in the tree. * The space complexity for the iterative approach should be `O(n)` in the worst case. * The space complexity for the recursive approach should also be `O(n)` due to the call stack.","solution":"from typing import List, Optional class Node: def __init__(self, val: int, left: Optional[\'Node\'] = None, right: Optional[\'Node\'] = None): self.val = val self.left = left self.right = right def preorder_iterative(root: Optional[Node]) -> List[int]: if not root: return [] stack, output = [root], [] while stack: node = stack.pop() if node: output.append(node.val) if node.right: stack.append(node.right) if node.left: stack.append(node.left) return output def preorder_recursive(root: Optional[Node]) -> List[int]: def helper(node: Optional[Node], result: List[int]): if node: result.append(node.val) helper(node.left, result) helper(node.right, result) result = [] helper(root, result) return result"},{"question":"You are tasked with writing a function that encrypts a given string using Caesar\'s Cipher, but with additional flexibility and robustness compared to the standard implementation. # Description Write a function `custom_caesar_cipher(s: str, k: int) -> str` that performs the following: 1. Encrypts the input string `s` by shifting each letter by `k` positions in the alphabet. 2. If `k` is negative, shift the letters to the left. 3. Non-alphabetic characters should remain unchanged. 4. The function should handle arbitrarily large positive and negative values of `k`. # Function Signature ```python def custom_caesar_cipher(s: str, k: int) -> str: pass ``` # Input - `s` (1 <= len(s) <= 10^5): The input string consisting of alphabetical and non-alphabetical characters. - `k` (-10^9 <= k <= 10^9): The integer by which to shift the characters. # Output - Returns the encrypted string. # Constraints 1. The function should be efficient and work within the given constraints. 2. Handle both uppercase and lowercase letters appropriately by shifting them within their respective ranges. 3. Ensure non-alphabetic characters remain unchanged. # Example ```python assert custom_caesar_cipher(\\"Hello, World!\\", 3) == \\"Khoor, Zruog!\\" assert custom_caesar_cipher(\\"Hello, World!\\", -3) == \\"Ebiil, Tloia!\\" assert custom_caesar_cipher(\\"xyz\\", 3) == \\"abc\\" assert custom_caesar_cipher(\\"abc\\", -3) == \\"xyz\\" assert custom_caesar_cipher(\\"123\\", 4) == \\"123\\" ``` # Extended Requirements 1. Optimize the handling of large shift values by reducing `k` modulo 26 to avoid unnecessary large iterations. 2. Consider edge cases where the input string might be empty.","solution":"def custom_caesar_cipher(s: str, k: int) -> str: Encrypts the input string `s` by shifting each letter by `k` positions in the alphabet. If `k` is negative, shifts the letters to the left. Non-alphabetic characters remain unchanged. Handles both uppercase and lowercase letters appropriately by shifting them within their respective ranges. result = [] k = k % 26 # Reduce k to be within the range of 0-25 for char in s: if \'a\' <= char <= \'z\': new_char = chr((ord(char) - ord(\'a\') + k) % 26 + ord(\'a\')) result.append(new_char) elif \'A\' <= char <= \'Z\': new_char = chr((ord(char) - ord(\'A\') + k) % 26 + ord(\'A\')) result.append(new_char) else: result.append(char) return \'\'.join(result)"},{"question":"**Objective**: Implement the Matrix Chain Multiplication problem using dynamic programming. # Problem Statement You are given a sequence of matrices, and you need to find the most efficient way to multiply these matrices together. The order in which matrices are multiplied can affect the performance of the matrix multiplication due to the number of scalar multiplications involved. Write a function `matrix_chain_multiplication` that takes an array `p` where the element ( p[i] ) represents the dimension of the matrix ( A_i cdot A_{i+1} ) and returns the minimum number of scalar multiplications needed to multiply the chain of matrices. Additionally, implement a function `print_optimal_order` that prints the optimal order of matrix multiplication. # Function Signature ```python def matrix_chain_multiplication(p: List[int]) -> int: pass def print_optimal_order(order: List[List[int]], i: int, j: int) -> None: pass ``` # Input * `p` - A list of integers where the i-th matrix has dimensions ( p[i-1] times p[i] ). (e.g., for 4 matrices ( A_1(10 times 30) ), ( A_2(30 times 5) ), ( A_3(5 times 60) ), ( A_4(60 times 15) ), the provided list will be [10, 30, 5, 60, 15]). # Output * The function `matrix_chain_multiplication` should return the minimum number of scalar multiplications needed. * The function `print_optimal_order` should print the optimal order in which matrices should be multiplied. # Constraints * ( 1 leq n leq 500 ), where ( n ) is the number of matrices. * Dimensions provided are positive integers. # Example ```python p = [40, 20, 30, 10, 30] # Function Calls min_operations = matrix_chain_multiplication(p) print(\\"Minimum number of multiplications is:\\", min_operations) # Expected minimum number of multiplications is: 26000 # For the print_optimal_order function order = matrix_chain_order(p)[1] # Assume matrix_chain_order gives the order matrix print_optimal_order(order, 1, len(p)-1) # Expected Output is something like: ((A1 (A2 A3)) A4) ``` # Detailed Explanation 1. The `matrix_chain_multiplication` function calculates the minimal number of multiplications to multiply a chain of matrices by leveraging dynamic programming. 2. The `print_optimal_order` function should use the order matrix (solution matrix) calculated during the dynamic programming process to print the optimal multiplication order. Provide implementation for these two functions based on the core algorithm of dynamic programming demonstrated initially. # Notes Be mindful of edge cases such as when there is only one matrix or no matrix at all.","solution":"def matrix_chain_multiplication(p): Calculate the minimum number of multiplications needed to multiply a chain of matrices. Parameters: p (List[int]): Dimensions of matrices. Returns: int: Minimum number of multiplications. n = len(p) - 1 # Number of matrices m = [[0 for _ in range(n)] for _ in range(n)] s = [[0 for _ in range(n)] for _ in range(n)] for l in range(2, n + 1): # l is the chain length for i in range(n - l + 1): j = i + l - 1 m[i][j] = float(\'inf\') for k in range(i, j): q = m[i][k] + m[k + 1][j] + p[i] * p[k + 1] * p[j + 1] if q < m[i][j]: m[i][j] = q s[i][j] = k return m[0][n - 1], s def print_optimal_order(order, i, j): Prints the optimal order of matrix multiplication. Parameters: order (List[List[int]]): A 2D list containing the optimal split points. i (int): Starting matrix index. j (int): Ending matrix index. if i == j: print(f\\"A{i + 1}\\", end=\\"\\") else: print(\\"(\\", end=\\"\\") print_optimal_order(order, i, order[i][j]) print_optimal_order(order, order[i][j] + 1, j) print(\\")\\", end=\\"\\")"},{"question":"You work for a company that needs to analyze numerous binary datasets to determine certain properties of the systems represented by these datasets. One of the critical properties is the Hamming weight, which is the total number of \'1\' bits present in the binary representation of a given integer. Implement a function that takes an unsigned integer and returns the Hamming weight of that integer using Brian Kernighan\'s Algorithm. Your solution should avoid direct iteration over all the bits of the number, leveraging the efficiency of the proposed algorithm. **Function Signature:** ```python def hamming_weight(n: int) -> int: pass ``` **Input:** - `n` (an integer): a non-negative integer whose Hamming weight is to be calculated. **Output:** - An integer representing the number of \'1\' bits in the binary representation of `n`. **Constraints:** - The integer `n` is guaranteed to be non-negative. - Your implementation should run with a time complexity better than O(log n), specifically O(k) where k is the number of 1\'s in the binary representation of `n`. # Examples 1. Input: `n = 11` - Binary representation: `00000000000000000000000000001011` - Output: `3` 2. Input: `n = 128` - Binary representation: `00000000000000000000000010000000` - Output: `1` 3. Input: `n = 4294967293` - Binary representation: `11111111111111111111111111111101` - Output: `31` # Notes - The function should handle both small and large integers efficiently. - Aim to use the iterative version of Brian Kernighan\'s Algorithm for ease of implementation and to avoid potential recursion limits.","solution":"def hamming_weight(n: int) -> int: Calculate the Hamming weight of an integer using Brian Kernighan\'s Algorithm. Args: n (int): Non-negative integer whose Hamming weight is to be calculated. Returns: int: Number of \'1\' bits in the binary representation of n. count = 0 while n: n &= n - 1 count += 1 return count"},{"question":"# Context You are working as a software engineer at a company that handles image processing tasks. One of your tasks involves transforming image matrices by rotating and inverting them. Your task is to write functions that can handle these transformations efficiently. # Problem Statement Implement the following functions to transform an `n x n` matrix: 1. **rotate_90_clockwise(matrix)**: Rotate the matrix 90 degrees clockwise. 2. **rotate_90_counterclockwise(matrix)**: Rotate the matrix 90 degrees counterclockwise. 3. **invert_diagonal_top_left(matrix)**: Invert the matrix across the top-left diagonal. 4. **invert_diagonal_bottom_left(matrix)**: Invert the matrix across the bottom-left diagonal. # Function Signatures ```python def rotate_90_clockwise(matrix: List[List[int]]) -> List[List[int]]: pass def rotate_90_counterclockwise(matrix: List[List[int]]) -> List[List[int]]: pass def invert_diagonal_top_left(matrix: List[List[int]]) -> List[List[int]]: pass def invert_diagonal_bottom_left(matrix: List[List[int]]) -> List[List[int]]: pass ``` # Input - `matrix: List[List[int]]` - A 2D list representing the `n x n` matrix to be transformed. # Output - Returns a new `n x n` matrix after performing the specified transformation. # Constraints - `1 <= n <= 1000` - The matrix will contain integers in the range `[-10^6, 10^6]`. # Examples Example 1: **Input**: ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] ``` **Output**: ``` rotate_90_clockwise(matrix) => [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] rotate_90_counterclockwise(matrix) => [ [3, 6, 9], [2, 5, 8], [1, 4, 7] ] invert_diagonal_top_left(matrix) => [ [1, 4, 7], [2, 5, 8], [3, 6, 9] ] invert_diagonal_bottom_left(matrix) => [ [9, 6, 3], [8, 5, 2], [7, 4, 1] ] ``` **Note**: Ensure solutions handle edge cases, such as empty matrices and single rows or columns, effectively.","solution":"def rotate_90_clockwise(matrix): Rotates the matrix 90 degrees clockwise. n = len(matrix) return [[matrix[n - j - 1][i] for j in range(n)] for i in range(n)] def rotate_90_counterclockwise(matrix): Rotates the matrix 90 degrees counterclockwise. n = len(matrix) return [[matrix[j][n - i - 1] for j in range(n)] for i in range(n)] def invert_diagonal_top_left(matrix): Inverts the matrix across the top-left (main) diagonal. n = len(matrix) return [[matrix[j][i] for j in range(n)] for i in range(n)] def invert_diagonal_bottom_left(matrix): Inverts the matrix across the bottom-left diagonal. n = len(matrix) return [[matrix[n - j - 1][n - i - 1] for j in range(n)] for i in range(n)]"},{"question":"# Scenario You are a software engineer tasked to implement a reliable and efficiently performing dictionary for an application that handles a large number of dynamic entries. The current implementation needs enhancements for supporting better performance under heavy loads and different patterns of usage. # Task Implement a function that simulates a spell-checker using a modified version of the provided `ResizableHashTable`. The function should take a list of valid words to initialize the dictionary and then allow for dynamic creation, updating, and deletion of entries. The spell-checker should be able to detect incorrectly spelled words. # Function Signature ```python def spell_checker(valid_words, operations): # your code here ``` # Input * `valid_words`: A list of strings; initially valid words for the spell checker. (1 <= len(valid_words) <= 10^5) * `operations`: A list of tuples, where each tuple represents an operation. Operations can be of four types: * `(\\"query\\", word)`: Check if the word is spelled correctly. Returns `True` if found, `False` otherwise. * `(\\"add\\", word)`: Add the word to the dictionary. * `(\\"delete\\", word)`: Delete the word from the dictionary. * `(\\"update\\", old_word, new_word)`: Update the word in the dictionary. # Output The function should return a list of results for `query` operations in the order they appear in the input. # Example ```python valid_words = [\\"hello\\", \\"world\\", \\"python\\", \\"programming\\"] operations = [(\\"query\\", \\"hello\\"), (\\"add\\", \\"helloworld\\"), (\\"query\\", \\"helloworld\\"), (\\"delete\\", \\"hello\\"), (\\"query\\", \\"hello\\")] spell_checker(valid_words, operations) ``` Output: ``` [True, False, True, False] ``` # Constraints * All strings contain only lowercase English letters and are at most 100 characters long. * The number of operations will be at most 10^6. # Instructions 1. Implement the `ResizableHashTable` class within the `spell_checker` function. 2. Use the provided class with modifications to support the spell-checker requirements. 3. Ensure your implementation efficiently handles up to 10^6 operations within reasonable time limits.","solution":"def spell_checker(valid_words, operations): class ResizableHashTable: def __init__(self): self.size = 1000 self.count = 0 self.table = [[] for _ in range(self.size)] def _hash(self, key): return hash(key) % self.size def _resize(self): new_size = self.size * 2 new_table = [[] for _ in range(new_size)] for buck_lst in self.table: for key in buck_lst: new_index = hash(key) % new_size new_table[new_index].append(key) self.size = new_size self.table = new_table def add(self, key): index = self._hash(key) bucket = self.table[index] if key not in bucket: bucket.append(key) self.count += 1 if self.count > self.size * 0.7: # load factor 0.7 self._resize() def delete(self, key): index = self._hash(key) bucket = self.table[index] if key in bucket: bucket.remove(key) self.count -= 1 def contains(self, key): index = self._hash(key) bucket = self.table[index] return key in bucket # Initialize the hash table with valid_words hash_table = ResizableHashTable() for word in valid_words: hash_table.add(word) results = [] # Process each operation for operation in operations: if operation[0] == \\"query\\": results.append(hash_table.contains(operation[1])) elif operation[0] == \\"add\\": hash_table.add(operation[1]) elif operation[0] == \\"delete\\": hash_table.delete(operation[1]) elif operation[0] == \\"update\\": old_word, new_word = operation[1], operation[2] hash_table.delete(old_word) hash_table.add(new_word) return results"},{"question":"# Polynomial Differentiation In this task, you are required to extend the `Polynomial` class to include the functionality of differentiation with respect to a given variable. Differentiation is a fundamental operation in calculus, often used on polynomials in mathematical calculations and analysis. Requirements 1. **Add a Method**: Add a method `differentiate` to the `Polynomial` class. 2. **Method Definition**: * The `differentiate` method should accept an integer representing the variable number with respect to which the differentiation will be performed. * The method should return a new `Polynomial` instance representing the derivative. Function Signature ```python def differentiate(self, var: int) -> Polynomial: ``` Input * An integer `var` representing the variable number for differentiation. Output * A `Polynomial` instance representing the differentiated polynomial. # Example Scenarios **Example 1:** ```python # Original Polynomial: 3(a_1)^2 - 2(a_1) poly = Polynomial([Monomial({1: 2}, 3), Monomial({1: 1}, -2)]) # Differentiate with respect to variable 1 derivative = poly.differentiate(1) print(derivative) # Expected output: Polynomial with Monomials equivalent to 6(a_1) - 2 ``` **Example 2:** ```python # Original Polynomial: 5(a_1)(a_2)^3 - 4(a_1)^2(a_2) poly = Polynomial([Monomial({1: 1, 2: 3}, 5), Monomial({1: 2, 2: 1}, -4)]) # Differentiate with respect to variable 2 derivative = poly.differentiate(2) print(derivative) # Expected output: Polynomial with Monomials equivalent to 15(a_1)(a_2)^2 - 4(a_1)^2 ``` # Notes * Ensure that your method correctly handles cases where the variable is not present. * Any constant terms should vanish after differentiation. * Handle edge cases gracefully, such as differentiation with respect to a non-existent variable.","solution":"class Monomial: def __init__(self, powers, coefficient): Each monomial is represented by a dictionary with variable indices as keys and their powers as values, and a coefficient. self.powers = powers self.coefficient = coefficient def differentiate(self, var): Differentiate this monomial with respect to the given variable. if var not in self.powers or self.powers[var] == 0: return Monomial({}, 0) new_powers = self.powers.copy() new_coefficient = self.coefficient * new_powers[var] new_powers[var] -= 1 if new_powers[var] == 0: del new_powers[var] return Monomial(new_powers, new_coefficient) def __repr__(self): return f\\"Monomial(powers={self.powers}, coefficient={self.coefficient})\\" class Polynomial: def __init__(self, monomials): The polynomial is represented by a list of monomials. self.monomials = monomials def differentiate(self, var): Differentiate the polynomial with respect to the given variable. new_monomials = [m.differentiate(var) for m in self.monomials] differentiated_polynomial = Polynomial( [m for m in new_monomials if m.coefficient != 0] ) return differentiated_polynomial def __repr__(self): return f\\"Polynomial(monomials={self.monomials})\\""},{"question":"# Rabin-Karp Advanced String Search As a data scientist working for a large tech company, you are tasked with developing a fast and efficient plagiarism detection tool. The Rabin-Karp algorithm is an excellent fit for this task due to its efficient string searching capabilities. Task Write a function `rabin_karp_all_occurrences(word, text)` that uses the Rabin-Karp algorithm to find all occurrences of the word in the given text. The function should return a list of starting indices of each occurrence of the word in the text. If there are no matches, the function should return an empty list. Input and Output Formats * **Input**: - `word`: A non-empty string with a maximum length of 1000 characters. - `text`: A string with a maximum length of 100,000 characters. * **Output**: - A list of integers representing the starting indices of each occurrence of the `word` in the `text`. Constraints * Search is case-sensitive. * Both `word` and `text` will only contain lower-case English letters (a-z). * Efficient solutions are required, leveraging the rolling hash technique. Performance Requirements * Your implementation should be efficient in terms of time complexity, targeting averagely O(n + m) time complexity. Example ```python text = \\"ababab\\" word = \\"ab\\" print(rabin_karp_all_occurrences(word, text)) # Expected Output: [0, 2, 4] text = \\"hello world\\" word = \\"world\\" print(rabin_karp_all_occurrences(word, text)) # Expected Output: [6] text = \\"abcdabcabc\\" word = \\"abc\\" print(rabin_karp_all_occurrences(word, text)) # Expected Output: [0, 4, 7] ```","solution":"def rabin_karp_all_occurrences(word, text): Returns a list of starting indices of each occurrence of `word` in `text` using the Rabin-Karp algorithm. def calculate_hash(s, prime=101): Calculates and returns the hash value of the given string using a specified prime number. h = 0 for char in s: h = h * prime + ord(char) return h word_length = len(word) text_length = len(text) word_hash = calculate_hash(word) current_hash = calculate_hash(text[:word_length]) occurrences = [] prime = 101 highest_power = prime ** (word_length - 1) for i in range(text_length - word_length + 1): if current_hash == word_hash: if text[i:i + word_length] == word: occurrences.append(i) if i < text_length - word_length: current_hash = (current_hash - ord(text[i]) * highest_power) * prime + ord(text[i + word_length]) return occurrences"},{"question":"# Question: Adaptive Search Algorithm Implementation **Problem Statement**: Given a sorted array consisting of integer elements, create a function that adapts between interpolation search and binary search based on the distribution of values. The function should start with interpolation search and, upon detecting poor performance with non-uniform distributions, switch to binary search. **Function Signature**: ```python def adaptive_search(array: List[int], search_key: int) -> int: :param array: List[int] - A sorted list of integers. :param search_key: int - The target integer to be searched. :returns: int - The index of search_key in array if found, else -1. ``` **Input/Output**: - **Input**: - `array` - A list of integers sorted in ascending order. - `search_key` - An integer which is to be searched. - **Output**: - The function returns the index of `search_key` in the array if found; otherwise, it returns -1. **Constraints**: - You can assume that the array will contain at most 10^6 elements. - The integers in the array can be any valid integer range from -10^9 to 10^9. **Performance Requirement**: - The function should efficiently adapt between O(log(log(n))) and O(log(n)) time complexity based on the input data distribution. **Examples**: ```python assert adaptive_search([1, 4, 7, 9, 12, 34, 50, 67], 9) == 3 assert adaptive_search([10, 20, 30, 40, 50], 45) == -1 assert adaptive_search([-10, -5, 0, 5, 10], -5) == 1 assert adaptive_search([1, 3, 5, 7, 9, 11, 13, 15, 17, 19], 8) == -1 ``` **Hint**: 1. Implement the interpolation search as per the provided code snippet. 2. Track the number of steps taken or the range reduction in interpolation search. 3. If it falls below a certain threshold, switch to binary search for better performance. 4. Binary search can be implemented directly using an iterative or recursive approach. **Edge Cases**: - Handle arrays with repeated elements robustly. - Use binary search directly if the range reduction during interpolation search is inefficient.","solution":"from typing import List def adaptive_search(array: List[int], search_key: int) -> int: Performs an adaptive search combining interpolation search and binary search. :param array: List[int] - A sorted list of integers. :param search_key: int - The target integer to be searched. :returns: int - The index of search_key in array if found, else -1. low, high = 0, len(array) - 1 steps = 0 while low <= high and array[low] <= search_key <= array[high]: if low == high: if array[low] == search_key: return low return -1 pos = low + ((search_key - array[low]) * (high - low) // (array[high] - array[low])) if pos < 0 or pos >= len(array): break # Interpolation index out of bounds steps += 1 if array[pos] == search_key: return pos if array[pos] < search_key: low = pos + 1 else: high = pos - 1 if steps > 2 * (high - low): break # If interpolation search isn\'t reducing range efficiently, switch to binary search # Fallback to binary search low, high = 0, len(array) - 1 while low <= high: mid = (low + high) // 2 if array[mid] == search_key: return mid elif array[mid] < search_key: low = mid + 1 else: high = mid - 1 return -1"},{"question":"You are given an array `array` containing `n` integers, and an integer `query`. Your task is to implement a function `linear_search_optimized` that finds the index of the `query` element in the `array`. If the element is not found, the function should return -1. However, to challenge your understanding beyond simple implementation, the array may contain duplicate elements. Your task is to modify the algorithm to return the index value of the first occurrence of the `query` and additionally, count the number of occurrences of the `query` in the given array. # Function Signature ```python def linear_search_optimized(array: List[int], query: int) -> Tuple[int, int]: Args: - array: List of integers. - query: Integer to search in the array. Returns: - A tuple where the first element is the index of the first occurrence of the query in the array, or -1 if the query is not found, and the second element is the count of the query within the array. ``` # Input * `array`: A list of integers `[a1, a2, ..., an]` (1 ≤ n ≤ 10^6). * `query`: An integer to search for in the `array`. # Output A tuple `(index, count)`: * `index`: The index of the first occurrence of the `query` in the `array`, or -1 if the `query` is not present. * `count`: The total number of times the `query` element is found in the `array`. # Constraints * The array can have up to 1,000,000 elements. * The elements of the array can be any integer within the range of [-10^9, 10^9]. # Example ```python array = [1, 2, 3, 2, 5] query = 2 # The query \'2\' is found at index 1 (first occurrence) with a total count of 2. print(linear_search_optimized(array, query)) # Output: (1, 2) array = [1, 2, 3, 4, 5] query = 6 # The query \'6\' is not found, hence index is -1 with a count of 0. print(linear_search_optimized(array, query)) # Output: (-1, 0) ```","solution":"from typing import List, Tuple def linear_search_optimized(array: List[int], query: int) -> Tuple[int, int]: index = -1 count = 0 for i, num in enumerate(array): if num == query: if index == -1: index = i count += 1 return (index, count)"},{"question":"# Question Implement a function `find_missing_side` that calculates the length of an unknown side of a right-angled triangle. The parameters provided are the lengths of the two known sides and a placeholder \\"?\\" for the unknown side. Each side\'s length can either be an integer or float. Your function should handle values that result in invalid right-angled triangles by raising an appropriate error. Detailed Requirements: 1. Your function, `find_missing_side(opposite, adjacent, hypotenuse)`, will take three parameters: - **opposite** (float or int or \\"?\\" string): Length of the side opposite the right angle. - **adjacent** (float or int or \\"?\\" string): Length of the side adjacent to the right angle. - **hypotenuse** (float or int or \\"?\\" string): Length of the hypotenuse (the longest side). 2. The function will return the length of the unknown side as a float. Raise a `ValueError` if the inputs are invalid or cannot form a valid right-angled triangle. Example Usage: ```python find_missing_side(3, 4, \\"?\\") # returns 5.0 find_missing_side(3, \\"?\\", 5) # returns 4.0 find_missing_side(\\"?\\", 4, 5) # returns 3.0 find_missing_side(3, 4, 5) # raises ValueError find_missing_side(3, -4, \\"?\\") # raises ValueError find_missing_side(\\"?\\", \\"?\\", 5) # raises ValueError ``` Constraints: 1. The input lengths must be positive values. 2. Exactly one of the inputs must be \\"?\\" while the others must be valid positive numbers.","solution":"import math def find_missing_side(opposite, adjacent, hypotenuse): Takes the lengths of two known sides of a right-angled triangle and returns the length of the third side. if [opposite, adjacent, hypotenuse].count(\\"?\\") != 1: raise ValueError(\\"Exactly one side must be unknown (\'?\').\\") sides = [opposite, adjacent, hypotenuse] try: known_sides = [float(x) for x in sides if x != \\"?\\"] if len(known_sides) != 2 or any(side <= 0 for side in known_sides): raise ValueError(\\"All known sides must be positive numbers.\\") except ValueError: raise ValueError(\\"All known sides must be numeric values.\\") if opposite == \\"?\\": # Hypotenuse^2 - Adjacent^2 = Opposite^2 hyp, adj = float(hypotenuse), float(adjacent) if hyp <= adj: raise ValueError(\\"Hypotenuse must be greater than the other sides.\\") return round(math.sqrt(hyp**2 - adj**2), 1) elif adjacent == \\"?\\": # Hypotenuse^2 - Opposite^2 = Adjacent^2 hyp, opp = float(hypotenuse), float(opposite) if hyp <= opp: raise ValueError(\\"Hypotenuse must be greater than the other sides.\\") return round(math.sqrt(hyp**2 - opp**2), 1) elif hypotenuse == \\"?\\": # Opposite^2 + Adjacent^2 = Hypotenuse^2 opp, adj = float(opposite), float(adjacent) return round(math.sqrt(opp**2 + adj**2), 1) raise ValueError(\\"Invalid input.\\") # Sample usage # print(find_missing_side(3, 4, \\"?\\")) # returns 5.0 # print(find_missing_side(3, \\"?\\", 5)) # returns 4.0 # print(find_missing_side(\\"?\\", 4, 5)) # returns 3.0 # print(find_missing_side(3, 4, 5)) # raises ValueError # print(find_missing_side(3, -4, \\"?\\")) # raises ValueError # print(find_missing_side(\\"?\\", \\"?\\", 5)) # raises ValueError"},{"question":"Full Path Resolution Function **Objective**: You are provided with a function that converts a given file path into its full absolute path. To assess your understanding of file path operations and Python built-in libraries, you need to implement this function and ensure it handles various path configurations. Function Signature: ```python def resolve_full_path(file: str) -> str: pass ``` Input: * A single string `file` that represents the path to the file. The path may include: - A relative path (e.g., `../folder/file.txt`) - An absolute path (e.g., `/home/user/folder/file.txt`) - A user directory shorthand (e.g., `~/folder/file.txt`) Output: * A single string that represents the full absolute path of the input file. Constraints: * `file` will be a non-empty string. * The file does not necessarily exist; the function should only resolve the path. * The user directory shorthand should expand correctly for valid paths. Example Scenarios: 1. `resolve_full_path(\\"~/folder/file.txt\\")` should return `/home/user/folder/file.txt` 2. `resolve_full_path(\\"/var/log/system.log\\")` should return `/var/log/system.log` 3. `resolve_full_path(\\"../folder/file.txt\\")` should return the appropriate absolute path relative to the current working directory. Instructions: 1. Implement the `resolve_full_path` function. 2. Make sure your implementation covers edge cases where paths might include invalid characters or references. **Bonus**: - Write additional validation to ensure the expanded path segments exist on the file system.","solution":"import os def resolve_full_path(file: str) -> str: Resolve a given file path to its full absolute path. Parameters: file (str): The file path to resolve Returns: str: The resolved full absolute path return os.path.abspath(os.path.expanduser(file))"},{"question":"# Digit Counting Algorithm Problem Statement You are provided with a method that efficiently counts the number of digits in a given integer using logarithmic properties. Your task is to extend this functionality to operate on a list of integers. Objective Write a function `count_digits(lst)` which takes a list of integers `lst` as input and returns a list of integers where each integer represents the number of digits in the corresponding element from the input list. Function Signature ```python def count_digits(lst: List[int]) -> List[int]: ``` Input - A list of integers `lst` where each integer can be positive, negative, or zero. - The list can be of length `n` (0 ≤ n ≤ 10^4). Output - A list of integers where each element represents the number of digits of the corresponding integer in the input list. Constraints - All integers will fall within the range of typical 32-bit signed integers: -2,147,483,648 to 2,147,483,647. - You must use the digit counting logic as provided in the previous snippet. Example ```python assert count_digits([123, -45, 0, 6789]) == [3, 2, 1, 4] assert count_digits([1, 22, 333, 4444, -55555]) == [1, 2, 3, 4, 5] assert count_digits([]) == [] ``` Explanation - For the list `[123, -45, 0, 6789]`, the number of digits are `[3, 2, 1, 4]` respectively. - For the list `[1, 22, 333, 4444, -55555]`, the number of digits are `[1, 2, 3, 4, 5]` respectively. - An empty list `[]` should return an empty list `[]`.","solution":"import math from typing import List def count_digits(lst: List[int]) -> List[int]: Takes a list of integers and returns a list of their digit counts. def digit_count(n: int) -> int: if n == 0: return 1 return int(math.log10(abs(n))) + 1 return [digit_count(num) for num in lst]"},{"question":"You are given two singly linked lists, potentially sharing some nodes. Your task is to find the first common node where the lists intersect, if any. # Function Signature ```python def find_intersection(head1: Node, head2: Node) -> Node: ``` # Input * Two heads of linked lists: * `head1` - the head of the first linked list. * `head2` - the head of the second linked list. # Output * The first common node shared by both linked lists. * If there is no intersection, return `None`. # Constraints * The linked lists can be of different lengths. * The function should be optimized for time complexity O(N + M) and space complexity O(1). * The lists are non-cyclical. # Example Consider the following linked lists: ``` 1 -> 3 -> 5 7 -> 9 -> 11 / 2 -> 4 -> 6 ``` Here, the first shared node is 7. # Test Case Create a test suite to validate your solution. Include edge cases such as: 1. No intersection at all. 2. Intersection at the first node. 3. Lists of different lengths. 4. One or both lists are empty. # Notes * The inherent challenge is to correctly adjust the starting point of the longer list to align traversals in a way that simultaneously moves towards identification of the common node. * Be cautious of handling null pointers appropriately.","solution":"class Node: def __init__(self, value): self.value = value self.next = None def get_length(head): length = 0 while head: length += 1 head = head.next return length def find_intersection(head1, head2): Returns the first common node in two singly linked lists, or None if no intersection exists. if not head1 or not head2: return None len1 = get_length(head1) len2 = get_length(head2) # Align both heads to the same position from the end of the linked lists while len1 > len2: head1 = head1.next len1 -= 1 while len2 > len1: head2 = head2.next len2 -= 1 # Traverse together until we find the intersection while head1 and head2: if head1 is head2: return head1 head1 = head1.next head2 = head2.next return None"},{"question":"Calculate the Height of a Binary Tree Problem Description You are given a binary tree. Your task is to write a function to calculate the height of this binary tree. The height of a tree is the number of levels it contains. An empty tree has height 0, a tree with one node has height 1, and a root node with one or two leaves as children has a height of 2 and so on. Function Signature ```python def height(root: Node) -> int: pass ``` Input - `root`: The root node of a binary tree. Each node has attributes `left` and `right`, which can be `None` or another node. Output - Return the height of the tree (an integer). Constraints - The binary tree can have up to `10^4` nodes. - A node is defined as follows: ```python class Node: def __init__(self, key): self.left = None self.right = None self.val = key ``` Implementation Requirements - Your function should be as efficient as possible in terms of runtime and memory usage. - Handle edge cases such as an empty tree or a single node tree properly. Example Consider the tree below: ``` 9 / 6 12 / / 3 8 10 15 / 7 18 ``` In this case, `height(root)` should return `4`. # Additional Notes - Write appropriate unit tests to validate your solution.","solution":"class Node: def __init__(self, key): self.left = None self.right = None self.val = key def height(root: Node) -> int: if root is None: return 0 else: left_height = height(root.left) right_height = height(root.right) return 1 + max(left_height, right_height)"},{"question":"**Scenario**: You are tasked with developing a feature for a text editor that checks if a given input string is a palindrome. The input consists only of printable ASCII characters, including spaces and punctuation. **Task Description**: Write a function `is_valid_palindrome(s: str) -> bool` that takes an input string `s` and returns a boolean indicating whether the string is a palindrome. In determining if the string is a palindrome, consider only alphanumeric characters and ignore case differences. **Input**: - A single string `s` which can have length ranging from 0 to 10^5. **Output**: - Return `True` if the string is a valid palindrome, `False` otherwise. **Constraints**: - You must implement the function using the two-pointer technique to ensure optimal performance. - Only alphanumeric characters should be considered, ignoring case. **Exercises**: 1. Implement the `is_valid_palindrome` function. 2. Write tests for edge cases: empty string, strings with only punctuation, and mixed alphanumeric strings. **Function Signature**: ```python def is_valid_palindrome(s: str) -> bool: pass ``` # Example ```python # Example 1 s = \\"A man, a plan, a canal: Panama\\" assert is_valid_palindrome(s) == True # Example 2 s = \\"race a car\\" assert is_valid_palindrome(s) == False # Example 3 s = \\" \\" assert is_valid_palindrome(s) == True ``` # Explanation: - For \\"A man, a plan, a canal: Panama\\", after considering only alphanumeric characters and ignoring case, it is \\"amanaplanacanalpanama\\", which reads the same backward and forward. - For \\"race a car\\", considering only alphanumeric characters and ignoring case, it is \\"raceacar\\", which does not read the same backward and forward. - An empty string or string with only spaces is considered a valid palindrome. **Note**: Aim to achieve O(n) time complexity with O(1) additional space complexity for your function implementation.","solution":"def is_valid_palindrome(s: str) -> bool: Returns True if the input string s is a valid palindrome, ignoring non-alphanumeric characters and case differences. left, right = 0, len(s) - 1 while left < right: # Move the left pointer to the next alphanumeric character while left < right and not s[left].isalnum(): left += 1 # Move the right pointer to the previous alphanumeric character while left < right and not s[right].isalnum(): right -= 1 # Compare the characters at the pointers, ignoring case if s[left].lower() != s[right].lower(): return False left += 1 right -= 1 return True"},{"question":"Nearest Neighbor Classifier # Context You\'re working on a simple machine learning project and need to implement the Nearest Neighbor algorithm. This algorithm will classify a new data point based on its \'nearest\' neighbor in an existing training set of classified points. The problem requires calculating the Euclidean distance between the new point and each point in the training set to determine the closest neighbor. # Task Implement a Python function `nearest_neighbor(x, tSet)` which takes: * A tuple `x` representing a new data point (or vector). * A dictionary `tSet` where keys are tuples representing training data points and values are their corresponding class labels. The function should return the class label of the closest training data point to `x`. # Function Signature ```python def nearest_neighbor(x: tuple, tSet: dict) -> any: pass ``` # Input - `x`: A tuple of integers or floats. For example, `(2.0, 3.0)`. - `tSet`: A dictionary where keys are tuples of integers or floats representing points in the same space as `x`, and values are of any type (usually strings or integers representing class labels). For example, `{(1.0, 2.0): \'A\', (4.0, 6.0): \'B\'}`. # Output - The function should return the value associated with the nearest neighbor of `x` from `tSet`. # Constraints - All points in `tSet` and `x` will have the same dimensionality. - `tSet` will not be empty. # Example ```python x = (2.0, 3.0) tSet = { (1.0, 2.0): \'A\', (4.0, 6.0): \'B\', (2.5, 3.5): \'C\' } print(nearest_neighbor(x, tSet)) # Output: \'C\' ``` # Additional Considerations - Ensure your implementation correctly handles floating point arithmetic. - Think about edge cases where multiple training points might be equidistant to `x`. - Consider the efficiency of your solution and avoid redundant computations.","solution":"import math def euclidean_distance(point1, point2): Calculate the Euclidean distance between two points. return math.sqrt(sum((p1 - p2) ** 2 for p1, p2 in zip(point1, point2))) def nearest_neighbor(x: tuple, tSet: dict) -> any: Find the class label of the nearest neighbor to the point x in the training set tSet. nearest_point = None nearest_distance = float(\'inf\') for point, label in tSet.items(): distance = euclidean_distance(x, point) if distance < nearest_distance: nearest_distance = distance nearest_point = point return tSet[nearest_point]"},{"question":"# Number Decomposition: Dynamic Programming Approach Context: The decomposition of a positive integer into sums of non-negative integers has numerous applications in combinatorics and theoretical computer science. Understanding the dynamic programming solution helps grasp advanced algorithmic techniques. Task: Implement a function `integer_decomposition(n)` that computes the number of different ways to decompose the input integer `n` into sums of non-negative integers. Expected Input and Output: * **Input**: A positive integer `n` (1 ≤ n ≤ 200). * **Output**: An integer representing the number of decompositions. Constraints: * The implementation must run with time complexity O(n^2) and space complexity O(n^2). * Handle input integer edge cases, including the smallest integer (1). Example: ``` Input: 4 Output: 5 Explanation: - 4 - 3 + 1 - 2 + 2 - 2 + 1 + 1 - 1 + 1 + 1 + 1 ``` Implementation Notes: * Use a dynamic programming approach with a 2D table to store counts of decompositions. * Ensure to properly iterate and fill in the array to avoid incorrect counts. Implement the function in Python as follows: ```python def integer_decomposition(n): Compute the number of decompositions of the integer n n -- positive integer (1 ≤ n ≤ 200) arr = [[0 for _ in range(n + 1)] for _ in range(n + 1)] arr[1][1] = 1 for i in range(1, n + 1): for j in range(1, n + 1): if i < j: arr[i][j] = arr[i][i] elif i == j: arr[i][j] = 1 + arr[i][j - 1] else: arr[i][j] = arr[i][j - 1] + arr[i - j][j] return arr[n][n] # Test case print(integer_decomposition(4)) # Output: 5 ```","solution":"def integer_decomposition(n): Compute the number of decompositions of the integer n n -- positive integer (1 ≤ n ≤ 200) dp = [[0 for _ in range(n + 1)] for _ in range(n + 1)] # Base case: there is exactly one way to decompose 0 (using no parts) for i in range(n + 1): dp[0][i] = 1 # Fill the dp table for total in range(1, n + 1): for max_part in range(1, n + 1): if max_part > total: dp[total][max_part] = dp[total][total] else: dp[total][max_part] = dp[total][max_part - 1] + dp[total - max_part][max_part] return dp[n][n]"},{"question":"**Objective**: Write a function `min_cost_path` that implements the minimum cost path algorithm. Given a cost matrix as input, the function should return the minimum cost required to reach the last station from the first station. Function Signature ```python def min_cost_path(cost: List[List[int]]) -> int: pass ``` # Input - `cost`: A list of lists (2D List) where `cost[i][j]` represents the cost to move from station `i` to station `j` (`i < j`). - The matrix will always be square and all positions `i >= j` will contain `-1` or `INF`. - Length of cost matrix: `n` (2 <= n <= 100). # Output - Returns an integer which represents the minimum cost to reach the last station from the first station. # Constraints - The matrix is guaranteed to have at least two stations. - Costs are non-negative integers, and infeasible transitions are represented by `-1` or `INF`. # Example ```python # Given cost matrix cost_matrix = [ [0, 15, 80, 90], [-1, 0, 40, 50], [-1, -1, 0, 70], [-1, -1, -1, 0] ] # Expected Output: 65 (path 0 -> 1 -> 3) print(min_cost_path(cost_matrix)) # Output: 65 ``` # Performance Requirements - Your solution should be optimized to run within O(n^2) time and O(n) space complexity. _Hints_: - Use dynamic programming to build up the solution. - Keep track of the minimum cost to reach each station from the first station.","solution":"def min_cost_path(cost): Returns the minimum cost path from the first station to the last station. n = len(cost) # Initialize `min_cost` array where `min_cost[i]` stores the minimum cost to reach station `i` min_cost = [float(\'inf\')] * n min_cost[0] = 0 # The cost to reach the first station from itself is 0 # Iterate over all stations for i in range(n): # Iterate over subsequent stations from station i for j in range(i + 1, n): if cost[i][j] != -1: # Ignore infeasible transitions min_cost[j] = min(min_cost[j], min_cost[i] + cost[i][j]) return min_cost[-1]"},{"question":"Segment Tree Implementation and Application Context: A social media platform wants to monitor the maximum number of active users on their website over different time intervals. To efficiently process both the updates (when user activity changes) and queries (for maximum active users in a given time interval), they decide to use a Segment Tree. Task: Your task is to implement a `SegmentTree` class that efficiently handles updates and range queries using the principles of segment trees. You also need to ensure that the tree can handle various types of data and aggregation functions. Requirements: 1. **Class Definition**: `SegmentTree` 2. **Methods**: - `__init__(self, arr, function)`: Initializes the segment tree with an array `arr` and a commutative function `function`. - `build_tree(self)`: Builds the segment tree from the provided array. - `update(self, p, v)`: Updates the element at index `p` to value `v`. - `query(self, l, r)`: Returns the aggregated result of the function over the range `[l, r]`. Input and Output: - **Input**: - The list of initial values (e.g., number of active users initially at various times). - A commutative function for aggregation (e.g., `max` to find the maximum number of active users). - Range updates and queries. - **Output**: - The result of each range query (e.g., the maximum number of active users in a specified range). Constraints: - The input array can contain up to (10^5) elements. - Updates and queries will be frequent, necessitating logarithmic operations. Example Usage: ```python # Define the number of active users initially active_users = [5, 3, 8, 6, 10, 7] # Create a Segment Tree to get maximum active users in a range seg_tree = SegmentTree(active_users, max) # Query the range for the maximum number of active users from index 2 to 5 print(seg_tree.query(2, 5)) # Output: 10 # Update the number of active users at index 3 to 12 seg_tree.update(3, 12) # Query again for the maximum number of active users from index 2 to 5 print(seg_tree.query(2, 5)) # Output: 12 ``` Implement the `SegmentTree` class based on the above specifications and thorough testing to ensure all operations comply with the expected performance and output.","solution":"class SegmentTree: def __init__(self, arr, function): self.n = len(arr) self.function = function self.tree = [0] * (2 * self.n) # Build the tree after initialization self.build_tree(arr) def build_tree(self, arr): # Initialize the leaves of the tree for i in range(self.n): self.tree[i + self.n] = arr[i] # Build the segment tree by calculating parents for i in range(self.n - 1, 0, -1): self.tree[i] = self.function(self.tree[2 * i], self.tree[2 * i + 1]) def update(self, p, value): # Update the value at position p p += self.n self.tree[p] = value while p > 1: p //= 2 self.tree[p] = self.function(self.tree[2 * p], self.tree[2 * p + 1]) def query(self, l, r): # Query the function in the range [l, r) res = None l += self.n r += self.n while l < r: if l % 2: if res is None: res = self.tree[l] else: res = self.function(res, self.tree[l]) l += 1 if r % 2: r -= 1 if res is None: res = self.tree[r] else: res = self.function(res, self.tree[r]) l //= 2 r //= 2 return res"},{"question":"# Power of Two Determination Scenario You are developing a utility in a software application where checking if a given number is a power of two is a frequent operation. A power of two means the number can be expressed as (2^k) where (k) is a non-negative integer (e.g., 1, 2, 4, 8, 16, etc.). Implement a function that determines if a given integer is a power of two. Task Write a function `is_power_of_two` that returns `True` if the given integer is a power of two, and `False` otherwise. Specifications * **Function Signature**: `def is_power_of_two(n: int) -> bool:` * **Input**: A single integer `n` (−2^31 ≤ n ≤ 2^31−1). * **Output**: A boolean indicating whether `n` is a power of two. Constraints * You must achieve this in constant time (O(1)) using bitwise operations. * Avoid using any loops or standard library functions except for basic bitwise operations. Examples: * Input: `n = 1` Output: `True` Explanation: (2^0 = 1) * Input: `n = 16` Output: `True` Explanation: (2^4 = 16) * Input: `n = 0` Output: `False` Explanation: Zero is not a power of two. * Input: `n = -8` Output: `False` Explanation: Negative numbers are not powers of two.","solution":"def is_power_of_two(n: int) -> bool: Determine if a given integer is a power of two. :param n: Integer to check. :return: True if n is a power of two, False otherwise. # A number is a power of two if it\'s greater than 0 and its binary representation has exactly one \'1\'. return n > 0 and (n & (n - 1)) == 0"},{"question":"# Queue Implementation Comparison and Enhancement Context: You\'re working on improving the performance of a queue system in a large-scale application. The current implementation uses two queue structures: `ArrayQueue` and `LinkedListQueue`. Each structure has its advantages and drawbacks, and you need to assess their performance under different scenarios to decide on the best approach for your application. Task: Implement a function that simulates a series of operations on both the `ArrayQueue` and `LinkedListQueue`, and then measure their performance under varying load conditions. Your job is to: 1. Implement a function `simulate_operations` that: - Accepts a list of operations. - Applies these operations to both `ArrayQueue` and `LinkedListQueue`. - Measures and compares the execution time of each structure for the given operations. 2. Implement a helper function `generate_operations` that: - Generates a given number of random queue operations (`enqueue` and `dequeue`). - Ensures a balanced mix of operations based on a specified ratio. Function Signatures: ```python def simulate_operations(operations: list) -> dict: Simulate and compare performance of ArrayQueue and LinkedListQueue. :param operations: A list of operations to be applied on queues. Each operation is a tuple (op_name, value) where op_name is \'enqueue\' or \'dequeue\', and value is an integer (ignored for \'dequeue\'). :return: A dictionary with average execution times for each structure. pass def generate_operations(num_operations: int, enqueue_ratio: float) -> list: Generate a list of random queue operations. :param num_operations: Total number of operations to generate. :param enqueue_ratio: Ratio of \'enqueue\' operations to be generated. (0 <= enqueue_ratio <= 1) :return: A list of operations in the format (op_name, value) pass ``` Input and Output: 1. `simulate_operations`: - **Input**: - A list of operations, where each operation is a tuple `(operation, value)`. - `operation`: \'enqueue\' or \'dequeue\' - `value`: an integer (ignored for \'dequeue\') - **Output**: - A dictionary with keys \'ArrayQueue\' and \'LinkedListQueue\', and average execution times as values. 2. `generate_operations`: - **Input**: - `num_operations`: Integer specifying the total number of operations to generate. - `enqueue_ratio`: Float specifying the ratio of \'enqueue\' operations. - **Output**: - A list of tuples representing the operations. Example: ```python # Example usage: operations = generate_operations(10000, 0.6) results = simulate_operations(operations) print(results) # {\'ArrayQueue\': 0.035, \'LinkedListQueue\': 0.027} ``` **Constraints:** - Limit the random values for `enqueue` to a range of 1 to 1000. - Ensure no more `dequeue` operations are generated than existing elements in the queue. Notes: - Use the provided Queue implementations (`ArrayQueue`, `LinkedListQueue`). - Optimization and efficient exception handling are critical since the operations might scale up to millions.","solution":"import time import random from collections import deque class ArrayQueue: def __init__(self): self.queue = [] def enqueue(self, value): self.queue.append(value) def dequeue(self): if len(self.queue) == 0: raise IndexError(\\"dequeue from an empty queue\\") return self.queue.pop(0) class LinkedListQueue: class Node: def __init__(self, value=None): self.value = value self.next = None def __init__(self): self.head = None self.tail = None def enqueue(self, value): new_node = self.Node(value) if self.tail is not None: self.tail.next = new_node self.tail = new_node if self.head is None: self.head = new_node def dequeue(self): if self.head is None: raise IndexError(\\"dequeue from an empty queue\\") value = self.head.value self.head = self.head.next if self.head is None: self.tail = None return value def simulate_operations(operations): array_queue = ArrayQueue() linked_list_queue = LinkedListQueue() array_queue_times = [] linked_list_queue_times = [] for operation, value in operations: if operation == \'enqueue\': start_time = time.time() array_queue.enqueue(value) array_queue_times.append(time.time() - start_time) start_time = time.time() linked_list_queue.enqueue(value) linked_list_queue_times.append(time.time() - start_time) elif operation == \'dequeue\': start_time = time.time() try: array_queue.dequeue() except IndexError: pass array_queue_times.append(time.time() - start_time) start_time = time.time() try: linked_list_queue.dequeue() except IndexError: pass linked_list_queue_times.append(time.time() - start_time) array_queue_avg_time = sum(array_queue_times)/len(array_queue_times) linked_list_queue_avg_time = sum(linked_list_queue_times)/len(linked_list_queue_times) return { \'ArrayQueue\': array_queue_avg_time, \'LinkedListQueue\': linked_list_queue_avg_time } def generate_operations(num_operations, enqueue_ratio): operations = [] enqueue_count = int(num_operations * enqueue_ratio) dequeue_count = num_operations - enqueue_count for _ in range(enqueue_count): operations.append((\'enqueue\', random.randint(1, 1000))) for _ in range(dequeue_count): operations.append((\'dequeue\', None)) random.shuffle(operations) return operations"},{"question":"# Polynomial Algebra with Monomials Background: In algebra, a monomial is a product of constants and variables, typically expressed in the form (c cdot x^a), where (c) is the coefficient, (x) is the variable, and (a) is the exponent. A polynomial is a sum of monomials. Your task is to implement a class `Polynomial` that supports basic algebraic operations on polynomials (addition, subtraction, multiplication, and division). Each `Polynomial` object consists of a list of `Monomial` objects. Problem: You need to implement the following two methods in the Polynomial class: 1. `__add__`: To add two polynomials. 2. `subs`: To substitute variables in the polynomial with given values. Detailed Instructions: - The `__add__` method should take another Polynomial or monomial as input and return a new Polynomial object that is the sum of the input polynomials. - The `subs` method should take a dictionary mapping variables to their substituted values and return the numerical result of the polynomial after substitution. You will be provided with the `Monomial` class. You must implement the specified methods in the provided `Polynomial` class. Constraints: - The variables will be represented as integers ( >= 1 ). - Coefficients will be integers or fractions. - Substitution values will also be integers or fractions. Example Input/Output: ```python # Example 1: p1 = Polynomial([ Monomial({1: 1}, 3), # 3a_1 Monomial({2: 2}, 4), # 4(a_2)² Monomial({1: 1, 3: 3}, 5) # 5a_1a_3³ ]) p2 = Polynomial([ Monomial({1: 1}, 7), # 7a_1 Monomial({2: 2}, -4) # -4(a_2)² ]) # Adding polynomials p3 = p1.__add__(p2) # Substitute variables with their values subs_values = {1: 2, 2: 1, 3: 1} # a_1 = 2, a_2 = 1, a_3 = 1 result = p3.subs(subs_values) # should return the value after substitution # Example verification assert str(p3) == \'10(a_1) + 4(a_1)(a_3)**3\' # the order of terms may vary assert result == 10 # after substitution ```","solution":"class Monomial: def __init__(self, variables, coefficient): self.variables = variables # dict with variable:int {variable: exponent} self.coefficient = coefficient # int or fraction def __repr__(self): terms = [] for var, exp in sorted(self.variables.items()): terms.append(f\\"a_{var}\\") if exp > 1: terms[-1] += f\\"^{exp}\\" return f\\"{self.coefficient}*{\'*\'.join(terms)}\\" def __mul__(self, other): if not isinstance(other, Monomial): return NotImplemented new_vars = self.variables.copy() for var, exp in other.variables.items(): if var in new_vars: new_vars[var] += exp else: new_vars[var] = exp return Monomial(new_vars, self.coefficient * other.coefficient) class Polynomial: def __init__(self, monomials): self.monomials = monomials # list of Monomial objects def __repr__(self): return \\" + \\".join(str(mono) for mono in self.monomials) def __add__(self, other): if not isinstance(other, Polynomial): return NotImplemented new_monomials = self.monomials.copy() new_monomials.extend(other.monomials) return Polynomial(new_monomials) def subs(self, values): total = 0 for mono in self.monomials: prod = mono.coefficient for var, exp in mono.variables.items(): if var in values: prod *= values[var] ** exp else: prod *= 0 total += prod return total"},{"question":"# Scenario You are building a sorting module for a parallel processing system that often deals with data sizes that are powers of two. The current implementation of bitonic sort needs to be enhanced to ensure it handles a common edge case effectively. # Task Implement the `bitonic_sort` function to handle an empty input array correctly while maintaining the integrity of the sort for valid inputs. The function must return an appropriately sorted array without raising exceptions (unless the input size is not a power of two). # Function Signature ```python def bitonic_sort(arr: list, reverse: bool = False) -> list: ``` # Input * `arr`: A list of integers where the length should be a power of two. - Example: `[3, 7, 4, 8]` is valid, while `[3, 7, 4]` is not. * `reverse`: A boolean flag indicating sort order. - `False`: Sort in ascending order. - `True`: Sort in descending order. # Output * The function should return a list of integers sorted as per the `reverse` flag. # Constraints * The function should handle empty input arrays gracefully by returning an empty array. * Array elements can be positive, negative, or zero. # Performance Requirements * Aim for O(n log(n)^2) in the non-parallel version. # Example ```python print(bitonic_sort([])) # Output: [] print(bitonic_sort([3, 7, 4, 8])) # Output: [3, 4, 7, 8] print(bitonic_sort([3, 7, 4, 8], reverse=True)) # Output: [8, 7, 4, 3] ``` # Additional Notes You should not use any direct built-in sorting functions or libraries to solve this problem. Implement the logic explicitly within the given function signature.","solution":"def bitonic_sort(arr: list, reverse: bool = False) -> list: Bitonic sort function to sort an array with size a power of two. if len(arr) == 0: return [] if not is_power_of_two(len(arr)): raise ValueError(\\"The length of the input list is not a power of two.\\") def compare_and_swap(i, j, dir): if (dir and arr[i] > arr[j]) or (not dir and arr[i] < arr[j]): arr[i], arr[j] = arr[j], arr[i] def bitonic_merge(low, count, dir): if count > 1: mid = count // 2 for i in range(low, low + mid): compare_and_swap(i, i + mid, dir) bitonic_merge(low, mid, dir) bitonic_merge(low + mid, mid, dir) def bitonic_sort_rec(low, count, dir): if count > 1: mid = count // 2 bitonic_sort_rec(low, mid, True) bitonic_sort_rec(low + mid, mid, False) bitonic_merge(low, count, dir) bitonic_sort_rec(0, len(arr), not reverse) return arr def is_power_of_two(n): return n != 0 and ((n & (n - 1)) == 0)"},{"question":"# Question: **Title**: Optimized Calculation of Binomial Coefficient **Problem Statement**: Write a function `iterative_binomial_coefficient(n, k)` to calculate the binomial coefficient C(n, k) iteratively, leveraging dynamic programming to optimize performance and avoid deep recursion. The function should handle large values of n and k efficiently. **Function Signature**: ```python def iterative_binomial_coefficient(n: int, k: int) -> int: pass ``` **Input**: * An integer `n` (0 ≤ n ≤ 1000). * An integer `k` (0 ≤ k ≤ n). **Output**: * An integer representing the binomial coefficient C(n, k). **Examples**: ```python print(iterative_binomial_coefficient(5, 0)) # Output: 1 print(iterative_binomial_coefficient(8, 2)) # Output: 28 print(iterative_binomial_coefficient(10, 5)) # Output: 252 print(iterative_binomial_coefficient(100, 50)) # Output: 100891344545564193334812497256 ``` **Constraints**: * The function must use an iterative approach and dynamic programming. * Performance should be optimized to handle the upper limits of input efficiently. **Guidance**: * Use a 2D array to store intermediate results (Pascal\'s triangle). * Avoid recalculating the known results of subproblems. * This approach must be non-recursive to ensure it\'s not limited by maximum recursion depth.","solution":"def iterative_binomial_coefficient(n, k): if k > n: return 0 if k == 0 or k == n: return 1 # Initialize a table to store previously computed values C = [[0 for x in range(k+1)] for x in range(n+1)] # Build the table in bottom-up manner for i in range(n+1): for j in range(min(i, k)+1): # Base cases if j == 0 or j == i: C[i][j] = 1 else: C[i][j] = C[i-1][j-1] + C[i-1][j] return C[n][k]"},{"question":"Implement the `SeparateChainingHashTable` class with dynamic resizing to ensure efficient performance even as the number of elements increases. Functionality to Implement: 1. **put(key, value)**: Insert or update the key-value pair. 2. **get(key)**: Retrieve the value associated with the key. 3. **del_(key)**: Delete the key-value pair. 4. **Dynamic Resizing**: - When the load factor (number of elements / table size) exceeds a certain threshold, double the size of the hash table and rehash all existing elements. # Constraints: - Initial size of the hash table should be 11. - Load factor threshold for resizing is 0.75. # Examples: ```python table = SeparateChainingHashTable() # Inserting values table.put(\\"apple\\", \\"fruit\\") table.put(\\"cucumber\\", \\"vegetable\\") table.put(\\"carrot\\", \\"vegetable\\") # Retrieving values assert table.get(\\"apple\\") == \\"fruit\\" assert table.get(\\"cucumber\\") == \\"vegetable\\" assert table.get(\\"missing\\") is None # Updating values table.put(\\"apple\\", \\"green fruit\\") assert table.get(\\"apple\\") == \\"green fruit\\" # Deleting values table.del_(\\"carrot\\") assert table.get(\\"carrot\\") is None # Dynamic resizing should work seamlessly in the background. for i in range(100): table.put(f\\"key{i}\\", i) assert table.get(\\"key99\\") == 99 assert len(table) == 101 ``` # Performance Requirements: - Ensure that average-case time complexity for `put`, `get`, and `del_` operations remain O(1) despite dynamic resizing. - Handle edge cases gracefully, such as inserting duplicate keys, deleting non-existent keys, and managing empty buckets efficiently.","solution":"class SeparateChainingHashTable: def __init__(self, size=11): self.size = size self.table = [[] for _ in range(size)] self.num_elements = 0 self.load_factor_threshold = 0.75 def _hash(self, key): return hash(key) % self.size def put(self, key, value): index = self._hash(key) bucket = self.table[index] for i, (k, v) in enumerate(bucket): if k == key: bucket[i] = (key, value) return bucket.append((key, value)) self.num_elements += 1 if self._load_factor() > self.load_factor_threshold: self._resize() def get(self, key): index = self._hash(key) bucket = self.table[index] for k, v in bucket: if k == key: return v return None def del_(self, key): index = self._hash(key) bucket = self.table[index] for i, (k, v) in enumerate(bucket): if k == key: del bucket[i] self.num_elements -= 1 return def _load_factor(self): return self.num_elements / self.size def _resize(self): new_size = self.size * 2 new_table = [[] for _ in range(new_size)] old_table = self.table self.table = new_table self.size = new_size self.num_elements = 0 for bucket in old_table: for key, value in bucket: self.put(key, value) def __len__(self): return self.num_elements"},{"question":"# Question **Context**: You are given a singly linked list of integers. Your task is to remove a range of elements in place, specified by starting and ending indices. This operation will involve updating pointers within the list to exclude the nodes within the given range. **Function Signature**: ```python def remove_range(head: ListNode, start: int, end: int) -> ListNode: pass ``` **Inputs**: - `head`: The head node of the linked list (`ListNode`). - `start`: An integer representing the starting index (inclusive) of the range to be removed. - `end`: An integer representing the ending index (inclusive) of the range to be removed. **Outputs**: - Returns the head of the modified list after removing the range of elements. **Constraints**: - The linked list will have at least one node. - `0 <= start <= end < number of nodes in the list`. **Performance Requirements**: - Time complexity should be O(n), where n is the number of nodes in the linked list. - Space complexity should be O(1) (in-place operation without extra space). **Examples**: 1. Given the linked list: [8, 13, 17, 4, 9, 12, 98, 41, 7, 23, 0, 92] and remove_range(list, 3, 8), the output should be: [8, 13, 17, 23, 0, 92] 2. Given the linked list: [1, 2, 3, 4, 5] and remove_range(list, 1, 3), the output should be: [1, 5] **Scenario**: Consider a scenario where you need to dynamically manage a collection of nodes, effectively excluding certain ranges of records, e.g., log files where certain entries need to be removed before processing further. Write a function `remove_range` in Python to achieve this. **Hint**: - Pay attention to handling the head of the list and ensure proper updating of the next pointers.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def remove_range(head: ListNode, start: int, end: int) -> ListNode: Removes a range of elements from the linked list specified by start and end indices (inclusive). :param head: The head node of the linked list. :param start: The starting index (inclusive) of the range to be removed. :param end: The ending index (inclusive) of the range to be removed. :return: The head of the modified list after removing the range of elements. dummy = ListNode(0, head) prev = dummy current = head idx = 0 # Navigate to the node just before the start index while idx < start: prev = current current = current.next idx += 1 # Navigate to the node just after the end index skip = current while idx <= end: skip = skip.next idx += 1 prev.next = skip return dummy.next"},{"question":"# Question Context You are working on a networking tool that needs to display IP addresses in their binary representation format. To achieve this, you must convert IP addresses provided in decimal notation to their corresponding binary format. Task Write two functions, `decimal_to_binary_util(val: str) -> str` and `decimal_to_binary_ip(ip: str) -> str`, that ensure correct conversion as described below: 1. **Function: `decimal_to_binary_util`** * **Description**: This function converts an 8-bit decimal number (integer value from 0 to 255) to an 8-bit binary string. * **Input**: A string, `val`, which is a single decimal number. * **Output**: A string representing the 8-bit binary format of the input. 2. **Function: `decimal_to_binary_ip`** * **Description**: This function converts an IP address from dotted-decimal notation to its binary representation, using the utility function `decimal_to_binary_util`. * **Input**: A string, `ip`, which is an IP address in dotted-decimal format. * **Output**: A string representing the IP address in dotted-binary format. Constraints * The input to `decimal_to_binary_util` will always be a valid integer string between \\"0\\" and \\"255\\". * The input to `decimal_to_binary_ip` will always be a valid IP address in the form \\"XXX.XXX.XXX.XXX\\", where XXX is a number between 0 and 255. Performance Requirements * Ensure that the time complexity of both functions remains O(1). * Memory usage should be minimal and constant. Example ```python assert decimal_to_binary_ip(\\"255.0.0.5\\") == \\"11111111.00000000.00000000.00000101\\" assert decimal_to_binary_ip(\\"192.168.1.1\\") == \\"11000000.10101000.00000001.00000001\\" assert decimal_to_binary_ip(\\"0.0.0.0\\") == \\"00000000.00000000.00000000.00000000\\" assert decimal_to_binary_ip(\\"128.0.0.1\\") == \\"10000000.00000000.00000000.00000001\\" ```","solution":"def decimal_to_binary_util(val): Converts an 8-bit decimal number to an 8-bit binary string. return format(int(val), \'08b\') def decimal_to_binary_ip(ip): Converts an IP address from dotted-decimal notation to binary format. return \'.\'.join(decimal_to_binary_util(octet) for octet in ip.split(\'.\'))"},{"question":"Given the previous analysis of HashMap (Dictionary) and Set usage for checking patterns, your task is to implement a function that checks if a given pattern matches a given string. The function should ensure a one-to-one correspondence between characters of the pattern and words of the string. **Function Signature**: ```python def word_pattern(pattern: str, input_string: str) -> bool: pass ``` # Input: - `pattern` (a string) containing only lowercase letters. - `input_string` (a string) containing lowercase words separated by a single space. # Output: - Return `True` if the string follows the pattern, `False` otherwise. # Constraints: - Length of `pattern` and words in `input_string` will be between 1 and 10^4. - Words in `input_string` are separated by a single space, and neither the pattern nor words contain any spaces. # Examples: ```python assert word_pattern(\\"abba\\", \\"dog cat cat dog\\") == True assert word_pattern(\\"abba\\", \\"dog cat cat fish\\") == False assert word_pattern(\\"aaaa\\", \\"dog cat cat dog\\") == False assert word_pattern(\\"abba\\", \\"dog dog dog dog\\") == False ``` # Explanation: - In the first example, \'a\' maps to \\"dog\\" and \'b\' maps to \\"cat\\", forming a valid pattern. - In the second example, \'a\' maps to \\"dog\\", but \'b\' should map to \\"cat\\", making the pattern invalid. - In the third example, \'a\' maps to \\"dog\\", but the pattern suggests that all characters should map to the same word. - In the fourth example, all characters map to \\"dog\\", resulting in an invalid pattern due to the requirement of a bijection. Ensure the implementation is efficient and considers all edge cases mentioned in the analysis.","solution":"def word_pattern(pattern: str, input_string: str) -> bool: words = input_string.split() if len(pattern) != len(words): return False char_to_word = {} word_to_char = {} for char, word in zip(pattern, words): if char in char_to_word: if char_to_word[char] != word: return False else: if word in word_to_char: return False char_to_word[char] = word word_to_char[word] = char return True"},{"question":"# Question: Unique Character String Construction Scenario You have been tasked with designing an algorithm for a text cleaning tool that ensures all characters in a given string appear only once. This tool will be used as part of data preparation in a larger text processing application, which demands high efficiency. Task Implement a function `unique_chars_string(s: str) -> str` that takes a string `s` as input and returns a new string with all duplicate characters removed, preserving the first occurrence of each character. Input Format * A single string `s`, consisting of any printable ASCII characters (0 <= len(s) <= 10^6). Output Format * A string which contains only the first occurrence of each character from the input string, in the same order as they first appear. Constraints * You should handle both uppercase and lowercase characters as distinct (i.e., \'A\' and \'a\' are different characters). * Optimize the function to handle large inputs up to the maximum constraint efficiently. Performance Requirements * Your solution should run in O(n) time where n is the length of the input string. Example ```plaintext Input: \\"abracadabra\\" Output: \\"abrcd\\" Input: \\"hello world\\" Output: \\"helo wrd\\" ``` **Notes:** 1. Ensure that your solution handles empty inputs correctly. 2. Consider using a set to track seen characters and a list to build the result for efficiency.","solution":"def unique_chars_string(s: str) -> str: Returns a new string with all duplicate characters removed, preserving the first occurrence of each character. seen = set() result = [] for char in s: if char not in seen: seen.add(char) result.append(char) return \'\'.join(result)"},{"question":"You are tasked with creating a class to calculate the moving average of a stream of integers using a fixed-size sliding window. Your implementation should ensure efficient appending and averaging operations for the sliding window. **Scenario**: A weather data collection system streams temperature readings continuously. To monitor trends, the system needs to calculate the moving average of the last \'n\' readings for real-time analysis. **Objective**: Implement the `MovingAverage` class with two methods: 1. `__init__(size: int)`: Initializes the class with a window size of \'size\'. 2. `next(val: int) -> float`: Updates the moving average with the incoming value \'val\' and returns the current moving average. **Constraints**: * The input value \'val\' will be a valid integer within the range of typical temperature readings. * The window size \'size\' will be a positive integer. **Performance Requirements**: The operations `next` should run in constant time O(1). # Function Signature ```python class MovingAverage: def __init__(self, size: int): # initialization code here def next(self, val: int) -> float: # updating moving average code here ``` # Example ```python m = MovingAverage(3) print(m.next(1)) # Output: 1.0 print(m.next(10)) # Output: 5.5 print(m.next(3)) # Output: 4.67 print(m.next(5)) # Output: 6.0 ``` # Explanation 1. `m.next(1)` initializes the window with [1], resulting in an average of 1.0. 2. `m.next(10)` updates the window to [1, 10], resulting in an average of (1 + 10) / 2 = 5.5. 3. `m.next(3)` updates the window to [1, 10, 3], resulting in an average of (1 + 10 + 3) / 3 = 4.67. 4. `m.next(5)` updates the window to [10, 3, 5], as the window slides, resulting in an average of (10 + 3 + 5) / 3 = 6.0. Implement the `MovingAverage` class and ensure all edge cases and constraints are handled effectively.","solution":"from collections import deque class MovingAverage: def __init__(self, size: int): self.size = size self.queue = deque() self.sum = 0 def next(self, val: int) -> float: if len(self.queue) == self.size: removed = self.queue.popleft() self.sum -= removed self.queue.append(val) self.sum += val return self.sum / len(self.queue)"},{"question":"# String Matching Challenge: Implement `strStr()` with Improved Efficiency Context You are tasked with enhancing the search functionality of a text editor. The current implementation uses a basic brute force approach to find the first occurrence of a substring (`needle`) within a main string (`haystack`). While this works for small texts, it becomes inefficient for larger inputs. Objective Implement the `strStr()` function using a more efficient algorithm. You can choose to implement either the Knuth-Morris-Pratt (KMP) algorithm or the Boyer-Moore algorithm to improve the performance. # Function Definition ```python def improved_strStr(haystack: str, needle: str) -> int: # Your implementation here ``` # Input and Output - **Input**: - `haystack` (str): The main string in which to search. - `needle` (str): The substring to search for. - **Output**: - Returns the index of the first occurrence of `needle` in `haystack`, or `-1` if the `needle` is not part of `haystack`. # Constraints - `0 ≤ len(haystack), len(needle) ≤ 10^5` - All characters in `haystack` and `needle` are lowercase English letters. # Performance Requirements - The solution should ideally have a time complexity better than O(n * m), where `n` is the length of `haystack` and `m` is the length of `needle`. - The space complexity should be O(n + m) or better. # Example ```python # Example 1: haystack = \\"hello\\" needle = \\"ll\\" print(improved_strStr(haystack, needle)) # Output: 2 # Example 2: haystack = \\"aaaaa\\" needle = \\"bba\\" print(improved_strStr(haystack, needle)) # Output: -1 # Example 3: haystack = \\"abcdef\\" needle = \\"\\" print(improved_strStr(haystack, needle)) # Output: 0 ``` # Additional Notes - If `needle` is an empty string, return 0. - Consider edge cases such as when `needle` is longer than `haystack` or when `haystack` is empty.","solution":"def improved_strStr(haystack: str, needle: str) -> int: Returns the index of the first occurrence of `needle` in `haystack`, or `-1` if `needle` is not part of `haystack` using the Knuth-Morris-Pratt Algorithm. if not needle: return 0 def build_kmp_table(needle): Builds KMP table to represent the length of proper prefix which is also suffix. m = len(needle) kmp_table = [0] * m length = 0 i = 1 while i < m: if needle[i] == needle[length]: length += 1 kmp_table[i] = length i += 1 else: if length != 0: length = kmp_table[length - 1] else: kmp_table[i] = 0 i += 1 return kmp_table n = len(haystack) m = len(needle) kmp_table = build_kmp_table(needle) i = 0 # index for haystack j = 0 # index for needle while i < n: if haystack[i] == needle[j]: i += 1 j += 1 if j == m: return i - j elif i < n and haystack[i] != needle[j]: if j != 0: j = kmp_table[j - 1] else: i += 1 return -1"},{"question":"# Question: Word Search with Trie and Backtracking Context You are given a 2D board of characters and a list of words. Your task is to determine which words from the list are present in the board. A word can be built from letters of sequentially adjoining cells, where \\"adjoining\\" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once in a word. Function Signature ```python def find_words_in_board(board: List[List[str]], words: List[str]) -> List[str]: pass ``` Input and Output - **Input**: - `board`: A 2D list of characters representing the board. - `words`: A list of strings representing the words to search for. - **Output**: - A list of strings representing the words found in the board. Constraints - Board dimensions: (1 leq board leq 12 times 12) - Word length: (1 leq text{length of each word} leq 10) - Number of words: (1 leq text{number of words} leq 10^3) Scenario Consider a word guessing game where a player is presented with a 4x4 board of letters and a list of words. They need to identify and list all the words that can be constructed by moving sequentially through adjoining (horizontally or vertically) letters on the board. Example Given the board: ```plaintext [[\'o\', \'a\', \'a\', \'n\'], [\'e\', \'t\', \'a\', \'e\'], [\'i\', \'h\', \'k\', \'r\'], [\'i\', \'f\', \'l\', \'v\']] ``` and the list of words: ```plaintext [\\"oath\\", \\"pea\\", \\"eat\\", \\"rain\\"] ``` the function should return: ```plaintext [\\"oath\\", \\"eat\\"] ``` Performance Requirements - Optimize the solution to efficiently search for words in the grid given the constraints. - Implement the solution leveraging backtracking and a Trie for optimal performance.","solution":"from typing import List, Dict class Trie: def __init__(self): self.children = {} self.end_of_word = False def insert(self, word: str): node = self for char in word: if char not in node.children: node.children[char] = Trie() node = node.children[char] node.end_of_word = True def find_words_in_board(board: List[List[str]], words: List[str]) -> List[str]: if not board or not board[0]: return [] rows, cols = len(board), len(board[0]) trie = Trie() # Build Trie for word in words: trie.insert(word) result = set() visited = [[False] * cols for _ in range(rows)] def backtrack(row: int, col: int, node: Trie, path: str): if node.end_of_word: result.add(path) if row < 0 or col < 0 or row >= rows or col >= cols or visited[row][col]: return char = board[row][col] if char not in node.children: return visited[row][col] = True for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: new_row, new_col = row + dx, col + dy backtrack(new_row, new_col, node.children[char], path + char) visited[row][col] = False for row in range(rows): for col in range(cols): if board[row][col] in trie.children: backtrack(row, col, trie, \\"\\") return list(result)"},{"question":"Problem Statement: Given a string as your input, remove any reoccurring character, and return the new string such that each character appears only once in the order of its first appearance. Implement a function `delete_reoccurring_characters_optimized(string: str) -> str` that accomplishes this task: Input * `string` (str): A string consisting of upper and lower case English letters and possibly digits. Output * (str): A new string with all reoccurring characters removed. Constraints * The length of the input string will not exceed 10^6 characters. * The string will contain only ASCII characters. Performance Requirements: * Your implementation should operate in linear time, O(n), where n is the length of the input string. * Use a list for collecting characters and a set to track seen characters, optimizing for performance in scenarios with large input strings. Example ```python assert delete_reoccurring_characters_optimized(\\"google\\") == \\"gole\\" assert delete_reoccurring_characters_optimized(\\"ababc\\") == \\"abc\\" assert delete_reoccurring_characters_optimized(\\"1112233\\") == \\"123\\" assert delete_reoccurring_characters_optimized(\\"\\") == \\"\\" ``` Good luck!","solution":"def delete_reoccurring_characters_optimized(string: str) -> str: Removes reoccurring characters from the string and returns a new string with each character appearing only once in the order of its first appearance. seen = set() result = [] for char in string: if char not in seen: seen.add(char) result.append(char) return \'\'.join(result)"},{"question":"You have been provided with an implementation of Heap Sort using both Max Heap and Min Heap. Your task is to implement a function that decides dynamically which heap sort to use based on a given configuration, and then sorts the array in ascending order. # Function Signature ```python def dynamic_heap_sort(arr: List[int], use_max_heap: bool, simulation: bool = False) -> List[int]: ``` # Input - `arr`: A list of integers that need to be sorted. - `use_max_heap`: A boolean flag. - If `True`, use the Max Heap Sort method. - If `False`, use the Min Heap Sort method. - `simulation`: An optional boolean flag (default to False) to simulate the sorting process, showing intermediate steps. # Output - Return a sorted list in ascending order. # Constraints - The array length (1 leq n leq 10^5) - Elements of the array are integers in the range ([-10^6, 10^6]). # Example ```python # Example 1 arr = [4, 10, 3, 5, 1] use_max_heap = True print(dynamic_heap_sort(arr, use_max_heap)) # Output: [1, 3, 4, 5, 10] # Example 2 arr = [4, 10, 3, 5, 1] use_max_heap = False print(dynamic_heap_sort(arr, use_max_heap)) # Output: [1, 3, 4, 5, 10] ``` # Notes 1. Ensure the simulation flag correctly prints intermediate steps when set to `True`. 2. Thoroughly test your implementation with edge cases like an empty array, a single-element array, already sorted arrays, and arrays in reverse order. 3. Maintain efficiency to handle larger datasets within time limits.","solution":"from typing import List def max_heapify(arr: List[int], n: int, i: int, simulate: bool): largest = i left = 2 * i + 1 right = 2 * i + 2 if left < n and arr[left] > arr[largest]: largest = left if right < n and arr[right] > arr[largest]: largest = right if largest != i: arr[i], arr[largest] = arr[largest], arr[i] if simulate: print(\\"Max-heapify step:\\", arr) max_heapify(arr, n, largest, simulate) def heap_sort_max(arr: List[int], simulate: bool): n = len(arr) for i in range(n // 2 - 1, -1, -1): max_heapify(arr, n, i, simulate) for i in range(n - 1, 0, -1): arr[i], arr[0] = arr[0], arr[i] if simulate: print(\\"Max-sort step:\\", arr) max_heapify(arr, i, 0, simulate) def min_heapify(arr: List[int], n: int, i: int, simulate: bool): smallest = i left = 2 * i + 1 right = 2 * i + 2 if left < n and arr[left] < arr[smallest]: smallest = left if right < n and arr[right] < arr[smallest]: smallest = right if smallest != i: arr[i], arr[smallest] = arr[smallest], arr[i] if simulate: print(\\"Min-heapify step:\\", arr) min_heapify(arr, n, smallest, simulate) def heap_sort_min(arr: List[int], simulate: bool): n = len(arr) for i in range(n // 2 - 1, -1, -1): min_heapify(arr, n, i, simulate) for i in range(n - 1, 0, -1): arr[i], arr[0] = arr[0], arr[i] if simulate: print(\\"Min-sort step:\\", arr) min_heapify(arr, i, 0, simulate) def dynamic_heap_sort(arr: List[int], use_max_heap: bool, simulation: bool = False) -> List[int]: new_arr = arr[:] if use_max_heap: heap_sort_max(new_arr, simulation) else: heap_sort_min(new_arr, simulation) new_arr.reverse() # Reverse to get ascending order since we sorted with min heap return new_arr"},{"question":"# Question: Graph Traversal Algorithm Implementation Context Given the implementation of a Directed Graph, your task is to implement a Breadth-First Search (BFS) algorithm to determine the shortest path from a given start node to all other nodes in the graph. The BFS algorithm will traverse the graph level by level from the start node and can be used to find the shortest path in an unweighted graph. Problem Statement Write a function `bfs_shortest_path(graph, start_node_name)` that takes a `DirectedGraph` object and the name of the start node as inputs and returns a dictionary. The dictionary keys are node names, and the values are the shortest path distances from the start node to each node. A non-reachable node should have a distance of `float(\'inf\')`. Function Signature ```python def bfs_shortest_path(graph: DirectedGraph, start_node_name: str) -> dict: ``` Input * `graph` (DirectedGraph): An instance of the DirectedGraph class. * `start_node_name` (str): The name of the start node. Output * A dictionary where each key is a node name and each value is the shortest distance from the start node. Constraints * The graph can have up to 10,000 nodes and 50,000 edges. * Node names are unique strings. * The start node will always exist in the graph. Example ```python # Create a directed graph from an adjacency dictionary graph_data = { \'A\': [\'B\', \'C\'], \'B\': [\'D\'], \'C\': [\'D\'], \'D\': [\'E\'], \'E\': [] } graph = DirectedGraph(graph_data) # Find the shortest path distances from node \'A\' distances = bfs_shortest_path(graph, \'A\') print(distances) # Expected output: {\'A\': 0, \'B\': 1, \'C\': 1, \'D\': 2, \'E\': 3} ``` Implementation Notes * Use a queue to manage the BFS traversal. * Maintain a set to keep track of visited nodes to avoid reprocessing. * Initialize distances with `float(\'inf\')` and set the start node distance to `0`.","solution":"from collections import deque, defaultdict class DirectedGraph: def __init__(self, adjacency_dict): self.graph = adjacency_dict def get_neighbors(self, node): return self.graph.get(node, []) def bfs_shortest_path(graph: DirectedGraph, start_node_name: str) -> dict: distances = {node: float(\'inf\') for node in graph.graph} distances[start_node_name] = 0 queue = deque([start_node_name]) while queue: current_node = queue.popleft() current_distance = distances[current_node] for neighbor in graph.get_neighbors(current_node): if distances[neighbor] == float(\'inf\'): # If not visited distances[neighbor] = current_distance + 1 queue.append(neighbor) return distances"},{"question":"You are provided with a list of integers representing frequencies of occurrences of various events. Your task is to efficiently handle queries related to the sum of frequencies up to a specific index and also update the frequency of an event at a specific index. You will implement a Fenwick Tree (Binary Indexed Tree) to support these operations. # Function Definitions You need to implement the following functions: 1. **update**: This function will update the frequency of an event at a specific index. 2. **query**: This function will return the sum of frequencies from the start up to a specific index. # Function Signatures ```python def update(bit_tree: list, idx: int, val: int) -> None: Updates the Fenwick Tree at given index by adding val to it. pass def query(bit_tree: list, idx: int) -> int: Returns the sum of the array from start to the given index by using Fenwick Tree. pass def construct(frequencies: list) -> list: Constructs the Fenwick Tree based on the given frequency list and returns it. pass ``` # Input Format 1. `frequencies`: A list of integers representing the frequencies of occurrences. 2. Different `update` and `query` operations in sequence, where: - `update` inputs: `index`, `value` (where value should be added to the frequency at the given index). - `query` input: `index` (upto which the sum should be calculated). # Output Format For each `query` operation, return the sum of elements from the start of the array up to the given index. # Example ```python frequencies = [3, 2, -1, 6, 5, 4, -3, 3, 7, 2, 3] bit_tree = construct(frequencies) update(bit_tree, 3, 6) # Update index 3 by adding 6 to it result = query(bit_tree, 5) # Should return sum of frequencies from index 0 to 5 print(result) # Expected output is 19 ``` # Constraints - 1 <= len(frequencies) <= 10^5 - -10^4 <= frequency value <= 10^4 - Multiple updates and queries may be there, handle updates first and then queries.","solution":"def update(bit_tree, idx, val): Updates the Fenwick Tree at given index by adding val to it. Fenwick Tree indices are 1-based, so we need to adjust the given index. idx += 1 # Convert to 1-based index while idx < len(bit_tree): bit_tree[idx] += val idx += idx & -idx def query(bit_tree, idx): Returns the sum of the array from start to the given index by using Fenwick Tree. Fenwick Tree indices are 1-based, so we need to adjust the given index. idx += 1 # Convert to 1-based index sum_ = 0 while idx > 0: sum_ += bit_tree[idx] idx -= idx & -idx return sum_ def construct(frequencies): Constructs the Fenwick Tree based on the given frequency list and returns it. n = len(frequencies) bit_tree = [0] * (n + 1) # Fenwick Tree with 1-based index for i in range(n): update(bit_tree, i, frequencies[i]) return bit_tree"},{"question":"# Graph Cloning Challenge Scenario In various data processing contexts, it\'s essential to preserve the original data structures while performing manipulations on their duplicates. Suppose you have an undirected graph where each node is labeled uniquely. Task Implement a function to clone an undirected graph. The graph is represented using basic node and adjacency list structures. You must ensure your cloned graph preserves the same labeling, connections, and structure as the original. Function Signature ```python def clone_graph(node: \'UndirectedGraphNode\') -> \'UndirectedGraphNode\': ``` Input - `node`: A reference to the node in the graph that we need to clone. Output - A reference to the node of the cloned graph corresponding to the input node. Constraints - The number of nodes in the graph will not exceed 1000. - The graph nodes are labeled with unique integer values. - The adjacency list for each node might include 0 to several other nodes forming unconnected, cyclic, or acyclic constructs. - Handle graphs containing self-loops. Examples 1. Given the graph serialization `{0,1,2#1,2#2,2}`, the visuals and neighbors are as follows: 1 / / 0 --- 2 / _/ Suppose `node` refers to the node labeled `0`. After cloning, the structure should be preserved with distinct node instances carrying the correct neighbors. Additional Clarifications - Do not mutate the original graph. - Ensure all copies are independent of the original but maintain identical connections and structures.","solution":"# Definition for an undirected graph node. class UndirectedGraphNode: def __init__(self, x): self.label = x self.neighbors = [] def clone_graph(node): if not node: return None # A dictionary to save the cloned nodes clones = {} # DFS function to perform cloning def dfs(current_node): if current_node in clones: return clones[current_node] # Create a new node clone clone = UndirectedGraphNode(current_node.label) clones[current_node] = clone # Iterate through neighbors to clone them recursively for neighbor in current_node.neighbors: clone_neigh = dfs(neighbor) clone.neighbors.append(clone_neigh) return clone return dfs(node)"},{"question":"# Polynomial and Monomial Operations **Context:** You are given a `Monomial` and `Polynomial` class designed to perform various arithmetic operations on monomials and polynomials. These classes support operations like addition, subtraction, multiplication, division, and variable substitution. Your task is to implement a specific function to achieve polynomial multiplication. **Objective:** Implement the function `multiply_polynomials(polynomial1: Polynomial, polynomial2: Polynomial) -> Polynomial` that multiplies two polynomials. Function Details: * **Input**: * `polynomial1` (Polynomial): First polynomial operand. * `polynomial2` (Polynomial): Second polynomial operand. * **Output**: * `Polynomial`: The result of multiplying `polynomial1` by `polynomial2`. To illustrate, if `polynomial1` has monomials ([2(a_1)^2, -1(a_2)^3(a_1)^{-1}]) and `polynomial2` has monomials ([3(a_1), 1]), then the resulting `Polynomial` would encompass all the products of each monomial from `polynomial1` with every monomial from `polynomial2`. Constraints: * You must ensure that the polynomial result is simplified, meaning no duplicate monomials should exist. * Coefficients of zero should be removed. ```python def multiply_polynomials(polynomial1: Polynomial, polynomial2: Polynomial) -> Polynomial: # Implement this method to multiply two polynomials pass # Example usage: p1 = Polynomial([ Monomial({1: 2}, 2), Monomial({2: 3, 1: -1}, -1) ]) p2 = Polynomial([ Monomial({1: 1}, 3), Monomial({}, 1) ]) print(multiply_polynomials(p1, p2)) # Should return the Polynomial resulting from (2(a_1)^2 + (-1)(a_2)^3(a_1)^(-1)) * (3(a_1) + 1) ``` Ensure to test your function with edge cases such as multiplication involving zero monomials, single-term polynomials, and high-degree polynomials. Your function should maintain the efficiency and principled design demonstrated in the provided classes.","solution":"class Monomial: def __init__(self, variables, coefficient): self.variables = variables # A dictionary {variable_index: exponent} self.coefficient = coefficient def __mul__(self, other): result_variables = self.variables.copy() for var, exp in other.variables.items(): if var in result_variables: result_variables[var] += exp else: result_variables[var] = exp return Monomial(result_variables, self.coefficient * other.coefficient) def __repr__(self): return f\\"{self.coefficient} * {\' \'.join([f\'a{var}^{exp}\' for var, exp in self.variables.items()])}\\" class Polynomial: def __init__(self, monomials): self.monomials = monomials def add_monomial(self, monomial): self.monomials.append(monomial) self.simplify() def simplify(self): terms = {} for monomial in self.monomials: term_key = tuple(sorted(monomial.variables.items())) if term_key in terms: terms[term_key] += monomial.coefficient else: terms[term_key] = monomial.coefficient self.monomials = [Monomial(dict(k), v) for k, v in terms.items() if v != 0] def __repr__(self): return \\" + \\".join([str(m) for m in self.monomials]) def multiply_polynomials(polynomial1, polynomial2): result = Polynomial([]) for monomial1 in polynomial1.monomials: for monomial2 in polynomial2.monomials: result.add_monomial(monomial1 * monomial2) return result"},{"question":"# Factorial Calculation with Modulo Operation Implement a function that calculates the factorial of a non-negative integer `n` with an optional modulo operation. You need to provide two versions of this function: one iterative and one recursive. # Function Signature ```python def factorial_iter(n: int, mod: int = None) -> int: pass def factorial_recur(n: int, mod: int = None) -> int: pass ``` # Input * An integer `n` (0 ≤ n ≤ 10^5) representing the number for which to calculate the factorial. * An optional integer `mod` (1 ≤ mod ≤ 10^9+7) if provided, the result should be calculated modulo `mod`. # Output * An integer representing `n!` or `n! % mod` if mod is specified. # Constraints * `n` will always be a non-negative integer. * If `mod` is provided, it will always be a positive integer. # Requirements * Implement both iterative and recursive versions of the factorial function. * Ensure proper exception handling for invalid inputs (though the constraints guarantee valid ones here). * Optimize for large values of `n` and `mod` for performance and to avoid overflow. # Examples ```python assert factorial_iter(5) == 120 assert factorial_iter(5, 3) == 0 # 120 % 3 = 0 assert factorial_recur(0) == 1 assert factorial_recur(10, 1000) == 800 # 3628800 % 1000 = 800 ``` Implement the functions and ensure they pass the provided tests.","solution":"def factorial_iter(n: int, mod: int = None) -> int: Returns the factorial of a non-negative integer n, optionally modulo mod. result = 1 for i in range(2, n + 1): result *= i if mod: result %= mod return result def factorial_recur(n: int, mod: int = None) -> int: Returns the factorial of a non-negative integer n, optionally modulo mod, using recursion. if n == 0 or n == 1: return 1 result = n * factorial_recur(n - 1, mod) if mod: result %= mod return result"},{"question":"**Scenario**: You are part of a team working on processing user input strings for a new text analytics tool. To ensure data integrity, you need to remove any additional occurrences of characters within the input strings, while preserving the first occurrence and original ordering. **Task**: Write a function `remove_duplicates` that takes a string as input and returns a new string with only the first occurrences of each character, preserving the order of their first appearances. **Function Signature**: ```python def remove_duplicates(s: str) -> str: # Your code here pass ``` **Input**: * `s`: A string of length n (0 <= n <= 10^6) containing any printable ASCII characters. **Output**: * A new string with duplicates removed, keeping the original character order for first appearances. **Constraints**: * The function should have O(n) time complexity where n is the length of the input string. * Space complexity should be kept reasonable, ideally O(n). **Examples**: ```python assert remove_duplicates(\\"hello\\") == \\"helo\\" assert remove_duplicates(\\"apple\\") == \\"aple\\" assert remove_duplicates(\\"mississippi\\") == \\"misp\\" assert remove_duplicates(\\"\\") == \\"\\" assert remove_duplicates(\\"abcd\\") == \\"abcd\\" ``` Your solution must handle edge cases like empty strings, strings with all unique characters, and very long strings efficiently.","solution":"def remove_duplicates(s: str) -> str: This function takes a string as input and returns a new string with only the first occurrences of each character, preserving the original order of their first appearances. seen = set() output = [] for char in s: if char not in seen: seen.add(char) output.append(char) return \'\'.join(output)"},{"question":"Context You are given a singly linked list which may contain duplicate values. Your task is to write a function that removes duplicate values from the list. You are required to implement two versions of this function: 1. One that uses a temporary buffer (e.g., a hashset). 2. One that does not use any additional data structures (no temporary buffer allowed). Requirements - **Function 1**: `remove_dups_with_buffer(head)` should use additional data structures to achieve O(N) time complexity. - **Function 2**: `remove_dups_without_buffer(head)` should not use any additional data structures and should achieve O(N^2) time complexity. Input Format - `head`: The head node of the singly linked list. Each node has the structure `Node(val)` where `val` is the string value of the node. Output Format - The list should be modified in place. Return the head of the modified list. Performance Constraints - `1 <= N <= 10^5` where N is the number of nodes in the linked list. Function Signatures ```python class Node(): def __init__(self, val = None): self.val = val self.next = None def remove_dups_with_buffer(head: Node) -> Node: pass def remove_dups_without_buffer(head: Node) -> Node: pass ``` Example ```python # The following code creates the linked list: A -> A -> B -> C -> D -> C -> F -> G a1 = Node(\\"A\\") a2 = Node(\\"A\\") b = Node(\\"B\\") c1 = Node(\\"C\\") d = Node(\\"D\\") c2 = Node(\\"C\\") f = Node(\\"F\\") g = Node(\\"G\\") a1.next = a2 a2.next = b b.next = c1 c1.next = d d.next = c2 c2.next = f f.next = g # Testing remove_dups_with_buffer new_head = remove_dups_with_buffer(a1) # Expected output list: A -> B -> C -> D -> F -> G print_linked_list(new_head) # Testing remove_dups_without_buffer new_head = remove_dups_without_buffer(a1) # Since remove_dups_with_buffer already processed the list, you may create the original list again before testing. # Expected output list: A -> B -> C -> D -> F -> G print_linked_list(new_head) ``` Edge Cases - Ensure the function handles empty lists correctly (i.e., `head = None`). - Edge cases with all nodes having the same value should be handled correctly to reduce it to a single node.","solution":"class Node: def __init__(self, val=None): self.val = val self.next = None def remove_dups_with_buffer(head: Node) -> Node: if not head: return None current = head seen = set() seen.add(current.val) while current.next: if current.next.val in seen: current.next = current.next.next else: seen.add(current.next.val) current = current.next return head def remove_dups_without_buffer(head: Node) -> Node: if not head: return None current = head while current: runner = current while runner.next: if runner.next.val == current.val: runner.next = runner.next.next else: runner = runner.next current = current.next return head def print_linked_list(head): current = head result = [] while current: result.append(current.val) current = current.next return \\" -> \\".join(result)"},{"question":"# Transitive Closure of a Directed Graph You are given a directed graph represented by an adjacency list. Your task is to compute the transitive closure of this graph. The transitive closure of a graph is a reachability matrix where the element at row `i` and column `j` is `1` if there is a path from vertex `i` to vertex `j`, and `0` otherwise. Input 1. An integer `vertices` representing the number of vertices in the graph (with vertices labeled from `0` to `vertices - 1`). 2. A list of pairs `(source, target)` representing directed edges in the graph. Output A 2D list (matrix) of size `vertices` x `vertices`, representing the transitive closure of the graph. Constraints * `1 <= vertices <= 100` * `0 <= len(edges) <= vertices * (vertices - 1)` Example ```python vertices = 4 edges = [(0, 1), (1, 2), (2, 3)] Output: [[1, 1, 1, 1], [0, 1, 1, 1], [0, 0, 1, 1], [0, 0, 0, 1]] ``` Performance Requirements Your solution should be efficient in terms of both time and space, suitable for dense graphs up to 100 vertices. Implementation Notes - Use the DFS approach to calculate the transitive closure. - Make sure your code handles graphs with isolated vertices and self-loops correctly.","solution":"def transitive_closure(vertices, edges): Computes the transitive closure of a directed graph. :param vertices: Number of vertices in the graph. :param edges: List of pairs (source, target) representing directed edges in the graph. :return: A 2D list representing the transitive closure of the graph. closure = [[0] * vertices for _ in range(vertices)] # Initialize the adjacency matrix representation of the graph for i in range(vertices): closure[i][i] = 1 # Every vertex is reachable from itself for u, v in edges: closure[u][v] = 1 # Use the Floyd-Warshall algorithm to compute the transitive closure for k in range(vertices): for i in range(vertices): for j in range(vertices): if closure[i][k] and closure[k][j]: closure[i][j] = 1 return closure"},{"question":"**Question**: Pangram Check Optimization You are given the task of optimizing a function to check if a given string is a pangram. A pangram is a sentence that contains every single letter of the alphabet at least once. For example, the sentence “The quick brown fox jumps over the lazy dog” is a pangram because it uses the letters A-Z at least once. Your task is to write a more efficient version of the `check_pangram` function. # Requirements * **Function Signature**: `def is_pangram(s: str) -> bool:` * **Input**: A string `s` (0 <= len(s) <= 10^6) * **Output**: A boolean value - `True` if the string is a pangram, `False` otherwise. * **Constraints**: - The string `s` contains only ASCII characters. # Example ```python assert is_pangram(\\"The quick brown fox jumps over the lazy dog\\") == True assert is_pangram(\\"Hello World\\") == False assert is_pangram(\\"\\") == False assert is_pangram(\\"abc defghijklmnopqrstuvwxyz\\") == True ``` # Performance Requirements The optimized solution should ideally complete in O(N) time complexity where N is the length of the string. # Brief Scenario You\'ve come across a collection of text files and you need an efficient tool to identify files that are complete in terms of containing every letter at least once from the English alphabet. Your job is to write an optimized function to help with this task.","solution":"def is_pangram(s: str) -> bool: Checks if the given string s is a pangram. :param s: The input string to check. :return: True if the input string is a pangram, False otherwise. # Create a set of all 26 lower case alphabets alphabet_set = set(\'abcdefghijklmnopqrstuvwxyz\') # Convert the input string to lower case for uniformity and create a set of characters present in it input_char_set = set(s.lower()) # Check if the alphabet set is a subset of the input character set return alphabet_set.issubset(input_char_set)"},{"question":"URL Query Parameter Processor You need to create a function `process_url` that takes in a URL and removes any duplicate query parameters and additionally removes any query parameters that are specified to be stripped. The goal is to ensure each query parameter in the resulting URL is unique and all unwanted parameters are removed. # Function Signature ```python def process_url(url: str, params_to_strip: Optional[List[str]] = None) -> str: ``` # Input * `url` (str): A URL string that may contain a query string. * `params_to_strip` (Optional[List[str]]): An optional list of query parameter keys you\'ve been asked to remove if they exist in the input URL. # Output * Returns a new URL string with duplicate query parameters removed and specified parameters stripped. # Constraints * If the URL does not contain any query parameters, it should be returned unchanged. * If no `params_to_strip` is provided, all duplicate query parameters should be removed without any additional parameter removal. * The function should handle special characters correctly. # Example ```python print(process_url(\\"www.example.com?a=1&b=2&a=2\\")) # Output: \\"www.example.com?a=1&b=2\\" print(process_url(\\"www.example.com?a=1&b=2&a=2\\", [\\"b\\"])) # Output: \\"www.example.com?a=1\\" print(process_url(\\"www.example.com?a=1&b=2&c=3&b=3&c=4\\", [\\"b\\", \\"c\\"])) # Output: \\"www.example.com?a=1\\" ``` # Important Points * Consider edge cases such as URLs without query strings or with query strings but without any keys to strip out. * Ensure your implementation handles performance efficiently, especially for URLs with many query parameters. * You may use Python built-in libraries to aid your solution if necessary.","solution":"from typing import Optional, List from urllib.parse import urlparse, parse_qs, urlencode, urlunparse def process_url(url: str, params_to_strip: Optional[List[str]] = None) -> str: if params_to_strip is None: params_to_strip = [] parsed_url = urlparse(url) query_params = parse_qs(parsed_url.query) # Keep only the first occurrence of each key (removing duplicates) filtered_query_params = {k: v[0] for k, v in query_params.items() if k not in params_to_strip} filtered_query_string = urlencode(filtered_query_params, doseq=True) new_url = urlunparse((parsed_url.scheme, parsed_url.netloc, parsed_url.path, parsed_url.params, filtered_query_string, parsed_url.fragment)) return new_url"},{"question":"Problem Statement **Context**: A large sorted dataset has been provided, and you need to efficiently find the index of the last occurrence of a specific number within this dataset. **Task**: Implement a function `last_occurrence(array, query)` that takes a sorted list of integers `array` and a single integer `query`, and returns the index of the last occurrence of `query` in `array`. If the number is not found, return `-1`. # Function Signature: ```python def last_occurrence(array: List[int], query: int) -> int: ``` # Input: * `array`: A list of integers sorted in increasing order. Length of `array` is `n` (0 <= n <= 10^5). * `query`: An integer to find in the array (-10^6 <= query <= 10^6). # Output: * An integer representing the index of the last occurrence of `query` in `array`. If `query` is not found, return `-1`. # Constraints: * The algorithm should have a time complexity of O(log n). * Assume that the input list is sorted in increasing order. # Example: Input: ```python array = [1, 2, 2, 2, 3, 4, 5] query = 2 ``` Output: ```python 3 ``` # Explanation: The number `2` appears multiple times in the array at indices `[1, 2, 3]`. The last occurrence is at index `3`. # Additional Notes: Carefully handle the case where the array is empty or the `query` is not present in the array. Watching out for boundary conditions where `query` is at the ends of the array is crucial.","solution":"from typing import List def last_occurrence(array: List[int], query: int) -> int: Returns the index of the last occurrence of query in array. If not found, returns -1. left, right = 0, len(array) - 1 result = -1 while left <= right: mid = (left + right) // 2 if array[mid] == query: result = mid left = mid + 1 # Keep searching to the right for the last occurrence elif array[mid] < query: left = mid + 1 else: right = mid - 1 return result"},{"question":"**Binomial Coefficient with Constraints** You are working on combinatorial problems and need to compute the binomial coefficient ( C(n, k) ). Given the constraints of time and space, you must implement an efficient algorithm. # Problem Description Write a function `efficient_binomial_coefficient(n, k)` that computes the binomial coefficient ( C(n, k) ) using an iterative approach to prevent deep recursion and excessive computation time while managing large values for ( n ). # Input - Two integers, `n` and `k`, where ( 0 leq k leq n ). # Output - An integer representing the binomial coefficient ( C(n, k) ). # Constraints - ( 0 leq k leq n leq 10^5 ) # Performance Requirements - Time complexity should be optimized towards O(k). - Space complexity should be minimal, preferably O(1) additional space. # Example ```python # Example 1 n = 5 k = 2 efficient_binomial_coefficient(n, k) # Output: 10 # Example 2 n = 8 k = 3 efficient_binomial_coefficient(n, k) # Output: 56 # Example 3 n = 100 k = 50 efficient_binomial_coefficient(n, k) # Output: 100891344545564193334812497256 ``` Write your implementation for the function `efficient_binomial_coefficient(n, k)` using an iterative approach.","solution":"def efficient_binomial_coefficient(n, k): Computes the binomial coefficient C(n, k) using an iterative approach. :param n: The total number of items. :param k: The number of items to choose. :return: The binomial coefficient C(n, k). # Since C(n, k) == C(n, n-k), we choose the smaller k to minimize the number of multiplications. if k > n - k: k = n - k # Initialize result result = 1 # Calculate the result iteratively to prevent overflow and improve efficiency for i in range(k): result = result * (n - i) // (i + 1) return result"},{"question":"# Context Given an encoded string, your task is to return its decoded version. The encoding rule is defined as follows: `k[encoded_string]`, where the `encoded_string` inside the square brackets is repeated exactly `k` times. You can assume `k` is a positive integer. The input string is always valid with no extra white spaces and proper bracket formation. # Examples * `s = \\"3[a]2[bc]\\"`, return `\\"aaabcbc\\"`. * `s = \\"3[a2[c]]\\"`, return `\\"accaccacc\\"`. * `s = \\"2[abc]3[cd]ef\\"`, return `\\"abcabccdcdcdef\\"`. # Function Signature ```python def decode_string(s): :type s: str :rtype: str ``` # Input and Output Format * **Input**: - `s` (a string) - an encoded string following the defined rule. * **Output**: - `return` (a string) - the decoded string. # Constraints * The string will only contain digits, squares brackets, and lowercase letters. * The input string is guaranteed to be well-formed. # Performance Requirements * Time Complexity: O(N) * Space Complexity: O(N) # Task Implement the function `decode_string(s)` that decodes the given encoded string based on the k[encoded_string] rule.","solution":"def decode_string(s): Decodes the given encoded string based on the k[encoded_string] rule. :type s: str :rtype: str stack = [] current_string = \\"\\" current_num = 0 for char in s: if char.isdigit(): current_num = current_num * 10 + int(char) elif char == \'[\': stack.append((current_string, current_num)) current_string = \\"\\" current_num = 0 elif char == \']\': last_string, num = stack.pop() current_string = last_string + current_string * num else: current_string += char return current_string"},{"question":"Problem Description Given two strings `s` and `t` which consist of only lowercase letters. String `t` is generated by shuffling string `s` and then adding one more letter at a random position. Write a function `find_added_letter` to find the letter that was added in `t`. Function Signature ```python def find_added_letter(s: str, t: str) -> str: pass ``` Input * `s` - A string of lowercase letters (1 <= |s| <= 10^5) * `t` - A string created by shuffling `s` and adding one more letter (len(t) == len(s) + 1) Output * A single character that represents the added letter in `t`. Constraints * Both `s` and `t` consist only of lowercase English letters. * Each test case has exactly one valid solution. Scenario Imagine you are given two bags containing alphabet blocks. One bag contains blocks representing the characters in string `s`, and the other bag, representing string `t`, has all the blocks from the first bag plus one additional block. Your task is to find out which letter was added to the second bag. Example * Input: * `s = \\"abcd\\"` * `t = \\"abecd\\"` * Output: `\'e\'` Hints * Consider properties of the XOR operation. * Think about how XOR cancels out identical elements when used in a pair.","solution":"def find_added_letter(s: str, t: str) -> str: Returns the letter that was added to t. # Using XOR method to find the added character result = 0 for char in s + t: result ^= ord(char) return chr(result)"},{"question":"Wiggle Sort Implementation Context Suppose you are working on a signal processing application that needs to transform an array of amplitudes into a \\"wiggle\\" pattern for visualization purposes. You need to ensure the array follows a zigzag pattern where every element at an even index is less than its next element and every element at an odd index is greater than its next element. Task Write a function `wiggle_sort(nums)` that reorders an unsorted list of integers `nums` to satisfy the wiggle pattern: nums[0] < nums[1] > nums[2] < nums[3] > ... Function Signature ```python def wiggle_sort(nums: List[int]) -> None: Modify nums in-place to satisfy the wiggle pattern. :params nums: List[int] - A list of unsorted integers. ``` Input * `nums` - a list of integers with 1 ≤ len(nums) ≤ 10^4 and -10^9 ≤ nums[i] ≤ 10^9. Output * The input list `nums` should be modified in-place to follow the wiggle pattern. # Constraints * You must achieve this in a single pass with O(n) time complexity. * You may not use additional lists or arrays to achieve the result (O(1) space complexity). # Example *Input*: ```python nums = [3, 5, 2, 1, 6, 4] ``` *Output*: ```python [3, 5, 1, 6, 2, 4] # One of the valid outputs ``` **Note**: The output must satisfy the wiggle pattern but does not need to be exactly as shown in the example. There can be multiple correct solutions.","solution":"def wiggle_sort(nums): Reorders the list \'nums\' in place to satisfy the wiggle pattern: nums[0] < nums[1] > nums[2] < nums[3] > ... :params nums: List[int] - A list of unsorted integers. for i in range(len(nums) - 1): if (i % 2 == 0 and nums[i] > nums[i + 1]) or (i % 2 == 1 and nums[i] < nums[i + 1]): nums[i], nums[i + 1] = nums[i + 1], nums[i]"},{"question":"# Question: Implement Advanced RLE Compression and Decompression Run-Length Encoding (RLE) is a simple compression algorithm that represents consecutive repeated characters in data by the character and the number of times it is repeated. You need to implement two functions: `advanced_encode_rle` and `advanced_decode_rle`. The `advanced_encode_rle` function will take a string and return its RLE encoded form. The `advanced_decode_rle` function will take an RLE encoded string and return the original string. Constraints * The input string to `advanced_encode_rle` will have a maximum length of 10^5 characters. * The RLE encoded string to `advanced_decode_rle` will be valid and follow the RLE format. * You must handle cases where the count for a single character exceeds 9 (e.g., \\"aaaaaaaaaaa\\" should be encoded as \\"11a\\"). Input Format # Function 1: `advanced_encode_rle` - `input`: A string to be encoded (1 <= length <= 10^5). # Function 2: `advanced_decode_rle` - `input`: An RLE encoded string to be decoded, following the count-character pattern (1 <= length <= 300,000). Output Format # Function 1: `advanced_encode_rle` - Return the RLE encoded string. # Function 2: `advanced_decode_rle` - Return the decoded original string. Example ```python # Example usage encoded_str = advanced_encode_rle(\\"aaaaaaaaabbbbcccd\\") # Should return \'9a2a4b3c1d\' (or similar valid RLE) decoded_str = advanced_decode_rle(\\"9a2a4b3c1d\\") # Should return \'aaaaaaaaabbbbcccd\' ``` Additional Notes - Consider edge cases, such as strings with no repeating characters, all identical characters, and very long strings. - Ensure your implementations efficiently handle large input sizes within the constraints.","solution":"def advanced_encode_rle(s): if not s: return \\"\\" encoded_str = [] current_char = s[0] count = 1 for char in s[1:]: if char == current_char: count += 1 else: while count > 9: encoded_str.append(f\\"9{current_char}\\") count -= 9 encoded_str.append(f\\"{count}{current_char}\\") current_char = char count = 1 while count > 9: encoded_str.append(f\\"9{current_char}\\") count -= 9 encoded_str.append(f\\"{count}{current_char}\\") return \\"\\".join(encoded_str) def advanced_decode_rle(encoded_s): decoded_str = [] i = 0 while i < len(encoded_s): j = i while encoded_s[j].isdigit(): j += 1 count = int(encoded_s[i:j]) char = encoded_s[j] decoded_str.append(char * count) i = j + 1 return \\"\\".join(decoded_str)"},{"question":"**Scenario**: You are a developer for a scientific computing software suite, and you need to implement a function that leverages the hailstone sequence. The goal is to not just compute the sequence but also to analyze some essential properties like the length of the sequence and the maximum value encountered in the sequence. **Problem Statement**: Write a function `analyze_hailstone_sequence(n)` that computes the hailstone sequence for an integer (n). Alongside returning the sequence, the function should also return the length of the sequence and the maximum value encountered in the sequence. # Function Signature ```python def analyze_hailstone_sequence(n: int) -> (List[int], int, int): ``` # Input: * An integer `n` where (1 leq n leq 10^6). # Output: * A tuple containing: * A list of integers representing the hailstone sequence starting from `n` and ending at 1. * An integer representing the length of the sequence. * An integer representing the maximum value encountered in the sequence. # Constraints: * You must handle numbers up to (10^6) efficiently. * Ensure the solution can run within reasonable time limits for large (n). # Example: ```python assert analyze_hailstone_sequence(7) == ([7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1], 17, 52) assert analyze_hailstone_sequence(1) == ([1], 1, 1) assert analyze_hailstone_sequence(10) == ([10, 5, 16, 8, 4, 2, 1], 7, 16) ``` # Notes: * Focus on implementing the function in a way that accurately computes the sequence, its length, and the max value. * Ensure your code is well-tested with large values within the specified range.","solution":"def analyze_hailstone_sequence(n: int) -> (list, int, int): if n < 1 or n > 10**6: raise ValueError(\\"n should be between 1 and 10^6 inclusive.\\") sequence = [] max_value = n while n != 1: sequence.append(n) if n % 2 == 0: n = n // 2 else: n = 3 * n + 1 max_value = max(max_value, n) sequence.append(1) length = len(sequence) return sequence, length, max_value"},{"question":"# String Reversal Implementation **Context**: You are tasked with implementing a string reversal function. Different methods of reversing strings have been shown, each with different approaches and complexities. Your objective is to implement a function that reverses a given string using the most efficient and pythonic way. **Objective**: Write a function `reverse_string(s: str) -> str` that takes a string `s` as input and returns the reversed string. **Requirements**: - Implement the function using the slicing method (as it is the most concise and efficient). **Specifications**: - **Input**: A string `s` where `0 <= len(s) <= 10^6`. - **Output**: A string that is the reversed version of `s`. **Constraints**: - You must handle edge cases such as empty string and single character string. - Performance must be optimal to handle strings up to length 10^6 efficiently. **Examples**: ```python assert reverse_string(\\"hello\\") == \\"olleh\\" assert reverse_string(\\"Python\\") == \\"nohtyP\\" assert reverse_string(\\"\\") == \\"\\" assert reverse_string(\\"A\\") == \\"A\\" assert reverse_string(\\"12345\\") == \\"54321\\" assert reverse_string(\\"race car\\") == \\"rac ecar\\" ``` **Function Signature**: ```python def reverse_string(s: str) -> str: # Implement the function here pass ```","solution":"def reverse_string(s: str) -> str: Takes a string s and returns the reversed string. return s[::-1]"},{"question":"# Bitonic Sort Implementation Given the code snippet for a bitonic sort algorithm, we need to implement a function to check if the input array is properly sorted. Your task is to write a Python function `is_sorted` that verifies if a given list is sorted in either ascending or descending order. # Function Signature ```python def is_sorted(arr: list, ascending: bool = True) -> bool: ``` # Input * `arr`: A list of integers that needs to be checked for sorted order. * `ascending`: A boolean value that indicates whether to check for ascending (`True`) or descending (`False`) order. Default value is `True`. # Output * Returns `True` if the list is sorted in the specified order, otherwise returns `False`. # Example Example 1: * Input: `arr = [1, 2, 3, 4, 5]`, `ascending = True` * Output: `True` * Explanation: The list is sorted in ascending order. Example 2: * Input: `arr = [5, 4, 3, 2, 1]`, `ascending = False` * Output: `True` * Explanation: The list is sorted in descending order. Example 3: * Input: `arr = [1, 3, 2, 4, 5]`, `ascending = True` * Output: `False` * Explanation: The list is not sorted in ascending order. # Constraints * The function should handle lists of varying lengths, including empty lists and lists with a single element. * Time complexity should be O(n) where n is the length of the list. # Additional Information The is_sorted function is essential for verifying the correctness of sorting algorithms, such as the bitonic sort, for both unit tests and practical use-cases. Write your answer in the provided function skeleton below. ```python def is_sorted(arr: list, ascending: bool = True) -> bool: # Your code here ``` # Assessment Criteria Your implementation will be evaluated based on: * Correctness: Properly returns `True` or `False` based on the sorting check. * Efficiency: Operates within O(n) time complexity. * Edge Cases: Appropriately handles edge cases such as empty lists and single-element lists.","solution":"def is_sorted(arr: list, ascending: bool = True) -> bool: This function checks whether a given array is sorted in a specified order (ascending or descending). :param arr: The list of integers to check. :param ascending: Boolean indicating if the order should be ascending (default is True) or descending. :returns: True if the list is sorted in the specified order, False otherwise. if ascending: return all(arr[i] <= arr[i + 1] for i in range(len(arr) - 1)) else: return all(arr[i] >= arr[i + 1] for i in range(len(arr) - 1))"},{"question":"# Problem: Balanced Parentheses Validator You are tasked with implementing a function that validates whether a given string containing various types of brackets is balanced. A string is considered balanced if each type of bracket (`()`, `{}`, `[]`) is correctly opened and closed in the correct order. Function Signature ```python def is_balanced_brackets(s: str) -> bool: pass ``` # Input * A single string `s` with length n (0 <= n <= 10^4). * The string contains the characters `(`, `)`, `{`, `}`, `[`, and `]`. # Output * Return `True` if the string is balanced; otherwise, return `False`. # Constraints * The function should run in O(n) time complexity. * The function should use O(n) space complexity in the worst case. # Examples ```python print(is_balanced_brackets(\\"()\\")) # True print(is_balanced_brackets(\\"()[]{}\\")) # True print(is_balanced_brackets(\\"(]\\")) # False print(is_balanced_brackets(\\"([)]\\")) # False print(is_balanced_brackets(\\"{[]}\\")) # True print(is_balanced_brackets(\\"\\")) # True print(is_balanced_brackets(\\"[\\")) # False ``` # Explanation * The function should return `True` for the following reasons: - `()` is a pair of matched parentheses. - `()[]{}` - `{[]}` represents nested valid brackets. * Whereas `False` should be returned for: - `(]` mismatched brackets. - `([)]` correctly nested but incorrectly closed. - `[` single opening bracket with no matching closing. # Detailed Requirements 1. Your solution needs to focus on using stack data structure effectively to ensure constant time checking for each character. 2. All types of brackets need to be correctly matched. 3. Edge cases like empty strings and strings with a single type of bracket need to be considered. Implement the function `is_balanced_brackets` to solve this problem.","solution":"def is_balanced_brackets(s: str) -> bool: stack = [] bracket_map = {\')\': \'(\', \'}\': \'{\', \']\': \'[\'} for char in s: if char in bracket_map.values(): stack.append(char) elif char in bracket_map.keys(): if stack == [] or bracket_map[char] != stack.pop(): return False else: # If the character is not a bracket, we ignore it. continue return stack == []"},{"question":"# Question Context You are tasked with developing a function to check if a given pattern string and word string maintain the same bijection (one-to-one correspondence). Task Description Implement a function `word_pattern(pattern: str, s: str) -> bool` that returns `True` if `s` follows the same pattern as `pattern`, and `False` otherwise. A pattern string `pattern` consists of lowercase letters, and a word string `s` consists of words separated by a single space. For the mapping to be valid, each character in the pattern must uniquely map to a word in `s` and vice versa. Function Signature ```python def word_pattern(pattern: str, s: str) -> bool: pass ``` Input - `pattern` (string): A pattern consisting of only lowercase letters (e.g., \\"abba\\"). - `s` (string): A string consisting of lowercase words separated by single spaces (e.g., \\"dog cat cat dog\\"). Output - Returns a boolean value: `True` if the word string follows the bijection pattern, otherwise `False`. Constraints - Both `pattern` and `s` are non-empty. - The length of `pattern` does not exceed 50. - Words in `s` are non-empty and consist of lowercase letters only. # Examples ```python assert word_pattern(\\"abba\\", \\"dog cat cat dog\\") == True assert word_pattern(\\"abba\\", \\"dog cat cat fish\\") == False assert word_pattern(\\"aaaa\\", \\"dog cat cat dog\\") == False assert word_pattern(\\"abba\\", \\"dog dog dog dog\\") == False assert word_pattern(\\"abba\\", \\"dog cat dog\\") == False # Pattern and word count mismatch ``` Remember to consider edge cases in your implementation, such as mismatched lengths and already existing mappings leading to conflicting bijections.","solution":"def word_pattern(pattern: str, s: str) -> bool: words = s.split() if len(pattern) != len(words): return False char_to_word = {} word_to_char = {} for c, w in zip(pattern, words): if c not in char_to_word: if w in word_to_char: return False char_to_word[c] = w word_to_char[w] = c else: if char_to_word[c] != w: return False return True"},{"question":"Stooge Sort Verification Context Stooge Sort is known for its theoretical interest rather than practical use due to its inefficiency. This question aims to verify your understanding and capability to implement this sorting algorithm with a focus on ensuring correctness and edge case handling. Objective Implement the Stooge Sort algorithm in Python. Your implementation should be recursive, follow the principles of Stooge Sort, and correctly handle various edge cases. Function Signature ```python def stoogesort(arr: List[int], l: int, h: int) -> None: pass ``` Input Format - `arr`: List of integers `arr` (1 <= len(arr) <= 100) - `l`: The starting index of the list segment to sort (0 <= l < len(arr)) - `h`: The ending index of the list segment to sort (0 <= h < len(arr)) Output Format - The function will modify the input list `arr` in-place to sort the elements between indices `l` and `h`. Constraints - The array can contain duplicate elements. - You should ensure that the function can handle cases where `l >= h` without errors. Example # Input ```python arr = [5, 1, 3, 2, 8, 6, 7, 4, 0, 9] stoogesort(arr, 0, len(arr)-1) ``` # Output ```python # The array should be sorted in ascending order print(arr) # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] ``` Notes 1. You are allowed to use the provided function signature and implement the function in such a way that it sorts the array in-place. 2. Ensure proper handling of edge cases such as a segment with a single element or an empty segment.","solution":"def stoogesort(arr, l, h): Sorts the array \'arr\' in place using the Stooge Sort algorithm from index \'l\' to index \'h\'. if l >= h: return if arr[l] > arr[h]: arr[l], arr[h] = arr[h], arr[l] if h - l + 1 > 2: t = (h - l + 1) // 3 stoogesort(arr, l, h - t) stoogesort(arr, l + t, h) stoogesort(arr, l, h - t)"},{"question":"# Question A popular coding challenge involves filling each empty room in a 2D grid with the distance to its nearest gate using the Depth-First Search (DFS) algorithm. Here, you will implement a similar function but with a more efficient approach using the Breadth-First Search (BFS) algorithm. # Problem Statement You are given an `m x n` 2D grid initialized with these three possible values: * `-1`: A wall or an obstacle. * `0`: A gate. * `INF`: Infinity means an empty room. You will use the value 2^31 - 1 = 2147483647 to represent INF as you may assume that the distance to a gate is less than 2147483647. Your task is to fill each empty room with the distance to its nearest gate. If it is impossible to reach a gate, the room should remain filled with `INF`. # Input * `rooms`: A list of lists (2D grid) with dimensions `m x n`. Each element in the grid can be `-1`, `0`, or `2147483647`. # Output * Modify the `rooms` grid in place, i.e., do not return anything. # Constraints * `1 <= m, n <= 300` # Example Given the input grid: ``` [ [2147483647, -1, 0, 2147483647], [2147483647, 2147483647, 2147483647, -1], [2147483647, -1, 2147483647, -1], [0, -1, 2147483647, 2147483647] ] ``` The output grid should be: ``` [ [3, -1, 0, 1], [2, 2, 1, -1], [1, -1, 2, -1], [0, -1, 3, 4] ] ``` # Requirements * Implement the function `walls_and_gates(rooms)` which takes the 2D grid `rooms` as an argument. * Use a more efficient breadth-first search (BFS) approach. **Note**: Begin the breadth-first search from all gates simultaneously to ensure all rooms are filled with the shortest distance efficiently. # Function Signature ```python def walls_and_gates(rooms: List[List[int]]) -> None: # Your code here ```","solution":"from collections import deque from typing import List def walls_and_gates(rooms: List[List[int]]) -> None: Fills each empty room with the distance to its nearest gate using BFS. if not rooms: return m, n = len(rooms), len(rooms[0]) queue = deque() # Initialize the queue with all gates for i in range(m): for j in range(n): if rooms[i][j] == 0: queue.append((i, j)) # BFS from all gates directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] while queue: x, y = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and rooms[nx][ny] == 2147483647: rooms[nx][ny] = rooms[x][y] + 1 queue.append((nx, ny))"},{"question":"**Context**: You are tasked with building a search functionality for a reservation system, which needs to locate the most recent booking for a specific customer in a sorted list of reservations. Each reservation is represented as a tuple of `(customer_id, reservation_date)`. Your task is to write a function that returns the index of the last reservation made by a given customer in the sorted list. **Function Specification**: * **Function Name**: `last_reservation` * **Input**: * `reservations` (List[Tuple[int, str]]): A sorted list of tuples where each tuple is of the format `(customer_id, reservation_date)`. * `customer_id` (int): The ID of the customer for which the last reservation needs to be found. * **Output**: * (int): The index of the last reservation for the given customer in the list. If the customer is not found in the list, return -1. **Constraints**: * The list `reservations` is sorted in increasing order based on `customer_id`. * `customer_id` is guaranteed to be a non-negative integer. * `reservations` may be empty. **Performance Requirements**: * Aim for O(log n) time complexity. **Example**: ```python reservations = [ (1001, \\"2023-05-01\\"), (1002, \\"2023-05-10\\"), (1003, \\"2023-05-12\\"), (1003, \\"2023-05-15\\"), (1003, \\"2023-05-20\\"), ] customer_id = 1003 # Expected output: 4 (Index of the last reservation for customer 1003) print(last_reservation(reservations, customer_id)) customer_id = 1004 # Expected output: -1 (Customer 1004 is not found in the list) print(last_reservation(reservations, customer_id)) ``` **Notes**: * Make use of the Binary Search technique to achieve optimal time complexity. * Handle edge cases such as an empty reservation list or a customer id not present in the list.","solution":"def last_reservation(reservations, customer_id): Returns the index of the last reservation made by the given customer in the list. If the customer_id is not found in the list, returns -1. :param reservations: List[Tuple[int, str]] - A sorted list of tuples (customer_id, reservation_date) in increasing order based on customer_id :param customer_id: int - The ID of the customer for which the last reservation needs to be found :return: int - The index of the last reservation for the given customer_id in the list. left, right = 0, len(reservations) - 1 result = -1 while left <= right: mid = (left + right) // 2 mid_customer_id = reservations[mid][0] if mid_customer_id == customer_id: result = mid left = mid + 1 # Keep searching in the right half elif mid_customer_id < customer_id: left = mid + 1 else: right = mid - 1 return result"},{"question":"# Problem: Efficient Missing Number Finder You are given a large sorted array of unique integers `arr`, which contains integers from 1 to n with exactly one missing number. Your task is to use an efficient search algorithm to identify the missing number in the array. Implement the function `find_missing_number(arr: List[int]) -> int` where: - Input: A sorted list of unique integers `arr` with exactly one number missing from the sequence. - Output: The missing integer. **Constraints**: - The array `arr` is guaranteed to have length `n-1` (one number missing from a total of n). - The integers in `arr` range from 1 to n. # Examples 1. If `arr = [1, 2, 3, 5]`, the function should return `4`. 2. If `arr = [1, 3, 4, 5, 6]`, the function should return `2`. # Performance Requirements Your implementation should aim to have a time complexity better than O(n) and utilize space efficiently (O(1) space complexity preferred). You may leverage jump search principles to optimize the search process by narrowing down the range within the list to find the missing number effectively. # Additional Information You should handle edge cases where the missing number is at the beginning or end of the array efficiently. For the purpose of this problem, assume that the sorted array `arr` is non-empty and valid as described. Compose your function considering all provided constraints and test it thoroughly.","solution":"def find_missing_number(arr): Finds the missing number in a sorted array of unique integers ranging from 1 to n. n = len(arr) + 1 # Total number of elements including the missing number left, right = 0, len(arr) - 1 while left <= right: mid = (left + right) // 2 if arr[mid] != mid + 1: # Missing number is on the left side (inclusive of mid) right = mid - 1 else: # Missing number is on the right side left = mid + 1 # The point where left becomes greater than right is where the missing number should be return left + 1"},{"question":"# Task Description You are given an array of integers and two optional limits (minimum and maximum). Your task is to write a Python function `value_filter` that filters the values in the array to include only those within the specified range and return the new filtered list. Unlike the provided `limit` function, your implementation must handle non-numeric elements appropriately by ignoring them. # Function Signature ```python def value_filter(arr: List[Union[int, float]], min_lim: Optional[Union[int, float]] = None, max_lim: Optional[Union[int, float]] = None) -> List[Union[int, float]]: # Your code here ``` # Input Format - An array of integers and/or floats `arr` of length `n` (0 ≤ n ≤ 10^6). - An optional integer or float `min_lim` (can be `None`). - An optional integer or float `max_lim` (can be `None`). # Output Format - The function should return a list containing only the elements from `arr` that lie between `min_lim` and `max_lim` inclusively, filtered in original order. - Non-numeric elements should be ignored. # Constraints - If `min_lim` is `None`, no lower limit is applied. - If `max_lim` is `None`, no upper limit is applied. - The function should be optimized for performance given the constraints. # Example ```python # Example 1: value_filter([1, 2, 3, 4, \'a\', None, 5], 2, 4) # Output: [2, 3, 4] # Example 2: value_filter([-10, 20, 30, -40], min_lim=-15) # Output: [-10, 20, 30] # Example 3: value_filter([1, 2, 3, \'b\', 5]) # Output: [1, 2, 3, 5] ``` # Explanation In the above examples: 1. Non-numeric elements (`\'a\'` and `None`) are ignored, and only values between 2 and 4 inclusive are included. 2. Negative numbers that are greater or equal to -15 are included without an upper limit. 3. Only numeric elements are considered, since neither limit is provided, all numeric values are included.","solution":"from typing import List, Union, Optional def value_filter(arr: List[Union[int, float]], min_lim: Optional[Union[int, float]] = None, max_lim: Optional[Union[int, float]] = None) -> List[Union[int, float]]: Filters the values in the array to include only those within the specified range and returns the new filtered list. Args: - arr: A list of integers and/or floats. - min_lim: An optional integer or float that represents the minimum limit. - max_lim: An optional integer or float that represents the maximum limit. Returns: - A list of integers and/or floats filtered by the specified limits. filtered_list = [] for val in arr: if isinstance(val, (int, float)): if (min_lim is None or val >= min_lim) and (max_lim is None or val <= max_lim): filtered_list.append(val) return filtered_list"},{"question":"# Sorting Financial Transactions Context You are tasked with creating a module to sort a large number of financial transaction values for a fintech application. The transaction values are floating point numbers that can range from 0.00 to 10,000.00. However, the values are generally spread out uniformly within this range. To achieve optimal performance for real-time financial analysis, you decide to implement and optimize the bucket sort algorithm. # Task Implement a function `optimized_bucket_sort(arr: List[float]) -> List[float]` that sorts an array containing transaction values using an optimized bucket sort algorithm based on the provided pseudocode. Replace the insertion sort within bucket sort with a more efficient sorting algorithm for sorting elements within each bucket to handle larger inputs effectively. # Input - `arr`: A list of floating-point numbers, representing financial transactions. Each element of `arr` lies within the range [0.00, 10000.00]. # Output - Return a sorted list of transaction values. # Constraints - The input list can contain up to 1,000,000 transactions. - Each transaction value is rounded to two decimal places. - Assume that transactions are uniformly distributed within the range. # Performance Requirements - The implementation should aim to achieve better than O(n^2) time complexity. - Efficient memory usage to handle up to 1,000,000 elements. # Example ```python transactions = [2500.34, 999.99, 750.00, 5050.01, 6300.77, 8200.36, 1500.22, 4100.88] sorted_transactions = optimized_bucket_sort(transactions) print(sorted_transactions) # Expected: [750.00, 999.99, 1500.22, 2500.34, 4100.88, 5050.01, 6300.77, 8200.36] ``` # Considerations - Optimize the index calculation to effectively distribute transaction values. - Choose an appropriate sorting method to improve efficiency within each bucket. - Handle edge cases such as empty input arrays and arrays with identical values.","solution":"from typing import List def optimized_bucket_sort(arr: List[float]) -> List[float]: if not arr: return [] min_value, max_value = 0.00, 10000.00 bucket_count = len(arr) buckets = [[] for _ in range(bucket_count)] for value in arr: index = int((value - min_value) / (max_value - min_value) * (bucket_count - 1)) buckets[index].append(value) sorted_arr = [] for bucket in buckets: sorted_arr.extend(sorted(bucket)) return sorted_arr"},{"question":"Rolling Maximum of a Sliding Window Given a stream of integers and a window size, implement a data structure that supports the following operations: 1. Adding a new integer to the stream. 2. Calculating the maximum of the integers in the current sliding window. # Requirements * Implement a class `SlidingWindowMaximum` with the following methods: * `__init__(self, size: int)`: Initializes the data structure with a fixed window size. * `add(self, val: int)`: Adds a new integer to the stream. * `get_max(self) -> int`: Returns the maximum integer within the current window. If the window is empty, return `None`. # Input and Output Formats The `__init__` method will be called to initialize the window size. The `add` method will be called with individual integer inputs, and the `get_max` method will return the maximum value of the elements within the current window after the `add` method is called. # Example ```python # Example usage: sw = SlidingWindowMaximum(3) print(sw.add(1)) # window = [1] print(sw.get_max()) # output: 1 print(sw.add(10)) # window = [1, 10] print(sw.get_max()) # output: 10 print(sw.add(3)) # window = [1, 10, 3] print(sw.get_max()) # output: 10 print(sw.add(5)) # window = [10, 3, 5] print(sw.get_max()) # output: 10 ``` # Constraints * The stream will contain at least one integer and at most `10^4` integers. * The window size is guaranteed to be between 1 and the length of the stream. # Note Ensure efficient handling of edge cases and performance optimizations where necessary. Aim for O(1) complexity for the `add` and `get_max` operations if possible.","solution":"from collections import deque class SlidingWindowMaximum: def __init__(self, size: int): Initialize the data structure with a fixed window size. self.window_size = size self.deque = deque() # Stores indices of the elements in the current window self.nums = [] # Stores actual values of the elements in the stream def add(self, val: int): Add a new integer to the stream. self.nums.append(val) index = len(self.nums) - 1 # Remove elements from deque that are smaller than the current element # since they are not useful as we want max while self.deque and self.nums[self.deque[-1]] <= val: self.deque.pop() # Add the current element\'s index to the deque self.deque.append(index) # Remove the element/index which is out of the window size if self.deque[0] <= index - self.window_size: self.deque.popleft() def get_max(self) -> int: Returns the maximum integer within the current window. If the window is empty, returns None. if not self.deque: return None return self.nums[self.deque[0]]"},{"question":"# Number of Digits Determination **Objective**: Write a function `count_digits` that takes an integer as input and returns the number of digits in the number. Ensure your solution handles both positive and negative integers correctly and accounts for zero. **Requirements**: 1. Your function must run in constant time O(1). 2. You are NOT allowed to use any string conversion methods to determine the number of digits. **Function Signature**: ```python def count_digits(n: int) -> int: # Your code here ``` **Input**: - An integer `n` where ( -10^{18} leq n leq 10^{18} ). **Output**: - An integer representing the number of digits in `n`. **Constraints**: - You cannot use string-related methods or libraries to convert the number to a string to count the digits. - Handle both positive and negative numbers by considering their absolute values. - Ensure the function works correctly for zero, which should return 1. **Example**: ```python count_digits(100) # returns 3 count_digits(-456) # returns 3 count_digits(0) # returns 1 count_digits(987654321) # returns 9 count_digits(-100000) # returns 6 ```","solution":"def count_digits(n: int) -> int: Returns the number of digits in the given integer n. Handles both positive and negative integers. if n == 0: return 1 n = abs(n) digit_count = 0 while n > 0: n //= 10 digit_count += 1 return digit_count"},{"question":"You are required to implement a class `BSTIteratorImproved` that enhances the functionality of a basic in-order traversal iterator for a Binary Search Tree (BST). The class should allow for both forward and backward iteration over the elements. Implement the class with following methods: * **Initialization** (`__init__(self, root)`): Initialize the iterator with the root node of a BST. * **has_next(self) -> bool**: Return True if there is a next element in the in-order traversal, otherwise, return False. * **next(self) -> int**: Return the next smallest element in the in-order traversal. * **has_prev(self) -> bool**: Return True if there is a previous element in the in-order traversal, otherwise, return False. * **prev(self) -> int**: Return the previous element in the in-order traversal. # Input * `__init__(root)`: The root of the BST. * `next()`: None * `has_next()`: None * `prev()`: None * `has_prev()`: None # Output * `next()`: The next smallest integer in the BST. * `has_next()`: Boolean value indicating if more elements are available in the forward direction. * `prev()`: The previous integer in the BST. * `has_prev()`: Boolean value indicating if elements are available in the backward direction. # Constraints * Assume that the BST does not contain duplicate values. * The total number of nodes in the tree is at most `10^4`. # Example ```python # Example usage: root = TreeNode(7) root.left = TreeNode(3) root.right = TreeNode(15) root.right.left = TreeNode(9) root.right.right = TreeNode(20) iterator = BSTIteratorImproved(root) iterator.next() # returns 3 iterator.next() # returns 7 iterator.prev() # returns 3 ``` Please implement the `BSTIteratorImproved` class based on the specifications above.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BSTIteratorImproved: def __init__(self, root: TreeNode): self.inorder_list = [] self.current_index = -1 # Not pointing to any element initially self._inorder_traversal(root) def _inorder_traversal(self, node: TreeNode): if node: self._inorder_traversal(node.left) self.inorder_list.append(node.val) self._inorder_traversal(node.right) def has_next(self) -> bool: return self.current_index + 1 < len(self.inorder_list) def next(self) -> int: if self.has_next(): self.current_index += 1 return self.inorder_list[self.current_index] raise StopIteration(\\"No next element.\\") def has_prev(self) -> bool: return self.current_index - 1 >= 0 def prev(self) -> int: if self.has_prev(): self.current_index -= 1 return self.inorder_list[self.current_index] raise StopIteration(\\"No previous element.\\")"},{"question":"# Scenario You are tasked with cleaning up URLs for a search engine optimization (SEO) tool. Your goal is to ensure that URLs are canonical, with no duplicate query parameters, and optionally removing unwanted parameters. # Task Write a function `sanitize_url` that performs the following operations: 1. Removes any duplicate query string parameters from the URL, keeping only the first occurrence. 2. Removes any query string parameters provided in an optional list of parameters to strip. # Function Signature ```python def sanitize_url(url: str, params_to_strip: Optional[List[str]] = None) -> str: ``` # Input * `url` (str): A URL string that may contain query parameters. * `params_to_strip` (Optional[List[str]]): A list of query parameters to remove from the URL. Defaults to None. # Output * Returns a sanitized URL string with duplicates and specified parameters removed. # Constraints * If the URL contains no query parameters, it should return the URL as-is. * The order of the remaining query parameters must be preserved. * If `params_to_strip` is not provided, only duplicate removal should be performed. # Examples ```python # Example 1: url = \'www.example.com?a=1&b=2&a=2\' params_to_strip = None sanitize_url(url) # Should return \'www.example.com?a=1&b=2\' # Example 2: url = \'www.example.com?a=1&b=2&a=2\' params_to_strip = [\'a\'] sanitize_url(url, params_to_strip) # Should return \'www.example.com?b=2\' # Example 3: url = \'www.example.com\' params_to_strip = [\'a\'] sanitize_url(url, params_to_strip) # Should return \'www.example.com\' ``` # Requirements * Efficiency: Aim for best time and space complexity. * Use Python standard libraries for URL manipulation if needed. * Thoroughly test for edge cases.","solution":"from typing import Optional, List from urllib.parse import urlparse, parse_qsl, urlencode, urlunparse def sanitize_url(url: str, params_to_strip: Optional[List[str]] = None) -> str: # Parse the URL into its components parsed_url = urlparse(url) # Parse the query parameters query_params = parse_qsl(parsed_url.query) # Use an ordered dictionary to keep the order of first occurrences of query parameters seen_params = {} for key, value in query_params: if key not in seen_params: seen_params[key] = value # Remove any parameters that are in params_to_strip if params_to_strip is not None: for param in params_to_strip: seen_params.pop(param, None) # Reconstruct the query string sanitized_query = urlencode(seen_params) # Reconstruct the URL with the sanitized query string sanitized_url = urlunparse((parsed_url.scheme, parsed_url.netloc, parsed_url.path, parsed_url.params, sanitized_query, parsed_url.fragment)) return sanitized_url"},{"question":"Scenario You are working as a software engineer at a company managing complex linked data structures. One of your tasks is to identify cycles within these structures to prevent infinite loops in the program\'s operations. Problem Statement Given a linked list, implement a function `first_cyclic_node` to find the first node where a cycle begins. If no cycle is present, return `None`. Function Signature ```python class Node: def __init__(self, x): self.val = x self.next = None def first_cyclic_node(head: Node) -> Node: pass ``` Input - `head`: a Node object that represents the head of a singly linked list. Output - Return the Node object where the cycle begins, or `None` if there is no cycle. Constraints - The input linked list may have no cycle or may contain a cycle. - You should ensure the function uses only constant additional space. Example ```python # Example 1: # Input: 1 -> 2 -> 3 -> 4 -> 5 -> 2 (cycle begins at 2) # Output: Node with value 2 # Example 2: # Input: A -> B -> C -> D -> E -> C (cycle begins at C) # Output: Node with value \'C\' # Example 3: # Input: 1 -> 2 -> 3 -> 4 (no cycle) # Output: None ``` Test Case Create a test case using the `unittest` package to validate your implementation. ```python import unittest class Node: def __init__(self, val): self.val = val self.next = None def first_cyclic_node(head): runner = walker = head while runner and runner.next: runner = runner.next.next walker = walker.next if runner is walker: break if runner is None or runner.next is None: return None walker = head while runner is not walker: runner, walker = runner.next, walker.next return runner class TestSuite(unittest.TestCase): def test_no_cycle(self): head = Node(1) head.next = Node(2) self.assertIsNone(first_cyclic_node(head)) def test_with_cycle(self): head = Node(\'A\') head.next = Node(\'B\') curr = head.next cyclic_node = Node(\'C\') curr.next = cyclic_node curr = curr.next curr.next = Node(\'D\') curr = curr.next curr.next = Node(\'E\') curr = curr.next curr.next = cyclic_node self.assertEqual(\'C\', first_cyclic_node(head).val) if __name__ == \'__main__\': unittest.main() ``` Notes - Do not modify the `Node` class definition. - Only modify the `first_cyclic_node` function to achieve the goal.","solution":"class Node: def __init__(self, x): self.val = x self.next = None def first_cyclic_node(head: Node) -> Node: Returns the node where the cycle begins in the linked list. If no cycle is present, returns None. if not head or not head.next: return None slow = fast = head # First step: determine whether there is a cycle while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: break else: return None # Second step: find the entry point of the cycle slow = head while slow != fast: slow = slow.next fast = fast.next return slow"},{"question":"# Question You are tasked to implement a function that computes Euler\'s Totient function for a given positive integer. Euler\'s Totient function, ϕ(n), for an integer ( n ) is defined as the count of integers from 1 to ( n ) that are coprime to ( n ) (i.e., their greatest common divisor (GCD) with ( n ) is 1). Function Signature ```python def compute_totient(n: int) -> int: pass ``` Input - `n` (1 ≤ n ≤ 10^6): An integer for which you need to compute the Totient function. Output - Return a single integer, the value of ϕ(n). Example ```python assert compute_totient(1) == 1 assert compute_totient(2) == 1 assert compute_totient(9) == 6 assert compute_totient(30) == 8 ``` Constraints - You should ensure the solution operates efficiently within the provided constraint on ( n ). - The function should handle edge cases effectively, such as the smallest and largest inputs within the given range. Hint Euler\'s Totient function is derived through consideration of the prime factors of ( n ). Efficient iterative division and reduction of ( n ) can help achieve the desired results within good time complexity.","solution":"def compute_totient(n: int) -> int: Computes Euler\'s Totient function for a given positive integer n. if n == 1: return 1 result = n p = 2 # Consider all prime factors for n while p * p <= n: # Check if p is a prime factor of n if n % p == 0: # If yes, then it is a prime factor, update result while n % p == 0: n //= p result -= result // p p += 1 # If n has a prime factor greater than sqrt(n) (n > 1 in that case) if n > 1: result -= result // n return result"},{"question":"Scenario You have been hired to develop a sorting library for a new high-performance data analytics software. One of the key requirements is to implement the Quick Sort algorithm efficiently, understanding its strengths and potential pitfalls. To ensure the sorting method meets performance requirements, you will integrate features to demonstrate its operation in detail. Task Implement the Quick Sort algorithm with the following specifications: 1. **Function Signature**: ```python def quick_sort(arr, simulation=False): Sort the input array using the Quick Sort algorithm. Args: arr (list of int): The list of integers to be sorted. simulation (bool): If True, print the array at each iteration. Returns: list of int: The sorted list. ``` 2. **Expected Input and Output Formats**: - **Input**: A list of integers `arr` and a boolean flag `simulation`. - **Output**: The list sorted in ascending order. 3. **Constraints and Limitations**: - Implement the quick sort recursively. - If `simulation` is `True`, the function should print the array at each iteration. - You may assume that the input list contains no more than 10,000 elements, and elements are in the range of -10^9 to 10^9. 4. **Performance Requirements**: - The function should ideally perform in O(n log(n)) time on average. - Must handle worst-case scenarios within constraints gracefully. Example 1. Input: `arr = [3, 6, 8, 10, 1, 2, 1]`, `simulation = False` Output: `[1, 1, 2, 3, 6, 8, 10]` 2. Input: `arr = [3, 6, 8, 10, 1, 2, 1]`, `simulation = True` Output: ``` iteration 0: 3 6 8 10 1 2 1 iteration 1: 3 1 2 1 6 8 10 iteration 2: 1 1 2 3 6 8 10 [1, 1, 2, 3, 6, 8, 10] ``` In case of any additional array manipulations or utility functions required, make sure to document them clearly and integrate them seamlessly into the main quick sort implementation.","solution":"def quick_sort(arr, simulation=False): Sort the input array using the Quick Sort algorithm. Args: arr (list of int): The list of integers to be sorted. simulation (bool): If True, print the array at each iteration. Returns: list of int: The sorted list. def partition(start, end): pivot_index = start pivot = arr[pivot_index] while start < end: # Increment the start pointer until we find an element larger than the pivot while start < len(arr) and arr[start] <= pivot: start += 1 # Decrement the end pointer until we find an element smaller than the pivot while arr[end] > pivot: end -= 1 # If the start is less than the end, swap the elements if start < end: arr[start], arr[end] = arr[end], arr[start] # Swap the pivot element with the element on the end pointer arr[end], arr[pivot_index] = arr[pivot_index], arr[end] # Return the end index which specifies the pivot position return end def quick_sort_recursive(start, end, iteration=0): if start < end: pivot = partition(start, end) if simulation: print(f\\"iteration {iteration}: {\' \'.join(map(str, arr))}\\") # Recursively sort elements before and after partition quick_sort_recursive(start, pivot - 1, iteration + 1) quick_sort_recursive(pivot + 1, end, iteration + 1) quick_sort_recursive(0, len(arr) - 1) return arr"},{"question":"# Maximum Flow Implementation **Context**: As part of a network design team, your task is to optimize the data transfer rate from the central server (source) to the client nodes (sinks) across a designed network. Understanding the maximum capacity achievable in given constraints of your network is crucial. **Objective**: Your task is to implement a function that finds the maximum possible flow from a source node to a sink node in a directed graph representing a flow network using one of the discussed algorithms. # Requirements: **Function Signature**: ```python def maximum_flow(graph: List[List[int]], source: int, sink: int) -> int: pass ``` **Expected Input and Output**: - `graph`: a 2D list of integers representing the capacity matrix of the graph. - `graph[i][j]` represents the capacity of the edge from node `i` to `j`. - If there is no edge between nodes `i` and `j`, `graph[i][j]` should be zero. - `source`: an integer representing the index of the source node. - `sink`: an integer representing the index of the sink node. - Returns an integer representing the maximum flow from the source node to the sink node. **Constraints**: - Nodes can be labeled from `0` to `N-1`, where (2 leq N leq 500). - Capacities are non-negative integers not exceeding (10^6). **Performance Requirements**: - The function should efficiently handle up to 500 nodes and potential dense connectivity without excessive slowdowns. # Examples: ```python graph = [ [0, 16, 13, 0, 0, 0], [0, 0, 10, 12, 0, 0], [0, 4, 0, 0, 14, 0], [0, 0, 9, 0, 0, 20], [0, 0, 0, 7, 0, 4], [0, 0, 0, 0, 0, 0] ] print(maximum_flow(graph, 0, 5)) # Output should be 23 ``` # Tasks: 1. Implement the function `maximum_flow` using any of the discussed algorithms (Ford-Fulkerson, Edmonds-Karp, or Dinic\'s Algorithm). 2. Ensure consideration of edge cases such as unconnected graphs or zero capacities. 3. Validate performance on large-scale input scenarios to meet required constraints. Good luck and happy coding!","solution":"from collections import deque def bfs(rGraph, source, sink, parent): Returns true if there is a path from source to sink in residual graph. Also fills parent[] to store the path visited = [False] * len(rGraph) queue = deque([source]) visited[source] = True while queue: u = queue.popleft() for v, cap in enumerate(rGraph[u]): if visited[v] == False and cap > 0: if v == sink: parent[v] = u return True queue.append(v) visited[v] = True parent[v] = u return False def maximum_flow(graph, source, sink): n = len(graph) rGraph = [row[:] for row in graph] # Residual graph parent = [-1] * n max_flow = 0 # Augment the flow while there is a path from source to sink while bfs(rGraph, source, sink, parent): # Find the maximum flow through the path found by BFS path_flow = float(\\"Inf\\") s = sink while s != source: path_flow = min(path_flow, rGraph[parent[s]][s]) s = parent[s] # update residual capacities of the edges and reverse edges along the path v = sink while v != source: u = parent[v] rGraph[u][v] -= path_flow rGraph[v][u] += path_flow v = parent[v] max_flow += path_flow return max_flow"},{"question":"Implement an **Address Book** using a Binary Search Tree (BST). Your Address Book should support the following operations: 1. **Add Contact**: Add a contact with the name and phone number. 2. **Find Contact**: Search for a contact by name. 3. **List Contacts**: List all contacts in alphabetical order. **Context**: You are building a simple Address Book for a smartphone app. The app needs to allow users to store and find contacts efficiently, as well as to retrieve the contacts in alphabetical order for easy browsing. # Requirements 1. **Class Definitions**: - Define a `Contact` class with attributes `name` and `phone`. - Define an `AddressBook` class using BST principles to store `Contact` instances. 2. **Operations**: - `add_contact(name: str, phone: str) -> bool`: Adds a contact. Returns `True` if the contact was added, and `False` if a contact with the name already exists. - `find_contact(name: str) -> str`: Searches for a contact by name. Returns the phone number if found, otherwise return `None`. - `list_contacts() -> List[str]`: Returns a list of all contacts\' names in alphabetical order. # Constraints - Contact names are unique and case-sensitive. - The address book can store up to 1000 contacts. - The name and phone number are strings, where the name can have a length of up to 50 characters, and the phone number is a valid phone format (numerical strings). # Performance Requirements - All operations should be optimized for an average-case time complexity of O(log N). # Example Usage ```python address_book = AddressBook() # Add contacts address_book.add_contact(\\"Alice\\", \\"12345\\") address_book.add_contact(\\"Bob\\", \\"67890\\") # Find contacts assert address_book.find_contact(\\"Alice\\") == \\"12345\\" assert address_book.find_contact(\\"Charlie\\") == None # List contacts assert address_book.list_contacts() == [\\"Alice\\", \\"Bob\\"] ``` # Implementation Implement the classes `Contact` and `AddressBook` to satisfy the requirements above.","solution":"class Contact: def __init__(self, name: str, phone: str): self.name = name self.phone = phone self.left = None self.right = None class AddressBook: def __init__(self): self.root = None def add_contact(self, name: str, phone: str) -> bool: if not self.root: self.root = Contact(name, phone) return True else: return self._add_contact(self.root, name, phone) def _add_contact(self, node: Contact, name: str, phone: str) -> bool: if name < node.name: if node.left: return self._add_contact(node.left, name, phone) else: node.left = Contact(name, phone) return True elif name > node.name: if node.right: return self._add_contact(node.right, name, phone) else: node.right = Contact(name, phone) return True return False def find_contact(self, name: str) -> str: return self._find_contact(self.root, name) def _find_contact(self, node: Contact, name: str) -> str: if not node: return None if name == node.name: return node.phone elif name < node.name: return self._find_contact(node.left, name) else: return self._find_contact(node.right, name) def list_contacts(self) -> list: contacts = [] self._in_order_traversal(self.root, contacts) return contacts def _in_order_traversal(self, node: Contact, contacts: list): if node: self._in_order_traversal(node.left, contacts) contacts.append(node.name) self._in_order_traversal(node.right, contacts)"},{"question":"# Directed Graph Path Finder You have been provided with code snippets to represent a directed graph using nodes and edges. Given this structure, your task is to implement a function that determines if there exists a path between two given nodes. Your function should explore the graph using breadth-first search (BFS). Your implementation should be in Python using the provided `DirectedGraph` class. Function Specification **Function Name**: `is_path_exists` **Input**: * `graph`: `DirectedGraph` object - The input graph. * `start_node`: `str` - The name of the start node. * `end_node`: `str` - The name of the end node. **Output**: * `bool` - `True` if there is a path from `start_node` to `end_node`, `False` otherwise. Constraints: * `start_node` and `end_node` are guaranteed to be unique and present in the graph. * The graph can have up to 1000 nodes and 5000 edges. Requirements: * Your function should efficiently find if a path exists or not. * Implement a breadth-first search (BFS) for path finding. * Consider edge cases like self-loops and isolated nodes. * Optimize for performance and ensure your solution can handle the upper limit of constraints. Example ```python # Example Usage: # Create the graph with given structure graph_dict = { \\"A\\": [\\"B\\", \\"C\\"], \\"B\\": [\\"D\\"], \\"C\\": [\\"E\\"], \\"D\\": [\\"F\\"], \\"E\\": [], \\"F\\": [] } graph = DirectedGraph(graph_dict) # Check if path exists print(is_path_exists(graph, \\"A\\", \\"F\\")) # Output: True print(is_path_exists(graph, \\"C\\", \\"D\\")) # Output: False ``` **Notes**: 1. Assume the `DirectedGraph` structure as given in the snippets above. 2. You are required to use the `DirectedGraph`, `Node`, and `DirectedEdge` classes as provided. 3. Do not modify existing methods and only add your solution as specified.","solution":"from collections import deque class DirectedGraph: def __init__(self, graph_dict=None): self.graph_dict = graph_dict or {} def add_edge(self, from_node, to_node): if from_node in self.graph_dict: self.graph_dict[from_node].append(to_node) else: self.graph_dict[from_node] = [to_node] def is_path_exists(graph, start_node, end_node): Determines if there exists a path between start_node and end_node in the directed graph using BFS. if start_node == end_node: return True visited = set() queue = deque([start_node]) while queue: current_node = queue.popleft() if current_node == end_node: return True visited.add(current_node) for neighbor in graph.graph_dict.get(current_node, []): if neighbor not in visited: queue.append(neighbor) return False"},{"question":"You are given an implementation of a Separate Chaining Hash Table. The current implementation handles insertions, deletions, and lookups for key-value pairs. Your task is to extend this implementation to include the following functionality: 1. **Resize Hash Table**: Implement a method `resize` in the `SeparateChainingHashTable` class to resize the hash table dynamically. When the load factor exceeds 0.7, double the size of the hash table. When the load factor goes below 0.2, halve the size of the hash table (minimum size should remain at 11). 2. **Load Factor Calculation**: Implement a method `load_factor` to compute and return the current load factor of the hash table. 3. **Handling Frequent Resizing**: Add a feature to prevent resizing if the hash table has been resized more than 10 times within the last minute. # Function Signatures ```python class SeparateChainingHashTable: # Already implemented methods def load_factor(self): Calculate and return the current load factor of the hash table. Returns: float: The current load factor. pass def resize(self, new_size): Resize the hash table to the target capacity. Args: new_size (int): The new size of the hash table. pass ``` # Input & Output * `load_factor()`: Returns the load factor as a `float`. * `resize(new_size)`: Updates the hash table to the new size. # Constraints * Ensure you use a robust and collision-resistant hash function. * Maintain the integrity and order of elements after resizing. * Trace the number and frequency of resizes accurately and avoid frequent unnecessary resizing. # Example ```python # Example usage table = SeparateChainingHashTable() for i in range(20): table.put(f\\"key{i}\\", f\\"value{i}\\") print(table.load_factor()) # Load factor should be around 1.82 table.resize(22) print(table.load_factor()) # Load factor should be recalculated according to the new size ``` # Notes * Ensure that the hash table\'s operations still run efficiently after implementing the resize feature. * Include test cases covering scenarios such as: - Frequently adding and removing elements to test the resizing functionality. - Edge cases for adding, removing, and looking up elements in resized tables. - Validating the no-frequent-resizing feature.","solution":"class SeparateChainingHashTable: def __init__(self, initial_size=11, max_resizes_per_minute=10): self.table = [[] for _ in range(initial_size)] self.size = 0 self.max_resizes_per_minute = max_resizes_per_minute self.resizes = [] def _hash(self, key): return hash(key) % len(self.table) def put(self, key, value): index = self._hash(key) for pair in self.table[index]: if pair[0] == key: pair[1] = value return self.table[index].append([key, value]) self.size += 1 if self.load_factor() > 0.7: self.resize(len(self.table) * 2) def get(self, key): index = self._hash(key) for pair in self.table[index]: if pair[0] == key: return pair[1] return None def remove(self, key): index = self._hash(key) for i, pair in enumerate(self.table[index]): if pair[0] == key: self.table[index].pop(i) self.size -= 1 if len(self.table) > 11 and self.load_factor() < 0.2: self.resize(max(len(self.table) // 2, 11)) return pair[1] return None def load_factor(self): return self.size / len(self.table) def resize(self, new_size): import time current_time = time.time() self.resizes = [t for t in self.resizes if current_time - t < 60] if len(self.resizes) >= self.max_resizes_per_minute: return self.resizes.append(current_time) old_table = self.table self.table = [[] for _ in range(new_size)] self.size = 0 for bucket in old_table: for key, value in bucket: self.put(key, value)"},{"question":"Problem Description You are given a non-negative integer `num`. Your task is to write a function `next_bigger(num)` that returns the next greater number using the same set of digits as `num`. If no such number exists, return `-1`. # Function Signature ```python def next_bigger(num: int) -> int: pass ``` # Input * An integer `num` such that `0 <= num <= 10**18`. # Output * An integer which is the next greater number with the same set of digits as `num`. * Return `-1` if no such number exists. # Example ```python assert next_bigger(38276) == 38627 assert next_bigger(54321) == -1 assert next_bigger(5) == -1 assert next_bigger(1528452) == 1528524 assert next_bigger(138654) == 143568 ``` # Constraints * The function should handle inputs up to `10**18` efficiently. * The implementation should pass multiple edge cases, including numbers in descending order and repeated digits. # Notes Ensure your code is efficient and handles edge cases such as: 1. Numbers with all digits in descending order. 2. Single digit numbers. 3. Numbers with repeated digits. Implement the function and ensure it passes all the provided test cases.","solution":"def next_bigger(num: int) -> int: num_str = list(str(num)) n = len(num_str) # Step 1: Identify the rightmost digit which is smaller than its next digit for i in range(n-2, -1, -1): if num_str[i] < num_str[i+1]: break else: # If no such digit is found, then all digits are in descending order return -1 # Step 2: Find the smallest digit on the right of the above found digit that is larger than the found digit for j in range(n-1, i, -1): if num_str[j] > num_str[i]: break # Step 3: Swap the above found two digits num_str[i], num_str[j] = num_str[j], num_str[i] # Step 4: Sort the digits after the position i num_str = num_str[:i+1] + sorted(num_str[i+1:]) # Convert list back to integer return int(\\"\\".join(num_str))"},{"question":"# Question: Verify Strong Connectivity in Directed Graphs You are working on a network analysis tool that needs to determine the robustness of the network by verifying that it is strongly connected. In this context, a directed network (or graph) is considered strongly connected if there is a path between any pair of vertices in both directions. **Implement the function `is_strongly_connected_graph(graph)`. Given a directed graph, this function should determine if the graph is strongly connected.** Input: - `graph`: An instance of the `Graph` class, which represents a directed graph with `n` vertices and `e` edges. Output: - Return `True` if the graph is strongly connected; otherwise, return `False`. # Class `Graph`: - `Graph(int vertex_count)`: Initializes the graph with `vertex_count` vertices. - `add_edge(int source, int target)`: Adds a directed edge from `source` to `target`. - `is_strongly_connected()`: Checks if the graph is strongly connected. # Example Usage: ```python # Create a graph instance g = Graph(5) g.add_edge(0, 1) g.add_edge(1, 2) g.add_edge(2, 0) g.add_edge(0, 3) g.add_edge(3, 4) g.add_edge(4, 0) print(g.is_strongly_connected()) # Expected output: True g2 = Graph(4) g2.add_edge(0, 1) g2.add_edge(1, 2) g2.add_edge(2, 3) print(g2.is_strongly_connected()) # Expected output: False ``` # Constraints: - The graph has at least one vertex and all vertex indices are non-negative integers. - The graph is represented as a directed graph with potentially multiple edges and self-loops.","solution":"class Graph: def __init__(self, vertex_count): self.vertex_count = vertex_count self.edges = {i: [] for i in range(vertex_count)} def add_edge(self, source, target): self.edges[source].append(target) def _dfs(self, v, visited): visited[v] = True for neighbour in self.edges[v]: if not visited[neighbour]: self._dfs(neighbour, visited) def _transpose(self): transposed = Graph(self.vertex_count) for v in range(self.vertex_count): for neighbour in self.edges[v]: transposed.add_edge(neighbour, v) return transposed def is_strongly_connected(self): visited = [False] * self.vertex_count # Step 1: Do DFS from any vertex. Here, we start with vertex 0. self._dfs(0, visited) # Check if all vertices were visited in the original graph if not all(visited): return False # Step 2: Create a transposed graph and do DFS again transposed_graph = self._transpose() visited = [False] * self.vertex_count transposed_graph._dfs(0, visited) # Check if all vertices were visited in the transposed graph if not all(visited): return False return True"},{"question":"# Coding Assessment: First Occurrence in a Sorted Array Context: You are a software engineer working on a large database system. Your task is to implement a search feature that can efficiently find the first occurrence of a given number in a sorted dataset. Problem Statement: Write a function `first_occurrence(array: List[int], query: int) -> int` that takes a sorted array of integers and a query integer. It should return the index of the first occurrence of the query integer in the array. If the query integer is not present, the function should return `-1`. # Function Signature: ```python from typing import List def first_occurrence(array: List[int], query: int) -> int: pass ``` Input: * An array of integers `array`, where `1 <= len(array) <= 10^6` and `-10^9 <= array[i] <= 10^9`. The array is sorted in increasing order. * An integer `query`, where `-10^9 <= query <= 10^9`. Output: * An integer, the index of the first occurrence of `query` in `array`, or `-1` if `query` is not present. Constraints: * The algorithm should have a time complexity of O(log n). # Examples: ```python assert first_occurrence([1, 2, 2, 2, 3, 4, 5], 2) == 1 assert first_occurrence([1, 2, 2, 2, 3, 4, 5], 3) == 4 assert first_occurrence([1, 2, 2, 2, 3, 4, 5], 6) == -1 assert first_occurrence([2, 2, 2, 2, 2, 2, 2], 2) == 0 assert first_occurrence([1, 3, 5, 7], 1) == 0 assert first_occurrence([1, 3, 5, 7], 7) == 3 assert first_occurrence([1], 1) == 0 assert first_occurrence([1], 2) == -1 ``` Edge Cases to Consider: * The `query` being smaller or larger than any element in the array. * The `query` appearing multiple times consecutively. * The array containing only one element. Your implementation will be evaluated based on correctness and efficiency. Ensure your solution handles the specified constraints effectively.","solution":"from typing import List def first_occurrence(array: List[int], query: int) -> int: Returns the index of the first occurrence of query in a sorted array. If the query is not present, returns -1. left, right = 0, len(array) - 1 result = -1 while left <= right: mid = left + (right - left) // 2 if array[mid] == query: result = mid right = mid - 1 # Look on the left side of mid for the first occurrence elif array[mid] < query: left = mid + 1 else: right = mid - 1 return result"},{"question":"# Context You are developing a software component for secure communication, which involves repeated use of exponentiation with large numbers. Being aware of the constraints, you are required to implement an efficient algorithm for this purpose. # Task Implement a function `modular_exponentiation(base: int, exponent: int, mod: int) -> int` that calculates `(base^exponent) % mod` using an efficient algorithm. # Requirements * **Input**: - `base` (integer): The base number. `1 <= base <= 10^9` - `exponent` (integer): The exponent. `0 <= exponent <= 10^9` - `mod` (integer): The modulo value. `1 <= mod <= 10^9` * **Output**: - Return an integer which is the result of `(base^exponent) % mod`. # Constraints - Do not use Python\'s built-in power functions. - The implementation must handle large values of `base`, `exponent`, and `mod` efficiently. # Performance Requirements - Time Complexity: O(log(exponent)) - Space Complexity: O(1) for iterative, or O(log(exponent)) for recursive # Edge Cases to Consider 1. `exponent = 0`: Should return `1` for any `base` and `mod`. 2. `mod = 1`: Should always return `0`. # Example ```python assert modular_exponentiation(2, 10, 1000) == 24 # (2^10) % 1000 = 1024 % 1000 = 24 assert modular_exponentiation(3, 0, 7) == 1 # Any number to the power of 0 is 1 assert modular_exponentiation(7, 5, 13) == 11 # (7^5) % 13 = 16807 % 13 = 11 ``` # Note Both iterative and recursive approaches are acceptable, but ensure that the time complexity remains O(log(exponent)) in either case.","solution":"def modular_exponentiation(base: int, exponent: int, mod: int) -> int: if mod == 1: return 0 result = 1 base = base % mod while exponent > 0: if exponent % 2 == 1: result = (result * base) % mod exponent = exponent >> 1 base = (base * base) % mod return result"},{"question":"# Context You are given an array that you need to rotate to the right by `k` steps. The need for such rotations is common in algorithm design, where rearrangements optimize search or organization processes. # Task Implement a function `optimized_rotate_array` which encapsulates the most efficient method to rotate the array. You should aim to achieve O(n) time complexity and O(1) space complexity. # Function Signature ```python def optimized_rotate_array(array, k): Rotates the array \'k\' times to the right. :param array: List[int] - List of integers that need to be rotated :param k: int - Number of steps to rotate the array :return: List[int] - Rotated array pass ``` # Input - `array`: A list of integers (0 <= len(array) <= 10^5). - `k`: An integer indicating the number of steps to rotate (0 <= k <= 10^9). # Output - A list of integers representing the rotated array. # Constraints - Aim for O(n) time complexity and O(1) space complexity. - Modify the array in place if possible. - Consider edge cases such as empty arrays and arrays with one element. # Examples ```python # Example 1 array = [1, 2, 3, 4, 5, 6, 7] k = 3 # Rotated array should be [5, 6, 7, 1, 2, 3, 4] print(optimized_rotate_array(array, k)) # Expected output: [5, 6, 7, 1, 2, 3, 4] # Example 2 array = [1, 2, 3, 4, 5] k = 0 # Rotated array should be [1, 2, 3, 4, 5] print(optimized_rotate_array(array, k)) # Expected output: [1, 2, 3, 4, 5] # Example 3 array = [1, 2] k = 5 # Rotated array should be [2, 1] print(optimized_rotate_array(array, k)) # Expected output: [2, 1] ``` # Notes - Ensure the code handles large values of `k` efficiently by normalizing `k`. - Account for edge cases and test robustly.","solution":"def optimized_rotate_array(array, k): Rotates the array \'k\' times to the right. :param array: List[int] - List of integers that need to be rotated :param k: int - Number of steps to rotate the array :return: List[int] - Rotated array n = len(array) if n == 0: return array k = k % n # Normalize k if k == 0: return array # Reverse the entire array reverse(array, 0, n - 1) # Reverse the first k elements reverse(array, 0, k - 1) # Reverse the remaining n - k elements reverse(array, k, n - 1) return array def reverse(array, start, end): Helper function to reverse elements in the array from start to end indices. :param array: List[int] - The list to reverse elements in :param start: int - Starting index :param end: int - Ending index while start < end: array[start], array[end] = array[end], array[start] start += 1 end -= 1"},{"question":"# Filtering Array by Value Range Context You have a dataset represented as an array of numeric values. Sometimes, you need to extract a subset of this data that falls within a specific range of values. You want to implement a function that will filter the array based on minimum and maximum threshold values. Objective Write a function named `filter_by_range` that takes three inputs: 1. `arr` (a list of integers): The array of numbers to filter. 2. `min_value` (an integer or None): The minimum threshold value. If None, there is no minimum bound. 3. `max_value` (an integer or None): The maximum threshold value. If None, there is no maximum bound. The function should return a new list that contains only the values from `arr` that are greater than or equal to `min_value` and less than or equal to `max_value`. If `min_value` or `max_value` is None, it should consider no bound for that limit. Function Signature ```python def filter_by_range(arr: List[int], min_value: Optional[int], max_value: Optional[int]) -> List[int]: ``` Input Constraints 1. `arr` will have at most 100,000 elements. 2. Elements in `arr` will be integers between -10^6 and 10^6. 3. `min_value` and `max_value`, if provided (not None), will be integers within the same range. Output Return a list of integers filtered from `arr` based on the given `min_value` and `max_value`. Example ```python filter_by_range([1, 2, 3, 4, 5], None, 3) # Output: [1, 2, 3] filter_by_range([10, 15, 20, 25], 12, None) # Output: [15, 20, 25] filter_by_range([100, 200, 300], None, None) # Output: [100, 200, 300] filter_by_range([], 5, 10) # Output: [] ``` Performance Requirements The solution should have a time complexity of O(n) where n is the number of elements in the array.","solution":"from typing import List, Optional def filter_by_range(arr: List[int], min_value: Optional[int], max_value: Optional[int]) -> List[int]: Returns a new list that contains only the values from arr that are greater than or equal to min_value and less than or equal to max_value. :param arr: List of integers to be filtered :param min_value: Minimum threshold value, if None, no minimum bound :param max_value: Maximum threshold value, if None, no maximum bound :return: Filtered list of integers return [x for x in arr if (min_value is None or x >= min_value) and (max_value is None or x <= max_value)]"},{"question":"Consecutive Power Sum Numbers Scenario You are part of a team working on a mathematics exploration project that identifies numbers with specific properties. One interesting property is that of numbers where each digit raised to successive powers sums to the number itself. You are to implement a function to find all such numbers within a given range. Task Write a function `find_consecutive_power_sum_numbers` that takes two integers `low` and `high` as input and returns a list of numbers within this range [low, high] that satisfy the following property: * For a number `n`, if `n = d_1 ^ 1 + d_2 ^ 2 + ... + d_k ^ k`, where `d_1, d_2, ..., d_k` are its digits and k is the number of digits, then `n` should be part of the result. Input * `low` (integer) - the lower limit of the range (inclusive). * `high` (integer) - the upper limit of the range (inclusive). Output * A list of integers where each integer meets the required property. Constraints * `1 <= low <= high <= 10^6` * Your solution should be efficient enough to handle large ranges within practical execution times. Example ```python def find_consecutive_power_sum_numbers(low, high): # Your code here # Example Usage: assert find_consecutive_power_sum_numbers(1, 10) == [1, 2, 3, 4, 5, 6, 7, 8, 9] assert find_consecutive_power_sum_numbers(1, 100) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 89] assert find_consecutive_power_sum_numbers(89, 135) == [89, 135] ``` Additional Information * Focus on edge cases like low equal to high, low at minimum, or high at maximum constraints.","solution":"def find_consecutive_power_sum_numbers(low, high): Return a list of numbers within the range [low, high] where the number is equal to the sum of its digits each raised to the corresponding power. def is_consecutive_power_sum(n): digits = list(map(int, str(n))) return sum(d ** (i + 1) for i, d in enumerate(digits)) == n return [n for n in range(low, high + 1) if is_consecutive_power_sum(n)]"},{"question":"# Hierarchical Tree Representation and Print You are given a hierarchical tree structure with keys and nested elements as described below. Your task is to modify the function `tree_print(tree)` to: 1. Properly handle mixed data types. 2. Correctly indent and format the printed output to visually represent the hierarchical structure. Input - A python dictionary where the keys are strings, and the values are lists. The lists can contain strings, other dictionaries, or numbers. Output - A printed representation of the tree that clearly shows the hierarchy. Example Input: ```python tree = { \'a\': [\'Adam\', {\'Book\': [4]}], \'b\': [\'Bill\', {\'Computer\': [5]}, {\'TV\': [6]}, \'Jill\', {\'Sports\': [1]}], \'c\': [\'Bill\', {\'Sports\': [3]}], \'d\': [\'Adam\', {\'Computer\': [3]}, \'Quin\', {\'Computer\': [3]}], \'e\': [\'Quin\', {\'Book\': [5]}, {\'TV\': [2]}], \'f\': [\'Adam\', {\'Computer\': [7]}], } ``` Expected Output: ``` a Adam -> Book -> 4 b Bill -> Computer -> 5 -> TV -> 6 -> Sports -> 1 c Bill -> Sports -> 3 d Adam -> Computer -> 3 Quin -> Computer -> 3 e Quin -> Book -> 5 -> TV -> 2 f Adam -> Computer -> 7 ``` Notes: - Ensure proper formatting of nested elements. - Handle mixed data types and empty dictionaries appropriately. - You might find it useful to write a helper function to handle nested elements. ```python # Your function implementation here def tree_print(tree): # Tree printing logic goes here pass # Example usage tree_print(tree) ```","solution":"def tree_print(tree, indent=0): Prints a hierarchical tree structure with appropriate formatting. for key, values in tree.items(): print(\' \' * indent + key) for value in values: if isinstance(value, dict): for sub_key, sub_values in value.items(): print(\' \' * (indent + 3) + \'-> \' + sub_key) for sub_value in sub_values: print(\' \' * (indent + 6) + \'-> \' + str(sub_value)) else: print(\' \' * (indent + 3) + str(value)) # Example usage tree = { \'a\': [\'Adam\', {\'Book\': [4]}], \'b\': [\'Bill\', {\'Computer\': [5]}, {\'TV\': [6]}, \'Jill\', {\'Sports\': [1]}], \'c\': [\'Bill\', {\'Sports\': [3]}], \'d\': [\'Adam\', {\'Computer\': [3]}, \'Quin\', {\'Computer\': [3]}], \'e\': [\'Quin\', {\'Book\': [5]}, {\'TV\': [2]}], \'f\': [\'Adam\', {\'Computer\': [7]}], } tree_print(tree)"},{"question":"# Question: Finding Strongly Connected Components **Objective**: Implement the Tarjan\'s algorithm to find all Strongly Connected Components (SCCs) in a directed graph. **Scenario**: Alice is working with a directed graph representing a network of webpages. She needs to identify clusters of webpages where each page is reachable from any other page in the same cluster. Your task is to help Alice by implementing Tarjan\'s algorithm to find these Strongly Connected Components. **Function signature**: ```python def find_sccs(dict_graph: dict) -> list: Finds and returns all strongly connected components in the given directed graph using Tarjan\'s algorithm. :param dict_graph: A dictionary where keys are nodes, and values are lists of successor nodes (adjacency list). Example: {1: [2], 2: [3], 3: [1, 4], 4: [5], 5: [4]} :return: A list of SCCs, each SCC is represented by a list of nodes. Example: [[1, 2, 3], [4, 5]] pass ``` **Constraints**: 1. All nodes in `dict_graph` are represented by integers. 2. The graph does not contain any self-loops or parallel edges. 3. Return the SCCs in any order. # Example Input ```python dict_graph = { 1: [2], 2: [3], 3: [1, 4], 4: [5], 5: [4] } ``` Output ```python [[1, 2, 3], [4, 5]] ``` # Notes: 1. Make sure to handle disconnected graphs. 2. Take into account edge cases like graphs with no edges or a single node graph. 3. Optimize for both time and space complexity. **Testing**: You should write at least three to five test cases to validate your implementation, including edge cases.","solution":"def find_sccs(dict_graph): Finds and returns all strongly connected components in the given directed graph using Tarjan\'s algorithm. :param dict_graph: A dictionary where keys are nodes, and values are lists of successor nodes (adjacency list). Example: {1: [2], 2: [3], 3: [1, 4], 4: [5], 5: [4]} :return: A list of SCCs, each SCC is represented by a list of nodes. Example: [[1, 2, 3], [4, 5]] index = 0 stack = [] indices = {} lowlink = {} on_stack = {} sccs = [] def strongconnect(node): nonlocal index indices[node] = index lowlink[node] = index index += 1 stack.append(node) on_stack[node] = True # Consider successors of node for successor in dict_graph.get(node, []): if successor not in indices: # Successor has not yet been visited; recurse on it strongconnect(successor) lowlink[node] = min(lowlink[node], lowlink[successor]) elif on_stack.get(successor, False): # Successor is in stack and hence in the current SCC lowlink[node] = min(lowlink[node], indices[successor]) # If node is a root node, pop the stack and generate an SCC if lowlink[node] == indices[node]: scc = [] while True: successor = stack.pop() on_stack[successor] = False scc.append(successor) if successor == node: break sccs.append(scc) for node in dict_graph: if node not in indices: strongconnect(node) return sccs"},{"question":"# Polynomial Operations and Simplification Context You are tasked with enhancing a symbolic mathematics system that requires robust handling of polynomial operations. Your aim is to implement efficient polynomial addition, multiplication, and simplification routines. Problem Statement Given the `Polynomial` class, implement the function `simplify()` which simplifies the polynomial by combining like terms. A like term is defined as having the same set of variables raised to the same powers. Function Signature ```python def simplify(polynomial: Polynomial) -> Polynomial: Simplify the given polynomial by combining like terms. Parameters: polynomial (Polynomial): The polynomial to be simplified. Returns: Polynomial: The simplified polynomial. ``` Input * A `Polynomial` object containing a set of monomials. Output * A single simplified `Polynomial` where like terms are combined into a single monomial. Constraints * Assure that the resulting polynomial does not contain monomials with zero coefficients. * Ensure that all coefficients are rationalized. Examples ```python # Creating polynomials with like terms p1 = Polynomial([ Monomial({1: 2}, 3), Monomial({1: 2}, 4), Monomial({2: 1, 1: 3}, -5), Monomial({2: 1, 1: 3}, 1) ]) # Simplifying polynomial simplified_p1 = simplify(p1) print(simplified_p1) # Expected output should combine like terms: \\"7(a_1)^2 - 4(a_1)^3(a_2)\\" # Without like terms p2 = Polynomial([ Monomial({1: 2}, 3), Monomial({2: 1, 1: 3}, 1) ]) simplified_p2 = simplify(p2) print(simplified_p2) # Expected: \\"3(a_1)^2 + (a_1)^3(a_2)\\" ``` Implement the `simplify()` function and fully test it with different polynomials to ensure its correctness.","solution":"from collections import defaultdict class Monomial: def __init__(self, variables, coefficient): self.variables = variables # dictionary mapping variable index to its power self.coefficient = coefficient def __eq__(self, other): return self.variables == other.variables and self.coefficient == other.coefficient def __hash__(self): return hash((frozenset(self.variables.items()), self.coefficient)) def __repr__(self): terms = [f\\"(a_{k})^{v}\\" if v != 1 else f\\"(a_{k})\\" for k, v in sorted(self.variables.items())] return f\\"{self.coefficient}{\'\'.join(terms)}\\" class Polynomial: def __init__(self, monomials): self.monomials = monomials # list of Monomial objects def __eq__(self, other): return set(self.monomials) == set(other.monomials) def __repr__(self): return \\" + \\".join(map(str, self.monomials)) def simplify(polynomial: Polynomial) -> Polynomial: combined_monomials = defaultdict(int) for monomial in polynomial.monomials: # Convert variable dict to a tuple of sorted items to make it hashable var_tuple = tuple(sorted(monomial.variables.items())) combined_monomials[var_tuple] += monomial.coefficient # Filter out zero coefficients and create the resulting monomials simplified_monomials = [ Monomial(dict(variables), coefficient) for variables, coefficient in combined_monomials.items() if coefficient != 0 ] return Polynomial(simplified_monomials)"},{"question":"# Question: Radix Sort Implementation You are tasked with implementing the `radix_sort` function that efficiently sorts a list of non-negative integers using the Radix Sort algorithm. This algorithm should handle the digits of numbers from the least significant to the most significant. **Function Signature:** ```python def radix_sort(arr: List[int], simulation: bool = False) -> List[int]: ``` **Input:** - `arr`: List[int] - a list of non-negative integers (0 ≤ arr[i] ≤ 10^9) - `simulation`: bool - an optional flag to print the internal state at each iteration. **Output:** - List[int] - The sorted list of integers. **Constraints:** - The size of the list, `len(arr)`, can be up to 10^6. - The integers can have up to 10 digits. **Performance Requirements:** - The algorithm should run in O(nk + n) time complexity, where k is the maximum number of digits in any number and n is the length of the input list. - Optimize memory usage efficiently. **Example:** ```python assert radix_sort([170, 45, 75, 90, 802, 24, 2, 66]) == [2, 24, 45, 66, 75, 90, 170, 802] assert radix_sort([3, 34, 219, 504, 303]) == [3, 34, 219, 303, 504] ``` **Scenario/Context:** You are a software engineer responsible for implementing a fast and efficient sorting module for a large dataset of non-negative integers. This task is crucial for improving the performance of your company\'s data processing pipeline where sorted data is required for subsequent operations.","solution":"from typing import List def counting_sort(arr: List[int], exp: int, simulation: bool) -> List[int]: n = len(arr) output = [0] * n count = [0] * 10 for i in range(n): index = (arr[i] // exp) % 10 count[index] += 1 for i in range(1, 10): count[i] += count[i - 1] i = n - 1 while i >= 0: index = (arr[i] // exp) % 10 output[count[index] - 1] = arr[i] count[index] -= 1 i -= 1 for i in range(n): arr[i] = output[i] if simulation: print(f\\"exp={exp}, count={count}, output={output}\\") return arr def radix_sort(arr: List[int], simulation: bool = False) -> List[int]: if len(arr) == 0: return arr max1 = max(arr) exp = 1 while max1 // exp > 0: arr = counting_sort(arr, exp, simulation) exp *= 10 return arr"},{"question":"# Bogo Sort Simulation with Additional Constraints **Scenario**: You have encountered a whimsical sorting algorithm called Bogo Sort. However, in this magical land, it is used in a unique context at a magical marketplace lottery system where occasionally items are picked in a rush, causing chaos. The items need to be sorted back into order, but there’s a twist. The market master uses Bogo Sort to do this. **Task**: Implement the function `constrained_bogo_sort(arr: List[int], max_iterations: int) -> Tuple[List[int], int]` sorting an array using Bogo Sort, while limiting the number of iterations to prevent infinite loops. This function should: 1. Attempt to sort the array using the Bogo Sort algorithm. 2. Stop if the number of iterations exceeds `max_iterations`. 3. Return the array in its current state along with the number of iterations performed. **Input/Output Format**: - **Input**: - `arr`: A list of integers `[a1, a2, ..., an]` with ( 0 leq n leq 10 ). - `max_iterations`: An integer representing the maximum number of shuffles allowed. - **Output**: - A tuple `(sorted_array, num_iterations)` containing the (potentially) sorted array and the number of iterations performed before stopping. **Constraints**: - You must implement a function to shuffle the array. - You cannot use Python’s `random.shuffle` for the shuffling; write your own shuffling function. - The array has a maximum length of 10 to simplify testing. **Performance Requirements**: - Your function must stop executing if the maximum number of allowed iterations is reached. **Examples**: ```python constrained_bogo_sort([3, 2, 1], 5000) # Possible Output: ([1, 2, 3], 200) constrained_bogo_sort([1, 2, 3], 1) # Output: ([1, 2, 3], 0) ``` The task above assesses the student\'s understanding of Bogo Sort, including its properties, edge cases, and handling of constraints to avoid infinite loops.","solution":"import random from typing import List, Tuple def is_sorted(arr: List[int]) -> bool: Helper function to check if the array is sorted. for i in range(len(arr) - 1): if arr[i] > arr[i + 1]: return False return True def shuffle(arr: List[int]) -> List[int]: Helper function to shuffle the array randomly. arr_copy = arr[:] n = len(arr_copy) for i in range(n): j = random.randint(0, n - 1) arr_copy[i], arr_copy[j] = arr_copy[j], arr_copy[i] return arr_copy def constrained_bogo_sort(arr: List[int], max_iterations: int) -> Tuple[List[int], int]: Sorts the array using Bogo Sort with a constraint on number of iterations. Parameters: arr (List[int]): The array to be sorted. max_iterations (int): Maximum number of iterations allowed. Returns: Tuple[List[int], int]: The potentially sorted array and the number of iterations performed. iterations = 0 while not is_sorted(arr) and iterations < max_iterations: arr = shuffle(arr) iterations += 1 return arr, iterations"},{"question":"Context: You are given a `SeparateChainingHashTable` class that implements a hash table with separate chaining using linked lists. Your task is to extend this class with an additional method that deals with hash table optimization. Problem Statement: Implement a method named `resize` within the `SeparateChainingHashTable` class. This method should efficiently resize the hash table to reduce the load factor. The new hash table size should be a prime number that is approximately double the current size. Function Signature: ```python def resize(self): pass ``` Input: - No direct input. The function manipulates the internal state of the `SeparateChainingHashTable`. Output: - No direct output. The function updates the internal state of the hash table. Constraints: - Assume the initial table size is `11`, which is prime. - The resize operation should rehash all existing keys into the new table size. - The new size should be a prime number greater than or equal to twice the current size. Example: Consider the following sequence of operations: ```python table = SeparateChainingHashTable() # Create a new hash table with size 11. table.put(\'a\', 1) # Insert key-value pair (\'a\', 1). table.put(\'b\', 2) # Insert key-value pair (\'b\', 2). table.put(\'c\', 3) # Insert key-value pair (\'c\', 3). table.put(\'d\', 4) # Insert key-value pair (\'d\', 4). table.put(\'e\', 5) # Insert key-value pair (\'e\', 5). table.put(\'f\', 6) # Insert key-value pair (\'f\', 6). table.resize() # Resize the hash table. ``` After a call to `resize`, the hash table should have a new size that is a prime number approximately double the current size (e.g., 23) and contain the same key-value pairs correctly placed based on the new hash values. Notes: - You may need to find the next prime number greater than or equal to twice the current size. Implement a helper function if necessary. - Make sure to rehash all existing keys into new positions according to the new hash table size.","solution":"class SeparateChainingHashTable: def __init__(self): self.size = 11 self.table = [[] for _ in range(self.size)] def _hash(self, key): return hash(key) % self.size def put(self, key, value): index = self._hash(key) for kv in self.table[index]: if kv[0] == key: kv[1] = value return self.table[index].append([key, value]) def get(self, key): index = self._hash(key) for kv in self.table[index]: if kv[0] == key: return kv[1] return None def delete(self, key): index = self._hash(key) for kv in self.table[index]: if kv[0] == key: self.table[index].remove(kv) return def resize(self): new_size = self._find_next_prime(2 * self.size) new_table = [[] for _ in range(new_size)] for chain in self.table: for key, value in chain: new_index = hash(key) % new_size new_table[new_index].append([key, value]) self.size = new_size self.table = new_table def _find_next_prime(self, n): def is_prime(num): if num < 2: return False for i in range(2, int(num**0.5) + 1): if num % i == 0: return False return True while not is_prime(n): n += 1 return n"},{"question":"# Minimum Trials for Egg Drop Puzzle You are working in a high-stakes research lab and tasked with determining the minimum number of trials needed to find the highest floor (F) from which you can drop an egg without it breaking. You have access to a building with N floors and you have K identical eggs. Your goal is to find the minimum number of trials required in the worst-case scenario, so that you can determine with certainty the highest floor F. # Function Signature ```python def minimum_trials(k: int, n: int) -> int: pass ``` # Input - `k`: an integer representing the number of eggs (1 ≤ k ≤ 100). - `n`: an integer representing the number of floors (1 ≤ n ≤ 100). # Output - Return an integer representing the minimum number of trials needed to determine the highest floor from which an egg can be dropped without breaking. # Example ```python print(minimum_trials(1, 2)) # Output: 2 print(minimum_trials(2, 10)) # Output: 4 print(minimum_trials(3, 14)) # Output: 4 ``` # Constraints - You need to ensure your implementation is efficient in terms of both time and space. - Make sure to handle edge cases, such as having only one egg or one floor. # Notes - Focus on optimizing your implementation to reduce time complexity. - The function should handle up to 100 eggs and 100 floors efficiently. # Hints - Think about how dynamic programming can reduce the number of repeated calculations. - Use a 2D table approach to store the results of subproblems.","solution":"def minimum_trials(k: int, n: int) -> int: Determines the minimum number of trials needed in the worst-case scenario to find the highest floor from which an egg can be dropped without breaking. # dp[i][j] means the minimum number of trials needed for i eggs and j floors dp = [[0 for _ in range(n + 1)] for _ in range(k + 1)] # If there is only one egg, we need to try all floors from 1 to n for i in range(1, n + 1): dp[1][i] = i # If there is only one floor, we need one trial for any number of eggs for i in range(1, k + 1): dp[i][1] = 1 for i in range(2, k + 1): for j in range(2, n + 1): dp[i][j] = float(\'inf\') for x in range(1, j + 1): res = 1 + max(dp[i-1][x-1], dp[i][j-x]) if res < dp[i][j]: dp[i][j] = res return dp[k][n]"},{"question":"# Task Implement a function that calculates Euler\'s Totient function, ϕ(n), for multiple integers. You will be given an array of integers, and you need to compute the totient for each integer in the array. # Function Signature ```python def calculate_totients(arr: List[int]) -> List[int]: Compute Euler\'s Totient function for each integer in the input list. Parameters: arr (List[int]): A list of positive integers. Returns: List[int]: A list containing the results of ϕ(n) for each input integer n. ``` # Input * `arr`: A list of integers where each integer `n` satisfies 1 <= n <= 10^6. # Output * A list of integers, where each integer is the result of the Euler\'s Totient function ϕ(n) corresponding to the input integer `n`. # Constraints * The length of the array `arr` will be between 1 and 10^5. * Each integer in the array `arr` will be between 1 and 10^6. # Performance Requirements * The solution should be efficient to handle multiple queries efficiently given the constraints. # Example ```python print(calculate_totients([1, 2, 3, 10, 25])) # Output: [1, 1, 2, 4, 20] ``` # Notes 1. Be sure to handle edge cases such as when the input list contains the smallest possible values (1). 2. You might want to precompute Euler\'s Totient values up to the maximum number in the array for better efficiency when processing multiple queries.","solution":"from typing import List def calculate_totients(arr: List[int]) -> List[int]: Compute Euler\'s Totient function for each integer in the input list. Parameters: arr (List[int]): A list of positive integers. Returns: List[int]: A list containing the results of ϕ(n) for each input integer n. max_n = max(arr) phi = list(range(max_n + 1)) for i in range(2, max_n + 1): if phi[i] == i: for j in range(i, max_n + 1, i): phi[j] = phi[j] * (i - 1) // i return [phi[n] for n in arr]"},{"question":"# Graph Path Finding Assessment Context: You are given a graph represented as an adjacency list. The graph does not contain weighted edges. You are required to implement three functions to find specific types of paths between two given nodes in the graph. Task: 1. **Function 1**: Write a function `find_path(graph, start, end)` that returns a single path from the `start` node to the `end` node using Depth-First Search (DFS) and backtracking. 2. **Function 2**: Write a function `find_all_paths(graph, start, end)` that returns all possible paths from the `start` node to the `end` node using DFS and backtracking. 3. **Function 3**: Write a function `find_shortest_path(graph, start, end)` that returns the shortest path (in terms of the number of edges) from the `start` node to the `end` node. Inputs: - `graph`: A dictionary where keys are node identifiers and values are lists of adjacent nodes. - `start`: The starting node identifier. - `end`: The ending node identifier. Outputs: - Each function should return a list of nodes representing the path(s). - `find_path`: Return a list representing a single path. - `find_all_paths`: Return a list of lists, with each inner list representing a path. - `find_shortest_path`: Return a list representing the shortest path. Constraints: - The graph is unweighted and can be disconnected. - Nodes are labeled with integers or strings. - You may assume there are no negative cycles. Performance Requirements: - Efficient use of time and space, especially for the `find_all_paths` function. - Handle edge cases such as no path existing between nodes. Example: ```python graph_example = { \'A\': [\'B\', \'C\'], \'B\': [\'A\', \'D\', \'E\'], \'C\': [\'A\', \'F\'], \'D\': [\'B\'], \'E\': [\'B\', \'F\'], \'F\': [\'C\', \'E\'] } # Single path print(find_path(graph_example, \'A\', \'F\')) # Example output: [\'A\', \'C\', \'F\'] (one possible path) # All paths print(find_all_paths(graph_example, \'A\', \'F\')) # Example output: [[\'A\', \'C\', \'F\'], [\'A\', \'B\', \'E\', \'F\'], [\'A\', \'B\', \'D\', \'E\', \'F\']] # Shortest path print(find_shortest_path(graph_example, \'A\', \'F\')) # Example output: [\'A\', \'C\', \'F\'] ```","solution":"def find_path(graph, start, end, path=[]): Returns a single path from start to end node using DFS and backtracking. path = path + [start] if start == end: return path if start not in graph: return None for node in graph[start]: if node not in path: newpath = find_path(graph, node, end, path) if newpath: return newpath return None def find_all_paths(graph, start, end, path=[]): Returns all possible paths from start to end node using DFS and backtracking. path = path + [start] if start == end: return [path] if start not in graph: return [] paths = [] for node in graph[start]: if node not in path: newpaths = find_all_paths(graph, node, end, path) for newpath in newpaths: paths.append(newpath) return paths from collections import deque def find_shortest_path(graph, start, end): Returns the shortest path (in terms of the number of edges) from start to end node using BFS. if start == end: return [start] if start not in graph: return None queue = deque([(start, [start])]) visited = set() while queue: (current_node, path) = queue.popleft() if current_node not in visited: for adjacent in graph[current_node]: if adjacent == end: return path + [end] else: queue.append((adjacent, path + [adjacent])) visited.add(current_node) return None"},{"question":"Given two singly linked lists, write a function `find_intersection(h1, h2)` that returns the node at which the two lists intersect. If the lists do not intersect, return `None`. Input: - `h1`: The head node of the first singly linked list. - `h2`: The head node of the second singly linked list. Output: - Return the node at which the two linked lists intersect, or `None` if they do not intersect. Constraints: - Neither of the linked lists is guaranteed to be non-empty. - The lists are non-cyclical. Examples: **Example 1:** ``` 1 -> 3 -> 5 7 -> 9 -> 11 / 2 -> 4 -> 6 ``` - Input: `h1` is the head of (1 -> 3 -> 5 -> 7 -> 9 -> 11), and `h2` is the head of (2 -> 4 -> 6 -> 7 -> 9 -> 11) - Output: Node with value 7, since this is the node where both lists intersect. **Example 2:** ``` 1 -> 2 -> 3 4 -> 5 -> 6 ``` - Input: `h1` is the head of (1 -> 2 -> 3), and `h2` is the head of (4 -> 5 -> 6) - Output: `None`, since there is no intersection. **Implementation Instructions:** 1. Create a class `Node` with properties `val` and `next`. 2. Implement function `find_intersection(h1, h2)`. 3. The function should handle edge cases where either or both input lists are empty. 4. Use O(1) additional space. # Framework Code ```python class Node: def __init__(self, val=None): self.val = val self.next = None def find_intersection(h1, h2): # Implement your solution here pass # Test your implementation with this small suite import unittest class TestSuite(unittest.TestCase): def test_intersection(self): # create linked list as: # 1 -> 3 -> 5 # # 7 -> 9 -> 11 # / # 2 -> 4 -> 6 a1 = Node(1) b1 = Node(3) c1 = Node(5) d = Node(7) a2 = Node(2) b2 = Node(4) c2 = Node(6) e = Node(9) f = Node(11) a1.next = b1 b1.next = c1 c1.next = d a2.next = b2 b2.next = c2 c2.next = d d.next = e e.next = f self.assertEqual(7, find_intersection(a1, a2).val) if __name__ == \'__main__\': unittest.main() ```","solution":"class Node: def __init__(self, val=None): self.val = val self.next = None def find_intersection(h1, h2): Find the intersection node of two singly linked lists. if not h1 or not h2: return None # Get the lengths of both lists len1, len2 = 0, 0 node1, node2 = h1, h2 while node1: len1 += 1 node1 = node1.next while node2: len2 += 1 node2 = node2.next # Reset pointers to the heads node1, node2 = h1, h2 # Advance the pointer of the longer list if len1 > len2: for _ in range(len1 - len2): node1 = node1.next else: for _ in range(len2 - len1): node2 = node2.next # Traverse both lists together until the nodes are the same while node1 and node2: if node1 == node2: return node1 node1 = node1.next node2 = node2.next # If no intersection found return None"},{"question":"Scenario You are tasked with creating a utility function that can resolutely transform a list of potentially relative file paths into their full, absolute paths. This is a part of building a file indexing tool that must standardize paths to ensure uniformity in handling files. Task Write a function `resolve_paths(paths)` that takes a list of file paths and returns a dictionary where the keys are the original paths and the values are their corresponding absolute paths. Function Signature ```python def resolve_paths(paths: list) -> dict: ``` Input * `paths` – a list of strings, where each string is a file path. Each path may be absolute or relative, and may or may not include a `~` symbol indicating the user\'s home directory. Output * A dictionary where each key is a string from the input list and the corresponding value is the fully resolved absolute path. Example ```python input_paths = [\\"~/Documents/file.txt\\", \\"../folder1/file2.txt\\", \\"/etc/hosts\\"] print(resolve_paths(input_paths)) # Expected Output: # { # \\"~/Documents/file.txt\\": \\"/Users/username/Documents/file.txt\\", # \\"../folder1/file2.txt\\": \\"/Users/username/.../folder1/file2.txt\\", # \\"/etc/hosts\\": \\"/etc/hosts\\" # } ``` Constraints * You may assume all provided paths are syntactically correct. * The function should handle any valid filesystem path formats, including relative paths and paths starting with `~`. * Performance: Aim to handle lists of up to 1000 paths efficiently. Notes * Use the `os` library functions to ensure correct path transformations.","solution":"import os def resolve_paths(paths): This function takes a list of file paths and returns a dictionary where the keys are the original paths and the values are their corresponding absolute paths. resolved_paths = {} for path in paths: resolved_paths[path] = os.path.abspath(os.path.expanduser(path)) return resolved_paths"},{"question":"You are given a singly linked list. Your task is to write a function `find_cycle_entry_point` that finds and returns the first node of the cycle in the linked list, if a cycle exists. If there is no cycle, return `None`. Implement this function using Floyd\'s Cycle-Finding Algorithm. # Input - `head`: The head node of the singly linked list. The `Node` class is already implemented with the following attributes: * `val` (contains node\'s value), and * `next` (pointer to the next node). # Output - If there is a cycle, return the `Node` where the cycle begins. - If there is no cycle, return `None`. # Constraints - The number of nodes in the linked list is not constrained but should fit in memory. # Example ```python # Construction of the following linked list # A -> B -> C -> D -> E -> C (cycle starts at C) head = Node(\'A\') head.next = Node(\'B\') nodeC = Node(\'C\') head.next.next = nodeC head.next.next.next = Node(\'D\') head.next.next.next.next = Node(\'E\') head.next.next.next.next.next = nodeC assert find_cycle_entry_point(head).val == \'C\' ``` # Notes - You can assume that the linked list does not contain any duplicate values. - Avoid using extra data structures.","solution":"class Node: def __init__(self, val=0, next=None): self.val = val self.next = None def find_cycle_entry_point(head): if head is None or head.next is None: return None slow = head fast = head # Phase 1: Determine if there is a cycle while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: # Cycle detected break # If no cycle is found, return None if fast is None or fast.next is None: return None # Phase 2: Find the entry point of the cycle slow = head while slow != fast: slow = slow.next fast = fast.next return slow"},{"question":"Scenario/Context A city has various intersections connected by one-way streets. As a traffic analyst for the city, you need to develop a system that helps determine if it is possible to travel from one specific intersection to another using the available streets. Task Write a function `is_there_a_path` that determines if there is a path between two intersections in a directed graph representing the city\'s intersections and streets. Function Signature ```python def is_there_a_path(vertex_count: int, edges: List[Tuple[int, int]], source: int, target: int) -> bool: pass ``` Input * **vertex_count**: An integer representing the number of intersections in the city. * **edges**: A list of tuples where each tuple (a, b) represents a one-way street from intersection `a` to intersection `b`. * **source**: An integer representing the starting intersection. * **target**: An integer representing the destination intersection. Output * Return a boolean value indicating whether there is a path from the `source` intersection to the `target` intersection. Constraints 1. 1 <= vertex_count <= 10^4 2. 0 <= edges <= 2 * 10^4 3. 0 <= source, target < vertex_count Example ```python # Intersections count vertex_count = 5 # Streets edges = [(0, 1), (0, 2), (1, 2), (1, 3), (2, 4)] # Source and Target source = 0 target = 4 # Function call print(is_there_a_path(vertex_count, edges, source, target)) # Output: True source = 3 target = 4 print(is_there_a_path(vertex_count, edges, source, target)) # Output: False ``` Explanation - In the first case, there is a path from intersection 0 to 4 (0 -> 2 -> 4). - In the second case, there is no path from intersection 3 to 4. Performance Requirements - Ensure the function can handle large inputs within the given constraints efficiently.","solution":"from typing import List, Tuple from collections import deque def is_there_a_path(vertex_count: int, edges: List[Tuple[int, int]], source: int, target: int) -> bool: Determines if there is a path from source to target in a graph represented by vertex_count and edges. # Create adjacency list from the edges adjacency_list = [[] for _ in range(vertex_count)] for a, b in edges: adjacency_list[a].append(b) # Use BFS to check for path from source to target queue = deque([source]) visited = [False] * vertex_count visited[source] = True while queue: current = queue.popleft() if current == target: return True for neighbor in adjacency_list[current]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) return False"},{"question":"<|Analysis Begin|> # Core Identification * **Algorithm/Data Structure**: The given code constructs \\"word squares\\" using a backtracking search algorithm. * **Complexity**: - **Time Complexity**: Worst-case time complexity is O(N * 26^L), where N is the number of words, and L is the length of each word. - **Space Complexity**: The space complexity mainly involves the space required to store the results and intermediary prefix lists, which is O(N*L). * **Principles**: The algorithm uses backtracking to explore all possible word squares. It constructs word squares while checking prefixes at each step to ensure the word square condition is met. # Characteristics & Applications * **Properties**: - Prefix-based search: Words are added to the word square only if they match the required prefixes. - Backtracking: Explore possibilities and backtrack if a prefix does not yield a valid word square. * **Common Use Cases**: This type of algorithm can be useful in word puzzle games, automated crossword creation, and other word-based computational problems. * **Strengths/Limitations**: - **Strengths**: - Efficient creation of word squares. - Good use of prefix-based word grouping to reduce search space. - **Limitations**: - Performance can degrade with longer words and larger datasets. - Memory usage can be significant for large word lists. * **Most Suitable Use**: Suitable when word length and input size are moderate, and you need to find multiple valid word squares from a given list of words. # Implementation Challenges * **Edge Cases**: - Inputs with words of differing lengths. - Ensuring all rows and columns match for a valid word square. * **Performance Bottlenecks**: The primary bottleneck is the backtracking step that grows exponentially with the word length and number of words. * **Error Scenarios**: - Incorrect handling of prefixes might lead to invalid word squares or missed valid ones. - Mismanaging the base case conditions in backtracking. * **Optimization Points**: - Use of more efficient data structures like Tries for faster prefix search. - Pruning search space more aggressively. <|Analysis End|> <|Question Begin|> # Word Square Construction Objective Create a function that generates all possible word squares from a given set of words. A word square is an arrangement of words in a square grid such that each row reads the same as the corresponding column. Function Signature ```python def find_word_squares(words: List[str]) -> List[List[str]]: pass ``` Input - `words`: A list of strings, each representing a word. All words have the same length, and their length is between 1 and 5 inclusive. The total number of words will be between 1 and 1000 inclusive. Output - Return a list of lists, where each inner list represents a valid word square. Example ```python words = [\\"area\\",\\"lead\\",\\"wall\\",\\"lady\\",\\"ball\\"] print(find_word_squares(words)) # Expected Output: # [ # [\\"wall\\", \\"area\\", \\"lead\\", \\"lady\\"], # [\\"ball\\", \\"area\\", \\"lead\\", \\"lady\\"] # ] ``` # Constraints 1. Each word contains only lowercase English alphabets (a-z). 2. The order of word squares in the output does not matter, but within each square, the order of words does matter. # Performance Requirements - Efficiently handle the case where there are up to 1000 words, each of length 5. Guidelines 1. Utilize prefix-based searches to efficiently build potential word squares. 2. Implement a backtracking approach to explore all possible combinations. 3. Ensure the construction handles prefixes correctly at each level of the word square. # Scenario You are working on adding a feature to a word puzzle game that needs to generate all valid word squares from a given dictionary. Your function will be used to dynamically create word puzzles that are challenging and correctly structured.","solution":"from typing import List, Dict, Tuple, Set def build_prefix_map(words: List[str]) -> Dict[str, List[str]]: prefix_map = {} for word in words: for i in range(len(word)): prefix = word[:i+1] if prefix not in prefix_map: prefix_map[prefix] = [] prefix_map[prefix].append(word) return prefix_map def backtrack(step: int, word_len: int, word_square: List[str], results: List[List[str]], prefix_map: Dict[str, List[str]]): if step == word_len: results.append(word_square[:]) return prefix = \'\'.join([word[step] for word in word_square]) if prefix in prefix_map: for candidate in prefix_map[prefix]: word_square.append(candidate) backtrack(step + 1, word_len, word_square, results, prefix_map) word_square.pop() def find_word_squares(words: List[str]) -> List[List[str]]: if not words: return [] word_len = len(words[0]) prefix_map = build_prefix_map(words) results = [] for word in words: word_square = [word] backtrack(1, word_len, word_square, results, prefix_map) return results"},{"question":"# Scenario You have been hired by a company that processes large amounts of numerical data. They need you to develop a sorting algorithm that can efficiently sort arrays of non-negative integers. To fit their memory constraints, the algorithm should use additional space efficiently and handle small to moderately large lists gracefully. # Task Implement a `bucket_sort_enhanced` function to improve upon the given bucket sort implementation. Your function should: 1. Generalize the bucket size calculation to handle arbitrary ranges of input numbers. 2. Optimize the internal sorting mechanism of each bucket. 3. Return a correctly sorted array. # Requirements - **Input**: A list of non-negative integers `arr`. - **Output**: A sorted list in ascending order. Constraints - The length of the array `n` will be between 1 and 10^6. - The values in the array `arr[i]` will be between 0 and 10^9. Performance Requirements - The algorithm should have an average-case time complexity of O(n + k). - The solution must efficiently manage space. # Example ```python def bucket_sort_enhanced(arr): # Enhanced bucket sort implementation here pass # Example usage: arr = [29, 25, 3, 49, 9, 37, 21, 43] sorted_arr = bucket_sort_enhanced(arr) print(sorted_arr) # Output: [3, 9, 21, 25, 29, 37, 43, 49] ``` **Note**: Provide appropriate justifications for the chosen bucket size and the internal sorting optimization. # Solution Template ```python def bucket_sort_enhanced(arr): if len(arr) == 0: return arr # Step 1: Create Buckets num_buckets = len(arr) # Optimal number of buckets - can vary max_value = max(arr) min_value = min(arr) bucket_range = (max_value - min_value) / num_buckets buckets = [[] for _ in range(num_buckets)] # Step 2: Distribute the array elements into buckets for value in arr: index = int((value - min_value) / bucket_range) index = min(index, num_buckets - 1) buckets[index].append(value) # Step 3: Sort individual buckets and concatenate them sorted_list = [] for bucket in buckets: sorted_list.extend(sorted(bucket)) # Using Tim-sort (Python\'s Built-in) return sorted_list ```","solution":"def bucket_sort_enhanced(arr): Sorts a list of non-negative integers using an enhanced bucket sort algorithm. if len(arr) == 0: return arr # Step 1: Determine the bucket size and number of buckets num_buckets = len(arr) if len(arr) > 1 else 1 max_value = max(arr) min_value = min(arr) bucket_range = (max_value - min_value + 1) / num_buckets buckets = [[] for _ in range(num_buckets)] # Step 2: Distribute the array elements into buckets for value in arr: index = int((value - min_value) / bucket_range) # Clamp index to avoid \\"index out of range\\" issue index = min(index, num_buckets - 1) buckets[index].append(value) # Step 3: Sort individual buckets and concatenate them sorted_list = [] for bucket in buckets: sorted_list.extend(sorted(bucket)) # Use Python\'s built-in Timsort return sorted_list"},{"question":"Verify Sorted Linked List **Description**: You are given the head of a singly linked list. Implement a function `sort_linked_list` that will check if the linked list is sorted in non-decreasing order and, if it is not, will sort the linked list in non-decreasing order. **Function Signature**: ```python def sort_linked_list(head: Optional[Node]) -> Optional[Node]: pass ``` **Input**: * `head`: The head node of a singly linked list. Each node contains an integer value and a pointer to the next node or `null`. **Output**: * The head node of the modified linked list which is sorted in non-decreasing order. **Constraints**: * The linked list can have any number of nodes, from 0 to (10^5). * The values in the nodes are integers within the range (-10^9) to (10^9). # Example: ``` Input: head = [1, 2, -1, 3] Output: head = [-1, 1, 2, 3] Input: head = [4, 3, 2, 1] Output: head = [1, 2, 3, 4] Input: head = [] Output: head = [] ``` **Explanation**: * In the first example, the linked list `[1, 2, -1, 3]` is not sorted, so it is sorted to `[-1, 1, 2, 3]`. * In the second example, the linked list `[4, 3, 2, 1]` is not sorted, so it is sorted to `[1, 2, 3, 4]`. * In the third example, the linked list is empty, and the result is also an empty list. **Additional Information**: Think about how you can convert the linked list to an array, sort it, and re-form the linked list from the sorted array efficiently. Consider edge cases such as an already sorted list or an empty list.","solution":"from typing import Optional class Node: def __init__(self, data: int, next: Optional[\'Node\'] = None): self.data = data self.next = next def sort_linked_list(head: Optional[Node]) -> Optional[Node]: Sorts the linked list in non-decreasing order if it is not already sorted. Returns the head node of the sorted linked list. # Base case for empty list or a list with a single node if not head or not head.next: return head # Convert linked list to array node_list = [] current = head while current: node_list.append(current.data) current = current.next # Sort the array node_list.sort() # Convert sorted array back to linked list dummy_head = Node(0) # Create a dummy head to simplify list creation current = dummy_head for val in node_list: current.next = Node(val) current = current.next return dummy_head.next"},{"question":"**Graph Traversal with Specific Constraints** You are given an unweighted graph represented as an adjacency list, and your goal is to implement a function to find all nodes reachable from a given start node using both BFS and DFS traversal methods. Additionally, you should also compute the number of steps it takes to reach each node from the start node for BFS traversal. Function Signature: ```python def graph_traversal(graph: Dict[int, List[int]], start: int) -> Tuple[Dict[int, int], Set[int]]: ``` # Input: - `graph`: A dictionary where keys are node identifiers (unique integers), and values are lists of integers representing the nodes connected by an edge. - `start`: An integer representing the starting node for the traversal. # Output: - A tuple containing: - A dictionary where keys are nodes reachable from the start node and values are the minimum number of steps required to reach each node (for BFS traversal). - A set of all nodes reachable from the start node (for DFS traversal). # Constraints: - The graph is represented as an adjacency list. - Node identifiers are non-negative integers. - The graph might be disconnected. - You can assume the starting node is always valid. # Example: ```python graph = { 0: [1, 2], 1: [2], 2: [0, 3], 3: [3] } start = 2 # Expected output: # ( # {2: 0, 0: 1, 3: 1, 1: 2}, # BFS traversal steps count # {2, 0, 1, 3} # DFS reachable nodes # ) ``` # Instructions: 1. Implement the required graph traversal functions to handle the constraints mentioned. 2. Ensure to handle edge cases such as empty graphs and disconnected components. 3. Optimize for performance to handle large graphs effectively.","solution":"from collections import deque from typing import List, Dict, Tuple, Set def graph_traversal(graph: Dict[int, List[int]], start: int) -> Tuple[Dict[int, int], Set[int]]: def bfs(graph, start): visited = {} queue = deque([(start, 0)]) while queue: node, steps = queue.popleft() if node not in visited: visited[node] = steps for neighbor in graph.get(node, []): if neighbor not in visited: queue.append((neighbor, steps + 1)) return visited def dfs(graph, start): visited = set() stack = [start] while stack: node = stack.pop() if node not in visited: visited.add(node) for neighbor in graph.get(node, []): if neighbor not in visited: stack.append(neighbor) return visited bfs_result = bfs(graph, start) dfs_result = dfs(graph, start) return bfs_result, dfs_result"},{"question":"You are tasked with implementing a function that takes a string of digits and a target value, and returns all possible ways to add binary operators (+, -, *) between the digits to achieve the target value. The solution should involve a Depth-First Search (DFS) approach with backtracking. Function Signature ```python def generate_expressions(digits: str, target: int) -> List[str]: pass ``` Input * `digits` (str): A non-empty string that contains only digits (0-9). * `target` (int): The target value to be achieved through the insertion of binary operators. Output * List of strings, where each string is a valid expression that evaluates to the target value. Constraints * Leading zeros in the numbers should be handled correctly (i.e., \\"05\\" is not a valid number). * You are allowed to use the operators +, -, and * only. * You must use all digits in the string in each expression. Example 1. `generate_expressions(\\"123\\", 6)` should return `[\\"1+2+3\\", \\"1*2*3\\"]` 2. `generate_expressions(\\"232\\", 8)` should return `[\\"2*3+2\\", \\"2+3*2\\"]` 3. `generate_expressions(\\"105\\", 5)` should return `[\\"1*0+5\\", \\"10-5\\"]` 4. `generate_expressions(\\"00\\", 0)` should return `[\\"0+0\\", \\"0-0\\", \\"0*0\\"]` 5. `generate_expressions(\\"3456237490\\", 9191)` should return `[]` Performance Requirements The solution must be efficient and handle input strings with a length up to 10 digits. You can begin by writing a helper function that performs the DFS and handles the recursive exploration of possible operator placements. Use backtracking to ensure all valid combinations are explored.","solution":"from typing import List def generate_expressions(digits: str, target: int) -> List[str]: def backtrack(index: int, prev_operand: int, current_operand: int, value: int, expr: str): # If we have reached the end of the digit string, check if the expression evaluates to the target if index == len(digits): if value == target and current_operand == 0: results.append(expr) return # Start from first index and iterate till the end of digit length for i in range(index, len(digits)): # Avoid numbers with leading zeroes if i != index and digits[index] == \'0\': break # Generate the current operand by appending the current digit current_val_str = digits[index:i + 1] current_val = int(current_val_str) if index == 0: # First number in the expression backtrack(i + 1, current_val, 0, current_val, current_val_str) else: # Addition backtrack(i + 1, current_val, 0, value + current_val, expr + \\"+\\" + current_val_str) # Subtraction backtrack(i + 1, -current_val, 0, value - current_val, expr + \\"-\\" + current_val_str) # Multiplication backtrack(i + 1, prev_operand * current_val, 0, value - prev_operand + (prev_operand * current_val), expr + \\"*\\" + current_val_str) results = [] backtrack(0, 0, 0, 0, \\"\\") return results"},{"question":"Context Given a string `s` and a set of words `dictionary`, write a function that calculates the number of ways to segment the string into a list of valid sentences where each word in the sentence is in the dictionary. Avoid counting the same segmentation multiple times. Function Signature ```python def count_sentences(s: str, dictionary: set) -> int: ``` Input * `s`: A non-empty string representing the input string. * `dictionary`: A set of strings representing the valid words. Output * Returns an integer representing the number of valid segmentations of the input string. Constraints * The length of `s` will be at most 50. * Each word in the dictionary will have a length between 1 to 10. * All characters in `s` and the dictionary are lowercase English letters. Example ```python s = \\"appletablet\\" dictionary = {\\"apple\\", \\"tablet\\", \\"applet\\", \\"able\\", \\"table\\", \\"let\\", \\"t\\"} ``` Expected output: `4` Segments: 1. \\"apple\\", \\"tablet\\" 2. \\"apple\\", \\"table\\", \\"t\\" 3. \\"applet\\", \\"able\\", \\"t\\" 4. \\"applet\\", \\"let\\", \\"t\\" Hints 1. Consider using dynamic programming or memoization to optimize your solution. 2. Be mindful of overlapping subproblems as the recursive approach explores different prefixes. Implementation Guidelines * Ensure your solution handles edge cases like an empty string, strings that cannot be fully segmented, and repeated computations. * Make sure to reset or handle global variables properly to avoid unintended side-effects between function calls.","solution":"def count_sentences(s: str, dictionary: set) -> int: Computes the number of ways to segment a string into valid words found in the given dictionary. Parameters: s (str): the string to be segmented dictionary (set): a set of valid words Returns: int: the number of valid segmentations of the input string memo = {} def count_ways(sub_s): if sub_s == \\"\\": return 1 if sub_s in memo: return memo[sub_s] total_ways = 0 for i in range(1, len(sub_s) + 1): prefix = sub_s[:i] if prefix in dictionary: total_ways += count_ways(sub_s[i:]) memo[sub_s] = total_ways return total_ways return count_ways(s)"},{"question":"You are the lead developer for a tech company that maintains a large, sorted database of customer transactions. You need to implement a function to quickly find the first occurrence of a transaction ID in this sorted database for auditing and transaction tracking purposes. # Task Write a Python function called `first_occurrence` that takes two arguments: 1. A list of integers `array`, sorted in increasing order, representing the transaction IDs. 2. An integer `query`, representing the transaction ID to search for. The function should return the index of the first occurrence of the `query` in the `array`. If the `query` is not found in the `array`, the function should return `-1`. # Function Signature ```python def first_occurrence(array, query): pass ``` # Input * `array`: A list of integers sorted in increasing order, `1 <= len(array) <= 10^5` * `query`: An integer, `1 <= query <= 10^5` # Output * An integer representing the index of the first occurrence of `query` in `array`. If `query` is not present, return `-1`. # Constraints * The array is guaranteed to be sorted in increasing order. * Optimal performance is desirable, considering the length of the array can be up to 100,000 elements. # Example ```python print(first_occurrence([1, 2, 2, 4, 5], 2)) # Output: 1 print(first_occurrence([1, 2, 2, 4, 5], 6)) # Output: -1 print(first_occurrence([1, 1, 1, 1, 1], 1)) # Output: 0 print(first_occurrence([], 1)) # Output: -1 ``` # Explanation 1. In the first example, the first occurrence of the number `2` is at index `1`. 2. In the second example, the number `6` is not present in the array, so the output is `-1`. 3. In the third example, all elements in the array are `1`, so the first occurrence is at index `0`. 4. The fourth example checks for an edge case where the array is empty, returning `-1`.","solution":"def first_occurrence(array, query): Returns the index of the first occurrence of query in array. If query is not found, returns -1. Utilizes binary search for optimal performance. low, high = 0, len(array) - 1 while low <= high: mid = (low + high) // 2 if array[mid] < query: low = mid + 1 elif array[mid] > query: high = mid - 1 else: if mid == 0 or array[mid - 1] != query: return mid high = mid - 1 return -1"},{"question":"Design a set of functions to encode a list of strings into a single string and decode that single string back into the original list of strings. Your implementation should be efficient and handle edge cases gracefully. **Input and Output Formats**: - `encode` function: - **Input**: A list of strings (`List[str]`). - **Output**: A single encoded string (`str`) that combines all input strings. - `decode` function: - **Input**: A single encoded string (`str`). - **Output**: The original list of strings (`List[str]`). **Constraints**: - The length of each string in the list and the total length of the encoded string must be manageable within standard memory limits. - Assume the input list will contain only ASCII characters. **Performance Requirements**: - The `encode` and `decode` functions should both run in linear time with respect to the total number of characters in all the strings. **Scenario**: Imagine you are implementing a chat application that needs to send messages (list of strings) from one client to another over a network. For transmission efficiency, you want to encode the list of strings into a single string before sending, and decode it back on the receiving end. ```python def encode(strs): Encodes a list of strings to a single string. :type strs: List[str] :rtype: str res = \'\' for string in strs.split(): res += str(len(string)) + \\":\\" + string return res def decode(s): Decodes a single string to a list of strings. :type s: str :rtype: List[str] strs = [] i = 0 while i < len(s): index = s.find(\\":\\", i) size = int(s[i:index]) strs.append(s[index+1: index+1+size]) i = index+1+size return strs ``` - **Test Cases**: - `encode([\\"hello\\", \\"world\\"])` should return \\"5:hello5:world\\". - `decode(\\"5:hello5:world\\")` should return [\\"hello\\", \\"world\\"]. - `encode([])` should return \\"\\". - `decode(\\"\\")` should return []. Write the complete implementations of the `encode` and `decode` functions accordingly.","solution":"def encode(strs): Encodes a list of strings to a single string. :type strs: list[str] :rtype: str encoded_str = \\"\\" for s in strs: encoded_str += f\\"{len(s)}:{s}\\" return encoded_str def decode(s): Decodes a single string to a list of strings. :type s: str :rtype: list[str] decoded_list = [] i = 0 while i < len(s): # Find the position of the separator \\":\\" j = s.find(\':\', i) # Read the length of the next string length = int(s[i:j]) # Extract the string string = s[j+1:j+1+length] decoded_list.append(string) # Move to the next position i = j + 1 + length return decoded_list"},{"question":"You are given an implementation of a Markov Chain that can iterate through states based on given transition probabilities. Your task is to extend this functionality by creating a function that simulates a Markov Chain for a specified number of steps and collects the states visited in a path. # Function Signature ```python def simulate_markov_chain(chain: dict, initial_state: str, steps: int) -> list: ``` # Input * `chain`: A dictionary representing the Markov chain where the keys are states and values are dictionaries with probable next states and their corresponding probabilities. * `initial_state`: A string representing the initial state in the chain. * `steps`: An integer representing the number of steps to simulate in the Markov Chain. # Output * A list of strings where each string is a state visited sequentially, starting from the initial state. # Constraints * The input chain will have at least one state. * The total sum of probabilities in each state\'s dictionary will sum to 1. * The number of steps will be a positive integer. # Example ```python chain = { \'A\': {\'A\': 0.6, \'B\': 0.4}, \'B\': {\'A\': 0.3, \'B\': 0.7} } initial_state = \'A\' steps = 5 simulate_markov_chain(chain, initial_state, steps) ``` Possible output: ```python [\'A\', \'B\', \'B\', \'A\', \'A\'] ``` # Explanation In the example above, starting at state \'A\', the function simulates 5 steps transitioning between states based on the given probabilities at each step. The output list contains the sequence of states visited. # Notes * Use the existing methods provided above (`__choose_state`, `next_state`, `iterating_markov_chain`) to assist in the implementation. * Consider boundary cases such as an empty chain, although guaranteed constraints prevent this scenario from happening here.","solution":"import random def __choose_state(probabilities): Helper function to choose a state based on given probabilities. random_value = random.random() cumulative = 0.0 for state, probability in probabilities.items(): cumulative += probability if random_value < cumulative: return state # safeguard in case of rounding errors return state def simulate_markov_chain(chain, initial_state, steps): Simulate a Markov chain for a specified number of steps. :param chain: A dictionary representing the Markov chain. :param initial_state: The initial state in the chain. :param steps: Number of steps to simulate. :return: A list of states visited in the path. current_state = initial_state path = [current_state] for _ in range(steps): current_state = __choose_state(chain[current_state]) path.append(current_state) return path # Example usage: chain = { \'A\': {\'A\': 0.6, \'B\': 0.4}, \'B\': {\'A\': 0.3, \'B\': 0.7} } initial_state = \'A\' steps = 5 simulate_markov_chain(chain, initial_state, steps)"},{"question":"Rabin-Miller Primality Test Implementation **Context:** As an upcoming software engineer working on a cryptographic module, you are tasked with implementing a component that efficiently determines the primality of large numbers using the Rabin-Miller primality test, a probabilistic algorithm. **Task:** Implement the `is_prime` function that uses the Rabin-Miller primality test to check whether a given integer `n` is prime. The function should return `True` if the number is probably prime, and `False` if it is definitely composite. Ensure to handle edge cases appropriately. **Function Signature:** ```python def is_prime(n: int, k: int) -> bool: pass ``` **Input Format:** * An integer `n` (2 ≤ n ≤ 10^18), the number to be tested for primality. * An integer `k` (1 ≤ k ≤ 100), representing the number of iterations to perform for the test. **Output Format:** * Return `True` if `n` is probably prime, else return `False`. **Constraints:** * Your function should have a time complexity of O(k log^3 n). * Ensure the space complexity remains O(1). **Example:** ```python print(is_prime(17, 5)) # Output: True print(is_prime(18, 5)) # Output: False print(is_prime(15485863, 10)) # Output: True ``` **Notes:** * For `n < 5`, handle these cases explicitly as described by the precondition checks. * Consider optimizing the internal modular exponentiation to handle large numbers efficiently. * Verify edge cases and error conditions to ensure robustness of the solution.","solution":"import random def is_prime(n: int, k: int) -> bool: Uses the Rabin-Miller primality test to check if a number n is prime. The test runs k iterations for accuracy. if n <= 1: return False if n <= 3: return True if n % 2 == 0: return False def power_mod(base, exp, mod): Efficient modular exponentiation to compute (base ** exp) % mod result = 1 base %= mod while exp > 0: if exp % 2 == 1: result = (result * base) % mod exp //= 2 base = (base * base) % mod return result d = n - 1 r = 0 while d % 2 == 0: d //= 2 r += 1 for _ in range(k): a = random.randint(2, n - 2) x = power_mod(a, d, n) if x == 1 or x == n - 1: continue for _ in range(r - 1): x = power_mod(x, 2, n) if x == n - 1: break else: return False return True"},{"question":"# Gnome Sort Implementation Challenge **Scenario**: You are tasked with implementing a sorting algorithm known as Gnome Sort. This algorithm has a unique approach to sorting by stepping through the list and performing swaps. Given an array of integers, your goal is to sort the array in ascending order using the Gnome Sort algorithm. **Function Signature**: ```python def gnome_sort(arr: List[int]) -> List[int]: pass ``` # Input: - A list of integers, `arr` (0 <= len(arr) <= 1000). - Each integer in the array can range from -1000 to 1000. # Output: - A new list of integers sorted in ascending order. # Constraints: 1. The algorithm must be implemented using the gnome sort principles. 2. Avoid using any built-in sort functions. # Example: ```python gnome_sort([34, 2, 78, 1, 56]) -> [1, 2, 34, 56, 78] gnome_sort([-3, 0, -1, 4, -5]) -> [-5, -3, -1, 0, 4] gnome_sort([10, 10, 0, -10, 20]) -> [-10, 0, 10, 10, 20] ``` **Performance Requirements**: Ensure that the implementation can handle edge cases gracefully and operates within optimal time for the given constraints.","solution":"def gnome_sort(arr): Sorts the array in ascending order using the Gnome Sort algorithm. Parameters: arr (List[int]): The list of integers to sort. Returns: List[int]: The sorted list of integers. index = 0 n = len(arr) while index < n: if index == 0 or arr[index] >= arr[index - 1]: index += 1 else: arr[index], arr[index - 1] = arr[index - 1], arr[index] index -= 1 return arr"},{"question":"# Question Scenario You are tasked with implementing a function for a robotics project that uses binary search trees (BSTs) to model decision paths. One important aspect is to know the height of the decision tree, which is critical for evaluating the complexity of the decision-making process. Problem Statement Write a function `height(root)` that calculates the height of a given Binary Search Tree (BST). The function should return the height as an integer. Your function will be tested with various BSTs, so ensure that it handles edge cases such as an empty tree or a tree with just one node. # Function Specification - **Function Name**: `height` - **Parameters**: - `root` (Node): The root node of the BST. - **Returns**: An integer representing the height of the tree. # Input and Output - **Input**: A Node object representing the root of a Binary Search Tree. - **Output**: An integer representing the height of the tree. # Constraints - The number of nodes in the tree will be between 0 and 10,000. - Node values are unique integers ranging from -10^4 to 10^4. # Example ```python # Example usage: # Define node and BST classes class Node: def __init__(self, key): self.left = None self.right = None self.val = key def bst_insert(root, key): if root is None: return Node(key) else: if root.val < key: root.right = bst_insert(root.right, key) else: root.left = bst_insert(root.left, key) return root # Construct the example tree root = Node(9) root = bst_insert(root, 6) root = bst_insert(root, 12) root = bst_insert(root, 3) root = bst_insert(root, 8) root = bst_insert(root, 10) root = bst_insert(root, 15) root = bst_insert(root, 7) root = bst_insert(root, 18) # Function call print(height(root)) # Output: 4 ``` # Additional Edge Cases 1. An empty tree should return height 0: - `height(None)` should return `0`. 2. A tree with a single node: - `height(Node(5))` should return `1`. # Performance Requirements - Your implementation should efficiently handle trees with up to 10,000 nodes. Note Ensure you handle the edge cases and avoid deep recursion issues for large trees.","solution":"class Node: def __init__(self, key): self.left = None self.right = None self.val = key def height(root): Returns the height of a binary search tree. if root is None: return 0 left_height = height(root.left) right_height = height(root.right) return max(left_height, right_height) + 1"},{"question":"Implement and Optimize the Cocktail Shaker Sort You are tasked with implementing an optimized function for the Cocktail Shaker Sort. This function should maintain the in-place sorting and stable sorting characteristics of the original algorithm but should handle additional performance optimizations. **Function Signature**: ```python def optimized_cocktail_shaker_sort(arr: list[int]) -> list[int]: pass ``` **Input**: - A list of integers `arr` where `0 <= len(arr) <= 10^6`. **Output**: - A list of integers where the elements are sorted in ascending order. **Constraints**: - Ensure the algorithm remains in-place and stable. - Attempt to reduce the number of redundant comparisons and swaps to improve efficiency. **Scenario**: You are working with large datasets and need an efficient sorting algorithm that operates effectively even if the data is partially sorted. Achieving performance optimization while retaining the core properties of Cocktail Shaker Sort is crucial. **Performance Requirements**: - Ensure the solution can handle edge cases like empty lists, single-element lists, lists with all identical elements, and pre-sorted lists efficiently. - Optimize to minimize unnecessary traversals of the list. **Example**: ```python assert optimized_cocktail_shaker_sort([5, 3, 4, 2, 1]) == [1, 2, 3, 4, 5] assert optimized_cocktail_shaker_sort([1, 2, 3, 5, 4]) == [1, 2, 3, 4, 5] assert optimized_cocktail_shaker_sort([]) == [] assert optimized_cocktail_shaker_sort([1]) == [1] assert optimized_cocktail_shaker_sort([2, 1, 2, 1]) == [1, 1, 2, 2] ``` # Notes: - Keep track of the actual boundaries where changes happen to avoid unnecessary passes. - Consider edge cases and optimize for them.","solution":"def optimized_cocktail_shaker_sort(arr: list[int]) -> list[int]: Optimized implementation of the Cocktail Shaker Sort algorithm. This function sorts the input list in ascending order in-place. if not arr: return arr n = len(arr) start = 0 end = n - 1 swapped = True while swapped: swapped = False for i in range(start, end): if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] swapped = True if not swapped: break # Reset the swapped flag so we can use it in the next stage swapped = False end -= 1 for i in range(end, start, -1): if arr[i] < arr[i - 1]: arr[i], arr[i - 1] = arr[i - 1], arr[i] swapped = True start += 1 return arr"},{"question":"# Finding Strongly Connected Components in a Directed Graph **Background**: You are given a directed graph where each node represents a web page, and each directed edge represents a hyperlink from one page to another. Your task is to find all Strongly Connected Components (SCC) in the graph using Tarjan\'s Algorithm. A Strongly Connected Component is a maximal subgraph where every vertex is reachable from every other vertex in this subgraph. **Input**: - A dictionary representation of a directed graph where keys are node identifiers and values are lists of adjacent nodes. **Output**: - A list of SCCs, where each SCC is represented as a list of node identifiers. **Task**: Implement a function `find_scc(graph: Dict[int, List[int]]) -> List[List[int]]` that finds all strongly connected components using Tarjan\'s Algorithm. **Constraints**: - Node identifiers are unique integers. - The graph can have up to 10^4 vertices and 10^5 edges. - Graph can be empty or contain disconnected nodes. - You can assume no parallel edges and no self-loops. **Example**: ```python def find_scc(graph: Dict[int, List[int]]) -> List[List[int]]: # Your code here # Example usage: graph = { 0: [1], 1: [2], 2: [0, 3], 3: [4], 4: [] } print(find_scc(graph)) ``` **Expected output**: ```python [[4], [3], [0, 2, 1]] ``` **Note**: - The exact order of SCCs in the output does not matter, as long as nodes within each SCC are correctly identified.","solution":"def find_scc(graph): Finds all strongly connected components (SCCs) in the given directed graph using Tarjan\'s algorithm. Parameters: graph (Dict[int, List[int]]): A dictionary representation of a directed graph where keys are node identifiers and values are lists of adjacent nodes. Returns: List[List[int]]: A list of SCCs, where each SCC is represented as a list of node identifiers. index = 0 stack = [] indices = {} lowlinks = {} on_stack = {} sccs = [] def strongconnect(node): nonlocal index indices[node] = index lowlinks[node] = index index += 1 stack.append(node) on_stack[node] = True for neighbor in graph.get(node, []): if neighbor not in indices: strongconnect(neighbor) lowlinks[node] = min(lowlinks[node], lowlinks[neighbor]) elif on_stack.get(neighbor, False): lowlinks[node] = min(lowlinks[node], indices[neighbor]) if lowlinks[node] == indices[node]: scc = [] while True: w = stack.pop() on_stack[w] = False scc.append(w) if w == node: break sccs.append(scc) for node in graph: if node not in indices: strongconnect(node) return sccs"},{"question":"Context: You are tasked with implementing a dictionary-like system that supports efficient insertion, search, and prefix-based query functionality. This system should handle multiple query types dynamically. Task: Implement a `Trie` class with the following methods: 1. **`insert(word: str) -> None`**: Inserts the string `word` into the trie. 2. **`search(word: str) -> bool`**: Returns true if the string `word` is in the trie, and false otherwise. 3. **`starts_with(prefix: str) -> bool`**: Returns true if there is any string in the trie that starts with the given `prefix`, and false otherwise. Your implementation should ensure efficiency in terms of both time and space use. Input and Output: - **Insert Method**: `insert(\\"word\\")` - Input: A string `word` consisting of lowercase letters (\'a\' to \'z\'). - Output: None - **Search Method**: `search(\\"word\\")` - Input: A string `word` consisting of lowercase letters (\'a\' to \'z\'). - Output: Boolean value `True` if `word` is found, `False` otherwise. - **Starts With Method**: `starts_with(\\"prefix\\")` - Input: A string `prefix` consisting of lowercase letters (\'a\' to \'z\'). - Output: Boolean value `True` if any word in the trie starts with `prefix`, `False` otherwise. Constraints: - Assume all input strings will only contain lowercase letters a-z. - Function execution for each word or prefix should be optimal (i.e., should run in linear time relative to the length of the word or prefix). - You should handle edge cases such as searching or querying prefixes of non-existent words appropriately. Implement the Trie class based on the above requirements and ensure that it performs efficiently for a large number of words and queries.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str) -> None: node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, word: str) -> bool: node = self.root for char in word: if char not in node.children: return False node = node.children[char] return node.is_end_of_word def starts_with(self, prefix: str) -> bool: node = self.root for char in prefix: if char not in node.children: return False node = node.children[char] return True"},{"question":"# Student Coding Question: Remove Duplicates from a Linked List **Objective:** Implement a function to remove duplicate values from a singly linked list. **Function Signature:** ```python def remove_duplicates(head: Node) -> Node: pass ``` # Requirements: 1. **Input**: A singly linked list where each node contains an integer value. 2. **Output**: The modified linked list with all duplicates removed. 3. You are not allowed to use any additional data structures such as hash sets. 4. The relative order of the elements must be preserved. 5. **Constraints**: - The linked list may contain up to 10^4 nodes. - Each node\'s value is an integer between -10^5 and 10^5. # Specifications: - Implement the function to meet O(N^2) time complexity and O(1) space complexity. **Example:** ```plaintext Given: Linked list: 1 -> 2 -> 3 -> 2 -> 1 Output: Linked list: 1 -> 2 -> 3 ``` # Test Cases: 1. **Input**: 1 -> 1 -> 1 -> 1 **Output**: 1 2. **Input**: 4 -> 5 -> 6 -> 5 -> 4 -> 7 **Output**: 4 -> 5 -> 6 -> 7 3. **Input**: 10 -> 9 -> 8 -> 7 **Output**: 10 -> 9 -> 8 -> 7 # Detailed specification for the `Node` class used in the function: ```python class Node: def __init__(self, value=None): self.value = value self.next = None ``` **Implementation:** Write the function `remove_duplicates` adhering to the given requirements.","solution":"class Node: def __init__(self, value=None): self.value = value self.next = None def remove_duplicates(head: Node) -> Node: Removes duplicate values from a singly linked list. if not head: return head current = head while current: runner = current while runner.next: if runner.next.value == current.value: runner.next = runner.next.next else: runner = runner.next current = current.next return head"},{"question":"# Minimal Bit Flips to Convert Integers Objective Write a function `count_flips_to_convert(a, b)` that determines the minimal number of bits you would need to flip to convert integer `a` to integer `b`. Input * Two integers, `a` and `b` (0 <= a, b <= 2^31-1). Output * An integer representing the number of bits that need to be flipped. Constraints * You may assume that both `a` and `b` fit within a 32-bit signed integer. Example ```python count_flips_to_convert(29, 15) # Output: 2 count_flips_to_convert(0, 0) # Output: 0 count_flips_to_convert(1, 0) # Output: 1 ``` Scenario Imagine you are working on an error detection system that needs to determine the number of differences between transmitted and received data packets. Each data packet can be represented as an integer, and you need a quick way to determine how many bits something needs to be flipped to convert one packet into another, ensuring efficient error correction. Function Signature ```python def count_flips_to_convert(a: int, b: int) -> int: # Write your implementation here pass ``` # Notes * You may use bitwise operations to solve this problem efficiently. * Consider edge cases such as where `a` and `b` are identical, one of them is zero, or both are very large.","solution":"def count_flips_to_convert(a, b): Returns the number of bits that need to be flipped to convert integer a to integer b. xor_result = a ^ b count = 0 while xor_result: count += xor_result & 1 xor_result >>= 1 return count"},{"question":"# Simplify Unix-Style File Path Problem Statement Given an absolute path for a file (Unix-style), write a function `simplify_path(path)` to simplify it. This involves converting the path to its canonical form: - Converting multiple consecutive slashes into a single slash. - Removing redundant current directory references (\'.\'). - Correctly handling parent directory references (\'..\') such that going above the root directory results in \'/\'. Input - A single string `path` representing the Unix-style file path. Output - A simplified canonical string representing the file path. Constraints - The input path will be a string of length at most 10^4. - The input path will be a valid Unix-style path. Example ```text Input: \\"/home/\\" Output: \\"/home\\" Input: \\"/a/./b/../../c/\\" Output: \\"/c\\" Input: \\"/../\\" Output: \\"/\\" Input: \\"/home//foo/\\" Output: \\"/home/foo\\" ``` Edge Cases - Path with multiple consecutive slashes \\"/home//foo/\\" - Path going above the root directory \\"/../\\" - Path ending with multiple slashes \\"/a/b/c/\\" Requirements Implement a function `simplify_path(path: str) -> str` that simplifies the input path according to the described rules.","solution":"def simplify_path(path): Simplifies the given Unix-style file path. Args: path (str): The Unix-style file path Returns: str: The simplified canonical path parts = path.split(\'/\') stack = [] for part in parts: if part == \'\' or part == \'.\': continue elif part == \'..\': if stack: stack.pop() else: stack.append(part) return \'/\' + \'/\'.join(stack)"},{"question":"You are tasked to implement a function that efficiently computes the exponential result of a given base raised to a given power and optionally apply a modulo operation. The function must handle both large base and exponent values efficiently. # Function Signature ```python def custom_power(base: int, exponent: int, modulo: int = None) -> int: pass ``` # Input - `base` (int) : The base number (1 <= base <= 10^9). - `exponent` (int) : The exponent to which the base is raised (0 <= exponent <= 10^9). - `modulo` (int, optional) : A number modulo which the result should be computed (1 <= modulo <= 10^9). If not provided, compute the standard exponentiation. # Output - Return the computed result of base^exponent modulo `modulo` (if provided), otherwise return base^exponent. # Constraints - You should utilize binary exponentiation technique for efficient computation. - Ensure the implementation handles large inputs without performance degradation. # Example ```python assert custom_power(2, 10) == 1024 assert custom_power(2, 10, 1000) == 24 assert custom_power(10, 0) == 1 assert custom_power(9, 3, 100) == 29 assert custom_power(2, 1000000000, 1000000007) == 140625001 ``` # Requirements - Use either iterative or recursive approach. - Pay attention to edge cases, particularly zeroes in the base and exponent. - Handle large inputs efficiently, ensuring no overflow errors.","solution":"def custom_power(base: int, exponent: int, modulo: int = None) -> int: Compute base^exponent. If modulo is given, compute (base^exponent) % modulo. Utilizes binary exponentiation for efficient computation. def binary_exponentiation(base, exponent, modulo): result = 1 base = base % modulo while exponent > 0: if exponent % 2 == 1: # If exponent is odd, multiply base with result result = (result * base) % modulo exponent = exponent >> 1 # Divide the exponent by 2 base = (base * base) % modulo # Square the base return result if modulo: return binary_exponentiation(base, exponent, modulo) else: result = 1 while exponent > 0: if exponent % 2 == 1: # If exponent is odd, multiply base with result result *= base exponent = exponent >> 1 # Divide the exponent by 2 base *= base # Square the base return result"},{"question":"You are designing a message transmission system that encodes and decodes lists of strings for network communication. Implement the `encode()` and `decode()` functions according to the following specifications: Function Definitions: 1. **encode()** - **Input**: A list of strings `strs`. - **Output**: A single encoded string. - **Description**: Concatenate the length of each string followed by the colon `:` character and the string itself. ```python def encode(strs): Encodes a list of strings to a single string. :type strs: List[str] :rtype: str # WRITE YOUR CODE HERE ``` 2. **decode()** - **Input**: A single encoded string `s`. - **Output**: The original list of strings. - **Description**: Parse the string by reading lengths and corresponding substrings. ```python def decode(s): Decodes a single string to a list of strings. :type s: str :rtype: List[str] # WRITE YOUR CODE HERE ``` Constraints: * The `encode` function should handle empty input appropriately. * The `decode` function should correctly parse valid encoded strings. * You can assume that the input to `decode()` will always be a valid encoded string as per your encoding scheme. * Performance should be optimized for typical use cases. Example: ```python # Given: strings = [\\"hello\\", \\"world\\"] # Encode: encoded_str = encode(strings) # encoded_str should be \\"5:hello5:world\\" # Decode: decoded_list = decode(encoded_str) # decoded_list should be [\\"hello\\", \\"world\\"] ``` Ensure your implementation handles edge cases like empty string lists and special characters within the strings.","solution":"def encode(strs): Encodes a list of strings to a single string. :type strs: List[str] :rtype: str encoded_str = \'\' for s in strs: encoded_str += f\'{len(s)}:{s}\' return encoded_str def decode(s): Decodes a single string to a list of strings. :type s: str :rtype: List[str] decoded_list = [] i = 0 while i < len(s): # Find the length of the next string j = i while s[j] != \':\': j += 1 length = int(s[i:j]) # Extract the string based on the identified length decoded_list.append(s[j+1:j+1+length]) # Move to the next part of the encoded string i = j + 1 + length return decoded_list"},{"question":"# Question: You are tasked with writing a function that filters a list such that each number appears at most N times, while retaining the original order of appearance. Function Signature: ```python def filter_list_by_occurrence(input_list: List[int], max_occurrences: int) -> List[int]: pass ``` Input: * `input_list` (List[int]): A list of integers which may have duplicates. * `max_occurrences` (int): A non-negative integer that specifies the maximum number of occurrences for each element. Output: * Returns a new list with the same integers but ensuring that each integer appears at most `max_occurrences` times, retaining their initial order. Constraints: * `0 <= len(input_list) <= 10^5` * `0 <= max_occurrences <= 10^4` * The list elements are between `-10^9` and `10^9`. Requirements: * The implementation should have a time complexity of O(n). * You should use hashing or a similar efficient mechanism to track occurrences. Example: ```python input_list = [1, 2, 3, 1, 2, 1, 2, 3] max_occurrences = 2 filter_list_by_occurrence(input_list, max_occurrences) -> [1, 2, 3, 1, 2, 3] ``` In this example, the first occurrence of 1, 2, and 3 are taken completely. The second occurrence of 1 and 2 are accepted but the third occurrences are dropped. The remaining 3 is added as it is within the allowed limit, leading to the final list: `[1, 2, 3, 1, 2, 3]`. Notes: - Pay close attention to edge cases elucidated in the analysis. - Ensure the algorithm runs efficiently on large inputs.","solution":"from typing import List def filter_list_by_occurrence(input_list: List[int], max_occurrences: int) -> List[int]: Filters the input list to ensure that each number appears at most max_occurrences times, while retaining the original order of appearance. if max_occurrences == 0: return [] occurrence_count = {} filtered_list = [] for num in input_list: if num in occurrence_count: if occurrence_count[num] < max_occurrences: filtered_list.append(num) occurrence_count[num] += 1 else: filtered_list.append(num) occurrence_count[num] = 1 return filtered_list"},{"question":"# Ordered Stack Analysis and Implementation Objective You are given a partially implemented Ordered Stack that maintains the elements in sorted order from bottom to top. Complete the implementation of the `OrderedStack` class by addressing the following prompt. Problem Statement You are tasked with improving the performance of the Ordered Stack for the `push` operation. The aim is to minimize the number of operations required to insert an element while maintaining the stack order. Instructions 1. Complete the `OrderedStack` class by optimizing the `push` method. 2. Ensure that the stack maintains the elements in a sorted order from bottom to top. Functional Requirements 1. **push(item)**: Insert an item into the stack while maintaining sorted order. - **Input**: `item` (a numeric value). - **Output**: None. 2. **pop()**: Remove and return the top element of the stack. - **Input**: None. - **Output**: The top element of the stack. 3. **peek()**: Return the top element of the stack without removing it. - **Input**: None. - **Output**: The top element of the stack. 4. **is_empty()**: Check if the stack is empty. - **Input**: None. - **Output**: Boolean indicating whether the stack is empty. 5. **size()**: Return the number of elements in the stack. - **Input**: None. - **Output**: The size of the stack. Constraints * The stack must maintain the ordering from the smallest at the bottom to the largest at the top. * Avoid using built-in sorting algorithms for the `push` operation. Example ```python stack = OrderedStack() stack.push(3) stack.push(1) stack.push(2) print(stack.pop()) # Output: 3 print(stack.pop()) # Output: 2 print(stack.pop()) # Output: 1 ``` Ensure that your implementation is efficient and handles edge cases appropriately. Optimize the `push` method to handle large datasets efficiently.","solution":"class OrderedStack: def __init__(self): self.stack = [] def push(self, item): if not self.stack or item >= self.stack[-1]: self.stack.append(item) else: temp_stack = [] while self.stack and self.stack[-1] > item: temp_stack.append(self.stack.pop()) self.stack.append(item) while temp_stack: self.stack.append(temp_stack.pop()) def pop(self): if not self.stack: raise IndexError(\\"pop from empty stack\\") return self.stack.pop() def peek(self): if not self.stack: raise IndexError(\\"peek from empty stack\\") return self.stack[-1] def is_empty(self): return len(self.stack) == 0 def size(self): return len(self.stack)"},{"question":"Design and Implement a Prefix Suggester **Context**: You\'re tasked with creating a `PrefixSuggester` system that supports adding new words and suggesting completions for a given prefix. Unlike the above problem, your task is to build a more nuanced system from these functionalities. This tool is intended to improve input efficiency in textual applications, such as search engines or integrated development environments. **Requirements**: 1. Implement a class `PrefixSuggester` that supports: - Adding words. - Suggesting words based on a given prefix. **Detailed Specifications**: 1. **add_word(word: str) -> None**: Adds the given `word` to the `PrefixSuggester`. 2. **suggest(prefix: str) -> List[str]**: Returns a list of all words in the data structure that start with the given `prefix`. These suggestions need to be sorted in lexicographical order. **Input & Output**: * `add_word(word)` * **Input**: A string \\"word\\" without any spaces or special characters. * **Output**: None * `suggest(prefix)` * **Input**: A string \\"prefix\\" without any spaces or special characters. * **Output**: A list of strings representing the suggested completions, sorted in lexicographical order. **Constraints**: - All words and prefixes consist of lowercase alphabets. - The length of any word or prefix will be between 1 and 100, inclusive. - The total number of words added will not exceed 10^5. **Performance Requirements**: - The add_word function should operate efficiently even when a large number of words is added. - The suggest function should return results within 1 second for prefixes. # Example Usage: ```python ps = PrefixSuggester() ps.add_word(\\"apple\\") ps.add_word(\\"appetite\\") ps.add_word(\\"appliance\\") ps.add_word(\\"append\\") print(ps.suggest(\\"app\\")) # Should output [\\"append\\", \\"appetite\\", \\"apple\\"] print(ps.suggest(\\"appl\\")) # Should output [\\"apple\\", \\"appliance\\"] print(ps.suggest(\\"apple\\"))# Should output [\\"apple\\"] print(ps.suggest(\\"xyz\\")) # Should output [] ``` **Note**: Ensure your solution handles edge cases like prefixes with no matching words efficiently. Also, consider optimizing for both time and space based on the constraints provided.","solution":"class PrefixSuggester: def __init__(self): self.words = [] def add_word(self, word: str) -> None: self.words.append(word) # Keep the words list sorted lexicographically for quick suggestion. self.words.sort() def suggest(self, prefix: str) -> list: # To store the suggestions suggestions = [] # Iterate over sorted words list and collect matching prefix words for word in self.words: if word.startswith(prefix): suggestions.append(word) return suggestions"},{"question":"Digit Counter You are tasked with implementing a Python function that counts the number of digits in a given integer using a logarithmic approach. Your function should handle both positive and negative integers, as well as zero. The function should run in constant time complexity O(1). Function Signature ```python def count_digits(n: int) -> int: pass ``` Input * An integer `n` where `-10^18 ≤ n ≤ 10^18`. Output * An integer representing the number of digits in `n`. # Example ```python # Example 1 input: 12345 output: 5 # Example 2 input: -987654321 output: 9 # Example 3 input: 0 output: 1 ``` # Constraints * Your implementation must use a logarithmic function to achieve O(1) time complexity. # Important Scenarios and Edge Cases * Ensure the function returns 1 for an input of 0. * Negative numbers should be counted as if they were positive. * Extremely large and small values within the given range should be processed correctly. Implement the `count_digits` function adhering to the specified constraints and ensuring it meets the performance requirements.","solution":"import math def count_digits(n: int) -> int: Returns the number of digits in the given integer n. if n == 0: return 1 return int(math.log10(abs(n))) + 1"},{"question":"# Scenario You are working on a data serialization library that needs to support various endianness formats due to requirements from different systems. Your task is to extend and optimize the provided functions for converting integers to bytes and vice versa using both big-endian and little-endian byte orders. # Main Requirements 1. **Function Implementations**: - Convert an integer to a big-endian byte sequence. - Convert a big-endian byte sequence back to an integer. - Convert an integer to a little-endian byte sequence. - Convert a little-endian byte sequence back to an integer. 2. **Extensions and Optimizations**: - Maintain the current functionalities but enhance their performance where possible. - Handle edge cases such as the integer `0` efficiently. # Input and Output Formats - **Input**: - An integer `num` for conversion to a byte sequence. - A byte sequence `bytestr` for conversion to an integer. - **Output**: - A byte sequence resulting from an integer-to-byte conversion. - An integer resulting from a byte-to-integer conversion. # Functions 1. `int_to_bytes_big_endian(num: int) -> bytes` - **Input**: `num` (integer to be converted) - **Output**: A `bytes` object representing the integer in big-endian format. - **Constraints**: 0 <= num < 2^64 2. `bytes_big_endian_to_int(bytestr: bytes) -> int` - **Input**: `bytestr` (byte sequence in big-endian format) - **Output**: An `int` reconstructed from the byte sequence - **Constraints**: `bytestr` is a non-empty sequence of bytes 3. `int_to_bytes_little_endian(num: int) -> bytes` - **Input**: `num` (integer to be converted) - **Output**: A `bytes` object representing the integer in little-endian format. - **Constraints**: 0 <= num < 2^64 4. `bytes_little_endian_to_int(bytestr: bytes) -> int` - **Input**: `bytestr` (byte sequence in little-endian format) - **Output**: An `int` reconstructed from the byte sequence - **Constraints**: `bytestr` is a non-empty sequence of bytes # Example Example 1: ```python # Converting integer to big-endian byte sequence num = 305419896 # == 0x12345678 result = int_to_bytes_big_endian(num) print(result) # Output: b\'x12x34x56x78\' ``` Example 2: ```python # Converting big-endian byte sequence to integer bytestr = b\'x12x34x56x78\' result = bytes_big_endian_to_int(bytestr) print(result) # Output: 305419896 ``` Example 3: ```python # Converting integer to little-endian byte sequence num = 305419896 # == 0x12345678 result = int_to_bytes_little_endian(num) print(result) # Output: b\'x78x56x34x12\' ``` Example 4: ```python # Converting little-endian byte sequence to integer bytestr = b\'x78x56x34x12\' result = bytes_little_endian_to_int(bytestr) print(result) # Output: 305419896 ``` # Constraints - Ensure the functions handle edge cases such as `0`. - Optimize your implementations for performance. **Note**: Assume valid input formats; you do not need to handle non-integer or negative values.","solution":"def int_to_bytes_big_endian(num: int) -> bytes: Converts an integer to a big-endian byte sequence. return num.to_bytes((num.bit_length() + 7) // 8 or 1, \'big\') def bytes_big_endian_to_int(bytestr: bytes) -> int: Converts a big-endian byte sequence to an integer. return int.from_bytes(bytestr, \'big\') def int_to_bytes_little_endian(num: int) -> bytes: Converts an integer to a little-endian byte sequence. return num.to_bytes((num.bit_length() + 7) // 8 or 1, \'little\') def bytes_little_endian_to_int(bytestr: bytes) -> int: Converts a little-endian byte sequence to an integer. return int.from_bytes(bytestr, \'little\')"},{"question":"Encode and Decode List of Strings You are given the task of implementing a mechanism to encode a list of strings into a single string and subsequently decode that single string back into the original list of strings. This is important for scenarios such as sending data over a network or storing it in a compact form. Implement the following two functions: 1. **encode(strs)**: - **Input**: A list of strings `strs`. - **Output**: A single string that encodes the list of strings. 2. **decode(s)**: - **Input**: A single string `s` that encodes a list of strings. - **Output**: The original list of strings. Here are the constraints: - Each string within the list can contain any printable ASCII character. - The encoded string should be able to handle an empty list of strings. - Strings within the list can be empty. - You may not use any string delimiter that might conflict with the data, and colon (`:`) is already used as a special delimiter in the encoding process. Consider edge cases such as: - An empty string within the list. - A string that contains a colon (`:`). - Large lists of small strings. - Small lists with very large strings. # Example For encoding: ```python encode([\\"hello\\", \\"world\\"]) -> \\"5:hello5:world\\" encode([\\"\\"]) -> \\"0:\\" encode([\\"abc\\", \\"d:e:f\\", \\"\\", \\"ghij\\"]) -> \\"3:abc5:d:e:f0:4:ghij\\" ``` For decoding: ```python decode(\\"5:hello5:world\\") -> [\\"hello\\", \\"world\\"] decode(\\"0:\\") -> [\\"\\"] decode(\\"3:abc5:d:e:f0:4:ghij\\") -> [\\"abc\\", \\"d:e:f\\", \\"\\", \\"ghij\\"] ``` Ensure your implementation is robust and handles all possible edge cases appropriately.","solution":"def encode(strs): Encodes a list of strings to a single string. return \'\'.join(f\'{len(s)}:{s}\' for s in strs) def decode(s): Decodes a single string to a list of strings. decoded = [] i = 0 while i < len(s): # find the next colon which separates the length and the actual string j = s.find(\':\', i) length = int(s[i:j]) # length of the next string i = j + 1 # move to the start of the actual string content decoded.append(s[i:i + length]) i += length # move to the start of the next length descriptor return decoded"},{"question":"You have been tasked with designing a system for scheduling tasks in a project. Tasks are represented as a Directed Acyclic Graph (DAG) where each node corresponds to a task, and an edge from task A to task B signifies that task A must be completed before task B. Implement a function `schedule_tasks(graph)` to return a valid order of tasks that respects these dependencies. If the graph contains a cycle, return an error indicating a cycle was detected. # Function Signature ```python def schedule_tasks(graph: Dict[int, List[int]]) -> List[int]: ``` # Input - `graph`: A dictionary representing the adjacency list of a directed graph where the keys are task IDs (integers), and the values are lists of task IDs that must be completed before the key task. # Output - Returns a list of integers representing a valid order of task execution. - If the graph contains a cycle, raise a `ValueError` with the message \\"Cycle detected\\". # Constraints - The number of tasks (vertices) is between 1 and 10^4. - There can be up to 10^5 dependencies (edges). # Example Example Input: ```python graph = { 1: [2], 2: [3], 3: [] } ``` Example Output: ```python [3, 2, 1] # or [3, 1, 2] depending on the DFS implementation details ``` Example Input with Cycle: ```python graph = { 1: [2], 2: [3], 3: [1] } ``` Example Output: ```python ValueError: Cycle detected ``` # Explanation - The first example represents a simple DAG where task 1 depends on task 2, and task 2 depends on task 3. A valid topological sort order would be [3, 2, 1]. - The second example is a graph containing a cycle (1 -> 2 -> 3 -> 1). As cycles prevent a valid topological sort, an error should be raised. Your task is to implement this function correctly and handle the edge cases appropriately.","solution":"from typing import List, Dict def schedule_tasks(graph: Dict[int, List[int]]) -> List[int]: from collections import deque, defaultdict # Calculate in-degrees of all vertices in_degree = {u: 0 for u in graph} for u in graph: for v in graph[u]: in_degree[v] += 1 # Queue for vertices with no incoming edges queue = deque([u for u in graph if in_degree[u] == 0]) topological_order = [] while queue: u = queue.popleft() topological_order.append(u) # Decrease in-degree of all neighbors for v in graph[u]: in_degree[v] -= 1 if in_degree[v] == 0: queue.append(v) # Check if topological sort is possible (i.e., no cycles) if len(topological_order) == len(graph): return topological_order else: raise ValueError(\\"Cycle detected\\")"},{"question":"# Priority Queue with String Priorities You are tasked with implementing a Modified Priority Queue data structure that uses string-based priorities instead of numerical ones. This priority queue will sort the strings lexicographically. Specifically, you need to: 1. Modify the existing `PriorityQueue` and `PriorityQueueNode` classes to handle string priorities. 2. Ensure that the `push` method correctly inserts nodes based on lexicographical order of their string priorities. 3. Allow the `pop` method to remove and return the item with the lexicographically smallest priority. # Function Signatures ```python class PriorityQueueNode: def __init__(self, data, priority: str): pass class PriorityQueue: def __init__(self, items=None, priorities=None): pass def size(self) -> int: pass def push(self, item, priority: str): pass def pop(self): pass ``` # Requirements 1. **Input Specification**: - `push(self, item, priority: str)`: Inserts an item with a string priority into the queue. - `pop(self)`: Removes and returns the item with the lexicographically smallest priority. 2. **Output Specification**: - `push` should modify the internal state of the queue. - `pop` should return the data of the node with the lexicographically smallest priority. 3. **Constraints**: - `priority` is a non-empty string. - `pop` is only called when the queue is non-empty. 4. **Example**: ```python pq = PriorityQueue() pq.push(\\"task1\\", \\"high\\") pq.push(\\"task2\\", \\"medium\\") pq.push(\\"task3\\", \\"low\\") print(pq.pop()) # Output should be \\"task3\\" print(pq.pop()) # Output should be \\"task2\\" print(pq.pop()) # Output should be \\"task1\\" ``` # Clarifications 1. If two items have the same priority, the one added first should come out first (lexicographical order). 2. The solution should handle various edge cases, such as inserting into an empty queue and popping the last remaining item.","solution":"class PriorityQueueNode: def __init__(self, data, priority: str): self.data = data self.priority = priority class PriorityQueue: def __init__(self): self.heap = [] def size(self) -> int: return len(self.heap) def push(self, item, priority: str): node = PriorityQueueNode(item, priority) self.heap.append(node) self.heap.sort(key=lambda x: x.priority) # Sort based on string priority def pop(self): if self.size() == 0: raise IndexError(\\"pop from empty priority queue\\") return self.heap.pop(0).data"},{"question":"Context You\'re tasked with creating a mechanism to encode a list of strings into a single string for compact transmission and storage. Conversely, you also need to decode this single string back into its original list of strings. Ensuring the encoded string is unique is crucial to avoid data corruption during transmission. Problem Statement Implement two functions, `encode()` and `decode()`, that perform the following operations: - `encode(strs)`: Given a list of strings `strs`, return a single encoded string. - `decode(s)`: Given an encoded string `s`, return the original list of strings. Requirements 1. The encoding should be robust to handle any characters within the strings, including numbers and delimiters. 2. The decoding should accurately reconstruct the list of strings, exactly as it was before encoding. Input and Output Formats: - `encode(strs)`: - Input: List of strings `strs` (List[str]). - Output: Encoded string (str). - `decode(s)`: - Input: Encoded string `s` (str). - Output: List of original strings (List[str]). Constraints: - The total number of characters in `strs` combined will not exceed `10^6`. - Each string in the list `strs` will have a maximum length of `1000`. - Strings may contain any printable ASCII characters. Example: ```python # Example usage: input_strs = [\\"hello\\", \\"world\\", \\"123\\"] encoded = encode(input_strs) # Example encoded output: \\"5:hello5:world3:123\\" decoded = decode(encoded) # Should return [\\"hello\\", \\"world\\", \\"123\\"] assert decoded == input_strs ``` Implement the `encode` and `decode` functions below: ```python def encode(strs): Encodes a list of strings to a single string. :type strs: List[str] :rtype: str res = \'\' for string in strs: res += str(len(string)) + \\":\\" + string return res def decode(s): Decodes a single string to a list of strings. :type s: str :rtype: List[str] strs = [] i = 0 while i < len(s): index = s.find(\\":\\", i) size = int(s[i:index]) strs.append(s[index+1: index+1+size]) i = index+1+size return strs ``` Write a full implementation and conduct tests to verify edge cases and correctness of your functions.","solution":"def encode(strs): Encodes a list of strings to a single string. :type strs: List[str] :rtype: str res = \'\' for string in strs: res += str(len(string)) + \\":\\" + string return res def decode(s): Decodes a single string to a list of strings. :type s: str :rtype: List[str] strs = [] i = 0 while i < len(s): index = s.find(\\":\\", i) size = int(s[i:index]) strs.append(s[index+1: index+1+size]) i = index+1+size return strs"},{"question":"# Problem Description Your task is to implement a function to remove duplicates from an unsorted singly linked list. You are required to do this **without using any additional data structures**. # Input You are provided with the head of a singly linked list. Each node has a value and a reference to the next node. The list can contain any data type as values but will be homogenous (all values in the list are of the same type). # Output Return the head of the modified linked list where all duplicates have been removed. The order of the nodes should be the same as in the input list, but only the first occurrence of each value should be preserved. # Constraints - You are **not allowed** to use any additional data structures (e.g., sets, lists). - The function should have a **time complexity** of O(N^2) in the worst case and **space complexity** of O(1). # Example ```python class Node(): def __init__(self, val = None): self.val = val self.next = None def remove_dups_without_set(head): Remove duplicates from a singly linked list without using extra space. :param head: The head of the linked list. :return: The head of the modified linked list. # Your code here def print_linked_list(head): if not head: print(\\"Empty List\\") return result = [] current = head while current: result.append(str(current.val)) current = current.next print(\\" -> \\".join(result)) # Example usage: # Creating the linked list: 1 -> 2 -> 3 -> 2 -> 1 -> 4 n1 = Node(1) n2 = Node(2) n3 = Node(3) n4 = Node(2) n5 = Node(1) n6 = Node(4) n1.next = n2 n2.next = n3 n3.next = n4 n4.next = n5 n5.next = n6 # Removing duplicates remove_dups_without_set(n1) print_linked_list(n1) # Expected Output: 1 -> 2 -> 3 -> 4 ``` **Note**: Modify the `remove_dups_without_set` function to properly remove duplicates without using any additional data structures.","solution":"class Node: def __init__(self, val=None): self.val = val self.next = None def remove_dups_without_set(head): Remove duplicates from a singly linked list without using extra space. :param head: The head of the linked list. :return: The head of the modified linked list. if not head: return head current = head while current: runner = current while runner.next: if runner.next.val == current.val: # Remove the duplicate node runner.next = runner.next.next else: runner = runner.next current = current.next return head"},{"question":"You are required to implement a `SortedQueue` class using two instances of the `OrderedStack` class. The `SortedQueue` must maintain its elements in ascending order such that when elements are dequeued, the smallest element is always retrieved first. # Requirements 1. **Method Signatures**: * `def __init__(self):` - Initialize your queue. * `def enqueue(self, item: int) -> None:` - Add an item to the queue while maintaining ascending order. * `def dequeue(self) -> int:` - Remove and return the smallest item from the queue. * `def is_empty(self) -> bool:` - Return `True` if the queue is empty, else `False`. 2. **Input/Output**: * The `enqueue` method should accept an integer. * The `dequeue` method should return an integer. * The `is_empty` method should return a boolean value. 3. **Constraints**: * All operations should maintain the order in the queue. * At any point, the operations should not exceed O(n) time complexity if n is the number of elements in the queue. 4. **Error Handling**: * Raise an appropriate error if attempting to dequeue from an empty queue. # Example Usage ```python # Example execution: queue = SortedQueue() queue.enqueue(10) queue.enqueue(5) queue.enqueue(15) print(queue.dequeue()) # Output: 5 print(queue.dequeue()) # Output: 10 print(queue.dequeue()) # Output: 15 assert queue.is_empty() # Output: True ``` # Note Ensure all methods operate as expected and maintain the ascending order of elements within the `SortedQueue`. Properly handle edge cases such as attempting to dequeue from an empty queue.","solution":"class OrderedStack: def __init__(self): self.stack = [] def push(self, item): self.stack.append(item) def pop(self): if not self.is_empty(): return self.stack.pop() else: raise IndexError(\\"pop from empty stack\\") def peek(self): if not self.is_empty(): return self.stack[-1] else: raise IndexError(\\"peek from empty stack\\") def is_empty(self): return len(self.stack) == 0 class SortedQueue: def __init__(self): self.in_stack = OrderedStack() self.out_stack = OrderedStack() def enqueue(self, item: int) -> None: # Move elements from in_stack to out_stack while not self.in_stack.is_empty() and self.in_stack.peek() < item: self.out_stack.push(self.in_stack.pop()) # Push the new item into in_stack self.in_stack.push(item) # Move elements back to in_stack while not self.out_stack.is_empty(): self.in_stack.push(self.out_stack.pop()) def dequeue(self) -> int: if self.in_stack.is_empty() and self.out_stack.is_empty(): raise IndexError(\\"dequeue from empty queue\\") return self.in_stack.pop() def is_empty(self) -> bool: return self.in_stack.is_empty() and self.out_stack.is_empty()"},{"question":"# Coding Challenge: Sort Student Scores Context: You are given a list of student scores that needs to be sorted in ascending order. To accomplish this, you need to implement a sorting algorithm, particularly Comb Sort. Requirements: Implement a function `sort_student_scores(scores)` that accepts a list of integers representing student scores and returns the sorted list. Function Signature: ```python def sort_student_scores(scores: List[int]) -> List[int]: ``` Input Format: * `scores`: A list of integers where each integer represents a student\'s score. Output Format: * A list of integers, sorted in ascending order. Constraints: * The list can contain up to (10^6) integers. * Each score is a non-negative integer and less than (10^9). Performance Requirements: * Ensure the solution is efficient in both time and space. * The solution should handle edge cases like empty lists, single-element lists, and lists with repeated elements gracefully. Examples: 1. Input: `[5, 3, 8, 4, 2]` Output: `[2, 3, 4, 5, 8]` 2. Input: `[15, 15, 15, 15]` Output: `[15, 15, 15, 15]` 3. Input: `[12, 4, 78, 2, 0, 45, 21, 33]` Output: `[0, 2, 4, 12, 21, 33, 45, 78]` Good luck!","solution":"def sort_student_scores(scores): Sorts a list of student scores in ascending order using Comb Sort. Args: - scores: List of integers representing student scores. Returns: - A sorted list of integers in ascending order. def get_next_gap(gap): # Shrink gap by the shrink factor of 1.3 gap = int(gap / 1.3) if gap < 1: return 1 return gap n = len(scores) gap = n swapped = True while gap != 1 or swapped: gap = get_next_gap(gap) swapped = False for i in range(n - gap): if scores[i] > scores[i + gap]: scores[i], scores[i + gap] = scores[i + gap], scores[i] swapped = True return scores"},{"question":"# Decoding Numeric Message Challenge **Problem Description:** A message containing letters from A-Z is encoded to numbers using the mapping as follows: - \'A\' -> 1 - \'B\' -> 2 - ... - \'Z\' -> 26 Given an encoded message as a string of digits, write a function to determine the total number of ways to decode it. The function should have the following signature: ```python def decode_message(encoded_message: str) -> int: ``` **Input:** - `encoded_message`: A string representing the encoded message, where each character is a digit from \'0\'-\'9\'. The length of the string will be between 1 and 100 inclusive. **Output:** - Return an integer representing the total number of ways to decode the message. **Constraints:** - The encoded message does not contain any leading zeros. - The encoded message only contains characters \'0\'-\'9\'. **Examples:** 1. Input: \\"12\\" - Output: 2 - Explanation: \\"12\\" can be decoded as \\"AB\\" (1 2) or \\"L\\" (12). 2. Input: \\"226\\" - Output: 3 - Explanation: \\"226\\" can be decoded as \\"BZ\\" (2 26), \\"VF\\" (22 6), or \\"BBF\\" (2 2 6). 3. Input: \\"06\\" - Output: 0 - Explanation: Since there is a leading zero in \\"06\\", it cannot be decoded. **Edge Cases to Consider:** - Single-digit inputs. - Inputs containing zeros, especially between valid digits (i.e., \'101\'). - Longer sequences of digits requiring efficient computation. **Requirements:** - Achieve time complexity of O(n) where n is the length of the input string. - Use constant space if possible. **Scenario:** You are tasked with implementing a feature for a text decoding application that must process encoded messages efficiently and correctly report the number of possible decodings. Ensuring the solution is optimal and handles all edge cases is crucial for the application\'s reliability and performance. ```python def decode_message(encoded_message: str) -> int: # Implementation here ```","solution":"def decode_message(encoded_message: str) -> int: if not encoded_message or encoded_message[0] == \'0\': return 0 n = len(encoded_message) dp = [0] * (n + 1) dp[0] = 1 for i in range(1, n + 1): # Check the current digit if encoded_message[i - 1] != \'0\': dp[i] += dp[i - 1] # Check the last two digits if i > 1 and \'10\' <= encoded_message[i - 2:i] <= \'26\': dp[i] += dp[i - 2] return dp[n]"},{"question":"Scenario You are given the task of implementing a utility function in a library that needs to search for elements within datasets. Due to the nature of these datasets, they can be large and you must handle them efficiently, even if they are not sorted. Given the constraints of not knowing the order of elements beforehand, you should implement a linear search approach. Problem Statement Write a Python function `linear_search(array, query)` that performs a linear search on the array and returns the index at which the `query` element is found. If the `query` element is not found in the array, it should return -1. Function Signature ```python def linear_search(array: list, query: int) -> int: pass ``` Input * `array`: A list of integers where you will search for the `query` element. * `query`: An integer representing the element you need to find in the array. Output * Return an integer representing the index of the `query` element in the array. * If the `query` element is not present, return -1. Constraints 1. The `array` can contain between 0 and 10^5 elements. 2. Each element in the `array` is an integer between -10^9 and 10^9. 3. The `query` value will be an integer within the same range as the elements of the `array`. Example ```python # Example 1 array = [34, 8, 50, 2, 99] query = 50 print(linear_search(array, query)) # should return 2 # Example 2 array = [34, 8, 50, 2, 99] query = 100 print(linear_search(array, query)) # should return -1 # Example 3 array = [] query = 10 print(linear_search(array, query)) # should return -1 ``` # Requirements * Ensure your function runs efficiently for up to 10^5 elements. * Handle edge cases such as empty arrays and large values. * Document your code with comments explaining your logic.","solution":"def linear_search(array: list, query: int) -> int: Performs a linear search on the array to find the index of the query element. :param array: list of integers where the search is performed :param query: integer element to search for :return: index of the query element in the array or -1 if not found for index, element in enumerate(array): if element == query: return index return -1"},{"question":"Count the Number of Digits You are given an integer `n` which can be positive, negative, or zero. Your task is to write a Python function that computes and returns the number of digits in `n`. # Function Signature ```python def num_digits(n: int) -> int: ``` # Input * A single integer `n`. # Output * An integer representing the number of digits in `n`. # Constraints * The integer `n` can be in the range of `[-10^8, 10^8]`. # Examples ```python assert num_digits(12345) == 5 assert num_digits(-987) == 3 assert num_digits(0) == 1 assert num_digits(100000000) == 9 ``` # Task Requirements 1. **Efficiency**: The solution should run in O(1) time. 2. **Edge Case Handling**: Properly handle cases where `n` is zero or negative. # Hints * Use mathematical properties to compute the number of digits efficiently. * Consider edge cases like zero and negative numbers.","solution":"def num_digits(n: int) -> int: Returns the number of digits in the integer n. if n == 0: return 1 return len(str(abs(n)))"},{"question":"# Topological Sorting Problem Context A software project is represented as a series of tasks with dependencies. Each task must be completed before the tasks dependent on it can start. This forms a Directed Acyclic Graph (DAG), with tasks as nodes and dependencies as edges. To plan the project, you need to determine a valid order to complete the tasks ensuring all dependencies are met. Problem Statement Implement the function `find_task_ordering(graph: Dict[int, List[int]]) -> List[int]:` that returns a valid topological ordering of tasks represented by the input graph. Input - `graph`: A dictionary where: - Each key is an integer representing a task. - Each value is a list of integers representing tasks dependent on the key task. Output - A list of integers representing a valid topological ordering of the tasks. Constraints - If the graph contains a cycle, the function should raise a `ValueError` with the message \\"cycle\\". - The graph contains at least one task (node) and each task is identified by a unique integer. - Some nodes may not have any dependencies. # Expected Performance - Time Complexity: O(V + E) - Space Complexity: O(V) Example ```python graph = { 1: [2, 3], 2: [4], 3: [4], 4: [] } # This can have multiple valid outputs like [1, 2, 3, 4] or [1, 3, 2, 4] assert find_task_ordering(graph) in [[1, 2, 3, 4], [1, 3, 2, 4]] ```","solution":"from collections import deque def find_task_ordering(graph): Returns a valid topological ordering of tasks from the input graph. If the graph contains a cycle, raises ValueError(\\"cycle\\"). indegree = {u: 0 for u in graph} for u in graph: for v in graph[u]: indegree[v] += 1 queue = deque([u for u in graph if indegree[u] == 0]) topo_order = [] while queue: u = queue.popleft() topo_order.append(u) for v in graph[u]: indegree[v] -= 1 if indegree[v] == 0: queue.append(v) if len(topo_order) == len(graph): return topo_order else: raise ValueError(\\"cycle\\")"},{"question":"# Scenario You are working on a new feature in a tree visualization tool. The feature must flip a given binary tree horizontally. This is an essential upgrade as it helps users view the tree structure from a different perspective, thus enhancing the understanding and debugging capabilities of your tool. # Problem Statement Implement a function `invert_tree(root)` that takes the root of a binary tree and inverts the tree horizontally. Essentially, each left and right child of every node in the tree must be swapped recursively. # Input Format * A binary tree represented by its root node. The tree node has the following structure: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` # Output Format * The function should modify the tree in place and return the root of the inverted binary tree. # Constraints * The number of nodes in the tree is in the range [0, 1000]. * The tree\'s depth will not exceed 1000. * The value of each node is an integer. # Function Signature ```python def invert_tree(root: TreeNode) -> TreeNode: # Your implementation here ``` # Example ```python # Example binary tree: # 4 # / # 2 7 # / / # 1 3 6 9 # After inverting, it should become: # 4 # / # 7 2 # / / # 9 6 3 1 root = TreeNode(4, TreeNode(2, TreeNode(1), TreeNode(3)), TreeNode(7, TreeNode(6), TreeNode(9))) inverted_root = invert_tree(root) # The structure of inverted_root should now be the inverted tree as described. ``` # Notes * Ensure your implementation correctly handles edge cases, including an empty tree or trees with single nodes. * Pay attention to the algorithm\'s depth to avoid stack overflow on very deep trees. * Consider additional optimizations for handling deep trees, if needed.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def invert_tree(root: TreeNode) -> TreeNode: if root is None: return None # Swap the left and right children root.left, root.right = root.right, root.left # Recursively invert the left and right subtrees invert_tree(root.left) invert_tree(root.right) return root"},{"question":"You are tasked with developing an algorithm to find the number of ways to decompose a given positive integer `decompose` into sums of non-negative integers. Each decomposition represents a different combination of values equalling `decompose`. # Function Signature ```python def int_divide(decompose: int) -> int: ``` # Input - `decompose`: A positive integer (1 <= decompose <= 100) # Output - Returns an integer representing the number of unique ways to decompose the integer `decompose`. # Constraints - The input will always be a positive integer within the specified range. - The function should have a time and space complexity of O(n^2). # Examples 1. **Example 1**: - Input: `4` - Output: `5` - Explanation: ```plaintext 4 can be decomposed as: 4 3+1 2+2 2+1+1 1+1+1+1 Total: 5 ways ``` 2. **Example 2**: - Input: `7` - Output: `15` - Explanation: ```plaintext 7 can be decomposed as: 7 6+1 5+2 5+1+1 4+3 4+2+1 4+1+1+1 3+3+1 3+2+2 3+2+1+1 3+1+1+1+1 2+2+2+1 2+2+1+1+1 2+1+1+1+1+1 1+1+1+1+1+1+1 Total: 15 ways ``` # Case Analysis Consider the following edge cases: - **Minimum Edge Case**: - Input: `1` - Output: `1` - **Small Number Decompositions**: - Check for `decompose = 2, 3, 4` to ensure correctness for small inputs.","solution":"def int_divide(decompose: int) -> int: Returns the number of ways to decompose the integer `decompose` into sums of non-negative integers. # We will use dynamic programming to solve this problem. # dp[i][j] will store the number of ways to get the sum i using integers up to j. dp = [[0] * (decompose + 1) for _ in range(decompose + 1)] # There is one way to make zero with zero integers (by using no integers at all) for i in range(decompose + 1): dp[0][i] = 1 # Iterate over all the sum values for i in range(1, decompose + 1): # Iterate over all integers up to decompose for j in range(1, decompose + 1): dp[i][j] = dp[i][j-1] # number of ways to make sum i without using j if i >= j: dp[i][j] += dp[i-j][j] # number of ways to make sum i by using j return dp[decompose][decompose]"},{"question":"# Intersection Node in Linked Lists **Objective**: Write a function that finds the intersection node between two singly linked lists. # Input - Two linked lists represented by their head nodes: `head1` and `head2`. # Output - The first intersecting node, or `null` if there is no intersection. # Constraints - Do not modify the linked lists. - Nodes are compared by reference, not by value. - List nodes are defined classically with an integer value and a pointer to the next node. # Function Signature ```python def find_intersection(head1, head2): ``` # Example Consider the linked lists: * List1: 1 -> 3 -> 5 7 -> 9 -> 11 / * List2: 2 -> 4 -> 6 Input: ```plaintext head1 = 1 -> 3 -> 5 -> 7 -> 9 -> 11 head2 = 2 -> 4 -> 6 -> 7 -> 9 -> 11 ``` Output: ```plaintext Intersection Node: 7 ``` # Explanation The linked lists intersect at node with value 7. Your function should return this node. # Edge Cases - One or both lists are empty. - Lists do not intersect at any point. # Test Cases 1. **Basic case with intersection**: - Input: `(List1, List2)` - Output: `7` 2. **Lists with no intersection**: - Input: `(List1, List3)` - Output: `null` 3. **One of the lists is empty**: - Input: `(List1, None)` - Output: `null` # Implementation Example ```python class Node: def __init__(self, val=None): self.val = val self.next = None def find_intersection(head1, head2): # Your implementation here pass # Example test scenarios (verify against expected output) def test_find_intersection(): a1 = Node(1) b1 = Node(3) c1 = Node(5) d = Node(7) e = Node(9) f = Node(11) a2 = Node(2) b2 = Node(4) c2 = Node(6) a1.next = b1 b1.next = c1 c1.next = d d.next = e e.next = f a2.next = b2 b2.next = c2 c2.next = d assert find_intersection(a1, a2) == d test_find_intersection() ```","solution":"class Node: def __init__(self, val=None): self.val = val self.next = None def find_intersection(head1, head2): if head1 is None or head2 is None: return None # Calculate lengths of both linked lists def get_length(head): length = 0 current = head while current: length += 1 current = current.next return length len1 = get_length(head1) len2 = get_length(head2) # Align both lists at the start of intersection current1, current2 = head1, head2 if len1 > len2: for _ in range(len1 - len2): current1 = current1.next elif len2 > len1: for _ in range(len2 - len1): current2 = current2.next # Find the intersection node while current1 and current2: if current1 == current2: return current1 current1 = current1.next current2 = current2.next return None"},{"question":"# Question You are a developer working on a web application that processes user-submitted links for tracking and analysis. Often, these links contain redundant query parameters or parameters that are unnecessary for your processing needs. Your task is to write a function that cleanly and efficiently processes these URLs. Requirements Write a function `process_url(url: str, params_to_strip: List[str] = []) -> str` that performs the following tasks: 1. Removes any duplicate query string parameters, keeping the first occurrence. 2. Removes any query string parameters specified in the `params_to_strip` list. Input - `url` (str): The URL to be processed. - `params_to_strip` (List[str]): An optional list of query parameter names to be removed from the URL. Output - Returns a string representing the processed URL. Constraints - If the URL does not contain a query string, it should be returned unchanged. - If no `params_to_strip` are provided, only duplicate parameters should be removed. - Ensure the function is efficient and can handle URLs with a large number of query parameters. Examples ```python assert process_url(\\"www.example.com?a=1&b=2&a=2\\") == \\"www.example.com?a=1&b=2\\" assert process_url(\\"www.example.com?a=1&b=2&a=2\\", [\\"a\\"]) == \\"www.example.com?b=2\\" assert process_url(\\"www.example.com\\", [\\"a\\"]) == \\"www.example.com\\" assert process_url(\\"www.example.com?a=1&b=2&c=3\\", [\\"b\\", \\"c\\"]) == \\"www.example.com?a=1\\" ``` Notes * You may assume the URL string is well-formed. * You may use libraries such as `urllib` for parsing and constructing URLs.","solution":"from typing import List from urllib.parse import urlencode, urlparse, urlunparse, parse_qsl def process_url(url: str, params_to_strip: List[str] = []) -> str: Processes the URL to remove duplicate query parameters and specified parameters to strip. Args: url (str): The URL to be processed. params_to_strip (List[str]): List of query parameters to remove. Returns: str: The processed URL. parsed_url = urlparse(url) query_params = parse_qsl(parsed_url.query, keep_blank_values=True) seen_params = set() filtered_params = [] for key, value in query_params: if key not in seen_params and key not in params_to_strip: filtered_params.append((key, value)) seen_params.add(key) new_query_string = urlencode(filtered_params) new_url = urlunparse(parsed_url._replace(query=new_query_string)) return new_url"},{"question":"# Scenario You are creating a library to help manage an organization\'s resource allocation hierarchy. Each resource is allocated to different individuals, with each allocation characterized by specific resources and quantities. You are tasked to build a utility function that processes and displays this allocation hierarchy in a readable format. # Problem Statement Write a function `print_resource_allocation` that formats and prints a nested dictionary representing resource allocations. The input dictionary\'s structure is as follows: * Top-level keys are arbitrary identifiers (e.g., single letters). * Each top-level key maps to a list of allocations. * An allocation is structured as a sequence of elements where: - First element: Individual\'s name (string). - Following elements: Alternating resource type (string) and quantity (integer). Your function should format the output to display this hierarchy clearly. The printed format should be consistent with the example provided below. # Input ```python allocations = { \\"a\\": [\\"Adam\\", \\"Book\\", 4], \\"b\\": [\\"Bill\\", \\"Computer\\", 5, \\"TV\\", 6, \\"Jill\\", \\"Sports\\", 1], \\"c\\": [\\"Bill\\", \\"Sports\\", 3], \\"d\\": [\\"Adam\\", \\"Computer\\", 3, \\"Quin\\", \\"Computer\\", 3], \\"e\\": [\\"Quin\\", \\"Book\\", 5, \\"TV\\", 2], \\"f\\": [\\"Adam\\", \\"Computer\\", 7] } ``` # Expected Output ``` a -> Adam -> Book -> 4 b -> Bill -> Computer -> 5 -> TV -> 6 -> Jill -> Sports -> 1 c -> Bill -> Sports -> 3 d -> Adam -> Computer -> 3 -> Quin -> Computer -> 3 e -> Quin -> Book -> 5 -> TV -> 2 f -> Adam -> Computer -> 7 ``` # Constraints * The input dictionary can have a maximum of 1000 keys. * Each list associated with a key can have up to 20 elements. # Function Signature ```python def print_resource_allocation(allocations: dict) -> None: pass ``` # Requirements * Handle nested resource entries. * Avoid redundant lookups and ensure efficient traversal. * Print the hierarchy in the specified format.","solution":"def print_resource_allocation(allocations): Formats and prints the resource allocation hierarchy. Parameters: allocations (dict): A dictionary representing resource allocations. for key, values in allocations.items(): output = f\\"{key} -> {values[0]}\\" i = 1 while i < len(values): if isinstance(values[i], str) and isinstance(values[i + 1], int): output += f\\" -> {values[i]} -> {values[i + 1]}\\" i += 2 elif isinstance(values[i], str): print(output) output = \\" -> \\" + values[i] i += 1 print(output)"},{"question":"You have been hired to enhance the security protocol of a messaging service by implementing a robust encryption system. Your task is to implement functions to generate RSA keys and use them for encrypting and decrypting messages. RSA (Rivest-Shamir-Adleman) is an asymmetric cryptographic algorithm that relies on generating a pair of keys – a public key for encryption and a private key for decryption. # Function Specifications: 1. **`generate_key(k)`** - **Input**: - `k` (int): The number of bits in the modulus `n` (for key generation). - **Output**: - A tuple `(n, e, d)` where: - `n` (int): The modulus. - `e` (int): The public exponent. - `d` (int): The private exponent. 2. **`encrypt(data, e, n)`** - **Input**: - `data` (int): The plaintext message to be encrypted. - `e` (int): The public exponent. - `n` (int): The modulus. - **Output**: - An integer representing the encrypted message. 3. **`decrypt(data, d, n)`** - **Input**: - `data` (int): The encrypted message. - `d` (int): The private exponent. - `n` (int): The modulus. - **Output**: - An integer representing the decrypted plaintext message. # Requirements: 1. Use the principles of the RSA algorithm to implement the `generate_key`, `encrypt`, and `decrypt` functions based on the provided specifications. 2. Handle edge cases such as generating distinct primes for `p` and `q` and ensuring `e` is coprime with `λ(n)`. 3. Your solution should efficiently generate primes and compute modular inverses. 4. Ensure that your code adheres to performance requirements by optimizing the expensive operations where possible. # Constraints: - The bit length `k` for the modulus `n` will be in the range `[16, 1024]`. - The decrypted message should match the original message for validation. # Example Usage: ```python n, e, d = generate_key(16) data = 42 encrypted = encrypt(data, e, n) decrypted = decrypt(encrypted, d, n) assert decrypted == data ```","solution":"import random from sympy import isprime, mod_inverse, gcd def generate_prime_candidate(length): Generate an odd integer randomly. p = random.getrandbits(length) # apply a mask to set MSB and LSB to 1 p |= (1 << length - 1) | 1 return p def generate_prime_number(length=1024): Generate a prime number of specified bit length. p = 4 # keep generating while the primality test fail while not isprime(p): p = generate_prime_candidate(length) return p def generate_key(k): Generate RSA keys of bit-length k. # Generate two distinct prime numbers p and q bit_length = k // 2 p = generate_prime_number(bit_length) q = generate_prime_number(bit_length) while p == q: q = generate_prime_number(bit_length) n = p * q # Euler\'s totient function φ(n) = (p-1)*(q-1) phi = (p - 1) * (q - 1) # Choose e such that 1 < e < φ(n) and gcd(e, φ(n)) = 1 e = 65537 # Common choice for e if gcd(e, phi) != 1: # If 65537 doesn\'t work, pick another prime that is coprime with φ(n) e = 3 while gcd(e, phi) != 1: e += 2 # Compute d, the modular inverse of e mod φ(n) d = mod_inverse(e, phi) return (n, e, d) def encrypt(data, e, n): Encrypt data using RSA encryption. return pow(data, e, n) def decrypt(data, d, n): Decrypt data using RSA decryption. return pow(data, d, n)"},{"question":"# Hash Table Optimization and Performance You are given an implementation of a Hash Table with resizing capabilities. Your task is to enhance this implementation by adding a performance tracking mechanism to monitor and limit the average time complexity of operations. # Requirements 1. **Tracking Operations**: Implement a mechanism that tracks the number of probes required for each operation (put, get, and delete). 2. **Threshold Exceed**: If the average number of probes exceeds a certain threshold (e.g., 5 probes on average), resize the hash table to half the current load factor size and rehash the elements. 3. **No loss in existing functionalities**: Ensure that the functionalities of the original hash table are retained, including resizing when load factor crosses 2/3. # Function Signature ```python class PerformanceHashTable(ResizableHashTable): def put(self, key, value): # Your code here def get(self, key): # Your code here def del_(self, key): # Your code here ``` # Input & Output Format - **Input**: None directly; functions will be called on instances of `PerformanceHashTable`. - **Output**: None directly; but methods should perform as described and maintain correct key-value storage. # Constraints - The initial size of *PerformanceHashTable* remains the same as in the parent class. - The resize when exceeding probe threshold should be implemented efficiently. - Ensure that methods operate within the expected average time complexity by tracking and regulating probes. # Scenario Consider a situation where your hash table is subject to high load and experiencing many collisions. By tracking the performance and managing the load dynamically, you ensure that operations remain efficient. # Example Here\'s an illustration: ```python hash_table = PerformanceHashTable() hash_table.put(1, \'one\') hash_table.put(12, \'twelve\') # Assuming hash collision here print(hash_table.get(1)) # \'one\' print(hash_table.get(12)) # \'twelve\' hash_table.del_(1) print(hash_table.get(1)) # None # Throughout these operations, the average number of probes should be tracked and regulated. ``` Your task is to implement the `PerformanceHashTable` class with the described additional functionality.","solution":"class ResizableHashTable: def __init__(self): self.size = 8 self.load_factor_threshold = 2 / 3 self.table = [None] * self.size self.num_elements = 0 def hash(self, key): return hash(key) % self.size def put(self, key, value): if self.num_elements / self.size > self.load_factor_threshold: self.resize() idx = self.hash(key) initial_idx = idx while self.table[idx] is not None: if self.table[idx][0] == key: self.table[idx] = (key, value) return idx = (idx + 1) % self.size self.table[idx] = (key, value) self.num_elements += 1 def get(self, key): idx = self.hash(key) initial_idx = idx while self.table[idx] is not None: if self.table[idx][0] == key: return self.table[idx][1] idx = (idx + 1) % self.size return None def del_(self, key): idx = self.hash(key) initial_idx = idx while self.table[idx] is not None: if self.table[idx][0] == key: self.table[idx] = None self.num_elements -= 1 return idx = (idx + 1) % self.size def resize(self): old_table = self.table self.size *= 2 self.table = [None] * self.size self.num_elements = 0 for item in old_table: if item is not None: self.put(item[0], item[1]) class PerformanceHashTable(ResizableHashTable): def __init__(self): super().__init__() self.probes = 0 self.operations = 0 self.probe_threshold = 5 def put(self, key, value): self.operations += 1 probes = 0 if self.num_elements / self.size > self.load_factor_threshold: self.resize() idx = self.hash(key) initial_idx = idx while self.table[idx] is not None: probes += 1 if self.table[idx][0] == key: self.table[idx] = (key, value) self.probes += probes self.check_and_resize() return idx = (idx + 1) % self.size self.table[idx] = (key, value) self.num_elements += 1 self.probes += probes self.check_and_resize() def get(self, key): self.operations += 1 probes = 0 idx = self.hash(key) while self.table[idx] is not None: probes += 1 if self.table[idx][0] == key: self.probes += probes return self.table[idx][1] idx = (idx + 1) % self.size self.probes += probes return None def del_(self, key): self.operations += 1 probes = 0 idx = self.hash(key) while self.table[idx] is not None: probes += 1 if self.table[idx][0] == key: self.table[idx] = None self.num_elements -= 1 self.probes += probes self.check_and_resize() return idx = (idx + 1) % self.size self.probes += probes self.check_and_resize() def check_and_resize(self): if self.operations > 0 and (self.probes / self.operations) > self.probe_threshold: self.resize_half_load_factor() def resize_half_load_factor(self): old_table = self.table new_size = int(self.num_elements / (0.5)) self.size = new_size self.table = [None] * self.size self.num_elements = 0 for item in old_table: if item is not None: self.put(item[0], item[1])"},{"question":"# Question Context: You are given an array of integers where every integer appears exactly three times, except for one integer which appears only once. Your task is to identify and return that single integer. To add to the challenge, your function should have a linear time complexity and should not use any extra memory (i.e., constant space complexity). Task: Implement the function `find_single_number(nums)` that takes an array of integers, `nums`, and returns the integer that appears only once. Input: - A list of integers, `nums`, where `1 <= len(nums) <= 3*10^4` and all elements are within the range of a 32-bit signed integer. Output: - Return an integer, the single number. Constraints: - You must achieve O(n) time complexity. - You must achieve O(1) space complexity. Example: Input: `nums = [2, 2, 3, 2]` Output: `3` Input: `nums = [0, 1, 0, 1, 0, 1, 99]` Output: `99`","solution":"def find_single_number(nums): Find the single number that appears only once in the array where every other number appears exactly three times. The implementation uses bitwise operations and ensures constant space complexity. one, two = 0, 0 for num in nums: one = (one ^ num) & ~two two = (two ^ num) & ~one return one"},{"question":"# Kruskal\'s Algorithm: Minimum Spanning Tree Construction **Scenario**: You are tasked with designing a software tool to manage the layout of new infrastructure for a city\'s electrical grid system. The goal is to ensure that the entire city is power-connected in an optimal way to minimize the total cost of constructing the power lines. **Problem Statement**: Given a list of weighted edges representing the costs to lay power lines between various city points, write a function to compute the Minimum Spanning Tree (MST) using Kruskal\'s algorithm and return the sum of the weights of the MST. **Function Signature**: ```python def compute_mst(vertex_count: int, edges: List[Tuple[int, int, int]]) -> int: pass ``` **Input**: - `vertex_count`: An integer `V` representing the number of vertices (city points). - `edges`: A list of tuples `(u, v, w)` where each tuple represents an edge between vertex `u` and vertex `v` with weight `w`. **Output**: - The sum of weights of the MST. **Constraints**: - `1 <= vertex_count <= 1000` - `0 <= len(edges) <= 10000` - `1 <= w <= 10000` **Requirements**: - Use Kruskal\'s algorithm. - Implement the Disjoint Set data structure with path compression and union by rank to optimize `find` and `union` operations. **Example**: ```python vertex_count = 5 edges = [(1, 2, 3), (1, 3, 8), (2, 4, 5), (3, 4, 2), (3, 5, 4), (4, 5, 6)] print(compute_mst(vertex_count, edges)) # Output: 14 ``` **Explanation**: In the given example, the MST will include the edges with weights: 3, 5, 2, and 4, forming a tree with a total weight of 14. **Notes**: - Ensure that your implementation efficiently handles the given constraints. - Discuss any assumptions you make and how you handle potential edge cases in your implementation.","solution":"from typing import List, Tuple class DisjointSet: def __init__(self, n): self.parent = list(range(n)) self.rank = [0] * n def find(self, u): if self.parent[u] != u: self.parent[u] = self.find(self.parent[u]) return self.parent[u] def union(self, u, v): root_u = self.find(u) root_v = self.find(v) if root_u != root_v: if self.rank[root_u] > self.rank[root_v]: self.parent[root_v] = root_u elif self.rank[root_u] < self.rank[root_v]: self.parent[root_u] = root_v else: self.parent[root_v] = root_u self.rank[root_u] += 1 def compute_mst(vertex_count: int, edges: List[Tuple[int, int, int]]) -> int: # Step 1: Sort all the edges in non-decreasing order of their weight. edges.sort(key=lambda x: x[2]) # Step 2: Create a disjoint set for keeping track of the connected components ds = DisjointSet(vertex_count) mst_weight = 0 mst_edges = [] # Step 3: Process the edges in sorted order for u, v, w in edges: if ds.find(u - 1) != ds.find(v - 1): # u and v are given in 1-based, convert to 0-based ds.union(u - 1, v - 1) mst_weight += w mst_edges.append((u, v, w)) # Optionally check if we have enough edges for MST (vertex_count - 1 edges) if len(mst_edges) == vertex_count - 1: break return mst_weight"},{"question":"You are provided with an implementation of cocktail shaker sort, which sorts a given array in ascending order. This sort is a bidirectional version of the bubble sort algorithm. It processes the array in two phases during each iteration: a left-to-right pass and a right-to-left pass. Your task is to enhance this implementation. # Requirements 1. **Enhance** the existing `cocktail_shaker_sort` function to be more efficient by adding an early termination mechanism to handle cases where the list gets sorted before completing all passes. 2. **Identify and handle edge cases** effectively, including lists of varying lengths and already sorted lists. # Input * A list of integers, `arr`. # Output * A list of integers sorted in ascending order. # Constraints * The input list length, `0 <= len(arr) <= 10^5`. * The list may contain negative numbers. # Example 1. Input: `[3, 0, 2, 5, -1, 4, 1]` Output: `[-1, 0, 1, 2, 3, 4, 5]` 2. Input: `[5, 1, 4, 2, 8, 0, 2]` Output: `[0, 1, 2, 2, 4, 5, 8]` # Performance Your solution should handle lists with up to 100,000 elements efficiently. # Function Signature ```python def enhanced_cocktail_shaker_sort(arr: list) -> list: pass ```","solution":"def enhanced_cocktail_shaker_sort(arr): Sorts the given list using the cocktail shaker sort algorithm with early termination. Parameters: arr (list): The list of integers to be sorted. Returns: list: The sorted list in ascending order. n = len(arr) if n <= 1: return arr # already sorted if single element or empty start = 0 end = n - 1 while start < end: swapped = False # Forward pass for i in range(start, end): if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] swapped = True if not swapped: break # Updating the end point as the largest element in the current pass is at correct position end -= 1 swapped = False # Backward pass for i in range(end, start, -1): if arr[i] < arr[i - 1]: arr[i], arr[i - 1] = arr[i - 1], arr[i] swapped = True if not swapped: break # Updating the start point as the smallest element in the current pass is at correct position start += 1 return arr"},{"question":"You are tasked with writing a function to perform regular expression matching with support for the characters `.` and `*`. The matching should cover the entire input string (not partial matches). The function `is_match(s: str, p: str) -> bool` takes two input arguments: - `s`: the input string containing only lowercase letters. - `p`: the pattern string containing only lowercase letters, `.` and/or `*`. Function Signature ```python def is_match(s: str, p: str) -> bool: # Your code here ``` # Functionality 1. `.` matches any single character. 2. `*` matches zero or more of the preceding element. # Input and Output Examples 1. `is_match(\\"aa\\", \\"a\\")` ➞ `False` Explanation: \\"a\\" does not match the entire string \\"aa\\". 2. `is_match(\\"aa\\", \\"aa\\")` ➞ `True` Explanation: \\"aa\\" matches the entire string \\"aa\\". 3. `is_match(\\"aaa\\", \\"aa\\")` ➞ `False` Explanation: \\"aa\\" does not match the entire string \\"aaa\\". 4. `is_match(\\"aa\\", \\"a*\\")` ➞ `True` Explanation: \'*\' means zero or more of the preceding element, \'a\'. Therefore, \\"a*\\" matches \\"aa\\". 5. `is_match(\\"aa\\", \\".*\\")` ➞ `True` Explanation: \\".*\\" means \\"any character (.) repeated zero or more times (*)\\". Therefore, \\".*\\" matches \\"aa\\". 6. `is_match(\\"ab\\", \\".*\\")` ➞ `True` Explanation: \\".*\\" means \\"any character (.) repeated zero or more times (*)\\". Therefore, \\".*\\" matches \\"ab\\". 7. `is_match(\\"aab\\", \\"c*a*b\\")` ➞ `True` Explanation: \'c*\' can be considered zero \'c\'s, and \'a*\' matches \'aa\'. Therefore \\"c*a*b\\" matches \\"aab\\". # Constraints - `0 <= len(s) <= 1000` - `0 <= len(p) <= 1000` - Each character in `s` is a lowercase English letter. - Each character in `p` is either a lowercase English letter, `.` or `*`.","solution":"def is_match(s: str, p: str) -> bool: Checks if the input string `s` matches the pattern `p`. # dp[i][j] will be True if the first i characters in s can match # the first j characters in p dp = [[False] * (len(p) + 1) for _ in range(len(s) + 1)] # Base case: empty string matches empty pattern dp[0][0] = True # Handle patterns like a* or a*b* or a*b*c* which can match empty string for j in range(1, len(p) + 1): if p[j - 1] == \'*\': dp[0][j] = dp[0][j - 2] for i in range(1, len(s) + 1): for j in range(1, len(p) + 1): if p[j - 1] == \'.\' or p[j - 1] == s[i - 1]: dp[i][j] = dp[i - 1][j - 1] elif p[j - 1] == \'*\': dp[i][j] = dp[i][j - 2] or (dp[i - 1][j] and (p[j - 2] == s[i - 1] or p[j - 2] == \'.\')) return dp[len(s)][len(p)]"},{"question":"Imagine you are a software engineer working on a system that analyzes transportation routes. For this system, you need to determine if there is a valid route between two cities represented as nodes in a directed graph. Implement a function that will check if a path exists between two given nodes. Function Signature: ```python def is_route_between_nodes(vertex_count: int, edges: List[Tuple[int, int]], source: int, target: int) -> bool: pass ``` Input: * `vertex_count` (int): The number of vertices (nodes) in the graph. * `edges` (List[Tuple[int, int]]): A list of ordered pairs where each pair (u, v) represents an edge from node u to node v in the directed graph. * `source` (int): The starting node. * `target` (int): The destination node. Output: * `bool`: Return `True` if there is a path from source to target, `False` otherwise. Constraints: * `0 <= vertex_count <= 10^5` * `0 <= number of edges <= 10^6` * `0 <= source, target < vertex_count` Requirements: * Your solution should be efficient in terms of time and space complexity. * Consider edge cases such as no edges, no path between nodes, and graph with cycles. Example: ```python edges = [(0, 1), (1, 2), (2, 3), (4, 5)] print(is_route_between_nodes(6, edges, 0, 3)) # Output: True print(is_route_between_nodes(6, edges, 0, 5)) # Output: False ``` Additional Notes: * You can use an iterative implementation of the depth-first search to avoid potential recursion depth issues. * Be sure to handle cases where the source or target node is not present in the graph.","solution":"from typing import List, Tuple from collections import defaultdict, deque def is_route_between_nodes(vertex_count: int, edges: List[Tuple[int, int]], source: int, target: int) -> bool: Determines if there is a valid route between the source and target nodes in a directed graph. if source == target: return True adjacency_list = defaultdict(list) for u, v in edges: adjacency_list[u].append(v) visited = [False] * vertex_count queue = deque([source]) while queue: current = queue.popleft() if current == target: return True for neighbor in adjacency_list[current]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) return False"},{"question":"**Scenario**: In low-level communication protocols, bit-level manipulation is often required for efficiency. One of the common operations in these protocols is to remove a specific bit from an integer, which may represent a sequence of flags or encoded data. Given this need, you as an engineer have to implement a function that efficiently removes a bit at a specified position from an integer represented in binary form. **Task**: Write a function `remove_bit(num, i)` that takes an integer `num` and an integer `i` as inputs and returns a new integer representing the number with the bit at position `i` removed. **Function Definition**: ```python def remove_bit(num, i): pass ``` **Input**: - `num` (int): A non-negative integer representing the binary number from which to remove the bit. - `i` (int): The zero-based bit position to remove (0 being the least significant bit). **Output**: - Returns an integer representing the binary number after removing the specified bit. **Constraints**: - `0 <= num < 2^31` (e.g., a 32-bit unsigned integer) - `0 <= i < number of bits in num` **Examples**: ```python assert remove_bit(21, 2) == 9 # 10101 -> 1001 assert remove_bit(21, 4) == 5 # 10101 -> 101 assert remove_bit(21, 0) == 10 # 10101 -> 1010 assert remove_bit(0, 0) == 0 # 0 -> remains 0 ``` **Notes**: - Be cautious of edge cases, such as removing the least significant bit (position 0) and when the `num` is a single-bit number. - Consider the implication of removing a bit towards the highest position of the binary representation.","solution":"def remove_bit(num, i): Removes the bit at position i from the binary representation of num. if num == 0: return 0 # Create a mask to remove the bit at position i left_part = num >> (i + 1) << i right_part = num & ((1 << i) - 1) return (left_part | right_part)"},{"question":"Scenario You are a software engineer working on developing software for a railway reservation system. The system needs to calculate the minimum cost to travel from the first station to the last station in a linear pass structure, where the cost of travel between two stations is provided. Task Implement a function `minimum_cost_path(matrix)` that computes the minimum cost to travel from station 0 to station N-1 using dynamic programming principles. The cost between stations is provided as a matrix. Function Signature ```python def minimum_cost_path(matrix: List[List[int]]) -> int: ``` Expected Input and Output - **Input**: - `matrix`: A square list of lists (2D matrix) of size `N x N` where `matrix[i][j]` represents the cost of travelling from station `i` to station `j` (`i < j`). - For invalid routes (where i > j), the value will be -1 or a very large number representing infinity. - **Output**: - Integer value representing the minimum cost to travel from station 0 to station N-1. Example ```python matrix = [ [ 0, 15, 80, 90], [ -1, 0, 40, 50], [ -1, -1, 0, 70], [ -1, -1, -1, 0] ] assert minimum_cost_path(matrix) == 65 Output: 65 ``` Constraints 1. The matrix will have dimensions `N x N` where 2 ≤ N ≤ 100. 2. Costs will be non-negative integers, and invalid routes will be represented by -1 or a large number. Performance Requirements 1. Time complexity should not exceed O(N^2). 2. Space complexity should be O(N).","solution":"from typing import List def minimum_cost_path(matrix: List[List[int]]) -> int: N = len(matrix) INF = float(\'inf\') # Initialize dp array where dp[i] will store minimum cost to reach station i from station 0 dp = [INF] * N dp[0] = 0 # Populate the dp array for i in range(N): for j in range(i + 1, N): if matrix[i][j] != -1: # If there\'s a valid route dp[j] = min(dp[j], dp[i] + matrix[i][j]) return dp[-1]"},{"question":"# Your Task: You are required to write a function that finds numbers within a given range `[low, high]` where the digits of the number when raised to the power of their positions (starting at 1) sum up to the number itself. # Function Signature: ```python def find_special_numbers(low: int, high: int) -> List[int]: pass ``` # Input: * `low` (int): The lower bound of the range. * `high` (int): The upper bound of the range. # Output: * `List[int]`: A list of integers within the range `[low, high]` that satisfy the described property. # Constraints: * `1 <= low <= high <= 5000` * Your function should be efficient enough to handle the upper limit within a reasonable time frame. # Example: ```python assert find_special_numbers(1, 10) == [1, 2, 3, 4, 5, 6, 7, 8, 9] assert find_special_numbers(1, 150) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 89, 135] ``` # Explanation: 1. For example, `89` has digits `8` and `9`. When raised to powers based on their positions this gives: - (8^1 + 9^2 = 8 + 81 = 89). 2. Similarly `135` has digits `1`, `3`, and `5`. - (1^1 + 3^2 + 5^3 = 1 + 9 + 125 = 135). Write your solution below: ```python def find_special_numbers(low, high): result = [] for number in range(low, high + 1): summation = 0 for idx, digit in enumerate(str(number)): summation += int(digit) ** (idx + 1) if summation == number: result.append(number) return result ```","solution":"from typing import List def find_special_numbers(low: int, high: int) -> List[int]: result = [] for number in range(low, high + 1): summation = 0 for idx, digit in enumerate(str(number)): summation += int(digit) ** (idx + 1) if summation == number: result.append(number) return result"},{"question":"Context In a digital security system, ensuring that two binary identifiers match or detecting the number of changes required to make them match is crucial for integrity verification. Your task is to determine the number of bit flips necessary to convert one integer into another. Problem Statement Write a function `count_flips_to_convert(a: int, b: int) -> int` that receives two non-negative integers `a` and `b` as inputs and returns the minimal number of bit flips required to transform the integer `a` to integer `b`. Input - Two non-negative integers `a` and `b` where (0 ≤ a, b < 2^31) Output - An integer representing the minimal number of bit flips required. Constraints - You must use bitwise operations to determine the differences and count the needed flips efficiently. - The solution must run in constant time relative to the number of bits in the integers. Example - Input: `a = 29`, `b = 15` - Binary representation of 29: `11101` - Binary representation of 15: `01111` - Output: `2` - Explanation: Two bits need to be flipped from `11101` to `01111`. Function Signature ```python def count_flips_to_convert(a: int, b: int) -> int: # Your implementation here pass ``` Notes - You can assume the given integers fit within the standard 32-bit signed integer range. - Attention should be given to edge cases such as when one or both integers are zero.","solution":"def count_flips_to_convert(a: int, b: int) -> int: Returns the number of bit flips required to convert integer a to integer b. # XOR the two numbers to find the bits that differ xor_result = a ^ b # Count the number of 1\'s in the binary representation of xor_result count_flips = 0 while xor_result: count_flips += xor_result & 1 xor_result >>= 1 return count_flips"},{"question":"# Exchange All Strings Into Sorted Order **Problem Statement:** You have been given a list of strings. Your task is to implement a function that sorts the strings in ascending lexicographical order using the Exchange Sort algorithm. The function should mimic the structure and process of the given Exchange Sort algorithm. **Function Signature:** ```python def exchange_sort_strings(arr: List[str]) -> List[str]: pass ``` **Input:** * `arr` - A list of strings with a length `n` where `0 <= n <= 10^3`. **Output:** * A list of strings sorted in ascending lexicographical order. **Constraints:** * The list will contain only valid strings (each string comprises only characters from a-z and A-Z). * Sorting should use the Exchange Sort technique. * Aim for O(n²) time complexity and O(1) space complexity. **Examples:** ```python assert exchange_sort_strings([\\"apple\\", \\"banana\\", \\"cherry\\", \\"date\\"]) == [\\"apple\\", \\"banana\\", \\"cherry\\", \\"date\\"] assert exchange_sort_strings([\\"zebra\\", \\"apple\\", \\"mango\\", \\"banana\\"]) == [\\"apple\\", \\"banana\\", \\"mango\\", \\"zebra\\"] assert exchange_sort_strings([\\"a\\"]) == [\\"a\\"] assert exchange_sort_strings([]) == [] assert exchange_sort_strings([\\"same\\", \\"word\\", \\"same\\"]) == [\\"same\\", \\"same\\", \\"word\\"] ``` **Detailed Requirements:** 1. **Sorting Lexicographically**: The strings should be sorted in a manner similar to dictionary order. 2. **Case Sensitivity**: The sort should be case-sensitive. (e.g., `\\"A\\"` comes before `\\"a\\"`). 3. **Edge Cases**: Handle lists with duplicate strings, single-element lists, and empty lists correctly. **Notes:** * The provided template should be used to ensure your function matches the expected signature. * Your implementation should be thorough and handle all specified edge cases effectively.","solution":"from typing import List def exchange_sort_strings(arr: List[str]) -> List[str]: Sorts the list of strings in ascending lexicographical order using the Exchange Sort algorithm. Parameters: arr (List[str]): A list of strings to be sorted. Returns: List[str]: The list of strings sorted in ascending lexicographical order. n = len(arr) for i in range(n): for j in range(i + 1, n): if arr[i] > arr[j]: # Swap arr[i] and arr[j] arr[i], arr[j] = arr[j], arr[i] return arr"},{"question":"# Question: Implement the Function to Sort an Array Using Iterative Quick Sort Context: You are tasked with implementing a more efficient sorting algorithm to handle larger datasets more efficiently than Exchange Sort. Quick Sort offers better average-case performance with O(n log n) time complexity. Given the random and recursive nature, implementing an iterative version of Quick Sort can prevent stack overflow for very large arrays. Task: Write a Python function called `iterative_quick_sort` which takes an array of integers and sorts it in ascending order using the Iterative Quick Sort algorithm. Requirements: * Your function should not use recursion. * You must use a stack data structure to mimic the recursive calls of the Quick Sort algorithm. * Implement the partitioning logic and ensure it is applied correctly in the iterative logic. Input: * `arr`: A list of integers (e.g., `[34, 7, 23, 32, 5, 62]`). Output: * Return the sorted list of integers. Constraints: * The input array can have up to 10^5 elements. * Each element in the array is in the range of -10^9 to 10^9. Example: ```python def iterative_quick_sort(arr): # Your implementation here # Examples print(iterative_quick_sort([34, 7, 23, 32, 5, 62])) # Output: [5, 7, 23, 32, 34, 62] print(iterative_quick_sort([-3, 10, 0, -1, 5, 7])) # Output: [-3, -1, 0, 5, 7, 10] ``` **Performance Requirements:** - The implemented function should sort arrays efficiently, even for the upper size limit. Notes: - Ensure edge cases like empty arrays, arrays with one element, and arrays with repeated elements are handled. - Carefully manage the stack to avoid any overflow or memory issues.","solution":"def iterative_quick_sort(arr): Sorts the array using the iterative version of Quick Sort. if len(arr) == 0: return arr stack = [(0, len(arr) - 1)] while stack: low, high = stack.pop() if low < high: pivot_index = partition(arr, low, high) stack.append((low, pivot_index - 1)) stack.append((pivot_index + 1, high)) return arr def partition(arr, low, high): pivot = arr[high] i = low - 1 for j in range(low, high): if arr[j] <= pivot: i += 1 arr[i], arr[j] = arr[j], arr[i] arr[i + 1], arr[high] = arr[high], arr[i + 1] return i + 1"},{"question":"Context You are tasked with identifying a special type of numbers within a specified range. These numbers have the property where the sum of their digits, when raised to consecutive powers starting from 1, equals the number itself. The number 89 is a notable example since ( 89 = 8^1 + 9^2 ). This algorithm has applications in number theory, mathematical puzzles, and teaching algorithms involving digit manipulation and exponentiation. Task Implement the function `sum_dig_pow(low, high)` that returns a list of all numbers in the range `[low, high]` (both inclusive) that satisfy the special property. Function Signature ```python def sum_dig_pow(low: int, high: int) -> list: pass ``` Input and Output Formats * **Input**: Two integers `low` and `high` where (1 leq low leq high). * **Output**: A list of integers within the range that satisfy the described property. Constraints 1. ( 1 leq low leq high ) 2. ( low ) and ( high ) are integers within reasonable computational limits in a typical coding environment (e.g., up to 10,000). Requirements * Ensure the function runs efficiently for input ranges up to 10,000. * Handle edge cases where no numbers in the range satisfy the property. Examples ```python assert sum_dig_pow(1, 10) == [1, 2, 3, 4, 5, 6, 7, 8, 9] assert sum_dig_pow(1, 100) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 89] assert sum_dig_pow(50, 150) == [89, 135] assert sum_dig_pow(10, 80) == [] ``` Ensure you consider the efficiency and clarity of your code, including handling potential edge cases effectively.","solution":"def sum_dig_pow(low: int, high: int) -> list: def is_eureka_number(n): digits = [int(d) for d in str(n)] return n == sum(digit ** (index + 1) for index, digit in enumerate(digits)) result = [] for number in range(low, high + 1): if is_eureka_number(number): result.append(number) return result"},{"question":"# Scenario: You\'ve been hired to develop a program that can efficiently merge daily stock price lists from two different sources into a single sorted linked list. Both sources provide their data as sorted linked lists. It is essential for your program to maintain the order without using extra space significantly. # Task: Implement a function that will take two sorted linked lists and merge them into one sorted linked list. # Function Signature: ```python class Node: def __init__(self, x): self.val = x self.next = None def merge_two_sorted_lists(l1: Node, l2: Node) -> Node: pass ``` # Input: - Two input arguments, `l1` and `l2`, are the head nodes of two sorted linked lists. # Output: - The function should return the head node of the merged sorted linked list. # Constraints: - Each linked list element will be of type integer. - The maximum number of elements in each list is 10^4. - The elements in each linked list are sorted in non-decreasing order. # Example: ```plaintext Given the linked lists: l1: 1 -> 2 -> 4 l2: 1 -> 3 -> 4 The function should return: 1 -> 1 -> 2 -> 3 -> 4 -> 4 ``` # Additional Notes: - You should aim for O(n + m) time complexity. - Optimization for minimal space usage is a priority; aim for O(1) additional space if using the iterative approach. - Ensure to handle edge cases like one of the lists being empty or both being empty. # Evaluation Criteria: - Correctness: The output linked list must be correctly sorted and contain all elements from both input lists. - Efficiency: The solution should run within the specified time and space complexity constraints. - Edge Cases: Proper handling of special conditions like empty input lists.","solution":"class Node: def __init__(self, x): self.val = x self.next = None def merge_two_sorted_lists(l1: Node, l2: Node) -> Node: # Create a dummy node to simplify the merge process dummy = Node(0) current = dummy # Merge the two lists while both `l1` and `l2` are not empty while l1 and l2: if l1.val < l2.val: current.next = l1 l1 = l1.next else: current.next = l2 l2 = l2.next current = current.next # Attach the remaining part of the list that is not yet exhausted if l1: current.next = l1 if l2: current.next = l2 # Return the merged list, skipping the dummy node return dummy.next"},{"question":"# Maximum Subarray Problem (Kadane\'s Algorithm) Background You are given a list of integers representing daily stock prices. You aim to identify the maximum possible profit from a single continuous period of buying and selling. The profit is calculated by finding a contiguous subarray (any length) that has the greatest sum. Task Implement a function `max_contiguous_subsequence_sum(arr)` that computes the highest sum of any contiguous subsequence in the given list of integers. This is a common interview problem for demonstrating proficiency in dynamic programming and greedy algorithms. Function Signature ```python def max_contiguous_subsequence_sum(arr: List[int]) -> int: ``` Input * A list of integers `arr` where each integer can be positive, negative, or zero. Output * An integer representing the maximum sum of a contiguous subsequence. Constraints * The length of `arr` does not exceed (10^5). * The elements of `arr` range from (-10^4) to (10^4). Examples ```python # Example 1 arr = [-2, 3, 8, -1, 4] # max contiguous subsequence sum: 3 + 8 - 1 + 4 = 14 assert(max_contiguous_subsequence_sum(arr) == 14) # Example 2 arr = [-1, 1, 0] # max contiguous subsequence sum: 1 assert(max_contiguous_subsequence_sum(arr) == 1) # Example 3 arr = [-1, -3, -4] # max contiguous subsequence sum: -1 (the smallest negative value) assert(max_contiguous_subsequence_sum(arr) == -1) # Example 4 arr = [1, 2, 3, 4, 5] # max contiguous subsequence sum: 1 + 2 + 3 + 4 + 5 = 15 assert(max_contiguous_subsequence_sum(arr) == 15) # Example 5 arr = [] # max contiguous subsequence sum: 0 (by definition for an empty array) assert(max_contiguous_subsequence_sum(arr) == 0) ``` Edge Cases to Consider * Ensure the function handles an empty array. * Ensure the function can process arrays with all negative numbers correctly.","solution":"def max_contiguous_subsequence_sum(arr): Finds the maximum sum of a contiguous subarray in the given list of integers. Parameters: arr (List[int]): A list of integers which can have positive, negative, or zero elements. Returns: int: The maximum sum of any contiguous subarray. if not arr: return 0 max_sum = current_sum = arr[0] for num in arr[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"**Q1: Unique Character String Generator** You have been tasked with creating a function that processes a given string to remove any recurring characters. The function should return a new string that includes only the first occurrence of each character from the original string and maintains the order of their first appearance. # Example Scenarios Let\'s consider the following examples: * For the input string `\\"google\\"`, the function should return the string `\\"gole\\"`. * For the input string `\\"programming\\"`, the function should return the string `\\"progamin\\"`. * For the input string `\\"\\"`, the function should return an empty string. # Function Signature ```python def delete_reoccurring_characters(string: str) -> str: pass ``` # Input * A single string `string` (0 ≤ length of string ≤ 10^5). The string contains alphanumeric characters and/or spaces. # Output * A new string containing only the first occurrence of each character from the original string in the order of their first appearance. Here are some constraints and points to keep in mind: 1. The function should handle both uppercase and lowercase characters, but treat them as distinct characters (`\'A\'` is different from `\'a\'`). 2. If the input string is empty, the function should return an empty string. # Notes * Focus on efficiency, ensuring the function can handle long strings within a reasonable time frame. * Provide a solution that is readable and well-organized, with comments where necessary. # Performance Requirements * Must run in linear time O(n) relative to the size of the input string.","solution":"def delete_reoccurring_characters(string: str) -> str: Removes recurring characters from the input string, except for their first occurrence. Maintains the order of appearance of the first occurrence of each character. Parameters: string (str): The input string. Returns: str: A string with only the first occurrences of each character and in the order they first appeared. seen = set() result = [] for char in string: if char not in seen: seen.add(char) result.append(char) return \'\'.join(result)"},{"question":"**Scenario**: In an online gaming platform, players are paired into groups, and each player’s score is recorded. Due to a bug, every score got recorded twice except for one player’s score which was recorded once. Your task is to pinpoint this unique score so that necessary debugging actions can be taken. **Task**: Write a function `unique_score` that, given a list of integers where every integer appears twice except for one, finds that single occurrence. You should ensure your function runs in linear time and uses constant space. ```python def unique_score(scores): Returns the unique score that appears once. :type scores: List[int] :rtype: int single = 0 for score in scores: single ^= score return single ``` # Input and Output * **Input**: * `scores`: A list of integers, where each integer (the score) except for one appears twice. * **Output**: * Returns the integer (score) that appears only once. # Constraints * Linear time complexity: O(n) * Constant space complexity: O(1) * You can assume the input list is non-empty and contains at least one unique score. Example: ```python assert unique_score([2, 3, 5, 4, 5, 3, 4]) == 2 assert unique_score([1, 1, 2]) == 2 assert unique_score([10]) == 10 ``` **Hint**: Utilize the properties of the XOR bitwise operation to find the single occurrence efficiently.","solution":"def unique_score(scores): Returns the unique score that appears once. :type scores: List[int] :rtype: int single = 0 for score in scores: single ^= score return single"},{"question":"# String Reversal Assessment Objective: You need to implement four different string reversal methods demonstrating various techniques: recursive, iterative, pythonic, and ultra-pythonic. Tasks: 1. Implement `recursive_reverse(s: str) -> str` to reverse a string using recursion. 2. Implement `iterative_reverse(s: str) -> str` to reverse a string using iteration. 3. Implement `pythonic_reverse(s: str) -> str` to reverse a string using Python\'s built-in functions. 4. Implement `ultra_pythonic_reverse(s: str) -> str` to reverse a string using Python slicing. Function Signatures: ```python def recursive_reverse(s: str) -> str: pass def iterative_reverse(s: str) -> str: pass def pythonic_reverse(s: str) -> str: pass def ultra_pythonic_reverse(s: str) -> str: pass ``` Input: - A single string `s` with a length constraint where 0 <= len(s) <= 10^5. Output: - A new string that represents the reversed order of `s`. Constraints: - Assume the string contains only ASCII characters. Requirements: - The functions should handle edge cases and large input sizes efficiently. Example: ```python assert recursive_reverse(\\"hello\\") == \\"olleh\\" assert iterative_reverse(\\"world\\") == \\"dlrow\\" assert pythonic_reverse(\\"algorithm\\") == \\"mhtirogla\\" assert ultra_pythonic_reverse(\\"data\\") == \\"atad\\" assert recursive_reverse(\\"\\") == \\"\\" assert iterative_reverse(\\"a\\") == \\"a\\" assert pythonic_reverse(\\"racecar\\") == \\"racecar\\" assert ultra_pythonic_reverse(\\"12345\\") == \\"54321\\" ``` Provide implementations for all the required functions, ensuring they pass the given test cases efficiently.","solution":"def recursive_reverse(s: str) -> str: Reverses a string using recursion. if len(s) == 0: return s else: return s[-1] + recursive_reverse(s[:-1]) def iterative_reverse(s: str) -> str: Reverses a string using iteration. reversed_string = \\"\\" for char in s: reversed_string = char + reversed_string return reversed_string def pythonic_reverse(s: str) -> str: Reverses a string using Python\'s built-in reversed() function. return \'\'.join(reversed(s)) def ultra_pythonic_reverse(s: str) -> str: Reverses a string using Python slicing. return s[::-1]"},{"question":"KMP Algorithm Modification Scenario: You are working on a text analysis tool that needs to perform regular searches for multiple patterns in a given text. To optimize the search process, you have been tasked to modify the Knuth-Morris-Pratt (KMP) algorithm so that it can identify the positions of multiple patterns in the text efficiently. Requirements: 1. Write a function `knuth_morris_pratt_multi` that takes a text string and a list of pattern strings, and returns a dictionary where keys are patterns, and values are lists of start indexes in the text where each pattern is found. 2. Your function should leverage the KMP algorithm for efficient searching. Function Signature: ```python from typing import Sequence, List, Dict def knuth_morris_pratt_multi(text: Sequence, patterns: List[Sequence]) -> Dict[str, List[int]]: pass ``` Input: - `text`: A sequence of characters (str) representing the text to search within. - `patterns`: A list of sequences of characters (List[str]) where each sequence represents a pattern to search. Output: - A dictionary (Dict[str, List[int]]) where each key is a pattern from the input list, and each value is a list of start indexes in the text where the corresponding pattern is found. Constraints: - The length of `text` is up to 100,000 characters. - The total length of all patterns combined is up to 10,000 characters. - Patterns can be empty strings, in which case they should not appear in the output dictionary. Example: ```python assert knuth_morris_pratt_multi(\'hello there hero!\', [\'he\', \'hero\', \'\']) == {\'he\': [0, 7], \'hero\': [12]} ``` Notes: - Your implementation should efficiently handle multiple patterns by not reprocessing the text more than necessary. - Ensure robust handling of edge cases such as empty patterns and patterns longer than the text.","solution":"from typing import Sequence, List, Dict def knuth_morris_pratt_multi(text: Sequence, patterns: List[Sequence]) -> Dict[str, List[int]]: Returns a dictionary where keys are patterns, and values are lists of start indexes in the text where each pattern is found. if not text or not patterns: return {} def compute_lps(pattern: str) -> List[int]: Helper function to compute the Longest Prefix Suffix (LPS) array. lps = [0] * len(pattern) length = 0 i = 1 while i < len(pattern): if pattern[i] == pattern[length]: length += 1 lps[i] = length i += 1 else: if length != 0: length = lps[length - 1] else: lps[i] = 0 i += 1 return lps def kmp_search(pattern: str) -> List[int]: Helper function to perform KMP search for a single pattern. if not pattern: return [] lps = compute_lps(pattern) i, j = 0, 0 matches = [] while i < len(text): if text[i] == pattern[j]: i += 1 j += 1 if j == len(pattern): matches.append(i - j) j = lps[j - 1] elif i < len(text) and text[i] != pattern[j]: if j != 0: j = lps[j - 1] else: i += 1 return matches result = {} for pattern in patterns: if pattern and pattern in text: result[pattern] = kmp_search(pattern) return result"},{"question":"You have been tasked to help a local nonprofit organization plan their fundraising event. They have a list of possible donation amounts that individuals can contribute, and they aim to find all possible combinations of these amounts that sum to a specific fundraising goal. Function Signature ```python def combination_sum(candidates: List[int], target: int) -> List[List[int]]: Finds all unique combinations in candidates where the candidate numbers sum to target. Parameters: candidates (List[int]): The list of candidate numbers (without duplicates). target (int): The target sum to be achieved. Returns: List[List[int]]: A list containing all unique combinations that sum up to the target. ``` # Requirements 1. Implement the `combination_sum` function using a backtracking approach. 2. Ensure that the returned combinations are unique and contain numbers in a non-decreasing order. 3. Consider the provided constraints: - All numbers (including target) will be positive integers. - The input list `candidates` will not contain duplicate elements. # Constraints - (1 leq text{candidates.length} leq 30) - (1 leq text{candidates}[i] leq 200) - (1 leq text{target} leq 500) # Example Given the `candidates = [2, 3, 6, 7]` and `target = 7`: ```python combination_sum([2, 3, 6, 7], 7) ``` The expected output is: ```python [ [2, 2, 3], [7] ] ``` # Notes - Make sure the function handles edge cases such as an empty list of candidates or a target that cannot be achieved. - Ensure optimized performance by pruning unnecessary recursive calls where possible. - Provide sufficient test cases to validate the implementation.","solution":"from typing import List def combination_sum(candidates: List[int], target: int) -> List[List[int]]: def backtrack(start, current_combination, current_sum): if current_sum == target: result.append(list(current_combination)) return if current_sum > target: return for i in range(start, len(candidates)): current_combination.append(candidates[i]) backtrack(i, current_combination, current_sum + candidates[i]) current_combination.pop() candidates.sort() result = [] backtrack(0, [], 0) return result"},{"question":"# Question: Implement Optimized Edit Distance Algorithm You are a software engineer at a text processing company and you\'ve been tasked to implement an optimized version of the edit distance algorithm (also known as Levenshtein Distance). This version should minimize space complexity while maintaining the correctness of the original algorithm. Objective: Create an efficient function to calculate the minimum edit distance between two given words using a space-optimized approach. Function Signature: ```python def optimized_edit_distance(word_a: str, word_b: str) -> int: Calculate minimum edit distance between word_a and word_b. Parameters: word_a (str): The first word. word_b (str): The second word. Returns: int: The minimum number of operations required to transform word_a into word_b. ``` Input: - `word_a` : a string representing the first word (1 <= len(word_a) <= 1000) - `word_b` : a string representing the second word (1 <= len(word_b) <= 1000) Output: - Returns an integer representing the minimum number of operations required to transform `word_a` into `word_b`. Constraints: - The function should use a space-optimized approach and must run within a reasonable time for strings of length up to 1000. Example: ```python assert optimized_edit_distance(\\"kitten\\", \\"sitting\\") == 3 assert optimized_edit_distance(\\"flaw\\", \\"lawn\\") == 2 assert optimized_edit_distance(\\"intention\\", \\"execution\\") == 5 assert optimized_edit_distance(\\"food\\", \\"money\\") == 4 ``` Note: - Remember the cost of insertion, deletion, and substitution is 1. - Your implementation should aim to improve the space efficiency compared to the traditional O(m*n) space complexity dynamic programming approach.","solution":"def optimized_edit_distance(word_a: str, word_b: str) -> int: Calculate minimum edit distance between word_a and word_b using a space-optimized approach. Parameters: word_a (str): The first word. word_b (str): The second word. Returns: int: The minimum number of operations required to transform word_a into word_b. len_a, len_b = len(word_a), len(word_b) if len_a < len_b: word_a, word_b = word_b, word_a len_a, len_b = len_b, len_a # Create two rows for dynamic programming previous_row = list(range(len_b + 1)) current_row = [0] * (len_b + 1) for i in range(1, len_a + 1): current_row[0] = i for j in range(1, len_b + 1): insert_cost = current_row[j - 1] + 1 delete_cost = previous_row[j] + 1 replace_cost = previous_row[j - 1] + (0 if word_a[i - 1] == word_b[j - 1] else 1) current_row[j] = min(insert_cost, delete_cost, replace_cost) previous_row, current_row = current_row, previous_row return previous_row[len_b]"},{"question":"# Problem: Binary Tree Path Sum Validation Objective: Write a function called `is_valid_path_sum` that determines if a given binary tree has any root-to-leaf path where the sum of the node values equals a specified target sum. Function Signature: ```python def is_valid_path_sum(root: TreeNode, target_sum: int) -> bool: pass ``` Input: - `root`: The root node of a binary tree (of type `TreeNode`). - `target_sum`: An integer representing the target sum to be checked against any root-to-leaf path. Output: - Returns `True` if there exists a path from root to leaf such that the sum of the node values equals `target_sum`. - Otherwise, returns `False`. Constraints: - The number of nodes in the tree is in the range `[0, 5000]`. - `-1000 <= Node.val <= 1000` - `-1000 <= target_sum <= 1000` Example: ```python # Example tree: # 5 # / # 4 8 # / / # 11 13 4 # / # 7 2 1 # Given the above binary tree and target_sum = 22, assert is_valid_path_sum(root, 22) == True # Output: True for path 5->4->11->2 # Given the same tree and target_sum = 18, assert is_valid_path_sum(root, 18) == False # Output: False, as there\'s no valid path. ``` Notes: - Ensure efficient handling of memory and performance to suit the constraints. - Consider implementing both DFS and BFS approaches for better understanding while focusing on a clean and concise solution. Hint: - Use traversal techniques to explore each path from root to leaf, keeping a running total of the sum so far.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_valid_path_sum(root: TreeNode, target_sum: int) -> bool: if not root: return False if not root.left and not root.right: return target_sum == root.val target_sum -= root.val return is_valid_path_sum(root.left, target_sum) or is_valid_path_sum(root.right, target_sum)"},{"question":"Given an unordered list of elements, write a function `calculate_histogram` to find and return the histogram of the input list. The histogram should be represented as a dictionary where each key is an element from the list, and the corresponding value is the frequency of that element in the list. # Function Signature: ```python def calculate_histogram(input_list: list) -> dict: ``` # Input: * `input_list`: List of elements (e.g., integers, strings, etc.) (1 <= len(input_list) <= 10^5) # Output: * Returns a dictionary where keys are elements from the input list and values are the counts of their occurrences. # Constraints: * Elements of the list are hashable. * The list can contain any type of elements as long as they are hashable. # Example: ```python # Example 1 input_list = [3, 3, 2, 1] # Expected output: {3: 2, 2: 1, 1: 1} # Example 2 input_list = [2, 3, 5, 5, 5, 6, 4, 3, 7] # Expected output: {2: 1, 3: 2, 5: 3, 6: 1, 4: 1, 7: 1} # Example 3 input_list = [] # Expected output: {} ``` # Notes: * You are not allowed to use any libraries that provide similar functionalities such as `collections.Counter`. # Edge Cases to Consider: * Handle an empty list appropriately by returning an empty dictionary. * Handle lists with all identical elements. * Assume all input elements are hashable and valid.","solution":"def calculate_histogram(input_list: list) -> dict: Calculate the histogram of the input list. Parameters: input_list (list): List of hashable elements. Returns: dict: A dictionary where keys are elements from the input list and values are the counts of their occurrences. histogram = {} for element in input_list: if element in histogram: histogram[element] += 1 else: histogram[element] = 1 return histogram"},{"question":"# Question **Objective**: Implement an advanced calculation system using a stack-based approach. **Scenario**: You are tasked with designing a function that evaluates arithmetic expressions written in postfix notation (Reverse Polish Notation). In such expressions, operators follow their operands, for example, the expression `5 1 2 + 4 * + 3 -` reads as: `5 + ((1 + 2) * 4) - 3`. **Function Signature**: ```python def evaluate_postfix(expression: str) -> int: pass ``` **Input/Output Formats**: * **Input**: * `expression`: A string representing a postfix expression, where each token (operator or operand) is separated by a space. The expression can include non-negative integers and the operators `+`, `-`, `*`, `/`. * **Output**: * Return the integer result of the evaluated expression. **Constraints**: * The given expression will always be valid. * Division `a / b` should be treated as integer division if `a` and `b` are both integers. **Requirements**: * You **must** use the `ArrayStack` stack implementation provided above. * Your solution should be efficient both in terms of time and space. * Aim for a time complexity of O(n), where `n` is the number of tokens in the expression. **Examples**: ```python print(evaluate_postfix(\\"5 1 2 + 4 * + 3 -\\")) # Output: 14 print(evaluate_postfix(\\"2 3 +\\")) # Output: 5 print(evaluate_postfix(\\"10 6 9 3 + -11 * / * 17 + 5 +\\")) # Output: 22 ``` **Hints**: 1. Use the ArrayStack to manage operands. 2. Iterate through each token in the expression, push operands to the stack and pop for operators to apply operations and push the results back.","solution":"def evaluate_postfix(expression: str) -> int: stack = [] tokens = expression.split() for token in tokens: if token.isdigit() or (token[0] == \'-\' and token[1:].isdigit()): stack.append(int(token)) else: b = stack.pop() a = stack.pop() if token == \'+\': stack.append(a + b) elif token == \'-\': stack.append(a - b) elif token == \'*\': stack.append(a * b) elif token == \'/\': stack.append(int(a / b)) # use int() to perform integer division return stack.pop()"},{"question":"# Context: You are tasked with implementing an efficient priority queue system for a parcel dispatch center. This system should allow parcels to be added with a priority, and the highest priority parcel should be dispatched first. Parcels with the same priority should be dispatched in the order they were added. # Task: Implement a class `PriorityQueue` using a modified min-heap data structure provided in the code snippet. You need to support the following operations efficiently: 1. `enqueue(parcel_id: int, priority: int)`: Adds a parcel with the given `parcel_id` and `priority` to the priority queue. 2. `dequeue() -> int`: Removes and returns the `parcel_id` of the highest priority parcel from the queue. 3. `peek() -> int`: Returns the `parcel_id` of the highest priority parcel without removing it from the queue. 4. `is_empty() -> bool`: Returns `True` if the priority queue is empty, and `False` otherwise. # Input: 1. `enqueue(parcel_id: int, priority: int)`: Takes two integers `parcel_id` and `priority`. 2. `dequeue() -> int`: Takes no parameters. 3. `peek() -> int`: Takes no parameters. 4. `is_empty() -> bool`: Takes no parameters. # Output: 1. `enqueue`: No return value. 2. `dequeue() -> int`: Returns the `parcel_id` of the highest priority parcel or -1 if the queue is empty. 3. `peek() -> int`: Returns the `parcel_id` of the highest priority parcel or -1 if the queue is empty. 4. `is_empty() -> bool`: Returns a boolean indicating whether the queue is empty. # Constraints: - `1 <= parcel_id, priority <= 10^5` - Operations will be called up to `10^6` times. # Example: ```python pq = PriorityQueue() pq.enqueue(1, 10) pq.enqueue(2, 5) pq.enqueue(3, 20) assert pq.peek() == 2 assert pq.dequeue() == 2 assert pq.peek() == 1 assert pq.is_empty() == False assert pq.dequeue() == 1 assert pq.dequeue() == 3 assert pq.is_empty() == True assert pq.dequeue() == -1 ``` # Notes: - You may utilize the provided BinaryHeap class as a guideline but will need to adjust it to handle the custom priority and tie-breaking rules.","solution":"import heapq class PriorityQueue: def __init__(self): self.heap = [] self.counter = 0 # This will act as a tiebreaker def enqueue(self, parcel_id: int, priority: int): heapq.heappush(self.heap, (priority, self.counter, parcel_id)) self.counter += 1 def dequeue(self) -> int: if self.is_empty(): return -1 return heapq.heappop(self.heap)[2] def peek(self) -> int: if self.is_empty(): return -1 return self.heap[0][2] def is_empty(self) -> bool: return len(self.heap) == 0"},{"question":"You have been given an array of integers where the values are mostly within the same range. Your task is to write a function `pigeonhole_sort` that sorts this array using the Pigeonhole sort algorithm. Function Signature ```python def pigeonhole_sort(arr: List[int]) -> List[int]: ``` Input * `arr`: a list of integers to be sorted. * `1 <= len(arr) <= 10^5` * The integers could be negative or positive. Output * The function should return the sorted list. Constraints * The function should sort the array in ascending order. * The values of the integers in the array will generally be within a small range relative to the number of elements, but the range will not be explicitly provided. Performance Requirements * The function should efficiently handle sorting arrays up to the maximum input size within a reasonable time frame. * The space complexity should be managed effectively based on the input constraints. # Example ```python assert pigeonhole_sort([8, 3, 2, 7, 4]) == [2, 3, 4, 7, 8] assert pigeonhole_sort([1, 4, 1, 0, 0, 3, 5]) == [0, 0, 1, 1, 3, 4, 5] ``` # Scenario Imagine you are working with a dataset where the values represent various counts or measurements that fall within a recognizable range. However, you need to ensure quick sorting to perform subsequent analyses. Implement the `pigeonhole_sort` function to efficiently handle such tasks given the constraints.","solution":"from typing import List def pigeonhole_sort(arr: List[int]) -> List[int]: if not arr: return arr min_val = min(arr) max_val = max(arr) size = max_val - min_val + 1 holes = [0] * size for number in arr: holes[number - min_val] += 1 sorted_arr = [] for index, count in enumerate(holes): if count > 0: sorted_arr.extend([index + min_val] * count) return sorted_arr"},{"question":"Bitwise Sum Calculator Problem Statement You are tasked with implementing a function that adds two non-negative integers without using the \'+\' operator. Instead, you will use bitwise operations to complete the addition process. The objective is to demonstrate your understanding of bitwise manipulation and arithmetic. Function Signature ```python def bitwise_sum(a: int, b: int) -> int: Add two non-negative integers using bitwise operations. :param a: Non-negative integer :param b: Non-negative integer :return: The sum of a and b ``` Input * Two non-negative integers `a` and `b` such that (0 leq a, b leq 10^9). Output * Return a single integer that is the sum of `a` and `b`. Constraints * You must not use the \'+\' operator or any library functions that perform addition. * Utilize bitwise operations (AND, OR, XOR, and Left Shift) to achieve the result. * Consider the performance for large integers close to the maximum limit. Example *Example 1:* Input: ```plaintext a = 2 b = 3 ``` Output: ```plaintext 5 ``` *Example 2:* Input: ```plaintext a = 0 b = 10 ``` Output: ```plaintext 10 ``` Additional Information: Ensure your implementation handles the edge cases of zero addition and works efficiently within the given constraints.","solution":"def bitwise_sum(a: int, b: int) -> int: Add two non-negative integers using bitwise operations. :param a: Non-negative integer :param b: Non-negative integer :return: The sum of a and b while b != 0: carry = a & b a = a ^ b b = carry << 1 return a"},{"question":"# Primality Testing with Rabin-Miller Algorithm **Scenario**: You are working for a company that needs to frequently verify large prime numbers for cryptographic purposes. To ensure speed and reliability, you decide to design a primality test using the Rabin-Miller algorithm. # Problem Statement: Write a function named **`is_prime`** that determines if a given number `n` is probably prime. The function should follow these specifications: Function Signature: ```python def is_prime(n: int, k: int) -> bool: Determine if a number is probably prime using the Rabin-Miller primality test. :param n: Integer, the number to test for primality. :param k: Integer, the number of rounds of testing to perform. :return: Boolean, True if n is probably prime, False if n is composite. ``` Input: - `n` (int): The number to be tested. **Constraints**: `n >= 2`. - `k` (int): The number of iterations for the test. **Constraints**: `k >= 1`. Output: - Returns `True` if `n` is probably prime, `False` if `n` is definitely composite. # Examples: ```python print(is_prime(7, 5)) # True print(is_prime(4, 3)) # False print(is_prime(123457, 5))# True print(is_prime(561, 4)) # False (561 is a Carmichael number) ``` # Constraints: - Your solution should handle edge cases like very small `n` (less than 5). - Ensure optimal performance for large values of `n` up to at least 10^12. # Notes: - Remember that `False` guarantees compositeness, `True` means probably prime with a probabilistic error dependent on `k`. - You may assume that the random number generator is sufficiently random for the purposes of the test. Good luck!","solution":"import random def is_prime(n: int, k: int) -> bool: Determine if a number is probably prime using the Rabin-Miller primality test. :param n: Integer, the number to test for primality. :param k: Integer, the number of rounds of testing to perform. :return: Boolean, True if n is probably prime, False if n is composite. if n <= 1: return False if n <= 3: return True if n % 2 == 0: return False # Write n-1 as d*2^r r, d = 0, n - 1 while d % 2 == 0: d //= 2 r += 1 # Witness loop for _ in range(k): a = random.randint(2, n - 2) x = pow(a, d, n) if x == 1 or x == n - 1: continue for _ in range(r - 1): x = pow(x, 2, n) if x == n - 1: break else: return False return True"},{"question":"You are given a graph represented as an adjacency list, where each node points to a list of its neighbors. Implement a function called `count_shortest_paths` that finds and returns the number of shortest paths between two nodes in the graph. # Function Signature: ```python def count_shortest_paths(graph: Dict[str, List[str]], start: str, end: str) -> int: ``` # Input: * `graph`: A dictionary where keys are node identifiers (strings) and values are lists of neighboring node identifiers (strings). * `start`: A string representing the starting node. * `end`: A string representing the target node. # Output: * Return an integer representing the number of shortest paths from `start` to `end`. # Constraints: * The graph does not contain any negative cycles. * All nodes and edges are unweighted. * Nodes will have unique identifiers. * Nodes can have from 0 to N-1 neighbors. # Example: ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'C\', \'D\'], \'C\': [\'D\'], \'D\': [] } start = \'A\' end = \'D\' count_shortest_paths(graph, start, end) # Expected output: 2 ``` # Explanation: In the given graph, there are two shortest paths from A to D: {\'A\', \'B\', \'D\'} and {\'A\', \'C\', \'D\'}, both having length 2. Hence, the function should return 2. # Guidelines: * You may use BFS for finding the shortest path. * Carefully handle cases where the path does not exist. * Ensure your solution considers the edge cases and efficiency for larger graphs. Good luck!","solution":"from collections import deque, defaultdict def count_shortest_paths(graph, start, end): Returns the number of shortest paths from start to end in an unweighted graph. :param graph: a dictionary representing the adjacency list of the graph :param start: the start node as a string :param end: the end node as a string :return: the number of shortest paths between start and end if start == end: return 1 # BFS initialization queue = deque([(start, 0)]) visited = {start: 0} path_count = defaultdict(int) path_count[start] = 1 while queue: current_node, current_distance = queue.popleft() for neighbor in graph.get(current_node, []): if neighbor not in visited: visited[neighbor] = current_distance + 1 queue.append((neighbor, current_distance + 1)) path_count[neighbor] = path_count[current_node] elif visited[neighbor] == current_distance + 1: path_count[neighbor] += path_count[current_node] return path_count[end]"},{"question":"# Question: Extending the Markov Chain Implementation Context Imagine you are working on a simulation project that models customer behavior in a store. You\'ve been asked to use a Markov Chain to represent the possible transitions between different sections of the store (e.g., entrance, electronics, clothing, checkout). Your Task Extend the provided Markov Chain implementation to include the following functionality: 1. Add a function `find_path(chain, start_state, end_state, max_steps)` that finds if there is a path from `start_state` to `end_state` within at most `max_steps` steps. If a path is found, return the sequence of states; otherwise, return `None`. Requirements - The path must be valid per the given transition probabilities. - If multiple paths exist, any valid path can be returned. - If `max_steps` is 0, the function should only return the path if `start_state` is the same as `end_state`. Input - `chain`: A dictionary representing the Markov chain, where keys are states and values are dictionaries of state probabilities `{state: {next_state: probability, ...}}`. - `start_state`: The state from which we start. - `end_state`: The destination state we want to reach. - `max_steps`: The maximum number of steps allowed to reach the end state. Output - A list of states representing the path from `start_state` to `end_state` if such a path exists within `max_steps` steps. - If no such path exists, return `None`. Constraints - All probabilities in the chain sum to 1 per state. - The chain contains at least one state. - `max_steps` is a non-negative integer. # Example ```python my_chain = { \'entrance\': {\'electronics\': 0.5, \'clothing\': 0.5}, \'electronics\': {\'clothing\': 1.0}, \'clothing\': {\'checkout\': 1.0}, \'checkout\': {} } start_state = \'entrance\' end_state = \'checkout\' max_steps = 3 path = find_path(my_chain, start_state, end_state, max_steps) print(path) # Output: [\'entrance\', \'electronics\', \'clothing\', \'checkout\'] ``` # Guidelines - Ensure your function handles edge cases, such as no possible transitions or states not being reachable. - Aim for a solution that balances clarity, code efficiency, and thorough handling of input constraints.","solution":"def find_path(chain, start_state, end_state, max_steps): Finds a path from start_state to end_state within at most max_steps steps. If a path is found, return the sequence of states; otherwise, return None. if start_state == end_state and max_steps >= 0: return [start_state] def dfs(current_state, target_state, steps_remaining, path): if steps_remaining < 0: return None if current_state == target_state: return path for next_state in chain.get(current_state, {}): result = dfs(next_state, target_state, steps_remaining - 1, path + [next_state]) if result: return result return None return dfs(start_state, end_state, max_steps, [start_state])"},{"question":"# Scenario You have been hired to develop a text parser for a simple text-based adventure game. As part of the game\'s engine, you need to implement a DFA that checks if player commands are valid according to predefined patterns. # Task Write a function `is_valid_command` that determines if an input player command string is accepted by the DFA. The DFA is designed to recognize valid player commands based on a set of transitions, a start state, and a final (accepting) state. # Input * A dictionary `transitions` representing the state transitions. Each key is a state, and each value is another dictionary mapping input symbols to the corresponding state. * An integer `start` representing the starting state. * A list of integers `final` representing the accepting states. * A string `command` representing the player command. # Output * Return `True` if the DFA accepts the command (i.e., processing the entire command string ends in an accepting state). * Return `False` if the DFA does not accept the command. # Constraints * The transition dictionary will always contain states and symbols relevant to the DFA. * Only valid states and symbols will be provided in the command string. * The number of states will be between 1 and 1000. * The length of the command string will be between 1 and 100. # Example ```python transitions = { 0: {\'a\': 1, \'b\': 2}, 1: {\'a\': 1, \'b\': 3}, 2: {\'a\': 1, \'b\': 2}, 3: {\'a\': 3, \'b\': 3} } start = 0 final = [3] command = \\"ab\\" print(is_valid_command(transitions, start, final, command)) # Output: True ``` # Explanation In the example above, processing the command \\"ab\\": 1. Start at state 0, read \'a\', move to state 1. 2. From state 1, read \'b\', move to state 3. 3. State 3 is an accepting state, so the DFA accepts the command, and the function returns `True`. # Solution Template ```python def is_valid_command(transitions, start, final, command): num = len(command) num_final = len(final) cur = start for i in range(num): if transitions[cur][command[i]] is None: return False else: cur = transitions[cur][command[i]] for i in range(num_final): if cur == final[i]: return True return False ```","solution":"def is_valid_command(transitions, start, final, command): Determines if the given command is accepted by the DFA. Args: transitions (dict): The state transition dictionary. start (int): The starting state. final (list): List of accepting states. command (string): The command string to be checked. Returns: bool: True if the command is accepted, False otherwise. current_state = start for symbol in command: if symbol in transitions[current_state]: current_state = transitions[current_state][symbol] else: return False return current_state in final"}]'),O={name:"App",components:{PoemCard:N},data(){return{searchQuery:"",visibleCount:4,poemsData:S,isLoading:!1}},computed:{filteredPoems(){const r=this.searchQuery.trim().toLowerCase();return r?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(r)||e.solution&&e.solution.toLowerCase().includes(r)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(r=>setTimeout(r,1e3)),this.visibleCount+=4,this.isLoading=!1}}},C={class:"search-container"},L={class:"card-container"},F={key:0,class:"empty-state"},z=["disabled"],R={key:0},Y={key:1};function j(r,e,l,p,a,s){const m=g("PoemCard");return n(),i("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",C,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),_(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>a.searchQuery=o),placeholder:"Search..."},null,512),[[y,a.searchQuery]]),a.searchQuery?(n(),i("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>a.searchQuery="")}," ✕ ")):u("",!0)]),t("div",L,[(n(!0),i(b,null,v(s.displayedPoems,(o,f)=>(n(),w(m,{key:f,poem:o},null,8,["poem"]))),128)),s.displayedPoems.length===0?(n(),i("div",F,' No results found for "'+d(a.searchQuery)+'". ',1)):u("",!0)]),s.hasMorePoems?(n(),i("button",{key:0,class:"load-more-button",disabled:a.isLoading,onClick:e[2]||(e[2]=(...o)=>s.loadMore&&s.loadMore(...o))},[a.isLoading?(n(),i("span",Y,"Loading...")):(n(),i("span",R,"See more"))],8,z)):u("",!0)])}const P=c(O,[["render",j],["__scopeId","data-v-20856f84"]]),M=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"drive/57.md","filePath":"drive/57.md"}'),D={name:"drive/57.md"},G=Object.assign(D,{setup(r){return(e,l)=>(n(),i("div",null,[x(P)]))}});export{M as __pageData,G as default};
