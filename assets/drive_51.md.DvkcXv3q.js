import{_ as c,o as n,c as i,a as t,m as h,t as d,C as g,M as _,U as y,f as u,F as b,p as v,e as w,q as x}from"./chunks/framework.B1z0IdBH.js";const k={name:"PoemCard",props:{poem:{type:Object,required:!0}}},T={class:"poem-container"},q={class:"review"},I={class:"review-title"},E={class:"review-content"};function A(r,e,l,p,s,a){return n(),i("div",T,[t("div",q,[t("div",I,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),h(d(l.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",E,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),h(d(l.poem.solution),1)])])])}const S=c(k,[["render",A],["__scopeId","data-v-b80e05c7"]]),O=JSON.parse('[{"question":"# Question: You are given an array of integers `nums` which contains exactly two unique elements and every other element appears exactly twice. Write a function `find_unique_elements(nums)` to find the two unique elements. Your solution must run in O(N) time and use only O(1) extra space. Input * An array of integers, `nums` (0 ≤ len(nums) ≤ 10^5), with exactly two unique numbers and all other numbers appearing exactly twice. Output * A list of the two unique integers. Function Signature ```python def find_unique_elements(nums: List[int]) -> List[int]: # your code here ``` Example ```python assert find_unique_elements([1, 2, 1, 3, 2, 5]) == [3, 5] or find_unique_elements([1, 2, 1, 3, 2, 5]) == [5, 3] assert find_unique_elements([4, 4, 6, 6, 9, 7]) == [9, 7] or find_unique_elements([4, 4, 6, 6, 9, 7]) == [7, 9] ``` Constraints * You must achieve a time complexity of O(N) and a space complexity of O(1). * The order of the result does not matter. Guideline 1. Use XOR bitwise operation to find the combined result of the two unique numbers. 2. Isolate one bit that is set in the combined result. 3. Divide the array into two groups based on this isolated bit and use XOR again to find the unique numbers for each group.","solution":"from typing import List def find_unique_elements(nums: List[int]) -> List[int]: # Step 1: XOR all numbers to get XOR of the two unique numbers xor_result = 0 for num in nums: xor_result ^= num # Step 2: Find a set bit in the xor_result (that differs in the two unique numbers) diff_bit = xor_result & -xor_result # Step 3: Divide numbers into two groups based on the diff_bit and XOR individually unique1 = 0 unique2 = 0 for num in nums: if num & diff_bit: unique1 ^= num else: unique2 ^= num return [unique1, unique2]"},{"question":"Scenario You are working on a text segmentation feature for an application that processes sentences to identify words from a given dictionary. Your task is to write a function that determines the number of valid segmentations of a given string into dictionary words. Each word in the string must be contained within the given dictionary. Function Specification Implement the following function: ```python def count_sentences(s: str, dictionary: set) -> int: Given a string s and a set of valid words (dictionary), this function returns the number of ways to segment s such that every segment is a valid word in the dictionary. :param s: str - Input string to be segmented. :param dictionary: set - A set of valid words. :return: int - Number of ways to segment the string s using words in dictionary. pass ``` Input and Output Formats * **Input**: * `s` (1 <= `s` <= 1000): A string worth splitting. * `dictionary` (size <= 1000): A set containing valid dictionary words. * **Output**: * Return an integer denoting the number of possible segmentations. Constraints * The characters in the string `s` are all lowercase English letters. * The dictionary contains lowercase English words. * Performance is crucial; therefore, consider optimizing your solution to avoid time complexity bottlenecks discussed. Example ```python assert count_sentences(\\"appletablet\\", {\\"apple\\", \\"tablet\\", \\"app\\", \\"let\\", \\"able\\", \\"t\\", \\"applet\\"}) == 4 assert count_sentences(\\"thing\\", {\\"thing\\"}) == 1 assert count_sentences(\\"thing\\", {\\"th\\", \\"ing\\", \\"thing\\"}) == 2 assert count_sentences(\\"helloworld\\", {\\"hello\\", \\"world\\"}) == 1 ``` Hints * Consider using a dynamic programming approach to store results of already computed segmentations. * An iterative approach with a queue might also be beneficial to avoid deep recursion.","solution":"def count_sentences(s: str, dictionary: set) -> int: Given a string s and a set of valid words (dictionary), this function returns the number of ways to segment s such that every segment is a valid word in the dictionary. :param s: str - Input string to be segmented. :param dictionary: set - A set of valid words. :return: int - Number of ways to segment the string s using words in dictionary. # Create a list to store the number of ways to segment s up to each index dp = [0] * (len(s) + 1) dp[0] = 1 # There\'s one way to segment an empty string for i in range(1, len(s) + 1): for j in range(i): if s[j:i] in dictionary: dp[i] += dp[j] return dp[len(s)]"},{"question":"# Comb Sort Implementation and Optimization Challenge You are provided with a basic implementation of the Comb Sort algorithm. This algorithm is known to sort an array in a manner somewhat similar to Bubble Sort by reducing the gap between compared elements over iterations. Task Your task is to implement the function `optimized_comb_sort` which will improve upon the given Comb Sort algorithm by using a more efficient gap reduction sequence. Specifically, you should implement the \\"Hibbard sequence\\" (1, 3, 7, ... up to the largest increment less than the length of the array). # Function Signature ```python def optimized_comb_sort(arr: List[int]) -> List[int]: pass ``` Input * An array `arr` of integers, with a maximum length of 10^5 and values ranging between -10^9 and 10^9. Output * A sorted list of integers in ascending order. Constraints * The algorithm should run efficiently with an average-case time complexity better than O(N^2). Example ```python >>> optimized_comb_sort([34, 8, 64, 51, 32, 21]) [8, 21, 32, 34, 51, 64] >>> optimized_comb_sort([3, 1, 2]) [1, 2, 3] >>> optimized_comb_sort([10, 9, 8, 7, 6, 5, 4, 3, 2, 1]) [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] ``` Notes * Ensure that your implementation handles edge cases such as empty arrays, single-element arrays, and arrays with all identical elements correctly. * Consider performance optimizations in your implementation to handle large arrays efficiently.","solution":"from typing import List def optimized_comb_sort(arr: List[int]) -> List[int]: def next_gap(gap): # Using the Hibbard sequence `1, 3, 7, 15, ...` return (gap + 1) // 2 if gap > 1 else 0 n = len(arr) if n <= 1: return arr gap = n swapped = True while gap > 1 or swapped: gap = next_gap(gap) swapped = False for i in range(n - gap): if arr[i] > arr[i + gap]: arr[i], arr[i + gap] = arr[i + gap], arr[i] swapped = True return arr"},{"question":"# Context: You are working on a text generator that uses a Markov chain to predict the next word based on the current word. Given a text, you build a Markov chain to learn the transition probabilities between words. Your task is to implement a function that predicts the next sequence of words given an initial word and a Markov chain. # Input and Output Formats: - **Input**: - A Markov chain defined as a dictionary where each key is a word and the value is another dictionary containing possible next words and their transition probabilities. - An initial word as a string. - An integer `num_words` indicating the sequence length to generate. - **Output**: - A list of words representing the sequence generated from the initial word using the Markov chain. # Constraints & Limitations: - Ensure all probabilities in the chain dictionary sum to 1 for each word. - Handle the edge case where the initial word has no corresponding transitions. - Avoid infinite loops and ensure the function terminates practically. # Performance Requirements: - The function should run efficiently even for large Markov chains with thousands of states. # Function Signature: ```python def generate_sequence(chain: dict, initial_word: str, num_words: int) -> List[str]: pass ``` # Example: ```python my_chain = { \'A\': {\'A\': 0.6, \'E\': 0.4}, \'E\': {\'A\': 0.7, \'E\': 0.3} } sequence = generate_sequence(my_chain, \'A\', 5) print(sequence) # Expected output might be: [\'E\', \'A\', \'E\', \'A\', \'A\'] # Note: Due to randomness, actual output may vary. ``` # Additional Notes: - You are not required to handle training the Markov chain from the text, only using the provided chain for generation. - Make sure to seed the random number generator for consistency when testing.","solution":"import random def generate_sequence(chain: dict, initial_word: str, num_words: int) -> list: Generate a sequence of words from a Markov chain. Parameters: - chain: A dictionary representing the Markov chain with transition probabilities. - initial_word: The word to start the sequence from. - num_words: The number of words to generate for the sequence. Returns: - A list of words representing the generated sequence. if initial_word not in chain: return [] sequence = [initial_word] current_word = initial_word for _ in range(num_words - 1): if current_word not in chain or not chain[current_word]: break next_word = random.choices( population=list(chain[current_word].keys()), weights=list(chain[current_word].values()) )[0] sequence.append(next_word) current_word = next_word return sequence"},{"question":"# Question: Implement an Enhanced Atbash Cipher **Scenario**: You are tasked with implementing an Atbash cipher that supports both encryption and decryption. This type of cipher maps each letter of the alphabet to its reverse. For this task, you\'re expected to write a function that performs the encryption/decryption given an input string, while properly preserving spaces and special characters. Function Signature: ```python def enhanced_atbash_cipher(input_string: str) -> str: ``` Input: - `input_string` (str): A string consisting of characters including letters (both upper and lower case), spaces, and special characters. Output: - (str): A string where each letter is substituted with its reverse in the alphabet. Constraints: - The input string can contain alphabets (case-sensitive), digits, spaces, and special characters. - The length of the input string will not exceed 1000 characters. Examples: ```python assert enhanced_atbash_cipher(\\"Attack at dawn!\\") == \\"Zggzxp zg wzdm!\\" assert enhanced_atbash_cipher(\\"Hello, World!\\") == \\"Svool, Dliow!\\" assert enhanced_atbash_cipher(\\"R2D2\\") == \\"I2W2\\" assert enhanced_atbash_cipher(\\"Code 2021\\") == \\"Xlwv 2021\\" ``` Requirements: - The function should have a time complexity of O(n). - Non-alphabet characters (digits, spaces, punctuation) should remain unchanged. - The function should handle edge cases like empty strings and strings with no alphabet characters gracefully.","solution":"def enhanced_atbash_cipher(input_string: str) -> str: Encrypts or decrypts the input string using the Atbash cipher. # Define the Atbash cipher for both uppercase and lowercase letters def atbash(c): if \'a\' <= c <= \'z\': return chr(ord(\'z\') - ord(c) + ord(\'a\')) elif \'A\' <= c <= \'Z\': return chr(ord(\'Z\') - ord(c) + ord(\'A\')) else: return c # Apply the Atbash cipher to each character in the input string return \'\'.join(atbash(c) for c in input_string)"},{"question":"# Hash Table Implementation with Advanced Features Objective You are tasked with extending the provided `ResizableHashTable` class to include two additional features: 1. Support for quadratic probing as an alternative to linear probing. 2. A method to get all the keys currently stored in the hash table. Features to Implement 1. **Quadratic Probing**: - Add an option to use quadratic probing for collision resolution. - Implement this via an optional parameter for the hash table initialization. 2. **Retrieve All Keys**: - Implement a method `keys()` that returns a list of all keys in the hash table. Detailed Requirements * **Quadratic Probing**: - Modify the constructor to take an optional parameter `probing = \'linear\'` or `probing = \'quadratic\'`. - Modify the `_rehash` method to utilize quadratic probing if the latter option is chosen. * **Retrieve All Keys**: - Implement a `keys()` method that returns a list of all keys currently present in the hash table. Expected Input and Output ```python # Example instantiation and usage with linear probing (default) ht = ResizableHashTable() ht.put(1, \'one\') ht.put(2, \'two\') ht.put(3, \'three\') print(ht.get(2)) # Output: \'two\' print(ht.keys()) # Output: [1, 2, 3] ht.put(2, \'TWO\') print(ht.get(2)) # Output: \'TWO\' # Example instantiation and usage with quadratic probing ht_q = ResizableHashTable(probing=\'quadratic\') ht_q.put(1, \'one\') ht_q.put(12, \'twelve\') # Assuming size is 11, this will collide with 1 and use quadratic probing print(ht_q.get(12)) # Output: \'twelve\' print(ht_q.keys()) # Output: [1, 12] ``` Constraints and Limitations - The hash table should dynamically resize when the load factor exceeds `2/3`. - Implement effective collision handling using either linear or quadratic probing based on the initialization parameter. - Ensure that the retrieval of all keys through the `keys` method is efficient. Performance Requirements - The overall average case time complexity for `put`, `get`, and `delete` operations should remain as close to O(1) as possible. - The resizing operations should maintain O(n) complexity, with consideration for maintaining efficient amortized performance.","solution":"class ResizableHashTable: def __init__(self, initial_capacity=11, probing=\'linear\'): self.capacity = initial_capacity self.probing = probing self.size = 0 self.keys_ls = [None] * self.capacity self.values_ls = [None] * self.capacity def hash(self, key): return key % self.capacity def put(self, key, value): idx = self.hash(key) probe_count = 0 while self.keys_ls[idx] is not None and self.keys_ls[idx] != key: probe_count += 1 if self.probing == \'quadratic\': idx = (idx + probe_count ** 2) % self.capacity else: # linear probing idx = (idx + 1) % self.capacity if self.keys_ls[idx] is None: self.size += 1 self.keys_ls[idx] = key self.values_ls[idx] = value if self.size / self.capacity > 2 / 3: self._rehash() def get(self, key): idx = self.hash(key) probe_count = 0 while self.keys_ls[idx] is not None: if self.keys_ls[idx] == key: return self.values_ls[idx] probe_count += 1 if self.probing == \'quadratic\': idx = (idx + probe_count ** 2) % self.capacity else: # linear probing idx = (idx + 1) % self.capacity return None def delete(self, key): idx = self.hash(key) probe_count = 0 while self.keys_ls[idx] is not None: if self.keys_ls[idx] == key: self.keys_ls[idx] = None self.values_ls[idx] = None self.size -= 1 self._rehash(False) # compact the array return probe_count += 1 if self.probing == \'quadratic\': idx = (idx + probe_count ** 2) % self.capacity else: # linear probing idx = (idx + 1) % self.capacity def keys(self): return [key for key in self.keys_ls if key is not None] def _rehash(self, resize=True): old_keys = self.keys_ls old_values = self.values_ls if resize: self.capacity *= 2 self.size = 0 self.keys_ls = [None] * self.capacity self.values_ls = [None] * self.capacity for key, value in zip(old_keys, old_values): if key is not None: self.put(key, value)"},{"question":"# Compression with Run-Length Encoding You are tasked with implementing a basic compression and decompression system using Run-Length Encoding (RLE), as demonstrated in the provided functions. **Objective**: Implement a function to compress a given string using RLE and a function to decompress an RLE compressed string back to its original format. # Function Specifications Function 1: `encode_rle(input: str) -> str` This function receives a string `input`, and returns its RLE encoded version. * **Input**: * A string `input` (1 ≤ len(input) ≤ 10^6), which consists of alphanumeric characters and/or symbols. * **Output**: * A string representing the compressed version of `input` using RLE. **Example**: ```python encode_rle(\\"aaaabbbcc\\") # Output: \\"4a3b2c\\" encode_rle(\\"abcd\\") # Output: \\"1a1b1c1d\\" ``` Function 2: `decode_rle(input: str) -> str` This function receives a string `input` in an RLE compressed format and returns its original decompressed format. * **Input**: * A string `input` containing the RLE compressed data (1 ≤ len(input) ≤ 10^6). * It is guaranteed that the `input` is correctly formatted according to RLE specifications. * **Output**: * A string representing the decompressed version of the `input`. **Example**: ```python decode_rle(\\"4a3b2c\\") # Output: \\"aaaabbbcc\\" decode_rle(\\"1a1b1c1d\\") # Output: \\"abcd\\" ``` # Constraints * The encoded string should be valid and correctly formatted. * Pay attention to edge cases such as empty strings or strings without any repetitions. * Ensure efficiency with the time and space complexity within the problem constraints. # Scenario Imagine you\'ve been hired by a company with a primitive file storage system to implement a simple and efficient data compression mechanism to save storage space for their textual data files. Your task is to apply the Run-Length Encoding technique to compress and later retrieve the data efficiently. Good luck, and happy coding!","solution":"def encode_rle(input: str) -> str: Encodes the input string using Run-Length Encoding (RLE). Args: input (str): The input string to encode. Returns: str: The RLE encoded string. if not input: return \\"\\" encoded_string = [] current_char = input[0] count = 1 for char in input[1:]: if char == current_char: count += 1 else: encoded_string.append(f\\"{count}{current_char}\\") current_char = char count = 1 # Append the last set of characters encoded_string.append(f\\"{count}{current_char}\\") return \'\'.join(encoded_string) def decode_rle(input: str) -> str: Decodes the RLE encoded string back to its original format. Args: input (str): The RLE encoded string. Returns: str: The original decoded string. if not input: return \\"\\" decoded_string = [] count = 0 for char in input: if char.isdigit(): count = count * 10 + int(char) else: decoded_string.append(char * count) count = 0 return \'\'.join(decoded_string)"},{"question":"# Scenario: You have a stack representing a sequence of integers, and you need to design a function that removes all occurrences of the smallest value, keeping the relative order of other elements intact. For this, you need to implement an optimal algorithm using an auxiliary stack or any additional data structure. # Function Signature: ```python def remove_min_elements(stack: List[int]) -> List[int]: pass ``` # Input: - `stack`: A list of integers representing a stack, where the last element in the list is the top of the stack. Example: [2, 8, 3, -6, 7, 3] # Output: - A list of integers representing the stack after removal of all occurrences of the smallest element, with the order of other elements maintained. # Constraints: - You can assume the stack will contain at most 10^4 elements. - The stack can contain negative integers. - The stack can be empty. - Minimize the use of additional space if possible. # Requirements: - Your implementation should have a time complexity of O(n). - Your implementation should handle edge cases such as an empty stack gracefully. - The solution should aim to minimize additional memory usage while respecting the constraints. # Examples: ```python assert remove_min_elements([2, 8, 3, -6, 7, 3]) == [2, 8, 3, 7, 3] assert remove_min_elements([1, 2, 3, 4, 5]) == [2, 3, 4, 5] assert remove_min_elements([5, 4, 3, 2, 1]) == [5, 4, 3, 2] assert remove_min_elements([2, 2, 2, 2]) == [] assert remove_min_elements([]) == [] assert remove_min_elements([-1, -1, -1, 3]) == [3] ``` Your task is to implement the function `remove_min_elements` that satisfies the given requirements and constraints.","solution":"from typing import List def remove_min_elements(stack: List[int]) -> List[int]: if not stack: return stack min_value = min(stack) result_stack = [element for element in stack if element != min_value] return result_stack"},{"question":"# Context You are tasked with implementing the core operations for a Binary Search Tree (BST) data structure to demonstrate understanding of algorithms and data structures. The BST should support insertion, deletion, search, and in-order traversal operations. # Task Implement a BinarySearchTree class with the following methods: 1. `insert(val: int) -> None`: Inserts a value into the BST. 2. `delete(val: int) -> None`: Deletes a value from the BST if it exists. 3. `search(val: int) -> bool`: Returns `True` if the value exists in the BST, otherwise returns `False`. 4. `in_order_traversal() -> List[int]`: Returns a list of all values in the BST in ascending order. # Input/Output format * `insert(val: int)`: Inserts a value `val` into the BST. Does not return any value. * `delete(val: int)`: Deletes a value `val` from the BST if it exists. Does not return any value. * `search(val: int) -> bool`: Returns `True` if `val` exists in the BST, otherwise returns `False`. * `in_order_traversal() -> List[int]`: Returns a list of all values in the BST in ascending order. # Constraints * The values inserted into the BST will be integers. * The number of operations (insert, delete, search) will be in the range `[1, 10^4]`. # Performance Requirements * The implementation should ensure a reasonable average-case performance for insert, delete, and search operations. * The tree should handle balanced insertions and deletions to prevent degeneration. # Example ```python bst = BinarySearchTree() bst.insert(5) bst.insert(3) bst.insert(7) bst.insert(2) bst.insert(4) # After insertion, the BST should have the following structure: # 5 # / # 3 7 # / # 2 4 assert bst.search(3) == True assert bst.search(6) == False bst.delete(3) # After deletion, the BST should have the following structure: # 5 # / # 4 7 # / # 2 assert bst.search(3) == False assert bst.search(4) == True assert bst.in_order_traversal() == [2, 4, 5, 7] ```","solution":"class TreeNode: def __init__(self, key): self.left = None self.right = None self.val = key class BinarySearchTree: def __init__(self): self.root = None def insert(self, key: int) -> None: if self.root is None: self.root = TreeNode(key) else: self._insert(self.root, key) def _insert(self, node, key): if key < node.val: if node.left is None: node.left = TreeNode(key) else: self._insert(node.left, key) else: if node.right is None: node.right = TreeNode(key) else: self._insert(node.right, key) def delete(self, key: int) -> None: self.root = self._delete(self.root, key) def _delete(self, node, key): if node is None: return node if key < node.val: node.left = self._delete(node.left, key) elif key > node.val: node.right = self._delete(node.right, key) else: if node.left is None: return node.right elif node.right is None: return node.left temp = self._minValueNode(node.right) node.val = temp.val node.right = self._delete(node.right, temp.val) return node def _minValueNode(self, node): current = node while current.left is not None: current = current.left return current def search(self, key: int) -> bool: return self._search(self.root, key) def _search(self, node, key): if node is None: return False if node.val == key: return True elif key < node.val: return self._search(node.left, key) else: return self._search(node.right, key) def in_order_traversal(self): result = [] self._in_order_traversal(self.root, result) return result def _in_order_traversal(self, node, result): if node: self._in_order_traversal(node.left, result) result.append(node.val) self._in_order_traversal(node.right, result)"},{"question":"# Scenario You are working in a company that needs to frequently sort small datasets of employee IDs for quick lookups. You decide to implement an insertion sort algorithm due to its simplicity and efficiency on small datasets. # Problem Statement Implement the `insertion_sort` function that sorts an array of integers using the insertion sort algorithm. # Function Signature ```python def insertion_sort(arr: list) -> list: Sorts a list of integers using the insertion sort algorithm. Parameters: arr (list): A list of integers to be sorted. Returns: list: The sorted list of integers. ``` # Input * A list of integers `arr` with a length n (0 <= n <= 1000). # Output * Return a sorted list of integers. # Constraints * The list may contain duplicate elements. * Optimize the code for best performance under the array sizes provided. # Example ```python input: [5, 2, 9, 1, 5, 6] output: [1, 2, 5, 5, 6, 9] input: [3, 0, -3, 8, 7, 1] output: [-3, 0, 1, 3, 7, 8] input: [] output: [] input: [10] output: [10] ``` # Requirements * Your implementation should pass a range of test cases, including edge cases and varied lengths of arrays.","solution":"def insertion_sort(arr: list) -> list: Sorts a list of integers using the insertion sort algorithm. Parameters: arr (list): A list of integers to be sorted. Returns: list: The sorted list of integers. for i in range(1, len(arr)): key = arr[i] j = i - 1 while j >= 0 and key < arr[j]: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key return arr"},{"question":"# Permutations - Coding Assessment Question Objective Write a function to generate all possible permutations of a given list of distinct numbers. Your function should return these permutations as a list of lists. Additionally, write a generator function that yields each permutation one at a time. Function Signature ```python def generate_permutations(nums: List[int]) -> List[List[int]]: pass def generate_permutations_iter(nums: List[int]) -> Iterator[List[int]]: pass ``` Input * A list of distinct numbers `nums` with length `n` where `0 <= n <= 8`. Output * `generate_permutations(nums)`: Returns a list of lists, each inner list representing a permutation of the input list. * `generate_permutations_iter(nums)`: Returns an iterator that yields each permutation of the input list one at a time. Example ```python Input: nums = [1, 2, 3] Output: generate_permutations(nums) should return: [ [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1] ] generate_permutations_iter(nums) should yield in some order: [1, 2, 3] [1, 3, 2] [2, 1, 3] [2, 3, 1] [3, 1, 2] [3, 2, 1] ``` Constraints * You must not use existing libraries to generate permutations. * You must handle edge cases like empty lists and single-element lists. * Consider performance implications and avoid unnecessary computations. Scenario Consider a scenario where you are developing a feature for a puzzle-solving application. This feature requires generating all possible configurations of a given set of unique tiles. Implement the function to accommodate this requirement and ensure it is efficient enough for small input sizes typically used in puzzles.","solution":"from typing import List, Iterator def generate_permutations(nums: List[int]) -> List[List[int]]: Generate all possible permutations of a list of distinct numbers. if not nums: return [[]] result = [] def backtrack(path, remaining): if not remaining: result.append(path) for i in range(len(remaining)): backtrack(path + [remaining[i]], remaining[:i] + remaining[i+1:]) backtrack([], nums) return result def generate_permutations_iter(nums: List[int]) -> Iterator[List[int]]: Generator function to yield permutations of a list of distinct numbers one at a time. if not nums: yield [] return def backtrack(path, remaining): if not remaining: yield path for i in range(len(remaining)): yield from backtrack(path + [remaining[i]], remaining[:i] + remaining[i+1:]) yield from backtrack([], nums)"},{"question":"You are tasked with implementing a function to rotate an array of `n` elements to the right by `k` steps. # Function Signature: ```python def rotate_array(array: List[int], k: int) -> List[int]: Rotate the entire array \'k\' times to the right :param array: List[int] - Array of integers to be rotated :param k: int - Number of steps to rotate to the right :return: List[int] - The rotated array ``` # Input: - `array`: A list of integers where `1 <= len(array) <= 10^5`. - `k`: A non-negative integer where `0 <= k <= 10^9`. # Output: - Returns the array after rotating it by `k` steps to the right. # Constraints: - Optimize the function to handle large values of `n` and `k`. - Minimize the use of additional memory. # Examples: ```python assert rotate_array([1, 2, 3, 4, 5, 6, 7], 3) == [5, 6, 7, 1, 2, 3, 4] assert rotate_array([-1, -100, 3, 99], 2) == [3, 99, -1, -100] assert rotate_array([1, 2], 0) == [1, 2] assert rotate_array([1, 2], 2) == [1, 2] ``` # Additional Information: - Think about how you can optimize the rotations. - Describe any edge cases you considered for your solution. - You are encouraged to use any approach discussed in the code snippets or come up with a new efficient solution.","solution":"def rotate_array(array, k): Rotate the entire array \'k\' times to the right :param array: List[int] - Array of integers to be rotated :param k: int - Number of steps to rotate to the right :return: List[int] - The rotated array n = len(array) k = k % n # To handle cases where k is larger than the size of the array return array[-k:] + array[:-k]"},{"question":"Scenario You are working as a software engineer at a data analytics company. One of your tasks is to summarize ranges of sequential data points in sorted datasets without duplicates. Given an array of integers, your goal is to identify and represent the ranges of consecutive numbers. Task Write a function `summarize_ranges` that receives a list of sorted, non-duplicate integers and returns a list of ranges in the format \'start-end\' if the range contains more than one number, otherwise just the single number as a string. Function Signature ```python def summarize_ranges(array: List[int]) -> List[str]: ``` Input * `array (List[int])`: A sorted list of unique integers. Output * `List[str]`: A list of strings where each string represents a range or a single number. Example ```python # Example 1 array = [0, 1, 2, 4, 5, 7] # output: [\\"0-2\\", \\"4-5\\", \\"7\\"] # Example 2 array = [] # output: [] # Example 3 array = [3, 4, 5, 10, 11, 12, 20] # output: [\\"3-5\\", \\"10-12\\", \\"20\\"] ``` Constraints * All inputs will be sorted and contain unique integers. * The input list can have a length between 0 and 10^6. Guidelines * Ensure the function efficiently handles large input sizes up to the specified limit. * Properly manage edge cases like an empty array or a single-element array. Your task is to implement `summarize_ranges` following these requirements.","solution":"from typing import List def summarize_ranges(array: List[int]) -> List[str]: Given a sorted list of unique integers, summarizes the ranges of consecutive numbers. if not array: return [] ranges = [] start = array[0] for i in range(1, len(array)): if array[i] != array[i-1] + 1: if start == array[i-1]: ranges.append(f\\"{start}\\") else: ranges.append(f\\"{start}-{array[i-1]}\\") start = array[i] if start == array[-1]: ranges.append(f\\"{start}\\") else: ranges.append(f\\"{start}-{array[-1]}\\") return ranges"},{"question":"Problem Statement: You are given a number as input. Your task is to write a function that returns the next larger number that can be formed using the same set of digits within the input number. If no such larger number exists, your function should return -1. Input: * An integer `num` (1 ≤ num ≤ 10^9) Output: * An integer representing the next larger number with the same set of digits, or `-1` if no such number exists. Examples: ```plaintext 1. next_bigger(38276) -> 38627 2. next_bigger(15552) -> 21555 3. next_bigger(999) -> -1 4. next_bigger(12345) -> 12354 5. next_bigger(54321) -> -1 ``` Function Signature: ```python def next_bigger(num: int) -> int: pass ``` Guideline: 1. Convert the number to its constituent digits. 2. Implement logic to find the rightmost pivot where the order breaks. 3. Swap to bring in the smallest larger digit to the pivot. 4. Reverse the part of the array from the pivot to achieve the next order. 5. Reconstruct and return the integer reflecting the next permutation.","solution":"def next_bigger(num: int) -> int: Returns the next bigger number using the same set of digits within the input number. If no such number exists, returns -1. digits = list(str(num)) # Step 1: Find the largest index i such that digits[i] is less than digits[i + 1]. for i in range(len(digits) - 2, -1, -1): if digits[i] < digits[i + 1]: break else: # If no such index exists, the digits are in descending order and we return -1. return -1 # Step 2: Find the largest index j greater than i such that digits[i] is less than digits[j]. for j in range(len(digits) - 1, i, -1): if digits[i] < digits[j]: break # Step 3: Swap digits[i] and digits[j]. digits[i], digits[j] = digits[j], digits[i] # Step 4: Reverse the part of the array from i+1 to end. digits = digits[:i + 1] + digits[i + 1:][::-1] # Step 5: Reconstruct the number and return. return int(\\"\\".join(digits))"},{"question":"Context You are tasked with designing a process scheduler for a multi-threaded application. To prevent deadlocks, you need to detect if the resource allocation graph contains cycles. This will help ensure that the scheduling system does not enter an indefinite wait state. Problem Statement Write a function `is_deadlock_free(process_graph)` that determines if the given directed graph contains a cycle. This graph represents processes as vertices and resource dependencies as directed edges. Function Signature ```python def is_deadlock_free(process_graph: dict) -> bool: Determines if the directed graph representing processes and resource dependencies is free from cycles. :param process_graph: A dictionary where keys are process names (strings) and values are lists of processes (strings) that the key process depends on. Example: process_graph = { \'P1\': [\'P2\', \'P3\'], \'P2\': [\'P4\'], \'P3\': [\'P6\'], \'P4\': [\'P5\', \'P6\'], \'P5\': [\'P2\'], \'P6\': [] } :return: True if there are no cycles (deadlock free), False otherwise. pass ``` Constraints * The process graph dictionary will only contain string keys and lists of string values. * The total number of processes (vertices) will not exceed 1000. * The graph can be empty, in which case it should return `True`. Performance Requirements * Your solution should run in O(V + E) time complexity, where V is the number of vertices and E is the number of edges. * Space complexity should be O(V) to store the traversal states of each vertex. Edge Cases to Consider 1. An empty graph should return `True`. 2. A graph with a single vertex should return `True` if it has no self-loop, and `False` if it does. 3. Graphs with complex cycles and multiple disconnected components. Example ```python # Test Case 1 process_graph = { \'P1\': [\'P2\', \'P3\'], \'P2\': [\'P4\'], \'P3\': [\'P6\'], \'P4\': [\'P5\', \'P6\'], \'P5\': [\'P2\'], \'P6\': [] } # Expected Output: False (There is a cycle involving P2, P4, and P5) # Test Case 2 process_graph = { \'T1\': [\'T2\'], \'T2\': [\'T3\'], \'T3\': [] } # Expected Output: True (No cycles present) ``` Using the above function signature, implement the `is_deadlock_free` function. Your solution should accurately determine if the process graph contains a cycle.","solution":"def is_deadlock_free(process_graph): Determines if the directed graph representing processes and resource dependencies is free from cycles. :param process_graph: A dictionary where keys are process names (strings) and values are lists of processes (strings) that the key process depends on. :return: True if there are no cycles (deadlock free), False otherwise. def dfs(node, visited, rec_stack): visited[node] = True rec_stack[node] = True for neighbor in process_graph.get(node, []): if not visited.get(neighbor, False): if dfs(neighbor, visited, rec_stack): return True elif rec_stack.get(neighbor, False): return True rec_stack[node] = False return False visited = {} rec_stack = {} for process in process_graph: if not visited.get(process, False): if dfs(process, visited, rec_stack): return False return True"},{"question":"**Question**: Suppose you are developing a cryptographic application that needs to compute the modular inverse for secure key generation. Given two numbers, you need to implement the computation of the coefficients of Bézout\'s identity using the Extended Euclidean Algorithm. **Task**: Write a function `extended_gcd(num1, num2)` that takes two positive integers `num1` and `num2` and returns three values (s), (t), and (g). The values represent: 1. (s) and (t) such that (num1 cdot s + num2 cdot t = g) 2. (g) being the greatest common divisor (GCD) of `num1` and `num2`. # Function Signature ```python def extended_gcd(num1: int, num2: int) -> (int, int, int): ``` # Input - `num1`: A positive integer ((1 leq num1 leq 10^9)) - `num2`: A positive integer ((1 leq num2 leq 10^9)) # Output - Returns a tuple of three integers: ((s, t, g)) # Example ```python s, t, g = extended_gcd(240, 46) print(s, t, g) # Output: 2, -11, 2 ``` # Constraints - Both `num1` and `num2` are positive integers. - The implemented solution must run efficiently for the given input range. # Edge Cases to Consider - Handling of non-integer and boundary input values is not necessary. - Inputs (num1, num2) where one is zero should not occur based on constraints. # Additional Details - The algorithm followed must be iterative. - Ensure correct handling of integer division and updating the coefficients.","solution":"def extended_gcd(num1, num2): Computes the coefficients of Bézout\'s identity and the greatest common divisor of num1 and num2 using the Extended Euclidean Algorithm. Returns a tuple (s, t, g) where: s and t are coefficients such that num1*s + num2*t = g g is the greatest common divisor of num1 and num2 x0, x1, y0, y1 = 1, 0, 0, 1 while num2 != 0: q, num1, num2 = num1 // num2, num2, num1 % num2 x0, x1 = x1, x0 - q * x1 y0, y1 = y1, y0 - q * y1 return x0, y0, num1"},{"question":"**Scenario**: You have been hired to improve the performance of a sorting application used mainly for small to medium-sized datasets. You decide to implement the Cocktail Shaker Sort algorithm because of its simplicity and stability. However, the application receives data that may sometimes be in reverse order or contain duplicates. **Problem Statement**: Write a function `cocktail_shaker_sort(arr: List[int]) -> List[int]` that takes an array of integers and sorts it in ascending order using the Cocktail Shaker Sort algorithm. Your function should handle the following conditions efficiently: **Input Format**: - A list of integers, `arr`, where `1 <= len(arr) <= 1000`. **Output Format**: - A new list of integers sorted in ascending order. **Constraints**: - The integers in the array range from -10^6 to 10^6. - The function should not use any built-in sorting methods. **Edge Cases**: - Handle empty arrays. - Arrays with all elements being the same. - Check behavior with arrays already sorted in ascending or descending order. **Performance Requirements**: - Ensure that the function performs efficiently for the given constraints. **Example**: ```python assert cocktail_shaker_sort([3, 2, 1]) == [1, 2, 3] assert cocktail_shaker_sort([1, 2, 3]) == [1, 2, 3] assert cocktail_shaker_sort([5, -2, 5, 7, -2, 0]) == [-2, -2, 0, 5, 5, 7] assert cocktail_shaker_sort([]) == [] assert cocktail_shaker_sort([2]) == [2] ``` Implement the function `cocktail_shaker_sort` in the following cell.","solution":"from typing import List def cocktail_shaker_sort(arr: List[int]) -> List[int]: Sorts an array of integers using the Cocktail Shaker Sort algorithm. Args: arr (List[int]): The list of integers to be sorted. Returns: List[int]: The sorted list of integers. n = len(arr) if n <= 1: return arr start = 0 end = n - 1 is_swapped = True while is_swapped: is_swapped = False # Traverse from left to right for i in range(start, end): if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] is_swapped = True # If no elements were swapped, then the array is sorted if not is_swapped: break # Otherwise, reset the swapped flag and traverse from right to left is_swapped = False end -= 1 for i in range(end, start, -1): if arr[i] < arr[i - 1]: arr[i], arr[i - 1] = arr[i - 1], arr[i] is_swapped = True start += 1 return arr"},{"question":"# Coin Change Combination Count Context You are designing a vending machine that can return change for any given amount using a set of coin denominations. To ensure the machine can handle this efficiently, you need to determine the total number of ways to make change for a specific amount using a provided set of coin denominations. Problem Statement Write a function `count(coins, value)` that calculates the number of ways to make change for a given `value` using the available coin denominations in `coins`. The order of the coins in combination does not matter. Input * `coins` : List of integers representing the coin denominations available. (1 <= |coins| <= 50) * `value` : An integer representing the amount of change required. (0 <= value <= 5000) Output * Return an integer representing the number of ways to make change for the `value` using the specified `coins`. Constraints * Coin denominations are unique positive integers. * The function should efficiently handle the given constraints in terms of time and space complexity. Example * Example 1: ```python coins = [1, 2, 3] value = 4 ``` Output: 4 Explanation: The four solutions are [1, 1, 1, 1], [1, 1, 2], [2, 2], [1, 3]. * Example 2: ```python coins = [2, 5, 3, 6] value = 10 ``` Output: 5 Explanation: The five solutions are [2, 2, 2, 2, 2], [2, 2, 3, 3], [2, 2, 6], [2, 3, 5], [5, 5]. Function Signature ```python def count(coins: List[int], value: int) -> int: # Implementation here ``` Notes * You should use a bottom-up dynamic programming approach to build a solution efficiently. * Pay attention to edge cases, particularly when `value` is 0 or the list `coins` is empty.","solution":"def count(coins, value): Calculate the number of ways to make change for a given value using available coin denominations :param coins: List of coin denominations available :param value: Integer value to make change for :return: Integer number of ways to make change # Initialize dp array where dp[i] means number of ways to get amount i dp = [0] * (value + 1) dp[0] = 1 # There is one way to make 0 amount i.e., no coin for coin in coins: for v in range(coin, value + 1): dp[v] += dp[v - coin] return dp[value]"},{"question":"Context You are working as part of a team that deals with highly optimized search algorithms in large datasets. A common scenario you come across is working with sorted arrays that are rotated at an unknown index. For a submodule in your project, your task is to efficiently find the minimum element in these rotated arrays to maintain data integrity during processing. Task Write a function to find the minimum element in a rotated sorted array. Utilize an efficient algorithm with a time complexity of O(log N), given that the array does not contain any duplicates and originally was sorted in ascending order before an unknown rotation. Specification - **Function Name**: `find_min_rotate` - **Input Format**: A list of integers `array` (0 < length <= 10^4) which is sorted and rotated at an unknown index. - **Output Format**: An integer representing the minimum element in the array. Constraints 1. The input array is non-empty. 2. No duplicate elements are in the array. Examples ```python assert find_min_rotate([4, 5, 6, 7, 0, 1, 2]) == 0 assert find_min_rotate([3, 4, 5, 1, 2]) == 1 assert find_min_rotate([1]) == 1 ``` Notes - Consider edge cases such as when the input array is already sorted (not rotated), contains a single element, or reaches the pivot point immediately.","solution":"def find_min_rotate(array): Finds the minimum element in a rotated sorted array. Parameters: array (List[int]): A list of integers representing the rotated sorted array. Returns: int: The minimum element in the array. left, right = 0, len(array) - 1 while left < right: mid = (left + right) // 2 if array[mid] > array[right]: left = mid + 1 else: right = mid return array[left]"},{"question":"# Question: Implement a Max-Priority Queue Using a Binary Heap Implement a Max-Priority Queue class using a binary heap. This implementation should include methods to insert an item with a priority, extract the item with the highest priority, and get the current size of the priority queue. Requirements: 1. **Insertion** method should be efficient with a time complexity of O(log n). 2. **Extraction** method should remove and return the item with the highest priority, which should also be O(log n). 3. **Size** method to get the current number of items in the queue. 4. Proper handling of edge cases such as extracting from an empty queue. Expected Input/Output * The PriorityQueue class should support the following operations: ```python class PriorityQueue: def __init__(self): # Initialize your data structure def push(self, item, priority): # Insert the item with the given priority def pop(self): # Remove and return the item with the highest priority def size(self): # Return the number of items in the queue ``` Constraints: * You may assume the item is hashable and has a valid comparison operation. * The priority will be an integer. * The queue can hold up to 10^5 items. Example ```python pq = PriorityQueue() pq.push(\'task1\', 3) pq.push(\'task2\', 5) pq.push(\'task3\', 1) print(pq.pop()) # Output: \'task2\' print(pq.size()) # Output: 2 ``` Implement the **PriorityQueue** class according to the specifications provided.","solution":"import heapq class PriorityQueue: def __init__(self): self.heap = [] def push(self, item, priority): # We use a negative priority to simulate a max-heap with heapq (since it is a min-heap) heapq.heappush(self.heap, (-priority, item)) def pop(self): if self.size() > 0: return heapq.heappop(self.heap)[1] else: raise IndexError(\'pop from an empty priority queue\') def size(self): return len(self.heap)"},{"question":"# Scenario A medical emergency room\'s management system must use a priority queue to ensure patients with more severe conditions are treated first. The severity of a patient\'s condition is given as a priority while being inserted into the queue: higher severity (numerically larger) should be treated first. # Implement Priority Queue with Custom Print Function Implement a PriorityQueue class which should have: 1. An `__init__` method. 2. A `push` method to add elements to the queue with prioritization. 3. A `pop` method to remove and return the patient with the highest severity. 4. A `size` method to get the total number of patients. 5. A `print_queue` method to print the queue in the format `[(data_1, priority_1), (data_2, priority_2), ...]`. # Function Specifications 1. `def __init__(self, items=None, priorities=None)` - Initializes the priority queue, analogous to the provided code snippet. 2. `def push(self, item, priority=None)` - Inserts the `item` with given `priority`. If `priority` is None, use `item` as the priority. 3. `def pop(self)` - Removes and returns the element with the highest priority. 4. `def size(self)` - Returns the number of elements in the queue. 5. `def print_queue(self)` - Returns a string representation in form `[(data_1, priority_1), ...]`. # Example ```python # Create instances pq = PriorityQueue() # Push elements pq.push(\\"patient_1\\", 5) pq.push(\\"patient_2\\", 10) pq.push(\\"patient_3\\", 1) # Size of priority queue print(pq.size()) # Outputs: 3 # Printing the queue pq.print_queue() # Should output: [(patient_2, 10), (patient_1, 5), (patient_3, 1)] # Popping the highest priority print(pq.pop()) # Outputs: patient_2 # Printing the queue after popping pq.print_queue() # Should output: [(patient_1, 5), (patient_3, 1)] ``` # Constraints - Assume all priorities are distinct integers. - Aim for a correct, structured solution focused on demonstrating understanding of priority queues.","solution":"import heapq class PriorityQueue: def __init__(self): self._queue = [] self._index = 0 def push(self, item, priority): heapq.heappush(self._queue, (-priority, self._index, item)) self._index += 1 def pop(self): return heapq.heappop(self._queue)[-1] def size(self): return len(self._queue) def print_queue(self): queue_representation = [(item, -priority) for priority, index, item in self._queue] sorted_queue = sorted(queue_representation, key=lambda x: (-x[1], x[0])) return str(sorted_queue)"},{"question":"# 2-SAT Problem Solver Context In this problem, you are given a boolean formula in Conjunctive Normal Form (2-CNF), which implies that each clause contains exactly two literals. You need to determine whether it is possible to assign boolean values (True/False) to the variables in such a way that all clauses are satisfied. A literal is either a variable itself or its negation. For example, `(x)` and `(~x)` are literals involving variable `x`. Problem Statement Given a list of clauses, where each clause is a tuple containing two literals, implement a function `solve_2SAT(formula)` that returns a dictionary containing the boolean assignments for each variable that satisfies the formula, if such an assignment exists. If there is no satisfying assignment, the function should return `None`. Input Format * `formula`: A list of clauses, where each clause is represented as a tuple of two literals. Each literal is expressed as `(variable, is_negated)`: * `variable`: A string representing the variable\'s name. * `is_negated`: A boolean value indicating if the variable is negated (`True` for negation, `False` for non-negated). Output Format * A dictionary where the keys are variable names (strings), and the values are their assigned boolean values (True/False). If no satisfying assignment exists, return `None`. Constraints * The formula is a list of clauses in 2-CNF form. * Each variable is a string of alphanumeric characters. * The formula can contain at most 10^5 variables and 10^5 clauses. Example ```python formula = [((\'x\', False), (\'y\', False)), ((\'y\', True), (\'z\', True)), ((\'z\', False), (\'x\', True))] result = solve_2SAT(formula) # Expected output: {\'x\': True, \'y\': True, \'z\': False} or some equivalent satisfying assignment. formula = [((\'x\', False), (\'y\', False)), ((\'x\', True), (\'y\', False)), ((\'y\', True), (\'x\', False)), ((\'y\', True), (\'x\', True))] result = solve_2SAT(formula) # Expected output: None (No satisfying assignment exists). ```","solution":"def solve_2SAT(formula): from collections import defaultdict, deque def variable_index(variable, negated, num_vars): return 2 * variable + int(negated) n = sum(len(set(clause)) for clause in formula) variable_ids = {} id_counter = 0 for clause in formula: for literal in clause: var, _ = literal if var not in variable_ids: variable_ids[var] = id_counter id_counter += 1 num_vars = len(variable_ids) graph = [[] for _ in range(2 * num_vars)] reverse_graph = [[] for _ in range(2 * num_vars)] for clause in formula: (var1, neg1), (var2, neg2) = clause v1_id = variable_ids[var1] v2_id = variable_ids[var2] graph[variable_index(v1_id, not neg1, num_vars)].append(variable_index(v2_id, neg2, num_vars)) graph[variable_index(v2_id, not neg2, num_vars)].append(variable_index(v1_id, neg1, num_vars)) reverse_graph[variable_index(v2_id, neg2, num_vars)].append(variable_index(v1_id, not neg1, num_vars)) reverse_graph[variable_index(v1_id, neg1, num_vars)].append(variable_index(v2_id, not neg2, num_vars)) def strongly_connected_components(graph): index = [None] * len(graph) lowlink = [None] * len(graph) on_stack = [False] * len(graph) stack = [] sccs = [] def strong_connect(node, idx_counter=[0]): index[node] = idx_counter[0] lowlink[node] = idx_counter[0] idx_counter[0] += 1 stack.append(node) on_stack[node] = True for neighbor in graph[node]: if index[neighbor] is None: strong_connect(neighbor) lowlink[node] = min(lowlink[node], lowlink[neighbor]) elif on_stack[neighbor]: lowlink[node] = min(lowlink[node], index[neighbor]) if lowlink[node] == index[node]: scc = [] while True: w = stack.pop() on_stack[w] = False scc.append(w) if w == node: break sccs.append(scc) for i in range(len(graph)): if index[i] is None: strong_connect(i) return sccs sccs = strongly_connected_components(graph) component = [-1] * (2 * num_vars) for i, scc in enumerate(sccs): for node in scc: component[node] = i assignment = {} for var in variable_ids: var_id = variable_ids[var] if component[2 * var_id] == component[2 * var_id + 1]: return None assignment[var] = component[2 * var_id] < component[2 * var_id + 1] return assignment"},{"question":"**Problem Statement:** Implement a function `is_anagram` that takes two strings `s` and `t` as input and returns `True` if `t` is an anagram of `s`, and `False` otherwise. An anagram of a string is another string that contains the same characters, only the order of characters can be different. # Input Format: * Two strings, `s` and `t`. # Output Format: * A boolean value (`True` or `False`). # Constraints: * The strings contain only lowercase alphabets. * Size of the strings should be `1 <= s.length, t.length <= 10^5`. # Performance Requirements: * The function must run in linear time, O(n), where `n` is the length of the strings. * The space complexity must be O(1) with respect to the size of the alphabet or O(n) otherwise. # Examples: Example 1: * **Input**: s = \\"anagram\\", t = \\"nagaram\\" * **Output**: True Example 2: * **Input**: s = \\"rat\\", t = \\"car\\" * **Output**: False # Implementation Guidelines: 1. Assume the strings contain only lowercase alphabets. 2. Utilize a single hash map to count characters from `s` while decrementing counts as you parse `t`. 3. If the lengths of the two strings do not match, return `False` immediately. 4. Traverse the character counts to ensure all counts end at zero for a valid anagram. Implement the function `is_anagram(s: str, t: str) -> bool`: ```python def is_anagram(s, t): if len(s) != len(t): return False char_count = {} for char in s: char_count[char] = char_count.get(char, 0) + 1 for char in t: if char not in char_count: return False char_count[char] -= 1 if char_count[char] < 0: return False return all(value == 0 for value in char_count.values()) # Example Usage print(is_anagram(\\"anagram\\", \\"nagaram\\")) # Output: True print(is_anagram(\\"rat\\", \\"car\\")) # Output: False ```","solution":"def is_anagram(s, t): if len(s) != len(t): return False # Initialize a dictionary to count characters char_count = {} # Count each character in the first string for char in s: char_count[char] = char_count.get(char, 0) + 1 # Decrease count for each character found in the second string for char in t: if char not in char_count: return False char_count[char] -= 1 if char_count[char] < 0: return False # Ensure all counts are zero return all(value == 0 for value in char_count.values()) # Example Usage #print(is_anagram(\\"anagram\\", \\"nagaram\\")) # Output: True #print(is_anagram(\\"rat\\", \\"car\\")) # Output: False"},{"question":"You are a security expert tasked with implementing a simplified version of a secure communication protocol using the Diffie-Hellman key exchange method. Your goal is to create a Python function that performs the following: 1. Generates private and public keys for two entities, Alice and Bob. 2. Computes the shared secret key using the Diffie-Hellman key exchange algorithm. # Function Definition ```python def diffie_hellman_key_exchange(a: int, p: int) -> bool: Perform Diffie-Hellman key exchange. :param a: An integer representing the primitive root of p. :param p: A large prime number. :return: True if the shared keys match, False otherwise. pass ``` # Input - Two integers, `a` and `p`, where `a` is the primitive root of `p` and `p` is a large prime number. # Output - A boolean value `True` if the shared keys computed by Alice and Bob match, `False` otherwise. # Constraints - Assume `a` is already validated as the primitive root of `p`. - Assume `p` is validated as a large prime number. # Explanation 1. **Private Keys**: - Alice generates a private key `a_pr_k` randomly within the range [1, p-1). - Bob generates a private key `b_pr_k` randomly within the range [1, p-1). 2. **Public Keys**: - Alice computes her public key `a_pu_k` as `a^a_pr_k % p`. - Bob computes his public key `b_pu_k` as `a^b_pr_k % p`. 3. **Shared Secret Keys**: - Alice computes the shared key `a_sh_k` using Bob\'s public key: `b_pu_k^a_pr_k % p`. - Bob computes the shared key `b_sh_k` using Alice\'s public key: `a_pu_k^b_pr_k % p`. 4. **Comparison**: - The function returns `True` if `a_sh_k` equals `b_sh_k`, otherwise it returns `False`. # Example ```python >>> diffie_hellman_key_exchange(5, 23) True ``` # Note - Use Python\'s built-in functions and libraries where necessary. - Focus on correct implementation and handling of edge cases.","solution":"import random def diffie_hellman_key_exchange(a: int, p: int) -> bool: Perform Diffie-Hellman key exchange. :param a: An integer representing the primitive root of p. :param p: A large prime number. :return: True if the shared keys match, False otherwise. a_pr_k = random.randint(1, p - 1) # Alice\'s private key b_pr_k = random.randint(1, p - 1) # Bob\'s private key # Compute public keys a_pu_k = pow(a, a_pr_k, p) b_pu_k = pow(a, b_pr_k, p) # Compute shared keys a_sh_k = pow(b_pu_k, a_pr_k, p) b_sh_k = pow(a_pu_k, b_pr_k, p) # Return whether the shared keys match return a_sh_k == b_sh_k"},{"question":"# Coding Challenge: Maximum Key Retrieval in B-Tree Objective Implement a function to find and return the maximum key in a B-tree. This function should utilize the existing `Node` and `BTree` classes provided and correctly traverse the tree to find the maximum key. Details * **Function Signature**: ```python def find_max_key(btree: BTree) -> int: ``` * **Expected Input**: * `btree`: An instance of the `BTree` class with nodes potentially containing keys. * **Expected Output**: * An integer representing the maximum key present in the B-tree. * **Constraints**: * Assume the B-tree is properly initialized and contains at least one key. * The keys within each node are distinct integers. Requirements * The solution should traverse the right-most path from the root to find the maximum key. * Maintain the log(n) time complexity characteristic of B-trees. * Handle possible edge cases including: * Tree with a single node. * Tree with varying depths. Example ```python # Constructing a B-tree btree = BTree(t_val=3) keys_to_insert = [10, 20, 5, 6, 12, 30, 7, 17] for key in keys_to_insert: btree.insert_key(key) # Finding the maximum key max_key = find_max_key(btree) print(max_key) # Output should be 30 ``` Implementation Write the function `find_max_key` based on the `BTree` class provided. Good luck!","solution":"class Node: def __init__(self, t, leaf=False): self.t = t self.leaf = leaf self.keys = [] self.children = [] class BTree: def __init__(self, t): self.t = t self.root = Node(t, True) def insert_key(self, k): root = self.root if len(root.keys) == (2 * self.t) - 1: temp = Node(self.t) self.root = temp temp.children.append(root) self._split_child(temp, 0) self._insert_non_full(temp, k) else: self._insert_non_full(root, k) def _split_child(self, parent, i): t = self.t y = parent.children[i] z = Node(t, y.leaf) parent.children.insert(i + 1, z) parent.keys.insert(i, y.keys[t - 1]) z.keys = y.keys[t: (2 * t) - 1] y.keys = y.keys[0: t - 1] if not y.leaf: z.children = y.children[t: 2 * t] y.children = y.children[0: t] def _insert_non_full(self, node, k): i = len(node.keys) - 1 if node.leaf: node.keys.append(0) while i >= 0 and k < node.keys[i]: node.keys[i + 1] = node.keys[i] i -= 1 node.keys[i + 1] = k else: while i >= 0 and k < node.keys[i]: i -= 1 i += 1 if len(node.children[i].keys) == (2 * self.t) - 1: self._split_child(node, i) if k > node.keys[i]: i += 1 self._insert_non_full(node.children[i], k) def find_max_key(btree: BTree) -> int: current_node = btree.root while not current_node.leaf: current_node = current_node.children[-1] return current_node.keys[-1]"},{"question":"Path Sum Checker in a Binary Tree Given a binary tree, implement a function `has_path_sum(root, target_sum)` that determines if the tree has a root-to-leaf path such that the sum of the values along the path equals the given sum. # Function Signature ```python def has_path_sum(root: TreeNode, target_sum: int) -> bool: ``` # Input - `root`: The root node of the binary tree (can be None for an empty tree). - `target_sum`: An integer representing the target path sum. # Output - Returns `True` if there is a root-to-leaf path with the sum equal to `target_sum`, otherwise returns `False`. # Constraints - The binary tree may contain negative, zero, or positive integer values. - The binary tree nodes are defined as follows: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` - The solution should handle large trees efficiently. # Examples Example 1 ```text Input: root = [5,4,8,11,null,13,4,7,2,null,null,null,1], target_sum = 22 Output: True Explanation: The root-to-leaf path with the sum of 22 is [5,4,11,2]. ``` Example 2 ```text Input: root = [1,2,3], target_sum = 5 Output: False Explanation: There are no root-to-leaf paths that sum to 5. ``` Example 3 ```text Input: root = [1,2], target_sum = 1 Output: False Explanation: There are no root-to-leaf paths that sum to 1. ``` # Notes - Use recursive and iterative traversal methods to formulate your solution. - Ensure edge cases such as an empty tree and single node trees are covered in your implementation.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def has_path_sum(root: TreeNode, target_sum: int) -> bool: if not root: return False # Check if we are at a leaf node if not root.left and not root.right: return root.val == target_sum # Subtract the current node\'s value from the target sum remaining_sum = target_sum - root.val # Recur for the left and right subtree return has_path_sum(root.left, remaining_sum) or has_path_sum(root.right, remaining_sum)"},{"question":"You are given an array of integers; you need to implement a function that filters this array based on provided minimum and maximum limits. The function should return a new array that includes only those elements of the original array that lie within the specified range, inclusive of the limits. Function Signature ```python def limit(arr: List[int], min_lim: Optional[int]=None, max_lim: Optional[int]=None) -> List[int]: Filters the input array to include only elements between min_lim and max_lim inclusive. Parameters: arr (List[int]): The input list of integers. min_lim (Optional[int]): The minimum limit. Defaults to the minimum element of the array if not provided. max_lim (Optional[int]): The maximum limit. Defaults to the maximum element of the array if not provided. Returns: List[int]: A list with elements within the specified range. ``` Examples ```python assert limit([1, 2, 3, 4, 5], None, 3) == [1, 2, 3] assert limit([1, 2, 3, 4, 5], 2, None) == [2, 3, 4, 5] assert limit([10, 20, 30, 40, 50], 15, 45) == [20, 30, 40] assert limit([], 10, 20) == [] ``` Constraints * If `min_lim` is None, assume the min limit to be the smallest element in the array. * If `max_lim` is None, assume the max limit to be the largest element in the array. * If `arr` is empty, the function should return an empty list. * You may assume that all elements in the array are integers and comparable. * Aim for a linear time complexity, i.e., O(n).","solution":"from typing import List, Optional def limit(arr: List[int], min_lim: Optional[int] = None, max_lim: Optional[int] = None) -> List[int]: Filters the input array to include only elements between min_lim and max_lim inclusive. Parameters: arr (List[int]): The input list of integers. min_lim (Optional[int]): The minimum limit. Defaults to the minimum element of the array if not provided. max_lim (Optional[int]): The maximum limit. Defaults to the maximum element of the array if not provided. Returns: List[int]: A list with elements within the specified range. if not arr: return [] if min_lim is None: min_lim = min(arr) if max_lim is None: max_lim = max(arr) return [x for x in arr if min_lim <= x <= max_lim]"},{"question":"You are given a non-negative number represented as an array of digits, where each element in the array is a digit of the number. Your task is to write a function `increment_digits` that takes such an array and returns the array representing the number after adding one to it. The array should handle large numbers effectively and must account for carrying over when digits result in 10. Function Signature ```python def increment_digits(digits: List[int]) -> List[int]: pass ``` # Input - `digits` (List[int]): A list of integers where each integer `digits[i]` is a digit (0 ≤ digits[i] ≤ 9). # Output - (List[int]): The array of digits representing the number after incrementing by one. # Constraints - The number of digits is at least 1 and at most 10,000. - The number does not contain leading zeros except when the number is 0 itself. # Example ```python assert increment_digits([1, 2, 3]) == [1, 2, 4] assert increment_digits([4, 3, 2, 1]) == [4, 3, 2, 2] assert increment_digits([9, 9, 9, 9]) == [1, 0, 0, 0, 0] ``` # Additional Requirements - Implement the function with a time complexity of O(n) where n is the length of the input list. - The implementation should modify the input array in-place if possible to optimize space complexity. # Note Consider all possible edge cases such as all digits being the maximum value (e.g., `[9, 9, 9]`), and handle them effectively.","solution":"from typing import List def increment_digits(digits: List[int]) -> List[int]: Given a non-negative number represented as an array of digits, this function returns the array representing the number after adding one to it. n = len(digits) # Traverse the digits from the end to the beginning for i in reversed(range(n)): # if the current digit is less than 9, we can simply increase it by one if digits[i] < 9: digits[i] += 1 return digits # if the current digit is 9, we set it to 0 and continue to the next digit digits[i] = 0 # If all digits were 9, we reach here return [1] + digits"},{"question":"Given a Binary Search Tree (BST) and a node within this tree, write a function to find the in-order successor of that node. The in-order successor of a node is defined as the next node in the in-order traversal of the BST. If the node has no in-order successor, return `None`. # Function Signature ```python def inorder_successor(root: TreeNode, node: TreeNode) -> TreeNode: ``` # Input - `root (TreeNode)`: The root of the Binary Search Tree. - `node (TreeNode)`: The node in the tree for which the in-order successor is to be found. # Output - Return the `TreeNode` that is the in-order successor of the given `node`. - If the given `node` has no in-order successor, return `None`. # Constraints - Each node value is unique. - The BST will not be empty. - The `node` will always be present in the tree. # Example Example 1 Input: ```plaintext 20 / 10 30 / 5 ``` Node = 10 Output: ```plaintext 20 ``` Example 2 Input: ```plaintext 20 / 10 30 / 5 ``` Node = 30 Output: ```plaintext None ``` # Additional Notes 1. Remember to handle the scenario when the given node is the rightmost element in the tree (i.e., it has no in-order successor). 2. Efficient performance is expected with respect to time complexity. The solution should ideally run in O(h) time, where h is the height of the tree. # Scenario You are developing a module for navigating a directory hierarchy where directories and files are stored in a BST, and you need to implement a feature to quickly jump to the next directory or file in sorted order for an efficient user experience.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def inorder_successor(root: TreeNode, node: TreeNode) -> TreeNode: Finds the in-order successor of a given node in a Binary Search Tree (BST). successor = None current = root while current: if node.val < current.val: successor = current current = current.left else: current = current.right return successor"},{"question":"# Question: Implementing and Using a Doubly Linked List You are tasked with creating a Doubly Linked List (DLL) and implementing core functionalities. A DLL is a data structure that allows traversal in both directions, making it flexible for operations such as insertion and deletion at both ends. Your Task: 1. **Node Class**: Define the `DoublyLinkedListNode` class. - **Attributes**: `value`, `next`, and `prev`. 2. **Doubly Linked List Class**: Implement the `DoublyLinkedList` class. - **Attributes**: `head` and `tail`. - **Methods**: * `__init__(self)`: Initialize an empty list. * `append(self, value)`: Add a node with the given value at the end of the list. * `prepend(self, value)`: Add a node with the given value at the beginning of the list. * `delete(self, value)`: Remove the first node with the given value. * `display(self)`: Print the list from head to tail. Expected Input and Output Formats: ```python # Initialize the list dll = DoublyLinkedList() # Append values dll.append(10) dll.append(20) dll.append(30) dll.display() # Output should show: 10 <-> 20 <-> 30 # Prepend a value dll.prepend(5) dll.display() # Output should show: 5 <-> 10 <-> 20 <-> 30 # Delete a value dll.delete(20) dll.display() # Output should show: 5 <-> 10 <-> 30 # Handle edge case (delete non-existent value) dll.delete(50) dll.display() # Output should remain: 5 <-> 10 <-> 30 ``` Constraints: * **Domain**: You can assume the values are non-negative integers. * **Edge Cases**: Account for operations on empty lists or the presence of duplicated values. Implement the `DoublyLinkedList` class with the specified methods and ensure it handles the edge cases appropriately.","solution":"class DoublyLinkedListNode: def __init__(self, value): self.value = value self.next = None self.prev = None class DoublyLinkedList: def __init__(self): self.head = None self.tail = None def append(self, value): new_node = DoublyLinkedListNode(value) if not self.tail: self.head = self.tail = new_node else: self.tail.next = new_node new_node.prev = self.tail self.tail = new_node def prepend(self, value): new_node = DoublyLinkedListNode(value) if not self.head: self.head = self.tail = new_node else: self.head.prev = new_node new_node.next = self.head self.head = new_node def delete(self, value): current = self.head while current: if current.value == value: if current.prev: current.prev.next = current.next else: self.head = current.next if current.next: current.next.prev = current.prev else: self.tail = current.prev return current = current.next def display(self): nodes = [] current = self.head while current: nodes.append(str(current.value)) current = current.next print(\\" <-> \\".join(nodes))"},{"question":"You are provided with a 2D matrix where each row and column are sorted in non-decreasing order. Write a function `search_in_sorted_matrix(matrix, key)` to determine whether the given `key` is present in the matrix or not. If found, return the 1-based indices of the row and column. If not found, return `-1`. The solution should be efficient in terms of time complexity and optimized for the given constraints. Function Signature ```python def search_in_sorted_matrix(matrix: List[List[int]], key: int) -> Union[Tuple[int, int], int]: pass ``` Input: * `matrix`: A list of lists where each sublist represents a row in the matrix, and each row and column are sorted in non-decreasing order. * `key`: An integer value which you need to search in the matrix. Output: * Return a tuple of 1-based indices (row, column) if the key is found. * Return `-1` if the key is not present in the matrix. Constraints: * Assume `1 <= len(matrix), len(matrix[0]) <= 1000`. * Each element in the matrix is an integer within the range `-10^9` to `10^9`. Example: ```python matrix = [ [2, 5, 7], [4, 8, 13], [9, 11, 15], [12, 17, 20] ] key = 13 assert search_in_sorted_matrix(matrix, key) == (2, 3) key = 6 assert search_in_sorted_matrix(matrix, key) == -1 key = 12 assert search_in_sorted_matrix(matrix, key) == (4, 1) ``` # Notes: * You must handle cases where the matrix is empty. * Ensure that your implementation is efficient and avoids unnecessary computations.","solution":"from typing import List, Union, Tuple def search_in_sorted_matrix(matrix: List[List[int]], key: int) -> Union[Tuple[int, int], int]: This function searches for a given key in a sorted 2D matrix and returns the 1-based index (row, column) if the key is found. If not found, it returns -1. :param matrix: 2D list of integers, where each row and column is sorted in non-decreasing order :param key: Integer to search for in the matrix :return: Tuple of 1-based indices (row, column) if key is found, else -1 if not matrix or not matrix[0]: return -1 rows = len(matrix) cols = len(matrix[0]) # Start from the top-right corner of the matrix row = 0 col = cols - 1 while row < rows and col >= 0: if matrix[row][col] == key: return (row + 1, col + 1) elif matrix[row][col] > key: col -= 1 else: row += 1 return -1"},{"question":"# Question: Merging Two Sorted Linked Lists You are provided with the following problem statement: Write a function to merge two sorted linked lists into a new sorted linked list. The new list should be created by splicing together the nodes of the first two lists. Function Signature: ```python def merge_sorted_lists(l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]: pass ``` Input: * `l1`: `Optional[ListNode]`, the head of the first sorted linked list. * `l2`: `Optional[ListNode]`, the head of the second sorted linked list. Output: * Returns the head of the newly merged sorted linked list. # Examples: 1. **Example 1:** ```python Input: l1 = [1, 2, 4], l2 = [1, 3, 4] Output: [1, 1, 2, 3, 4, 4] ``` 2. **Example 2:** ```python Input: l1 = [], l2 = [] Output: [] ``` 3. **Example 3:** ```python Input: l1 = [], l2 = [0] Output: [0] ``` # Constraints: * The number of nodes in both lists is in the range `[0, 50]`. * `-100 <= Node.val <= 100` * Both `l1` and `l2` are sorted in non-decreasing order. # Performance Requirements: * The function should aim for an optimal merge both in terms of time (O(n + m)) and space complexity. * Consider iterative and recursive solutions. Be aware of the implications of using recursion. # Context: Merging two sorted linked lists is a common task in computer science that demonstrates a fundamental ability to manipulate linked lists, understand list traversal and recursive logic, and maintain sorted order in merged results. **Notes:** 1. You should define the `ListNode` class with two member variables: `val` (type: int) and `next` (type: Optional[ListNode]). 2. Pay special attention to edge cases such as empty input lists.","solution":"from typing import Optional class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_sorted_lists(l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]: # Create a dummy node to handle edge cases easily dummy = ListNode() current = dummy # Traverse both lists and merge them while l1 and l2: if l1.val <= l2.val: current.next = l1 l1 = l1.next else: current.next = l2 l2 = l2.next current = current.next # If there are remaining nodes in either list, append them if l1: current.next = l1 elif l2: current.next = l2 # The merged list is after the dummy node return dummy.next"},{"question":"You are given a list of integers where every element appears twice except for one. Your task is to implement a function that finds that single unique integer. This function should operate with a time complexity of O(n) and use constant space (O(1)). # Requirements: - **Input**: A list of integers `nums`. ```python nums = [int, ...] ``` - **Output**: An integer representing the unique element. ```python output: int ``` # Constraints: - The list contains at least one number. - Each number in the list except one appears exactly twice. - You must not use additional memory (constant space requirement). # Function Signature: ```python def find_single(nums: list) -> int: pass ``` # Example: ```python nums = [4, 1, 2, 1, 2] print(find_single(nums)) # Output: 4 nums = [2, 2, 1] print(find_single(nums)) # Output: 1 nums = [1] print(find_single(nums)) # Output: 1 ``` # Constraints: - The list length is `1 <= len(nums) <= 10^4`. - Each element in the list satisfies `-3 * 10^4 <= nums[i] <= 3 * 10^4`. # Scenario: Imagine a shipment of items marked with unique IDs, each appearing twice except for one item left out mistakenly during inventory. Your task is to identify the missing unique item efficiently to complete the database correctly. Implement the function `find_single(nums: list)` to solve the problem using the described algorithm.","solution":"def find_single(nums: list) -> int: Finds the single unique integer in a list where every element except one appears exactly twice. This implementation uses bitwise XOR to achieve the desired result with O(n) time complexity and O(1) space complexity. unique_element = 0 for num in nums: unique_element ^= num return unique_element"},{"question":"# Problem: String Acceptance in DFA Given a Deterministic Finite Automaton (DFA), determine whether a given string is accepted by the DFA. **Function Signature**: ```python def DFA(transitions: dict, start: str, final: list, string: str) -> bool: ``` **Input**: - `transitions`: A dictionary where keys are states and values are dictionaries representing transitions. Each inner dictionary has keys as input characters and values as the resulting states. - `start`: A string representing the starting state of the DFA. - `final`: A list of strings representing the accepting/final states of the DFA. - `string`: A string representing the input to be checked for acceptance by the DFA. **Output**: - Return `True` if the input string is accepted by the DFA (i.e., after processing all input characters, the DFA is in a final state). Return `False` otherwise. **Constraints**: - All states and characters are represented as strings. - `transitions` dictionary has complete transitions for all states and input characters. - The input string contains characters that appear in the transitions dictionary. **Performance Requirements**: - Your solution should be efficient, with a time complexity of O(n) where n is the length of the input string. - Space complexity should be O(1) excluding the space used for input storage. **Examples**: ```python # Example 1: transitions = { \'q0\': {\'0\': \'q0\', \'1\': \'q1\'}, \'q1\': {\'0\': \'q2\', \'1\': \'q0\'}, \'q2\': {\'0\': \'q1\', \'1\': \'q2\'} } start = \'q0\' final = [\'q0\'] string = \'1100\' # Expected Output: True # Example 2: transitions = { \'q0\': {\'a\': \'q1\'}, \'q1\': {\'b\': \'q2\'}, \'q2\': {\'c\': \'q0\'} } start = \'q0\' final = [\'q0\'] string = \'abca\' # Expected Output: False print(DFA(transitions, start, final, \'1100\')) # True print(DFA(transitions, start, final, \'abca\')) # False ``` **Explanation**: 1. In Example 1, the string \'1100\' takes the DFA through states q0 -> q1 -> q0 -> q1 -> q2 -> q0, and ends in the accepting state \'q0\'. 2. In Example 2, the string \'abca\' leads to a cyclic transition and ends in state \'q1\', which is not an accepting state. Implement the `DFA` function to solve the problem.","solution":"def DFA(transitions: dict, start: str, final: list, string: str) -> bool: Check whether the given string is accepted by the DFA. Parameters: transitions (dict): A dictionary representing state transitions of the DFA. start (str): The starting state of the DFA. final (list): A list of accepting states of the DFA. string (str): The input string to be checked. Returns: bool: True if the string is accepted by the DFA, False otherwise. current_state = start for char in string: if char in transitions[current_state]: current_state = transitions[current_state][char] else: # If character is not in the current state\'s transitions, string is not accepted return False return current_state in final"},{"question":"# Coding Task Scenario: You are designing a library of functions for performing common mathematical number theory operations, particularly focusing on efficient methods for determining relationships between integers. Your task is to implement functions for computing the greatest common divisor (GCD) using a bitwise method and the least common multiple (LCM). Additionally, you need a function to count the trailing zeros in the binary representation of an integer, as it is integral to the bitwise GCD algorithm. Requirements: You will implement three functions: `gcd_bitwise(a, b)`, `lcm(a, b)`, and `trailing_zero(x)`. The definitions are as follows: 1. **gcd_bitwise(a, b)** - Computes the greatest common divisor using bitwise operations. 2. **lcm(a, b)** - Computes the least common multiple using the result from gcd_bitwise. 3. **trailing_zero(x)** - Determines the number of trailing zeros in the binary representation of `x`. **Function Signatures:** ```python def gcd_bitwise(a: int, b: int) -> int: pass def lcm(a: int, b: int) -> int: pass def trailing_zero(x: int) -> int: pass ``` **Constraints:** 1. `a` and `b` are non-negative integers with 1 ≤ a, b ≤ 10^12. 2. `x` is a positive integer with 1 ≤ x ≤ 10^12. **Input Format:** * `gcd_bitwise(a, b)` takes two integers `a` and `b`. * `lcm(a, b)` takes two integers `a` and `b`. * `trailing_zero(x)` takes one integer `x`. **Output Format:** * `gcd_bitwise(a, b)` returns an integer representing the greatest common divisor. * `lcm(a, b)` returns an integer representing the least common multiple. * `trailing_zero(x)` returns an integer representing the number of trailing zeros in the binary representation of `x`. Example: ```python print(gcd_bitwise(18, 24)) # Output: 6 print(lcm(18, 24)) # Output: 72 print(trailing_zero(40)) # Output: 3 ```","solution":"def trailing_zero(x: int) -> int: Determines the number of trailing zeros in the binary representation of x. if x == 0: return 0 count = 0 while (x & 1) == 0: x >>= 1 count += 1 return count def gcd_bitwise(a: int, b: int) -> int: Computes the greatest common divisor using bitwise operations. if a == 0: return b if b == 0: return a # Count the number of trailing zeros in a and b shift = min(trailing_zero(a), trailing_zero(b)) # Remove all factors of 2 a >>= trailing_zero(a) b >>= trailing_zero(b) while b != 0: while (b & 1) == 0: b >>= 1 # Swap if a greater than b if a > b: a, b = b, a b = b - a # Restore common factors of 2 return a << shift def lcm(a: int, b: int) -> int: Computes the least common multiple using the result from gcd_bitwise. return a * (b // gcd_bitwise(a, b))"},{"question":"You are implementing a text processing function for a new application that ensures each character in a string appears only once and in the order of their first occurrence. Being mindful of performance constraints, your task is to create a Python function `delete_reoccurring_characters` that efficiently processes the string to meet these requirements. # Function Specification Function Signature ```python def delete_reoccurring_characters(string: str) -> str: ``` Input - `string`: A string `s` of length `n` (1 <= n <= 10^6), consisting of printable ASCII characters. Output - Returns a string with all repeated characters removed, only retaining their first occurrence. # Examples ```python assert delete_reoccurring_characters(\\"interview\\") == \\"intervw\\" assert delete_reoccurring_characters(\\"\\") == \\"\\" assert delete_reoccurring_characters(\\"a\\") == \\"a\\" assert delete_reoccurring_characters(\\"abba\\") == \\"ab\\" assert delete_reoccurring_characters(\\"googley\\") == \\"gole\\" ``` # Constraints and Considerations - The function should run in linear time relative to the length of the input string. - Optimize for both time and space, considering the input constraints. # Performance Requirement - Time complexity: O(n) - Space complexity: O(n) # Additional Context Your function will be integrated into a larger text-processing pipeline, where performance and correctness are critical. Ensure edge cases, such as empty strings or strings with no repeating characters, are handled correctly.","solution":"def delete_reoccurring_characters(string: str) -> str: Returns a string with all repeated characters removed, only retaining their first occurrence. seen = set() result = [] for char in string: if char not in seen: seen.add(char) result.append(char) return \'\'.join(result)"},{"question":"# Quick Sort Analysis and Implementation **Objective**: Implement and analyze the Quick Sort algorithm and optimize its performance as required. **Problem Statement**: You are given an array of integers. Write a function `optimized_quick_sort` which sorts the array in non-decreasing order. To avoid the worst-case time complexity, use the median-of-three method for pivot selection. **Function Signature**: ```python def optimized_quick_sort(arr: List[int]) -> List[int]: ``` **Input**: * `arr`: A list of integers where `1 <= len(arr) <= 10^5` and `-10^9 <= arr[i] <= 10^9`. **Output**: * A list of integers sorted in non-decreasing order. **Constraints**: 1. You must use the median-of-three method to select the pivot. 2. Implement an iterative version to avoid recursion limit problems. 3. The solution should be optimized to handle large datasets efficiently. **Example**: ```python assert optimized_quick_sort([3, 6, 8, 10, 1, 2, 1]) == [1, 1, 2, 3, 6, 8, 10] assert optimized_quick_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] assert optimized_quick_sort([-1, -2, -3, -4, -5]) == [-5, -4, -3, -2, -1] ```","solution":"from typing import List def partition(arr: List[int], low: int, high: int) -> int: mid = (low + high) // 2 pivot_candidates = [(arr[low], low), (arr[mid], mid), (arr[high], high)] pivot_candidates.sort() pivot = pivot_candidates[1][1] arr[pivot], arr[high] = arr[high], arr[pivot] # Move pivot to end pivot = arr[high] i = low - 1 for j in range(low, high): if arr[j] <= pivot: i += 1 arr[i], arr[j] = arr[j], arr[i] arr[i + 1], arr[high] = arr[high], arr[i + 1] return i + 1 def optimized_quick_sort(arr: List[int]) -> List[int]: if len(arr) < 2: return arr stack = [(0, len(arr) - 1)] while stack: low, high = stack.pop() if low < high: p = partition(arr, low, high) if p - low < high - p: stack.append((p + 1, high)) stack.append((low, p - 1)) else: stack.append((low, p - 1)) stack.append((p + 1, high)) return arr"},{"question":"# Intersection of Linked Lists Objective: Write a function that determines the intersection node of two singly linked lists. The intersection node is the node at which the two lists merge into one, and it must be returned. If there is no intersection, the function should return `None`. Task: Implement the function `def intersection(h1: Node, h2: Node) -> Node:` where: * `h1` is the head node of the first linked list. * `h2` is the head node of the second linked list. * The function returns the intersection node or `None` if no intersection exists. Constraints: - The linked lists are non-circular. - The node itself (reference) is the identifier of the intersection, not the node\'s value. Example: ```python class Node: def __init__(self, val=None): self.val = val self.next = None # Create linked lists: # 1 -> 3 -> 5 # # 7 -> 9 -> 11 # / # 2 -> 4 -> 6 a1 = Node(1) b1 = Node(3) c1 = Node(5) d = Node(7) a2 = Node(2) b2 = Node(4) c2 = Node(6) e = Node(9) f = Node(11) a1.next = b1 b1.next = c1 c1.next = d a2.next = b2 b2.next = c2 c2.next = d d.next = e e.next = f assert intersection(a1, a2).val == 7 ``` Testing: Your implementation will be tested with various cases, including but not limited to: - Different lengths of lists with and without intersections. - Lists with intersection at the start, middle, and end. - Lists with no intersection. - Empty lists.","solution":"class Node: def __init__(self, val=None): self.val = val self.next = None def get_length(head: Node) -> int: length = 0 current = head while current: length += 1 current = current.next return length def intersection(h1: Node, h2: Node) -> Node: len1 = get_length(h1) len2 = get_length(h2) # Align both pointers for the lists while len1 > len2: h1 = h1.next len1 -= 1 while len2 > len1: h2 = h2.next len2 -= 1 # Traverse both lists together to find the intersection while h1 and h2: if h1 is h2: return h1 h1 = h1.next h2 = h2.next return None # No intersection found"},{"question":"Scenario You are working on a text-processing application where you need to determine if one string can be formed by interleaving two other strings. The characters of the two strings should appear in the same order as they appear in the original strings. Task Write a function `is_merge_dynamic` that efficiently determines if a string `s` can be formed by merging two other strings `part1` and `part2`. The order of characters in `part1` and `part2` should be preserved in the merged string `s`. Function Signature ```python def is_merge_dynamic(s: str, part1: str, part2: str) -> bool: pass ``` Input - `s` (str): A string to be formed by merging `part1` and `part2`. - `part1` (str): The first part string. - `part2` (str): The second part string. Output - (bool): Returns `True` if `s` can be formed by interleaving `part1` and `part2`, else `False`. Constraints - The lengths of `s`, `part1`, and `part2` are at most 1000. - The characters in `part1` and `part2` are in the same order as in `s`. Example ```python print(is_merge_dynamic(\\"codewars\\", \\"cdw\\", \\"oears\\")) # True print(is_merge_dynamic(\\"abc\\", \\"ab\\", \\"d\\")) # False print(is_merge_dynamic(\\"\\", \\"\\", \\"\\")) # True print(is_merge_dynamic(\\"a\\", \\"\\", \\"a\\")) # True print(is_merge_dynamic(\\"a\\", \\"a\\", \\"\\")) # True print(is_merge_dynamic(\\"a\\", \\"b\\", \\"\\")) # False ``` You should aim to optimize the function to run efficiently in terms of time and space complexity. Note Use dynamic programming to avoid inefficient exponential time complexities.","solution":"def is_merge_dynamic(s: str, part1: str, part2: str) -> bool: if len(s) != len(part1) + len(part2): return False dp = [[False] * (len(part2) + 1) for _ in range(len(part1) + 1)] dp[0][0] = True for i in range(len(part1) + 1): for j in range(len(part2) + 1): if i > 0 and s[i + j - 1] == part1[i - 1]: dp[i][j] = dp[i][j] or dp[i - 1][j] if j > 0 and s[i + j - 1] == part2[j - 1]: dp[i][j] = dp[i][j] or dp[i][j - 1] return dp[len(part1)][len(part2)]"},{"question":"You are given a training set of labeled points in a Euclidean space and an unlabeled point. Your task is to classify the unlabeled point using the nearest neighbor algorithm provided. Scenario You are aiding an autonomous drone navigation system that relies on sensor data to recognize obstacles in its path. Given a set of labeled obstacle data points in a 3-dimensional space (x, y, z) and sensor readings indicating the position of an unknown obstacle, your task is to determine the type of the obstacle by finding the nearest labeled data point in the obstacle database. Function Specification **Function Name**: `classify_obstacle` **Inputs**: 1. `point` (tuple of float): A tuple representing the coordinates (x, y, z) of the unknown obstacle. 2. `obstacle_data` (dictionary): A dictionary where keys are tuples of floats representing the coordinates of known obstacles, and values are strings representing the type of obstacles. **Output**: - Return a string representing the type of the nearest obstacle from the `obstacle_data`. **Constraints**: - The training set `obstacle_data` will have at least one data point. - Each vector in the `obstacle_data` and the input `point` will have exactly three float components. Example ```python point = (1.0, 2.0, 3.0) obstacle_data = { (0.0, 0.0, 0.0): \\"tree\\", (2.0, 3.0, 4.0): \\"building\\", (1.1, 2.1, 2.9): \\"vehicle\\" } print(classify_obstacle(point, obstacle_data)) # Output: \\"vehicle\\" ``` Requirements 1. Your function should correctly handle all edge cases. 2. Implement the helper functions `distance` and `nearest_neighbor` as provided to compute the Euclidean distance and identify the nearest neighbor. 3. Optimize the function to handle large datasets effectively if possible.","solution":"import math def distance(point1, point2): Calculate the Euclidean distance between two points in 3D space. return math.sqrt(sum((a - b) ** 2 for a, b in zip(point1, point2))) def nearest_neighbor(point, obstacle_data): Find the nearest neighbor of the given point from the obstacle_data. nearest_point = None min_dist = float(\'inf\') for obstacle_point in obstacle_data: dist = distance(point, obstacle_point) if dist < min_dist: min_dist = dist nearest_point = obstacle_point return nearest_point def classify_obstacle(point, obstacle_data): Classify the obstacle by finding the nearest neighbor in the obstacle_data. nearest_point = nearest_neighbor(point, obstacle_data) return obstacle_data[nearest_point]"},{"question":"# Scenario You are tasked with maintaining a sorted list of numbers using a Binary Search Tree (BST). You need to implement insertion, deletion, and search operations to ensure the numbers can be efficiently managed. # Problem Statement Write a Python class `BinarySearchTree` that supports the following methods: - `insert(val: int) -> None`: Inserts a value into the BST. - `delete(val: int) -> None`: Deletes a value from the BST. If the value is not present, do nothing. - `search(val: int) -> bool`: Returns `True` if the value exists in the BST, otherwise returns `False`. # Requirements 1. **Insertion**: Maintain the BST properties while inserting a new node. 2. **Deletion**: Handle all cases of node deletion (leaf node, node with one child, node with two children). 3. **Search**: Efficiently check the existence of a value. # Node Class The node class `TreeNode` is provided as follows: ```python class TreeNode: def __init__(self, val=0): self.val = val self.left = None self.right = None ``` # Input and Output - Inputs for `insert`, `delete`: Single integer value. - Input for `search`: Single integer value. - Output for `search`: Boolean (`True` if found, `False` otherwise). # Constraints - All values are integers. - Assume no duplicate values will be inserted. # Example Usage ```python bst = BinarySearchTree() bst.insert(5) bst.insert(3) bst.insert(7) print(bst.search(3)) # Output: True bst.delete(3) print(bst.search(3)) # Output: False ``` Note: Ensure that the methods `insert`, `delete`, and `search` all operate within O(log n) time on average for balanced BSTs.","solution":"class TreeNode: def __init__(self, val=0): self.val = val self.left = None self.right = None class BinarySearchTree: def __init__(self): self.root = None def insert(self, val: int) -> None: def _insert(node, val): if node is None: return TreeNode(val) if val < node.val: node.left = _insert(node.left, val) else: node.right = _insert(node.right, val) return node self.root = _insert(self.root, val) def delete(self, val: int) -> None: def _min_value_node(node): current = node while current.left is not None: current = current.left return current def _delete(node, val): if node is None: return node if val < node.val: node.left = _delete(node.left, val) elif val > node.val: node.right = _delete(node.right, val) else: if node.left is None: return node.right elif node.right is None: return node.left temp = _min_value_node(node.right) node.val = temp.val node.right = _delete(node.right, temp.val) return node self.root = _delete(self.root, val) def search(self, val: int) -> bool: def _search(node, val): if node is None: return False if node.val == val: return True elif val < node.val: return _search(node.left, val) else: return _search(node.right, val) return _search(self.root, val)"},{"question":"Given an integer `n`, your task is to write a function `optimized_hailstone` that generates the Hailstone sequence. However, instead of returning the entire sequence, return the length of the sequence (the number of terms until it reaches 1). This is to improve performance and reduce memory usage. # Function Signature ```python def optimized_hailstone(n: int) -> int: pass ``` # Input * An integer value `n` where `1 <= n <= 10^6`. # Output * An integer representing the length of the Hailstone sequence for the starting number `n`. # Constraints * You must optimize your function to handle the upper limits efficiently both in time and space. * Handle edge cases where `n = 1`, large values of `n`, and invalid inputs gracefully (the function will only receive valid positive integers as per constraints). # Example ```python assert optimized_hailstone(1) == 1 assert optimized_hailstone(7) == 17 assert optimized_hailstone(27) == 112 assert optimized_hailstone(1000000) == 153 ``` # What you need to consider - Use a while loop for iterative calculations. - Ensure minimal memory usage by not storing the sequence. - Handle and return the sequence length efficiently.","solution":"def optimized_hailstone(n: int) -> int: Returns the length of the Hailstone sequence for the given integer n. length = 1 while n != 1: if n % 2 == 0: n = n // 2 else: n = 3 * n + 1 length += 1 return length"},{"question":"Markov Chain Simulator with Weighted State Transitions # Objective To assess your understanding of implementing and manipulating stochastic processes using a Markov Chain, you are required to write a function that can iterate through the states of a Markov Chain and return a finite list of states based on a given starting state and number of transitions. # Function Signature ```python def simulate_markov_chain(chain: dict, start_state: str, num_transitions: int) -> list: Simulate a sequence of state transitions in a Markov Chain. :param chain: A dictionary representing the Markov Chain with state transition probabilities. :param start_state: The starting state from which the transitions will begin. :param num_transitions: The number of transitions to simulate. :return: A list of states visited during the simulation. ``` # Input - `chain`: dictionary where keys are states and values are dictionaries that map to other states with transition probabilities. - Example format: ```python { \'A\': {\'A\': 0.5, \'B\': 0.5}, \'B\': {\'A\': 0.2, \'B\': 0.8} } ``` - `start_state`: a string representing the initial state. - `num_transitions`: an integer indicating the number of state transitions to be performed. # Output - Returns a list of strings representing the sequence of states visited, of length `num_transitions`. # Example ```python chain = { \'A\': {\'A\': 0.5, \'B\': 0.5}, \'B\': {\'A\': 0.2, \'B\': 0.8} } # Simulate starting at \'A\' with 3 transitions output = simulate_markov_chain(chain, \'A\', 3) # Possible output could be: [\'A\', \'B\', \'B\', \'A\'] ``` # Constraints - The `chain` should contain valid probabilities (non-negative and summing to 1 for each state). - If `start_state` is not in `chain`, the function should return an empty list. - The function should be optimized to handle moderately sized chains efficiently. # Notes - Ensure that transition probabilities are handled accurately. - Implement error handling for invalid inputs or unreachable states.","solution":"import random def simulate_markov_chain(chain: dict, start_state: str, num_transitions: int) -> list: if start_state not in chain: return [] states = [start_state] current_state = start_state for _ in range(num_transitions): next_state = random.choices( list(chain[current_state].keys()), weights=list(chain[current_state].values()) )[0] states.append(next_state) current_state = next_state return states"},{"question":"Scenario: You have been assigned a task to review a system that processes hierarchical data (such as organizational structures or directory trees) and outputs it level by level. The current implementation needs to be improved to handle more extensive datasets efficiently. Question: Write a function `level_order(root)` that takes the root of a binary tree and returns its level order traversal as a list of lists. Each sublist should contain the values of nodes at the corresponding level from left to right. Input and Output Format: * **Input**: The input to the function is the `root` of a binary tree. - The `root` is an instance of a class `TreeNode` which is defined as: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` * **Output**: - Return a list of lists, where each nested list contains the node values at the corresponding tree level. Constraints: * The number of nodes in the tree is in the range `[0, 10^4]`. * The tree node values are in the range `[-10^9, 10^9]`. Performance Requirements: * Ensure your solution can handle large trees efficiently with respect to both time and space complexity. * Consider edge cases such as an empty tree or a tree with only one node. Example: ```python def example(): root = TreeNode(3) root.left = TreeNode(9) root.right = TreeNode(20) root.right.left = TreeNode(15) root.right.right = TreeNode(7) # Tree looks like this: # 3 # / # 9 20 # / # 15 7 # Function Call result = level_order(root) # Expected Output: [[3], [9, 20], [15, 7]] example() ``` Implement the function `level_order(root)` with the above specifications and constraints. Ensure it handles edge cases gracefully.","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_order(root): Returns the level order traversal of a binary tree as a list of lists. if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) level = [] for _ in range(level_size): node = queue.popleft() level.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level) return result"},{"question":"**Context** You are developing a plagiarism detection tool and a critical feature is determining if two text fragments are anagrams. A solution based on character frequency counting is desired for its linear time complexity. **Problem** Write a function `are_anagrams(frag1: str, frag2: str) -> bool` to determine if the two given strings are anagrams of each other. This function must: 1. Handle case-insensitivity by converting uppercase letters to lowercase. 2. Ignore non-alphabet characters and treat them as if they do not exist. **Function Signature** ```python def are_anagrams(frag1: str, frag2: str) -> bool ``` **Input Format** * Two strings `frag1` and `frag2` consisting of ASCII characters. **Output Format** * A boolean `True` if the strings are anagrams of each other; otherwise, `False`. **Constraints** * The strings will have a maximum length of 1000. * The comparison should be case-insensitive and ignore non-alphabet characters. **Examples** 1. `are_anagrams(\\"apple!!\\", \\"pleap?\\")` -> `True` 2. `are_anagrams(\\"apple\\", \\"cherry\\")` -> `False` 3. `are_anagrams(\\"Listen\\", \\"Silent!\\")` -> `True` 4. `are_anagrams(\\"Hello, World!\\", \\"Hello W\\")` -> `False` **Performance Requirements** * The solution should work efficiently with the given constraints. * Aim to achieve a linear-time complexity solution. **Additional Notes** * You may use any data structures and methods provided by Python to solve this problem. * Clearly comment on how non-alphabet characters are handled.","solution":"import re from collections import Counter def are_anagrams(frag1: str, frag2: str) -> bool: Determines if two given strings are anagrams, ignoring case and non-alphabet characters. Parameters: - frag1 (str): The first string fragment. - frag2 (str): The second string fragment. Returns: - bool: True if the strings are anagrams, False otherwise. # Function to filter and convert string to a normalized form def normalize_string(s: str) -> str: # Remove non-alphabetical characters and convert to lowercase return re.sub(r\'[^a-zA-Z]\', \'\', s).lower() # Normalize the input strings normalized_frag1 = normalize_string(frag1) normalized_frag2 = normalize_string(frag2) # Use Counter to compare character frequencies return Counter(normalized_frag1) == Counter(normalized_frag2)"},{"question":"# Red-Black Tree Insertion In this task, you are required to write a function to simulate the insertion of a new node in a Red-Black Tree. # Context: We have a complete implementation of a Red-Black Tree that supports various operations, including insertions. Your task is to extend its functionality to add a new method that calculates the height of the Red-Black Tree. # Red-Black Tree Height In this problem, you should write a method named `rb_tree_height` in the `RBTree` class that calculates the height of the tree. The height of a binary tree is the number of edges in the longest path from the root to a leaf node. For example, in the following tree: ``` 11 / 2 14 / 1 7 15 / 5 8 ``` The height is 3 (number of edges in the path 11 -> 2 -> 7 -> 8). # Function Signature: ```python def rb_tree_height(self) -> int: pass ``` # Input and Output: - The function does not take any input parameters. - The function returns an integer representing the height of the Red-Black Tree. # Constraints: - The tree will have at least one node. # Example: Given the tree is represented as: ```python rb = RBTree() children = [11, 2, 14, 1, 7, 15, 5, 8, 4] for child in children: rb.insert(RBNode(child, 1)) ``` Calling `rb.rb_tree_height()` should return `3`. # Notes: Ensure your function is efficient and maintains the properties of the Red-Black Tree.","solution":"class RBNode: def __init__(self, key, color, left=None, right=None, parent=None): self.key = key self.color = color self.left = left self.right = right self.parent = parent class RBTree: def __init__(self): self.NIL_LEAF = RBNode(None, 0) # Every leaf has a black child which is NIL_LEAF self.root = self.NIL_LEAF def insert(self, node): if self.root == self.NIL_LEAF: self.root = node self.root.color = 1 # Root is always black self.root.parent = None else: self._rb_insert(self.root, node) node.left = self.NIL_LEAF node.right = self.NIL_LEAF node.color = 0 # New node must be red self._fix_insert(node) def _rb_insert(self, current, node): if node.key < current.key: if current.left == self.NIL_LEAF: current.left = node node.parent = current else: self._rb_insert(current.left, node) else: if current.right == self.NIL_LEAF: current.right = node node.parent = current else: self._rb_insert(current.right, node) def _fix_insert(self, node): # Fix the tree, maintaining Red-Black Tree properties while node != self.root and node.parent.color == 0: if node.parent == node.parent.parent.left: uncle = node.parent.parent.right if uncle.color == 0: # Case 1: Uncle is red node.parent.color = 1 uncle.color = 1 node.parent.parent.color = 0 node = node.parent.parent else: if node == node.parent.right: # Case 2: Node is right child node = node.parent self._left_rotate(node) node.parent.color = 1 # Case 3: Node is left child node.parent.parent.color = 0 self._right_rotate(node.parent.parent) else: uncle = node.parent.parent.left if uncle.color == 0: # Case 1: Uncle is red node.parent.color = 1 uncle.color = 1 node.parent.parent.color = 0 node = node.parent.parent else: if node == node.parent.left: # Case 2: Node is left child node = node.parent self._right_rotate(node) node.parent.color = 1 # Case 3: Node is right child node.parent.parent.color = 0 self._left_rotate(node.parent.parent) self.root.color = 1 # Root is always black def _left_rotate(self, x): y = x.right x.right = y.left if y.left != self.NIL_LEAF: y.left.parent = x y.parent = x.parent if x.parent is None: self.root = y elif x == x.parent.left: x.parent.left = y else: x.parent.right = y y.left = x x.parent = y def _right_rotate(self, x): y = x.left x.left = y.right if y.right != self.NIL_LEAF: y.right.parent = x y.parent = x.parent if x.parent is None: self.root = y elif x == x.parent.right: x.parent.right = y else: x.parent.left = y y.right = x x.parent = y def rb_tree_height(self): def _height(node): if node == self.NIL_LEAF: return -1 left_height = _height(node.left) right_height = _height(node.right) return 1 + max(left_height, right_height) return _height(self.root)"},{"question":"# Scenario You\'ve been hired to implement a hash table data structure for a given dataset. Your task is to enhance the provided `SeparateChainingHashTable` with some additional functionalities to ensure better performance and functionality. # Task 1. Implement a `resize` method to expand the hash table when a certain load factor (e.g., 0.75) is exceeded. This involves: * Creating a larger underlying array. * Rehashing all existing entries into this new array. 2. Enhance the class such that `resize` is automatically called after an `insert` operation if the load factor condition is met. # Function Signature ```python class SeparateChainingHashTable: # existing methods def resize(self, new_size: int): # Implement this method def put(self, key, value): # Modify this method to call `resize` if necessary ``` # Constraints * Assume all keys and values are immutable and hashable. * Ensure that the resizing operation preserves the current entries and performs necessary rehashing. # Input and Output 1. `put(key, value)`: * **Input**: - `key`: The key to insert in the hash table (usually a string or an integer). - `value`: The value associated with the key (can be any immutable data type). * **Output**: None * If the insertion causes the load factor to exceed 0.75, resize the hash table. 2. `resize(new_size)`: * **Input**: - `new_size`: An integer specifying the new size of the underlying array. * **Output**: None * Rehash all current entries into the new underlying array of size `new_size`. # Performance Requirements Ensure the implementation of the resize method efficiently handles the rehashing process and maintains a time complexity of O(n) in the average case for the resizing operation, where n is the number of entries. # Example ```python table = SeparateChainingHashTable() table.put(\'hello\', \'world\') table.put(\'foo\', \'bar\') table.put(\'baz\', \'qux\') # Suppose the load factor exceeds 0.75, resize() should be called print(len(table)) # Output should be 3 after inserting three items print(table.get(\'hello\')) # Output: \'world\' print(table.get(\'foo\')) # Output: \'bar\' print(table.get(\'baz\')) # Output: \'qux\' ``` # Notes You are encouraged to perform unit tests to ensure the correctness of your implementation, especially around the resizing logic.","solution":"class SeparateChainingHashTable: def __init__(self, initial_size=8): self.size = 0 self.capacity = initial_size self.load_factor_threshold = 0.75 self.buckets = [[] for _ in range(self.capacity)] def hash(self, key): return hash(key) % self.capacity def put(self, key, value): if self.size / self.capacity >= self.load_factor_threshold: self.resize(self.capacity * 2) index = self.hash(key) for kv in self.buckets[index]: if kv[0] == key: kv[1] = value return self.buckets[index].append([key, value]) self.size += 1 def get(self, key): index = self.hash(key) for kv in self.buckets[index]: if kv[0] == key: return kv[1] return None def resize(self, new_size): old_buckets = self.buckets self.capacity = new_size self.buckets = [[] for _ in range(self.capacity)] self.size = 0 for bucket in old_buckets: for key, value in bucket: self.put(key, value) def __len__(self): return self.size"},{"question":"# Edit Distance Minimization **Context**: In many text processing applications, it’s useful to determine how similar two strings are. A robust measure of similarity is the minimum number of single-character edits (insertions, deletions, or substitutions) required to convert one string into another. This problem is often referred to as computing the \\"edit distance\\" or \\"Levenshtein distance\\". Given two words, your task is to write a function to calculate the minimum edit distance between them. Function Signature ```python def min_edit_distance(word1: str, word2: str) -> int: pass ``` Input * `word1` (string): The first input string, 0 ≤ len(word1) ≤ 1000. * `word2` (string): The second input string, 0 ≤ len(word2) ≤ 1000. Output * Return an integer that represents the minimum edit distance between `word1` and `word2`. Constraints * Only lowercase English letters (\'a\' to \'z\') will be used in the input strings. Examples 1. **Example 1** * Input: word1 = \\"kitten\\", word2 = \\"sitting\\" * Output: 3 * Explanation: * kitten -> sitten (substitution of \'k\' with \'s\') * sitten -> sittin (substitution of \'e\' with \'i\') * sittin -> sitting (insertion of \'g\') 2. **Example 2** * Input: word1 = \\"flaw\\", word2 = \\"lawn\\" * Output: 2 * Explanation: * flaw -> law (deletion of \'f\') * law -> lawn (insertion of \'n\') Edge Cases * Both strings are empty. * One string is empty and the other is non-empty. * Both strings are identical. Implement the function taking into account both the time and space complexity. If necessary, optimize the space usage to handle large inputs.","solution":"def min_edit_distance(word1: str, word2: str) -> int: Calculate the minimum edit distance between two words using dynamic programming. m, n = len(word1), len(word2) # Initialize the DP table dp = [[0] * (n + 1) for _ in range(m + 1)] # Fill the base cases for i in range(m + 1): dp[i][0] = i for j in range(n + 1): dp[0][j] = j # Compute the edit distances for i in range(1, m + 1): for j in range(1, n + 1): if word1[i - 1] == word2[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = 1 + min(dp[i - 1][j], # Deletion dp[i][j - 1], # Insertion dp[i - 1][j - 1]) # Substitution return dp[m][n]"},{"question":"Check if One Binary Tree is a Subtree of Another Objective You are tasked to write a function to check whether one binary tree (`t`) is a subtree of another binary tree (`s`). Function Signature ```python def is_subtree(s, t): pass ``` Input and Output - **Input**: Two binary trees `s` and `t`. - Each tree node is represented as: ```python class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None ``` - **Output**: A boolean (True if `t` is a subtree of `s`, otherwise False) Example ```python # Example 1 # Tree s: # 3 # / # 4 5 # / # 1 2 # Tree t: # 4 # / # 1 2 # Return: True # Example 2: # Tree s: # 3 # / # 4 5 # / # 1 2 # / # 0 # Tree t: # 4 # / # 1 2 # Return: False ``` Constraints * Assume tree nodes hold integer values. * The solution should handle cases where `s` or `t` can be `None`. * Aim to achieve the best possible performance on balanced trees. Follow-Up How would your solution handle the case where one tree is significantly larger than the other? Performance Requirements * Your solution should consider both time complexity and space complexity, providing an optimal approach where necessary. Function Context Your function will support overall tree comparison needed in structured data handling scenarios like file systems, and XML processing, hence accuracy and performance are crucial.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def is_same_tree(s, t): if not s and not t: return True if not s or not t: return False if s.val != t.val: return False return is_same_tree(s.left, t.left) and is_same_tree(s.right, t.right) def is_subtree(s, t): if not s: return False if is_same_tree(s, t): return True return is_subtree(s.left, t) or is_subtree(s.right, t)"},{"question":"**Problem Statement**: Given a binary tree represented by its root node and two distinct target nodes `p` and `q`, find the lowest common ancestor (LCA) of the nodes. # Input The function will take the following inputs: - `root`: The root node of the binary tree. - `p`: A target node in the binary tree. - `q`: Another target node in the binary tree. # Output Return the lowest common ancestor (LCA) node of the two given nodes `p` and `q`. # Constraints - The binary tree is given as a TreeNode structure where each node has left and right child pointers. - All TreeNode values are unique. - The two nodes `p` and `q` are guaranteed to be present in the binary tree. - The function must run efficiently with respect to both time and space. # Example Consider the following binary tree: ``` _______3______ / ___5__ ___1__ / / 6 _2 0 8 / 7 4 ``` Given the nodes `p = 5` and `q = 1`, the LCA is `3`. Given the nodes `p = 5` and `q = 4`, the LCA is `5`. # Implementation Define the function `lca` as follows: ```python class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def lca(root, p, q): :type root: TreeNode :type p: TreeNode :type q: TreeNode :rtype: TreeNode # Your code here ``` You are required to implement the function to find the lowest common ancestor (LCA) of two given nodes in the binary tree.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def lca(root, p, q): :type root: TreeNode :type p: TreeNode :type q: TreeNode :rtype: TreeNode if root is None or root == p or root == q: return root left = lca(root.left, p, q) right = lca(root.right, p, q) if left and right: return root return left if left else right"},{"question":"# Task **Implement a function `remove_reoccurring_characters_efficiently` that removes reoccurring characters from a string and returns the resultant string, maintaining the order of first occurrences of each character.** # Function Signature ```python def remove_reoccurring_characters_efficiently(input_string: str) -> str: ``` # Input Format * A single input parameter `input_string` which is a string containing up to 100,000 characters. # Output Format * Return a string containing the result after removing reoccurring characters from the input string. # Constraints * The input string will only contain printable ASCII characters. # Examples: Example 1: ```python input_string = \\"abracadabra\\" assert remove_reoccurring_characters_efficiently(input_string) == \\"abrcd\\" ``` Example 2: ```python input_string = \\"hello world\\" assert remove_reoccurring_characters_efficiently(input_string) == \\"helo wrd\\" ``` Example 3: ```python input_string = \\"aaaaaa\\" assert remove_reoccurring_characters_efficiently(input_string) == \\"a\\" ``` # Detailed Requirements * You should use an efficient way of handling the string concatenation internally to ensure the solution remains within the constraints of time and space complexity. * You must maintain the order of the first occurrence of each character. * Consider edge cases like an empty string and strings with all unique characters.","solution":"def remove_reoccurring_characters_efficiently(input_string: str) -> str: Removes reoccurring characters from the input string and returns the resultant string, maintaining the order of first occurrences of each character. :param input_string: String from which reoccurring characters are to be removed. :return: String with reoccurring characters removed. seen = set() result = [] for char in input_string: if char not in seen: seen.add(char) result.append(char) return \'\'.join(result)"},{"question":"# Binary Search for the Last Occurrence Write a function `find_last_occurrence(arr, target)` that finds the index of the last occurrence of a given target element in a sorted array. Your implementation should leverage binary search for efficient performance. Function Signature ```python def find_last_occurrence(arr: List[int], target: int) -> int: ``` Input - `arr`: A list of integers sorted in increasing order (0 <= len(arr) <= 10^5). - `target`: An integer value to be searched for in `arr`. Output - Returns an integer representing the index of the last occurrence of `target` in `arr`. If `target` is not found, return -1. Constraints - Time complexity should be O(log n). - Space complexity should be O(1). Examples ```python assert find_last_occurrence([1, 2, 2, 2, 3, 4, 5], 2) == 3 assert find_last_occurrence([1, 2, 3, 4, 5], 6) == -1 assert find_last_occurrence([], 1) == -1 assert find_last_occurrence([10, 10, 10, 10], 10) == 3 assert find_last_occurrence([1, 3, 5, 7, 9], 5) == 2 ``` Comments - Make sure your solution handles all edge cases. - Remember that the array is sorted in increasing order.","solution":"from typing import List def find_last_occurrence(arr: List[int], target: int) -> int: Finds the index of the last occurrence of the target in a sorted array. Parameters: arr (List[int]): A list of integers sorted in increasing order. target (int): The target integer value to be searched in arr. Returns: int: The index of the last occurrence of the target. If the target is not found, return -1. left, right = 0, len(arr) - 1 result = -1 while left <= right: mid = left + (right - left) // 2 if arr[mid] == target: result = mid # Update result to the current mid left = mid + 1 # Move right to find a later occurrence elif arr[mid] < target: left = mid + 1 else: right = mid - 1 return result"},{"question":"You are given a list of distinct integers. Your task is to generate all possible permutations of this list. Implement a function `generate_permutations(nums)` that takes a list of distinct integers `nums` as input and returns a list of all possible permutations. # Input - A list of distinct integers `nums` (1 ≤ len(nums) ≤ 8). # Output - A list of lists, where each inner list is a permutation of the input list. # Constraints - The input list will contain distinct integers. - The length of the input list will be between 1 and 8 inclusive. # Performance Requirements - The solution should aim to effectively generate permutations without excessive memory or computational overhead. # Example ```python def generate_permutations(nums): # Implement this function pass # Example Usage nums = [1, 2, 3] print(generate_permutations(nums)) # Expected Output: # [ # [1, 2, 3], # [1, 3, 2], # [2, 1, 3], # [2, 3, 1], # [3, 1, 2], # [3, 2, 1] # ] ``` # Explanation In this example, the input list [1, 2, 3] has 3! = 6 permutations. The function should return a list containing all possible rearrangements, maintaining the specified order in the output.","solution":"from itertools import permutations def generate_permutations(nums): Returns all possible permutations of the input list of distinct integers. return list(map(list, permutations(nums)))"},{"question":"# Pseudo-Perfect Numbers A \\"pseudo-perfect\\" number is a number whose digits can be raised to consecutive powers, starting at 1 for the left-most digit, and then summed to form the same number. For example: - 89 = 8^1 + 9^2 = 8 + 81 = 89 - 135 = 1^1 + 3^2 + 5^3 = 1 + 9 + 125 = 135 Write a function `find_pseudo_perfect_numbers` that takes two integers, `low` and `high`, and returns a list of all pseudo-perfect numbers within the inclusive range from `low` to `high`. # Function Signature ```python def find_pseudo_perfect_numbers(low: int, high: int) -> List[int]: ``` # Input - `low` (int): The start of the range (1 ≤ `low` ≤ `high` ≤ 10^6). - `high` (int): The end of the range. # Output - `List[int]`: A list of all pseudo-perfect numbers within the given range, in ascending order. # Constraints - The range will always be such that `low` ≤ `high`. - Try to ensure your function is optimized to handle the upper limits efficiently. # Example ```python assert find_pseudo_perfect_numbers(1, 10) == [1, 2, 3, 4, 5, 6, 7, 8, 9] assert find_pseudo_perfect_numbers(1, 100) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 89] assert find_pseudo_perfect_numbers(50, 150) == [89, 135] ``` # Additional Notes - Single-digit numbers (1-9) always fulfill this condition by definition. - Consider edge cases where the range might be minimal (e.g., low = high). # Hints - You may use helper functions to keep the main function clean and easy to understand.","solution":"from typing import List def is_pseudo_perfect(n: int) -> bool: digits = list(map(int, str(n))) sum_of_powers = sum(digit ** (i + 1) for i, digit in enumerate(digits)) return sum_of_powers == n def find_pseudo_perfect_numbers(low: int, high: int) -> List[int]: pseudo_perfect_numbers = [] for num in range(low, high + 1): if is_pseudo_perfect(num): pseudo_perfect_numbers.append(num) return pseudo_perfect_numbers"},{"question":"**Scenario**: You are working for a data storage and retrieval service company. Your clients often query large datasets stored across different disk blocks. To optimize these disk accesses, you want to ensure that the data structure used for indexing remains balanced and can handle vast amounts of data with minimal I/O operations. For this scenario, you will be required to manage the dynamic insertion, search, and deletion of elements in a B-tree. # Problem Statement: Your task is to write a function to manage a B-tree. You need to implement the B-tree operations: 1. `insert_key`: Insert a key into the B-tree. 2. `find`: Check if a key exists in the B-tree. 3. `remove_key`: Remove a key from the B-tree. # Function Signatures: ```python class BTree: def __init__(self, t_val=2): Initializes the B-tree with a given degree \'t_val\'. pass def insert_key(self, key: int): Insert \'key\' into the B-tree. Parameters: key (int): The key to insert. pass def find(self, key: int) -> bool: Find if \'key\' exists in the B-tree. Parameters: key (int): The key to search for. Returns: bool: True if key is found, False otherwise. pass def remove_key(self, key: int): Remove \'key\' from the B-tree. Parameters: key (int): The key to remove. pass ``` # Constraints: - Keys are unique positive integers. - The B-tree should be initialized with a minimum degree `t_val = 2`. - Handle typical edge cases such as inserting into an empty tree, searching non-existent keys, deleting nodes that are internal or leaf nodes, and handling underflow or overflow conditions. - Ensure efficiency with respect to time complexity and minimize excessive disk I/O operations conceptually. # Example: ```python btree = BTree(t_val=3) # Insert keys btree.insert_key(10) btree.insert_key(20) btree.insert_key(5) btree.insert_key(6) btree.insert_key(12) btree.insert_key(30) btree.insert_key(7) btree.insert_key(17) # Search for keys print(btree.find(10)) # Output: True print(btree.find(15)) # Output: False # Remove keys btree.remove_key(6) ``` This task will test your understanding of B-trees, including balanced tree operations, edge cases handling, and the ability to manage insertion, deletion, and search operations efficiently.","solution":"class BTreeNode: def __init__(self, t, leaf=False): self.t = t # Minimum degree (defines the range for number of keys) self.leaf = leaf # True if leaf node, else False self.keys = [] # List of keys in node self.children = [] # List of child pointers class BTree: def __init__(self, t_val=2): self.t = t_val # Minimum degree self.root = BTreeNode(t_val, leaf=True) def insert_key(self, key): root = self.root if len(root.keys) == (2 * self.t) - 1: # Root is full, need to split new_node = BTreeNode(self.t, leaf=False) new_node.children.append(self.root) self.split_child(new_node, 0) self.root = new_node self.insert_non_full(self.root, key) def insert_non_full(self, node, key): i = len(node.keys) - 1 if node.leaf: node.keys.append(key) # Add a placeholder for the new key while i >= 0 and key < node.keys[i]: node.keys[i + 1] = node.keys[i] i -= 1 node.keys[i + 1] = key else: while i >= 0 and key < node.keys[i]: i -= 1 i += 1 if len(node.children[i].keys) == (2 * self.t) - 1: # Child is full self.split_child(node, i) if key > node.keys[i]: i += 1 self.insert_non_full(node.children[i], key) def split_child(self, parent, i): t = self.t y = parent.children[i] z = BTreeNode(t, y.leaf) parent.children.insert(i + 1, z) parent.keys.insert(i, y.keys[t - 1]) z.keys = y.keys[t:(2 * t) - 1] y.keys = y.keys[0:t - 1] if not y.leaf: z.children = y.children[t:2 * t] y.children = y.children[0:t - 1] def find(self, key) -> bool: return self._find(self.root, key) def _find(self, node, key) -> bool: i = 0 while i < len(node.keys) and key > node.keys[i]: i += 1 if i < len(node.keys) and node.keys[i] == key: return True if node.leaf: return False return self._find(node.children[i], key) def remove_key(self, key): self._remove(self.root, key) if len(self.root.keys) == 0: if len(self.root.children) > 0: self.root = self.root.children[0] else: self.root = BTreeNode(self.t, leaf=True) def _remove(self, node, key): t = self.t idx = 0 while idx < len(node.keys) and node.keys[idx] < key: idx += 1 if idx < len(node.keys) and node.keys[idx] == key: if node.leaf: node.keys.pop(idx) else: self._remove_internal_node(node, key, idx) else: if node.leaf: return # Key is not present need_to_merge = (len(node.children[idx].keys) < t) if need_to_merge: self._fill(node, idx) if len(node.children[idx].keys) < t and idx > 0: idx -= 1 self._remove(node.children[idx], key) def _remove_internal_node(self, node, key, idx): t = self.t k = node.keys[idx] if len(node.children[idx].keys) >= t: predecessor_key = self._get_predecessor(node, idx) node.keys[idx] = predecessor_key self._remove(node.children[idx], predecessor_key) elif len(node.children[idx + 1].keys) >= t: successor_key = self._get_successor(node, idx) node.keys[idx] = successor_key self._remove(node.children[idx + 1], successor_key) else: self._merge(node, idx) self._remove(node.children[idx], key) def _get_predecessor(self, node, idx): cur = node.children[idx] while not cur.leaf: cur = cur.children[len(cur.keys)] return cur.keys[len(cur.keys) - 1] def _get_successor(self, node, idx): cur = node.children[idx + 1] while not cur.leaf: cur = cur.children[0] return cur.keys[0] def _fill(self, node, idx): t = self.t if idx != 0 and len(node.children[idx - 1].keys) >= t: self._borrow_from_prev(node, idx) elif idx != len(node.keys) and len(node.children[idx + 1].keys) >= t: self._borrow_from_next(node, idx) else: if idx != len(node.keys): self._merge(node, idx) else: self._merge(node, idx - 1) def _borrow_from_prev(self, node, idx): child = node.children[idx] sibling = node.children[idx - 1] child.keys.insert(0, node.keys[idx - 1]) if not child.leaf: child.children.insert(0, sibling.children.pop()) node.keys[idx - 1] = sibling.keys.pop() def _borrow_from_next(self, node, idx): child = node.children[idx] sibling = node.children[idx + 1] child.keys.append(node.keys[idx]) if not child.leaf: child.children.append(sibling.children.pop(0)) node.keys[idx] = sibling.keys.pop(0) def _merge(self, node, idx): t = self.t child = node.children[idx] sibling = node.children[idx + 1] child.keys.append(node.keys.pop(idx)) child.keys.extend(sibling.keys) if not child.leaf: child.children.extend(sibling.children) node.children.pop(idx + 1)"},{"question":"# Question: Find the Single Unique Number You are given an array of integers where each integer appears exactly three times except for one integer which appears exactly once. Your task is to write a function that identifies the unique integer in the array. *Your solution should have linear runtime complexity, and you should not use extra memory.* Function Signature ```python def find_single_number(nums: List[int]) -> int: pass ``` Input * `nums`: A list of integers where each integer appears exactly three times except for one integer which appears exactly once. The list will contain at least one element and the total number of integers will be at least 4. Output * Returns the single integer that appears exactly once. Example ```python find_single_number([2, 2, 3, 2]) # Returns 3 find_single_number([0, 1, 0, 1, 0, 1, 99]) # Returns 99 ``` Constraints * The function should run in O(n) time complexity. * Do not use extra memory, i.e., O(1) space complexity. Explanation - Implement the function using bitwise operations. - Track the count of each bit that has appeared once or twice using two variables.","solution":"from typing import List def find_single_number(nums: List[int]) -> int: This function finds the single unique number in a list where every other number occurs exactly three times. This is done using bitwise operations to ensure a linear runtime complexity without extra memory usage. ones, twos = 0, 0 for num in nums: # First appearance: # Add it to ones if it\'s not there in twos ones = (ones ^ num) & ~twos # Second appearance: # Remove it from ones and add it to twos twos = (twos ^ num) & ~ones # If it appears the third time, it will be removed from ones and twos automatically return ones"},{"question":"# FizzBuzz Coding Question Context: You are implementing a simple yet popular coding problem to test basic algorithmic skills. The problem involves generating a sequence of numbers with specific substitutions based on divisibility rules. Task: Write a function named `fizzbuzz_sequence` that takes a single integer parameter `n` and returns an array containing numbers from 1 to `n`, following the rules: * For numbers which are multiples of both 3 and 5, append \\"FizzBuzz\\". * For numbers which are multiples of 3 (but not 5), append \\"Fizz\\". * For numbers which are multiples of 5 (but not 3), append \\"Buzz\\". * For other numbers, append the number itself. Input: * An integer `n` where `n >= 1`. Output: * A list of length `n` containing the sequence described above. Constraints: * `n` is a positive integer (1 <= n <= 10^5). Implementation Requirements: * Ensure proper input validation. * Optimize for performance to handle the upper limit of n efficiently. Example: ```python print(fizzbuzz_sequence(15)) # Output: [1, 2, \\"Fizz\\", 4, \\"Buzz\\", \\"Fizz\\", 7, 8, \\"Fizz\\", \\"Buzz\\", 11, \\"Fizz\\", 13, 14, \\"FizzBuzz\\"] ``` Further Requirements: 1. The function should raise a `ValueError` if `n` is less than 1. 2. Handle the possibility of `n` being `None` by raising a `TypeError`. Implement the function `fizzbuzz_sequence` adhering to the above requirements.","solution":"def fizzbuzz_sequence(n): Generates a FizzBuzz sequence up to n elements. :param n: int :returns: list :raises ValueError: if n is less than 1 :raises TypeError: if n is None or not an integer # Validate input if not isinstance(n, int): raise TypeError(\'Input must be an integer\') if n < 1: raise ValueError(\'Input must be a positive integer greater than or equal to 1\') # Generate FizzBuzz sequence fizzbuzz_list = [] for i in range(1, n + 1): if i % 3 == 0 and i % 5 == 0: fizzbuzz_list.append(\\"FizzBuzz\\") elif i % 3 == 0: fizzbuzz_list.append(\\"Fizz\\") elif i % 5 == 0: fizzbuzz_list.append(\\"Buzz\\") else: fizzbuzz_list.append(i) return fizzbuzz_list"},{"question":"# Regular Expression Matching with Dynamic Programming Background A common problem in computer science involves determining if a given input string matches a specified pattern. Patterns may contain characters and special symbols like \'.\' and \'*\'. In this problem: - **\'.\'**: Matches any single character. - **\'*\'**: Matches zero or more of the preceding element. Task You need to write a function `is_match(s: str, p: str) -> bool` that checks if the entire string `s` matches the pattern `p`. # Function Signature ```python def is_match(s: str, p: str) -> bool: # Your code here ``` Input - `s`: A string containing only lowercase alphabets (`1 <= len(s) <= 1000`). - `p`: A string containing lowercase alphabets, `.` and `*` (`1 <= len(p) <= 1000`). Output - A boolean indicating whether the entire string `s` matches the pattern `p`. Constraints - The string can only contain lowercase alphabets. - The pattern can contain lowercase alphabets, \'.\' and \'*\'. - The matching must cover the entire input string (not partial). Example ```python print(is_match(\\"aa\\", \\"a\\")) # False print(is_match(\\"aa\\", \\"aa\\")) # True print(is_match(\\"aaa\\", \\"aa\\")) # False print(is_match(\\"aa\\", \\"a*\\")) # True print(is_match(\\"aa\\", \\".*\\")) # True print(is_match(\\"ab\\", \\".*\\")) # True print(is_match(\\"aab\\", \\"c*a*b\\")) # True ``` # Performance The solution needs to: - Handle edge cases such as empty strings and patterns. - Be optimized for both time and space complexity.","solution":"def is_match(s: str, p: str) -> bool: Returns True if the string `s` matches the pattern `p`. # Create a DP table with dimensions (len(s)+1) x (len(p)+1) dp = [[False] * (len(p) + 1) for _ in range(len(s) + 1)] # Empty string and empty pattern match dp[0][0] = True # Handle patterns with \'*\' that can match zero previous characters for j in range(2, len(p) + 1): if p[j - 1] == \'*\': dp[0][j] = dp[0][j - 2] # Fill the DP table for i in range(1, len(s) + 1): for j in range(1, len(p) + 1): if p[j - 1] == \'.\' or p[j - 1] == s[i - 1]: dp[i][j] = dp[i - 1][j - 1] elif p[j - 1] == \'*\': dp[i][j] = dp[i][j - 2] if p[j - 2] == \'.\' or p[j - 2] == s[i - 1]: dp[i][j] = dp[i][j] or dp[i - 1][j] return dp[-1][-1]"},{"question":"# Task: Implement the Stooge Sort algorithm in Python. Your function should sort an array of integers in non-descending order. # Function Signature: ```python def stoogesort(arr: list, l: int, h: int) -> None: ``` # Input: - `arr`: A list of integers to be sorted. - `l`: The starting index of the list. - `h`: The ending index of the list. # Output: The function should sort the list in place and does not return a value. # Constraints: - The list can contain up to 10^3 elements. - Each element in the list is an integer in the range [-10^3, 10^3]. # Example: ```python arr = [5, 3, 2, 4, 1] stoogesort(arr, 0, len(arr) - 1) print(arr) # Output should be [1, 2, 3, 4, 5] ``` # Explanation: You need to implement the Stooge Sort algorithm as described above. Make sure to handle all potential edge cases, such as single-element arrays or arrays that are already sorted.","solution":"def stoogesort(arr: list, l: int, h: int) -> None: if l >= h: return if arr[l] > arr[h]: arr[l], arr[h] = arr[h], arr[l] if h - l + 1 > 2: t = (h - l + 1) // 3 stoogesort(arr, l, h - t) stoogesort(arr, l + t, h) stoogesort(arr, l, h - t) # Example usage: arr = [5, 3, 2, 4, 1] stoogesort(arr, 0, len(arr) - 1) print(arr) # Output should be [1, 2, 3, 4, 5]"},{"question":"You are required to implement a messaging system that uses a queue to manage incoming messages. You need to implement both the array-based and linked list-based versions of the queue to handle the messages effectively. # Requirements You will implement two classes, `ArrayMessageQueue` and `LinkedListMessageQueue`, each representing a queue using an array and a linked list respectively. Each class must support the following operations: * **enqueue(message)**: Add a message to the end of the queue. * **dequeue()**: Remove and return the message at the front of the queue. If the queue is empty, raise an `IndexError` with the message \\"Queue is empty\\". * **peek()**: Return the message at the front of the queue without removing it. If the queue is empty, raise an `IndexError` with the message \\"Queue is empty\\". * **is_empty()**: Return `True` if the queue is empty, and `False` otherwise. * **__len__()**: Return the number of messages in the queue. # Constraints * The messages are represented as strings. * For the `ArrayMessageQueue`, you can start with an initial capacity of 10. * You are not allowed to use any built-in queue implementations (such as `collections.deque` or `queue.Queue`). # Example Usage ```python # Using ArrayMessageQueue queue = ArrayMessageQueue() queue.enqueue(\\"Message 1\\") queue.enqueue(\\"Message 2\\") print(queue.dequeue()) # Output: \\"Message 1\\" print(queue.peek()) # Output: \\"Message 2\\" print(len(queue)) # Output: 1 print(queue.is_empty()) # Output: False # Using LinkedListMessageQueue queue = LinkedListMessageQueue() queue.enqueue(\\"Message A\\") queue.enqueue(\\"Message B\\") print(queue.dequeue()) # Output: \\"Message A\\" print(queue.peek()) # Output: \\"Message B\\" print(len(queue)) # Output: 1 print(queue.is_empty()) # Output: False ``` # Submission You need to submit the implementation of both `ArrayMessageQueue` and `LinkedListMessageQueue` which follow the described interfaces.","solution":"class ArrayMessageQueue: def __init__(self): self.queue = [] self.capacity = 10 def enqueue(self, message): self.queue.append(message) def dequeue(self): if self.is_empty(): raise IndexError(\\"Queue is empty\\") return self.queue.pop(0) def peek(self): if self.is_empty(): raise IndexError(\\"Queue is empty\\") return self.queue[0] def is_empty(self): return len(self.queue) == 0 def __len__(self): return len(self.queue) class Node: def __init__(self, value): self.value = value self.next = None class LinkedListMessageQueue: def __init__(self): self.head = None self.tail = None self.size = 0 def enqueue(self, message): new_node = Node(message) if self.tail is not None: self.tail.next = new_node self.tail = new_node if self.head is None: self.head = new_node self.size += 1 def dequeue(self): if self.is_empty(): raise IndexError(\\"Queue is empty\\") value = self.head.value self.head = self.head.next if self.head is None: self.tail = None self.size -= 1 return value def peek(self): if self.is_empty(): raise IndexError(\\"Queue is empty\\") return self.head.value def is_empty(self): return self.size == 0 def __len__(self): return self.size"},{"question":"# Cycle Detection in a Directed Graph You are tasked with implementing a function to detect cycles in a directed graph using Depth-First Search (DFS) and a 3-color marking system. Each vertex in the graph can be in one of three states: - **WHITE** (unvisited), - **GRAY** (currently visiting), - **BLACK** (completely processed). A cycle is detected if a GRAY vertex is encountered during the DFS traversal. Function Signature ```python def contains_cycle(graph: dict) -> bool: pass ``` Input * `graph`: A dictionary representing a directed graph where each key is a vertex and its corresponding value is a list of its directed neighbors. - Example: ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'D\'], \'C\': [\'F\'], \'D\': [\'E\', \'F\'], \'E\': [\'B\'], \'F\': [] } ``` Output * Returns `True` if there is a cycle in the graph, `False` otherwise. Constraints * The graph does not contain duplicate edges. * Each vertex has a unique identifier (string). Scenarios 1. **Simple cycle**: ```python graph = { \'A\': [\'B\'], \'B\': [\'C\'], \'C\': [\'A\'] } ``` - Output: `True` 2. **No cycle**: ```python graph = { \'A\': [\'B\'], \'B\': [\'C\'], \'C\': [] } ``` - Output: `False` 3. **Self-loop**: ```python graph = { \'A\': [\'A\'] } ``` - Output: `True` 4. **Disconnected graph**: ```python graph = { \'A\': [\'B\'], \'B\': [], \'C\': [\'D\'] } ``` - Output: `False` Implement the function `contains_cycle` that: * Initializes all vertices to WHITE, * Uses DFS to traverse each vertex, * Marks vertices as GRAY when they are first visited and BLACK when completely processed, * Detects a cycle if a GRAY vertex is encountered during the DFS traversal, * Returns `True` if any cycle is found, `False` otherwise.","solution":"def contains_cycle(graph): WHITE, GRAY, BLACK = 0, 1, 2 color = {node: WHITE for node in graph} def dfs(node): if color[node] == GRAY: return True if color[node] == BLACK: return False color[node] = GRAY for neighbor in graph[node]: if dfs(neighbor): return True color[node] = BLACK return False for node in graph: if color[node] == WHITE: if dfs(node): return True return False"},{"question":"# RSA Encryption and Decryption Using Improved Key Generation You have been given snippets implementing RSA key generation, encryption, and decryption functions. In the current form, the code uses a simplified method for generating primes and computing the modular inverse, which can be inefficient for large key sizes. Your task is to improve the key generation algorithm and ensure it performs efficiently for larger bit sizes (e.g., 1024 bits). Task 1. Implement an efficient prime number generation method using the **Miller-Rabin primality test**. 2. Implement the **Extended Euclidean Algorithm** to find the modular inverse. 3. Modify the `generate_key` function to use these improvements. 4. Ensure the encryption and decryption functionalities remain consistent with the enhanced key generation. Function Signatures ```python def miller_rabin_is_prime(n, k=5): Implement the Miller-Rabin primality test to check if n is a prime number. :param n: integer, the number to test. :param k: integer, number of iterations for accuracy. :return: boolean, True if n is probably prime, False if n is composite. pass def extended_gcd(a, b): Implement the Extended Euclidean Algorithm to find the GCD and the coefficients. :param a: integer :param b: integer :return: tuple (g, x, y) where g is the gcd of a and b, and x, y are the coefficients. pass def modinv(a, m): Compute the modular inverse using the extended Euclidean algorithm. :param a: integer, the number to find the inverse of. :param m: integer, the modulus. :return: integer, the modular inverse of a modulo m. pass def generate_key(k, seed=None): Generate an RSA key pair with prime numbers using optimized methods. :param k: integer, the number of bits in n. :param seed: (optional) integer, seed for random number generation. :return: tuple (n, e, d) the modulus and the public and private exponents. pass ``` Constraints * Ensure the `generate_key` function uses an improved prime generation method with `miller_rabin_is_prime`. * Optimize the modular inverse calculation to improve efficiency for large bit sizes. * Handle large keys up to 1024 bits efficiently. * Preserve the functionality of the encryption and decryption methods. Example ``` # Testing the RSA implementation n, e, d = generate_key(1024) message = 123456789 encrypted_message = encrypt(message, e, n) decrypted_message = decrypt(encrypted_message, d, n) assert decrypted_message == message ``` **Note:** You are not restricted to these specific function names but ensure the overall functionality remains the same.","solution":"import random def miller_rabin_is_prime(n, k=5): Implement the Miller-Rabin primality test to check if n is a prime number. :param n: integer, the number to test. :param k: integer, number of iterations for accuracy. :return: boolean, True if n is probably prime, False if n is composite. if n in (2, 3): return True if n <= 1 or n % 2 == 0: return False # Write n as d*2^r + 1 r, d = 0, n - 1 while d % 2 == 0: r += 1 d //= 2 def check_composite(a, d, n, r): x = pow(a, d, n) if x == 1 or x == n - 1: return False for _ in range(r - 1): x = pow(x, 2, n) if x == n - 1: return False return True for _ in range(k): a = random.randrange(2, n - 1) if check_composite(a, d, n, r): return False return True def extended_gcd(a, b): Implement the Extended Euclidean Algorithm to find the GCD and the coefficients. :param a: integer :param b: integer :return: tuple (g, x, y) where g is the gcd of a and b, and x, y are the coefficients. if a == 0: return (b, 0, 1) g, y, x = extended_gcd(b % a, a) return (g, x - (b // a) * y, y) def modinv(a, m): Compute the modular inverse using the extended Euclidean algorithm. :param a: integer, the number to find the inverse of. :param m: integer, the modulus. :return: integer, the modular inverse of a modulo m. g, x, y = extended_gcd(a, m) if g != 1: raise ValueError(\'Modular inverse does not exist\') return x % m def generate_prime_candidate(length): Generate an odd integer randomly p = random.getrandbits(length) p |= (1 << length - 1) | 1 return p def generate_prime_number(length=1024): Generate a prime number of bit length `length` p = 4 while not miller_rabin_is_prime(p, 128): p = generate_prime_candidate(length) return p def generate_key(bits, seed=None): Generate an RSA key pair with prime numbers using optimized methods. :param bits: integer, the number of bits in the modulus n. :param seed: (optional) integer, seed for random number generation. :return: tuple (n, e, d) the modulus and the public and private exponents. if seed is not None: random.seed(seed) # Step 1: Generate two large prime numbers p and q p = generate_prime_number(bits // 2) q = generate_prime_number(bits // 2) # Step 2: Compute n = p * q n = p * q # Step 3: Compute the totient function phi(n) = (p-1)(q-1) phi = (p - 1) * (q - 1) # Step 4: Choose an integer e such that 1 < e < phi(n) and gcd(e, phi(n)) = 1 e = 65537 # Common choice for e # Step 5: Compute the modular inverse of e modulo phi(n) d = modinv(e, phi) return (n, e, d) def encrypt(message, e, n): Encrypt the message with the public exponent e and modulus n. :param message: integer, the plaintext message. :param e: integer, the public exponent. :param n: integer, the modulus. :return: integer, the ciphertext. return pow(message, e, n) def decrypt(ciphertext, d, n): Decrypt the ciphertext with the private exponent d and modulus n. :param ciphertext: integer, the ciphertext. :param d: integer, the private exponent. :param n: integer, the modulus. :return: integer, the plaintext message. return pow(ciphertext, d, n)"},{"question":"# Question: Implement a Doubly Linked List with Specific Operations You are required to implement a doubly linked list that supports the following operations: 1. **Insert**: Add a node with a given value to the end of the list. 2. **Delete**: Remove a node with a specific value from the list. 3. **Find**: Search for the first node with a given value. # Instructions: 1. Implement a `DoublyLinkedList` class with the aforementioned operations. 2. The list should also maintain and return its length. 3. Ensure to handle edge cases, such as inserting into an empty list, deleting from an empty list, and deleting a non-existent value. # Function Specifications: - **insert(value: int) -> None**: Adds a node with the specified value to the end of the list. - **delete(value: int) -> bool**: Removes the first occurrence of a node containing the specified value. Returns `True` if the deletion was successful, or `False` if the value was not found. - **find(value: int) -> Optional[DoublyLinkedListNode]**: Returns the node with the specified value if found, else returns `None`. - **length() -> int**: Returns the current number of nodes in the list. # Constraints: - Assume all values are integers. - The `delete` operation should not alter the list if the value is not present. # Example ```python dll = DoublyLinkedList() dll.insert(10) dll.insert(20) dll.insert(30) print(dll.length()) # Output: 3 found_node = dll.find(20) print(found_node.value if found_node else \\"Not found\\") # Output: 20 deleted = dll.delete(10) print(deleted) # Output: True print(dll.length()) # Output: 2 deleted = dll.delete(40) print(deleted) # Output: False ``` # Notes: - If the list is empty and a delete operation is attempted, return `False`. - All nodes in your implementation must be instances of the `DoublyLinkedListNode` class. ```python class DoublyLinkedListNode: def __init__(self, value): self.value = value self.next = None self.prev = None class DoublyLinkedList: def __init__(self): self.head = None self.tail = None self._length = 0 def insert(self, value: int) -> None: # Implement this method pass def delete(self, value: int) -> bool: # Implement this method pass def find(self, value: int) -> Optional[DoublyLinkedListNode]: # Implement this method pass def length(self) -> int: return self._length # Implement the class methods as per the above specifications. ```","solution":"class DoublyLinkedListNode: def __init__(self, value): self.value = value self.next = None self.prev = None class DoublyLinkedList: def __init__(self): self.head = None self.tail = None self._length = 0 def insert(self, value: int) -> None: new_node = DoublyLinkedListNode(value) if self.tail is None: # List is empty self.head = new_node self.tail = new_node else: # Append to the end new_node.prev = self.tail self.tail.next = new_node self.tail = new_node self._length += 1 def delete(self, value: int) -> bool: current = self.head while current: if current.value == value: if current.prev: current.prev.next = current.next else: self.head = current.next if current.next: current.next.prev = current.prev else: self.tail = current.prev self._length -= 1 return True current = current.next return False def find(self, value: int) -> \'DoublyLinkedListNode\': current = self.head while current: if current.value == value: return current current = current.next return None def length(self) -> int: return self._length"},{"question":"# Question: First Occurrence Finder You are given a function `first_occurrence(array, query)` that uses a binary search algorithm to find the first occurrence of a given number in a sorted array. However, this function is incomplete and doesn\'t correctly handle some edge cases and scenarios. Your task is to: 1. Correctly implement the function to ensure it returns a valid index. 2. Handle edge cases such as the element not being present in the array. # Expected Function Signature: ```python def first_occurrence(array: List[int], query: int) -> int: Returns the index of the first occurrence of the query in the sorted array; returns -1 if not found. ``` # Input 1. A list of integers `array` sorted in increasing order. 2. An integer `query` that needs to be searched in the array. # Output - An integer representing the index of the first occurrence of the `query` in the `array`. - If the `query` is not present in the `array`, return -1. # Examples Example 1: ```python array = [1, 2, 2, 4, 4, 4, 5] query = 4 assert first_occurrence(array, query) == 3 ``` Example 2: ```python array = [1, 2, 3, 5, 6] query = 4 assert first_occurrence(array, query) == -1 ``` # Constraints - The length of the array will be between 1 and 10^6. - The values in the array will be between -10^9 and 10^9. - The `query` value will also lie in the same range. # Performance Requirements - Your solution should work within O(log n) time complexity. - Solution should handle edge cases and avoid unnecessary comparisons or loops.","solution":"from typing import List def first_occurrence(array: List[int], query: int) -> int: Returns the index of the first occurrence of the query in the sorted array; returns -1 if not found. left, right = 0, len(array) - 1 result = -1 while left <= right: mid = (left + right) // 2 if array[mid] == query: result = mid # temporarily store the index right = mid - 1 # continue searching in the left half to find the first occurrence elif array[mid] < query: left = mid + 1 else: right = mid - 1 return result"},{"question":"Scenario You are developing a predictive model for an automated text generator. The system uses a Markov Chain to transition between characters or words based on the history of the previous ones. You are required to implement an extended version of the provided Markov Chain model to handle additional functionalities and edge cases. Task 1. **Function Implementation**: Implement a function `validate_and_sanitize_chain(chain)` to validate a provided Markov Chain and sanitize it for better performance. If the chain is invalid (transition probabilities don\'t sum to 1 or states not properly linked), print an appropriate error message and return an empty dictionary. If valid, you must normalize any mis-summed probabilities. 2. **Generator Implementation**: Fix the `iterating_markov_chain(chain, state, steps)` function to generate a finite number of steps through the Markov chain instead of running indefinitely. Constraints * Each state\'s transition probabilities should sum to 1. * There should be no missing transitions from a state; ensure there is always a valid transition path. * Your solution should handle large chain sizes efficiently. Input * `chain`: A dictionary representing the Markov Chain. ```python { \'A\': {\'A\': 0.6, \'B\': 0.4}, \'B\': {\'A\': 0.5, \'B\': 0.5} } ``` * `state`: A string representing the initial state. * `steps`: An integer representing the number of steps to take in the Markov chain. Output * `validate_and_sanitize_chain(chain)`: A sanitized markov chain dictionary. * `iterating_markov_chain(chain, state, steps)`: A list of states representing the Markov chain traversal for the given number of steps. Performance Requirements * The `validate_and_sanitize_chain` function should have a time complexity of O(n), where n is the number of states multiplied by the number of transitions. * The `iterating_markov_chain` function should run in O(m) time per step transition. # Example ```python chain = { \'A\': {\'A\': 0.3, \'B\': 0.3, \'C\': 0.4}, \'B\': {\'A\': 0.5, \'B\': 0.5}, \'C\': {\'A\': 1.0} } state = \'A\' steps = 5 print(validate_and_sanitize_chain(chain)) print(iterating_markov_chain(chain, state, steps)) ``` Expected Output: ```python # Validate and sanitize chain should correct the probability sums if needed. { \'A\': {\'A\': 0.3, \'B\': 0.3, \'C\': 0.4}, \'B\': {\'A\': 0.5, \'B\': 0.5}, \'C\': {\'A\': 1.0} } # The iterating process should yield a finite list of states based on the number of steps [\'B\', \'A\', \'B\', \'A\', \'B\'] ```","solution":"def validate_and_sanitize_chain(chain): Validate a provided Markov Chain and sanitize it for better performance. If the chain is invalid, print an appropriate error message and return an empty dictionary. If valid, normalize any mis-summed probabilities. for state, transitions in chain.items(): total_probability = sum(transitions.values()) if not (0.99 <= total_probability <= 1.01): # Allowing small floating point errors if not (0.99 <= total_probability <= 1.01): return {} # Normalize the probabilities for next_state in transitions: transitions[next_state] /= total_probability return chain import random def iterating_markov_chain(chain, state, steps): Generate a finite number of steps through the Markov chain. sequence = [] current_state = state for _ in range(steps): sequence.append(current_state) next_states = list(chain[current_state].keys()) probabilities = list(chain[current_state].values()) current_state = random.choices(next_states, probabilities)[0] return sequence"},{"question":"# Question: Implement Extended Binary Search Tree (BST) with Enhanced Functionalities You are given an incomplete implementation of a Binary Search Tree (BST) that supports typical operations (insertion, search, size calculation, and tree traversal). Your task is to extend this implementation with the following enhanced functionalities: 1. **Delete Function**: Implement the `delete` method which should remove a node with the specified value from the BST. 2. **Height Function**: Implement a `height` method to compute the height of the BST. 3. **Find Minimum and Maximum**: Implement `find_min` and `find_max` methods to find the minimum and maximum values stored in the BST respectively. 4. **Level Order Traversal**: Implement a `level_order` traversal method that prints the nodes level by level. Input and Output Formats 1. `delete(self, data: int) -> bool`: * **Input**: Integer `data`, the value to be deleted. * **Output**: Boolean indicating if the delete operation was successful (True if the node existed and was removed, False otherwise). 2. `height(self) -> int`: * **Output**: Integer representing the height of the tree. 3. `find_min(self) -> int`: * **Output**: Integer representing the minimum value in the BST. If the tree is empty, raise an exception. 4. `find_max(self) -> int`: * **Output**: Integer representing the maximum value in the BST. If the tree is empty, raise an exception. 5. `level_order(self) -> None`: * **Output**: Print the values of the nodes in level order. Constraints * Assume all values to be inserted, searched, and deleted are integers. * Outputs should match the specified formats precisely. * For simplified demonstration, the print statements in traversal methods are acceptable. # Example Suppose initially the BST contains the following values: 10, 6, 15, 4, 9, 12, 24, 7, 20, 30, 18. 1. After performing `delete(6)`, print the in-order traversal of the updated tree. **Inorder Output**: 4, 7, 9, 10, 12, 15, 18, 20, 24, 30 2. Result of `height()`: **Output**: 3 3. Result of `find_min()`: **Output**: 4 4. Result of `find_max()`: **Output**: 30 5. Level-order traversal of the tree: **Level Order Output**: 10 7 15 4 9 12 24 20 30 18","solution":"class TreeNode: def __init__(self, key): self.left = None self.right = None self.val = key class BinarySearchTree: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = TreeNode(key) else: self._insert(self.root, key) def _insert(self, root, key): if key < root.val: if root.left is None: root.left = TreeNode(key) else: self._insert(root.left, key) else: if root.right is None: root.right = TreeNode(key) else: self._insert(root.right, key) def search(self, key): return self._search(self.root, key) def _search(self, root, key): if root is None or root.val == key: return root elif key < root.val: return self._search(root.left, key) else: return self._search(root.right, key) def delete(self, key): self.root, deleted = self._delete(self.root, key) return deleted def _delete(self, root, key): if root is None: return root, False if key < root.val: root.left, deleted = self._delete(root.left, key) elif key > root.val: root.right, deleted = self._delete(root.right, key) else: if root.left is None: return root.right, True elif root.right is None: return root.left, True min_larger_node = self._find_min(root.right) root.val = min_larger_node.val root.right, _ = self._delete(root.right, root.val) return root, True return root, deleted def _find_min(self, root): while root.left is not None: root = root.left return root def find_min(self): if self.root is None: raise Exception(\\"The tree is empty\\") return self._find_min(self.root).val def _find_max(self, root): while root.right is not None: root = root.right return root def find_max(self): if self.root is None: raise Exception(\\"The tree is empty\\") return self._find_max(self.root).val def height(self): return self._height(self.root) def _height(self, root): if root is None: return -1 return 1 + max(self._height(root.left), self._height(root.right)) def level_order(self): if not self.root: return queue = [self.root] while queue: current = queue.pop(0) print(current.val, end=\' \') if current.left: queue.append(current.left) if current.right: queue.append(current.right) def inorder(self): if self.root: self._inorder(self.root) print() def _inorder(self, root): if root: self._inorder(root.left) print(root.val, end=\' \') self._inorder(root.right)"},{"question":"# Coding Challenge: Determine Strong Connectivity of a Directed Graph **Problem Statement**: You are given a directed graph consisting of `V` vertices and `E` edges. Your task is to determine if the graph is strongly connected. A graph is strongly connected if there is a path between any pair of vertices `(u, v)` and `(v, u)`. Implement a function `is_strongly_connected_graph(V, edges)` that takes the number of vertices `V` and a list of edges `edges`, where `edges[i] = [source, target]` represents a directed edge from `source` to `target`. Your function should return `True` if the graph is strongly connected, otherwise, return `False`. **Function Signature**: ```python def is_strongly_connected_graph(V: int, edges: List[List[int]]) -> bool: ... ``` **Input**: - `V`: An integer representing the number of vertices. - `edges`: A list of lists where each sublist `[source, target]` represents a directed edge from `source` to `target`. **Output**: - A boolean value indicating if the graph is strongly connected. **Constraints**: - `1 <= V <= 10^4` - `0 <= E <= 10^5` - `0 <= source, target < V` **Example**: ```python V = 5 edges = [ [0, 1], [1, 2], [2, 3], [3, 4], [4, 0], [1, 3], [3, 1] ] print(is_strongly_connected_graph(V, edges)) # Output: True ``` # Key Points to Consider: - Ensure all nodes are reachable from any given start node using DFS. - Ensure the reversed graph maintains connectivity from any start node. - Handle edge cases such as graphs with no edges or disconnected components.","solution":"from typing import List def is_strongly_connected_graph(V: int, edges: List[List[int]]) -> bool: # Helper function to perform DFS def dfs(graph, start, visited): stack = [start] while stack: node = stack.pop() if not visited[node]: visited[node] = True for neighbor in graph[node]: if not visited[neighbor]: stack.append(neighbor) # Build the graph and the reverse graph graph = [[] for _ in range(V)] reverse_graph = [[] for _ in range(V)] for u, v in edges: graph[u].append(v) reverse_graph[v].append(u) # Check if all nodes are reachable from node 0 in the original graph visited = [False] * V dfs(graph, 0, visited) if not all(visited): return False # Check if all nodes are reachable from node 0 in the reversed graph visited = [False] * V dfs(reverse_graph, 0, visited) if not all(visited): return False return True"},{"question":"# Keyboard Row Checker You are tasked with writing a function that assesses if words in a given list can be typed using letters from only one row of an American keyboard. The American keyboard layout consists of: - Top row: \\"qwertyuiop\\" - Middle row: \\"asdfghjkl\\" - Bottom row: \\"zxcvbnm\\" Your function should be case insensitive and focus only on alphabetic characters. Input - A list of strings (`words`) where each string represents a word. Output - A list of strings representing the words from the input list that can be typed using letters from only one row of an American keyboard. Function Signature ```python def find_keyboard_row(words: List[str]) -> List[str]: ``` Constraints - The input list can contain up to `10^4` words. - Each word can be up to `100` characters long. Example ```python Input: [\\"Hello\\", \\"Alaska\\", \\"Dad\\", \\"Peace\\"] Output: [\\"Alaska\\", \\"Dad\\"] ``` Scenario Imagine you\'re developing an educational typing game that only allows users to type words using letters from one row of the English keyboard. The game displays words that a user should practice. To generate this practice list, you need to filter out words that can be typed solely from one row of the keyboard, ensuring user practice focuses on one set of keys at a time. Your function will be critical in this filtering process. Edge Cases - An empty input list should return an empty list. - Mixed casing in words should not affect the output. - Non-alphabetic characters (if present in practice scenarios) should be ignored or handled correctly.","solution":"from typing import List def find_keyboard_row(words: List[str]) -> List[str]: # Defining rows of the American keyboard top_row = set(\\"qwertyuiop\\") middle_row = set(\\"asdfghjkl\\") bottom_row = set(\\"zxcvbnm\\") result = [] for word in words: lower_word = set(word.lower()) if lower_word.issubset(top_row) or lower_word.issubset(middle_row) or lower_word.issubset(bottom_row): result.append(word) return result"},{"question":"As a software developer, you are required to implement parts of the Huffman Coding algorithm. Specifically, you need to create functions to encode and decode text files using Huffman Coding. You can refer to the class templates provided but must write your own implementations. Requirements 1. **Character Frequency Calculation**: Implement a function to calculate the frequency of each character in a given text file. 2. **Huffman Tree Construction**: Implement a function to build the Huffman tree based on the character frequencies. 3. **Huffman Code Generation**: Create a function to generate the Huffman codes from the Huffman tree. 4. **Encoding and Decoding**: Write functions to encode a text file to a compressed binary file and decode a binary file back to the original text. Input and Output Formats 1. **Frequency Calculation** - Input: A string representing the file path of the text file. - Output: A dictionary where keys are characters and values are their frequencies. 2. **Huffman Tree Construction** - Input: A dictionary from the previous step (character frequencies). - Output: The root node of the Huffman tree. 3. **Huffman Code Generation** - Input: The root node of the Huffman tree. - Output: A dictionary where keys are characters and values are their corresponding Huffman codes. 4. **File Encoding** - Input: Two strings: input file path (text file) and output file path (compressed binary file). - Output: None (the function writes the compressed data to the output file). 5. **File Decoding** - Input: Two strings: input file path (compressed binary file) and output file path (decompressed text file). - Output: None (the function writes the decompressed data to the output file). Constraints - You may assume that the input files are small enough to fit in memory. - The input file path strings are valid and the files exist. - The output paths will always be writable. # Function Definitions ```python def calculate_frequency(file_path): Calculate the frequency of each character in the given text file. :param file_path: str, the path to the input text file. :return: dict, a dictionary with characters as keys and frequencies as values. pass def build_huffman_tree(frequency_dict): Build the Huffman tree using the given character frequencies. :param frequency_dict: dict, with characters as keys and frequencies as values. :return: Node, the root node of the Huffman tree. pass def generate_codes(tree_root): Generate Huffman codes from the given Huffman tree. :param tree_root: Node, the root node of the Huffman tree. :return: dict, a dictionary with characters as keys and codes as values. pass def encode_file(input_file_path, output_file_path): Encode a text file to a compressed binary file using Huffman coding. :param input_file_path: str, path to the input text file. :param output_file_path: str, path to the output binary file. pass def decode_file(input_file_path, output_file_path): Decode a binary file to the original text file using Huffman coding. :param input_file_path: str, path to the input binary file. :param output_file_path: str, path to the output text file. pass ``` # Explanation 1. **Frequency Calculation**: Calculate how often each character appears in the text file. 2. **Tree Construction**: Create a priority queue and build the Huffman tree by repeatedly merging the two nodes with the lowest frequencies. 3. **Code Generation**: Traverse the tree to assign binary codes to each character. 4. **File Encoding**: Read the input file, replace characters with their Huffman codes, and write the binary data to the output file. 5. **File Decoding**: Read the binary input file, decode it using the Huffman tree, and write the original text to the output file. Use the provided class templates to guide your implementation of the corresponding functions. Make sure to handle edge cases and test your functions thoroughly.","solution":"import heapq from collections import defaultdict, Counter import os class Node: def __init__(self, char, freq): self.char = char self.freq = freq self.left = None self.right = None def __lt__(self, other): return self.freq < other.freq def calculate_frequency(file_path): Calculate the frequency of each character in the given text file. :param file_path: str, the path to the input text file. :return: dict, a dictionary with characters as keys and frequencies as values. with open(file_path, \'r\') as file: text = file.read() return dict(Counter(text)) def build_huffman_tree(frequency_dict): Build the Huffman tree using the given character frequencies. :param frequency_dict: dict, with characters as keys and frequencies as values. :return: Node, the root node of the Huffman tree. priority_queue = [Node(char, freq) for char, freq in frequency_dict.items()] heapq.heapify(priority_queue) while len(priority_queue) > 1: left = heapq.heappop(priority_queue) right = heapq.heappop(priority_queue) merged = Node(None, left.freq + right.freq) merged.left = left merged.right = right heapq.heappush(priority_queue, merged) return priority_queue[0] def generate_codes(tree_root): Generate Huffman codes from the given Huffman tree. :param tree_root: Node, the root node of the Huffman tree. :return: dict, a dictionary with characters as keys and codes as values. codes = {} def generate_code(node, current_code): if node is None: return if node.char is not None: codes[node.char] = current_code generate_code(node.left, current_code + \'0\') generate_code(node.right, current_code + \'1\') generate_code(tree_root, \\"\\") return codes def encode_file(input_file_path, output_file_path): Encode a text file to a compressed binary file using Huffman coding. :param input_file_path: str, path to the input text file. :param output_file_path: str, path to the output binary file. frequency = calculate_frequency(input_file_path) huffman_tree = build_huffman_tree(frequency) codes = generate_codes(huffman_tree) with open(input_file_path, \'r\') as file: text = file.read() encoded_text = \'\'.join(codes[char] for char in text) with open(output_file_path, \'wb\') as output_file: data = bytearray() for i in range(0, len(encoded_text), 8): byte = encoded_text[i:i+8] data.append(int(byte, 2)) output_file.write(data) def decode_file(input_file_path, output_file_path): Decode a binary file to the original text file using Huffman coding. :param input_file_path: str, path to the input binary file. :param output_file_path: str, path to the output text file. frequency = calculate_frequency(input_file_path.replace(\'.enc\', \'.txt\')) # assuming .enc file as encoded file huffman_tree = build_huffman_tree(frequency) with open(input_file_path, \'rb\') as file: binary_data = file.read() encoded_text = \'\'.join(f\\"{byte:08b}\\" for byte in binary_data) current_node = huffman_tree decoded_text = \'\' for bit in encoded_text: if bit == \'0\': current_node = current_node.left else: current_node = current_node.right if current_node.char is not None: decoded_text += current_node.char current_node = huffman_tree with open(output_file_path, \'w\') as output_file: output_file.write(decoded_text)"},{"question":"Scenario You are working on a recommendation system for a retail company where you need to suggest the most similar products based on feature vectors representing various product attributes such as weight, price, and user ratings. To accomplish this, you need to implement the following functionality: 1. A function that calculates the Euclidean distance between two vectors. 2. A nearest neighbor function that finds and returns the closest product from a given set of products based on their feature vectors. Write the implementation of these functions following the specified requirements. Requirements 1. `euclidean_distance(x, y)`: * **Input**: Two tuples `x` and `y` of equal length representing the feature vectors of two products. * **Output**: A float representing the Euclidean distance between the two vectors. * **Constraints**: The length of the vectors must be the same. 2. `nearest_neighbor(x, tSet)`: * **Input**: * `x`: A tuple representing the feature vector of the product to find the nearest neighbor for. * `tSet`: A dictionary where keys are tuples representing feature vectors of products in the training set, and values are the product identifiers (e.g., product names, IDs). * **Output**: The identifier of the product in `tSet` that is closest to `x`. * **Constraints**: Both `x` and the keys of `tSet` are tuples of the same length. Code Skeleton ```python import math def euclidean_distance(x, y): Calculate the Euclidean distance between two vectors. Args: x (tuple): The first vector. y (tuple): The second vector. Returns: float: The Euclidean distance between the two vectors. # Your code here def nearest_neighbor(x, tSet): Find the nearest neighbor in the training set to the vector x. Args: x (tuple): The input vector. tSet (dict): A dictionary where keys are vectors in the training set, and values are the product identifiers. Returns: The product identifier of the nearest neighbor. # Your code here # Example usage: # tSet = { # (1.0, 2.0, 3.0): \'Product A\', # (4.0, 0.5, 2.1): \'Product B\', # (0.0, 2.1, 1.9): \'Product C\' # } # x = (2.0, 2.0, 2.0) # print(nearest_neighbor(x, tSet)) # Should print the identifier of the nearest product ``` Constraints 1. You must handle any assertion errors or edge cases, such as empty training sets or vectors of different lengths, appropriately. 2. The function `euclidean_distance` should not use any external libraries except for `math.sqrt`.","solution":"import math def euclidean_distance(x, y): Calculate the Euclidean distance between two vectors. Args: x (tuple): The first vector. y (tuple): The second vector. Returns: float: The Euclidean distance between the two vectors. # Check if the lengths of the two vectors are the same if len(x) != len(y): raise ValueError(\\"The vectors must be of the same length\\") # Calculate the sum of squared differences sum_squared_diff = sum((xi - yi) ** 2 for xi, yi in zip(x, y)) # Return the square root of the sum of squared differences return math.sqrt(sum_squared_diff) def nearest_neighbor(x, tSet): Find the nearest neighbor in the training set to the vector x. Args: x (tuple): The input vector. tSet (dict): A dictionary where keys are vectors in the training set, and values are the product identifiers. Returns: The product identifier of the nearest neighbor. if not tSet: raise ValueError(\\"The training set is empty\\") # Initialize minimum distance and the nearest product identifier min_distance = float(\'inf\') nearest_product = None # Iterate over each vector in the training set for tVector, identifier in tSet.items(): distance = euclidean_distance(x, tVector) if distance < min_distance: min_distance = distance nearest_product = identifier return nearest_product"},{"question":"# Question: Efficiently Searching a Priority Queue You are given a priority queue implemented as a max-heap and a query element. Write a function `find_in_priority_queue` that finds the first occurrence of a given element in this priority queue. **Function Signature**: ```python def find_in_priority_queue(priority_queue, query): pass ``` # Input: * `priority_queue`: A list of integers representing a max-heap. * `query`: An integer, the element to search for in the max-heap. # Output: * Return the index of the first occurrence of the query element in the max-heap. * If the element is not found, return -1. # Constraints: * You may assume all elements in the priority queue are unique. * The size of the priority queue `n` satisfies `1 <= n <= 10^5`. # Performance Requirements: * The solution must be optimized to run efficiently on large datasets. Aim for a time complexity better than O(n). # Example: ```python priority_queue = [15, 10, 12, 8, 5, 9, 11] query = 8 # The expected output is 3, as 8 is at index 3 priority_queue = [15, 10, 12, 8, 5, 9, 11] query = 4 # The expected output is -1, as 4 is not in the priority queue ``` **Explanation**: * A priority queue implemented using max-heap data structure maintains the highest priority element at the root. * The rest of the properties for insertion and maintenance of the heap should guide your approach in finding the required element efficiently.","solution":"def find_in_priority_queue(priority_queue, query): Returns the index of the first occurrence of the query element in the max-heap priority queue. def find_in_heap(index): if index >= len(priority_queue): return -1 if priority_queue[index] == query: return index # Given the max-heap property, if the current element is smaller than the query, # there\'s no use to look further since no child can be larger than the current element. if priority_queue[index] < query: return -1 # Recursively check the left and right children left_child_index = 2 * index + 1 right_child_index = 2 * index + 2 left_result = find_in_heap(left_child_index) if left_result != -1: return left_result return find_in_heap(right_child_index) return find_in_heap(0)"},{"question":"You are given a staircase with `steps` number of steps to reach the top. Each time, you can either climb 1 or 2 steps. Write a function `distinct_ways_to_climb(steps)` that computes and returns the number of distinct ways you can climb to the top. # Function Signature ```python def distinct_ways_to_climb(steps: int) -> int: ``` # Input * An integer `steps` (1 <= steps <= 10^5) representing the total number of steps. # Output * An integer representing the number of distinct ways to climb to the top of the staircase. # Constraints * The function should efficiently handle up to 100,000 steps. * You are not allowed to use any built-in functions for computing Fibonacci numbers. * Aim to achieve O(n) time complexity and O(1) space complexity. # Example ```python print(distinct_ways_to_climb(3)) # Output: 3 # Explanation: There are three ways to climb to the top: # 1. 1 step + 1 step + 1 step # 2. 1 step + 2 steps # 3. 2 steps + 1 step print(distinct_ways_to_climb(5)) # Output: 8 # Explanation: There are eight ways to climb to the top: # 1. 1 step + 1 step + 1 step + 1 step + 1 step # 2. 1 step + 1 step + 1 step + 2 steps # 3. 1 step + 1 step + 2 steps + 1 step # 4. 1 step + 2 steps + 1 step + 1 step # 5. 2 steps + 1 step + 1 step + 1 step # 6. 1 step + 2 steps + 2 steps # 7. 2 steps + 1 step + 2 steps # 8. 2 steps + 2 steps + 1 step ``` # Requirements * Implement the function without importing external libraries. * Handle edge cases (e.g., the minimum step of 1). # Implementation Notes * Dynamic programming and iterative approaches should be considered. * Ensure that the solution is optimized for both time and space.","solution":"def distinct_ways_to_climb(steps: int) -> int: Returns the number of distinct ways to climb to the top of a staircase with the given number of steps. # Edge cases if steps == 1: return 1 if steps == 2: return 2 prev2 = 1 # Ways to reach step 0 (base case) prev1 = 2 # Ways to reach step 1 (base case) for _ in range(3, steps + 1): current = prev1 + prev2 prev2 = prev1 prev1 = current return prev1"},{"question":"**Scenario**: You are working on a system that maintains a history of operations with stacks. One requirement is to extend the stack capabilities to allow efficient removal of the smallest element. You\'ll write a function that performs this operation while ensuring the order of other elements is preserved according to the stack\'s LIFO nature. **Task**: Implement a function named `enhanced_remove_min` that takes a list representing a stack and removes the smallest element in the stack. Ensure that the function is optimized for both time and space complexity and can handle large inputs efficiently. # Function Signature: ```python def enhanced_remove_min(stack: List[int]) -> List[int]: ``` # Input: * `stack` (List[int]): A list of integers where the end of the list represents the top of the stack. # Output: * A list of integers where the smallest value has been removed. # Constraints: * Do not use any additional data structures that scale with the size of the input. * Aim for improved time and/or space complexity over the provided approach. # Examples: 1. **Input**: `[2, 8, 3, -6, 7, 3]` **Output**: `[2, 8, 3, 7, 3]` 2. **Input**: `[1, 2, 3, 4, 5]` **Output**: `[2, 3, 4, 5]` 3. **Input**: `[5, 5, 5, 5]` **Output**: `[5, 5, 5]` # Notes: * Consider the efficiency of your implementation, particularly in terms of how you minimize space usage and the number of passes through the stack. * Think about potential edge cases, such as when the stack is empty or contains multiple occurrences of the minimum value.","solution":"def enhanced_remove_min(stack): Removes the smallest element from the stack. The stack is represented as a list where the end of the list represents the top of the stack. Parameters: stack (List[int]): The stack of integers. Returns: List[int]: The stack after removing the smallest element. if not stack: return stack # Find the minimum value in the stack min_value = min(stack) # Remove the first encountered min_value from the stack for i in range(len(stack)): if stack[i] == min_value: return stack[:i] + stack[i+1:]"},{"question":"# Advanced Matrix Manipulation Scenario You have been hired by a tech company that develops advanced image processing software. One of the core features of their software includes manipulation of images represented as matrices. You are tasked with implementing a set of matrix transformation functions efficiently. Objective Write a function `matrix_transform(matrix, operation)` that performs the specified transformation on a given matrix according to the operation provided. Requirements You need to implement the following transformations: 1. **Rotate Clockwise**: Rotate the matrix 90 degrees clockwise. 2. **Rotate Counterclockwise**: Rotate the matrix 90 degrees counterclockwise. 3. **Top Left Invert**: Invert the top-left quadrant of the matrix. 4. **Bottom Left Invert**: Invert the bottom-left quadrant of the matrix. Input and Output Formats - Input: - `matrix`: A 2D list representing the matrix (List[List[int]]). - `operation`: A string representing the transformation to perform (`\'rotate_clockwise\'`, `\'rotate_counterclockwise\'`, `\'top_left_invert\'`, `\'bottom_left_invert\'`). - Output: - A new 2D list representing the transformed matrix. Constraints - Assume all matrices are non-empty and rectangular (rows may have different lengths). - Maximum matrix dimensions are 1000x1000. # Function Signature ```python def matrix_transform(matrix, operation): pass ``` Example ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9], ] # Output for Rotate Clockwise Transformation # [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3], # ] # Output for Rotate Counterclockwise Transformation # [ # [3, 6, 9], # [2, 5, 8], # [1, 4, 7], # ] print(matrix_transform(matrix, \'rotate_clockwise\')) print(matrix_transform(matrix, \'rotate_counterclockwise\')) ``` Additional Context Ensure that your function handles edge cases gracefully and performs efficiently for larger matrices. You are encouraged to substitute `try...except` segmentations with more efficient list handling to showcase your optimization skills.","solution":"def matrix_transform(matrix, operation): def rotate_clockwise(m): return [list(row) for row in zip(*m[::-1])] def rotate_counterclockwise(m): return rotate_clockwise(rotate_clockwise(rotate_clockwise(m))) def invert(matrix, ul_row, ul_col, lr_row, lr_col): rows = lr_row - ul_row + 1 cols = lr_col - ul_col + 1 submatrix = [row[ul_col:ul_col+cols] for row in matrix[ul_row:ul_row+rows]] inverted_submatrix = [[1 - cell for cell in row] for row in submatrix] for r in range(rows): for c in range(cols): matrix[ul_row + r][ul_col + c] = inverted_submatrix[r][c] return matrix rows = len(matrix) cols = len(matrix[0]) if operation == \'rotate_clockwise\': return rotate_clockwise(matrix) elif operation == \'rotate_counterclockwise\': return rotate_counterclockwise(matrix) elif operation == \'top_left_invert\': return invert(matrix, 0, 0, rows // 2 - 1, cols // 2 - 1) elif operation == \'bottom_left_invert\': return invert(matrix, rows // 2, 0, rows - 1, cols // 2 - 1) else: raise ValueError(\\"Invalid operation\\")"},{"question":"# Coding Challenge: Finding the Added Character Scenario: You are tasked with identifying a newly added character to a string. Given the nature of databases, sometimes extra characters might slip into strings due to various reasons like user input errors, network issues, etc. Using your knowledge of XOR operations, you need to pinpoint the added character quickly and efficiently. Problem Statement: Write a function `find_difference(s: str, t: str) -> str` that takes two input strings, `s` and `t`, and returns the character that was added to the second string `t`. Input: * `s` - A string consisting of only lowercase letters of length n. * `t` - A string consisting of only lowercase letters of length n+1, generated by shuffling string `s` and adding one additional character at a random position. Output: * Return the single character that was added to `t`. Constraints: * 1 <= len(s) <= 10^5 Examples: ```python assert find_difference(\\"abcd\\", \\"abecd\\") == \'e\' assert find_difference(\\"xyz\\", \\"xyaz\\") == \'a\' assert find_difference(\\"\\", \\"a\\") == \'a\' ``` Explanation: In the first example, the character \'e\' is the additional character in `t`. In the second example, the character \'a\' is the additional character in `t`. In the third example, adding \'a\' to an empty string results in \'a\'. Notes: Leverage the properties of the XOR operation to efficiently solve this problem in linear time with constant space usage. Be mindful of edge cases where `s` is an empty string.","solution":"def find_difference(s: str, t: str) -> str: Finds the character that was added to string `t` which is modified from string `s` by adding one extra character. result = 0 for char in s + t: result ^= ord(char) return chr(result)"},{"question":"# Inorder Successor in BST Given a Binary Search Tree (BST) and a node, write a function to find the inorder successor of this node. The inorder successor of a node in a BST is the next node in the inorder traversal of the BST. You are not allowed to modify the BST, and your algorithm should operate in O(h) time complexity where h is the height of the tree. Function Signature ```python def find_inorder_successor(root: TreeNode, p: TreeNode) -> TreeNode: ``` Input * `root`: The root node of the BST. * `p`: The given node for which the inorder successor should be found. Output * Returns the inorder successor node of `p`. If `p` has no inorder successor in the BST, return `None`. Constraints * The number of nodes in the BST is in the range [1, 10^4]. * -10^5 <= Node.val <= 10^5 * All values in the BST are unique. * `p` is guaranteed to be in the BST. Example ```python # Example 1: # Input: root = [2,1,3], p = 1 # Output: 2 # Example 2: # Input: root = [5,3,6,2,4,None,None,1], p = 6 # Output: None ``` **Note**: You do not need to implement the tree-building logic or input parsing, focus solely on the `find_inorder_successor` function implementation.","solution":"# Definition for a binary tree node. class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find_inorder_successor(root: TreeNode, p: TreeNode) -> TreeNode: successor = None while root: if p.val < root.val: successor = root root = root.left else: root = root.right return successor"},{"question":"You are tasked with writing a function to generate all possible letter combinations that a given digit string could represent based on an old mobile phone keypad. Assign each digit to its corresponding letters using the following mapping: - 2: \\"abc\\" - 3: \\"def\\" - 4: \\"ghi\\" - 5: \\"jkl\\" - 6: \\"mno\\" - 7: \\"pqrs\\" - 8: \\"tuv\\" - 9: \\"wxyz\\" # Input A single string `digits` of length n (0 <= n <= 4) representing the digits pressed on the keypad. # Output A list of all possible letter combinations that the input digit string could represent. Output the combinations in lexicographical order. # Constraints - The input string will only contain digits from \'2\' to \'9\'. - The length of the digits string will not exceed 4 characters. # Example **Input**: ``` \\"23\\" ``` **Output**: ``` [\\"ad\\", \\"ae\\", \\"af\\", \\"bd\\", \\"be\\", \\"bf\\", \\"cd\\", \\"ce\\", \\"cf\\"] ``` # Additional Notes 1. If the input string is empty, return an empty list. 2. Assume each digit maps to a unique set of letters as described, so there cannot be invalid characters in the input. # Hints Consider using a combinatorial approach starting with the first digit and iterating over the corresponding possible letters, then moving on to the next digit and appending its possible letters to each previously generated combination recursively.","solution":"def letter_combinations(digits): Returns all possible letter combinations that the input digit string could represent. if not digits: return [] phone_map = { \\"2\\": \\"abc\\", \\"3\\": \\"def\\", \\"4\\": \\"ghi\\", \\"5\\": \\"jkl\\", \\"6\\": \\"mno\\", \\"7\\": \\"pqrs\\", \\"8\\": \\"tuv\\", \\"9\\": \\"wxyz\\" } def backtrack(index, path): if index == len(digits): combinations.append(\\"\\".join(path)) return possible_letters = phone_map[digits[index]] for letter in possible_letters: path.append(letter) backtrack(index + 1, path) path.pop() combinations = [] backtrack(0, []) return combinations"},{"question":"# Dynamic Island Counter In this task, you are to implement a function to dynamically count the number of islands in a 2D grid after each operation that turns water into land. An island is defined as a group of horizontally or vertically connected lands. You need to implement the following function: ```python def num_islands(rows: int, cols: int, positions: List[Tuple[int, int]]) -> List[int]: Parameters: - rows (int): The number of rows in the 2D grid. - cols (int): The number of columns in the 2D grid. - positions (List[Tuple[int, int]]): A list of tuples where each tuple contains the coordinates (row, col) of land positions to be added sequentially. Returns: - List[int]: A list containing the number of islands after each addLand operation. pass ``` Constraints: - The grid is initially filled with water. - Each position (row, col) will be within the bounds of the grid (0 <= row < rows, 0 <= col < cols). - No duplicate positions will be added. Each `addLand` operation adds a piece of land at the specified coordinates and the function should return the number of islands after each such operation. **Example:** Given `rows = 3`, `cols = 3`, `positions = [(0, 0), (0, 1), (1, 2), (2, 1)]`: Initially: ``` 0 0 0 0 0 0 0 0 0 ``` - After `addLand(0, 0)`: ``` 1 0 0 0 0 0 -> Number of islands = 1 0 0 0 ``` - After `addLand(0, 1)`: ``` 1 1 0 0 0 0 -> Number of islands = 1 0 0 0 ``` - After `addLand(1, 2)`: ``` 1 1 0 0 0 1 -> Number of islands = 2 0 0 0 ``` - After `addLand(2, 1)`: ``` 1 1 0 0 0 1 -> Number of islands = 3 0 1 0 ``` **Your task is to implement the function `num_islands` to solve the above problem.**","solution":"from typing import List, Tuple def num_islands(rows: int, cols: int, positions: List[Tuple[int, int]]) -> List[int]: def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: parent[rootX] = rootY parent = {} directions = [(0, 1), (0, -1), (1, 0), (-1, 0)] island_num = 0 results = [] for r, c in positions: if (r, c) in parent: results.append(island_num) continue parent[(r, c)] = (r, c) island_num += 1 # Add a new island for dr, dc in directions: nr, nc = r + dr, c + dc if (nr, nc) in parent: if find((r, c)) != find((nr, nc)): union((r, c), (nr, nc)) island_num -= 1 # Merge islands results.append(island_num) return results"},{"question":"Locate the nth Digit in Sequence Given an infinite sequence formed by concatenating all positive integers consecutively: \\"123456789101112131415...\\". The task is to find the `n`-th digit in this infinite sequence. Function Signature: ```python def find_nth_digit(n: int) -> int: ``` Inputs: - `n` (1 ≤ n ≤ 2^31 - 1): an integer representing the position in the infinite sequence. Output: - Returns an integer representing the digit located at the `n`-th position in the sequence. # Constraints: - The function must execute efficiently for large values of `n` up to (2^{31} - 1). - Memory usage should be minimal as only constant space is needed. # Examples: ```python assert find_nth_digit(1) == 1 assert find_nth_digit(9) == 9 assert find_nth_digit(10) == 1 assert find_nth_digit(11) == 0 assert find_nth_digit(189) == 9 assert find_nth_digit(190) == 1 assert find_nth_digit(191) == 0 ``` Hints: - Consider the size of the ranges (1-digit, 2-digit numbers, and so on). - Progressively subtract the range sizes until the correct digit length range is found. - Calculate the specific number and digit position in that number. # Context: Imagine a scenario where you need to determine a specific digit\'s position in an extensively large sequence formed by sequential positive integers due to mathematical puzzles or for digital web-based numeric games and sequences.","solution":"def find_nth_digit(n: int) -> int: length = 1 count = 9 start = 1 # Find the range where the nth digit is located while n > length * count: n -= length * count length += 1 count *= 10 start *= 10 # Find the exact number where the nth digit is located start += (n - 1) // length # Find the exact digit in that number s = str(start) return int(s[(n - 1) % length])"},{"question":"Consider the provided functions for converting integers to byte arrays and vice versa with different endianness. You are tasked with extending these functions and optimizing them, taking into account the mentioned performance bottlenecks and key improvement points. Write a Python function `optimized_int_to_bytes(num: int, endianness: str) -> bytes` which converts an integer to a byte array based on the specified endianness (\'big\' or \'little\') efficiently without using `deque`. Similarly, write another function `optimized_bytes_to_int(bytestr: bytes, endianness: str) -> int` that does the reverse conversion. # Function Signature ```python def optimized_int_to_bytes(num: int, endianness: str) -> bytes: pass def optimized_bytes_to_int(bytestr: bytes, endianness: str) -> int: pass ``` # Input 1. `num` - A non-negative integer that you need to convert (0 <= num < 2^64). 2. `endianness` - A string indicating the endianness, either \'big\' or \'little\'. 3. `bytestr` - A byte array that you need to convert back to integer. # Output - `optimized_int_to_bytes` should return a byte string representing the integer in required endianness. - `optimized_bytes_to_int` should return the integer represented by the byte array. # Constraints - You need to avoid using collections like `deque` and aim for list-only implementations. - Ensure your implementation handles edge cases such as zero or empty byte arrays correctly. # Examples ```python # Example 1 assert optimized_int_to_bytes(259, \'big\') == b\'x01x03\' assert optimized_int_to_bytes(259, \'little\') == b\'x03x01\' # Example 2 assert optimized_bytes_to_int(b\'x01x03\', \'big\') == 259 assert optimized_bytes_to_int(b\'x03x01\', \'little\') == 259 # Edge Case assert optimized_int_to_bytes(0, \'little\') == b\'x00\' assert optimized_bytes_to_int(b\'x00\', \'little\') == 0 ``` # Hints - Consider using bitwise operations for efficient conversion. - You may utilize helper functions to reduce redundancy. - Ensure your implementation is optimized for both time and space complexity.","solution":"def optimized_int_to_bytes(num: int, endianness: str) -> bytes: Converts an integer to a byte array based on the specified endianness (\'big\' or \'little\'). if num == 0: return b\'x00\' byte_array = [] while num: byte_array.append(num & 0xff) num >>= 8 if endianness == \'big\': byte_array.reverse() return bytes(byte_array) def optimized_bytes_to_int(bytestr: bytes, endianness: str) -> int: Converts a byte array to an integer based on the specified endianness (\'big\' or \'little\'). result = 0 if endianness == \'little\': bytestr = bytestr[::-1] for byte in bytestr: result = (result << 8) | byte return result"},{"question":"Given a string containing just the characters \'(\', \')\', \'{\', \'}\', \'[\' and \']\', determine if the input string is valid. An input string is valid if: 1. Open brackets are closed by the same type of brackets. 2. Open brackets are closed in the correct order. Write a function `is_valid(s: str) -> bool` that takes a string `s` as input and returns `True` if the string is valid, otherwise returns `False`. Example: 1. Input: `s = \\"()\\"`, Output: `True` 2. Input: `s = \\"()[]{}\\"`, Output: `True` 3. Input: `s = \\"(]\\"`, Output: `False` 4. Input: `s = \\"([)]\\"`, Output: `False` 5. Input: `s = \\"{[]}\\"`, Output: `True` Constraints: - The input string `s` can be empty. - The input string `s` only contains the characters \'(\', \')\', \'{\', \'}\', \'[\' and \']\', without any other characters. - Length of `s` will be at most (10^4).","solution":"def is_valid(s: str) -> bool: Determine if the input string s containing just the characters \'(\', \')\', \'{\', \'}\', \'[\' and \']\', is valid. stack = [] bracket_map = {\')\': \'(\', \'}\': \'{\', \']\': \'[\'} for char in s: if char in bracket_map: top_element = stack.pop() if stack else \'#\' if bracket_map[char] != top_element: return False else: stack.append(char) return not stack"},{"question":"# Subset Generation with Constraints You are given a set of distinct integers, `nums`. Your task is to implement a function that returns all possible subsets of these integers. However, to increase the complexity, you should apply the following constraints: 1. **Subsets must be returned in lexicographical order** — This means if `nums` is `[3, 1, 2]`, subsets should be sorted first ([1, 2, 3]) and then subsets should be generated (i.e., `[[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]`). 2. **Avoid using the built-in Python `sorted()` function** — You will need to use a sorting algorithm to achieve the sorted order before generating subsets. 3. **Handle edge cases gracefully** — Ensure your implementation correctly handles cases such as an empty input list. Input Format - A list of distinct integers `nums` where (0 leq text{len}(nums) leq 10) and each integer ( -10 leq text{nums[i]} leq 10 ). Output Format - A list of lists where each list represents a subset of `nums` in lexicographical order. Constraints - Subsets must be in lexicographical order without using Python\'s built-in sorting functions. Example ```python # Example 1 nums = [1, 2, 3] # Expected Output: # [ # [], # [1], # [1, 2], # [1, 2, 3], # [1, 3], # [2], # [2, 3], # [3] # ] # Example 2 nums = [3, 1, 2] # Expected Output: # [ # [], # [1], # [1, 2], # [1, 2, 3], # [1, 3], # [2], # [2, 3], # [3] # ] ``` Function Signature ```python def lexicographical_subsets(nums: List[int]) -> List[List[int]]: # TODO: Implement the function body pass ```","solution":"def lexicographical_subsets(nums): def merge_sort(arr): if len(arr) > 1: mid = len(arr)//2 L = arr[:mid] R = arr[mid:] merge_sort(L) merge_sort(R) i = j = k = 0 while i < len(L) and j < len(R): if L[i] < R[j]: arr[k] = L[i] i += 1 else: arr[k] = R[j] j += 1 k += 1 while i < len(L): arr[k] = L[i] i += 1 k += 1 while j < len(R): arr[k] = R[j] j += 1 k += 1 def generate_subsets(sorted_nums, index, current, result): result.append(current[:]) for i in range(index, len(sorted_nums)): current.append(sorted_nums[i]) generate_subsets(sorted_nums, i + 1, current, result) current.pop() result = [] merge_sort(nums) generate_subsets(nums, 0, [], result) return result"},{"question":"# Coding Task: Integer to Roman Numeral Converter You need to implement a function that converts a given integer into a Roman numeral. Roman numerals for 1 to 3999 are represented by specific characters: `I` (1), `V` (5), `X` (10), `L` (50), `C` (100), `D` (500), and `M` (1000), with certain rules regarding their combination. Task Write a function `convert_to_roman(n: int) -> str` that: 1. Takes an integer `n` as an input. 2. Returns a string which is the Roman numeral representation of that integer. Input * An integer `n` where (1 leq n leq 3999). Output * A string that represents the Roman numeral equivalent of the integer. Example ```python assert convert_to_roman(3) == \\"III\\" assert convert_to_roman(4) == \\"IV\\" assert convert_to_roman(9) == \\"IX\\" assert convert_to_roman(58) == \\"LVIII\\" assert convert_to_roman(1994) == \\"MCMXCIV\\" ``` Constraints * The function should handle the specific range of integers from 1 to 3999. * Ensure that the function is optimized for constant time execution.","solution":"def convert_to_roman(n: int) -> str: Converts an integer to a Roman numeral. Parameters: n (int): The integer to convert to a Roman numeral. Returns: str: The Roman numeral representation of the integer. val = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ] syb = [ \\"M\\", \\"CM\\", \\"D\\", \\"CD\\", \\"C\\", \\"XC\\", \\"L\\", \\"XL\\", \\"X\\", \\"IX\\", \\"V\\", \\"IV\\", \\"I\\" ] roman_num = \'\' i = 0 while n > 0: for _ in range(n // val[i]): roman_num += syb[i] n -= val[i] i += 1 return roman_num"},{"question":"As a part of understanding complex string manipulations and stack usage, you are tasked with implementing a function to decode a given encoded string. The encoded string follows a specific format where encoding is done as `k[encoded_string]`, meaning the `encoded_string` appears exactly `k` times. The encoded format is always valid (well-formed with no spaces, proper nesting, and placement). Your task is to implement the `decode_string(s)` function that decodes the given encoded string. Function Signature ```python def decode_string(s: str) -> str: pass ``` Parameters and Return Value * **Input**: - `s` (string): The encoded string which follows the given format containing digits, square brackets, and letters. * **Output**: - A decoded string resulting from processing all the encoded patterns in the given string. # Constraints - The input string `s` will be a valid encoded string. No extra white spaces in the string, valid nested brackets, and no digits other than repeat counts. - The repeat count `k` is a positive integer. - The length of the input string does not exceed 30,000 characters. Example Scenarios 1. **Input**: `\\"3[a]2[bc]\\"` - **Output**: `\\"aaabcbc\\"` 2. **Input**: `\\"3[a2[c]]\\"` - **Output**: `\\"accaccacc\\"` 3. **Input**: `\\"2[abc]3[cd]ef\\"` - **Output**: `\\"abcabccdcdcdef\\"` Explanation In example 1, \\"3[a]2[bc]\\" decodes as \\"aaa\\" + \\"bc\\" + \\"bc\\" = \\"aaabcbc\\". In example 2, \\"3[a2[c]]\\" decodes as three repetitions of \\"acc\\" (since \\"a2[c]\\" decodes to \\"acc\\"), resulting in \\"accaccacc\\". In example 3, \\"2[abc]\\" is decoded as \\"abcabc\\" and \\"3[cd]\\" as \\"cdcdcd\\", appended by \\"ef\\" to give the final \\"abcabccdcdcdef\\". **Implementation Note** Make sure your function handles nested brackets correctly and efficiently decodes the given string according to the described format.","solution":"def decode_string(s: str) -> str: Decodes the given encoded string according to the specified format. stack = [] current_num = 0 current_str = \'\' for char in s: if char.isdigit(): current_num = current_num * 10 + int(char) elif char == \'[\': # Push the current number and string onto the stack stack.append((current_str, current_num)) # Reset the current values current_str = \'\' current_num = 0 elif char == \']\': # Pop from the stack and repeat the current string last_str, repeat_num = stack.pop() current_str = last_str + current_str * repeat_num else: current_str += char return current_str"},{"question":"Given a sequence of integers, your task is to implement an optimized version of Bubble Sort that improves upon the basic implementation by eliminating unnecessary comparisons once the list is already sorted. Write a function `optimized_bubble_sort` that sorts the input list of integers in non-decreasing order. # Function Signature ```python def optimized_bubble_sort(arr: List[int]) -> List[int]: ``` # Input - `arr`: A list of integers. Example: `[64, 34, 25, 12, 22, 11, 90]`. # Output - The sorted list of integers in non-decreasing order. Example: `[11, 12, 22, 25, 34, 64, 90]`. # Constraints - `1 <= len(arr) <= 10^3` - All values in the array are integers within the range of `-10^6` to `10^6`. # Example ```python assert optimized_bubble_sort([64, 34, 25, 12, 22, 11, 90]) == [11, 12, 22, 25, 34, 64, 90] assert optimized_bubble_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] assert optimized_bubble_sort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5] ``` # Notes - To optimize Bubble Sort, you can track the last swapped position in each iteration and reduce the number of comparisons in subsequent iterations accordingly. - Ensure your implementation handles edge cases such as empty arrays and arrays with repeated values correctly.","solution":"def optimized_bubble_sort(arr): Sorts a list of integers in non-decreasing order using an optimized version of Bubble Sort. n = len(arr) while n > 1: new_n = 0 for i in range(1, n): if arr[i - 1] > arr[i]: arr[i - 1], arr[i] = arr[i], arr[i - 1] new_n = i n = new_n return arr"},{"question":"# Problem Description You are given a universal set `U` with `n` elements and a collection of subsets `S = {S1, S2, ..., Sm}` where each subset has an associated cost. Your task is to write two functions—one using an optimal (but computationally expensive) approach and another using a greedy heuristic—to find the minimum cost subcollection of `S` that covers all elements of `U`. # Input Format 1. A list `UNIVERSE` representing the universal set `U`. 2. A dictionary `SUBSETS` where keys are subset names and values are sets of elements. 3. A dictionary `COSTS` where keys match those in `SUBSETS` and values represent the cost associated with each subset. # Output Format * The first function should return the optimal subcollection of sets with the minimum cost. * The second function should return a near-optimal (greedy) subcollection of sets and their total cost. # Constraints * The elements in the universal set and subsets will be positive integers. * There will be at least one way to cover the universal set with the provided subsets. * The cost values will also be positive integers. * (1 leq |U| leq 20) * (1 leq |S| leq 10) # Function Signatures ```python def optimal_set_cover(UNIVERSE, SUBSETS, COSTS): # Implement the optimal powerset-based solution here pass def greedy_set_cover(UNIVERSE, SUBSETS, COSTS): # Implement the greedy algorithm here pass ``` # Example ```python # Input UNIVERSE = {1, 2, 3, 4, 5} SUBSETS = {\'S1\': {4, 1, 3}, \'S2\': {2, 5}, \'S3\': {1, 4, 3, 2}} COSTS = {\'S1\': 5, \'S2\': 10, \'S3\': 3} # Output optimal_cover = optimal_set_cover(UNIVERSE, SUBSETS, COSTS) optimal_cost = sum(COSTS[s] for s in optimal_cover) # optimal_cover should be {\'S2\', \'S3\'} and optimal_cost should be 13 greedy_cover = greedy_set_cover(UNIVERSE, SUBSETS, COSTS) greedy_cost = sum(COSTS[s] for s in greedy_cover) # greedy_cover should also be {\'S2\', \'S3\'} and greedy_cost should be 13 in this example, but may differ in other cases ```","solution":"from itertools import combinations def optimal_set_cover(UNIVERSE, SUBSETS, COSTS): Find the optimal set cover using an exhaustive search method. min_cost = float(\'inf\') min_cover = None subsets_keys = list(SUBSETS.keys()) for r in range(1, len(subsets_keys) + 1): for subset_comb in combinations(subsets_keys, r): combined_elements = set() cost = 0 for key in subset_comb: combined_elements.update(SUBSETS[key]) cost += COSTS[key] if combined_elements == UNIVERSE and cost < min_cost: min_cost = cost min_cover = subset_comb return set(min_cover) def greedy_set_cover(UNIVERSE, SUBSETS, COSTS): Find a greedy set cover. uncovered = set(UNIVERSE) selected_subsets = set() while uncovered: best_subset = None best_coverage = 0 best_cost_per_coverage = float(\'inf\') for subset, elements in SUBSETS.items(): if subset in selected_subsets: continue coverage = len(uncovered & elements) cost_per_coverage = COSTS[subset] / coverage if coverage > 0 else float(\'inf\') if coverage > best_coverage or (coverage == best_coverage and cost_per_coverage < best_cost_per_coverage): best_subset = subset best_coverage = coverage best_cost_per_coverage = cost_per_coverage uncovered -= SUBSETS[best_subset] selected_subsets.add(best_subset) return selected_subsets"},{"question":"# Scenario: Imagine you are working on a text-matching application. Your task is to compare strings and determine if they have the same structural pattern i.e., they are isomorphic. Two strings are defined as isomorphic if you can replace characters in one string to get another string while preserving the character order and structure. # Task: Write a function that verifies if two strings `s` and `t` are isomorphic. # Requirements: * Your function should be named `are_isomorphic`. * The function should receive two arguments, `s` and `t`, both of the type `str`. * It should return a boolean indicating `True` if the strings are isomorphic, and `False` otherwise. # Input: * Two strings `s` and `t`, each with a length of at most 100,000 characters. # Output: * A boolean value: `True` or `False`. # Constraints: * Both `s` and `t` will consist of lowercase English letters. # Performance: * Your solution should run in O(n) time complexity, where n is the length of the strings. * Aim for O(n) space complexity. # Example Cases: Example 1: * Input: `s = \\"egg\\"`, `t = \\"add\\"` * Output: `True` Example 2: * Input: `s = \\"foo\\"`, `t = \\"bar\\"` * Output: `False` Example 3: * Input: `s = \\"paper\\"`, `t = \\"title\\"` * Output: `True` # Additional Notes: * Ensure that no characters in `s` map to the same character in `t`. * Consider edge cases such as strings of different lengths, strings with repetitive characters, and large input sizes.","solution":"def are_isomorphic(s, t): Returns True if two strings s and t are isomorphic, otherwise False. if len(s) != len(t): return False mapping_s_to_t = {} mapping_t_to_s = {} for char_s, char_t in zip(s, t): if char_s in mapping_s_to_t: if mapping_s_to_t[char_s] != char_t: return False if char_t in mapping_t_to_s: if mapping_t_to_s[char_t] != char_s: return False mapping_s_to_t[char_s] = char_t mapping_t_to_s[char_t] = char_s return True"},{"question":"# Question: Implement Array Flattening Function You are given a multi-dimensional array which can have nested arrays at any level. Your task is to implement a function `flatten` that takes such an array and returns a flattened version of it. Function Signature ```python def flatten(input_arr): pass ``` Input * `input_arr` - A multi-dimensional array (a list containing elements, where each element can be an integer, a string, or another list, recursively). Output * A single list that contains all the elements of `input_arr` in a flat structure. Constraints * Do not use any libraries that provide flattening utilities. * The input array can have mixed types as elements but ensure that any iterable (except strings) gets flattened. * The input list can be arbitrarily nested. Example ```python assert flatten([1, 2, [3, 4, [5, 6]], [7, [8, 9]]]) == [1, 2, 3, 4, 5, 6, 7, 8, 9] assert flatten([[1, 2, [3]], 4, [[5, [6, 7], 8], 9], [10]]) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] assert flatten([[[[[\'a\']], \'b\'], \'c\'], [\'d\'], [[\'e\']], \'f\']) == [\'a\', \'b\', \'c\', \'d\', \'e\', \'f\'] ``` Additional Notes * Consider edge cases: an empty input list should return an empty list; a list containing only other empty lists should also return an empty list. * Pay attention to performance, considering both time and space complexities. * Ensure that your solution handles large inputs efficiently, possibly employing lazy evaluation or optimization techniques where necessary. * While implementing, avoid over-complicating; strive for a clear, recursive or iterative approach that is easy to understand and maintain.","solution":"def flatten(input_arr): Flattens a multi-dimensional array into a single list. Args: input_arr (list): A multi-dimensional array. Returns: list: A flattened version of input_arr. def _flatten(arr): for item in arr: if isinstance(item, list): yield from _flatten(item) else: yield item return list(_flatten(input_arr))"},{"question":"You are tasked with implementing the Radix Sort algorithm. Your implementation should allow for an optional simulation mode that prints the intermediate steps of sorting arrays. Given an array of non-negative integers, sort the array in ascending order. # Function Signature ```python def radix_sort(arr, simulation=False): ``` # Input * **arr**: A list of non-negative integers `[a1, a2, ..., an]`, where 0 ≤ ai ≤ 10^6 and 1 ≤ n ≤ 10^5. * **simulation**: A boolean flag indicating whether to print the intermediate steps (default is `False`). # Output * **A sorted list** of integers in ascending order. # Constraints * The list `arr` contains non-negative integers. * The simulation output should print each intermediate sorting step, showing the array state after each digit position processing. # Requirements 1. Implement the Radix Sort algorithm. 2. In `simulation` mode, print the intermediate array states where each line shows the state of the array after sorting by each digit position. # Example ```python # Example 1 arr = [170, 45, 75, 90, 802, 24, 2, 66] radix_sort(arr, simulation=True) ``` Expected Output: ``` iteration 0 : 170 45 75 90 802 24 2 66 iteration 1 : 170 90 802 2 24 45 75 66 iteration 2 : 802 2 24 45 66 170 75 90 iteration 3 : 2 24 45 66 75 90 170 802 ``` ```python # Example 2 arr = [10, 100, 1000, 10000] radix_sort(arr) # returns: [10, 100, 1000, 10000] ``` # Notes for Edge cases * If the input array is empty, return an empty list. * Ensure the handling of arrays containing a single element or all identical elements.","solution":"def counting_sort(arr, exp, simulation=False, iteration=0): n = len(arr) output = [0] * n count = [0] * 10 for i in range(n): index = (arr[i] // exp) % 10 count[index] += 1 if simulation: print(f\\"Count array at iteration {iteration} for exp {exp}: {count}\\") for i in range(1, 10): count[i] += count[i - 1] i = n - 1 while i >= 0: index = (arr[i] // exp) % 10 output[count[index] - 1] = arr[i] count[index] -= 1 i -= 1 for i in range(n): arr[i] = output[i] def radix_sort(arr, simulation=False): max_num = max(arr) if arr else 0 exp = 1 iteration = 0 while max_num // exp > 0: if simulation: print(f\\"Iteration {iteration} : {\' \'.join(map(str, arr))}\\") counting_sort(arr, exp, simulation, iteration) exp *= 10 iteration += 1 if simulation: print(f\\"Final sorted array : {\' \'.join(map(str, arr))}\\") return arr"},{"question":"You have been assigned a task to create a variant of the FizzBuzz sequence generator with extended rules. The traditional rules are: - Replace multiples of 3 with \\"Fizz\\". - Replace multiples of 5 with \\"Buzz\\". - Replace multiples of both 3 and 5 with \\"FizzBuzz\\". In addition, your variant should handle: - Replace multiples of 7 with \\"Whizz\\". - Replace multiples of 3 and 7 with \\"FizzWhizz\\". - Replace multiples of 5 and 7 with \\"BuzzWhizz\\". - Replace multiples of 3, 5, and 7 with \\"FizzBuzzWhizz\\". # Function Signature ```python def extended_fizzbuzz(n: int) -> List[str]: pass ``` # Input - `n` (1 <= n <= 10^6): An integer representing the length of the sequence. Note: it\'s guaranteed to be a positive integer within the specified range. # Output - A list of strings where each string is either: - \\"Fizz\\", \\"Buzz\\", \\"Whizz\\", \\"FizzBuzz\\", \\"FizzWhizz\\", \\"BuzzWhizz\\", \\"FizzBuzzWhizz\\", or the string representation of the number. # Constraints - You must ensure the solution runs efficiently for large values (up to 10^6). # Example ```python assert extended_fizzbuzz(15) == [ \'1\', \'2\', \'Fizz\', \'4\', \'Buzz\', \'Fizz\', \'Whizz\', \'8\', \'Fizz\', \'Buzz\', \'11\', \'Fizz\', \'13\', \'Whizz\', \'FizzBuzz\' ] assert extended_fizzbuzz(21) == [ \'1\', \'2\', \'Fizz\', \'4\', \'Buzz\', \'Fizz\', \'Whizz\', \'8\', \'Fizz\', \'Buzz\', \'11\', \'Fizz\', \'13\', \'Whizz\', \'FizzBuzz\', \'16\', \'17\', \'Fizz\', \'19\', \'Buzz\', \'FizzWhizz\' ] ```","solution":"from typing import List def extended_fizzbuzz(n: int) -> List[str]: result = [] for number in range(1, n + 1): output = \\"\\" if number % 3 == 0: output += \\"Fizz\\" if number % 5 == 0: output += \\"Buzz\\" if number % 7 == 0: output += \\"Whizz\\" if not output: output = str(number) result.append(output) return result"},{"question":"# Problem: Remove Recurring Characters You are tasked with writing a function that, given an input string, returns a new string with all recurring characters removed. The order of the characters in the returned string should be the same as their first appearance in the input string. Function Signature ```python def remove_recurring_characters(input_string: str) -> str: ``` Input * `input_string` (str): The input string, which consists of only ASCII characters. The length of the string is `1 <= len(input_string) <= 10^5`. Output * (str): A string with all recurring characters removed. Constraints * The order of characters in the output string must be the same as their first appearance in the input string. * The input string will not be empty. * Performance expectations: The solution should operate within O(n) time complexity. Example ```python assert remove_recurring_characters(\\"programming\\") == \\"progamin\\" assert remove_recurring_characters(\\"abcd\\") == \\"abcd\\" assert remove_recurring_characters(\\"aabbcc\\") == \\"abc\\" assert remove_recurring_characters(\\"mississippi\\") == \\"misp\\" ``` Scenario Imagine you are working on a system where you need to preprocess the user input to ensure no duplicate characters are present. For instance, you are designing a unique identifier generator where each identifier must be derived from the user’s name, except no characters repeat, and the order of characters remains as they were first seen. Instructions 1. Implement the function `remove_recurring_characters`. 2. Ensure your implementation finishes in O(n) time complexity. 3. Make sure to handle edge cases like strings with all unique characters, strings with all identical characters, or input strings being relatively large (near the upper constraint).","solution":"def remove_recurring_characters(input_string: str) -> str: Returns a new string with all recurring characters removed while retaining the order of their first appearance in the input string. seen = set() result = [] for char in input_string: if char not in seen: seen.add(char) result.append(char) return \'\'.join(result)"},{"question":"**Merge Check Algorithm** Problem Statement You are given three strings `s`, `part1`, and `part2`. Write a function `is_merge` that checks if the string `s` can be formed by a **merged sequence** of `part1` and `part2` while maintaining the order of characters in both `part1` and `part2`. # Function Signature ```python def is_merge(s: str, part1: str, part2: str) -> bool: pass ``` # Input - `s` (0 <= len(s) <= 100): The target string. - `part1` (0 <= len(part1) <= 100): First part string. - `part2` (0 <= len(part2) <= 100): Second part string. # Output - Return `True` if `s` can be formed by merging `part1` and `part2`. - Return `False` otherwise. # Constraints * All strings contain only lowercase English letters. # Example ```python assert is_merge(\\"codewars\\", \\"cdw\\", \\"oears\\") == True assert is_merge(\\"codewars\\", \\"cd\\", \\"wars\\") == False assert is_merge(\\"abcdef\\", \\"abc\\", \\"def\\") == True assert is_merge(\\"abcdef\\", \\"ab\\", \\"cdef\\") == True assert is_merge(\\"a\\", \\"\\", \\"a\\") == True assert is_merge(\\"a\\", \\"a\\", \\"\\") == True assert is_merge(\\"a\\", \\"\\", \\"\\") == False assert is_merge(\\"abc\\", \\"a\\", \\"abc\\") == False ``` # Explanation * For the string \\"codewars\\": - Part1: \\"cdw\\" - Part2: \\"oears\\" - `s` can be split and rearranged as \\"cdw\\" + \\"oears\\" with characters in the respective order. * For the string \\"codewars\\": - Part1: \\"cd\\" - Part2: \\"wars\\" - `s` cannot be formed with maintaining both parts in the same reading sequence. * For the string \\"abcdef\\": - Both \\"abc\\" and \\"def\\" combine to form `s`. * if `part1` is an empty string, the test should only check the similarity with `s` and `part2`, and vice versa. * If both `part1` and `part2` are empty, the function should return `False` unless `s` is also empty. Implement this function optimally and ensure to cover various edge cases.","solution":"def is_merge(s: str, part1: str, part2: str) -> bool: Check if the string s can be formed by merging part1 and part2 while maintaining the order of characters in both part1 and part2. if len(s) != len(part1) + len(part2): return False # Use dynamic programming to check the merge possibility dp = [[False] * (len(part2) + 1) for _ in range(len(part1) + 1)] dp[0][0] = True for i in range(len(part1) + 1): for j in range(len(part2) + 1): if i > 0 and dp[i-1][j] and s[i + j - 1] == part1[i - 1]: dp[i][j] = True if j > 0 and dp[i][j-1] and s[i + j - 1] == part2[j - 1]: dp[i][j] = True return dp[len(part1)][len(part2)]"},{"question":"# Question Objective You are given a dataset (array of integers) that you need to preprocess by filtering out values falling outside a specified range. This is often necessary to prevent outliers from skewing subsequent data analysis or visualizations. Task Write a Python function `limit(arr, min_lim=None, max_lim=None)` that filters an array of integers, returning a new list that includes only the elements between `min_lim` and `max_lim` (inclusive). # Function Signature ```python def limit(arr: list[int], min_lim: int=None, max_lim: int=None) -> list[int]: ``` # Input * `arr`: A list of integers. * `min_lim`: An optional integer representing the lower limit of the range. Default is `None`. * `max_lim`: An optional integer representing the upper limit of the range. Default is `None`. # Output * Returns a list of integers from the input list `arr` that are greater than or equal to `min_lim` and less than or equal to `max_lim`. # Constraints * The input list `arr` may contain up to (10^6) elements. * The integer values in `arr` range from (-10^9) to (10^9). * If `min_lim` is `None`, the filter should consider the smallest value from the input list as the lower limit. * If `max_lim` is `None`, the filter should consider the largest value from the input list as the upper limit. # Examples 1. `limit([1, 2, 3, 4, 5], None, 3)` should return `[1, 2, 3]`. 2. `limit([1, 20, 8, 4, 18], 4, 15)` should return `[20, 8, 4]`. 3. `limit([], 1, 10)` should return `[]`. 4. `limit([100, 200, 300, 400, 500], 150, None)` should return `[200, 300, 400, 500]`. # Notes * Feel free to use built-in functions such as `filter` and `lambda`. * Ensure the function handles edge cases like empty list, where all values fall outside the range, or if the range is specified as `None`.","solution":"from typing import List, Optional def limit(arr: List[int], min_lim: Optional[int]=None, max_lim: Optional[int]=None) -> List[int]: This function filters an array of integers, returning a new list that includes only the elements between `min_lim` and `max_lim` (inclusive). if not arr: return [] if min_lim is None: min_lim = min(arr) if max_lim is None: max_lim = max(arr) return [x for x in arr if min_lim <= x <= max_lim]"},{"question":"**Scenario**: You are developing a search engine that lists products in real-time as the user types in the search bar. To achieve this, you need a data structure that can efficiently store and search for product names based on their prefixes. **Problem Statement**: Implement a class `ProductTrie` which supports three methods: 1. **insert(product: str) -> None**: Adds the product to the trie. 2. **search(product: str) -> bool**: Returns True if the product is found in the trie, else False. 3. **starts_with(prefix: str) -> bool**: Returns True if there is any product in the trie that starts with the given prefix. **Constraints**: * All input products consist of lowercase English letters. * The length of each product is at most 100. * Assume there are at most 1,000,000 products. **Function Signature**: ```python class ProductTrie: def __init__(self): self.root = TrieNode() def insert(self, product: str) -> None: pass def search(self, product: str) -> bool: pass def starts_with(self, prefix: str) -> bool: pass ``` **Example**: ```python # Example Usage trie = ProductTrie() trie.insert(\\"apple\\") print(trie.search(\\"apple\\")) # Output: True print(trie.search(\\"app\\")) # Output: False print(trie.starts_with(\\"app\\")) # Output: True trie.insert(\\"app\\") print(trie.search(\\"app\\")) # Output: True ``` **Performance Requirements**: - The methods should have a time complexity of O(m), where m is the length of the input string for the respective operations.","solution":"class TrieNode: def __init__(self): self.children = {} self.end_of_product = False class ProductTrie: def __init__(self): self.root = TrieNode() def insert(self, product: str) -> None: node = self.root for char in product: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.end_of_product = True def search(self, product: str) -> bool: node = self.root for char in product: if char not in node.children: return False node = node.children[char] return node.end_of_product def starts_with(self, prefix: str) -> bool: node = self.root for char in prefix: if char not in node.children: return False node = node.children[char] return True"},{"question":"# Question: Implement a K-ZigZagIterator **Context**: You are tasked with extending the functionality of ZigZagIterator to handle `k` lists, instead of just two. This means that given `k` input lists, the iterator should traverse these lists in a zigzag fashion. **Function Signature**: ```python class KZigZagIterator: def __init__(self, lists: List[List[int]]): Initialize your data structure here. :type lists: List[List[int]] def next(self) -> int: :rtype: int def has_next(self) -> bool: :rtype: bool ``` **Input**: * `lists`: A list of `k` integer lists (1 <= k <= 1000). **Output**: * Your iterator class should support the `next()` and `has_next()` operations. * `next()` should return the next element in the zigzag iteration. * `has_next()` should return whether the iteration has more elements. **Constraints**: * Element counts in each list can vary, up to a maximum length of 1000 elements per list. * The iterator should efficiently handle the interleaving of elements without preprocessing all elements initially. **Examples**: ```python lists = [ [1, 2, 3], [4, 5, 6, 7], [8, 9] ] it = KZigZagIterator(lists) result = [] while it.has_next(): result.append(it.next()) print(result) ``` *Output*: [1, 4, 8, 2, 5, 9, 3, 6, 7] The order can be understood as: - 1 from the first list, - 4 from the second list, - 8 from the third list, - 2 from the first list, - 5 from the second list, - 9 from the third list, and so on… **Implementation Note**: Carefully handle empty lists. Ensure that your solution is efficient and works within the provided constraints.","solution":"from collections import deque class KZigZagIterator: def __init__(self, lists): Initialize your data structure here. :type lists: List[List[int]] self.queue = deque() for l in lists: if l: self.queue.append(iter(l)) def next(self): :rtype: int if self.queue: curr_iter = self.queue.popleft() next_elem = next(curr_iter) remaining_iter = list(curr_iter) if remaining_iter: self.queue.append(iter(remaining_iter)) return next_elem raise StopIteration(\\"No more elements\\") def has_next(self): :rtype: bool return len(self.queue) > 0"},{"question":"# Scenario In distributed systems and network communication, ensuring data integrity and compatibility is crucial. One common challenge is to handle the byte ordering (endianness) of integers correctly when sending data between systems. # Task Implement two utility functions to handle byte conversions: 1. `varint_encode(num)` that converts a given non-negative integer to its variable-length byte array representation. 2. `varint_decode(bytestr)` that converts a variable-length byte array representation back to the original integer. The variable-length encoding works as follows: * Numbers are divided into 7-bit chunks. * Each chunk is stored in the lower 7 bits of a byte, with the most significant bit (MSB) set to 1 to indicate there\'s another byte. * The last byte has its MSB set to 0. # Input/Output Formats * **Function 1**: `varint_encode(num)` * **Input**: A non-negative integer `num`. * **Output**: A list of bytes representing the variable-length encoding of the integer. * **Function 2**: `varint_decode(bytestr)` * **Input**: A list of bytes `bytestr` representing the variable-length encoding. * **Output**: The integer represented by the byte array. # Constraints * `num` will be at least 0 and will fit in a 64-bit unsigned integer representation. * `bytestr` will be a valid variable-length encoded byte array. # Examples * `varint_encode(300) -> [172, 2]` * Explanation: 300 in binary is 100101100, which breaks into 7-bit chunks: 0010110 and 10. These are encoded as 172 (10101100) and 2 (00000010). * `varint_decode([172, 2]) -> 300` # Requirements - The encoding function should have a time complexity of O(log(num)). - The decoding function should have a time complexity of O(m), where m is the length of the encoded byte array.","solution":"def varint_encode(num): This function encodes a given non-negative integer to its variable-length byte array representation. if num == 0: return [0] encoded_bytes = [] while num > 0: byte = num & 0x7F num >>= 7 if num > 0: byte |= 0x80 encoded_bytes.append(byte) return encoded_bytes def varint_decode(bytestr): This function decodes a variable-length byte array representation back to the original integer. num = 0 shift = 0 for byte in bytestr: num |= (byte & 0x7F) << shift if byte & 0x80 == 0: break shift += 7 return num"},{"question":"You are required to implement a circular buffer-based queue which prevents the overhead of resizing operations seen in the simple array-based queue implementation. This will help in optimizing the performance of the queue operations by reusing the space of elements that have been dequeued. Requirements: 1. Implement the `CircularQueue` class that follows the Queue ADT principles provided. 2. Operations to implement: `enqueue(item)`, `dequeue()`, `is_empty()`, `peek()`, `size()`, and `__iter__()`. 3. Ensure that enqueuing into a full queue raises an OverflowError. Class Signature: ```python class CircularQueue: def __init__(self, capacity=10): Initializes the queue with a given capacity. Throws ValueError if capacity is less than 1. pass def enqueue(self, value): Adds a new item to the rear of the queue. Raises OverflowError if the queue is full. pass def dequeue(self): Removes and returns the front item of the queue. Raises IndexError if the queue is empty. pass def peek(self): Returns the front item of the queue without removing it. Raises IndexError if the queue is empty. pass def is_empty(self): Checks if the queue is empty. Returns a boolean. pass def size(self): Returns the current number of items in the queue. pass def __iter__(self): Iterates over the items in the queue from front to rear. pass ``` Constraints: - You must not use any built-in Python data structures like `collections.deque`. - The queue should dynamically circle back to use empty space at the beginning of the array once the end is reached. Example Usage: ```python q = CircularQueue(5) q.enqueue(1) q.enqueue(2) q.enqueue(3) print(q.dequeue()) # Output: 1 print(q.peek()) # Output: 2 q.enqueue(4) q.enqueue(5) q.enqueue(6) # Should raise OverflowError for item in q: print(item) # Output: 2 3 4 5 ``` Performance Requirements: - `enqueue()`, `dequeue()`, `is_empty()`, `peek()`, and `size()` must all operate in O(1) time complexity. Notes: - Handle all possible edge cases. - Write clear, modular, and well-documented code. - Validate inputs where necessary.","solution":"class CircularQueue: def __init__(self, capacity=10): Initializes the queue with a given capacity. Throws ValueError if capacity is less than 1. if capacity < 1: raise ValueError(\\"Capacity must be at least 1\\") self.capacity = capacity self.queue = [None] * capacity self.front = 0 self.rear = 0 self.count = 0 def enqueue(self, value): Adds a new item to the rear of the queue. Raises OverflowError if the queue is full. if self.count == self.capacity: raise OverflowError(\\"Queue is full\\") self.queue[self.rear] = value self.rear = (self.rear + 1) % self.capacity self.count += 1 def dequeue(self): Removes and returns the front item of the queue. Raises IndexError if the queue is empty. if self.count == 0: raise IndexError(\\"Queue is empty\\") value = self.queue[self.front] self.queue[self.front] = None self.front = (self.front + 1) % self.capacity self.count -= 1 return value def peek(self): Returns the front item of the queue without removing it. Raises IndexError if the queue is empty. if self.count == 0: raise IndexError(\\"Queue is empty\\") return self.queue[self.front] def is_empty(self): Checks if the queue is empty. Returns a boolean. return self.count == 0 def size(self): Returns the current number of items in the queue. return self.count def __iter__(self): Iterates over the items in the queue from front to rear. for i in range(self.count): yield self.queue[(self.front + i) % self.capacity]"},{"question":"Problem Statement: You are given a stack of integers, and your task is to write a function `stutter_stack` that doubles each element in the input stack by replacing each value with two occurrences of that value, while maintaining the order. # Function Signature: `def stutter_stack(stack: List[int]) -> List[int]:` # Input: - `stack`: A list of integers representing the stack, where the end of the list is considered the top of the stack. # Output: - A list of integers representing the modified stack where each element appears twice, retaining the original order. # Constraints: - Do not use any libraries other than collections for helping with stack operations. - Handle edge cases gracefully, such as an empty stack or a stack with a single element. - The function should run efficiently with a time complexity of O(n) and space complexity of O(n). # Example: ```python input_stack = [3, 7, 1, 14, 9] output_stack = stutter_stack(input_stack) # output_stack should be [3, 3, 7, 7, 1, 1, 14, 14, 9, 9] ``` # Explanation: Given the input stack [3, 7, 1, 14, 9], `stutter_stack` returns [3, 3, 7, 7, 1, 1, 14, 14, 9, 9] by doubling the occurrence of each element. # Note: - Design the function to use either a single additional stack or a queue to achieve the task. - Ensure to analyze any performance or space inefficiencies and take measures to address them.","solution":"def stutter_stack(stack): Given a stack represented by a list of integers, doubles each element by replacing each value with two occurrences of that value, maintaining the order. Args: stack (list of int): The stack of integers, where the end of the list is the top of the stack. Returns: list of int: The modified stack with each value appearing twice consecutively. # Initialize an empty list to store the doubled elements doubled_stack = [] # Iterate over each element in the original stack for element in stack: # Append the element twice doubled_stack.append(element) doubled_stack.append(element) return doubled_stack"},{"question":"You are tasked with implementing a function that determines the next perfect square after a given integer. If the input number is not a perfect square, your function should return `-1`. # Function Specification Function Name `find_next_square` Input - `sq` (int): An integer which is the candidate to check for being a perfect square. Output - (int): The next perfect square after the given number, or `-1` if the input number is not a perfect square. # Constraints - `sq` will be a non-negative integer. # Performance Requirements - Your solution should run in constant time and space. # Example ```python assert find_next_square(121) == 144 assert find_next_square(625) == 676 assert find_next_square(114) == -1 ``` # Instructions 1. Implement the function `find_next_square`. 2. Ensure your function handles the edge cases where the input number is not a perfect square. 3. Your function should return an integer and adhere strictly to the defined input/output format. # Scenario In a game development setup, squares of grids might need to \'level up\' based on certain calculations triggered during gameplay. Your function will be critical in efficiently computing these next \'levels\' based on perfect squares, ensuring smooth and quick updates during the game\'s runtime. Good luck!","solution":"import math def find_next_square(sq): Given an integer sq, returns the next perfect square if sq is a perfect square. Otherwise, returns -1. # Check if sq is a perfect square root = math.isqrt(sq) if root * root == sq: # Return the next perfect square next_root = root + 1 return next_root * next_root else: # Return -1 if sq is not a perfect square return -1"},{"question":"You are asked to implement a function that calculates the n-th Fibonacci number. However, the function should meet specific constraints and performance requirements. # Requirements: 1. **Function Signature**: `def fibonacci(n: int) -> int:` 2. **Input**: * A single integer `n` (0 ≤ n ≤ 10^18). Assume the input will always be valid. 3. **Output**: * The n-th Fibonacci number as an integer. 4. **Performance Constraints**: * The function should be optimized for time and space efficiency. The expected time complexity should be O(log n), and space complexity should be O(1). 5. **Please use memoization or matrix exponentiation techniques to achieve the required performance**. # Specifications: * The function should handle large values of `n` efficiently. * Ensure there are no integer overflow issues (use Python\'s built-in capabilities to handle big integers). * Do not use direct recursion, as it will not meet the performance constraints. # Examples: ```python print(fibonacci(10)) # Output: 55 print(fibonacci(50)) # Output: 12586269025 print(fibonacci(100)) # Output: 354224848179261915075 ```","solution":"def fibonacci(n: int) -> int: Returns the n-th Fibonacci number using matrix exponentiation method to ensure O(log n) time complexity. if n == 0: return 0 elif n == 1: return 1 def matrix_mult(A, B): return [ [A[0][0]*B[0][0] + A[0][1]*B[1][0], A[0][0]*B[0][1] + A[0][1]*B[1][1]], [A[1][0]*B[0][0] + A[1][1]*B[1][0], A[1][0]*B[0][1] + A[1][1]*B[1][1]] ] def matrix_pow(matrix, power): result = [[1, 0], [0, 1]] # Identity matrix base = matrix while power > 0: if power % 2 == 1: result = matrix_mult(result, base) base = matrix_mult(base, base) power //= 2 return result # Matrix representation of the Fibonacci sequence F = [[1, 1], [1, 0]] result_matrix = matrix_pow(F, n - 1) return result_matrix[0][0] # The n-th Fibonacci number"},{"question":"# Combination Sum Problem Problem Statement You are given an integer array `nums` containing all positive numbers and a target integer `target`. Your task is to find the number of possible ordered combinations that add up to the target. Function Signature ```python def combination_sum(nums: List[int], target: int) -> int: ``` Input * `nums`: List of positive integers without duplicates. (1 <= len(nums) <= 200, 1 <= nums[i] <= 1000) * `target`: A positive integer. (1 <= target <= 1000) Output * An integer representing the number of possible ordered combinations that sum to the target. Constraints * The order of the numbers in combinations matters. * All given numbers in the array are positive. Example ```python nums = [1, 2, 3] target = 4 # The possible combination ways are: # (1, 1, 1, 1) # (1, 1, 2) # (1, 2, 1) # (1, 3) # (2, 1, 1) # (2, 2) # (3, 1) assert combination_sum(nums, target) == 7 ``` Follow-Up * What if negative numbers are allowed in the given array? How does it change the problem? * If negative numbers are allowed, the problem becomes more complex as it might potentially result in infinite combinations. Additional constraints are needed such as limiting the depth of recursion or preventing re-use of negative numbers to avoid infinite loops. Implementation Implement both top-down and bottom-up DP approaches, and ensure your solution efficiently handles edge cases and large inputs.","solution":"from typing import List def combination_sum(nums: List[int], target: int) -> int: Returns the number of possible ordered combinations that add up to the target. # Initialize a dp array with (target + 1) zeroes, representing ways to achieve each sum from 0 to target dp = [0] * (target + 1) # There is 1 way to make a sum of 0 (by choosing nothing) dp[0] = 1 # Build the dp array bottom up for current_target in range(1, target + 1): for num in nums: if current_target >= num: dp[current_target] += dp[current_target - num] return dp[target]"},{"question":"# Question: Implement a String Reversal Function Imagine a scenario where you manage a text processing system that requires efficient and reliable methods for reversing strings. Using your knowledge of algorithms and data structures, you need to implement a string reversal function in Python. You are required to write a function `reverse_string(s: str) -> str` that takes a string `s` as input and returns the reversed string. Ensure your implementation handles various edge cases and is optimized for performance and readability. **Input Format**: - A single string `s`. **Output Format**: - A single string representing the reversed input string `s`. **Constraints**: - `0 <= len(s) <= 10^6` **Performance Requirements**: - Your implementation should operate with a time complexity of (O(n)) and a space complexity of (O(n)). **Edge Cases to Consider**: - Empty string input should return an empty string. - Single character string input should return the same character. Example ```python # Example Input s = \\"hello\\" # Example Output \\"olleh\\" ``` Additional Examples ```python # Example Input s = \\"a\\" # Example Output \\"a\\" # Example Input s = \\"\\" # Example Output \\"\\" ```","solution":"def reverse_string(s: str) -> str: Returns the reversed string of the input string s. Parameters: s (str): The input string to be reversed. Returns: str: The reversed string. return s[::-1]"},{"question":"Implement a Moving Average Calculator using a sliding window. # Scenario: You are implementing a real-time data analysis tool to compute the moving average of readings from an online sensor. Given a stream of integer sensor readings and a window size, you need to efficiently calculate the moving average of the values within the sliding window. # Function Implementation Define a class `MovingAverage` that supports the following operations: `__init__(self, size: int) -> None` * Initializes the MovingAverage object with a fixed window size. * **Input**: `size` - An integer representing the size of the sliding window. `next(self, val: int) -> float` * Compute and return the current moving average after adding the new value to the sliding window. * **Input**: `val` - An integer representing the new value to be added. * **Output**: A float representing the moving average of the values in the sliding window. # Constraints * The valid range for values is `-10^4 <= val <= 10^4`. * The window size will always be greater than or equal to 1. * Ensure that the average calculation returns accurate floating-point results. # Example ```python m = MovingAverage(3) print(m.next(1)) # Output: 1.0 print(m.next(10)) # Output: 5.5 print(m.next(3)) # Output: 4.666666666666667 print(m.next(5)) # Output: 6.0 ``` # Additional Information: * Ensure your implementation handles continuous streams and properly manages window constraints. * Consider performance optimizations suitable for large-sized streams and windows.","solution":"from collections import deque class MovingAverage: def __init__(self, size: int) -> None: self.size = size self.window = deque() self.window_sum = 0.0 def next(self, val: int) -> float: if len(self.window) == self.size: self.window_sum -= self.window.popleft() self.window.append(val) self.window_sum += val return self.window_sum / len(self.window)"},{"question":"# Question: Implement and Utilize a Fenwick Tree Scenario You are working on a financial application that needs to keep track of daily incomes and compute cumulative finances efficiently. Due to the dynamic nature of the data, you will often update specific day\'s income and frequently need the sum of incomes over a range of days. Implementing a Fenwick Tree will help in managing these operations efficiently. Task Implement a Fenwick Tree class encapsulating the following functionalities: 1. **Constructor**: Initialize the tree with a given list of daily incomes. 2. **Update**: Add a value to a given day\'s income. 3. **Get Prefix Sum**: Return the sum of incomes from day 1 to a given day. Function Signatures You will need to implement the following methods: 1. **__init__(self, incomes: List[int])** 2. **update(self, day: int, income: int)** 3. **get_prefix_sum(self, day: int) -> int** Input and Output Format * The constructor takes a single argument - a list of integers where each integer represents the income for a specific day. * The `update` method takes two integers, `day` (1-indexed day of the month) and `income` (amount to add for that day). * The `get_prefix_sum` method takes an integer `day` (1-indexed day of the month) and returns the sum of incomes from day 1 to the given day. Constraints * 1 ≤ day ≤ length of the income array. * Daily incomes and updates can be negative. Example ```python # Initialize income records for 5 days fenwick = FenwickTree([100, 200, 300, 400, 500]) # Update the income on day 3 (add 50) fenwick.update(3, 50) # Get prefix sum up to day 3 print(fenwick.get_prefix_sum(3)) # Output: 650 ``` Implement the Fenwick Tree class based on the given requirements and example above.","solution":"class FenwickTree: def __init__(self, incomes): Initialize the Fenwick Tree with the given list of daily incomes. self.n = len(incomes) self.tree = [0] * (self.n + 1) for i, income in enumerate(incomes): self.update(i + 1, income) def update(self, day, income): Add a value to the given day\'s income. Day is 1-indexed. while day <= self.n: self.tree[day] += income day += day & -day def get_prefix_sum(self, day): Return the sum of incomes from day 1 to the given day. Day is 1-indexed. total = 0 while day > 0: total += self.tree[day] day -= day & -day return total"},{"question":"# Cocktail Shaker Sort Implementation Challenge Cocktail shaker sort, also known as bidirectional bubble sort, is a variation of the bubble sort that increases sorting efficiency by passing through the list in both directions alternatively. Task Implement the `cocktail_shaker_sort` function that sorts a given list of integers in ascending order. You may not use any built-in sort functions and must perform the sorting in-place. Input - A list of integers, `arr` (1 ≤ len(arr) ≤ 10^5). Output - The same list, sorted in ascending order. Example ```python Input: [5, 1, 4, 2, 8] Output: [1, 2, 4, 5, 8] ``` Constraints - Handle both negative and positive integers. - Avoid excessive swaps for large inputs to maintain efficiency. Requirements 1. The function should implement cocktail shaker sort. 2. The solution must maintain (O(1)) additional space. 3. Consider and handle edge cases such as already sorted arrays, arrays with duplicates, and edge sizes. ```python def cocktail_shaker_sort(arr): Implement cocktail shaker sort to sort a list in-place in ascending order. Parameters: arr (list of int): The input list of integers to be sorted. Returns: list of int: The sorted list of integers. # TODO: Implement this function to perform the sorting pass # Example Usage: # arr = [5, 1, 4, 2, 8] # print(cocktail_shaker_sort(arr)) # Output should be [1, 2, 4, 5, 8] ```","solution":"def cocktail_shaker_sort(arr): Implement cocktail shaker sort to sort a list in-place in ascending order. Parameters: arr (list of int): The input list of integers to be sorted. Returns: list of int: The sorted list of integers. n = len(arr) swapped = True start = 0 end = n - 1 while swapped: swapped = False # Move from left to right for i in range(start, end): if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] swapped = True if not swapped: break swapped = False end -= 1 # Move from right to left for i in range(end, start, -1): if arr[i] < arr[i - 1]: arr[i], arr[i - 1] = arr[i - 1], arr[i] swapped = True start += 1 return arr"},{"question":"Context: You are responsible for developing an application that manages configuration files based on user inputs. For uniformity and reliability, all file paths provided by users must be converted to their absolute paths irrespective of whether they are specified relative to the current directory or the user\'s home directory. Task: Write a function `resolve_file_path` that takes a single string input representing a file path and returns its absolute path. Your function must handle the following correctly: * Expand paths beginning with `~` to the user\'s home directory. * Resolve relative paths (starting without a leading `/`). * Ensure paths are converted to absolute paths. Input: * A string `path` that represents a file path. The string can be an absolute path, a relative path, or a user home directory referenced path. Output: * A string that is the absolute path to the given file. Constraints: * The input path is a valid file path string. * The function does not need to validate the existence of the file. Example: ```python assert resolve_file_path(\\"~/.bashrc\\") == \\"/home/user/.bashrc\\" # Assuming /home/user is the home directory assert resolve_file_path(\\"../Documents/config.txt\\") == \\"/home/user/Documents/config.txt\\" # Assuming the current directory is /home/user/Projects assert resolve_file_path(\\"/etc/hosts\\") == \\"/etc/hosts\\" # Absolute path remains unchanged ```","solution":"import os def resolve_file_path(path): Converts the provided file path to an absolute path. Parameters: path (str): The file path to be resolved. Returns: str: The absolute path. return os.path.abspath(os.path.expanduser(path))"},{"question":"# Question: Implement Enhanced Dijkstra\'s Algorithm Using Min-Heap Context Dijkstra\'s algorithm is a popular shortest path algorithm widely used in networking and pathfinding. The basic O(V^2) implementation, though easier to understand and implement, can be inefficient for large graphs. An improvement can be achieved using a min-heap to maintain vertices with the smallest tentative distance. Task Write an enhanced version of Dijkstra’s single-source shortest-path algorithm that utilizes a min-heap (priority queue) for better performance. Your implementation should be able to handle graphs more efficiently than the O(V^2) approach. # Function Signature ```python def dijkstra_min_heap(graph: List[List[int]], src: int) -> List[int]: :param graph: A 2D list representing the adjacency matrix of a directed, weighted graph. graph[u][v] is the weight of the edge from node u to node v, or 0 if there is no edge. Note: The graph will have non-negative weights only. :param src: The source vertex from which to calculate shortest paths. :return: A list where the value at index i is the shortest distance from the source vertex to vertex i. ``` # Input/Output Format * **Input**: A 2D list `graph` representing the weighted adjacency matrix of the graph, and an integer `src`. * The length of `graph` and depth of `graph[i]` is n (number of vertices). * `graph[i][j]` (0 ≤ i, j < n) represents the weight of the edge from vertex `i` to vertex `j`, or 0 if there is no edge. * **Output**: A list of integers where the i-th integer represents the shortest distance from the `src` vertex to vertex `i`. # Constraints * The graph will contain non-negative weights only. * 1 ≤ number of vertices ≤ 10^4 * 0 ≤ weight of any edge ≤ 10^3 # Example ```python graph = [ [0, 10, 20, 0], [10, 0, 0, 50], [20, 0, 0, 20], [0, 50, 20, 0], ] src = 0 result = dijkstra_min_heap(graph, src) print(result) # Output: [0, 10, 20, 40] ``` In the above example, the vertex set {0, 1, 2, 3} with varying edge weights shown in the adjacency matrix is processed from source vertex 0. The resulting shortest paths from the source are correct distances to each vertex.","solution":"import heapq from typing import List, Tuple def dijkstra_min_heap(graph: List[List[int]], src: int) -> List[int]: :param graph: A 2D list representing the adjacency matrix of a directed, weighted graph. graph[u][v] is the weight of the edge from node u to node v, or 0 if there is no edge. Note: The graph will have non-negative weights only. :param src: The source vertex from which to calculate shortest paths. :return: A list where the value at index i is the shortest distance from the source vertex to vertex i. n = len(graph) dist = [float(\'inf\')] * n dist[src] = 0 min_heap = [(0, src)] # (distance, vertex) while min_heap: current_dist, u = heapq.heappop(min_heap) if current_dist > dist[u]: continue for v in range(n): if graph[u][v] != 0: distance = graph[u][v] if dist[u] + distance < dist[v]: dist[v] = dist[u] + distance heapq.heappush(min_heap, (dist[v], v)) return dist"},{"question":"You are given access to a node in a singly linked list, and the node is guaranteed not to be the last node. Write a function `delete_node(node: Node) -> None` that deletes this node from the linked list. # Function Signature ```python def delete_node(node: Node) -> None: pass ``` # Input - node: A `Node` object pointing to the node to be deleted. It is guaranteed not to be the last node in the list and is never `None`. # Output - The function should not return anything. It should modify the linked list in place. # Constraints - The node will always be valid and exists within a non-empty list. - The node will never be the tail node. - You should not use any auxiliary data structures. - The length of the linked list will be between 2 and 1000. - The values stored in the list\'s nodes will be unique integers. # Example Example 1 - Input: 1 -> 2 -> 3 -> 4 (with the node having value 3) - Output: 1 -> 2 -> 4 Example 2 - Input: 5 -> 6 -> 7 -> 8 (with the node having value 7) - Output: 5 -> 6 -> 8 # Scenarios & Context Imagine a scenario where you have a linked list representing various tasks. Given direct access to a specific task\'s node and knowing it\'s not the last one, you need to remove this task efficiently. # Testing The provided test suite ensures the correctness of your implementation. You should consider and handle all edge cases (e.g., deleting a node from the middle of the list). ```python import unittest class Node: def __init__(self, x): self.val = x self.next = None def delete_node(node): if node is None or node.next is None: raise ValueError node.val = node.next.val node.next = node.next.next class TestSuite(unittest.TestCase): def test_delete_node(self): # make linkedlist 1 -> 2 -> 3 -> 4 head = Node(1) curr = head for i in range(2, 5): curr.next = Node(i) curr = curr.next # node2 = 3 node2 = head.next.next # after delete_node => 1 -> 2 -> 4 delete_node(node2) # checking resulting linked list curr = head self.assertEqual(1, curr.val) curr = curr.next self.assertEqual(2, curr.val) curr = curr.next self.assertEqual(4, curr.val) self.assertIsNone(curr.next) # make linkedlist 5 -> 6 -> 7 -> 8 head = Node(5) curr = head for i in range(6, 9): curr.next = Node(i) curr = curr.next node3 = head.next.next # node with value 7 # After deleting node with value 7, list -> 5 -> 6 -> 8 delete_node(node3) # verifying the linked list curr = head self.assertEqual(5, curr.val) curr = curr.next self.assertEqual(6, curr.val) curr = curr.next self.assertEqual(8, curr.val) self.assertIsNone(curr.next) # try deleting a last node should raise error self.assertRaises(ValueError, delete_node, curr) self.assertRaises(ValueError, delete_node, None) if __name__ == \'__main__\': unittest.main() ```","solution":"class Node: def __init__(self, x): self.val = x self.next = None def delete_node(node: Node) -> None: Given a node in a singly linked list that is not the last node, this function deletes the node from the list. if node is None or node.next is None: raise ValueError(\\"The node is invalid or is the last node.\\") # Copy the value of the next node to the current node node.val = node.next.val # Skip the next node node.next = node.next.next"},{"question":"# Question: Implementing and Using a Binary Search Tree (BST) Context You have been hired by a tech company to assist in optimizing their database queries. One key task involves frequently adding, removing, and searching for user accounts based on a unique user ID. A Binary Search Tree is well-suited for this task due to its efficient handling of dynamic data and quick search capabilities. Problem Statement Implement a Binary Search Tree class (`BST`) with the following methods: 1. **`insert(self, val: int) -> None`**: Insert a value into the BST. 2. **`delete(self, val: int) -> None`**: Delete a value from the BST. 3. **`search(self, val: int) -> bool`**: Return `True` if the value exists in the BST, otherwise `False`. 4. **`inorder_traversal(self) -> List[int]`**: Return a list of values representing the inorder traversal of the BST. Input/Output Formats - **Insert method**: * **Input**: an integer `val` * **Output**: None (modifies the tree in place) - **Delete method**: * **Input**: an integer `val` * **Output**: None (modifies the tree in place) - **Search method**: * **Input**: an integer `val` * **Output**: a boolean indicating whether `val` is found - **Inorder Traversal method**: * **Output**: a list of integers in ascending order (inorder traversal of the BST) Constraints: - No duplicate values will be introduced. - Operations will be interleaved (e.g., insertions followed by deletions and searches). Example: ```python # Initialize the tree bst = BST() # Insert values into BST bst.insert(10) bst.insert(5) bst.insert(15) bst.insert(2) bst.insert(7) # Search values in BST print(bst.search(7)) # Output: True print(bst.search(9)) # Output: False # Delete a value from BST bst.delete(5) # Inorder traversal of the tree print(bst.inorder_traversal()) # Output: [2, 7, 10, 15] ```","solution":"class TreeNode: def __init__(self, val=0): self.val = val self.left = None self.right = None class BST: def __init__(self): self.root = None def insert(self, val: int) -> None: if not self.root: self.root = TreeNode(val) else: self._insert(self.root, val) def _insert(self, node, val): if val < node.val: if node.left: self._insert(node.left, val) else: node.left = TreeNode(val) else: if node.right: self._insert(node.right, val) else: node.right = TreeNode(val) def search(self, val: int) -> bool: return self._search(self.root, val) def _search(self, node, val): if not node: return False if node.val == val: return True elif val < node.val: return self._search(node.left, val) else: return self._search(node.right, val) def delete(self, val: int) -> None: self.root = self._delete(self.root, val) def _delete(self, node, val): if not node: return node if val < node.val: node.left = self._delete(node.left, val) elif val > node.val: node.right = self._delete(node.right, val) else: if not node.left: return node.right elif not node.right: return node.left min_larger_node = self._get_min(node.right) node.val = min_larger_node.val node.right = self._delete(node.right, min_larger_node.val) return node def _get_min(self, node): while node.left: node = node.left return node def inorder_traversal(self) -> list: result = [] self._inorder_helper(self.root, result) return result def _inorder_helper(self, node, result): if node: self._inorder_helper(node.left, result) result.append(node.val) self._inorder_helper(node.right, result)"},{"question":"You are given two strings, `word_a` and `word_b`. Your task is to write a function `edit_distance_optimized(word_a, word_b)` which computes the minimum edit distance between the two strings. This function should optimize space usage while maintaining the same time complexity. Input: * `word_a`: A string of length `n` (1 <= n <= 2000) * `word_b`: A string of length `m` (1 <= m <= 2000) Output: * An integer representing the minimum number of operations required to transform `word_a` into `word_b`. Constraints: * Only insertions, deletions, and substitutions are allowed. * You need to optimize for space, keeping the space complexity to O(min(n, m)). Example: ```python assert edit_distance_optimized(\\"intention\\", \\"execution\\") == 5 assert edit_distance_optimized(\\"kitten\\", \\"sitting\\") == 3 assert edit_distance_optimized(\\"flaw\\", \\"lawn\\") == 2 assert edit_distance_optimized(\\"\\", \\"hello\\") == 5 ``` Performance Requirement: The solution should run within a reasonable time frame (a few seconds) for the given constraints on typical modern hardware with Python environment. Additional Context: You can optimize the space complexity by using only two arrays (previous and current) of size `min(n, m)` instead of the whole DP table. This heuristic still calculates the correct result by maintaining necessary states only between consecutive rows. Implement your `edit_distance_optimized` function below: ```python def edit_distance_optimized(word_a, word_b): # Your implementation here pass ```","solution":"def edit_distance_optimized(word_a, word_b): len_a = len(word_a) len_b = len(word_b) if len_a < len_b: word_a, word_b = word_b, word_a len_a, len_b = len_b, len_a previous_row = list(range(len_b + 1)) current_row = [0] * (len_b + 1) for i in range(1, len_a + 1): current_row[0] = i for j in range(1, len_b + 1): insert_cost = current_row[j - 1] + 1 delete_cost = previous_row[j] + 1 replace_cost = previous_row[j - 1] + (word_a[i - 1] != word_b[j - 1]) current_row[j] = min(insert_cost, delete_cost, replace_cost) previous_row, current_row = current_row, previous_row return previous_row[len_b]"},{"question":"# Two Sum Problem with Constraints You are given an array of integers and a target sum value. Write a function `two_sum` that finds the indices of the two numbers in the array that add up to the specified target sum. You need to implement extra error handling for cases where no pairs are found that sum up to the target. # Function Signature ```python def two_sum(array: List[int], target: int) -> Tuple[int, int]: pass ``` # Input * An array of integers (`array`), where `1 <= len(array) <= 10^5` and `-10^9 <= array[i] <= 10^9`. * An integer target value (`target`), where `-10^9 <= target <= 10^9`. # Output * Return a tuple (i, j), where `i` and `j` are the indices of the two numbers that add up to the target sum. * If there is no such pair, raise a `ValueError` with a message: \\"No two sum solution\\". # Constraints 1. You may assume that each input would have exactly one valid solution. 2. Do not repeat the same element for forming the pair. 3. Aim for a solution with O(n) time complexity and O(n) space complexity. # Example ```python assert two_sum([2, 7, 11, 15], 9) == (0, 1) assert two_sum([3, 2, 4], 6) == (1, 2) assert two_sum([3, 3], 6) == (0, 1) ``` # Error Handling Raise a `ValueError` if no solutions are found: ```python try: print(two_sum([1, 2, 3], 7)) except ValueError as e: print(e) # Output: No two sum solution ``` # Implementation Hints 1. Utilize a dictionary to store the indices of the numbers as you iterate through the array. 2. Ensure to check for each number if its complement (required value to reach the target) exists in the previously processed numbers.","solution":"from typing import List, Tuple def two_sum(array: List[int], target: int) -> Tuple[int, int]: Finds indices of the two numbers that add up to the target sum. :param array: List of integers. :param target: Target sum value. :return: A tuple of two indices. :raises ValueError: If no two sum solution exists. seen = {} for index, number in enumerate(array): complement = target - number if complement in seen: return seen[complement], index seen[number] = index raise ValueError(\\"No two sum solution\\")"},{"question":"**Scenario**: You are working as a software engineer at a company developing a task management application. The application requires an efficient data structure to manage tasks where users can frequently add, delete, and traverse tasks based on priority. You decide to use a Doubly Linked List to manage this functionality. **Task**: Implement a **DoublyLinkedList** class with the following methods: 1. **add_to_head(value)**: Adds a new node with the given `value` at the head of the list. 2. **add_to_tail(value)**: Adds a new node with the given `value` at the tail of the list. 3. **delete_node(node)**: Deletes a given node from the list. 4. **search(value)**: Searches for the first node with the given `value` and returns it. If not found, returns `None`. 5. **traverse_forward()**: Traverses the list from head to tail and returns a list of node values. 6. **traverse_backward()**: Traverses the list from tail to head and returns a list of node values. **Input/Output**: Each method should handle the necessary input and output as described below: - `add_to_head(value)`: No output. - `add_to_tail(value)`: No output. - `delete_node(node)`: No output. - `search(value) -> DoublyLinkedListNode or None`: Returns the node if found, else returns `None`. - `traverse_forward() -> List`: Returns a list of values in forward order. - `traverse_backward() -> List`: Returns a list of values in backward order. **Constraints**: - All nodes will contain unique values. - The list can initially be empty. - You may assume `delete_node` will only receive a node that exists in the list. ```python class DoublyLinkedListNode: def __init__(self, value): self.value = value self.next = None self.prev = None class DoublyLinkedList: def __init__(self): self.head = None self.tail = None def add_to_head(self, value): # Implement this method pass def add_to_tail(self, value): # Implement this method pass def delete_node(self, node): # Implement this method pass def search(self, value): # Implement this method pass def traverse_forward(self): # Implement this method pass def traverse_backward(self): # Implement this method pass ``` Your task is to complete the implementation of the above methods for the `DoublyLinkedList` class to ensure the list behaves as described.","solution":"class DoublyLinkedListNode: def __init__(self, value): self.value = value self.next = None self.prev = None class DoublyLinkedList: def __init__(self): self.head = None self.tail = None def add_to_head(self, value): new_node = DoublyLinkedListNode(value) if not self.head: self.head = self.tail = new_node else: new_node.next = self.head self.head.prev = new_node self.head = new_node def add_to_tail(self, value): new_node = DoublyLinkedListNode(value) if not self.tail: self.tail = self.head = new_node else: new_node.prev = self.tail self.tail.next = new_node self.tail = new_node def delete_node(self, node): if node.prev: node.prev.next = node.next else: self.head = node.next if node.next: node.next.prev = node.prev else: self.tail = node.prev node.next = node.prev = None def search(self, value): current = self.head while current: if current.value == value: return current current = current.next return None def traverse_forward(self): values = [] current = self.head while current: values.append(current.value) current = current.next return values def traverse_backward(self): values = [] current = self.tail while current: values.append(current.value) current = current.prev return values"},{"question":"Segment Tree Implementation and Usage **Context**: You are writing a variant of a segment tree based on the provided segment tree class. Your task is to not only implement the segment tree but also apply it to a range sum problem efficiently. Given a list of integers, you need to support the following operations: 1. `sumRange(i, j)`: Returns the sum of elements between indices i and j (inclusive). 2. `update(index, value)`: Updates the value at the specified index. **Function Specifications:** ```python class EnhancedSegmentTree: def __init__(self, nums: List[int]): Initializes an Enhanced Segment Tree with necessary data structures. pass def update(self, i: int, val: int): Updates the element at index i to val. pass def sumRange(self, i: int, j: int) -> int: Returns the sum of elements within the range [i, j]. pass ``` Input - `nums` is a list of integers initialized when creating the `EnhancedSegmentTree` object. - Each element in `nums` can range from -10^4 to 10^4. Output - For `sumRange(i, j)`, return the sum of elements between indices i and j (inclusive). - For `update(i, val)`, there is no return value. Constraints - The length of the input list `nums` ranges from 1 to 10^5. - Multiple queries (sumRange and update) will be called potentially in sequence. Example: ```python # Initialize segment tree with an array tree = EnhancedSegmentTree([1, 3, 5]) # Sum of range 0 to 2 is 1 + 3 + 5 = 9 print(tree.sumRange(0, 2)) # Output: 9 # Update index 1 to value 2 tree.update(1, 2) # Sum of range 0 to 2 is now 1 + 2 + 5 = 8 print(tree.sumRange(0, 2)) # Output: 8 ``` You need to implement the `EnhancedSegmentTree` class ensuring it uses a segment tree for efficient querying and updating. **Performance Requirements**: - Target time complexity for both `update` and `sumRange` operations should be O(log N). **Evaluation Criteria**: - Correctness of the implementation. - Efficiency and scalability to handle the maximum constraint. - Clean and robust code handling edge and corner cases effectively.","solution":"class EnhancedSegmentTree: def __init__(self, nums): Initializes an Enhanced Segment Tree with necessary data structures. self.nums = nums self.n = len(nums) self.tree = [0] * (2 * self.n) self.build_tree() def build_tree(self): # Building the tree from the leaves up to the root. for i in range(self.n): self.tree[self.n + i] = self.nums[i] for i in range(self.n - 1, 0, -1): self.tree[i] = self.tree[2 * i] + self.tree[2 * i + 1] def update(self, i, val): Updates the element at index i to val. pos = i + self.n self.tree[pos] = val while pos > 1: pos //= 2 self.tree[pos] = self.tree[2 * pos] + self.tree[2 * pos + 1] def sumRange(self, i, j): Returns the sum of elements within the range [i, j]. l, r = i + self.n, j + 1 + self.n sum_ = 0 while l < r: if l % 2: sum_ += self.tree[l] l += 1 if r % 2: r -= 1 sum_ += self.tree[r] l //= 2 r //= 2 return sum_"},{"question":"# Question: Counting Digits in a Number You are required to write a function that computes the number of digits in a given integer. Your implementation should be efficient with constant time complexity. Function Specification - **Function Name**: `count_digits` - **Input**: A single integer `n` where `-10^18 <= n <= 10^18`. - **Output**: Return an integer representing the number of digits in the number. Constraints - The input integer can be negative or positive. - For the integer 0, the function should return 1. Examples 1. **Input**: `n = 12345` - **Output**: `5` 2. **Input**: `n = -9876543210` - **Output**: `10` 3. **Input**: `n = 0` - **Output**: `1` Explanation of Examples - In the first example, `12345` has 5 digits. - In the second example, `-9876543210` is negative but has 10 digits. - In the third example, `0` is a special case where it should return 1 as it is counted as a single digit. Requirements Your implementation should have: - Efficient constant time complexity. - Proper handling of edge cases, including negative numbers and zero. Write the function in Python. ```python def count_digits(n): # Your implementation here pass # You may include additional test cases to validate your solution. ```","solution":"def count_digits(n): Returns the number of digits in the integer n. # Convert the number to its absolute value and then to a string # Then calculate the length of the string representation of the number return len(str(abs(n)))"},{"question":"You are given a very large sequence formed by concatenating all natural numbers starting from 1 together (e.g., \\"123456789101112...\\"). Write a function: ```python def find_nth_digit(n: int) -> int: pass ``` This function should take an integer `n` and return the nth digit in the sequence. # Input and Output Format - **Input**: A single integer `n` representing the position in the sequence. - Constraints: `1 <= n <= 10^18` - **Output**: An integer representing the nth digit in the sequence. # Examples - Example 1: `find_nth_digit(1)` should return `1` - Example 2: `find_nth_digit(10)` should return `1` (sequence starts with \\"12345678910...\\") # Constraints and Performance Requirements - Efficient processing is expected even for very high values up to `10^18`. - Avoid excessive memory use or unnecessary operations. Implementation Notes 1. Start by identifying the length of the number group where the nth digit is found. 2. Determine the specific number in that group. 3. Extract and return the particular digit in question. # Example Scenarios - **Scenario 1**: Small `n`, e.g., `n = 5`. This should be handled quickly as it\'s within the first few numbers. - **Scenario 2**: Larger `n`, e.g., `n = 100000`. Ensure the algorithm efficiently handles large numbers and transitions across number lengths. Please provide a solution in Python with the required accuracy and efficiency.","solution":"def find_nth_digit(n: int) -> int: # Start with the digit length digit_length = 1 count_of_slots = 9 start_number = 1 while n > digit_length * count_of_slots: n -= digit_length * count_of_slots digit_length += 1 count_of_slots *= 10 start_number *= 10 # Find the exact number where the nth digit is located number = start_number + (n - 1) // digit_length # Find the exact digit in the number digit_index = (n - 1) % digit_length return int(str(number)[digit_index])"},{"question":"# String Reversal Implementation Context: You need to validate a mechanism within a software system that relies heavily on string manipulations, particularly reversing strings. To ensure robustness, various approaches to string reversal must be evaluated. Task: Write a function `reverse_string(s: str) -> str` that takes a string as input and returns the string reversed, utilizing different methods provided: 1. Recursive 2. Iterative 3. Pythonic 4. Ultra Pythonic Input Format: - A single string `s` with length constraint (0 leq text{len}(s) leq 10^5). Output Format: - A single string which is the reversed version of the input string. Function Signature: ```python def reverse_string(s: str, method: str) -> str: pass ``` Constraints: - The `method` parameter will be one of the following: `\\"recursive\\"`, `\\"iterative\\"`, `\\"pythonic\\"`, `\\"ultra_pythonic\\"`. - Your solution should handle large strings efficiently for each method where applicable. Performance Requirements: - Optimal time and space complexity must be considered, especially for larger inputs. Examples: ```text reverse_string(\\"hello\\", \\"iterative\\") -> \\"olleh\\" reverse_string(\\"world\\", \\"recursive\\") -> \\"dlrow\\" reverse_string(\\"python\\", \\"pythonic\\") -> \\"nohtyp\\" reverse_string(\\"code\\", \\"ultra_pythonic\\") -> \\"edoc\\" ``` Instructions: 1. Implement the `reverse_string` function to reverse the string based on the specified method. 2. Handle edge cases, such as empty strings or very large input strings efficiently. 3. Ensure that the implemented function is performant and avoids unnecessary complexity.","solution":"def reverse_string(s: str, method: str) -> str: def recursive_reverse(s: str) -> str: if len(s) == 0: return s else: return s[-1] + recursive_reverse(s[:-1]) def iterative_reverse(s: str) -> str: reversed_str = \'\' for char in s: reversed_str = char + reversed_str return reversed_str def pythonic_reverse(s: str) -> str: return \'\'.join(reversed(s)) def ultra_pythonic_reverse(s: str) -> str: return s[::-1] if method == \\"recursive\\": return recursive_reverse(s) elif method == \\"iterative\\": return iterative_reverse(s) elif method == \\"pythonic\\": return pythonic_reverse(s) elif method == \\"ultra_pythonic\\": return ultra_pythonic_reverse(s) else: raise ValueError(\\"Invalid method. Choose from \'recursive\', \'iterative\', \'pythonic\', \'ultra_pythonic\'.\\")"},{"question":"# Question Description You are tasked with implementing a Trie (Prefix Tree) for a contact search system. The Trie will be used to store and search contact names efficiently. Your implementation should provide the following functionalities: 1. Insert a new contact name into the Trie. 2. Search for a contact name in the Trie. 3. Check if there is any contact name in the Trie that starts with a given prefix. # Function Signatures Implement the following methods: ```python class Trie: def __init__(self): Initialize your data structure here. pass def insert(self, word: str) -> None: Inserts a word into the trie. :param word: A string word to be inserted into the Trie. pass def search(self, word: str) -> bool: Returns if the word is in the trie. :param word: A string word to search in the Trie. :returns: True if the word is present, False otherwise. pass def starts_with(self, prefix: str) -> bool: Returns if there is any word in the trie that starts with the given prefix. :param prefix: A string prefix to search for in the Trie. :returns: True if any word starts with the prefix, False otherwise. pass ``` # Constraints * All inputs are guaranteed to be lowercase letters `a-z`. * The length of the contact name or prefix does not exceed 100 characters. # Input and Output 1. **Insert**: This method will not return anything. * Input: `insert(\\"example\\")` * Output: `None` 2. **Search**: This method will return a boolean indicating if the word is in the Trie. * Input: `search(\\"example\\")` * Output: `True` or `False` 3. **Starts With**: This method will return a boolean indicating if there is any word in the Trie that starts with the given prefix. * Input: `starts_with(\\"exam\\")` * Output: `True` or `False` # Example ```python trie = Trie() trie.insert(\\"contact\\") print(trie.search(\\"contact\\")) # Expected: True print(trie.search(\\"con\\")) # Expected: False print(trie.starts_with(\\"con\\")) # Expected: True print(trie.starts_with(\\"cta\\")) # Expected: False ``` Implement the `Trie` class to pass this functionality.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): Initialize your data structure here. self.root = TrieNode() def insert(self, word: str) -> None: Inserts a word into the trie. :param word: A string word to be inserted into the Trie. node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, word: str) -> bool: Returns if the word is in the trie. :param word: A string word to search in the Trie. :returns: True if the word is present, False otherwise. node = self.root for char in word: if char not in node.children: return False node = node.children[char] return node.is_end_of_word def starts_with(self, prefix: str) -> bool: Returns if there is any word in the trie that starts with the given prefix. :param prefix: A string prefix to search for in the Trie. :returns: True if any word starts with the prefix, False otherwise. node = self.root for char in prefix: if char not in node.children: return False node = node.children[char] return True"},{"question":"# Binary Exponentiation Challenge **Context**: You are implementing an efficient large number computation algorithm for a cryptographic application. Given the importance of speed and precision, you need to implement both the iterative and recursive versions of binary exponentiation to verify their performance. **Task**: Write the following two functions: 1. `power_iter(a: int, n: int, mod: int = None) -> int`: Computes ( a^n ) (or ( a^n mod text{mod} )) using iterative approach. 2. `power_recur(a: int, n: int, mod: int = None) -> int`: Computes ( a^n ) (or ( a^n mod text{mod} )) using recursive approach. **Input**: * `a` (integer, ( |a| leq 10^9 )): the base number. * `n` (integer, ( 0 leq n leq 10^9 )): the exponent. * `mod` (integer, default is None, ( 1 leq text{mod} leq 10^9 ), optional): the modulus. If the `mod` is not provided, compute the simple power. **Output**: * Return an integer that is the result of ( a^n ) or ( a^n mod text{mod} ). **Constraints**: * Your solution should handle edge cases such as ( n = 0 ) or ( n = 1 ). * Ensure that if `mod` is provided, it correctly calculates the result modulo `mod`. * Implement the functions to minimize time and space complexity as described. **Examples**: ```python power_iter(2, 10) -> 1024 power_iter(2, 10, 1000) -> 24 power_recur(3, 5) -> 243 power_recur(3, 5, 100) -> 43 ``` **Performance Requirements**: Your implementation should run in ( O(log n) ) time complexity. Ensure that the iterative version uses O(1) space, and consider the recursive call stack for the recursive version.","solution":"def power_iter(a, n, mod=None): Computes a^n or a^n % mod using iterative approach. result = 1 base = a while n > 0: if n % 2 == 1: result = result * base if mod is None else (result * base) % mod base = base * base if mod is None else (base * base) % mod n //= 2 return result def power_recur(a, n, mod=None): Computes a^n or a^n % mod using recursive approach. if n == 0: return 1 half_power = power_recur(a, n // 2, mod) half_power = half_power * half_power if mod is None else (half_power * half_power) % mod if n % 2 != 0: return half_power * a if mod is None else (half_power * a) % mod else: return half_power"},{"question":"**Scenario:** Given a grid representing a 2-dimensional map with water initially, write an algorithm to handle a sequence of operations where land is added at specific positions. After each operation, you have to calculate the number of separate islands formed. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. **Coding Task:** Implement a function `count_islands(positions, m, n)` to calculate the number of islands after each add operation. * **Function Signature:** ```python def count_islands(positions: List[List[int]], m: int, n: int) -> List[int]: pass ``` * **Input:** * `positions`: A list of lists, where each sublist contains two integers `[x, y]` representing the position where land is added. * `m`: Number of rows in the grid. * `n`: Number of columns in the grid. * **Output:** * A list of integers representing the count of islands after each add operation. * **Constraints:** * 1 <= m, n <= 1000 * 1 <= len(positions) <= 1000 * 0 <= positions[i][0] < m * 0 <= positions[i][1] < n **Example:** ```python positions = [[0, 0], [0, 1], [1, 2], [2, 1]] m = 3 n = 3 assert count_islands(positions, m, n) == [1, 1, 2, 3] ``` Implement the solution using the Union-Find (Disjoint Set) data structure and consider the properties and edge cases mentioned.","solution":"from typing import List def count_islands(positions: List[List[int]], m: int, n: int) -> List[int]: def find(x): if parents[x] != x: parents[x] = find(parents[x]) return parents[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: parents[rootY] = rootX return True return False parents = {} counts = [] island_count = 0 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] for r, c in positions: if (r, c) in parents: counts.append(island_count) continue parents[(r, c)] = (r, c) island_count += 1 for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < m and 0 <= nc < n and (nr, nc) in parents: if union((r, c), (nr, nc)): island_count -= 1 counts.append(island_count) return counts"},{"question":"# AVL Tree Insertions and Traversals Objective You are required to implement a self-balancing AVL tree and perform various operations including insertion and in-order traversal. Your implementation should guarantee that the tree remains balanced after each insertion. Task 1. **Insert**: Insert a set of integers into the AVL tree. 2. **In-order Traversal**: Implement a method to perform in-order traversal of the AVL tree that returns the nodes in ascending order. Input * A sequence of integers to be inserted in the AVL tree. (e.g., [10, 20, 30, 40, 50, 25]). Output * An array of integers representing the in-order traversal of the AVL tree post all insertions. Constraints * All integers are distinct. * The number of integers will not exceed 1000. Example **Input**: ```python [10, 20, 30, 40, 50, 25] ``` **Expected Output**: ```python [10, 20, 25, 30, 40, 50] ``` Function Signature ```python class AVLTree: def __init__(self): pass def insert(self, key): pass def in_order_traverse(self) -> List[int]: pass ``` Notes * You must ensure that the tree is balanced after each insertion. * Use the provided class structure and proper AVL tree operations to maintain balance. * The in-order traversal method should return an array of integers in ascending order.","solution":"class AVLNode: def __init__(self, key): self.key = key self.left = None self.right = None self.height = 1 class AVLTree: def __init__(self): self.root = None def _height(self, node): if not node: return 0 return node.height def _update_height(self, node): node.height = 1 + max(self._height(node.left), self._height(node.right)) def _balance_factor(self, node): if not node: return 0 return self._height(node.left) - self._height(node.right) def _rotate_right(self, y): x = y.left T2 = x.right # Perform rotation x.right = y y.left = T2 # Update heights self._update_height(y) self._update_height(x) return x def _rotate_left(self, x): y = x.right T2 = y.left # Perform rotation y.left = x x.right = T2 # Update heights self._update_height(x) self._update_height(y) return y def _rebalance(self, node, key): balance = self._balance_factor(node) # Left Left Case if balance > 1 and key < node.left.key: return self._rotate_right(node) # Right Right Case if balance < -1 and key > node.right.key: return self._rotate_left(node) # Left Right Case if balance > 1 and key > node.left.key: node.left = self._rotate_left(node.left) return self._rotate_right(node) # Right Left Case if balance < -1 and key < node.right.key: node.right = self._rotate_right(node.right) return self._rotate_left(node) return node def _insert(self, node, key): if not node: return AVLNode(key) if key < node.key: node.left = self._insert(node.left, key) else: node.right = self._insert(node.right, key) self._update_height(node) return self._rebalance(node, key) def insert(self, key): self.root = self._insert(self.root, key) def _in_order_traverse(self, node, result): if not node: return self._in_order_traverse(node.left, result) result.append(node.key) self._in_order_traverse(node.right, result) def in_order_traverse(self): result = [] self._in_order_traverse(self.root, result) return result"},{"question":"# Context: You are tasked with implementing a very basic version of a Binary Search Tree (BST) that supports insertion and retrieval operations. This will help you understand the fundamental operations of a BST and how they maintain their properties. # Question: **Objective**: Implement the `BinarySearchTree` class with necessary methods to handle the insertion of nodes and searching for a value within the tree. **Specifications**: 1. **Class Definition**: `BinarySearchTree` - **Methods**: * `insert(self, val: int) -> None`: Inserts a value into the BST. If the value already exists, do nothing. * `contains(self, val: int) -> bool`: Returns `True` if the value exists in the BST, otherwise `False`. 2. **Input and Output**: * The `insert` method accepts an integer `val` as its parameter. * The `contains` method accepts an integer `val` and returns a boolean value. ```python class TreeNode: def __init__(self, val=0): self.val = val self.left = None self.right = None class BinarySearchTree: def __init__(self): self.root = None def insert(self, val: int) -> None: # Implement insertion logic here pass def contains(self, val: int) -> bool: # Implement search logic here pass ``` **Constraints**: * Values are distinct integers within the range `[-10^4, 10^4]`. * Operations (insert and search) need to maintain an average time complexity of O(log n). **Example Usage**: ```python bst = BinarySearchTree() bst.insert(10) bst.insert(5) bst.insert(15) bst.insert(10) # Duplicate, do nothing print(bst.contains(10)) # Output: True print(bst.contains(7)) # Output: False ``` Make sure to handle the insertion and searching as per the properties of the Binary Search Tree.","solution":"class TreeNode: def __init__(self, val=0): self.val = val self.left = None self.right = None class BinarySearchTree: def __init__(self): self.root = None def insert(self, val: int) -> None: if not self.root: self.root = TreeNode(val) else: self._insert(self.root, val) def _insert(self, node, val): if node.val == val: return # Value already exists, do nothing elif val < node.val: if node.left: self._insert(node.left, val) else: node.left = TreeNode(val) else: if node.right: self._insert(node.right, val) else: node.right = TreeNode(val) def contains(self, val: int) -> bool: return self._contains(self.root, val) def _contains(self, node, val): if not node: return False if node.val == val: return True elif val < node.val: return self._contains(node.left, val) else: return self._contains(node.right, val)"},{"question":"Objective Implement a modified version of Crout\'s matrix decomposition, ensuring matrix validity and providing additional functionalities to check input properties. Problem Statement Given a square matrix (A) of size (n times n), write a function `crout_decomposition` which returns a tuple ((L, U)) of two matrices such that (L times U = A), where (L) is a lower triangular matrix and (U) is an upper triangular matrix with ones on its diagonal. Ensure the implementation handles edge cases and validates the input matrix. # Function Signature: ```python def crout_decomposition(A: List[List[float]]) -> Tuple[List[List[float]], List[List[float]]]: ``` # Input * (A) (List[List[float]]): A square matrix of size (n times n) (where (1 leq n leq 100)). # Output * Tuple of two matrices, (L) and (U) (both of size (n times n)). # Constraints 1. The input matrix (A) should be validated to be a non-singular square matrix. If the matrix is singular or near-singular, raise a `ValueError`. 2. Ensure numerically stable computations avoiding exceptionally small values in (L)\'s diagonal using a small threshold. 3. The function should handle common edge cases (identities, singular matrices appropriately). # Example: ```python input_matrix = [ [1.0, 2.0, 3.0], [3.0, 4.0, 5.0], [6.0, 7.0, 8.0] ] L, U = crout_decomposition(input_matrix) print(L) # Prints: # [[1.0, 0.0, 0.0], # [3.0, -2.0, 0.0], # [6.0, -5.0, 0.0]] print(U) # Prints: # [[1.0, 2.0, 3.0], # [0.0, 1.0, 2.0], # [0.0, 0.0, 1.0]] ``` # Notes: - You must validate that the matrix is a square matrix and handle potential singular matrices appropriately. - Ensure stability by implementing a small value threshold for diagonal entries in (L).","solution":"from typing import List, Tuple def crout_decomposition(A: List[List[float]]) -> Tuple[List[List[float]], List[List[float]]]: Decompose a square matrix A into L and U matrices where L is a lower triangular matrix and U is an upper triangular matrix with 1s on its diagonal. Parameters: A (List[List[float]]): 2D list representing the square matrix of size n x n. Returns: Tuple[List[List[float]], List[List[float]]]: A tuple containing the lower and upper triangular matrices, L and U. n = len(A) # Validate if the matrix is square if any(len(row) != n for row in A): raise ValueError(\\"Input matrix must be square\\") # Initialize L and U matrices to zero L = [[0.0] * n for _ in range(n)] U = [[0.0] * n for _ in range(n)] # Performing Crout\'s decomposition for i in range(n): # Decompose into L for j in range(i, n): sum = 0.0 for k in range(i): sum += L[j][k] * U[k][i] L[j][i] = A[j][i] - sum # Decompose into U for j in range(i + 1, n): if L[i][i] == 0.0: raise ValueError(\\"Matrix is singular or near-singular\\") sum = 0.0 for k in range(i): sum += L[i][k] * U[k][j] U[i][j] = (A[i][j] - sum) / L[i][i] U[i][i] = 1.0 # Diagonal elements of U are set to 1 return L, U"},{"question":"You are given an array that potentially includes non-zero elements, zero elements, and boolean values. Implement a function `move_zeros(arr)` that moves all zero elements to the end of the array while preserving the order of non-zero elements. Boolean values should not be treated as zero. # Function Signature ```python def move_zeros(arr: list) -> list: ``` # Input - `arr` (list): A list of elements consisting of integers, booleans, and potentially other data types. # Output - Returns the modified array where all zero elements are at the end and non-zero elements retain their original order. # Constraints - The function must have a time complexity of O(n). - The function must maintain a space complexity of O(n). # Example ```python print(move_zeros([False, 1, 0, 1, 2, 0, 1, 3, \\"a\\"])) # Output: [False, 1, 1, 2, 1, 3, \\"a\\", 0, 0] ``` # Clarifications - Boolean values (`True` and `False`) are common, but `False` should not be treated as zero. - Other falsey values apart from `0` (e.g., `None`, empty strings) should not be moved to the end as they are not supposed to be identified as zero. **Performance Requirements:** Ensure the function handles the given complexity constraints efficiently. Test your function against edge cases to ensure robustness.","solution":"def move_zeros(arr): Moves all zero elements in the array to the end while preserving the order of non-zero elements. Boolean values are not treated as zero. result = [x for x in arr if isinstance(x, bool) or x != 0] # Filter out non-zero elements and bools zeros = [0] * (len(arr) - len(result)) # List of zeros based on the count of zeros in the input list return result + zeros"},{"question":"# Maximum Flow in Transport Network You are responsible for managing traffic flow in a city\'s transport network represented as a directed graph in the form of an adjacency matrix. The nodes represent intersections, and the edges represent streets with capacities indicating the maximum number of vehicles that can pass through per unit time. Implement a function `maximum_flow_bfs(adjacency_matrix)` that computes the maximum number of vehicles that can be transported from the first intersection (source) to the last intersection (sink). Function Signature ```python def maximum_flow_bfs(adjacency_matrix: List[List[int]])-> int: # Your code here ``` Input - `adjacency_matrix`: A square matrix where: - The value at `adjacency_matrix[i][j]` represents the capacity of the street from intersection `i` to intersection `j`. - `adjacency_matrix` is `n x n` (with `1 <= n <= 500`). - `adjacency_matrix[i][j] = 0` indicates no direct street from `i` to `j`. Output - Returns a single integer, the maximum flow from the first node (intersection) to the last node. Constraints - The graph is connected enough that a solution always exists. - Non-negative capacities. Example ```python graph = [[0, 16, 13, 0, 0, 0], [0, 0, 10, 12, 0, 0], [0, 4, 0, 0, 14, 0], [0, 0, 9, 0, 0, 20], [0, 0, 0, 7, 0, 4], [0, 0, 0, 0, 0, 0]] assert maximum_flow_bfs(graph) == 23 ``` **Note:** Ensure your function is optimized for performance and handles large graphs efficiently.","solution":"from typing import List from collections import deque def bfs(residual_graph: List[List[int]], source: int, sink: int, parent: List[int]) -> bool: # Mark all vertices as not visited visited = [False] * len(residual_graph) # Create a queue for BFS queue = deque() # Mark the source node as visited and enqueue it queue.append(source) visited[source] = True # Standard BFS Loop while queue: u = queue.popleft() # Get all adjacent vertices of the dequeued vertex u # If an adjacent has not been visited and its capacity is positive, mark it visited and enqueue it for ind, val in enumerate(residual_graph[u]): if visited[ind] == False and val > 0: # If we find a connection to the sink node, then there is no point in BFS anymore, we just need to return true if ind == sink: parent[ind] = u return True queue.append(ind) parent[ind] = u visited[ind] = True # We didn\'t reach sink in BFS starting from source, so return False return False def maximum_flow_bfs(adjacency_matrix: List[List[int]]) -> int: # Number of vertices in the graph n = len(adjacency_matrix) # This array is filled by BFS and to store path parent = [-1] * n # Residual graph where rGraph[i][j] indicates residual capacity of edge from i to j (if there is an edge). residual_graph = [row[:] for row in adjacency_matrix] source = 0 sink = n - 1 max_flow = 0 # There is no flow initially # Augment the flow while there is a path from source to sink while bfs(residual_graph, source, sink, parent): # Find the maximum flow through the path found by BFS path_flow = float(\'Inf\') s = sink while(s != source): path_flow = min(path_flow, residual_graph[parent[s]][s]) s = parent[s] # update residual capacities of the edges and reverse edges along the path v = sink while(v != source): u = parent[v] residual_graph[u][v] -= path_flow residual_graph[v][u] += path_flow v = parent[v] max_flow += path_flow return max_flow"},{"question":"# Question You are tasked with implementing an optimized solution for finding the k-th smallest element in an unsorted array of integers. Your solution should balance between time complexity and space complexity. **Scenario**: You\'ve been given an unsorted array of unique integers, and you need to determine the k-th smallest element in this array. To achieve this, you need to efficiently extract this element without fully sorting the array, focusing particularly on minimizing the computational time for large datasets. # Function Signature ```python def kth_smallest_element(arr: list, k: int) -> int: Find the k-th smallest element in an unsorted array. Args: arr (list): An unsorted list of unique integers. k (int) : The k-th position (1-based) smallest element to find. Returns: int: The k-th smallest element in the list. Constraints: * 1 ≤ len(arr) ≤ 10^5 * 1 ≤ k ≤ len(arr) Note: The array contains no duplicate elements. ``` # Examples ```python # Example 1: arr = [7, 10, 4, 3, 20, 15] k = 3 # The 3rd smallest element in the array [7, 10, 4, 3, 20, 15] is 7. print(kth_smallest_element(arr, k)) # Expected output: 7 # Example 2: arr = [7, 10, 4, 3, 20, 15] k = 4 # The 4th smallest element in the array [7, 10, 4, 3, 20, 15] is 10. print(kth_smallest_element(arr, k)) # Expected output: 10 ``` # Performance Requirements * Aim to reduce the time complexity to better than O(n^2), leveraging algorithms well-suited for this problem like Quickselect or using a Max-Heap. # Input * An unsorted list of unique integers with length between 1 and 10^5. * An integer k, representing the k-th smallest position (1 ≤ k ≤ len(arr)). # Output * An integer representing the k-th smallest element in the given list.","solution":"import random def kth_smallest_element(arr, k): Find the k-th smallest element in an unsorted array using Quickselect algorithm. Args: arr (list): An unsorted list of unique integers. k (int) : The k-th position (1-based) smallest element to find. Returns: int: The k-th smallest element in the list. def quickselect(lo, hi, k): if lo == hi: return arr[lo] pivot_index = random.randint(lo, hi) pivot_index = partition(lo, hi, pivot_index) if k == pivot_index: return arr[k] elif k < pivot_index: return quickselect(lo, pivot_index - 1, k) else: return quickselect(pivot_index + 1, hi, k) def partition(lo, hi, pivot_index): pivot_value = arr[pivot_index] arr[pivot_index], arr[hi] = arr[hi], arr[pivot_index] store_index = lo for i in range(lo, hi): if arr[i] < pivot_value: arr[store_index], arr[i] = arr[i], arr[store_index] store_index += 1 arr[store_index], arr[hi] = arr[hi], arr[store_index] return store_index return quickselect(0, len(arr) - 1, k - 1)"},{"question":"You are tasked with implementing an enhanced version of the Caesar Cipher. Assume that you are working with an advanced encryption system which requires not just letter shifts but also incorporates non-alphabetic characters handling for encryption, ensuring they remain unchanged. # Function Specification **Function**: `enhanced_caesar_cipher(s: str, k: int) -> str` **Parameters**: * `s` (str): A string containing the input text to be encrypted. * `k` (int): An integer representing the encryption shift. **Returns**: * `str`: The encrypted string after applying the Caesar Cipher with the specified shift. # Constraints * `1 <= len(s) <= 1000` * k can be positive, negative, or even zero. * All printable ASCII characters in the input should be handled. # Performance Requirements * The function should efficiently process strings up to the upper length constraint. * Time complexity must not exceed O(n), where n is the length of the input string. # Example ```python assert enhanced_caesar_cipher(\\"Hello, World!\\", 3) == \\"Khoor, Zruog!\\" assert enhanced_caesar_cipher(\\"abc-def\\", -3) == \\"xyz-abc\\" assert enhanced_caesar_cipher(\\"Encrypted-987!\\", 30) == \\"Irgvctxih-987!\\" ``` # Description Write a Python function `enhanced_caesar_cipher` that shifts each letter in the input string `s` by `k` positions in the alphabet. For non-alphabetic characters, maintain them in their original position. Make sure to handle the shifts efficiently even if `k` is very large or negative.","solution":"def enhanced_caesar_cipher(s: str, k: int) -> str: result = [] k = k % 26 # Effective shift for alphabet characters for char in s: if \'a\' <= char <= \'z\': new_char = chr((ord(char) - ord(\'a\') + k) % 26 + ord(\'a\')) result.append(new_char) elif \'A\' <= char <= \'Z\': new_char = chr((ord(char) - ord(\'A\') + k) % 26 + ord(\'A\')) result.append(new_char) else: result.append(char) return \'\'.join(result)"},{"question":"# Problem Description You are given an array `arr` that may contain multiple data types (e.g., integers, strings, booleans). Write a function that removes all duplicate elements from the array while preserving the order of first occurrence of each unique element. To ensure efficient performance, aim for a solution that has a linear time complexity. # Function Signature ```python def remove_duplicates(arr: list) -> list: pass ``` # Input * A list `arr` of length `n` where `0 <= n <= 10^5`. Elements of `arr` can include any data type such as integers, strings, booleans, etc. * Example: ```python [1, 1, 1, 2, 2, 3, 4, 4, \\"hey\\", \\"hey\\", \\"hello\\", True, True] ``` # Output * A list containing the unique elements from `arr` in the order of their first occurrence. * Example: ```python [1, 2, 3, 4, \\"hey\\", \\"hello\\"] ``` # Constraints 1. The input array may contain integers, strings, and booleans. 2. The input array can be empty. 3. Try to achieve a time complexity of (O(n)). # Scenarios to Consider * Edge cases like empty arrays. * Arrays with all identical elements. * Arrays containing various data types. * Large arrays to test the performance of your solution. # Example ```python assert remove_duplicates([\\"apple\\", \\"orange\\", \\"apple\\", \\"banana\\", \\"banana\\"]) == [\\"apple\\", \\"orange\\", \\"banana\\"] assert remove_duplicates([]) == [] assert remove_duplicates([True, True, True, False, False]) == [True, False] assert remove_duplicates([1, 2, 3, 1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] assert remove_duplicates([1, \'a\', 1, \'b\', \'a\']) == [1, \'a\', \'b\'] ``` Write a function to solve the problem with the optimal performance. # Hints - Consider using a data structure that allows for constant-time checks of membership (like a set). - Think about how you can combine a set\'s efficiency with maintaining order.","solution":"def remove_duplicates(arr: list) -> list: Removes duplicate elements from the array while preserving the order of first occurrence of each unique element. seen = set() result = [] for item in arr: if item not in seen: seen.add(item) result.append(item) return result"},{"question":"# Scenario You have been given two heap-sort implementations: one that utilizes a max heap and another that utilizes a min heap. Both have been designed to sort arrays in ascending order. Unfortunately, there is a requirement change, and now you need to enhance these functions to handle descending order sorting. # Objective Your task is to modify the provided `max_heap_sort` and `min_heap_sort` functions to sort an array in descending order. Additionally, the max-heap should output the sorted results, and the min-heap should simulate the process like the provided simulation prototype. # Functions to Implement Function 1: `max_heap_sort_descending(arr, simulation=False)` * **Input**: * `arr` (List[int]): An array of integers to be sorted. * `simulation` (bool, default=False): If True, prints internal states during the heapify process. * **Output**: * Returns the input array `arr` sorted in descending order. Function 2: `min_heap_sort_descending(arr, simulation=False)` * **Input**: * `arr` (List[int]): An array of integers to be sorted. * `simulation` (bool, default=False): If True, prints internal states during the heapify process. * **Output**: * Returns the input array `arr` sorted in descending order. # Constraints 1. Use the existing heapify helper functions with minimal modifications. 2. Do not use any additional data structures. 3. Ensure the output array is sorted in descending order. # Performance Requirements * Time complexity must remain O(n log(n)). * Space complexity must remain O(1). # Example Example 1: * **Input**: `[4, 10, 3, 5, 1]` * **Output**: `[10, 5, 4, 3, 1]` Example 2: * **Input**: `[2, -1, 3, 7, 3, 5, 8, 10]`, `simulation=True` * **Output (Simulated)**: ``` iteration 0: 2 -1 3 7 3 5 8 10 iteration 1: 10 -1 3 2 3 5 8 7 iteration 2: 8 -1 3 2 3 5 -1 7 ... ``` * **Output (Sorted)**: `[10, 8, 7, 5, 3, 3, 2, -1]` # Submission Submit your solutions as two separate functions `max_heap_sort_descending` and `min_heap_sort_descending`.","solution":"def max_heapify(arr, n, i, simulation=False): largest = i left = 2 * i + 1 right = 2 * i + 2 if left < n and arr[i] < arr[left]: largest = left if right < n and arr[largest] < arr[right]: largest = right if largest != i: arr[i], arr[largest] = arr[largest], arr[i] if simulation: print(f\\"heapify: {arr}\\") max_heapify(arr, n, largest, simulation) def max_heap_sort_descending(arr, simulation=False): n = len(arr) for i in range(n // 2 - 1, -1, -1): max_heapify(arr, n, i, simulation) for i in range(n-1, 0, -1): arr[i], arr[0] = arr[0], arr[i] if simulation: print(f\\"sort step: {arr}\\") max_heapify(arr, i, 0, simulation) arr.reverse() return arr def min_heapify(arr, n, i, simulation=False): smallest = i left = 2 * i + 1 right = 2 * i + 2 if left < n and arr[i] > arr[left]: smallest = left if right < n and arr[smallest] > arr[right]: smallest = right if smallest != i: arr[i], arr[smallest] = arr[smallest], arr[i] if simulation: print(f\\"heapify: {arr}\\") min_heapify(arr, n, smallest, simulation) def min_heap_sort_descending(arr, simulation=False): n = len(arr) for i in range(n // 2 - 1, -1, -1): min_heapify(arr, n, i, simulation) for i in range(n-1, 0, -1): arr[i], arr[0] = arr[0], arr[i] if simulation: print(f\\"sort step: {arr}\\") min_heapify(arr, i, 0, simulation) return arr"},{"question":"# Scenario You are given the task of implementing functions to calculate the factorial of a number. You are required to design the function in a way that it can handle both typical and large input values. Additionally, the function should support the ability to compute the factorial with a modulo operation, which helps manage large numbers by preventing overflow. # Task Implement two functions, `factorial_iter` and `factorial_recur`: 1. `factorial_iter(n, mod=None)`: This function should compute the factorial iteratively. 2. `factorial_recur(n, mod=None)`: This function should compute the factorial recursively. # Function Signatures ```python def factorial_iter(n: int, mod: int = None) -> int: pass def factorial_recur(n: int, mod: int = None) -> int: pass ``` # Inputs - `n`: A non-negative integer whose factorial is to be calculated. - `mod`: An optional positive integer. If provided, the result should be computed as `(n! % mod)`. # Outputs - Both functions should return the factorial of n, optionally computed modulo `mod`. # Constraints - `0 <= n <= 1000` (Consider python’s integer handling while computing large numbers without explicitly specifying limits, but keep this in mind for practical scenarios). - If `mod` is specified, it will be a positive integer. # Requirements & Considerations - Ensure correct handling of the edge cases, including n = 0. - For recursive implementation, ensure it handles the recursive nature efficiently, considering maximum recursion depth. - Validate inputs for n and mod, raising `ValueError` for invalid values. # Example ```python assert factorial_iter(5) == 120 assert factorial_recur(5) == 120 assert factorial_iter(5, mod=3) == 0 assert factorial_recur(5, mod=3) == 0 ```","solution":"def factorial_iter(n: int, mod: int = None) -> int: if n < 0: raise ValueError(\\"n must be a non-negative integer\\") if mod is not None and mod <= 0: raise ValueError(\\"mod must be a positive integer\\") result = 1 for i in range(1, n + 1): result *= i if mod: result %= mod return result def factorial_recur(n: int, mod: int = None) -> int: if n < 0: raise ValueError(\\"n must be a non-negative integer\\") if mod is not None and mod <= 0: raise ValueError(\\"mod must be a positive integer\\") def helper(x, mod): if x == 0 or x == 1: return 1 else: result = helper(x - 1, mod) * x if mod: result %= mod return result return helper(n, mod)"},{"question":"# Linear Search Challenge You are given an array of integers and a query integer. Your task is to implement a function `linear_search(array, query)` that returns the index of the query integer in the array. If the query integer does not exist in the array, the function should return -1. Function Signature: ```python def linear_search(array: List[int], query: int) -> int: ``` Input: - `array`: A list of integers `array`, (0 <= len(array) <= 10^6). - `query`: An integer `query` that needs to be searched in the array. Output: - An integer representing the index of the first occurrence of `query` in `array`. If `query` is not found, return -1. Constraints: - The elements in `array` can be positive, negative, or zero. Example: ```python # Example 1 array = [1, 3, 5, 7, 9] query = 5 Output: 2 # Example 2 array = [1, 3, 5, 7, 9] query = 4 Output: -1 # Example 3 array = [] query = 1 Output: -1 # Example 4 array = [5, 5, 5, 5] query = 5 Output: 0 ``` Explanation: - In example 1, the integer `5` is found at index `2`. - In example 2, the integer `4` is not present in the array, so the function returns `-1`. - In example 3, the array is empty, hence the function returns `-1`. - In example 4, all elements are `5`, and the first `5` is at index `0`. Implement the function `linear_search` following the requirements and constraints provided.","solution":"from typing import List def linear_search(array: List[int], query: int) -> int: Returns the index of the first occurrence of the query integer in the array. If the query integer does not exist in the array, returns -1. for i, num in enumerate(array): if num == query: return i return -1"},{"question":"# Question: Find the Extra Character Scenario You\'re tasked with helping a security team quickly identify changes in system logs. The logs are represented as strings, and due to a known bug, an extra character may be added to the log during transmission. Your job is to find this added character. Problem Statement You are given two strings, `s` and `t`, where `t` is generated by shuffling string `s` and then adding one additional letter at a random position. You need to write a function to determine the letter that was added to `t`. Implementation Details * **Function Prototype**: ```python def find_difference(s: str, t: str) -> str: ``` * **Input**: - `s` (string): A lowercased string of length `n` (`1 <= n <= 10^4`). - `t` (string): A lowercased string of length `n + 1`, generated by shuffling `s` and adding one extra character. * **Output**: - A single character that represents the one added extra character in `t`. Example ```python # Example 1 s = \\"abcd\\" t = \\"abecd\\" assert find_difference(s, t) == \'e\' # Example 2 s = \\"xyz\\" t = \\"xyaz\\" assert find_difference(s, t) == \'a\' # Example 3 s = \\"aaa\\" t = \\"aaaa\\" assert find_difference(s, t) == \'a\' ``` Constraints - You should not use any additional data structures with significant space requirements. - Optimize for the fastest execution time possible.","solution":"def find_difference(s: str, t: str) -> str: Finds the extra character added to string t. :param s: Original string. :param t: Modified string with one additional character. :return: The extra character. # Using XOR to find the extra character result = 0 for char in s + t: result ^= ord(char) return chr(result)"},{"question":"# Reverse a Singly Linked List You are tasked with reversing a singly linked list. Given the head of a singly linked list, return the head of the reversed list. Function Signature: ```python def reverse_linked_list(head: ListNode) -> ListNode: pass ``` Input: - `head`: A ListNode representing the head of a singly linked list, where each node contains an integer value and a next pointer to the following node. Output: - The head of the reversed linked list. Constraints: - The number of nodes in the list will not exceed 10^5. - Node values will be in the range -10^9 to 10^9. Example: 1. - **Input**: head = [1, 2, 3, 4, 5] - **Output**: [5, 4, 3, 2, 1] 2. - **Input**: head = [1, 2] - **Output**: [2, 1] 3. - **Input**: head = [] - **Output**: [] Implementation Notes: - You may implement the solution iteratively or recursively. - Be mindful of edge cases such as: - Empty lists. - Single node list.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_linked_list(head: ListNode) -> ListNode: Reverses a singly linked list. Args: head (ListNode): The head of the singly linked list. Returns: ListNode: The head of the reversed singly linked list. prev = None current = head while current: next_node = current.next current.next = prev prev = current current = next_node return prev"},{"question":"# Graph Cloning Challenge You are given a graph represented as nodes connected with undirected edges. Each node has a unique label. Your task is to write a function that takes a node from this graph and returns a deep copy of the entire graph. You must ensure that the copied graph maintains the same structure as the original. Requirements: 1. Implement the function `clone_graph` that returns a deep copy of an undirected graph using the depth-first search (DFS) algorithm. Ensure your solution is recursive. 2. Ensure that your function handles edge cases, such as self-cycles and disconnected subgraphs. 3. Provide accompanying helper methods if necessary. # Function Signature: ```python class UndirectedGraphNode: def __init__(self, label): self.label = label self.neighbors = [] def clone_graph(node: UndirectedGraphNode) -> UndirectedGraphNode: # Your code goes here ``` # Constraints: - You may assume that the graph contains at most 100 nodes. - The labels of the nodes are unique integers. - There are no parallel edges in the graph (i.e., there is at most one edge connecting any two nodes). # Example: Suppose the graph is represented as follows: ``` 1 / 0---2 2 ``` As suggested by the serialization {0,1,2#1,2#2,2}, running `clone_graph(node)` where `node` is the reference to node `0` should create a deep copy of the entire graph. # Additional Notes: - Ensure the input graph is not modified. - Focus on clarity and efficiency of your solution. Good luck!","solution":"class UndirectedGraphNode: def __init__(self, label): self.label = label self.neighbors = [] def clone_graph(node: UndirectedGraphNode) -> UndirectedGraphNode: if not node: return None def clone(node, copied): if node.label in copied: return copied[node.label] cloned_node = UndirectedGraphNode(node.label) copied[node.label] = cloned_node for neighbor in node.neighbors: cloned_node.neighbors.append(clone(neighbor, copied)) return cloned_node return clone(node, {})"},{"question":"Scenario: You are tasked with implementing a function that generates the next higher permutation of digits from a given non-negative integer. The function should return the next permutation as an integer, or -1 if no higher permutation is possible. Problem Statement: Write a function `next_bigger(num)` that takes a non-negative integer `num` as input and returns the next higher number with the exact same set of digits. If no such number exists, return -1. Expected Input and Output: * **Input**: A non-negative integer `num` (0 <= num <= 10^9). * **Output**: An integer, representing the next permutation or -1 if no higher permutation exists. Constraints and Limitations: * Do not use built-in permutation functions. * Aim for O(n) time complexity and try to manage space efficiently. * The input number will be within a manageable range of typical integer values. * Consider edge cases like numbers with all identical digits or single-digit numbers. Function Signature: ```python def next_bigger(num: int) -> int: pass ``` Example: ```python # Example 1: # Input: 38276 # Output: 38627 # Example 2: # Input: 54321 # Output: -1 # Example 3: # Input: 12345 # Output: 12354 ``` Implementation Guidelines: 1. Convert the number to a list of its digits. 2. Traverse the list from the end to find the pivot. 3. Swap the pivot with the smallest digit larger than the pivot. 4. Reverse the suffix starting from the pivot index. 5. Convert the list back to a number and return it. Feel free to use the provided test cases to validate your implementation.","solution":"def next_bigger(num: int) -> int: Returns the next higher permutation of the digits of the given number. If no such permutation exists, returns -1. digits = list(map(int, str(num))) # Step 1: Find the pivot, the point (from right) where digits decrease for i in range(len(digits) - 2, -1, -1): if digits[i] < digits[i + 1]: break else: return -1 # If no pivot, it\'s the last permutation # Step 2: Find the smallest digit on right side of pivot which is larger than digits[i] for j in range(len(digits) - 1, i, -1): if digits[j] > digits[i]: break # Step 3: Swap the found digit with pivot digits[i], digits[j] = digits[j], digits[i] # Step 4: Reverse the digits after the pivot point digits = digits[:i+1] + digits[i+1:][::-1] # Convert back to number return int(\'\'.join(map(str, digits)))"},{"question":"Minimum Deletion Steps to Make Strings Identical Objective: Write a function that computes the minimum number of deletions required to make two input strings identical. Problem Statement: Given two words `word1` and `word2`, determine the minimum number of steps required to make `word1` and `word2` the same. In each step, you can delete one character from either string. Function Signature: ```python def min_deletions_to_match(word1: str, word2: str) -> int: pass ``` Input: - `word1` (type: `str`): A string consisting of lowercase English letters, where `1 <= len(word1) <= 500`. - `word2` (type: `str`): A string consisting of lowercase English letters, where `1 <= len(word2) <= 500`. Output: - An integer representing the minimum number of deletions required to make the two strings identical. Constraints: - The length of `word1` and `word2` will be in the range from 1 to 500. - Only lowercase English letters will appear in the given strings. Examples: 1. **Example 1:** - **Input:** `word1 = \\"sea\\"`, `word2 = \\"eat\\"` - **Output:** `2` - **Explanation:** You need one step to make `\\"sea\\"` to `\\"ea\\"` and another step to make `\\"eat\\"` to `\\"ea\\"`. 2. **Example 2:** - **Input:** `word1 = \\"leetcode\\"`, `word2 = \\"etco\\"` - **Output:** `4` - **Explanation:** Deletions needed to match the longest common subsequence. Implementation Notes: - Think about how to determine the longest common subsequence (LCS) using dynamic programming. - Understand how the length of LCS helps in calculating the minimum deletions needed. - Consider edge cases, such as both strings being identical or completely different. - Optimize for both time and space complexity as much as possible. Tips: - Start by creating a 2D array to store the length of the LCS up to each index of the two strings. - Use the LCS to derive the number of deletions required to match the two strings. - Test your implementation with various inputs to ensure correctness and efficiency.","solution":"def min_deletions_to_match(word1: str, word2: str) -> int: Returns the minimum number of deletions required to make the two input strings identical. m, n = len(word1), len(word2) # Create a 2D array to store lengths of longest common subsequence. dp = [[0] * (n + 1) for _ in range(m + 1)] # Fill the dp array using bottom-up dynamic programming approach for i in range(1, m + 1): for j in range(1, n + 1): if word1[i-1] == word2[j-1]: dp[i][j] = dp[i-1][j-1] + 1 else: dp[i][j] = max(dp[i-1][j], dp[i][j-1]) # Length of longest common subsequence lcs_length = dp[m][n] # Minimum deletions required to make both strings identical return (m - lcs_length) + (n - lcs_length)"},{"question":"# Inverting Larger Matrices Context: As a software engineer working on a scientific computing application, you often deal with large datasets and their transformations. An essential task in your project is the inversion of n x n matrices, which are frequently used in various algorithms, including those for solving systems of linear equations and understanding statistical relationships. Given a snippet of code that performs matrix inversion utilizing the matrix of minors, cofactors, adjugate, and multiplication by the reciprocal of the determinant, write a function that utilizes this logic and is capable of inverting square matrices of arbitrary dimensions (n ≥ 2). Task: Implement a function `invert_matrix(matrix: List[List[float]]) -> List[List[float]]` that: 1. Checks if the input is a valid square matrix. 2. Calculates the inverse of the matrix using the described method. Input: - A list of lists of floats representing an n x n matrix (n ≥ 2). Output: - A list of lists of floats representing the inverted matrix. - In cases of invalid input (not a square matrix or singular matrix), return a special error matrix: - `[[-1]]` for non-matrix inputs. - `[[-2]]` for non-square matrices. - `[[-3]]` for matrices smaller than 2x2. - `[[-4]]` for singular matrices. Constraints: - You may assume the input size n will not exceed 10 due to the high computational complexity. Performance Requirement: - Your solution should ensure correctness over performance due to the inherently high time complexity. **Example:** ```python matrix = [ [4, 7], [2, 6] ] print(invert_matrix(matrix)) # Output: [[0.6, -0.7], [-0.2, 0.4]] singular_matrix = [ [1, 2], [2, 4] ] print(invert_matrix(singular_matrix)) # Output: [[-4]] ``` Develop the function `invert_matrix` while ensuring to handle edge cases appropriately.","solution":"from typing import List def invert_matrix(matrix: List[List[float]]) -> List[List[float]]: def is_square_matrix(matrix): if not all(len(row) == len(matrix) for row in matrix): return False return True def determinant(matrix): n = len(matrix) if n == 1: return matrix[0][0] if n == 2: return matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0] det = 0 for c in range(n): det += ((-1) ** c) * matrix[0][c] * determinant(get_minor(matrix, 0, c)) return det def get_minor(matrix, i, j): return [row[:j] + row[j+1:] for row in (matrix[:i] + matrix[i+1:])] def transpose(matrix): return list(map(list, zip(*matrix))) def cofactor(matrix): n = len(matrix) cofactor_matrix = [] for r in range(n): cofactor_row = [] for c in range(n): minor = get_minor(matrix, r, c) cofactor_row.append(((-1) ** (r + c)) * determinant(minor)) cofactor_matrix.append(cofactor_row) return cofactor_matrix def zero_matrix(n): return [[0.0] * n for _ in range(n)] if not isinstance(matrix, list) or not all(isinstance(row, list) for row in matrix): return [[-1]] if not is_square_matrix(matrix): return [[-2]] n = len(matrix) if n < 2: return [[-3]] det = determinant(matrix) if det == 0: return [[-4]] cofactor_matrix = cofactor(matrix) adjugate_matrix = transpose(cofactor_matrix) inverse_matrix = zero_matrix(n) for i in range(n): for j in range(n): inverse_matrix[i][j] = adjugate_matrix[i][j] / det return inverse_matrix"},{"question":"# Matrix Transformation Assessment You are working for a company dealing with image processing, where matrices represent images, and various transformations on these matrices are crucial. You need to implement an efficient matrix transformation function covering both inverting and rotating functionalities. Your task is to write a function that can handle both operations optimally. Function Specification Implement a function `transform_matrix(matrix, operation)` that performs the specified transformation on a given matrix. ```python def transform_matrix(matrix, operation): Transforms the matrix based on the given operation. Args: matrix (List[List[int]]): 2D list of integers representing the matrix. operation (str): A string indicating the operation. - \'rotate_clockwise\' for rotating the matrix 90 degrees clockwise. - \'rotate_counterclockwise\' for rotating the matrix 90 degrees counterclockwise. - \'top_left_invert\' for inverting the matrix across the top-left to bottom-right diagonal. - \'bottom_left_invert\' for inverting the matrix across the bottom-left to top-right diagonal. Returns: List[List[int]]: The transformed matrix. pass ``` Input 1. `matrix`: A 2D list of integers representing the matrix. 2. `operation`: A string indicating the operation. - \'rotate_clockwise\' - \'rotate_counterclockwise\' - \'top_left_invert\' - \'bottom_left_invert\' Output - Returns a 2D list of integers representing the transformed matrix. Example ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] print(transform_matrix(matrix, \'rotate_clockwise\')) # Output: # [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] print(transform_matrix(matrix, \'rotate_counterclockwise\')) # Output: # [ # [3, 6, 9], # [2, 5, 8], # [1, 4, 7] # ] print(transform_matrix(matrix, \'top_left_invert\')) # Output: # [ # [1, 4, 7], # [2, 5, 8], # [3, 6, 9] # ] print(transform_matrix(matrix, \'bottom_left_invert\')) # Output: # [ # [9, 6, 3], # [8, 5, 2], # [7, 4, 1] # ] ``` Constraints: - The input matrix will be a square matrix (n x n), where 1 ≤ n ≤ 500. - Each element in the matrix will be an integer (-1000 ≤ element ≤ 1000).","solution":"def transform_matrix(matrix, operation): n = len(matrix) def rotate_clockwise(matrix): return [[matrix[n - j - 1][i] for j in range(n)] for i in range(n)] def rotate_counterclockwise(matrix): return [[matrix[j][n - i - 1] for j in range(n)] for i in range(n)] def top_left_invert(matrix): return [[matrix[j][i] for j in range(n)] for i in range(n)] def bottom_left_invert(matrix): return [[matrix[n - j - 1][n - i - 1] for j in range(n)] for i in range(n)] if operation == \'rotate_clockwise\': return rotate_clockwise(matrix) elif operation == \'rotate_counterclockwise\': return rotate_counterclockwise(matrix) elif operation == \'top_left_invert\': return top_left_invert(matrix) elif operation == \'bottom_left_invert\': return bottom_left_invert(matrix) else: raise ValueError(\\"Unsupported operation\\")"},{"question":"# Question: You are working on a text processing module in a document managing software. One of the requirements is to generate all possible abbreviations for given words to be used in building a comprehensive text compression algorithm. Write a function `generate_abbreviations(word: str) -> List[str]` that takes a single string `word` and returns a list of all possible abbreviations of the word. An abbreviation is a word formed by replacing some characters of the original word with the number of omitted characters. Each character can be replaced or left unchanged. Input: - A string `word` (1 <= len(word) <= 10). Output: - A list of strings, where each string is a unique abbreviation of the input word. Constraint: - Preserve the order of characters in the word. - The output list does not need to be in lexicographically sorted order. Example: ```python generate_abbreviations(\\"word\\") ``` Should return: ```python [\\"word\\", \\"wor1\\", \\"wo1d\\", \\"wo2\\", \\"w1rd\\", \\"w1r1\\", \\"w2d\\", \\"w3\\", \\"1ord\\", \\"1or1\\", \\"1o1d\\", \\"1o2\\", \\"2rd\\", \\"2r1\\", \\"3d\\", \\"4\\"] ``` # Constraints and Performance: - Your function should be able to handle words up to length 10 efficiently. - Any solution exceeding a reasonable timeout due to inefficient algorithms won\'t be accepted. # Note: - Properly handle edge cases like an empty string or all letters being the same. - Ensure your implementation adheres to best practices with concise code and comments where necessary.","solution":"from typing import List def generate_abbreviations(word: str) -> List[str]: def backtrack(pos: int, cur: str, count: int): if pos == len(word): if count > 0: cur += str(count) result.append(cur) else: # Option 1: Abbreviate the current character backtrack(pos + 1, cur, count + 1) # Option 2: Keep the current character backtrack(pos + 1, cur + (str(count) if count > 0 else \'\') + word[pos], 0) result = [] backtrack(0, \'\', 0) return result"},{"question":"# Scenario You are working on a text processing tool that includes a feature to compress repeated patterns within strings. To implement this feature, you need to detect repetitive patterns efficiently. # Task Write a function `is_repeated_pattern` that determines whether a given string can be constructed by taking a substring of it and appending multiple copies of the substring together. # Input and Output * **Input Format**: - A non-empty string `s` consisting of lowercase English letters. * **Output Format**: - A boolean value `True` if the string can be constructed by repeating a substring, otherwise `False`. # Constraints * ( 1 <= text{len}(s) <= 10^4 ) # Performance Requirements Your solution should be optimized for both time and space, ideally with a linear time complexity and reasonable space complexity. # Example ```python # Example 1 input_s = \\"abab\\" print(is_repeated_pattern(input_s)) # Output: True # Example 2 input_s = \\"aba\\" print(is_repeated_pattern(input_s)) # Output: False # Example 3 input_s = \\"abcabcabcabc\\" print(is_repeated_pattern(input_s)) # Output: True ``` # Implementation Make sure to handle edge cases such as single character strings or non-repetitive patterns. Your implementation should be robust and efficient.","solution":"def is_repeated_pattern(s): Determine if a string can be constructed by repeating a substring. Args: s (str): The input string. Returns: bool: True if the string can be constructed by repeating a substring, otherwise False. n = len(s) # Double the string and remove the first and the last character doubled_s = (s + s)[1:-1] # If the original string exists in the modified doubled string, it is a repetitive pattern return s in doubled_s"},{"question":"Given a list of non-negative integer pairs, implement two functions to perform the following: 1. Compute the greatest common divisor (GCD) of each pair using bitwise operations. 2. Compute the lowest common multiple (LCM) of each pair using the Euclidean algorithm for GCD. # Constraints: - All integers within pairs will be non-negative and not greater than ( 10^6 ). - If any of the pairs contain zero, skip that pair. - Return the results as a list of tuples where each tuple contains the GCD and LCM for the respective pair. # Input: - A list of pairs `pairs` of non-negative integers. ```python pairs = [(12, 15), (0, 5), (100, 150), (200, 300)] ``` # Output: - A list of tuples where each tuple contains the GCD and LCM for respective pairs (skip invalid pairs). ```python [(3, 60), (50, 300), ...] ``` # Function Signature: ```python def gcd_bitwise(a: int, b: int) -> int: Compute GCD using bitwise operations. def lcm_using_gcd(a: int, b: int) -> int: Compute LCM using Euclidean algorithm\'s GCD. def process_pairs(pairs: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Compute GCD and LCM for each pair of integers. ``` # Implementation Instructions: 1. **gcd_bitwise() Function**: Implement this function to compute the GCD using bitwise operations. 2. **lcm_using_gcd() Function**: Implement this function to compute the LCM using the Euclidean algorithm\'s GCD. 3. **process_pairs() Function**: Iterate over the list of pairs, compute the GCD and LCM for valid pairs, and store the result in the output list. # Example: ```python def gcd_bitwise(a, b): # Implementation using bitwise operations pass def lcm_using_gcd(a, b): # Implementation computing LCM using GCD pass def process_pairs(pairs: List[Tuple[int, int]]) -> List[Tuple[int, int]]: results = [] for a, b in pairs: if a == 0 or b == 0: continue gcd_val = gcd_bitwise(a, b) lcm_val = lcm_using_gcd(a, b) results.append((gcd_val, lcm_val)) return results pairs = [(12, 15), (0, 5), (100, 150), (200, 300)] print(process_pairs(pairs)) # Expected output: [(3, 60), (50, 300), (100, 600)] ``` **Note**: Edge cases should be considered, and input validation should be handled directly within the functions.","solution":"from typing import List, Tuple def gcd_bitwise(a: int, b: int) -> int: Compute GCD using bitwise operations. if a == 0: return b if b == 0: return a if a == b: return a if a % 2 == 0: if b % 2 == 0: return gcd_bitwise(a >> 1, b >> 1) << 1 else: return gcd_bitwise(a >> 1, b) else: if b % 2 == 0: return gcd_bitwise(a, b >> 1) else: if a > b: return gcd_bitwise(a - b, b) else: return gcd_bitwise(a, b - a) def lcm_using_gcd(a: int, b: int) -> int: Compute LCM using the Euclidean algorithm\'s GCD. return a * b // gcd_bitwise(a, b) def process_pairs(pairs: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Compute GCD and LCM for each pair of integers. results = [] for a, b in pairs: if a == 0 or b == 0: continue gcd_val = gcd_bitwise(a, b) lcm_val = lcm_using_gcd(a, b) results.append((gcd_val, lcm_val)) return results"},{"question":"Scenario You have been tasked with developing a function for a mathematical toolbox that helps users find all unique combinations of factors for a given integer `n`. Factors should be greater than 1 and less than `n`. Problem Statement Write a Python function `factor_combinations(n: int) -> List[List[int]]` that takes an integer `n` and returns a list of lists containing all unique combinations of its factors. Input/Output Format - **Input**: - A positive integer `n`. - **Output**: - A list of lists, where each list contains integers that are factors of `n` and their product equals `n`. Constraints - `1 <= n <= 10^6` Examples - **Example 1:** - Input: `1` - Output: `[]` - Explanation: No factors exist for `1` within the given constraints. - **Example 2:** - Input: `37` - Output: `[]` - Explanation: `37` is a prime number and has no other factors but 1 and itself. - **Example 3:** - Input: `12` - Output: `[[2, 6], [2, 2, 3], [3, 4]]` - Explanation: `12` can be factored into `[2, 6]`, `[2, 2, 3]`, and `[3, 4]`. - **Example 4:** - Input: `32` - Output: `[[2, 16], [2, 2, 8], [2, 2, 2, 4], [2, 2, 2, 2, 2], [2, 4, 4], [4, 8]]` - Explanation: `32` can factor into various combinations as listed. Notes - The factors should be listed in ascending order within each combination. - Return the combinations in any order. Requirement The function should efficiently handle the upper constraint of `n` without causing excessive memory or time consumption issues.","solution":"from typing import List def factor_combinations(n: int) -> List[List[int]]: Returns all unique combinations of factors of `n` which are greater than 1 and less than `n`. def dfs(num, start, path, res): if num == 1: if len(path) > 1: res.append(path[:]) return for i in range(start, num + 1): if num % i == 0: path.append(i) dfs(num // i, i, path, res) path.pop() if n <= 1: return [] result = [] dfs(n, 2, [], result) return result"},{"question":"You are tasked with implementing a sorting function that mimics the behavior of the selection sort algorithm. Your implementation should not only sort the array but also handle edge cases appropriately and provide an option to simulate the sorting process by showing the intermediate steps. # Function Signature ```python def custom_selection_sort(arr: List[int], simulation: bool = False) -> List[int]: pass ``` # Input * `arr`: A list of integers that can be positive, negative, or zero. * `simulation`: A boolean value (`True` or `False`). When `True`, your function should print the state of the list after each iteration. # Output * The function should return the sorted list. # Constraints * Do not use in-built sorting functions. * The length of the list can be up to 1000 elements. * The list may contain negative integers. * Ensure the function performs sorting in place (modify the input list) and uses O(1) additional space. # Performance Your function should efficiently handle the constraints mentioned above, including the worst-case time complexity of O(n^2). # Example ```python # Example 1 arr = [64, 25, 12, 22, 11] sorted_arr = custom_selection_sort(arr) # Output: [11, 12, 22, 25, 64] # Example 2 (with simulation) arr = [64, 25, 12, 22, 11] sorted_arr = custom_selection_sort(arr, simulation=True) # Expected Output: # iteration 0 : 64 25 12 22 11 # iteration 1 : 11 25 12 22 64 # iteration 2 : 11 12 25 22 64 # iteration 3 : 11 12 22 25 64 # iteration 4 : 11 12 22 25 64 # Example 3 (edge case) arr = [] sorted_arr = custom_selection_sort(arr) # Output: [] # Example 4 (edge case) arr = [1] sorted_arr = custom_selection_sort(arr) # Output: [1] ``` # Testing Ensure your function passes multiple test cases, including but not limited to ideal cases, edge cases, and random large inputs.","solution":"from typing import List def custom_selection_sort(arr: List[int], simulation: bool = False) -> List[int]: n = len(arr) for i in range(n): min_idx = i for j in range(i+1, n): if arr[j] < arr[min_idx]: min_idx = j arr[i], arr[min_idx] = arr[min_idx], arr[i] if simulation: print(f\'iteration {i} : {\\" \\".join(map(str, arr))}\') return arr"},{"question":"# Linked List Rotation Problem Scenario: You are tasked with restructuring a collection represented as a singly linked list. The goal is to rotate the list to the right by a specified number of places. This operation is frequently needed in systems where data shifts over time, such as cyclic buffers and round-robin task scheduling. Prompt: Write a function `rotate_right(head: ListNode, k: int) -> ListNode:` that takes a singly linked list and an integer `k`, then rotates the list to the right by `k` places. Specifications: 1. Input: - `head`: The head node of a singly linked list. - `k`: A non-negative integer representing the number of places to rotate the list. 2. Output: - The function should return the new head of the rotated list. 3. Constraints: - The number of nodes in the linked list ranges from 0 to 10^5. - The value of each node is an integer. - k is a non-negative integer. 4. Performance: - The function should run in O(N) time complexity where N is the number of nodes in the list. - The function should use O(1) additional space. Examples: ```python # Example 1: Input: head = [1, 2, 3, 4, 5], k = 2 Output: [4, 5, 1, 2, 3] # Example 2: Input: head = [0, 1, 2], k = 4 Output: [2, 0, 1] ``` Implement the function `rotate_right` by modifying the provided template, keeping in mind the edge cases and performance considerations.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def rotate_right(head: ListNode, k: int) -> ListNode: if not head or not head.next or k == 0: return head # First, determine the length of the list length = 1 current = head while current.next: current = current.next length += 1 # Make the linked list circular current.next = head # Find the point to break the circle k = k % length # Normalize k to be within the bounds of the length for _ in range(length - k): current = current.next new_head = current.next current.next = None return new_head"},{"question":"# Heap Sort with Custom Comparators You are tasked with implementing a version of heap sort that can take a custom comparator function to determine the order in which elements are sorted. This will allow the heap sort to adapt to different sorting criteria beyond the usual numerical order. Problem Statement Implement the function `custom_heap_sort(arr, comparator, simulation=False)` which sorts the given array `arr` in place using the specified `comparator` function. The `comparator` function should take two elements and return: - A negative value if the first element should come before the second, - Zero if they are considered equal, - A positive value if the first element should come after the second. The `simulation` argument is a boolean flag that, if set to True, causes the function to print the state of the array after each iteration of heapifying or swapping elements. Function Signature ```python def custom_heap_sort(arr, comparator, simulation=False): ``` Input - `arr`: A list of elements that need to be sorted. - `comparator`: A function that takes two elements from the array and returns an integer as described above. - `simulation`: A boolean (default False), if True, the function will print the iteration state. Output - The function should return the sorted array `arr`. Constraints - The array `arr` can contain elements of any type, but it is guaranteed that the comparator function can handle them. - The length of `arr` will not exceed 1000 elements. Example Usage ```python def comparator(x, y): return x - y # Sorts in ascending order arr = [4, 10, 3, 5, 1] custom_heap_sort(arr, comparator) print(arr) # Output should be [1, 3, 4, 5, 10] ``` # Additional Exposition - Ensure your implementation maintains the heap property based on the provided comparator function. - Consider edge cases like an empty array or an array with uniform elements.","solution":"def custom_heap_sort(arr, comparator, simulation=False): def heapify(arr, n, i): largest = i # Initialize largest as root left = 2 * i + 1 # left = 2*i + 1 right = 2 * i + 2 # right = 2*i + 2 # See if left child of root exists and is greater than root if left < n and comparator(arr[i], arr[left]) < 0: largest = left # See if right child of root exists and is greater than root if right < n and comparator(arr[largest], arr[right]) < 0: largest = right # Change root, if needed if largest != i: arr[i], arr[largest] = arr[largest], arr[i] # swap # Heapify the root. heapify(arr, n, largest) # Build a maxheap. n = len(arr) for i in range(n // 2 - 1, -1, -1): heapify(arr, n, i) if simulation: print(\\"Heapify step:\\", arr) # One by one extract elements for i in range(n - 1, 0, -1): arr[i], arr[0] = arr[0], arr[i] # swap heapify(arr, i, 0) if simulation: print(\\"Extract step:\\", arr) return arr"},{"question":"Scenario You are working as a software engineer for city planning. The city is represented by a 2D grid where: - **1** represents a building that you need to visit. - **0** represents an empty land to potentially build a park. - **2** represents an obstacle where neither buildings nor parks can exist. Your task is to determine the shortest distance (in terms of grid cells) from each building to the nearest empty cell where a park could be built such that the total distance from all buildings to that empty cell is minimized. Task Given a 2D grid, find the shortest distance from all the buildings to an empty cell. If it\'s impossible for a park to be accessible from all buildings, return -1. Instructions Write a function `shortest_distance(grid: List[List[int]]) -> int` that takes a 2D list `grid` as input and returns the shortest distance as an integer. **Input:** - `grid`: A 2D list of integers representing the city layout. (1 <= len(grid) <= 50, 1 <= len(grid[0]) <= 50) **Output:** - Return an integer representing the minimal distance or -1 if a park cannot be accessed from all buildings. **Constraints:** - You must use BFS for the traversal. - Consider performance implications especially for larger grids. Examples ```python # Example 1 grid = [ [1, 0, 2, 0, 1], [0, 0, 0, 0, 0], [0, 0, 1, 0, 0] ] assert shortest_distance(grid) == 7 # Example 2 grid = [ [1, 0], [2, 0] ] assert shortest_distance(grid) == 1 ``` Hints 1. Use BFS rooted at each building to propagate distances to empty cells. 2. Maintain a matrix to keep track of cumulative distances and the number of hits for each empty cell.","solution":"from collections import deque from typing import List def shortest_distance(grid: List[List[int]]) -> int: if not grid or not grid[0]: return -1 rows, cols = len(grid), len(grid[0]) buildings = sum(val == 1 for row in grid for val in row) def bfs(start_row, start_col): visited = [[False] * cols for _ in range(rows)] queue = deque([(start_row, start_col, 0)]) visited[start_row][start_col] = True distance = 0 while queue: r, c, dist = queue.popleft() for dr, dc in ((0,1), (1,0), (0,-1), (-1,0)): nr, nc = r + dr, c + dc if 0 <= nr < rows and 0 <= nc < cols and not visited[nr][nc] and grid[nr][nc] == 0: visited[nr][nc] = True distance_matrix[nr][nc] += dist + 1 reach[nr][nc] += 1 queue.append((nr, nc, dist + 1)) distance_matrix = [[0] * cols for _ in range(rows)] reach = [[0] * cols for _ in range(rows)] for r in range(rows): for c in range(cols): if grid[r][c] == 1: bfs(r, c) min_distance = float(\'inf\') for r in range(rows): for c in range(cols): if grid[r][c] == 0 and reach[r][c] == buildings: min_distance = min(min_distance, distance_matrix[r][c]) return min_distance if min_distance != float(\'inf\') else -1"},{"question":"# Context: You are tasked with implementing a custom sorting algorithm for a data processing system that handles a large and uniformly distributed dataset representing sensor measurements ranging from 0 to 1000. Your goal is to use the Bucket Sort algorithm with nested Insertion Sort to efficiently order these measurements. # Task: Implement the `bucket_sort` function using the provided specifications. Ensure it can handle a list of integers in the range 0 to 1000. The provided code uses Insertion Sort for the buckets; you need not change this part but focus on ensuring the overall algorithm is reliable and efficient. # Function Signature: ```python def bucket_sort(arr: List[int]) -> List[int]: # Your implementation here pass ``` # Input: * List of integers, `arr`, where each element is in range [0, 1000], with possible duplicates and an arbitrary length. # Output: * A sorted list of integers in ascending order. # Constraints: * 0 ≤ len(arr) ≤ 10^5 * 0 ≤ arr[i] ≤ 1000 for each i # Example: ```python assert bucket_sort([29, 25, 3, 49, 9, 37, 21, 43]) == [3, 9, 21, 25, 29, 37, 43, 49] assert bucket_sort([100, 200, 300]) == [100, 200, 300] assert bucket_sort([]) == [] assert bucket_sort([500, 500, 500]) == [500, 500, 500] ``` # Evaluation Criteria: * **Correctness**: The solution should return accurately sorted results. * **Efficiency**: Consider time complexity and performance, particularly for large lists. * **Handling Edge Cases**: Ensure the implementation correctly handles various edge cases.","solution":"from typing import List def insertion_sort(bucket: List[int]) -> List[int]: for i in range(1, len(bucket)): key = bucket[i] j = i - 1 while j >= 0 and key < bucket[j]: bucket[j + 1] = bucket[j] j -= 1 bucket[j + 1] = key return bucket def bucket_sort(arr: List[int]) -> List[int]: if len(arr) == 0: return arr # Set the number of buckets n = len(arr) max_value = max(arr) size = max_value // n + 1 # Create buckets and distribute the elements buckets = [[] for _ in range(n)] for num in arr: index = num // size buckets[index].append(num) # Sort each bucket using insertion sort, then concatenate results sorted_array = [] for bucket in buckets: sorted_array.extend(insertion_sort(bucket)) return sorted_array"},{"question":"# Task: Implement and Enhance Insertion Sort Scenario You are given an array of integers and need to sort it using the Insertion Sort algorithm. To test your understanding and ability to handle optimizations, you will implement an enhanced version of the Insertion Sort algorithm with an optional binary search optimization. Requirements 1. Implement the classic Insertion Sort algorithm in Python. 2. Enhance your Insertion Sort implementation by including an optional optimization that uses binary search to find the insertion position. 3. Handle the enhancement using a boolean flag `binary_optimization`. If set to `True`, use binary search for finding the insertion position; otherwise, use the linear search method. 4. Ensure your implementation handles edge cases, such as empty arrays and single-element arrays correctly. 5. Maintain the stability of the sorting (i.e., ensure that the relative order of equal elements is maintained). Function Signature ```python def enhanced_insertion_sort(arr: List[int], binary_optimization: bool=false) -> List[int]: ``` Input - **arr**: List of integers. - **binary_optimization**: Boolean flag to control the usage of the binary search enhancement. Output - **List[int]**: Sorted list of integers. Constraints - The input array can contain up to 10^5 elements. - Each element of the array is an integer that fits in a 32-bit signed integer. Example ```python print(enhanced_insertion_sort([5, 2, 9, 1, 5, 6], binary_optimization=False)) # Output: [1, 2, 5, 5, 6, 9] print(enhanced_insertion_sort([5, 2, 9, 1, 5, 6], binary_optimization=True)) # Output: [1, 2, 5, 5, 6, 9] ``` Notes - Ensure that your solution is properly tested for various edge cases mentioned in the analysis. - Aim for optimal performance in terms of time and space as per the constraints.","solution":"from typing import List def enhanced_insertion_sort(arr: List[int], binary_optimization: bool = False) -> List[int]: def binary_search(array, val, start, end): while start < end: mid = (start + end) // 2 if array[mid] < val: start = mid + 1 else: end = mid return start for i in range(1, len(arr)): key = arr[i] if binary_optimization: ins_pos = binary_search(arr, key, 0, i) else: ins_pos = i while ins_pos > 0 and arr[ins_pos - 1] > key: ins_pos -= 1 arr = arr[:ins_pos] + [key] + arr[ins_pos:i] + arr[i+1:] return arr"},{"question":"# Context: You are developing a text obfuscation tool based on the Atbash cipher. Your tool will allow users to quickly obfuscate and deobfuscate messages by reversing the alphabet. # Task: Write a function `atbash` that takes an input string and returns the Atbash ciphered version of it. # Function Signature: ```python def atbash(s: str) -> str: ``` # Input: * A single string `s` (1 ≤ len(s) ≤ 10^5), which may include alphabetic characters (both upper-case and lower-case), spaces, and special characters. # Output: * Return a string that represents the Atbash cipher of the input string. # Constraints: * Maintain capitalization: The case of each letter should remain the same as in the input. * Preserve non-alphabetic characters: Special characters and spaces should not be altered or shifted. # Example: ```python assert atbash(\\"Attack at dawn\\") == \\"Zggzxp zg wzdm\\" assert atbash(\\"abcdefghijklmnopqrstuvwxyz\\") == \\"zyxwvutsrqponmlkjihgfedcba\\" assert atbash(\\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\") == \\"ZYXWVUTSRQPONMLKJIHGFEDCBA\\" assert atbash(\\"Hello, World!\\") == \\"Svool, Dliow!\\" ``` **Note**: Your implementation should efficiently handle inputs up to the maximum length.","solution":"def atbash(s: str) -> str: Returns the Atbash ciphered version of the input string s. result = [] for char in s: if \'a\' <= char <= \'z\': result.append(chr(219 - ord(char))) # 219 = \'a\'.ord + \'z\'.ord elif \'A\' <= char <= \'Z\': result.append(chr(155 - ord(char))) # 155 = \'A\'.ord + \'Z\'.ord else: result.append(char) return \'\'.join(result) # Example usage: # print(atbash(\\"Attack at dawn\\")) # Output: \\"Zggzxp zg wzdm\\" # print(atbash(\\"abcdefghijklmnopqrstuvwxyz\\")) # Output: \\"zyxwvutsrqponmlkjihgfedcba\\" # print(atbash(\\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\")) # Output: \\"ZYXWVUTSRQPONMLKJIHGFEDCBA\\" # print(atbash(\\"Hello, World!\\")) # Output: \\"Svool, Dliow!\\""},{"question":"# Context A message is encoded into digits using a mapping from \'A\' to \'Z\' represented as \'1\' to \'26\'. Given a string containing such digits, decode the message and return the total number of ways to decode it. # Task Write a function `decode_ways(encoded_message)` that calculates the number of ways to decode an encoded message. # Input * `encoded_message`: A string containing the encoded message (`1 <= len(encoded_message) <= 100`). # Output * Return an integer representing the total number of ways to decode the message. # Constraints 1. The input string will contain only digits. 2. The input string will not contain leading zeros unless the string is \\"0\\". # Example ```python decode_ways(\\"12\\") # Returns: 2 (\\"AB\\" or \\"L\\") decode_ways(\\"226\\") # Returns: 3 (\\"BZ\\", \\"VF\\", \\"BBF\\") decode_ways(\\"06\\") # Returns: 0 # Note that \\"06\\" cannot have a valid decoding since \\"0\\" isn\'t mapped to any character. # \\"100\\" should be decoded as 1 way only given \\"J\\" for 10. ``` # Solution Requirements * Efficient solution with a time complexity of O(n). * Proper handling of edge cases such as \'0\'s in the encoded message. * Clearly organized code with detailed comments explaining your approach.","solution":"def decode_ways(encoded_message): if not encoded_message or encoded_message[0] == \'0\': return 0 n = len(encoded_message) dp = [0] * (n + 1) dp[0], dp[1] = 1, 1 # base initialization for i in range(2, n + 1): if encoded_message[i-1] != \'0\': dp[i] += dp[i-1] if encoded_message[i-2] == \'1\' or (encoded_message[i-2] == \'2\' and encoded_message[i-1] in \'0123456\'): dp[i] += dp[i-2] return dp[n]"},{"question":"# Crout Matrix Decomposition Objective Write a function `crout_matrix_decomposition` that takes a square matrix (A) as input and returns the matrices (L) and (U) such that (L times U = A). Input - A square matrix `A` of dimensions (n times n) where (1 leq n leq 100 ). - Matrix (A) will be represented as a list of lists in Python, where each inner list is a row of the matrix. Output - A tuple containing two matrices (L) and (U), each of dimensions (n times n). - (L) should be a lower triangular matrix. - (U) should be an upper triangular matrix. Constraints - The elements of the matrix (A) are integers or floating-point numbers. - The matrix (A) will not be singular. - Ensure to handle potential division by zero cases gracefully. Performance Requirements - The solution should run within a time complexity of (O(n^3)). Example ```python def crout_matrix_decomposition(A): # Your code here # Example usage A = [[1, 2, 3], [3, 4, 5], [6, 7, 8]] L, U = crout_matrix_decomposition(A) print(\\"L =\\", L) print(\\"U =\\", U) ``` **Expected Output:** ```text L = [[1.0, 0.0, 0.0], [3.0, -2.0, 0.0], [6.0, -5.0, 0.0]] U = [[1.0, 2.0, 3.0], [0.0, 1.0, 2.0], [0.0, 0.0, 1.0]] ``` Notes - Ensure your solution is efficient and handles corner cases effectively. - Document your code with comments to explain critical sections.","solution":"def crout_matrix_decomposition(A): Perform Crout\'s matrix decomposition on a square matrix A. Parameters: A (list of list of floats): Square matrix of dimensions n x n. Returns: tuple: A tuple containing two matrices L and U such that L * U = A. L is a lower triangular matrix, and U is an upper triangular matrix. n = len(A) L = [[0.0] * n for _ in range(n)] U = [[0.0] * n for _ in range(n)] # Initialize U to be identity matrix for i in range(n): U[i][i] = 1.0 for j in range(n): for i in range(j, n): # Compute L[i][j] sum_l = sum(L[i][k] * U[k][j] for k in range(j)) L[i][j] = A[i][j] - sum_l for i in range(j + 1, n): # Compute U[j][i] sum_u = sum(L[j][k] * U[k][i] for k in range(j)) U[j][i] = (A[j][i] - sum_u) / L[j][j] return L, U"},{"question":"# Question You are provided with a stream of numerical updates in the form of tuples (value, sign), where `value` is a non-negative integer and `sign` is either \'+\' or \'-\'. Your task is to implement a function that determines if this stream is 1-sparse, meaning that after all cancelations (+ and - of the same values), there is at most one unique value left in the stream. # Specifications 1. **Function Name**: `determine_one_sparse` 2. **Arguments**: - `stream`: a list of tuples, where each tuple contains a non-negative integer and a sign (\'+\', \'-\'). 3. **Returns**: - The unique element that remains if the stream is 1-sparse, otherwise return `None`. # Example: Input ```python determine_one_sparse([(4,\'+\'), (2,\'+\'),(2,\'-\'),(4,\'+\'),(3,\'+\'),(3,\'-\')]) ``` Output ```python 4 # Since 2 and 3 get canceled out. ``` Input ```python determine_one_sparse([(2,\'+\'),(2,\'+\'),(2,\'+\'),(2,\'+\'),(2,\'+\'),(2,\'+\'),(2,\'+\')]) ``` Output ```python 2 # No other numbers present, so return 2. ``` Input ```python determine_one_sparse([(2,\'+\'),(2,\'+\'),(2,\'+\'),(2,\'+\'),(2,\'+\'),(2,\'+\'),(1,\'+\')]) ``` Output ```python None # Not 1-sparse due to the extra 1. ``` # Constraints - Each element in the stream is a tuple with a non-negative integer and a sign (\'+\', \'-\'). - The stream is guaranteed to contain valid tuples only. Implement function `determine_one_sparse` carefully to ensure it passes all edge cases and performs efficiently for large input sizes.","solution":"def determine_one_sparse(stream): Determines if the stream is 1-sparse, meaning after all cancellation, there is at most one unique value left in the stream. Parameters: stream (list of tuples): A list of tuples where each tuple contains a non-negative integer and a sign (\'+\', \'-\'). Returns: int or None: The unique element if the stream is 1-sparse, otherwise None. from collections import defaultdict count = defaultdict(int) for value, sign in stream: if sign == \'+\': count[value] += 1 elif sign == \'-\': count[value] -= 1 # Clean up zero counts resulting from balanced pairs final_counts = {k: v for k, v in count.items() if v != 0} if len(final_counts) == 1: return list(final_counts.keys())[0] else: return None"},{"question":"# Power of Two Checker **Objective**: Write a function to determine whether a given integer is a power of two. This involves checking if the integer has exactly one \'1\' in its binary representation. **Function Signature**: ```python def is_power_of_two(n: int) -> bool: :type n: int :rtype: bool ``` **Input**: - An integer `n` where `-2^31 <= n <= 2^31 - 1`. **Output**: - Return `True` if the integer is a power of two, otherwise return `False`. **Example**: ```python # Example 1: is_power_of_two(1) # returns: True, because 2^0 = 1 # Example 2: is_power_of_two(16) # returns: True, because 2^4 = 16 # Example 3: is_power_of_two(218) # returns: False ``` **Constraints**: - Ensure that the function handles negative numbers and zero correctly. - Optimize for time complexity using appropriate operations. You should consider edge cases such as negative integers and zero while implementing the function. **Additional Challenge**: - Implement the function using bitwise operations similar to the provided example. - Clarify how the bitwise operation works in your solution.","solution":"def is_power_of_two(n: int) -> bool: Returns True if n is a power of two, otherwise False. # A power of two has exactly one \'1\' in its binary representation. # Additionally, n should be positive since powers of two are always positive. if n > 0 and (n & (n - 1)) == 0: return True return False # Explanation: # The condition (n & (n - 1)) == 0 uses bitwise AND operation to check if there is only one \'1\' in the binary representation of n. # For example: # If n = 16 (binary: 10000) then n-1 = 15 (binary: 01111) # Applying n & (n-1) => 10000 & 01111 = 00000 which is 0. # Thus, 16 is a power of two."},{"question":"# Question: You are tasked with optimizing the calculation of the binomial coefficient nCr (number of ways to choose r items from n items) using dynamic programming. Implement a function that leverages an iterative approach to achieve this. Specification: * Function Name: `combination_dp(n, r)` * Input: * `n` (integer): The total number of items. * `r` (integer): The number of items to choose. * Output: * Integer: The binomial coefficient nCr. Constraints: 1. 0 <= r <= n <= 1000 2. Minimize both time and space complexity as much as possible. Requirements: The method should: * Efficiently compute the value of nCr. * Handle edge cases correctly (e.g., when r = 0 or r = n). Examples: ```python assert combination_dp(5, 2) == 10 assert combination_dp(6, 3) == 20 assert combination_dp(10, 0) == 1 assert combination_dp(10, 10) == 1 assert combination_dp(1000, 500) == [expected large number] ``` **Hint**: You may use a 2-dimensional table or reduce space complexity using a 1-dimensional array.","solution":"def combination_dp(n, r): if r > n or r < 0: return 0 if r == 0 or r == n: return 1 # Reduce r to be the smaller of r and n-r for efficiency r = min(r, n - r) # Initialize a 1D DP array dp = [0] * (r + 1) dp[0] = 1 # nC0 is always 1 # Iterate over the range of n for i in range(1, n + 1): # Traverse backwards to avoid overwriting values needed for calculations for j in range(min(i, r), 0, -1): dp[j] += dp[j - 1] return dp[r]"},{"question":"Enhanced Sorting Assessment Context: Stooge Sort is a classic example of a highly inefficient sorting algorithm, primarily used for educational purposes. In this task, you will need to implement a much more efficient and commonly-used sorting algorithm called Merge Sort. Merge Sort is a divide-and-conquer algorithm with a much better time complexity, making it suitable for practical applications. Problem Statement: Given an unsorted array of integers, implement the Merge Sort algorithm to sort the array in ascending order. You need to write a function `merge_sort(arr)` that sorts the array using the Merge Sort algorithm. Function Signature: ```python def merge_sort(arr: List[int]) -> List[int]: pass ``` Input: - A list of integers `arr` where (1 leq text{len(arr)} leq 10^5) and each integer is in the range (-10^9 leq text{arr[i]} leq 10^9). Output: - Return the sorted array in ascending order. Constraints: - Use the Merge Sort algorithm. - Focus on achieving optimal time complexity (O(n log n)). Performance Requirements: - Your function should efficiently handle the upper limit of input size. Example: ```python # Example 1 input: [64, 34, 25, 12, 22, 11, 90] output: [11, 12, 22, 25, 34, 64, 90] # Example 2 input: [-3, -6, 0, 2, 1] output: [-6, -3, 0, 1, 2] ```","solution":"from typing import List def merge_sort(arr: List[int]) -> List[int]: Sorts an array using the Merge Sort algorithm. Parameters: arr (List[int]): The array to be sorted. Returns: List[int]: The sorted array. if len(arr) <= 1: return arr mid = len(arr) // 2 left_half = merge_sort(arr[:mid]) right_half = merge_sort(arr[mid:]) return merge(left_half, right_half) def merge(left: List[int], right: List[int]) -> List[int]: Merges two sorted arrays. Parameters: left (List[int]): The left sorted array. right (List[int]): The right sorted array. Returns: List[int]: The merged sorted array. sorted_arr = [] left_index, right_index = 0, 0 while left_index < len(left) and right_index < len(right): if left[left_index] < right[right_index]: sorted_arr.append(left[left_index]) left_index += 1 else: sorted_arr.append(right[right_index]) right_index += 1 sorted_arr.extend(left[left_index:]) sorted_arr.extend(right[right_index:]) return sorted_arr"},{"question":"# Problem Description You are provided with a stack of integers represented as a list where the last element is the top of the stack. Your task is to implement a function that removes the smallest element from the stack. If the stack contains duplicates of the minimum element, only the first occurrence (nearest to the top) needs to be removed. # Function Signature ```python def remove_min(stack: list) -> list: ``` # Input * `stack`: A list where elements are ordered from bottom to top (bottom being the first element, top being the last). The stack will have zero or more integer elements. # Output * The function should return the modified stack with the smallest element removed. # Constraints * If the stack is empty, no elements should be removed, and it should return the empty stack. * Constraints assume that stack size is limited by typical memory constraints of Python lists. # Performance Requirements * Aim to achieve a time complexity of O(n). * Space complexity should also be O(n) due to the auxiliary storage. # Examples ```python assert remove_min([2, 8, 3, -6, 7, 3]) == [2, 8, 3, 7, 3] assert remove_min([5, 4, 3, 2, 1]) == [5, 4, 3, 2] assert remove_min([1, 2, 3, 4, 5]) == [2, 3, 4, 5] assert remove_min([]) == [] assert remove_min([42]) == [] assert remove_min([3, 3, 3]) == [3, 3] ``` # Additional Notes * Ensure you handle an empty stack properly. * The integrity of the stack’s order should be maintained except for the removal of the smallest element.","solution":"def remove_min(stack): if not stack: return stack # If the stack is empty, return it as is. min_element = min(stack) # Find the smallest element in the stack found = False result_stack = [] # Iterate over the stack to remove the first occurrence of the min element for element in stack: if element == min_element and not found: found = True # Flag set to True when the first occurrence of min is found continue # Skip this element result_stack.append(element) # Add the element to the result stack return result_stack"},{"question":"# Scenario: You are working on a project involving complex linked data structures, and you need to make deep copies of these structures. Given the nodes have both `next` and `random` pointers, you need to ensure that each replica node’s pointers accurately reflect the corresponding original node’s pointers. # Task: Given a linked list where each node contains an additional random pointer which could point to any node in the list or null, implement a function to return a deep copy of the list. Function Signature: ```python class RandomListNode: def __init__(self, label: int): self.label = label self.next = None self.random = None def copy_random_pointer(head: RandomListNode) -> RandomListNode: pass ``` Input: * `head`: The head of a linked list. Each node in the list has two pointers: * `next`: points to the next node in the list. * `random`: points to any node in the list or null. Output: * The function should return the head of the deep-copied linked list. Constraints: * You must create a deep copy of the entire list structurally identical to the original but independent. * Consider edge cases such as: * An empty linked list. * A list with a single node where the random pointer points to itself. * Large lists to evaluate performance in terms of time complexity. # Example: Assume a list `1 -> 2 -> 3` where: * Node 1’s random pointer points to Node 3. * Node 2’s random pointer is null. * Node 3’s random pointer points to Node 1. The deep copy should produce a structurally identical list with the same `next` and `random` pointers.","solution":"class RandomListNode: def __init__(self, label: int): self.label = label self.next = None self.random = None def copy_random_pointer(head: RandomListNode) -> RandomListNode: if not head: return None # Creating a mapping from original nodes to their copies mapping = {} # Step 1: Create copies and store them in the mapping current = head while current: mapping[current] = RandomListNode(current.label) current = current.next # Step 2: Assign next and random pointers to the copied nodes current = head while current: if current.next: mapping[current].next = mapping[current.next] if current.random: mapping[current].random = mapping[current.random] current = current.next return mapping[head]"},{"question":"You are tasked with implementing a more efficient version of the Shell Sort algorithm. The provided code snippet uses a simple gap sequence that halves the gap size each time. To improve its efficiency, we will use the Hibbard sequence (1, 3, 7, ... , 2^k - 1). **Task**: Implement the `optimized_shell_sort` function using the Hibbard gap sequence. # Specifications: * **Function Signature**: ```python def optimized_shell_sort(arr: List[int]) -> List[int]: ``` * **Input**: - `arr`: a list of integers to sort. `1 <= len(arr) <= 10^4` * **Output**: - a sorted list of integers in ascending order. # Constraints: - You must use the Hibbard gap sequence for the shell sort. - The implementation should maintain in-place sorting. # Example: ```python Input: [8, 5, 2, 9, 5, 6, 3] Output: [2, 3, 5, 5, 6, 8, 9] ``` # Additional Considerations: 1. Ensure your implementation handles edge cases correctly, including arrays of size 1, already sorted arrays, and arrays with repeating elements. 2. Aim for optimal performance and avoid unnecessary operations. 3. Ensure the function is well-documented and adheres to good coding practices.","solution":"from typing import List def optimized_shell_sort(arr: List[int]) -> List[int]: Sort the array using the Shell Sort algorithm with the Hibbard gap sequence. n = len(arr) k = 1 gaps = [] # Generating Hibbard gap sequence: 1, 3, 7, ..., 2^k - 1 while (2 ** k - 1) < n: gaps.append(2 ** k - 1) k += 1 gaps.reverse() # Start with the largest gap for gap in gaps: # Perform a gapped insertion sort for this gap size. for i in range(gap, n): temp = arr[i] j = i while j >= gap and arr[j - gap] > temp: arr[j] = arr[j - gap] j -= gap arr[j] = temp return arr"},{"question":"**Scenario**: You are developing a spell-checking feature for a text editor. One of the functionalities you need is to identify if the words typed by the user are anagrams of each other. To achieve this, you must write an efficient function to check if two words are anagrams. **Task**: Write a function that determines if two given strings are anagrams after reordering their letters. The function should be efficient and handle general cases, including uppercase letters and non-alphabetic characters. **Function Signature**: ```python def are_anagrams(s1: str, s2: str) -> bool: pass ``` # Constraints: - The strings `s1` and `s2` can contain uppercase and lowercase letters, digits, and special characters. - Anagrams are case-insensitive. - Ignore any non-alphanumeric characters. # Input: - `s1` and `s2`: Two non-empty strings. # Output: - Return `True` if the strings are anagrams (after preprocessing), otherwise return `False`. # Examples: ```python assert are_anagrams(\\"apple\\", \\"pleap\\") == True assert are_anagrams(\\"apple\\", \\"Pizza\\") == False assert are_anagrams(\\"apple\\", \\"AppLe!!!\\") == True assert are_anagrams(\\"123abc!\\", \\"cba321\\") == True assert are_anagrams(\\"\\", \\"\\") == True assert are_anagrams(\\"apple\\", \\"apple \\") == True ``` # Requirements: - Handle both uppercase and lowercase letters. - Ignore non-alphanumeric characters. - Deliver optimal time complexity. # Suggested Approach: 1. **Preprocess**: Convert strings to lowercase and filter out non-alphanumeric characters. 2. **Comparison**: Use letter frequency count or sorted string comparison to check for anagrams.","solution":"def are_anagrams(s1: str, s2: str) -> bool: Determines if two strings are anagrams after reordering their letters. The function is case-insensitive and ignores non-alphanumeric characters. def preprocess(s): return sorted(char.lower() for char in s if char.isalnum()) return preprocess(s1) == preprocess(s2)"},{"question":"# Nearest Neighbor Classifier You have been tasked with implementing a simple nearest neighbor classifier. Given a set of training data points with labels and a query point, your classifier should return the label of the nearest training data point. # Input - A dictionary where keys are tuples representing coordinates in a multi-dimensional Euclidean space, and values are the associated labels (which can be any datatype). - A tuple representing a query point in the same Euclidean space. # Output - The label of the training point that is closest to the query point. # Constraints - The length of the query point and training data points will be the same. - There will be at least one point in the training set. - The training set keys are unique and non-empty. # Performance Requirements - Your solution should be efficient enough to handle training sets with up to `10^5` points and dimensional space up to `10^3`. # Example ```python def nearest_neighbor(x, tSet): # Your code here # Example usage: training_set = { (1, 2): \'A\', (3, 4): \'B\', (5, 6): \'C\' } query_point = (2, 3) print(nearest_neighbor(query_point, training_set)) # Expected Output: \'A\' ``` # Hints 1. Utilize the provided `distance` function to compute Euclidean distances. 2. Ensure proper handling of edge cases, such as when the input is at the same point as one of the training samples.","solution":"import math def euclidean_distance(point1, point2): Calculate the Euclidean distance between two points in multi-dimensional space. return math.sqrt(sum((x - y) ** 2 for x, y in zip(point1, point2))) def nearest_neighbor(query_point, training_set): Find the label of the nearest neighbor to the query_point from the training_set. nearest_label = None nearest_distance = float(\'inf\') for point, label in training_set.items(): distance = euclidean_distance(point, query_point) if distance < nearest_distance: nearest_distance = distance nearest_label = label return nearest_label"},{"question":"Question: Next Higher Permutation # Objective: You are required to implement the function `next_bigger(num)` which takes a non-negative integer (`num`) and returns the next higher number which has the exact same set of digits as `num`. If no such number exists, return -1. # Constraints: - The input number (`num`) should be a non-negative integer. - The output should be an integer as well. - Your solution should be optimal in both time and space complexities. # Implementation: You need to implement the following function: ```python def next_bigger(num): # Your code here ``` # Example: ```python print(next_bigger(38276)) # Output: 38627 print(next_bigger(99999)) # Output: -1 print(next_bigger(12345)) # Output: 12354 print(next_bigger(54321)) # Output: -1 print(next_bigger(138654)) # Output: 143568 ``` # Explanation: 1. For the number `38276`: The next higher permutation with the same digits is `38627`. 2. For the number `99999`: All digits are in descending order indicating that it is the largest permutation, so the output is `-1`. 3. For the number `12345`: The next higher permutation is `12354`. 4. For the number `54321`: It is already in descending order, so output `-1`. 5. For the number `138654`: The next higher permutation is `143568`. # Tips: - Consider the properties of lexicographical ordering. - Think about swapping elements and reversing the subsequences efficiently. You are encouraged to write your own tests to validate your solution thoroughly.","solution":"def next_bigger(num): Returns the next higher number using the same digits as num. If no such number exists, returns -1. digits = list(str(num)) length = len(digits) # Step 1: Find the rightmost digit which is smaller than its next digit. for i in range(length - 2, -1, -1): if digits[i] < digits[i + 1]: break else: return -1 # If no such digit is found, that means the number is the highest permutation. # Step 2: Find the smallest digit on right side of (i\'th digit) that is greater than digits[i] for j in range(length - 1, i, -1): if digits[j] > digits[i]: # Step 3: Swap the found digits. digits[i], digits[j] = digits[j], digits[i] break # Step 4: Reverse the digits after position i+1 to get the smallest lexicographic order. digits = digits[:i + 1] + sorted(digits[i + 1:]) return int(\\"\\".join(digits))"},{"question":"# Context You are working with a Binary Search Tree (BST) that stores integers in a recursive manner. The BST allows for insertion and searching of values and maintains the in-order property where for any node, all values in its left subtree are smaller, and all values in its right subtree are larger. # Problem Statement Implement a function `find_successor(root, node)` that finds the in-order successor of a given node in a BST. The in-order successor of a node in a BST is the node that appears immediately after the given node in the in-order traversal of the BST. # Expected Function Signature ```python def find_successor(root: Optional[TreeNode], node: TreeNode) -> Optional[TreeNode]: ``` # Input * `root` - the root node of the BST, represented as an instance of `TreeNode`. * `node` - the node for which the in-order successor is to be found, represented as an instance of `TreeNode`. # Output * Returns the in-order successor node of the specified `node`. If there is no in-order successor, return `None`. # Constraints * The tree may contain up to `10^4` nodes. * Node values are unique and may be any integer. # Example ```plaintext Example BST: 20 / 8 22 / 4 12 / 10 14 find_successor(root, node(8)) -> node(10) find_successor(root, node(14)) -> node(20) find_successor(root, node(22)) -> None ``` # Performance Requirements * Ensure the solution runs efficiently with a time complexity of O(h) and space complexity of O(1), where h is the height of the BST. # Implementation Notes * Consider all edge cases including when the given node has no right subtree, or it’s the largest node in the BST. * The solution should handle skewed trees efficiently.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find_successor(root, node): Finds the in-order successor of the given node in a Binary Search Tree (BST). if node.right: # The successor is the leftmost node of node\'s right subtree. current = node.right while current.left: current = current.left return current else: # The successor is one of the ancestors. successor = None current = root while current: if node.val < current.val: successor = current current = current.left elif node.val > current.val: current = current.right else: break return successor"},{"question":"Problem Statement You are given a universe of elements `U` and a collection of subsets `S` where each subset `Si` has an associated cost. Your task is to implement two functions: 1. **optimal_set_cover(U, S, costs)**: An optimal algorithm to find the minimum cost subcollection of `S` that covers all elements of `U`. This solution should be exact but may not be feasible for large inputs due to its exponential time complexity. 2. **greedy_set_cover(U, S, costs)**: A greedy approximation algorithm to find a subcollection of `S` that covers all elements of `U` with relatively low cost. This solution is feasible for large inputs but does not guarantee the minimum cost. Input - **U**: A set of integers representing the universe. - **S**: A dictionary where keys are subset identifiers (strings) and values are sets of integers representing the subsets. - **costs**: A dictionary where keys are subset identifiers (strings) and values are integers representing the costs of each subset. Output - Both functions should return a subset of `S` identifiers representing the sets selected to cover the universe. Constraints - The universe and subsets will only contain non-negative integers. - All costs will be non-negative integers. - The union of all subsets in `S` will cover the universe `U`. Performance Requirements - **optimal_set_cover**: Time complexity should be O(2^n), where n is the number of subsets. - **greedy_set_cover**: Time complexity should be O(m * n), where m is the number of elements in the universe and n is the number of subsets. Example ```python U = {1, 2, 3, 4, 5} S = {\'S1\': {4, 1, 3}, \'S2\': {2, 5}, \'S3\': {1, 4, 3, 2}} costs = {\'S1\': 5, \'S2\': 10, \'S3\': 3} optimal_cover = optimal_set_cover(U, S, costs) # Output: {\'S2\', \'S3\'}, as this is the minimum cost cover with total cost = 13 greedy_cover = greedy_set_cover(U, S, costs) # Output: {\'S2\', \'S3\'}, as this gives a reasonable approximation with total cost = 13 ``` Implementation Define the following two functions: ```python from itertools import chain, combinations def powerset(iterable): s = list(iterable) return chain.from_iterable(combinations(s, r) for r in range(len(s) + 1)) def optimal_set_cover(universe, subsets, costs): # Your implementation here pass def greedy_set_cover(universe, subsets, costs): # Your implementation here pass ``` Implement the `optimal_set_cover` and `greedy_set_cover` functions ensuring they meet the specifications provided.","solution":"from itertools import chain, combinations def powerset(iterable): s = list(iterable) return chain.from_iterable(combinations(s, r) for r in range(len(s) + 1)) def optimal_set_cover(universe, subsets, costs): min_cost = float(\'inf\') best_cover = None for cover in powerset(subsets.keys()): current_cover = set() total_cost = 0 for subset in cover: current_cover.update(subsets[subset]) total_cost += costs[subset] if current_cover >= universe and total_cost < min_cost: min_cost = total_cost best_cover = set(cover) return best_cover def greedy_set_cover(universe, subsets, costs): remaining = set(universe) chosen_subsets = set() while remaining: best_subset = None best_cost = float(\'inf\') best_coverage = set() for subset, elements in subsets.items(): if subset in chosen_subsets: continue coverage = remaining & elements if coverage and costs[subset] / len(coverage) < best_cost: best_subset = subset best_cost = costs[subset] / len(coverage) best_coverage = coverage remaining -= best_coverage if best_subset: chosen_subsets.add(best_subset) return chosen_subsets"},{"question":"**Scenario:** You are working with a financial application where transactions can be represented as nodes in a binary tree. Each transaction node has a value, and you need to determine if there exists a sequence of transactions starting from the root transaction to any leaf transaction that sums up to a given target value. This is crucial to validating certain financial patterns and transaction anomalies. **Problem Statement:** Write a function `validate_transaction_path(root, target)` that takes the root of a binary tree and an integer target sum. The function should return `True` if there exists a root-to-leaf path such that the sum of the values of the nodes along this path equals the target sum. Otherwise, return `False`. **Function Specification:** ```python def validate_transaction_path(root, target): :type root: TreeNode :type target: int :rtype: bool ``` **Input:** - `root` (TreeNode): The root node of the binary tree. - `target` (int): The target sum for the path from root to leaf. **Output:** - `bool`: `True` if such a path exists, `False` otherwise. **Constraints:** - The number of nodes in the tree is in the range [0, 5000]. - The values of the nodes (`TreeNode.val`) are in the range [-1000, 1000]. - The target sum is in the range [-100000, 100000]. **Examples:** 1. Given the binary tree, ``` 5 / 4 8 / / 11 13 4 / 7 2 1 ``` and `target = 22`, your function should return `True` as the tree has a path 5->4->11->2 which sums to 22. 2. Given the binary tree, ``` 1 / 2 3 ``` and `target = 5`, your function should return `False` as there are no paths that sum up to 5. 3. Given the binary tree is empty (i.e., `root = None`) and `target = 0`, your function should return `False`.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def validate_transaction_path(root, target): :type root: TreeNode :type target: int :rtype: bool if not root: return False if not root.left and not root.right: return root.val == target return (validate_transaction_path(root.left, target - root.val) or validate_transaction_path(root.right, target - root.val))"},{"question":"# Binary Search Tree Implementation and Traversal You are to implement a Binary Search Tree in Python. Your task is to implement the following operations: 1. **Insert** a value into the BST. 2. **Search** for a value in the BST. 3. **Delete** a value from the BST. 4. Perform **in-order traversal** and return the result as a list. Function Signatures * `insert(root: TreeNode, val: int) -> TreeNode` * `search(root: TreeNode, val: int) -> bool` * `delete(root: TreeNode, val: int) -> TreeNode` * `in_order_traversal(root: TreeNode) -> List[int]` Constraints 1. Values are unique integers. 2. No duplicate insertions. 3. Deleting a non-existent element should maintain the tree\'s structure. 4. The in-order traversal should return a sorted list of values. # Example ```python # Creating an empty BST root = None # Inserting values root = insert(root, 5) root = insert(root, 3) root = insert(root, 7) root = insert(root, 2) # Searching values print(search(root, 7)) # True print(search(root, 4)) # False # In-order traversal print(in_order_traversal(root)) # [2, 3, 5, 7] # Deleting a value root = delete(root, 3) # Final in-order traversal print(in_order_traversal(root)) # [2, 5, 7] ``` Guidelines 1. Ensure you handle all edge cases, such as empty trees and leaf-only nodes. 2. Make sure your delete operation correctly adjusts the tree for nodes with two children by replacing with in-order successor. 3. Your code should be optimized for performance and readability. Good luck!","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def insert(root, val): if root is None: return TreeNode(val) if val < root.val: root.left = insert(root.left, val) else: root.right = insert(root.right, val) return root def search(root, val): if root is None: return False if root.val == val: return True elif val < root.val: return search(root.left, val) else: return search(root.right, val) def delete(root, val): if root is None: return root if val < root.val: root.left = delete(root.left, val) elif val > root.val: root.right = delete(root.right, val) else: if root.left is None: return root.right elif root.right is None: return root.left min_larger_node = root.right while min_larger_node.left: min_larger_node = min_larger_node.left root.val = min_larger_node.val root.right = delete(root.right, root.val) return root def in_order_traversal(root): result = [] def traverse(node): if not node: return traverse(node.left) result.append(node.val) traverse(node.right) traverse(root) return result"},{"question":"Generate All Possible Valid Arithmetic Expressions You are given a string `num` that contains only digits (0-9) and an integer `target`. Your task is to implement a function `generate_expressions` that returns all possible valid arithmetic expressions that can be formed by adding binary operators (not unary) `+`, `-`, or `*` between the digits such that the expression evaluates to the target value. Function Signature ```python def generate_expressions(num: str, target: int) -> List[str]: pass ``` Input Constraints * `num` consists only of digits `0-9`. * The length of `num` is between `1` and `10`. * The `target` value is any integer between `-2^31` and `2^31 - 1`. Expected Output * A list of strings, where each string is a valid arithmetic expression. Examples 1. **Example 1:** ```python num = \\"123\\" target = 6 generate_expressions(num, target) ``` **Output:** ```python [\\"1+2+3\\", \\"1*2*3\\"] ``` 2. **Example 2:** ```python num = \\"232\\" target = 8 generate_expressions(num, target) ``` **Output:** ```python [\\"2*3+2\\", \\"2+3*2\\"] ``` 3. **Example 3:** ```python num = \\"105\\" target = 5 generate_expressions(num, target) ``` **Output:** ```python [\\"1*0+5\\", \\"10-5\\"] ``` 4. **Example 4:** ```python num = \\"00\\" target = 0 generate_expressions(num, target) ``` **Output:** ```python [\\"0+0\\", \\"0-0\\", \\"0*0\\"] ``` 5. **Example 5:** ```python num = \\"3456237490\\" target = 9191 generate_expressions(num, target) ``` **Output:** ```python [] ``` Constraints and Requirements * You must use Depth-First Search (DFS) to explore potential solutions. * Avoid leading zeros in any segment of your expressions, except for the number zero itself. * Optimize for cases where the recursion can be pruned early if overstepping the target value.","solution":"from typing import List def generate_expressions(num: str, target: int) -> List[str]: def dfs(index, prev_operand, current_operand, value, expression): # Base case: If we have reached the end of the string if index == len(num): if value == target and current_operand == 0: expressions.append(\\"\\".join(expression[1:])) # remove the leading empty string or initial \'+\' return current_operand = current_operand * 10 + int(num[index]) str_op = str(current_operand) # Avoid cases where we have leading zero as operand if current_operand > 0: # NO OP: Continue with current_operand dfs(index + 1, prev_operand, current_operand, value, expression) # ADD expression.append(\'+\') expression.append(str_op) dfs(index + 1, current_operand, 0, value + current_operand, expression) expression.pop() expression.pop() # Can `-` or `*` we can only do so if there are operands available. if expression: # SUBTRACT expression.append(\'-\') expression.append(str_op) dfs(index + 1, -current_operand, 0, value - current_operand, expression) expression.pop() expression.pop() # MULTIPLY expression.append(\'*\') expression.append(str_op) dfs(index + 1, current_operand * prev_operand, 0, value - prev_operand + (current_operand * prev_operand), expression) expression.pop() expression.pop() expressions = [] dfs(0, 0, 0, 0, []) return expressions"},{"question":"**Scenario**: You are a developer working on a game where players need to find the shortest path to exit from various rooms. Each room is represented as a 2D grid where: * \\"-1\\" denotes a wall. * \\"0\\" denotes the exit gate. * \\"INF\\" denotes an empty room, with a value of 2147483647 to represent infinity. **Problem**: Given such a grid, your task is to implement a function `walls_and_gates` to fill each empty room with the distance to its nearest exit gate. If it\'s impossible to reach a gate, leave the room\'s value as INF. **Function Signature**: ```python def walls_and_gates(rooms: List[List[int]]) -> None: Modify rooms in-place such that each empty room is filled with the distance to the nearest gate. ``` **Example**: ```python rooms = [ [2147483647, -1, 0, 2147483647], [2147483647, 2147483647, 2147483647, -1], [2147483647, -1, 2147483647, -1], [0, -1, 2147483647, 2147483647] ] walls_and_gates(rooms) print(rooms) # Expected Output: # [ # [3, -1, 0, 1], # [2, 2, 1, -1], # [1, -1, 2, -1], # [0, -1, 3, 4] # ] ``` **Constraints**: * The 2D grid dimensions m and n are within the range [1, 200]. * Each room\'s value is either `-1`, `0`, or `INF` (2147483647). **Requirements**: * You should not return anything; modify the `rooms` grid in place. * The traversal should not involve any cell with a wall (-1). * Implement the function to handle both typical and edge cases efficiently. **Hint**: Consider using a more efficient approach such as Breadth-First Search (BFS) to handle the shortest path discovery from multiple sources.","solution":"from collections import deque from typing import List def walls_and_gates(rooms: List[List[int]]) -> None: Modify rooms in-place such that each empty room is filled with the distance to the nearest gate. INF = 2147483647 rows, cols = len(rooms), len(rooms[0]) queue = deque() # Initialize the queue with all gates for r in range(rows): for c in range(cols): if rooms[r][c] == 0: queue.append((r, c)) # BFS from each gate directions = [(1, 0), (0, 1), (-1, 0), (0, -1)] while queue: r, c = queue.popleft() for dr, dc in directions: rr, cc = r + dr, c + dc if 0 <= rr < rows and 0 <= cc < cols and rooms[rr][cc] == INF: rooms[rr][cc] = rooms[r][c] + 1 queue.append((rr, cc))"},{"question":"# Question You are tasked with implementing an algorithm to solve the 2-Satisfiability (2-SAT) problem using the concept of Strongly Connected Components (SCC). Given a formula in conjunctive normal form (2-CNF), your program should find a way to assign True/False values to all variables to satisfy all clauses or report that no such assignment exists. Input: - A list of clauses where each clause is a pair of literals. - Each literal is represented as a tuple (name, is_neg) where `name` is a string identifier, and `is_neg` is a boolean indicating if the literal is negated. Output: - A dictionary where keys are variable names and values are the assigned boolean values (True or False). If no satisfying assignment exists, return `None`. Constraints: - The number of variables and clauses will be at most 1000. - Variable names will be strings of length at most 10 characters. Example: ```python formula = [ ((\'x\', False), (\'y\', False)), ((\'y\', True), (\'y\', True)), ((\'a\', False), (\'b\', False)), ((\'a\', True), (\'c\', True)), ((\'c\', False), (\'b\', True)) ] result = solve_sat(formula) # Example output: {\'x\': False, \'y\': False, \'a\': False, \'b\': False, \'c\': False} or None if no solution exists. ``` Implementation Steps: 1. Construct an implication graph from the given formula. 2. Use Depth-First Search (DFS) to identify Strongly Connected Components (SCCs) in the graph. 3. Check for contradictions within the SCCs to determine satisfiability. 4. Assign appropriate boolean values to variables based on the SCCs. Key Functions to Implement: - `dfs_transposed(vertex, graph, order, visited)`: Helper function to perform DFS on the transposed graph. - `dfs(vertex, current_comp, vertex_scc, graph, visited)`: Helper function to perform DFS and assign SCC identifiers. - `add_edge(graph, vertex_from, vertex_to)`: Helper function to add edges to the graph. - `scc(graph)`: Function to compute the strongly connected components of the graph. - `build_graph(formula)`: Function to build the implication graph from the formula. - `solve_sat(formula)`: Function to solve the 2-SAT problem using the above methods. Good luck, and ensure to handle all edge cases effectively!","solution":"def add_edge(graph, vertex_from, vertex_to): if vertex_from not in graph: graph[vertex_from] = [] graph[vertex_from].append(vertex_to) def build_graph(formula): graph = {} for (u, v) in formula: u_name, u_sign = u v_name, v_sign = v add_edge(graph, (u_name, not u_sign), (v_name, v_sign)) add_edge(graph, (v_name, not v_sign), (u_name, u_sign)) return graph def dfs(vertex, graph, visited, stack): visited.add(vertex) if vertex in graph: for neighbor in graph[vertex]: if neighbor not in visited: dfs(neighbor, graph, visited, stack) stack.append(vertex) def dfs_transposed(vertex, graph, visited, component): visited.add(vertex) component.append(vertex) if vertex in graph: for neighbor in graph[vertex]: if neighbor not in visited: dfs_transposed(neighbor, graph, visited, component) def scc(graph): stack = [] visited = set() for vertex in graph: if vertex not in visited: dfs(vertex, graph, visited, stack) transposed_graph = {} for v in graph: for neighbor in graph[v]: add_edge(transposed_graph, neighbor, v) visited.clear() components = [] while stack: v = stack.pop() if v not in visited: component = [] dfs_transposed(v, transposed_graph, visited, component) components.append(component) return components def solve_sat(formula): graph = build_graph(formula) components = scc(graph) vertex_scc = {} for idx, component in enumerate(components): for vertex in component: vertex_scc[vertex] = idx assignment = {} for idx, component in enumerate(components): for (var, neg) in component: if (var, not neg) in vertex_scc and vertex_scc[(var, not neg)] == idx: return None # Contradiction found if var not in assignment: assignment[var] = not neg return assignment"},{"question":"# Quick Sort Implementation and Analysis **Context**: You have been hired by a tech company to optimize and analyze the performance of various sorting algorithms. Your first task is to implement the Quick Sort algorithm from scratch and analyze its behavior on different types of input arrays. **Task**: Implement the Quick Sort algorithm and write a function `analyze_quick_sort(arr: List[int], simulation: bool) -> List[int]`, that sorts an input list of integers, `arr`, using the Quick Sort algorithm. Additionally, if `simulation` is set to `True`, the function should print the intermediate steps to help analyze the algorithm. **Function Signature**: ```python from typing import List def analyze_quick_sort(arr: List[int], simulation: bool) -> List[int]: pass ``` **Input**: * `arr` (List[int]): A list of integers to be sorted. The length of the list, `n`, will be 0 <= n <= 10^5. * `simulation` (bool): A boolean flag that controls whether to print the intermediate steps of the algorithm for analysis. **Output**: * Returns the sorted list of integers. **Constraints**: * The function should be implemented using the Quick Sort algorithm. * If `simulation` is `True`, print each iteration of the sorting process as shown in the code snippets. * Ensure to manage recursion depth to avoid issues with large inputs. **Example**: ```python # Example 1 assert analyze_quick_sort([3, 6, 8, 10, 1, 2, 1], simulation=True) == [1, 1, 2, 3, 6, 8, 10] # Example 2 assert analyze_quick_sort([1, 2, 3, 4, 5], simulation=False) == [1, 2, 3, 4, 5] # Example 3 assert analyze_quick_sort([], simulation=False) == [] ``` **Note**: - If `simulation` is `True`, an example output might look like: ``` iteration 0 : 3 6 8 10 1 2 1 iteration 1 : 1 2 1 3 8 6 10 ... ``` - Ensure the implementation is efficient and handles edge cases like empty arrays or arrays with duplicate elements.","solution":"from typing import List def quick_sort(arr: List[int], low: int, high: int, simulation: bool, depth: int = 0) -> None: if low < high: p = partition(arr, low, high, simulation, depth) quick_sort(arr, low, p - 1, simulation, depth + 1) quick_sort(arr, p + 1, high, simulation, depth + 1) def partition(arr: List[int], low: int, high: int, simulation: bool, depth: int) -> int: pivot = arr[high] i = low for j in range(low, high): if arr[j] < pivot: arr[i], arr[j] = arr[j], arr[i] i += 1 arr[i], arr[high] = arr[high], arr[i] if simulation: print(f\\"iteration {depth} : {\' \'.join(map(str, arr))}\\") return i def analyze_quick_sort(arr: List[int], simulation: bool) -> List[int]: if not arr: # Handling empty array return arr quick_sort(arr, 0, len(arr) - 1, simulation) return arr"},{"question":"Efficient Sorting Algorithm You are given an array of `n` integers. Your task is to implement an efficient sorting algorithm that sorts the array in ascending order. The current implementation using Stooge Sort has high time complexity and is inefficient for large datasets. You need to implement a more efficient sorting algorithm of your choice (e.g., Merge Sort, Quick Sort, Heap Sort, etc.). # Requirements: 1. **Function Signature**: ```python def efficient_sort(arr: List[int]) -> List[int]: ``` 2. **Input**: - A list of `n` integers where `1 <= n <= 10^5`. 3. **Output**: - A sorted list of integers in ascending order. # Constraints: - Time Complexity must be O(n log n) or better. - The function must handle large arrays efficiently. # Example: - Input: `[1,3,64,5,7,8]` - Output: `[1,3,5,7,8,64]` # Note: Consider edge cases where the input array might be already sorted, empty, or contain repeated elements. # Implement your function below: ```python def efficient_sort(arr): # Your efficient sorting algorithm implementation here pass if __name__ == \\"__main__\\": array = [1,3,64,5,7,8] sorted_array = efficient_sort(array) for element in sorted_array: print(element, end = \' \') ```","solution":"from typing import List def efficient_sort(arr: List[int]) -> List[int]: Sorts an array of integers in ascending order using Merge Sort algorithm. if len(arr) <= 1: return arr # Divide the array into two halves mid = len(arr) // 2 left_half = efficient_sort(arr[:mid]) right_half = efficient_sort(arr[mid:]) # Merge the sorted halves return merge(left_half, right_half) def merge(left: List[int], right: List[int]) -> List[int]: sorted_array = [] i = j = 0 # Merge the two arrays into the sorted_array while i < len(left) and j < len(right): if left[i] < right[j]: sorted_array.append(left[i]) i += 1 else: sorted_array.append(right[j]) j += 1 # Append any remaining elements from left or right sorted_array.extend(left[i:]) sorted_array.extend(right[j:]) return sorted_array"},{"question":"Symmetric Binary Tree Verification Scenario You\'re given the task of developing a utility to verify if a binary tree is symmetric. This utility could be a part of a larger system that processes tree-structured data and needs to ensure certain properties such as symmetry (mirror image around the center). Description Write a function `is_symmetric` that takes the root of a binary tree and returns `True` if the tree is symmetric, and `False` otherwise. Additionally, implement the same functionality using both recursive and iterative approaches. Function Signatures ```python def is_symmetric(root: TreeNode) -> bool: # Implement recursive approach def is_symmetric_iterative(root: TreeNode) -> bool: # Implement iterative approach ``` Input * `root`: An instance of the `TreeNode` class representing the root of the binary tree. - `TreeNode` class has attributes: `val` (int), `left` (TreeNode), `right` (TreeNode). Output * Return `True` if the binary tree is symmetric, `False` otherwise. Example ```python # Tree structure for input: [1,2,2,3,4,4,3] # 1 # / # 2 2 # / / # 3 4 4 3 root = TreeNode(1, TreeNode(2, TreeNode(3), TreeNode(4)), TreeNode(2, TreeNode(4), TreeNode(3))) assert is_symmetric(root) == True assert is_symmetric_iterative(root) == True # Tree structure for input: [1,2,2,None,3,None,3] # 1 # / # 2 2 # # 3 3 root = TreeNode(1, TreeNode(2, None, TreeNode(3)), TreeNode(2, None, TreeNode(3))) assert is_symmetric(root) == False assert is_symmetric_iterative(root) == False ``` Constraints * The number of nodes in the tree is in the range [0, 1000]. * -100 ≤ Node.val ≤ 100","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_symmetric(root: TreeNode) -> bool: def is_mirror(t1: TreeNode, t2: TreeNode) -> bool: if t1 is None and t2 is None: return True if t1 is None or t2 is None: return False return (t1.val == t2.val) and is_mirror(t1.left, t2.right) and is_mirror(t1.right, t2.left) return is_mirror(root, root) def is_symmetric_iterative(root: TreeNode) -> bool: if not root: return True queue = [(root.left, root.right)] while queue: t1, t2 = queue.pop(0) if not t1 and not t2: continue if not t1 or not t2: return False if t1.val != t2.val: return False queue.append((t1.left, t2.right)) queue.append((t1.right, t2.left)) return True"},{"question":"# Regular Expression Matching Problem Statement: Implement a function `bool is_match(const char *s, const char *p)` that determines if the input string `s` matches the pattern `p`. The pattern `p` may include: - `.` which matches any single character. - `*` which matches zero or more of the preceding element. The matching should cover the entire input string `s` (not partial). Function Signature: ```python def is_match(str_a: str, str_b: str) -> bool: ``` Input: - `str_a`: A string containing only lowercase letters. - `str_b`: A string representing the pattern, containing lowercase letters, \'.\' and \'*\'. Output: - A boolean value (`True` or `False`) that indicates if the string `str_a` matches the pattern `str_b`. Constraints: - Both `str_a` and `str_b` will not exceed 1000 characters. - `str_b` is a valid regular expression according to the problem statement. Examples: ```python is_match(\\"aa\\", \\"a\\") # Output: False is_match(\\"aa\\", \\"aa\\") # Output: True is_match(\\"aaa\\", \\"aa\\") # Output: False is_match(\\"aa\\", \\"a*\\") # Output: True is_match(\\"aa\\", \\".*\\") # Output: True is_match(\\"ab\\", \\".*\\") # Output: True is_match(\\"aab\\", \\"c*a*b\\") # Output: True ``` Notes: - Ensure your implementation considers edge cases such as empty strings, patterns ending or starting with `*`, and patterns composed entirely of repetitions.","solution":"def is_match(str_a: str, str_b: str) -> bool: Determines if the input string matches the pattern. # Initialize a 2D DP array. dp[i][j] means whether s[0..i) matches p[0..j) dp = [[False] * (len(str_b) + 1) for _ in range(len(str_a) + 1)] # Base case: empty string matches empty pattern. dp[0][0] = True # Deals with patterns with \'*\' at the beginning like a*, a*b*, a*b*c* for j in range(1, len(str_b) + 1): if str_b[j - 1] == \'*\': dp[0][j] = dp[0][j - 2] for i in range(1, len(str_a) + 1): for j in range(1, len(str_b) + 1): if str_b[j - 1] == \'.\' or str_b[j - 1] == str_a[i - 1]: dp[i][j] = dp[i - 1][j - 1] elif str_b[j - 1] == \'*\': dp[i][j] = dp[i][j - 2] if str_b[j - 2] == \'.\' or str_b[j - 2] == str_a[i - 1]: dp[i][j] = dp[i][j] or dp[i - 1][j] return dp[len(str_a)][len(str_b)]"},{"question":"Scenario You have been given a project to work with a database that stores records in a singly linked list format. For efficiency, there need to be certain reorganization touchpoints for data alignment and accessibility. Task Implement a function to swap every two adjacent nodes of a given singly linked list, returning the new head of the modified list. The nodes must be swapped in pairs, and alterations to the node values are not allowed; only node pointers shall be changed. Function Signature ```python class Node: def __init__(self, x): self.val = x self.next = None def swap_pairs(head: Node) -> Node: ``` Input * `head`: The head node of the singly linked list to be modified. * Constraints: * The number of nodes in the list is non-negative (0 to 100). * Node values are integers between -1000 and 1000. Output * Return the head node of the newly arranged linked list. Example ```python # Example 1 # Input: 1->2->3->4 # Output: 2->1->4->3 # Example 2 # Input: 1->2->3->4->5 # Output: 2->1->4->3->5 # Example 3 # Input: None # Output: None ``` Notes * Your implementation should be done in-place with constant space complexity. * Handle edge cases such as empty lists or a list with an odd number of nodes. Develop a well-structured and error-free solution to achieve the specified output under these constraints.","solution":"class Node: def __init__(self, x): self.val = x self.next = None def swap_pairs(head: Node) -> Node: if not head or not head.next: return head # Initialize pointers dummy = Node(0) dummy.next = head current = dummy while current.next and current.next.next: first = current.next second = current.next.next # Swap nodes first.next = second.next second.next = first current.next = second # Move the pointer two nodes ahead current = first return dummy.next"},{"question":"You are given a non-negative number represented as an array of digits, stored such that the most significant digit is at the head of the list. Write a function `increment_digits` that increments the number by one and returns the resulting array of digits. The function should efficiently handle the carry generated when a digit exceeds 9 and adjust the size of the array if necessary. # Function Signature ```python def increment_digits(digits: List[int]) -> List[int]: pass ``` # Input * A list `digits` of integers: `digits` (0 ≤ digits[i] ≤ 9), where 1 ≤ len(digits) ≤ 10^6. # Output * A list of integers representing the incremented number. # Constraints * The input list should not contain any leading zero except for the number zero itself. * Your solution should handle cases where all the digits are nines (e.g., [9, 9, 9]) efficiently. # Examples ```python assert increment_digits([1, 2, 3]) == [1, 2, 4] assert increment_digits([9, 9, 9]) == [1, 0, 0, 0] assert increment_digits([0]) == [1] assert increment_digits([2, 9, 9]) == [3, 0, 0] ``` # Requirements * Your solution should have a time complexity of O(n) and a space complexity of O(1), not including the input and output list sizes. # Additional Notes * You cannot use any built-in functions that directly convert the list to an integer or vice versa.","solution":"def increment_digits(digits): Given a list of digits representing a non-negative integer, increment the integer by 1 and return the resulting list of digits. n = len(digits) carry = 1 # start with the increment of 1 # Traverse the list backwards for i in range(n - 1, -1, -1): new_digit = digits[i] + carry if new_digit >= 10: # if there\'s a carry over digits[i] = new_digit % 10 carry = 1 # carry over else: digits[i] = new_digit carry = 0 # no carry over, we are done break # If there is still a carry at the end, we add a new digit at the front if carry: digits.insert(0, 1) return digits"},{"question":"# Question: Scenario: You are a software engineer working on a navigation system. Your task is to determine the shortest paths from a central point in a city map, represented as a graph, to various key locations across the city. Problem Statement: Write a function `find_shortest_paths` that implements Dijkstra\'s algorithm to find the shortest paths from a given source vertex to all other vertices in the graph. Function Signature: ```python def find_shortest_paths(graph: List[List[int]], src: int) -> List[int]: Compute the shortest paths from src to all other vertices in the given graph. Parameters: - graph (List[List[int]]): Adjacency matrix representing the graph where graph[i][j] indicates the weight of the edge from vertex i to j. If there is no edge, the weight is considered to be infinity. - src (int): The source vertex. Returns: - List[int]: The list of shortest distances from the source vertex to all other vertices. ``` Inputs: 1. `graph`: A 2D list `graph` of integers where `graph[u][v]` represents the weight of an edge from vertex `u` to vertex `v`. If there is no edge, the weight will be a large number representing infinity (e.g., a value like 99999999). 2. `src`: An integer `src` representing the source vertex from which to calculate the shortest paths. Outputs: 1. A list of integers where the `i-th` element represents the shortest distance from the source vertex to the `i-th` vertex. Constraints: - The graph will have no more than 1000 vertices. - The graph is represented as a fully connected graph. - No negative weights are present. Example: ```python graph = [ [0, 10, 20, 99999999, 99999999], [10, 0, 30, 50, 99999999], [20, 30, 0, 40, 60], [99999999, 50, 40, 0, 70], [99999999, 99999999, 60, 70, 0] ] src = 0 print(find_shortest_paths(graph, src)) # Output: [0, 10, 20, 60, 80] ``` Requirements: - Implement the Dijkstra\'s algorithm as described. - Ensure the solution handles edge cases such as graphs with vertices that are not directly connected. - Optimize the solution to handle the upper limit of constraints efficiently.","solution":"import heapq def find_shortest_paths(graph, src): Compute the shortest paths from src to all other vertices in the given graph. Parameters: - graph (List[List[int]]): Adjacency matrix representing the graph where graph[i][j] indicates the weight of the edge from vertex i to j. If there is no edge, the weight is considered to be infinity. - src (int): The source vertex. Returns: - List[int]: The list of shortest distances from the source vertex to all other vertices. num_vertices = len(graph) distances = [float(\'inf\')] * num_vertices distances[src] = 0 priority_queue = [(0, src)] # (distance, vertex) while priority_queue: current_distance, u = heapq.heappop(priority_queue) if current_distance > distances[u]: continue for v in range(num_vertices): weight = graph[u][v] if weight < float(\'inf\'): distance_through_u = current_distance + weight if distance_through_u < distances[v]: distances[v] = distance_through_u heapq.heappush(priority_queue, (distance_through_u, v)) return distances"},{"question":"You are tasked with implementing a function that performs binary search on a sorted array of integers. Given a sorted array and a target value, your function should return the index of the target value in the array. If the target value is not found, the function should return -1. You must provide both iterative and recursive implementations of the binary search. # Function Signature ```python def binary_search_iter(array: List[int], target: int) -> int: pass def binary_search_recur(array: List[int], target: int, low: int, high: int) -> int: pass ``` # Input - `array`: A list of integers sorted in ascending order (1 <= len(array) <= 10^5). - `target`: An integer value to search for. # Output - An integer representing the index of `target` in `array`. If `target` is not found, return -1. # Constraints - You must use binary search. - Aim for logarithmic time complexity. - Avoid using built-in functions or methods relevant to search operations. - The recursive function must use the signature provided and handle the stack depth appropriately. # Example ```python # Example - Iterative array = [1, 2, 3, 4, 5, 6, 7, 8, 9] target = 4 print(binary_search_iter(array, target)) # Output: 3 # Example - Recursive array = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100] target = 70 print(binary_search_recur(array, target, 0, len(array) - 1)) # Output: 6 ``` # Notes - Consider edge cases such as an empty array, or when the target is at the boundaries of the array. - Be mindful of the performance impact of stack depth in recursive implementation.","solution":"from typing import List def binary_search_iter(array: List[int], target: int) -> int: Perform iterative binary search on the sorted array to find the target. Parameters: array (List[int]): Sorted list of integers. target (int): The integer to search for. Returns: int: The index of the target if found, else -1. low, high = 0, len(array) - 1 while low <= high: mid = (low + high) // 2 if array[mid] == target: return mid elif array[mid] < target: low = mid + 1 else: high = mid - 1 return -1 def binary_search_recur(array: List[int], target: int, low: int, high: int) -> int: Perform recursive binary search on the sorted array to find the target. Parameters: array (List[int]): Sorted list of integers. target (int): The integer to search for. low (int): The lower bound index for the current search. high (int): The upper bound index for the current search. Returns: int: The index of the target if found, else -1. if low <= high: mid = (low + high) // 2 if array[mid] == target: return mid elif array[mid] < target: return binary_search_recur(array, target, mid + 1, high) else: return binary_search_recur(array, target, low, mid - 1) return -1"},{"question":"# Coding Task: Primitive Root Generator Problem Statement: You are asked to implement an efficient algorithm to find all primitive roots of a given integer `n`. To do this, you will use three helper functions: `find_order`, `euler_totient`, and `find_primitive_root`, which compute the mathematical properties needed to determine whether a number is a primitive root. Input: - An integer `n` (1 ≤ n ≤ 10^6). Output: - A list of integers which are the primitive roots of `n`. If `n = 1`, return `[0]`. If no primitive roots exist, return an empty list. Constraints: - Your algorithm should aim for readability and efficiency within the given constraints. Detailed Requirements: 1. **Helper Function: `find_order(a, n)`**: - Input: Integers `a` and `n`. - Output: The order of `a` modulo `n`, or `-1` if no order exists. - Complexity: Should be optimized to O(nlog(n)). 2. **Helper Function: `euler_totient(n)`**: - Input: Integer `n`. - Output: Euler\'s totient function value `ϕ(n)`. - Complexity: Should be optimized to O(sqrt(n)). 3. **Main Function: `find_primitive_root(n)`**: - Input: Integer `n`. - Output: List of primitive roots of `n`. - Complexity: Should aim to be optimized within feasible limits, taking into account the nested operations. Example: ```python # Example input: n = 10 # Example output: # [3, 7] n = 1 # Example output: # [0] ``` Tips: - Ensure you handle edge cases, such as when `n` is very small or very large. - Make use of efficient number theory functions to keep your solution within the performance requirements.","solution":"def gcd(a, b): while b: a, b = b, a % b return a def find_order(a, n): if gcd(a, n) != 1: return -1 order = 1 current = a % n while current != 1: order += 1 current = (current * a) % n return order def euler_totient(n): result = n p = 2 while p * p <= n: if n % p == 0: while n % p == 0: n //= p result -= result // p p += 1 if n > 1: result -= result // n return result def find_primitive_root(n): if n == 1: return [0] phi = euler_totient(n) roots = [] for a in range(1, n): if gcd(a, n) == 1 and find_order(a, n) == phi: roots.append(a) return roots"},{"question":"# Question: Find the Deepest Left Node in a Binary Tree Problem Description You are given a binary tree, and your task is to find the deepest node which is the left child of its parent. You need to implement this function using depth-first search (DFS). Function Signature ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find_deepest_left_node(root: TreeNode) -> int: # Your code here pass ``` Input - `root` (TreeNode): The root node of the binary tree. Output - Returns the value of the deepest left child node. If no such node exists, return `-1`. Constraints - The number of nodes in the tree is in the range [1, 10^4]. - The values of the nodes are in the range [-10^5, 10^5]. Example ```python # Example Tree: # 1 # / # 2 3 # / # 4 5 6 # # 7 # For the above tree, the deepest left node is 4. root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) root.right.right = TreeNode(6) root.right.right.right = TreeNode(7) # Expected output: 4 print(find_deepest_left_node(root)) ``` Guidelines 1. Implement the `TreeNode` class if necessary. 2. Use DFS to traverse the tree. 3. Track if the current node is a left child during recursion. 4. Keep updating the depth and value of the deepest left child encountered.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find_deepest_left_node(root: TreeNode) -> int: Find the deepest left node in a binary tree and return its value. Parameters: root (TreeNode): The root of the binary tree. Returns: int: The value of the deepest left node, or -1 if no such node exists. if not root: return -1 max_depth = -1 deepest_left_value = -1 def dfs(node, depth, is_left): nonlocal max_depth, deepest_left_value if not node: return if is_left and not node.left and not node.right: if depth > max_depth: max_depth = depth deepest_left_value = node.val dfs(node.left, depth + 1, True) dfs(node.right, depth + 1, False) dfs(root, 0, False) return deepest_left_value"},{"question":"# Longest Common Prefix (LCP) Problem Statement Write a function `longest_common_prefix(strs: List[str]) -> str` to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string `\\"\\"`. Constraints - All strings are in lowercase English letters only. - 1 <= len(strs) <= 200 - 0 <= len(str[i]) <= 200 Input: - A list of strings, `strs`. Output: - A single string representing the longest common prefix. Examples **Example 1:** Input: `[\\"flower\\",\\"flow\\",\\"flight\\"]` Output: `\\"fl\\"` **Example 2:** Input: `[\\"dog\\",\\"racecar\\",\\"car\\"]` Output: `\\"\\"` Scenario You are developing a code editor\'s \\"autocomplete\\" feature where you must find the longest common string in real-time from a list of user’s frequently used words. Your function `longest_common_prefix` will be clipped into that autocomplete function, helping suggest completions as the user types. Performance Requirements - The solution must handle the constraints efficiently. - Ensure the solution adheres to the optimal time complexity. Task Implement the function `longest_common_prefix` using one of the given strategies (Horizontal scanning, Vertical scanning, or Divide and Conquer). Ensure that the function properly handles edge cases and optimizes performance where possible. ```python from typing import List def longest_common_prefix(strs: List[str]) -> str: # Your implementation here pass ```","solution":"from typing import List def longest_common_prefix(strs: List[str]) -> str: if not strs: return \\"\\" # Finding the minimum length string in the list min_length = min(len(s) for s in strs) # Start with an empty prefix prefix = \\"\\" for i in range(min_length): # Take the current character from the first string char = strs[0][i] # Check if this character is the same in all strings if all(s[i] == char for s in strs): prefix += char else: break return prefix"},{"question":"# Coding Challenge: Enhanced Bucket Sort **Context**: You are working on a project that requires efficient sorting of large datasets. Given the current implementation of Bucket Sort, you suspect that the worst-case performance is occasionally impacting the overall system efficiency. You decide to enhance the current bucket sort by implementing a more optimized sorting algorithm (Mergesort) for sorting elements within each bucket. **Task**: Implement the `bucket_sort` function by replacing the current `next_sort` (insertion sort) with Mergesort. Your solution should maintain the original structure but replace insertion sort with an optimized Mergesort for intra-bucket sorting. **Function Signature**: ```python def bucket_sort(arr): pass def merge_sort(arr): pass ``` **Input**: * `arr`: A list of non-negative integers. **Output**: * A sorted list of integers. **Constraints**: * 1 <= len(arr) <= 10^5 * 0 <= arr[i] <= 10^6 # Example: ```python assert bucket_sort([4, 1, 7, 3, 10]) == [1, 3, 4, 7, 10] assert bucket_sort([10, 4, 7, 1, 3]) == [1, 3, 4, 7, 10] ``` **Notes**: 1. Write a separate `merge_sort` function for sorting elements within each bucket. 2. Ensure that your implementation is efficient and handles edge cases effectively. # Implementation Guidance: 1. Modify the `next_sort` function to implement merge sort. 2. Use the modified `merge_sort` in your bucket sorting algorithm. 3. Take care of edge cases such as an empty list or all elements being the same.","solution":"def bucket_sort(arr): if len(arr) == 0: return arr # Create buckets and distribute the elements max_value = max(arr) size = max_value / len(arr) buckets = [[] for _ in range(len(arr))] for i in range(len(arr)): index = int(arr[i] / size) if index != len(arr): buckets[index].append(arr[i]) else: # Case when the element is the maximum value buckets[len(arr) - 1].append(arr[i]) # Sort each bucket using merge sort for i in range(len(buckets)): buckets[i] = merge_sort(buckets[i]) # Concatenate buckets result = [] for i in range(len(buckets)): result.extend(buckets[i]) return result def merge_sort(arr): if len(arr) <= 1: return arr mid = len(arr) // 2 left = merge_sort(arr[:mid]) right = merge_sort(arr[mid:]) return merge(left, right) def merge(left, right): result = [] i = j = 0 while i < len(left) and j < len(right): if left[i] <= right[j]: result.append(left[i]) i += 1 else: result.append(right[j]) j += 1 result.extend(left[i:]) result.extend(right[j:]) return result"},{"question":"Implement an improved sorting algorithm that demonstrates your understanding of advanced sorting techniques. Use the `bubble_sort` function provided as a reference, but enhance the algorithm to efficiently handle large datasets and improve its performance. # Requirements * **Input/Output**: * Write a function `improved_sort(arr: List[int]) -> List[int]`. * It takes a list of integers (`arr`) as input and returns a sorted list. * **Constraints**: * Optimize the sorting algorithm to avoid O(n^2) time complexity on average. * The input list can be of any length but must contain integers only. * The implementation should maintain the stability of the sorting algorithm. * **Performance**: * Aim for an average-case time complexity better than O(n^2). # Example ```python Input: [64, 34, 25, 12, 22, 11, 90] Output: [11, 12, 22, 25, 34, 64, 90] Input: [5, 1, 4, 2, 8] Output: [1, 2, 4, 5, 8] ```","solution":"def improved_sort(arr): This function implements the Merge Sort algorithm which provides better performance than O(n^2) in average and worst-case scenarios. Merge Sort also maintains the stability of the sorting algorithm. if len(arr) <= 1: return arr # Split the array into two halves mid = len(arr) // 2 left_half = improved_sort(arr[:mid]) right_half = improved_sort(arr[mid:]) return merge(left_half, right_half) def merge(left, right): Helper function to merge two halves in a sorted manner. sorted_array = [] left_index, right_index = 0, 0 while left_index < len(left) and right_index < len(right): if left[left_index] <= right[right_index]: sorted_array.append(left[left_index]) left_index += 1 else: sorted_array.append(right[right_index]) right_index += 1 # Append the remaining elements sorted_array.extend(left[left_index:]) sorted_array.extend(right[right_index:]) return sorted_array"},{"question":"Problem Statement You are given a 32-bit integer, and you can flip exactly one bit from 0 to 1. Write a function, `max_ones_sequence`, that determines the length of the longest sequence of 1s you could create by flipping a single bit of the given integer. # Function Signature ```python def max_ones_sequence(num: int) -> int: ``` # Input * `num` (int): A 32-bit integer (both positive and negative values are allowed). # Output * `int`: The length of the longest sequence of 1s possible with exactly one bit flipped from 0 to 1. # Example Example 1 * **Input**: `1775` (binary: `11011101111`) * **Output**: `8` Example 2 * **Input**: `-1` (binary: all 1\'s in 32-bit representation) * **Output**: `32` # Constraints * You must handle both positive and negative 32-bit integers. * Aim for an algorithm with a time complexity of O(b), where b is the number of bits in the integer. # Hints 1. When calculating sequences, consider edge cases like long consecutive sequences of \'1\'s. 2. Make sure to process both the current and subsequent bits correctly when counting sequences.","solution":"def max_ones_sequence(num: int) -> int: Determines the length of the longest sequence of 1s that could be created by flipping exactly one bit from 0 to 1 in the given 32-bit integer. if num == -1: return 32 current_length = 0 previous_length = 0 max_length = 0 for _ in range(32): if (num & 1) == 1: current_length += 1 else: previous_length = 0 if (num & 2) == 0 else current_length current_length = 0 max_length = max(max_length, previous_length + current_length + 1) num >>= 1 return max_length"},{"question":"# Matrix Inversion Challenge You are tasked with implementing a function that computes the inverse of a given n x n matrix using the cofactor method. Your function should account for various edge cases and ensure it handles invalid inputs appropriately. **Function Signature:** ```python def invert_matrix(matrix: List[List[float]]) -> List[List[float]]: pass ``` **Input:** - `matrix` (List of List of float): An n x n matrix represented as a list of n lists, each containing n floating point numbers. **Output:** - Returns the inverse of the given matrix as an n x n list of lists. In the case of invalid input or singular matrices, return a list containing a single list with a specific error code: - `[-1]` if the input is not a matrix. - `[-2]` if the matrix is not square. - `[-3]` if the matrix size is less than 2x2. - `[-4]` if the matrix is singular (determinant is zero). **Constraints:** - The input matrix can contain both positive and negative floating point numbers. - The determinant of the matrix should not be zero to have an inverse. **Performance Requirements:** - Your implementation must be efficient enough to handle matrices up to size 10x10 within a reasonable time frame. # Example ```python matrix = [ [4, 7], [2, 6] ] print(invert_matrix(matrix)) # Should output: [[0.6, -0.7], [-0.2, 0.4]] matrix = [ [1, 2, 3], [0, 1, 4], [5, 6, 0] ] print(invert_matrix(matrix)) # Expected output based on matrix inversion. ``` **Notes:** - Pay special attention to edge cases and handle error scenarios as described above. - Avoid using any high-level libraries for matrix inversion; implement the algorithm as described.","solution":"from typing import List def determinant(matrix: List[List[float]], n: int) -> float: if n == 1: return matrix[0][0] if n == 2: return matrix[0][0]*matrix[1][1] - matrix[0][1]*matrix[1][0] det = 0 for c in range(n): det += ((-1) ** c) * matrix[0][c] * determinant(minor(matrix, 0, c), n - 1) return det def minor(matrix: List[List[float]], i: int, j: int) -> List[List[float]]: return [row[:j] + row[j + 1:] for row in (matrix[:i] + matrix[i + 1:])] def cofactor(matrix: List[List[float]], n: int) -> List[List[float]]: cofactors = [] for r in range(n): cofactorRow = [] for c in range(n): minorMatrix = minor(matrix, r, c) cofactorRow.append(((-1) ** (r + c)) * determinant(minorMatrix, n - 1)) cofactors.append(cofactorRow) return cofactors def transpose(matrix: List[List[float]]) -> List[List[float]]: return list(map(list, zip(*matrix))) def inverse(matrix: List[List[float]], n: int) -> List[List[float]]: det = determinant(matrix, n) if det == 0: return [[-4]] cofactors = cofactor(matrix, n) adjugate = transpose(cofactors) for r in range(n): for c in range(n): adjugate[r][c] = adjugate[r][c] / det return adjugate def invert_matrix(matrix: List[List[float]]) -> List[List[float]]: if not isinstance(matrix, list) or not all(isinstance(row, list) for row in matrix): return [[-1]] n = len(matrix) if n < 2 or any(len(row) != n for row in matrix): return [[-2 if any(len(row) != n for row in matrix) else -3]] return inverse(matrix, n)"},{"question":"Context You are tasked with creating a new software feature that requires sorting user input data. Your goal is to improve the existing simple sorting mechanism. One alternative you can consider is the Cocktail Shaker Sort, a bi-directional variant of bubble sort. Problem Statement Implement the `cocktail_shaker_sort` function to sort a given list of integers using the Cocktail Shaker Sort algorithm. Your implementation should follow the principles of the algorithm described and include optimizations to improve its efficiency where possible. Function Signature ```python def cocktail_shaker_sort(arr: List[int]) -> List[int]: ``` Input * A list of integers `arr` where: - The length of `arr` (denoted as N) can range from 0 to 1000. - Values in `arr` can be any integers, positive or negative. Output * The function should return a sorted list of integers. Constraints * The sorting should be performed in-place with O(1) space complexity. * The overall algorithmic complexity should ideally be O(N^2) in the average and worst case. Example ```python print(cocktail_shaker_sort([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5])) # Output: [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9] print(cocktail_shaker_sort([10, -1, 2, -10, 5, 7])) # Output: [-10, -1, 2, 5, 7, 10] print(cocktail_shaker_sort([])) # Output: [] print(cocktail_shaker_sort([42])) # Output: [42] ``` Notes * You may use helper functions if necessary. * Ensure to handle all edge cases, specifically empty arrays and arrays with a single element. * Emphasize code readability and efficiency.","solution":"def cocktail_shaker_sort(arr): Sorts a list of integers in ascending order using the Cocktail Shaker Sort algorithm. n = len(arr) if n <= 1: return arr is_sorted = False start = 0 end = n - 1 while not is_sorted: is_sorted = True # Forward pass for i in range(start, end): if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] is_sorted = False if is_sorted: break is_sorted = True end -= 1 # Backward pass for i in range(end - 1, start - 1, -1): if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] is_sorted = False start += 1 return arr"},{"question":"You\'ve been tasked with implementing a secure numerical computation system as part of a broader cryptographic module. One fundamental operation you need to implement is efficient exponentiation, given the frequent need to perform power calculations with high exponents and potentially large bases, often under a specified modulus. **Function Signature**: ```python def power(a: int, n: int, mod: int = None) -> int: pass ``` # Description Implement and document an efficient function `power(a, n, mod)` that calculates (a^n) using: - An **iterative** version of binary exponentiation. - A **recursive** version, named `power_recur(a, n, mod)`. (Consider this as a helper function and invoke it from within `power` if you choose to handle recursion separately.) # Input: 1. **a**: Base integer ((1 leq a leq 10^{9})). 2. **n**: Exponent integer ((0 leq n leq 10^{9})). 3. **mod**: An optional modulus integer ((2 leq text{mod} leq 10^{9})). # Output: - Returns the result of (a^n). - If `mod` is not `None`, return (a^n % text{mod}). # Constraints and Performance Requirements: 1. Ensure (O(log n)) time complexity for efficient computation. 2. Optimize memory usage with (O(1)) space for the iterative version. 3. Handle potential edge cases like (n = 0), (n = 1), and negative values correctly. # Examples: ```python print(power(2, 10)) # 1024 print(power(2, 10, 1000)) # 24 print(power(7, 0)) # 1 print(power(0, 0)) # 1 (by convention) print(power(3, 3)) # 27 print(power(2, 3, 3)) # 2 (8 % 3 = 2) ``` # Requirements: 1. Implement both the iterative and recursive versions of the binary exponentiation. 2. Ensure your implementation handles large numbers efficiently and correctly, especially with modulo operation included. 3. Provide clear and comprehensive inline comments and documentation for each function explaining the process.","solution":"def power_iter(a: int, n: int, mod: int = None) -> int: Efficiently computes a^n using an iterative version of binary exponentiation. If mod is specified, returns a^n % mod. Args: - a (int): The base integer. - n (int): The exponent integer. - mod (int, optional): The modulus integer. Default is None. Returns: - int: The result of the exponentiation, optionally modulo `mod`. result = 1 base = a while n > 0: if n % 2 == 1: result = (result * base) % mod if mod else result * base base = (base * base) % mod if mod else base * base n //= 2 return result def power_recur(a: int, n: int, mod: int = None) -> int: Efficiently computes a^n using a recursive version of binary exponentiation. If mod is specified, returns a^n % mod. Args: - a (int): The base integer. - n (int): The exponent integer. - mod (int, optional): The modulus integer. Default is None. Returns: - int: The result of the exponentiation, optionally modulo `mod`. if n == 0: return 1 half_power = power_recur(a, n // 2, mod) half_power = (half_power * half_power) % mod if mod else half_power * half_power if n % 2 == 1: half_power = (half_power * a) % mod if mod else half_power * a return half_power def power(a: int, n: int, mod: int = None) -> int: Wrapper function that calls the iterative version by default. Args: - a (int): The base integer. - n (int): The exponent integer. - mod (int, optional): The modulus integer. Default is None. Returns: - int: The result of the exponentiation, optionally modulo `mod`. return power_iter(a, n, mod)"},{"question":"# Question You are tasked with implementing a probabilistic primality test for a cryptographic application that requires identifying large prime numbers. The algorithm should follow the Rabin-Miller Primality Test principles but include additional handling for smaller edge cases by simple deterministic checks. Function Signature ```python def probabilistic_primality_test(n: int, k: int) -> bool: ``` Input: * `n` (int): The integer to be tested for primality. * `k` (int): The number of iterations/tests to reduce the probability of error. Output: * Returns `True` if `n` is probably prime. * Returns `False` if `n` is definitely composite. Constraints: * ( n geq 1 ) * ( k geq 1 ) Example: ```python assert probabilistic_primality_test(561, 5) == False # 561 is known to be composite assert probabilistic_primality_test(7, 10) == True # 7 is prime ``` # Notes: 1. For ( n < 5 ): * Return `True` if ( n ) is one of {2, 3}. * Return `False` otherwise. 2. Use random values for the witness test between 2 and ( n-2 ). 3. Each iteration should reduce the probability of erroneously identifying a composite as prime by approximately ( 4^{-k} ). # Implementation Details: 1. Factor ( n-1 ) into ( 2^r times d ) where ( d ) is odd. 2. Run ( k ) iterations of witnessing potential compositeness: * Select a random witness and check if it violates primality conditions. * If any witness indicates compositeness, return `False`. 3. If all tests pass, return `True`.","solution":"import random def probabilistic_primality_test(n: int, k: int) -> bool: Uses the Rabin-Miller Primality Test to determine if n is probably prime. The test is repeated k times to reduce the probability of error. if n < 2: return False if n in (2, 3): return True if n % 2 == 0: return False # Write n-1 as 2^r * d where d is odd r, d = 0, n - 1 while d % 2 == 0: r += 1 d //= 2 def is_composite(a): Checks if a is a composite witness for n. x = pow(a, d, n) if x == 1 or x == n - 1: return False for _ in range(r - 1): x = pow(x, 2, n) if x == n - 1: return False return True for _ in range(k): a = random.randint(2, n - 2) if is_composite(a): return False return True"},{"question":"# Question: Reverse Words in a Sentence You have been tasked with writing a program that takes a string and reverses the order of words within it. Each word is defined as a sequence of non-space characters. Words should be separated by a single space in the output, and there should not be any extra spaces in the output string. Function Signature ```python def reverse_words(sentence: str) -> str: ``` Input - `sentence`: A string `s` of length `n`, where `0 <= n <= 10000`. Output - A string `result`, which is the input string with the order of words reversed. Constraints - Your solution should have a time complexity of O(n), where n is the length of the sentence. - The space complexity should be O(1) additional space (ignoring the space required for the input and output strings). Examples 1. Input: `\\"Hello world\\"` - Output: `\\"world Hello\\"` 2. Input: `\\" a fast runner \\"` - Output: `\\"runner fast a\\"` 3. Input: `\\"keon kim pizza\\"` - Output: `\\"pizza kim keon\\"` Edge Cases - An empty string should return an empty string. - A string with multiple consecutive spaces should still only have one space separating the words in the output. Implementation Challenge Handle both typical and edge cases efficiently, ensuring that your solution is optimal in terms of time and space complexity. The function should handle leading, trailing, and multiple consecutive spaces correctly.","solution":"def reverse_words(sentence: str) -> str: Reverses the order of words in the given sentence. Args: sentence: A string containing the sentence to reverse the words of. Returns: A string with words in reverse order. # Split the sentence into words words = sentence.split() # Reverse the list of words reversed_words = words[::-1] # Join the reversed list back into a single string with spaces in between result = \' \'.join(reversed_words) return result"},{"question":"You are tasked with implementing a function to find the Least Common Multiple (LCM) of two integers using a novel algorithm. The provided implementation of `lcm` uses the GCD (Greatest Common Divisor) approach. However, your task is to come up with an optimized version that minimizes computational steps, considering practical constraints like integer overflow for large numbers. # Specifications * **Input** - Two positive integers `a` and `b` (`1 <= a, b <= 10^18`). * **Output** - One positive integer, which is the LCM of `a` and `b`. * **Constraints** - You must avoid integer overflow. - Optimize for both performance and memory use. - Consider edge cases and large input values. # Function Signature ```python def optimized_lcm(a: int, b: int) -> int: pass ``` # Example ```python assert optimized_lcm(21, 6) == 42 assert optimized_lcm(13, 17) == 221 assert optimized_lcm(1234567891011, 1234567891011) == 1234567891011 ``` # Hint You may consider alternative mathematical approaches or more sophisticated number handling mechanisms to ensure accuracy and efficiency for very large inputs.","solution":"import math def optimized_lcm(a: int, b: int) -> int: Returns the Least Common Multiple (LCM) of two integers a and b. This implementation uses the GCD-based approach to avoid integer overflow. return abs(a * b) // math.gcd(a, b)"},{"question":"# Question: You are given a string `s` and are tasked with implementing a function to reverse the string. The function should be written in three different ways: recursively, iteratively, and using Python slicing. The purpose of this exercise is to demonstrate comprehension of different algorithmic approaches to solving the same problem. Function Signature ```python def reverse_recursive(s: str) -> str: # Your implementation here def reverse_iterative(s: str) -> str: # Your implementation here def reverse_slicing(s: str) -> str: # Your implementation here ``` # Input - A single string `s` where (0 leq text{len}(s) leq 10^6). # Output - Return the reversed string. # Constraints - Each approach must correctly handle edge cases, such as empty strings and single-character strings. - Function names and signatures should remain as provided. - Performance of solutions should meet the expected time complexity discussed. # Example - Input: `\\"hello\\"` - Output: `\\"olleh\\"` - Input: `\\"racecar\\"` - Output: `\\"racecar\\"` # Requirements - Implement `reverse_recursive`, `reverse_iterative`, and `reverse_slicing` functions. - Ensure code is optimized for performance and handles edge cases. # Performance Notes - The recursive approach should not hit maximum recursion depth for reasonable input sizes. - Iterative and slicing methods should exhibit linear performance characteristics. # Evaluation Criteria - Correctness and adherence to specifications. - Efficiency and optimization of the implemented functions. - Handling of specified edge cases.","solution":"def reverse_recursive(s: str) -> str: Recursively reverses the given string s. if len(s) <= 1: return s return s[-1] + reverse_recursive(s[:-1]) def reverse_iterative(s: str) -> str: Iteratively reverses the given string s. reversed_str = \\"\\" for char in s: reversed_str = char + reversed_str return reversed_str def reverse_slicing(s: str) -> str: Reverses the given string s using slicing. return s[::-1]"},{"question":"# Question: Enhanced Quick Sort Implementation **Context:** You are hired by a tech company to improve the performance of their flagship sorting library. One of the popular methods in this library is Quick Sort. The current implementation has some performance issues with large and small datasets. **Task:** Implement an enhanced version of Quick Sort that addresses its weaknesses and optimizes pivot selection to mitigate worst-case performance. **Details:** 1. Implement a function `enhanced_quick_sort(arr)` that sorts an array `arr` using Quick Sort with optimized pivot selection. 2. Optimize pivot selection using the median-of-three rule. 3. Use insertion sort for small sub-arrays (size <= 10) to improve performance. 4. Ensure the function maintains the following properties of Quick Sort: - O(n log n) average case time complexity. - In-place sorting (does not use extra storage for sorting). **Input Format:** - A list of integers `arr` which can contain both positive and negative values. **Output Format:** - A list of integers, sorted in non-decreasing order. **Constraints:** - The length of the array `n` is between 1 and 10^6. - The array elements can be any integer fitting in a standard Python `int`. **Example:** ```python # Example Input arr = [34, 7, 23, 32, 5, 62] # Example Output print(enhanced_quick_sort(arr)) # Output: [5, 7, 23, 32, 34, 62] ```","solution":"def insertion_sort(arr, left, right): for i in range(left + 1, right + 1): key = arr[i] j = i - 1 while j >= left and key < arr[j]: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key def median_of_three(arr, low, high): mid = (low + high) // 2 if arr[low] > arr[mid]: arr[low], arr[mid] = arr[mid], arr[low] if arr[low] > arr[high]: arr[low], arr[high] = arr[high], arr[low] if arr[mid] > arr[high]: arr[mid], arr[high] = arr[high], arr[mid] arr[mid], arr[high] = arr[high], arr[mid] return arr[high] def partition(arr, low, high): pivot = median_of_three(arr, low, high) i = low - 1 for j in range(low, high): if arr[j] <= pivot: i += 1 arr[i], arr[j] = arr[j], arr[i] arr[i + 1], arr[high] = arr[high], arr[i + 1] return i + 1 def quick_sort(arr, low, high): if low < high: if high - low <= 10: insertion_sort(arr, low, high) else: pi = partition(arr, low, high) quick_sort(arr, low, pi - 1) quick_sort(arr, pi + 1, high) def enhanced_quick_sort(arr): if len(arr) == 0: return arr quick_sort(arr, 0, len(arr) - 1) return arr"},{"question":"# Matrix Rotation Challenge Given an n x n 2D matrix \'matrix\', rotate the matrix 90 degrees clockwise in-place. Your implementation must modify the input matrix directly without using extra space for another matrix. Input Format - A 2D list `matrix` of dimensions ( n times n ) where ( 1 leq n leq 1000 ) containing integers. Output Format - The function should return the modified matrix, but the main goal is to validate the in-place modification. # Example ```python # Example input matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] # Expected in-place transformation [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] ``` # Constraints - Modify the input 2D matrix in-place. - The matrix will always be of shape ( n times n ). # Task Implement the function `rotate_matrix(matrix: List[List[int]]) -> None` which performs the in-place rotation. Function Signature ```python def rotate_matrix(matrix: List[List[int]]) -> None: pass ``` Notes - You may assume all elements are integers. - Your implementation should work efficiently even for large values of ( n ).","solution":"from typing import List def rotate_matrix(matrix: List[List[int]]) -> None: Rotates the given n x n 2D matrix 90 degrees clockwise in-place. n = len(matrix) # Step 1: Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Step 2: Reverse each row for i in range(n): matrix[i].reverse()"},{"question":"You are tasked to build a self-balancing binary search tree using Red-Black Tree data structure. The Red-Black Tree should support insertion and deletion of nodes while maintaining its balance property. # Requirements Implement a class `RedBlackTree` that supports the following operations: 1. **Insertion** of a value. 2. **Deletion** of a value. 3. **Finding the minimum and maximum value** in the tree. 4. **In-order traversal** to retrieve all elements in sorted order. # Function Signatures ```python class RedBlackTree(): def __init__(self): pass def insert(self, val: int) -> None: Insert a value into the Red-Black Tree. :param val: Value to be inserted. pass def delete(self, val: int) -> None: Delete a value from the Red-Black Tree. :param val: Value to be deleted. pass def find_minimum(self) -> int: Find the minimum value in the Red-Black Tree. :return: Minimum value. pass def find_maximum(self) -> int: Find the maximum value in the Red-Black Tree. :return: Maximum value. pass def in_order_traversal(self) -> list: Perform in-order traversal of the Red-Black Tree. :return: List of elements in in-order traversal. pass ``` # Constraints - Each `insert` operation must guarantee the tree remains balanced. - No duplicate elements will be added. - Handle edge cases where the value to be deleted or searched does not exist. # Example Usage ```python rb_tree = RedBlackTree() rb_tree.insert(10) rb_tree.insert(20) rb_tree.insert(15) rb_tree.insert(30) print(rb_tree.in_order_traversal()) # Output: [10, 15, 20, 30] print(rb_tree.find_minimum()) # Output: 10 print(rb_tree.find_maximum()) # Output: 30 rb_tree.delete(20) print(rb_tree.in_order_traversal()) # Output: [10, 15, 30] ```","solution":"class Node: def __init__(self, data, color=\\"red\\"): self.data = data self.color = color self.left = None self.right = None self.parent = None class RedBlackTree: def __init__(self): self.TNULL = Node(0) self.TNULL.color = \\"black\\" self.root = self.TNULL def insert(self, key): node = Node(key) node.left = self.TNULL node.right = self.TNULL parent = None cur = self.root while cur != self.TNULL: parent = cur if node.data < cur.data: cur = cur.left else: cur = cur.right node.parent = parent if parent is None: self.root = node elif node.data < parent.data: parent.left = node else: parent.right = node if node.parent is None: node.color = \\"black\\" return if node.parent.parent is None: return self._balance_insert(node) def delete(self, key): self._delete_node_helper(self.root, key) def find_minimum(self): return self._minimum(self.root).data def find_maximum(self): return self._maximum(self.root).data def in_order_traversal(self): elements = [] self._in_order_helper(self.root, elements) return elements def _balance_insert(self, k): while k.parent.color == \\"red\\": if k.parent == k.parent.parent.right: u = k.parent.parent.left if u.color == \\"red\\": u.color = \\"black\\" k.parent.color = \\"black\\" k.parent.parent.color = \\"red\\" k = k.parent.parent else: if k == k.parent.left: k = k.parent self._right_rotate(k) k.parent.color = \\"black\\" k.parent.parent.color = \\"red\\" self._left_rotate(k.parent.parent) else: u = k.parent.parent.right if u.color == \\"red\\": u.color = \\"black\\" k.parent.color = \\"black\\" k.parent.parent.color = \\"red\\" k = k.parent.parent else: if k == k.parent.right: k = k.parent self._left_rotate(k) k.parent.color = \\"black\\" k.parent.parent.color = \\"red\\" self._right_rotate(k.parent.parent) if k == self.root: break self.root.color = \\"black\\" def _delete_node_helper(self, node, key): z = self.TNULL while node != self.TNULL: if node.data == key: z = node if node.data <= key: node = node.right else: node = node.left if z == self.TNULL: return y = z y_original_color = y.color if z.left == self.TNULL: x = z.right self._rb_transplant(z, z.right) elif z.right == self.TNULL: x = z.left self._rb_transplant(z, z.left) else: y = self._minimum(z.right) y_original_color = y.color x = y.right if y.parent == z: x.parent = y else: self._rb_transplant(y, y.right) y.right = z.right y.right.parent = y self._rb_transplant(z, y) y.left = z.left y.left.parent = y y.color = z.color if y_original_color == \\"black\\": self._balance_delete(x) def _minimum(self, node): while node.left != self.TNULL: node = node.left return node def _maximum(self, node): while node.right != self.TNULL: node = node.right return node def _in_order_helper(self, node, res): if node != self.TNULL: self._in_order_helper(node.left, res) res.append(node.data) self._in_order_helper(node.right, res) def _balance_delete(self, x): while x != self.root and x.color == \\"black\\": if x == x.parent.left: s = x.parent.right if s.color == \\"red\\": s.color = \\"black\\" x.parent.color = \\"red\\" self._left_rotate(x.parent) s = x.parent.right if s.left.color == \\"black\\" and s.right.color == \\"black\\": s.color = \\"red\\" x = x.parent else: if s.right.color == \\"black\\": s.left.color = \\"black\\" s.color = \\"red\\" self._right_rotate(s) s = x.parent.right s.color = x.parent.color x.parent.color = \\"black\\" s.right.color = \\"black\\" self._left_rotate(x.parent) x = self.root else: s = x.parent.left if s.color == \\"red\\": s.color = \\"black\\" x.parent.color = \\"red\\" self._right_rotate(x.parent) s = x.parent.left if s.left.color == \\"black\\" and s.right.color == \\"black\\": s.color = \\"red\\" x = x.parent else: if s.left.color == \\"black\\": s.right.color = \\"black\\" s.color = \\"red\\" self._left_rotate(s) s = x.parent.left s.color = x.parent.color x.parent.color = \\"black\\" s.left.color = \\"black\\" self._right_rotate(x.parent) x = self.root x.color = \\"black\\" def _rb_transplant(self, u, v): if u.parent == None: self.root = v elif u == u.parent.left: u.parent.left = v else: u.parent.right = v v.parent = u.parent def _left_rotate(self, x): y = x.right x.right = y.left if y.left != self.TNULL: y.left.parent = x y.parent = x.parent if x.parent == None: self.root = y elif x == x.parent.left: x.parent.left = y else: x.parent.right = y y.left = x x.parent = y def _right_rotate(self, x): y = x.left x.left = y.right if y.right != self.TNULL: y.right.parent = x y.parent = x.parent if x.parent == None: self.root = y elif x == x.parent.right: x.parent.right = y else: x.parent.left = y y.right = x x.parent = y"},{"question":"# Question: Determine 1-Sparse Numbers in a Data Stream **Background**: In data streams, there are scenarios where you need to determine if a stream of numbers, combined with addition or subtraction signs, can be reduced to exactly one unique number that remains non-canceled. **Problem Statement**: Write a Python function to determine if the given stream of tuples (`(value, sign)`) can be classified as 1-sparse. If it is 1-sparse, return the unique non-canceled number. Otherwise, return `None`. **Function Signature:** ```python def one_sparse(array: List[Tuple[int, str]]) -> Optional[int]: pass ``` **Input**: - `array`: A list of tuples, where each tuple consists of: - `value` (int): A non-negative integer. - `sign` (str): Either `\'+\'` or `\'-\'`. **Output**: - An integer if the stream is 1-sparse. - `None` if the stream is not 1-sparse. **Constraints**: - Each number will be a non-negative integer (0 <= value <= 10^6). - The stream size will be between 1 and 10^5 tuples. **Example**: 1. Input: [(4, \'+\'), (2, \'+\'), (2, \'-\'), (4, \'+\'), (3, \'+\'), (3, \'-\')] Output: 4 (Explanation: All numbers except 4 cancel out.) 2. Input: [(2, \'+\'), (2, \'+\'), (2, \'+\'), (2, \'+\'), (2, \'+\'), (2, \'+\'), (2, \'+\')] Output: 2 (Explanation: No other numbers present.) 3. Input: [(2, \'+\'), (2, \'+\'), (2, \'+\'), (2, \'+\'), (2, \'+\'), (2, \'+\'), (1, \'+\')] Output: None (Explanation: Not 1-sparse as there\'s an extra 1.) **Notes**: - Ensure that your function efficiently handles the given constraints. - Consider edge cases such as all additions or subtractions leading to zero or cases with all values being the same.","solution":"from typing import List, Tuple, Optional from collections import defaultdict def one_sparse(array: List[Tuple[int, str]]) -> Optional[int]: This function determines if the given stream of tuples is 1-sparse. If it is 1-sparse, returns the unique non-canceled number. Otherwise, returns None. count_dict = defaultdict(int) for value, sign in array: if sign == \'+\': count_dict[value] += 1 elif sign == \'-\': count_dict[value] -= 1 non_canceled_values = [v for v, count in count_dict.items() if count != 0] if len(non_canceled_values) == 1: return non_canceled_values[0] else: return None"},{"question":"Problem Statement You are tasked to write a function `selection_sort_simulate` which implements the Selection Sort algorithm, enhanced with a simulation mode to visualize the sorting process. Your function should sort a given list of integers in ascending order. # Function Signature ```python def selection_sort_simulate(arr: List[int], simulation: bool = False) -> List[int]: pass ``` # Input - `arr` (List[int]): A list of integers that needs to be sorted. - `simulation` (bool): A boolean flag to enable step-by-step simulation of the sorting process. When `True`, the function should print the array after each complete pass through the array. # Output - Returns a list of integers in ascending order. # Constraints - The input list can have up to 1000 integers. - Each integer in the list can range from -10^6 to 10^6. # Requirements 1. Implement the Selection Sort algorithm as described. 2. If the `simulation` parameter is set to `True`, the function should print the state of the list after each complete pass through the list, with the current iteration number. Use the format: `iteration <iteration_number> : <space-separated-elements>`. 3. Maintain the overall time complexity of O(n^2) and space complexity of O(1). # Example ```python # Example 1 print(selection_sort_simulate([64, 25, 12, 22, 11], simulation=False)) # Output: [11, 12, 22, 25, 64] # Example 2 print(selection_sort_simulate([64, 25, 12, 22, 11], simulation=True)) # Output (Includes print statements for each iteration): # iteration 0 : 11 25 12 22 64 # iteration 1 : 11 12 25 22 64 # iteration 2 : 11 12 22 25 64 # iteration 3 : 11 12 22 25 64 # iteration 4 : 11 12 22 25 64 # Final output: [11, 12, 22, 25, 64] ``` # Additional Notes - Ensure that your implementation handles all edge cases, such as an empty list or a list with a single element.","solution":"from typing import List def selection_sort_simulate(arr: List[int], simulation: bool = False) -> List[int]: n = len(arr) for i in range(n): min_idx = i for j in range(i+1, n): if arr[j] < arr[min_idx]: min_idx = j arr[i], arr[min_idx] = arr[min_idx], arr[i] if simulation: print(f\'iteration {i} : {\\" \\".join(map(str, arr))}\') return arr"},{"question":"# Matrix Transformation Problem Implement a function called `transform_matrix(matrix, transformation)` that takes a 2D list `matrix` and a string `transformation` as input, and returns the transformed matrix based on the given transformation. The possible transformations are: - \'rotate_clockwise\': 90 degrees clockwise rotation. - \'rotate_counterclockwise\': 90 degrees counterclockwise rotation. - \'invert_top_left\': Top-left-inversion (identity operation for this problem). - \'invert_bottom_left\': 180 degrees rotation. # Function Signature ```python def transform_matrix(matrix: List[List[int]], transformation: str) -> List[List[int]]: pass ``` # Input - `matrix`: A 2D list representing an NxN matrix where all inner lists have the same length. - `transformation`: A string denoting the transformation to perform. # Output - A new 2D list representing the transformed matrix. # Constraints - `matrix` is NxN where 1 ≤ N ≤ 100. - `matrix` contains integers -1000 ≤ matrix[i][j] ≤ 1000. - `transformation` is one of [\'rotate_clockwise\', \'rotate_counterclockwise\', \'invert_top_left\', \'invert_bottom_left\']. # Examples ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9], ] assert transform_matrix(matrix, \'rotate_clockwise\') == [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] assert transform_matrix(matrix, \'rotate_counterclockwise\') == [ [3, 6, 9], [2, 5, 8], [1, 4, 7] ] assert transform_matrix(matrix, \'invert_top_left\') == [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] assert transform_matrix(matrix, \'invert_bottom_left\') == [ [9, 8, 7], [6, 5, 4], [3, 2, 1] ] ``` # Note - Ensure your function handles various edge cases, such as empty matrices, single row/column matrices, etc. - Aim for an efficient implementation.","solution":"from typing import List def transform_matrix(matrix: List[List[int]], transformation: str) -> List[List[int]]: n = len(matrix) if transformation == \'rotate_clockwise\': return [[matrix[n - j - 1][i] for j in range(n)] for i in range(n)] elif transformation == \'rotate_counterclockwise\': return [[matrix[j][n - i - 1] for j in range(n)] for i in range(n)] elif transformation == \'invert_top_left\': return matrix # No change needed elif transformation == \'invert_bottom_left\': return [row[::-1] for row in matrix[::-1]] else: raise ValueError(\\"Invalid transformation type\\")"},{"question":"# Question: You are given an integer array `arr`. Implement the function `optimized_comb_sort(arr)` that sorts the array using an improved version of the Comb Sort algorithm. In addition to the comb sort procedure, implement an optimization to check if the array is sorted after the gap is reduced to 1. If the array is already sorted, the function should terminate early. # Function Signature: ```python def optimized_comb_sort(arr: List[int]) -> List[int]: pass ``` # Input: - A list of integers `arr` with length `n` where ( 1 leq n leq 10^4 ). # Output: - Returns the sorted list of integers in non-decreasing order. # Example: ```python >>> optimized_comb_sort([5, 1, 4, 2, 8]) [1, 2, 4, 5, 8] >>> optimized_comb_sort([3, -2, -1, 0]) [-2, -1, 0, 3] ``` # Constraints: - You must use an in-place sorting algorithm. - Your implementation should have an average time complexity of O(n log n).","solution":"from typing import List def optimized_comb_sort(arr: List[int]) -> List[int]: def get_next_gap(gap): # Shrink gap by the shrink factor gap = (gap * 10) // 13 if gap < 1: return 1 return gap n = len(arr) gap = n swapped = True while gap != 1 or swapped: gap = get_next_gap(gap) swapped = False for i in range(n - gap): if arr[i] > arr[i + gap]: arr[i], arr[i + gap] = arr[i + gap], arr[i] swapped = True return arr"},{"question":"# Matrix Inversion Challenge Problem Statement You are given an n x n invertible matrix and need to write a function to compute its inverse. The matrix will only consist of integers, and you need to ensure that all edge cases are properly handled. Function Signature ```python def invert_matrix(m: List[List[int]]) -> List[List[float]]: ``` Input * `m`: a list of lists of integers representing an n x n invertible matrix where (2 leq n leq 10) Output * Returns a list of lists of floats representing the inverted matrix. Constraints 1. The input matrix `m` will always be a square matrix. 2. The matrix will only contain integers. 3. The matrix\'s determinant will always be non-zero. Example ```python invert_matrix([[2, 1], [1, 2]]) # Returns: [[0.66666667, -0.33333333], [-0.33333333, 0.66666667]] invert_matrix([[4, 3], [3, 2]]) # Returns: [[-2.0, 3.0], [3.0, -4.0]] ``` Notes * Ensure the floating-point precision is up to 8 decimal places. * Handle edge cases such as invalid input size or non-invertible matrices by returning relevant error messages or appropriate values as specified in the example code above. Performance Requirements * The algorithm should run within reasonable time limits for matrix sizes up to 10x10.","solution":"from typing import List import numpy as np def invert_matrix(m: List[List[int]]) -> List[List[float]]: Returns the inverse of the given n x n matrix. :param m: A list of lists of integers representing an n x n invertible matrix. :return: A list of lists of floats representing the inverted matrix. try: matrix = np.array(m, dtype=float) inv_matrix = np.linalg.inv(matrix) return inv_matrix.tolist() except np.linalg.LinAlgError: raise ValueError(\\"Matrix is not invertible\\")"},{"question":"# Context: The Insertion Sort algorithm is a simple and intuitive way of sorting a small array of numbers efficiently. However, it may not always be the best choice for larger datasets due to its quadratic time complexity. Understanding and implementing this algorithm will help in forming a solid base for more advanced sorting techniques. # Task: Implement the Insertion Sort algorithm to sort an array of integers. However, contrary to a usual sorting function, your task is to implement a function `custom_insertion_sort(arr: List[int], threshold: int) -> List[int]` that incorporates an optimization. If the number of elements in the array is greater than the threshold, the function should return the array as it is without sorting. Otherwise, it should sort the array using the Insertion Sort algorithm. # Function Signature: ```python def custom_insertion_sort(arr: List[int], threshold: int) -> List[int]: ``` # Input: * `arr`: A list of integers to sort. * `threshold`: An integer which determines if the array should be sorted. If the length of `arr` is greater than `threshold`, do not sort it. # Output: * Return the sorted list if its length is less than or equal to the threshold. If not, return the original list. # Constraints: 1. The array `arr` can have between 1 and 10^5 integers. 2. Each integer in the array can be between -10^6 and 10^6. 3. The threshold `0 <= threshold <= 10^5`. # Example: ```python # Example 1 arr = [3, 1, 4, 2] threshold = 3 custom_insertion_sort(arr, threshold) # Output: [3, 1, 4, 2] # Example 2 arr = [5, 3, 8, 4, 2] threshold = 6 custom_insertion_sort(arr, threshold) # Output: [2, 3, 4, 5, 8] ``` # Explanation: - In the first example, the array `[3, 1, 4, 2]` is not sorted since its length (4) is greater than the threshold (3). - In the second example, the array `[5, 3, 8, 4, 2]` is sorted since its length (5) is less than the threshold (6).","solution":"from typing import List def custom_insertion_sort(arr: List[int], threshold: int) -> List[int]: if len(arr) > threshold: return arr for i in range(1, len(arr)): key = arr[i] j = i - 1 while j >= 0 and key < arr[j]: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key return arr"},{"question":"# Coding Challenge: Enhanced Insertion Sort for Nearly Sorted Arrays Scenario You are a software developer working on the backend of a financial application that needs to sort large datasets of transaction records that are nearly sorted. A nearly sorted array is one where each element is at most \'k\' positions away from its target position in the sorted array. You have been tasked to enhance the traditional insertion sort algorithm to work more efficiently with such nearly sorted arrays. The existing insertion sort code has been provided for reference. Task Write a Python function called `enhanced_insertion_sort(arr, k)`. This function should take an array of integers `arr` and an integer `k`, and return the sorted array. The function should handle cases where the array is nearly sorted, ensuring an efficient execution. Input - `arr` (List[int]): An array of integers to be sorted. - `k` (int): The maximum distance (number of positions) any element can be from its target position in the sorted array. Output - A list of integers representing the sorted array. Constraints - `1 <= len(arr) <= 10^5` - `0 <= k <= 50` - The array may contain duplicate values. Example ```python def enhanced_insertion_sort(arr, k): pass # Example input arr = [3, 2, 1, 5, 4, 6] k = 2 # Example output print(enhanced_insertion_sort(arr, k)) # Output: [1, 2, 3, 4, 5, 6] ```","solution":"import heapq def enhanced_insertion_sort(arr, k): Sorts a nearly sorted array using a min-heap. Parameters: arr (List[int]): Nearly sorted array of integers. k (int): Maximum distance an element is from its target position. Returns: List[int]: Sorted array. heap = [] result = [] # Build an initial heap of the first k+1 elements for i in range(min(k + 1, len(arr))): heapq.heappush(heap, arr[i]) # Process the array starting from k+1 for i in range(k + 1, len(arr)): heapq.heappush(heap, arr[i]) result.append(heapq.heappop(heap)) # Extract remaining elements from the heap while heap: result.append(heapq.heappop(heap)) return result"},{"question":"# Question: Implement Cycle Sort You are required to implement the Cycle Sort algorithm. This algorithm sorts an array of integers in place, utilizing the principle of cycle decomposition to move elements to their correct positions. Function Signature ```python def cycle_sort(arr: list[int]) -> list[int]: pass ``` Input * `arr` (List[int]): List of integers to be sorted. * Length of list `N` is in the range [0, 10^5] * Each integer `arr[i]` is in the range [0, 10^6] Output * List[int]: The sorted list of integers. Constraints * You are required to sort the input list in-place. No additional list or array should be used for sorting. * The function should handle edge cases like empty lists or lists with duplicate elements. Examples ```python assert cycle_sort([3, 5, 2, 1, 4]) == [1, 2, 3, 4, 5] assert cycle_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] assert cycle_sort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5] assert cycle_sort([2, 2, 3, 1, 2]) == [1, 2, 2, 2, 3] assert cycle_sort([]) == [] ``` Performance Requirements * Your implementation should have a time complexity of O(N^2) and space complexity of O(1) to adhere to in-place sorting. Description Cycle Sort operates by finding the correct position of each element in an array and rotating elements to their correct position in cycles. The process is repeated until every cycle is sorted. This algorithm exhibits in-place sorting with constant memory usage but is not stable and has quadratic time complexity, making it inefficient for larger lists but showcasing interesting properties of cycle handling.","solution":"def cycle_sort(arr: list[int]) -> list[int]: Sorts a list of integers using Cycle Sort algorithm in place. Returns the sorted list. n = len(arr) if n <= 1: return arr for cycle_start in range(n - 1): item = arr[cycle_start] pos = cycle_start for i in range(cycle_start + 1, n): if arr[i] < item: pos += 1 if pos == cycle_start: continue while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] while pos != cycle_start: pos = cycle_start for i in range(cycle_start + 1, n): if arr[i] < item: pos += 1 while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] return arr"},{"question":"Shell Sort Enhancement Scenario Given the original implementation of the Shell Sort algorithm, you observe that its current time complexity is O(n^2). To improve this, you need to modify the algorithm to adopt a more efficient gap sequence such as the Knuth sequence (1, 4, 13, 40, ...). Task Refactor the provided Shell Sort function to use the Knuth sequence for the gap intervals to potentially reduce the time complexity and improve the sorting performance. Requirements 1. **Function Signature**: `def improved_shell_sort(arr: List[int]) -> List[int]:` 2. **Input Format**: A list of integers `arr` where `1 <= len(arr) <= 10^5` and `-10^9 <= arr[i] <= 10^9`. 3. **Output Format**: Return the sorted list of integers. 4. **Constraints**: Aim to achieve an average time complexity better than O(n^2). Example ```python # Example Input arr = [5, 2, 9, 1, 5, 6] # Example Output [1, 2, 5, 5, 6, 9] ``` Notes * Be mindful of the edge cases and ensure your algorithm handles them gracefully. * Ensure your implementation adheres to Python’s list and indexing capabilities without causing out-of-range errors.","solution":"from typing import List def improved_shell_sort(arr: List[int]) -> List[int]: This function sorts a list using the Shell sort algorithm with Knuth\'s sequence. n = len(arr) gap = 1 # Build the Knuth sequence while gap < n // 3: gap = 3 * gap + 1 # Start with the largest gap and work down to a gap of 1 while gap > 0: for i in range(gap, n): temp = arr[i] j = i while j >= gap and arr[j - gap] > temp: arr[j] = arr[j - gap] j -= gap arr[j] = temp gap //= 3 return arr"},{"question":"Problem Statement You are required to implement a function for solving the Matrix Chain Multiplication problem using dynamic programming. The objective is to find the optimal order of multiplying a given sequence of matrices such that the total number of scalar multiplications is minimized. Implement the following two functions in Python: 1. `matrix_chain_order(array)`: This function takes a list `array` where (array[i]) represents the dimensions of matrix (A_i) such that (A_i) is of dimension (array[i-1] times array[i]). It should return a table (`matrix`) that contains the minimal multiplication costs and a table (`sol`) that stores the indices for splits. 2. `print_optimal_solution(optimal_solution, i, j)`: This function takes the table `optimal_solution` from the previous function and prints the optimal order of matrix multiplications. Input Constraints - The length of `array` will be ( n + 1 ) where ( n ) is the number of matrices. - ( 2 ≤ n ≤ 100 ) - Each element in `array` will be a positive integer and ( 1 ≤ array[i] ≤ 1000 ). Output 1. Print the minimum number of multiplications needed. 2. Print the optimal order to perform the multiplications. Example ```python array = [30, 35, 15, 5, 10, 20, 25] # Expected Output # Minimum number of multiplications: 15125 # Optimal Parenthesization: ((A1 (A2 A3)) ((A4 A5) A6)) ``` Implementation You need to implement the functions as follows: ```python def matrix_chain_order(array): # Implementation as described in the provided code snippet pass def print_optimal_solution(optimal_solution, i, j): # Implementation as described in the provided code snippet pass # Testing the function if __name__ == \\"__main__\\": array = [30, 35, 15, 5, 10, 20, 25] matrix, optimal_solution = matrix_chain_order(array) print(\\"Minimum number of multiplications:\\", matrix[1][len(array) - 1]) print(\\"Optimal Parenthesization:\\", end=\\" \\") print_optimal_solution(optimal_solution, 1, len(array) - 1) print() ```","solution":"def matrix_chain_order(array): n = len(array) - 1 matrix = [[0 for _ in range(n + 1)] for _ in range(n + 1)] sol = [[0 for _ in range(n + 1)] for _ in range(n + 1)] for l in range(2, n + 1): for i in range(1, n - l + 2): j = i + l - 1 matrix[i][j] = float(\'inf\') for k in range(i, j): q = matrix[i][k] + matrix[k + 1][j] + array[i - 1] * array[k] * array[j] if q < matrix[i][j]: matrix[i][j] = q sol[i][j] = k return matrix, sol def print_optimal_solution(sol, i, j): if i == j: print(f\\"A{i}\\", end=\\"\\") else: print(\\"(\\", end=\\"\\") print_optimal_solution(sol, i, sol[i][j]) print(\\" \\", end=\\"\\") print_optimal_solution(sol, sol[i][j] + 1, j) print(\\")\\", end=\\"\\") # Testing the function if __name__ == \\"__main__\\": array = [30, 35, 15, 5, 10, 20, 25] matrix, optimal_solution = matrix_chain_order(array) print(\\"Minimum number of multiplications:\\", matrix[1][len(array) - 1]) print(\\"Optimal Parenthesization:\\", end=\\" \\") print_optimal_solution(optimal_solution, 1, len(array) - 1) print()"},{"question":"# Segment Tree Implementation Challenge Objective Implement a performant Segment Tree to handle range queries and updates on an array efficiently. You should demonstrate comprehension of data structures and algorithms by ensuring the Segment Tree handles specified operations correctly. Function Implementations 1. **`__init__(self, arr, function)`** * Initializes the Segment Tree with the given array and commutative function. * Constructs the segment tree to store precomputed values for range queries. 2. **`build_tree(self)`** * Builds the tree using the given input array and function. 3. **`update(self, p, v)`** * Updates the value at position `p` of the array to `v`. * Propagates the update through the segment tree to keep the tree valid. 4. **`query(self, l, r)`** * Performs a range query from index `l` to `r` (inclusive), using the given function. Input & Output Specifications * **Function Signatures**: ``` def __init__(self, arr: List[Union[int, Tuple[int, int], float]], function: Callable[[Any, Any], Any]) -> None: def build_tree(self) -> None: def update(self, p: int, v: Union[int, Tuple[int, int], float]) -> None: def query(self, l: int, r: int) -> Union[int, Tuple[int, int], float]: ``` * **Constraints**: * The array will have a length `N` where `1 ≤ N ≤ 10^5`. * The `function` is associative and commutative. * The updates and queries can be frequent, up to `10^4` operations. * **Example**: ```python # Example 1 segTree = SegmentTree([2, 4, 5, 3, 4], max) assert segTree.query(2, 4) == 5 segTree.update(3, 6) assert segTree.query(0, 3) == 6 # Example 2 segTree = SegmentTree([4, 5, 2, 3, 4, 43, 3], lambda a, b: a + b) assert segTree.query(0, 6) == 64 segTree.update(2, -10) assert segTree.query(0, 6) == 52 # Example 3 segTree = SegmentTree([(1, 2), (4, 6), (4, 5)], lambda a, b: (a[0] + b[0], a[1] + b[1])) assert segTree.query(0, 2) == (9, 13) segTree.update(2, (-1, 2)) assert segTree.query(0, 2) == (4, 10) ``` Write a Python function `SegmentTree` with the appropriate methods to solve the above challenge.","solution":"from typing import List, Union, Callable, Any, Tuple class SegmentTree: def __init__(self, arr: List[Union[int, Tuple[int, int], float]], function: Callable[[Any, Any], Any]) -> None: self.n = len(arr) self.function = function self.tree = [None] * (2 * self.n) self.build_tree(arr) def build_tree(self, arr: List[Union[int, Tuple[int, int], float]]) -> None: for i in range(self.n): self.tree[self.n + i] = arr[i] for i in range(self.n - 1, 0, -1): self.tree[i] = self.function(self.tree[2 * i], self.tree[2 * i + 1]) def update(self, p: int, v: Union[int, Tuple[int, int], float]) -> None: pos = p + self.n self.tree[pos] = v while pos > 1: pos //= 2 self.tree[pos] = self.function(self.tree[2 * pos], self.tree[2 * pos + 1]) def query(self, l: int, r: int) -> Union[int, Tuple[int, int], float]: res = None l += self.n r += self.n + 1 while l < r: if l % 2 == 1: res = self.tree[l] if res is None else self.function(res, self.tree[l]) l += 1 if r % 2 == 1: r -= 1 res = self.tree[r] if res is None else self.function(res, self.tree[r]) l //= 2 r //= 2 return res"},{"question":"# Question: Find the nth Digit in a Sequential Concatenation of Numbers Given a number sequence formed by concatenating all integers in ascending order (e.g., 123456789101112...), write a function `find_nth_digit(n)` that returns the nth digit in this sequence. # Function Signature ```python def find_nth_digit(n: int) -> int: ``` # Input * `n` is an integer (1 ≤ n ≤ 10^9). # Output * The function should return an integer (the nth digit in the sequence). # Constraints * The input value n can be very large, up to 10^9. * Consider all possible edge cases mentioned in the analysis part. # Example ```python # Example 1 input = 11 output = 0 # Explanation: The sequence up to the 11th digit is \\"12345678910\\", # and the 11th digit is \\"0\\". # Example 2 input = 3 output = 3 # Explanation: The sequence up to the 3rd digit is \\"123\\", and the 3rd digit is \\"3\\". # Example 3 input = 15 output = 2 # Explanation: The sequence up to the 15th digit is \\"12345678910111213\\", # and the 15th digit is \\"2\\". ``` # Testing Ensure to test the function on: 1. Small and large values of n. 2. Values of n that fall on digit length transitions, e.g., n = 9, 10, 100, etc. 3. Values of n where calculations involve large numbers to ensure no overflow or precision loss.","solution":"def find_nth_digit(n: int) -> int: # Define how many digits in numbers of lengths 1, 2, 3, etc. length = 1 # Initially considering single digit numbers (1-9) count = 9 # There are 9 single digit numbers start = 1 # Starting number for the current length is 1 # Loop to find the range in which the nth digit falls while n > length * count: n -= length * count length += 1 count *= 10 start *= 10 # Find the actual number that contains the nth digit start += (n - 1) // length # Find the nth digit and return it digit_index = (n - 1) % length return int(str(start)[digit_index])"},{"question":"# Question: Transforming a Binary Tree to a Doubly Linked List Given a binary tree, write a function `bin_tree_to_list(root)` that transforms the tree into a doubly linked list in-place. The linked list should be created using the in-order traversal of the tree. You are also provided a utility function `print_tree(root)` that prints the values of the nodes in the doubly linked list format. Function Signature ```python from tree.tree import TreeNode def bin_tree_to_list(root: TreeNode) -> TreeNode: ... ``` Input * `root`: The root node of a binary tree. Output * The function should return the head of the doubly linked list. Constraints * The number of nodes in the tree will be in the range [0, 1000]. * Each node will contain a unique value. # Example ```python # Example binary tree # 10 # / # 5 15 # / / # 2 8 11 20 root = TreeNode(10) root.left = TreeNode(5) root.right = TreeNode(15) root.left.left = TreeNode(2) root.left.right = TreeNode(8) root.right.left = TreeNode(11) root.right.right = TreeNode(20) head_of_list = bin_tree_to_list(root) print_tree(head_of_list) # Output should be the values in the order: 2, 5, 8, 10, 11, 15, 20 ``` Notes 1. The given problem uses a binary tree node class `TreeNode` which has the attributes `val`, `left`, and `right`. 2. You do not need to handle input I/O operations in your solution. 3. Ensure that all left and right pointers in the final doubly linked list are appropriately set.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def bin_tree_to_list(root): if not root: return None def inorder_traversal(node): if node is None: return inorder_traversal(node.left) nonlocal last, head if last: last.right = node node.left = last else: head = node last = node inorder_traversal(node.right) last, head = None, None inorder_traversal(root) return head def print_tree(head): while head: print(head.val, end=\\" \\") head = head.right print()"},{"question":"# Context You are working on a low-level system where it\'s crucial to understand the minimal number of changes required to transform one binary state into another. To ensure efficient operations, you need to determine how many bits need to be flipped when converting one integer to another. # Problem Statement Write a function `count_flips_to_convert(a: int, b: int) -> int` that takes two integer inputs `a` and `b`, and returns the minimal number of bit flips required to convert `a` to `b`. # Input * Two integers `a` and `b` where (0 leq a, b leq 10^9). # Output * An integer representing the minimal number of bit flips needed. # Constraints 1. Both inputs are non-negative integers. 2. Efficient time complexity is expected due to the upper limit constraints. # Example Example 1 Input: `a = 29`, `b = 15` Output: `2` Explanation: Binary representation of 29 is `11101`, and for 15 it\'s `01111`. Flipping the 1st and 3rd bits of 29 gives 15. Example 2 Input: `a = 0`, `b = 0` Output: `0` Explanation: Both integers are the same; no bits need to be flipped. # Edge Cases * Inputs where `a` is equal to `b`. * Inputs where either `a` or `b` is zero. * Maximum possible integer inputs. # Notes Ensure that your implementation runs efficiently even for large inputs.","solution":"def count_flips_to_convert(a: int, b: int) -> int: Returns the number of bit flips required to convert integer a to integer b. # XOR of a and b will highlight the differing bits xor = a ^ b # Count the number of set bits in the result count = 0 while xor: count += xor & 1 xor >>= 1 return count"},{"question":"# Question: Find the Unique Element Using Bitwise XOR Given an array of integers, where each element appears twice except for one, write a function to find that single element that appears once. Your implementation should have a linear runtime complexity and should not use extra memory. Function Signature ```python def find_unique_element(nums: List[int]) -> int: ``` # Input - A list of integers `nums` where every element appears exactly twice, except for one element which appears once. - Size of the array (n) where 1 <= n <= 10^5. # Output - The single integer that appears only once in the array. # Constraints - The array will have exactly one element that s not duplicated, while all others appear exactly twice. - The function should have a linear time complexity, O(n). - No additional space beyond the input array and a few integer variables should be used (O(1) space complexity). # Example ```python # Example 1 nums = [2, 2, 1] assert find_unique_element(nums) == 1 # Example 2 nums = [4, 1, 2, 1, 2] assert find_unique_element(nums) == 4 # Example 3 nums = [1] assert find_unique_element(nums) == 1 ``` # Explanation - In the first example, `2` appears twice while `1` appears once. The function returns `1`. - In the second example, both `2` and `1` appear twice while `4` appears once. The function returns `4`. - In the third example, the single element `1` appears. Your task is to implement the function `find_unique_element` such that it follows the above requirements and passes all given examples and edge cases.","solution":"from typing import List def find_unique_element(nums: List[int]) -> int: Finds the single element in a list where every element appears twice except for one. This solution uses the bitwise XOR operator to achieve O(n) time complexity and O(1) space complexity. unique = 0 for num in nums: unique ^= num return unique"},{"question":"# Filter Values in a Range Problem Statement You are given an array of integers and two optional boundary values, `min_lim` and `max_lim`. Implement a function called `limit(arr, min_lim, max_lim)` that filters the array to include only the values that fall within the specified range [min_lim, max_lim]. Expected Input and Output * **Input**: - `arr`: A list of integers (1 ≤ len(arr) ≤ 10^6). - `min_lim`: An integer or None, representing the lower bound. If None, it should be considered as the minimum value in the array. - `max_lim`: An integer or None, representing the upper bound. If None, it should be considered as the maximum value in the array. * **Output**: - A list of integers filtered to only include values within the specified range [min_lim, max_lim]. Constraints 1. The order of elements in the returned list must be the same as in the original array. 2. If `min_lim` > `max_lim`, return an empty list. 3. If both `min_lim` and `max_lim` are None, the function should return the original array. Performance Requirements The algorithm should run in O(n) time complexity. Examples ```python # Example 1 arr = [1, 2, 3, 4, 5] min_lim = None max_lim = 3 # The function should return [1, 2, 3] # Example 2 arr = [10, 20, 30, 40, 50] min_lim = 20 max_lim = None # The function should return [20, 30, 40, 50] # Example 3 arr = [] min_lim = 10 max_lim = 20 # The function should return [] # Example 4 arr = [1, 2, 3, 4, 5] min_lim = 3 max_lim = 1 # The function should return [] ```","solution":"def limit(arr, min_lim, max_lim): Filters the array to include only the values within the range [min_lim, max_lim] :param arr: List of integers :param min_lim: Integer or None, lower boundary of the range :param max_lim: Integer or None, upper boundary of the range :return: List of integers within the specified range if min_lim is None: min_lim = min(arr, default=None) if max_lim is None: max_lim = max(arr, default=None) if min_lim is None or max_lim is None or min_lim > max_lim: return [] return [x for x in arr if min_lim <= x <= max_lim]"},{"question":"# Queue Operation Extended - Priority Queue Implementation You have been given the basic implementation of a Queue Abstract Data Type (ADT) with two implementations: `ArrayQueue` and `LinkedListQueue`. However, a standard Queue does not consider the priority of elements when processing them. Your task is to extend the functionality by implementing a **PriorityQueue** that operates similarly, but processes elements based on their priority where the element with the highest priority is dequeued first. The priority queue should have the following operations: * **enqueue(value, priority)**: Adds a new item with its associated priority to the queue. * **dequeue()**: Removes and returns the item with the highest priority from the queue. * **peek()**: Returns the item with the highest priority without removing it. * **is_empty()**: Tests if the queue is empty. * **size()**: Returns the number of items in the queue. # Specifications 1. **Input/Output Format**: - `enqueue(value, priority)`: - **Input**: `value` (any type), `priority` (integer) - **Output**: None - `dequeue()`: - **Input**: None - **Output**: `value` (item with the highest priority) - `peek()`: - **Input**: None - **Output**: `value` (item with the highest priority) - `is_empty()`: - **Input**: None - **Output**: `bool` (True if the queue is empty, else False) - `size()`: - **Input**: None - **Output**: `int` (number of items in the queue) 2. **Constraints**: - Items with the same priority should be processed in the order they were added to the queue. - Implement at least one efficient solution (Time Complexity: O(log n) for enqueue and O(log n) for dequeue) using a data structure such as a heap. # Example Usage: ```python pq = PriorityQueue() pq.enqueue(\'task1\', 1) pq.enqueue(\'task2\', 3) pq.enqueue(\'task3\', 2) assert pq.dequeue() == \'task2\' assert pq.peek() == \'task3\' assert pq.dequeue() == \'task3\' assert pq.dequeue() == \'task1\' assert pq.is_empty() == True assert pq.size() == 0 ``` Implement the `PriorityQueue` class to meet the above requirements.","solution":"import heapq class PriorityQueue: def __init__(self): self._heap = [] self._index = 0 # This will keep track of the order items were added for tiebreaking purposes def enqueue(self, value, priority): Adds a new item along with its priority to the priority queue. heapq.heappush(self._heap, (-priority, self._index, value)) self._index += 1 def dequeue(self): Removes and returns the item with the highest priority. if self.is_empty(): raise IndexError(\\"dequeue from an empty priority queue\\") return heapq.heappop(self._heap)[-1] def peek(self): Returns the item with the highest priority without removing it. if self.is_empty(): raise IndexError(\\"peek from an empty priority queue\\") return self._heap[0][-1] def is_empty(self): Checks if the priority queue is empty. return len(self._heap) == 0 def size(self): Returns the number of items in the priority queue. return len(self._heap)"},{"question":"You are tasked with developing a comprehensive utility that leverages fundamental algorithms like the Euclidean method for GCD, incorporates bitwise operations for efficient computation, and counts trailing zeros in binary numbers to facilitate various number theoretical operations. This utility will contain three main functions that you need to define: 1. **`compute_gcd(a, b)`**: * Compute the greatest common divisor (GCD) of two integers using the Euclidean algorithm. * **Input**: Two integers `a` and `b` where `a, b != 0`. * **Output**: An integer which is the GCD of `a` and `b`. * **Constraints**: Inputs must be non-zero integers. 2. **`compute_lcm(a, b)`**: * Compute the least common multiple (LCM) of two integers. * **Input**: Two integers `a` and `b` (both non-zero). * **Output**: An integer which is the LCM of `a` and `b`. * **Constraints**: Inputs must be non-zero integers. 3. **`count_trailing_zeros(x)`**: * Compute the number of trailing zeros in the binary representation of a positive integer. * **Input**: A positive integer `x`. * **Output**: An integer representing the count of trailing zeros in `x`. * **Constraints**: Input must be a positive integer. # Requirements 1. Function prototypes should be as follows: ```python def compute_gcd(a, b): # Your implementation here def compute_lcm(a, b): # Your implementation here def count_trailing_zeros(x): # Your implementation here ``` 2. Ensure each function handles edge cases and invalid input gracefully where applicable. 3. Efficiency is paramount; aim for the optimal solution in terms of time and space complexity. # Examples ```python compute_gcd(48, 18) -> 6 compute_lcm(4, 5) -> 20 count_trailing_zeros(8) -> 3 ``` # Performance Your solution should be performant for large inputs up to approximately 10^12 (for GCD and LCM).","solution":"def compute_gcd(a, b): Compute the GCD of two integers using the Euclidean algorithm. while b: a, b = b, a % b return a def compute_lcm(a, b): Compute the LCM of two integers. return abs(a * b) // compute_gcd(a, b) def count_trailing_zeros(x): Compute the number of trailing zeros in the binary representation of a positive integer. count = 0 while x & 1 == 0: count += 1 x >>= 1 return count"},{"question":"# Coding Challenge: Advanced Run-Length Encoding with Position Tracking Context Run-length encoding (RLE) is a fundamental data compression algorithm that reduces the size of runs of repeated data. You have implemented basic RLE encoding and decoding algorithms. Now, you need to tackle a more complex scenario that involves tracking the positions of each run of data in the original input. Problem Write a Python function `compress_with_positions` that takes an input string and compresses it using run-length encoding (RLE) along with the starting positions of each run in the original string. Your output should be a list of tuples where each tuple contains: 1. The count of characters. 2. The character itself. 3. The starting position of that run in the original string. Additionally, write a function `decompress_with_positions` that takes the output from your `compress_with_positions` function and reconstructs the original string. Function Signatures ```python def compress_with_positions(input: str) -> list: pass def decompress_with_positions(encoded: list) -> str: pass ``` Input Format * `compress_with_positions(input: str) -> list`: * `input`: A non-empty string consisting of any printable ASCII characters. * `decompress_with_positions(encoded: list) -> str`: * `encoded`: A list of tuples where each tuple contains an integer count, a character, and an integer starting position. This input is guaranteed to be the output of a valid `compress_with_positions` function. Output Format * `compress_with_positions`: Returns a list of tuples where each tuple has the format `(count, character, start_position)`. * `decompress_with_positions`: Returns the original string reconstructed from the encoded list. Example ```python # Example for compress_with_positions input_string = \\"aaabbccccdd\\" compressed = compress_with_positions(input_string) print(compressed) # Expected output: [(3, \'a\', 0), (2, \'b\', 3), (4, \'c\', 5), (2, \'d\', 9)] # Example for decompress_with_positions compressed_list = [(3, \'a\', 0), (2, \'b\', 3), (4, \'c\', 5), (2, \'d\', 9)] decompressed = decompress_with_positions(compressed_list) print(decompressed) # Expected output: \\"aaabbccccdd\\" ``` Constraints * You may assume that the input string for compression has a length of at most (10^5). * The output list from `compress_with_positions` will have a length of at most (10^5 / 2). Performance Requirements * Aim for a time complexity of (O(n)) for both compression and decompression, where (n) is the length of the input string.","solution":"def compress_with_positions(input: str) -> list: Compresses the input string using run-length encoding with position tracking. Args: - input (str): The input string to compress. Returns: - list: A list of tuples (count, character, start_position). if not input: return [] compressed = [] count = 1 char = input[0] start_position = 0 for i in range(1, len(input)): if input[i] == char: count += 1 else: compressed.append((count, char, start_position)) char = input[i] count = 1 start_position = i # Append the last run compressed.append((count, char, start_position)) return compressed def decompress_with_positions(encoded: list) -> str: Decompresses the encoded list back to the original string. Args: - encoded (list): The list of tuples (count, character, start_position). Returns: - str: The decompressed original string. decompressed = [] for count, char, start_position in encoded: decompressed.append(char * count) return \'\'.join(decompressed)"},{"question":"**Matrix Transformation Challenge** **Context**: In the realm of computer graphics and data visualization, matrix transformations such as rotations and inversions play a crucial role. Understanding how these transformations work is fundamental for manipulating and correctly rendering graphical objects and datasets. In this exercise, you\'ll implement multiple matrix transformation functions. **Task**: Write Python functions that perform transformations on a square matrix (2D list). Specifically, implement the following functions: 1. `rotate_clockwise(matrix)`: Rotate the matrix 90 degrees clockwise. 2. `rotate_counterclockwise(matrix)`: Rotate the matrix 90 degrees counterclockwise. 3. `top_left_invert(matrix)`: Invert the matrix elements along the top-left to bottom-right diagonal. 4. `bottom_left_invert(matrix)`: Invert the matrix elements along the bottom-left to top-right diagonal. **Input**: - A matrix represented by a 2D list of integers. For simplicity, assume it is always a non-empty square matrix (n x n). **Output**: - Each function should return a new matrix that represents the transformed input matrix. **Constraints**: - 1 ≤ n ≤ 1000 (where n is the dimension of the matrix) **Example**: ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] print(rotate_clockwise(matrix)) # Output: # [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] print(rotate_counterclockwise(matrix)) # Output: # [ # [3, 6, 9], # [2, 5, 8], # [1, 4, 7] # ] print(top_left_invert(matrix)) # Output: # [ # [1, 4, 7], # [2, 5, 8], # [3, 6, 9] # ] print(bottom_left_invert(matrix)) # Output: # [ # [9, 6, 3], # [8, 5, 2], # [7, 4, 1] # ] ``` Write your functions below: ```python def rotate_clockwise(matrix): # Your code here pass def rotate_counterclockwise(matrix): # Your code here pass def top_left_invert(matrix): # Your code here pass def bottom_left_invert(matrix): # Your code here pass ``` **Performance Requirements**: - Solutions should have a time complexity of O(n^2) and should not use excessive additional space. **Edge Cases to Consider**: - Single element matrices should be correctly handled. - The matrix transformations should be correctly performed as per the examples provided, maintaining the integrity of matrix dimensions and indices.","solution":"def rotate_clockwise(matrix): n = len(matrix) return [[matrix[n - j - 1][i] for j in range(n)] for i in range(n)] def rotate_counterclockwise(matrix): n = len(matrix) return [[matrix[j][n - i - 1] for j in range(n)] for i in range(n)] def top_left_invert(matrix): n = len(matrix) result = [row[:] for row in matrix] # To copy the matrix for i in range(n): for j in range(i + 1, n): result[i][j], result[j][i] = result[j][i], result[i][j] return result def bottom_left_invert(matrix): n = len(matrix) result = [row[:] for row in matrix] # To copy the matrix for i in range(n): for j in range(n - i - 1): result[i][j], result[n - j - 1][n - i - 1] = result[n - j - 1][n - i - 1], result[i][j] return result"},{"question":"# Scenario Alex is dealing with a large dataset containing daily temperatures for the past several years. He wants to perform various range queries and updates on this dataset efficiently. # Objective Develop a data structure that allows Alex to compute the maximum temperature in any given range and to update the temperature in a specific day quickly. # Task Description Implement a class `MaxTemperature`, which leverages the segment tree data structure to allow efficient range queries and updates for the maximum temperature. # Requirements 1. **Initialization**: The class should be initialized with a list of daily temperatures. 2. **Range Query**: A method `range_max(l, r)` to get the maximum temperature between days `l` and `r` inclusive. 3. **Update**: A method `update(day, temperature)` to update the temperature of a specific day. # Input and Output Formats - **Initialization**: `MaxTemperature(temperatures: List[int])` - `temperatures`: List of integers representing daily temperatures. - **Range Query**: `range_max(l: int, r: int) -> int` - `l`: Start day of the query (0-indexed). - `r`: End day of the query (0-indexed). - Returns an integer representing the maximum temperature in the range `[l, r]`. - **Update**: `update(day: int, temperature: int) -> None` - `day`: The specific day to update the temperature. - `temperature`: The new temperature value. # Constraints - 1 ≤ len(temperatures) ≤ 10^5 - -100 ≤ temperatures[i] ≤ 100 - 0 ≤ l ≤ r < len(temperatures) - 0 ≤ day < len(temperatures) # Example ```python # Initialize with daily temperatures temps = MaxTemperature([21, 23, 20, 22, 25, 24, 23]) # Query for the maximum temperature from day 2 to day 5 result = temps.range_max(2, 5) print(result) # Output should be 25 # Update the temperature on day 3 to be 27 temps.update(3, 27) # Query again to check the new maximum temperature from day 2 to day 5 result = temps.range_max(2, 5) print(result) # Output should be 27 ``` # Note - Ensure the implementation is efficient and handles large datasets within the acceptable time limits. - Pay attention to edge cases such as single-element arrays and queries that span the entire range of temperatures.","solution":"class MaxTemperature: def __init__(self, temperatures): self.n = len(temperatures) self.tree = [0] * (2 * self.n) for i in range(self.n): self.tree[self.n + i] = temperatures[i] for i in range(self.n - 1, 0, -1): self.tree[i] = max(self.tree[2 * i], self.tree[2 * i + 1]) def range_max(self, l, r): l += self.n r += self.n + 1 maximum = float(\'-inf\') while l < r: if l % 2 == 1: maximum = max(maximum, self.tree[l]) l += 1 if r % 2 == 1: r -= 1 maximum = max(maximum, self.tree[r]) l //= 2 r //= 2 return maximum def update(self, day, temperature): pos = day + self.n self.tree[pos] = temperature while pos > 1: pos //= 2 self.tree[pos] = max(self.tree[2 * pos], self.tree[2 * pos + 1])"},{"question":"Question You are provided with classes to represent a directed graph using nodes and edges. Your task is to implement a function that finds all paths from a given source node to a target node in the directed graph. # Function Signature ```python def find_all_paths(graph: DirectedGraph, start: str, end: str) -> List[List[str]]: pass ``` # Input - `graph` (DirectedGraph): An instance of the DirectedGraph class representing the graph. - `start` (str): The name of the start node. - `end` (str): The name of the end node. # Output - Returns a list of paths, where each path is represented as a list of node names (strings) in the order from start to end. # Constraints - Assume that the nodes `start` and `end` exist in the graph. - The graph may have cycles. # Example ```python graph_dict = { \'A\': [\'B\', \'C\'], \'B\': [\'C\', \'D\'], \'C\': [\'D\'], \'D\': [\'C\'], \'E\': [\'F\'], \'F\': [\'C\'] } directed_graph = DirectedGraph(graph_dict) print(find_all_paths(directed_graph, \'A\', \'D\')) # Expected output: # [ # [\'A\', \'B\', \'D\'], # [\'A\', \'B\', \'C\', \'D\'], # [\'A\', \'C\', \'D\'] # ] ``` # Notes * Consider paths that visit the same node multiple times as valid unless otherwise specified. * Efficiency matters: ensure that your solution can handle the graph\'s size and cycles effectively.","solution":"from typing import List, Dict class DirectedGraph: def __init__(self, graph_dict: Dict[str, List[str]]): self.graph = graph_dict def find_all_paths(graph: DirectedGraph, start: str, end: str) -> List[List[str]]: def dfs(node, path): path.append(node) if node == end: paths.append(list(path)) else: for neighbor in graph.graph.get(node, []): dfs(neighbor, path) path.pop() paths = [] dfs(start, []) return paths"},{"question":"You are tasked to implement a recursive sorting algorithm called Stooge Sort. This algorithm sorts an array by recursively sorting different segments of the array until the entire array is sorted. Given an array of integers, implement the Stooge Sort algorithm to sort the array in non-decreasing order. **Function Signature**: `def stooge_sort(arr: List[int], l: int, h: int) -> None` # Input - `arr`: A list of integers `arr` where `1 <= len(arr) <= 20`. - `l`: An integer, representing the starting index of the array segment to be sorted. - `h`: An integer, representing the ending index of the array segment to be sorted. # Output - This function should modify the list `arr` in place, sorting the elements between indices `l` and `h`. # Constraints - The function must modify the array in place and rely on recursive calls. - Performance requirements are not stringent due to the small size of the array (max length 20). # Example ```python arr = [5, 4, 3, 2, 1] stooge_sort(arr, 0, len(arr)-1) print(arr) # Output: [1, 2, 3, 4, 5] ``` # Notes - Your implementation should ensure that the entire array is sorted according to Stooge Sort\'s principles. - Consider edge cases like an already sorted array and arrays with duplicate elements. - Analyze the provided steps thoroughly before coding your solution.","solution":"from typing import List def stooge_sort(arr: List[int], l: int, h: int) -> None: if l >= h: return if arr[l] > arr[h]: arr[l], arr[h] = arr[h], arr[l] if h - l + 1 > 2: t = (h - l + 1) // 3 stooge_sort(arr, l, h - t) stooge_sort(arr, l + t, h) stooge_sort(arr, l, h - t)"},{"question":"Imagine you are working on a system to enforce limitations on user activity based on predefined quotas. You are tasked with ensuring that an array of user actions does not exceed a given number of occurrences for any specific action. Function Objective Create a function `enforce_quota` that takes in a list of actions and an integer quota, and returns a new list that contains each action at most `quota` times, preserving the original order of actions. Input and Output Formats **Input**: - `actions` (list of str): A list of user actions where each action is represented by a string. - `quota` (int): The maximum number of times any specific action can appear in the output list. **Output**: - Returns a list of user actions where each action appears at most `quota` times, in the order they first appeared in the input list. Constraints - You can assume `actions` has at most (10^5) elements. - Each action is a string with a maximum length of 100 characters. - `quota` is a positive integer no greater than (10^4). Performance Requirements - Your solution should have a time complexity of (O(n)). Example **Examples 1** ```python actions = [\\"login\\", \\"click\\", \\"login\\", \\"scroll\\", \\"click\\", \\"login\\", \\"click\\", \\"scroll\\", \\"logout\\"] quota = 2 ``` **Expected Output** ```python [\\"login\\", \\"click\\", \\"login\\", \\"scroll\\", \\"click\\", \\"scroll\\", \\"logout\\"] ``` - The actions \\"login\\" and \\"click\\" appear more than 2 times initially, but the output limits each to 2 occurrences. **Example 2:** ```python actions = [\\"register\\", \\"register\\", \\"register\\"] quota = 1 ``` **Expected Output** ```python [\\"register\\"] ``` - The action \\"register\\" appears more than once, but the output limits it to 1 occurrence. Note: - Ensure your implementation handles edge cases effectively, such as an empty list or a quota that exceeds the number of action occurrences. ```python def enforce_quota(actions, quota): # Your implementation here pass ``` Begin implementing the function `enforce_quota` to pass the provided examples and meet the performance constraints.","solution":"def enforce_quota(actions, quota): Returns a new list where each action appears at most quota times. from collections import defaultdict action_count = defaultdict(int) result = [] for action in actions: if action_count[action] < quota: result.append(action) action_count[action] += 1 return result"},{"question":"You are tasked with writing a more memory-efficient and optimized version of an algorithm that generates all combinations of well-formed parentheses given `n` pairs of parentheses. # Function Signature ```python def generate_optimized_parenthesis(n: int) -> List[str]: Generates all combinations of well-formed parentheses for n pairs. Parameters: n (int): the number of pairs of parentheses. Returns: List[str]: a list with all combinations of well-formed parentheses. ``` # Input * An integer `n` where 0 <= n <= 8, representing the number of pairs of parentheses. # Output * A list of strings where each string represents a valid combination of well-formed parentheses. # Constraints * The function should be optimized for both time and space, minimizing unnecessary computations. * The list of strings should contain unique permutations of well-formed parentheses. # Example 1. Input: `n = 3` Output: ```python [\\"((()))\\", \\"(()())\\", \\"(())()\\", \\"()(())\\", \\"()()()\\"] ``` 2. Input: `n = 1` Output: ```python [\\"()\\"] ``` # Performance Requirements * Ensure that the solution is within the provided constraints, especially for upper limits (n = 8). * The solution should efficiently manage memory usage and avoid excessive recursion depth where possible. # Scenario Consider a situation where you are developing a compiler. As part of the syntax validation process, you need to generate all possible valid parentheses combinations to match and validate the syntax structure of code blocks, function calls, etc. Write a function that can generate these valid combinations efficiently.","solution":"from typing import List def generate_optimized_parenthesis(n: int) -> List[str]: Generates all combinations of well-formed parentheses for n pairs. Parameters: n (int): the number of pairs of parentheses. Returns: List[str]: a list with all combinations of well-formed parentheses. result = [] def backtrack(s=\'\', left=0, right=0): if len(s) == 2 * n: result.append(s) return if left < n: backtrack(s + \'(\', left + 1, right) if right < left: backtrack(s + \')\', left, right + 1) backtrack() return result"},{"question":"Implement a function `find_last_occurrence(arr: List[int], target: int) -> int` that takes a sorted list of integers `arr` and an integer `target`, and returns the index of the last occurrence of `target` in `arr`. If `target` is not found in the array, the function should return -1. # Input * A sorted list of integers `arr` (1 ≤ len(arr) ≤ 10^5) * An integer `target` (−10^9 ≤ target ≤ 10^9) # Output * An integer denoting the index of the last occurrence of `target` in `arr`. # Constraints * The input list `arr` is guaranteed to be sorted in increasing order. * Use binary search to achieve O(log n) time complexity. # Examples ```python assert find_last_occurrence([1, 2, 2, 2, 3], 2) == 3 assert find_last_occurrence([1, 1, 1, 1, 1], 1) == 4 assert find_last_occurrence([1, 2, 3, 4, 5], 6) == -1 ``` # Explanation * In the first example, the last occurrence of `2` in the array `[1, 2, 2, 2, 3]` is at index `3`. * In the second example, the number `1` is repeated throughout the array and its last occurrence is at index `4`. * In the third example, `6` does not exist in the array, so the output is `-1`.","solution":"from typing import List def find_last_occurrence(arr: List[int], target: int) -> int: Returns the index of the last occurrence of target in arr. If target is not found, returns -1. Args: arr (List[int]): A list of sorted integers. target (int): The integer to find in the list. Returns: int: The index of the last occurrence of target in arr, or -1 if not found. low, high = 0, len(arr) - 1 result = -1 while low <= high: mid = (low + high) // 2 if arr[mid] == target: result = mid low = mid + 1 # Continue searching in the right half elif arr[mid] < target: low = mid + 1 else: high = mid - 1 return result"},{"question":"**Problem Description:** You are given a stack where the elements are stored in the traditional manner (LIFO - Last In, First Out). Implement a function that duplicates every element in the stack such that each element appears twice consecutively. **Function Specifications**: You are required to complete the function `def stutter(stack: list) -> list`. The function should take a list `stack` that uses the last element as the \'top\' of the stack and return the modified stack with duplicated elements. **Input**: - A list, `stack` (0 <= len(stack) <= 10^4), where each integer represents an element in the stack. The bottom of the stack is the start of the list and the top is the end. **Output**: - The modified stack as a list where each element is duplicated. **Example**: ```python stack = [3, 7, 1, 14, 9] print(stutter(stack)) # Output: [3, 3, 7, 7, 1, 1, 14, 14, 9, 9] stack = [] print(stutter(stack)) # Output: [] stack = [5] print(stutter(stack)) # Output: [5, 5] ``` **Constraints**: - You should use either an additional stack or queue as auxiliary storage. - Aim to keep your solution within O(n) time complexity and O(n) space complexity. **Note**: Do not use any built-in functions for stack operations (which are `list.append` for push and `list.pop` for pop). Instead, manually manipulate the list to achieve the required behavior. This is to assess your understanding of fundamental stack operations.","solution":"def stutter(stack): Duplicates each element in the stack such that each element appears twice consecutively. Parameters: stack (list): The input stack represented as a list. Returns: list: The modified stack with each element duplicated. auxiliary_stack = [] # Transfer elements from the original stack to the auxiliary stack (to reverse order) while stack: auxiliary_stack.append(stack.pop()) # Transfer elements back to the original stack, duplicating each element while auxiliary_stack: element = auxiliary_stack.pop() stack.append(element) stack.append(element) return stack"},{"question":"# Question: Extended Insertion Search Using Binary Search Using the given binary search helper function, `search_insert`, write a function `insert_and_search` that first ensures the array is sorted, inserts a new value into the array in the correct position, and then searches for another given target value using the `search_insert` function. Function Signature ```python def insert_and_search(array: List[int], insert_val: int, search_val: int) -> int: ``` Input * `array` (List[int]): A list of integers. * `insert_val` (int): A value to be inserted into the list. * `search_val` (int): A value to be searched for in the list. Output * Returns the index where `search_val` is located or where it would be if inserted. Constraints * `array` will have at most 10^5 elements. * Elements in `array` can be negative or positive integers. * Your implementation must operate within O(log n) for the search operation and O(n) for the sorting if required. Example ```python insert_and_search([3, 5, 7, 9], 6, 8) ``` - Step 1: Insert 6 into the sorted array: [3, 5, 6, 7, 9] - Step 2: Search for 8, which would be at index 4 Output: `4` Explanation The function should ensure the list is sorted after insertion, then use the `search_insert` function to determine where `search_val` would fit into this sorted array. If `array` is already sorted and `insert_val` is inserted correctly, binary search can be directly applied.","solution":"from typing import List def search_insert(array: List[int], target: int) -> int: A helper function that performs binary search to find the target or the insertion index. left, right = 0, len(array) - 1 while left <= right: mid = (left + right) // 2 if array[mid] == target: return mid elif array[mid] < target: left = mid + 1 else: right = mid - 1 return left def insert_and_search(array: List[int], insert_val: int, search_val: int) -> int: Inserts a new value into the sorted array in the correct position, and then searches for another target value using binary search. # Insert the value in the correct position array.append(insert_val) array.sort() # Since sorting in this way is effectively O(n log n) which includes insertion as well # Search for the search_val using search_insert function return search_insert(array, search_val)"},{"question":"**Finding the Nth Digit in Numerical Sequence** You are given a problem to find the nth digit in an infinite sequence of digits formed by concatenating the positive integers in ascending order. The sequence starts as \'123456789101112131415...\' Write a function `find_nth_digit(n)` to find the nth digit of this sequence. # Function Signature ```python def find_nth_digit(n: int) -> int: ``` # Input * An integer `n` (1 <= n <= 2^31 - 1) denoting the position in the sequence. # Output * Returns the integer digit at the nth position in the sequence. # Constraints * Efficiently determine the digit without constructing the entire sequence. * Consider edge cases and rounding issues during the computation. # Example ```python assert find_nth_digit(1) == 1 assert find_nth_digit(10) == 1 assert find_nth_digit(11) == 0 assert find_nth_digit(15) == 2 assert find_nth_digit(1000) == 3 ``` # Notes 1. The algorithm should handle values of n efficiently, even for large inputs. 2. Document your code appropriately to reflect your implementation logic. 3. Ensure the precision and correctness of the result, especially near the boundaries of digit group transitions.","solution":"def find_nth_digit(n: int) -> int: # Initial variable setup digit_length = 1 count = 9 start = 1 # Find the range in which the nth digit falls while n > digit_length * count: n -= digit_length * count digit_length += 1 count *= 10 start *= 10 # Identify the exact number that contains the nth digit num = start + (n - 1) // digit_length # Find the specific digit in the number digit_index = (n - 1) % digit_length return int(str(num)[digit_index])"},{"question":"# Scenario You are tasked with developing a job scheduler that always executes the task with the highest priority first. To achieve this, you need to implement a min binary heap to manage the dynamic set of tasks prioritized by their urgency levels (smaller number means higher priority). # Task Implement a min binary heap with the following functionalities: 1. `insert(val)`: Inserts a task with priority `val`. 2. `remove_min()`: Removes and returns the highest priority task (smallest value). **Function Signatures**: ```python class MinBinaryHeap: def __init__(self): # Initializes an empty min binary heap. def insert(self, val: int): # Inserts the value into the heap. def remove_min(self) -> int: # Removes and returns the minimum value from the heap. ``` # Expected Input and Output Formats ```python # Example: heap = MinBinaryHeap() heap.insert(10) heap.insert(15) heap.insert(5) heap.insert(7) print(heap.remove_min()) # Output: 5 print(heap.remove_min()) # Output: 7 print(heap.remove_min()) # Output: 10 print(heap.remove_min()) # Output: 15 ``` # Constraints: - You can assume a maximum of 10^5 insert/remove operations. - Task priorities are strictly positive integers. # Performance Requirements: - Ensure that both `insert` and `remove_min` operations have a time complexity of O(log N).","solution":"class MinBinaryHeap: def __init__(self): self.heap = [] def _heapify_up(self, index): parent_index = (index - 1) // 2 if index > 0 and self.heap[parent_index] > self.heap[index]: # Swap the elements self.heap[parent_index], self.heap[index] = self.heap[index], self.heap[parent_index] # Recursively heapify the parent self._heapify_up(parent_index) def _heapify_down(self, index): smallest = index left_child_index = 2 * index + 1 right_child_index = 2 * index + 2 if left_child_index < len(self.heap) and self.heap[left_child_index] < self.heap[smallest]: smallest = left_child_index if right_child_index < len(self.heap) and self.heap[right_child_index] < self.heap[smallest]: smallest = right_child_index if smallest != index: # Swap the elements self.heap[smallest], self.heap[index] = self.heap[index], self.heap[smallest] # Recursively heapify the affected sub-tree self._heapify_down(smallest) def insert(self, val): self.heap.append(val) self._heapify_up(len(self.heap) - 1) def remove_min(self) -> int: if len(self.heap) == 0: raise IndexError(\\"remove_min(): empty heap\\") if len(self.heap) == 1: return self.heap.pop() # Swap the root with the last element root = self.heap[0] self.heap[0] = self.heap.pop() # Heapify down the new root element self._heapify_down(0) return root"},{"question":"Interpolation Search Optimization Scenario You are a software developer working in an e-commerce company where you need to implement a search function to quickly find product prices within a large dataset of sorted prices. While the existing implementation works fine, you notice that the algorithm could be optimized for some special cases. Task Your task is to enhance the interpolation search function for better handling of some performance concerns mentioned in the analysis—particularly addressing the edge cases and potential division by zero error. Specifications 1. Implement a function `optimized_interpolation_search` that enhances the existing search function by considering edge cases and optimizing for them. 2. Ensure the function: - Handles empty and single-element arrays. - Avoids division by zero issue when `array[low] == array[high]`. - Returns the correct index of the search key if found, else returns -1. Input Format - A sorted list of integers `array` with length `n` (0 ≤ n ≤ 10^6). - An integer `search_key` to be searched within the list. Output Format - An integer representing the index of `search_key` if found, otherwise -1. Performance Requirements - The algorithm should aim to keep time complexity as O(log log n) where possible. - The space complexity must remain O(1). Example ```python def optimized_interpolation_search(array: List[int], search_key: int) -> int: # Your implementation here # Examples print(optimized_interpolation_search([-25, -12, -1, 10, 12, 15, 20, 41, 55], -1)) # Output: 2 print(optimized_interpolation_search([5, 10, 12, 14, 17, 20, 21], 55)) # Output: -1 print(optimized_interpolation_search([5, 10, 12, 14, 17, 20, 21], -5)) # Output: -1 print(optimized_interpolation_search([], 10)) # Output: -1 print(optimized_interpolation_search([7], 7)) # Output: 0 print(optimized_interpolation_search([7], 1)) # Output: -1 ``` **Pro tip**: Pay special attention to handling extreme edge cases and optimize as much as possible to avoid unnecessary calculations.","solution":"from typing import List def optimized_interpolation_search(array: List[int], search_key: int) -> int: Enhanced interpolation search to handle edge cases and optimize performance. if not array: return -1 low, high = 0, len(array) - 1 while low <= high and array[low] <= search_key <= array[high]: # Prevent division by zero if array[low] == array[high] if array[low] == array[high]: if array[low] == search_key: return low else: return -1 # Calculate the probe position using the interpolation formula pos = low + ((high - low) // (array[high] - array[low])) * (search_key - array[low]) # Condition for the remaining elements if pos < 0 or pos >= len(array): return -1 # Check if search_key is found if array[pos] == search_key: return pos # If search_key is larger, search in the upper part if array[pos] < search_key: low = pos + 1 # If search_key is smaller, search in the lower part else: high = pos - 1 return -1"},{"question":"# Scenario You are part of a team designing a navigational software for a new city-wide autonomous public transport system. As part of the system, the software must efficiently compute the shortest path between any two given points (stations) in the city. The city map is modeled as a directed graph where vertices represent the stations and edges represent the routes with given travel times. # Task Your task is to implement a function that, given a city map represented as an adjacency matrix and a starting station, computes the shortest travel time from the starting station to all other stations in the city using Dijkstra\'s algorithm. # Function Signature ```python def shortest_path_from_station(vertex_count: int, graph: List[List[int]], start_station: int) -> List[int]: pass ``` # Input * `vertex_count` (int): The number of stations (nodes). * `graph` (List[List[int]]): A `vertex_count x vertex_count` adjacency matrix representing the travel times between stations. `graph[i][j]` is the travel time from station `i` to station `j`. If there is no direct route from `i` to `j`, `graph[i][j]` is 0. * `start_station` (int): The starting station index. # Output * (List[int]): A list of integers where the i-th element is the shortest travel time from the `start_station` to the i-th station. If a station is unreachable, the travel time should be `float(\'inf\')`. # Constraints * 1 ≤ `vertex_count` ≤ 1000 * 0 ≤ `graph[i][j]` ≤ 1000, where `graph[i][i]` = 0 * 0 ≤ `start_station` < `vertex_count` # Performance Requirements * The solution should be efficient given the constraints. # Example ```python vertex_count = 5 graph = [ [0, 10, 0, 30, 100], [10, 0, 50, 0, 0], [0, 50, 0, 20, 10], [30, 0, 20, 0, 60], [100, 0, 10, 60, 0] ] start_station = 0 print(shortest_path_from_station(vertex_count, graph, start_station)) # Output: [0, 10, 50, 30, 60] ```","solution":"import heapq from typing import List def shortest_path_from_station(vertex_count: int, graph: List[List[int]], start_station: int) -> List[int]: Computes the shortest travel time from the start_station to all other stations. # Initialize distances with infinity distances = [float(\'inf\')] * vertex_count distances[start_station] = 0 # Priority queue to process nodes priority_queue = [(0, start_station)] while priority_queue: current_distance, current_station = heapq.heappop(priority_queue) # If the distance is greater than the recorded shortest distance, continue if current_distance > distances[current_station]: continue # Update distances for each neighboring station for adjacent_station in range(vertex_count): if graph[current_station][adjacent_station] != 0: # There is a route distance = graph[current_station][adjacent_station] new_distance = current_distance + distance if new_distance < distances[adjacent_station]: distances[adjacent_station] = new_distance heapq.heappush(priority_queue, (new_distance, adjacent_station)) return distances"},{"question":"# Cosine Similarity Calculation Context: You are developing a recommendation system for a content-sharing platform. To suggest relevant content to users, you need to measure the similarity between their activity vectors. The cosine similarity metric is suitable for this purpose as it measures the cosine of the angle between two vectors, which represents their similarity. You must implement this similarity measure efficiently. Task: Write a function to calculate the cosine similarity between two equal-length vectors. Function Signature: ```python def cosine_similarity(vec1: List[float], vec2: List[float]) -> float: ``` Input: * `vec1` - A list of floating-point numbers representing the first vector. * `vec2` - A list of floating-point numbers representing the second vector. Both lists will have the same length, and each list will have at least one element. Output: * A single floating-point number representing the cosine similarity between the two vectors. Constraints: * The vectors must be non-empty and of equal length. Performance Requirements: * The solution should be optimized for both time and space, with a time complexity of ( O(n) ) and space complexity of ( O(1) ). Example: ```python cosine_similarity([1.0, 1.0, 1.0], [1.0, 2.0, -1.0]) # Expected output: 0.47140452079103173 ``` Notes: * Handle potential edge cases such as vectors containing zeroes but keep in mind the vectors are guaranteed to be non-zero in length. * Ensure to validate the length of both vectors and raise a ValueError if they do not match.","solution":"from typing import List import math def cosine_similarity(vec1: List[float], vec2: List[float]) -> float: Calculate the cosine similarity between two vectors. Parameters: vec1 (List[float]): First vector. vec2 (List[float]): Second vector. Returns: float: Cosine similarity between the two vectors. if len(vec1) != len(vec2): raise ValueError(\\"Vectors must be of the same length\\") dot_product = sum(a * b for a, b in zip(vec1, vec2)) magnitude_vec1 = math.sqrt(sum(a * a for a in vec1)) magnitude_vec2 = math.sqrt(sum(b * b for b in vec2)) if magnitude_vec1 == 0 or magnitude_vec2 == 0: raise ValueError(\\"Vectors must not be zero vectors\\") return dot_product / (magnitude_vec1 * magnitude_vec2)"},{"question":"# Problem Description You are assigned a task to find two unique user records in a database system where the user IDs sum up to a given target. Ensure that these are the only two records that meet this criterion. The system is designed to group users in a list with their user IDs as integers. Write a function `find_user_pair` with the following specifications: Function Signature ```python def find_user_pair(user_ids: List[int], target: int) -> Tuple[int, int]: pass ``` Input 1. `user_ids`: A list of integers representing user IDs. 2. `target`: An integer representing the required sum of two user IDs. Output - Returns a tuple of two indices representing the positions of the two user IDs in the list that add up to the `target`. Constraints 1. If there are multiple pairs, return the first pair found. 2. You may assume that each input has exactly one solution. 3. An element cannot be used twice. 4. Indices start from 0 and should be returned in the tuple. Example ```python user_ids = [10, 5, 8, 12, 7], target = 15 # The IDs 10 and 5 sum to 15. # Therefore, the expected output is (0, 1) result = find_user_pair(user_ids, target) # Output should be (0, 1) ``` Additional Notes Ensure that your solution is efficient in terms of time complexity. Test your function thoroughly for edge cases such as very large or very small input arrays.","solution":"from typing import List, Tuple def find_user_pair(user_ids: List[int], target: int) -> Tuple[int, int]: Finds and returns the indices of the two unique user IDs that sum up to the target. Parameters: user_ids (List[int]): List of user IDs. target (int): The target sum of the two user IDs. Returns: Tuple[int, int]: A tuple containing the indices of the two user IDs. id_to_index = {} for index, user_id in enumerate(user_ids): complement = target - user_id if complement in id_to_index: return (id_to_index[complement], index) id_to_index[user_id] = index # If there is no such pair, though the problem states it always exist. return ()"},{"question":"# Shell Sort Implementation Challenge Context Imagine you are a software engineer responsible for managing data in a performance-critical application like a stock trading platform, where sorting operations need to be efficient both in terms of time and space. The operations rely on sorting stock prices repeatedly. You need to implement a variant of the Shell Sort algorithm that uses an optimized gap sequence to ensure better performance for large arrays. Task Implement a function `optimized_shell_sort` that sorts a given list of integers using an optimized Shell Sort algorithm with a provided gap sequence. Analyze which gap sequence would provide better performance and implement the function accordingly. Function Signature ```python def optimized_shell_sort(arr: List[int]) -> List[int]: pass ``` Input - `arr`: List of integers, where 1 ≤ len(arr) ≤ 10^5 and -10^9 ≤ arr[i] ≤ 10^9. Output - Returns a sorted list of integers. Constraints - The algorithm should sort the array in-place with a constant additional space complexity. - You should consider common gap sequences like Hibbard\'s gaps or Sedgewick\'s gaps and justify your choice briefly in a comment within the code. Performance Requirements - Your sorting function should have an average-case time complexity better than O(n^2) and be suitable for large arrays. Example ```python arr = [23, -3, 45, 0, 2, 78, 45, -1] print(optimized_shell_sort(arr)) # Expected output: [-3, -1, 0, 2, 23, 45, 45, 78] ```","solution":"from typing import List def optimized_shell_sort(arr: List[int]) -> List[int]: Sorts the list of integers using an optimized Shell Sort algorithm. We use the Sedgewick gap sequence which provides good performance for large arrays. n = len(arr) gaps = [] k = 0 while True: gap = 9 * (4**k - 2**k) + 1 if k % 2 == 0 else (2**(k+2)) * (2**(k+2) - 3) + 1 if gap > n: break gaps.append(gap) k += 1 gaps.reverse() for gap in gaps: for i in range(gap, n): temp = arr[i] j = i while j >= gap and arr[j - gap] > temp: arr[j] = arr[j - gap] j -= gap arr[j] = temp return arr"},{"question":"You are tasked with implementing a variation of the exchange sort algorithm, but this time, the algorithm should sort the array in descending order. Problem Statement Write a function `exchange_sort_descending(arr)` that takes as input a list of integers `arr` and returns a new list that contains the elements of `arr` sorted in descending order. # Input * A list of integers `arr` where `1 <= len(arr) <= 10^3`. # Output * A new list of integers sorted in descending order. # Constraints * You must implement the sorting algorithm from scratch, without using Python\'s built-in sorting functions. * The expected time complexity is O(n^2) and space complexity is O(1). # Examples Example 1 Input: `arr = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]` Output: `[9, 6, 5, 5, 5, 4, 3, 3, 2, 1, 1]` Example 2 Input: `arr = [1, 2, 3, 4, 5]` Output: `[5, 4, 3, 2, 1]` # Scenario Imagine you are working on a small embedded system with limited resources. You need to sort a list of sensor readings in descending order before passing them over to another system component that requires data in descending order for its processing. Given the constraints and requirements of the system, implementing the exchange sort algorithm is suitable for this case. # Function Signature ```python def exchange_sort_descending(arr: list) -> list: ```","solution":"def exchange_sort_descending(arr): Sorts the array in descending order using the exchange sort algorithm. n = len(arr) # Traverse through all array elements for i in range(n): # Last i elements are already in place, no need to check them for j in range(0, n-i-1): # Traverse the array from 0 to n-i-1 # Swap if the element found is less than the next element if arr[j] < arr[j+1]: arr[j], arr[j+1] = arr[j+1], arr[j] return arr"},{"question":"<|Analysis Begin|> # Algorithm Analysis Core Identification * **Algorithm/Data Structure**: The provided code utilizes a **backtracking algorithm** to construct word squares. * **Complexity**: * **Time Complexity**: In the worst case, the time complexity of the algorithm is (O(N cdot 26^L)), where (N) is the number of words and (L) is the length of each word. * **Space Complexity**: Space complexity primarily depends on the recursion stack and the storage of prefixes where it is (O(N cdot L)). Principles * **Core Steps**: 1. **Preprocessing**: Uses a dictionary `fulls` to map prefixes to words. 2. **Backtracking**: Builds word squares by recursively adding words that match the current prefix in the partially built square. Characteristics & Applications * **Properties**: * Each word forms both horizontal and vertical parts of the square, meaning the k-th column and row must read the same word. * **Common Use Cases**: * Solving crossword puzzles. * Generating valid word squares for word games. * **Strengths/Limitations**: * **Strengths**: Powerful for problems requiring combinations/permutations with constraints. * **Limitations**: Computationally expensive for a large number of words or long word lengths. Implementation Challenges * **Edge Cases**: * When the list of words is empty. * When no valid word square can be formed. * **Performance Bottlenecks**: * Extensive recursive calls leading to high memory use and slower execution for large inputs. * **Error Scenarios**: * Handling words of different lengths. * **Optimization Points**: * Reducing the number of recursive calls by efficient prefix matching. * Early termination when a prefix does not match any word. <|Analysis End|> <|Question Begin|> # Backtracking to Find Word Squares Problem Statement Given a set of words (without duplicates), write a function to find all possible word squares that can be formed from them. A word square is a sequence of words where the kth row and column read the exact same string, for all valid k. Input: * A list of words, where each word: * Contains only lowercase English letters (a-z). * Has the exact same length. * Is at least 1 character and at most 5 characters long. * The total number of words is at least 1 and at most 1000. Output: * A list of all possible word squares. * Each word square should be represented as a list of words. * The order of word squares in the output does not matter, but the order within each word square does. Example: ```python Input: [\\"area\\",\\"lead\\",\\"wall\\",\\"lady\\",\\"ball\\"] Output: [ [ \\"wall\\", \\"area\\", \\"lead\\", \\"lady\\" ], [ \\"ball\\", \\"area\\", \\"lead\\", \\"lady\\" ] ] Explanation: The output consists of two word squares. The order of output does not matter (just the order of words in each word square matters). ``` Constraints: * All words will have the exact same length. * Word length is at least 1 and at most 5. * Each word contains only lowercase English alphabet a-z. Function Signature: ```python def word_squares(words: List[str]) -> List[List[str]]: ``` Notes: * Consider edge cases where no valid word square can be formed. * Optimize the approach to handle the upper limits of the constraints efficiently. Good luck!","solution":"from typing import List, Dict from collections import defaultdict def build_prefix_dict(words: List[str]) -> Dict[str, List[str]]: prefix_dict = defaultdict(list) for word in words: for i in range(len(word)): prefix = word[:i] prefix_dict[prefix].append(word) return prefix_dict def backtrack(step: int, word_len: int, words: List[str], square: List[str], result: List[List[str]], prefix_dict: Dict[str, List[str]]): if step == word_len: result.append(square[:]) return # Build the current prefix prefix = \'\'.join([word[step] for word in square]) for candidate in prefix_dict.get(prefix, []): square.append(candidate) backtrack(step + 1, word_len, words, square, result, prefix_dict) square.pop() def word_squares(words: List[str]) -> List[List[str]]: if not words: return [] word_len = len(words[0]) prefix_dict = build_prefix_dict(words) result = [] for word in words: square = [word] backtrack(1, word_len, words, square, result, prefix_dict) return result"},{"question":"Problem Statement: # Flatten Nested Arrays You are given a nested array which may contain any number of sub-arrays, multiple levels deep. Your task is to write two Python functions: 1. **`flatten(input_arr)`**: This function takes a nested array (`input_arr`) and returns a flattened list containing all the elements in the input array, but without any nested structure. The order of appearance should be preserved. 2. **`flatten_iter(iterable)`**: This function takes a nested iterable (`iterable`) and returns a generator that produces the flattened elements one-by-one. This should also preserve the order of elements. Input - The input parameter to both functions can be a deeply nested list. For `flatten_iter`, the input parameter can be any iterable, not just lists. Output - For `flatten(input_arr)`, return a flat list containing all elements of `input_arr`. - For `flatten_iter(iterable)`, return a generator that yields each element of the flattened structure. Constraints - The elements of the input arrays can be arbitrary objects. - The input may include sub-arrays to any depth. - Handle both empty arrays and very large, deeply nested arrays. Examples ```python assert flatten([1, [2, [3, 4], [[5]]]]) == [1, 2, 3, 4, 5] assert list(flatten_iter([1, [2, [3, 4], [[5]]]])) == [1, 2, 3, 4, 5] assert flatten([]) == [] assert list(flatten_iter([])) == [] assert flatten([1, \'a\', [2, [\'b\', 3]], \'c\']) == [1, \'a\', 2, \'b\', 3, \'c\'] assert list(flatten_iter([1, \'a\', [2, [\'b\', 3]], \'c\'])) == [1, \'a\', 2, \'b\', 3, \'c\'] ``` Performance Requirements - Your solution should handle arrays nested to a reasonable depth (1000 levels). - Try to optimize for the maximum depth Python can handle recursively within the default recursion limit. Good luck!","solution":"from collections import abc def flatten(input_arr): Flattens a nested list into a single list of elements. def flatten_helper(arr): for elem in arr: if isinstance(elem, list): yield from flatten_helper(elem) else: yield elem return list(flatten_helper(input_arr)) def flatten_iter(iterable): Flattens a nested iterable into a single iterable of elements. for elem in iterable: if isinstance(elem, abc.Iterable) and not isinstance(elem, (str, bytes)): yield from flatten_iter(elem) else: yield elem"},{"question":"Unique Paths in an m x n Grid Context You are working on developing a game that requires characters to navigate through a grid. Each cell in the grid represents a position that the character can move to. Implement a function that calculates the number of unique paths from the top-left corner to the bottom-right corner of an m x n grid. The character can only move right or down at any point in time. Objective Write a function `count_paths(m, n)` that returns the number of unique paths from the top-left corner to the bottom-right corner of the given m x n grid. Function Signature ```python def count_paths(m: int, n: int) -> int: ``` Input - `m` (int): the number of rows in the grid (1 <= m <= 100) - `n` (int): the number of columns in the grid (1 <= n <= 100) Output - Returns an integer - the number of unique paths from top-left to bottom-right. Constraints - You can only move either right or down from any cell. - For invalid inputs where `m` or `n` are less than 1, return -1. Example ```python print(count_paths(3, 3)) # Should return 6 print(count_paths(1, 5)) # Should return 1 print(count_paths(5, 1)) # Should return 1 print(count_paths(2, 2)) # Should return 2 ``` # Requirements - **Efficiency**: The function should handle grids as large as 100x100 efficiently. - **Clarity and Robustness**: The function should handle edge cases and invalid inputs gracefully. Hints - Use dynamic programming to avoid redundant calculations and improve performance. - Consider using only a single row or column if you need to optimize space usage.","solution":"def count_paths(m: int, n: int) -> int: Calculate the number of unique paths from the top-left corner to the bottom-right corner of an m x n grid. The character can only move right or down. Args: m (int): the number of rows in the grid n (int): the number of columns in the grid Returns: int: the number of unique paths or -1 for invalid input if m < 1 or n < 1: return -1 # Create a 2D array to store the number of paths to each cell dp = [[1] * n for _ in range(m)] # Iteratively calculate the number of paths to each cell for i in range(1, m): for j in range(1, n): dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[m-1][n-1]"},{"question":"# Sudoku Solver Sudoku is a logic-based, combinatorial number-placement puzzle. The objective is to fill a 9x9 grid with digits so that each column, each row, and each of the nine 3x3 sub-grids contains all of the digits from 1 to 9. Here is how a basic Sudoku board looks: ``` 5 3 . | . 7 . | . . . 6 . . | 1 9 5 | . . . . 9 8 | . . . | . 6 . ------+-------+------ 8 . . | . 6 . | . . 3 4 . . | 8 . 3 | . . 1 7 . . | . 2 . | . . 6 ------+-------+------ . 6 . | . . . | 2 8 . . . . | 4 1 9 | . . 5 . . . | . 8 . | . 7 9 ``` Write a function `sudoku_solver(board: List[List[str]]) -> None:` that takes as input a partially filled Sudoku board and modifies the board in-place to solve the puzzle, using the Backtracking algorithm outlined in the analysis section. Input * A 2D `board` representing a 9x9 Sudoku grid, where each element is a string (\'.\' denotes an empty cell, \'1\'-\'9\' denote filled cells). Output * The function should modify the board in-place to fill in the missing elements such that the completed board satisfies Sudoku conditions. Constraints * The input board is guaranteed to be a valid Sudoku puzzle, with exactly one solution. * Consider the puzzle size to be always 9x9. Example Input: ``` [ [\\"5\\",\\"3\\",\\".\\",\\".\\",\\"7\\",\\".\\",\\".\\",\\".\\",\\".\\"], [\\"6\\",\\".\\",\\".\\",\\"1\\",\\"9\\",\\"5\\",\\".\\",\\".\\",\\".\\"], [\\".\\",\\"9\\",\\"8\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\"], [\\"8\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\"3\\"], [\\"4\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\"3\\",\\".\\",\\".\\",\\"1\\"], [\\"7\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\".\\",\\".\\",\\".\\",\\"6\\"], [\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\"8\\",\\".\\"], [\\".\\",\\".\\",\\".\\",\\"4\\",\\"1\\",\\"9\\",\\".\\",\\".\\",\\"5\\"], [\\".\\",\\".\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\".\\",\\"7\\",\\"9\\"] ] ``` Output: ``` [ [\\"5\\",\\"3\\",\\"4\\",\\"6\\",\\"7\\",\\"8\\",\\"9\\",\\"1\\",\\"2\\"], [\\"6\\",\\"7\\",\\"2\\",\\"1\\",\\"9\\",\\"5\\",\\"3\\",\\"4\\",\\"8\\"], [\\"1\\",\\"9\\",\\"8\\",\\"3\\",\\"4\\",\\"2\\",\\"5\\",\\"6\\",\\"7\\"], [\\"8\\",\\"5\\",\\"9\\",\\"7\\",\\"6\\",\\"1\\",\\"4\\",\\"2\\",\\"3\\"], [\\"4\\",\\"2\\",\\"6\\",\\"8\\",\\"5\\",\\"3\\",\\"7\\",\\"9\\",\\"1\\"], [\\"7\\",\\"1\\",\\"3\\",\\"9\\",\\"2\\",\\"4\\",\\"8\\",\\"5\\",\\"6\\"], [\\"9\\",\\"6\\",\\"1\\",\\"5\\",\\"3\\",\\"7\\",\\"2\\",\\"8\\",\\"4\\"], [\\"2\\",\\"8\\",\\"7\\",\\"4\\",\\"1\\",\\"9\\",\\"6\\",\\"3\\",\\"5\\"], [\\"3\\",\\"4\\",\\"5\\",\\"2\\",\\"8\\",\\"6\\",\\"1\\",\\"7\\",\\"9\\"] ] ```","solution":"from typing import List def sudoku_solver(board: List[List[str]]) -> None: Solves the Sudoku puzzle by filling the board in-place. def is_valid(row: int, col: int, num: str) -> bool: # Check whether \'num\' is not in the current row, column, and 3x3 sub-grid for i in range(9): if board[row][i] == num or board[i][col] == num: return False if board[3*(row//3) + i//3][3*(col//3) + i%3] == num: return False return True def solve() -> bool: for i in range(9): for j in range(9): if board[i][j] == \'.\': for num in map(str, range(1, 10)): if is_valid(i, j, num): board[i][j] = num if solve(): return True board[i][j] = \'.\' return False return True solve()"},{"question":"Scenario: You have been tasked with creating a sorting module that accelerates an inefficient but educationally valuable pancake sorting algorithm for a teaching tool. This tool needs to show step-by-step sorting of arrays by reversing segments, demonstrating how elements are moved through the array to reach their correct positions. Task: Implement the function `pancake_sort` that takes a list of integers and sorts it using the pancake sorting algorithm. The goal is to mutate the input list such that it becomes sorted in non-descending order. Function Signature: ```python def pancake_sort(arr: List[int]) -> List[int]: ``` Input: - An unsorted list of integers, `arr` (0 <= len(arr) <= 100; -10^5 <= arr[i] <= 10^5) Output: - A list of integers sorted in non-descending order. Constraints: - The implementation should sort the array in place, meaning no auxiliary list should be used for the sorting process. Example: ```python arr = [3, 1, 4, 1, 5, 9, 2, 6, 5] print(pancake_sort(arr)) # Output: [1, 1, 2, 3, 4, 5, 5, 6, 9] ``` Notes: - Ensure the function handles edge cases such as empty input or single-element arrays efficiently. - Think about potential error scenarios with list indexing and ensure to handle them appropriately.","solution":"def pancake_sort(arr): Sorts the given list of integers using the Pancake sorting algorithm in place. def flip(sub_arr, k): Reverses sub-array from start up to index k (inclusive). left, right = 0, k while left < right: sub_arr[left], sub_arr[right] = sub_arr[right], sub_arr[left] left += 1 right -= 1 n = len(arr) for size in range(n, 1, -1): # Get the index of the maximum number in subarray arr[0:size] max_idx = max(range(size), key=lambda i: arr[i]) if max_idx != size - 1: # Flip the maximum number to the front flip(arr, max_idx) # Flip it to its correct position flip(arr, size - 1) return arr"},{"question":"# Question: Implementing a Binary Search Tree Iterator You are given a binary search tree (BST) with its root node. Implement an iterator over the BST to perform an in-order traversal. Your iterator should be able to return elements in ascending order using only the following methods: 1. `__init__(self, root)` - Initializes the iterator with the root node of the BST. 2. `has_next(self)` - Returns `True` if there exists a next element in the in-order traversal, otherwise `False`. 3. `next(self)` - Returns the next smallest number in the BST. Each method should run in average O(1) time and use O(h) memory, where h is the height of the tree. # Example ```plaintext BST structure (numbers represent node values): 7 / 3 15 / 9 20 Initially, the iterator is initialized with the root node (7). Calling next() returns 3. Calling next() returns 7. Calling next() returns 9. Calling next() returns 15. Calling next() returns 20. Calling has_next() at any of these points returns True until the iterator is exhausted. Calling next() should not be called if has_next() returns False. Input Format: The root node of a BST. Output Format: An implementation of the class with given methods. ``` Constraints - The number of nodes in the tree is in the range [0, 10000]. - -10^5 ≤ Node.val ≤ 10^5 - Your implementation should avoid using any extra space, only O(h) space allowed for auxiliary data structures. Write your code in Python: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BSTIterator: def __init__(self, root: TreeNode): Initializes the BST Iterator with root node # Your code here. def has_next(self) -> bool: Check if there is a next smallest number in BST :return: bool # Your code here. def next(self) -> int: Return the next smallest number :return: int # Your code here. ```","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BSTIterator: def __init__(self, root: TreeNode): Initializes the BST Iterator with root node self.stack = [] self._leftmost_inorder(root) def _leftmost_inorder(self, root): Helper function to push all the leftmost nodes of the root onto the stack. while root: self.stack.append(root) root = root.left def has_next(self) -> bool: Check if there is a next smallest number in BST :return: bool return len(self.stack) > 0 def next(self) -> int: Return the next smallest number in the BST :return: int smallest_node = self.stack.pop() # Pop the topmost element if smallest_node.right: self._leftmost_inorder(smallest_node.right) # Process the right subtree return smallest_node.val"},{"question":"You are given the task to simulate a system that tracks connected components on a 2D grid (considered as water at the start). Each operation, you can add a piece of land and need to track the number of islands (connected components of lands) formed after each operation in the grid. **Function Signature**: ```python def number_of_islands(n: int, m: int, positions: List[Tuple[int, int]]) -> List[int]: Args: n : int : number of rows in the grid m : int : number of columns in the grid positions : List[Tuple[int, int]] : list of positions to add land Returns: List[int] : number of islands after each addLand operation ``` # Parameters - **n**: an integer denoting the number of rows in the grid. - **m**: an integer denoting the number of columns in the grid. - **positions**: a list of tuples `(x, y)` where each tuple denotes the position to be converted from water to land in the grid. # Output Return a list of integers where the (i)-th element denotes the number of islands after the (i)-th operation. # Constraints - (1 leq n, m leq 1000) - (0 leq x < n) - (0 leq y < m) - Positions are unique for each operation. # Example ```python n = 3 m = 3 positions = [(0, 0), (0, 1), (1, 2), (2, 1)] print(number_of_islands(n, m, positions)) # Output: [1, 1, 2, 3] ``` # Explanation 1. Initial grid: ``` 0 0 0 0 0 0 0 0 0 ``` 2. After position (0, 0): ``` 1 0 0 0 0 0 Number of islands = 1 0 0 0 ``` 3. After position (0, 1): ``` 1 1 0 0 0 0 Number of islands = 1 0 0 0 ``` 4. After position (1, 2): ``` 1 1 0 0 0 1 Number of islands = 2 0 0 0 ``` 5. After position (2, 1): ``` 1 1 0 0 0 1 Number of islands = 3 0 1 0 ``` # Notes - Ensure efficient handling by leveraging the Union-Find structure with path compression and union by size for optimal performance. - Carefully handle adding land positions and merging adjacent lands to determine islands correctly.","solution":"from typing import List, Tuple class UnionFind: def __init__(self, size): self.parent = list(range(size)) self.rank = [0] * size self.count = 0 def find(self, x): if self.parent[x] != x: self.parent[x] = self.find(self.parent[x]) return self.parent[x] def union(self, x, y): rootX = self.find(x) rootY = self.find(y) if rootX != rootY: if self.rank[rootX] > self.rank[rootY]: self.parent[rootY] = rootX elif self.rank[rootX] < self.rank[rootY]: self.parent[rootX] = rootY else: self.parent[rootY] = rootX self.rank[rootX] += 1 self.count -= 1 def number_of_islands(n: int, m: int, positions: List[Tuple[int, int]]) -> List[int]: def position_id(x, y): return x * m + y uf = UnionFind(n * m) grid = [[0] * m for _ in range(n)] results = [] directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] for x, y in positions: if grid[x][y] == 1: results.append(uf.count) continue grid[x][y] = 1 uf.count += 1 current_id = position_id(x, y) for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] == 1: neighbor_id = position_id(nx, ny) uf.union(current_id, neighbor_id) results.append(uf.count) return results"},{"question":"# Missing Ranges Finder Problem Statement Given a sorted array of unique integers `arr`, along with two integers `lo` and `hi`, write a function `missing_ranges` that returns a list of tuples indicating the ranges of integers that are missing between `lo` and `hi` inclusive. Function Signature ```python def missing_ranges(arr: List[int], lo: int, hi: int) -> List[Tuple[int, int]]: pass ``` Input * `arr` (List[int]): A sorted list of unique integers. * `lo` (int): The lower bound of the range. * `hi` (int): The upper bound of the range. Output * List[Tuple[int, int]]: A list of tuples, each representing a range (inclusive) of missing integers. Constraints 1. All integers will be in the range `-10^9` to `10^9`. 2. `0 <= len(arr) <= 10^5`. 3. `lo <= hi`. Example * Input: `arr = [3, 5, 7]`, `lo = 1`, `hi = 10` * Output: `[(1, 2), (4, 4), (6, 6), (8, 10)]` * Input: `arr = [1, 2, 3, 4, 5]`, `lo = 1`, `hi = 5` * Output: `[]` Scenario/Context Suppose you are a network administrator who needs to identify missing packet IDs in a sequence of received packets. This function will assist in pinpointing gaps in the sequence, thus enabling you to infer loss of data packets effectively. Performance Requirements The function should efficiently handle up to 100,000 elements in the array within a practical time frame.","solution":"from typing import List, Tuple def missing_ranges(arr: List[int], lo: int, hi: int) -> List[Tuple[int, int]]: Returns a list of ranges (tuples) that are missing between lo and hi, inclusive. missing = [] prev = lo - 1 # Initialize previous as one less than lo to handle the first range correctly # Loop through the array and check the gaps between consecutive elements for num in arr: if num > prev + 1: missing.append((prev + 1, num - 1)) prev = num # Check the gap between the last element and hi if hi > prev: missing.append((prev + 1, hi)) return missing"},{"question":"# Magic Number Checker with Optimization Scenario The local puzzle club has a special interest in determining \\"Magic Numbers\\". They need an efficient way to check if various numbers meet the magic number criteria. A magic number is a number that becomes 1 when its digits are summed repeatedly until a single digit is obtained. You are tasked to write a function to help them out. Task Write a function `is_magic_number(n)` that determines if the given number `n` is a Magic Number as per the described criteria. Function Signature ```python def is_magic_number(n: int) -> bool: :param n: An integer n (0 <= n <= 10^18) :return: True if n is a Magic Number, otherwise False. ``` Input * An integer `n` (0 <= n <= 10^18) Output * A Boolean value: `True` if `n` is a Magic Number, otherwise `False`. Constraints * The number `n` will be between 0 and 10^18, inclusive. Examples 1. Input: `n = 50113` Output: `True` 2. Input: `n = 1234` Output: `True` 3. Input: `n = 199` Output: `True` 4. Input: `n = 111` Output: `False` 5. Input: `n = 0` Output: `False` Notes * Ensure the solution handles large values efficiently. * Optimize for performance, considering the constraint limits.","solution":"def is_magic_number(n: int) -> bool: Determines if the given number n is a Magic Number. :param n: An integer n (0 <= n <= 10^18) :return: True if n is a Magic Number, otherwise False. if n == 0: return False def digital_root(num): if num == 0: return 0 return 1 + (num - 1) % 9 return digital_root(n) == 1"},{"question":"Rabin-Karp Enhanced You are given the implementation of the Rabin-Karp algorithm, which is used to find a specific pattern (`word`) within a larger string (`text`). However, this basic implementation doesn\'t handle cases with multiple potential matches and might not manage hash collisions efficiently. Your task is to extend the given function to handle multiple occurrences of the pattern in the text and consider hash collisions. **Requirements:** 1. Modify the `rabin_karp` function so that it returns a list of starting indices where the `word` is found within the `text`. 2. Enhance the function to handle collision cases where different substrings might have the same hash. **Input:** - A string `word` (1 ≤ length of `word` ≤ 10^4) - A string `text` (1 ≤ length of `text` ≤ 10^5) **Output:** - A list of integers representing the starting indices where `word` occurs in `text`. **Constraints:** - Your solution should handle empty strings by returning an empty list. - Ensure that your solution maintains a linear time complexity on average. **Example:** ```python # Expected to return [0, 6] print(rabin_karp_enhanced(\\"abc\\", \\"abcxabc\\")) ``` **Hint:** - Make sure to account for situations where multiple substrings might lead to the same hash value by verifying the actual substring where necessary.","solution":"def rabin_karp_enhanced(word, text): Implements an enhanced Rabin-Karp algorithm to find all starting indices of the pattern `word` in the string `text`. if not word or not text or len(word) > len(text): return [] base = 256 # A larger base to handle character hashing (number of characters in the input alphabet) mod = 2**31 - 1 # A large prime to reduce the occurrence of hash collisions word_len = len(word) text_len = len(text) word_hash = 0 # Initial hash value for the word text_hash = 0 # Initial hash value for the text highest_base = 1 # The highest base^m value, where m is the length of the word for i in range(word_len): word_hash = (base * word_hash + ord(word[i])) % mod text_hash = (base * text_hash + ord(text[i])) % mod if i < word_len - 1: highest_base = (highest_base * base) % mod result = [] for i in range(text_len - word_len + 1): if word_hash == text_hash: # Potential match found, validate substring to avoid collision issues if text[i:i + word_len] == word: result.append(i) # Update the hash value for the next substring if i < text_len - word_len: text_hash = (text_hash - ord(text[i]) * highest_base) % mod text_hash = (text_hash * base + ord(text[i + word_len])) % mod text_hash = (text_hash + mod) % mod # Unnecessary in Python but ensures non-negative values return result"},{"question":"# Comb Sort Implementation You have been tasked with implementing and enhancing the Comb Sort algorithm. Given an unsorted list of integers, you need to sort it using the Comb Sort technique. Additionally, focus on identifying and properly handling edge cases and optimizing the performance where possible. # Function Signature ```python def comb_sort(arr): Sorts an array of integers using the Comb Sort algorithm. Parameters: - arr (List[int]): A list of unsorted integers. Returns: - List[int]: The sorted list of integers. pass ``` # Input - A list of integers `arr` with length `n`, where `1 <= n <= 10^5`. - Each integer in the list is within the range -10^6 to 10^6. # Output - A new list of integers sorted in non-decreasing order. # Constraints - The algorithm should handle large lists efficiently. - The function should be optimized for both time and space complexity. - Make sure to properly handle any possible edge cases like an already sorted list, a list with all identical elements, etc. # Example ```python assert comb_sort([4, 3, 1, 2]) == [1, 2, 3, 4] assert comb_sort([8, 4, 8, 3, 2]) == [2, 3, 4, 8, 8] assert comb_sort([1, 1, 1, 1]) == [1, 1, 1, 1] assert comb_sort([]) == [] ``` # Additional Notes - A visual representation of the algorithm and its gap reduction mechanism would be beneficial. - Consider adding unit tests to ensure your solution covers all edge cases. Implement the `comb_sort` function according to the above specifications.","solution":"def comb_sort(arr): Sorts an array of integers using the Comb Sort algorithm. Parameters: - arr (List[int]): A list of unsorted integers. Returns: - List[int]: The sorted list of integers. def get_next_gap(gap): # Shrink the gap by the shrink factor (1.3) gap = (gap * 10) // 13 if gap < 1: return 1 return gap n = len(arr) gap = n swapped = True while gap != 1 or swapped: gap = get_next_gap(gap) swapped = False for i in range(0, n - gap): if arr[i] > arr[i + gap]: arr[i], arr[i + gap] = arr[i + gap], arr[i] swapped = True return arr"},{"question":"Given a string `input_string` and a set of words `word_dict` (representing the dictionary), write a Python function `count_sentences(input_string, word_dict)` to count the number of different ways the `input_string` can be segmented into words contained in `word_dict`. # Input - `input_string`: A non-empty string consisting of lowercase English letters. - `word_dict`: A set of strings, where each string is a valid word consisting of lowercase English letters. # Output - An integer representing the number of valid segmentations of `input_string`. # Constraints - You cannot use global variables. - Your function should handle large input efficiently. - Consider using dynamic programming or memoization to optimize performance. # Example ```python input_string = \\"appletablet\\" word_dict = {\\"apple\\", \\"tablet\\", \\"applet\\", \\"able\\", \\"t\\"} print(count_sentences(input_string, word_dict)) # Output: 3 ``` - \\"apple\\", \\"tablet\\" - \\"applet\\", \\"able\\", \\"t\\" - \\"apple\\", \\"table\\", \\"t\\" # Implementation Details - You should handle edge cases such as when `input_string` cannot be segmented at all using the words in `word_dict`. - Ensure your implementation does not use excessive memory or time for large inputs. # Code Stub ```python def count_sentences(input_string, word_dict): # Your implementation here pass # Example usage input_string = \\"appletablet\\" word_dict = {\\"apple\\", \\"tablet\\", \\"applet\\", \\"able\\", \\"t\\"} print(count_sentences(input_string, word_dict)) # Output: 3 ```","solution":"def count_sentences(input_string, word_dict): Counts the number of different ways the input_string can be segmented into words contained in word_dict. n = len(input_string) dp = [0] * (n + 1) dp[0] = 1 # Base case: one way to segment an empty string for i in range(1, n + 1): for j in range(i): if input_string[j:i] in word_dict: dp[i] += dp[j] return dp[n]"},{"question":"# Segment Tree Range Minimum Query Implementation Context: You are working on a performance-critical application that frequently needs to find the minimum value within subarrays. To optimize the computational cost, you are tasked with implementing a segment tree from scratch that supports efficient range minimum queries. Task: Implement a segment tree class `SegmentTreeMin` that supports the following operations: 1. **Initialize**: Construct the segment tree from a given list of integers. 2. **Minimum Query**: Query the segment tree for the minimum value within a specified range. Your implementation should include: * Efficient construction of the segment tree. * Support querying the minimum value within a range in O(log N) time. Input: * Initialization input: A list of integers representing the array. * Query input: Two integers representing the start and end of the range (inclusive). Output: * The minimum value within the specified range for each query. Constraints: * 1 <= len(arr) <= 10^5 * The values in the array are integers. * Query start and end indices are within the bounds of the array. Example: ```python # Initializing the segment tree with an array arr = [2, 4, 5, 3, 4] seg_tree = SegmentTreeMin(arr) # Performing queries result1 = seg_tree.query(1, 3) # Expected output: 3 result2 = seg_tree.query(0, 4) # Expected output: 2 result3 = seg_tree.query(2, 2) # Expected output: 5 print(result1) print(result2) print(result3) ``` Requirements: - Implement the `SegmentTreeMin` class. - Ensure queries are efficient and perform within O(log N) time.","solution":"class SegmentTreeMin: def __init__(self, arr): self.n = len(arr) self.tree = [None] * (4 * self.n) self._build(arr, 0, 0, self.n - 1) def _build(self, arr, node, start, end): if start == end: self.tree[node] = arr[start] else: mid = (start + end) // 2 left_child = 2 * node + 1 right_child = 2 * node + 2 self._build(arr, left_child, start, mid) self._build(arr, right_child, mid + 1, end) self.tree[node] = min(self.tree[left_child], self.tree[right_child]) def query(self, L, R): return self._query(0, 0, self.n - 1, L, R) def _query(self, node, start, end, L, R): if R < start or end < L: return float(\'inf\') if L <= start and end <= R: return self.tree[node] mid = (start + end) // 2 left_child = 2 * node + 1 right_child = 2 * node + 2 left_min = self._query(left_child, start, mid, L, R) right_min = self._query(right_child, mid + 1, end, L, R) return min(left_min, right_min)"},{"question":"# Scenario You are tasked to improve the performance of a process scheduling system that uses a priority queue. The current implementation has poor performance in environments where new tasks are frequently added. Therefore, you need to optimize the insertion operations. # Task Implement a priority queue using a Binary Heap, which will significantly improve the insertion operation time complexity from O(n) to O(log n). # Function Signatures You need to implement the following methods: 1. **init**: Initializes the priority queue. 2. **size**: Returns the current size of the priority queue. 3. **push**: Inserts an element with a given priority into the priority queue. 4. **pop**: Removes and returns the element with the highest priority. # Input/Output Examples ```python pq = PriorityQueue() pq.push(\'task1\', 5) pq.push(\'task2\', 2) pq.push(\'task3\', 3) print(pq.size()) # Output -> 3 print(pq.pop()) # Output -> \'task1\' print(pq.pop()) # Output -> \'task3\' print(pq.pop()) # Output -> \'task2\' ``` # Constraints * Assume the priorities are integers and can be positive or negative. * The methods should handle operations in expected time complexity. * Consider edge cases such as: - Empty queue operations. - Multiple items with the same priority. # Performance Requirements * Insertion time complexity: O(log n) * Extraction time complexity: O(log n) Please implement the priority queue with the specified functionality and input/output behavior.","solution":"import heapq class PriorityQueue: def __init__(self): self._heap = [] def size(self): return len(self._heap) def push(self, element, priority): heapq.heappush(self._heap, (-priority, element)) def pop(self): if not self._heap: return None return heapq.heappop(self._heap)[1]"},{"question":"Unique Element Finder Given an array of integers where every element appears three times except for one element that appears exactly once, write a function `find_unique_number` to find that single element. Your solution must follow these constraints: 1. The function should have a linear runtime complexity. 2. No additional memory should be used beyond a constant amount of extra space. **Function Signature**: ```python def find_unique_number(nums: List[int]) -> int: pass ``` # Input * `nums`: A list of integers where each element occurs exactly three times except for one unique element. # Output * The function should return the integer that appears exactly once in the list. # Example ```python print(find_unique_number([2, 2, 3, 2])) # Output: 3 print(find_unique_number([0, 1, 0, 1, 0, 1, 99])) # Output: 99 ``` # Constraints * The length of the array will be between 1 and 10^4. * Each element in the array will be within the 32-bit integer range. # Scenario Imagine you\'re working with a system where specific signals appear in triplets due to a transmission protocol except for one signal that\'s unique and crucial for the next step. Your task is to create an efficient solution to identify this unique signal from a dataset received in a single burst. # Performance Requirements Ensure your implementation is efficient with O(n) time complexity and O(1) space complexity, handling up to 10^4 elements in the array.","solution":"def find_unique_number(nums): Find the number that appears exactly once in the list where all other elements appear exactly three times. ones, twos = 0, 0 for num in nums: twos = twos | (ones & num) ones = ones ^ num common_bit_mask = ~(ones & twos) ones &= common_bit_mask twos &= common_bit_mask return ones"},{"question":"# FizzBuzz with Validity Checks and Generator **Context**: FizzBuzz is a common programming task used to teach or test introductory iteration and conditional logic. The classical task involves iterating through numbers, replacing those divisible by 3 with \'Fizz\', by 5 with \'Buzz\', and by both with \'FizzBuzz\'. We\'re going to expand it by incorporating generators and additional input validation to streamline memory usage and prevent unnecessary large amount of memory consumption for large inputs. **Objective**: You need to write a function `fizzbuzz_generator` that generates the FizzBuzz sequence up to a given integer N. This function should not use more memory than necessary and should perform input validation to handle edge cases. **Function Signature**: ```python def fizzbuzz_generator(n: int): Generates the FizzBuzz sequence up to a given number N. Args: n (int): The upper limit of the sequence (inclusive). Yields: str|int: The Fizz, Buzz, or FizzBuzz strings, or the number itself. pass ``` # Input - `n` (int): An integer greater than or equal to 1. # Output - A generator that yields each value in the FizzBuzz sequence up to `n`. # Constraints - `n` will always be an integer. - If `n` is less than 1, the function should raise a `ValueError` with the message \\"n must be greater than or equal to 1\\". # Performance Requirements - Must use a generator to yield results instead of returning a list, to handle large `n` efficiently. # Example ```python # Example usage: fizzbuzz_gen = fizzbuzz_generator(15) print(list(fizzbuzz_gen)) # Output: [1, 2, \'Fizz\', 4, \'Buzz\', \'Fizz\', 7, 8, \'Fizz\', \'Buzz\', 11, \'Fizz\', 13, 14, \'FizzBuzz\'] ``` # Notes - Ensure input validation by checking edge cases such as n < 1 and raising an appropriate error message. - Utilize `yield` keyword for efficient memory usage.","solution":"def fizzbuzz_generator(n: int): Generates the FizzBuzz sequence up to a given number N. Args: n (int): The upper limit of the sequence (inclusive). Yields: str|int: The Fizz, Buzz, or FizzBuzz strings, or the number itself. if n < 1: raise ValueError(\\"n must be greater than or equal to 1\\") for i in range(1, n + 1): if i % 3 == 0 and i % 5 == 0: yield \'FizzBuzz\' elif i % 3 == 0: yield \'Fizz\' elif i % 5 == 0: yield \'Buzz\' else: yield i"},{"question":"# Scenario You\'re assigned to manage a new social networking platform that dynamically connects people and queries their connections. Whenever a person sends a friend request, you need to update the system to recognize they are now directly connected. Similarly, you should efficiently determine if two people are connected either directly or indirectly through other connections. # Problem Statement Implement a class `SocialNetwork` that offers efficient ways to manage and query friend connections. Specifically, you need to: 1. **Add People**: Maintain records for new people as they join the network. 2. **Add Friend Connection**: Record a new friendship between two people. 3. **Check Connection**: Determine if two people are connected through direct or indirect friendship paths. # Requirements * Implement three methods: `add_user(id: int)`, `add_friend(id1: int, id2: int)`, and `check_connection(id1: int, id2: int) -> bool`. * Your solution should efficiently support large numbers of users and frequent friendship updates. * Use the Union-Find data structure described above. # Class Definition ```python class SocialNetwork: def __init__(self): # Initializes the SocialNetwork pass def add_user(self, id: int): # Adds a new user to the network pass def add_friend(self, id1: int, id2: int): # Records a friendship connection between two users pass def check_connection(self, id1: int, id2: int) -> bool: # Checks if two users are connected through direct or indirect friendships pass ``` # Constraints * `1 <= id, id1, id2 <= 10^6` * A user can be added multiple times, but must only be recorded once. * Each `add_friend` call involves only previously added users. # Example ```python # Example usage: network = SocialNetwork() network.add_user(1) network.add_user(2) network.add_user(3) network.add_friend(1, 2) print(network.check_connection(1, 2)) # Outputs: True print(network.check_connection(1, 3)) # Outputs: False network.add_friend(2, 3) print(network.check_connection(1, 3)) # Outputs: True ``` # Note Ensure that each operation, `add_user`, `add_friend`, and `check_connection`, is optimized for time and space efficiency to handle up to one million users.","solution":"class SocialNetwork: def __init__(self): self.parent = {} self.rank = {} def add_user(self, id: int): if id not in self.parent: self.parent[id] = id self.rank[id] = 0 def find(self, id: int) -> int: if self.parent[id] != id: self.parent[id] = self.find(self.parent[id]) # Path compression return self.parent[id] def union(self, id1: int, id2: int): root1 = self.find(id1) root2 = self.find(id2) if root1 != root2: # Union by rank if self.rank[root1] > self.rank[root2]: self.parent[root2] = root1 elif self.rank[root1] < self.rank[root2]: self.parent[root1] = root2 else: self.parent[root2] = root1 self.rank[root1] += 1 def add_friend(self, id1: int, id2: int): self.union(id1, id2) def check_connection(self, id1: int, id2: int) -> bool: return self.find(id1) == self.find(id2)"},{"question":"Given a set of n distinct items, you need to compute the number of ways to choose r items from these n items (denoted as ( C(n, r) )), efficiently. Implement two functions: 1. `combination_memo(n, r)`: This function must use memoization to avoid redundant calculations and to improve runtime efficiency. 2. `combination_iter(n, r)`: This function must use an iterative approach with dynamic programming. Both functions should return the same result but must use their respective methods for computation. # Specifications: **Function 1: combination_memo(n, r)** - **Input:** Two integers, n (number of items), and r (number of items to choose). - **Output:** An integer representing the value of ( C(n, r) ). - **Constraints:** - 0 ≤ r ≤ n - n ≤ 1000 (Choose an efficient method given this constraint to avoid performance issues) **Function 2: combination_iter(n, r)** - **Input:** Two integers, n (number of items), and r (number of items to choose). - **Output:** An integer representing the value of ( C(n, r) ). - **Constraints:** - 0 ≤ r ≤ n - n ≤ 1000 # Example ```python assert combination_memo(5, 2) == 10 assert combination_iter(5, 2) == 10 assert combination_memo(6, 3) == 20 assert combination_iter(6, 3) == 20 ``` # Explanation: - ( C(5, 2) = 10 ) - ( C(6, 3) = 20 ) # Additional Context: Choosing r items from n is a foundational problem in combinatorics, relevant to various domains including probability, graphs, and statistical modeling. Efficiently solving this with both memoization and dynamic programming solidifies understanding of optimization in recursive problems.","solution":"from functools import lru_cache @lru_cache(None) def combination_memo(n, r): if r == 0 or r == n: return 1 return combination_memo(n-1, r-1) + combination_memo(n-1, r) def combination_iter(n, r): if r > n: return 0 if r == 0 or r == n: return 1 dp = [[0 for _ in range(r+1)] for _ in range(n+1)] for i in range(n+1): for j in range(min(i, r)+1): if j == 0 or j == i: dp[i][j] = 1 else: dp[i][j] = dp[i-1][j-1] + dp[i-1][j] return dp[n][r]"},{"question":"# Question: Graph Component Count You are provided with an undirected graph represented as an adjacency list. Your task is to write a function that counts the number of connected components in the graph by employing both Depth-First Search (DFS) and Breadth-First Search (BFS). You should verify that both traversal techniques yield the same result. Function Signature ```python def count_connected_components(graph: dict) -> int: Count the number of connected components in the given undirected graph. Parameters: graph (dict): An adjacency list where keys are nodes, and values are lists of neighbouring nodes. Returns: int: The number of connected components in the graph. ``` Input and Output * **Input**: * A dictionary representing an undirected graph (adjacency list). Example: ```python { 0: [1, 2], 1: [0], 2: [0], 3: [] } ``` * This input represents a graph with 4 nodes (0 to 3). Node 3 is isolated. * **Output**: * An integer representing the number of connected components in the graph. For the above example, the output should be `2` indicating two connected components: {0, 1, 2} and {3}. Constraints * The graph is undirected. * The graph could be disconnected or have isolated nodes. * Node identifiers are integers. Example ```python graph = { 0: [1, 2], 1: [0], 2: [0], 3: [] } assert count_connected_components(graph) == 2 graph = { 0: [1], 1: [0, 2], 2: [1], 3: [4], 4: [3] } assert count_connected_components(graph) == 2 ``` **Note**: Your implementation should use both DFS and BFS, and confirm that the number of connected components computed by both traversals is the same. Although only one count should be returned, it may be helpful to create helper functions for traversals.","solution":"def count_connected_components(graph: dict) -> int: Count the number of connected components in the given undirected graph using BFS. Parameters: graph (dict): An adjacency list where keys are nodes, and values are lists of neighbouring nodes. Returns: int: The number of connected components in the graph. def bfs(node, visited): queue = [node] while queue: current = queue.pop(0) for neighbour in graph[current]: if neighbour not in visited: visited.add(neighbour) queue.append(neighbour) def dfs(node, visited): stack = [node] while stack: current = stack.pop() for neighbour in graph[current]: if neighbour not in visited: visited.add(neighbour) stack.append(neighbour) visited = set() connected_components = 0 for node in graph: if node not in visited: connected_components += 1 # You can use either bfs or dfs bfs(node, visited) # dfs(node, visited) # Optionally, confirm by using DFS as well visited_dfs = set() connected_components_dfs = 0 for node in graph: if node not in visited_dfs: connected_components_dfs += 1 dfs(node, visited_dfs) assert connected_components == connected_components_dfs, \\"BFS and DFS counts do not match\\" return connected_components"},{"question":"You are provided with the partial implementation of a class `Graph` which represents a directed graph using adjacency lists. Your task is to complete the implementation by writing additional functions as specified below. Task 1. Write a method `has_path(self, source, target)` in the `Graph` class that determines if there is a path from the vertex `source` to vertex `target` by using the transitive closure matrix. 2. Based on the transitive closure matrix, implement a method `all_reachable_vertices(self, vertex)` which returns a list of all vertices reachable from a given `vertex`. # Method Signatures * `def has_path(self, source: int, target: int) -> bool:` * `def all_reachable_vertices(self, vertex: int) -> List[int]:` # Input and Output Format * `has_path`: * **Input**: Two integers `source` and `target` representing the vertices. * **Output**: Returns `True` if there is a path from `source` to `target`, otherwise returns `False`. * `all_reachable_vertices`: * **Input**: An integer `vertex` representing the starting vertex. * **Output**: Returns a list of integers representing all reachable vertices from the given `vertex`. # Constraints * The graph can have at most 500 vertices. * Vertices are indexed from 0 to V-1. * Edges are given as pairs of integers. # Example ```python graph = Graph(4) graph.add_edge(0, 1) graph.add_edge(0, 2) graph.add_edge(1, 2) graph.add_edge(2, 0) graph.add_edge(2, 3) graph.add_edge(3, 3) graph.transitive_closure() print(graph.has_path(0, 3)) # Output: True print(graph.all_reachable_vertices(0)) # Output: [0, 1, 2, 3] ``` # Additional Notes * Ensure you use the already computed transitive closure to answer these queries efficiently. * Manage edge cases where the graph might have disconnected components or no edges.","solution":"class Graph: def __init__(self, vertices): self.V = vertices self.graph = [[] for _ in range(vertices)] self.tc = [[0 for _ in range(vertices)] for _ in range(vertices)] def add_edge(self, u, v): self.graph[u].append(v) def transitive_closure(self): self._initialize_tc() for k in range(self.V): for i in range(self.V): for j in range(self.V): self.tc[i][j] = self.tc[i][j] or (self.tc[i][k] and self.tc[k][j]) def _initialize_tc(self): for i in range(self.V): for j in range(self.V): if i == j: self.tc[i][j] = 1 elif j in self.graph[i]: self.tc[i][j] = 1 else: self.tc[i][j] = 0 def has_path(self, source, target): return self.tc[source][target] == 1 def all_reachable_vertices(self, vertex): return [v for v in range(self.V) if self.tc[vertex][v] == 1]"},{"question":"Context Bucket Sort is an effective distribution-based sorting algorithm that divides elements into different buckets and sorts them individually. Your task is to implement a variant of this sorting algorithm. By understanding the principles and intricacies of Bucket Sort as well as optimizing the auxiliary sort mechanism, you will demonstrate comprehensive algorithm application and optimization skills. Task Implement the `bucket_sort` function as described below: Function Signature ```python def bucket_sort(arr: List[int]) -> List[int]: Sorts a given list of integers using the Bucket Sort algorithm. Parameters: arr (List[int]): A list of integers to be sorted. Returns: List[int]: A sorted list of integers. ``` Requirements * If the array is empty, return an empty array. * If the array contains one element, return that element. * Your solution must handle edge cases efficiently (e.g., all elements being identical, varying ranges). * The auxiliary sort within the buckets should utilize a sorting algorithm more efficient than Insertion Sort. Consider using Quick Sort or Heap Sort. Constraints * The values in the array are guaranteed to be non-negative integers. * The maximum value of any element in the array will not exceed 10^6. * The input array can have up to 10^5 elements. Performance Requirements - The `bucket_sort` function should run in O(n log n) time complexity on average. - The function should use memory efficiently, optimizing space complexity where possible. Additional Notes * Consider dynamically determining the number of buckets based on the input data. * Provide a brief explanation of any chosen auxiliary sorting technique and why it might improve the performance of Bucket Sort.","solution":"from typing import List def bucket_sort(arr: List[int]) -> List[int]: Sorts a given list of integers using the Bucket Sort algorithm. Parameters: arr (List[int]): A list of integers to be sorted. Returns: List[int]: A sorted list of integers. if len(arr) == 0: return [] # Determine the number of buckets num_buckets = len(arr) max_value = max(arr) # Create empty buckets buckets = [[] for _ in range(num_buckets)] # Distribute elements into buckets for num in arr: index = num * num_buckets // (max_value + 1) buckets[index].append(num) # Sort each bucket using a fast sorting algorithm (Timsort in this case, used in Python\'s sorted()) sorted_arr = [] for bucket in buckets: sorted_arr.extend(sorted(bucket)) return sorted_arr"},{"question":"# Question You are tasked with developing a function that filters out elements of an integer array based on specified minimum and maximum limits. Your solution should efficiently handle arrays of varying lengths and account for a variety of edge cases. Implement the function **`limit`** that takes in three arguments: * **`arr`** (list of int): The input array of integers. * **`min_lim`** (int, optional): The minimum limit. If not provided (None), treat the minimum limit as the minimum value within the given array. * **`max_lim`** (int, optional): The maximum limit. If not provided (None), treat the maximum limit as the maximum value within the given array. The function should return a list containing only the elements that are within the range `[min_lim, max_lim]`, inclusive. Input Constraints: * The input array `arr` can have up to `10^6` elements. * Each element in the array `arr` is an integer within the range `[-10^6, 10^6]`. * `min_lim` and `max_lim` are integers within the same range, or can be `None`. Output: Return a list of integers representing the filtered array. Example: ```python assert limit([1, 2, 3, 4, 5], None, 3) == [1, 2, 3] assert limit([1, 2, 3, 4, 5], 2, 4) == [2, 3, 4] assert limit([-10, -5, 0, 5, 10], -3, 3) == [0] assert limit([], None, 3) == [] assert limit([100, 200, 300], 50, 150) == [100] ``` # Note: * Replacing `min_lim` and `max_lim` with actual minimum or maximum from the array should be done keeping in mind the potential of very large or very small numbers.","solution":"def limit(arr, min_lim=None, max_lim=None): Filters out elements of an integer array based on specified minimum and maximum limits. Args: arr (list of int): The input array of integers. min_lim (int, optional): The minimum limit. If not provided (None), treat the minimum limit as the minimum value within the given array. max_lim (int, optional): The maximum limit. If not provided (None), treat the maximum limit as the maximum value within the given array. Returns: list: A list containing only the elements that are within the range [min_lim, max_lim], inclusive. if not arr: return [] if min_lim is None: min_lim = min(arr) if max_lim is None: max_lim = max(arr) return [x for x in arr if min_lim <= x <= max_lim]"},{"question":"# Question: You are given a list of integers that represent scores in a game. Your goal is to sort the scores in non-decreasing order using the Pigeonhole Sort algorithm. Function Signature: ```python def pigeonhole_sort(arr: List[int]) -> List[int]: ``` Input: - `arr`: A list of integers, where the size of the list is `n` and elements are within a specific integer range `Range` such that `Range = max(arr) - min(arr) + 1`. Output: - Returns a sorted list of integers in non-decreasing order. Constraints: - `1 <= n <= 10^6` - `-10^6 <= arr[i] <= 10^6` (for all `0 <= i < n`) Example: ```python assert pigeonhole_sort([8, 3, 2, 7, 4]) == [2, 3, 4, 7, 8] assert pigeonhole_sort([1, 4, 1, 4, 1]) == [1, 1, 1, 4, 4] assert pigeonhole_sort([100, 2, 72, -50, 33]) == [-50, 2, 33, 72, 100] ``` Edge Cases to Consider: - An array with duplicate elements. - An empty array. - An array where all elements are the same. - An array with negative values. Use the Pigeonhole Sort algorithm described and make sure your function handles the edge cases correctly.","solution":"from typing import List def pigeonhole_sort(arr: List[int]) -> List[int]: if not arr: return arr min_val = min(arr) max_val = max(arr) Range = max_val - min_val + 1 holes = [0] * Range for number in arr: holes[number - min_val] += 1 sorted_arr = [] for index, count in enumerate(holes): if count > 0: sorted_arr.extend([index + min_val] * count) return sorted_arr"},{"question":"You are tasked with cloning an undirected graph. Each node in the graph contains a unique label and a list of its neighbors. The goal is to create an exact replica of the graph starting from a given node. # Function Signature: ```python def clone_graph(node: \'UndirectedGraphNode\') -> \'UndirectedGraphNode\': ``` # Input: * `node` (UndirectedGraphNode): The starting node of the graph to be cloned. # Output: * `UndirectedGraphNode`: The node corresponding to the cloned graph\'s starting node. # Constraints: * The graph may contain self-loops (a node pointing to itself). * The graph does not contain any cycles. * No two nodes in the graph have the same label. * The graph is connected. # Performance Requirements: * Ensure a time complexity of O(V + E) and a space complexity of O(V), where V is the number of vertices (nodes) and E is the number of edges. # Example: ```python # Define the graph: 0 -- 1 # / # 2 node0 = UndirectedGraphNode(0) node1 = UndirectedGraphNode(1) node2 = UndirectedGraphNode(2) node0.add_neighbor(node1) node0.add_neighbor(node2) node1.add_neighbor(node2) cloned_node0 = clone_graph(node0) # The returned cloned_node0 should represent a graph that is structurally identical # to the one that node0 represents. ``` # Description: Implement a function `clone_graph` that takes in the starting node of an undirected graph and returns a deep copy of the entire graph. You are required to use either a BFS or DFS approach for this task. Ensure that the cloned graph has the same labels and connectivity as the original. # Points to Consider: * Think about how you would store the mapping between original and cloned nodes. * Decide on whether you want to use BFS (iterative) or DFS (iterative/recursive) approach for the graph traversal. * Handle the special case where the input node is `None`. * Ensure the function is optimized and does not exceed memory bounds for large graphs.","solution":"class UndirectedGraphNode: def __init__(self, label): self.label = label self.neighbors = [] def add_neighbor(self, neighbor): self.neighbors.append(neighbor) def clone_graph(node: \'UndirectedGraphNode\') -> \'UndirectedGraphNode\': if not node: return None # Dictionary to store the mapping from original nodes to their clones node_map = {} # Recursive function to clone nodes def clone(node): if node in node_map: return node_map[node] clone_node = UndirectedGraphNode(node.label) node_map[node] = clone_node for neighbor in node.neighbors: clone_node.add_neighbor(clone(neighbor)) return clone_node return clone(node)"},{"question":"# Counting Digits in an Integer **Scenario**: You are working on a numerical analysis tool that quickly evaluates the properties of large datasets of integers. One of the fundamental operations needed is to determine how many digits each integer contains. Your task is to implement a highly efficient and reliable method to do so. Function Specification * **Function Name**: `count_digits` * **Input**: A single integer `n`, where `n` can be positive, negative, or zero. * **Output**: An integer representing the number of digits in `n`. Constraints * The function should handle any valid integer input. * The solution should aim for constant time complexity, O(1). * You may assume that input will always be a valid Python integer type. Example ```python assert count_digits(12345) == 5 assert count_digits(-678) == 3 assert count_digits(0) == 1 ``` Requirements: * You are to use principles from logarithms to efficiently determine the number of digits. * Do not use iteration or convert the number to a string.","solution":"import math def count_digits(n): Returns the number of digits in the integer n. if n == 0: return 1 # abs ensures negative numbers are treated the same as positive for counting digits return int(math.log10(abs(n))) + 1"},{"question":"# Question You are given a string `s` and you need to write a function to reverse the string. You need to provide implementations for the following approaches: Recursive, Iterative, and Pythonic. **Function Definitions:** ```python def reverse_recursive(s: str) -> str: # Your code here def reverse_iterative(s: str) -> str: # Your code here def reverse_pythonic(s: str) -> str: # Your code here ``` **Input Format:** - A string `s` (1 <= len(s) <= 10^6) **Output Format:** - A string which is the reversed version of input string `s`. **Constraints:** - The input string will consist only of printable ASCII characters. **Performance Requirements:** - The solutions should handle the maximum input size within reasonable time and memory limits. **Examples:** ```python # Example 1 input: \\"hello\\" output: \\"olleh\\" # Example 2 input: \\"world\\" output: \\"dlrow\\" # Example 3 input: \\"a\\" output: \\"a\\" ``` **Note:** - Make sure to handle edge cases such as empty strings. - The iterative and pythonic approaches should be as efficient as possible in both time and space complexity. - The recursive approach should handle the depth of recursion optimally without leading to stack overflow for maximum input sizes.","solution":"def reverse_recursive(s: str) -> str: Returns the reverse of the given string `s` using a recursive approach. if len(s) == 0: return s return reverse_recursive(s[1:]) + s[0] def reverse_iterative(s: str) -> str: Returns the reverse of the given string `s` using an iterative approach. result = [] for char in s: result.insert(0, char) return \'\'.join(result) def reverse_pythonic(s: str) -> str: Returns the reverse of the given string `s` using a pythonic approach. return s[::-1]"},{"question":"You are tasked with sorting a list of students\' scores in ascending order using a sorting algorithm discussed in class: Gnome Sort. Demonstrate your understanding of this algorithm by implementing the `gnome_sort` function. # Function Signature ```python def gnome_sort(arr: List[int]) -> List[int]: pass ``` # Input - A list of integers `arr` (1 ≤ len(arr) ≤ 1000) representing students\' scores. # Output - A list of integers `arr` sorted in ascending order. # Constraints - The input list can contain duplicate scores. - The input list can have elements in any order, including already sorted. # Example ```python assert gnome_sort([34, 2, 10, -9]) == [-9, 2, 10, 34] assert gnome_sort([1, 1, 1, 1]) == [1, 1, 1, 1] assert gnome_sort([]) == [] ``` # Requirements - Implement Gnome Sort directly and do not use any built-in sorting functions or other sorting algorithms. - Ensure the solution handles edge cases efficiently (e.g., empty list, all elements the same, etc.). # Hint Gnome Sort is an efficient algorithm for small lists and works similarly to insertion sort but is easier to implement. Focus on the condition to swap elements and moving the index backward when necessary.","solution":"def gnome_sort(arr): Sorts a list of integers in ascending order using Gnome Sort algorithm. Parameters: arr (List[int]): List of integers to be sorted. Returns: List[int]: Sorted list of integers. index = 0 while index < len(arr): if index == 0 or arr[index] >= arr[index - 1]: index += 1 else: arr[index], arr[index - 1] = arr[index - 1], arr[index] index -= 1 return arr"},{"question":"# Question You are given a stack and a task to duplicate each element within it. Implement two functions, `duplicate_with_stack` and `duplicate_with_queue`, each achieving the objective but using different auxiliary data structures as specified. Requirements: 1. **duplicate_with_stack** should use an auxiliary stack. 2. **duplicate_with_queue** should use an auxiliary queue (deque). # Function Signature: ```python def duplicate_with_stack(stack: list) -> list: # Your code goes here def duplicate_with_queue(stack: list) -> list: # Your code goes here ``` # Input: - Each function accepts one parameter, `stack`: - `stack` (list of integers): The stack to be operated on, where `stack[-1]` is the top of the stack. # Output: - Each function should return the modified stack with each element duplicated. # Example: ```python stack = [3, 7, 1, 14, 9] print(duplicate_with_stack(stack)) # Expected Output: [3, 3, 7, 7, 1, 1, 14, 14, 9, 9] print(duplicate_with_queue(stack)) # Expected Output: [3, 3, 7, 7, 1, 1, 14, 14, 9, 9] ``` # Constraints: - You may assume that the input stack has a size within 0 to 10^4. - You should manage and handle edge cases such as an empty stack. # Performance: - The solution should leverage auxiliary space as specified (either stack or queue) but should be efficient in time complexity, striving for O(n) performance.","solution":"def duplicate_with_stack(stack: list) -> list: Duplicates each element in the stack using an auxiliary stack. auxiliary_stack = [] original_size = len(stack) # Transfer all elements to auxiliary stack to reverse the order for _ in range(original_size): auxiliary_stack.append(stack.pop()) # Reinsert each element twice back to the original stack while auxiliary_stack: element = auxiliary_stack.pop() stack.append(element) stack.append(element) return stack def duplicate_with_queue(stack: list) -> list: Duplicates each element in the stack using an auxiliary queue (deque). from collections import deque queue = deque() # Transfer all elements to the queue to reverse the order while stack: queue.appendleft(stack.pop()) # Reinsert each element twice back to the original stack while queue: element = queue.popleft() stack.append(element) stack.append(element) return stack"},{"question":"You are tasked with improving the efficiency of an algorithm that removes duplicates from an array. Given an array, your goal is to return a new array with all duplicate elements removed while preserving the original order of elements. # Instructions - Implement the function `remove_duplicates_optimized(array)` which takes in an array and returns a new array with duplicates removed. - Optimize your function to handle larger datasets efficiently. - Your solution should handle mixed data types in the array (integers, floats, strings, and booleans). # Input - An array `array` of length `n` (0 ≤ n ≤ 10^5) containing integers, floating-point numbers, strings, and boolean values. # Output - Return a new array with duplicates removed, maintaining the original order of elements. # Constraints - Elements are considered duplicates if they have the same value and data type. - Python\'s built-in `set` cannot be used directly for tracking duplicates while preserving order. # Example ```python Input: [1, 1, 1, 2, 2, 3, 4, 4, \\"hey\\", \\"hey\\", \\"hello\\", True, True] Output: [1, 2, 3, 4, \'hey\', \'hello\', True] Input: [1, 2, \'1\', \'2\', 2, \'2\'] Output: [1, 2, \'1\', \'2\'] ``` # Additional Notes - Consider edge cases such as empty arrays, arrays with all elements being the same, and arrays with mixed data types.","solution":"def remove_duplicates_optimized(array): Remove duplicates from the array while preserving the original order of elements. Args: array (list): A list containing integers, floats, strings, and boolean values. Returns: list: A new list with duplicates removed, maintaining the original order of elements. seen = set() result = [] for item in array: if (item, type(item)) not in seen: seen.add((item, type(item))) result.append(item) return result"},{"question":"# Question **Context**: You are tasked to evaluate your comprehension of graph algorithms by implementing Prim\'s algorithm to find the minimum spanning tree (MST) of a given connected, weighted, undirected graph. The graph is represented as a dictionary where each key is a node, and its value is a list of lists. Each list represents an edge with its corresponding weight and the adjacent node. **Task**: Implement a function `find_mst_weight(graph)`, which receives a dictionary representing a graph and returns the total weight of the MST. **Function Signature**: ```python def find_mst_weight(graph: Dict[int, List[List[int]]]) -> int: pass ``` **Input**: * `graph`: A dictionary where keys are node identifiers (integers or strings), and values are lists of lists. Each list contains two elements: the weight of the edge (an integer) and the adjacent node. * The graph is guaranteed to be connected and undirected. **Output**: * The function returns a single integer: the total weight of the MST. **Constraints**: * The graph will have at least one node and all edge weights will be non-negative integers. **Example**: ```python graph = { 0: [[3, 1], [8, 2]], 1: [[3, 0], [5, 3]], 2: [[8, 0], [2, 3], [4, 4]], 3: [[5, 1], [2, 2], [6, 4]], 4: [[4, 2], [6, 3]] } assert find_mst_weight(graph) == 14 ``` The function should compute the weight of the MST, which in this example is 14.","solution":"import heapq def find_mst_weight(graph): Finds the weight of the minimum spanning tree (MST) using Prim\'s algorithm. Args: graph (dict): The input graph represented as a dictionary. Keys are node identifiers, and values are lists of lists. Each inner list contains [weight, adjacent_node]. Returns: int: The total weight of the MST. if not graph: return 0 start_node = list(graph.keys())[0] # Start from any node visited = set() min_heap = [(0, start_node)] # (weight, node) total_weight = 0 while min_heap: weight, node = heapq.heappop(min_heap) if node in visited: continue visited.add(node) total_weight += weight for edge_weight, adj_node in graph[node]: if adj_node not in visited: heapq.heappush(min_heap, (edge_weight, adj_node)) return total_weight"},{"question":"Problem Statement Given a square matrix `mat` of size ( n times n ) and an integer `exp`, write a function `power_matrix(mat: List[List[int]], exp: int) -> List[List[int]]` that returns the matrix raised to the power of `exp`. # Input - A square matrix `mat` of size ( n times n ), where ( 1 leq n leq 100 ). - An integer `exp`, where ( 0 leq exp leq 10^9 ). # Output - A list of lists representing the matrix `mat` raised to the power of `exp`. # Constraints - Your solution should be efficient enough to handle the upper limits of ( n ) and `exp`. # Examples ```python # Example 1 mat = [ [1, 2], [3, 4] ] exp = 2 result = power_matrix(mat, exp) # Expected output: [[7, 10], [15, 22]] # Example 2 mat = [ [2, 0], [0, 2] ] exp = 5 result = power_matrix(mat, exp) # Expected output: [[32, 0], [0, 32]] # Example 3 mat = [ [1, 1], [1, 0] ] exp = 10 result = power_matrix(mat, exp) # Expected output: [[89, 55], [55, 34]] ``` # Function Signature ```python from typing import List def power_matrix(mat: List[List[int]], exp: int) -> List[List[int]]: # Write your implementation here pass ``` # Notes - You may assume all matrix entries are integers. - The result should be computed using efficient matrix exponentiation by repeated squaring as discussed in the analysis. - Take special care for edge cases, e.g., when `exp = 0`, the result should be the identity matrix of the same dimension as `mat`.","solution":"from typing import List def multiply_matrices(A: List[List[int]], B: List[List[int]]) -> List[List[int]]: n = len(A) result = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): for k in range(n): result[i][j] += A[i][k] * B[k][j] return result def identity_matrix(size: int) -> List[List[int]]: I = [[0] * size for _ in range(size)] for i in range(size): I[i][i] = 1 return I def power_matrix(mat: List[List[int]], exp: int) -> List[List[int]]: n = len(mat) result = identity_matrix(n) base = mat while exp > 0: if exp % 2 == 1: result = multiply_matrices(result, base) base = multiply_matrices(base, base) exp //= 2 return result"},{"question":"# Question: Bitwise Array Sum Context You are working on a low-level system programming task where you need to perform additions without using the arithmetic \'+\' operator. Let\'s extend this need to an array of numbers instead of just two integers. Task Write a function `sum_array_bitwise(arr)` that takes an array of non-negative integers and returns their sum using bitwise operations. Input Format * An integer array `arr` of length `n` (1 <= n <= 10^5), where each element is a non-negative integer, 0 <= arr[i] <= 10^9. Output Format * A single integer which is the sum of all integers in the array. Constraints * You cannot use any arithmetic `+` operator for summation. * You must handle large inputs efficiently in terms of both time and space complexity. Function Signature ```python def sum_array_bitwise(arr: list) -> int: # Your implementation here ``` Example **Input** ```python arr = [1, 2, 3, 4, 5] ``` **Output** ```python 15 ``` **Explanation** The sum of the array elements [1, 2, 3, 4, 5] is 15 using bitwise operations for addition.","solution":"def bitwise_add(a, b): Helper function to add two integers using bitwise operations. while b != 0: carry = a & b a = a ^ b b = carry << 1 return a def sum_array_bitwise(arr): Returns the sum of the elements in array `arr` using bitwise operations. total = 0 for num in arr: total = bitwise_add(total, num) return total"},{"question":"# Question: Enhanced Randomized Set Design an enhanced data structure `EnhancedRandomizedSet` that supports insertion, deletion, and returning a random element, all in average O(1) time. Additionally, implement the following functionality: 1. `get_random_three()` - Returns three distinct random elements from the set, each with an equal probability of being chosen. If there are fewer than three elements, return all elements present. 2. `is_present(val)` - Checks if a value is present in the set. Function Signatures ```python class EnhancedRandomizedSet: def __init__(self): pass def insert(self, new_one): pass def remove(self, old_one): pass def random_element(self): pass def get_random_three(self): pass def is_present(self, val): pass ``` # Input/Output Format - `insert(val)`: Inserts `val` into the set. Returns `True` if the element was inserted, `False` otherwise. - `remove(val)`: Removes `val` from the set. Returns `True` if the element was successfully removed, `False` otherwise. - `random_element()`: Returns a random element from the set. Raises an exception or returns a specific value if the set is empty. - `get_random_three()`: Returns a list of three random distinct elements from the set. If fewer than three elements exist, return all of them. - `is_present(val)`: Returns `True` if `val` is present in the set, `False` otherwise. # Constraints - Elements inserted will be integers. - The set should handle up to 10^6 elements efficiently. # Performance Expectations - Ensure all operations are on average O(1) in time complexity. - Handle empty sets and edge cases appropriately. # Example Usage ```python rset = EnhancedRandomizedSet() print(rset.insert(10)) # True (inserts 10) print(rset.insert(20)) # True (inserts 20) print(rset.is_present(10)) # True (10 is present) print(rset.is_present(30)) # False (30 is not present) print(rset.remove(10)) # True (removes 10) print(rset.remove(30)) # False (30 not present) print(rset.random_element()) # Could return 20 print(rset.get_random_three()) # If only 1 element present, e.g., [20] # Insert more elements for i in range(5): rset.insert(i) print(rset.get_random_three()) # Returns 3 distinct random elements from the set ``` # Notes - Ensure your implementation is robust to handle edge scenarios, such as duplicate insertions and deletions of non-existent elements. - If the set has fewer than three elements, return all elements in the set for `get_random_three()`.","solution":"import random class EnhancedRandomizedSet: def __init__(self): self.elem_map = {} self.elem_list = [] def insert(self, val): if val in self.elem_map: return False self.elem_map[val] = len(self.elem_list) self.elem_list.append(val) return True def remove(self, val): if val not in self.elem_map: return False index = self.elem_map[val] last_elem = self.elem_list[-1] self.elem_list[index] = last_elem self.elem_map[last_elem] = index self.elem_list.pop() del self.elem_map[val] return True def random_element(self): if not self.elem_list: raise Exception(\\"Set is empty\\") return random.choice(self.elem_list) def get_random_three(self): if len(self.elem_list) < 3: return self.elem_list[:] return random.sample(self.elem_list, 3) def is_present(self, val): return val in self.elem_map"},{"question":"Merge K Sorted Linked Lists Given `k` sorted linked lists, merge them into one sorted linked list and return it. **Function Signature**: ```python class Node: def __init__(self, x): self.val = x self.next = None def merge_k_sorted_lists(lists: List[Node]) -> Node: pass ``` **Input**: * `lists`: A list of `k` `Node` objects, each representing the head of a sorted linked list. **Output**: * A single `Node` which is the head of the merged sorted linked list. **Constraints**: * The total number of nodes across all `k` lists will not exceed `10^4`. * Each sorted linked list\'s length is between `[0, 200]`. **Example**: ```text Input: 1->4->5, 1->3->4, 2->6 Output: 1->1->2->3->4->4->5->6 Input: [], [], [] Output: ``` **Performance Requirements**: * The solution should be optimized for both time and space complexity, ideally targeting a complexity of O(N log k) where N is the total number of nodes. # Scenario Imagine a system merging log files from multiple servers, each producing a sorted log list, into a single chronological log sequence. Implement this function to support efficient log merging, ensuring minimal memory usage and handling edge cases, such as empty log lists or highly imbalanced log volumes.","solution":"import heapq from typing import List class Node: def __init__(self, x): self.val = x self.next = None def __lt__(self, other): return self.val < other.val def merge_k_sorted_lists(lists: List[Node]) -> Node: min_heap = [] dummy = Node(0) current = dummy # Initialize the heap with the head of each list for node in lists: if node: heapq.heappush(min_heap, node) while min_heap: smallest_node = heapq.heappop(min_heap) current.next = smallest_node current = current.next if smallest_node.next: heapq.heappush(min_heap, smallest_node.next) return dummy.next"},{"question":"# Recursive Binomial Coefficient Calculation Imagine you are working on a project that involves a lot of combinatorial calculations. One common requirement is to find the number of ways to select k items from a collection of n items. This is known as the binomial coefficient, often denoted as C(n, k). Your task is to write a function that efficiently computes this value using recursion, leveraging mathematical properties to optimize the calculation. **Function Signature:** ```python def recursive_binomial_coefficient(n: int, k: int) -> int: pass ``` Input - `n` (integer): The total number of items, where 0 <= n <= 10^18. - `k` (integer): The number of items to select, where 0 <= k <= n. Output - Returns an integer representing the binomial coefficient C(n, k). Constraints - Avoid stack overflow by ensuring that recursive calls are optimized. - Ensure the function is efficient in terms of both time and space. Example ```python assert recursive_binomial_coefficient(5, 0) == 1 assert recursive_binomial_coefficient(8, 2) == 28 assert recursive_binomial_coefficient(500, 300) == 5054949849935535817667719165973249533761635252733275327088189563256013971725761702359997954491403585396607971745777019273390505201262259748208640 ``` Notes - Ensure to handle edge cases where inputs may be invalid (e.g., n < k) by raising a `ValueError`. - You may use internal properties like C(n, k) == C(n, n - k) to minimize the depth of the recursive call stack. - Consider the base cases in your recursion effectively to simplify the implementation.","solution":"def recursive_binomial_coefficient(n: int, k: int) -> int: if k < 0 or n < k: raise ValueError(\\"Invalid values for n and k. Ensure 0 <= k <= n.\\") # Improve efficiency using symmetry property: C(n, k) == C(n, n - k) if k > n - k: k = n - k # Base cases if k == 0 or k == n: return 1 # Recursive Definition: C(n, k) = C(n-1, k-1) + C(n-1, k) return recursive_binomial_coefficient(n - 1, k - 1) + recursive_binomial_coefficient(n - 1, k)"},{"question":"You are tasked with designing a data structure that supports common operations of a set with additional functionality to retrieve a random element in constant time. Implement the `RandomizedSet` class with the following methods: 1. `insert(val: int) -> bool`: Inserts an integer `val` into the set. Returns `True` if the element was successfully inserted, and `False` if it was already present. 2. `remove(val: int) -> bool`: Removes an integer `val` from the set. Returns `True` if the element was successfully removed, and `False` if it was not present. 3. `get_random() -> int`: Returns a random element from the set. Each element must have the same probability of being picked. # Requirements - **Input/Output**: - `insert(val: int) -> bool`: Takes an integer `val` and returns a boolean. - `remove(val: int) -> bool`: Takes an integer `val` and returns a boolean. - `get_random() -> int`: Returns an integer. - **Constraints**: - The functions should run in average O(1) time complexity. - The number of calls to `insert`, `remove`, and `get_random` will not exceed 10^4. # Example ```python rs = RandomizedSet() print(rs.insert(1)) # True print(rs.insert(2)) # True print(rs.insert(3)) # True print(rs.insert(2)) # False print(rs.remove(2)) # True print(rs.remove(2)) # False print(rs.get_random()) # Randomly returns 1 or 3 print(rs.get_random()) # Randomly returns 1 or 3 print(rs.insert(4)) # True print(rs.get_random()) # Randomly returns 1, 3 or 4 ``` # Notes - Ensure that the `get_random` method provides uniformly distributed random elements. - The set should handle edge cases such as inserting an already present element, removing an absent element, and calling `get_random` on an empty set gracefully. Implement the `RandomizedSet` class based on the above specifications.","solution":"from random import choice class RandomizedSet: def __init__(self): Initialize data structure. self.dict = {} self.list = [] def insert(self, val: int) -> bool: Insert value into the set. if val in self.dict: return False self.dict[val] = len(self.list) self.list.append(val) return True def remove(self, val: int) -> bool: Remove value from the set. if val not in self.dict: return False # Move the last element to the place of the element to remove last_element = self.list[-1] idx_to_remove = self.dict[val] self.list[idx_to_remove] = last_element self.dict[last_element] = idx_to_remove # Remove the last element self.list.pop() del self.dict[val] return True def get_random(self) -> int: Get a random element from the set. return choice(self.list)"},{"question":"# Reverse String Implementations Problem Statement You are given four functions that reverse a string using different methods. Your task is to write a function that combines the advantages of iterative and Pythonic approaches to reverse a string efficiently both in terms of time and space. Implement a function: ```python def efficient_reverse(s: str) -> str: # Your code here ``` Input - A single string `s` which consists of printable ASCII characters. The string length `n` will be such that `1 <= n <= 10^5`. Output - Return the reverse of the string `s`. Constraints 1. You should not use the slicing technique (`s[::-1]` or similar). 2. The solution should be efficient in both time (O(n)) and space (O(n)) complexities. Performance Requirements - The solution must handle large inputs (up to 100,000 characters) within reasonable time limits. Example ```python efficient_reverse(\\"hello\\") # should return \\"olleh\\" efficient_reverse(\\"A man, a plan, a canal: Panama\\") # should return \\"amanaP :lanac a ,nalp a ,nam A\\" efficient_reverse(\\"\\") # should return \\"\\" efficient_reverse(\\"x\\") # should return \\"x\\" ```","solution":"def efficient_reverse(s: str) -> str: # Using a list to collect the characters in reverse order and join them reversed_chars = [] for char in s: reversed_chars.insert(0, char) return \'\'.join(reversed_chars)"},{"question":"# Segment Tree Optimization and Extension You are given a segment tree that efficiently supports range queries on an array. The current implementation supports basic range queries using a given query function (like sum or max). Your task is to extend this implementation to support point updates. Additionally, you are required to optimize the segment tree to handle large arrays efficiently with lazy propagation for range updates. # Steps to Follow: 1. Implement the `update` method to support point updates. 2. Implement lazy propagation to optimize the segment tree for range updates. 3. Modify the `query` method to account for the lazily updated values. # Function Signatures: ```python class SegmentTree: def __init__(self, arr, function): Initialize the segment tree with an array and a function (e.g., sum, max). def make_tree(self, i, l, r): Build the tree based on the initial array. def __query(self, i, L, R, lRange, rRange): Internal method for range query, required to be extended for lazy propagation. def query(self, L, R): Public method to perform a range query on the segment tree. def point_update(self, index, value): Update an element of the array at the given index to a new value and adjust the segment tree accordingly. def range_update(self, lRange, rRange, delta): Update all elements in the given range by adding \'delta\' and adjust the segment tree accordingly. Use lazy propagation for efficient updates. ``` # Expected Behavior and Constraints: - **Input Format**: - The constructor initializes with an array and a function (e.g., sum or max). - The `query(L, R)` method returns the result of the function applied to the range [L, R] of the array. - The `point_update(index, value)` method updates the element at the specified index to the new value. - The `range_update(lRange, rRange, delta)` method adds delta to all elements in the range [lRange, rRange]. - **Output Format**: - The respective operations must reflect correct results based on the segment tree logic. # Example: ```python arr = [2, 4, 5, 3, 4] mytree = SegmentTree(arr, sum) print(mytree.query(1, 3)) # Output: 12 mytree.point_update(2, 10) print(mytree.query(1, 3)) # Output: 17 mytree.range_update(1, 3, 5) print(mytree.query(1, 3)) # Output: 32 ```","solution":"class SegmentTree: def __init__(self, arr, function): self.arr = arr self.n = len(arr) self.function = function self.tree = [0] * (4 * self.n) self.lazy = [0] * (4 * self.n) self.build_tree(0, 0, self.n - 1) def build_tree(self, i, l, r): if l == r: self.tree[i] = self.arr[l] else: mid = (l + r) // 2 self.build_tree(2 * i + 1, l, mid) self.build_tree(2 * i + 2, mid + 1, r) self.tree[i] = self.function(self.tree[2 * i + 1], self.tree[2 * i + 2]) def __apply_lazy(self, node, start, end): if self.lazy[node] != 0: self.tree[node] += (end - start + 1) * self.lazy[node] if start != end: self.lazy[2 * node + 1] += self.lazy[node] self.lazy[2 * node + 2] += self.lazy[node] self.lazy[node] = 0 def __range_update(self, node, start, end, lRange, rRange, delta): self.__apply_lazy(node, start, end) if start > end or start > rRange or end < lRange: return if start >= lRange and end <= rRange: self.tree[node] += (end - start + 1) * delta if start != end: self.lazy[2 * node + 1] += delta self.lazy[2 * node + 2] += delta return mid = (start + end) // 2 self.__range_update(2 * node + 1, start, mid, lRange, rRange, delta) self.__range_update(2 * node + 2, mid + 1, end, lRange, rRange, delta) self.tree[node] = self.function(self.tree[2 * node + 1], self.tree[2 * node + 2]) def range_update(self, lRange, rRange, delta): self.__range_update(0, 0, self.n - 1, lRange, rRange, delta) def __query(self, node, start, end, lRange, rRange): self.__apply_lazy(node, start, end) if start > end or start > rRange or end < lRange: return 0 if start >= lRange and end <= rRange: return self.tree[node] mid = (start + end) // 2 left_query = self.__query(2 * node + 1, start, mid, lRange, rRange) right_query = self.__query(2 * node + 2, mid + 1, end, lRange, rRange) return self.function(left_query, right_query) def query(self, L, R): return self.__query(0, 0, self.n - 1, L, R) def point_update(self, index, value): def __point_update(node, start, end, idx, val): self.__apply_lazy(node, start, end) if start == end: self.tree[node] = val else: mid = (start + end) // 2 if start <= idx <= mid: __point_update(2 * node + 1, start, mid, idx, val) else: __point_update(2 * node + 2, mid + 1, end, idx, val) self.tree[node] = self.function(self.tree[2 * node + 1], self.tree[2 * node + 2]) __point_update(0, 0, self.n - 1, index, value)"},{"question":"# Matrix Manipulation Challenge **Objective**: Implement a function to rotate a given n x m matrix 180 degrees in both clockwise and counterclockwise directions. **Function Signature**: ```python def rotate_180(matrix, direction): pass ``` **Parameters**: - `matrix` (list of lists of integers): A matrix represented as a list of lists where each sublist is a row. - `direction` (string): Either \\"clockwise\\" or \\"counterclockwise\\", specifying the direction of the 180-degree rotation. **Returns**: - A new matrix (list of lists of integers) which is the original matrix rotated by 180 degrees in the specified direction. **Description**: - If `direction` is \\"clockwise\\", rotate the matrix by 180 degrees clockwise. - If `direction` is \\"counterclockwise\\", rotate the matrix by 180 degrees counterclockwise. **Performance Requirements**: - The function should run in (O(n times m)) time complexity. - The function should use (O(n times m)) additional space complexity. **Constraints**: - The matrix will contain at least 1 element and no more than 10^4 elements. - Each sublist (row) in the matrix will have the same length. **Examples**: ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9], ] rotate_180(matrix, \\"clockwise\\") # Output: [ # [9, 8, 7], # [6, 5, 4], # [3, 2, 1] # ] rotate_180(matrix, \\"counterclockwise\\") # Output: [ # [9, 8, 7], # [6, 5, 4], # [3, 2, 1] # ] ``` **Notes**: - Regardless of the direction parameter, the 180-degree rotation results in the same output. - Make sure to handle and test with edge cases like 1x1 matrix and rectangular matrices (e.g., 2x3 or 3x2). Good luck!","solution":"def rotate_180(matrix, direction): Rotate a given matrix by 180 degrees in either clockwise or counterclockwise direction. :param matrix: List of lists where each sublist is a row. :param direction: Either \\"clockwise\\" or \\"counterclockwise\\", specifying the direction of the 180-degree rotation. :return: A new matrix which is the original matrix rotated by 180 degrees. # Rotate the matrix 180 degrees rotated_matrix = [row[::-1] for row in matrix[::-1]] return rotated_matrix"},{"question":"You are given the geometric information of several buildings in a city, represented as a list of triplets. Each triplet represents a building with its left and right x-coordinates and its height: ([L_i, R_i, H_i]). Your task is to compute the skyline formed by these buildings. # Input - A list of buildings where each building is represented as a triplet ([L_i, R_i, H_i]). - (0 leq L_i, R_i leq text{INT_MAX}) - (0 < H_i leq text{INT_MAX}) - (R_i - L_i > 0) # Output - A list of key points forming the skyline. Each key point is represented as ([x, y]) where (x) is the x-coordinate and (y) is the height of the skyline at that point. The output list should be sorted by the x-coordinate. Key points should be minimal such that there are no consecutive points with the same height. For example, ([...[2, 3], [4, 5], [7, 5]...]) should be merged into ([...[2, 3], [4, 5], [7, 5]...]. # Example Given the input: ``` buildings = [ [2, 9, 10], [3, 7, 15], [5, 12, 12], [15, 20, 10], [19, 24, 8] ] ``` The output should be: ``` [[2, 10], [3, 15], [7, 12], [12, 0], [15, 10], [20, 8], [24, 0]] ``` # Constraints - The number of buildings is in the range ([0, 10000]). - The input list is already sorted in ascending order by the left x position (L_i). - Each key point should correspond to either the start or the end of a building\'s height change. # Notes: - The ground between any two adjacent buildings should be considered part of the skyline contour. - There should be no consecutive horizontal lines of equal height in the output skyline. # Function Signature ```python def get_skyline(buildings: List[List[int]]) -> List[List[int]]: # Your implementation here ```","solution":"import heapq def get_skyline(buildings): Compute the skyline formed by the given list of buildings. Parameters: - buildings: List[List[int]] - A list of buildings where each building is represented as a triplet [Li, Ri, Hi]. Returns: - List[List[int]] - A list of key points forming the skyline. events = [] # Create events for both the start and end of each building for L, R, H in buildings: events.append((L, -H, R)) # start of a building events.append((R, 0, 0)) # end of a building # Sort events. First by x, then by height (negative height for starts, 0 for ends) events.sort() # Result and Priority Queue (heap) result = [[0, 0]] heap = [(0, float(\\"inf\\"))] # (negative height, ending position) # Process events for x, negH, R in events: while heap[0][1] <= x: heapq.heappop(heap) if negH != 0: heapq.heappush(heap, (negH, R)) maxH = -heap[0][0] if result[-1][1] != maxH: result.append([x, maxH]) return result[1:]"},{"question":"You are given two strings, `text` and `pattern`. Your task is to implement a function `find_first_occurrence` which uses the Rabin-Karp algorithm to find the first occurrence of the `pattern` in the `text`. If the pattern is found, return the index of the first occurrence; if not, return -1. # Function Signature ```python def find_first_occurrence(text: str, pattern: str) -> int: ``` # Input - `text`: A string in which to search for the pattern. (1 <= len(text) <= 10^5) - `pattern`: A string to be searched within the text. (1 <= len(pattern) <= 10^4) # Output - The index of the first occurrence of the pattern in the text if found, otherwise -1. # Constraints - Both `text` and `pattern` will contain only lowercase English letters. # Examples ```python assert find_first_occurrence(\\"hello world\\", \\"world\\") == 6 assert find_first_occurrence(\\"abracadabra\\", \\"cad\\") == 4 assert find_first_occurrence(\\"abcabcabc\\", \\"cab\\") == 2 assert find_first_occurrence(\\"abcdef\\", \\"gh\\") == -1 assert find_first_occurrence(\\"searchinhaystack\\", \\"needle\\") == -1 assert find_first_occurrence(\\"thisisatest\\", \\"\\") == -1 assert find_first_occurrence(\\"\\", \\"pattern\\") == -1 assert find_first_occurrence(\\"text\\", \\"texttext\\") == -1 ``` # Explanation 1. In the first example, the pattern \\"world\\" is found at index 6. 2. In the second example, the pattern \\"cad\\" is found at index 4. 3. In the third example, the pattern \\"cab\\" is found at index 2. 4. In the fourth example, the pattern \\"gh\\" is not found in the text, so the function returns -1. 5. Similarly in the last two examples, the conditions for empty string and pattern greater than text length return -1. # Notes Make sure your implementation utilizes the rolling hash mechanism as described in the Rabin-Karp algorithm to achieve efficient string searching.","solution":"def find_first_occurrence(text: str, pattern: str) -> int: Uses the Rabin-Karp algorithm to find the first occurrence of the pattern in the text. Returns the index of the first occurrence of the pattern in the text if found, otherwise -1. if len(pattern) == 0 or len(pattern) > len(text): return -1 # Define a prime number to be used for the hash function prime = 101 # Function to calculate hash value of a string def calculate_hash(s, length, prime): hash_val = 0 for i in range(length): hash_val = (hash_val * 256 + ord(s[i])) % prime return hash_val # Precompute the power of 256 used in rolling hash (256^(pattern_len-1) % prime) pattern_len = len(pattern) text_len = len(text) high_order = 1 # This is 256^(pattern_len-1) for _ in range(pattern_len - 1): high_order = (high_order * 256) % prime # Calculate initial hash values of the pattern and first window of the text pattern_hash = calculate_hash(pattern, pattern_len, prime) text_hash = calculate_hash(text, pattern_len, prime) # Slide the window over text one character at a time for i in range(text_len - pattern_len + 1): if pattern_hash == text_hash: # If the hashes match, then only check the characters one by one if text[i:i+pattern_len] == pattern: return i # Compute hash of the next window by removing leading char and adding trailing char if i < text_len - pattern_len: text_hash = (text_hash - ord(text[i]) * high_order) % prime text_hash = (text_hash * 256 + ord(text[i + pattern_len])) % prime # We might get negative value of text_hash, converting it to positive if text_hash < 0: text_hash = text_hash + prime # Pattern not found return -1"},{"question":"# Question: Implementing Detailed File Path Resolution You are required to implement a function that transforms a given file or directory path to its absolute path with additional error handling and optimization. Given a list of file paths, your function should provide detailed verification, handle different types of invalid or edge case paths gracefully, and ensure the absolute paths are cached for repeated lookups. # Implementation Details: - **Function Signature**: `def enhanced_full_paths(paths: List[str]) -> List[str]:` - **Input**: - `paths`: A list of file or directory paths as strings. Paths can be absolute or relative, including special shortcuts like user home (`~`). - **Output**: - A list of absolute paths as strings corresponding to each input path or error messages for paths that couldn\'t be resolved. # Constraints: - You must handle cases where a path does not exist, returning an appropriate message such as `\\"Path does not exist: <input_path>\\"`. - Handle cases where the input path is an empty string or contains only whitespace, returning `\\"Invalid path: <input_path>\\"`. - Ensure that the resolution performance is optimized for repeated lookups by implementing caching. # Example Usage: ```python input_paths = [\\"~/Documents\\", \\"invalid_path\\", \\"\\", \\"relative/path/to/file\\"] output = enhanced_full_paths(input_paths) print(output) ``` Expected output could be something like: ``` [ \\"/home/user/Documents\\", \\"Path does not exist: invalid_path\\", \\"Invalid path: \\", \\"/home/user/relative/path/to/file\\" ] ``` # Additional Requirements: - Utilize Python\'s `os` module functionalities like `os.path.abspath` and `os.path.expanduser`. - You may use any data structure for caching paths but ensure it maintains performance efficiency.","solution":"import os from typing import List def enhanced_full_paths(paths: List[str]) -> List[str]: cache = {} def resolve_path(path: str) -> str: if path in cache: return cache[path] if not path or path.strip() == \\"\\": resolved_path = f\\"Invalid path: {path}\\" else: expanded_path = os.path.expanduser(path) absolute_path = os.path.abspath(expanded_path) if os.path.exists(absolute_path): resolved_path = absolute_path else: resolved_path = f\\"Path does not exist: {path}\\" cache[path] = resolved_path return resolved_path return [resolve_path(p) for p in paths]"},{"question":"Context: You are tasked with managing a priority queue system, which will handle job executions based on their priorities. Using a binary min-heap, implement the following functionality: Inserting a new job with a specific priority and removing the job with the highest priority (the root of the heap). Task Description: Complete the implementation of the `JobPriorityQueue` class with the following methods: 1. **`insert_job(priority: int) -> None`**: Inserts a new job with the given priority into the priority queue. 2. **`remove_highest_priority_job() -> int`**: Removes and returns the priority value of the job with the highest priority (minimum value). Requirements: 1. You should use the provided heap template and expand upon it. 2. Handle edge cases like trying to remove from an empty heap. 3. Maintain a min-heap property at all times. Input and Output: * **`insert_job(priority: int) -> None`** * **Input**: An integer `priority` representing the priority of the job. * **Output**: None * **`remove_highest_priority_job() -> int`** * **Output**: An integer representing the priority of the removed job. * **Constraints**: * Priorities will be non-negative integers. * It is guaranteed that `remove_highest_priority_job` will only be called on a non-empty heap. Example ```python # Example of usage queue = JobPriorityQueue() queue.insert_job(4) queue.insert_job(7) queue.insert_job(50) queue.insert_job(2) print(queue.remove_highest_priority_job()) # Outputs: 2 print(queue.remove_highest_priority_job()) # Outputs: 4 ``` Implement the `JobPriorityQueue` class based on the above requirements. Given Template: ```python class JobPriorityQueue(AbstractHeap): def __init__(self): self.current_size = 0 self.heap = [0] def perc_up(self, i): while i // 2 > 0: if self.heap[i] < self.heap[i // 2]: self.heap[i], self.heap[i // 2] = self.heap[i // 2], self.heap[i] i = i // 2 def perc_down(self, i): while (i * 2) <= self.current_size: mc = self.min_child(i) if self.heap[i] > self.heap[mc]: self.heap[i], self.heap[mc] = self.heap[mc], self.heap[i] i = mc def min_child(self, i): if (i * 2 + 1) > self.current_size: return i * 2 else: if self.heap[i*2] < self.heap[i*2+1]: return i*2 else: return i*2+1 def insert_job(self, priority): self.heap.append(priority) self.current_size = self.current_size + 1 self.perc_up(self.current_size) def remove_highest_priority_job(self): ret_val = self.heap[1] self.heap[1] = self.heap[self.current_size] self.current_size = self.current_size - 1 self.heap.pop() self.perc_down(1) return ret_val ```","solution":"class JobPriorityQueue: def __init__(self): self.current_size = 0 self.heap = [0] # Initialize heap with a placeholder at index 0 def perc_up(self, i): while i // 2 > 0: if self.heap[i] < self.heap[i // 2]: self.heap[i], self.heap[i // 2] = self.heap[i // 2], self.heap[i] i = i // 2 def perc_down(self, i): while (i * 2) <= self.current_size: mc = self.min_child(i) if self.heap[i] > self.heap[mc]: self.heap[i], self.heap[mc] = self.heap[mc], self.heap[i] i = mc def min_child(self, i): if (i * 2 + 1) > self.current_size: return i * 2 else: if self.heap[i * 2] < self.heap[i * 2 + 1]: return i * 2 else: return i * 2 + 1 def insert_job(self, priority): self.heap.append(priority) self.current_size += 1 self.perc_up(self.current_size) def remove_highest_priority_job(self): root = self.heap[1] self.heap[1] = self.heap[self.current_size] self.current_size -= 1 self.heap.pop() self.perc_down(1) return root"},{"question":"Counting Connected Components in a Grid In a given N x M grid, each cell can either be water (0) or land (1). Initially, all cells are water. You will be given a list of positions where land is added sequentially. Your task is to implement a function `count_islands` that keeps track of the number of islands after each addition. An island is formed by connecting adjacent lands horizontally or vertically. # Function Signature ```python def count_islands(rows: int, cols: int, positions: List[Tuple[int, int]]) -> List[int]: pass ``` # Input - `rows`: An integer representing the number of rows in the grid (1 <= rows <= 1000). - `cols`: An integer representing the number of columns in the grid (1 <= cols <= 1000). - `positions`: A list of tuples, where each tuple contains two integers representing the row and column index of the position where land is added (0 <= row < rows, 0 <= col < cols). # Output - Return a list of integers where each integer represents the number of islands after the corresponding position is added. # Example ```python rows = 3 cols = 3 positions = [(0, 0), (0, 1), (1, 2), (2, 1)] print(count_islands(rows, cols, positions)) # Output: [1, 1, 2, 3] ``` # Constraints - Ensure that land positions are added only once. # Requirements - **Performance**: Your solution should be efficient enough to handle grids with up to 1,000,000 cells and up to 100,000 land additions. - **Correctness**: Handle edge cases such as: - Adding land to already existing land cells. - Handling grid boundaries appropriately. **Hint**: Use the Union-Find data structure to efficiently manage and union sets of connected cells.","solution":"from typing import List, Tuple def count_islands(rows: int, cols: int, positions: List[Tuple[int, int]]) -> List[int]: def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: if rank[rootX] > rank[rootY]: parent[rootY] = rootX elif rank[rootX] < rank[rootY]: parent[rootX] = rootY else: parent[rootY] = rootX rank[rootX] += 1 parent = {} rank = {} island_count = 0 results = [] lands = set() directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] for r, c in positions: if (r, c) in lands: results.append(island_count) continue lands.add((r, c)) index = r * cols + c parent[index] = index rank[index] = 0 island_count += 1 # New island formed for dr, dc in directions: nr, nc = r + dr, c + dc neighbor_index = nr * cols + nc if 0 <= nr < rows and 0 <= nc < cols and (nr, nc) in lands: if find(index) != find(neighbor_index): union(index, neighbor_index) island_count -= 1 results.append(island_count) return results"},{"question":"# ZigZag Iterator You are to implement a ZigZag Iterator class that will take in an arbitrary number of lists and iterate over them in a round-robin manner. Each call to `next()` should retrieve the next element in a zigzag manner from the input lists. The iterator should continue to interleave elements until all lists are exhausted. Function Signatures * `__init__(self, *args: List[int])` * `next(self) -> int` * `has_next(self) -> bool` Input and Output Formats * `__init__(self, *args: List[int])`: Takes in a variable number of input lists (each containing integers). * `next() -> int`: Returns the next integer in the sequence. * `has_next() -> bool`: Returns `True` if there are more elements to iterate; otherwise, returns `False`. Performance Requirements * Time complexity for initialization should be (O(k)), where `k` is the number of input lists. * Time complexity for `next()` and `has_next()` should be (O(1)) on average. Constraints * Each list contains up to (10^5) integers. * The total number of integers across all lists does not exceed (10^6). * The number of input lists does not exceed (10^4). Example ```python # Example usage: l1 = [1, 2] l2 = [3, 4, 5, 6] it = ZigZagIterator(l1, l2) result = [] while it.has_next(): result.append(it.next()) print(result) # Output: [1, 3, 2, 4, 5, 6] ``` # Task Implement a Python class `ZigZagIterator` with the methods `__init__`, `next`, and `has_next` to achieve the desired functionality.","solution":"from collections import deque from typing import List class ZigZagIterator: def __init__(self, *args: List[int]): self.queue = deque([(lst, 0) for lst in args if lst]) def next(self) -> int: if self.has_next(): lst, idx = self.queue.popleft() val = lst[idx] if idx + 1 < len(lst): self.queue.append((lst, idx + 1)) return val raise StopIteration(\\"Iterator has no more elements.\\") def has_next(self) -> bool: return bool(self.queue)"},{"question":"Context You are a software developer working on an application that requires efficient insertion in a sorted list of events based on their timestamps. Inserting events in the correct position while maintaining order is crucial for subsequent operations, such as event processing and retrieval. Task Implement a function that uses binary search to find the index at which a new event\'s timestamp should be inserted into a sorted list of event timestamps to maintain order. Function Signature ```python def find_insert_position(timestamps: list, new_timestamp: int) -> int: Given a sorted list of integer timestamps and a new integer timestamp, return the index where the new timestamp should be inserted to maintain the list order. :param timestamps: A sorted list of integer timestamps. :param new_timestamp: An integer timestamp to insert. :return: The index where the new timestamp should be inserted. Examples: find_insert_position([100, 200, 300, 400], 250) -> 2 find_insert_position([100, 200, 300, 400], 50) -> 0 find_insert_position([100, 200, 300, 400], 500) -> 4 find_insert_position([], 250) -> 0 find_insert_position([200, 200, 300], 200) -> 0 pass ``` Constraints and Requirements 1. The list `timestamps` is guaranteed to be sorted in ascending order. 2. The new timestamp can be any integer (positive, zero, or negative). 3. Aim for a solution that runs in O(log n) time complexity. 4. You should handle edge cases, including empty lists and duplicate timestamps. 5. The function should be robust against input errors, assuming the input types are correct. Notes 1. Assume the function is used in a larger system where performance is critical. 2. The function should correctly identify the position for new timestamps to ensure that the list remains sorted.","solution":"def find_insert_position(timestamps: list, new_timestamp: int) -> int: Given a sorted list of integer timestamps and a new integer timestamp, return the index where the new timestamp should be inserted to maintain the list order. :param timestamps: A sorted list of integer timestamps. :param new_timestamp: An integer timestamp to insert. :return: The index where the new timestamp should be inserted. Examples: find_insert_position([100, 200, 300, 400], 250) -> 2 find_insert_position([100, 200, 300, 400], 50) -> 0 find_insert_position([100, 200, 300, 400], 500) -> 4 find_insert_position([], 250) -> 0 find_insert_position([200, 200, 300], 200) -> 0 low, high = 0, len(timestamps) while low < high: mid = (low + high) // 2 if timestamps[mid] < new_timestamp: low = mid + 1 else: high = mid return low"},{"question":"# AVL Tree Node Count Problem Statement You are required to implement a function `count_nodes(self)` within the `AvlTree` class provided in the snippet. This function should return the total number of nodes in the AVL tree. Function Signature ```python class AvlTree: # existing methods... def count_nodes(self) -> int: pass ``` Input * An instance of the `AvlTree`. Output * An integer representing the total number of nodes in the AVL tree. Example ```python from tree.tree import TreeNode # Create an AVL tree and insert elements avl = AvlTree() avl.insert(10) avl.insert(20) avl.insert(5) # The tree structure is: # 10 # / # 5 20 # Output should be 3 print(avl.count_nodes()) ``` Constraints * You should assume that the `TreeNode` class and other methods (`insert`, `rebalance`, etc.) are implemented as provided. * The function should handle edge cases such as an empty tree (should return 0). Notes You are expected to traverse the AVL tree and count the nodes effectively. Avoid unnecessary computations or repeated traversals to ensure your solution is efficient.","solution":"class TreeNode: def __init__(self, key, left=None, right=None, height=1): self.key = key self.left = left self.right = right self.height = height class AvlTree: def __init__(self): self.root = None def insert(self, key): self.root = self._insert(self.root, key) def _insert(self, node, key): if not node: return TreeNode(key) elif key < node.key: node.left = self._insert(node.left, key) else: node.right = self._insert(node.right, key) return self._rebalance(node) def _rebalance(self, node): # Assume this method rebalances the subtree rooted at `node` return node def count_nodes(self) -> int: def _count_nodes(node): if node is None: return 0 return 1 + _count_nodes(node.left) + _count_nodes(node.right) return _count_nodes(self.root)"},{"question":"Scenario Imagine you are given a very large non-negative integer represented as an array of its digits in big-endian format (most significant digit first). You are required to add one to this number and return the resulting array of digits. Task Write a function `increment_number(digits)` that takes a list `digits` representing a non-negative number and returns a new list of digits representing the number incremented by one. Function Signature ```python def increment_number(digits: List[int]) -> List[int]: ``` Parameters * **digits**: List[int] - A list of non-negative digits representing a non-negative integer. The most significant digit is at the start of the list. Returns * **List[int]** - A list of digits representing the input number incremented by one. Constraints * The input list `digits` is non-empty. * The elements of `digits` are in the range [0, 9]. * The input list can potentially be very large (up to 10^6 elements). Example ```python assert increment_number([1, 2, 3]) == [1, 2, 4] assert increment_number([9]) == [1, 0] assert increment_number([9, 9, 9]) == [1, 0, 0, 0] assert increment_number([0]) == [1] ``` Notes * Consider edge cases including carry-over situations and the length increase after incrementation. * Optimize for both time and space complexity as much as possible.","solution":"from typing import List def increment_number(digits: List[int]) -> List[int]: This function takes a list of integers representing a large number, and returns a list of integers representing that number plus one. n = len(digits) for i in range(n - 1, -1, -1): if digits[i] < 9: digits[i] += 1 return digits digits[i] = 0 # If all the digits were 9, then we need an extra leading 1 at the start return [1] + [0] * n"},{"question":"# Question: Array Flattening Function You are tasked with writing a function that takes a potentially nested list of integers and flattens it into a single list of integers. Your task is to provide a robust solution that can handle arbitrary levels of nesting. You should implement this function in two parts: one using recursion and another using an iterative approach. Part 1: Recursive Method Write a function `flatten_recursive(input_list: list) -> list` that takes a nested list and returns a single flat list. Part 2: Iterative Method Write a function `flatten_iterative(input_list: list) -> list` that takes a nested list and returns a single flat list without using recursion. # Input: - A list of integers which may contain other lists of integers nested arbitrarily. # Output: - A single list of integers, flattened from the input nested list. # Example: ```python # Example Input input_list = [1, [2, 3, [4, 5]], [6, [7, 8], 9], 10] # Example Output flatten_recursive(input_list) # [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] flatten_iterative(input_list) # [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] ``` # Constraints: - The elements of the list are integers or other lists. - The maximum manageable recursion depth (for recursive part) should be considered to avoid a stack overflow. - Aim to handle large and deeply nested input efficiently within reasonable limits.","solution":"def flatten_recursive(input_list: list) -> list: Flattens a nested list of integers using recursion. result = [] for item in input_list: if isinstance(item, list): result.extend(flatten_recursive(item)) else: result.append(item) return result def flatten_iterative(input_list: list) -> list: Flattens a nested list of integers using an iterative approach. stack = input_list.copy() result = [] while stack: item = stack.pop(0) if isinstance(item, list): stack = item + stack else: result.append(item) return result"},{"question":"# Scenario: You are developing a system to monitor average response times of API calls for a web service. To smooth out short-term fluctuations, you need to compute the moving average of response times over a given number of recent calls. # Problem Statement: Write a Python class `MovingAverage` that calculates the moving average of the last `n` integers in a stream of data. Your implementation should efficiently manage the fixed-size sliding window using a suitable data structure, providing an average in constant time. # Requirements: 1. Implement the `__init__(self, size: int):` initializer with an integer `size` representing the fixed size of the sliding window. 2. Implement the `next(self, val: int) -> float:` method. This method should: - Accept an integer `val`, add it to the sliding window, calculate the new moving average, and return it as a float. - Self-adjust the sliding window such that it always holds the most recent `size` elements. # Example: ```python # Example usage: m = MovingAverage(3) print(m.next(1)) # Output: 1.0 print(m.next(10)) # Output: (1 + 10) / 2 = 5.5 print(m.next(3)) # Output: (1 + 10 + 3) / 3 = 4.666666666666667 print(m.next(5)) # Output: (10 + 3 + 5) / 3 = 6.0 ``` # Constraints: 1. The value of the sliding window size, `size`, will be an integer in the range [1, 1000]. 2. The values passed to the `next` method will be integers in the range [-10^4, 10^4]. 3. The `next` method should return a float representing the moving average of the current window. # Performance: Your solution should ensure efficient time complexity per operation, ideally O(1) for average calculation and O(n) space utilization where `n` is the window size. # Notes: - Consider how you will handle the initial state when the window has fewer elements than the specified size. - Ensure to use Python\'s deque from collections to manage the sliding window efficiently.","solution":"from collections import deque class MovingAverage: def __init__(self, size: int): Initialize the MovingAverage with a fixed size window. self.size = size self.window = deque() self.window_sum = 0 def next(self, val: int) -> float: Calculate the moving average with the addition of the new value. if len(self.window) == self.size: self.window_sum -= self.window.popleft() self.window.append(val) self.window_sum += val return self.window_sum / len(self.window)"},{"question":"Given a positive integer, develop a function `next_bigger(num: int) -> int` that returns the next higher number using the exact same set of digits of the given number. If no such number exists, return -1. # Input - An integer `num` (1 ≤ num ≤ 10^18) # Output - An integer representing the next permutation of digits if possible, otherwise -1. # Constraints - The number will not contain any non-numeric characters. - The number will be positive. # Example Cases - Example 1: - Input: 38276 - Output: 38627 - Example 2: - Input: 54321 - Output: -1 - Example 3: - Input: 999 - Output: -1 - Example 4: - Input: 5 - Output: -1 # Edge Cases - Single digit input where permutation is not possible. - Input with all identical digits. - Input that is already the maximum permutation. # Solution Framework 1. Convert the number to a list of its digits for easy manipulation. 2. Traverse the list from the end to find the first decreasing element. 3. If no such element is found, return -1. 4. Find the smallest element larger than the identified pivot in the suffix. 5. Swap these elements. 6. Reverse the suffix starting from the next position of the initial pivot. 7. Convert the list back to the integer and return it. # Hints - You may start by understanding the structures of permutations. - Think about how swapping and reversing parts of the list can help achieve the next lexicographical order. # Function Signature ```python def next_bigger(num: int) -> int: # Your implementation here # You may include some test cases to validate your solution assert next_bigger(38276) == 38627 assert next_bigger(12345) == 12354 assert next_bigger(1528452) == 1528524 assert next_bigger(138654) == 143568 assert next_bigger(54321) == -1 assert next_bigger(999) == -1 assert next_bigger(5) == -1 ```","solution":"def next_bigger(num: int) -> int: # Convert the number to a list of digits digits = list(map(int, str(num))) n = len(digits) # Step 2: Traverse the list from the end and find the first decreasing element i = n - 2 while i >= 0 and digits[i] >= digits[i + 1]: i -= 1 if i == -1: return -1 # Step 4: Find the smallest element larger than the identified pivot in the suffix j = n - 1 while digits[j] <= digits[i]: j -= 1 # Step 5: Swap these elements digits[i], digits[j] = digits[j], digits[i] # Step 6: Reverse the suffix starting from the next position of the initial pivot digits[i + 1:] = reversed(digits[i + 1:]) # Convert the list back to the integer and return it return int(\'\'.join(map(str, digits)))"},{"question":"Ternary Search Implementation # Context Imagine you are working on a search optimization problem. Given the need to search for elements in a highly sorted numerical dataset, you decide to implement a **Ternary Search** algorithm. This algorithm divides the array into three segments, improving the complexity over a linear search and in some cases over binary searches. # Task Implement the `ternary_search` function to find a specified element in a sorted numerical array using the ternary search method. # Function Signature ```python def ternary_search(left: int, right: int, key: int, arr: List[int]) -> int: pass ``` # Input 1. **left (int)**: The starting index of the array segment to search within. 2. **right (int)**: The ending index of the array segment to search within. 3. **key (int)**: The element you need to search for in the array. 4. **arr (List[int])**: The sorted array in which to perform the search. # Output - **int**: Returns the index of the key if found within the specified range otherwise returns -1. # Constraints - The array `arr` is sorted in ascending order. - `left` and `right` are valid indices within `arr`. - The array length does not exceed (10^6). # Example ```python arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] left = 0 right = len(arr) - 1 key = 5 print(ternary_search(left, right, key, arr)) # Output: 4 ``` # Requirements - Your implementation should optimize for both time and space complexity. - Consider edge cases and handle them gracefully. - Ensure that the method is iterative.","solution":"from typing import List def ternary_search(left: int, right: int, key: int, arr: List[int]) -> int: Performs a ternary search on the sorted array `arr` to find the index of `key`. Args: left (int): The starting index of the array segment to search within. right (int): The ending index of the array segment to search within. key (int): The element to search for. arr (List[int]): The sorted array in which to perform the search. Returns: int: The index of `key` if found, otherwise -1. while right >= left: mid1 = left + (right - left) // 3 mid2 = right - (right - left) // 3 if arr[mid1] == key: return mid1 if arr[mid2] == key: return mid2 if key < arr[mid1]: right = mid1 - 1 elif key > arr[mid2]: left = mid2 + 1 else: left = mid1 + 1 right = mid2 - 1 return -1"},{"question":"# Question: Find a Key in a Row-wise and Column-wise Sorted Matrix You are given a matrix `mat` of size `m x n` where each row and each column is sorted in non-decreasing order. Implement a function `search_in_a_sorted_matrix` that determines whether a given key exists in the matrix. If the key is found, print the indices of the matrix where the key is located; otherwise, print that the key is not found. # Function Signature ```python def search_in_a_sorted_matrix(mat: List[List[int]], m: int, n: int, key: int) -> None: Function to search for a key in a sorted matrix ``` # Input * `mat`: 2D List of integers, the matrix. * `m`: Integer, the number of rows in the matrix. * `n`: Integer, the number of columns in the matrix. * `key`: Integer, the value to search for in the matrix. # Output * Print \\"Key {key} found at row- {i+1} column- {j+1}\\" if the key exists in the matrix. * Otherwise, print \\"Key {key} not found\\". # Constraints * `1 <= m, n <= 1000` * `-10^9 <= mat[i][j], key <= 10^9` # Example **Input** ```python mat = [ [2, 5, 7], [4, 8, 13], [9, 11, 15], [12, 17, 20] ] key = 13 ``` **Output** ```plaintext Key 13 found at row- 2 column- 3 ``` # Notes * The function should handle edge cases, such as when the matrix is empty. * The function should operate within O(m + n) time complexity.","solution":"from typing import List def search_in_a_sorted_matrix(mat: List[List[int]], m: int, n: int, key: int) -> None: Function to search for a key in a sorted matrix. Prints the position if the key is found; otherwise, prints that the key is not found. i, j = 0, n - 1 # start from the top-right corner while i < m and j >= 0: if mat[i][j] == key: print(f\\"Key {key} found at row- {i+1} column- {j+1}\\") return elif mat[i][j] > key: j -= 1 # move left else: i += 1 # move down print(f\\"Key {key} not found\\")"},{"question":"# Insertion Sort with Binary Search You are tasked to implement an enhanced version of the Insertion Sort algorithm, leveraging binary search to reduce the comparison time for finding the right position. Function Signature: ```python def binary_insertion_sort(arr: List[int]) -> List[int]: pass ``` Input: - `arr`: A list of integers that needs to be sorted. Output: - A list of integers, sorted in ascending order. # Constraints: - You must use the provided binary search function `search_insert` for determining the correct positions. - The algorithm should work for: - `arr` length between 0 to 10^3 - Elements of `arr` can be between -10^6 to 10^6 # Examples: ```python binary_insertion_sort([4, 2, 7, 1]) -> [1, 2, 4, 7] binary_insertion_sort([10, 20, 5, 15]) -> [5, 10, 15, 20] binary_insertion_sort([1, 1, 1, 1]) -> [1, 1, 1, 1] binary_insertion_sort([]) -> [] ``` Scenario: You are helping develop an efficient system for sorting received data for a real-time application. The data comes intermittently, and you need to integrate each new data point into the already sorted order quickly. Using binary search within the insertion sort will help ensure that each insertion step is less time-consuming.","solution":"from typing import List def binary_insertion_sort(arr: List[int]) -> List[int]: def search_insert(subarr: List[int], val: int) -> int: Use binary search to find the index to insert val in subarr. low, high = 0, len(subarr) - 1 while low <= high: mid = (low + high) // 2 if subarr[mid] < val: low = mid + 1 else: high = mid - 1 return low for i in range(1, len(arr)): val = arr[i] j = search_insert(arr[:i], val) arr = arr[:j] + [val] + arr[j:i] + arr[i+1:] return arr"},{"question":"# Convert Sorted Array to Height-Balanced BST Background You are given an array of integers where elements are sorted in ascending order. Your task is to write a function that converts this array into a height-balanced Binary Search Tree (BST). A height-balanced BST is defined as a binary tree in which the depth of the two subtrees of every node never differs by more than 1. Function Signature ```python def sorted_array_to_bst(nums: List[int]) -> TreeNode: ``` Input - `nums`: A list of `n` integers sorted in ascending order. Output - The function should return the root node of the height-balanced BST. Example ```python Input: nums = [-10, -3, 0, 5, 9] Output: A reference to the root of a height-balanced BST, whose pre-order traversal could yield something like [0, -3, -10, 5, 9]. ``` Constraints - The number of elements in `nums` will not exceed 10^4. - Elements of `nums` are unique integers. Performance - The function should operate in O(n) time. - Space complexity should be constrained by the recursive stack depth, ideally O(log n). Scenario Imagine you are developing software for an e-commerce platform that needs to quickly lookup user transactions. The transactions are stored in an array that\'s pre-sorted by transaction ID. By converting this list into a balanced BST, you ensure that lookups remain efficient even as the number of transactions scales. Write the function `sorted_array_to_bst` to help solve this problem.","solution":"from typing import List, Optional class TreeNode: def __init__(self, val: int = 0, left: Optional[\'TreeNode\'] = None, right: Optional[\'TreeNode\'] = None): self.val = val self.left = left self.right = right def sorted_array_to_bst(nums: List[int]) -> Optional[TreeNode]: Convert sorted array to a height balanced BST. if not nums: return None def sorted_array_to_bst_recursive(left: int, right: int) -> Optional[TreeNode]: if left > right: return None mid = (left + right) // 2 node = TreeNode(nums[mid]) node.left = sorted_array_to_bst_recursive(left, mid - 1) node.right = sorted_array_to_bst_recursive(mid + 1, right) return node return sorted_array_to_bst_recursive(0, len(nums) - 1)"},{"question":"You are given a list of integers representing a series of measurements. Your task is to write a function that constructs a histogram (frequency distribution) of these measurements. # Function Signature ```python def get_histogram(input_list: list) -> dict: Get histogram representation of a list of integers. :param input_list: List of integers (can be unordered and with duplicates) :return: A dictionary where keys are the unique integers in the list and values are their counts. ``` # Input * A list of integers, `input_list` (0 ≤ length ≤ 10^6). The integers can be in any order and can have duplicates. # Output * A dictionary where each key is a unique integer from `input_list` and each value is the count of that integer. # Constraints 1. The function should run with a time complexity of O(n) and a space complexity of O(k), where n is the length of the input list and k is the number of unique elements. # Examples 1. For the input `[3, 3, 2, 1]`, your function should return `{1: 1, 2: 1, 3: 2}`. 2. For the input `[2, 3, 5, 5, 5, 6, 4, 3, 7]`, your function should return `{2: 1, 3: 2, 4: 1, 5: 3, 6: 1, 7: 1}`. 3. For the input `[]`, your function should return `{}`. # Additional Notes Consider edge cases such as: - Input list being empty. - Input list containing all identical elements. - Large input list with many unique elements (within given constraints). # Evaluation Criteria Your solution will be evaluated on: 1. **Correctness**: Does it correctly compute the histogram for various test cases? 2. **Efficiency**: Does it meet the performance requirements? 3. **Code Quality**: Is the solution clean, readable, and well-organized?","solution":"def get_histogram(input_list: list) -> dict: Get histogram representation of a list of integers. :param input_list: List of integers (can be unordered and with duplicates) :return: A dictionary where keys are the unique integers in the list and values are their counts. histogram = {} for number in input_list: if number in histogram: histogram[number] += 1 else: histogram[number] = 1 return histogram"},{"question":"# Objective Your task is to implement a function to delete a node from a given Binary Search Tree (BST) maintaining its key properties. # Description You need to add a `delete` method to the existing `BST` class implementation. # Function Signature ```python def delete(self, data: int) -> bool: # Implementation goes here ``` # Parameters - `data`: An integer to specify the node that is to be deleted from the BST. # Returns - Returns `True` if the node was successfully deleted. - Returns `False` if the node with the specified value does not exist in the tree. # Constraints - The value to be deleted can be any integer present in the BST. - The tree will not contain duplicate values. - Ensure that after deletion, the BST maintains its key properties. # Assumptions - The BST class and the Node class have already been implemented as shown in the provided code snippet. - The tree will always have at least one node when calling the delete method. # Example ```python # Example usage: # The tree initially is built as shown in the given example. bst = BST() test_data = [10, 15, 6, 4, 9, 12, 24, 7, 20, 30, 18] for num in test_data: bst.insert(num) # Perform deletion assert bst.delete(15) == True assert bst.delete(15) == False # Trying to delete again should return False assert bst.delete(50) == False # Non-existent value should return False # Validate tree structure, search element 24 after deletion assert bst.search(24) == True ``` # Notes - The `delete` method should correctly handle all cases, including: - Deleting a leaf node (node with no children). - Deleting a node with one child. - Deleting a node with two children. - The deleted node should leave the BST valid, meaning you may need to find and promote the appropriate successor of the deleted node. # To Test Your Implementation Use or extend the provided `unittest` class to check the correctness of your implementation.","solution":"class Node: def __init__(self, key): self.key = key self.left = None self.right = None class BST: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = Node(key) else: self._insert_rec(self.root, key) def _insert_rec(self, node, key): if key < node.key: if not node.left: node.left = Node(key) else: self._insert_rec(node.left, key) else: if not node.right: node.right = Node(key) else: self._insert_rec(node.right, key) def search(self, key): return self._search_rec(self.root, key) def _search_rec(self, node, key): if node is None: return False if node.key == key: return True elif key < node.key: return self._search_rec(node.left, key) else: return self._search_rec(node.right, key) def delete(self, key: int) -> bool: self.root, deleted = self._delete_rec(self.root, key) return deleted def _delete_rec(self, node, key): if node is None: return node, False if key < node.key: node.left, deleted = self._delete_rec(node.left, key) elif key > node.key: node.right, deleted = self._delete_rec(node.right, key) else: if node.left is None: return node.right, True elif node.right is None: return node.left, True # Node with two children, get the inorder successor temp = self._min_value_node(node.right) node.key = temp.key node.right, _ = self._delete_rec(node.right, temp.key) return node, True return node, deleted def _min_value_node(self, node): current = node while current.left: current = current.left return current"},{"question":"**Context:** In digital systems, certain integrity checks require verification where binary signals must alternate to prevent errors. Given an integer, you are to determine if the binary representation of the number maintains an alternating pattern of bits (adjacent bits are different). **Task:** Implement a function `has_alternating_bits(n: int) -> bool` that: - Takes a single positive integer `n`. - Returns a boolean value indicating whether the binary representation of `n` has alternating bits. **Input:** - An integer `n` (1 <= n <= 10^9). **Output:** - Return `True` if the binary representation of `n` has alternating bits. - Return `False` otherwise. **Constraints:** - The function should operate efficiently, ideally in constant time. **Example:** ```plaintext Input: 5 Output: True Explanation: Binary representation of 5 is \\"101\\". Input: 7 Output: False Explanation: Binary representation of 7 is \\"111\\". Input: 11 Output: False Explanation: Binary representation of 11 is \\"1011\\". Input: 10 Output: True Explanation: Binary representation of 10 is \\"1010\\". ``` **Notes:** - Consider using bit manipulation techniques to achieve optimal performance. - You can assume the input will always be a valid positive integer within the given range. **Starter Function:** ```python def has_alternating_bits(n: int) -> bool: # Your implementation here pass ```","solution":"def has_alternating_bits(n: int) -> bool: Determine if the binary representation of n has alternating bits. Args: n (int): The input integer. Returns: bool: True if the binary representation of n has alternating bits, False otherwise. current_bit = n & 1 n >>= 1 while n > 0: next_bit = n & 1 if current_bit == next_bit: return False current_bit = next_bit n >>= 1 return True"},{"question":"# Question Binary Exponentiation with Extended Functionality You are given two functions, `power` and `power_recur`, which implement binary exponentiation in iterative and recursive form, respectively. These functions can calculate `a ^ n` efficiently, with the added support for modular arithmetic where applicable. While these functions handle most basic cases well, there are some scenarios they do not cover, such as handling negative exponents and efficiently managing large numbers without exceeding typical data type limits. **Your task**: 1. **Enhance the `power` and `power_recur` functions** to handle negative exponents. When the exponent `n` is negative, the function should compute the inverse of the base raised to the positive exponent (i.e., `a ^ -n` should be calculated as `1 / (a ^ n)`). Ensure that the extended functions maintain the same performance characteristics. 2. **Write efficient test cases** to validate the performance and correctness of your extended functions: - Validate basic test cases. - Test edge cases such as zero and negative numbers. - Ensure the implementation works well with large numbers, especially with modular arithmetic. Function Signature ```python def power_extended(a: float, n: int, mod: int = None) -> float: Calculate a ^ n, where n can be negative. If mod is specified, return the result modulo mod (if positive). Ensure the function maintains logarithmic time complexity. Args: a : float : The base number n : int : The exponent, which may be negative mod : int : An optional modulus. If specified, mod must be positive. Returns: float : The result of a raised to the power n, optionally modulo mod. pass def power_recur_extended(a: float, n: int, mod: int = None) -> float: Calculate a ^ n, where n can be negative. Recursive approach. If mod is specified, return the result modulo mod (if positive). Ensure the function maintains logarithmic time complexity. Args: a : float : The base number n : int : The exponent, which may be negative mod : int : An optional modulus. If specified, mod must be positive. Returns: float : The result of a raised to the power n, optionally modulo mod. pass ``` Input and Output Format * **Input**: * `a` (float): The base number. * `n` (int): The exponent, which can be negative. * `mod` (int, optional): An optional modulus (must be positive if specified). * **Output**: * The function should return a float representing the result of `a` raised to the power `n`, optionally modulo `mod`. Constraints * `-10^9 <= a <= 10^9` * `-10^9 <= n <= 10^9` Example ```python assert power_extended(2, -3) == 0.125 # 1 / (2^3) assert power_recur_extended(2, -3) == 0.125 # 1 / (2^3) assert power_extended(3, 3, 5) == 2 # 27 % 5 assert power_recur_extended(3, 3, 5) == 2 # 27 % 5 ```","solution":"def power_extended(a: float, n: int, mod: int = None) -> float: Calculate a ^ n, where n can be negative. If mod is specified, return the result modulo mod (if positive). Ensure the function maintains logarithmic time complexity. Args: a : float : The base number n : int : The exponent, which may be negative mod : int : An optional modulus. If specified, mod must be positive. Returns: float : The result of a raised to the power n, optionally modulo mod. if n < 0: a = 1 / a n = -n result = 1 while n > 0: if n % 2 == 1: result *= a if mod: result %= mod a *= a if mod: a %= mod n //= 2 if mod: return result % mod return result def power_recur_extended(a: float, n: int, mod: int = None) -> float: Calculate a ^ n, where n can be negative. Recursive approach. If mod is specified, return the result modulo mod (if positive). Ensure the function maintains logarithmic time complexity. Args: a : float : The base number n : int : The exponent, which may be negative mod : int : An optional modulus. If specified, mod must be positive. Returns: float : The result of a raised to the power n, optionally modulo mod. def power_recur(a, n, mod): if n == 0: return 1 half = power_recur(a, n // 2, mod) half = (half * half) % mod if mod else half * half if n % 2 != 0: half = (half * a) % mod if mod else half * a return half if n < 0: a = 1 / a n = -n result = power_recur(a, n, mod) if mod: return result % mod return result"},{"question":"Problem Statement You are provided with a singly linked list where each node contains a string value. Your task is to design and implement a function that removes duplicate values from the linked list. You need to implement two versions of the function: 1. A version that achieves O(N) time complexity and uses additional memory. 2. A version that achieves O(1) additional space complexity but may have higher time complexity (O(N^2)). Your implementation should demonstrate a thorough understanding of linked list traversal and element comparison. Consider edge cases such as an empty list or a list where all elements are duplicates. Input Format - A `Node` class representing nodes in the linked list, each initialized with a `val` (string) and `next` node pointer. - The head node of a linked list containing string values. Output Format - Modify the linked list in place to remove duplicates. - The final linked list should consist of unique elements retaining their original order of first occurrence. Constraints - Each node\'s value is a string. - List can contain up to (10^5) nodes. Example ```python # Define Node class (provided) class Node(): def __init__(self, val=None): self.val = val self.next = None # Define functions to remove duplicates (to be implemented by students) def remove_duplicates_with_set(head): # Your code here def remove_duplicates_without_set(head): # Your code here def print_linked_list(head): string = \\"\\" while head and head.next: string += head.val + \\" -> \\" head = head.next string += head.val if head else \\"Empty List\\" print(string) # Example usage: a1 = Node(\\"A\\") a2 = Node(\\"A\\") b = Node(\\"B\\") c1 = Node(\\"C\\") d = Node(\\"D\\") c2 = Node(\\"C\\") f = Node(\\"F\\") g = Node(\\"G\\") a1.next = a2 a2.next = b b.next = c1 c1.next = d d.next = c2 c2.next = f f.next = g remove_duplicates_with_set(a1) print_linked_list(a1) # Expected: A -> B -> C -> D -> F -> G remove_duplicates_without_set(a1) print_linked_list(a1) # Expected: A -> B -> C -> D -> F -> G (if the list was modified again or remained the same) ``` **Note**: The `print_linked_list` function is provided for your convenience to verify the output.","solution":"class Node: def __init__(self, val=None): self.val = val self.next = None def remove_duplicates_with_set(head): if head is None: return seen = set() current = head prev = None while current: if current.val in seen: prev.next = current.next else: seen.add(current.val) prev = current current = current.next def remove_duplicates_without_set(head): if head is None: return current = head while current: runner = current while runner.next: if runner.next.val == current.val: runner.next = runner.next.next else: runner = runner.next current = current.next def print_linked_list(head): string = \\"\\" while head and head.next: string += head.val + \\" -> \\" head = head.next string += head.val if head else \\"Empty List\\" return string"},{"question":"Problem Description In a city, intersections are connected by one-way roads. The city\'s traffic control system needs to ensure that there are no loops in the traffic flow (i.e., no vehicular routes that form a cycle). You are tasked to determine if the city\'s road network (represented as a directed graph where intersections are vertices and roads are directed edges) contains any cycles. Task Write a Python function `has_traffic_cycle(road_map: Dict[str, List[str]]) -> bool` that takes a road network as input and returns `True` if there exists at least one cycle, otherwise returns `False`. Input Format * `road_map`: A dictionary where keys are intersection names (strings) and values are lists of intersections (strings) that can be directly reached from the key intersection. Output Format * A boolean value: `True` if there is a cycle, `False` otherwise. Constraints * The number of intersections (vertices) and roads (edges) will be at most (1000). * The intersection names will consist of lowercase and uppercase English letters only. * There will be no intersections with the same name (i.e., unique intersection names). Example ```python # Example input: A road map containing a cycle road_map = { \'A\': [\'B\'], \'B\': [\'C\'], \'C\': [\'A\'] } # Example output: True (A -> B -> C -> A forms a cycle) print(has_traffic_cycle(road_map)) # Output: True # Example input: A road map without any cycle road_map = { \'A\': [\'B\'], \'B\': [\'C\'], \'C\': [] } # Example output: False (No cycle exists) print(has_traffic_cycle(road_map)) # Output: False ``` Explanation * Consider using a Depth-First Search (DFS) approach with coloring (marking) of vertices to detect cycles. * During the DFS traversal, if you reach a vertex that is currently being explored (indicated by a specific state), a cycle is detected. Function Signature ```python from typing import Dict, List def has_traffic_cycle(road_map: Dict[str, List[str]]) -> bool: # function implementation goes here ```","solution":"from typing import Dict, List def has_traffic_cycle(road_map: Dict[str, List[str]]) -> bool: # Define the states for each node NOT_VISITED = 0 VISITING = 1 VISITED = 2 # Initialize the state of each node to NOT_VISITED state = {node: NOT_VISITED for node in road_map} def dfs(node: str) -> bool: if state[node] == VISITING: # Found a cycle return True if state[node] == VISITED: # No cycle from this node return False # Mark this node as VISITING state[node] = VISITING # Recursively visit all the neighbors for neighbor in road_map[node]: if dfs(neighbor): return True # Mark this node as VISITED state[node] = VISITED return False # Start DFS from each node for node in road_map: if state[node] == NOT_VISITED: if dfs(node): return True return False"},{"question":"# Matrix Multiplication Challenge Objective Write a function `matrix_multiply` that takes two 2-dimensional lists (matrices) and returns their product as a new 2-dimensional list. Function Signature ```python def matrix_multiply(multiplicand: list, multiplier: list) -> list: pass ``` Input - `multiplicand`: A list of lists of integers where each sub-list represents a row of the matrix. - `multiplier`: A list of lists of integers where each sub-list represents a row of the matrix. Output - A list of lists of integers representing the result of matrix multiplication. Constraints - The number of columns in `multiplicand` must be equal to the number of rows in `multiplier`. - You may assume that all elements of the input matrices are integers. - You should handle the case where input matrices are not compatible for multiplication by raising an appropriate exception. Performance Requirements - Your implementation should work efficiently for matrices of size up to 100x100. Example ```python multiplicand = [ [1, 2], [3, 4] ] multiplier = [ [5, 6], [7, 8] ] expected_output = [ [19, 22], [43, 50] ] assert matrix_multiply(multiplicand, multiplier) == expected_output ``` Scenario Suppose we\'re designing a graphics engine that transforms vectors using matrices representing various transformations such as translation, rotation, and scaling. Efficient multiplication of these transformation matrices is crucial for rendering scenes accurately and quickly. Implement the `matrix_multiply` function to facilitate these transformations by correctly computing the product of two matrices.","solution":"def matrix_multiply(multiplicand: list, multiplier: list) -> list: Multiplies two matrices and returns the result. :param multiplicand: List of lists representing the multiplicand matrix. :param multiplier: List of lists representing the multiplier matrix. :return: List of lists representing the resulting matrix after multiplication. :raises ValueError: If the matrices cannot be multiplied due to incompatible dimensions. # Check if number of columns in multiplicand equals number of rows in multiplier if len(multiplicand[0]) != len(multiplier): raise ValueError(\\"Matrices have incompatible dimensions for multiplication\\") # Dimensions of the result matrix result_rows = len(multiplicand) result_cols = len(multiplier[0]) # Initialize the result matrix with zeros result = [[0 for _ in range(result_cols)] for _ in range(result_rows)] # Perform matrix multiplication for i in range(result_rows): for j in range(result_cols): for k in range(len(multiplier)): result[i][j] += multiplicand[i][k] * multiplier[k][j] return result"},{"question":"You are given a sorted array of integers and a list of queries. For each query, you need to determine the index of the queried element in the array using the Binary Search algorithm. If the element is not present in the array, return `-1`. # Function Signature Implement the function `search_elements(array: List[int], queries: List[int]) -> List[int]` where: - `array`: A list of integers sorted in ascending order. - `queries`: A list of integers representing the elements to search for in the array. # Expected Output Return a list of integers representing the indices of the queried elements in the array or `-1` if the element is not found. # Constraints - The array will have a maximum length of 10^5. - Each query will be an integer within the range of elements in the array. - The number of queries will not exceed 10^4. # Example ```python # Example 1 array = [1, 2, 4, 5, 7, 8, 9] queries = [5, 8, 10] search_elements(array, queries) # Output: [3, 5, -1] # Example 2 array = [2, 3, 5, 6, 9, 12, 15, 18] queries = [15, 2, 9, 1] search_elements(array, queries) # Output: [6, 0, 4, -1] ``` # Explanation - In the first example, the value `5` is located at index `3`, `8` is at index `5`, and `10` is not present in the array (hence -1). - In the second example, `15` is at index `6`, `2` at index `0`, `9` at index `4`, and `1` is not in the array (hence -1). # Performance Requirements Make sure your solution is optimized for efficiency and adheres to the time complexity of O(log n) for each search operation.","solution":"from typing import List def binary_search(array: List[int], target: int) -> int: Helper function to perform binary search on a sorted list. Returns the index of target in the list or -1 if not found. left, right = 0, len(array) - 1 while left <= right: mid = (left + right) // 2 if array[mid] == target: return mid elif array[mid] < target: left = mid + 1 else: right = mid - 1 return -1 def search_elements(array: List[int], queries: List[int]) -> List[int]: Given a sorted array and a list of queries, returns the indices of the queried elements or -1 if an element is not found. results = [] for query in queries: result = binary_search(array, query) results.append(result) return results"},{"question":"<|Analysis Begin|> # Algorithm Analysis Core Identification * **Algorithm/Data Structure**: This is an algorithm that utilizes the XOR bitwise operation. * **Complexity**: * Time complexity: ( O(n) ) where ( n ) is the length of string ( s ). Since ( t ) is ( s ) plus one character, the combined length is ((n + n + 1) = O(2n) = O(n) ). * Space complexity: ( O(1) ), as it uses a constant amount of extra space. * **Principles**: * The algorithm leverages the properties of the XOR operation. XOR-ing a number with itself results in zero, and XOR-ing any number with zero results in the number itself. Thus, XOR-ing all characters in ( s ) and ( t ) will cancel out all characters that appear in both ( s ) and ( t ), leaving the extra character in ( t ). Characteristics & Applications * **Properties**: It is fast and operates in linear time with constant space. This solution is deterministic and complete. * **Common Use Cases**: Useful in scenarios where an efficient and simple solution is needed to detect differences between two datasets where exactly one additional item exists in the second set. * **Strengths/Limitations**: * **Strengths**: Efficient in time and space, and easy to understand and implement. * **Limitations**: Only applicable when the specific condition of one additional element holds true. Not suitable for finding multiple differences or in scenarios where the data structure does not support bitwise operations. Implementation Challenges * **Edge Cases**: * ( s ) and ( t ) are very small strings. * Characters in ( s ) and ( t ) include only lowercase letters. * **Performance Bottlenecks**: No significant bottlenecks due to the simplicity of the XOR operation. * **Error Scenarios**: Situations where ( s ) and ( t ) do not conform to the problem constraints (e.g., multiple characters are different, ( t ) is not exactly ( s ) plus one character) can result in incorrect outcomes. * **Optimization Points**: No significant optimization is required beyond the current ( O(n) ) time solution. <|Analysis End|> <|Question Begin|> # Coding Question: Problem Statement: You are given two strings `s` and `t` both consisting of lowercase letters. String `t` is generated by shuffling the characters of string `s` and then adding an extra character at a random position. Your task is to write a function `find_difference(s, t)` that identifies and returns the additional character in `t`. Function Signature: ```python def find_difference(s: str, t: str) -> str: # implementation here ``` Input: * `s`: A string of length `n` where ( 1 leq n leq 10^5 ). The string consists of lowercase English letters. * `t`: A string of length `n + 1` generated by shuffling `s` and adding one extra lowercase letter. Output: * The function should return a single character, which is the one additional character in the string `t`. Constraints: * The strings consist only of lowercase English letters. * String `t` is guaranteed to be generated by shuffling `s` and then adding one extra character. Example: ```python # Example 1 s = \\"abcd\\" t = \\"abecd\\" find_difference(s, t) # Output: \'e\' # Example 2 s = \\"hello\\" t = \\"helloo\\" find_difference(s, t) # Output: \'o\' ``` Explanation: 1. In the first example, after shuffling \\"abcd\\" and adding \'e\', we get \\"abecd\\". The function should return \'e\'. 2. In the second example, after shuffling \\"hello\\" and adding \'o\', we get \\"helloo\\". The function should return \'o\'. Use the properties of the XOR operation to achieve an efficient solution.","solution":"def find_difference(s: str, t: str) -> str: xor_result = 0 # XOR all characters in s for char in s: xor_result ^= ord(char) # XOR all characters in t for char in t: xor_result ^= ord(char) # The remaining result is the ASCII value of the different character return chr(xor_result)"},{"question":"You are given a positive integer `n`. Your task is to write a function `partition_count(n)` that returns the number of distinct ways the integer can be partitioned into sums of other positive integers. Each unique combination should be counted only once regardless of order. Input - A single integer `n` where `1 <= n <= 100`. Output - An integer representing the number of distinct partitions of the input integer `n`. Constraints - The calculation must be efficient enough to handle the upper constraints (`n <= 100`) within a reasonable time frame. # Example Example 1 - **Input**: `4` - **Output**: `5` - **Explanation**: ``` 4 = 4 4 = 3 + 1 4 = 2 + 2 4 = 2 + 1 + 1 4 = 1 + 1 + 1 + 1 ``` Example 2 - **Input**: `7` - **Output**: `15` - **Explanation**: ``` 7 = 7 7 = 6 + 1 7 = 5 + 2 7 = 5 + 1 + 1 7 = 4 + 3 7 = 4 + 2 + 1 7 = 4 + 1 + 1 + 1 7 = 3 + 3 + 1 7 = 3 + 2 + 2 7 = 3 + 2 + 1 + 1 7 = 3 + 1 + 1 + 1 + 1 7 = 2 + 2 + 2 + 1 7 = 2 + 2 + 1 + 1 + 1 7 = 2 + 1 + 1 + 1 + 1 + 1 7 = 1 + 1 + 1 + 1 + 1 + 1 + 1 ``` # Constraints - Optimize for both time and space. - Think about initialization, matrix management, and edge case handling. # Function Signature ```python def partition_count(n: int) -> int: pass ```","solution":"def partition_count(n): dp = [0] * (n+1) dp[0] = 1 # There is exactly one way to partition zero for i in range(1, n+1): for j in range(i, n+1): dp[j] += dp[j-i] return dp[n]"},{"question":"# Question: Optimized Binomial Coefficient Calculation using Dynamic Programming Background In combinatorics, the binomial coefficient ({n choose k}) represents the number of ways to choose k elements from a set of n elements without regard to the order of selection. It can be defined recursively as follows: - ({n choose 0} = 1) - ({n choose n} = 1) - ({n choose k} = {n-1 choose k-1} + {n-1 choose k}) Implement a function `dynamic_binomial_coefficient(n, k)` using dynamic programming to compute the binomial coefficient, ensuring the solution is efficient and avoids the pitfalls of deep recursion. Function Signature ```python def dynamic_binomial_coefficient(n: int, k: int) -> int: pass ``` Input - `n` (int): Number of elements in the set (0 <= n <= 10^3) - `k` (int): Number of elements to choose from the set (0 <= k <= n) Output - (int): The binomial coefficient ({n choose k}) Constraints - 0 <= n <= 1000 - 0 <= k <= n Performance Requirements - The implementation must run in O(n * k) time complexity. - The space complexity should be O(k) by using optimized space dynamic programming techniques. Example ```python assert dynamic_binomial_coefficient(5, 2) == 10 assert dynamic_binomial_coefficient(10, 3) == 120 ``` Additional Information The solution should account for large values and ensure the use of an iterative dynamic programming approach to avoid recursive depth issues.","solution":"def dynamic_binomial_coefficient(n, k): if k > n: return 0 if k == 0 or k == n: return 1 # Use a 1-D array to store previously calculated values dp = [0] * (k + 1) dp[0] = 1 # Base case # Compute binomial coefficients iteratively for i in range(1, n + 1): # Compute next row of Pascal\'s triangle j = min(i, k) while j > 0: dp[j] = dp[j] + dp[j - 1] j -= 1 return dp[k]"},{"question":"Scenario You\'ve been provided a set of matrix transformation functions which include rotating and inverting the matrix. Your goal is to implement a new function that performs a chain of these transformations efficiently as specified by a command list. Problem Write a function `transform_matrix(matrix: List[List[int]], commands: List[str]) -> List[List[int]]` that takes a 2D matrix and a list of commands, then returns the matrix after executing the chain of transformations. Valid commands are: - \\"rotate_clockwise\\": Rotate the matrix 90 degrees clockwise. - \\"rotate_counterclockwise\\": Rotate the matrix 90 degrees counterclockwise. - \\"top_left_invert\\": Invert the matrix along the top-left to bottom-right diagonal. - \\"bottom_left_invert\\": Invert the matrix along the bottom-left to top-right diagonal. Input * `matrix` (List[List[int]]): A square 2D list of integers. * `commands` (List[str]): A list of strings, each being one of the valid commands. Output * (List[List[int]]): The matrix after applying all given commands sequentially. Constraints * The input matrix will always be square (n x n) with (1 ≤ n ≤ 100). * The commands list will contain between 1 and 10 valid command strings. Example ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] commands = [\\"rotate_clockwise\\", \\"top_left_invert\\"] # After rotation clockwise: # [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] # After top_left_invert: # [ # [7, 8, 9], # [4, 5, 6], # [1, 2, 3] # ] result = transform_matrix(matrix, commands) # Output: [[7, 8, 9], [4, 5, 6], [1, 2, 3]] ``` Notes * You should optimize the transformation to utilize space and handle matrices efficiently. * Ensure your code considers the edge cases such as single element matrices.","solution":"from typing import List def rotate_clockwise(matrix: List[List[int]]) -> List[List[int]]: n = len(matrix) return [[matrix[n - j - 1][i] for j in range(n)] for i in range(n)] def rotate_counterclockwise(matrix: List[List[int]]) -> List[List[int]]: n = len(matrix) return [[matrix[j][n - i - 1] for j in range(n)] for i in range(n)] def top_left_invert(matrix: List[List[int]]) -> List[List[int]]: n = len(matrix) for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] return matrix def bottom_left_invert(matrix: List[List[int]]) -> List[List[int]]: n = len(matrix) for i in range(n): for j in range(n - i): matrix[i][j], matrix[n - j - 1][n - i - 1] = matrix[n - j - 1][n - i - 1], matrix[i][j] return matrix def transform_matrix(matrix: List[List[int]], commands: List[str]) -> List[List[int]]: for command in commands: if command == \\"rotate_clockwise\\": matrix = rotate_clockwise(matrix) elif command == \\"rotate_counterclockwise\\": matrix = rotate_counterclockwise(matrix) elif command == \\"top_left_invert\\": matrix = top_left_invert(matrix) elif command == \\"bottom_left_invert\\": matrix = bottom_left_invert(matrix) return matrix"},{"question":"# Question: Given the reverse_bits function that reverses the bits of a 32-bit unsigned integer, enhance the function to handle reversing bits for different data sizes. Implement a general bit-reversal function `reverse_bits_generalized(n, bit_length)` that reverses the bits of a given `bit_length` sized unsigned integer `n`. # Requirements: - **Function**: `reverse_bits_generalized(n, bit_length)` - **Input**: - `n` - A non-negative integer whose bits are to be reversed. - `bit_length` - An integer specifying the number of bits in `n` (1 ≤ bit_length ≤ 64). - **Output**: - An integer with `bit_length` reversed bits of `n`. - **Constraints**: - The input integer `n` is an unsigned integer within the valid range of the given `bit_length`. - **Performance**: - The solution should operate in O(k) time complexity where `k` is the bit length. - Use O(1) additional space. # Examples: ```python # Example 1: # Input: n = 43261596, bit_length = 32 # Output: 964176192 # Explanation: 00000010100101000001111010011100 (43261596) in binary reversed is 00111001011110000010100101000000 (964176192). # Example 2: # Input: n = 3, bit_length = 8 # Output: 192 # Explanation: 00000011 (3) in binary reversed is 11000000 (192). # Example 3: # Input: n = 170, bit_length = 8 # Output: 85 # Explanation: 10101010 (170) in binary reversed is 01010101 (85). ``` # Solution Template: ```python def reverse_bits_generalized(n, bit_length): # Initialize the variable to store the result m = 0 i = 0 # Loop over the bit length to reverse bits while i < bit_length: m = (m << 1) + (n & 1) n >>= 1 i += 1 return m ``` Implement the `reverse_bits_generalized` function and test it with the provided examples.","solution":"def reverse_bits_generalized(n, bit_length): Reverses the bits of an integer n up to the specified bit length. Parameters: n (int): The integer whose bits are to be reversed. bit_length (int): The number of bits to consider in the reversal. Returns: int: The integer with reversed bits. m = 0 for i in range(bit_length): m = (m << 1) | (n & 1) n >>= 1 return m"},{"question":"You are required to implement the `SeparateChainingHashTable` class as described above. Your implementation should support the fundamental operations of a hash table using separate chaining to resolve collisions. # Implementation Details 1. **Class Name**: `SeparateChainingHashTable` 2. **Initialization**: - `__init__(self, size)`: Initializes the hash table with the given size. 3. **Hash Function**: - `hash(self, key)`: Returns the hash value for the given key. 4. **Core Methods**: - `put(self, key, value)`: Inserts the key-value pair into the hash table. - `get(self, key)`: Retrieves the value associated with the given key. - `del_(self, key)`: Deletes the key-value pair from the hash table. - `__len__(self)`: Returns the number of elements in the hash table. - `__getitem__(self, key)`: Retrieves value using indexing syntax. - `__delitem__(self, key)`: Deletes key-value pair using deletion syntax. - `__setitem__(self, key, value)`: Sets the key-value pair using indexing syntax. # Constraints - The keys are non-empty strings. - The values can be any valid Python object but are not `None`. - The initial size of the hash table should be 11. - Ensure the hash table handles collisions and edge cases as described. # Example ```python table = SeparateChainingHashTable() table.put(\'hello\', \'world\') assert table.get(\'hello\') == \'world\' assert len(table) == 1 table.put(\'foo\', \'bar\') assert table.get(\'foo\') == \'bar\' assert len(table) == 2 del table[\'hello\'] assert table.get(\'hello\') is None assert len(table) == 1 ``` # Performance Requirements - Optimize for average-case O(1) time complexity for insertions, deletions, and lookups. - Handle edge cases effectively to avoid common pitfalls. Implement the `SeparateChainingHashTable` class and ensure it passes all the example test cases provided.","solution":"class SeparateChainingHashTable: def __init__(self, size=11): self.size = size self.table = [[] for _ in range(size)] self.count = 0 def hash(self, key): # Simple hash function hash_sum = sum(ord(c) for c in key) return hash_sum % self.size def put(self, key, value): index = self.hash(key) # Check if the key already exists in the bucket and update value for i, (k, v) in enumerate(self.table[index]): if k == key: self.table[index][i] = (key, value) return self.table[index].append((key, value)) self.count += 1 def get(self, key): index = self.hash(key) for k, v in self.table[index]: if k == key: return v return None def del_(self, key): index = self.hash(key) for i, (k, v) in enumerate(self.table[index]): if k == key: self.table[index].pop(i) self.count -= 1 return def __len__(self): return self.count def __getitem__(self, key): return self.get(key) def __delitem__(self, key): self.del_(key) def __setitem__(self, key, value): self.put(key, value)"},{"question":"Question: Implement an optimization of Cocktail Shaker Sort # Problem Statement You are required to implement an optimized version of the Cocktail Shaker Sort algorithm. Your implementation should improve its efficiency by introducing early termination if the array becomes sorted before all passes are done. Additionally, ensure your code is equipped to handle various edge cases mentioned below. # Input * A list `arr` of `N` integers (1 ≤ N ≤ 10^5), where each integer satisfies -10^9 ≤ arr[i] ≤ 10^9. # Output * The sorted list of integers. # Constraints * You should aim to minimize the number of swaps and checks as much as possible while maintaining the algorithm\'s correctness and stability. * The implementation must handle input efficiently given the constraints on `N` and the range of values. * Python\'s built-in sorting functions are not allowed. # Example ```python Input: [3, 0, 2, 5, -1, 4, 1] Output: [-1, 0, 1, 2, 3, 4, 5] Input: [1, 2, 3, 4, 5] Output: [1, 2, 3, 4, 5] ``` # Instructions 1. Define a function `optimized_cocktail_shaker_sort(arr: List[int]) -> List[int]`. 2. Implement the optimized Cocktail Shaker Sort within the function. 3. Your code should handle edge cases efficiently. 4. Add comments to explain any significant steps or optimizations in your implementation. # Evaluation Criteria * Correctness: The function produces the correct output for various cases. * Efficiency: The function adheres to time and space complexity requirements. * Code Quality: Code readability, comment explanation, and adherence to Python coding conventions.","solution":"from typing import List def optimized_cocktail_shaker_sort(arr: List[int]) -> List[int]: An optimized version of the Cocktail Shaker Sort algorithm that introduces early termination if the array becomes sorted before all passes are done. if len(arr) <= 1: return arr start = 0 end = len(arr) - 1 while start < end: swapped = False # Traverse the array from left to right, pushing the largest unfixed element to the end for i in range(start, end): if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] swapped = True if not swapped: break # Decrease the end as the last element is already sorted end -= 1 swapped = False # Traverse the array backwards, pushing the smallest unfixed element to the start for i in range(end, start, -1): if arr[i - 1] > arr[i]: arr[i], arr[i - 1] = arr[i - 1], arr[i] swapped = True if not swapped: break # Increase the start as the first element is already sorted start += 1 return arr"},{"question":"Context: You\'re developing a function for a system that analyzes the structure of Binary Search Trees (BST). You need to count all the empty branches (i.e., missing left or right child nodes) in a given BST. An empty tree is considered as having one empty branch. Task: Implement a function `num_empty(root)` to count the total number of empty branches in a given BST. Input: * `root`: The root node of the BST or `None` if the tree is empty. * The structure of BST nodes is as follows: ```python class Node: def __init__(self, value): self.value = value self.left = None self.right = None ``` Output: * Returns an integer representing the number of empty branches. Constraints: * Assume that the input provided is always a valid BST or `None`. Performance Requirements: * Time Complexity should be O(n), where n is the number of nodes in the BST. * Space Complexity should be O(h), where h is the height of the BST due to recursion stack. Example: For the BST depicted, ``` 9 / 6 12 / / 3 8 10 15 / 7 18 ``` The function call `num_empty(root)` should return `10`. Function Signature: ```python def num_empty(root): # your code here ``` Testing: Use the following template for testing: ```python import unittest class TestNumEmpty(unittest.TestCase): def test_case_1(self): root = Node(9) root.left = Node(6) root.right = Node(12) root.left.left = Node(3) root.left.right = Node(8) root.right.left = Node(10) root.right.right = Node(15) root.left.right.left = Node(7) root.right.right.right = Node(18) self.assertEqual(num_empty(root), 10) def test_case_2(self): root = None self.assertEqual(num_empty(root), 1) if __name__ == \'__main__\': unittest.main() ``` Implement the function `num_empty` such that all the tests pass successfully.","solution":"class Node: def __init__(self, value): self.value = value self.left = None self.right = None def num_empty(root): if root is None: return 1 count = 0 if root.left is None: count += 1 else: count += num_empty(root.left) if root.right is None: count += 1 else: count += num_empty(root.right) return count"},{"question":"Design and implement a function `find_shortest_transformation(begin_word: str, end_word: str, word_list: List[str]) -> int` that determines the length of the shortest transformation sequence from `begin_word` to `end_word`. Each intermediate word in the transformation sequence must be in the `word_list`, and only one letter can be changed at a time. # Inputs: * `begin_word`: A string representing the starting word. * `end_word`: A string representing the target word. * `word_list`: A list of strings representing the dictionary of possible intermediate words. # Output: * An integer representing the length of the shortest transformation sequence from `begin_word` to `end_word`, or `-1` if no such transformation sequence exists. # Constraints: * All words have the same length. * All words contain only lowercase alphabetic characters. # Example: ```python begin_word = \\"hit\\" end_word = \\"cog\\" word_list = [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\", \\"cog\\"] # Expected output: 5 (\\"hit\\" -> \\"hot\\" -> \\"dot\\" -> \\"dog\\" -> \\"cog\\") print(find_shortest_transformation(begin_word, end_word, word_list)) # Output: 5 ``` # Implementation Requirements: * Utilize bidirectional breadth-first search to optimize the solution. * Ensure that the function handles edge cases gracefully. * Ensure that words are processed efficiently using appropriate data structures.","solution":"from collections import deque from typing import List, Set def find_shortest_transformation(begin_word: str, end_word: str, word_list: List[str]) -> int: if end_word not in word_list: return -1 word_set = set(word_list) begin_set, end_set = {begin_word}, {end_word} length = len(begin_word) visited = set([begin_word, end_word]) step = 1 while begin_set and end_set: if len(begin_set) > len(end_set): begin_set, end_set = end_set, begin_set next_set = set() for word in begin_set: for i in range(length): for char in \'abcdefghijklmnopqrstuvwxyz\': new_word = word[:i] + char + word[i + 1:] if new_word in end_set: return step + 1 if new_word in word_set and new_word not in visited: next_set.add(new_word) visited.add(new_word) begin_set = next_set step += 1 return -1"},{"question":"# Longest Increasing Subsequence with Optimized Algorithms Problem Statement: Given an unsorted list of integers, your task is to write functions to find the length of the longest increasing subsequence (LIS). You need to implement the following three functions: 1. `longest_increasing_subsequence(sequence)`: Use a dynamic programming approach with O(n²) time complexity. 2. `longest_increasing_subsequence_optimized(sequence)`: Use an optimized dynamic programming approach with segment tree to achieve better performance for large maximum values in the sequence. 3. `longest_increasing_subsequence_optimized2(sequence)`: Use an optimized dynamic programming approach with segment tree to achieve O(nlogn) complexity. Input Format: - A single list `sequence` of `n` integers where 1 <= n <= 10⁵. Output Format: - An integer representing the length of the longest increasing subsequence. Examples: Example 1: ``` Input: [10,9,2,5,3,7,101,18] Output: 4 Explanation: The longest increasing subsequence is [2,3,7,101], so the length is 4. ``` Example 2: ``` Input: [0,1,0,3,2,3] Output: 4 Explanation: The longest increasing subsequence is [0,1,2,3], so the length is 4. ``` Example 3: ``` Input: [7,7,7,7,7,7,7] Output: 1 Explanation: The longest increasing subsequence is [7], so the length is 1. ``` Constraints: - Ensure that your solution for `longest_increasing_subsequence` runs within O(n²) time complexity. - Ensure that your solution for `longest_increasing_subsequence_optimized` runs within O(nlog(max(sequence))) time complexity. - Ensure that your solution for `longest_increasing_subsequence_optimized2` runs within O(nlogn) time complexity. Performance Requirements: - Your solution should handle sequences with the maximum length (10⁵ elements) efficiently. - Consider worst-case scenarios such as sequences with large ranges of values or strictly decreasing sequences. Write your solutions as functions in Python: ```python def longest_increasing_subsequence(sequence): pass def longest_increasing_subsequence_optimized(sequence): pass def longest_increasing_subsequence_optimized2(sequence): pass ```","solution":"def longest_increasing_subsequence(sequence): Finds the length of the longest increasing subsequence using a dynamic programming approach. This implementation has a time complexity of O(n^2). if not sequence: return 0 n = len(sequence) dp = [1] * n for i in range(1, n): for j in range(i): if sequence[i] > sequence[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"Implement a Recursive Merge Sort Objective: Implement a Merge Sort algorithm to sort an array of integers, showcasing your understanding of divide-and-conquer strategies, recursive function implementation, and array manipulation. Description: Write a function `merge_sort(arr)` that sorts the given list of integers in ascending order using the Merge Sort algorithm. Your implementation should efficiently handle the merging step without creating excessive additional arrays. Function Signature: ```python def merge_sort(arr: List[int]) -> List[int]: pass ``` Input: - `arr`: A list of integers (1 ≤ len(arr) ≤ 10^5). Output: - A list of integers sorted in ascending order. Example: ```python Input: [38, 27, 43, 3, 9, 82, 10] Output: [3, 9, 10, 27, 38, 43, 82] ``` Constraints: - You must implement the merge process in a way that mutates the original list or uses minimum additional space. - The function should handle large lists efficiently. Guide: - Consider defining a helper function to handle the merge process. - Ensure proper handling of edge cases such as empty input or a single-element list. - Think through managing the array indices carefully to avoid common errors such as index out of bounds.","solution":"from typing import List def merge_sort(arr: List[int]) -> List[int]: if len(arr) <= 1: return arr mid = len(arr) // 2 left = merge_sort(arr[:mid]) right = merge_sort(arr[mid:]) return merge(left, right) def merge(left: List[int], right: List[int]) -> List[int]: sorted_array = [] i = j = 0 while i < len(left) and j < len(right): if left[i] < right[j]: sorted_array.append(left[i]) i += 1 else: sorted_array.append(right[j]) j += 1 while i < len(left): sorted_array.append(left[i]) i += 1 while j < len(right): sorted_array.append(right[j]) j += 1 return sorted_array"},{"question":"Scenario: You are the lead engineer in a software company that deals with massive datasets. One of the routine tasks involves rapid searching in data that is periodically reset, leading to a rotated but sorted structure. To efficiently handle this task, you need to implement a search function capable of locating target values in these rotated arrays. Task: Implement a function `find_in_rotated_array` that accepts a list of integers `nums` and an integer `target`. The list `nums` is sorted in ascending order but has been rotated at an unknown pivot point. The function should return the index of `target` in `nums` if it exists, otherwise return -1. Function Signature: ```python def find_in_rotated_array(nums: List[int], target: int) -> int: pass ``` Input: - `nums`: A list of integers where the list is sorted in ascending order but is rotated at an unknown pivot. `1 <= nums.length <= 5000`. - `target`: An integer indicating the value to search for within the array. `-10^4 <= target <= 10^4`. Output: - Returns the 0-based index of the `target` in the list `nums` if found, otherwise returns -1. Constraints: - Your solution must run in O(log n) time complexity. - The array may contain duplicate values. Example: ```python # Example 1: nums = [4, 5, 6, 7, 0, 1, 2] target = 0 # Output: 4 # Example 2: nums = [4, 5, 6, 7, 0, 1, 2] target = 3 # Output: -1 # Example 3: nums = [1] target = 0 # Output: -1 ``` Notes: - The array can have a length of at least one to handle edge cases. - Consider any potential performance bottlenecks or error scenarios during implementation.","solution":"from typing import List def find_in_rotated_array(nums: List[int], target: int) -> int: Searches for a target in a rotated sorted array and returns its index if found, otherwise returns -1. left, right = 0, len(nums) - 1 while left <= right: mid = (left + right) // 2 if nums[mid] == target: return mid if nums[left] <= nums[mid]: # Left part is sorted if nums[left] <= target < nums[mid]: right = mid - 1 else: left = mid + 1 else: # Right part is sorted if nums[mid] < target <= nums[right]: left = mid + 1 else: right = mid - 1 return -1"},{"question":"# Scenario: You are working as an engineer at a software company developing a code editor. One of the essential features of the editor is to highlight syntax errors where brackets do not match correctly. To achieve this, you need to write a function that determines if a string containing various types of brackets is valid. # Challenge: Write a function `is_valid` that receives a string `s` containing just the characters \'(\', \')\', \'{\', \'}\', \'[\' and \']\', and returns `True` if the input string is valid. An input string is valid if: 1. Open brackets are closed by the same type of brackets. 2. Open brackets are closed in the correct order. Function Signature: ```python def is_valid(s: str) -> bool: pass ``` Input: - `s` is a string consisting of \'(\', \')\', \'{\', \'}\', \'[\' and \']\'. - Length of `s` is between `0` and `10000`. Output: - Return `True` if the string is valid, otherwise return `False`. Examples: 1. `is_valid(\\"()\\")` should return `True` 2. `is_valid(\\"()[]{}\\")` should return `True` 3. `is_valid(\\"(]\\")` should return `False` 4. `is_valid(\\"([)]\\")` should return `False` 5. `is_valid(\\"{[]}\\")` should return `True` Constraints: - Ensure the algorithm runs efficiently with a time complexity of O(n) and space complexity of O(n). Additional Notes: - Consider edge cases like empty strings, single types of brackets, and mixed types of valid/invalid bracket sequences. - No external libraries should be used; implement your solution using basic data structures and constructs.","solution":"def is_valid(s: str) -> bool: This function checks if a given string of parentheses is valid. A string is considered valid if: 1. Open brackets are closed by the same type of brackets. 2. Open brackets are closed in the correct order. # Stack to keep track of opening brackets. stack = [] # Dictionary to hold mappings of open and close brackets. bracket_map = {\')\': \'(\', \'}\': \'{\', \']\': \'[\'} # Iterate over each character in the string. for char in s: # If the character is a closing bracket. if char in bracket_map: # Pop the top element from the stack if it is not empty, otherwise assign a dummy value. top_element = stack.pop() if stack else \'#\' # If the mapped opening bracket does not match the top element, return False. if bracket_map[char] != top_element: return False else: # If it is an opening bracket, push it onto the stack. stack.append(char) # If the stack is empty, all brackets were matched correctly; otherwise, return False. return not stack"},{"question":"# Word Pattern Matching Given a pattern and a string str, your task is to determine if `str` follows the same pattern. Here \'follows the same pattern\' means establishing a full match between a letter in the pattern and a non-empty word in `str`, ensuring a bijection between the letters and the words. Write a function `word_pattern(pattern: str, str: str) -> bool` that returns `True` if `str` follows the `pattern`, and `False` otherwise. # Input * `pattern` is a non-empty string composed of lowercase letters. * `str` is a non-empty string where words are separated by a single space. # Output * Return a boolean indicating whether the string `str` follows the pattern. # Constraints * The lengths of `pattern` and `str` must be non-zero. * The words and pattern are case-sensitive and contain only lowercase alphabetical characters. # Scenario Imagine you are working on a text formatting tool that validates whether certain text samples follow predefined structural patterns. This function will be an essential part of your validation library to ensure compliant text formatting. # Example ```python pattern = \\"abba\\" str = \\"dog cat cat dog\\" output = True pattern = \\"abba\\" str = \\"dog cat cat fish\\" output = False pattern = \\"aaaa\\" str = \\"dog cat cat dog\\" output = False pattern = \\"abba\\" str = \\"dog dog dog dog\\" output = False ``` # Notes * You may assume the pattern contains only lowercase letters, and `str` contains lowercase letters separated by single spaces.","solution":"def word_pattern(pattern: str, str: str) -> bool: words = str.split() if len(pattern) != len(words): return False char_to_word = {} word_to_char = {} for char, word in zip(pattern, words): if char in char_to_word: if char_to_word[char] != word: return False else: if word in word_to_char: return False char_to_word[char] = word word_to_char[word] = char return True"},{"question":"You are provided with a partial implementation of a Red-Black Tree. Your task is to complete and extend this implementation by adding the following features: 1. Write a method to find a node in the tree given its value. 2. Write a method to print all nodes\' values in level-order traversal (breadth-first search). # Function Signatures: ```python def find_node(self, value: int) -> Union[RBNode, None]: Return the node with the given value if it exists, else return None. :param value: Integer value to be searched in the tree. :return: The node with the given value or None if it does not exist. def level_order(self) -> List[int]: Return a list of all node values in the Red-Black Tree in level order traversal. :return: List of integers representing values of nodes in level-order traversal. ``` # Input: - `find_node`: A single integer representing the value to search. - `level_order`: No input. # Output: - `find_node`: Returns the node with the provided value if found, otherwise `None`. - `level_order`: A list of integers, representing the values of nodes in level-order traversal of the tree. # Constraints: - All node values are unique. - Tree operations (insertions and deletions) are valid and maintain the Red-Black Tree properties. # Implementation Notes: - Implement the `find_node` method using a standard binary search mechanism. - Implement the `level_order` method utilizing the breadth-first search algorithm. # Example: Given the tree rooted at `rb`: ```python rb = RBTree() children = [11, 2, 14, 1, 7, 15, 5, 8, 4] for child in children: node = RBNode(child, 1) rb.insert(node) ``` - `rb.find_node(7)` should return the node with value 7 (including node details such as color). - `rb.find_node(12)` should return `None`. - `rb.level_order()` should return `[11, 2, 14, 1, 7, 15, 5, 8, 4]`. # Starter Code: ```python class RBNode: def __init__(self, val, is_red, parent=None, left=None, right=None): self.val = val self.parent = parent self.left = left self.right = right self.color = is_red class RBTree: def __init__(self): self.root = None def find_node(self, value: int) -> Union[RBNode, None]: # Implement this method def level_order(self) -> List[int]: # Implement this method # (Other methods from the initial implementation) ``` # Assumptions: - Assume the `RBNode` and other initial methods from the given code snippets are correctly implemented. - Assume a suitable environment setup where basic classes like `RBNode` and inserted values are unique.","solution":"from typing import Union, List, Optional class RBNode: def __init__(self, val: int, is_red: bool, parent: Optional[\'RBNode\'] = None, left: Optional[\'RBNode\'] = None, right: Optional[\'RBNode\'] = None): self.val = val self.parent = parent self.left = left self.right = right self.color = is_red class RBTree: def __init__(self): self.root = None def find_node(self, value: int) -> Optional[RBNode]: Return the node with the given value if it exists, else return None. :param value: Integer value to be searched in the tree. :return: The node with the given value or None if it does not exist. current = self.root while current: if value < current.val: current = current.left elif value > current.val: current = current.right else: return current return None def level_order(self) -> List[int]: Return a list of all node values in the Red-Black Tree in level order traversal. :return: List of integers representing values of nodes in level-order traversal. if self.root is None: return [] result = [] queue = [self.root] while queue: current = queue.pop(0) result.append(current.val) if current.left: queue.append(current.left) if current.right: queue.append(current.right) return result def insert(self, node: RBNode): A simple insertion method to add nodes for the purpose of testing. Note: The red-black properties are not maintained in this simplified implementation. if self.root is None: self.root = node return current = self.root while current: if node.val < current.val: if current.left is None: current.left = node node.parent = current return current = current.left else: if current.right is None: current.right = node node.parent = current return current = current.right"},{"question":"You are working on a text processing application and need to implement a function to find the first occurrence of a substring in a main string. Optimizing for edge cases and performance will be critical due to the application\'s large data sets. # Function Signature: ```python def contain_string(haystack: str, needle: str) -> int: ``` # Input: * `haystack` (str): The main string where you need to search for `needle`. * `needle` (str): The substring that you are searching for in `haystack`. # Output: * `int`: The index of the first occurrence of `needle` in `haystack`, or -1 if `needle` is not part of `haystack`. # Constraints: * `0 <= len(haystack) <= 2 * 10^5` * `0 <= len(needle) <= 10^4` # Examples: ```python assert contain_string(\\"hello\\", \\"ll\\") == 2 assert contain_string(\\"aaaaa\\", \\"bba\\") == -1 assert contain_string(\\"\\", \\"\\") == 0 assert contain_string(\\"abc\\", \\"\\") == 0 assert contain_string(\\"\\", \\"a\\") == -1 assert contain_string(\\"abcdef\\", \\"def\\") == 3 ``` # Notes: * Your implementation should consider edge cases, such as: * When `needle` is an empty string, return 0. * When `needle` is longer than `haystack`, return -1. * Handle large strings efficiently to prevent timeouts. # Additional Requirement: * Optimize your algorithm beyond the brute-force method to handle large inputs efficiently.","solution":"def contain_string(haystack: str, needle: str) -> int: Returns the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack. # Edge case: if needle is an empty string, return 0 if needle == \\"\\": return 0 needle_len = len(needle) haystack_len = len(haystack) # Edge case: if needle is longer than haystack, return -1 if needle_len > haystack_len: return -1 # Use built-in find method for efficiency return haystack.find(needle)"},{"question":"Context You are given a string containing multiple words. The goal is to reverse the order of the words in the string while maintaining the stability of the words themselves (i.e., each word\'s characters should remain in the same order). Additionally, you should ensure that multiple spaces between words are reduced to a single space in the final output, and leading or trailing spaces should be removed. Task Write a function `reverse_words(string: str) -> str` that takes a string as input and returns a new string with the order of words reversed. Input - A single string `string` containing words separated by spaces. The string may contain leading or trailing spaces and multiple spaces between words. - **Constraints**: - The input string can be up to 10^6 characters long. Output - A string with the order of words reversed, with single spaces between words, and no leading or trailing spaces. Examples 1. **Input**: \\"I am a student\\" **Output**: \\"student a am I\\" 2. **Input**: \\" Hello, world! \\" **Output**: \\"world! Hello,\\" 3. **Input**: \\"Python is great\\" **Output**: \\"great is Python\\" 4. **Input**: \\" \\" **Output**: \\"\\" Performance Requirements - The function must run in O(n) time complexity, where n is the length of the input string. - The function should use O(n) additional space at most.","solution":"def reverse_words(string: str) -> str: Reverses the order of words in a given string, reducing multiple spaces to a single space, and removing any leading or trailing spaces. Args: string (str): The input string containing words separated by spaces. Returns: str: The string with the order of words reversed. # Split the string by spaces to get the words words = string.split() # Reverse the list of words words.reverse() # Join the words with a single space reversed_string = \' \'.join(words) return reversed_string"},{"question":"# Question: Modified Climbing Stairs with Restrictions Problem Statement You are climbing a staircase that has `steps` steps. It takes `steps` number of steps to reach to the top. But this time, you can climb either 1 step, 2 steps, or a maximum of `k` steps at a time. Write a function `climb_stairs_with_max_step(steps, k)` to determine the number of distinct ways you can climb to the top under these constraints. Function Signature: ```python def climb_stairs_with_max_step(steps: int, k: int) -> int: :param steps: int - the total number of steps to reach the top :param k: int - the maximum steps you can climb at a time :return: int - number of distinct ways to reach the top ``` Input * An integer `steps` (1 <= steps <= 1000) - the total number of steps to climb. * An integer `k` (1 <= k <= 100) - the maximum steps you can climb at a time. Output * An integer representing the number of distinct ways to climb the staircase following the given constraints. Example 1. `climb_stairs_with_max_step(steps=3, k=2)` should return `3`. - Explanation: (1, 1, 1), (1, 2), and (2, 1) 2. `climb_stairs_with_max_step(steps=4, k=3)` should return `7`. - Explanation: (1, 1, 1, 1), (1, 1, 2), (1, 2, 1), (2, 1, 1), (2, 2), (1, 3), and (3, 1) Constraints * Your solution should be efficient, with time complexity ideally not more than O(steps * k). Hints * Think in terms of dynamic programming. How would you modify the original dynamic programming approach to account for the maximum step constraint `k`?","solution":"def climb_stairs_with_max_step(steps: int, k: int) -> int: Returns the number of distinct ways to reach the top of the staircase with max steps restriction k. if steps == 0: return 0 # Initialize dp array where dp[i] will store the number of ways to reach step i dp = [0] * (steps + 1) # Base case: there\'s one way to stay at the ground (step 0) dp[0] = 1 # Fill the dp array for i in range(1, steps + 1): for j in range(1, k + 1): if i - j >= 0: dp[i] += dp[i - j] return dp[steps]"},{"question":"# Question: Implement an Efficient Ordered Stack You are required to implement a stack data structure where elements are maintained in a sorted order, with the highest element always at the top. This stack should provide efficient operations for the push, pop, peek, and size functionalities. Implement a class `OrderedStack` with the following methods: 1. `push(self, item: int) -> None`: Adds an item to the stack while maintaining the order. 2. `pop(self) -> int`: Removes and returns the top element of the stack. 3. `peek(self) -> int`: Returns the top element without removing it. 4. `is_empty(self) -> bool`: Returns True if the stack is empty, otherwise False. 5. `size(self) -> int`: Returns the number of elements in the stack. Constraints: - All elements pushed to the stack are integers. - All stack operations must run within typical stack operation constraints, with `push` potentially taking longer due to sorting. - The stack operates using an internal list. Performance Requirements: - `push` should have an average time complexity of O(n) in the worst case. - `pop`, `peek`, `is_empty`, and `size` should operate in constant time O(1). Example: ```python ordered_stack = OrderedStack() ordered_stack.push(4) ordered_stack.push(1) ordered_stack.push(3) print(ordered_stack.pop()) # Output: 4 print(ordered_stack.peek()) # Output: 3 print(ordered_stack.size()) # Output: 2 print(ordered_stack.is_empty()) # Output: False ``` > Note: Ensure you handle edge cases such as popping or peeking from an empty stack correctly by raising appropriate exceptions.","solution":"class OrderedStack: def __init__(self): self.stack = [] def push(self, item: int) -> None: Adds an item to the stack while maintaining the order. index = 0 while index < len(self.stack) and self.stack[index] > item: index += 1 self.stack.insert(index, item) def pop(self) -> int: Removes and returns the top element of the stack. if self.is_empty(): raise IndexError(\\"pop from empty stack\\") return self.stack.pop(0) def peek(self) -> int: Returns the top element without removing it. if self.is_empty(): raise IndexError(\\"peek from empty stack\\") return self.stack[0] def is_empty(self) -> bool: Returns True if the stack is empty, otherwise False. return len(self.stack) == 0 def size(self) -> int: Returns the number of elements in the stack. return len(self.stack)"},{"question":"Given an array `arr` of integers, and two optional bounds `min_lim` and `max_lim`, write a function `bounded_filter(arr, min_lim=None, max_lim=None)` that returns a new array containing only the elements from `arr` that are greater than or equal to `min_lim` and less than or equal to `max_lim`. If `min_lim` or `max_lim` are not provided (i.e., they are `None`), they should be treated as unbounded (for `min_lim` use the smallest value in `arr`, for `max_lim` use the largest value in `arr`). # Input - `arr` (list of integers): An array of integers. - `min_lim` (integer or None, optional): The lower bound for filter criteria. Consider `None` as not setting any lower bound. - `max_lim` (integer or None, optional): The upper bound for filter criteria. Consider `None` as not setting any upper bound. # Output - Returns a list of integers containing only elements that satisfy the filter criteria. # Constraints - The array `arr` will have at most 10^5 elements. - Each integer in `arr` will be between -10^6 and 10^6. - `min_lim` and `max_lim` (if provided as integers) will be within the range of -10^6 to 10^6. # Example ```python def bounded_filter(arr, min_lim=None, max_lim=None): # Your code here # Example 1 print(bounded_filter([1, 2, 3, 4, 5], None, 3)) # Output: [1, 2, 3] # Example 2 print(bounded_filter([10, 20, 30, 40, 50], 15, None)) # Output: [20, 30, 40, 50] # Example 3 print(bounded_filter([], 0, 10)) # Output: [] # Example 4 print(bounded_filter([5, 5, 5, 5, 5], 5, 5)) # Output: [5, 5, 5, 5, 5] # Example 5 print(bounded_filter([1, 2, 3, 4, 5], None, None)) # Output: [1, 2, 3, 4, 5] ``` # Explanation - Example 1: Filters values less than or equal to 3. The resulting array includes values [1, 2, 3]. - Example 2: Filters values greater than or equal to 15. The resulting array is [20, 30, 40, 50]. - Example 3: The input is an empty array, so the result is also an empty array. - Example 4: All elements are equal to the bounds, so the entire array is returned. - Example 5: No bounds are provided, so the entire array is returned unmodified.","solution":"def bounded_filter(arr, min_lim=None, max_lim=None): Filters the array `arr` to only include elements that are greater than or equal to `min_lim` and less than or equal to `max_lim`. If `min_lim` or `max_lim` are None, they are treated as unbounded limits. if not arr: return [] if min_lim is None: min_lim = min(arr) if max_lim is None: max_lim = max(arr) return [x for x in arr if min_lim <= x <= max_lim]"},{"question":"Design a function to resize a Separate Chaining Hash Table once its load factor (number of elements / size of table) exceeds a certain threshold. The function should ensure that all existing key-value pairs are rehashed to their new positions in the resized table. You are given an initial implementation of the Separate Chaining Hash Table. Function Signature ```python def resize_hash_table(hash_table: SeparateChainingHashTable, new_size: int) -> None: pass ``` # Inputs - `hash_table`: An instance of `SeparateChainingHashTable`. - `new_size`: An integer indicating the new size of the hash table. # Outputs - This function should modify the input `hash_table` in place. It does not return any value. # Constraints - The initial size of `hash_table` will be a positive integer. - `new_size` will be a larger integer than the initial size of `hash_table`. - Keys are assumed to be hashable objects. - The hash table should maintain its correct logic and efficiency after resizing. # Example ```python table = SeparateChainingHashTable(5) table.put(\'a\', 1) table.put(\'b\', 2) table.put(\'c\', 3) table.put(\'d\', 4) resize_hash_table(table, 10) assert len(table) == 4 assert table.get(\'a\') == 1 assert table.get(\'b\') == 2 assert table.get(\'c\') == 3 assert table.get(\'d\') == 4 ``` Performance Requirements - The resize operation should ideally be completed in O(n) time complexity, where `n` is the number of elements in the hash table.","solution":"class SeparateChainingHashTable: def __init__(self, initial_size=5): self.table_size = initial_size self.table = [[] for _ in range(self.table_size)] self.element_count = 0 def _hash(self, key): return hash(key) % self.table_size def put(self, key, value): self.remove(key) hashed_key = self._hash(key) self.table[hashed_key].append((key, value)) self.element_count += 1 def get(self, key): hashed_key = self._hash(key) for k, v in self.table[hashed_key]: if k == key: return v return None def remove(self, key): hashed_key = self._hash(key) for i, (k, v) in enumerate(self.table[hashed_key]): if k == key: del self.table[hashed_key][i] self.element_count -= 1 return def __len__(self): return self.element_count def resize_hash_table(hash_table: SeparateChainingHashTable, new_size: int) -> None: old_table = hash_table.table hash_table.table_size = new_size hash_table.table = [[] for _ in range(new_size)] hash_table.element_count = 0 for bucket in old_table: for (key, value) in bucket: hash_table.put(key, value)"},{"question":"**Context**: A postorder traversal of a binary tree is an important technique in computer science, particularly useful in applications such as expression evaluation and hierarchical processing. Your task is to implement the postorder traversal both iteratively and recursively in Python. **Assignment**: Write two functions: 1. `postorder_iterative(root)` - This function performs iterative postorder traversal on a binary tree. 2. `postorder_recursive(root)` - This function performs recursive postorder traversal on a binary tree. * **Input**: `root` - The root node of the binary tree. The `Node` class is predefined as follows: ```python class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right ``` * **Output**: A list of node values in postorder traversal order. **Constraints**: * The number of nodes in the tree is in the range [0, 1000]. * The value of each node is an integer. * You must handle trees with duplicate values. * The solution must work efficiently for both small and very large trees. **Examples**: 1. Given the binary tree: ``` 1 / 2 3 ``` - The `postorder_iterative` output should be: `[2, 3, 1]` - The `postorder_recursive` output should be: `[2, 3, 1]` 2. Given the binary tree: ``` 4 / 5 6 / 7 8 ``` - The `postorder_iterative` output should be: `[7, 8, 5, 6, 4]` - The `postorder_recursive` output should be: `[7, 8, 5, 6, 4]` Implement the identified functions ensuring to handle edge cases and optimize where necessary.","solution":"class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right def postorder_iterative(root): Performs iterative postorder traversal on a binary tree. if root is None: return [] stack = [root] output = [] while stack: node = stack.pop() output.append(node.val) if node.left: stack.append(node.left) if node.right: stack.append(node.right) return output[::-1] def postorder_recursive(root): Performs recursive postorder traversal on a binary tree. def recurse(node): if node is None: return [] return recurse(node.left) + recurse(node.right) + [node.val] return recurse(root)"},{"question":"You are provided with a graph represented using adjacency lists. The graph can have up to 100 vertices. Your task is to find the transitive closure of this graph using the DFS-based approach. # Input 1. An integer `V` representing the number of vertices in the graph. 2. An integer `E` representing the number of directed edges in the graph. 3. A list of `E` pairs of integers `edges` where each `edges[i] = [u, v]` indicates a directed edge from vertex `u` to vertex `v`. # Output Return a 2D list `closure` where `closure[i][j]` is `1` if there is a path from vertex `i` to vertex `j`, otherwise `0`. # Constraints & Requirements - 1 ≤ V ≤ 100 - 0 ≤ E ≤ 10,000 - 0 ≤ u, v < V # Example **Input**: ``` V = 4 E = 4 edges = [[0, 1], [1, 2], [2, 3], [3, 0]] ``` **Output**: ``` [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]] ``` # Coding Task Implement the function `find_transitive_closure(V, E, edges)`: ```python def find_transitive_closure(V, E, edges): class Graph: def __init__(self, vertices): self.vertex_count = vertices self.graph = {} self.closure = [[0 for j in range(vertices)] for i in range(vertices)] def add_edge(self, source, target): if source in self.graph: self.graph[source].append(target) else: self.graph[source] = [target] def dfs_util(self, source, target): self.closure[source][target] = 1 for adjacent in self.graph.get(target, []): if self.closure[source][adjacent] == 0: self.dfs_util(source, adjacent) def find_transitive_closure(self): for i in range(self.vertex_count): self.dfs_util(i, i) return self.closure graph = Graph(V) for u, v in edges: graph.add_edge(u, v) return graph.find_transitive_closure() # Example Usage V = 4 E = 4 edges = [[0, 1], [1, 2], [2, 3], [3, 0]] print(find_transitive_closure(V, E, edges)) # Expected output: [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]] ```","solution":"def find_transitive_closure(V, E, edges): class Graph: def __init__(self, vertices): self.vertex_count = vertices self.graph = {} self.closure = [[0 for j in range(vertices)] for i in range(vertices)] def add_edge(self, source, target): if source in self.graph: self.graph[source].append(target) else: self.graph[source] = [target] def dfs_util(self, source, target): self.closure[source][target] = 1 for adjacent in self.graph.get(target, []): if self.closure[source][adjacent] == 0: self.dfs_util(source, adjacent) def find_transitive_closure(self): for i in range(self.vertex_count): self.dfs_util(i, i) return self.closure graph = Graph(V) for u, v in edges: graph.add_edge(u, v) return graph.find_transitive_closure() # Example Usage V = 4 E = 4 edges = [[0, 1], [1, 2], [2, 3], [3, 0]] print(find_transitive_closure(V, E, edges)) # Expected output: [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]]"},{"question":"**Matrix Transformations Challenge** # Context Imagine you\'re developing a photo editing application, and part of your job is to implement various transformations on images represented as square matrices. Each element in the matrix represents a pixel value. # Objective Implement a function to perform any of the following transformations on a given n x n matrix: 1. **Rotate Clockwise**: Rotate the matrix 90 degrees to the right. 2. **Rotate Counterclockwise**: Rotate the matrix 90 degrees to the left. 3. **Top Left Invert**: Mirror the matrix across its top-left to bottom-right diagonal. 4. **Bottom Left Invert**: Mirror the matrix across its bottom-left to top-right diagonal. # Task Implement a function called `transform_matrix` that accepts two parameters: - `matrix`: a list of lists representing the n x n matrix. - `operation`: a string that can be one of `\\"rotate_clockwise\\"`, `\\"rotate_counterclockwise\\"`, `\\"top_left_invert\\"`, or `\\"bottom_left_invert\\"` indicating the type of transformation to perform. The function should return the transformed matrix. # Function Definition ```python def transform_matrix(matrix, operation): # Your code here ``` # Input - `matrix`: List of lists of integers, with dimensions n x n (1 <= n <= 100). - `operation`: A string of one of the specified transformation operations. # Output - A list of lists representing the transformed matrix. # Constraints - The matrix will always be non-empty and square. - Every element in the matrix will be an integer between -1000 and 1000. # Examples ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] print(transform_matrix(matrix, \\"rotate_clockwise\\")) # Expected output: # [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] print(transform_matrix(matrix, \\"rotate_counterclockwise\\")) # Expected output: # [ # [3, 6, 9], # [2, 5, 8], # [1, 4, 7] # ] print(transform_matrix(matrix, \\"top_left_invert\\")) # Expected output: # [ # [1, 4, 7], # [2, 5, 8], # [3, 6, 9] # ] print(transform_matrix(matrix, \\"bottom_left_invert\\")) # Expected output: # [ # [9, 6, 3], # [8, 5, 2], # [7, 4, 1] # ] ``` # Note Ensure that your function handles all the edge cases described in the analysis section. Performance should be efficient enough to handle large matrices up to 100x100 within a reasonable time frame.","solution":"def transform_matrix(matrix, operation): n = len(matrix) def rotate_clockwise(mat): return [[mat[n - 1 - j][i] for j in range(n)] for i in range(n)] def rotate_counterclockwise(mat): return [[mat[j][n - 1 - i] for j in range(n)] for i in range(n)] def top_left_invert(mat): return [[mat[j][i] for j in range(n)] for i in range(n)] def bottom_left_invert(mat): return [[mat[n - 1 - j][n - 1 - i] for j in range(n)] for i in range(n)] if operation == \\"rotate_clockwise\\": return rotate_clockwise(matrix) elif operation == \\"rotate_counterclockwise\\": return rotate_counterclockwise(matrix) elif operation == \\"top_left_invert\\": return top_left_invert(matrix) elif operation == \\"bottom_left_invert\\": return bottom_left_invert(matrix) else: raise ValueError(\\"Invalid operation\\")"},{"question":"You have been provided with two functions that participate in switching successive pairs of numbers in a stack: `first_switch_pairs` which uses an auxiliary stack for storage, and `second_switch_pairs` which uses a queue. Your task is to implement a third function called `optimized_switch_pairs`. Problem Statement: Design a function `optimized_switch_pairs` that switches successive pairs of numbers starting at the bottom of the stack. Aim to maintain or improve upon the space complexity while ensuring correct functionality like the other two provided solutions. # Constraints: 1. The input stack can be of any size, including zero. 2. If the number of elements in the stack is odd, the top-most element should remain unchanged. 3. You can only use one auxiliary data structure and try to optimize the space usage. # Input: - A stack represented by a list of integers, e.g., `[3, 8, 17, 9, 1, 10]`. # Output: - The modified stack with pairs switched, e.g., `[8, 3, 9, 17, 10, 1]`. # Example: # Input: ```python stack = [3, 8, 17, 9, 1] ``` # Output: ```python [8, 3, 9, 17, 1] ``` # Function Signature: ```python def optimized_switch_pairs(stack): # Your implementation here pass ``` # Notes: - You can assume that the provided stack is mutable and can be modified in place. - The solution should ideally aim to use only a single additional data structure apart from the original stack. Good luck!","solution":"def optimized_switch_pairs(stack): This function switches successive pairs of numbers starting from the bottom of the stack. If the stack has an odd number of elements, the top-most element remains unchanged. from collections import deque # A queue to temporarily hold elements queue = deque() # Moving all elements from stack to queue while stack: queue.append(stack.pop()) # Moving elements from queue back to stack while queue: stack.append(queue.popleft()) # Now the elements are in reverse order. Switch pairs as we push back into queue. while stack: first = stack.pop() if stack: # Check if there\'s a second element to form a pair. second = stack.pop() queue.append(second) queue.append(first) # Moving elements back from the queue to the stack while queue: stack.append(queue.popleft()) return stack"},{"question":"# Question You are tasked with designing an algorithm to encode a list of strings into a single string and decode it back to the original list of strings. This process is essential for safely transmitting data over a network where the data can sometimes be fragmented or need to be stored in a compact form. Implement the following two methods: 1. `encode(strs: List[str]) -> str`: - **Input**: `strs` is a list of strings that we want to encode. - **Output**: A single string which is the encoded representation of the list of strings. 2. `decode(s: str) -> List[str]`: - **Input**: `s` is a single string that represents the encoded data. - **Output**: A list of strings that have been decoded from the encoded string. **Your implementation should handle the following constraints**: - Strings can contain any character, including numerals and special characters. - The size of each string will be in the range of `1 <= len(string) <= 1000`. - The total number of characters in the input to encode will be in the range of `0 <= sum(len(string) for string in strs) <= 2 * 10^4`. Example ```python encoded_str = encode([\\"hello\\", \\"world\\"]) print(encoded_str) # Output: \\"5:hello5:world\\" decoded_list = decode(\\"5:hello5:world\\") print(decoded_list) # Output: [\\"hello\\", \\"world\\"] ``` Scenario: Consider you are working on a messaging system where messages can be split into multiple parts and need to be reconstructed upon receipt. You need to encode messages into a single string for transmission and decode them back into their original form upon receipt to ensure no data is lost. Write the implementation for the `encode` and `decode` functions ensuring you handle edge cases and optimize for time and space complexity.","solution":"from typing import List def encode(strs: List[str]) -> str: Encodes a list of strings to a single string. encoded_str = \'\'.join(f\'{len(s)}:{s}\' for s in strs) return encoded_str def decode(s: str) -> List[str]: Decodes a single string to a list of strings. i, length = 0, len(s) decoded_list = [] while i < length: # Find the position of the delimiter \':\' j = s.find(\':\', i) # Get the length of the string, which is before the \':\' str_len = int(s[i:j]) # Get the actual string using the length found above decoded_str = s[j + 1: j + 1 + str_len] # Add decoded string to the list decoded_list.append(decoded_str) # Move index to the start of the next length descriptor i = j + 1 + str_len return decoded_list"},{"question":"Scenario You are developing a robotic pathfinder for a grid-based maze. The robot can only move right or down. To help the robot plan its movements, you need to determine the number of unique paths from the top-left corner to the bottom-right corner of a given `m x n` grid. Problem Statement Write a function `count_unique_paths(m, n)` that calculates the number of unique paths from the top-left corner `(0, 0)` to the bottom-right corner `(m-1, n-1)` of an `m x n` grid. Function Signature ```python def count_unique_paths(m: int, n: int) -> int: ``` Input * `m` (int): The number of rows in the grid. (1 <= m <= 100) * `n` (int): The number of columns in the grid. (1 <= n <= 100) Output * Returns an integer representing the number of unique paths from the top-left to the bottom-right corner. Constraints * You may only move down or right at any point in time. * If `m` or `n` is less than 1, return `0` as there are no valid paths for non-positive grid dimensions. Example ```python assert count_unique_paths(3, 3) == 6 assert count_unique_paths(1, 5) == 1 assert count_unique_paths(0, 0) == 0 ``` Hints * Use dynamic programming to keep track of the number of paths to each cell. * Start by initializing the paths to the first row and first column. * For other cells, the number of paths to that cell is the sum of the paths from the cell above it and the cell to the left of it. You are to use the guidelines provided to ensure your function handles all edge cases and returns accurate results.","solution":"def count_unique_paths(m: int, n: int) -> int: if m <= 0 or n <= 0: return 0 # Create a 2D list to store the number of paths to each cell dp = [[0] * n for _ in range(m)] # Initialize the paths for the first column and row for i in range(m): dp[i][0] = 1 for j in range(n): dp[0][j] = 1 # Fill the rest of the dp array for i in range(1, m): for j in range(1, n): dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[m-1][n-1]"},{"question":"You are tasked with implementing a sorting function using the Merge Sort algorithm. The following snippet takes care of dividing the array and calls a helper function to merge the sorted subarrays back together. However, the function misses handling several edge cases and optimizations to make it more robust and efficient. Your tasks are as follows: 1. **Implement** a revised version of the merge_sort function. 2. **Ensure** that your code handles edge cases and minimizes unnecessary operations. 3. **Optimize** so that no extra copying of arrays is done during the merging process. # Function Signature ```python def merge_sort(arr: List[int]) -> List[int]: pass ``` # Input * A list of integers, `arr`, where `1 <= len(arr) <= 10^5` and `-10^3 <= arr[i] <= 10^3`. # Output * A sorted list of integers in non-decreasing order, `arr`. # Constraints * Time complexity should not exceed O(n log(n)). * Space complexity should be managed efficiently without excessive use of additional space. # Example ```python assert merge_sort([3, 5, 1, 4, 2]) == [1, 2, 3, 4, 5] assert merge_sort([]) == [] assert merge_sort([1]) == [1] assert merge_sort([4, 4, 4, 4]) == [4, 4, 4, 4] assert merge_sort([9, 2, 7, 3, 6, 2]) == [2, 2, 3, 6, 7, 9] ``` * **Scenario**: Your program needs to sort a large list of integers with the constraints provided. Ensuring the result is accurate under all possible edge cases is key. # Responsibilities * Effectively manage array splitting and merging. * Handle all provided edge cases. * Optimize space and time complexity. Happy coding!","solution":"from typing import List def merge_sort(arr: List[int]) -> List[int]: if len(arr) <= 1: # edge case: empty list or single element list return arr # Helper function to merge two sorted arrays def merge(left: List[int], right: List[int]) -> List[int]: merged_array = [] i = j = 0 # Merge the two arrays while maintaining order while i < len(left) and j < len(right): if left[i] <= right[j]: merged_array.append(left[i]) i += 1 else: merged_array.append(right[j]) j += 1 # If any elements are left in either list, append them while i < len(left): merged_array.append(left[i]) i += 1 while j < len(right): merged_array.append(right[j]) j += 1 return merged_array # Split the array into two halves mid = len(arr) // 2 left_half = merge_sort(arr[:mid]) right_half = merge_sort(arr[mid:]) # Merge the sorted halves return merge(left_half, right_half)"},{"question":"# Binary Search Problem: Last Occurrence Finder **Context**: You are working on a project that requires efficient searching within large, sorted datasets. One common task is finding the position of the last occurrence of a specific value. **Task**: Write a function `last_occurrence` that takes a sorted array and a query value as inputs and returns the index of the last occurrence of the query value in the array. # Function Signature: ```python def last_occurrence(array: List[int], query: int) -> int: ``` # Input Parameters: * `array`: A list of integers sorted in increasing order. * `query`: An integer value to find within the array. # Output: * Return an integer representing the index of the last occurrence of the query value in the array. * If the query is not found, return `-1` to indicate absence. # Constraints: * The length of the array, `n`, will satisfy `0 <= n <= 10^6`. * The value in the array elements and the query will satisfy `-10^9 <= array[i], query <= 10^9`. # Examples: ```python print(last_occurrence([1, 2, 2, 2, 3, 4, 5], 2)) # Output: 3 print(last_occurrence([1, 2, 3, 4, 5, 6, 7, 8, 9], 5)) # Output: 4 print(last_occurrence([1, 1, 1, 1, 1], 1)) # Output: 4 print(last_occurrence([], 3)) # Output: -1 ``` # Requirements: - Handle edge cases such as an empty array or when the query does not exist in the array. - Ensure the implementation adheres to a time complexity of O(log n) and space complexity of O(1).","solution":"from typing import List def last_occurrence(array: List[int], query: int) -> int: Returns the index of the last occurrence of the query value in the sorted array. If the query is not found, returns -1 to indicate absence. low, high = 0, len(array) - 1 result = -1 while low <= high: mid = (low + high) // 2 if array[mid] == query: result = mid low = mid + 1 # Keep searching in the right half elif array[mid] < query: low = mid + 1 else: high = mid - 1 return result"},{"question":"You are given an abstract Stack class and two concrete implementations using arrays and linked lists. Your task is to implement a new method `merge_stacks(stack1, stack2)`, which merges two stacks into one. The merging process should follow these rules: 1. The items in the new stack should preserve the order as if elements from `stack2` are pushed to `stack1`. 2. The final stack should be a new instance that does not affect the original stacks. Here\'s the interface you need to follow: ```python class AbstractStack(metaclass=ABCMeta): def __init__(self): # Abstract stack initializer pass def __len__(self): # Code to return the length of the stack pass def __str__(self): # Code to return a string representation of the stack pass def is_empty(self): # Code to check if the stack is empty pass @abstractmethod def __iter__(self): # Code to iterate through the stack pass @abstractmethod def push(self, value): # Code to push a value into the stack pass @abstractmethod def pop(self): # Code to pop the top value from the stack pass @abstractmethod def peek(self): # Code to peek at the top value of the stack pass def merge_stacks(stack1: AbstractStack, stack2: AbstractStack) -> AbstractStack: Merges two stacks into a new stack. pass ``` # Requirements: 1. **Input:** - `stack1`: An instance of `AbstractStack`. - `stack2`: Another instance of `AbstractStack`. 2. **Output:** - A new instance of `AbstractStack` that contains all elements from `stack1` followed by elements from `stack2`. 3. **Constraints:** - You can assume the stacks are of moderate size, within typical memory limits. - The stack should be the same type as `stack1`. 4. **Performance Considerations:** - Aim for efficient operations, leveraging O(1) stack operations wherever possible. - Avoid unnecessary memory utilization. # Example: ```python stack1 = LinkedListStack() # or ArrayStack stack1.push(1) stack1.push(2) stack2 = LinkedListStack() # or ArrayStack stack2.push(3) stack2.push(4) new_stack = merge_stacks(stack1, stack2) # new_stack now contains: 1, 2, 3, 4 in that order ```","solution":"from abc import ABCMeta, abstractmethod from collections import deque class AbstractStack(metaclass=ABCMeta): def __init__(self): pass @abstractmethod def __len__(self): pass @abstractmethod def __str__(self): pass @abstractmethod def is_empty(self): pass @abstractmethod def __iter__(self): pass @abstractmethod def push(self, value): pass @abstractmethod def pop(self): pass @abstractmethod def peek(self): pass class LinkedListStack(AbstractStack): def __init__(self): super().__init__() self.stack = deque() def __len__(self): return len(self.stack) def __str__(self): return str(list(self.stack)) def is_empty(self): return len(self.stack) == 0 def __iter__(self): return iter(self.stack) def push(self, value): self.stack.append(value) def pop(self): return self.stack.pop() def peek(self): return self.stack[-1] if not self.is_empty() else None class ArrayStack(AbstractStack): def __init__(self): super().__init__() self.stack = [] def __len__(self): return len(self.stack) def __str__(self): return str(self.stack) def is_empty(self): return len(self.stack) == 0 def __iter__(self): return iter(self.stack) def push(self, value): self.stack.append(value) def pop(self): return self.stack.pop() def peek(self): return self.stack[-1] if not self.is_empty() else None def merge_stacks(stack1: AbstractStack, stack2: AbstractStack) -> AbstractStack: merged_stack_type = type(stack1) merged_stack = merged_stack_type() temp_stack = [] for item in stack2: temp_stack.append(item) while temp_stack: merged_stack.push(temp_stack.pop(0)) for item in stack1: merged_stack.push(item) return merged_stack"},{"question":"Given a sequence of unique integers in the range [0..n], find the missing number that completes the sequence. The difference between consecutive numbers cannot be more than 1. If the sequence is already complete, return the next integer in the sequence. # Input - An array of unique integers `nums` where each integer is in the range [0..n]. # Output - Return a single integer that is the missing number in the array. If the sequence is complete, return n+1. # Constraints - The array `nums` has a length `n` and contains unique integers ranging from 0 to n with exactly one missing integer. - The solution should run in O(n) time and use O(1) additional space. # Example ```python Input: nums = [4, 1, 3, 0, 6, 5, 2] Output: 7 Input: nums = [0, 1, 2, 3, 4, 5] Output: 6 Input: nums = [1, 2, 3, 4, 5, 6] Output: 0 ``` # Function signature Write the implementation for the function with the following signature: ```python def find_missing_number(nums: List[int]) -> int: # Your code here ``` # Additional Notes - Consider both the XOR-based and sum-based approaches for this problem. - Ensure your solution handles edge cases efficiently and returns the correct missing number even under constraint extremes.","solution":"from typing import List def find_missing_number(nums: List[int]) -> int: Given a sequence of unique integers in the range [0..n], this function finds the missing number that completes the sequence. If the sequence is already complete, it returns n+1. n = len(nums) total_sum = n * (n + 1) // 2 actual_sum = sum(nums) missing_number = total_sum - actual_sum return missing_number if missing_number <= n else n + 1"},{"question":"You are given an integer number. Every pair of adjacent bits in the integer should be swapped. Write a function `swap_bit_pairs` that takes an integer as input and returns an integer where every pair of adjacent bits in the original number has been swapped. # Function Signature ```python def swap_bit_pairs(num: int) -> int: ``` # Input * An integer `num` where `0 <= num <= 2^32 - 1`. # Output * An integer with every pair of adjacent bits swapped. # Example ```python assert swap_bit_pairs(22) == 41 # 010110 -> 101001 assert swap_bit_pairs(10) == 5 # 1010 -> 0101 ``` # Constraints * The maximum value of the integer input is `2^32 - 1`. * You may assume that the input will fit in a 32-bit signed integer. # Performance Requirements * Your solution should be efficient with a time complexity of O(1). * The space complexity should be O(1), i.e., constant space usage apart from the input and output. # Brief Scenario Consider a situation where you\'re working on a hardware programming or low-level software engineering project involving memory manipulation at the bit level. Efficiently swapping adjacent bits can be critical for optimizing certain cryptographic algorithms or data encoding processes. # Additional Notes: * Carefully handle the bitwise operations to ensure bits are correctly swapped. * Pay attention to the masking and shifting operations to avoid losing bits or incorrect swaps.","solution":"def swap_bit_pairs(num: int) -> int: Swaps every pair of adjacent bits in the given integer. # Mask for even bits even_bits = num & 0xAAAAAAAA # Mask for odd bits odd_bits = num & 0x55555555 # Right shift even bits even_bits >>= 1 # Left shift odd bits odd_bits <<= 1 # Combine the bits return even_bits | odd_bits"},{"question":"# Matrix Transformations You are given functions that transform a 2D matrix (or list of lists) in various ways. However, you need to extend this functionality by implementing another transformation. Your task is to write a function that performs a **diagonal flip** of a matrix. In a diagonal flip, elements of the matrix are mirrored along its main diagonal (top-left to bottom-right). Function Signature ```python def diagonal_flip(matrix: List[List[int]]) -> List[List[int]]: pass ``` Input * A 2D matrix `matrix` represented as a list of lists of integers, where 1 <= len(matrix), len(matrix[0]) <= 100. Output * A new 2D matrix which is the result of flipping the original matrix along its main diagonal. Examples ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9], ] diagonal_flip(matrix) # Output: # [ # [1, 4, 7], # [2, 5, 8], # [3, 6, 9], # ] ``` Constraints 1. The input matrix is non-empty and rectangular (every row has the same number of columns). 2. You should not modify the input matrix. Performance Requirements Your solution should have a time complexity of O(n*m) and a space complexity of O(n*m). Edge Cases to Consider 1. Matrix with only one element. 2. Non-square matrices (e.g., 3x2 or 2x3). Context This question helps in understanding matrix manipulations, which are common in areas such as computer graphics, image processing, scientific computing, and more. A deeper understanding of these transformations can help in optimizing space and time complexities in related applications.","solution":"from typing import List def diagonal_flip(matrix: List[List[int]]) -> List[List[int]]: Performs a diagonal flip of the input matrix along its main diagonal. Args: matrix (List[List[int]]): 2D list representing the matrix. Returns: List[List[int]]: A new 2D list representing the diagonal flipped matrix. rows, cols = len(matrix), len(matrix[0]) flipped = [[0] * rows for _ in range(cols)] for i in range(rows): for j in range(cols): flipped[j][i] = matrix[i][j] return flipped"},{"question":"# Problem Context: The number 89 is the first integer with more than one digit whose digits, when raised to consecutive powers, give the same number. For instance, 8^1 + 9^2 = 89. The next such number is 135, as 1^1 + 3^2 + 5^3 = 135. # Task: Write a function `find_special_numbers(low, high)` that returns a list of numbers between `low` and `high` (inclusive) that possess this property. # Input: * An integer `low` (1 ≤ low ≤ 10^6) * An integer `high` (1 ≤ high ≤ 10^6) # Output: * A list of integers that fulfill the above property within the given range `[low, high]`. # Constraints: * The range `[low, high]` will be such that `low ≤ high`. * The function should handle both large and small ranges efficiently. # Example: ```python def find_special_numbers(low, high) ``` Example Input: ```python print(find_special_numbers(1, 100)) ``` Example Output: ```python [1, 2, 3, 4, 5, 6, 7, 8, 9, 89] ``` # Performance Requirements: * Ensure the function runs efficiently for the upper limits of input sizes. **Note:** Ideally, this problem not only checks for students\' understanding of looping and conditionals but also for their ability to optimize code for performance and manage edge cases.","solution":"def find_special_numbers(low, high): Finds the special numbers between low and high (inclusive) where the sum of the digits raised to consecutive powers equals the number itself. def is_special_number(n): return n == sum(int(digit) ** (i + 1) for i, digit in enumerate(str(n))) return [n for n in range(low, high + 1) if is_special_number(n)]"},{"question":"Search in Rotated Sorted Array Context: You are working on validating a search feature for an application that stores cyclically rotated user lists. Given a rotated, sorted array of user IDs, you need to quickly find a specific user ID\'s index. Task: Write a function to search for a target value in a rotated sorted array. The list is assumed to be rotated at some unknown point. If the target is found in the array, return its index; otherwise, return -1. Your implementation should adhere to O(log n) time complexity. Specification: - Function signature: `def search_rotate(array: List[int], target: int) -> int` - **Input:** - `array`: A list of integers representing rotated sorted unique user IDs in ascending order. - `target`: An integer representing the user ID to be searched for. - **Output:** - An integer representing the index of the target value. Return `-1` if the target is not found. Constraints: - The length of `array` will be in the range `[0, 10^4]`. - Each element in `array` will be unique. - `target` is an integer which can be positive or negative. Examples: 1. Input: `array = [4,5,6,7,0,1,2]`, `target = 0` Output: `4` 2. Input: `array = [4,5,6,7,0,1,2]`, `target = 3` Output: `-1` 3. Input: `array = [1]`, `target = 0` Output: `-1` 4. Input: `array = [8,9,2,3,4]`, `target = 9` Output: `1` Notes: - Consider edge cases such as empty arrays, arrays with only one element, and target values outside the range of the array elements. - Provide a solution using both iterative and recursive approaches if possible.","solution":"from typing import List def search_rotate(array: List[int], target: int) -> int: Searches for a target value in a rotated sorted array and returns its index if found, otherwise returns -1. if not array: return -1 left, right = 0, len(array) - 1 while left <= right: mid = (left + right) // 2 if array[mid] == target: return mid # Determine which side is normally ordered if array[left] <= array[mid]: # Left side is normally ordered if array[left] <= target < array[mid]: right = mid - 1 else: left = mid + 1 else: # Right side is normally ordered if array[mid] < target <= array[right]: left = mid + 1 else: right = mid - 1 return -1"},{"question":"Heap Sort is a well-known sorting algorithm that can be implemented using either a max heap or a min heap. Based on the provided explanation and analysis, your task is to complete the implementation of the `min_heap_sort` function to sort an array in ascending order using a min heap. Complete the `min_heap_sort` function below: ```python def min_heap_sort(arr, simulation=False): Heap Sort that uses a min heap to sort an array in ascending order. Args: - arr (List[int]): The list of integers to be sorted. - simulation (bool): If True, print the array at each iteration. Returns: - List[int]: Sorted list of integers. iteration = 0 if simulation: print(\\"iteration\\",iteration,\\":\\",*arr) for i in range(0, len(arr) - 1): iteration = min_heapify(arr, i, simulation, iteration) return arr def min_heapify(arr, start, simulation, iteration): Min heapify helper for min_heap_sort. Args: - arr (List[int]): The list of integers being sorted. - start (int): The current starting index for heapify operation. - simulation (bool): If True, print the array at each iteration. - iteration (int): Keeps track of the number of iterations. Returns: - int: Updated iteration count. # Offset last_parent by the start (last_parent calculated as if start index was 0) end = len(arr) - 1 last_parent = (end - start - 1) // 2 # Iterate from last parent to first for parent in range(last_parent, -1, -1): current_parent = parent # Iterate from current_parent to last_parent while current_parent <= last_parent: # Find lesser child of current_parent child = 2 * current_parent + 1 if child + 1 <= end - start and arr[child + start] > arr[child + 1 + start]: child = child + 1 # Swap if child is less than parent if arr[child + start] < arr[current_parent + start]: arr[current_parent + start], arr[child + start] = arr[child + start], arr[current_parent + start] current_parent = child if simulation: iteration = iteration + 1 print(\\"iteration\\",iteration,\\":\\",*arr) # If no swap occurred, no need to keep iterating else: break return iteration # Example Usage: # Input: arr = [4, 10, 3, 5, 1], simulation=True # Output: [1, 3, 4, 5, 10] and printed iterations arr = [4, 10, 3, 5, 1] sorted_arr = min_heap_sort(arr, simulation=True) print(\\"Sorted Array:\\", sorted_arr) ``` # Constraints * The list contains integers only. * The list may include negative numbers. * The array can be of size up to 10^4. Ensure your implementation handles edge cases like an empty array, a single-element array, and arrays with duplicate values.","solution":"def min_heap_sort(arr, simulation=False): Heap Sort that uses a min heap to sort an array in ascending order. Args: - arr (List[int]): The list of integers to be sorted. - simulation (bool): If True, print the array at each iteration. Returns: - List[int]: Sorted list of integers. iteration = 0 length = len(arr) if simulation: print(\\"iteration\\", iteration, \\":\\", *arr) # Building the heap in array a so that largest value is at the root for start in range((length-2)//2, -1, -1): heapify(arr, length, start, simulation, iteration) iteration += 1 if simulation: print(\\"iteration\\", iteration, \\":\\", *arr) # Extract elements from heap one by one and heapify the remaining items for end in range(length-1, 0, -1): arr[0], arr[end] = arr[end], arr[0] heapify(arr, end, 0, simulation, iteration) return arr def heapify(arr, n, i, simulation, iteration): largest = i left = 2 * i + 1 right = 2 * i + 2 if left < n and arr[largest] < arr[left]: largest = left if right < n and arr[largest] < arr[right]: largest = right if largest != i: arr[i], arr[largest] = arr[largest], arr[i] heapify(arr, n, largest, simulation, iteration) # Example usage: # Input: arr = [4, 10, 3, 5, 1], simulation=True # Output: [1, 3, 4, 5, 10] and printed iterations arr = [4, 10, 3, 5, 1] sorted_arr = min_heap_sort(arr, simulation=True) print(\\"Sorted Array:\\", sorted_arr)"},{"question":"# Edit Distance Calculation Scenario: You are working on a text processing tool that requires finding how similar two words are by computing the edit distance between them. The edit distance is defined as the minimum number of insertions, deletions, and substitutions needed to convert one word into another. Given two words, `word_a` and `word_b`, your task is to write a function that calculates the edit distance between the two words. Function Signature: ```python def edit_distance(word_a: str, word_b: str) -> int: ``` Input: - `word_a` (str): The first word. - `word_b` (str): The second word. Output: - (int): The edit distance between `word_a` and `word_b`. Constraints: - The length of each word will be at most 1000. - The words will consist of lowercase English letters only. Example: ```python assert edit_distance(\\"kitten\\", \\"sitting\\") == 3 # Explanation: kitten -> sitten (substitution) # sitten -> sittin (substitution) # sittin -> sitting (insertion) assert edit_distance(\\"food\\", \\"money\\") == 4 # Explanation: food -> mood (substitution) # mood -> mond (substitution) # mond -> moned (insertion) # moned -> money (substitution) ``` Note: Your solution should be efficient in terms of both time and space, as it needs to handle input strings with lengths up to 1000.","solution":"def edit_distance(word_a: str, word_b: str) -> int: Calculate the edit distance between two words. m, n = len(word_a), len(word_b) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(m + 1): for j in range(n + 1): if i == 0: dp[i][j] = j elif j == 0: dp[i][j] = i elif word_a[i - 1] == word_b[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = 1 + min(dp[i - 1][j], # Deletion dp[i][j - 1], # Insertion dp[i - 1][j - 1]) # Substitution return dp[m][n]"},{"question":"Implement and Optimize Radix Sort You are tasked with implementing an optimized version of Radix Sort. Given an input list of non-negative integers, your goal is to sort the list efficiently. You are required to demonstrate a good grasp of the Radix Sort algorithm, handling various edge cases effectively. Function Signature ```python def optimized_radix_sort(arr: List[int], simulation: bool = False) -> List[int]: pass ``` # Input * A list of non-negative integers, `arr`, where `0 <= len(arr) <= 10^5` and each integer is between `0` and `10^9`. * A boolean `simulation` which, when set to `True`, prints the list after each digit-based sorting iteration. # Output * A list of non-negative integers sorted in non-decreasing order. # Constraints 1. The algorithm should handle empty lists and single-element lists correctly. 2. The maximum number in the list will not exceed `10^9`. 3. The implementation should be able to handle large input sizes and be efficient in terms of both time and space complexity. 4. When `simulation` is `True`, ensure the state of the list is printed after each digit-based sorting iteration in a readable format. # Performance Requirements * Target an efficient average-case time complexity close to O(nk) for sorting the entire list. * Use auxiliary space judiciously, aiming to stay within O(n) space complexity. # Example ```python assert optimized_radix_sort([170, 45, 75, 90, 802, 24, 2, 66]) == [2, 24, 45, 66, 75, 90, 170, 802] # Simulation enabled optimized_radix_sort([170, 45, 75, 90, 802, 24, 2, 66], simulation=True) # Expected output: # iteration 0 : 170 45 75 90 802 24 2 66 # iteration 1 : 170 90 802 2 24 45 75 66 # iteration 2 : 2 24 45 66 75 170 802 90 # iteration 3 : 2 24 45 66 75 90 170 802 ``` Explanation: The function processes the digits of each number starting from least significant to most significant, grouping numbers by their digits using temporary buckets, and rebuilding the list after each pass. The `simulation` mode helps students visualize how the list evolves.","solution":"from typing import List def counting_sort(arr: List[int], exp: int, simulation: bool) -> None: n = len(arr) output = [0] * n # output array that will have sorted arr count = [0] * 10 # count array to store count of occurrences of digits # Store count of occurrences in count[] for i in range(n): index = arr[i] // exp count[index % 10] += 1 # Change count[i] so that count[i] now contains actual # position of this digit in output[] for i in range(1, 10): count[i] += count[i-1] # Build the output array for i in range(n-1, -1, -1): index = arr[i] // exp output[count[index % 10] - 1] = arr[i] count[index % 10] -= 1 # Copy the output array to arr[], so that arr now # contains sorted numbers according to current digit for i in range(len(arr)): arr[i] = output[i] if simulation: print(f\\"iteration {exp}: {\' \'.join(map(str, arr))}\\") def optimized_radix_sort(arr: List[int], simulation: bool = False) -> List[int]: if len(arr) == 0: return arr # Find the maximum number to know the number of digits max_val = max(arr) # Do counting sort for every digit. Note that exp is 10^i # where i is the current digit number exp = 1 while max_val // exp > 0: counting_sort(arr, exp, simulation) exp *= 10 return arr"},{"question":"Integer Partition Count You have been tasked with determining the number of ways a positive integer `n` can be partitioned into sums of non-negative integers. Your approach should use dynamic programming to compute this efficiently. Functional Specifications * Implement a function `partition_count(n: int) -> int` which returns the number of such possible partitions. * Each partition counts the order of summands, meaning `1 + 4` and `4 + 1` are the same. Input * A single integer `n` where ( 1 leq n leq 100 ). Output * A single integer, the number of ways to partition the given integer. Constraints * Ensure your solution has a time complexity no worse than O(n^2). * Optimize for space where possible without increasing time complexity beyond stated limits. Example ```python assert partition_count(4) == 5 # Explanation: 4 can be partitioned into [4], [3+1], [2+2], [2+1+1], and [1+1+1+1] assert partition_count(7) == 15 # Explanation: 7 can be partitioned into 15 ways as described earlier ``` The main goal is to leverage dynamic programming principles to build a solution that iteratively computes the number of partitions for `n`. Consider edge cases and ensure memory efficiency where feasible.","solution":"def partition_count(n: int) -> int: if n < 1: return 0 # dp[i] will be storing the number of ways to partition integer i dp = [0] * (n + 1) dp[0] = 1 # There\'s one way to partition 0 - using no numbers. # Fill the dp table for i in range(1, n + 1): for j in range(i, n + 1): dp[j] += dp[j - i] return dp[n]"},{"question":"Scenario: You are working as a software developer, and you have been tasked with solving a common problem in data manipulation: identifying the minimum value in a rotated sorted array. The array is initially sorted in ascending order and then rotated at an unknown pivot point, making it challenging to identify the smallest element with a simple traversal. Task: Implement a function `find_min_in_rotated_array` that takes a list of integers representing a rotated sorted array and returns the minimum value in that array. Your implementation should have a time complexity of O(log N). Specifications: * **Function Name**: `find_min_in_rotated_array` * **Input**: A list of distinct integers `arr` sorted in ascending order and then rotated. * **Output**: An integer, which is the minimum element in the array. * **Constraints**: - `1 <= len(arr) <= 10^5` - Clockwise rotation, meaning all elements are distinct. - Array length will be at least 1. Example: ``` Input: [4, 5, 6, 7, 0, 1, 2] Output: 0 Input: [6, 7, 1, 2, 3, 4, 5] Output: 1 Input: [1] Output: 1 ``` Notes: - Your solution should efficiently handle large input sizes up to `10^5` elements. - Avoid unnecessary space usage, strive for O(1) additional space complexity.","solution":"def find_min_in_rotated_array(arr): Finds the minimum element in a rotated sorted array. Utilizes binary search to maintain O(log N) time complexity. if not arr: raise ValueError(\\"Array must not be empty\\") left, right = 0, len(arr) - 1 while left < right: mid = (left + right) // 2 # If mid element is greater than right element, the minimum is in the right half if arr[mid] > arr[right]: left = mid + 1 # If mid element is less than or equal to right element, the minimum is in the left half else: right = mid return arr[left]"},{"question":"# Histogram Function Challenge Given an unsorted list of elements, your task is to implement a function that returns its histogram. A histogram is a representation of the frequency distribution of the elements in the list. Function Signature ```python def create_histogram(input_list: list) -> dict: ``` Input * `input_list`: A list of elements (integers or strings). The list length `n` can be between `0` and `10000`. Output * Returns a dictionary where keys are the elements of the list and values are the frequency counts of those elements. Constraints * Elements in the list will be hashable (e.g., integers or strings). * Optimize for performance regarding both time and space complexity. Example ```python # Example 1 input_list = [1, 2, 2, 3, 3, 3] # Expected Output: {1: 1, 2: 2, 3: 3} # Example 2 input_list = [\'apple\', \'banana\', \'apple\', \'banana\', \'banana\', \'cherry\'] # Expected Output: {\'apple\': 2, \'banana\': 3, \'cherry\': 1} # Example 3 input_list = [] # Expected Output: {} ``` Edge Cases * Ensure your function handles an empty list correctly. * Consider the efficiency of your implementation for large input lists with potentially many unique elements. Implement the `create_histogram` function.","solution":"def create_histogram(input_list): Given an unsorted list of elements, return a histogram as a dictionary where the keys are the elements and the values are the frequency counts of those elements. histogram = {} for element in input_list: if element in histogram: histogram[element] += 1 else: histogram[element] = 1 return histogram"},{"question":"Longest Palindromic Substring # Objective Implement a function to find the longest palindromic substring in a given input string using the algorithm discussed. # Function Signature ```python def longest_palindrome(s: str) -> str: pass ``` # Input * `s` (str): The input string, where `0 <= len(s) <= 1000`. # Output * (str): The longest palindromic substring in the input `s`. # Constraints * If there are multiple longest palindromic substrings, return the one which appears first. * Consider both odd and even length palindromes. * Aim to achieve O(n) time complexity, leveraging the discussed algorithm. # Example Example 1 * Input: `\\"dasdasdasdasdasdadsa\\"` * Output: `\\"asdadsa\\"` Example 2 * Input: `\\"acdbbdaa\\"` * Output: `\\"dbbd\\"` # Context Consider applying this function in scenarios where you need to detect symmetrical patterns in strings such as DNA sequences or communication protocols\' validation for mirrored sequences. # Constraints Focus on a clear and efficient implementation, handling edge cases like empty strings or strings where no palindromic substring greater than length 1 exists.","solution":"def longest_palindrome(s: str) -> str: if len(s) == 0: return \\"\\" # Function to expand around center and return the length of palindrome def expand_around_center(s: str, left: int, right: int) -> str: while left >= 0 and right < len(s) and s[left] == s[right]: left -= 1 right += 1 return s[left+1:right] longest = \\"\\" for i in range(len(s)): # Check for odd length palindromes p1 = expand_around_center(s, i, i) if len(p1) > len(longest): longest = p1 # Check for even length palindromes p2 = expand_around_center(s, i, i + 1) if len(p2) > len(longest): longest = p2 return longest"},{"question":"# Comb Sort Implementation **Scenario**: You\'ve been tasked with implementing a sorting function using the Comb Sort algorithm for an application that occasionally needs to sort small datasets of integers. Although Comb Sort is not the most efficient sorting algorithm, it\'s easy to implement and performs significantly better than Bubble Sort. **Task**: Implement the `comb_sort` function that takes a list of integers and sorts them in ascending order using the Comb Sort algorithm. # Function Signature ```python def comb_sort(arr: list[int]) -> list[int]: ``` # Input - A list `arr` of `n` integers where (1 leq n leq 10^5) # Output - The list `arr`, sorted in ascending order. # Constraints - The integers in the list can be both positive and negative. **Example**: ```python assert comb_sort([34, 7, 23, 32, 5, 62]) == [5, 7, 23, 32, 34, 62] assert comb_sort([4, 1, 3, 9, 7]) == [1, 3, 4, 7, 9] ``` # Notes: - Pay attention to edge cases like an empty list or a list with one element, which are already sorted by definition.","solution":"def comb_sort(arr: list[int]) -> list[int]: def get_next_gap(gap): gap = (gap * 10) // 13 if gap < 1: return 1 return gap n = len(arr) gap = n swapped = True while gap != 1 or swapped: gap = get_next_gap(gap) swapped = False for i in range(n - gap): if arr[i] > arr[i + gap]: arr[i], arr[i + gap] = arr[i + gap], arr[i] swapped = True return arr"},{"question":"# Knuth-Morris-Pratt String Matching You are tasked with implementing the Knuth-Morris-Pratt (KMP) algorithm to search for occurrences of a pattern within a given text. The algorithm should return the starting indices of each match. # Requirements * Implement the function `knuth_morris_pratt` which takes two arguments: * `text` (Sequence): The text in which to search. * `pattern` (Sequence): The pattern to be searched for in the text. * The function should return a list of integer indices, each representing the start position of a match of the pattern in the text. * Ensure that the function handles edge cases correctly and operates efficiently within time complexity of O(N+M). # Example ```python def knuth_morris_pratt(text: Sequence, pattern: Sequence) -> List[int]: pass # Example Usage print(knuth_morris_pratt(\'hello there hero!\', \'he\')) # Output: [0, 7, 12] ``` # Constraints 1. The input text and pattern will be non-empty strings or sequences. 2. Maximum length of text and pattern can be up to 10^5 characters. 3. The function should be able to handle and return correct results quickly even if text and pattern consist of repeated characters. # Context Imagine you are building a text editing application. One feature you need to add is the \\"Find\\" utility, which locates all instances of a given word or pattern within the text the user is working on. The \'knuth_morris_pratt\' function you\'ll implement is essential to ensure that the search operation is both efficient and accurate, regardless of the size of the text. # Additional Considerations * Carefully handle the edge case where the pattern does not appear in the text at all. * Ensure the function works for cases where pattern length equals to the text length. * Do not assume any particular character set; the function should be generic and applicable to any sequence of characters. Implement the function to meet the above requirements and provide robust behavior even under edge case scenarios.","solution":"from typing import List, Sequence def knuth_morris_pratt(text: Sequence, pattern: Sequence) -> List[int]: def compute_lps(pattern): lps = [0] * len(pattern) length = 0 i = 1 while i < len(pattern): if pattern[i] == pattern[length]: length += 1 lps[i] = length i += 1 else: if length != 0: length = lps[length - 1] else: lps[i] = 0 i += 1 return lps lps = compute_lps(pattern) indices = [] i = 0 j = 0 while i < len(text): if pattern[j] == text[i]: i += 1 j += 1 if j == len(pattern): indices.append(i - j) j = lps[j - 1] elif i < len(text) and pattern[j] != text[i]: if j != 0: j = lps[j - 1] else: i += 1 return indices"},{"question":"<|Analysis Begin|> **Algorithm/Data Structure**: - **Name**: Binary Search Insert Position - **Type**: Algorithm, used as a helper in sorting algorithms. - **Main Purpose**: To find the insertion position of an element in a sorted array efficiently. **Complexity**: - **Time Complexity**: O(log n), because it reduces the search range by half each iteration. - **Space Complexity**: O(1), since it only uses a constant amount of extra space. **Principles**: - **Core Operational Steps**: 1. Initialize two pointers, `low` and `high`, to define search boundaries. 2. Calculate the middle index of the current subarray. 3. Compare the target value with the middle element. 4. Adjust the search boundaries based on the comparison result. 5. Repeat steps 2-4 until the correct insertion position is found. **Properties**: - Efficiently finds the insertion point of an element in a sorted list. - Does not modify the input list. **Common Use Cases**: - Insertion sort to determine the position of the next element quickly. - Anywhere you need to maintain a sorted list dynamically by inserting elements at the correct position. **Strengths/Limitations**: - **Strengths**: - Much faster than a linear search for finding the insertion point. - Simple and easy to implement. - **Limitations**: - Requires the input array to be sorted. - Not suitable for linked lists due to its reliance on indexing elements in constant time. **Implementation Challenges**: - **Edge Cases**: - Insert positions at the beginning or the end of the array. - Duplicate elements in the array. - **Performance Bottlenecks**: - None inherent to the algorithm itself as it is optimized for its purpose. - **Error Scenarios**: - Incorrect handling of the array bounds can lead to infinite loops or index errors. - If the starting array is not sorted, the result will be incorrect. - **Optimization Points**: - None specific as binary search is already optimal for this purpose. - However, proper boundary checks should be in place. <|Analysis End|> <|Question Begin|> **Binary Search Insert Position** # Problem Description You are given a sorted list of integers and a target value. Your task is to write a function `search_insert` that finds the index of the target in the list if it is present. If the target is not present, return the index where it would be inserted to maintain the order. # Function Signature ```python def search_insert(array: List[int], val: int) -> int: ``` # Input - `array` (List[int]): A sorted list of integers. - `val` (int): A target integer to search for or insert. # Output - Return an integer representing the index where the target is or should be inserted. # Constraints - The input list `array` will have a length between 0 and 10^5. - The elements of the list will be between -10^6 to 10^6. - The target `val` will be between -10^6 to 10^6. # Example ```python search_insert([1, 3, 5, 6], 5) -> 2 search_insert([1, 3, 5, 6], 2) -> 1 search_insert([1, 3, 5, 6], 7) -> 4 search_insert([1, 3, 5, 6], 0) -> 0 search_insert([], 10) -> 0 ``` # Requirements - The algorithm should have a time complexity of O(log n). - Make sure to handle edge cases such as an empty list or insertion positions at the boundaries appropriately. **Additional Context:** This function can be used as a fundamental building block in more complex sorting algorithms such as insertion sort, where insert positions need to be determined efficiently to insert elements in sorted order.","solution":"from typing import List def search_insert(array: List[int], val: int) -> int: Finds the index at which the target would fit into the sorted list. Uses binary search for an efficient O(log n) time complexity. Parameters: array (List[int]): A sorted list of integers. val (int): The value to search for or insert. Returns: int: Index where the target is or should be inserted. if not array: return 0 low, high = 0, len(array) - 1 while low <= high: mid = (low + high) // 2 if array[mid] == val: return mid elif array[mid] < val: low = mid + 1 else: high = mid - 1 return low"},{"question":"**Context**: You have been hired by a logistics company to help sort large amounts of data efficiently. Given that most of their data consists of integer values within a known range, they need an optimized sorting algorithm. They are particularly interested in a non-comparative and stable sorting algorithm, and you decided to use the Counting Sort. **Requirement**: Your task is to implement the Counting Sort algorithm to sort an array of integers efficiently. The input array may contain negative numbers. **Function Signature**: ```python def counting_sort(arr: List[int]) -> List[int]: pass ``` **Input**: * `arr`: A list of integers where `-10^6 <= arr[i] <= 10^6` and the length of the list `0 <= len(arr) <= 10^6`. **Output**: * Return a sorted list of integers in non-decreasing order. **Constraints**: * The algorithm should handle arrays with negative numbers appropriately without altering their relative positions. * Ensure the implementation has linear time complexity, i.e., O(n + k), where `n` is the number of elements and `k` is the range of input values. **Example**: ```python # Example 1 input_arr = [4, 2, -3, 1, 0, -1, -2, 3] output_arr = counting_sort(input_arr) print(output_arr) # Output should be: [-3, -2, -1, 0, 1, 2, 3, 4] # Example 2 input_arr = [5] output_arr = counting_sort(input_arr) print(output_arr) # Output should be: [5] # Example 3 input_arr = [] output_arr = counting_sort(input_arr) print(output_arr) # Output should be: [] ``` Ensure your implementation is efficient and handles all edge cases including arrays with negative values and empty arrays appropriately.","solution":"from typing import List def counting_sort(arr: List[int]) -> List[int]: if not arr: return arr max_val = max(arr) min_val = min(arr) range_val = max_val - min_val + 1 count = [0] * range_val output = [0] * len(arr) for num in arr: count[num - min_val] += 1 for i in range(1, len(count)): count[i] += count[i - 1] for num in reversed(arr): output[count[num - min_val] - 1] = num count[num - min_val] -= 1 return output"},{"question":"You have been provided with an implementation of a Segment Tree data structure that can be used to perform efficient range queries and point updates on an array. Your task is to modify the `SegmentTree` class so that it can handle additional functionality. # Task Modify the `SegmentTree` class to implement the following new method: Method: `range_update` * **Input**: Two indices `l` and `r`, and a value `val`. * **Output**: None. * **Objective**: Update every element in the range `[l, r]` by applying the function with the given `val` without rebuilding the entire tree. # Constraints 1. The array elements and the value used for `range_update` can be integers, floats, or tuples. 2. The function provided to the segment tree constructor will always be a commutative function (i.e., `f(a, b) == f(b, a)`). 3. The function provided will be closed within the range, which means applying the function any number of times will still result in valid elements of the array. # Example ```python arr = [4, 7, 2, 5, 3] segment_tree = SegmentTree(arr, lambda a, b: a + b) # Initial range query print(segment_tree.query(0, 4)) # Output: 21 (4+7+2+5+3) # Range update segment_tree.range_update(1, 3, 10) # Applying addition by 10 to elements in range [1, 3] # Query after range update print(segment_tree.query(0, 4)) # Updated Output should consider updated values ``` **Note**: In this example, the range update adds 10 to elements at positions 1, 2, and 3. So the updated array would be `[4, 17, 12, 15, 3]`. The query result `[0, 4]` now becomes `4 + 17 + 12 + 15 + 3 = 51`. # Additional Notes * Your implementation should ensure that the `range_update` operation is efficient and does not involve rebuilding the entire tree. * You may assume that the `update` and `query` methods provided by the initial `SegmentTree` class implementation are functional and correct.","solution":"class SegmentTree: def __init__(self, data, function): self.n = len(data) self.function = function self.data = data[:] self.tree = [0] * (2 * self.n) self.build() def build(self): # Initialize leaves of the tree for i in range(self.n): self.tree[self.n + i] = self.data[i] # Construct the rest of the tree for i in range(self.n - 1, 0, -1): self.tree[i] = self.function(self.tree[2 * i], self.tree[2 * i + 1]) def update(self, idx, value): idx += self.n self.tree[idx] = value while idx > 1: idx //= 2 self.tree[idx] = self.function(self.tree[2 * idx], self.tree[2 * idx + 1]) def query(self, l, r): l += self.n r += self.n + 1 res = None while l < r: if l % 2 == 1: res = self.tree[l] if res is None else self.function(res, self.tree[l]) l += 1 if r % 2 == 1: r -= 1 res = self.tree[r] if res is None else self.function(res, self.tree[r]) l //= 2 r //= 2 return res def range_update(self, l, r, val): for i in range(l, r + 1): self.data[i] = self.function(self.data[i], val) self.update(i, self.data[i])"},{"question":"**Problem Statement:** You are given an array of integers `arr`. Your task is to implement the merge sort algorithm to sort this array in non-decreasing order. Write a function `merge_sort(arr)` that sorts the array using the merge sort algorithm. # Requirements: 1. **Function Signature**: `def merge_sort(arr: List[int]) -> List[int]:` 2. **Input**: An array `arr` of integers, where `1 <= len(arr) <= 10^5` and `-10^9 <= arr[i] <= 10^9`. 3. **Output**: A new array that contains the elements of `arr` sorted in non-decreasing order. # Constraints: - The solution should have a time complexity of O(n log(n)). - The space complexity should be within acceptable parameters for large arrays (O(n)). # Examples: Example 1: - **Input**: `[5, 3, 8, 6, 2, 7, 4, 1]` - **Output**: `[1, 2, 3, 4, 5, 6, 7, 8]` Example 2: - **Input**: `[12, 11, 13, 5, 6, 7]` - **Output**: `[5, 6, 7, 11, 12, 13]` # Scenario: Imagine you are a software engineer at a company that needs to provide a real-time sorting feature as part of their data analysis tool. Your task is to implement merge sort to handle this sorting efficiently even when dealing with voluminous data. # Notes: - You can assume that Python\'s recursion limit will not be exceeded given the input constraints. - The implementation should manage memory efficiently to handle the upper limits of input size.","solution":"from typing import List def merge_sort(arr: List[int]) -> List[int]: Sorts the array `arr` using the merge sort algorithm. if len(arr) <= 1: return arr def merge(left: List[int], right: List[int]) -> List[int]: sorted_array = [] i = j = 0 while i < len(left) and j < len(right): if left[i] <= right[j]: sorted_array.append(left[i]) i += 1 else: sorted_array.append(right[j]) j += 1 sorted_array.extend(left[i:]) sorted_array.extend(right[j:]) return sorted_array mid = len(arr) // 2 left_half = merge_sort(arr[:mid]) right_half = merge_sort(arr[mid:]) return merge(left_half, right_half)"},{"question":"You are tasked with writing a function to determine if a given text matches a given pattern. The pattern includes two special characters: - `.`, which matches any single character. - `*`, which matches zero or more of the preceding element. The matching should cover the entire input string (`str_a`), not just part of it. Implement the function `is_match(str_a, str_b)` where `str_a` is the input string and `str_b` is the pattern. # Function Signature ```python def is_match(str_a: str, str_b: str) -> bool: # Implement your solution here ``` # Input - `str_a`: The input string containing lowercase characters (1 ≤ len(str_a) ≤ 100). - `str_b`: The pattern string containing lowercase characters, `.` and `*` (1 ≤ len(str_b) ≤ 100). # Output - A boolean value `True` if the pattern matches the entire input string, and `False` otherwise. # Constraints 1. The pattern string will be valid and will not contain consecutive `*`. # Example ```python is_match(\\"aa\\", \\"a\\") # Output: False is_match(\\"aa\\", \\"aa\\") # Output: True is_match(\\"aaa\\", \\"aa\\") # Output: False is_match(\\"aa\\", \\"a*\\") # Output: True is_match(\\"aa\\", \\".*\\") # Output: True is_match(\\"ab\\", \\".*\\") # Output: True is_match(\\"aab\\", \\"c*a*b\\") # Output: True ``` # Explanation 1. `(\\"aa\\", \\"a\\")` should return `False` because the string does not match the pattern. 2. `(\\"aa\\", \\"aa\\")` should return `True` because the string matches the pattern. 3. `(\\"aaa\\", \\"aa\\")` should return `False` because the string does not match the pattern. 4. `(\\"aa\\", \\"a*\\")` should return `True`, as `*` means \\"zero or more of the preceding element\\". 5. `(\\"aa\\", \\".*\\")` should return `True`, as `.` means \\"any single character\\" and `*` means \\"zero or more\\". 6. `(\\"ab\\", \\".*\\")` should return `True` for the same reason as (5). 7. `(\\"aab\\", \\"c*a*b\\")` should return `True` because `c*` can match zero `c`s, `a*` can match two `a`s, and `b` matches `b`. Write your solution such that the implementation handles all edge cases and provides correct results efficiently within the constraints.","solution":"def is_match(str_a: str, str_b: str) -> bool: def match_helper(i, j): if j == len(str_b): return i == len(str_a) first_match = i < len(str_a) and str_b[j] in {str_a[i], \'.\'} if j + 1 < len(str_b) and str_b[j + 1] == \'*\': return (match_helper(i, j + 2) or first_match and match_helper(i + 1, j)) else: return first_match and match_helper(i + 1, j + 1) return match_helper(0, 0)"},{"question":"We have discussed the Extended Euclidean Algorithm and how it can be used to find the modular inverse of a number. Now it\'s time to implement this to solve a real-world problem in cryptography. Problem Statement Alice wants to encrypt a message using the RSA algorithm. For this, she needs to generate a public and private key pair. As part of this process, she needs to find the modular inverse count `d` corresponding to the public key exponent `e` and the totient function `φ(n)` value. Given two integers `e` (public key exponent) and `φ(n)` (Euler\'s Totient Function value for a modulus `n`), implement a function `find_modular_inverse` that finds and returns the modular inverse `d` of `e` modulo `φ(n)`. # Function Signature ```python def find_modular_inverse(e: int, phi_n: int) -> int: Returns the modular inverse \'d\' of \'e\' modulo \'phi_n\'. pass ``` # Input * `e` - an integer representing the public key exponent (1 ≤ e < φ(n)). * `phi_n` - an integer representing the Euler\'s Totient Function value (φ(n) > 1). # Output * The integer `d`, where `1 < d < φ(n)`, such that `(d * e) % φ(n) == 1`. # Constraints * `e` and `phi_n` are guaranteed to be coprime. * If the inverse does not exist for any reason, throw an appropriate exception. # Example ```python # Example 1: e = 3 phi_n = 26 find_modular_inverse(e, phi_n) -> 9 # Example 2: e = 17 phi_n = 3120 find_modular_inverse(e, phi_n) -> 2753 ``` # Notes 1. You may assume that `e` and `phi_n` will always be coprime for the purpose of this problem, i.e., `GCD(e, φ(n)) = 1`. Use the `extended_gcd` and `modular_inverse` function from the previously provided code snippets to complete your implementation. Ensure that the output satisfies the modular inverse properties required for RSA key generation.","solution":"def extended_gcd(a, b): Extended Euclidean Algorithm. It returns a tuple (g, x, y) such that g = gcd(a, b) and a*x + b*y = g if b == 0: return a, 1, 0 g, x1, y1 = extended_gcd(b, a % b) x = y1 y = x1 - (a // b) * y1 return g, x, y def find_modular_inverse(e, phi_n): Returns the modular inverse \'d\' of \'e\' modulo \'phi_n\' using the Extended Euclidean Algorithm. :param e: An integer representing the public key exponent (1 ≤ e < φ(n)) :param phi_n: An integer representing the Euler\'s Totient Function value (φ(n) > 1) :return: The integer \'d\' where \'1 < d < φ(n)\' such that \'d * e ≡ 1 (mod φ(n))\' # Compute gcd and the coefficients x and y for the equation: e*x + phi_n*y = gcd(e, phi_n) gcd, x, y = extended_gcd(e, phi_n) # Since we are given that gcd(e, phi_n) = 1, x is the modular inverse of e # If x is negative, we add phi_n to make it positive if x < 0: x += phi_n return x"},{"question":"You are tasked with implementing an algorithm that checks if a given string `s` can be formed by merging two other strings `part1` and `part2`, maintaining their character order. This algorithm must handle various corner cases and should be efficient enough to handle long input strings. # Function Signature: ```python def is_merge(s: str, part1: str, part2: str) -> bool: pass ``` # Input: - `s` (string): The target string that needs to be formed (1 ≤ len(s) ≤ 1000). - `part1` (string): First part of the string that needs to be merged (0 ≤ len(part1) ≤ 1000). - `part2` (string): Second part of the string that needs to be merged (0 ≤ len(part2) ≤ 1000). # Output: - Returns a boolean value `True` if `s` can be formed by interleaving `part1` and `part2`, otherwise `False`. # Constraints: - Characters in `part1` and `part2` must appear in the same order in `s`. - Combined length of `part1` and `part2` should be equal to `s`. # Examples: - Example 1: ```python is_merge(\\"codewars\\", \\"cdw\\", \\"oears\\") # returns True ``` - Example 2: ```python is_merge(\\"codewars\\", \\"code\\", \\"wars\\") # returns True ``` - Example 3: ```python is_merge(\\"codewars\\", \\"cod\\", \\"ewar\\") # returns False ``` # Performance: - Optimize for scenarios where `s` is large but constraints still apply. - Consider both recursive and iterative solutions, and justify the choice based on observed performance. # Notes: - Ensure your implementation handles edge cases efficiently. - Provide tests that validate the solution across a range of scenarios, including minimal and maximal input sizes.","solution":"def is_merge(s: str, part1: str, part2: str) -> bool: if len(s) != len(part1) + len(part2): return False dp = [[False] * (len(part2) + 1) for _ in range(len(part1) + 1)] dp[0][0] = True for i in range(1, len(part1) + 1): dp[i][0] = dp[i-1][0] and part1[i-1] == s[i-1] for j in range(1, len(part2) + 1): dp[0][j] = dp[0][j-1] and part2[j-1] == s[j-1] for i in range(1, len(part1) + 1): for j in range(1, len(part2) + 1): dp[i][j] = (dp[i-1][j] and part1[i-1] == s[i+j-1]) or (dp[i][j-1] and part2[j-1] == s[i+j-1]) return dp[-1][-1]"},{"question":"# Queue Implementation and Performance Analysis Context You are tasked with developing an application requiring efficient task management where tasks need to be processed in the order they were added (FIFO order). You have two different queue implementation options: using a dynamic array (ArrayQueue) or a linked list (LinkedListQueue). Task 1. **Implementation**: - Write a function `process_tasks(queue_type, tasks)` that takes in: - `queue_type`: A string that can be either \\"array\\" or \\"linked\\" indicating which queue implementation to use. - `tasks`: A list of tasks (integers) to be processed. - The function should create the appropriate queue (`ArrayQueue` or `LinkedListQueue`), enqueue all tasks, then dequeue each task and print it. 2. **Performance Analysis**: - Compare the performance of both implementations by measuring the time taken to enqueue and dequeue the tasks. - Write a brief summary of the performance differences observed. Consider time complexity and any other relevant factors. Input - `queue_type`: A string (\\"array\\" or \\"linked\\"). - `tasks`: A list of integers representing tasks. Output - Print each task processed. - Return a string summary of performance analysis. Constraints - The number of tasks will not exceed 10^6. - Each task is an integer in the range [1, 10^9]. ```python def process_tasks(queue_type, tasks): import time if queue_type == \\"array\\": queue = ArrayQueue() elif queue_type == \\"linked\\": queue = LinkedListQueue() else: raise ValueError(\\"Invalid queue type\\") start_time = time.time() for task in tasks: queue.enqueue(task) enqueue_time = time.time() - start_time start_time = time.time() while not queue.is_empty(): print(queue.dequeue()) dequeue_time = time.time() - start_time summary = f\\"Performance Analysis:n\\" f\\"Enqueue Time: {enqueue_time:.6f} secondsn\\" f\\"Dequeue Time: {dequeue_time:.6f} secondsn\\" f\\"Total Time: {enqueue_time + dequeue_time:.6f} seconds\\" return summary ``` Example ```python # Assuming \'ArrayQueue\' and \'LinkedListQueue\' classes have been implemented above: tasks = [1, 2, 3, 4, 5] print(process_tasks(\\"array\\", tasks)) # Output should print the tasks in order (1, 2, 3, 4, 5), followed by a performance summary. print(process_tasks(\\"linked\\", tasks)) # Output should print the tasks in order (1, 2, 3, 4, 5), followed by a performance summary. ```","solution":"class ArrayQueue: def __init__(self): self.queue = [] def enqueue(self, item): self.queue.append(item) def dequeue(self): if self.is_empty(): raise IndexError(\\"Dequeue from empty queue\\") return self.queue.pop(0) def is_empty(self): return len(self.queue) == 0 class LinkedListQueue: class Node: def __init__(self, value): self.value = value self.next = None def __init__(self): self.head = None self.tail = None def enqueue(self, item): new_node = self.Node(item) if self.tail: self.tail.next = new_node self.tail = new_node if not self.head: self.head = new_node def dequeue(self): if self.is_empty(): raise IndexError(\\"Dequeue from empty queue\\") value = self.head.value self.head = self.head.next if not self.head: self.tail = None return value def is_empty(self): return self.head is None def process_tasks(queue_type, tasks): import time if queue_type == \\"array\\": queue = ArrayQueue() elif queue_type == \\"linked\\": queue = LinkedListQueue() else: raise ValueError(\\"Invalid queue type\\") start_time = time.time() for task in tasks: queue.enqueue(task) enqueue_time = time.time() - start_time start_time = time.time() while not queue.is_empty(): print(queue.dequeue()) dequeue_time = time.time() - start_time summary = f\\"Performance Analysis:n\\" f\\"Enqueue Time: {enqueue_time:.6f} secondsn\\" f\\"Dequeue Time: {dequeue_time:.6f} secondsn\\" f\\"Total Time: {enqueue_time + dequeue_time:.6f} seconds\\" return summary"},{"question":"**Question**: Implement a function `find_missing_side(opposite: Union[float, str], adjacent: Union[float, str], hypotenuse: Union[float, str]) -> Union[str, float]` which returns the length of the third side of a right-angled triangle when provided with the lengths of the other two sides. - If the unknown side\'s length is to be found, one of the parameters will be passed the string `\\"?\\"`. - Raise a `ValueError` if inputs are invalid (e.g., non-positive numbers, more than one parameter as `\\"?\\"`, etc.) **Input Format**: - `opposite` (float, str): Length of the opposite side or `\\"?\\"` for unknown. - `adjacent` (float, str): Length of the adjacent side or `\\"?\\"` for unknown. - `hypotenuse` (float, str): Length of the hypotenuse or `\\"?\\"` for unknown. **Output Format**: - A `float` representing the length of the missing side. - A `str` indicating an error if the input parameters are not valid. **Constraints**: - Lengths of the sides must be positive numbers. - No more than one parameter should be `\\"?\\"`. **Performance Requirements**: - The function should run in constant time, O(1). **Example**: 1. `find_missing_side(\\"?\\", 3, 5)` should return `4.0` 2. `find_missing_side(4, \\"?\\", 5)` should return `3.0` 3. `find_missing_side(4, 3, \\"?\\")` should return `5.0` 4. `find_missing_side(4, 5, \\"?\\")` should raise `ValueError(\\"Invalid side lengths.\\")` 5. `find_missing_side(0, 3, 5)` should raise `ValueError(\\"Side lengths must be positive.\\")` 6. `find_missing_side(4, \\"?\\", \\"5\\")` should raise `ValueError(\\"Invalid number of unknown sides.\\")`","solution":"from typing import Union def find_missing_side(opposite: Union[float, str], adjacent: Union[float, str], hypotenuse: Union[float, str]) -> Union[str, float]: Returns the length of the missing side of a right-angled triangle. :param opposite: Length of the opposite side or \\"?\\" if unknown. :param adjacent: Length of the adjacent side or \\"?\\" if unknown. :param hypotenuse: Length of the hypotenuse or \\"?\\" if unknown. :return: Length of the missing side or raises a ValueError for invalid inputs. try: sides = [opposite, adjacent, hypotenuse] unknown_count = sides.count(\\"?\\") if unknown_count != 1: raise ValueError(\\"Invalid number of unknown sides.\\") if opposite != \\"?\\": opposite = float(opposite) if adjacent != \\"?\\": adjacent = float(adjacent) if hypotenuse != \\"?\\": hypotenuse = float(hypotenuse) # Validate positive lengths if (opposite != \\"?\\" and opposite <= 0) or (adjacent != \\"?\\" and adjacent <= 0) or (hypotenuse != \\"?\\" and hypotenuse <= 0): raise ValueError(\\"Side lengths must be positive.\\") if opposite == \\"?\\": if hypotenuse <= adjacent: raise ValueError(\\"Invalid side lengths.\\") return (hypotenuse ** 2 - adjacent ** 2) ** 0.5 if adjacent == \\"?\\": if hypotenuse <= opposite: raise ValueError(\\"Invalid side lengths.\\") return (hypotenuse ** 2 - opposite ** 2) ** 0.5 if hypotenuse == \\"?\\": return (opposite ** 2 + adjacent ** 2) ** 0.5 except ValueError as ve: return str(ve)"},{"question":"# Comb Sort Algorithm Implementation Problem Statement Write a Python function to implement the Comb Sort algorithm. Given an unsorted list of integers, your task is to sort the list in ascending order using the Comb Sort approach detailed below: **Expected Function Signature**: ```python def comb_sort(arr: List[int]) -> List[int]: ``` Parameters: - **arr (List[int])**: A list of integers that needs to be sorted. The list can be of varying lengths, including empty. Returns: - **List[int]**: A sorted list of integers in ascending order. Constraints: - You must use the Comb Sort algorithm. - The algorithm should remain in-place, requiring only a constant amount of additional memory. - You may customize the shrink factor but justify your decision in the comments. Example: ```python assert comb_sort([3, 0, 2, 5, -1, 4, 1]) == [-1, 0, 1, 2, 3, 4, 5] assert comb_sort([10, 9, 8, 7, 6, 5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] assert comb_sort([]) == [] assert comb_sort([1]) == [1] assert comb_sort([5, 5, 5, 5, 5]) == [5, 5, 5, 5, 5] ``` Guidelines: 1. Initialize necessary variables such as `gap`, `shrink factor`, and a boolean `sorted`. 2. Continuously update the gap and compare elements in the `arr` using the gap. 3. Swap elements if necessary and mark the list as unsorted if any swaps are made. 4. Repeat the process until the gap is 1 and no swaps are needed. 5. Return the sorted list. Analysis: * Analyze the running time in terms of Big-O notation. * Discuss edge cases and how your implementation handles them.","solution":"def comb_sort(arr): Implementation of Comb Sort algorithm to sort a list of integers. :param arr: List[int] - a list of integers to be sorted. :return: List[int] - the sorted list. def get_next_gap(gap): # Shrink factor of 1.3 is generally used to reduce the gap gap = (gap * 10) // 13 if gap < 1: return 1 return int(gap) n = len(arr) gap = n swapped = True while gap != 1 or swapped: gap = get_next_gap(gap) swapped = False for i in range(0, n - gap): if arr[i] > arr[i + gap]: arr[i], arr[i + gap] = arr[i + gap], arr[i] swapped = True return arr"},{"question":"**Scenario**: Alice and Bob work in a company that needs to securely exchange sensitive data. They decide to use Diffie-Hellman Key Exchange to generate a shared secret key. You need to help implement the system that will allow them to safely generate and exchange this key. **Task**: Write a Python function `secure_key_exchange(p: int, a: int) -> bool` that will perform the Diffie-Hellman key exchange. The function should: 1. Validate that `p` is a prime number. 2. Validate that `a` is a primitive root of `p`. 3. Generate private keys for Alice and Bob. 4. Compute their public keys. 5. Compute their shared secret keys and ensure both calculated keys match. **Function Specification**: ```python def secure_key_exchange(p: int, a: int) -> bool: Perform a secure Diffie-Hellman key exchange. Parameters: - p: A large prime number. - a: A primitive root of `p`. Returns: - True if the key exchange is successful and both keys match. - False if any validation fails or keys do not match. ``` **Input Constraints**: - `p` is a positive prime number less than 10^9 - `a` is a positive integer **Sample Input**: ```python secure_key_exchange(23, 5) ``` **Expected Output**: ```python True ``` **Additional Notes**: - You may need to write auxiliary functions (for primality checking, primitive root checking, and key calculations). - Ensure to handle and print appropriate error messages for invalid inputs. - Consider edge cases where inputs do not meet constraints.","solution":"import random def is_prime(n): Check if a number is a prime number. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def primitive_root(p): Find the smallest primitive root of a prime number p. if not is_prime(p): return None required_set = {num for num in range(1, p) if gcd(num, p) == 1} for g in range(1, p): actual_set = {pow(g, powers, p) for powers in range(1, p)} if required_set == actual_set: return g return None def gcd(a, b): Return the greatest common divisor of a and b. while b: a, b = b, a % b return a def secure_key_exchange(p: int, a: int) -> bool: Perform a secure Diffie-Hellman key exchange. Parameters: - p: A large prime number. - a: A primitive root of `p`. Returns: - True if the key exchange is successful and both keys match. - False if any validation fails or keys do not match. # Step 1: Validate that p is a prime number if not is_prime(p): print(\\"Error: p is not a prime number.\\") return False # Step 2: Validate that a is a primitive root of p if a != primitive_root(p): print(\\"Error: a is not a primitive root of p.\\") return False # Step 3: Generate private keys for Alice and Bob private_key_alice = random.randint(1, p-2) private_key_bob = random.randint(1, p-2) # Step 4: Compute their public keys public_key_alice = pow(a, private_key_alice, p) public_key_bob = pow(a, private_key_bob, p) # Step 5: Compute their shared secret keys shared_secret_alice = pow(public_key_bob, private_key_alice, p) shared_secret_bob = pow(public_key_alice, private_key_bob, p) # Ensure both calculated shared secret keys match if shared_secret_alice == shared_secret_bob: return True return False"},{"question":"# Scenario You have been hired by a game development company to simulate the behavior of a character moving around a board. The character\'s moves follow a Markov Chain, where the next move depends only on the current move\'s state and predefined transition probabilities. # Task Write a function `simulated_moves(chain, start_state, num_moves)` that takes in: - A Markov Chain represented by a dictionary where keys are states and values are dictionaries of possible next states with their transition probabilities. - A `start_state` indicating the character\'s starting position. - An integer `num_moves` representing the number of moves to simulate. The function should return a list of states representing the sequence of states from the start state after the specified number of moves. # Input and Output - **Input**: - `chain`: Dictionary (e.g., `{\'A\': {\'A\': 0.6, \'E\': 0.4}, \'E\': {\'A\': 0.7, \'E\': 0.3}}`) - `start_state`: String (e.g., `\'A\'`) - `num_moves`: Integer (e.g., `5`) - **Output**: - List of states (e.g., `[\'A\', \'E\', \'A\', \'A\', \'E\']`) # Constraints - You can assume the chain contains valid states and transition probabilities. - The `num_moves` will be a non-negative integer. # Example ```python chain = { \'A\': {\'A\': 0.6, \'E\': 0.4}, \'E\': {\'A\': 0.7, \'E\': 0.3} } start_state = \'A\' num_moves = 5 print(simulated_moves(chain, start_state, num_moves)) # Example Output: [\'A\', \'E\', \'A\', \'A\', \'E\'] ``` # Notes - You should use the provided Markov Chain transition structure for the state transitions. - Make sure to handle edge cases such as no moves (`num_moves` = 0).","solution":"import random def simulated_moves(chain, start_state, num_moves): Simulate the sequence of states based on the Markov Chain transition probabilities. Parameters: - chain: Dictionary representing the Markov Chain transition probabilities. - start_state: Initial state of the character. - num_moves: Number of moves to simulate. Returns: - List of states representing the sequence of states after num_moves transitions. state_sequence = [start_state] current_state = start_state for _ in range(num_moves): next_state = random.choices( list(chain[current_state].keys()), weights=list(chain[current_state].values()) )[0] state_sequence.append(next_state) current_state = next_state return state_sequence"},{"question":"Implement Advanced Binary Search with Modification Problem Statement You are given a sorted (in ascending order) list of integers. Besides finding the presence of a target value, your task is to modify the traditional binary search to count occurrences of the target value in the list. If the target value is not present, your function should return 0. Function Signature: ```python def count_occurrences(array: List[int], target: int) -> int: ``` Input: - **array**: A list of integers sorted in ascending order (e.g., `[1, 2, 2, 2, 3, 4, 5]`). - **target**: An integer value to search for in the array. Output: - Return the number of occurrences of the target in the array (e.g., `3` for the array `[1, 2, 2, 2, 3, 4, 5]` and target `2`). Constraints: - The length of `array` will be in the range `[0, 10^6]`. - The elements of `array` and `target` can range from `-10^9` to `10^9`. Performance Requirements: - Your solution should have a time complexity of O(log n) to locate the first and last occurrence of the target. - Space complexity should be O(1) for the iterative approach or O(log n) for the recursive approach. Example: ```python assert count_occurrences([1, 1, 2, 2, 2, 3, 4, 4, 4, 4, 5], 2) == 3 assert count_occurrences([1, 2, 3, 4, 5], 6) == 0 assert count_occurrences([], 2) == 0 ``` # Guidelines: 1. First, implement an auxiliary function to find the first occurrence of the target. 2. Next, implement an auxiliary function to find the last occurrence of the target. 3. Combine these functions to calculate the total number of occurrences of the target. Note: Ensure your implementation handles edge cases such as empty arrays, single-element arrays, and no occurrence of the target value gracefully.","solution":"from typing import List def count_occurrences(array: List[int], target: int) -> int: def find_first(array, target): left, right = 0, len(array) - 1 first_occurrence = -1 while left <= right: mid = left + (right - left) // 2 if array[mid] == target: first_occurrence = mid right = mid - 1 elif array[mid] < target: left = mid + 1 else: right = mid - 1 return first_occurrence def find_last(array, target): left, right = 0, len(array) - 1 last_occurrence = -1 while left <= right: mid = left + (right - left) // 2 if array[mid] == target: last_occurrence = mid left = mid + 1 elif array[mid] < target: left = mid + 1 else: right = mid - 1 return last_occurrence first = find_first(array, target) if first == -1: return 0 last = find_last(array, target) return last - first + 1"},{"question":"# Queue Implementation with Circular Buffer Context A common scenario in network routers is to handle packet queues efficiently without allocating excessive memory. One approach is to use a circular buffer or ring buffer, where the queue behaves in a cyclic manner to utilize fixed memory optimally. Task You are required to modify the `ArrayQueue` implementation to include a circular buffer. This will enhance the classic array-based implementation to handle wrap-around scenarios efficiently without needing to resize frequently. Function Implementation 1. **Class Definition**: Modify the `ArrayQueue` class to implement a circular buffer. 2. **New Methods**: - `is_full()`: Returns whether the queue is full. - Update `enqueue` and `dequeue` to handle circular wrap-around. 3. **Expected Input and Output Formats**: - **enqueue(value)**: Adds a new item to the rear of the queue. - **dequeue()**: Removes the front item from the queue and returns it. - `is_empty()`: Returns a boolean indicating whether the queue is empty. - `is_full()`: Returns a boolean indicating whether the queue is full. - `peek()`: Returns the front item without removing it. - `size()`: Returns the number of items in the queue. Constraints - The queue should manage wrap-around using a fixed-size array. - Efficient handling of enqueue and dequeue with O(1) time complexity. - Raise an appropriate exception if `dequeue` or `peek` operations are performed on an empty queue. Example ```python queue = ArrayQueue(capacity=5) queue.enqueue(1) queue.enqueue(2) queue.enqueue(3) queue.dequeue() # -> 1 queue.enqueue(4) queue.enqueue(5) queue.enqueue(6) # This should raise an exception if queue full print(queue.is_full()) # -> True print(queue.peek()) # -> 2 ``` Implement the modified `ArrayQueue` class below: ```python class ArrayQueue(AbstractQueue): def __init__(self, capacity=10): super().__init__() self._array = [None] * capacity self._front = 0 self._rear = 0 self._capacity = capacity def is_full(self): return self._size == self._capacity def __iter__(self): probe = self._front count = 0 while count < self._size: yield self._array[probe] probe = (probe + 1) % self._capacity count += 1 def enqueue(self, value): if self.is_full(): raise OverflowError(\\"Queue is full\\") self._array[self._rear] = value self._rear = (self._rear + 1) % self._capacity self._size += 1 def dequeue(self): if self.is_empty(): raise IndexError(\\"Queue is empty\\") value = self._array[self._front] self._array[self._front] = None self._front = (self._front + 1) % self._capacity self._size -= 1 return value def peek(self): if self.is_empty(): raise IndexError(\\"Queue is empty\\") return self._array[self._front] ``` The above code serves as a base for your implementation.","solution":"class ArrayQueue: def __init__(self, capacity=10): Initialize the queue with a fixed capacity. self._array = [None] * capacity self._front = 0 self._rear = 0 self._size = 0 self._capacity = capacity def is_empty(self): Check if the queue is empty. return self._size == 0 def is_full(self): Check if the queue is full. return self._size == self._capacity def enqueue(self, value): Add a new item to the rear of the queue. Raise OverflowError if the queue is full. if self.is_full(): raise OverflowError(\\"Queue is full\\") self._array[self._rear] = value self._rear = (self._rear + 1) % self._capacity self._size += 1 def dequeue(self): Remove and return the front item from the queue. Raise IndexError if the queue is empty. if self.is_empty(): raise IndexError(\\"Queue is empty\\") value = self._array[self._front] self._array[self._front] = None self._front = (self._front + 1) % self._capacity self._size -= 1 return value def peek(self): Return the front item from the queue without removing it. Raise IndexError if the queue is empty. if self.is_empty(): raise IndexError(\\"Queue is empty\\") return self._array[self._front] def size(self): Return the number of items in the queue. return self._size"},{"question":"# Question: Advanced GCD Calculation You are given two non-negative integers `a` and `b`. Your task is to implement two functions: 1. `gcd_advanced(a, b)`: This function should compute the greatest common divisor (GCD) of `a` and `b` using the bitwise operations strategy, incorporating all necessary error handling. 2. `lcm_advanced(a, b)`: This function should compute the least common multiple (LCM) of `a` and `b` using the GCD calculated by `gcd_advanced`. # Input: - Two non-negative integers `a` and `b` (0 ≤ a, b ≤ 10^9) # Output: - For `gcd_advanced`: Return the GCD of `a` and `b`. - For `lcm_advanced`: Return the LCM of `a` and `b`. # Constraints: - Do not use any built-in functions for GCD. - Consider edge cases where one or both numbers may be zero. - Aim to maintain optimal time complexity. # Example: ```python # Example 1 a = 48 b = 18 print(gcd_advanced(a, b)) # Output: 6 print(lcm_advanced(a, b)) # Output: 144 # Example 2 a = 0 b = 5 print(gcd_advanced(a, b)) # Output: 5 print(lcm_advanced(a, b)) # Output: 0 # Example 3 a = 7 b = 0 print(gcd_advanced(a, b)) # Output: 7 print(lcm_advanced(a, b)) # Output: 0 # Example 4 a = 0 b = 0 print(gcd_advanced(a, b)) # Output: 0 print(lcm_advanced(a, b)) # Output: ValueError or 0 (depending on your implementation details) ``` # Function signatures: ```python def gcd_advanced(a, b): # Implementation here def lcm_advanced(a, b): # Implementation here ``` # Notes: - Handle the special case when both `a` and `b` are zero, typically GCD(0, 0) is undefined, you may return `0` or raise a ValueError. - Ensure that your LCM calculation does not result in a floating-point number but remains an integer.","solution":"def gcd_advanced(a, b): Computes the greatest common divisor of a and b using bitwise operations. if a == 0: return b if b == 0: return a # Find the greatest power of 2 that divides both a and b shift = 0 while ((a | b) & 1) == 0: a >>= 1 b >>= 1 shift += 1 # Make sure \'a\' is odd while (a & 1) == 0: a >>= 1 while b != 0: while (b & 1) == 0: b >>= 1 if a > b: a, b = b, a b -= a # Restore the common power of 2 return a << shift def lcm_advanced(a, b): Computes the least common multiple of a and b using the gcd_advanced function. if a == 0 or b == 0: return 0 return a * b // gcd_advanced(a, b)"},{"question":"Convert Sorted Array to Height-Balanced BST Background You are given an array where elements are sorted in ascending order. You need to write a function that converts this array into a height-balanced Binary Search Tree (BST). Task Implement a function `sorted_array_to_bst(nums: List[int]) -> Optional[TreeNode]` that converts the given sorted array `nums` into a height-balanced BST and returns the root of the BST. Definitions - A height-balanced Binary Tree is defined as a binary tree in which the depth of the two subtrees of every node never differs by more than 1. Input - A single list of integers `nums` where `nums` is sorted in ascending order. Output - Return the root of the height-balanced BST. Constraints - `0 <= len(nums) <= 10^4` Example ```plaintext Input: nums = [-10,-3,0,5,9] Output: [0,-3,9,-10,null,5] Explanation: The resulting height-balanced BST would be: 0 / -3 9 / / -10 5 ``` Notes - For the output format, you can return the tree root directly as the function returns a `TreeNode` object representing the root of the BST.","solution":"from typing import List, Optional class TreeNode: def __init__(self, val: int = 0, left: \'Optional[TreeNode]\' = None, right: \'Optional[TreeNode]\' = None): self.val = val self.left = left self.right = right def sorted_array_to_bst(nums: List[int]) -> Optional[TreeNode]: if not nums: return None mid = len(nums) // 2 root = TreeNode(nums[mid]) root.left = sorted_array_to_bst(nums[:mid]) root.right = sorted_array_to_bst(nums[mid+1:]) return root"},{"question":"# Prime Validator Function Given the code snippet for checking if a number is prime, we want to extend its functionality. Write a function `prime_sum(start, end)` that calculates the sum of all prime numbers within a given inclusive range [start, end]. Input * An integer `start` (0 <= start <= 10^6) * An integer `end` (start <= end <= 10^6) Output * Return the sum of all prime numbers in the range [start, end]. Constraints * You should utilize the provided `prime_check` function within your solution. * Aim to accomplish the task with an efficient approach due to the potentially large input size. Example ```python assert prime_sum(10, 20) == 60 # Primes are 11, 13, 17, 19 assert prime_sum(1, 10) == 17 # Primes are 2, 3, 5, 7 assert prime_sum(20, 20) == 0 # There are no primes in this range ``` # Notes 1. Extend duplication by efficiently iterating through the range and leveraging the prime checking function. 2. Note the prime_check function is provided for direct use; do not redefine it. ```python def prime_sum(start, end): Calculate the sum of all prime numbers within the range [start, end] # Your implementation here ```","solution":"def prime_check(n): Check if a number is prime or not. Parameters: n (int): The number to check if prime Returns: bool: True if n is a prime number, False otherwise. if n <= 1: return False if n == 2 or n == 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while (i * i) <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def prime_sum(start, end): Calculate the sum of all prime numbers within the range [start, end] Parameters: start (int): Starting integer of the range (inclusive) end (int): Ending integer of the range (inclusive) Returns: int: Sum of all prime numbers within the range return sum(n for n in range(start, end+1) if prime_check(n))"},{"question":"# Polynomial Operations Coding Challenge Context You are given Python classes `Monomial` and `Polynomial` to represent mathematical monomials and polynomials respectively. These classes support various operations such as addition, subtraction, multiplication, and division of monomials and polynomials. You have to extend the functionality of these classes to evaluate the derivatives of the polynomials with respect to a given variable. Task Implement a function `polynomial_derivative(polynomial: Polynomial, variable: int) -> Polynomial` that computes the derivative of a given polynomial with respect to the specified variable. Requirements 1. **Function Signature**: ```python def polynomial_derivative(polynomial: Polynomial, variable: int) -> Polynomial: ``` 2. **Input**: - `polynomial`: An instance of the `Polynomial` class. - `variable`: An integer representing the variable with respect to which the derivative is to be computed. 3. **Output**: - Returns an instance of the `Polynomial` class representing the derivative of the input polynomial with respect to the specified variable. 4. **Constraints**: - The `Polynomial` class instance may contain an arbitrary number of `Monomial` instances. - The `Monomial` instances may have coefficients of type int, float, or Fraction. - The variable for differentiation will always be a non-negative integer. 5. **Performance Requirements**: - Aim for an efficient solution, minimally impacting the time and space complexity of polynomial operations. Example ```python from fractions import Fraction # Example Polynomials p1 = Polynomial([ Monomial({1: 3}, 5), # 5a1^3 Monomial({1: 2, 2: 1}, 4), # 4a1^2a2 Monomial({}, Fraction(7, 3)) # 7/3 ]) # Derivative with respect to variable 1 dp1_dv1 = polynomial_derivative(p1, 1) print(dp1_dv1) # Should print the polynomial representing the derivative # Derivative with respect to variable 2 dp1_dv2 = polynomial_derivative(p1, 2) print(dp1_dv2) # Should print the polynomial representing the derivative ``` Hints 1. Recall the power rule for derivatives ( frac{d}{dx}(x^n) = nx^{n-1} ). 2. For each monomial, adjust the power of the specified variable and multiply the coefficient accordingly. 3. Ensure to handle cases where the specified variable is not present in the monomial. Good luck!","solution":"from fractions import Fraction class Monomial: def __init__(self, powers, coefficient): Initialize a monomial. :param powers: A dictionary mapping variables to their respective powers. :param coefficient: The coefficient of the monomial, can be int, float, or Fraction. self.powers = powers self.coefficient = coefficient def derivative(self, variable): Compute the derivative of the monomial with respect to a given variable. :param variable: The variable with respect to which the derivative is computed. :return: A new Monomial representing the derivative. if variable not in self.powers: return Monomial({}, 0) new_powers = self.powers.copy() if new_powers[variable] == 1: del new_powers[variable] else: new_powers[variable] -= 1 new_coefficient = self.coefficient * self.powers[variable] return Monomial(new_powers, new_coefficient) class Polynomial: def __init__(self, monomials): Initialize a polynomial. :param monomials: A list of Monomial instances that make up the polynomial. self.monomials = monomials def derivative(self, variable): Compute the derivative of the polynomial with respect to a given variable. :param variable: The variable with respect to which the derivative is computed. :return: A new Polynomial representing the derivative. derived_monomials = [monomial.derivative(variable) for monomial in self.monomials] # Filter out zero-coefficient monomials derived_monomials = [m for m in derived_monomials if m.coefficient != 0] return Polynomial(derived_monomials) def polynomial_derivative(polynomial, variable): Compute the derivative of a polynomial with respect to a given variable. :param polynomial: An instance of the `Polynomial` class. :param variable: An integer representing the variable for differentiation. :return: An instance of the `Polynomial` class representing the derivative. return polynomial.derivative(variable)"},{"question":"# Scenario You are tasked with implementing a data serialization and deserialization mechanism for safely transmitting lists of strings over a network. The challenge is to encode a list of strings into a single string format that can be transmitted and then correctly decoded back into the original list. # Task Implement two functions, `encode` and `decode`, that handle the encoding and decoding processes according to the specified format. # Implementation Requirements 1. **Function Signatures**: ```python def encode(strs: List[str]) -> str: pass def decode(s: str) -> List[str]: pass ``` 2. **Function Behavior**: - The `encode` function should take a list of strings and convert it to a single string, where each original string is prefixed with its length and a colon (`\\":\\"`). - The `decode` function should take this encoded string and parse it back into the original list of strings. 3. **Input and Output Formats**: - `encode`: - **Input**: A list of strings, `strs`. - **Output**: A single string that represents the encoded list. - `decode`: - **Input**: A single encoded string, `s`. - **Output**: A list of strings that were originally encoded. # Constraints 1. You may assume the strings do not contain the character sequence used as the delimiter in the encoding (`length:content`). 2. All strings consist of printable ASCII characters and have a length of at most (10^5) characters. 3. The maximum number of strings in the list is (10^5). # Examples **Example 1:** ```python strs = [\\"Hello\\", \\"World\\"] encoded = encode(strs) # encoded should be \'5:Hello5:World\' decoded = decode(encoded) # decoded should be [\'Hello\', \'World\'] ``` **Example 2:** ```python strs = [\\"\\"] encoded = encode(strs) # encoded should be \'0:\' decoded = decode(encoded) # decoded should be [\'\'] ``` **Example 3:** ```python strs = [\\"abc\\", \\"123\\", \\"long_string\\" * 1000] encoded = encode(strs) # expected format is \'3:abc3:12311000:long_stringlong_string...\' decoded = decode(encoded) # decoded should be [\'abc\', \'123\', \'long_string\' * 1000] ``` Make sure to handle edge cases and large inputs efficiently.","solution":"from typing import List def encode(strs: List[str]) -> str: Encodes a list of strings into a single string. encoded_str = \'\' for s in strs: encoded_str += f\'{len(s)}:{s}\' return encoded_str def decode(s: str) -> List[str]: Decodes a single string into a list of strings. decoded_strs = [] i = 0 while i < len(s): # Find the length prefix length = \'\' while s[i] != \':\': length += s[i] i += 1 i += 1 # Skip the colon length = int(length) # Extract the string of the given length decoded_strs.append(s[i:i+length]) i += length return decoded_strs"},{"question":"# B-Tree Node Splitting Optimization Context You’re working on optimizing a database management system which uses a B-tree for indexing records. The current implementation of the B-tree handles insertion and deletion operations effectively but needs improvements in the node splitting process to enhance performance. Task Write a function `optimized_split_child` within the `BTree` class to improve upon the efficiency of the `_split_child` method. This new method should: - Minimize unnecessary operations. - Ensure that after insertion or node splitting, the tree structure remains balanced. - Optimize for both space and time complexity while maintaining the correctness. Function Signature ```python class BTree: def optimized_split_child(self, parent: Node, child_index: int) -> None: # Your implementation here ``` Requirements - **Input**: The function takes two parameters: - `parent` (Node): The parent node which contains the child to be split. - `child_index` (int): The index of the child node to split in the parent’s children list. - **Output**: The function updates the B-tree structure by splitting the specified child node. Constraints - None of the nodes should have more than `2 * t - 1` keys after splitting. - The function should be optimized for time complexity and should handle edge cases effectively. - The B-tree must remain balanced after the operation. Example Consider a B-tree where each node can have at most 3 keys (t=2). If the child node `C` with keys `[5, 10, 15]` needs to be split into two, the parent node `P` with keys `[20, 30]` will be updated to `[10, 20, 30]` and `C` will be split into two nodes `[5]` and `[15]`. Performance - Ensure that the function runs efficiently with an expected time complexity of O(t).","solution":"class Node: def __init__(self, t, leaf=False): self.t = t self.leaf = leaf self.keys = [] self.children = [] class BTree: def __init__(self, t): self.root = Node(t, True) self.t = t def optimized_split_child(self, parent: Node, child_index: int) -> None: t = self.t child = parent.children[child_index] # Create a new node to be the right child of the split. new_child = Node(t, child.leaf) parent.keys.insert(child_index, child.keys[t - 1]) parent.children.insert(child_index + 1, new_child) # Split the keys and children between the left (original) and right (new) child. new_child.keys = child.keys[t:(2 * t - 1)] child.keys = child.keys[0:(t - 1)] # If the child to be split is not a leaf, redistribute the child pointers. if not child.leaf: new_child.children = child.children[t:(2 * t)] child.children = child.children[0:t] self.update_node(parent) self.update_node(child) self.update_node(new_child) def update_node(self, node: Node): # Placeholder for any node-specific updates necessary for balancing. pass"},{"question":"# Graph Pathfinding Challenge You are given a directed graph represented as an adjacency list. Your task is to implement functions that identify paths between nodes, specifically focusing on exhaustive and efficient traversal methods. Problem Statement 1. Implement the function `find_path(graph: Dict[str, List[str]], start: str, end: str) -> List[str]` that returns a single path from `start` to `end` using depth-first search (DFS). If no path exists, return `None`. 2. Implement the function `find_all_paths(graph: Dict[str, List[str]], start: str, end: str) -> List[List[str]]` that returns all possible paths from `start` to `end` using a depth-first search approach. 3. Implement the function `find_shortest_path(graph: Dict[str, List[str]], start: str, end: str) -> List[str]` that finds the shortest path from `start` to `end` using an efficient traversal method. Input: - `graph`: A dictionary where keys are node identifiers and values are lists of adjacent nodes. - `start`: The starting node identifier. - `end`: The ending node identifier. Output: - `find_path`: A list representing a single path from `start` to `end`, or `None` if no such path exists. - `find_all_paths`: A list of lists, where each inner list represents a unique path from `start` to `end`. - `find_shortest_path`: A list representing the shortest path from `start` to `end`, or `None` if no such path exists. Constraints: - Assume the graph does not contain any self-loops. - The graph can be disconnected. - Node identifiers are unique and non-empty strings. Example: ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'D\'], \'C\': [\'D\'], \'D\': [] } print(find_path(graph, \'A\', \'D\')) # Possible outputs: [\'A\', \'B\', \'D\'] or [\'A\', \'C\', \'D\'] print(find_all_paths(graph, \'A\', \'D\')) # Outputs: [[\'A\', \'B\', \'D\'], [\'A\', \'C\', \'D\']] print(find_shortest_path(graph, \'A\', \'D\')) # Outputs: [\'A\', \'B\', \'D\'] or [\'A\', \'C\', \'D\'] ``` Note: - Carefully handle recursion depth to avoid stack overflow in large graphs. - Ensure the functions return the correct results, considering edge cases such as isolated nodes or nonexistent paths.","solution":"from typing import List, Dict def find_path(graph: Dict[str, List[str]], start: str, end: str) -> List[str]: Returns a single path from start to end using depth-first search (DFS). If no path exists, returns None. path = [] def dfs(current): if current == end: path.append(current) return True path.append(current) for neighbor in graph.get(current, []): if neighbor not in path: # To avoid cycles if dfs(neighbor): return True path.pop() return False if dfs(start): return path else: return None def find_all_paths(graph: Dict[str, List[str]], start: str, end: str) -> List[List[str]]: Returns all possible paths from start to end using depth-first search. all_paths = [] def dfs(current, current_path): current_path.append(current) if current == end: all_paths.append(current_path.copy()) else: for neighbor in graph.get(current, []): if neighbor not in current_path: # To avoid cycles dfs(neighbor, current_path) current_path.pop() dfs(start, []) return all_paths def find_shortest_path(graph: Dict[str, List[str]], start: str, end: str) -> List[str]: Finds the shortest path from start to end using a breadth-first search (BFS). If no path exists, return None. from collections import deque queue = deque([(start, [start])]) while queue: current, path = queue.popleft() for neighbor in graph.get(current, []): if neighbor not in path: if neighbor == end: return path + [neighbor] queue.append((neighbor, path + [neighbor])) return None"},{"question":"**Problem Statement**: Given two strings `s` and `t`, write a function `find_isomorphic_pairs()` to check if they are isomorphic. Two strings are isomorphic if the characters in `s` can be replaced to get `t`. All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character, but a character may map to itself. **Function Signature**: ```python def find_isomorphic_pairs(s: str, t: str) -> bool: pass ``` **Input**: - `s` (string): A string comprised of any printable characters. - `t` (string): Another string comprised of any printable characters, expected to be checked against `s` for isomorphism. **Output**: - Return `True` if the two strings are isomorphic. - Return `False` otherwise. **Constraints**: - Both strings must be of the same length. - Strings may contain any printable character including special characters. # Examples Example 1: ```plaintext Input: s = \\"egg\\", t = \\"add\\" Output: True ``` Example 2: ```plaintext Input: s = \\"foo\\", t = \\"bar\\" Output: False ``` Example 3: ```plaintext Input: s = \\"paper\\", t = \\"title\\" Output: True ``` Example 4: ```plaintext Input: s = \\"\\", t = \\"\\" Output: True ``` **Explanation**: - Example 1: Character \'e\' maps to \'a\' and \'g\' maps to \'d\'; order is preserved. - Example 2: The character \'o\' maps inconsistently. - Example 3: \'p\' maps to \'t\', \'a\' to \'i\', \'p\' to \'t\', and so forth, consistently following the pattern. **Performance Requirement**: - The solution should ideally run in O(n) time complexity, where n is the length of the strings. Use the provided function signature and implement the solution. Make sure to handle all possible edge cases and constraints.","solution":"def find_isomorphic_pairs(s: str, t: str) -> bool: Returns True if the strings s and t are isomorphic, otherwise False. if len(s) != len(t): return False # Dictionary to keep mapping of characters from s to t and vice versa s_to_t = {} t_to_s = {} for sc, tc in zip(s, t): if sc in s_to_t: if s_to_t[sc] != tc: return False if tc in t_to_s: if t_to_s[tc] != sc: return False s_to_t[sc] = tc t_to_s[tc] = sc return True"},{"question":"# Question: Bit Manipulation Utility Library **Context**: You are tasked with creating a small utility library for handling various bit manipulation tasks. This library will be used in systems programming and performance-critical applications where efficient manipulation of bits can significantly enhance performance. **Task**: Implement the following four bit manipulation functions. Your implementation must be efficient and handle edge cases appropriately. 1. **get_bit(num, i)**: Retrieve the bit at position `i` from the integer `num`. 2. **set_bit(num, i)**: Set the bit at position `i` in the integer `num` to 1. 3. **clear_bit(num, i)**: Clear the bit at position `i` in the integer `num` to 0. 4. **update_bit(num, i, bit)**: Update the bit at position `i` in the integer `num` to the given bit value (`0` or `1`). # Function Signatures ```python def get_bit(num: int, i: int) -> bool: pass def set_bit(num: int, i: int) -> int: pass def clear_bit(num: int, i: int) -> int: pass def update_bit(num: int, i: int, bit: int) -> int: pass ``` # Input * `num` is an integer that will be subjected to bit manipulation. * `i` is the bit position (0-indexed). * `bit` is the value the bit at position `i` should be updated to, which can be either `0` or `1`. # Output * `get_bit` should return a boolean value indicating whether the bit at position `i` is `1` (True) or `0` (False). * `set_bit`, `clear_bit`, and `update_bit` should return an integer representing the modified number after performing the respective bit operation. # Constraints * Use bitwise operations efficiently. * Assume `0 <= i < 32` for simplicity, considering a 32-bit integer. # Examples ```python assert get_bit(5, 0) == True # binary: 101 assert get_bit(5, 1) == False # binary: 101 assert get_bit(5, 2) == True # binary: 101 assert set_bit(5, 1) == 7 # binary: 101 -> 111 assert clear_bit(7, 1) == 5 # binary: 111 -> 101 assert update_bit(5, 1, 1) == 7 # binary: 101 -> 111 assert update_bit(7, 1, 0) == 5 # binary: 111 -> 101 ```","solution":"def get_bit(num: int, i: int) -> bool: Retrieve the bit at position i from the integer num. return (num & (1 << i)) != 0 def set_bit(num: int, i: int) -> int: Set the bit at position i in the integer num to 1. return num | (1 << i) def clear_bit(num: int, i: int) -> int: Clear the bit at position i in the integer num to 0. return num & ~(1 << i) def update_bit(num: int, i: int, bit: int) -> int: Update the bit at position i in the integer num to the given bit value (0 or 1). num = num & ~(1 << i) # Clear the bit at position i return num | (bit << i) # Set the bit at position i to the given value"},{"question":"# Question **Scenario**: You are tasked with extending the functionality of an `OrderedStack` data structure. This stack keeps elements in ascending order, with the highest element at the top and the lowest element at the bottom. You are to add methods to merge two ordered stacks into a single ordered stack. **Objective**: Write a function `merge_ordered_stacks(stack1, stack2)` which takes two instances of `OrderedStack` and returns a new `OrderedStack` that contains all the elements from both stacks, maintaining the order. # Function Signature ```python def merge_ordered_stacks(stack1, stack2): pass ``` # Input - `stack1` and `stack2`: Two instances of `OrderedStack`, each containing `n1` and `n2` elements respectively. # Output - Returns a new instance of `OrderedStack` containing all elements from `stack1` and `stack2`, ordered such that the highest element is at the top and the lowest at the bottom. # Constraints - The elements in both input stacks are unique. - Both input stacks are already sorted as per `OrderedStack` rules. # Example ```python stack1 = OrderedStack() stack1.push(1) stack1.push(3) stack1.push(5) stack2 = OrderedStack() stack2.push(2) stack2.push(4) stack2.push(6) merged_stack = merge_ordered_stacks(stack1, stack2) print(merged_stack.pop()) # Should return 6 print(merged_stack.pop()) # Should return 5 print(merged_stack.pop()) # Should return 4 print(merged_stack.pop()) # Should return 3 print(merged_stack.pop()) # Should return 2 print(merged_stack.pop()) # Should return 1 ``` # Notes - Ensure your solution efficiently merges the two stacks preserving the order. - Aim to have a linear time complexity relative to the total number of elements in both stacks if possible.","solution":"class OrderedStack: def __init__(self): self.stack = [] def push(self, element): Push an element onto the stack. The stack is maintained in ascending order, so the highest element is at the top and the lowest element is at the bottom. self.stack.append(element) self.stack.sort() # Maintain ascending order upon each push def pop(self): Remove and return the topmost element from the stack. The topmost element is the highest one. return self.stack.pop() def is_empty(self): Check if the stack is empty. return len(self.stack) == 0 def merge_ordered_stacks(stack1, stack2): merged_stack = OrderedStack() elements = stack1.stack + stack2.stack # Combine elements from both stacks elements.sort() # Sort combined elements for element in elements: merged_stack.push(element) # Push each element into the merged stack (already sorted) return merged_stack"},{"question":"# Problem Description You are provided with an encoding scheme that converts a list of strings into a single string and back. Implement the encoding and decoding functions described below. # Function Signature ```python def encode(strs: List[str]) -> str: Encodes a list of strings to a single string. :param strs: List[str], a list of strings to encode. :return: str, the encoded string. def decode(s: str) -> List[str]: Decodes a single string to a list of strings. :param s: str, the encoded string. :return: List[str], the decoded list of strings. ``` # Inputs and Outputs You need to implement the following functions: 1. **encode(strs: List[str]) -> str** - **Input**: - `strs`: A list of strings with 0 <= len(list) <= 200, and 0 <= len(each string) <= 150. - **Output**: - A single string that is the encoded representation of the list. - **Example**: `encode([\\"hello\\", \\"world\\"])` should return `\\"5:hello5:world\\"`. 2. **decode(s: str) -> List[str]** - **Input**: - `s`: A string that is the encoded representation of a list of strings. - **Output**: - A list of strings that were encoded in the input string. - **Example**: `decode(\\"5:hello5:world\\")` should return `[\\"hello\\", \\"world\\"]`. # Constraints - The input list of strings for encoding will contain only printable ASCII characters. - The encoded string for decoding will follow the specified encoding format strictly. # Requirements - Do not use any external libraries. - Ensure your solution handles edge cases, such as empty lists and strings with special characters. - Your solution should have both encoding and decoding steps within linear time complexity relative to the total number of characters processed. # Example Usage ```python # Example for encode encoded_str = encode([\\"hello\\", \\"world\\"]) print(encoded_str) # Output: \\"5:hello5:world\\" # Example for decode decoded_list = decode(\\"5:hello5:world\\") print(decoded_list) # Output: [\\"hello\\", \\"world\\"] ``` Design your solution to handle diverse edge cases and ensure accuracy and performance optimizations where necessary.","solution":"def encode(strs): Encodes a list of strings to a single string. :param strs: List[str], a list of strings to encode. :return: str, the encoded string. return \'\'.join(f\'{len(s)}:{s}\' for s in strs) def decode(s): Decodes a single string to a list of strings. :param s: str, the encoded string. :return: List[str], the decoded list of strings. output = [] i = 0 while i < len(s): colon = s.find(\':\', i) length = int(s[i:colon]) i = colon + 1 + length output.append(s[colon + 1:i]) return output"},{"question":"You are given a list of people sitting in a circular fashion. Every third member of the list is eliminated until no one is left. Your task is to implement the function `josephus_problem` that returns the elimination order as a list. # Function Signature: ```python def josephus_problem(int_list: List[int], skip: int) -> List[int]: ``` # Input: * `int_list` - A list of integers representing people sitting in a circle (1 ≤ length ≤ 10^4). * `skip` - An integer representing the skip count (Must be a positive integer, 1 ≤ skip ≤ length of the list). # Output: * Return a list of integers showing the order in which people are eliminated. # Constraints: * The input list will contain distinct integers. * The `skip` value will always be valid (1 ≤ skip ≤ length of the list). # Example: ```python assert josephus_problem([1, 2, 3, 4, 5, 6, 7, 8, 9], 3) == [3, 6, 9, 4, 8, 5, 2, 7, 1] assert josephus_problem([1, 2, 3, 4], 2) == [2, 4, 3, 1] ``` # Explanation: For the example `josephus_problem([1, 2, 3, 4, 5, 6, 7, 8, 9], 3)`, the steps of elimination are: 1. Starting from 1, the third number in the circle is 3. Remove 3. 2. The next third number after 3 (search continues circularly) is 6. Remove 6. 3. Continue this process: Remove 9, 4, 8, 5, 2, 7, and finally 1. - Elimination order: 3, 6, 9, 4, 8, 5, 2, 7, 1 # Notes: - Ensure optimal and efficient handling of the algorithm especially for large lists. - Consider edge cases such as minimal skip values or starting points near the end of the list.","solution":"from typing import List def josephus_problem(int_list: List[int], skip: int) -> List[int]: This function solves the Josephus problem. Eliminate every `skip`th member from a circular list until no one is left. :param int_list: List[int] - list of integers representing people in circle :param skip: int - skip count for elimination :return: List[int] - order of elimination elimination_order = [] position = 0 # Start from the first element while len(int_list) > 0: position = (position + skip - 1) % len(int_list) elimination_order.append(int_list.pop(position)) return elimination_order"},{"question":"# Question: Implement a More Efficient Sorting Algorithm You have seen an example of the Bogo Sort algorithm, a highly inefficient sorting method. Your task is to demonstrate your understanding of sorting algorithms by implementing a more efficient algorithm: Merge Sort. Merge Sort is a highly efficient, comparison-based, divide-and-conquer sorting algorithm. Specifically, you should write the following function: ```python def merge_sort(arr): Sorts an array of integers using the Merge Sort algorithm. Parameters: arr (list): A list of integers to be sorted. Returns: list: A new list of integers, sorted in ascending order. pass ``` # Input * A list of integers `arr` is given which may contain negative numbers, zeros, and positive numbers. * **Constraints**: * The length of `arr` will not exceed 10^5. # Output * Return a new list of integers sorted in ascending order. # Requirements: * Your solution should have a time complexity of O(n log n). * Your solution should have a space complexity of O(n). # Example ```python print(merge_sort([34, 7, 23, 32, 5, 62])) # Output: [5, 7, 23, 32, 34, 62] print(merge_sort([-10, 100, 0, 3, -2])) # Output: [-10, -2, 0, 3, 100] ``` # Performance Requirement Your function should efficiently sort the integers within the specified constraints and should be able to handle large datasets within reasonable time limits.","solution":"def merge_sort(arr): Sorts an array of integers using the Merge Sort algorithm. Parameters: arr (list): A list of integers to be sorted. Returns: list: A new list of integers, sorted in ascending order. if len(arr) <= 1: return arr mid = len(arr) // 2 left = merge_sort(arr[:mid]) right = merge_sort(arr[mid:]) return merge(left, right) def merge(left, right): Merges two sorted lists into a single sorted list. Parameters: left (list): The first sorted list. right (list): The second sorted list. Returns: list: A new list containing the elements from both input lists, sorted. sorted_arr = [] i = j = 0 while i < len(left) and j < len(right): if left[i] < right[j]: sorted_arr.append(left[i]) i += 1 else: sorted_arr.append(right[j]) j += 1 # Append any remaining elements sorted_arr.extend(left[i:]) sorted_arr.extend(right[j:]) return sorted_arr"},{"question":"# Pathfinding in a Directed Graph Context You are working on an application that requires determining if there is a path between two specific nodes in a directed graph. This is essential for understanding connectivity and network flow within the application architecture. Problem Statement Write a function `is_reachable` that receives: 1. An integer `vertex_count` representing the number of vertices. 2. A list of tuples `edges` where each tuple (u, v) represents a directed edge from vertex `u` to vertex `v`. 3. Two integers `source` and `target` representing the source and target nodes, respectively. Your function should return `True` if there is a path from the `source` to the `target`, and `False` otherwise. Function Signature ```python def is_reachable(vertex_count: int, edges: list, source: int, target: int) -> bool: pass ``` Input and Output - **Input**: - `vertex_count` (1 ≤ vertex_count ≤ 10^4): Total number of vertices. - `edges`: List of directed edges, with each edge represented by a tuple (u, v). - `source` (0 ≤ source < vertex_count): Source node. - `target` (0 ≤ target < vertex_count): Target node. - **Output**: - Boolean `True` if there is a path from the source to the target node, `False` otherwise. Constraints - The number of edges does not exceed 10^4. - Graph may contain cycles and disconnected components. Examples ```python # Example 1 print(is_reachable(4, [(0, 1), (0, 2), (1, 2), (2, 0), (2, 3), (3, 3)], 1, 3)) # True # Example 2 print(is_reachable(4, [(0, 1), (0, 2), (1, 2), (2, 0), (2, 3), (3, 3)], 3, 1)) # False ``` Requirements - Use Depth-First Search (DFS) to determine if there is a path between the given nodes. - Ensure the function handles edge cases like cycles and disconnected vertices.","solution":"def is_reachable(vertex_count: int, edges: list, source: int, target: int) -> bool: from collections import defaultdict, deque # Create adjacency list from edges graph = defaultdict(list) for u, v in edges: graph[u].append(v) # Depth First Search (DFS) to check for path visited = [False] * vertex_count stack = [source] while stack: current = stack.pop() if current == target: return True if not visited[current]: visited[current] = True for neighbor in graph[current]: if not visited[neighbor]: stack.append(neighbor) return False"},{"question":"Objective Implement the matrix factorization algorithm using the Cholesky decomposition for a given Hermitian positive-definite matrix A. Task Write a function `cholesky_decomposition` that takes a single input: - `A`: a 2D list representing a Hermitian positive-definite matrix of floats, of size n x n (0 ≤ n ≤ 100). The function should return: - A 2D list representing the lower triangular matrix resulting from the Cholesky decomposition, if the decomposition is possible. - `None` if the matrix is not a Hermitian positive-definite matrix or if it cannot be decomposed. Input Format ```python def cholesky_decomposition(A: List[List[float]]) -> Union[List[List[float]], None]: pass ``` Constraints - The input matrix `A` will have dimensions n x n where 0 ≤ n ≤ 100. - The matrix `A` is guaranteed to be Hermitian (i.e., (A[i][j] = A[j][i])) Output Format - A 2D list representing the lower triangular matrix `V` if decomposition is successful. - `None` if decomposition is not possible. Example ```python # Example 1: A = [ [4, 12, -16], [12, 37, -43], [-16, -43, 98] ] print(cholesky_decomposition(A)) # Output: [ # [2.0, 0.0, 0.0], # [6.0, 1.0, 0.0], # [-8.0, 5.0, 3.0] # ] # Example 2: A = [ [1, 2], [2, 1] ] print(cholesky_decomposition(A)) # Output: None (since the matrix is not positive-definite) ```","solution":"from typing import List, Union def cholesky_decomposition(A: List[List[float]]) -> Union[List[List[float]], None]: Perform Cholesky decomposition on a given Hermitian positive-definite matrix A. If A cannot be decomposed, return None. n = len(A) if n == 0: return [] # Initialize the lower triangular matrix L with zeros L = [[0.0] * n for _ in range(n)] for i in range(n): for j in range(i + 1): sum_k = sum(L[i][k] * L[j][k] for k in range(j)) if i == j: # Diagonal elements if A[i][i] - sum_k <= 0: return None # The matrix is not positive-definite L[i][j] = (A[i][i] - sum_k) ** 0.5 else: # Off-diagonal elements if L[j][j] == 0: return None # Division by zero scenario L[i][j] = (A[i][j] - sum_k) / L[j][j] return L"},{"question":"# Hailstone Path Optimizer **Context**: The Hailstone sequence, also known to be derived from the Collatz conjecture, presents an interesting sequence of numbers that always appears to reach the value 1 for any positive integer. However, certain starting numbers generate sequences that are extraordinarily long and include very large intermediate values. **Task**: Write a Python function `optimized_hailstone(n)` which computes the hailstone sequence for any integer `n > 0` provided and tracks the length of the sequence as well as the highest number reached along the sequence. **Specifications**: 1. The function `optimized_hailstone(n)` should: - **Input**: A single integer `n` where `n > 0` - **Output**: - A tuple `(sequence_length, max_value)`; where `sequence_length` is the count of steps taken to reach 1, and `max_value` is the highest number reached within that sequence. 2. Ensure that the function works efficiently even with higher values of `n`. **Constraints**: - You can assume the input will always be a positive integer. - Consider the behavior of the algorithm for very large inputs up to `10^9`. Here is the template for your function. You need to implement the `optimized_hailstone(n)` function: ```python def optimized_hailstone(n): Return the length of the hailstone sequence and the maximum value in the sequence n: The starting point of the hailstone sequence sequence_length = 0 max_value = n while n > 1: if n % 2 == 0: n = n // 2 else: n = 3 * n + 1 sequence_length += 1 if n > max_value: max_value = n return (sequence_length + 1, max_value) # Including the starting number ``` **Example**: ```python assert optimized_hailstone(7) == (17, 52) assert optimized_hailstone(1) == (1, 1) assert optimized_hailstone(10) == (7, 16) assert optimized_hailstone(27) == (112, 9232) ``` **Notes**: - Make sure to handle and test edge cases where `n` is very large. - Adding comments in your code for clarity is highly encouraged.","solution":"def optimized_hailstone(n): Return the length of the hailstone sequence and the maximum value in the sequence n: The starting point of the hailstone sequence sequence_length = 0 max_value = n while n > 1: if n % 2 == 0: n = n // 2 else: n = 3 * n + 1 sequence_length += 1 if n > max_value: max_value = n return (sequence_length + 1, max_value) # Including the starting number"},{"question":"# Comb Sort Implementation and Enhancement You are provided with an implementation of the Comb Sort algorithm. While Comb Sort improves upon Bubble Sort by comparing gaps larger than 1 initially, its performance still lags behind more advanced algorithms. Your task involves two parts: 1. **Refactor and Optimize**: Enhance the provided Comb Sort algorithm for better performance. 2. **Extension to Descending Order**: Extend the algorithm to allow sorting in both ascending and descending order based on a parameter. Function Signature ```python def optimized_comb_sort(arr: list, order: str=\'asc\') -> list: pass ``` Input - `arr`: A list of integers or floats. - `order`: A string which could be either \'asc\' for ascending or \'desc\' for descending. Output - A sorted list in the specified order. Constraints - The list can have a maximum length of 10000. - The values in the list are in the range of -10^9 to 10^9. - Invalid `order` values should default to \'asc\'. Performance Requirements - Aim to improve the average case time complexity. - Optimize for reducing the number of swaps where possible. Example ```python # Example 1: input_arr = [5, 3, 9, 1, 5, 6] print(optimized_comb_sort(input_arr, \'asc\')) # Output: [1, 3, 5, 5, 6, 9] # Example 2: input_arr = [42, 23, 17, 99, 8, 77] print(optimized_comb_sort(input_arr, \'desc\')) # Output: [99, 77, 42, 23, 17, 8] ``` Notes - Optimize the shrinking factor based on typical datasets. - Consider edge cases like empty arrays, arrays with one element, and arrays that are already sorted. - Document your enhancements and justifications for changes made to the initial implementation.","solution":"def optimized_comb_sort(arr: list, order: str=\'asc\') -> list: Enhanced Comb Sort with order parameter to sort in ascending (\'asc\') or descending (\'desc\') order. def get_next_gap(gap): # Shrink gap by the shrink factor which is found from empirical studies to be 1.3 for best performance gap = (gap * 10) // 13 return max(1, gap) if order not in [\'asc\', \'desc\']: # Default to ascending if the order argument is invalid order = \'asc\' n = len(arr) gap = n swapped = True while gap != 1 or swapped: gap = get_next_gap(gap) swapped = False for i in range(n - gap): if (order == \'asc\' and arr[i] > arr[i + gap]) or (order == \'desc\' and arr[i] < arr[i + gap]): arr[i], arr[i + gap] = arr[i + gap], arr[i] swapped = True return arr"},{"question":"Your task is to implement a function that counts the number of set bits (bits that are 1) in an integer. This function will make use of the fundamental bit operations provided above: `get_bit`, `set_bit`, `clear_bit`, and `update_bit`. # Scenario Consider you are working on a low-level data processing system where efficient manipulation of data at the bit level is crucial. One of the tasks is to count the number of 1-bits in the binary representation of a given integer, which is often used in algorithms related to data compression and cryptography. # Function Signature ```python def count_set_bits(num: int) -> int: Count the number of set bits (1-bits) in the integer. Parameters: num (int): A non-negative integer. Returns: int: The count of set bits in the binary representation of \'num\'. # Implement this function using the provided helper bit operations. pass ``` # Input * The function takes a single integer `num`, where `0 <= num <= 10^9`. # Output * The function returns an integer representing the number of set bits in `num`. # Constraints * You are required to use the helper functions `get_bit`, `set_bit`, `clear_bit`, and `update_bit` where appropriate to solve the problem. * Your solution should have a time complexity of O(log n), where n is the value of `num`. # Example Consider the following examples: ```python # Example 1 num = 5 # Binary: 101 # Output: 2 # Example 2 num = 15 # Binary: 1111 # Output: 4 # Example 3 num = 9 # Binary: 1001 # Output: 2 ``` Your task is to correctly implement the function `count_set_bits`.","solution":"def count_set_bits(num: int) -> int: Count the number of set bits (1-bits) in the integer. Parameters: num (int): A non-negative integer. Returns: int: The count of set bits in the binary representation of \'num\'. count = 0 while num: count += num & 1 num >>= 1 return count"},{"question":"# Coding Assessment: Enhanced Quick Sort Context: Quick Sort is an efficient, general-purpose, comparison-based sorting algorithm. This assessment checks your understanding and ability to implement optimizations to the Quick Sort algorithm to handle edge cases effectively and improve overall performance. Task: Implement an enhanced version of the Quick Sort algorithm. Include the following enhancements: 1. **Randomized Pivot Selection**: Randomly select a pivot element to avoid worst-case performance on sorted/reversed arrays. 2. **Optimized Recursion Base Cases**: Segment the implementation to handle small subarrays with an alternative sorting algorithm like Insertion Sort. Requirements: 1. Implement the function `enhanced_quick_sort(arr, threshold=10)`. The function should sort the input list `arr` in ascending order: * **Input**: - `arr`: List of integers to be sorted. - `threshold`: Optional integer parameter (default 10), subarray size below which Insertion Sort is applied. * **Output**: - Return the sorted list. 2. Use the Quick Sort algorithm with randomized pivot selection and Insertion Sort for arrays smaller than the threshold size. 3. **Constraints**: - Assume the list contains integers only. - The list can be empty or have up to 10^5 elements. ```python import random def insertion_sort(arr, left, right): for i in range(left + 1, right + 1): key = arr[i] j = i - 1 while j >= left and arr[j] > key: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key def enhanced_quick_sort(arr, threshold=10): if len(arr) <= 1: return arr def quick_sort_recur(arr, first, last): if last - first < threshold: insertion_sort(arr, first, last) else: if first < last: pos = partition(arr, first, last) quick_sort_recur(arr, first, pos - 1) quick_sort_recur(arr, pos + 1, last) def partition(arr, first, last): rand_index = random.randint(first, last) arr[last], arr[rand_index] = arr[rand_index], arr[last] pivot = arr[last] wall = first for pos in range(first, last): if arr[pos] < pivot: arr[wall], arr[pos] = arr[pos], arr[wall] wall += 1 arr[wall], arr[last] = arr[last], arr[wall] return wall quick_sort_recur(arr, 0, len(arr) - 1) return arr # Example Usage: # sorted_array = enhanced_quick_sort([9, 3, 7, 5, 6, 2, 1, 8, 4]) # print(sorted_array) ``` Performance Expectations: - Ensure the solution can handle sorting an array of up to 100,000 integers efficiently. - Using randomized pivot selection should mitigate the risk of worst-case O(n^2) performance.","solution":"import random def insertion_sort(arr, left, right): for i in range(left + 1, right + 1): key = arr[i] j = i - 1 while j >= left and arr[j] > key: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key def enhanced_quick_sort(arr, threshold=10): if len(arr) <= 1: return arr def quick_sort_recur(arr, first, last): if last - first < threshold: insertion_sort(arr, first, last) else: if first < last: pos = partition(arr, first, last) quick_sort_recur(arr, first, pos - 1) quick_sort_recur(arr, pos + 1, last) def partition(arr, first, last): rand_index = random.randint(first, last) arr[last], arr[rand_index] = arr[rand_index], arr[last] pivot = arr[last] wall = first for pos in range(first, last): if arr[pos] < pivot: arr[wall], arr[pos] = arr[pos], arr[wall] wall += 1 arr[wall], arr[last] = arr[last], arr[wall] return wall quick_sort_recur(arr, 0, len(arr) - 1) return arr"},{"question":"# Minimum Spanning Tree with Custom Constraints You are given an undirected, weighted, and connected graph with `V` vertices, numbered from `1` to `V`, and `E` edges. You need to implement a function to find the Minimum Spanning Tree (MST) using Kruskal\'s Algorithm. However, there is a twist. You need to ensure that the algorithm not only finds the MST with the least total weight but also avoids using any edge with weight greater than a given threshold `T`. If it\'s not possible to find such an MST, the function should return `-1`. Function Signature ```python def constrained_kruskal(vertex_count: int, edges: List[Tuple[int, int, int]], threshold: int) -> int: ``` Input - `vertex_count`: An integer `V` representing the number of vertices. - `edges`: A list of tuples `(u, v, w)` where each tuple represents an edge connecting vertex `u` to vertex `v` with weight `w`. - `threshold`: An integer `T` representing the maximum allowable edge weight for inclusion in the MST. Output - Returns the sum of weights of the MST if possible with the given constraints, otherwise returns `-1`. Constraints - `1 ≤ V ≤ 1000` - `1 ≤ E ≤ 10000` - `1 ≤ w ≤ 10000` for each edge weight. Example ```python # Example 1 vertex_count = 5 edges = [(1, 2, 3), (1, 3, 8), (2, 4, 5), (3, 4, 2), (3, 5, 4), (4, 5, 6)] threshold = 6 # Output: 14 (sum of edges in MST: (1-2: 3), (3-4: 2), (3-5: 4), (2-4: 5)) # Example 2 vertex_count = 4 edges = [(1, 2, 10), (2, 3, 15), (3, 4, 20), (4, 1, 25)] threshold = 12 # Output: -1 (Cannot form MST with the given threshold) def constrained_kruskal(vertex_count: int, edges: List[Tuple[int, int, int]], threshold: int) -> int: # Implementation shall go here. pass ``` Explanation In the first example, the MST formed within the threshold has a total weight 14. In the second example, an MST cannot be formed with the given threshold; hence, the function returns -1. Ensure that the function correctly handles input graphs, performs necessary sorting, and utilizes a disjoint set for cycle detection to form the MST within given constraints.","solution":"def constrained_kruskal(vertex_count, edges, threshold): parent = list(range(vertex_count + 1)) rank = [0] * (vertex_count + 1) def find(u): if parent[u] != u: parent[u] = find(parent[u]) return parent[u] def union(u, v): root_u = find(u) root_v = find(v) if rank[root_u] > rank[root_v]: parent[root_v] = root_u elif rank[root_u] < rank[root_v]: parent[root_u] = root_v else: parent[root_v] = root_u rank[root_u] += 1 # Filter edges based on the threshold edges = [(u, v, w) for u, v, w in edges if w <= threshold] # Sort edges based on weight edges.sort(key=lambda x: x[2]) mst_weight = 0 edge_count = 0 for u, v, w in edges: if find(u) != find(v): union(u, v) mst_weight += w edge_count += 1 if edge_count == vertex_count - 1: break if edge_count != vertex_count - 1: return -1 return mst_weight"},{"question":"# Integer Partitions Problem Given a positive integer `n`, write a function `int_divide(n)` that returns the number of ways to partition `n` into a sum of positive integers, where the order does not matter. For instance, `4` can be partitioned into five different ways as follows: - 4 - 3 + 1 - 2 + 2 - 2 + 1 + 1 - 1 + 1 + 1 + 1 Function Signature ```python def int_divide(n: int) -> int: pass ``` # Input * `n` (1 ≤ n ≤ 100) - A positive integer to be partitioned. # Output * An integer representing the number of ways to partition `n`. # Constraints * The integer `n` will always be positive (1 ≤ n ≤ 100). # Example ```python >>> int_divide(4) 5 >>> int_divide(7) 15 ``` # Requirements * Your solution should have a time complexity of O(n^2) and space complexity of O(n^2). * Handle edge cases such as the minimum value (1). **Note**: Do not use any built-in libraries or functions for calculating partitions.","solution":"def int_divide(n: int) -> int: Returns the number of ways to partition n into a sum of positive integers, where the order does not matter. # Create a table to store results of subproblems dp = [[0 for _ in range(n + 1)] for _ in range(n + 1)] # Base case: There is exactly one way to partition 0 (with an empty set) for i in range(n + 1): dp[i][0] = 1 # Fill the table for i in range(1, n + 1): for j in range(1, n + 1): if j >= i: dp[i][j] = dp[i - 1][j] + dp[i][j - i] else: dp[i][j] = dp[i - 1][j] return dp[n][n]"},{"question":"# Question: Implement Matrix Operations You are required to implement two key operations involving matrices: matrix exponentiation and determinant calculation. The provided implementations for matrix multiplication and identity matrix may be useful. Task 1: Matrix Exponentiation Write a function `matrix_power(mat: list, p: int) -> list` that calculates the power ( mat^p ) using the repeated squaring method. Ensure the handle cases where ( p ) is 0 (returning the identity matrix). Task 2: Determinant Calculation Write a function `determinant(mat: list) -> float` that computes the determinant of a square matrix using the recursive minor expansion (Laplace expansion) method. **Input:** ```python - matrix for matrix_power (list of lists of integers or floats) - integer p for matrix_power (integer) - matrix for determinant (list of lists of integers or floats) ``` **Output:** ```python - matrix_power returns a list of lists representing the resultant matrix. - determinant returns a float representing the determinant value. ``` **Constraints:** - Matrices are guaranteed to be non-empty and square (( n times n )). - The algorithms should handle matrices up to size ( 10 times 10 ). # Example: ```python mat = [ [1, 2], [3, 4] ] p = 2 print(matrix_power(mat, p)) # Output: [[7, 10], [15, 22]] mat = [ [1, 2], [3, 4] ] print(determinant(mat)) # Output: -2.0 ``` # Recommendations: - Use the provided `multiply` and `identity` functions within your implementation for `matrix_power`. - Mind edge cases, such as handling zero dimensions or non-square matrices. - Optimize recursion to avoid too deep call stacks or excessive computation time.","solution":"def multiply(mat1, mat2): Multiplies two matrices mat1 and mat2. n = len(mat1) result = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): for k in range(n): result[i][j] += mat1[i][k] * mat2[k][j] return result def identity(n): Returns an identity matrix of size n. return [[1 if i == j else 0 for j in range(n)] for i in range(n)] def matrix_power(mat, p): Returns the matrix mat raised to the power p using the repeated squaring method. n = len(mat) result = identity(n) base = mat while p > 0: if p % 2 == 1: result = multiply(result, base) base = multiply(base, base) p //= 2 return result def determinant(mat): Returns the determinant of the matrix mat using the recursive minor expansion method. n = len(mat) if n == 1: return mat[0][0] if n == 2: return mat[0][0] * mat[1][1] - mat[0][1] * mat[1][0] det = 0 for c in range(n): minor = [[mat[i][j] for j in range(n) if j != c] for i in range(1, n)] det += ((-1) ** c) * mat[0][c] * determinant(minor) return det"},{"question":"You have been provided with the implementation of the `remove_min` function which removes the smallest value from a stack. In this question, you will implement a similar function that aims to improve on certain restrictions and enhance performance. Task: Write a function `remove_all_min` that removes **all instances of the minimum value** from a stack. Function Signature: ```python def remove_all_min(stack): pass ``` Input: * A list `stack` representing a stack where: * Elements are in any order. * The stack can include any integer values (positive, negative, or zero). * The stack maintains the Last In, First Out (LIFO) order. Output: * Return the modified stack after removing **all instances of the smallest value**. Constraints: * Do not convert the stack into other data structures like lists or sets; use stack operations (pop and append) exclusively. * Aim to minimize the space complexity while maintaining correctness. Examples: ```python # Example 1 stack = [2, 8, 3, -6, 7, 3, -6] # After remove_all_min(stack): # bottom [2, 8, 3, 7, 3] top # Example 2 stack = [1, 2, 3, 4, 5] # After remove_all_min(stack): # bottom [2, 3, 4, 5] top # Example 3 stack = [-3, -1, -3, 0, 2, -3] # After remove_all_min(stack): # bottom [-1, 0, 2] top # Example 4 stack = [7] # After remove_all_min(stack): # bottom [] top # Example 5 stack = [] # After remove_all_min(stack): # bottom [] top ``` Performance Requirement: * Your solution must handle a stack of size (10^5) efficiently.","solution":"def remove_all_min(stack): Removes all instances of the minimum value from the stack. if not stack: return stack min_value = float(\'inf\') temp_stack = [] # Step 1: Find the minimum value in the stack while stack: value = stack.pop() if value < min_value: min_value = value temp_stack.append(value) # Step 2: Rebuild the stack excluding all instances of the minimum value while temp_stack: value = temp_stack.pop() if value != min_value: stack.append(value) return stack"},{"question":"# Sorting Algorithm Challenge: Stooge Sort Enhancement **Context**: You have been provided with the Stooge Sort algorithm which is a recursive sorting algorithm having a worst-case time complexity of O(n^2.709). Despite its inefficiency in sorting large arrays, it offers a fundamental learning opportunity for understanding recursive sorting techniques. **Problem Statement**: Design and implement a function to sort an array using the Stooge Sort algorithm. Additionally, optimize the function to include checks for already sorted subarrays and avoid unnecessary recursive calls. **Function Signature**: ```python def optimized_stoogesort(arr: List[int], l: int, h: int) -> List[int]: ``` **Expected Input and Output**: * **Input**: An unsorted list of integers `arr` to sort, along with its starting index `l` and ending index `h`. * **Output**: The sorted list `arr` after applying the optimized Stooge Sort algorithm. **Constraints**: * Assume the function is called with valid indices within the bounds of the array. * The input list `arr` can have up to 1000 elements. * If the subarray is already sorted, the function should skip further recursion. **Performance Requirements**: * The function should handle up to 1000 elements within a time complexity close to the best possible for Stooge Sort (while maintaining recursive sorting structure). ```python # Example arr = [5, 3, 8, 4, 2] optimized_stoogesort(arr, 0, len(arr)-1) print(arr) # Output should be [2, 3, 4, 5, 8] ``` # Hints: 1. Check if subarray is already sorted before making recursive calls. 2. Ensure elements between index `l` and `h` are within valid bounds.","solution":"from typing import List def is_sorted(arr: List[int], l: int, h: int) -> bool: for i in range(l, h): if arr[i] > arr[i + 1]: return False return True def optimized_stoogesort(arr: List[int], l: int, h: int) -> List[int]: # Base case: if the subarray has one or no elements, it\'s already sorted if l >= h: return arr # Swap if the first element is greater than the last element if arr[l] > arr[h]: arr[l], arr[h] = arr[h], arr[l] # If the subarray is already sorted, no need to proceed further if is_sorted(arr, l, h): return arr # If there are more than two elements in the subarray if h - l + 1 > 2: t = (h - l + 1) // 3 # Recursive calls (optimized stoogesort algorithm) optimized_stoogesort(arr, l, h - t) optimized_stoogesort(arr, l + t, h) optimized_stoogesort(arr, l, h - t) return arr"},{"question":"# Question: Optimized Binomial Coefficient Calculation Given the naive recursive implementation of the binomial coefficient (C(n, k)) provided, your task is to rewrite this algorithm using dynamic programming to optimize its performance. Implement a function `dp_binomial_coefficient(n, k)` that calculates the binomial coefficient more efficiently. **Function Signature**: ```python def dp_binomial_coefficient(n: int, k: int) -> int: ``` **Input**: * `n`: An integer (0 <= n <= 1000) * `k`: An integer (0 <= k <= n) **Output**: * Returns an integer representing the binomial coefficient (C(n, k)). # Constraints 1. The function should handle values up to (n = 1000). 2. Consider space and time complexity optimizations to handle large values efficiently. # Example ```python assert dp_binomial_coefficient(5, 0) == 1 assert dp_binomial_coefficient(8, 2) == 28 assert dp_binomial_coefficient(500, 300) == 5054949849935535817667719165973249533761635252733275327088189563256013971725761702359997954491403585396607971745777019273390505201262259748208640 ``` # Detailed Requirements 1. **Dynamic Programming Table**: Utilize a 2D table where `dp[i][j]` holds the value of (C(i, j)). Initialize the table with appropriate base values. 2. **Iterative Approach**: Fill the table using iterative loops to avoid deep recursion and potential stack overflow. 3. **Symmetry Property**: Leverage the symmetry property, (text{C}(n, k) = text{C}(n, n-k)), to reduce the space complexity if necessary.","solution":"def dp_binomial_coefficient(n: int, k: int) -> int: Calculate the binomial coefficient C(n, k) using dynamic programming. Args: n (int): The number of trials. k (int): The number of successes. Returns: int: The binomial coefficient C(n, k). if k > n - k: k = n - k dp = [0] * (k + 1) dp[0] = 1 for i in range(1, n + 1): for j in range(min(i, k), 0, -1): dp[j] += dp[j - 1] return dp[k]"},{"question":"Implement a Reverse Operation for a Doubly Linked List Context One of the common operations on a doubly linked list is reversing the list, that is, rearranging the nodes in such a way that the first node becomes the last one and vice versa. This operation is useful in various applications, including undo functionalities in navigable interfaces and efficient backtracking mechanisms. Task You are required to implement a function that reverses a doubly linked list. Function Signature ```python def reverse_doubly_linked_list(head: DoublyLinkedListNode) -> DoublyLinkedListNode: pass ``` Input Format - `head`: A reference to the head node of a doubly linked list. If the list is empty, the head will be `None`. Output Format - Returns the new head node of the reversed doubly linked list. Constraints - The list may contain zero or more nodes. - Nodes of the doubly linked list should retain links to the previous and next nodes correctly after reversal. Performance Requirements - The operation should run in O(n) time complexity. - The space complexity should remain O(1) (in-place reversal). Examples ```python # Initializing the linked list node1 = DoublyLinkedListNode(1) node2 = DoublyLinkedListNode(2) node3 = DoublyLinkedListNode(3) node4 = DoublyLinkedListNode(4) node1.next = node2 node2.prev = node1 node2.next = node3 node3.prev = node2 node3.next = node4 node4.prev = node3 # head initially points to node1 head = node1 # After reversing # head should point to node4 new_head = reverse_doubly_linked_list(head) # Verification by traversing through the list assert new_head == node4 assert new_head.next == node3 assert node3.prev == new_head assert node3.next == node2 assert node2.prev == node3 assert node2.next == node1 assert node1.prev == node2 assert node1.next == None ``` You should consider all edge cases including but not limited to: - An empty list. - A list with a single node. - Proper maintenance of `next` and `prev` pointers after the reversal.","solution":"class DoublyLinkedListNode: def __init__(self, data): self.data = data self.prev = None self.next = None def reverse_doubly_linked_list(head: DoublyLinkedListNode) -> DoublyLinkedListNode: if not head: return None current = head new_head = None while current: new_head = current # Swap the previous and next pointers current.prev, current.next = current.next, current.prev current = current.prev return new_head"},{"question":"# Question: Numbers Satisfied by Sum of Digits Raised to Powers You are tasked with identifying all numbers within a given range [low, high] where the sum of their digits, each raised sequentially to increasing powers starting from 1, equals the number itself. **Function Signature**: ```python def sum_dig_pow(low: int, high: int) -> List[int]: pass ``` # Input * `low` (int): The starting integer of the range. * `high` (int): The ending integer of the range. # Output * A list of integers meeting the specified property within the given range. # Constraints * `1 <= low <= high <= 10^6` # Example ```python # Example 1 low = 1 high = 10 # Digits 1 through 9 will match as 1^1 = 1, 2^1 = 2, ..., 9^1 = 9 assert sum_dig_pow(1, 10) == [1, 2, 3, 4, 5, 6, 7, 8, 9] # Example 2 low = 1 high = 100 # Digits 1 through 9 and 89 will match assert sum_dig_pow(1, 100) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 89] # Example 3 low = 100 high = 150 # Only 135 matches here: 1^1 + 3^2 + 5^3 = 135 assert sum_dig_pow(100, 150) == [135] ``` # Notes * Ensure your solution is efficient enough to handle larger ranges up to 1,000,000 within reasonable time constraints. * Consider edge cases where the calculated powers are extremely high.","solution":"from typing import List def sum_dig_pow(low: int, high: int) -> List[int]: Returns a list of numbers in the range [low, high] where the number is equal to the sum of its digits each raised to sequential powers starting from 1. def is_valid_number(n: int) -> bool: # Converting number to a string representation to iterate over digits digits = str(n) # Calculating the sum of digits raised to their respective positions return sum(int(d) ** (i + 1) for i, d in enumerate(digits)) == n result = [] for number in range(low, high + 1): if is_valid_number(number): result.append(number) return result"},{"question":"# Binary Tree Postorder Traversal Scenario You are working on a file compression tool using a binary tree structure to represent folder contents. To properly compute the size of the directory, you need to traverse all subdirectories and files before processing the current directory. This calls for a postorder traversal mechanism. Task Implement a function `postorderTraversal(root)` to perform postorder traversal of a given binary tree. Function Signature ```python def postorderTraversal(root: Optional[Node]) -> List[int]: pass ``` Input - `root`: The root node of the binary tree. `Node` is a class that has: - `val` (int): The value of the node. - `left` (Optional[Node]): Reference to the left child node or `None`. - `right` (Optional[Node]): Reference to the right child node or `None`. Output - Returns a list of integers representing the values of the nodes in postorder. Constraints - The number of nodes in the tree is in the range [0, 1000]. - The values of the nodes are integers in the range [0, 1000]. Example ```python # Example 1 root = Node(1, None, Node(2, Node(3))) # The tree: # 1 # # 2 # / # 3 result = postorderTraversal(root) # Output: [3, 2, 1] # Example 2 root = None result = postorderTraversal(root) # Output: [] ``` Note You may use either an iterative or a recursive approach, but ensure that your solution is optimized to handle the maximum constraints efficiently.","solution":"from typing import Optional, List class Node: def __init__(self, val: int, left: Optional[\'Node\'] = None, right: Optional[\'Node\'] = None): self.val = val self.left = left self.right = right def postorderTraversal(root: Optional[Node]) -> List[int]: Perform postorder traversal of a binary tree. Args: root (Optional[Node]): The root of the binary tree. Returns: List[int]: List of integers representing values of nodes in postorder. result = [] def traverse(node: Optional[Node]): if node: traverse(node.left) traverse(node.right) result.append(node.val) traverse(root) return result"},{"question":"# Power of Two Check Background: An important property of numbers in binary systems is their representation of powers of two. Numbers like 1, 2, 4, 8, etc., are powers of two. Your task is to design a function capable of determining whether a given integer is a power of two using bit manipulation. Problem Statement: Write a function `is_power_of_two(n)` that takes an integer `n` and returns `True` if it is a power of two, otherwise returns `False`. Input: - An integer `n` where `n` can be any integer (positive, zero, or negative). Output: - A boolean `True` or `False`. Constraints: - You must make use of bitwise operators to determine if the number is a power of two. - Aim for O(1) time and space complexity. Requirements: 1. Do not use loops or recursion. 2. The solution must be implemented using bitwise operations. Example: Input: `n = 4` Output: `True` Input: `n = 5` Output: `False` Input: `n = -8` Output: `False` Explanation: - For `n = 4`, the binary representation is `100`, which is indeed a power of two. - For `n = 5`, the binary representation is `101`, which is not a power of two. - For `n = -8`, the problem only considers positive integers as a power of two, thus returning `False`. Edge Cases to Consider: - Zero (0) should return `False`. - Negative numbers should return `False`.","solution":"def is_power_of_two(n): Determines if a number is a power of two using bit manipulation. :param n: int, the number to check :return: bool, True if n is a power of two, False otherwise if n <= 0: return False return (n & (n - 1)) == 0"},{"question":"**Problem Statement:** Design a function `format_license_key` to format a given alphanumeric key string by inserting dashes at every `k` interval. **Input**: - A string `key` consisting of alphanumeric characters and dashes (`-`). - An integer `k` representing the interval for grouping characters. **Output**: - A formatted string where the alphanumeric characters are grouped in blocks of `k` with dashes inserted between these blocks. The characters should appear in upper case, and the ordering of characters should be preserved. **Constraints**: 1. All non-dash characters in the `key` should be preserved in the same order. 2. The dash does not count as part of the group size `k`. 3. The first group could be shorter than `k` if the total length is not divisible by `k`. **Function Signature**: ```python def format_license_key(key: str, k: int) -> str: pass ``` **Example**: ```python # Example 1 key = \\"2-5g-3-J\\" k = 2 Output: \\"2-5G-3J\\" # Example 2 key = \\"2-4A0r7-4k\\" k = 3 Output: \\"24-A0R-74K\\" # Example 3 key = \\"--a-a-a-a--\\" k = 2 Output: \\"AA-AA\\" ``` **Notes**: - It is expected that the implementation handles both lower and upper case characters uniformly by converting all to upper case. - Empty inputs or inputs with only dashes should return an empty string. - Ensure that there are no leading or trailing dashes in the output.","solution":"def format_license_key(key: str, k: int) -> str: Formats a given alphanumeric key string by inserting dashes at every `k` interval. # Remove all dashes and convert to upper case clean_key = key.replace(\'-\', \'\').upper() # If the length after cleaning is 0, return an empty string if not clean_key: return \\"\\" # Determine the length of the first group first_group_length = len(clean_key) % k or k # Initialize result with the first group formatted_key = clean_key[:first_group_length] # Process the rest of the string and append groups of size `k` for i in range(first_group_length, len(clean_key), k): formatted_key += \'-\' + clean_key[i:i + k] return formatted_key"},{"question":"# Binary Tree Depth Calculation You are provided with a binary tree, and your task is to calculate its height. The height of a tree is defined as the number of levels in the tree, where the height of an empty tree is 0. For a non-empty tree, the height is 1 (the root node) plus the height of the deepest subtree. # Function Signature ```python def height(root: Node) -> int: ``` # Input * **root**: The root node of a binary tree where the Node class is defined as: ```python class Node: def __init__(self, key: int): self.left = None self.right = None self.val = key ``` # Output * Returns an integer that represents the height of the binary tree. # Constraints * The number of nodes in the tree will be between 0 and 10^4. * Node values are distinct integers. # Example ```python # Given the binary tree # 9 # / # 6 12 # / / # 3 8 10 15 # / # 7 18 # height = 4 root = Node(9) root.left = Node(6) root.right = Node(12) root.left.left = Node(3) root.left.right = Node(8) root.left.right.left = Node(7) root.right.left = Node(10) root.right.right = Node(15) root.right.right.right = Node(18) assert height(root) == 4 ``` # Note * You should handle edge cases such as an empty tree or a tree with only one node. * Make sure the implementation is efficient to handle large trees within the constraints.","solution":"class Node: def __init__(self, key: int): self.left = None self.right = None self.val = key def height(root: Node) -> int: Calculates the height of a binary tree. Parameters: root (Node): Root node of the binary tree. Returns: int: Height of the binary tree. if root is None: return 0 left_height = height(root.left) right_height = height(root.right) return max(left_height, right_height) + 1"},{"question":"# Zigzag Level Order Traversal of a Binary Tree **Scenario**: You are a software engineer tasked with processing hierarchical data stored in a binary tree. To ensure readability and structure in your results, you decide to implement a zigzag (or spiral) traversal for the binary tree, alternating between left-to-right and right-to-left with each level. **Task**: Write a function `zigzag_level(root)`, that returns the zigzag level order traversal of its nodes\' values. The function should traverse the given binary tree level-by-level and switch the traversal order (left-to-right, right-to-left) for each level. Function Signature ```python def zigzag_level(root: Optional[TreeNode]) -> List[List[int]]: ``` Input: * `root`: The root node of the binary tree, where each `TreeNode` has attributes `val`, `left`, and `right`. Output: * A list of lists where each sublist contains the integer values of nodes at each level, following the zigzag order. Example: Given the binary tree represented as: ``` 3 / 9 20 / 15 7 ``` The function should return: ``` [ [3], [20,9], [15,7] ] ``` Constraints: * The number of nodes in the tree will be in the range [0, 2000]. * The value of each node will be in the range [-1000, 1000]. Your implementation should efficiently handle all edge cases and performance expectations described in this analysis.","solution":"from typing import List, Optional class TreeNode: def __init__(self, val: int = 0, left: \'TreeNode\' = None, right: \'TreeNode\' = None): self.val = val self.left = left self.right = right def zigzag_level(root: Optional[TreeNode]) -> List[List[int]]: if not root: return [] result = [] current_level = [root] left_to_right = True while current_level: level_values = [] next_level = [] for node in current_level: level_values.append(node.val) if node.left: next_level.append(node.left) if node.right: next_level.append(node.right) if not left_to_right: level_values.reverse() result.append(level_values) current_level = next_level left_to_right = not left_to_right return result"},{"question":"# Question: Word Pattern Matching **Objective**: Write a function that checks if a given pattern matches a string such that there\'s a bijection between a letter in the pattern and a non-empty word in the string. **Function Signature**: ```python def word_pattern(pattern: str, str: str) -> bool: pass ``` **Input**: * `pattern` (String): The pattern string containing only lowercase letters. * `str` (String): The string of words separated by single spaces, containing only lowercase letters. **Output**: * Return `True` if the string follows the pattern, else return `False`. **Constraints**: * Both the pattern and the string will contain at least one character. * No character or word in the input can be empty. * The pattern and words are provided as lowercase English letters. **Example**: ```python assert word_pattern(\\"abba\\", \\"dog cat cat dog\\") == True assert word_pattern(\\"abba\\", \\"dog cat cat fish\\") == False assert word_pattern(\\"aaaa\\", \\"dog cat cat dog\\") == False assert word_pattern(\\"abba\\", \\"dog dog dog dog\\") == False ``` **Scenario/Context**: Imagine you are tasked with developing a text pattern recognition system within a chatbot application. This system needs to determine if certain response structures match predefined patterns to enable appropriate responses. This function can be a core component in verifying that the sequence of words used in user responses matches expected patterns. Your task is to implement the `word_pattern` function that adheres to these requirements and correctly determines if the input string matches the given pattern string.","solution":"def word_pattern(pattern: str, str: str) -> bool: words = str.split() if len(pattern) != len(words): return False char_to_word = {} word_to_char = {} for c, word in zip(pattern, words): if c in char_to_word: if char_to_word[c] != word: return False else: if word in word_to_char: return False char_to_word[c] = word word_to_char[word] = c return True"},{"question":"# String-Based Large Number Multiplication Given two non-negative integers `num1` and `num2` represented as strings, write a function `multiply(num1: str, num2: str) -> str` that returns the product of `num1` and `num2` as a string. You must not use any built-in BigInteger library or convert the inputs to integer directly. Input: * `num1`: A string representing a non-negative integer. The length of `num1` is less than 110. * `num2`: A string representing a non-negative integer. The length of `num2` is less than 110. * Both strings do not contain any leading zeros except for the number \\"0\\" itself. Output: * A string representing the product of `num1` and `num2`. Constraints: * The inputs are guaranteed to be valid (only digits and no leading zeros). Examples: ``` multiply(\\"2\\", \\"3\\") -> \\"6\\" multiply(\\"123\\", \\"456\\") -> \\"56088\\" multiply(\\"0\\", \\"789\\") -> \\"0\\" multiply(\\"100\\", \\"10000\\") -> \\"1000000\\" ``` Requirements: - Your solution must handle potential performance issues efficiently. - Consider edge cases and necessary optimizations to meet the expected performance.","solution":"def multiply(num1: str, num2: str) -> str: if num1 == \\"0\\" or num2 == \\"0\\": return \\"0\\" len1, len2 = len(num1), len(num2) result = [0] * (len1 + len2) num1, num2 = num1[::-1], num2[::-1] for i in range(len1): for j in range(len2): result[i + j] += int(num1[i]) * int(num2[j]) result[i + j + 1] += result[i + j] // 10 result[i + j] = result[i + j] % 10 while len(result) > 1 and result[-1] == 0: result.pop() result = result[::-1] return \'\'.join(map(str, result))"},{"question":"Pigeonhole Sort Implementation Context: Pigeonhole sort is an efficient algorithm for sorting lists of integers where the number of elements (n) is close to the range of key values (Range). The algorithm works by first identifying the minimum and maximum values in the list, then creating \'holes\' for each key value in that range. Finally, it counts the occurrence of each key and reconstructs the sorted list. Objective: Write a function that implements the pigeonhole sort algorithm for a given list of non-negative integers. Function Signature: ```python def pigeonhole_sort(arr: List[int]) -> List[int]: ``` Input: * **arr** (List[int]): A list of non-negative integers to be sorted. Output: * **List[int]**: A sorted list of integers. Constraints: * The list can contain up to 10^5 elements. * The values in the list range from 0 to 10^5. Requirements: * The solution should efficiently sort the list while considering the memory constraints. * Ensure your implementation handles edge cases such as an empty list, a list with identical elements, etc. * The algorithm should maintain a time complexity of O(n + Range). Example: ```python # Example 1 input_list = [8, 3, 2, 7, 4] output_list = pigeonhole_sort(input_list) print(output_list) # Output: [2, 3, 4, 7, 8] # Example 2 input_list = [9, 2, 0, 1, 5] output_list = pigeonhole_sort(input_list) print(output_list) # Output: [0, 1, 2, 5, 9] # Example 3 input_list = [5, 5, 5, 5] output_list = pigeonhole_sort(input_list) print(output_list) # Output: [5, 5, 5, 5] # Example 4 input_list = [] output_list = pigeonhole_sort(input_list) print(output_list) # Output: [] ``` Ensure your implementation is optimized and correctly handles all edge cases. Perform a rigorous self-check before submitting your solution.","solution":"from typing import List def pigeonhole_sort(arr: List[int]) -> List[int]: if not arr: return [] min_val = min(arr) max_val = max(arr) size = max_val - min_val + 1 holes = [0] * size for number in arr: holes[number - min_val] += 1 sorted_array = [] for index, count in enumerate(holes): sorted_array.extend([index + min_val] * count) return sorted_array"},{"question":"# Problem Context A nature reserve is being operated in a grid layout where initially, the entire area is covered by water. Rangers will be adding new patches of land to the grid and need a tool to help them find how many distinct islands exist after each addition. An island is defined as a group of connected land cells (horizontally or vertically). You have been asked to design a solution to automate this process. # Objective Given a sequence of land addition operations, count the number of islands after each operation. # Function Signature ```python def num_islands_after_operations(n: int, m: int, positions: List[Tuple[int, int]]) -> List[int]: pass ``` # Input 1. `n` (int): The number of rows in the grid. 2. `m` (int): The number of columns in the grid. 3. `positions` (List[Tuple[int, int]]): A list of tuples, each representing the coordinates where a patch of land is added. # Output A list of integers, where each integer is the number of islands after each respective add-land operation in the positions list. # Constraints - Each position is a valid coordinate within the grid, i.e., 0 ≤ position[0] < n and 0 ≤ position[1] < m. - Positions may include duplicates. # Examples ```python assert num_islands_after_operations(3, 3, [(0, 0), (0, 1), (1, 2), (2, 1)]) == [1, 1, 2, 3] assert num_islands_after_operations(3, 3, [(0, 0), (0, 1), (1, 1), (1, 0)]) == [1, 1, 1, 1] ``` # Description Initially, the `n x m` grid is filled with water. With each given position, a land cell is added and you need to determine and return the number of distinct islands at each step. Use the Union-Find data structure to manage the merging of lands and keep the operations efficient. Make sure to handle potential cases where a patch of land might be added multiple times. # Requirements - Implement the Union-Find data structure (do not use existing libraries directly). - Optimize using path compression and union by size/rank. - Handle edge cases like adding the same land multiple times gracefully.","solution":"from typing import List, Tuple class UnionFind: def __init__(self, n): self.parent = list(range(n)) self.rank = [1] * n self.count = 0 # Number of connected components def find(self, p): if p != self.parent[p]: self.parent[p] = self.find(self.parent[p]) return self.parent[p] def union(self, p, q): rootP = self.find(p) rootQ = self.find(q) if rootP != rootQ: # Always attach smaller tree under larger tree if self.rank[rootP] > self.rank[rootQ]: self.parent[rootQ] = rootP elif self.rank[rootP] < self.rank[rootQ]: self.parent[rootP] = rootQ else: self.parent[rootQ] = rootP self.rank[rootP] += 1 self.count -= 1 def add(self, x): if self.parent[x] == x: self.count += 1 def num_islands_after_operations(n: int, m: int, positions: List[Tuple[int, int]]) -> List[int]: def index(x, y): return x * m + y uf = UnionFind(n * m) grid = [[0] * m for _ in range(n)] result = [] for r, c in positions: if grid[r][c] == 1: result.append(uf.count) continue grid[r][c] = 1 current_index = index(r, c) uf.add(current_index) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < n and 0 <= nc < m and grid[nr][nc] == 1: uf.union(current_index, index(nr, nc)) result.append(uf.count) return result"},{"question":"# Stooge Sort Implementation You are given an array of integers that needs to be sorted using the Stooge Sort algorithm. Implement the stooge sort following the guidelines outlined below. Task Write a function `stooge_sort(arr)` that sorts an array `arr` using the Stooge Sort algorithm. Function Signature ```python def stooge_sort(arr: List[int]) -> List[int]: ``` Input - A list of integers `arr` (1 ≤ len(arr) ≤ 1000, 0 ≤ arr[i] ≤ 10000). Output - The sorted list of integers. Constraints - You must implement the recursive Stooge Sort algorithm as described in the analysis. - You are allowed to create helper functions if necessary. - Do not use built-in sorting functions. Example ```python array = [1, 3, 64, 5, 7, 8] print(stooge_sort(array)) # Output: [1, 3, 5, 7, 8, 64] ``` Notes - Handle edge cases such as empty array or single-element array. - Ensure your function handles large arrays of up to 1000 elements efficiently, even though Stooge Sort is not the most efficient algorithm.","solution":"from typing import List def stooge_sort(arr: List[int]) -> List[int]: def stooge_recursive(arr, l, h): if l >= h: return # If the first element is larger than the last, swap them if arr[l] > arr[h]: arr[l], arr[h] = arr[h], arr[l] # If there are more than 2 elements in the array if h - l + 1 > 2: t = (h - l + 1) // 3 # Recursively sort the initial 2/3 segment stooge_recursive(arr, l, h - t) # Recursively sort the final 2/3 segment stooge_recursive(arr, l + t, h) # Recursively sort the initial 2/3 segment again stooge_recursive(arr, l, h - t) stooge_recursive(arr, 0, len(arr) - 1) return arr"},{"question":"# Question: Digit Counter in Base-B You are given a function that counts the number of digits in a decimal (base-10) integer using logarithms. Your task is to extend this functionality to count the digits in a given integer in any specified base. Detailed Requirements: **Function Signature**: ```python def num_digits_base(n: int, base: int) -> int: pass ``` Input: 1. **n** (Integer): The integer whose digits will be counted. It can be positive, negative, or zero. 2. **base** (Integer): The base in which to count number of digits. Guaranteed to be an integer greater than or equal to 2. Output: - **Integer**: The number of digits of the integer `n` in the given `base`. Constraints: 1. The input number `n` can be any integer within the range acceptable by Python\'s integer type. 2. The base `b` will be an integer greater than or equal to 2. Example: ```python assert num_digits_base(0, 10) == 1 # Zero has exactly one digit assert num_digits_base(255, 16) == 2 # 255 in hexadecimal (base-16) is \\"FF\\", hence 2 digits assert num_digits_base(-255, 16) == 2 # Sign doesn\'t affect the count assert num_digits_base(1000, 2) == 10 # 1000 in binary (base-2) is \\"1111101000\\", hence 10 digits ``` Performance Requirements: - The function should run in constant time O(1), independently of the size of integers `n` and `base`. Special Notes: - Make sure to handle edge cases such as zero correctly. - Negative numbers should be converted to their absolute values before computing the number of digits.","solution":"import math def num_digits_base(n: int, base: int) -> int: Returns the number of digits of the integer n in the specified base. if n == 0: return 1 # Taking the absolute value of n to handle negative numbers n = abs(n) # Computing the number of digits using logarithms return math.floor(math.log(n, base)) + 1"},{"question":"Scenario You are developing a scheduling application that requires maintaining tasks in an order such that the highest priority task is always on top. To achieve this, you decide to use an OrderedStack, a specialized stack that ensures the highest priority (highest value) is always on the top. However, the current implementation of OrderedStack has been noted for its inefficiency in the `push` operation. You are tasked with optimizing the push operation to minimize the number of element moves while ensuring the stack maintains its order. Additionally, you need to implement a method that merges another OrderedStack into the current one such that the order is maintained. Task 1. **Optimize the `push` operation**: Optimize the `push` method to minimize the number of element moves while maintaining the sorting order. 2. **Merge Stacks**: Implement a method `merge(self, other_stack)` that merges another `OrderedStack` into the current stack while maintaining the order. The other stack should be emptied after merging. # Function Specifications 1. **Function Signature**: ```python def push(self, item): # Your logic here ``` * **Input**: `item` (an integer to be added to the stack) * **Output**: None (Modifies the stack in place) 2. **Function Signature**: ```python def merge(self, other_stack): # Your logic here ``` * **Input**: `other_stack` (instance of `OrderedStack` to be merged) * **Output**: None (Merges and empties the other stack) # Class Code Template ```python class OrderedStack: def __init__(self): self.items = [] def is_empty(self): return self.items == [] # Implement or optimize the push operation here def push(self, item): pass def pop(self): if self.is_empty(): raise IndexError(\\"Stack is empty\\") return self.items.pop() def peek(self): return self.items[len(self.items) - 1] def size(self): return len(self.items) # Implement the merge function here def merge(self, other_stack): pass ``` # Constraints - Assume all input elements for `push` and in `other_stack` are integers. - The `OrderedStack` can contain duplicate values. # Example ```python s1 = OrderedStack() s1.push(5) s1.push(1) s2 = OrderedStack() s2.push(4) s2.push(6) s1.merge(s2) # After merging, s1 should be [1, 4, 5, 6] (base is leftmost, top is rightmost) # And s2 should be empty s1.pop() # returns 6 s1.pop() # returns 5 ``` # Notes - Your implementation should ensure the stack remains ordered. - Optimize where possible to minimize both time and space complexity in comparison to the initial implementation.","solution":"class OrderedStack: def __init__(self): self.items = [] def is_empty(self): return self.items == [] def push(self, item): Insert item into the stack such that the stack remains ordered with the highest priority (highest value) on the top. # Find the correct position to insert the item to keep the stack ordered position = len(self.items) for i in range(len(self.items)): if self.items[i] > item: position = i break # Insert and shift the elements only once self.items.insert(position, item) def pop(self): if self.is_empty(): raise IndexError(\\"Stack is empty\\") return self.items.pop() def peek(self): return self.items[len(self.items) - 1] def size(self): return len(self.items) def merge(self, other_stack): Merge another OrderedStack into the current one while maintaining order. The other stack should be emptied after merging. # Create a combined list and sort only once for better efficiency self.items.extend(other_stack.items) self.items.sort() # Empty the other stack other_stack.items.clear()"},{"question":"The task is to implement a dynamic list using a doubly-linked list, which supports efficient insertion, deletion, and access operations. Design a `DoublyLinkedList` class that includes the following functionalities: 1. **insert_at_position(pos, value)**: Inserts a new node with the specified value at the given position. If the position is invalid (greater than the length of the list + 1), do nothing. 2. **delete_value(value)**: Deletes the first occurrence of the node containing the specified value. Return `True` on successful deletion and `False` if the value was not found. 3. **find_value(value)**: Returns the position (1-indexed) of the first occurrence of the node containing the given value. If the value is not found, return `-1`. 4. **traverse()**: Returns a list of all elements in the doubly linked list. # Input and Output Formats: * **Functions**: - insert_at_position(pos: int, value: any) -> None - delete_value(value: any) -> bool - find_value(value: any) -> int - traverse() -> List[any] # Constraints: - Assume `pos` is a 1-indexed position. - Values could be any comparable types. - You should handle an empty list scenario in all operations. # Example: ```python dll = DoublyLinkedList() dll.insert_at_position(1, 10) dll.insert_at_position(2, 20) dll.insert_at_position(3, 30) dll.insert_at_position(2, 15) print(dll.traverse()) # Output: [10, 15, 20, 30] print(dll.find_value(20)) # Output: 3 print(dll.delete_value(15)) # Output: True print(dll.traverse()) # Output: [10, 20, 30] print(dll.delete_value(100)) # Output: False ```","solution":"class Node: def __init__(self, value=None): self.value = value self.prev = None self.next = None class DoublyLinkedList: def __init__(self): self.head = None def insert_at_position(self, pos, value): if pos < 1: return new_node = Node(value) if pos == 1: new_node.next = self.head if self.head: self.head.prev = new_node self.head = new_node return current = self.head current_position = 1 while current and current_position < pos - 1: current = current.next current_position += 1 if not current: return new_node.next = current.next new_node.prev = current if current.next: current.next.prev = new_node current.next = new_node def delete_value(self, value): current = self.head while current and current.value != value: current = current.next if not current: return False if current.prev: current.prev.next = current.next else: self.head = current.next if current.next: current.next.prev = current.prev return True def find_value(self, value): current = self.head position = 1 while current: if current.value == value: return position current = current.next position += 1 return -1 def traverse(self): elements = [] current = self.head while current: elements.append(current.value) current = current.next return elements"},{"question":"# Scenario: In a technology conference, several technical talks and workshops were presented. The event organizers want to sort the alphabetic list of talk titles to organize the conference proceedings. To help them, you need to implement a sorting function using a particular algorithm. # Task: Implement the `shell_sort` function that sorts a list of strings using the Shell Sort algorithm. Your algorithm should be capable of handling a mix of lower and upper case strings and special characters. # Function Signature: ```python def shell_sort(arr: List[str]) -> List[str]: ``` # Input: - `arr`: A list of strings (1 <= len(arr) <= 1000, 0 <= len(strings) <= 100). # Output: - A list of strings sorted in lexicographical order. # Constraints: - Use case-sensitive comparison for sorting. - The function should sort the list in place. # Example: ```python input: [\\"Zebra\\", \\"apple\\", \\"mango\\", \\"Banana\\", \\"cherry\\"] output: [\\"Banana\\", \\"Zebra\\", \\"apple\\", \\"cherry\\", \\"mango\\"] ``` # Notes: - Ensure you handle edge cases such as an empty list or a list that might already be sorted. - Consider efficiency, particularly how the gap sequence influences the sorting performance and optimize where possible.","solution":"from typing import List def shell_sort(arr: List[str]) -> List[str]: Sorts a list of strings using the Shell Sort algorithm. :param arr: List of strings to be sorted :return: Sorted list of strings n = len(arr) gap = n // 2 while gap > 0: for i in range(gap, n): temp = arr[i] j = i while j >= gap and arr[j - gap] > temp: arr[j] = arr[j - gap] j -= gap arr[j] = temp gap //= 2 return arr"},{"question":"**Title**: Advanced Pattern Matching using Dynamic Programming You are tasked to implement a function to determine if a given text string matches a pattern string. The pattern string can include the special characters `.` that matches any single character, and `*` that matches zero or more of the preceding element. Function Signature ```python def is_match(s: str, p: str) -> bool: ``` Input - `s`: A string representing the text to match. Constraints: 0 <= `len(s)` <= 20. - `p`: A string representing the pattern, which can include \'.\' and \'*\'. Constraints: 0 <= `len(p)` <= 30. Output - Returns `True` if the text string `s` matches the pattern `p` entirely. Otherwise, returns `False`. Examples ```python assert is_match(\\"aa\\", \\"a\\") == False assert is_match(\\"aa\\", \\"aa\\") == True assert is_match(\\"aaa\\", \\"aa\\") == False assert is_match(\\"aa\\", \\"a*\\") == True assert is_match(\\"aa\\", \\".*\\") == True assert is_match(\\"ab\\", \\".*\\") == True assert is_match(\\"aab\\", \\"c*a*b\\") == True ``` # Constraints and Performance Requirements - Your implementation should efficiently match strings up to the maximum specified limits. - Consider edge cases like empty strings and patterns ending with `*`. Hint - Implement a dynamic programming solution with a 2D table where the cell `matches[i][j]` indicates if the substring `s[:i]` matches `p[:j]`.","solution":"def is_match(s: str, p: str) -> bool: # Create a DP table where dp[i][j] holds whether s[:i] matches p[:j] dp = [[False] * (len(p) + 1) for _ in range(len(s) + 1)] # Base case: both s and p are empty strings dp[0][0] = True # Handle patterns with \'*\' that can match zero elements for j in range(2, len(p) + 1): dp[0][j] = dp[0][j - 2] if p[j - 1] == \'*\' else False # Fill the DP table for i in range(1, len(s) + 1): for j in range(1, len(p) + 1): if p[j - 1] == \'.\' or p[j - 1] == s[i - 1]: dp[i][j] = dp[i - 1][j - 1] elif p[j - 1] == \'*\': # Match zero of the preceding character dp[i][j] = dp[i][j - 2] if p[j - 2] == \'.\' or p[j - 2] == s[i - 1]: dp[i][j] |= dp[i - 1][j] # Return the value at the bottom-right corner of the DP table return dp[len(s)][len(p)]"},{"question":"# Scenario: You are tasked with implementing a priority queue using a min heap to manage and process tasks by their priority. Tasks with the smallest priority number should be dealt with first. # Question: Implement the following methods for a min-heap-based priority queue: 1. `insert(val)`: Inserts an integer into the heap. 2. `remove_min()`: Removes the minimum element from the heap and returns it. # Method Signatures: ```python class BinaryHeap: def __init__(self): self.current_size = 0 self.heap = [(0)] def insert(self, val: int): Inserts an integer into the heap. def remove_min(self) -> int: Removes and returns the smallest element from the heap. ``` # Example: ```python h = BinaryHeap() h.insert(5) h.insert(3) h.insert(8) h.insert(1) print(h.remove_min()) # Output: 1 print(h.remove_min()) # Output: 3 print(h.remove_min()) # Output: 5 print(h.remove_min()) # Output: 8 ``` # Constraints: * All inserted integers are non-negative. * The heap will not contain more than 10^5 elements. * Each `insert()` and `remove_min()` operation is expected to be on average O(log N).","solution":"class BinaryHeap: def __init__(self): self.current_size = 0 self.heap = [0] # A dummy element at index 0 for easier index calculations def insert(self, val: int): Inserts an integer into the heap. self.heap.append(val) self.current_size += 1 self._perc_up(self.current_size) def remove_min(self) -> int: Removes and returns the smallest element from the heap. if self.current_size == 0: raise IndexError(\\"remove_min from an empty heap\\") min_val = self.heap[1] # The root of the heap is the smallest element self.heap[1] = self.heap[self.current_size] # Move the last element to the root self.heap.pop() # Remove the last element self.current_size -= 1 self._perc_down(1) return min_val def _perc_up(self, idx): Percolate a node up until the heap property is restored. while idx // 2 > 0: # While the current node is not the root if self.heap[idx] < self.heap[idx // 2]: self.heap[idx], self.heap[idx // 2] = self.heap[idx // 2], self.heap[idx] idx = idx // 2 def _perc_down(self, idx): Percolate a node down until the heap property is restored. while (idx * 2) <= self.current_size: min_child_idx = self._min_child(idx) if self.heap[idx] > self.heap[min_child_idx]: self.heap[idx], self.heap[min_child_idx] = self.heap[min_child_idx], self.heap[idx] idx = min_child_idx def _min_child(self, idx): Return the index of the smaller child. if (idx * 2 + 1) > self.current_size: # If there is no right child return idx * 2 # Return the left child else: if self.heap[idx * 2] < self.heap[idx * 2 + 1]: return idx * 2 else: return idx * 2 + 1"},{"question":"You are given a positive integer and you are allowed to flip exactly one bit from 0 to 1. Your task is to write a function `flip_bit_longest_seq(num)` that returns the length of the longest sequence of consecutive 1s that can be created by flipping exactly one bit. # Scenario: Imagine you are working on a system where you need to maximize the uptime represented in binary form. You want to find out the longest possible consecutive uptime period by simulating a scenario where one outage can be fixed. This means you can flip one bit in the binary representation of uptime to extend the sequence of 1s. # Input: - A single integer `num` (0 ≤ num ≤ 2^31 - 1). # Output: - A single integer representing the length of the longest sequence of 1s possible by flipping exactly one bit. # Constraints: - The input integer will be within the range 0 to 2^31 - 1. # Examples: - Example 1: - Input: 1775 (binary: 11011101111) - Output: 8 (by flipping the second 0 from the right) - Example 2: - Input: 0 (binary: 0) - Output: 1 (by flipping the single 0 to 1) # Requirements: - The algorithm should run in O(b) time complexity where b is the number of bits in the binary representation of the input. - The space complexity should be O(1). # Edge Cases: - Consider the scenarios where the input number is 0 or where all bits are 1s. # Function Signature: ```python def flip_bit_longest_seq(num: int) -> int: # Your implementation here ``` You are expected to implement the function `flip_bit_longest_seq` to solve the problem adhering to the requirements and constraints mentioned.","solution":"def flip_bit_longest_seq(num): if num == 0: return 1 current_length = 0 previous_length = 0 max_length = 1 while num != 0: if (num & 1) == 1: current_length += 1 else: previous_length = current_length if (num & 2) == 2 else 0 current_length = 0 max_length = max(max_length, previous_length + current_length + 1) num >>= 1 return max_length"},{"question":"Implement an AVL Tree Background The Binary Search Tree (BST) is a crucial data structure in computer science that allows for rapid searching, insertion, and deletion of elements. However, a fundamental issue with regular BSTs is that their performance degrades significantly with unbalanced trees. To address this, AVL trees — a self-balancing variant of BSTs — ensure that the tree remains balanced after every insertion and deletion, thus maintaining O(log N) complexity for these operations. Task Implement an AVL Tree with the following operations: 1. **Insertion**: Add a new element to the AVL tree while maintaining its balanced property. 2. **Search**: Find whether a given element exists in the AVL tree. 3. **Size**: Return the number of elements in the AVL tree. 4. **Traversal (Inorder)**: Return a list of elements representing the in-order traversal of the tree. Guidelines 1. **Insert**: - Insert a node following BST properties. - Balance the tree by performing rotations (single or double) if necessary. 2. **Search**: - Similar to BST search, but taking advantage of AVL’s balance properties for efficiency. 3. **Size**: - Use a properties’ counter or recursive method to count and return the total number of elements. 4. **Inorder Traversal**: - Return elements in a sorted order using in-order traversal method. Input and Output * **Input**: * `insert(data: int) -> None`: Insert an integer data into the AVL tree. * `search(data: int) -> bool`: Search for the integer data in the AVL tree, return `True` if found, otherwise `False`. * `size() -> int`: Return the number of elements in the tree. * `inorder() -> List[int]`: Return a list of integers representing in-order traversal of the tree. * **Output**: None for insertions; boolean outputs for search operations; integer output for size, and list of integers for in-order traversal. Example ```python avl_tree = AVLTree() avl_tree.insert(10) avl_tree.insert(20) avl_tree.insert(30) print(avl_tree.size()) # Output: 3 print(avl_tree.search(20)) # Output: True print(avl_tree.search(40)) # Output: False print(avl_tree.inorder()) # Output: [10, 20, 30] ``` Constraints 1. You must balance the tree after every insertion. 2. Duplicate entries should not be added to the tree. 3. You can assume the operations will be performed on integers only.","solution":"class TreeNode: def __init__(self, key): self.left = None self.right = None self.height = 1 self.key = key class AVLTree: def __init__(self): self.root = None self._size = 0 def insert(self, key): if not self.search(key): # Check for duplicates self.root = self._insert(self.root, key) self._size += 1 def _insert(self, root, key): if not root: return TreeNode(key) elif key < root.key: root.left = self._insert(root.left, key) else: root.right = self._insert(root.right, key) root.height = 1 + max(self._get_height(root.left), self._get_height(root.right)) balance = self._get_balance(root) if balance > 1 and key < root.left.key: return self._rotate_right(root) if balance < -1 and key > root.right.key: return self._rotate_left(root) if balance > 1 and key > root.left.key: root.left = self._rotate_left(root.left) return self._rotate_right(root) if balance < -1 and key < root.right.key: root.right = self._rotate_right(root.right) return self._rotate_left(root) return root def search(self, key): return self._search(self.root, key) def _search(self, root, key): if not root: return False if key == root.key: return True elif key < root.key: return self._search(root.left, key) else: return self._search(root.right, key) def size(self): return self._size def inorder(self): result = [] self._inorder(self.root, result) return result def _inorder(self, root, result): if root: self._inorder(root.left, result) result.append(root.key) self._inorder(root.right, result) def _get_height(self, root): if not root: return 0 return root.height def _get_balance(self, root): if not root: return 0 return self._get_height(root.left) - self._get_height(root.right) def _rotate_left(self, z): y = z.right T = y.left y.left = z z.right = T z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def _rotate_right(self, z): y = z.left T = y.right y.right = z z.left = T z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y"},{"question":"Knapsack Maximum Value Problem You are given a knapsack that has a fixed capacity and a list of items where each item has a value and a weight. The goal is to determine the maximum total value of items that can be included in the knapsack without exceeding its weight capacity. # Function Signature ```python def get_maximum_value(items: List[Tuple[int, int]], capacity: int) -> int: ``` # Input * List of items represented as tuples `(value, weight)` where: - `value` is an integer `1 <= value <= 1000`. - `weight` is an integer `1 <= weight <= capacity`. * An integer `capacity` representing the maximum weight the knapsack can hold `1 <= capacity <= 1000`. # Output * An integer representing the maximum value that can be obtained without exceeding the specified capacity. # Constraints * All input values will be positive integers. * The number of items will not exceed 100. # Example ```python capacity = 10 items = [(60, 5), (100, 7), (120, 4)] # Possible maximum value output is 180 (Items with value 60 and 120) print(get_maximum_value(items, capacity)) # Output: 180 ``` # Note * Emphasize handling edge cases such as empty item lists or capacities. * Optimize the solution for performance constraints as described. Implement the function `get_maximum_value` that fulfills the above requirements.","solution":"from typing import List, Tuple def get_maximum_value(items: List[Tuple[int, int]], capacity: int) -> int: n = len(items) # Create a 2D dp array with (n+1) rows and (capacity+1) columns dp = [[0] * (capacity + 1) for _ in range(n + 1)] for i in range(1, n + 1): value, weight = items[i-1] for w in range(capacity + 1): if weight <= w: dp[i][w] = max(dp[i-1][w], dp[i-1][w-weight] + value) else: dp[i][w] = dp[i-1][w] return dp[n][capacity]"},{"question":"# Question: Implement an Improved Resizable Hash Table You are given a `ResizableHashTable` class that uses linear probing for collision handling and dynamically resizes the underlying array when it passes a certain load factor. Your task is to enhance this implementation by incorporating secondary hashing, a strategy known as double hashing, for better collision resolution. Requirements: 1. Implement a secondary hash function within the `ResizableHashTable` class. 2. Modify the `put`, `get`, and `del_` methods to use double hashing for collision resolution. 3. Ensure that the resizing functionality remains effective and correct. Input and Output Formats: * The methods should support the same input and output formats as the existing `HashTable`: * `put(key, value)`: Inserts the key-value pair. * `get(key)`: Returns the value associated with the key, or `None` if the key is not found. * `del_(key)`: Removes the key-value pair corresponding to the key. Constraints: * Keys are non-negative integers. * Values are strings. Performance Requirements: * The average case time complexity for `put`, `get`, and `del_` should remain O(1). Example Scenario: 1. Create an instance of `ResizableHashTable`. 2. Insert multiple key-value pairs. 3. Retrieve values for specific keys. 4. Remove some keys. 5. Ensure the table resizes correctly and performs as expected. ```python # Example Usage hash_table = ResizableHashTable() hash_table.put(1, \'value1\') hash_table.put(12, \'value12\') print(hash_table.get(1)) # Output should be \'value1\' hash_table.del_(1) print(hash_table.get(1)) # Output should be None due to deletion ``` Implement the `ResizableHashTable` class with the required functionalities.","solution":"class ResizableHashTable: def __init__(self, initial_capacity=8, load_factor_threshold=0.75): self.capacity = initial_capacity self.size = 0 self.load_factor_threshold = load_factor_threshold self.table = [None] * self.capacity def _hash_primary(self, key): return key % self.capacity def _hash_secondary(self, key): return 1 + (key % (self.capacity - 1)) def _resize(self): old_table = self.table self.capacity *= 2 self.table = [None] * self.capacity self.size = 0 for item in old_table: if item is not None and item != \'DELETED\': self.put(item[0], item[1]) def put(self, key, value): if (self.size + 1) / self.capacity > self.load_factor_threshold: self._resize() index = self._hash_primary(key) step_size = self._hash_secondary(key) while self.table[index] is not None and self.table[index] != \'DELETED\' and self.table[index][0] != key: index = (index + step_size) % self.capacity if self.table[index] is None or self.table[index] == \'DELETED\': self.size += 1 self.table[index] = (key, value) def get(self, key): index = self._hash_primary(key) step_size = self._hash_secondary(key) while self.table[index] is not None: if self.table[index] != \'DELETED\' and self.table[index][0] == key: return self.table[index][1] index = (index + step_size) % self.capacity return None def del_(self, key): index = self._hash_primary(key) step_size = self._hash_secondary(key) while self.table[index] is not None: if self.table[index] != \'DELETED\' and self.table[index][0] == key: self.table[index] = \'DELETED\' self.size -= 1 return index = (index + step_size) % self.capacity"},{"question":"You are required to implement a sorting function that sorts an array of integers using the Radix Sort algorithm. Additionally, your function should be able to handle some potential edge cases and ensure stability during sorting. # Function Signature ```python def radix_sort(arr: List[int]) -> List[int]: ``` # Input - `arr`: A list of integers `[a1, a2, ..., an]` where (1 leq n leq 10^5) and (0 leq ai leq 10^9). # Output - The function should return a list of integers sorted in non-decreasing order. # Constraints - You must use the Radix Sort technique. - Consider edge cases like empty list, list with all same elements, etc. - Expected time complexity: O(nk + n) and space complexity: O(n + k). # Performance Requirements - The function should efficiently handle large arrays up to the size (10^5). - Memory usage should be within acceptable limits for these sizes. # Example Example 1 ```python input_list = [170, 45, 75, 90, 802, 24, 2, 66] output = radix_sort(input_list) print(output) # Expected [2, 24, 45, 66, 75, 90, 170, 802] ``` Example 2 ```python input_list = [3, 3, 3, 3] output = radix_sort(input_list) print(output) # Expected [3, 3, 3, 3] ``` # Scenario A logistics company needs an efficient way to sort delivery cargo based on unique identifier codes represented as integers. Since these identifiers can range widely but mostly have fixed lengths, Radix Sort provides an efficient solution without excessive comparisons. Your task is to implement this sorting method ensuring accurate and stable sorting performance.","solution":"from typing import List def counting_sort(arr: List[int], exp: int) -> List[int]: n = len(arr) output = [0] * n count = [0] * 10 for i in range(n): index = arr[i] // exp count[index % 10] += 1 for i in range(1, 10): count[i] += count[i - 1] for i in range(n - 1, -1, -1): index = arr[i] // exp output[count[index % 10] - 1] = arr[i] count[index % 10] -= 1 for i in range(n): arr[i] = output[i] return arr def radix_sort(arr: List[int]) -> List[int]: if len(arr) == 0: return arr max_val = max(arr) exp = 1 while max_val // exp > 0: arr = counting_sort(arr, exp) exp *= 10 return arr"},{"question":"# Question: Merging Sorted Linked Lists You are given two singly linked lists that are already sorted in ascending order. The task is to merge these two lists into one sorted linked list. You will be provided with the following `Node` class: ```python class Node: def __init__(self, x): self.val = x self.next = None ``` # Function Signature: Implement the following function: ```python def merge_sorted_lists(l1: Node, l2: Node) -> Node: pass ``` # Input: - `l1`: Head node of the first sorted linked list. - `l2`: Head node of the second sorted linked list. The linked lists are composed of `Node` objects as defined above. The values within the nodes are integers. # Output: - Return the head node of the new sorted linked list composed of the nodes from `l1` and `l2`. # Constraints: - The values in both linked lists are sorted in ascending order. - The number of nodes in each linked list is between 0 and 1000. - All node values are integers between -10^6 and 10^6. # Scenario: Jane is working with logs from two different servers. Each server\'s logs are timestamped and already sorted. She needs to combine these logs while maintaining the sort order. Your task is to help Jane by writing a function that merges these sorted logs into a single sorted order. # Performance Requirements: * The solution should have a linear runtime complexity, O(n + m), where n and m are the lengths of the linked lists. * The solution should be optimized for space, preferably O(1) if using the iterative approach. # Example: ```python # List 1: 1 -> 2 -> 4 # List 2: 1 -> 3 -> 4 n1 = Node(1) n2 = Node(2) n3 = Node(4) n1.next = n2 n2.next = n3 m1 = Node(1) m2 = Node(3) m3 = Node(4) m1.next = m2 m2.next = m3 result = merge_sorted_lists(n1, m1) # The expected result is a linked list: 1 -> 1 -> 2 -> 3 -> 4 -> 4 ``` Your implementation should correctly handle edge cases such as empty lists and lists with duplicate values.","solution":"class Node: def __init__(self, x): self.val = x self.next = None def merge_sorted_lists(l1: Node, l2: Node) -> Node: dummy = Node(0) current = dummy while l1 and l2: if l1.val < l2.val: current.next = l1 l1 = l1.next else: current.next = l2 l2 = l2.next current = current.next # Append the rest of the remaining list if l1: current.next = l1 elif l2: current.next = l2 return dummy.next"},{"question":"# Binary Search in a Circularly Rotated Sorted Array Imagine you are given a circularly rotated sorted array (an array where some prefix of the sorted array has been moved to the end, e.g., [6,7,1,2,3,4,5]) and you need to find the index of a target element. Write a function `circular_binary_search` that implements this. Function Signature ```python def circular_binary_search(array: List[int], target: int) -> int: pass ``` Input - `array`: A list of integers representing a circularly rotated sorted array where each integer can be positive or negative. - `target`: The integer value you need to find in the array. Output - Return the index of the target if it exists in the array. If the target does not exist, return `-1`. Constraints * The array will not be empty. * The elements in the array are distinct. * The length of the array will be in the range [1, 10^5]. Example ```python assert circular_binary_search([6, 7, 1, 2, 3, 4, 5], 3) == 4 assert circular_binary_search([6, 7, 1, 2, 3, 4, 5], 6) == 0 assert circular_binary_search([6, 7, 1, 2, 3, 4, 5], 8) == -1 ``` Performance Requirements * The function should have a time complexity of O(log n). Hints * Think about how you can determine which side (left or right) of the mid element is properly sorted. * Based on the sorted half, narrow down the search interval appropriately.","solution":"from typing import List def circular_binary_search(array: List[int], target: int) -> int: left, right = 0, array.__len__() - 1 while left <= right: mid = (left + right) // 2 if array[mid] == target: return mid if array[left] <= array[mid]: # Left half is sorted if array[left] <= target < array[mid]: right = mid - 1 else: left = mid + 1 else: # Right half is sorted if array[mid] < target <= array[right]: left = mid + 1 else: right = mid - 1 return -1"},{"question":"# In-order Traversal Performance Analysis and Implementation Background You are given the task to traverse a binary tree in in-order fashion. In-order traversal is a depth-first traversal where nodes are processed in left-root-right order. This means that for a given node, you visit its entire left subtree first, then the node itself, and then its right subtree. Problem Given a binary tree\'s root node, write a function to return the in-order traversal of its nodes\' values. You should implement two versions of in-order traversal: 1. Iterative 2. Recursive Function Signature ```python def inorder_traversal_iterative(root: Node) -> List[int]: pass def inorder_traversal_recursive(root: Node) -> List[int]: pass ``` Input * `root`: The root node of a binary tree Output * A list of integer values representing the in-order traversal of the given binary tree. # Constraints 1. The number of nodes in the tree will be between 0 and (10^4). 2. Node values can be any integer within the range of ([-10^5, 10^5]). # Example ```python # Define the Node class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right # Sample tree # 1 # # 2 # / # 3 root = Node(1) root.right = Node(2, Node(3)) # Expected Output: [1, 3, 2] print(inorder_traversal_iterative(root)) # Output: [1, 3, 2] print(inorder_traversal_recursive(root)) # Output: [1, 3, 2] ``` # Important Points - Ensure your implementation handles the edge cases appropriately. - The iterative solution should utilize a stack to track nodes yet to be fully explored. - The recursive solution should handle deep recursion gracefully due to Python\'s recursion limits.","solution":"from typing import List class Node: def __init__(self, val: int, left: \'Node\' = None, right: \'Node\' = None): self.val = val self.left = left self.right = right def inorder_traversal_iterative(root: Node) -> List[int]: result, stack = [], [] current = root while current or stack: while current: stack.append(current) current = current.left current = stack.pop() result.append(current.val) current = current.right return result def inorder_traversal_recursive(root: Node) -> List[int]: result = [] def inorder(node: Node): if node: inorder(node.left) result.append(node.val) inorder(node.right) inorder(root) return result"},{"question":"You are given a description of a Markov Chain, where each state transitions to other states based on defined probabilities. You need to simulate this Markov Chain by generating a sequence of states starting from an initial state. Additionally, you should ensure that the transition probabilities are valid. Function Signature: ```python def generate_sequence(chain: Dict[str, Dict[str, float]], initial_state: str, length: int) -> List[str]: pass ``` Inputs: 1. `chain` - A dictionary representing the Markov Chain. Keys are the current state names and values are dictionaries where keys are next states and values are probabilities of transitioning to those states. Example: ```python { \'A\': {\'A\': 0.6, \'E\': 0.4}, \'E\': {\'A\': 0.7, \'E\': 0.3} } ``` 2. `initial_state` - A string representing the starting state. 3. `length` - An integer representing the number of states to generate in the sequence. Outputs: - A list of strings representing the sequence of states generated by the Markov Chain starting from the initial state, inclusive of the initial state itself. Constraints: - You may assume that the chain is valid and well-formed. - The `length` will be in the range [1, 100]. - Each transition probability in the dictionary will be a float between 0 and 1 and they will sum up to 1 for each state dictionary. Example: ```python chain = { \'A\': {\'A\': 0.6, \'E\': 0.4}, \'E\': {\'A\': 0.7, \'E\': 0.3} } initial_state = \'A\' length = 5 output = generate_sequence(chain, initial_state, length) print(output) # Example output: [\'A\', \'E\', \'A\', \'A\', \'E\'] ``` Explanation: Starting from \'A\', the function will generate a sequence of 5 states based on the provided Markov Chain `chain`. The sequence will vary depending on the random transitions according to the probabilities.","solution":"import random def generate_sequence(chain, initial_state, length): Generates a sequence of states in a Markov Chain starting from the initial state. :param chain: Dictionary representing the Markov Chain :param initial_state: The starting state of the chain :param length: Number of states to generate in the sequence :return: List of states in the generated sequence sequence = [initial_state] current_state = initial_state for _ in range(length - 1): next_states, probabilities = zip(*chain[current_state].items()) next_state = random.choices(next_states, probabilities)[0] sequence.append(next_state) current_state = next_state return sequence"},{"question":"# Nearest Neighbor Classification Challenge Background In pattern recognition, a simple yet powerful algorithm is the Nearest Neighbor algorithm. Given a set of training data, where each data point is a vector assigned to a class or label, the algorithm determines the class of a new point by finding the class of its nearest point in the training data. The distance metric used in this scenario is the Euclidean distance. Task You are required to implement the `nearest_neighbor(x, tSet)` function, which classifies a new data point (`x`) by finding the closest point in the training set (`tSet`). The training set is a dictionary where keys are tuples representing points, and values are their corresponding class labels. Provided Function ```python import math def distance(x, y): Calculate the Euclidean distance between vectors x and y. Arguments: x, y: Tuple of numeric values Returns: float: The Euclidean distance between the two vectors assert len(x) == len(y), \\"The vectors must have the same length\\" return math.sqrt(sum((a - b) ** 2 for a, b in zip(x, y))) ``` Your Task Implement the `nearest_neighbor(x, tSet)` function: 1. **Input**: * `x` (tuple): A vector to classify. * `tSet` (dict): A dictionary where keys are tuples (vectors) and values are the corresponding class labels. 2. **Output**: * Return the class label of the nearest neighbor in `tSet` to the vector `x`. Constraints 1. You may assume that `tSet` contains at least one entry and all vectors (including `x`) are of the same length. 2. The vectors contain numeric values (integers or floats). Example ```python tSet = { (2.0, 3.0): \'Class_A\', (1.0, 2.0): \'Class_B\', (5.0, 4.0): \'Class_A\', (1.5, 1.8): \'Class_B\' } x = (1.5, 2.5) print(nearest_neighbor(x, tSet)) # Output: \'Class_B\' ``` The function is expected to locate `(1.0, 2.0)` as the nearest point to `(1.5, 2.5)` in the training set, and return its class label `\'Class_B\'`. Notes * Ensure your implementation is efficient and properly handles edge cases. * The provided `distance()` helper function can be used to calculate the Euclidean distance.","solution":"import math def distance(x, y): Calculate the Euclidean distance between vectors x and y. assert len(x) == len(y), \\"The vectors must have the same length\\" return math.sqrt(sum((a - b) ** 2 for a, b in zip(x, y))) def nearest_neighbor(x, tSet): Classify a new data point x by finding the closest point in the training set tSet. Arguments: x : tuple -- A vector to classify. tSet : dict -- A dictionary where keys are tuples (vectors) and values are the corresponding class labels. Returns: The class label of the nearest neighbor in tSet to the vector x. nearest = None min_distance = float(\'inf\') for point, label in tSet.items(): dist = distance(x, point) if dist < min_distance: min_distance = dist nearest = label return nearest"},{"question":"# Anagram Checking You are given two strings `s1` and `s2`. Your task is to determine if these strings are anagrams of each other. Two strings are anagrams if they contain the same characters with the same frequencies, but their order can be different. Write a function `are_anagrams(s1: str, s2: str) -> bool` that returns `True` if the input strings are anagrams, otherwise `False`. Function Signature ```python def are_anagrams(s1: str, s2: str) -> bool: pass ``` Input - `s1`: A string consisting of lowercase alphabetic characters (1 ≤ |s1| ≤ 100). - `s2`: A string consisting of lowercase alphabetic characters (1 ≤ |s2| ≤ 100). Output - Return a boolean value: `True` if `s1` and `s2` are anagrams, and `False` otherwise. Constraints - Only lowercase alphabetic characters are considered. - You must achieve the time complexity of O(n). Examples ```python assert are_anagrams(\\"apple\\", \\"pleap\\") == True assert are_anagrams(\\"apple\\", \\"cherry\\") == False assert are_anagrams(\\"listen\\", \\"silent\\") == True assert are_anagrams(\\"abc\\", \\"cba\\") == True assert are_anagrams(\\"aaaa\\", \\"aaa\\") == False assert are_anagrams(\\"xyz\\", \\"zyxw\\") == False ``` Notes - Pay attention to edge cases, such as one or both strings being empty or having different lengths.","solution":"def are_anagrams(s1: str, s2: str) -> bool: Returns True if s1 and s2 are anagrams of each other, otherwise False. from collections import Counter # Anagrams must be of the same length if len(s1) != len(s2): return False # Check if both strings consist of the same characters with the same frequencies return Counter(s1) == Counter(s2)"},{"question":"# Problem: Extended Run-Length Encoding and Decoding You have been provided with basic implementations of Run-Length Encoding (RLE) and Decoding algorithms. Based on these, your task is to enhance and extend them to handle a greater variety of characters in the input. The primary goal is to implement a new encoding and decoding scheme that handles alphanumeric sequences and special characters efficiently. Your solution should also be optimized for performance and handle various edge cases effectively. # Function Specification `encode_advanced_rle(input: str) -> str` # Input: * `input` (string): The input data stream which contains alphanumeric characters, spaces, and special characters. # Output: * A string representing the encoded data using the advanced RLE compression, where contiguous character sequences are compressed as `<count><character>`. `decode_advanced_rle(input: str) -> str` # Input: * `input` (string): The encoded data stream which contains counts followed by characters, as per the advanced RLE compression. # Output: * A string representing the original data stream after decompression. # Constraints * The input strings for both functions will contain only printable ASCII characters (alphanumeric, spaces, and special characters). * The characters count in the encoding format will not exceed `9999` (i.e., counts are up to four digits long). * Ensure the implementation is efficient with the time complexity of O(n). # Examples Example 1: ```python input_string = \\"aaabbbcccaaa\\" print(encode_advanced_rle(input_string)) # Output: \\"3a3b3c3a\\" print(decode_advanced_rle(\\"3a3b3c3a\\")) # Output: \\"aaabbbcccaaa\\" ``` Example 2: ```python input_string = \\"a \\" print(encode_advanced_rle(input_string)) # Output: \\"1a2#2 3\\" print(decode_advanced_rle(\\"1a2#2 3\\")) # Output: \\"a \\" ``` Example 3: ```python input_string = \\"\\" print(encode_advanced_rle(input_string)) # Output: \\"\\" print(decode_advanced_rle(\\"\\")) # Output: \\"\\" ``` # Notes * You are required to handle all given constraints and edge cases as per the scenarios indicated. * Ensure your implementation optimally handles potentially long strings and large counts.","solution":"def encode_advanced_rle(input: str) -> str: Encodes the input string using an advanced Run-Length Encoding (RLE) algorithm. if not input: return \\"\\" encoded = [] count = 1 prev_char = input[0] for char in input[1:]: if char == prev_char: count += 1 else: encoded.append(f\\"{count}{prev_char}\\") count = 1 prev_char = char encoded.append(f\\"{count}{prev_char}\\") # append the last set return \\"\\".join(encoded) def decode_advanced_rle(input: str) -> str: Decodes the encoded string using an advanced Run-Length Encoding (RLE) algorithm. if not input: return \\"\\" decoded = [] count = \\"\\" for char in input: if char.isdigit(): count += char else: decoded.append(char * int(count)) count = \\"\\" return \\"\\".join(decoded)"},{"question":"Problem Statement You are given a positive integer `n`. Your task is to write a function `minPerfectSquares(n)` that computes the minimum number of perfect square numbers which sum to `n`. # Input * A single integer `n` (1 ≤ n ≤ 10^4). # Output * A single integer representing the minimum number of perfect squares that sum to `n`. # Requirements 1. Implement the function without importing external libraries other than `math`. 2. Your solution should be efficient enough to handle the upper constraint smoothly. # Example ```python # Example 1 n = 9 print(minPerfectSquares(9)) # Output: 1 (9 = 3^2) # Example 2 n = 10 print(minPerfectSquares(10)) # Output: 2 (10 = 3^2 + 1^2) # Example 3 n = 12 print(minPerfectSquares(12)) # Output: 3 (12 = 2^2 + 2^2 + 2^2) ``` Constraints: 1. Make sure your code handles edge cases efficiently. 2. Avoid redundant calculations and optimize wherever possible. # Hint: Utilize mathematical theorems like Lagrange’s Four Square Theorem and Legendre’s Three Square Theorem for an optimal solution.","solution":"def minPerfectSquares(n): # Initialize a list dp where dp[i] is the minimum number of perfect # squares that sum to i. dp[0] is 0 since 0 is the sum of zero numbers. dp = [0] + [float(\'inf\')] * n for i in range(1, n + 1): j = 1 while j * j <= i: dp[i] = min(dp[i], dp[i - j * j] + 1) j += 1 return dp[n]"},{"question":"You are required to implement a function to multiply two non-negative integers represented as strings and return the product also as a string. The function will simulate manual multiplication without converting the entire string directly into an integer or using any large integer libraries. # Input * `num1` and `num2`: Two non-negative integers represented as strings. Each contains only digits 0-9 and does not contain any leading zeros. * The length of both `num1` and `num2` is less than 110. # Output The product of `num1` and `num2`, represented as a string. # Constraints * You must not use any built-in BigInteger library or convert the inputs to integer directly. # Example ```python def multiply(num1: \\"str\\", num2: \\"str\\") -> \\"str\\": pass # Example Usage print(multiply(\\"123\\", \\"456\\")) # Output: \\"56088\\" ``` # Explanation * `123 * 456` is calculated as follows: ``` 123 * 456 ----- 738 (123 * 6) 615 (123 * 5 shifted one position to the left) +492 (123 * 4 shifted two positions to the left) ----- 56088 ``` You are required to simulate this exact process programmatically. # Notes * Consider edge cases such as when one of the strings is \\"0\\", or both strings are \\"1\\". * Optimize well within the constraints to ensure the solution is efficient and performs well for all allowed input sizes.","solution":"def multiply(num1: str, num2: str) -> str: if num1 == \\"0\\" or num2 == \\"0\\": return \\"0\\" m, n = len(num1), len(num2) result = [0] * (m + n) # Reverse the strings to facilitate multiplication from least significant digit num1, num2 = num1[::-1], num2[::-1] # Multiply each digit and add results to the corresponding position in the result array for i in range(m): for j in range(n): product = int(num1[i]) * int(num2[j]) result[i + j] += product # Carry over the excess to the next position result[i + j + 1] += result[i + j] // 10 result[i + j] %= 10 # Remove any leading zeros from the result while len(result) > 1 and result[-1] == 0: result.pop() # Convert result to a string and reverse it back return \'\'.join(map(str, result[::-1])) # Example Usage print(multiply(\\"123\\", \\"456\\")) # Output: \\"56088\\""},{"question":"You are tasked with writing a function to validate a Sudoku board. The validation should ensure that the board follows these Sudoku rules: 1. Each row contains the digits \'1\'-\'9\' without repetition. 2. Each column contains the digits \'1\'-\'9\' without repetition. 3. Each of the nine 3x3 sub-boxes contains the digits \'1\'-\'9\' without repetition. A partially filled Sudoku board is represented as a 2D array \'board\', filled with characters from \'1\' to \'9\' and \'.\' representing empty cells. # Example ```text Input: [ [\\"5\\",\\"3\\",\\".\\",\\".\\",\\"7\\",\\".\\",\\".\\",\\".\\",\\".\\"], [\\"6\\",\\".\\",\\".\\",\\"1\\",\\"9\\",\\"5\\",\\".\\",\\".\\",\\".\\"], [\\".\\",\\"9\\",\\"8\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\"], [\\"8\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\"3\\"], [\\"4\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\"3\\",\\".\\",\\".\\",\\"1\\"], [\\"7\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\".\\",\\".\\",\\".\\",\\"6\\"], [\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\"8\\",\\".\\"], [\\".\\",\\".\\",\\".\\",\\"4\\",\\"1\\",\\"9\\",\\".\\",\\".\\",\\"5\\"], [\\".\\",\\".\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\".\\",\\"7\\",\\"9\\"] ] Output: True Input: [ [\\"8\\",\\"3\\",\\".\\",\\".\\",\\"7\\",\\".\\",\\".\\",\\".\\",\\".\\"], [\\"6\\",\\".\\",\\".\\",\\"1\\",\\"9\\",\\"5\\",\\".\\",\\".\\",\\".\\"], [\\".\\",\\"9\\",\\"8\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\"], [\\"8\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\"3\\"], [\\"4\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\"3\\",\\".\\",\\".\\",\\"1\\"], [\\"7\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\".\\",\\".\\",\\".\\",\\"6\\"], [\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\"8\\",\\".\\"], [\\".\\",\\".\\",\\".\\",\\"4\\",\\"1\\",\\"9\\",\\".\\",\\".\\",\\"5\\"], [\\".\\",\\".\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\".\\",\\"7\\",\\"9\\"] ] Output: False ``` # Function Signature ```python def is_valid_sudoku(self, board: List[List[str]]) -> bool: # your code here ``` # Input Constraints * The Sudoku board is a 2D list of 9x9 size. * The board contains only digits \'1\'-\'9\' and empty cells \'.\'. # Requirements 1. Ensure the function handles edge cases such as few or no filled cells, and boards containing invalid characters. 2. Optimally implement the validation logic, preferably focusing on space efficiency. 3. Ensure the function returns `True` for valid boards and `False` otherwise.","solution":"def is_valid_sudoku(board): def is_valid_unit(unit): unit = [i for i in unit if i != \'.\'] return len(set(unit)) == len(unit) def is_valid_box(board, row, col): box = [ board[row + i][col + j] for i in range(3) for j in range(3) ] return is_valid_unit(box) for i in range(9): if not is_valid_unit(board[i]): # Check rows return False if not is_valid_unit([board[j][i] for j in range(9)]): # Check columns return False for i in range(0, 9, 3): for j in range(0, 9, 3): if not is_valid_box(board, i, j): return False return True"},{"question":"Scenario A robotics kit has a sensor array that can detect distances to objects around it, arranged in increasing numerical order. However, due to rotational movement, the sensor array data you receive is sometimes rotated at an unknown pivot. Your task is to implement a function to find a specific distance value in this rotated, sorted array. Task Write a function `search_in_rotated_array(nums: List[int], target: int) -> int` that searches for a target value in a rotated sorted array and returns its index. If not found, return -1. Your solution should maintain a runtime complexity of O(log n). Input * `nums` - A list of integers representing the rotated array, each integer uniquely representing distance. * `target` - An integer representing the distance value to search for. Output * An integer representing the index of the target value if found; otherwise, -1. Constraints * The array length will be in the range of [0, 10^4]. * Each integer in `nums` will be in the range of [-10^4, 10^4]. * The array will have unique integers. * Solution should have O(log n) time complexity. Example ```python assert search_in_rotated_array([4,5,6,7,0,1,2], 0) == 4 assert search_in_rotated_array([4,5,6,7,0,1,2], 3) == -1 assert search_in_rotated_array([1], 0) == -1 assert search_in_rotated_array([1, 3], 1) == 0 assert search_in_rotated_array([5, 1, 3], 3) == 2 ``` Performance Requirements * The implementation must achieve O(log n) runtime complexity. Good luck!","solution":"def search_in_rotated_array(nums, target): Searches for a target value in a rotated sorted array and returns its index. If not found, returns -1. :param nums: List[int] - The rotated sorted array. :param target: int - The target value to search for. :return: int - The index of the target value if found; otherwise, -1. left, right = 0, len(nums) - 1 while left <= right: mid = (left + right) // 2 if nums[mid] == target: return mid if nums[left] <= nums[mid]: # Left part is sorted if nums[left] <= target < nums[mid]: right = mid - 1 else: left = mid + 1 else: # Right part is sorted if nums[mid] < target <= nums[right]: left = mid + 1 else: right = mid - 1 return -1"},{"question":"# Base Conversion Algorithm As a software developer in a firm that deals with numeral systems extensively, you are tasked with implementing two critical functions that will be used throughout the system: `int_to_base` and `base_to_int`. These functions shall help in converting integers to different bases and vice versa. Function Specifications: 1. **int_to_base(num, base)** - **Input**: - `num` (integer): The number to convert. - `base` (integer): The base to convert the number to (between 2 and 36). - **Output**: A string representing the number in the given base. 2. **base_to_int(str_to_convert, base)** - **Input**: - `str_to_convert` (string): The string representation of the number in the specified base. - `base` (integer): The base of the input string (between 2 and 36). - **Output**: An integer representing the converted base 10 number. Constraints: - The base `base` should be an integer between 2 and 36. - The input for `int_to_base` can be any integer. - The input for `base_to_int` can be assumed to be a valid string using correct characters for the specified base. Example: ```python int_to_base(5, 2) # Output: \'101\' int_to_base(-15, 16) # Output: \'-F\' base_to_int(\'101\', 2) # Output: 5 base_to_int(\'F\', 16) # Output: 15 ``` Task: Implement the `int_to_base` and `base_to_int` functions while adhering to the given specifications. Pay attention to both the correctness of the implemented algorithm and the performance impacts as you handle various integer sizes and edge cases.","solution":"def int_to_base(num, base): Converts a given integer to a string representation in the specified base. Args: num (int): The number to convert. base (int): The base of the numeral system (between 2 and 36). Returns: str: The string representation of the number in the specified base. if base < 2 or base > 36: raise ValueError(\\"Base must be between 2 and 36\\") if num == 0: return \'0\' digits = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" negative = num < 0 num = abs(num) result = [] while num: result.append(digits[num % base]) num //= base if negative: result.append(\'-\') return \'\'.join(reversed(result)) def base_to_int(str_to_convert, base): Converts a string representation of a number in the specified base to an integer. Args: str_to_convert (str): The string representation of the number. base (int): The base of the numeral system (between 2 and 36). Returns: int: The integer representation of the number. if base < 2 or base > 36: raise ValueError(\\"Base must be between 2 and 36\\") str_to_convert = str_to_convert.upper() digits = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" value_map = {digit: i for i, digit in enumerate(digits[:base])} if str_to_convert[0] == \'-\': negative = True str_to_convert = str_to_convert[1:] else: negative = False result = 0 for char in str_to_convert: result = result * base + value_map[char] if negative: result = -result return result"},{"question":"# Context You\'ve been tasked with optimizing a software where stack operations frequently need to maintain consistency across multiple structures without redundant code. Given two different stack implementations (Array-based and Linked List-based), you need to extend their functionality to support an efficient minimum operation for constant-time access to the minimum element in the stacks. # Problem Statement Implement a `MinStack` class that extends the `ArrayStack` and `LinkedListStack` implementations to efficiently support a `get_min` method. This method should return the minimum element in the stack in O(1) time complexity. # Requirements * **Class Definitions**: `MinArrayStack`, `MinLinkedListStack` * Extend from `ArrayStack` and `LinkedListStack` respectively. * Implement `get_min` method: * **Input**: None. * **Output**: Return the minimum element currently in the stack. * **Constraints**: Must operate in O(1) time. # Input and Output * **Input**: Series of stack operations (`push`, `pop`, `peek`, `is_empty`, `get_min`). * **Output**: Outputs based on stack operations, especially focusing on `get_min`. # Example ```python # Example with ArrayStack min_array_stack = MinArrayStack() min_array_stack.push(3) min_array_stack.push(5) print(min_array_stack.get_min()) # Output: 3 min_array_stack.push(2) print(min_array_stack.get_min()) # Output: 2 min_array_stack.pop() print(min_array_stack.get_min()) # Output: 3 # Example with LinkedListStack min_linkedlist_stack = MinLinkedListStack() min_linkedlist_stack.push(3) min_linkedlist_stack.push(5) print(min_linkedlist_stack.get_min()) # Output: 3 min_linkedlist_stack.push(2) print(min_linkedlist_stack.get_min()) # Output: 2 min_linkedlist_stack.pop() print(min_linkedlist_stack.get_min()) # Output: 3 ``` # Implementation Extend the stack implementations with the following methods: * `push`: Modify to keep track of the minimum element. * `pop`: Adjust the minimum element accordingly. * `get_min`: Return the current minimum element in O(1) time.","solution":"class ArrayStack: def __init__(self): self.stack = [] def push(self, value): self.stack.append(value) def pop(self): if not self.is_empty(): return self.stack.pop() return None def peek(self): if not self.is_empty(): return self.stack[-1] return None def is_empty(self): return len(self.stack) == 0 class LinkedListStack: class Node: def __init__(self, value): self.value = value self.next = None def __init__(self): self.head = None def push(self, value): new_node = self.Node(value) new_node.next = self.head self.head = new_node def pop(self): if not self.is_empty(): value = self.head.value self.head = self.head.next return value return None def peek(self): if not self.is_empty(): return self.head.value return None def is_empty(self): return self.head is None class MinArrayStack(ArrayStack): def __init__(self): super().__init__() self.min_stack = [] def push(self, value): super().push(value) if not self.min_stack or value <= self.min_stack[-1]: self.min_stack.append(value) def pop(self): value = super().pop() if value is not None and value == self.min_stack[-1]: self.min_stack.pop() return value def get_min(self): if self.is_empty(): return None return self.min_stack[-1] class MinLinkedListStack(LinkedListStack): def __init__(self): super().__init__() self.min_stack = [] def push(self, value): super().push(value) if not self.min_stack or value <= self.min_stack[-1]: self.min_stack.append(value) def pop(self): value = super().pop() if value is not None and value == self.min_stack[-1]: self.min_stack.pop() return value def get_min(self): if self.is_empty(): return None return self.min_stack[-1]"},{"question":"# Scenario In certain digital displays (like calculators or digital clocks), numbers are often designed in a way that they appear the same when viewed upside down. An example of such a number is 69, which remains the same when viewed from the bottom or rotated by 180 degrees. Your task is to write a function that checks if a given number (represented as a string) is strobogrammatic. # Requirements You need to write a function `is_strobogrammatic(num: str) -> bool` that returns `True` if the number is strobogrammatic and `False` otherwise. # Constraints 1. The input string `num` consists of numeric characters (0-9) only. 2. The length of the input string `num` will be between 1 and 10^5. # Input * A single argument: `num` (a string representing the number to check). # Output * A boolean value: `True` if the number is strobogrammatic, `False` otherwise. # Example ```python assert is_strobogrammatic(\\"69\\") == True assert is_strobogrammatic(\\"88\\") == True assert is_strobogrammatic(\\"962\\") == False assert is_strobogrammatic(\\"818\\") == True assert is_strobogrammatic(\\"123\\") == False assert is_strobogrammatic(\\"\\") == True # Optional: Decide if you want to handle empty string ``` **Note**: Consider edge cases like an empty string or single character strings. You do not need to handle inputs with characters other than digits (0-9). # Performance Requirements The function should be efficient to handle strings up to length 10^5.","solution":"def is_strobogrammatic(num: str) -> bool: Checks if the given number (as a string) is strobogrammatic. A number is strobogrammatic if it looks the same when rotated 180 degrees. # Strobogrammatic number pairs strobogrammatic_pairs = { \'0\': \'0\', \'1\': \'1\', \'6\': \'9\', \'8\': \'8\', \'9\': \'6\' } # Two pointers approach to check digits from both ends left, right = 0, len(num) - 1 while left <= right: if num[left] not in strobogrammatic_pairs or num[right] not in strobogrammatic_pairs: return False if strobogrammatic_pairs[num[left]] != num[right]: return False left += 1 right -= 1 return True"},{"question":"**Scenario**: You are working on a project that requires you to represent and visualize hierarchical data structures similar to an organization chart or a nested file system. You need to implement a function to print this structure in a readable format. **Task**: Write a Python function named `tree_print` that takes a dictionary representing a tree structure as an input and prints its contents. Each key in the dictionary is associated with a list of sub-elements which can either be strings or further nested elements. Ensure the printout is readable with proper indentation and formatting. **Function Signature**: ```python def tree_print(tree: dict) -> None: ``` **Input**: * `tree`: A dictionary where each key is associated with a list of strings or further nested lists. The dictionary may contain nested dictionaries representing deeper levels of the hierarchy. **Output**: * The function should print the tree structure, each sub-element on a new line with proper indentation. **Constraints**: * Strings and nested elements should be printed with appropriate formatting to make the hierarchy clear. * Indentation increases with nesting levels. * Handle cases where the dictionary is empty or contains non-string sub-elements. **Performance Requirements**: * Aim to minimize dictionary lookups for efficiency. * Handle moderately large structures gracefully. **Example**: Given the following tree structure: ```python tree = { \'a\': [\'Adam\', \'Book\', 4], \'b\': [\'Bill\', \'Computer\', 5, \'TV\', 6], \'c\': [\'Bill\', \'Sports\', 3], \'d\': [\'Adam\', \'Computer\', 3, {\'Quin\': [\'Computer\', 3]}], \'e\': [{\'Quin\': [\'Book\', 5]}, \'TV\', 2], \'f\': [\'Adam\', {\'Computer\': 7}] } ``` Calling `tree_print(tree)` should output: ``` a Adam -> Book -> 4 b Bill -> Computer -> 5 -> TV -> 6 c Bill -> Sports -> 3 d Adam -> Computer -> 3 -> Quin -> Computer -> 3 e Quin -> Book -> 5 -> TV -> 2 f Adam -> Computer -> 7 ``` **Note**: This example should guide students through incorporating logic for nested dictionaries while maintaining proper indentation and format.","solution":"def tree_print(tree: dict, indent: int = 0) -> None: Print the hierarchical structure of a dictionary with proper indentation. :param tree: Dictionary representing tree structure. :param indent: Current level of indentation (used for recursive calls). for key, values in tree.items(): print(\' \' * indent + str(key)) if isinstance(values, list): for value in values: if isinstance(value, dict): tree_print(value, indent + 1) else: print(\' \' * (indent + 1) + str(value)) else: print(\' \' * (indent + 1) + str(values))"},{"question":"In a given array of integers, every element appears exactly three times except for one unique element which appears only once. Your task is to implement an algorithm that finds this unique element. # Input Format - An integer array `nums` containing `n` integers where `n` >= 4. # Output Format - An integer representing the element that appears only once in the array. # Constraints - The algorithm should have a linear runtime complexity, O(n). - No extra memory usage beyond a few integer variables, i.e., O(1) space complexity. - Each integer in the array can be both positive and negative including zero. # Example ```python def find_single_element(nums): # Your code goes here # Example Usage: nums = [2, 2, 3, 2] print(find_single_element(nums)) # Output: 3 nums = [0, 1, 0, 1, 0, 1, 99] print(find_single_element(nums)) # Output: 99 ``` # Explanation - In the first example, 3 is the only number that appears once while 2 appears three times. - In the second example, 99 is the unique element among 0 and 1 which appear three times each. # Notes - Be cautious with negative numbers and make sure they are handled correctly. - It\'s important to comment your code to explain the bitwise operations especially if it\'s non-trivial. # Implementation Requirements 1. Implement the function `find_single_element(nums)` using bit manipulation as described. 2. Ensure that your implementation adheres to the constraints regarding time complexity and space usage.","solution":"def find_single_element(nums): This function finds the unique element that appears only once in an array where every other element appears exactly three times. ones, twos = 0, 0 for num in nums: # Add num to `twos` if it is already in `ones` twos |= ones & num # XOR num with `ones` to toggle bits where num appears ones ^= num # `common_bit_mask` contains all the bits that have appeared three times common_bit_mask = ~(ones & twos) # Remove common_bits from `ones` and `twos` ones &= common_bit_mask twos &= common_bit_mask return ones"},{"question":"Calculate Combinations (nCr) You are tasked with implementing an efficient algorithm to calculate the number of combinations of choosing `r` items from a set of `n` items. The goal is to derive `nCr`, which is also known as the binomial coefficient. Function Signature ```python def combination_dp(n: int, r: int) -> int: pass ``` # Input * Two non-negative integers `n` and `r` such that `0 <= r <= n`. # Output * An integer representing the number of ways to choose `r` items from `n` items. # Performance Requirements Your solution should have a time complexity of `O(n*r)` and space complexity of `O(r)`. # Constraints * `0 <= n <= 1000` * `0 <= r <= n` # Examples 1. **Input**: `n = 5`, `r = 2` **Output**: `10` * Explanation: There are 10 ways to choose 2 items from a set of 5 items. 2. **Input**: `n = 7`, `r = 3` **Output**: `35` * Explanation: There are 35 ways to choose 3 items from a set of 7 items. 3. **Input**: `n = 10`, `r = 0` **Output**: `1` * Explanation: There is exactly 1 way to choose 0 items from a set of 10 items (by choosing none). # Requirements * You must use a dynamic programming approach to meet the performance requirements. * Handle any possible edge cases effectively. # Example Code to Start ```python def combination_dp(n: int, r: int) -> int: if r > n: return 0 if r == 0 or n == r: return 1 # Initialize a table to store results dp = [0] * (r + 1) dp[0] = 1 # Fill the dp array using bottom-up approach for i in range(1, n + 1): for j in range(min(i, r), 0, -1): dp[j] = dp[j] + dp[j - 1] return dp[r] ```","solution":"def combination_dp(n: int, r: int) -> int: if r > n: return 0 if r == 0 or n == r: return 1 # Initialize a table to store results dp = [0] * (r + 1) dp[0] = 1 # Fill the dp array using bottom-up approach for i in range(1, n + 1): for j in range(min(i, r), 0, -1): dp[j] = dp[j] + dp[j - 1] return dp[r]"},{"question":"# Scenario You are working on a system that needs to exchange data between a client and a server. The data consists of lists of strings, and you need a compact way to encode these lists into a single string that can be easily transmitted over the network. Once the string is received, it must be decoded back into the original list of strings reliably. # Task Implement the functions `encode` and `decode` that convert a list of strings into a single encoded string and decode it back to the original list. # Function Definitions ```python def encode(strs): Encodes a list of strings to a single string. :param strs: List of strings :type strs: List[str] :return: Encoded string :rtype: str pass def decode(s): Decodes a single string to a list of strings. :param s: Encoded string :type s: str :return: List of strings :rtype: List[str] pass ``` # Constraints 1. `strs` will contain only ASCII characters. 2. The encoded result should not add any extra delimiters that might conflict with the original strings. 3. All strings in `strs` may have varying lengths, including zero length. # Input/Output Examples ```python # Example 1 strs = [\\"hello\\", \\"world\\"] encoded_str = encode(strs) decoded_list = decode(encoded_str) assert decoded_list == [\\"hello\\", \\"world\\"] # Example 2 strs = [\\"\\", \\"a\\", \\"abc\\"] encoded_str = encode(strs) decoded_list = decode(encoded_str) assert decoded_list == [\\"\\", \\"a\\", \\"abc\\"] # Example 3 strs = [] encoded_str = encode(strs) decoded_list = decode(encoded_str) assert decoded_list == [] ``` # Additional Considerations - Ensure minimal processing overhead and memory usage. - Validate your solution with various edge cases, including empty lists and empty strings.","solution":"def encode(strs): Encodes a list of strings to a single string. :param strs: List of strings :type strs: List[str] :return: Encoded string :rtype: str return \'\'.join(f\'{len(s)}#{s}\' for s in strs) def decode(s): Decodes a single string to a list of strings. :param s: Encoded string :type s: str :return: List of strings :rtype: List[str] i, n = 0, len(s) result = [] while i < n: j = s.find(\'#\', i) length = int(s[i:j]) i = j + 1 result.append(s[i:i+length]) i += length return result"},{"question":"# Finding the Missing Number You\'re given an array of unique integers in the range `[0, n]`. The integers are unordered, and the difference between any two consecutive integers cannot exceed 1. Your task is to implement a function `find_missing_number_variant` that identifies the missing number in O(n) time and O(1) space. Input: - An integer array `nums` of length `n` containing unique integers in the range `[0, n]`. Output: - An integer representing the missing number or the next integer (`n + 1`) if the sequence is complete. Constraints: - The length of nums is `n`. - All integers in nums lie within the range `[0, n]`. # Example: ```python # Example 1: Input: nums = [4, 1, 3, 0, 6, 5, 2] Output: 7 # Example 2: Input: nums = [0, 1, 3] Output: 2 # Example 3: Input: nums = [0, 2, 1] Output: 3 ``` Notes: - Consider edge cases such as arrays of minimum and maximum possible sizes under the input constraints. - Think about ways to validate the array before processing it to avoid incorrect outcomes. # Implementation: Implement the function in Python: ```python def find_missing_number_variant(nums): # Implement your solution here pass # Test cases to validate the solution print(find_missing_number_variant([4, 1, 3, 0, 6, 5, 2])) # Expected: 7 print(find_missing_number_variant([0, 1, 3])) # Expected: 2 print(find_missing_number_variant([0, 2, 1])) # Expected: 3 ```","solution":"def find_missing_number_variant(nums): Returns the missing number in the array or the next integer (n + 1) if the sequence is complete. n = len(nums) total_sum = n * (n + 1) // 2 # Sum of first n natural numbers array_sum = sum(nums) missing_number = total_sum - array_sum # Check if all numbers from 0 to n are present if missing_number in nums: return n + 1 return missing_number"},{"question":"# Regular Expression Matching with Dynamic Programming Objective: Implement the function `is_match` to perform regular expression matching with support for the special characters `.` and `*`. Function Prototype ```python bool is_match(const char *s, const char *p) ``` Input * `s` (str): The input string to match. (1 ≤ len(s) ≤ 30) * `p` (str): The pattern string, which may contain `.` and `*`. (1 ≤ len(p) ≤ 30) Output * Returns `True` if the input string matches the pattern string; otherwise, returns `False`. Special Character Rules * `.` matches any single character. * `*` matches zero or more of the preceding element. Example Cases ```plaintext is_match(\\"aa\\",\\"a\\") → false is_match(\\"aa\\",\\"aa\\") → true is_match(\\"aaa\\",\\"aa\\") → false is_match(\\"aa\\", \\"a*\\") → true is_match(\\"aa\\", \\".*\\") → true is_match(\\"ab\\", \\".*\\") → true is_match(\\"aab\\", \\"c*a*b\\") → true ``` Constraints * Ensure no direct use of built-in regex libraries. * Aim to optimize time and space complexity within given constraints. Scenario Consider building a simple pattern matcher for syntax highlighting in a text editor. It should support basic regular expressions with `.` and `*`, enabling advanced pattern identification akin to what you\'d expect in more sophisticated editors. # Task Implement the function `is_match` to meet the given requirements and pass all provided test cases.","solution":"def is_match(s, p): Returns True if s matches the pattern p, where pattern p can contain . and * characters. # Create a DP table with dimensions (len(s) + 1) x (len(p) + 1) dp = [[False] * (len(p) + 1) for _ in range(len(s) + 1)] dp[0][0] = True # Populate the DP table for patterns with stars that can match zero characters. for j in range(1, len(p) + 1): if p[j - 1] == \'*\': dp[0][j] = dp[0][j - 2] # Fill the DP table row by row. for i in range(1, len(s) + 1): for j in range(1, len(p) + 1): if p[j - 1] == \'.\' or p[j - 1] == s[i - 1]: dp[i][j] = dp[i - 1][j - 1] elif p[j - 1] == \'*\': dp[i][j] = dp[i][j - 2] or ((p[j - 2] == \'.\' or p[j - 2] == s[i - 1]) and dp[i - 1][j]) else: dp[i][j] = False return dp[len(s)][len(p)]"},{"question":"# Reversing Bits of an N-bit Integer Objective Write an efficient function to reverse the bits of a given N-bit unsigned integer. The width of the integer (N) is flexible, not fixed to 32 bits. Context In certain low-level computing tasks, you might need to manipulate the sequence of bits directly. This requirement is common in cryptographic algorithms, data compression techniques, and certain hardware communication protocols. Function Signature ```python def reverse_bits(n: int, num_bits: int) -> int: Reverses the bits of an N-bit unsigned integer. Parameters: n (int): The integer to reverse bits of. num_bits (int): The width of the integer in bits. Returns: int: The integer resulting from reversing the bits of the input. pass ``` Input - `n` (int): a non-negative integer representing the N-bit unsigned integer. - `num_bits` (int): an integer (1 <= num_bits <= 64) defining the width of `n` in bits. Output - Returns a non-negative integer representing the reversed bit pattern of the input integer. Constraints - Input integer `n` will be within the range of a non-negative `num_bits`-bit integer. - The function should efficiently handle the input within the constraints. Examples 1. `reverse_bits(43261596, 32)` should return `964176192`. 2. `reverse_bits(1, 1)` should return `1`. Edge Cases to Consider 1. Minimum value of `n` (0). 2. Maximum value of `n` for the given `num_bits`. 3. `num_bits` values such as 1, 8, 16, 64 to test diversity in bit width.","solution":"def reverse_bits(n: int, num_bits: int) -> int: Reverses the bits of an N-bit unsigned integer. Parameters: n (int): The N-bit unsigned integer. num_bits (int): The width of the integer in bits. Returns: int: The integer resulting from reversing the bits of the input. reversed_n = 0 for i in range(num_bits): reversed_n = (reversed_n << 1) | (n & 1) n >>= 1 return reversed_n"},{"question":"# Question: Find the Mode You are tasked with writing a function that calculates the mode of a list of integers. The mode is the value(s) that appear most frequently in the list. If there are multiple values with the same highest frequency, the function should return all of them. Function Signature ```python def find_mode(arr: List[int]) -> List[int]: ``` Input * `arr` (List[int]): A list of integers. You can assume the list will contain at least one integer. Output * List[int]: A list of integers representing the mode(s) of the input list. # Example ```python # Example 1: # Input: [1, 1, 2, 2, 3, 4] # Output: [1, 2] # Example 2: # Input: [4, 4, 4, 2, 2, 3, 3, 3] # Output: [4] # Example 3: # Input: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1] # Output: [1] ``` # Constraints * The list will not be empty. * Elements in the list will be integers. * Aim for an efficient solution with linear time complexity. # Additional Notes * Consider edge cases such as input lists with all identical elements or lists with multiple most frequent values. * Ensure your function handles large input sizes effectively without excessive memory usage.","solution":"from collections import Counter from typing import List def find_mode(arr: List[int]) -> List[int]: Returns the mode(s) of the list of integers. If there are multiple values with the same highest frequency, all are returned. if not arr: return [] frequency = Counter(arr) max_frequency = max(frequency.values()) mode = [key for key, value in frequency.items() if value == max_frequency] return mode"},{"question":"# Knapsack Maximum Value Algorithm **Background**: A classic problem in combinatorial optimization is the 0/1 Knapsack problem, where you must maximize the value of items that can be placed into a knapsack with a limited carrying capacity. **Problem Statement**: You are given a number of items, where each item has a particular value and weight. Given a knapsack with a maximum weight capacity, your task is to write a function that returns the maximum summarized value of items that can fit into the knapsack without exceeding the weight capacity. **Function Signature**: ```python def get_maximum_value(items: List[Item], capacity: int) -> int: pass ``` **Input/Output**: - *Input*: - `items`: A list of `Item` objects where each `Item` object has two properties (value and weight). - `capacity`: An integer representing the maximum weight capacity of the knapsack. - *Output*: - Return an integer representing the maximum value that can be obtained without exceeding the capacity. **Example**: ```python items = [Item(60, 5), Item(50, 3), Item(70, 4), Item(30, 2)] capacity = 5 print(get_maximum_value(items, capacity)) # Output: 80 (Items with value 50 and 30) ``` **Constraints**: - 1 ≤ number of items ≤ 100 - 1 ≤ capacity ≤ 1000 - 1 ≤ weight, value of each item ≤ 1000 **Requirements**: - Your solution\'s time complexity should be O(n * m) and space complexity O(m) where `n` is the number of items and `m` is the capacity. **Considerations & Hints**: 1. Implement a dynamic programming solution using a bottom-up approach. 2. Ensure you handle the edge cases where item values or weights are zero. 3. Optimize space usage by iterating the DP table in a reversed manner to avoid overwriting values in the same iteration. Implement the function `get_maximum_value(items, capacity)` to solve this problem.","solution":"from typing import List class Item: def __init__(self, value, weight): self.value = value self.weight = weight def get_maximum_value(items: List[Item], capacity: int) -> int: Returns the maximum summarized value of items that can fit into the knapsack without exceeding the weight capacity. # Initialize a DP array for holding the maximum value at each capacity level dp = [0] * (capacity + 1) for item in items: # Traverse the DP array from right to left to prevent overwriting for c in range(capacity, item.weight - 1, -1): dp[c] = max(dp[c], dp[c - item.weight] + item.value) return dp[capacity]"},{"question":"# Question: Reverse In-Order Traversal of a Binary Search Tree **Context**: In-Order traversal of a Binary Search Tree (BST) naturally traverses the tree in ascending order. For certain applications, you might need to traverse a BST in descending order, which can be achieved through a reverse in-order traversal. Problem Statement: Write a function `reverse_inorder(root: Node) -> List[int]` that performs a reverse in-order traversal (Right, Root, Left) on a given BST and returns a list of values in descending order. **Function Signature**: ```python def reverse_inorder(root: Node) -> List[int]: # Your code here ``` Input: - `root`: The root node of the BST, where `Node` is defined as: ```python class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right ``` Output: - A list of integers representing the nodes\' values in descending order. Constraints: - The number of nodes in the BST will not exceed 10^4. Example: ```python # Example Tree: # 100 # / # 50 150 # / / # 25 75 125 175 if __name__ == \'__main__\': n1 = Node(100) n2 = Node(50) n3 = Node(150) n4 = Node(25) n5 = Node(75) n6 = Node(125) n7 = Node(175) n1.left, n1.right = n2, n3 n2.left, n2.right = n4, n5 n3.left, n3.right = n6, n7 assert reverse_inorder(n1) == [175, 150, 125, 100, 75, 50, 25] ``` Notes: - You can implement this function either iteratively or recursively. - Ensure your solution handles all given constraints and edge cases efficiently.","solution":"from typing import List class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right def reverse_inorder(root: Node) -> List[int]: result = [] def dfs(node): if not node: return # Process right subtree first dfs(node.right) # Process the root node result.append(node.val) # Process left subtree dfs(node.left) dfs(root) return result"},{"question":"Scenario You are tasked with automating a pattern recognition system for a playlist application. Your system needs to identify repeated patterns within a list of song titles. Specifically, you need a function that determines how many times a given list of song titles needs to be repeated such that a target sequence of titles appears as consecutive titles within the repeated list. Task Write a function `minimum_repeats(song_list, target_sequence)` that takes in two lists of strings: - `song_list`: The list of song titles to be repeated. - `target_sequence`: The target sequence of song titles to search for within the repeated list. Your function should return the minimum number of times the `song_list` has to be repeated so that the `target_sequence` appears as a subgroup in the resulting repeated list. If no such repetition can achieve this, return `-1`. Input and Output Formats * **Input**: * `song_list` (List of strings): List of song titles with length between 1 and 10000. * `target_sequence` (List of strings): List of target song titles with length between 1 and 10000. * **Output**: * Return an integer representing the minimum number of repetitions needed, or `-1` if the target sequence cannot be made a substring of the repeated `song_list`. Example * `song_list = [\\"hello\\", \\"world\\"]` * `target_sequence = [\\"world\\", \\"hello\\", \\"world\\"]` Return `2` because [\\"hello\\", \\"world\\", \\"hello\\", \\"world\\"] includes the target sequence. Constraints - Both `song_list` and `target_sequence` consist only of non-empty strings. - The lengths of `song_list` and `target_sequence` do not exceed 10000. Function Signature ```python def minimum_repeats(song_list: List[str], target_sequence: List[str]) -> int: pass ```","solution":"def minimum_repeats(song_list, target_sequence): Returns the minimum number of times the song_list needs to be repeated so that the target_sequence appears as a subgroup in the repeated list. If no such repetition can achieve this, return -1. n = len(song_list) m = len(target_sequence) # Limit to how many times we need to repeat the song_list limit = (m // n) + 2 # We add 2 to cover edge cases for i in range(1, limit + 1): extended_list = song_list * i if list_contains_sublist(extended_list, target_sequence): return i return -1 def list_contains_sublist(larger, smaller): Helper function to determine if smaller is a contiguous sublist of larger. n = len(larger) m = len(smaller) for i in range(n - m + 1): if larger[i:i + m] == smaller: return True return False"},{"question":"You are tasked with implementing a function to perform regular expression matching with support for `.` and `*`. * The `.` character matches any single character. * The `*` character matches zero or more of the preceding element. * The matching should be for the entire input string. Write a function `is_match(s, p)` that takes two inputs: - `s` (a string to be matched) - `p` (a pattern containing the characters `a-z`, `.` and `*`) The function should return a boolean indicating whether the input string `s` matches the pattern `p`. Example Input - s = \\"aa\\", p = \\"a\\" → False - s = \\"aa\\", p = \\"aa\\" → True - s = \\"aaa\\", p = \\"aa\\" → False - s = \\"aa\\", p = \\"a*\\" → True - s = \\"ab\\", p = \\".*\\" → True - s = \\"aab\\", p = \\"c*a*b\\" → True Constraints - You may assume that the given pattern is well-formed. - The strings consist of lowercase alphabets and the characters `.` and `*`. - The pattern will be non-empty and may contain the characters `a-z`, `.` and `*`. Function Signature ```python def is_match(s: str, p: str) -> bool: pass ``` Provide a well-detailed implementation of the `is_match` function. Ensure that all described edge cases are handled and the algorithm\'s complexity is clearly optimized for efficiency.","solution":"def is_match(s, p): Function to perform regular expression matching with support for \'.\' and \'*\'. # Utilize dynamic programming approach to solve the problem efficiently memo = {} def dp(i, j): if (i, j) not in memo: if j == len(p): ans = i == len(s) else: first_match = i < len(s) and p[j] in {s[i], \'.\'} if j + 1 < len(p) and p[j + 1] == \'*\': ans = (dp(i, j + 2) or first_match and dp(i + 1, j)) else: ans = first_match and dp(i + 1, j + 1) memo[i, j] = ans return memo[i, j] return dp(0, 0)"},{"question":"You are tasked with implementing a function that rotates an array of integers to the right by a given number of steps. The function should be optimized for performance and should have minimal space complexity. Additionally, handle edge cases where the array might be empty or the number of rotation steps exceeds the length of the array. # Function Signature ```python def optimized_rotate(array: List[int], k: int) -> List[int]: # Your implementation here ``` # Inputs and Outputs * **Input**: - `array`: List of integers (0 <= len(array) <= 10^5) - `k`: Number of steps to rotate the array (0 <= k <= 10^5) * **Output**: - List of integers representing the array rotated to the right by `k` steps. # Constraints * The function must run in O(n) time complexity. * The function must use O(1) additional space complexity (excluding the input and output arrays). * Consider edge cases: empty array, `k` being larger than length of the array, etc. # Example ```python assert optimized_rotate([1,2,3,4,5,6,7], 3) == [5,6,7,1,2,3,4] assert optimized_rotate([1,2,3,4,5], 2) == [4,5,1,2,3] assert optimized_rotate([1,2], 5) == [2,1] assert optimized_rotate([], 3) == [] assert optimized_rotate([1,1,1,1], 1) == [1, 1, 1, 1] ``` # Instructions 1. Implement the function `optimized_rotate` that follows the specifications. 2. Ensure your solution is optimized for both time and space complexities. 3. Thoroughly test your function with edge cases.","solution":"from typing import List def optimized_rotate(array: List[int], k: int) -> List[int]: Rotates the array to the right by k steps. Parameters: array (List[int]): The input array to be rotated. k (int): Number of steps to rotate the array. Returns: List[int]: The rotated array. if not array: return [] n = len(array) k = k % n # Normalize k to ensure it is within the array bounds # Reverse the entire array array.reverse() # Reverse the first k elements array[:k] = reversed(array[:k]) # Reverse the remaining elements array[k:] = reversed(array[k:]) return array"},{"question":"# Domain Name Parser **Objective:** Write a function that, given a URL as a string, extracts and returns the domain name as a string. Your implementation should handle various URL formats including presence or absence of \\"http://\\", \\"https://\\", and \\"www.\\". **Instructions:** - Implement the function `domain_name(url: str) -> str`: - `url`: A string representing the full URL. - Returns: A string containing only the domain name. **Constraints:** - You are not allowed to use built-in libraries (like `re` for regular expressions or `urlparse`). - However, using the `.split()` built-in function is allowed. **Example Inputs and Outputs:** - `domain_name(\\"http://github.com/SaadBenn\\")` should return `\\"github\\"`. - `domain_name(\\"http://www.zombie-bites.com\\")` should return `\\"zombie-bites\\"`. - `domain_name(\\"https://www.cnet.com\\")` should return `\\"cnet\\"`. **Edge Cases to Consider:** - URLs with no scheme (neither \\"http\\" nor \\"https\\"). - Subdomains or unconventional TLDs. - URLs with extra paths or query parameters.","solution":"def domain_name(url): Extracts the domain name from a given URL string. # Remove protocol (http:// or https://) if url.startswith(\\"http://\\"): url = url[len(\\"http://\\"):] elif url.startswith(\\"https://\\"): url = url[len(\\"https://\\"):] # Remove www. if it exists if url.startswith(\\"www.\\"): url = url[len(\\"www.\\"):] # Split by \'/\' and return the first part which contains the domain domain_with_possible_path = url.split(\'/\')[0] # Split by \'.\' and return the first part which is the actual domain name domain = domain_with_possible_path.split(\'.\')[0] return domain"},{"question":"In this task, you will implement a function to simulate a Markov Chain until it reaches a specified terminal state. Your goal is to extend the functionality of the provided Markov Chain implementation by adding a stopping condition and collecting the sequence of states visited up to that point. You will also ensure that the probabilities are correctly normalized. # Function Signature ```python def simulate_markov_chain(chain, initial_state, terminal_state): Simulates a Markov Chain until the terminal state is reached. Args: - chain (dict): A dictionary representing the Markov Chain. - initial_state (str): The starting state of the Markov Chain. - terminal_state (str): The stopping state of the Markov Chain. Returns: - list: A list of states visited in the order they were visited, including the terminal state. pass ``` # Expected Input and Output Format - **Input**: - `chain`: A dictionary where keys are state names and values are dictionaries that map next states to their transition probabilities. - `initial_state`: A string representing the starting state. - `terminal_state`: A string representing the stopping state. - **Output**: - A list of state names (strings) representing the sequence of states visited, ending with `terminal_state`. # Constraints - The Markov Chain is guaranteed to reach the terminal state eventually. - The transition probabilities for each state sum to 1. - Up to 1000 states and 1000 transitions. # Performance Requirements - Efficiently manage transitions to ensure simulation runs in a reasonable time. # Example ```python chain = { \'A\': {\'B\': 0.5, \'C\': 0.5}, \'B\': {\'A\': 0.3, \'C\': 0.7}, \'C\': {\'C\': 1.0} } initial_state = \'A\' terminal_state = \'C\' simulate_markov_chain(chain, initial_state, terminal_state) # Example Output: [\'A\', \'C\'] ``` **Explanation**: The function simulates transitions starting from `A`, until it reaches the terminal state `C`.","solution":"import random def simulate_markov_chain(chain, initial_state, terminal_state): Simulates a Markov Chain until the terminal state is reached. Args: - chain (dict): A dictionary representing the Markov Chain. - initial_state (str): The starting state of the Markov Chain. - terminal_state (str): The stopping state of the Markov Chain. Returns: - list: A list of states visited in the order they were visited, including the terminal state. current_state = initial_state sequence = [current_state] while current_state != terminal_state: next_state = random.choices( population=list(chain[current_state].keys()), weights=list(chain[current_state].values()) )[0] sequence.append(next_state) current_state = next_state return sequence"},{"question":"# Sorting Plant Watering Times As the gardener in charge of maintaining the garden, you have an array representing the amount of time (in minutes) each plant type needs daily. You realize you need to sort this array in ascending order to prioritize the watering schedule from shortest to longest time. **Task**: Write a function named `sort_watering_times(times)` that uses the Cocktail Shaker Sort algorithm to sort the array of plant watering times in ascending order. **Input**: * `times`: A list of integers where each integer represents the daily watering time required for a plant type. The list can be empty or have up to 1000 elements. **Output**: * The function should return the sorted list of watering times. **Example**: ```python def sort_watering_times(times): # Your implementation here # Example usage print(sort_watering_times([30, 10, 50, 20])) # Output: [10, 20, 30, 50] print(sort_watering_times([])) # Output: [] print(sort_watering_times([15, 10, 10, 20])) # Output: [10, 10, 15, 20] ``` **Constraints**: * 0 <= len(times) <= 1000 * 0 <= time <= 10^6 Think about edge cases such as an empty array, arrays with identical elements, and arrays that may already be sorted. Ensure your implementation maintains a time complexity of O(N^2) for the worst case.","solution":"def sort_watering_times(times): Sorts a list of plant watering times using the Cocktail Shaker Sort algorithm. Parameters: times (list of int): List of daily watering times for different plant types. Returns: list of int: Sorted list of watering times in ascending order. n = len(times) if n <= 1: return times start = 0 end = n - 1 swapped = True while swapped: swapped = False # Forward pass for i in range(start, end): if times[i] > times[i + 1]: times[i], times[i + 1] = times[i + 1], times[i] swapped = True if not swapped: break swapped = False end -= 1 # Backward pass for i in range(end, start, -1): if times[i] < times[i - 1]: times[i], times[i - 1] = times[i - 1], times[i] swapped = True start += 1 return times"},{"question":"# Atbash Cipher Transformation Write a function named `atbash_transform` that applies the Atbash cipher to a given input string and returns the transformed string. Input Format: - A single string `s` where `1 <= len(s) <= 10^6`. The string can contain any printable ASCII characters. Output Format: - A single string that represents the input string transformed using the Atbash cipher. Constraints: - Maintain the case of the letters (uppercase remains uppercase, lowercase remains lowercase). - Non-alphabetic characters (such as spaces, punctuation) should remain unchanged. Performance Requirements: - The solution should have a linear time complexity O(n) relative to the size of the input string. Example: ```python Input: \\"Attack at dawn!\\" Output: \\"Zggzxp zg wzdm!\\" Input: \\"Hello, World!\\" Output: \\"Svool, Dliow!\\" ``` Scenario: Imagine you are working on a project that involves creating a historical cipher tool for educational purposes. Your task is to implement the Atbash cipher transformation function to mimic one of the oldest known ciphers. Implement the `atbash_transform` function in Python. ```python def atbash_transform(s): # Your code here pass ```","solution":"def atbash_transform(s): def transform_char(c): if \'A\' <= c <= \'Z\': return chr(ord(\'Z\') - (ord(c) - ord(\'A\'))) elif \'a\' <= c <= \'z\': return chr(ord(\'z\') - (ord(c) - ord(\'a\'))) else: return c return \'\'.join(transform_char(c) for c in s)"},{"question":"Scenario You have been provided with a sorting algorithm known as Cocktail Shaker Sort that works by alternating sorting directions through a list. Now, you\'re required to implement this sorting algorithm with some additional constraints and optimizations to enhance its efficiency. Objective Write a function that sorts an integer list using the principles of Cocktail Shaker Sort but includes an optimization to skip already sorted sections after each pass. Function Signature ```python def optimized_cocktail_shaker_sort(arr: List[int]) -> List[int]: Optimized Cocktail Shaker Sort Function Parameters: arr (List[int]): A list of integers to be sorted. Returns: List[int]: The sorted list. ``` Input * A list of integers `arr` where `1 <= len(arr) <= 10^5` and `-10^6 <= arr[i] <= 10^6`. Output * A list of integers, sorted in ascending order. Constraints * You need to optimize your function to handle the input size effectively by minimizing redundant comparisons. * Expected time complexity should be better than the naive implementation for partially sorted arrays. * Function should maintain stability (relative order of equal elements). Example ```python assert optimized_cocktail_shaker_sort([5, 1, 4, 2, 8, 0, 2]) == [0, 1, 2, 2, 4, 5, 8] assert optimized_cocktail_shaker_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] assert optimized_cocktail_shaker_sort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5] assert optimized_cocktail_shaker_sort([]) == [] ``` Constraints * The solution must be efficient and fit within the time limits for large inputs (up to 100,000 elements).","solution":"from typing import List def optimized_cocktail_shaker_sort(arr: List[int]) -> List[int]: Optimized Cocktail Shaker Sort Function Parameters: arr (List[int]): A list of integers to be sorted. Returns: List[int]: The sorted list. if len(arr) <= 1: return arr start = 0 end = len(arr) - 1 while start <= end: swapped = False # Forward pass for i in range(start, end): if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] swapped = True if not swapped: break end -= 1 swapped = False # Backward pass for i in range(end, start, -1): if arr[i] < arr[i - 1]: arr[i], arr[i - 1] = arr[i - 1], arr[i] swapped = True if not swapped: break start += 1 return arr"},{"question":"# Range Minimum/Maximum Segment Tree Consider a segment tree which allows you to efficiently compute the minimum or maximum in a range of an array. Implement the segment tree data structure to support these operations: * `SegmentTree(arr, function)`: Initializes the segment tree with an array `arr` and a specified function (e.g., `min` or `max`). * `query(L, R)`: Returns the result of the function applied to the range `L` to `R` (inclusive) in the array. # Input 1. **Initialization**: An integer array `arr` of length `N`. 2. **Function**: A function (`min` or `max`). 3. **Queries**: Each query provides two integers `L` and `R` representing the range (0-indexed) within which the minimum or maximum should be computed. # Output For each query, output a single integer which is the result of the function applied to elements in the range `[L, R]`. # Constraints * `1 <= N <= 10^5` * `0 <= arr[i] <= 10^5` * `0 <= L <= R < N` * Function must be either `min` or `max`. # Example ```python # Example usage arr = [2, 4, 5, 3, 4] seg_tree = SegmentTree(arr, min) print(seg_tree.query(2, 4)) # Output: 3 print(seg_tree.query(0, 3)) # Output: 2 arr = [4, 5, 2, 3, 4, 43, 3] seg_tree = SegmentTree(arr, max) print(seg_tree.query(1, 5)) # Output: 43 print(seg_tree.query(0, 3)) # Output: 5 ``` # Task 1. Implement the `SegmentTree` class in Python with the described functionality. 2. **Ensure** that your implementation handles large inputs efficiently. 3. **Verify** that your solution addresses edge cases and common performance bottlenecks.","solution":"class SegmentTree: def __init__(self, arr, function): Initializes the segment tree with an array `arr` and a specified function (e.g., `min` or `max`). self.n = len(arr) self.func = function self.tree = [0] * (2 * self.n) # Building the tree for i in range(self.n): self.tree[self.n + i] = arr[i] for i in range(self.n - 1, 0, -1): self.tree[i] = self.func(self.tree[i * 2], self.tree[i * 2 + 1]) def query(self, L, R): Returns the result of the function applied to the range `L` to `R` (inclusive) in the array. L += self.n R += self.n + 1 result = None while L < R: if L % 2: if result is None: result = self.tree[L] else: result = self.func(result, self.tree[L]) L += 1 if R % 2: R -= 1 if result is None: result = self.tree[R] else: result = self.func(result, self.tree[R]) L //= 2 R //= 2 return result"},{"question":"# Strongly Connected Directed Graph Checker Given a directed graph with `V` vertices and `E` edges, implement a function to determine if the graph is strongly connected. A directed graph is strongly connected if there is a path between any two vertices in both directions (i.e., for any pair of vertices u and v, there is a path from u to v and from v to u). # Function Signature ```python def is_graph_strongly_connected(vertex_count: int, edges: List[Tuple[int, int]]) -> bool: ``` # Input * `vertex_count` (int): The number of vertices in the graph, V (1 ≤ V ≤ 1000). * `edges` (List[Tuple[int, int]]): A list of edges where each edge is represented as a tuple (source, target). # Output * (bool): Return `True` if the graph is strongly connected, otherwise return `False`. # Constraints * The graph is directed. * Vertices are numbered from 0 to V-1. * No self-loops or multiple edges are included in the input. # Example ```python assert is_graph_strongly_connected(5, [(0, 1), (1, 2), (2, 0), (1, 3), (3, 4), (4, 1)]) == True assert is_graph_strongly_connected(4, [(0, 1), (1, 2), (2, 3)]) == False ``` # Explanation * In the first example, every vertex can reach every other vertex either directly or through intermediate vertices in both directions. * In the second example, not all vertices can reach each other, hence it\'s not strongly connected. # Hints * Implement depth-first search (DFS) to traverse and check reachability of vertices. * Consider reversing the graph\'s edges to check reachability in the reverse direction. * You can use an adjacency list to represent the graph.","solution":"from typing import List, Tuple def is_graph_strongly_connected(vertex_count: int, edges: List[Tuple[int, int]]) -> bool: from collections import defaultdict, deque def bfs(start_vertex: int, graph: defaultdict): visited = [False] * vertex_count queue = deque([start_vertex]) visited[start_vertex] = True while queue: vertex = queue.popleft() for neighbor in graph[vertex]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) return visited # Create adjacency list for the graph graph = defaultdict(list) for u, v in edges: graph[u].append(v) # Check reachability from the first vertex start_vertex = 0 reachable_from_start = bfs(start_vertex, graph) if not all(reachable_from_start): return False # Create the reversed graph reversed_graph = defaultdict(list) for u, v in edges: reversed_graph[v].append(u) # Check reachability in the reversed graph reachable_from_start_reversed = bfs(start_vertex, reversed_graph) if not all(reachable_from_start_reversed): return False return True"},{"question":"# Bucket Sort Enhancement You are provided with an implementation of the Bucket Sort algorithm which uses `next_sort` (insertion sort) to sort elements within each bucket. This implementation has a time complexity of O(n^2) in the worst case due to the use of insertion sort. Your task is to improve the performance of this algorithm by implementing a more efficient sorting function to replace `next_sort`. Problem Statement Implement the function `optimized_sort` which will be used to sort each bucket more efficiently. Use `optimized_sort` in place of `next_sort` within the `bucket_sort` function. # Enhanced Bucket Sort Algorithm The `bucket_sort` function should use `optimized_sort` which you will implement. Ensure the overall bucket sorting mechanism remains the same, but improve the sorting within buckets to reduce worst-case time complexity. Function Signature ```python def optimized_sort(arr: list) -> list: Sort the input list using a more efficient sorting algorithm and return the sorted list. ``` Constraints - Each input to `optimized_sort` will be a list of integers provided by `bucket_sort` function. - You may choose any efficient comparison-based sorting algorithm (e.g., Merge Sort or Timsort) for your implementation of `optimized_sort`. - Ensure your `optimized_sort` implementation maintains the stability of sorting. Input & Output Formats - `optimized_sort` input: A list of integers `arr`. - `optimized_sort` output: Sorted list of integers. Example Suppose the `bucket_sort` function is called on the list `[29, 25, 3, 49, 9, 37, 21, 43]`. Below is a scenario demonstrating how `optimized_sort` should be used. ```python def bucket_sort(arr): num_buckets = len(arr) buckets = [[] for _ in range(num_buckets)] for value in arr: index = value * num_buckets // (max(arr) + 1) buckets[index].append(value) sorted_list = [] for i in range(num_buckets): sorted_list.extend(optimized_sort(buckets[i])) return sorted_list # Example usage arr = [29, 25, 3, 49, 9, 37, 21, 43] print(bucket_sort(arr)) # Should print the sorted list ```","solution":"def optimized_sort(arr): Sort the input list using Timsort (as implemented by Python\'s sorted function) and return the sorted list. return sorted(arr) def bucket_sort(arr): if not arr: return arr num_buckets = len(arr) max_value = max(arr) buckets = [[] for _ in range(num_buckets)] for value in arr: index = value * num_buckets // (max_value + 1) buckets[index].append(value) sorted_list = [] for i in range(num_buckets): sorted_list.extend(optimized_sort(buckets[i])) return sorted_list"},{"question":"Problem Description You are given an array of integers sorted in increasing order and a collection of new integers to be inserted into the array one by one. Your task is to create a function that performs these insertions such that the array remains sorted after each insertion. To achieve this efficiently, you will use a binary search method to determine the insertion position. Implement the function `sorted_insertion(array, new_elements)` that takes two arguments: 1. `array`: A list of integers sorted in increasing order. 2. `new_elements`: A list of integers to be inserted into `array`. The function should return the updated array after all insertions are complete. # Input * `array`: A list of integers, sorted in increasing order. * `new_elements`: A list of integers to be inserted into `array`. # Output * A new list that represents the sorted array after each insertion. # Constraints * `1 <= len(array) <= 10^4` * `0 <= len(new_elements) <= 10^4` * `-10^5 <= array[i], new_elements[i] <= 10^5` # Performance Requirements The insertion operations should be done efficiently, considering both the binary search for determining the position and the necessary shifts for insertion. Example ```python def search_insert(array, val): low = 0 high = len(array) - 1 while low <= high: mid = low + (high - low) // 2 if val > array[mid]: low = mid + 1 else: high = mid - 1 return low def sorted_insertion(array, new_elements): for val in new_elements: pos = search_insert(array, val) array.insert(pos, val) return array # Test Case 1 array = [1, 3, 5, 6] new_elements = [2, 4, 7] # After inserting 2: [1, 2, 3, 5, 6] # After inserting 4: [1, 2, 3, 4, 5, 6] # After inserting 7: [1, 2, 3, 4, 5, 6, 7] assert sorted_insertion(array, new_elements) == [1, 2, 3, 4, 5, 6, 7] # Test Case 2 array = [1, 3, 3, 3, 5] new_elements = [3, 2, 4] # After inserting 3: [1, 3, 3, 3, 3, 5] # After inserting 2: [1, 2, 3, 3, 3, 3, 5] # After inserting 4: [1, 2, 3, 3, 3, 3, 4, 5] assert sorted_insertion(array, new_elements) == [1, 2, 3, 3, 3, 3, 4, 5] ```","solution":"def search_insert(array, val): Use binary search to find the index where to insert \'val\' to keep the \'array\' sorted. low = 0 high = len(array) - 1 while low <= high: mid = low + (high - low) // 2 if val > array[mid]: low = mid + 1 else: high = mid - 1 return low def sorted_insertion(array, new_elements): Insert each element from \'new_elements\' into \'array\' maintaining sorted order. for val in new_elements: pos = search_insert(array, val) array.insert(pos, val) return array"},{"question":"You are given an n x n matrix that represents a set of linear equations. Your task is to write a function, `invert_matrix`, that returns the inverse of the input matrix using the matrix inversion algorithm. # Function Signature: ```python def invert_matrix(matrix): ``` # Input: - `matrix`: A list of lists representing an n x n matrix. Each inner list corresponds to a row of the matrix. The matrix elements are integers or floats. # Output: - A list of lists representing the inverted matrix, if the input matrix is invertible. If the matrix is non-invertible (singular or not square), return an appropriate error matrix as defined below: - `[[ -1 ]]` if the input is not a matrix. - `[[ -2 ]]` if the matrix is not square. - `[[ -3 ]]` if the matrix is smaller than 2x2. - `[[ -4 ]]` if the matrix is singular (determinant = 0). # Constraints: - The matrix size is 2 ≤ n ≤ 10. - Matrix elements are within the range of -100 ≤ element ≤ 100. # Examples: 1. Input: ```python matrix = [[4, 7], [2, 6]] ``` Output: ```python [[0.6, -0.7], [-0.2, 0.4]] ``` 2. Input: ```python matrix = [[1, 2], [1, 2]] ``` Output: ```python [[-4]] ``` 3. Input: ```python matrix = [[5]] ``` Output: ```python [[-3]] ``` 4. Input: ```python matrix = [[4, 7, 3], [2, 6, 1]] ``` Output: ```python [[-2]] ``` # Note: - Make sure to handle edge cases and validate input types and sizes. - Focus on creating a modular implementation separating different steps of matrix inversion. - You can use helper functions as required.","solution":"import numpy as np def invert_matrix(matrix): Returns the inverse of the matrix if invertible, otherwise returns an error matrix based on the error type. # Check if input is actually a matrix if not isinstance(matrix, list) or not all(isinstance(row, list) for row in matrix): return [[-1]] # Check if matrix is square n = len(matrix) if any(len(row) != n for row in matrix): return [[-2]] # Check if matrix is smaller than 2x2 if n < 2: return [[-3]] # Convert matrix to numpy array for inversion try: np_matrix = np.array(matrix, dtype=float) inv_matrix = np.linalg.inv(np_matrix).tolist() return inv_matrix except np.linalg.LinAlgError: return [[-4]]"},{"question":"# Minimum Spanning Tree Implementation Using Kruskal\'s Algorithm Problem Description You are given an undirected, connected graph G with V vertices and E edges. Each edge has a weight associated with it. Your task is to implement Kruskal\'s algorithm to find the Minimum Spanning Tree (MST) of the graph and return its total weight. The graph is represented by vertices numbered from 0 to V-1 and edges defined in the form (source, target, weight). Input - An integer V (number of vertices). - An integer E (number of edges). - Following E lines, each containing three integers: source, target, and weight of the edge. Output - An integer representing the total weight of the MST. Constraints - 1 ≤ V ≤ 10^5 - 0 ≤ E ≤ 3 * 10^5 - The graph is connected, i.e., there is at least one path between any pair of vertices. Example **Input:** ``` 5 6 0 1 3 0 2 8 1 3 5 2 3 2 2 4 4 3 4 6 ``` **Output:** ``` 14 ``` Explanation The input describes a graph with 5 vertices and 6 edges. The MST includes edges (2, 3), (0, 1), (2, 4), and (1, 3) with a total weight of 2 + 3 + 4 + 5 = 14. Notes - Implement a Disjoint Set data structure to assist in finding and merging sets. - Use edge list representation for the graph and Kruskal\'s algorithm to select edges for the MST. Function Signature ```python def kruskal_mst(V: int, edges: List[Tuple[int, int, int]]) -> int: pass ``` **Requirements**: - Ensure your implementation addresses edge cases like large graphs and duplicate edge weights. - The solution should be efficient and handle the upper bounds of constraints smoothly.","solution":"from typing import List, Tuple class DisjointSet: def __init__(self, n): self.parent = list(range(n)) self.rank = [0] * n def find(self, u): if self.parent[u] != u: self.parent[u] = self.find(self.parent[u]) # Path compression return self.parent[u] def union(self, u, v): root_u = self.find(u) root_v = self.find(v) if root_u != root_v: if self.rank[root_u] > self.rank[root_v]: self.parent[root_v] = root_u elif self.rank[root_u] < self.rank[root_v]: self.parent[root_u] = root_v else: self.parent[root_v] = root_u self.rank[root_u] += 1 def kruskal_mst(V: int, edges: List[Tuple[int, int, int]]) -> int: Applies Kruskal\'s algorithm to find and return the total weight of the Minimum Spanning Tree (MST) of a graph. :param V: An integer, the number of vertices in the graph. :param edges: A list of tuples, where each tuple contains three integers -- (source, target, weight) representing an edge. :return: An integer representing the total weight of the MST. # Sort edges by weight edges.sort(key=lambda edge: edge[2]) # Initialize Disjoint Set ds = DisjointSet(V) mst_weight = 0 for u, v, weight in edges: if ds.find(u) != ds.find(v): ds.union(u, v) mst_weight += weight return mst_weight"},{"question":"Your task is to implement a function that finds the missing number from a given list of unique integers in the range [0..n] using the XOR method. Each integer in the list is unique, and there should be exactly one missing number. If the sequence is already complete (i.e., all numbers in the range are present), your function should return the next integer in the sequence. Your function should comply with the expected input and output described below: Function Signature ```python def find_missing_number(nums: List[int]) -> int: ``` Input - `nums` (List[int]): A list of unique integers within the range [0..n], where `n` is the length of the list. The list will have exactly one missing integer from this range. Output - (int): The missing integer from the range, or the next integer in the sequence if no missing number is found (next integer will be `n`). Constraints - The list will contain `n` unique integers, where 0 ≤ nums[i] ≤ n and the length of nums is `n`. - No element will appear more than once in the input list. # Example **Example 1:** ``` Input: [4, 1, 3, 0, 6, 5, 2] Output: 7 ``` **Example 2:** ``` Input: [3, 7, 1, 2, 8, 4, 5, 0, 6] Output: 9 ``` **Example 3:** ``` Input: [0, 1, 2, 4, 5, 6] Output: 3 ``` Explanation - The function should iterate through the list while applying XOR operations to find the missing number efficiently. - Consider edge cases such as empty list or list containing maximum elements in the range. Notes - Remember to handle both the XOR method and ensure the constraints are maintained in your code. - Ensure to test and validate your function with various edge cases.","solution":"from typing import List def find_missing_number(nums: List[int]) -> int: n = len(nums) complete_range_xor = 0 nums_xor = 0 # XOR all numbers from 0 to n for i in range(n + 1): complete_range_xor ^= i # XOR all numbers in the list for num in nums: nums_xor ^= num # The missing number is the XOR of these two results return complete_range_xor ^ nums_xor"},{"question":"**Title**: Optimal Matrix Chain Multiplication **Question**: Given a sequence of matrices, your task is to determine the most efficient way to multiply these matrices together. The goal is to find the optimal parenthesization of the matrix chain product, such that the total number of scalar multiplications is minimized. You should implement this using the dynamic programming approach as discussed. **Function Signature**: ```python def optimal_matrix_chain_order(dimensions: list[int]) -> (int, list[list[int]]): :param dimensions: A list of integers where the i-th integer represents the number of rows in the i-th matrix and the (i+1)-th integer represents the number of columns of the i-th matrix. :return: A tuple where the first element is an integer representing the minimum number of scalar multiplications required and the second element is a 2D list representing the parenthesization scheme. pass ``` **Explanation**: * Input: - `dimensions`: A list of integers where dimensions[i-1] x dimensions[i] represent the dimension of the i-th matrix. - Example: For matrices A1 (30x35), A2 (35x15), A3 (15x5), A4 (5x10), A5 (10x20), A6 (20x25), the input list would be [30, 35, 15, 5, 10, 20, 25]. * Output: - The function should return a tuple: - The minimum number of scalar multiplications needed. - A 2D list indicating the optimal split points between matrices. * Example: ```python dimensions = [30, 35, 15, 5, 10, 20, 25] optimal_matrix_chain_order(dimensions) ``` Output: ``` (15125, [[0, 0, 0, 0, 0, 0, 0], [0, 0, 15750, 7875, 9375, 11875, 15125], [0, 0, 0, 2625, 4375, 7125, 10500], [0, 0, 0, 0, 750, 2500, 5375], [0, 0, 0, 0, 0, 1000, 3500], [0, 0, 0, 0, 0, 0, 5000], [0, 0, 0, 0, 0, 0, 0]]) ``` **Constraints**: - 1 <= len(dimensions) <= 100 - All elements in the `dimensions` list are positive integers. **Performance Requirements**: - Your function should be able to handle input sizes up to 100 matrices efficiently within a reasonable time frame due to O(n^3) complexity. **Testing**: - Write unit tests to ensure your function works with various edge cases including the minimal case, large input size, and invalid inputs gracefully. Note: Implementing an additional `print_optimal_solution` function for visualizing the parenthesization is optional but recommended for a deeper understanding.","solution":"def optimal_matrix_chain_order(dimensions): n = len(dimensions) - 1 m = [[0 for x in range(n + 1)] for x in range(n + 1)] s = [[0 for x in range(n + 1)] for x in range(n + 1)] for l in range(2, n + 1): for i in range(1, n - l + 2): j = i + l - 1 m[i][j] = float(\'inf\') for k in range(i, j): q = m[i][k] + m[k+1][j] + dimensions[i-1] * dimensions[k] * dimensions[j] if q < m[i][j]: m[i][j] = q s[i][j] = k return m[1][n], s # Helper function to print the optimal parenthesization def print_optimal_parens(s, i, j): if i == j: return f\\"A{i}\\" else: return \\"(\\" + print_optimal_parens(s, i, s[i][j]) + \\" x \\" + print_optimal_parens(s, s[i][j] + 1, j) + \\")\\" # Example usage: # dimensions = [30, 35, 15, 5, 10, 20, 25] # min_cost, split_points = optimal_matrix_chain_order(dimensions) # print(\\"Minimum number of multiplications is:\\", min_cost) # print(\\"Optimal parenthesization is:\\", print_optimal_parens(split_points, 1, len(dimensions) - 1))"},{"question":"# Scenario A digital signature algorithm requires the use of modular inverses to secure data. Given integers ( a ) and ( m ), you need to compute the modular inverse of ( a ) modulo ( m ). If the modular inverse doesn\'t exist (i.e., ( a ) and ( m ) are not coprime), the function should return -1. # Task Implement the function `compute_modular_inverse(a: int, m: int) -> int` to find the modular inverse of `a` modulo `m`. # Specifications * Input: Two integers `a` and `m` where ( 1 leq a, m leq 10^9 ). * Output: An integer representing the modular inverse or -1 if it does not exist. # Constraints * The function should handle large input values efficiently. * Do not use any in-built library functions that directly compute the modular inverse. # Function Signature ```python def compute_modular_inverse(a: int, m: int) -> int: # Implementation here pass ``` # Example ```python assert compute_modular_inverse(3, 11) == 4 # Explanation: 3 * 4 = 12, 12 % 11 = 1 assert compute_modular_inverse(10, 20) == -1 # Explanation: 10 and 20 are not coprime ``` # Note * Use the `extended_gcd` function to compute the necessary coefficients for solving the modular inverse. * Handle exceptions and edge cases as described in the analysis section.","solution":"def extended_gcd(a, b): Extended Euclidean Algorithm to find the coefficients x and y such that: ax + by = gcd(a, b) if a == 0: return b, 0, 1 gcd, x1, y1 = extended_gcd(b % a, a) x = y1 - (b // a) * x1 y = x1 return gcd, x, y def compute_modular_inverse(a: int, m: int) -> int: Computes the modular inverse of `a` modulo `m` using the Extended Euclidean Algorithm. Returns -1 if the modular inverse does not exist. gcd, x, _ = extended_gcd(a, m) if gcd != 1: return -1 # modular inverse does not exist else: return x % m # modular inverse exists and is x modulo m"},{"question":"# Scenario: You are implementing a simplified lexical analyzer for a new programming language. As part of this task, you will develop a function to determine if a given string of characters represents an acceptable identifier in the programming language using a DFA. # Problem Statement: Design a function `is_valid_identifier(transitions, start, final, string)` that takes the following parameters: * `transitions`: A dictionary representing the state transitions of the DFA where keys are state labels and values are dictionaries mapping input characters to state labels. * `start`: A label (string) indicating the initial state of the DFA. * `final`: A list of labels indicating the acceptable final states of the DFA. * `string`: The input string to be analyzed for validity as an identifier. The function should return `True` if the string is accepted by the DFA and `False` otherwise. # Input: * `transitions`: Dictionary format is `{state: {char: state, ...}, ...}` * `start`: String (e.g., \'q0\') * `final`: List of strings (e.g., [\'q1\', \'q2\']) * `string`: String to check (e.g., \'abc123\') # Output: * Boolean value: `True` if the string is accepted, `False` otherwise. # Constraints: * The input string will only contain alphanumeric characters and underscores. * The transition dictionary will cover all necessary transitions. # Example: Given the following DFA definition: ```python transitions = { \'q0\': {\'a\': \'q1\', \'b\': \'q2\', \'c\': \'q2\', \'_\': \'q3\'}, \'q1\': {\'1\': \'q1\', \'2\': \'q1\', \'3\': \'q1\'}, \'q2\': {\'4\': \'q2\', \'5\': \'q2\', \'6\': \'q2\'}, \'q3\': {\'7\': \'q3\', \'8\': \'q3\', \'9\': \'q3\'} } start = \'q0\' final = [\'q1\', \'q2\'] string = \'a123\' # The function should return True since \'a123\' is an acceptable identifier. ``` Implement the function `is_valid_identifier(transitions, start, final, string)` as described. ```python def is_valid_identifier(transitions, start, final, string): num = len(string) cur = start for i in range(num): if string[i] not in transitions[cur]: return False else: cur = transitions[cur][string[i]] return cur in final # Test the function with the provided example: transitions = { \'q0\': {\'a\': \'q1\', \'b\': \'q2\', \'c\': \'q2\', \'_\': \'q3\'}, \'q1\': {\'1\': \'q1\', \'2\': \'q1\', \'3\': \'q1\'}, \'q2\': {\'4\': \'q2\', \'5\': \'q2\', \'6\': \'q2\'}, \'q3\': {\'7\': \'q3\', \'8\': \'q3\', \'9\': \'q3\'} } start = \'q0\' final = [\'q1\', \'q2\'] string = \'a123\' print(is_valid_identifier(transitions, start, final, string)) # Should output: True ```","solution":"def is_valid_identifier(transitions, start, final, string): This function determines if the given string is a valid identifier according to the provided DFA transitions. :param transitions: Dictionary representing DFA state transitions. :param start: Initial state of the DFA. :param final: List of acceptable final states. :param string: The string to be validated. :return: True if the string is accepted by the DFA, False otherwise. current_state = start for char in string: if char not in transitions[current_state]: return False current_state = transitions[current_state][char] return current_state in final"},{"question":"# Question: Minimum Steps to Make Strings Equal Given two words `word1` and `word2`, you must find the minimum number of steps required to make both words the same. The only allowed operation is deleting characters from either of the strings. Your task is to implement the function `min_distance(word1: str, word2: str) -> int` using a Dynamic Programming approach: Function Signature: ```python def min_distance(word1: str, word2: str) -> int: pass ``` # Input Format * Both `word1` and `word2` are non-empty strings consisting of lowercase English letters. # Output Format * Return an integer representing the minimum number of steps required. # Constraints * The length of `word1` should be up to 500. * The length of `word2` should be up to 500. # Example ```python # Example 1 word1 = \\"sea\\" word2 = \\"eat\\" print(min_distance(word1, word2)) # Output: 2 # Example 2 word1 = \\"leetcode\\" word2 = \\"etco\\" print(min_distance(word1, word2)) # Output: 4 ``` Explanation * In the first example, \\"sea\\" can be transformed into \\"ea\\" by deleting the \'s\' and \\"eat\\" can be transformed into \\"ea\\" by deleting the \'t\'. This requires two deletions: hence, the minimum distance is 2. * In the second example, \\"leetcode\\" can be transformed to \\"etco\\" by deleting \\"lee\\" and \\"d\\". The \\"dco\\" can be retained from the second string. # Notes 1. The solution should optimally use dynamic programming to ensure it runs efficiently within the given constraints. 2. Consider edge cases such as when the strings have no common characters. 3. Ensure to handle base cases correctly to avoid any overflow or boundary issues in your DP table.","solution":"def min_distance(word1: str, word2: str) -> int: # Lengths of the given words m, n = len(word1), len(word2) # Create a DP table to store the results of subproblems dp = [[0] * (n + 1) for _ in range(m + 1)] # Initialize the table for the base cases for i in range(m + 1): for j in range(n + 1): if i == 0: dp[i][j] = j elif j == 0: dp[i][j] = i elif word1[i - 1] == word2[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = 1 + min(dp[i - 1][j], dp[i][j - 1]) # The answer is in the bottom-right cell of the table return dp[m][n]"},{"question":"# Binary Search Tree Balanced Insertion Algorithm Context A Binary Search Tree (BST) is effective but can degenerate into a linked list in the worst case, especially with sequential data insertions. To mitigate this, we need to implement a balanced insertion mechanism. This ensures that the height of the tree remains as small as possible, maintaining efficient performance for insertions, deletions, and lookups. Task Implement a function `bst_insert_balanced()` that balances the BST after each insertion. You are provided with a basic BST implementation (given above). Your task is to modify only the insertion part to ensure the tree remains balanced. Function Signature ```python def bst_insert_balanced(tree, value): Inserts a value into the BST while keeping it balanced. Args: tree: An instance of the `BST` class. value: The integer value to insert. Returns: None ``` Input * `tree`: A BST object reference. * `value`: Integer value to be inserted. Output No return value. Modify the tree in place. Constraints * Each inserted value is unique. * Number of operations cannot exceed O(log N) in the average case. Requirements 1. The BST should maintain its property of ordered nodes. 2. Ensure the tree remains balanced, using AVL rotations or other self-balancing techniques after each insertion. 3. Implement additional helper functions if needed within the `bst_insert_balanced` to facilitate balancing. Example ```python bst = BST() bst_insert_balanced(bst, 20) bst_insert_balanced(bst, 10) bst_insert_balanced(bst, 30) bst_insert_balanced(bst, 25) bst_insert_balanced(bst, 40) # Resulting tree should maintain balanced nature # You can verify by checking the tree height and structure ``` Note: You may extend the BST class or implement necessary balancing mechanisms (like AVL rotations) within the `bst_insert_balanced`. Modify the `BST` class only if essential. Testing Use the provided unittest framework to test your implementation. Consider edge cases like: * Insertions into an empty tree. * Sequences causing the tree to become unbalanced if naive insertion is done. * Tree rebalancing after multiple insertions.","solution":"class TreeNode: def __init__(self, key): self.left = None self.right = None self.height = 1 # Height of node in the AVL tree self.key = key class BST: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = TreeNode(key) else: self.root = bst_insert_balanced(self.root, key) def bst_insert_balanced(node, key): Inserts a key into the tree starting at node while keeping the tree balanced. if not node: return TreeNode(key) if key < node.key: node.left = bst_insert_balanced(node.left, key) else: node.right = bst_insert_balanced(node.right, key) # Update the height of the ancestor node node.height = 1 + max(get_height(node.left), get_height(node.right)) # Get the balance factor balance = get_balance(node) # If the node becomes unbalanced, then there are 4 cases: # Left Left Case if balance > 1 and key < node.left.key: return rotate_right(node) # Right Right Case if balance < -1 and key > node.right.key: return rotate_left(node) # Left Right Case if balance > 1 and key > node.left.key: node.left = rotate_left(node.left) return rotate_right(node) # Right Left Case if balance < -1 and key < node.right.key: node.right = rotate_right(node.right) return rotate_left(node) return node def rotate_left(z): y = z.right T2 = y.left # Perform rotation y.left = z z.right = T2 # Update heights z.height = 1 + max(get_height(z.left), get_height(z.right)) y.height = 1 + max(get_height(y.left), get_height(y.right)) # Return the new root return y def rotate_right(z): y = z.left T3 = y.right # Perform rotation y.right = z z.left = T3 # Update heights z.height = 1 + max(get_height(z.left), get_height(z.right)) y.height = 1 + max(get_height(y.left), get_height(y.right)) # Return the new root return y def get_height(node): if not node: return 0 return node.height def get_balance(node): if not node: return 0 return get_height(node.left) - get_height(node.right)"},{"question":"# String Reversal Assessment Scenario Imagine you are working on a text processing system where reversing the order of characters within strings is a critical operation. You need to implement robust string reversal techniques to improve various parts of the system. We will test your understanding by asking you to implement a string reversal function based on the recursive methodology described. Task Implement a function `recursive_reverse(s: str) -> str` that takes a string input `s` and returns the reversed string using a recursive approach. Input Format * A single string `s` where: * (0 leq text{len}(s) leq 10^4) Output Format * A single string which is the reverse of the input string. Example ```python >>> recursive_reverse(\\"hello\\") \\"olleh\\" >>> recursive_reverse(\\"world\\") \\"dlrow\\" >>> recursive_reverse(\\"\\") \\"\\" >>> recursive_reverse(\\"a\\") \\"a\\" ``` Constraints * Ensure your solution handles strings of up to 10,000 characters efficiently. * Avoid exceeding the recursion limit. Consider constraint handling and optimizations if necessary. Notes Use the principles and challenges outlined in the analysis to guide your implementation.","solution":"def recursive_reverse(s: str) -> str: Recursively reverses the input string s and returns the reversed string. if len(s) == 0: return s return s[-1] + recursive_reverse(s[:-1])"},{"question":"Problem Statement # Objective Write a function `simplify_path` that takes a Unix-style absolute file path and returns its simplified canonical path. # Detailed Requirements 1. The function should remove any redundant slashes. 2. The function should resolve any `.` segments (representing current directory). 3. The function should resolve any `..` segments (representing parent directory). 4. The simplified path must start with a single `/`. # Expected Input and Output Formats Input * The input will be a single string which is an absolute Unix-style file path. - Example: \\"/home//foo/\\" Output * The function must return a canonical simplified path string. - Example: \\"/home/foo\\" # Constraints * The input path will only contain ASCII characters. * The input path will be a valid Unix-style absolute path. * The length of the input path will not exceed 3000 characters. # Performance Requirements * Your solution should have a linear time complexity O(N), where N is the length of the input path. * Use space efficiently, with a preference for O(N) space complexity. # Example Scenarios * Example 1: - **Input**: `\\"/home/\\"` - **Output**: `\\"/home\\"` * Example 2: - **Input**: `\\"/a/./b/../../c/\\"` - **Output**: `\\"/c\\"` * Example 3: - **Input**: `\\"/../\\"` - **Output**: `\\"/\\"` * Example 4: - **Input**: `\\"/home//foo/\\"` - **Output**: `\\"/home/foo\\"` # Function Signature ```python def simplify_path(path: str) -> str: pass ``` # Notes * Ensure that your function handles edge cases such as extra \'..\' at the root level, multiple or trailing slashes correctly. * You are **not** allowed to import or use any external libraries or functions like `os.path.abspath`.","solution":"def simplify_path(path: str) -> str: Simplifies the given Unix-style absolute path and returns its canonical form. # Split the path by slashes parts = path.split(\'/\') # Use a stack to process the path components stack = [] for part in parts: if part == \'\' or part == \'.\': # Skip empty parts and current directory symbols (.) continue elif part == \'..\': # Pop from the stack if possible, which means going one directory up if stack: stack.pop() else: # Append the part to the stack stack.append(part) # Join the stack to form the canonical path canonical_path = \'/\' + \'/\'.join(stack) return canonical_path"},{"question":"# Problem Context A non-profit organization is trying to identify the most frequent donors who have not donated in the past week. They have a list of donor ids where some ids repeat if a donor has contributed multiple times during that week. They need to identify the first donor who contributed only once during that week. # Problem Statement Write a function `first_unique_char(donors)` that takes a string `donors` containing donor ids and returns the index of the first unique donor id in the given string. If there is no unique donor id, return -1. # Function Signature ```python def first_unique_char(donors: str) -> int: ``` # Input * `donors`: a string of alphanumeric characters representing donor ids (1 ≤ `len(donors)` ≤ 10^5). # Output * An integer representing the index of the first non-repeating donor id. If every donor id repeats, return -1. # Examples ```python assert first_unique_char(\\"abcabc\\") == -1 assert first_unique_char(\\"aabcbd\\") == 3 assert first_unique_char(\\"z\\") == 0 assert first_unique_char(\\"\\") == -1 ``` # Constraints * Your solution should run in O(n) time complexity. * Optimize for space where possible. # Additional Notes The donors might contain both uppercase and lowercase letters and digits. For the purpose, uppercase and lowercase should be considered different.","solution":"def first_unique_char(donors: str) -> int: Returns the index of the first unique donor id in the string. If no unique donor id exists, return -1. from collections import Counter # Count the frequency of each character in the donors string count = Counter(donors) # Find the first unique character by checking their counts for index, char in enumerate(donors): if count[char] == 1: return index return -1"},{"question":"# Problem Description You are required to implement a function that performs sorting on an array using the Bubble Sort algorithm. Your task is to write a function `custom_bubble_sort(arr, simulate)`, which sorts the input array in ascending order while optionally displaying each iteration of the sorting process. # Requirements * **Function Signature**: `def custom_bubble_sort(arr: list, simulate: bool = False) -> list:` * **Input**: - `arr`: A list of integer elements which you need to sort. - `simulate`: A boolean flag which, if set to True, will print the array after each iteration. Defaults to False. * **Output**: - A list of integers sorted in ascending order. # Constraints 1. The length of the array (n) will be in the range 0 <= n <= 1000. 2. The elements of the array will be integers, and their values will be in the range -10^6 <= element <= 10^6. # Performance Requirements Ensure that: - The time complexity of your solution is O(N^2) in the worst-case scenario. # Example ```python # Example 1: arr = [64, 34, 25, 12, 22, 11, 90] simulate = True Output: iteration 0 : 64 34 25 12 22 11 90 iteration 1 : 34 64 25 12 22 11 90 iteration 2 : 34 25 64 12 22 11 90 ... iteration 20 : 11 12 22 25 34 64 90 [11, 12, 22, 25, 34, 64, 90] # Example 2: arr = [5, 2, 9, 1, 5, 6] simulate = False Output: [1, 2, 5, 5, 6, 9] ``` Using the above example, when `simulate=True`, the function should print the array at each iteration where any swap occurs. When `simulate=False`, it should only return the sorted array.","solution":"def custom_bubble_sort(arr, simulate=False): Sorts the array using Bubble Sort algorithm and optionally displays each iteration. Parameters: arr (list): The list of integers to be sorted. simulate (bool): If True, print the array after each iteration. Defaults to False. Returns: list: The sorted list in ascending order. n = len(arr) for i in range(n): swapped = False for j in range(0, n-i-1): if arr[j] > arr[j+1]: arr[j], arr[j+1] = arr[j+1], arr[j] swapped = True if simulate: print(f\'iteration {i} : {\\" \\".join(map(str, arr))}\') if not swapped: break return arr"},{"question":"Decoding Ways Problem # Context A message containing letters from A-Z is being encoded to numbers using the following mapping: * \'A\' -> 1 * \'B\' -> 2 * ... * \'Z\' -> 26 Given an encoded message containing digits, determine the total number of ways to decode it. For instance, the encoded message \\"12\\" can be decoded as \\"AB\\" (1 2) or \\"L\\" (12); hence, the number of ways to decode \\"12\\" is 2. # Problem Statement Write a function `num_decodings(s: str) -> int` that calculates the total number of ways to decode a given encoded message. # Input * A single string `s` containing only digits (\'0\'-\'9\'). # Output * An integer representing the total number of ways to decode the input string. # Constraints * The input string can have a length between 1 and 100. # Examples 1. **Example 1:** ```python Input: \\"12\\" Output: 2 ``` 2. **Example 2:** ```python Input: \\"226\\" Output: 3 ``` 3. **Example 3:** ```python Input: \\"06\\" Output: 0 ``` # Performance Requirements Your solution should run efficiently for input strings of length up to 100 (`O(n)` time complexity). # Implementation Details Your solution should account for: * Edge cases like \'0\', \'10\', \'20\', mixed valid/invalid sequences. * Avoiding pitfalls of invalid starting points (like \'06\'). * Efficient memory usage as outlined in the core analysis.","solution":"def num_decodings(s: str) -> int: if not s or s[0] == \'0\': return 0 n = len(s) dp = [0] * (n + 1) dp[0] = 1 # Base case, empty string has one way to be decoded for i in range(1, n + 1): # Single digit decoding if s[i - 1] != \'0\': dp[i] += dp[i - 1] # Two digit decoding if i > 1 and \'10\' <= s[i - 2:i] <= \'26\': dp[i] += dp[i - 2] return dp[n]"},{"question":"# Coding Challenge You have been tasked with building a Binary Search Tree (BST) and implementing efficient search, insertion, and deletion methods. Please write a Python class `BST` that supports the following operations: 1. **Insert a node**: Insert a node into the BST, maintaining the BST properties. 2. **Search a node**: Search for a node with a given value and return `True` if found, otherwise return `False`. 3. **Delete a node**: Delete a node with a specific value, ensuring the BST property is preserved. Expected Input and Output Formats - **Insert a node**: `insert(self, val: int) -> None` - Input: An integer `val` representing the value to be inserted. - Output: None - **Search a node**: `search(self, val: int) -> bool` - Input: An integer `val` representing the value to search for. - Output: `True` if the value exists in the BST, otherwise `False`. - **Delete a node**: `delete(self, val: int) -> None` - Input: An integer `val` representing the value to delete. - Output: None You should also write helper methods to maintain the tree\'s balance and properties where necessary. # Constraints 1. Values will only be integers. 2. The BST should handle duplicate entries by ignoring new inserts of existing values. 3. The methods should be optimized for both average and worst-case performance. Performance Requirements - **Time complexity**: The average case should be O(log n) for search, insertion, and deletion, although worst-case scenarios may lead to O(n). - **Space Complexity**: O(n) due to node storage. # Example Usage ```python bst = BST() bst.insert(5) bst.insert(3) bst.insert(7) print(bst.search(3)) # Output: True print(bst.search(8)) # Output: False bst.delete(7) print(bst.search(7)) # Output: False ``` Develop your solution ensuring the BST handles all edge cases, avoids performance bottlenecks, and corrects any possible errors.","solution":"class TreeNode: def __init__(self, val=0): self.val = val self.left = None self.right = None class BST: def __init__(self): self.root = None def insert(self, val): Inserts a value into the BST. if not self.root: self.root = TreeNode(val) else: self._insert(self.root, val) def _insert(self, node, val): if val < node.val: if node.left: self._insert(node.left, val) else: node.left = TreeNode(val) elif val > node.val: if node.right: self._insert(node.right, val) else: node.right = TreeNode(val) # If val == node.val, do nothing (no duplicates) def search(self, val): Searches for a value in the BST. Returns True if the value exists, otherwise False. return self._search(self.root, val) def _search(self, node, val): if not node: return False if node.val == val: return True elif val < node.val: return self._search(node.left, val) else: return self._search(node.right, val) def delete(self, val): Deletes a value from the BST while maintaining BST properties. self.root = self._delete(self.root, val) def _delete(self, node, val): if not node: return node if val < node.val: node.left = self._delete(node.left, val) elif val > node.val: node.right = self._delete(node.right, val) else: if not node.left: return node.right elif not node.right: return node.left temp = self._min_value_node(node.right) node.val = temp.val node.right = self._delete(node.right, temp.val) return node def _min_value_node(self, node): current = node while current.left: current = current.left return current"},{"question":"# Context In the realm of mathematics and number theory, there\'s a sequence created by concatenating natural numbers into a single, continuous string. For example, the sequence would start as \\"123456789101112...\\". This problem requires you to retrieve the nth digit within this infinite sequence. # Task You need to write a function `find_nth_digit(n)` that returns the nth digit in this concatenated sequence of natural numbers. # Function Signature ```python def find_nth_digit(n: int) -> int: This function returns the nth digit of the concatenated sequence of natural numbers. :param n: An integer representing the position in the sequence (1-indexed). :return: The nth digit in the sequence as an integer. ``` # Input - A single integer `n` where `1 <= n <= 2 * 10^9`. # Output - A single integer which is the nth digit of the concatenated number sequence. # Examples Example 1: ```python find_nth_digit(3) ``` Output: ``` 3 ``` Example 2: ```python find_nth_digit(11) ``` Output: ``` 0 ``` # Constraints - The function should handle very large values of `n` efficiently. - The solution should avoid unnecessary computations and memory usage. # Performance Requirement - The function should run optimally with respect to both time and space complexity.","solution":"def find_nth_digit(n: int) -> int: This function returns the nth digit of the concatenated sequence of natural numbers. :param n: An integer representing the position in the sequence (1-indexed). :return: The nth digit in the sequence as an integer. length = 1 # The current number length count = 9 # The count of numbers of the current length start = 1 # The starting number of the current length while n > length * count: n -= length * count length += 1 count *= 10 start *= 10 start += (n - 1) // length s = str(start) return int(s[(n - 1) % length])"},{"question":"Scenario You are given a matrix where each row and each column is sorted in non-decreasing order. Your task is to write a function that searches for a specific key in the matrix and returns its position if found, or a specific message if not found. The matrix can have m rows and n columns. # Function Signature ```python def search_in_matrix(matrix: [[int]], key: int) -> str: pass ``` # Input - `matrix`: A list of lists of integers `[m][n]` where each row and column is sorted in non-decreasing order. - `key`: An integer representing the search key. # Output - Return a string `\\"Key <key> found at row- <row> column- <column>\\"` if the key is found. - Return a string `\\"Key <key> not found\\"` if the key is not found. # Constraints - 0 ≤ m, n ≤ 10^3 - -10^6 ≤ `matrix[i][j]`, `key` ≤ 10^6 - The function must run within O(m + n) time complexity. - Handle edge cases properly, including empty matrices and keys not within the matrix range. # Example ```python matrix = [ [2, 5, 7], [4, 8, 13], [9, 11, 15], [12, 17, 20] ] key = 13 search_in_matrix(matrix, key) # Expected Output: Key 13 found at row- 2 column- 3 key = 21 search_in_matrix(matrix, key) # Expected Output: Key 21 not found ``` Use this problem to test your understanding of matrix traversal and linear search techniques in constrained environments.","solution":"def search_in_matrix(matrix, key): Searches for a key in a sorted matrix and returns its position if found, or a specific message if not found. :param matrix: List of Lists of integers representing the sorted matrix. :param key: Integer representing the search key. :return: String message indicating whether the key was found or not. if not matrix or not matrix[0]: return f\\"Key {key} not found\\" rows, columns = len(matrix), len(matrix[0]) row, col = 0, columns - 1 while row < rows and col >= 0: if matrix[row][col] == key: return f\\"Key {key} found at row- {row + 1} column- {col + 1}\\" elif matrix[row][col] > key: col -= 1 else: row += 1 return f\\"Key {key} not found\\""},{"question":"Problem Statement # Scenario You are given a sequence of tuples where each tuple contains a non-negative integer and a sign (`+` or `-`). Your task is to determine if the sequence is 1-sparse. A stream is 1-sparse if, after considering the sign and canceling opposing entries, exactly one unique value remains without cancellation. # Task Write a function `find_one_sparse` that takes a list of tuples representing the stream and returns the unique number if the stream is 1-sparse. If the stream is not 1-sparse, return `None`. # Function Signature ```python def find_one_sparse(stream: List[Tuple[int, str]]) -> Optional[int]: Determine if the stream is 1-sparse and return the unique number, or None otherwise. Parameters: stream (List[Tuple[int, str]]): List of tuples, where each tuple contains a number (int) and a sign (str, either \'+\' or \'-\') Returns: Optional[int]: The unique number if the stream is 1-sparse, or None otherwise. ``` # Input - `stream`: A list of tuples `(number, sign)` where: - `number` is a non-negative integer (0 <= number <= 2^31 - 1) - `sign` is either `\'+\'` or `\'-\'` # Output - An integer representing the unique number if the stream is 1-sparse. - `None` if the stream is not 1-sparse. # Constraints - The input list can be empty but will contain at most 10^5 tuples. # Examples 1. **Example 1:** ```python Input: [(4, \'+\'), (2, \'+\'), (2, \'-\'), (4, \'+\'), (3, \'+\'), (3, \'-\')] Output: 4 ``` 2. **Example 2:** ```python Input: [(2, \'+\'), (2, \'+\'), (2, \'+\'), (2, \'+\'), (2, \'+\'), (2, \'+\'), (2, \'+\')] Output: 2 ``` 3. **Example 3:** ```python Input: [(2, \'+\'), (2, \'+\'), (2, \'+\'), (2, \'+\'), (2, \'+\'), (2, \'+\'), (1, \'+\')] Output: None ``` # Note - Properly handle the edge cases such as an empty stream or fully canceling streams. - Ensure optimal performance given the constraints.","solution":"from typing import List, Tuple, Optional from collections import defaultdict def find_one_sparse(stream: List[Tuple[int, str]]) -> Optional[int]: Determine if the stream is 1-sparse and return the unique number, or None otherwise. Parameters: stream (List[Tuple[int, str]]): List of tuples, where each tuple contains a number (int) and a sign (str, either \'+\' or \'-\') Returns: Optional[int]: The unique number if the stream is 1-sparse, or None otherwise. counter = defaultdict(int) # Process each number in the stream for number, sign in stream: if sign == \'+\': counter[number] += 1 elif sign == \'-\': counter[number] -= 1 # Extract numbers with non-zero counts non_zero_counts = [num for num, count in counter.items() if count != 0] # Check if there is exactly one unique number with a non-zero count if len(non_zero_counts) == 1: return non_zero_counts[0] else: return None"},{"question":"**Context**: You are building a text pattern recognizer using a deterministic finite automaton (DFA). Your task is to implement a function that will determine if a given string is accepted by the DFA. The DFA is defined by its transition table, a start state, a set of final states, and the input string to process. # Task Implement the function `dfa_recognizer(transitions, start, final, string)` that returns `True` if the string is accepted by the DFA and `False` otherwise. # Function Signature ```python def dfa_recognizer(transitions: dict, start: str, final: list, string: str) -> bool: # Your code here ``` # Parameters - `transitions`: A dictionary where keys are state names and values are dictionaries mapping input characters to the next state. - `start`: The starting state of the DFA (a string). - `final`: A list of accepting states (strings). - `string`: The input string to be processed by the DFA. # Constraints - The DFA has a finite number of states and transitions. - The alphabet (set of input characters) is finite and all strings are composed of these characters. - The lengths of `transitions`, `final`, and the input string do not exceed 10^3 elements. # Input Example ```python transitions = { \'q0\': {\'a\': \'q1\', \'b\': \'q0\'}, \'q1\': {\'a\': \'q1\', \'b\': \'q2\'}, \'q2\': {\'a\': \'q1\', \'b\': \'q0\'} } start = \'q0\' final = [\'q2\'] string = \'aab\' ``` # Output Example ```python print(dfa_recognizer(transitions, start, final, string)) # Output: True ``` In this example, the string \'aab\' transitions through the states as follows: `q0` -> `q1` -> `q1` -> `q2`, which is a final state. Hence, the function returns `True`. # Requirements - Ensure that your function handles strings of varying lengths, including the empty string. - Consider edge cases such as characters not being in the transition map. - Your implementation should be efficient and adhere to the described complexity. # Notes - You may assume all transitions will be properly defined for given states and input characters. - Focus on correctness, clarity, and efficiency.","solution":"def dfa_recognizer(transitions, start, final, string): Determines if a given string is accepted by the DFA. Parameters: transitions (dict): A dictionary where keys are state names and values are dictionaries mapping input characters to the next state. start (str): The starting state of the DFA. final (list): A list of accepting states. string (str): The input string to be processed by the DFA. Returns: bool: True if the string is accepted by the DFA, False otherwise. current_state = start for char in string: if char in transitions[current_state]: current_state = transitions[current_state][char] else: return False return current_state in final"},{"question":"# Word Squares Construction **Objective**: Implement a function to find all possible word squares from a given list of words. **Scenario**: You are designing a crossword puzzle and need to ensure that certain word sequences form valid word squares. Each word sequence must have its k-th row and column reading the exact same string. This can be particularly useful for designing word games or puzzles. **Function Signature**: ```python def word_squares(words: List[str]) -> List[List[str]]: pass ``` **Input**: * A list of words (without duplicates) where: - There are at least 1 and at most 1000 words. - All words will have the exact same length. - Word length is at least 1 and at most 5. - Each word contains only lowercase English alphabets \'a\' to \'z\'. **Output**: * A list of lists, where each inner list is a valid word square formed using the given words. **Constraints**: * The order of words within each word square matters, but the order of word squares in the output does not. **Performance Requirements**: * The function should be optimized to handle the maximum constraints efficiently. **Example**: ```python Input: [\\"area\\",\\"lead\\",\\"wall\\",\\"lady\\",\\"ball\\"] Output: [ [ \\"wall\\", \\"area\\", \\"lead\\", \\"lady\\" ], [ \\"ball\\", \\"area\\", \\"lead\\", \\"lady\\" ] ] ``` **Notes**: * The output consists of two valid word squares. The order of output does not matter; only the order of words in each word square matters. **Edge Cases to Consider**: * When only one word is provided. * When no valid word squares can be formed. * Duplicate words resulting in the same word square. Implement the `word_squares` function to solve this problem.","solution":"from typing import List, Dict from collections import defaultdict def build_prefix_dict(words: List[str], word_length: int) -> Dict[str, List[str]]: prefix_dict = defaultdict(list) for word in words: for i in range(word_length): prefix_dict[word[:i]].append(word) return prefix_dict def backtrack(step: int, word_length: int, square: List[str], prefix_dict: Dict[str, List[str]], results: List[List[str]]): if step == word_length: results.append(square[:]) return prefix = \'\'.join([word[step] for word in square]) for candidate in prefix_dict[prefix]: square.append(candidate) backtrack(step + 1, word_length, square, prefix_dict, results) square.pop() def word_squares(words: List[str]) -> List[List[str]]: if not words: return [] word_length = len(words[0]) prefix_dict = build_prefix_dict(words, word_length) results = [] for word in words: square = [word] backtrack(1, word_length, square, prefix_dict, results) return results"},{"question":"# Question: Regular Expression Matching with `.` and `*` You are tasked with implementing a function that performs regular expression matching with support for two special characters: * `.` (dot) - Matches any single character. * `*` (asterisk) - Matches zero or more of the preceding element. Your goal is to determine if a given input string `str_a` matches a pattern `str_b` entirely. The pattern matching should cover the entire input string (not partial). You need to implement the function `bool is_match(const char *str_a, const char *str_b)`. # Expected Function Signature ```python def is_match(str_a: str, str_b: str) -> bool: # Your code here ``` # Example ```python assert is_match(\\"aa\\", \\"a\\") == False assert is_match(\\"aa\\", \\"aa\\") == True assert is_match(\\"aaa\\", \\"aa\\") == False assert is_match(\\"aa\\", \\"a*\\") == True assert is_match(\\"aa\\", \\".*\\") == True assert is_match(\\"ab\\", \\".*\\") == True assert is_match(\\"aab\\", \\"c*a*b\\") == True ``` # Input Constraints * Both `str_a` and `str_b` consist only of lowercase English letters and the characters `.` and `*`. * The length of `str_a` is between 0 and 1000. * The length of `str_b` is between 0 and 1000. # Performance Requirements The implementation should be optimized to run efficiently with input strings up to the specified length constraints.","solution":"def is_match(str_a: str, str_b: str) -> bool: # dp[i][j] will be True if str_a[0:i] matches str_b[0:j] dp = [[False] * (len(str_b) + 1) for _ in range(len(str_a) + 1)] dp[0][0] = True # Both strings are empty # Initialize the dp array for patterns with * for j in range(1, len(str_b) + 1): if str_b[j - 1] == \'*\': dp[0][j] = dp[0][j - 2] # a pattern like a* can match empty string # Fill the dp array for i in range(1, len(str_a) + 1): for j in range(1, len(str_b) + 1): if str_b[j - 1] == \'.\' or str_b[j - 1] == str_a[i - 1]: dp[i][j] = dp[i - 1][j - 1] elif str_b[j - 1] == \'*\': dp[i][j] = dp[i][j - 2] # Match zero occurrence of the character before * if str_b[j - 2] == \'.\' or str_b[j - 2] == str_a[i - 1]: dp[i][j] = dp[i][j] or dp[i - 1][j] return dp[-1][-1]"},{"question":"# Question: Factor Combinations Given a positive integer `n`, write a function that returns all unique combinations of its factors. Each combination should be a list of integers greater than 1 that multiplies to the given number `n`. # Input - An integer `n` where `n` > 0. # Output - A list of lists containing unique combinations of factors of `n`. # Examples ```python input: n = 1 output: [] input: n = 37 output: [] input: n = 12 output: [ [2, 6], [2, 2, 3], [3, 4] ] input: n = 32 output: [ [2, 16], [2, 2, 8], [2, 2, 2, 4], [2, 2, 2, 2, 2], [2, 4, 4], [4, 8] ] ``` # Constraints - Factors should be greater than 1 and less than `n`. - Resulting factor combinations should be returned in any order. - `n` will always be a positive integer. # Function Signature ```python def get_factors(n: int) -> List[List[int]]: # implementation goes here ``` This problem focuses on understanding backtracking mechanisms and generating combinations based on conditions. Ensure that the solution effectively handles edge cases like prime numbers and minimal input values.","solution":"def get_factors(n: int): def backtrack(start, target, path, res): if target == 1 and len(path) > 1: res.append(path[:]) return for i in range(start, target+1): if target % i == 0: path.append(i) backtrack(i, target // i, path, res) path.pop() result = [] backtrack(2, n, [], result) return result"},{"question":"You are given a string `s`. Your task is to write a function `delete_reoccurring_characters(s)` that removes all duplicate characters from the string while preserving the order of their first appearance. Function Signature ```python def delete_reoccurring_characters(s: str) -> str: ``` Input - A single string `s`, where 0 ≤ len(s) ≤ 10000. The string can include letters, digits, whitespace, and special characters. Output - A string with all recurring characters removed while preserving the order of their first appearance in the original string. Constraints - The function should operate with a time complexity of O(n), where n is the length of the string. - The space complexity should be considered, but you are allowed to use additional memory proportional to the number of unique characters in the input string. Example ```python assert delete_reoccurring_characters(\\"abracadabra\\") == \\"abrcd\\" assert delete_reoccurring_characters(\\"google\\") == \\"gole\\" assert delete_reoccurring_characters(\\"12341234\\") == \\"1234\\" assert delete_reoccurring_characters(\\"\\") == \\"\\" ``` **Note**: 1. The `delete_reoccurring_characters` function should handle edge cases such as an empty string or a string with only unique characters. 2. Special and non-ASCII characters should also be treated as valid input characters.","solution":"def delete_reoccurring_characters(s: str) -> str: Removes all duplicate characters from the string while preserving the order of their first appearance. seen = set() result = [] for char in s: if char not in seen: seen.add(char) result.append(char) return \'\'.join(result)"},{"question":"**Title**: Bit Flip Counter **Objective**: Demonstrate your understanding of bit manipulation by writing a function to count the number of bits that need to be flipped to convert one integer to another. **Task**: Write a Python function `count_flips_to_convert(a: int, b: int) -> int` that computes the minimal number of bit flips required to change integer `a` into integer `b`. **Function Signature**: ```python def count_flips_to_convert(a: int, b: int) -> int: pass ``` **Input**: * `a, b`: Two non-negative integers (0 <= `a`, `b` <= 2^31 - 1). **Output**: * Returns an integer representing the number of bit flips needed. **Constraints**: * The function should run efficiently within the limits of typical 32-bit integers. * You must handle edge cases where either `a` or `b` is zero and ensure proper unsigned integer processing. **Examples**: ```python assert count_flips_to_convert(29, 15) == 2 # Explanation: 29 (11101) and 15 (01111) differ by 2 bits. assert count_flips_to_convert(0, 15) == 4 # Explanation: 0 (00000) and 15 (01111) differ by 4 bits. assert count_flips_to_convert(1, 2) == 2 # Explanation: 1 (00001) and 2 (00010) differ by 2 bits. assert count_flips_to_convert(31, 0) == 5 # Explanation: 31 (11111) and 0 (00000) differ by 5 bits. ``` **Scenario**: Imagine you are working on a network security tool that monitors traffic bits for anomaly detection. Part of the checking process involves comparing the current set of bits to a reference pattern to determine the presence of alterations. Implementing this bit flip counter will help you determine how much the current traffic pattern deviates from a predefined normal pattern. Your solution must handle highly disparate values efficiently and ensure correctness even under edge scenarios.","solution":"def count_flips_to_convert(a: int, b: int) -> int: Returns the number of bits that need to be flipped to convert integer a to integer b. # XOR a and b to isolate the different bits xor = a ^ b # Count the number of 1s in the XOR result, which gives the number of differing bits count = 0 while xor > 0: count += xor & 1 xor >>= 1 return count"},{"question":"You are given a dataset consisting of integers that need to be sorted. While typically you would use a more efficient algorithm, for the purposes of this exercise, we will be using a highly inefficient algorithm: Bogo Sort. Your task is to implement a variation of Bogo Sort that also counts and returns the number of shuffles it takes to sort the array. # Function Signature: ```python def bogo_sort_with_count(arr: List[int], simulation: bool = False) -> Tuple[List[int], int]: ``` # Input: * `arr` (List[int]): A list of integers that needs to be sorted. * `simulation` (bool): If `True`, print the array after each shuffle to simulate the sorting process. Default is `False`. # Output: * Returns a tuple containing: 1. A sorted list of integers. 2. An integer representing the number of shuffles performed. # Constraints: 1. The maximum length of the array `n` is 10 to prevent excessive computation time. 2. Elements in the array are not necessarily unique. # Example: ```python example_input = [3, 2, 1] print(bogo_sort_with_count(example_input)) # Output should be similar to ([1, 2, 3], shuffle_count) ``` # Notes: * Ensure your solution iteratively shuffles the array until it is sorted. * The shuffle count should accurately reflect the number of times the array was shuffled. * For simulation, you should print the array state after each shuffle, similar to the provided code. # Performance Considerations: Given the inherently exponential nature of the algorithm, avoid using large arrays. This question aims to test your ability to implement a naive algorithm and demonstrate understanding of concepts like the randomness and sorting check.","solution":"import random from typing import List, Tuple def bogo_sort_with_count(arr: List[int], simulation: bool = False) -> Tuple[List[int], int]: Sorts the array using Bogo Sort and counts the number of shuffles. Parameters: - arr: List[int] -- The list of integers to sort. - simulation: bool -- If True, prints the array after each shuffle. Returns: - Tuple[List[int], int] -- The sorted list and the number of shuffles performed. def is_sorted(arr: List[int]) -> bool: Checks if the array is sorted. Parameters: - arr: List[int] -- The list of integers to check. Returns: - bool -- True if the list is sorted, False otherwise. for i in range(len(arr) - 1): if arr[i] > arr[i + 1]: return False return True shuffle_count = 0 while not is_sorted(arr): random.shuffle(arr) shuffle_count += 1 if simulation: print(f\\"Shuffle {shuffle_count}: {arr}\\") return arr, shuffle_count"},{"question":"# Advanced Sorting with Comb Sort You are developing a sorting utility for a software project. Your task is to implement the Comb Sort algorithm, ensuring it handles specific edge cases and optimizes for performance. Function Signature: ```python def comb_sort(arr: List[int]) -> List[int]: ``` # Input - `arr`: List of integers to be sorted. (`1 <= len(arr) <= 10^5`, `-10^9 <= arr[i] <= 10^9`) # Output - The sorted list of integers in ascending order. # Constraints - The function must maintain an average-case performance close to O(N log N) and avoid an O(N^2) degradation. - You cannot use Python\'s built-in sorting functions. # Example: ```python assert comb_sort([34, -3, 0, 99, 23, 11, -100, 5]) == [-100, -3, 0, 5, 11, 23, 34, 99] assert comb_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] assert comb_sort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5] ``` # Additional Requirements: - Ensure the implementation handles large inputs efficiently. - Consider and handle all edge cases: already sorted array, array with all identical elements, and reverse-sorted array. - Optimize gap calculation if possible to improve performance.","solution":"from typing import List def comb_sort(arr: List[int]) -> List[int]: Sorts a list of integers using the Comb Sort algorithm. if len(arr) <= 1: return arr def get_next_gap(gap): # Shrinks the gap by shrink factor 1.3 new_gap = (gap * 10) // 13 return max(1, new_gap) n = len(arr) gap = n swapped = True while gap != 1 or swapped: gap = get_next_gap(gap) swapped = False for i in range(n - gap): if arr[i] > arr[i + gap]: arr[i], arr[i + gap] = arr[i + gap], arr[i] swapped = True return arr"},{"question":"Your task is to implement the insertion sort algorithm using a helper function that uses binary search to determine the correct insertion point for the next element in the partially sorted array. This will help minimize comparisons needed to find the correct position of the element. **Function Signature**: ```python def binary_insertion_sort(array: List[int]) -> List[int]: pass ``` **Parameters**: - `array`: A list of integers to be sorted. **Returns**: - A new list with the elements of `array` sorted in non-decreasing order. **Constraints**: - The input array may contain duplicates. - The array length can be up to (10^5). **Performance Requirements**: - The function should handle arrays of up to (10^5) elements efficiently within acceptable runtime limits for (O(n^2)) solutions. **Example**: ```python # Example Usage array = [12, 11, 13, 5, 6] sorted_array = binary_insertion_sort(array) print(sorted_array) # Output: [5, 6, 11, 12, 13] array = [] sorted_array = binary_insertion_sort(array) print(sorted_array) # Output: [] array = [1, 2, 3, 4, 5] sorted_array = binary_insertion_sort(array) print(sorted_array) # Output: [1, 2, 3, 4, 5] ``` **Scenario or Context**: Imagine you are working on a system that processes incoming data in real-time. Efficiently sorting the data is crucial for subsequent operations such as finding medians, percentiles, or simply displaying it in an ordered manner. Given the data size and real-time nature, a solution like binary insertion sort strikes a balance between simplicity and efficiency compared to more complex algorithms which might have higher setup costs. **Hints**: - Make use of the provided `search_insert` function to get the correct index where each element should be placed. - Shift elements to make room for the new element to be inserted in the correct position.","solution":"from typing import List def binary_search_insert_position(array: List[int], left: int, right: int, key: int) -> int: Perform binary search to find the correct insertion point for the key in the subarray array[left:right+1]. while left <= right: mid = left + (right - left) // 2 if array[mid] == key: return mid elif array[mid] < key: left = mid + 1 else: right = mid - 1 return left def binary_insertion_sort(array: List[int]) -> List[int]: Sort the provided array using binary insertion sort algorithm. for i in range(1, len(array)): key = array[i] # Find the position where key should be inserted in array[0..i-1] insert_pos = binary_search_insert_position(array, 0, i - 1, key) # Move all elements from insert_pos to i - 1 one position to the right for j in range(i, insert_pos, -1): array[j] = array[j - 1] # Place key at its correct position array[insert_pos] = key return array"},{"question":"Improved Bucket Sort Implementation You are tasked with implementing a more robust and efficient version of the Bucket Sort algorithm. The current implementation uses Insertion Sort to sort the elements within each bucket, which can be inefficient for larger datasets. Moreover, the current approach does not handle edge cases effectively. Requirements: 1. Implement a bucket sort function that handles edge cases and distributes elements more efficiently. 2. Use a more efficient sorting method for sorting the elements within each bucket. 3. Ensure the solution handles the case where all elements are identical and where the range of input data is minimal. Input and Output Specification: - **Input**: An array of floating-point numbers `arr` of length `n`. - The array can contain from 0 to 10^6 elements. - Each element in the array is within the range [0, 1). - **Output**: A sorted array. Constraints: - The solution should run within reasonable time limits for the input size. Function Signature: ```python def improved_bucket_sort(arr: List[float]) -> List[float]: pass ``` Example: ```python # Example 1 input: [0.42, 0.32, 0.23, 0.52, 0.25, 0.47] output: [0.23, 0.25, 0.32, 0.42, 0.47, 0.52] # Example 2 input: [0.23, 0.23, 0.23, 0.23] output: [0.23, 0.23, 0.23, 0.23] # Example 3 input: [] output: [] ``` Notes: - Handle edge cases such as empty arrays or arrays with duplicate entries efficiently. - Use a sorting algorithm that is more efficient in practice than insertion sort for sorting individual buckets.","solution":"from typing import List def quicksort(arr): Helper function to sort a given list using QuickSort algorithm. if len(arr) <= 1: return arr pivot = arr[len(arr) // 2] left = [x for x in arr if x < pivot] middle = [x for x in arr if x == pivot] right = [x for x in arr if x > pivot] return quicksort(left) + middle + quicksort(right) def improved_bucket_sort(arr: List[float]) -> List[float]: Sort the array using the improved bucket sort algorithm. if not arr: return [] num_buckets = len(arr) buckets = [[] for _ in range(num_buckets)] for num in arr: index = int(num_buckets * num) buckets[index].append(num) sorted_array = [] for bucket in buckets: sorted_array.extend(quicksort(bucket)) return sorted_array"},{"question":"# Regular Expression Matching Challenge Implement a regular expression matching function with support for \'.\' and \'*\'. The function should determine if the entire input string matches the given pattern. Description: - \'.\' Matches any single character. - \'*\' Matches zero or more of the preceding element. Function Signature: ```python def is_match(s: str, p: str) -> bool ``` Input: - `s` (string): The input string containing lowercase letters. - `p` (string): The pattern string containing lowercase letters, \'.\', and \'*\'. Output: - `bool`: Returns `True` if the input string `s` matches the pattern `p`, otherwise returns `False`. Constraints: - `0 <= len(s) <= 1000` - `0 <= len(p) <= 1000` Examples: ```python assert is_match(\\"aa\\", \\"a\\") == False assert is_match(\\"aa\\", \\"aa\\") == True assert is_match(\\"aaa\\", \\"aa\\") == False assert is_match(\\"aa\\", \\"a*\\") == True assert is_match(\\"aa\\", \\".*\\") == True assert is_match(\\"ab\\", \\".*\\") == True assert is_match(\\"aab\\", \\"c*a*b\\") == True ``` Implementation Notes: 1. Use dynamic programming to build a 2D table `matches` where `matches[i][j]` represents if the first `i` characters in `s` match the first `j` characters in `p`. 2. Initialize the base case where an empty string matches with an empty pattern. 3. Iterate through each character and pattern to update the table based on the rules for \'.\' and \'*\'. Your task is to implement the `is_match` function according to the above logic.","solution":"def is_match(s: str, p: str) -> bool: Determines if the entire input string matches the given pattern. m, n = len(s), len(p) # Initialize a 2D dp array dp = [[False] * (n + 1) for _ in range(m + 1)] dp[0][0] = True # Handle patterns with \'*\' matching an empty sequence for j in range(2, n + 1): if p[j - 1] == \'*\': dp[0][j] = dp[0][j - 2] # Fill the dp array for i in range(1, m + 1): for j in range(1, n + 1): if p[j - 1] == \'.\' or p[j - 1] == s[i - 1]: dp[i][j] = dp[i - 1][j - 1] elif p[j - 1] == \'*\': dp[i][j] = dp[i][j - 2] if p[j - 2] == \'.\' or p[j - 2] == s[i - 1]: dp[i][j] |= dp[i - 1][j] return dp[m][n]"},{"question":"# Base Conversion Challenge You are tasked with writing functions to convert integers between different bases efficiently. The functions `int_to_base` and `base_to_int` should convert an integer from decimal to any specified base up to base 36 and vice versa. Here are the requirements: 1. **Function `int_to_base(num, base)`**: - **Input**: - `num`: An integer (can be negative or zero). - `base`: An integer (2 ≤ base ≤ 36). - **Output**: - A string representing the number in the specified base. - **Constraints**: - Ensure the function handles edge cases like `num = 0` and different base values properly. - **Example**: - `int_to_base(5, 2)` should return `\'101\'`. - `int_to_base(-10, 16)` should return `\'-A\'`. 2. **Function `base_to_int(str_to_convert, base)`**: - **Input**: - `str_to_convert`: A string representing the number in the given base (can denote a negative number). - `base`: An integer (2 ≤ base ≤ 36). - **Output**: - An integer equivalent of the base number in decimal. - **Constraints**: - Ensure that the function handles invalid characters gracefully and considers edge cases like `str_to_convert = \'0\'`. - **Example**: - `base_to_int(\'101\', 2)` should return `5`. - `base_to_int(\'-A\', 16)` should return `-10`. Your task is to implement these two functions efficiently, adhering to the given constraints and considering potential edge cases.","solution":"def int_to_base(num, base): Convert an integer to a specified base. Args: num (int): the integer to convert. base (int): the base to convert to (2 <= base <= 36). Returns: str: the string representation of the number in the specified base. if base < 2 or base > 36: raise ValueError(\\"Base must be between 2 and 36, inclusive.\\") if num == 0: return \\"0\\" digits = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" result = \\"\\" negative = num < 0 num = abs(num) while num > 0: result = digits[num % base] + result num //= base if negative: result = \'-\' + result return result def base_to_int(str_to_convert, base): Convert a string representation of a number in a specified base to an integer. Args: str_to_convert (str): the string representation of the number in the given base. base (int): the base of the input string (2 <= base <= 36). Returns: int: the integer representation of the string in decimal. if base < 2 or base > 36: raise ValueError(\\"Base must be between 2 and 36, inclusive.\\") str_to_convert = str_to_convert.upper() digits = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" num_dict = {char: index for index, char in enumerate(digits)} if str_to_convert[0] == \'-\': negative = True str_to_convert = str_to_convert[1:] else: negative = False num = 0 for char in str_to_convert: if char not in num_dict or num_dict[char] >= base: raise ValueError(f\\"Invalid character {char} for base {base}\\") num = num * base + num_dict[char] return -num if negative else num"},{"question":"**Context**: You\'ve been hired to implement a function for an online code judge system to check whether numbers are prime. Your function needs to be efficient and correct to handle a high volume of submissions from users. **Task**: Implement the function `is_prime(n: int) -> bool` that returns `True` if `n` is a prime number and `False` otherwise. **Input**: - An integer `n` (1 ≤ n ≤ 10^9). **Output**: - Return `True` if `n` is a prime number. - Return `False` if `n` is not a prime number. **Constraints**: - Your solution must have a time complexity of O(√n). - Ensure it handles edge cases such as `n` being very small or very large within the given constraints. **Examples**: 1. `is_prime(2)` should return `True` 2. `is_prime(4)` should return `False` 3. `is_prime(17)` should return `True` 4. `is_prime(1000000007)` should return `True` ```python def is_prime(n): Determine if the given number is a prime number. Args: n (int): The number to check (1 <= n <= 10^9). Returns: bool: True if n is a prime number, False otherwise. pass # Implement the function here based on your understanding. ``` Consider edge cases and ensure your function is optimized for the constraints provided.","solution":"def is_prime(n): Determine if the given number is a prime number. Args: n (int): The number to check (1 <= n <= 10^9). Returns: bool: True if n is a prime number, False otherwise. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True"},{"question":"**Objective**: Write a Python function to determine how many bits you would need to flip to convert one integer (A) to another integer (B). **Function Signature**: ```python def count_flips_to_convert(a: int, b: int) -> int: pass ``` **Input**: - Two integers, (A) and (B) (0 ≤ (A), (B) ≤ (2^{31} - 1)) **Output**: - Return an integer representing the number of bits that need to be flipped to convert (A) to (B). **Constraints**: - The solution should be efficient with a time complexity of (O(n)), where (n) is the number of bits in the longest integer input. - The space complexity should be constant, (O(1)). **Example**: ```python assert count_flips_to_convert(29, 15) == 2 # (11101 to 01111, flips at positions 2 and 4) assert count_flips_to_convert(10, 5) == 4 # (01010 to 00101, flips at all positions) assert count_flips_to_convert(1, 1) == 0 # (00001 to 00001, no flips) assert count_flips_to_convert(0, 8) == 1 # (00000 to 01000, flips at position 4) ``` **Scenario**: A digital systems engineer is working on a networking protocol where minimizing the number of bit-level changes between packet formats is crucial. To ensure efficient data transmission, they must frequently compute the minimal bit flips required between different integer representations. Your task is to assist them by implementing a function that accurately determines this number of bit flips. **Additional Notes**: You may assume that the input numbers will always be valid integers within the specified range. There is no need for further input validation.","solution":"def count_flips_to_convert(a: int, b: int) -> int: Returns the number of bits you would need to flip to convert integer a to integer b. # XOR of a and b will have 1s where the bits of a and b differ xor_val = a ^ b # Count the number of 1s in the binary representation of XOR value count = 0 while xor_val: count += xor_val & 1 xor_val >>= 1 return count"},{"question":"**Scenario:** You are working as a software engineer tasked with stream processing for a financial transaction system. The system captures a stream of transaction tuples (each containing an amount and a sign indicating addition or subtraction). Your goal is to determine if the transactions net out to a single unique amount. **Problem Statement:** Implement a function `is_one_sparse(stream: List[Tuple[int, str]]) -> Optional[int]` that processes a stream of transaction tuples to determine if the stream is 1-sparse. If the stream is 1-sparse, return the unique amount; otherwise, return `None`. **Function Signature:** ```python def is_one_sparse(stream: List[Tuple[int, str]]) -> Optional[int]: pass ``` **Input:** - List of tuples, where each tuple consists of: - An integer representing the transaction amount (0 ≤ amount ≤ 10^9). - A character \'+\' or \'-\' indicating addition or subtraction. **Output:** - Integer representing the unique amount if 1-sparse. - `None` if the stream is not 1-sparse. **Constraints:** - The length of the stream is between 1 and 10^5. **Examples:** 1. `is_one_sparse([(4,\'+\'), (2,\'+\'), (2,\'-\'), (4,\'+\'), (3,\'+\'), (3,\'-\')]) -> 4` 2. `is_one_sparse([(2,\'+\'), (2,\'+\'), (2,\'+\'), (2,\'+\'), (2,\'+\'), (2,\'+\'), (2,\'+\')]) -> 2` 3. `is_one_sparse([(2,\'+\'), (2,\'+\'), (2,\'+\'), (2,\'+\'), (2,\'+\'), (2,\'+\'), (1,\'+\')]) -> None` **Explanation & Steps:** 1. Process each tuple: Track the net sum of the numbers and the signs. 2. Sum bitwise contributions from numbers keeping a running total. 3. If the computed results show consistent with only one number being non-zero, return that amount; otherwise, return `None`. Implement the `is_one_sparse` function ensuring efficiency and correctness through edge case handling and optimized performance.","solution":"from typing import List, Tuple, Optional def is_one_sparse(stream: List[Tuple[int, str]]) -> Optional[int]: count = {} for value, sign in stream: if value not in count: count[value] = 0 if sign == \'+\': count[value] += 1 elif sign == \'-\': count[value] -= 1 unique_values = [key for key, val in count.items() if val > 0] if len(unique_values) == 1: return unique_values[0] else: return None"},{"question":"Polynomial Differentiator You are tasked with implementing a method to differentiate a polynomial represented by the `Polynomial` class provided. The differentiation operation involves computing the derivative of the polynomial with respect to one of its variables. Define a `Polynomial` class method called `differentiate(variable_index: int) -> Polynomial`: Method Requirements: 1. **Input**: * An integer representing the index of the variable with respect to which differentiation is performed (e.g., if 1, then differentiate with respect to ( a_1 )). 2. **Output**: * Returns a new `Polynomial` that is the derivative of the original polynomial with respect to the given variable. 3. **Constraints**: * If the variable does not exist in any monomial, the derivative should be 0. * If there are no monomials, the derivative should be 0. * All intermediate simplifications should adhere to standard algebraic rules. 4. **Performance**: * Aim for efficient computation considering the provided complexities of operations induced by the Monomial and Polynomial classes. 5. **Validation**: * Handle edge cases like differentiation of constant polynomials or variable indices that are not present in the polynomial. # Example: ```python # Definitions and examples of given Polynomial and Monomial classes are assumed to be imported poly = Polynomial([ Monomial({1: 2, 2: 1}, 3), # Represents: 3(a_1)^2(a_2) Monomial({2: 1}, 2), # Represents: 2(a_2) Monomial({}, 5) # Represents: 5 ]) # Differentiating with respect to a_1 (index 1) derivative_a1 = poly.differentiate(1) print(derivative_a1) # Should output a polynomial equivalent to: 6(a_1)(a_2) # Differentiating with respect to a_2 (index 2) derivative_a2 = poly.differentiate(2) print(derivative_a2) # Should output a polynomial equivalent to: 3(a_1)^2 + 2 ``` **Function Signature**: ```python def differentiate(self, variable_index: int) -> Polynomial: ``` Implement this method within the `Polynomial` class.","solution":"from typing import List, Dict class Monomial: def __init__(self, exponents: Dict[int, int], coefficient: float): self.exponents = exponents # A dictionary representing the exponents of each variable self.coefficient = coefficient def differentiate(self, variable_index: int) -> \'Monomial\': Differentiates this monomial with respect to the given variable. if variable_index in self.exponents: new_exponents = self.exponents.copy() exponent = new_exponents[variable_index] new_coefficient = self.coefficient * exponent if exponent == 1: del new_exponents[variable_index] else: new_exponents[variable_index] -= 1 return Monomial(new_exponents, new_coefficient) else: # If the variable is not present in the monomial, the derivative is zero return Monomial({}, 0) def __repr__(self): return f\\"Monomial({self.exponents}, {self.coefficient})\\" class Polynomial: def __init__(self, monomials: List[Monomial]): self.monomials = monomials def differentiate(self, variable_index: int) -> \'Polynomial\': Differentiates the polynomial with respect to the given variable index. differentiated_monomials = [ monomial.differentiate(variable_index) for monomial in self.monomials ] differentiated_monomials = [m for m in differentiated_monomials if m.coefficient != 0] return Polynomial(differentiated_monomials) def __repr__(self): return f\\"Polynomial({self.monomials})\\""},{"question":"You are given a directed graph representing a set of processes, where each vertex represents a process, and an edge from vertex A to vertex B means process A is dependent on process B. Your task is to implement a function `detect_cycle` that determines whether there is a cyclic dependency among these processes. # Input: - `graph`: A dictionary representing the adjacency list of the graph, where keys are process names (strings) and values are lists of processes (strings) that the key process depends on. # Output: - Return `True` if there is a cycle in the graph, otherwise, return `False`. # Constraints: - The graph contains at most 1000 vertices. - Each vertex name is a string of up to 20 characters. - The graph may have up to 10,000 edges. # Example: ```python graph1 = { \'A\': [\'B\', \'C\'], \'B\': [\'D\'], \'C\': [\'F\'], \'D\': [\'E\', \'F\'], \'E\': [\'B\'], \'F\': [] } graph2 = { \'A\': [\'B\', \'C\'], \'B\': [\'C\'], \'C\': [], \'D\': [\'A\', \'C\'] } print(detect_cycle(graph1)) # Output: True (due to the cycle B -> D -> E -> B) print(detect_cycle(graph2)) # Output: False ``` # Function Signature: ```python def detect_cycle(graph: Dict[str, List[str]]) -> bool: pass ``` # Detailed Steps to Implement: 1. Define an enumeration class `TraversalState` with three states: WHITE, GRAY, and BLACK. 2. Create a helper function `is_in_cycle` that performs a DFS. 3. In `is_in_cycle`, recursively check the traversal state of each neighbor. If any neighbor is in the GRAY state, a cycle is detected. 4. Implement the main function `detect_cycle` that initializes the traversal states and uses `is_in_cycle` to check for cycles from each unvisited vertex. # Note: - Focus on edge cases like self-loops and disconnected graphs. - Handle the graph being empty or having isolated vertices properly. - Test your implementation thoroughly to cover diverse graph structures, including those with no edges, multiple disconnected components, and various cycle formations.","solution":"from typing import Dict, List class TraversalState: WHITE = 0 # Node has not been visited GRAY = 1 # Node is being visited (i.e., still in the recursion stack) BLACK = 2 # Node and its descendants have been fully visited def detect_cycle(graph: Dict[str, List[str]]) -> bool: traversal_state = {node: TraversalState.WHITE for node in graph} def is_in_cycle(node: str) -> bool: if traversal_state[node] == TraversalState.GRAY: return True if traversal_state[node] == TraversalState.BLACK: return False traversal_state[node] = TraversalState.GRAY for neighbor in graph[node]: if is_in_cycle(neighbor): return True traversal_state[node] = TraversalState.BLACK return False for node in graph: if traversal_state[node] == TraversalState.WHITE: if is_in_cycle(node): return True return False"},{"question":"# Context Alice and Bob want to communicate securely using the Diffie-Hellman key exchange algorithm. They must ensure their exchange is protected by using a large prime number and its primitive root. The key exchange will involve both parties keeping their private keys secret while sharing their respective public keys. # Problem Statement Write a Python function `secure_diffie_hellman_key_exchange(a: int, p: int)`. This function should: 1. Validate if `p` is a prime number. 2. Validate if `a` is a primitive root modulo `p`. 3. Generate private and public keys for Alice and Bob. 4. Compute the shared secret key for both parties. 5. Ensure both shared secret keys computed are equal. Return `True` if the shared keys match, otherwise return `False`. # Function Signature ```python def secure_diffie_hellman_key_exchange(a: int, p: int) -> bool: pass ``` # Input * `a (int)`: A candidate primitive root of `p`. * `p (int)`: A large prime number. # Output * `bool`: True if the shared keys match, otherwise False. # Constraints * `1 <= a < p` * `p` is a large prime number (also a requirement to be validated). * The solution should efficiently handle prime checking and primitive root verification. # Example ```python assert secure_diffie_hellman_key_exchange(2, 23) == True assert secure_diffie_hellman_key_exchange(2, 19) == False # assuming 2 is not a primitive root mod 19 ``` # Requirements * Utilize provided utility functions for prime checking, Euler’s totient function, and primitive root computation where appropriate. * Ensure efficient execution with consideration for edge cases and performance bottlenecks.","solution":"from sympy.ntheory import isprime, totient from random import randint def find_primitive_root(p): if not isprime(p): return -1 phi = p - 1 primitive_roots = [] for a in range(1, p): is_primitive_root = True for q in set(factorize(phi)): if pow(a, phi // q, p) == 1: is_primitive_root = False break if is_primitive_root: primitive_roots.append(a) if primitive_roots: return primitive_roots[0] # return the first primitive root found return -1 def factorize(n): Returns a list of prime factors of the given number `n` i = 2 factors = [] while i * i <= n: if n % i: i += 1 else: n //= i factors.append(i) if n > 1: factors.append(n) return factors def secure_diffie_hellman_key_exchange(a: int, p: int) -> bool: if not isprime(p): return False primitive_root = find_primitive_root(p) if primitive_root == -1 or a != primitive_root: return False # Private keys for Alice and Bob alice_private_key = randint(1, p - 1) bob_private_key = randint(1, p - 1) # Public keys alice_public_key = pow(a, alice_private_key, p) bob_public_key = pow(a, bob_private_key, p) # Shared secret keys alice_shared_secret = pow(bob_public_key, alice_private_key, p) bob_shared_secret = pow(alice_public_key, bob_private_key, p) return alice_shared_secret == bob_shared_secret # Example use case assert secure_diffie_hellman_key_exchange(5, 23) == True assert secure_diffie_hellman_key_exchange(2, 23) == False # since 2 is not a primitive root modulo 23"},{"question":"In-Order Successor in a Binary Search Tree Context You are given a Binary Search Tree (BST) and a reference to a node within it. Your task is to find the in-order successor of the given node. The in-order successor of a node is the node with the smallest value greater than the given node\'s value. Task Implement the function `successor(root, node)` that returns the in-order successor of the specified node. If the node does not have an in-order successor (i.e., it is the last node in an in-order traversal), return `None`. Function Signature ```python def successor(root: TreeNode, node: TreeNode) -> Optional[TreeNode]: ``` Input * `root`: The root of the BST, a `TreeNode` object. * `node`: The specified node within the BST, a `TreeNode` object that has been assured to be present in the tree. Output * The in-order successor of the `node`, or `None` if there is no successor. Examples ```python # Example 1 # Tree: 20 # / # 8 22 # / # 4 12 # / # 10 14 root = TreeNode(20) root.left = TreeNode(8) root.right = TreeNode(22) root.left.left = TreeNode(4) root.left.right = TreeNode(12) root.left.right.left = TreeNode(10) root.left.right.right = TreeNode(14) # The in-order successor of node with value 8 node = root.left print(successor(root, node).val) # Output: 10 # The in-order successor of node with value 14 node = root.left.right.right print(successor(root, node)) # Output: 20, as a TreeNode or its .val attribute ``` Constraints * The input BST will contain unique values. * `node` is guaranteed to be a node in the BST. * Try to optimize for O(h) time complexity.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def successor(root: TreeNode, node: TreeNode) -> TreeNode: # If the node has a right child, its successor is the leftmost node in its right subtree if node.right: n = node.right while n.left: n = n.left return n # If the node does not have a right child, we need to find the lowest ancestor # for which given node would be in left subtree successor = None current = root while current: if node.val < current.val: successor = current current = current.left elif node.val > current.val: current = current.right else: break return successor"},{"question":"# Coding Challenge **Scenario**: In software engineering, efficient memory allocation often requires understanding powers of two, as computer memory and various data structures (like heaps and hash tables) frequently connect to them. Understanding whether a number is a power of two is crucial in various applications, including error detection and optimizing algorithms. **Challenge**: Write a function that takes an integer as input and returns a boolean indicating whether the integer is a power of two. **Function Signature**: ```python def is_power_of_two(n: int) -> bool: pass ``` **Input**: * An integer `n`, where `-2^31 <= n <= 2^31 - 1`. **Output**: * A boolean, `True` if `n` is a power of two, otherwise `False`. **Constraints**: * The solution should have a time complexity of O(1). * The solution should handle both positive and negative integers but only return `True` for powers of two that are positive integers. **Examples**: ```python assert is_power_of_two(1) == True # 2^0 assert is_power_of_two(16) == True # 2^4 assert is_power_of_two(0) == False # 0 is not a power of two assert is_power_of_two(-16) == False # Negatives are not considered assert is_power_of_two(218) == False # 218 is not a power of two ``` **Detailed Explanation**: 1. A number `n` is considered a power of two if you can write it as `2^k` where `k` is a non-negative integer. 2. Using bit manipulation, a power of two will have only one bit set in its binary representation. 3. The function checks if `n` is positive and evaluates `n & (n-1)` to ensure it\'s zero.","solution":"def is_power_of_two(n: int) -> bool: Determines if the given integer n is a power of two. :param n: Integer to be checked :return: True if n is a power of two, False otherwise if n <= 0: return False return (n & (n - 1)) == 0"},{"question":"# Python Function for Counting Distinct Paths You are climbing a staircase. It takes a given number of `steps` to reach the top. Each time you can either climb 1 or 2 steps. Write a Python function to calculate the number of distinct ways to reach the top of the staircase. Optimize your solution to run in O(n) time complexity and O(1) space complexity. Function Signature ```python def distinct_paths(steps: int) -> int: ``` Input * `steps` (Integer): This is a positive integer representing the total number of steps to the top of the staircase (1 ≤ steps ≤ 10^6). Output * Return an integer representing the number of distinct ways to reach the top. Implementation Details 1. Use an optimized dynamic programming approach without storing the complete sequence. 2. Ensure the function can handle large inputs efficiently. **Constraints:** * The function should run efficiently with steps up to 1,000,000. Example ```python assert distinct_paths(1) == 1 assert distinct_paths(2) == 2 assert distinct_paths(3) == 3 assert distinct_paths(4) == 5 assert distinct_paths(5) == 8 ``` **Explanation:** For `steps = 4`, you can reach the top in the following ways: 1+1+1+1, 1+1+2, 1+2+1, 2+1+1, 2+2.","solution":"def distinct_paths(steps: int) -> int: Function to calculate the number of distinct ways to reach the top of a staircase with a given number of steps where you can either climb 1 or 2 steps each time. if steps <= 1: return 1 # Initialize base values prev2 = 1 # The number of ways to reach step 0 prev1 = 1 # The number of ways to reach step 1 for i in range(2, steps + 1): current = prev1 + prev2 prev2 = prev1 prev1 = current return prev1"},{"question":"# AVL Tree Implementation and Validation You are provided with the code of an AVL Tree, which is a self-balancing Binary Search Tree. The primary operations (insertion, rotation, balancing, height and balance updating) are already partially implemented. Your task is to complete the implementation and extend its functionality. # Objectives: 1. **Completion**: Ensure the provided AVL Tree code correctly implements insertion, rotation, balance factor calculations, and maintaining the height of the tree. 2. **Extend Functionality**: Implement an efficient method to delete a given node while maintaining the AVL tree properties. # Specific Tasks: 1. **Complete the `insert` Method**: - Ensure proper handling of duplicate keys. - Make sure the tree remains balanced after the insertion. 2. **Implement the `delete` Method**: - This method should remove a node with the given key and maintain the AVL tree properties. 3. **In-Order Traversal**: - Verify the correctness of the in-order traversal to ensure nodes remain in sorted order. # Deliverables: 1. Complete Python code for the following methods: - `insert` - `delete` # Function Signatures: ```python def insert(self, key: int) -> None: Inserts a key into the AVL tree. Ensures no duplicate keys and maintains AVL properties. def delete(self, key: int) -> None: Deletes a key from the AVL tree. Maintains AVL properties after deletion. ``` # Testing: The following test cases should be considered: 1. Normal insertion and deletion operations. 2. Edge case of deleting from an empty tree. 3. Inserting duplicate keys. 4. Ensuring the tree remains balanced after multiple insertions and deletions. 5. Validate in-order traversal gives sorted keys. # Constraints: - Key values will be integers. - The initial tree will be empty. Implement the methods ensuring optimal time and space complexity as per the characteristics of AVL Trees.","solution":"class AVLTreeNode: def __init__(self, key): self.key = key self.left = None self.right = None self.height = 1 class AVLTree: def __init__(self): self.root = None def get_height(self, node): if not node: return 0 return node.height def get_balance(self, node): if not node: return 0 return self.get_height(node.left) - self.get_height(node.right) def left_rotate(self, z): y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self.get_height(z.left), self.get_height(z.right)) y.height = 1 + max(self.get_height(y.left), self.get_height(y.right)) return y def right_rotate(self, z): y = z.left T3 = y.right y.right = z z.left = T3 z.height = 1 + max(self.get_height(z.left), self.get_height(z.right)) y.height = 1 + max(self.get_height(y.left), self.get_height(y.right)) return y def insert(self, root, key): if not root: return AVLTreeNode(key) if key < root.key: root.left = self.insert(root.left, key) elif key > root.key: root.right = self.insert(root.right, key) else: return root root.height = 1 + max(self.get_height(root.left), self.get_height(root.right)) balance = self.get_balance(root) if balance > 1 and key < root.left.key: return self.right_rotate(root) if balance < -1 and key > root.right.key: return self.left_rotate(root) if balance > 1 and key > root.left.key: root.left = self.left_rotate(root.left) return self.right_rotate(root) if balance < -1 and key < root.right.key: root.right = self.right_rotate(root.right) return self.left_rotate(root) return root def min_value_node(self, node): current = node while current.left is not None: current = current.left return current def delete(self, root, key): if not root: return root if key < root.key: root.left = self.delete(root.left, key) elif key > root.key: root.right = self.delete(root.right, key) else: if root.left is None: return root.right elif root.right is None: return root.left temp = self.min_value_node(root.right) root.key = temp.key root.right = self.delete(root.right, temp.key) if not root: return root root.height = 1 + max(self.get_height(root.left), self.get_height(root.right)) balance = self.get_balance(root) if balance > 1 and self.get_balance(root.left) >= 0: return self.right_rotate(root) if balance > 1 and self.get_balance(root.left) < 0: root.left = self.left_rotate(root.left) return self.right_rotate(root) if balance < -1 and self.get_balance(root.right) <= 0: return self.left_rotate(root) if balance < -1 and self.get_balance(root.right) > 0: root.right = self.right_rotate(root.right) return self.left_rotate(root) return root def in_order_traversal(self, root, res): if root: self.in_order_traversal(root.left, res) res.append(root.key) self.in_order_traversal(root.right, res) return res def insert_key(self, key): self.root = self.insert(self.root, key) def delete_key(self, key): self.root = self.delete(self.root, key) def get_in_order(self): return self.in_order_traversal(self.root, [])"},{"question":"# Scenario You are tasked with implementing a sorting algorithm for a specialized piece of flash memory where write operations are significantly more expensive than read operations. Therefore, minimizing the number of writes is crucial. In this scenario, Cycle Sort is an optimal solution due to its minimal write operations. # Problem Statement Write a function `minimal_write_sort(arr)` in Python that sorts an array using the Cycle Sort algorithm. Your implementation should focus on minimizing the number of write operations. # Function Signature ```python def minimal_write_sort(arr: List[int]) -> List[int]: pass ``` # Input - `arr` (List[int]): A list of integers. # Output - Returns a sorted version of `arr`. # Constraints - The length of `arr` is between 0 and 10^4. - Elements of `arr` are integers ranging from -10^6 to 10^6. # Performance Requirements - The algorithm should perform in O(N^2) time complexity. - The algorithm should perform in O(1) space complexity. # Example ```python assert minimal_write_sort([4, 3, 2, 1]) == [1, 2, 3, 4] assert minimal_write_sort([2, 3, 2, 1, 2]) == [1, 2, 2, 2, 3] assert minimal_write_sort([1]) == [1] assert minimal_write_sort([]) == [] ``` # Notes - Handle edge cases such as empty arrays, arrays with one element, arrays with duplicate values, and already sorted arrays effectively. - Ensure that your implementation adheres to the in-place sorting requirement, without using extra memory for another array or data structure.","solution":"def minimal_write_sort(arr): Sort an array using Cycle Sort, minimizing the number of write operations. n = len(arr) for cycle_start in range(n - 1): item = arr[cycle_start] pos = cycle_start for i in range(cycle_start + 1, n): if arr[i] < item: pos += 1 if pos == cycle_start: continue while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] while pos != cycle_start: pos = cycle_start for i in range(cycle_start + 1, n): if arr[i] < item: pos += 1 while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] return arr"},{"question":"# Implementing a Wildcard-Enabled Word Search Context You are tasked with building an efficient data structure capable of storing words and allowing for searches that support wildcards. Specifically, the wildcard character `.` can match any single letter. This is useful, for example, in a word puzzle solver, where some letters are unknown and represented by `.`. Objectives - Implement a class `WordDictionary` that supports add and search operations. - The `add_word` function should add a word to the data structure. - The `search` function should support \'.\' wildcards and return `True` if a word matching the search pattern exists in the data structure, and `False` otherwise. Input and Output - The `add_word(word: str) -> None` method: - **Input**: a single word (string). - **Output**: None. - The `search(word: str) -> bool` method: - **Input**: a single search pattern (string). - **Output**: Boolean indicating if any word in the data structure matches the search pattern. Constraints 1. The words consist of lowercase English letters (\'a\' to \'z\') only. 2. Search patterns are similarly composed of lowercase letters and \'.\' characters. 3. Each `add_word` and `search` operation should be efficient with considerations for time and space complexity. 4. Word length is capped at 1000 characters. You can assume a maximum of 50,000 words. Example ```python wd = WordDictionary() wd.add_word(\\"bad\\") wd.add_word(\\"dad\\") wd.add_word(\\"mad\\") print(wd.search(\\"pad\\")) # -> False print(wd.search(\\"bad\\")) # -> True print(wd.search(\\".ad\\")) # -> True print(wd.search(\\"b..\\")) # -> True ``` Your Task Implement the `WordDictionary` class, including the `add_word` and `search` methods, ensuring correctness and efficiency. ```python class TrieNode(object): def __init__(self, letter, is_terminal=False): self.children = dict() self.letter = letter self.is_terminal = is_terminal class WordDictionary: def __init__(self): self.root = TrieNode(\\"\\") def add_word(self, word): # Your implementation here def search(self, word, node=None): # Your implementation here ```","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class WordDictionary: def __init__(self): self.root = TrieNode() def add_word(self, word: str) -> None: node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, word: str) -> bool: return self._search_recursive(word, 0, self.root) def _search_recursive(self, word: str, index: int, node: TrieNode) -> bool: if index == len(word): return node.is_end_of_word char = word[index] if char == \'.\': for child in node.children.values(): if self._search_recursive(word, index + 1, child): return True else: if char in node.children: return self._search_recursive(word, index + 1, node.children[char]) return False"},{"question":"Context Given the quick sort algorithm, you need to implement a similar sorting algorithm but with added functionality. You should write a function that not only sorts the array but also returns the number of swaps made during the sort. This will help understand the \'cost\' of sorting in terms of swaps. Task Write a function `quick_sort_with_swaps(arr: List[int]) -> Tuple[List[int], int]` that sorts an array using Quick Sort algorithm and also counts the number of swaps made during the sorting process. Input - An unsorted array of integers, `arr` with length `n` where `1 <= n <= 10^5`. Output - A tuple containing: - The sorted array. - An integer representing the number of swaps made during the sorting. Constraints - The function should operate with an average time complexity of O(n log(n)) and handle arrays of length up to 100,000 efficiently. - You should maintain the logic of Quick Sort with appropriate handling for better pivot selection to prevent worst-case O(n^2) scenarios. Example ```python arr = [3, 6, 8, 10, 1, 2, 1] result = quick_sort_with_swaps(arr) # Expected output: ([1, 1, 2, 3, 6, 8, 10], number_of_swaps) arr = [1, 2, 3, 4, 5] result = quick_sort_with_swaps(arr) # Expected output: ([1, 2, 3, 4, 5], number_of_swaps) ``` Ensure to handle edge cases like empty arrays and arrays with repeated values correctly. Test the implementation with various scenarios to verify its correctness and efficiency.","solution":"from typing import List, Tuple def quick_sort_with_swaps(arr: List[int]) -> Tuple[List[int], int]: Sorts an array using Quick Sort algorithm and counts the number of swaps made during the sorting process. Parameters: arr (List[int]): The list of integers to sort. Returns: Tuple[List[int], int]: A tuple containing the sorted array and the number of swaps made. def partition(low, high): pivot = arr[high] i = low - 1 swap_count = 0 for j in range(low, high): if arr[j] <= pivot: i += 1 arr[i], arr[j] = arr[j], arr[i] swap_count += 1 arr[i + 1], arr[high] = arr[high], arr[i + 1] swap_count += 1 return i + 1, swap_count def quick_sort(low, high): if low < high: pi, swaps = partition(low, high) total_swaps[0] += swaps quick_sort(low, pi - 1) quick_sort(pi + 1, high) total_swaps = [0] quick_sort(0, len(arr) - 1) return arr, total_swaps[0]"},{"question":"# Priority Queue Implementation with Custom Comparator You are required to implement a Min-Priority Queue using a dynamically allocated array (e.g., Python list) that supports the following operations efficiently: 1. **Insert an element** in O(log n) time. 2. **Get and remove the element with the smallest priority** in O(log n) time. This can be achieved using a binary heap data structure (min-heap) rather than a linear array. **Specifications**: - **Function 1**: `insert(self, item, priority)` Insert a new element with the given priority into the priority queue. - Input: `item` (any data type), `priority` (int) - Output: None - **Function 2**: `extract_min(self)` Remove and return the element with the smallest priority. - Input: None - Output: Element with the smallest priority (any data type) - **Function 3**: `size(self)` Return the size of the priority queue. - Input: None - Output: Integer representing the number of elements - **Function 4**: `peek_min(self)` Return (without removing) the element with the smallest priority. - Input: None - Output: Element with the smallest priority (any data type) **Constraints**: - Priorities are integers. - The queue can handle up to `10^6` elements. - Must handle edge cases like extracting from an empty queue. ```python class MinPriorityQueue: def __init__(self): Initialize an empty priority queue. self.heap = [] def size(self): Return the size of the priority queue. return len(self.heap) def insert(self, item, priority): Insert a new item with the given priority. :param item: The item to be added. :param priority: The priority of the item. # Implementation goes here def extract_min(self): Remove and return the item with the smallest priority. :return: The item with the smallest priority. # Implementation goes here def peek_min(self): Return (without removing) the item with the smallest priority. :return: The item with the smallest priority. # Implementation goes here ``` **Hints:** - Consider implementing a binary heap. - Use helper functions like `_bubble_up` to maintain the heap invariant while inserting, and `_bubble_down` for when extracting the min element.","solution":"class MinPriorityQueue: def __init__(self): Initialize an empty priority queue. self.heap = [] def size(self): Return the size of the priority queue. return len(self.heap) def insert(self, item, priority): Insert a new item with the given priority. :param item: The item to be added. :param priority: The priority of the item. self.heap.append((priority, item)) self._bubble_up(len(self.heap) - 1) def extract_min(self): Remove and return the item with the smallest priority. :return: The item with the smallest priority. if not self.heap: raise IndexError(\'extract_min from an empty priority queue\') self._swap(0, len(self.heap) - 1) min_item = self.heap.pop() self._bubble_down(0) return min_item[1] def peek_min(self): Return (without removing) the item with the smallest priority. :return: The item with the smallest priority. if not self.heap: raise IndexError(\'peek_min from an empty priority queue\') return self.heap[0][1] def _bubble_up(self, index): parent_index = (index - 1) // 2 if index > 0 and self.heap[index][0] < self.heap[parent_index][0]: self._swap(index, parent_index) self._bubble_up(parent_index) def _bubble_down(self, index): smallest = index left_child = 2 * index + 1 right_child = 2 * index + 2 if left_child < len(self.heap) and self.heap[left_child][0] < self.heap[smallest][0]: smallest = left_child if right_child < len(self.heap) and self.heap[right_child][0] < self.heap[smallest][0]: smallest = right_child if smallest != index: self._swap(index, smallest) self._bubble_down(smallest) def _swap(self, i, j): self.heap[i], self.heap[j] = self.heap[j], self.heap[i]"},{"question":"Implement a scalable hash table with separate chaining for collision resolution, including dynamic resizing functionality. # Requirements Implement the `ScalableHashTable` class that enhances the provided `SeparateChainingHashTable` by adding the ability to resize dynamically. The class should include the following methods in addition to the inherited methods: 1. **Resize**: Dynamically resize the hash table when the load factor exceeds 0.75 or if reduced the load factor goes below 0.25. 2. **Put**: Override the provided put method to trigger a resize operation when necessary. # Method Specifications 1. `Resize`: - Input: Nothing. - Operation: Double the size of the internal array when load factor > 0.75, half the size of the internal array when the load factor < 0.25, and rehash all keys. 2. `Put`: - Input arguments: `key` (str or int), `value` (any type). - Operation: Insert/Update a key-value pair and trigger resize operation when load factor thresholds are crossed. # Example ```python table = ScalableHashTable() table.put(\'hello\', \'world\') assert table.get(\'hello\') == \'world\' table.put(\'foo\', \'bar\') assert table.get(\'foo\') == \'bar\' table.put(2, \'baz\') assert table.get(2) == \'baz\' ``` # Constraints - The internal array size must always be a power of 2. - Initial size of the internal array must be 4. **Additional Notes**: - Ensure robust performance even across resize operations. - Ensure hash collisions are managed effectively post resizing.","solution":"from collections import defaultdict class ScalableHashTable: def __init__(self): self.size = 4 self.table = [[] for _ in range(self.size)] self.num_elements = 0 def put(self, key, value): if self.num_elements / self.size > 0.75: self.resize(self.size * 2) index = hash(key) % self.size for pair in self.table[index]: if pair[0] == key: pair[1] = value return self.table[index].append([key, value]) self.num_elements += 1 def get(self, key): index = hash(key) % self.size for pair in self.table[index]: if pair[0] == key: return pair[1] return None def remove(self, key): index = hash(key) % self.size for pair in self.table[index]: if pair[0] == key: self.table[index].remove(pair) self.num_elements -= 1 if self.num_elements / self.size < 0.25 and self.size > 4: self.resize(self.size // 2) return True return False def resize(self, new_size): old_table = self.table self.size = new_size self.table = [[] for _ in range(new_size)] self.num_elements = 0 for bucket in old_table: for pair in bucket: self.put(*pair)"},{"question":"# Pancake Sort Assessment You work as a developer for a kitchenware company that models the cooking process digitally. One of the tasks involves sorting a stack of pancakes by size using a hypothetical pancake flipper. The objective is to implement a sorting algorithm, known as the Pancake Sort, that simulates this sorting process. Task Write a Python function `pancake_sort(arr: List[int]) -> List[int]` that sorts an array of integers using the Pancake Sort algorithm. The function should return the sorted array. Input Format - A list of integers `arr` where each integer represents the size of a pancake. Output Format - A list of integers, sorted in ascending order. Constraints - The input array `arr` can have up to 1000 elements. - Each element is an integer in the range [1, 1000]. Examples **Example 1:** ```python arr = [3, 6, 2, 7, 4, 1, 8, 5] print(pancake_sort(arr)) # Output: [1, 2, 3, 4, 5, 6, 7, 8] ``` **Example 2:** ```python arr = [10, 5, 3, 1, 6, 2] print(pancake_sort(arr)) # Output: [1, 2, 3, 5, 6, 10] ``` Performance Requirements - The algorithm should work efficiently within the provided constraints. - It should have a worst-case time complexity of O(N^2). # Scenario Imagine you have a stack of pancakes of different sizes, and you are allowed to flip over one section of the stack at a time. Initially, the largest pancake needs to be at the bottom. Using the Pancake Sort, sort the pancakes to have the smallest on top and the largest at the bottom. Your function should ideally perform two key actions: 1. Find the maximum element in the unsorted section of the array. 2. Reverse the required sections of the array to position this maximum element correctly. Make sure to consider edge cases like handling an already sorted array or an array with all elements the same.","solution":"from typing import List def pancake_sort(arr: List[int]) -> List[int]: def flip(sub_arr: List[int], k: int) -> None: Flips the first k elements of sub_arr. i = 0 j = k - 1 while i < j: sub_arr[i], sub_arr[j] = sub_arr[j], sub_arr[i] i += 1 j -= 1 n = len(arr) for size in range(n, 1, -1): # Find the index of the maximum element in the current unsorted section max_index = arr.index(max(arr[:size])) # Bring the maximum element to the front if it\'s not already there if max_index != 0: flip(arr, max_index + 1) # Bring the maximum element to its correct position flip(arr, size) return arr"},{"question":"# Question You are given an unsigned integer `n`, write a function `count_ones` that returns the number of \'1\' bits in its binary representation. Implement the function in two different approaches: 1. **Recursive Approach**: Apply Brian Kernighan\'s Algorithm recursively. 2. **Iterative Approach**: Apply Brian Kernighan\'s Algorithm iteratively. # Function Signature ```python def count_ones_recur(n: int) -> int: Recursively counts the number of \'1\' bits in the binary representation of n :param n: An unsigned integer :return: The number of \'1\' bits in the binary representation of n def count_ones_iter(n: int) -> int: Iteratively counts the number of \'1\' bits in the binary representation of n :param n: An unsigned integer :return: The number of \'1\' bits in the binary representation of n ``` # Input - A single unsigned integer `n` (0 ≤ n ≤ (2^{32} - 1)) # Output - A single integer representing the number of \'1\' bits in the binary representation of `n`. # Example ```python assert count_ones_recur(11) == 3 assert count_ones_iter(11) == 3 assert count_ones_recur(0) == 0 assert count_ones_iter(0) == 0 assert count_ones_recur(255) == 8 assert count_ones_iter(255) == 8 ``` **Constraints**: - Ensure your solution is efficient in terms of time complexity. - Consider edge cases such as n = 0 and n having a high density of \'1\' bits. # Performance Requirements: - Both functions should run in O(k) time complexity, where k is the number of \'1\' bits in the binary representation of `n`. # Note: You are expected to provide a well-documented and easy-to-understand implementation using the specified approach for each function.","solution":"def count_ones_recur(n: int) -> int: Recursively counts the number of \'1\' bits in the binary representation of n using Brian Kernighan\'s Algorithm. :param n: An unsigned integer :return: The number of \'1\' bits in the binary representation of n if n == 0: return 0 return 1 + count_ones_recur(n & (n - 1)) def count_ones_iter(n: int) -> int: Iteratively counts the number of \'1\' bits in the binary representation of n using Brian Kernighan\'s Algorithm. :param n: An unsigned integer :return: The number of \'1\' bits in the binary representation of n count = 0 while n: n = n & (n - 1) count += 1 return count"},{"question":"# Repeated String Match Problem Problem Statement: Given two strings `A` and `B`, determine the minimum number of times `A` needs to be repeated so that `B` becomes a substring of the repeated `A`. If `B` cannot be a substring of a repeated `A`, return `-1`. Function Signature: ```python def repeated_string_match(A: str, B: str) -> int: pass ``` Input: * Two strings `A` and `B` where 1 <= len(A), len(B) <= 10,000. Output: * An integer representing the minimum number of times `A` must be repeated to make `B` a substring. If it\'s not possible, return `-1`. Constraints: * The length of A and B is between 1 and 10,000. * Aim to achieve a solution with reasonable performance constraints. Example: ```python A = \\"abcd\\" B = \\"cdabcdab\\" print(repeated_string_match(A, B)) # Output: 3 ``` Explanation: By repeating A three times (\\"abcdabcdabcd\\"), B (\\"cdabcdab\\") becomes a substring of the result. B is not a substring of A repeated two times (\\"abcdabcd\\"). Edge Cases to Consider: * When B is considerably larger than A. * When B is a rotation or rearrangement of parts of A. Your task is to implement the function `repeated_string_match` to solve the problem efficiently, taking into account potential edge cases and performance considerations.","solution":"def repeated_string_match(A: str, B: str) -> int: Returns the minimum number of times A needs to be repeated so that B becomes a substring of the repeated A. If it\'s not possible, return -1. # Calculate the minimum number of repetitions needed min_repeats = (len(B) - 1) // len(A) + 1 # Check if B is a substring of the repeated string if B in A * min_repeats: return min_repeats if B in A * (min_repeats + 1): return min_repeats + 1 # If not found in the above checks, return -1 return -1"},{"question":"# RSA Key Pair Generation and Encryption/Decryption Problem Statement You are to implement an RSA encryption and decryption functionality, including key pair generation, using RSA principles. The implementation must include enhancements over the provided primality testing mechanism. Function Signature Implement the following three functions: 1. `generate_key(k: int, seed: Optional[int] = None) -> Tuple[int, int, int]`: - **Input**: `k` an integer representing the number of bits for the modulus n, `seed` an optional integer for random seed. - **Output**: A tuple `(n, e, d)` where `n` is the modulus, `e` is the encryption exponent, and `d` is the decryption exponent. 2. `encrypt(data: int, e: int, n: int) -> int`: - **Input**: `data` the integer to be encrypted, `e` and `n` are the public key components. - **Output**: The encrypted integer. 3. `decrypt(encrypted_data: int, d: int, n: int) -> int`: - **Input**: `encrypted_data` the integer to be decrypted, `d` and `n` are the private key components. - **Output**: The decrypted integer. Requirements - Use the efficient approach for prime checking. - Ensure the generated keys meet RSA\'s mathematical requirements. Constraints - `k` is guaranteed to be such that reasonable prime numbers of `k` bits exist. - Implement any auxiliary functions as necessary within the same module. - Ensure efficient prime number generation and modular inverse calculation. Example ```python n, e, d = generate_key(16) data = 20 encrypted = encrypt(data, e, n) decrypted = decrypt(encrypted, d, n) assert decrypted == data ```","solution":"import random from typing import Optional, Tuple def is_prime(n, k=128): Test if a number is prime using the Miller-Rabin primality test. if n == 2 or n == 3: return True if n <= 1 or n % 2 == 0: return False # Write n-1 as 2^r * d r, s = 0, n - 1 while s % 2 == 0: r += 1 s //= 2 # Perform k tests of primality for _ in range(k): a = random.randrange(2, n - 1) x = pow(a, s, n) if x == 1 or x == n - 1: continue for _ in range(r - 1): x = pow(x, 2, n) if x == n - 1: break else: return False return True def generate_prime_candidate(length): Generate an odd integer randomly. p = random.getrandbits(length) p |= (1 << length - 1) | 1 return p def generate_prime_number(length): Generate a prime number of bit length \'length\'. p = 4 while not is_prime(p, 128): p = generate_prime_candidate(length) return p def gcd(a, b): Compute the greatest common divisor using Euclid\'s algorithm. while b != 0: a, b = b, a % b return a def modinv(a, m): Compute the modular inverse using the extended Euclidean algorithm. m0, x0, x1 = m, 0, 1 while a > 1: q = a // m m, a = a % m, m x0, x1 = x1 - q * x0, x0 if x1 < 0: x1 += m0 return x1 def generate_key(k: int, seed: Optional[int] = None) -> Tuple[int, int, int]: if seed is not None: random.seed(seed) p = generate_prime_number(k // 2) q = generate_prime_number(k // 2) n = p * q phi = (p - 1) * (q - 1) e = 65537 while gcd(e, phi) != 1: e += 2 d = modinv(e, phi) return n, e, d def encrypt(data: int, e: int, n: int) -> int: return pow(data, e, n) def decrypt(encrypted_data: int, d: int, n: int) -> int: return pow(encrypted_data, d, n)"},{"question":"Find nth Digit in Number Sequence Context: You are required to find the nth digit in a continuous sequence of numbers starting from 1 (e.g., \\"123456789101112...\\"). This question will test your understanding of numerical sequences and efficient computation. Task: Implement the function `find_nth_digit(n)` that returns the nth digit in the sequence. Input: - **n** (1 <= n <= 2*10^9): An integer representing the position in the sequence. Output: - Returns an integer which is the nth digit in the continuous number sequence. Constraints: 1. The sequence starts from 1 and continues without any break. 2. Single digit numbers from 1 to 9 are followed by double digit from 10 to 99 and so on. Examples: 1. **Input**: `find_nth_digit(3)` - **Output**: `3` 2. **Input**: `find_nth_digit(11)` - **Output**: `0` 3. **Input**: `find_nth_digit(15)` - **Output**: `2` Performance Requirement: - The solution should be efficient in terms of both time and space complexity. Notes: - Optimize your function to handle very large values of `n` gracefully without performance degradation. - Be careful with edge cases around the transition points where the number of digits changes. ```python def find_nth_digit(n): Implement the code here length = 1 count = 9 start = 1 while n > length * count: n -= length * count length += 1 count *= 10 start *= 10 start += (n-1) // length s = str(start) return int(s[(n-1) % length]) ```","solution":"def find_nth_digit(n): Find the nth digit in the continuous sequence of numbers starting from 1. length = 1 count = 9 start = 1 while n > length * count: n -= length * count length += 1 count *= 10 start *= 10 start += (n - 1) // length digit_str = str(start) return int(digit_str[(n - 1) % length])"},{"question":"You are tasked with implementing a function to multiply two given matrices. The function will verify that the matrices are compatible for multiplication and return the product matrix. # Function Signature ```python def multiply(multiplicand: list[list[int]], multiplier: list[list[int]]) -> list[list[int]]: pass ``` # Input - `multiplicand` (List[List[int]]): A matrix of integers with dimensions (m times n). - `multiplier` (List[List[int]]): A matrix of integers with dimensions (n times p). # Output - Returns a matrix (List[List[int]]) which is the product of `multiplicand` and `multiplier` with dimensions (m times p). # Constraints - The number of columns in the `multiplicand` must be equal to the number of rows in the `multiplier`. - Elements in matrices will be non-negative integers. - Dimensions of matrices will be such that (1 leq m, n, p leq 100). # Requirements - Ensure efficient computation even on the upper constraint. - Handle edge cases where matrices are not compatible for multiplication by raising an appropriate exception. # Example ```python multiplicand = [ [1, 2], [3, 4] ] multiplier = [ [2, 0], [1, 2] ] # Expected output: # [ # [4, 4], # [10, 8] # ] print(multiply(multiplicand, multiplier)) ``` # Additional Notes - Consider the use of Python\'s list comprehensions for matrix initialization. - Optimize the nesting of loops if possible, keeping an eye on the (O(n^3)) complexity.","solution":"def multiply(multiplicand: list[list[int]], multiplier: list[list[int]]) -> list[list[int]]: # Get the dimensions of the matrices m = len(multiplicand) n = len(multiplicand[0]) p = len(multiplier[0]) # Ensure the matrices can be multiplied if len(multiplier) != n: raise ValueError(\\"Incompatible matrices for multiplication\\") # Initialize the product matrix with zeros product = [[0 for _ in range(p)] for _ in range(m)] # Perform matrix multiplication for i in range(m): for j in range(p): for k in range(n): product[i][j] += multiplicand[i][k] * multiplier[k][j] return product"},{"question":"# Task You are required to implement a queue data structure using a circular buffer approach to optimize space utilization. This will be an enhancement compared to the simple array queue. # Requirements * Implement a `CircularQueue` class with the following methods: - `__init__(self, capacity)`: Initializes the queue with a given capacity. - `enqueue(self, value)`: Adds an item to the rear of the queue. - `dequeue(self)`: Removes an item from the front of the queue. - `peek(self)`: Returns the front item without removing it. - `is_empty(self)`: Checks if the queue is empty. - `is_full(self)`: Checks if the queue is full. - `__len__(self)`: Returns the number of elements in the queue. - `__iter__(self)`: Iterates over the elements from front to rear. # Constraints - The queue must operate in O(1) time for `enqueue`, `dequeue`, and `peek` operations. - You must handle edge cases such as enqueueing to a full queue and dequeueing from an empty queue appropriately. - Your implementation must ensure that elements are managed in a circular fashion. # Example ```python queue = CircularQueue(5) queue.enqueue(1) queue.enqueue(2) queue.enqueue(3) print(queue.dequeue()) # Output: 1 print(queue.peek()) # Output: 2 queue.enqueue(4) queue.enqueue(5) queue.enqueue(6) for item in queue: print(item, end=\\" \\") # Output: 2 3 4 5 6 ``` # Implementation Notes - Use an array-based approach for the circular queue. - Ensure that your `enqueue` and `dequeue` operations correctly handle when the circular buffer wraps around to the beginning.","solution":"class CircularQueue: def __init__(self, capacity): self.capacity = capacity self.queue = [None] * capacity self.front = 0 self.rear = -1 self.size = 0 def enqueue(self, value): if self.is_full(): raise OverflowError(\\"Queue is full\\") self.rear = (self.rear + 1) % self.capacity self.queue[self.rear] = value self.size += 1 def dequeue(self): if self.is_empty(): raise IndexError(\\"Queue is empty\\") value = self.queue[self.front] self.queue[self.front] = None self.front = (self.front + 1) % self.capacity self.size -= 1 return value def peek(self): if self.is_empty(): raise IndexError(\\"Queue is empty\\") return self.queue[self.front] def is_empty(self): return self.size == 0 def is_full(self): return self.size == self.capacity def __len__(self): return self.size def __iter__(self): index = self.front num_elements = self.size while num_elements > 0: yield self.queue[index] index = (index + 1) % self.capacity num_elements -= 1"},{"question":"# Optimal Matrix Chain Multiplication **Context**: Given a chain of matrices, the Matrix Chain Multiplication problem determines the optimal way to multiply these matrices together. The goal is to find the parenthesization that minimizes the total number of scalar multiplications. **Task**: Write a function that takes an array `dims` representing the dimensions of matrices in the chain. The function should return the minimum number of scalar multiplications required and a string representing the optimal parenthesization order. Implement this using dynamic programming. **Function Signature**: ```python def matrix_chain_multiplication(dims: List[int]) -> Tuple[int, str]: pass ``` **Input**: - `dims`: A list of integers where the length is `n+1` for `n` number of matrices. The `i-th` matrix has dimensions `dims[i-1] x dims[i]`. **Output**: - A tuple containing: - An integer representing the minimum number of scalar multiplications needed. - A string that represents the optimal parenthesization. **Constraints**: - The length of `dims` is between 2 and 100 (inclusive). - All elements in `dims` are positive integers. **Example**: ```python dims = [30, 35, 15, 5, 10, 20, 25] result = matrix_chain_multiplication(dims) print(result) # Output: (15125, \'((A1(A2A3))((A4A5)A6))\') ``` # Explanation: - Matrices: A1: (30x35), A2: (35x15), A3: (15x5), A4: (5x10), A5: (10x20), A6: (20x25) - The optimal order found should minimize the total multiplications, which is 15125. - The string \'((A1(A2A3))((A4A5)A6))\' represents the parenthesization for achieving this minimum cost. **Hints**: 1. Use a DP table to keep track of costs. 2. Another table to store split points. 3. Recursively construct the optimal parenthesization string from the split points table. **Notes**: - Handle edge cases where the input array is of length 2 (one matrix).","solution":"from typing import List, Tuple def matrix_chain_multiplication(dims: List[int]) -> Tuple[int, str]: n = len(dims) - 1 m = [[0 for _ in range(n)] for _ in range(n)] s = [[0 for _ in range(n)] for _ in range(n)] for l in range(2, n + 1): for i in range(n - l + 1): j = i + l - 1 m[i][j] = float(\'inf\') for k in range(i, j): q = m[i][k] + m[k + 1][j] + dims[i] * dims[k + 1] * dims[j + 1] if q < m[i][j]: m[i][j] = q s[i][j] = k def construct_optimal_parens(s, i, j): if i == j: return f\\"A{i + 1}\\" else: return f\\"({construct_optimal_parens(s, i, s[i][j])}{construct_optimal_parens(s, s[i][j] + 1, j)})\\" optimal_parens = construct_optimal_parens(s, 0, n - 1) return m[0][n - 1], optimal_parens"},{"question":"# Context You are tasked with developing a sorted data collection mechanism that operates similarly to a stack but maintains elements in a sorted order automatically. This structure will be useful in scenarios where you frequently need to access the largest element quickly. # Task Implement an `OrderedStack` class to maintain sorted order of its elements such that the highest value is always at the top and the lowest at the bottom. Ensure your implementation handles edge cases and performs efficiently. # Requirements 1. **push(item)**: Insert an item into the stack while maintaining order. 2. **pop()**: Remove the top item from the stack and return it. 3. **peek()**: Return the top item without removing it. 4. **is_empty()**: Return `True` if the stack is empty, otherwise `False`. 5. **size()**: Return the number of items in the stack. # Input and Output Formats - Input: Method calls on the `OrderedStack` class. - Output: Return values from the methods. # Constraints - Items pushed onto the stack will be integers. - You may assume `pop()` and `peek()` methods are never called on an empty stack in valid use. # Example Usage Consider the following operations sequence: ```python stack = OrderedStack() stack.push(3) stack.push(1) stack.push(4) stack.push(2) assert stack.pop() == 4 # Topmost item assert stack.peek() == 3 # Now the topmost item after popping assert stack.size() == 3 # Three items left in stack assert stack.is_empty() == False # Stack is not empty ``` Implement the class as specified and ensure it adheres to the requirements.","solution":"import bisect class OrderedStack: def __init__(self): self.elements = [] def push(self, item): Insert an item into the stack while maintaining order. bisect.insort(self.elements, item) def pop(self): Remove the top item from the stack and return it. Assumes the stack is not empty. return self.elements.pop() def peek(self): Return the top item without removing it. Assumes the stack is not empty. return self.elements[-1] def is_empty(self): Return `True` if the stack is empty, otherwise `False`. return len(self.elements) == 0 def size(self): Return the number of items in the stack. return len(self.elements)"},{"question":"# Merge Sort Implementation Challenge You are tasked with implementing the Merge Sort algorithm. Merge Sort is highly regarded for its efficiency and stable sorting of data. In this challenge, you will write a function to sort an array of integers using Merge Sort. Task Write a function `merge_sort(arr: List[int]) -> List[int]` that takes an array of integers and returns the sorted array using the Merge Sort algorithm. Input Format - A list of integers `arr` where 1 ≤ len(arr) ≤ 10^5 and each integer is in the range -10^6 to 10^6. Output Format - A list of integers representing the sorted version of the input array in non-decreasing order. Constraints - Your algorithm should run in O(n log n) time complexity. - Use additional O(n) space for temporary arrays or lists. - Implement the `merge_sort` function accordingly. Example ```python >>> merge_sort([38, 27, 43, 3, 9, 82, 10]) [3, 9, 10, 27, 38, 43, 82] >>> merge_sort([5, 3, 8, 6, 2, 7, 4, 1]) [1, 2, 3, 4, 5, 6, 7, 8] >>> merge_sort([1]) [1] >>> merge_sort([]) [] ``` Scenario Consider you are working in a software company that manages a large database of user interactions. Periodically, you need to sort these interactions based on timestamps stored as integers. Given the stable and consistent performance of Merge Sort, it is chosen for sorting these large datasets. Implement the `merge_sort` function to handle this task effectively and efficiently.","solution":"from typing import List def merge_sort(arr: List[int]) -> List[int]: if len(arr) <= 1: return arr def merge(left: List[int], right: List[int]) -> List[int]: result = [] i = j = 0 while i < len(left) and j < len(right): if left[i] < right[j]: result.append(left[i]) i += 1 else: result.append(right[j]) j += 1 result.extend(left[i:]) result.extend(right[j:]) return result mid = len(arr) // 2 left = merge_sort(arr[:mid]) right = merge_sort(arr[mid:]) return merge(left, right)"},{"question":"License Key Reformatter **Context:** In developing a software distribution system, you need to reformat license keys provided by users to ensure they follow a specific grouping pattern. The provided license key may contain existing hyphens that need to be removed and then new hyphens added systematically to improve readability. **Task:** Write a Python function `reformat_license_key(key: str, k: int) -> str` to rearrange the given license key. The function should meet the following requirements: 1. All existing hyphens should be removed. 2. The remaining alphanumeric characters should be grouped such that each group contains `k` characters, separated by hyphens. 3. The first group can have fewer characters but must not be empty. **Function Signature:** ```python def reformat_license_key(key: str, k: int) -> str: ``` # Input - `key (str)`: A string consisting of alphanumeric characters and hyphens (\'-\'). Length of the string is up to 10,000 characters. - `k (int)`: An integer defining the size of each group formed after reformatting. 1 ≤ k ≤ 10,000. # Output - Returns the reformatted string following the new grouping rules. # Constraints - The string `key` and integer `k` will always be valid and meet the criteria given. # Example ```python assert reformat_license_key(\\"2-4A0r7-4k\\", 3) == \\"24-A0R-74K\\" assert reformat_license_key(\\"2-4A0r7-4k\\", 4) == \\"24A0-R74K\\" ``` Write a well-structured function to accomplish the task. Aim to maintain clarity, efficiency, and consider possible edge cases to ensure robustness.","solution":"def reformat_license_key(key: str, k: int) -> str: Reformats the license key to have each group contain k characters, separated by hyphens. The first group may be smaller but not empty. Args: key (str): The input license key containing alphanumeric characters and hyphens. k (int): The number of characters in each group. Returns: str: The reformatted license key. # Remove existing hyphens and convert to uppercase clean_key = key.replace(\'-\', \'\').upper() # Determine the size of the first group first_group_size = len(clean_key) % k or k # Initialize result with the first group result = clean_key[:first_group_size] # Process the remaining characters for i in range(first_group_size, len(clean_key), k): result += \'-\' + clean_key[i:i + k] return result"},{"question":"# Question You are participating in a coding competition where your task is to sort a list of integers using a specific sorting algorithm. Given a list of integers, you must implement the **Multi-Pass Selection Sort** algorithm. The Multi-Pass Selection Sort works as follows: 1. From the unsorted portion of the list, find the smallest element. 2. Swap this smallest element with the first element of the unsorted portion. 3. Mark this first element as sorted. 4. Repeat the process for the remaining unsorted portion of the list. Write a function `multi_pass_selection_sort(arr)` that sorts the input list `arr` using Multi-Pass Selection Sort. # Input - A list of integers `arr` (0 <= len(arr) <= 10^4, -10^6 <= arr[i] <= 10^6). # Output - A list of integers sorted in ascending order. # Constraints - Your solution should have a time complexity of (O(n^2)). - Your solution should not use additional memory, i.e., it should modify the input list in place. - Your solution should be robust and handle edge cases including empty or single-element lists. # Example ```python assert multi_pass_selection_sort([64, 34, 25, 12, 22, 11, 90]) == [11, 12, 22, 25, 34, 64, 90] assert multi_pass_selection_sort([5, 3, 8, 4, 2]) == [2, 3, 4, 5, 8] assert multi_pass_selection_sort([1]) == [1] assert multi_pass_selection_sort([]) == [] ```","solution":"def multi_pass_selection_sort(arr): Sorts a list of integers in ascending order using Multi-Pass Selection Sort. Parameters: arr (list): The list of integers to sort. Returns: list: The list sorted in ascending order. n = len(arr) for i in range(n): min_index = i for j in range(i + 1, n): if arr[j] < arr[min_index]: min_index = j arr[i], arr[min_index] = arr[min_index], arr[i] return arr"},{"question":"# Hailstone Sequence with Memoization Problem Description The Hailstone sequence (also known as the Collatz sequence) starts with a positive integer `n` and follows these rules: - If `n` is 1, the sequence ends. - If `n` is even, the next number in the sequence is `n / 2`. - If `n` is odd, the next number in the sequence is `3 * n + 1`. Write a function `hailstone_with_memoization(n, memo)` that generates the Hailstone sequence from a starting positive integer `n` to 1, using memoization to optimize performance. Input - A single integer `n` which is the starting point of the sequence (`1 <= n <= 10^6`). - A dictionary `memo` that stores the sequence results for previously encountered integers. Output - The function should return the sequence as a list of integers from n to 1. Constraints - Ensure to handle edge cases such as n = 1. - Use memoization to avoid recalculating the sequence for values previously encountered. Example ```python memo = {} print(hailstone_with_memoization(5, memo)) # Output: [5, 16, 8, 4, 2, 1] print(hailstone_with_memoization(10, memo)) # Output: [10, 5, 16, 8, 4, 2, 1] ``` Additional Note The performance of your implementation could be tested with very large values of `n` up to a million, so ensure your solution is optimized to handle these values efficiently.","solution":"def hailstone_with_memoization(n, memo): if n in memo: return memo[n] if n == 1: memo[n] = [1] return memo[n] if n % 2 == 0: next_n = n // 2 else: next_n = 3 * n + 1 sequence = [n] + hailstone_with_memoization(next_n, memo) memo[n] = sequence return sequence"},{"question":"Problem Statement Implement a function `min_steps_to_equal_strings` to compute the minimum number of steps required to make two given strings equal by performing deletions. In each step, you can delete one character from either string. Optimize your solution using dynamic programming. # Input * `word1` (str): The first word (length constraint: 1 <= len(word1) <= 1000) * `word2` (str): The second word (length constraint: 1 <= len(word2) <= 1000) # Output * (int): Minimum number of steps required # Function Signature ```python def min_steps_to_equal_strings(word1: str, word2: str) -> int: pass ``` # Constraints * Strings can contain lowercase English letters only. * Performance: Your solution should have a time complexity of O(m*n) and space complexity of O(m*n), where m and n are the lengths of `word1` and `word2`, respectively. # Examples 1. Example 1 * Input: `word1 = \\"sea\\"`, `word2 = \\"eat\\"` * Output: `2` * Explanation: You need two steps, one to make \\"sea\\" to \\"ea\\" and one to make \\"eat\\" to \\"ea\\". 2. Example 2 * Input: `word1 = \\"leetcode\\"`, `word2 = \\"etco\\"` * Output: `4` * Explanation: As one option, you can delete \'l\', \'e\', \'d\', and \'e\' from \\"leetcode\\" to get \\"etco\\".","solution":"def min_steps_to_equal_strings(word1: str, word2: str) -> int: Compute the minimum number of steps required to make two given strings equal by performing deletions. m, n = len(word1), len(word2) # Create a 2D dp array to store the length of the longest common subsequence dp = [[0] * (n + 1) for _ in range(m + 1)] # Build the dp array for i in range(1, m + 1): for j in range(1, n + 1): if word1[i - 1] == word2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) # The length of the longest common subsequence lcs_length = dp[m][n] # The minimum steps to make the two words equal is the sum of lengths of the two words # minus twice the length of the longest common subsequence (LCS) min_steps = (m - lcs_length) + (n - lcs_length) return min_steps"},{"question":"# Segment Tree Implementation and Application You are given an initial segment tree implementation in Python. Your task is to build upon this basic class and implement additional features to fulfill the following requirements. 1. **Range Update**: - Implement the ability to update all elements within a given range `[l, r]` to a new value `v` efficiently. - Specifically, create a new method `range_update(l, r, v)` that performs this operation in logarithmic time complexity. 2. **Minimum Range Query**: - Introduce a method for querying the minimum element within a specified range `[l, r]`. - This should leverage the existing infrastructure but apply a function suitable for finding minimum values. 3. **Tree Representation**: - Implement a method `__str__` that returns a string representation of the segment tree for debugging purposes. Implementation Details ```python class SegmentTree: def __init__(self, arr, function): self.tree = [None for _ in range(len(arr))] + arr self.size = len(arr) self.fn = function self.build_tree() def build_tree(self): for i in range(self.size - 1, 0, -1): self.tree[i] = self.fn(self.tree[i * 2], self.tree[i * 2 + 1]) def update(self, p, v): p += self.size self.tree[p] = v while p > 1: p = p // 2 self.tree[p] = self.fn(self.tree[p * 2], self.tree[p * 2 + 1]) def query(self, l, r): l, r = l + self.size, r + self.size res = None while l <= r: if l % 2 == 1: res = self.tree[l] if res is None else self.fn(res, self.tree[l]) if r % 2 == 0: res = self.tree[r] if res is None else self.fn(res, self.tree[r]) l, r = (l + 1) // 2, (r - 1) // 2 return res def range_update(self, l, r, v): # Implement range update method here. pass def min_query(self, l, r): # Implement minimum range query method here. pass def __str__(self): # Implement method to return string representation of the tree here. pass ``` # Input and Output Formats: * The `__init__` method takes an array `arr` and a function `function`. * The `update(p, v)` method updates the index `p` to value `v`. * The `query(l, r)` method returns the result of the commutative function over the range `[l, r]`. * The new `range_update(l, r, v)` method updates all elements in the range `[l, r]` to `v`. * The new `min_query(l, r)` method returns the minimum value in the range `[l, r]`. * The `__str__` method returns a string representation of the segment tree. __Constraints__: - The functions `query`, `range_update`, and `min_query` must operate within O(log N) time complexity. - Implementations should handle all edge cases. Please provide code with appropriate testing to validate your implementation.","solution":"class SegmentTree: def __init__(self, arr, function): self.tree = [None for _ in range(2 * len(arr))] self.size = len(arr) self.fn = function self.build_tree(arr) def build_tree(self, arr): # Build segment tree from given array for i in range(self.size): self.tree[self.size + i] = arr[i] for i in range(self.size - 1, 0, -1): self.tree[i] = self.fn(self.tree[i * 2], self.tree[i * 2 + 1]) def update(self, p, v): # Set value at position p p += self.size self.tree[p] = v while p > 1: p //= 2 self.tree[p] = self.fn(self.tree[2 * p], self.tree[2 * p + 1]) def query(self, l, r): # Range query from l to r res = None l += self.size r += self.size while l <= r: if l % 2 == 1: res = self.tree[l] if res is None else self.fn(res, self.tree[l]) l += 1 if r % 2 == 0: res = self.tree[r] if res is None else self.fn(res, self.tree[r]) r -= 1 l //= 2 r //= 2 return res def range_update(self, l, r, v): # Range update from l to r with value v l += self.size r += self.size while l <= r: if l % 2 == 1: self.tree[l] = v l += 1 if r % 2 == 0: self.tree[r] = v r -= 1 l //= 2 r //= 2 # Rebuild the affected parts of the segment tree for i in range(l, 0, -1): self.tree[i] = self.fn(self.tree[i * 2], self.tree[i * 2 + 1]) def min_query(self, l, r): # Minimum range query from l to r return self.query(l, r) def __str__(self): # String representation of segment tree return str(self.tree[self.size:])"},{"question":"You are given two lists of integers, `list1` and `list2`, as input. Write a class `ZigZagIterator` which provides a way to iterate over these lists in a zigzag manner. Specifically, it should alternate between elements of `list1` and `list2` until one list is exhausted, then continue with the remaining elements of the other list. Your implementation should include the following methods: 1. **`__init__(self, list1, list2)`**: Initializes the iterator with the two lists. 2. **`next(self)`**: Returns the next integer in the zigzag iteration. 3. **`has_next(self)`**: Returns a boolean indicating whether any more integers are left to iterate over. # Example: ```python list1 = [1, 3, 5] list2 = [2, 4, 6, 8, 10] it = ZigZagIterator(list1, list2) result = [] while it.has_next(): result.append(it.next()) print(result) # Output: [1, 2, 3, 4, 5, 6, 8, 10] ``` # Constraints: 1. The number of integers in each list `list1` and `list2` can be between 0 and 1000. 2. The integers in the lists are non-negative and do not have to be unique. 3. The total length of both lists combined will not exceed 2000. # Requirements: * Implement the `ZigZagIterator` class with the methods described. * Ensure that the methods are efficient and handle edge cases such as empty lists or lists with different lengths. * Provide a correct and optimized solution, following appropriate coding standards.","solution":"class ZigZagIterator: def __init__(self, list1, list2): Initialize the iterator with two lists. self._lists = [list1, list2] self._index = 0 # Track the current list self._pointers = [0, 0] # Pointers to the current elements in list1 and list2 def next(self): Return the next integer in the zigzag iteration. if not self.has_next(): raise StopIteration while self._pointers[self._index] >= len(self._lists[self._index]): self._index = (self._index + 1) % 2 result = self._lists[self._index][self._pointers[self._index]] self._pointers[self._index] += 1 self._index = (self._index + 1) % 2 return result def has_next(self): Return a boolean indicating whether any more integers are left to iterate over. return self._pointers[0] < len(self._lists[0]) or self._pointers[1] < len(self._lists[1])"},{"question":"You are given a sorted list of integers `array` and a list of target values `targets`. Your task is to determine for each target value the index at which it should be inserted into the `array` to maintain the sorted order. You need to implement a function `bulk_insert_indices` that takes `array` and `targets` as input and returns a list of indices corresponding to the insertion points for each target value. Function Signature ```python def bulk_insert_indices(array: List[int], targets: List[int]) -> List[int]: pass ``` Input * `array` (List[int]): A sorted list of integers. (1 <= len(array) <= 10^5) * `targets` (List[int]): A list of integers for which to find insertion points. (1 <= len(targets) <= 10^5) Output * Returns a list of integers, where each integer is the index at which the corresponding target should be inserted into the `array`. Constraints * The input list `array` will always be sorted in ascending order. * Target values can be found or need to be inserted in the range of array. Example ```python assert bulk_insert_indices([1, 3, 5, 6], [5, 2, 7, 0]) == [2, 1, 4, 0] assert bulk_insert_indices([1, 2, 4, 5], [3]) == [2] assert bulk_insert_indices([], [1, 2, 3]) == [0, 0, 0] ``` Explanation In the first example: - The target `5` should be inserted at index `2`. - The target `2` should be inserted at index `1`. - The target `7` should be inserted at index `4`. - The target `0` should be inserted at index `0`. **Your task is to implement the function and ensure it efficiently computes the correct insertion indices for each target.**","solution":"from typing import List def bulk_insert_indices(array: List[int], targets: List[int]) -> List[int]: from bisect import bisect_left return [bisect_left(array, target) for target in targets]"},{"question":"# Question Write a function `filtered_range` that filters an array\'s elements based on specified minimum and maximum limits. The function should include considerations for edge cases and performance optimizations where needed. Function Signature ```python def filtered_range(arr: List[int], min_lim: Optional[int] = None, max_lim: Optional[int] = None) -> List[int]: ``` Input Parameters - `arr`: List of integers to be filtered. - `min_lim`: Optional integer specifying the lower bound (inclusive) of the filtering range. Set to `None` to exclude this bound. - `max_lim`: Optional integer specifying the upper bound (inclusive) of the filtering range. Set to `None` to exclude this bound. Output - Return a list of integers from the input array that fall within the specified range `[min_lim, max_lim]`. Constraints - The input array may be empty. - If both `min_lim` and `max_lim` are `None`, return the original array. - Ensure the function handles large datasets efficiently. Example ```python # Example usage of the function print(filtered_range([1, 3, 5, 7, 9], 2, 8)) # Output: [3, 5, 7] print(filtered_range([23, 15, 42, 8, 16], None, 20)) # Output: [15, 8, 16] print(filtered_range([23, 15, 42, 8, 16], 25, None)) # Output: [42] print(filtered_range([1, 2, 3, 4, 5], 6, 10)) # Output: [] print(filtered_range([], 1, 10)) # Output: [] print(filtered_range([1, 2, 3, 4, 5], None, None)) # Output: [1, 2, 3, 4, 5] ```","solution":"from typing import List, Optional def filtered_range(arr: List[int], min_lim: Optional[int] = None, max_lim: Optional[int] = None) -> List[int]: Filters the array elements based on the specified min and max limits. Parameters: - arr: List of integers to be filtered. - min_lim: Optional integer specifying the lower bound (inclusive) of the filtering range. - max_lim: Optional integer specifying the upper bound (inclusive) of the filtering range. Returns: - A list of integers from the input array that fall within the specified range [min_lim, max_lim]. if min_lim is None and max_lim is None: return arr filtered_list = [] for num in arr: if (min_lim is None or num >= min_lim) and (max_lim is None or num <= max_lim): filtered_list.append(num) return filtered_list"},{"question":"# Objective Implement a function to solve a system of modular linear equations using the principles of the Chinese Remainder Theorem (CRT). # Function Specifications **Function Name:** `solve_chinese_remainder_optimized` **Input:** - `nums` (List[int]): A list of integers, each greater than 1 and pairwise coprime. - `rems` (List[int]): An equally sized list of integers representing the remainders for the congruences. **Output:** - Returns an integer, the smallest value of `x` satisfying all equations or raises an appropriate exception if conditions are not met. # Constraints: 1. Length of `nums` and `rems` are the same. 2. All elements in `nums` are greater than 1. 3. All elements in `nums` are pairwise coprime. # Examples: ```python assert solve_chinese_remainder_optimized([3, 5, 7], [2, 3, 2]) == 23 assert solve_chinese_remainder_optimized([5, 7], [1, 3]) == 31 ``` # Error Handling Ensure the function raises relevant exceptions for: - Lists of different lengths. - `nums` containing numbers less than or equal to 1. - Non-pairwise coprime `nums`. # Performance Optimize the function to achieve better-than-brute-force performance, potentially using the Extended Euclidean Algorithm to calculate Moduli inverses and reduce the search space. # Design Guidelines - **Edge Cases**: Consider handling minimum input size (one-element lists) and large prime gaps. - **Validation**: Initial input validation should be comprehensive to avoid unnecessary computation. - **Optimization**: Consider mathematical properties to reduce the search space and computational steps.","solution":"def solve_chinese_remainder_optimized(nums, rems): from math import gcd # Check for input errors if len(nums) != len(rems): raise ValueError(\\"The lengths of \'nums\' and \'rems\' should be the same.\\") if any(n <= 1 for n in nums): raise ValueError(\\"All elements in \'nums\' should be greater than 1.\\") def are_pairwise_coprime(numbers): for i in range(len(numbers)): for j in range(i + 1, len(numbers)): if gcd(numbers[i], numbers[j]) != 1: return False return True if not are_pairwise_coprime(nums): raise ValueError(\\"\'nums\' should be pairwise coprime.\\") def extended_gcd(a, b): if a == 0: return b, 0, 1 g, x1, y1 = extended_gcd(b % a, a) x = y1 - (b // a) * x1 y = x1 return g, x, y def modinv(a, m): g, x, _ = extended_gcd(a, m) if g != 1: raise ValueError(\\"Inverse doesn\'t exist\\") return x % m prod = 1 for n in nums: prod *= n result = 0 for n_i, a_i in zip(nums, rems): p = prod // n_i result += a_i * modinv(p, n_i) * p return result % prod"},{"question":"# Problem Description In this task, you are required to extend and optimize the Sieve of Eratosthenes for generating prime numbers. Particularly, your task is to further reduce the space complexity by implementing a segmented sieve approach. # Task Extend the `get_primes` function to generate all prime numbers less than a given number `n` using a segmented sieve approach. This method involves breaking up the range [2, n) into smaller segments that can fit into memory, processing each segment independently. # Input * An integer `n` where (2 le n le 10^8). # Output * A list of all prime numbers less than `n`. # Constraints * Your implementation should handle the given range efficiently. * Optimize for both time and space complexity. * Implement proper error handling for invalid inputs. # Function Signature ```python def segmented_sieve(n: int) -> List[int]: pass ``` # Example Input: `n = 30` Output: `[2, 3, 5, 7, 11, 13, 17, 19, 23, 29]` # Guidelines 1. Begin by generating all prime numbers up to (sqrt{n}) using the Sieve of Eratosthenes. 2. Use these primes to mark non-prime numbers in each segment range. 3. Optimize the memory by processing the range in chunks rather than the entire range at once.","solution":"from math import isqrt from typing import List def simple_sieve(limit: int) -> List[int]: Generates all prime numbers up to limit using the simple Sieve of Eratosthenes sieve = [True] * (limit + 1) sieve[0] = sieve[1] = False for start in range(2, isqrt(limit) + 1): if sieve[start]: for multiple in range(start*start, limit + 1, start): sieve[multiple] = False return [num for num in range(2, limit + 1) if sieve[num]] def segmented_sieve(n: int) -> List[int]: Generates all prime numbers less than n using the segmented sieve approach if n <= 1: return [] limit = isqrt(n) primes = simple_sieve(limit) low = limit + 1 high = min(2*limit, n) sieve = [True] * (n) for prime in primes: start = max(prime*prime, low + (prime - low % prime) % prime) for j in range(start, n, prime): sieve[j] = False for prime in range(low, n): if sieve[prime]: primes.append(prime) return primes"},{"question":"Alice and Bob want to establish a secure communication channel using the Diffie-Hellman key exchange protocol. However, they suspect that there may be issues with the prime number ( p ) they are using or the primitive root ( a ). You are to write a function that verifies whether the prime number and primitive root are appropriate for Diffie-Hellman key exchange and returns the shared secret key if they are. # Function Signature ```python def validate_diffie_hellman(a: int, p: int) -> int: Verifies the prime number p and primitive root a, then calculates and returns the shared secret key if valid, otherwise raises an error. Parameters: a (int) : candidate primitive root p (int) : candidate prime number Returns: int : the shared secret key if valid Raises: ValueError: if p is not a prime number or a is not a primitive root of p ``` # Input * `a` (1 <= a <= 10^9): Candidate for the primitive root of ( p ). * `p` (1 <= p <= 10^9): Candidate for the prime number. # Output * Returns the shared secret key if both ( p ) is a prime and ( a ) is a primitive root of ( p ). * Raises `ValueError` with an appropriate message if either is invalid. # Constraints * The function must validate if ( p ) is a prime number. * The function must validate if ( a ) is a primitive root of ( p ). * You should use the provided `prime_check`, `find_order`, and `euler_totient` functions to support your implementation. # Example ```python assert validate_diffie_hellman(5, 23) == some_shared_secret_value assert validate_diffie_hellman(3, 29) == some_shared_secret_value # These are sample placeholders and should be filled with actual shared key values ``` Implement additional helper functions or optimize the provided ones if necessary to meet the constraints within a reasonable time frame.","solution":"def is_prime(n: int) -> bool: Returns True if n is a prime number, otherwise False. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def euler_totient(n: int) -> int: Returns the value of Euler\'s Totient function phi(n). result = n p = 2 while p * p <= n: if n % p == 0: while n % p == 0: n //= p result -= result // p p += 1 if n > 1: result -= result // n return result def find_order(a: int, n: int) -> int: Returns the order of a modulo n (the smallest positive integer k such that a^k ≡ 1 (mod n)). k = 1 x = a while x != 1: x = (x * a) % n k += 1 return k def is_primitive_root(a: int, p: int) -> bool: Returns True if a is a primitive root modulo p. if not is_prime(p): return False phi = euler_totient(p) for i in range(2, phi): if phi % i == 0: if pow(a, i, p) == 1: return False return pow(a, phi, p) == 1 def diffie_hellman_shared_secret(a: int, p: int, private_key: int) -> int: Calculate the Diffie Hellman shared secret given primitive root a, prime p, and private key. return pow(a, private_key, p) def validate_diffie_hellman(a: int, p: int) -> int: if not is_prime(p): raise ValueError(f\\"p: {p} is not a prime number.\\") if not is_primitive_root(a, p): raise ValueError(f\\"a: {a} is not a primitive root of p: {p}.\\") private_key_alice = 6 # Example private key for Alice private_key_bob = 15 # Example private key for Bob public_key_alice = pow(a, private_key_alice, p) public_key_bob = pow(a, private_key_bob, p) shared_secret_alice = pow(public_key_bob, private_key_alice, p) shared_secret_bob = pow(public_key_alice, private_key_bob, p) if shared_secret_alice != shared_secret_bob: raise ValueError(\\"Shared secrets do not match, there is an error in the calculation.\\") return shared_secret_alice"},{"question":"You are given an indexed series of natural numbers concatenated as a single sequence (e.g., \\"123456789101112...\\"). Your task is to implement a function that finds and returns the nth digit of this concatenated sequence. # Function Signature ```python def find_nth_digit(n: int) -> int: pass ``` # Input - An integer `n`, where `1 <= n <= 2*10^9`. # Output - A single integer representing the nth digit in the sequence. # Constraints - The function should return the correct nth digit for `n` up to 2 billion. - The implementation should handle large values of `n` efficiently. # Example ```python assert find_nth_digit(1) == 1 assert find_nth_digit(11) == 0 assert find_nth_digit(189) == 9 assert find_nth_digit(190) == 1 assert find_nth_digit(191) == 0 assert find_nth_digit(1000) == 3 ``` # Performance Requirements - Time complexity must be logarithmic relative to `n` (O(log n)). - Space complexity must remain constant (O(1)). # Guidelines To solve the problem, your function should: 1. Identify the digit length category of the target digit. 2. Calculate the starting number of that identified length. 3. Determine the specific digit within the target number and return it. You should account for possible edge cases (like transitions between different digit lengths) and ensure the solution efficiently scales with large inputs.","solution":"def find_nth_digit(n: int) -> int: # Initialize digit length, initial count, and number start digit_length = 1 count = 9 start = 1 # Determine the range where the nth digit lies while n > digit_length * count: n -= digit_length * count digit_length += 1 count *= 10 start *= 10 # Find the exact number where the nth digit is located start += (n - 1) // digit_length s = str(start) # Return the nth digit in the whole sequence return int(s[(n - 1) % digit_length])"},{"question":"# Question: Matrix Exponentiation and Power Calculation Given three functions that handle matrix multiplication, identity matrix generation, and matrix exponentiation using repeated squaring, you are tasked with solving the following problem: Problem Statement: Given an integer `k` and an initial (2 times 2) matrix (M): [ M = begin{bmatrix} a & b c & d end{bmatrix} ] Create a function `matrix_power_two_by_k(a, b, c, d, k)` that computes the matrix (M) raised to the power (k) and returns the resulting matrix. Input: - Four integers, `a`, `b`, `c`, `d` representing the initial matrix (M). - An integer `k`, representing the power to raise the matrix to. (0 leq k leq 10^9). Output: - A 2x2 matrix represented as a list of lists. Constraints: - Matrix elements and resulting matrix elements will fit within standard integer range. - Efficient computation is expected due to the large possible range of `k`. # Example: **Input**: ```python a = 1 b = 1 c = 1 d = 0 k = 5 ``` **Output**: ```python [[8, 5], [5, 3]] ``` # Function Signature: ```python def matrix_power_two_by_k(a: int, b: int, c: int, d: int, k: int) -> list: # Your code here pass ``` Additional Notes: - Utilize the provided helper functions `multiply`, `identity`, and `matrix_exponentiation`. - Ensure your implementation handles large values of `k` efficiently using repeated squaring.","solution":"def multiply(m1, m2): Multiplies two 2x2 matrices. return [ [ m1[0][0] * m2[0][0] + m1[0][1] * m2[1][0], m1[0][0] * m2[0][1] + m1[0][1] * m2[1][1] ], [ m1[1][0] * m2[0][0] + m1[1][1] * m2[1][0], m1[1][0] * m2[0][1] + m1[1][1] * m2[1][1] ] ] def identity(): Returns a 2x2 identity matrix. return [ [1, 0], [0, 1] ] def matrix_exponentiation(matrix, power): Raises a 2x2 matrix to the power using repeated squaring. result = identity() base = matrix while power > 0: if power % 2 == 1: result = multiply(result, base) base = multiply(base, base) power //= 2 return result def matrix_power_two_by_k(a, b, c, d, k): Computes the matrix [[a, b], [c, d]] raised to the power of k. M = [[a, b], [c, d]] return matrix_exponentiation(M, k)"},{"question":"You are tasked with writing a function to determine the number of digits in a given integer. This function needs to be efficient, executing in constant time. This is particularly useful for preprocessing numbers before they are used in further calculations or for formatting purposes. # Function Specification Function Name `num_digits` Input * An integer `n`, where `-10^9 <= n <= 10^9`. Output * An integer representing the number of digits in the input number. # Constraints * The implementation must execute in constant time, O(1). * The input can be negative or zero. # Examples ```python assert num_digits(12345) == 5 assert num_digits(-98765) == 5 assert num_digits(1000000000) == 10 assert num_digits(0) == 1 assert num_digits(-1) == 1 ``` # Additional Notes * Your solution should handle edge cases, such as zero and negative numbers. * The logarithmic function utilized should handle large and small number ranges efficiently within provided constraints. # Submission Submit your solution in the form of a Python function defined as described.","solution":"def num_digits(n): Returns the number of digits in a given integer n. if n == 0: return 1 return len(str(abs(n)))"},{"question":"# Context: You are working on a project for a communications company that uses a custom encoding scheme to store and transmit alphabetic messages. Each letter from \'A\' to \'Z\' is encoded as a number from \'1\' to \'26\'. Your task is to create an algorithm that can decode these messages to determine how many possible valid original messages can be reconstructed from the encoded string. # Problem Statement: Given a string `enc_mes` containing only digits, determine the total number of ways to decode it according to the following mapping: ``` \'A\' -> 1, \'B\' -> 2, ..., \'Z\' -> 26 For example: If the encoded message is \\"12\\", it could be decoded as \\"AB\\" (1 2) or \\"L\\" (12), resulting in 2 possible decodings. ``` # Function Signature: ```python def num_decodings(enc_mes: str) -> int: pass ``` # Input: - `enc_mes` (a string of digits) with length in the range [0, 100]. - The string will not contain any characters other than digits. # Output: - An integer representing the number of ways to decode the input string. # Constraints: - It\'s guaranteed that the input will always be a valid string containing digits only. - The decoding cannot start or contain invalid \'0\'s or invalid two-digit numbers that don\'t map to any letter. # Requirements: - Your solution should have a time complexity of O(n) and an optimal space complexity. # Example: ```python assert num_decodings(\\"12\\") == 2 assert num_decodings(\\"226\\") == 3 assert num_decodings(\\"0\\") == 0 assert num_decodings(\\"10\\") == 1 assert num_decodings(\\"2101\\") == 1 ``` Provide a well-commented and efficient solution that correctly handles edge cases such as strings starting with \'0\', strings containing \'0\', and long input strings up to 100 characters.","solution":"def num_decodings(enc_mes: str) -> int: Returns the number of ways to decode the given encoded message. if not enc_mes or enc_mes[0] == \'0\': return 0 n = len(enc_mes) dp = [0] * (n + 1) dp[0] = 1 dp[1] = 1 if enc_mes[0] != \'0\' else 0 for i in range(2, n + 1): if enc_mes[i-1] != \'0\': dp[i] += dp[i-1] if 10 <= int(enc_mes[i-2:i]) <= 26: dp[i] += dp[i-2] return dp[n]"},{"question":"# Question You are given an array of integers where exactly two elements appear only once and all the other elements appear exactly twice. Implement a function `find_single_numbers` that identifies the two unique numbers in the array using O(N) time and O(1) space. Expected Function Signature ```python def find_single_numbers(nums: List[int]) -> List[int]: pass ``` Input * `nums (List[int])`: A list of integers where each integer except two appear exactly twice. The length of the input list is at least 2. Output * Returns a list containing the two numbers that appear only once. The order of the output does not matter. Constraints * Time complexity should be O(N). * Space complexity should be O(1). Example ```python assert sorted(find_single_numbers([1, 2, 1, 3, 2, 5])) == sorted([3, 5]) assert sorted(find_single_numbers([4, 4, 6, 7])) == sorted([6, 7]) ``` Note * You can assume there will always be exactly two unique elements in the input list.","solution":"from typing import List def find_single_numbers(nums: List[int]) -> List[int]: xor = 0 for num in nums: xor ^= num # Get the rightmost set bit rightmost_bit = xor & -xor num1, num2 = 0, 0 for num in nums: if (num & rightmost_bit) == 0: num1 ^= num else: num2 ^= num return [num1, num2]"},{"question":"Problem Statement: You are tasked with implementing a lossless universal integer coding scheme using the Elias γ and δ codes. Your implementation should compress a list of integers into a single encoded string and be able to decode that string back to the original list of integers. Function Signatures: ```python def compress_integers(integers: List[int]) -> str: pass def decompress_integers(encoded_string: str) -> List[int]: pass ``` Input Formats: - **compress_integers**: A list of positive integers (1 <= integer <= 10^6) - **decompress_integers**: A string that represents the Elias γ - encoded sequence of integers Output Formats: - **compress_integers**: A string which is the encoded sequence combining Elias γ - encoded integers. - **decompress_integers**: A list of integers which were originally encoded in the provided string. Constraints: - Ensure that the encoding and decoding methods are efficient enough to handle input sizes up to 10^4 integers. - Handle any edge cases such as minimal and maximal input sizes effectively. Example: ```python print(compress_integers([13, 5, 1])) # \\"000011001010001\\" (Exact encoding may vary) print(decompress_integers(\\"000011001010001\\")) # [13, 5, 1] ``` Hints: - Use the provided methods `elias_gamma` and potentially `elias_delta` for encoding single integers. - Create a concatenated string for the list of integers for `compress_integers`. - Implement a robust parsing mechanism for `decompress_integers` to sequentially decode individual integers from the string.","solution":"from typing import List def elias_gamma_encode(number: int) -> str: if number <= 0: raise ValueError(\\"Number must be positive\\") binary = bin(number)[2:] # Get the binary representation of the number without the \'0b\' prefix n = len(binary) - 1 prefix = \'0\' * n return prefix + binary def elias_gamma_decode(encoded_string: str, index: int) -> (int, int): zero_count = 0 while index < len(encoded_string) and encoded_string[index] == \'0\': zero_count += 1 index += 1 binary_number = encoded_string[index:index + zero_count + 1] decoded_number = int(binary_number, 2) return decoded_number, index + zero_count + 1 def compress_integers(integers: List[int]) -> str: encoded_string = \'\' for number in integers: encoded_string += elias_gamma_encode(number) return encoded_string def decompress_integers(encoded_string: str) -> List[int]: decoded_numbers = [] index = 0 while index < len(encoded_string): number, new_index = elias_gamma_decode(encoded_string, index) decoded_numbers.append(number) index = new_index return decoded_numbers"},{"question":"# Scenario John is working on a software project that requires performing numerous fast lookup operations on a dynamically changing dataset. To achieve efficient lookups, he decides to implement a Binary Search Tree (BST). # Problem Your task is to implement a Binary Search Tree (BST) in Python. Specifically, you need to complete methods for inserting a node, searching for a node, and performing inorder traversal of the tree. Additionally, you should implement a method to delete a node ensuring that the tree remains a valid BST after deletion. # Requirements 1. **Insert**: - Accepts an integer value and inserts it into the BST. 2. **Search**: - Accepts an integer value and returns `True` if the value is found, `False` otherwise. 3. **Inorder Traversal**: - Returns a list of all values in the BST in sorted order. 4. **Delete**: - Accepts an integer value and removes the node with that value from the BST while maintaining the BST properties. # Input/Output - **Insert**: - **Input**: integer to be inserted. - **Output**: None. - **Search**: - **Input**: integer to be searched. - **Output**: `True` if the value exists, `False` otherwise. - **Inorder Traversal**: - **Input**: None. - **Output**: List of integers in sorted order. - **Delete**: - **Input**: integer to be deleted. - **Output**: None. # Constraints - The BST should handle integer inputs and self-adjust to maintain efficiency. - Assume all integer values are unique unless specified. Here is the given `TreeNode` class structure: ```python class TreeNode: def __init__(self, val=0): self.val = val self.left = None self.right = None ``` # Example ```python # Example usage bst = BST() bst.insert(10) bst.insert(5) bst.insert(15) bst.insert(3) bst.insert(7) print(bst.search(7)) # Output: True print(bst.search(8)) # Output: False print(bst.inorder_traversal()) # Output: [3, 5, 7, 10, 15] bst.delete(10) print(bst.inorder_traversal()) # Output: [3, 5, 7, 15] ``` **Write your solution in the class BST below:** <|diff_marker|> PATCH A ```python class BST: def __init__(self): self.root = None def insert(self, val: int) -> None: # Implement the insert method pass def search(self, val: int) -> bool: # Implement the search method pass def inorder_traversal(self) -> list: # Implement the inorder traversal method pass def delete(self, val: int) -> None: # Implement the delete method pass ```","solution":"class TreeNode: def __init__(self, val=0): self.val = val self.left = None self.right = None class BST: def __init__(self): self.root = None def insert(self, val: int) -> None: if not self.root: self.root = TreeNode(val) return def _insert(node, val): if val < node.val: if node.left: _insert(node.left, val) else: node.left = TreeNode(val) else: if node.right: _insert(node.right, val) else: node.right = TreeNode(val) _insert(self.root, val) def search(self, val: int) -> bool: def _search(node, val): if not node: return False if node.val == val: return True elif val < node.val: return _search(node.left, val) else: return _search(node.right, val) return _search(self.root, val) def inorder_traversal(self) -> list: result = [] def _inorder(node): if not node: return _inorder(node.left) result.append(node.val) _inorder(node.right) _inorder(self.root) return result def delete(self, val: int) -> None: def _delete(node, val): if not node: return node if val < node.val: node.left = _delete(node.left, val) elif val > node.val: node.right = _delete(node.right, val) else: if not node.left: return node.right if not node.right: return node.left temp_val = self._min_value_node(node.right) node.val = temp_val.val node.right = _delete(node.right, temp_val.val) return node self.root = _delete(self.root, val) def _min_value_node(self, node): current = node while current.left: current = current.left return current"},{"question":"You are given an implementation of a priority queue using a linear array. Your task is to extend the provided `PriorityQueue` class with additional functionalities commonly required in a priority queue. # Required Implementations 1. **Method: `peek`** * **Description**: This method should return the item with the lowest priority without removing it from the queue. * **Input**: None. * **Output**: The item with the lowest priority. * **Constraints**: Should handle the case when the priority queue is empty and return `None`. 2. **Method: `change_priority(item, new_priority)`** * **Description**: This method should update the priority of the specified item to the new priority. If the item does not exist in the queue, do nothing. * **Input**: * `item`: The item whose priority needs to be updated. * `new_priority`: The new priority value. * **Output**: None. * **Constraints**: Assume that all items are unique. # Expected Complexity The `peek` method should operate in O(1) time. The `change_priority` method should operate in O(n) time due to removal and reinsertion. # Additional Information * Duplicate priorities are allowed, but items are unique. * Follow the existing conventions and methods of the Priority Queue class provided. # Example Usage ```python pq = PriorityQueue(items=[5, 3, 7], priorities=[2, 1, 3]) pq.change_priority(3, 5) assert pq.pop() == 5 assert pq.pop() == 3 assert pq.peek() == 7 assert pq.pop() == 7 assert pq.peek() is None ``` # Starting Class ```python class PriorityQueue: class PriorityQueueNode: def __init__(self, data, priority): self.data = data self.priority = priority def __repr__(self): return \\"{}: {}\\".format(self.data, self.priority) def __init__(self, items=None, priorities=None): self.priority_queue_list = [] if items is None: return if priorities is None: priorities = itertools.repeat(None) for item, priority in zip(items, priorities): self.push(item, priority=priority) def __repr__(self): return \\"PriorityQueue({!r})\\".format(self.priority_queue_list) def size(self): return len(self.priority_queue_list) def push(self, item, priority=None): priority = item if priority is None else priority node = self.PriorityQueueNode(item, priority) for index, current in enumerate(self.priority_queue_list): if current.priority < node.priority: self.priority_queue_list.insert(index, node) return self.priority_queue_list.append(node) def pop(self): return self.priority_queue_list.pop().data # Implement the following methods def peek(self): # Your implementation here pass def change_priority(self, item, new_priority): # Your implementation here pass ```","solution":"class PriorityQueue: class PriorityQueueNode: def __init__(self, data, priority): self.data = data self.priority = priority def __repr__(self): return \\"{}: {}\\".format(self.data, self.priority) def __init__(self, items=None, priorities=None): self.priority_queue_list = [] if items is None: return if priorities is None: priorities = itertools.repeat(None) for item, priority in zip(items, priorities): self.push(item, priority=priority) def __repr__(self): return \\"PriorityQueue({!r})\\".format(self.priority_queue_list) def size(self): return len(self.priority_queue_list) def push(self, item, priority=None): priority = item if priority is None else priority node = self.PriorityQueueNode(item, priority) for index, current in enumerate(self.priority_queue_list): if current.priority < node.priority: self.priority_queue_list.insert(index, node) return self.priority_queue_list.append(node) def pop(self): return self.priority_queue_list.pop().data def peek(self): if self.priority_queue_list: return self.priority_queue_list[-1].data return None def change_priority(self, item, new_priority): for index, node in enumerate(self.priority_queue_list): if node.data == item: del self.priority_queue_list[index] self.push(item, new_priority) return"},{"question":"# RSA Encryption System Implementation **Objective**: Implement an RSA encryption/decryption system with specific focus on generating keys efficiently. You are given a partially completed RSA encryption algorithm. Your task is to implement an optimized version of the `generate_key()` function, which should generate RSA public and private keys for a given bit size. # Requirements 1. **Key Generation**: - Implement `generate_key(k, seed=None)` to generate public and private keys `(n, e, d)`, where `n` is a product of two large prime numbers `p` and `q`. - Ensure `e` and the totient function `l` are coprime. 2. **Encryption**: - Implement a function `encrypt(data, e, n)` that encrypts the given data using the public key `(e, n)`. 3. **Decryption**: - Implement a function `decrypt(data, d, n)` that decrypts the given encrypted data using the private key `(d, n)`. # Expected Input and Output 1. **generate_key(k, seed=None)**: - **Input**: An integer `k` representing the bit size of the modulus `n`. - **Output**: Triple `(n, e, d)` where: - `n` is the modulus. - `e` is the public exponent. - `d` is the private exponent. 2. **encrypt(data, e, n)**: - **Input**: Integer `data` represents the plaintext to be encrypted, integers `e` and `n` are the public keys. - **Output**: Integer representing the encrypted data. 3. **decrypt(data, d, n)**: - **Input**: Integer `data` represents the encrypted data, integers `d` and `n` are the private keys. - **Output**: Integer representing the decrypted original data. # Constraints - Ensure `k` is at least 16 to maintain RSA\'s security properties. - Provide a seed for random generation to ensure reproducibility in tests. # Example ```python n, e, d = generate_key(16) data = 20 encrypted = encrypt(data, e, n) decrypted = decrypt(encrypted, d, n) assert decrypted == data # True if implemented correctly ``` # Guidelines 1. **Modular Inverse Calculation**: Refactor your modular inverse calculation for efficiency. 2. **Prime Generation**: Use an efficient primality test and consider a faster algorithm to generate prime numbers. 3. **Copraminess Check**: Ensure `e` and `totient` are coprime to safely generate the keys. **Note**: Do not use libraries like `Crypto` or `Cryptography` that provide direct implementations of RSA. The aim is to demonstrate your understanding by implementing the algorithm from scratch.","solution":"import random from math import gcd from sympy import isprime def mod_inverse(e, phi): Use the Extended Euclidean Algorithm to find the multiplicative inverse of e mod phi. def egcd(a, b): x0, x1, y0, y1 = 0, 1, 1, 0 while a != 0: q, a, b = b // a, b % a, a y0, y1 = y1, y0 - q * y1 x0, x1 = x1, x0 - q * x1 return b, x0, y0 g, x, y = egcd(e, phi) if g != 1: raise Exception(f\\"No modular inverse for input, e={e}, phi={phi}\\") else: return x % phi def generate_prime(bits): Generate a prime number of specified bit length. while True: p = random.getrandbits(bits) if p % 2 == 0: p += 1 if isprime(p): return p def generate_key(k, seed=None): Generate RSA public and private keys of bit length k. if seed is not None: random.seed(seed) assert k >= 16, \\"Key size should be at least 16 bits for security.\\" p = generate_prime(k // 2) q = generate_prime(k // 2) n = p * q phi = (p - 1) * (q - 1) e = 65537 # Commonly used prime exponent while gcd(e, phi) != 1: e = random.randrange(2, phi) d = mod_inverse(e, phi) return (n, e, d) def encrypt(data, e, n): Encrypt data using public key (e, n). return pow(data, e, n) def decrypt(data, d, n): Decrypt data using private key (d, n). return pow(data, d, n)"},{"question":"# Context You are tasked with implementing a stack using a linked list in a language of your choice. Stacks are a fundamental data structure used in various applications, particularly in scenarios where a Last-In-First-Out (LIFO) paradigm is required. # Objectives 1. Implement a `LinkedListStack` class with the following methods: - `push(value)`: Add an item to the stack. - `pop()`: Remove and return the top item from the stack. - `peek()`: Return the top item without removing it. - `is_empty()`: Return `True` if the stack is empty, otherwise `False`. # Requirements 1. Your implementation should handle edge cases, such as popping or peeking from an empty stack. 2. Operations should adhere to the expected time complexities of O(1) for `push`, `pop`, and `peek`. 3. Ensure proper memory management to avoid leaks (if applicable). # Input and Output Formats - **Input**: No direct input. - **Output**: No direct output, but the class methods should function as per the requirements. # Constraints - The stack should only store integer values for simplicity. - Assume the stack will not exceed 10^4 operations in a single run. # Example Usage ```python stack = LinkedListStack() stack.push(10) stack.push(20) print(stack.peek()) # Output: 20 print(stack.pop()) # Output: 20 print(stack.is_empty()) # Output: False print(stack.pop()) # Output: 10 print(stack.is_empty()) # Output: True ``` Implement the `LinkedListStack` class:","solution":"class Node: def __init__(self, value=None): self.value = value self.next = None class LinkedListStack: def __init__(self): self.top = None def push(self, value): new_node = Node(value) new_node.next = self.top self.top = new_node def pop(self): if self.is_empty(): raise IndexError(\\"pop from empty stack\\") value = self.top.value self.top = self.top.next return value def peek(self): if self.is_empty(): raise IndexError(\\"peek from empty stack\\") return self.top.value def is_empty(self): return self.top is None"},{"question":"Fenwick Tree Problem Statement You are provided with a specialized data structure called the **Fenwick Tree** (also known as **Binary Indexed Tree**). This data structure allows for efficient point updates and prefix sum queries on an array. An expert development team needs you to implement missing functionalities for the Fenwick Tree to handle dynamic cumulative frequency tasks. # Your Task: 1. Implement the `range_sum` method to calculate the sum of a range of elements from index `l` to `r`. 2. Implement the `update_index` method to update the value at a specific index in the original array and reflect this in the Fenwick Tree. # Implementation Details: * **range_sum(self, bit_tree, l, r)**: Returns the sum of the elements between indices `l` and `r`, inclusive. * **update_index(self, bit_tree, i, new_val)**: Updates the element at index `i` in the original array to `new_val` and adjusts the Fenwick Tree accordingly. # Input: You will be given: - `bit_tree` (list): A Fenwick Tree represented as a list. - `l` (int): The lower bound (inclusive) of the range for the `range_sum` query. - `r` (int): The upper bound (inclusive) of the range for the `range_sum` query. - `i` (int): The index to update in the original array. - `new_val` (int): The new value to be placed at index `i`. # Output: - The `range_sum` method should return an integer representing the sum of the specified range. - The `update_index` method should update the Fenwick Tree in place. # Constraints: - Assume `0 <= i, l, r < n` where `n` is the size of the input array. ```python class Fenwick_Tree(object): def __init__(self, freq): self.arr = freq self.n = len(freq) def get_sum(self, bit_tree, i): # Returns sum of arr[0..index]. s = 0 i = i + 1 while i > 0: s += bit_tree[i] i -= i & (-i) return s def update_bit(self, bit_tree, i, v): # Updates a node in Binary Index Tree i += 1 while i <= self.n: bit_tree[i] += v i += i & (-i) def construct(self): # Constructs and returns a Binary Indexed Tree bit_tree = [0]*(self.n+1) for i in range(self.n): self.update_bit(bit_tree, i, self.arr[i]) return bit_tree def range_sum(self, bit_tree, l, r): # Sum of range from l to r (inclusive) pass # TODO: Implement this function. def update_index(self, bit_tree, i, new_val): # Update the value at index i to new_val pass # TODO: Implement this function. ``` # Example: Given the array `freq = [2, 1, 1, 3, 2, 3, 4, 5, 6, 7, 8, 9]`, and constructing its Fenwick Tree: 1. A call to `range_sum(bit_tree, 1, 3)` should return `5` (sum of elements from index 1 to 3). 2. A call to `update_index(bit_tree, 1, 10)` should update the value at index 1 to 10 and adjust the Fenwick Tree to reflect this. Note: Implement these functions within the provided class framework for maintaining and operating on the Fenwick Tree structure. Your solution should ensure that the operations are efficient and adhere to the complexities expected of a Fenwick Tree.","solution":"class Fenwick_Tree(object): def __init__(self, freq): self.arr = freq self.n = len(freq) def get_sum(self, bit_tree, i): # Returns sum of arr[0..index]. s = 0 i = i + 1 while i > 0: s += bit_tree[i] i -= i & (-i) return s def update_bit(self, bit_tree, i, v): # Updates a node in Binary Index Tree i += 1 while i <= self.n: bit_tree[i] += v i += i & (-i) def construct(self): # Constructs and returns a Binary Indexed Tree bit_tree = [0]*(self.n+1) for i in range(self.n): self.update_bit(bit_tree, i, self.arr[i]) return bit_tree def range_sum(self, bit_tree, l, r): # Sum of range from l to r (inclusive) return self.get_sum(bit_tree, r) - self.get_sum(bit_tree, l - 1) def update_index(self, bit_tree, i, new_val): # Update the value at index i to new_val diff = new_val - self.arr[i] self.arr[i] = new_val self.update_bit(bit_tree, i, diff)"},{"question":"# Diffie-Hellman Key Exchange Exercise Alice and Bob want to securely share a secret key over a public network using Diffie-Hellman key exchange. They agree on a large prime number (p) and its primitive root (a). Your task is to implement a Python function that demonstrates this key exchange and ensures both parties compute the same shared secret key. Function Signature ```python def diffie_hellman_key_exchange(a: int, p: int) -> bool: ``` Input 1. `a` (int): A primitive root of prime (p). 2. `p` (int): A large prime number. Output - Returns `True` if Alice and Bob successfully compute the same shared key. - Returns `False` if any of the preconditions (e.g., prime (p) or primitive root (a)) are not met. Constraints - (a) and (p) should satisfy the conditions for Diffie-Hellman Key Exchange: - (p) must be a prime number. - (a) must be a primitive root of (p). Implementation Requirements 1. Verify that (p) is a prime number. 2. Verify that (a) is a primitive root of (p). 3. Simulate Alice and Bob selecting private keys and generating public keys. 4. Compute the shared secret keys for both parties and ensure they are equal. Performance Requirements - Optimize for time complexity, especially in primality checks and order calculations. - Use efficient modular exponentiation. Example ```python if __name__ == \\"__main__\\": a, p = 5, 23 print(diffie_hellman_key_exchange(a, p)) # Should return True ``` Notes - You may use helper functions for primality check, finding orders, and computing Euler\'s Totient function. - Include exception handling for cases where input does not meet the required conditions. Good luck and ensure your implementation is secure and efficient!","solution":"def is_prime(n): if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i ** 2 <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def gcd(a, b): while b: a, b = b, a % b return a def is_primitive_root(a, p): if not is_prime(p): return False required_set = {num for num in range(1, p) if gcd(num, p) == 1} actual_set = {pow(a, powers, p) for powers in range(1, p)} return required_set == actual_set def mod_exp(base, exponent, modulus): result = 1 base = base % modulus while exponent > 0: if exponent % 2 == 1: result = (result * base) % modulus exponent = exponent >> 1 base = (base * base) % modulus return result def diffie_hellman_key_exchange(a, p): if not is_prime(p): return False if not is_primitive_root(a, p): return False alice_private_key = 6 # Assuming a randomly chosen small private key for demonstration bob_private_key = 15 # Assuming a randomly chosen small private key for demonstration alice_public_key = mod_exp(a, alice_private_key, p) bob_public_key = mod_exp(a, bob_private_key, p) alice_shared_secret = mod_exp(bob_public_key, alice_private_key, p) bob_shared_secret = mod_exp(alice_public_key, bob_private_key, p) return alice_shared_secret == bob_shared_secret"},{"question":"Scenario You have been hired by a company that wants to implement a simple encryption algorithm for encoding secret messages. Your job is to write a function that will encode given strings using the Atbash cipher. Problem Statement **Function**: `encrypt_atbash(message: str) -> str` Write a function that takes a string, `message`, and returns a new string that is the Atbash cipher encoding of the input message. * The function should maintain the case of the letters (uppercase translates to uppercase, lowercase translates to lowercase). * Non-alphabet characters should be included in the output as they are without changing. Detailed Specification 1. **Input**: - `message` (str): The input string containing alphabetic and possibly non-alphabetic characters. 2. **Output**: - (str): A new string that represents the message encoded with the Atbash cipher. 3. **Constraints**: - `1 <= len(message) <= 10^5` - The input string `message` can contain any printable ASCII characters. Example ```python assert encrypt_atbash(\\"Attack at dawn\\") == \\"Zggzxp zg wzdm\\" assert encrypt_atbash(\\"Hello, World!\\") == \\"Svool, Dliow!\\" assert encrypt_atbash(\\"abc XYZ\\") == \\"zyx CBA\\" ``` Performance Requirements Your solution should handle strings of length up to 100,000 characters efficiently.","solution":"def encrypt_atbash(message: str) -> str: Encodes the input message using the Atbash cipher. Parameters: message (str): The input message to be encoded. Returns: str: The encoded message. def atbash_char(c): if \'a\' <= c <= \'z\': return chr(219 - ord(c)) elif \'A\' <= c <= \'Z\': return chr(155 - ord(c)) return c return \'\'.join(atbash_char(c) for c in message)"},{"question":"**Task**: Write a function called `reformat_license_key` that takes in a string and an integer, and returns the string reformatted according to specific rules. **Function Signature**: ```python def reformat_license_key(key: str, k: int) -> str: pass ``` **Input**: * `key` (string): A string of alphanumeric characters and hyphens (`-`). Length of the string is up to 10^5. * `k` (int): A positive integer indicating the group size for formatted segments. **Output**: * Return a string where the input is reformatted by: * Removing all hyphens. * Inserting a hyphen after every `k` characters. **Constraints**: * The function should ensure no hyphen follows at the end of the string. * Grouping should be from right to left. * The length of input string `key` will be between 1 and 10^5. * `k` will be a positive integer and no greater than the length of the input string. **Example**: ```python assert reformat_license_key(\\"5F3Z-2e-9-w\\", 4) == \\"5F3Z-2E9W\\" assert reformat_license_key(\\"2-5g-3-J\\", 2) == \\"2-5G-3J\\" assert reformat_license_key(\\"--a-a-a-a--\\", 2) == \\"AA-AA\\" ``` **Explanation**: 1. In the first example, after removing hyphens and grouping 4 characters results in \\"5F3Z-2E9W\\". 2. In the second example, grouping by 2 results in \\"2-5G-3J\\". 3. In the third example, after considering only alphanumerics and grouping by 2 results in \\"AA-AA\\". Write your implementation considering the edge cases specified and taking care of any performance bottlenecks.","solution":"def reformat_license_key(key: str, k: int) -> str: Reformats the license key according to the specified rules :param key: License key string with alphanumeric characters and hyphens :param k: Integer indicating the group size for formatted segments :return: Formatted license key string # Remove all hyphens and convert to uppercase cleaned_key = key.replace(\'-\', \'\').upper() # Reverse the cleaned string for easier grouping from the end reversed_key = cleaned_key[::-1] # Create the grouped string with the hyphens grouped = [] for i in range(0, len(reversed_key), k): grouped.append(reversed_key[i:i+k]) # Join the groups with hyphens and reverse back to the original order formatted_key = \'-\'.join(grouped)[::-1] return formatted_key"},{"question":"# Context: You are given a non-negative integer represented as a list of digits, where each element in the list contains a single digit. The integer does not contain any leading zero, except the number 0 itself. You need to write a function that increments this integer by one and returns the resulting list of digits. # Task: Implement a function `increment_number(digits: List[int]) -> List[int]` that: 1. Takes in a list of non-negative digits. 2. Returns a list of digits representing the incremented number. # Input: - A list `digits` of length `n` (1 ≤ n ≤ 10^4), where each element is a digit (0-9). # Output: - A list of digits representing the number incremented by one. # Constraints: - The input list will not be empty and does not contain leading zeros except for the single digit number 0. # Example: ```python def increment_number(digits: List[int]) -> List[int]: # Implement the logic here pass # Test case 1 print(increment_number([1, 2, 3])) # Output: [1, 2, 4] # Test case 2 print(increment_number([4, 3, 2, 1])) # Output: [4, 3, 2, 2] # Test case 3 print(increment_number([9, 9, 9, 9])) # Output: [1, 0, 0, 0, 0] ``` # Notes: - Make sure the solution is efficient in terms of time and space complexity. - Be careful to handle edge cases such as carryover when all digits are 9. Your solution will be evaluated based on correctness, efficiency, and clarity of the code.","solution":"from typing import List def increment_number(digits: List[int]) -> List[int]: This function takes a list of digits representing a non-negative integer and increments that integer by one, returning the resulting list of digits. # Start from the end of the list and work backwards for i in reversed(range(len(digits))): # If the current digit is less than 9, simply increment it and return the result if digits[i] < 9: digits[i] += 1 return digits # If the current digit is 9, set it to 0 and continue to the next digit digits[i] = 0 # If we\'ve gone through all digits and all were 9, we need an additional digit at the start digits.insert(0, 1) return digits"},{"question":"Bitonic Sort Implementation Objective Your task is to implement a modified version of the `bitonic_sort` function. This modified version should handle arrays of any size by padding the array to the next power of two with a specified padding value before sorting and then removing the padding after sorting. Function Signature ```python def modified_bitonic_sort(arr: List[int], reverse: bool = False, pad_value: int = float(\'inf\')) -> List[int]: Sorts an array using the Bitonic Sort algorithm, modified to handle arrays of any size. Parameters: arr (List[int]): The array to sort. reverse (bool): If True, sorts in decreasing order. Otherwise, sorts in increasing order. pad_value (int): The value used to pad the array to the next power of two. Returns: List[int]: The sorted array. ``` Constraints * The input array can have any non-negative size. * You should pad the array to the next power of two using the specified `pad_value`. * Only remove the padding values to return the sorted array. * You can assume the `pad_value` will always be greater than any element in the input array (if sorting in ascending order) and less than any element if `reverse` is `True`. Example ```python arr = [3, 1, 5, 7, 2] print(modified_bitonic_sort(arr)) # Output: [1, 2, 3, 5, 7] arr = [3, 1, 5, 7, 2] print(modified_bitonic_sort(arr, reverse=True)) # Output: [7, 5, 3, 2, 1] ``` Additional Explanation Given the input array `[3, 1, 5, 7, 2]`, which size is not a power of two, you need to pad it to the next power of two (which is 8). If `pad_value` is infinity, then the padded array becomes `[3, 1, 5, 7, 2, inf, inf, inf]`. After sorting this padded array, you should remove the padding and return only the original elements sorted.","solution":"from typing import List import math def bitonic_compare_and_swap(arr: List[int], i: int, j: int, direction: bool): if direction == (arr[i] > arr[j]): arr[i], arr[j] = arr[j], arr[i] def bitonic_merge(arr: List[int], low: int, cnt: int, direction: bool): if cnt > 1: k = cnt // 2 for i in range(low, low + k): bitonic_compare_and_swap(arr, i, i + k, direction) bitonic_merge(arr, low, k, direction) bitonic_merge(arr, low + k, k, direction) def bitonic_sort_rec(arr: List[int], low: int, cnt: int, direction: bool): if cnt > 1: k = cnt // 2 bitonic_sort_rec(arr, low, k, True) # ascending bitonic_sort_rec(arr, low + k, k, False) # descending bitonic_merge(arr, low, cnt, direction) def next_power_of_two(n: int) -> int: return 1 << (n - 1).bit_length() def modified_bitonic_sort(arr: List[int], reverse: bool = False, pad_value: int = float(\'inf\')) -> List[int]: n = len(arr) if n == 0: return arr next_pow2 = next_power_of_two(n) padded_arr = arr + [pad_value] * (next_pow2 - n) bitonic_sort_rec(padded_arr, 0, next_pow2, not reverse) result = [x for x in padded_arr if x != pad_value] return result"},{"question":"**Skyline Problem** Given a city\'s skyline represented by buildings with their positions and heights, write a function `get_skyline(buildings)` that outputs the critical points forming the skyline when viewed from a distance. **Input:** - `buildings`: A list of `n` buildings, where each building is denoted by a triplet `[Li, Ri, Hi]`. - `Li` is the x-coordinate of the left edge of the ith building. - `Ri` is the x-coordinate of the right edge of the ith building. - `Hi` is the height of the ith building. - Constraints: - (0 le Li, Ri le text{INT_MAX}) - (0 < Hi le text{INT_MAX}) - (Ri - Li > 0) - Number of buildings: (0 le n le 10000) **Output:** - A list of key points in the format of `[[x1, y1], [x2, y2], ...]` that defines the skyline. - Each key point `[x, y]` represents the x-coordinate of a vertical line where the height of the skyline changes. - Ensure no consecutive horizontal lines of equal height appear in the output. **Example:** Input: ``` buildings = [[2, 9, 10], [3, 7, 15], [5, 12, 12], [15, 20, 10], [19, 24, 8]] ``` Output: ``` [[2, 10], [3, 15], [7, 12], [12, 0], [15, 10], [20, 8], [24, 0]] ``` **Scenario:** Suppose you want to visualize the silhouette of a city\'s skyline formed by several buildings grounded on a flat surface. Given the geometric information of the buildings, determine the critical points that uniquely define the external contour of the skyline. **Task:** Implement the function `get_skyline(buildings)` to solve the skyline problem efficiently. **Function Signature:** ```python def get_skyline(buildings: List[List[int]]) -> List[List[int]]: pass ``` **Constraints:** * The input list is already sorted by the left x position `Li`. * The output list must be sorted by the x position. * Ensure no redundant points in the skyline. Use the provided function signature and ensure the output is as per the specified format. Good luck!","solution":"import heapq from typing import List def get_skyline(buildings: List[List[int]]) -> List[List[int]]: if not buildings: return [] # Events are the critical points events = [] for L, R, H in buildings: events.append((L, -H, R)) # Start point events.append((R, 0, 0)) # End point # Sort events, prioritizing by x, then height descending, then R ascending events.sort() # Result list and an active invisible heap (height, end) result = [[0, 0]] live_heap = [(0, float(\'inf\'))] for x, h_neg, R in events: while live_heap[0][1] <= x: heapq.heappop(live_heap) if h_neg != 0: heapq.heappush(live_heap, (h_neg, R)) if result[-1][1] != -live_heap[0][0]: result.append([x, -live_heap[0][0]]) return result[1:]"},{"question":"You are required to implement a function that computes the power of a given base raised to an exponent using the concept of binary exponentiation. Your implementation should be efficient enough to handle large inputs and offer an option to compute results under modulo arithmetic. # Function Signature ```python def binary_exponentiation(a: int, n: int, mod: int = None) -> int: :param a: The base integer :param n: The exponent integer :param mod: Optional integer for modulo :return: The computed result of a^n, optionally modulo mod ``` # Input Constraints - `-10^9 <= a <= 10^9` - `0 <= n <= 10^9` - `1 <= mod <= 10^9` (if provided) # Output - The function should return an integer, the computed value of (a^n). - If `mod` is provided, return the result as (a^n % mod). # Examples Example 1: ```python binary_exponentiation(2, 10) ``` **Output**: `1024` Example 2: ```python binary_exponentiation(2, 10, 1000) ``` **Output**: `24` # Explanation 1. In the first example: (2^{10} = 1024). 2. In the second example: (2^{10} = 1024), and (1024 % 1000 = 24). # Note - It is important to consider the efficiency in terms of time and space. - Specifically handle and define the behavior for base cases, and consider large input scenarios to ensure performance.","solution":"def binary_exponentiation(a: int, n: int, mod: int = None) -> int: Computes the power of a given base raised to an exponent using binary exponentiation. :param a: The base integer :param n: The exponent integer :param mod: Optional integer for modulo :return: The computed result of a^n, optionally modulo mod result = 1 base = a # Adjust the base if modulo is provided if mod: base = base % mod while n > 0: # If n is odd, multiply the base with result if n % 2 == 1: result = result * base # Apply modulo if provided if mod: result = result % mod # Floor divide n by 2 n = n // 2 # Square the base base = base * base # Apply modulo if provided if mod: base = base % mod return result"},{"question":"# Efficient Word Dictionary Design You are tasked with implementing an efficient word dictionary that allows storing a list of words and supports searching with optional pattern matching using the \'.\' character, representing any letter. Requirements 1. **add_word(word)**: Adds a word to the dictionary. 2. **search(word)**: Searches for a word in the dictionary. The word can contain the \'.\' character representing any letter. # Function Specifications ```python class WordDictionary: def __init__(self): pass # implement initialization code here def add_word(self, word: str): pass # implement code to add word here def search(self, word: str) -> bool: pass # implement search functionality here ``` Input/Output * **add_word(word)**: * `word` (string): A non-empty string containing alphabetic characters \'a\' to \'z\'. * **search(word)**: * `word` (string): A non-empty string possibly containing alphabetic characters \'a\' to \'z\' and \'.\' character. * **Returns**: `True` if the word matches any added word, or `False` otherwise. Constraints * Assume the addition and search operations will be called multiple times. * Each word\'s length will not exceed 100. * The total number of words added will not exceed 10000. Example ```python wd = WordDictionary() wd.add_word(\\"bad\\") wd.add_word(\\"dad\\") wd.add_word(\\"mad\\") assert wd.search(\\"pad\\") == False # exact match required assert wd.search(\\"bad\\") == True assert wd.search(\\".ad\\") == True # \'.\' can match \'b\', \'d\', \'m\' assert wd.search(\\"b..\\") == True # \'..\' can match \'a\', \'d\' assert wd.search(\\"b...\\") == False # no word with 4 letters starting with \'b\' ``` # Additional Notes * Ensure your solution handles edge cases properly including words with multiple \'.\' characters, and words of varying lengths efficiently. * Your solution should be optimized for both space and time complexity.","solution":"class WordDictionary: def __init__(self): self.words = [] def add_word(self, word: str): self.words.append(word) def search(self, word: str) -> bool: def match(word, candidate): if len(word) != len(candidate): return False for w_char, c_char in zip(word, candidate): if w_char != \'.\' and w_char != c_char: return False return True return any(match(word, candidate) for candidate in self.words)"},{"question":"# Single Unique Number Finder You are given an array of integers where every element appears twice except for one. You need to find the element that appears only once. You should implement the solution with a linear runtime complexity and without using extra memory apart from a constant amount of space. Input: * A single list of integers, `nums`, where `1 <= len(nums) <= 10^5` and each element is an integer. Output: * An integer representing the unique element in the list. Constraints: * Exactly one element appears once, and all other elements appear exactly twice. Example: ```python Input: [4, 1, 2, 1, 2] Output: 4 Input: [2, 2, 3, 4, 4, 3, 5] Output: 5 ``` # Function Signature: ```python def find_unique_number(nums: List[int]) -> int: ``` # Notes: * Consider handling edge cases such as an array with one element. * Optimize the function to run in O(n) time and use O(1) additional space. * Ensure to handle both larger datasets effectively.","solution":"def find_unique_number(nums): Returns the unique number in the list where every element except one appears twice. unique = 0 for num in nums: unique ^= num return unique"},{"question":"Write a function named `heap_sort` that sorts an array of integers in ascending order using Heap Sort algorithm. You should provide both the max-heap version and the min-heap version of the heap sort. Your function should meet the following specifications: Function Signature ```python def heap_sort(arr: list[int], use_max_heap: bool = True, simulation: bool = False) -> list[int]: Sorts an array of integers in ascending order using Heap Sort algorithm. :param arr: List of integers to be sorted. :param use_max_heap: Boolean flag to choose between max-heap and min-heap sort. True for max-heap based heap sort, False for min-heap. :param simulation: Boolean flag to output the array state at each significant iteration for visualization. :return: Sorted list of integers in ascending order. ``` Input 1. `arr`: A list of integers to be sorted. Example: `[3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]` 2. `use_max_heap`: A boolean flag to determine the type of heap sort. Default is `True` (max-heap sort). 3. `simulation`: A boolean flag to enable output of array states at each significant step. Default is `False`. Output 1. Returns a sorted list of integers in ascending order. Constraints 1. The length of the input array `n` will be between 0 and 10^5. 2. Each element in the array will be an integer within the 32-bit signed integer range. Example ```python print(heap_sort([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5])) # Output: [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9] print(heap_sort([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5], use_max_heap=False)) # Output: [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9] ``` Notes * You are not allowed to use any in-built Python sorting functions or libraries to accomplish the task. * Your implementation should handle empty arrays gracefully and return an empty array if the input is empty. * If `simulation` is `True`, print the state of the array at each significant iteration (similar to the provided code snippets).","solution":"def heap_sort(arr, use_max_heap=True, simulation=False): def heapify(arr, n, i, use_max_heap): largest_or_smallest = i l = 2 * i + 1 r = 2 * i + 2 comparison = (lambda x, y: x > y) if use_max_heap else (lambda x, y: x < y) if l < n and comparison(arr[l], arr[largest_or_smallest]): largest_or_smallest = l if r < n and comparison(arr[r], arr[largest_or_smallest]): largest_or_smallest = r if largest_or_smallest != i: arr[i], arr[largest_or_smallest] = arr[largest_or_smallest], arr[i] if simulation: print(f\\"Heapify step with i={i}, n={n}: {arr}\\") heapify(arr, n, largest_or_smallest, use_max_heap) def build_heap(arr, use_max_heap): n = len(arr) for i in range(n // 2 - 1, -1, -1): heapify(arr, n, i, use_max_heap) if simulation: print(f\\"Build heap step with i={i}: {arr}\\") n = len(arr) build_heap(arr, use_max_heap) for i in range(n - 1, 0, -1): arr[0], arr[i] = arr[i], arr[0] heapify(arr, i, 0, use_max_heap) if simulation: print(f\\"Sorting step with i={i}: {arr}\\") if not use_max_heap: arr.reverse() return arr"},{"question":"# Binary Tree Preorder Traversal **Scenario**: You are given a binary tree and need to traverse it in preorder. Preorder traversal involves visiting the root node first, then recursively traversing the left subtree, followed by the right subtree. This type of traversal is often used to create a copy of the tree. **Task**: Implement a function to perform preorder traversal of a binary tree. You should implement two versions of this function: one using recursion and another using iteration. **Function Signature**: ```python def preorder_recursive(root: Optional[Node]) -> List[int]: pass def preorder_iterative(root: Optional[Node]) -> List[int]: pass ``` **Input**: - `root`: A reference to the root of the binary tree. The tree node is represented by an instance of a `Node` class with attributes `val` (integer), `left` (left child), and `right` (right child). **Output**: - Return a list of integers representing the node values in preorder sequence. **Constraints**: - You may assume that the node values are unique. - The maximum number of nodes in the tree is `10^4`. **Performance requirements**: - The solution should have a time complexity of O(n) and a space complexity of O(h) for the recursive solution. **Examples**: 1. Given the tree: ``` 1 / 2 3 / 4 5 ``` Calling `preorder_recursive(root)` or `preorder_iterative(root)` should both return `[1, 2, 4, 5, 3]`. 2. Given the tree: ``` 1 2 3 ``` Calling `preorder_recursive(root)` or `preorder_iterative(root)` should both return `[1, 2, 3]`. **Edge Cases**: - An empty tree (`root = None`) should return an empty list (`[]`). - A tree with a single node should return a list with one element ([node_value]).","solution":"from typing import Optional, List class Node: def __init__(self, val: int, left: \'Node\' = None, right: \'Node\' = None): self.val = val self.left = left self.right = right def preorder_recursive(root: Optional[Node]) -> List[int]: def helper(node: Optional[Node]) -> List[int]: if node is None: return [] return [node.val] + helper(node.left) + helper(node.right) return helper(root) def preorder_iterative(root: Optional[Node]) -> List[int]: if root is None: return [] stack, result = [root], [] while stack: node = stack.pop() result.append(node.val) if node.right: stack.append(node.right) if node.left: stack.append(node.left) return result"},{"question":"# Context: You are tasked with implementing a Red-Black Tree (RBTree) data structure which balances itself during insertion and deletion of nodes while adhering to specific properties (outlined below). The tree should provide efficient operations for inserting, deleting, and retrieving nodes, ensuring that the computational performance demands are met (i.e., operations remain logarithmic in complexity). # Problem Statement: Implement an efficient and self-balancing Red-Black Tree. Your Red-Black Tree should support standard operations: insertion, deletion, and an in-order traversal to get all elements in the tree. # Function Definitions: 1. **Insert Function**: ```python def insert(self, key: int) -> None: Insert a node with a given key into the Red-Black Tree. :param key: Key of the node to be inserted. pass ``` 2. **Delete Function**: ```python def delete(self, key: int) -> None: Delete a node with a given key from the Red-Black Tree. :param key: Key of the node to be deleted. pass ``` 3. **In-Order Traversal**: ```python def inorder(self) -> list: Perform an in-order traversal of the Red-Black Tree and return the keys of nodes in sorted order. :return: A list of keys in sorted order. pass ``` # Requirements: 1. **Red-Black Tree Properties**: - Each node is either red or black. - The root is always black. - All leaves (NIL nodes) are black. - If a red node has children, then the children are always black (no two red nodes in a row). - Every path from a node to its descendant NIL nodes has the same number of black nodes. 2. **Operational Complexity**: - Insertions, deletions, and lookups should be ( O(log n) ). 3. **Edge Cases**: - Handle inserting duplicate keys (either by rejecting duplicates or managing counts). - Ensure properties are maintained during insertion and deletion. - Handle NULL pointers and ensure correct tree updates for single children nodes. # Input/Output Examples: - After inserting keys [20, 15, 30, 25, 40]: - `inorder()` returns [15, 20, 25, 30, 40]. - After deleting key 25: - `inorder()` returns [15, 20, 30, 40]. ```python # Example Usage: rbt = RBTree() rbt.insert(20) rbt.insert(15) rbt.insert(30) rbt.insert(25) rbt.insert(40) print(rbt.inorder()) # Expected: [15, 20, 25, 30, 40] rbt.delete(25) print(rbt.inorder()) # Expected: [15, 20, 30, 40] ``` **Note**: Ensure the Red-Black Tree properties are maintained after each insertion and deletion operation.","solution":"class Node: def __init__(self, key, color=\'red\'): self.key = key self.color = color # \'red\' or \'black\' self.left = None self.right = None self.parent = None class RBTree: def __init__(self): self.NIL_LEAF = Node(key=None, color=\'black\') self.root = self.NIL_LEAF def insert(self, key): new_node = Node(key) new_node.left = self.NIL_LEAF new_node.right = self.NIL_LEAF self._insert_node(new_node) self._fix_insert(new_node) def _insert_node(self, node): current = self.root parent = None while current != self.NIL_LEAF: parent = current if node.key < current.key: current = current.left else: current = current.right node.parent = parent if parent is None: self.root = node elif node.key < parent.key: parent.left = node else: parent.right = node node.color = \'red\' def _fix_insert(self, node): while node != self.root and node.parent.color == \'red\': if node.parent == node.parent.parent.left: uncle = node.parent.parent.right if uncle.color == \'red\': node.parent.color = \'black\' uncle.color = \'black\' node.parent.parent.color = \'red\' node = node.parent.parent else: if node == node.parent.right: node = node.parent self._left_rotate(node) node.parent.color = \'black\' node.parent.parent.color = \'red\' self._right_rotate(node.parent.parent) else: uncle = node.parent.parent.left if uncle.color == \'red\': node.parent.color = \'black\' uncle.color = \'black\' node.parent.parent.color = \'red\' node = node.parent.parent else: if node == node.parent.left: node = node.parent self._right_rotate(node) node.parent.color = \'black\' node.parent.parent.color = \'red\' self._left_rotate(node.parent.parent) self.root.color = \'black\' def _left_rotate(self, node): right = node.right node.right = right.left if right.left != self.NIL_LEAF: right.left.parent = node right.parent = node.parent if node.parent is None: self.root = right elif node == node.parent.left: node.parent.left = right else: node.parent.right = right right.left = node node.parent = right def _right_rotate(self, node): left = node.left node.left = left.right if left.right != self.NIL_LEAF: left.right.parent = node left.parent = node.parent if node.parent is None: self.root = left elif node == node.parent.right: node.parent.right = left else: node.parent.left = left left.right = node node.parent = left def delete(self, key): node = self._find_node(key, self.root) if node: self._delete_node(node) def _find_node(self, key, node): while node != self.NIL_LEAF: if key == node.key: return node elif key < node.key: node = node.left else: node = node.right return None def _delete_node(self, node): y_original_color = node.color if node.left == self.NIL_LEAF: x = node.right self._transplant(node, node.right) elif node.right == self.NIL_LEAF: x = node.left self._transplant(node, node.left) else: y = self._minimum(node.right) y_original_color = y.color x = y.right if y.parent == node: x.parent = y else: self._transplant(y, y.right) y.right = node.right y.right.parent = y self._transplant(node, y) y.left = node.left y.left.parent = y y.color = node.color if y_original_color == \'black\': self._fix_delete(x) def _transplant(self, u, v): if u.parent is None: self.root = v elif u == u.parent.left: u.parent.left = v else: u.parent.right = v v.parent = u.parent def _minimum(self, node): while node.left != self.NIL_LEAF: node = node.left return node def _fix_delete(self, x): while x != self.root and x.color == \'black\': if x == x.parent.left: sibling = x.parent.right if sibling.color == \'red\': sibling.color = \'black\' x.parent.color = \'red\' self._left_rotate(x.parent) sibling = x.parent.right if sibling.left.color == \'black\' and sibling.right.color == \'black\': sibling.color = \'red\' x = x.parent else: if sibling.right.color == \'black\': sibling.left.color = \'black\' sibling.color = \'red\' self._right_rotate(sibling) sibling = x.parent.right sibling.color = x.parent.color x.parent.color = \'black\' sibling.right.color = \'black\' self._left_rotate(x.parent) x = self.root else: sibling = x.parent.left if sibling.color == \'red\': sibling.color = \'black\' x.parent.color = \'red\' self._right_rotate(x.parent) sibling = x.parent.left if sibling.left.color == \'black\' and sibling.right.color == \'black\': sibling.color = \'red\' x = x.parent else: if sibling.left.color == \'black\': sibling.right.color = \'black\' sibling.color = \'red\' self._left_rotate(sibling) sibling = x.parent.left sibling.color = x.parent.color x.parent.color = \'black\' sibling.left.color = \'black\' self._right_rotate(x.parent) x = self.root x.color = \'black\' def inorder(self): result = [] self._inorder_helper(self.root, result) return result def _inorder_helper(self, node, result): if node != self.NIL_LEAF: self._inorder_helper(node.left, result) result.append(node.key) self._inorder_helper(node.right, result)"},{"question":"# ZigZag Iterator for Multiple Lists **Scenario**: Assume you\'re working on a system that processes multiple streams of data where you want to read elements from all streams in a round-robin fashion to ensure fair processing of all streams. # Task: Implement a ZigZagIterator class that can handle an arbitrary number of lists. Your iterator should return elements from the lists in a round-robin manner, skipping over any list that has been exhausted. # Requirements: 1. **Initialization**: - Initialize the iterator with a list of lists. - `__init__(self, list_of_lists: List[List[int]])` 2. **next()**: - Return the next element in the zigzag traversal. - `next(self) -> int` 3. **has_next()**: - Return whether there are any remaining elements. - `has_next(self) -> bool` # Example: ```python l1 = [1, 2] l2 = [3, 4, 5, 6] l3 = [7, 8, 9] iterator = ZigZagIterator([l1, l2, l3]) result = [] while iterator.has_next(): result.append(iterator.next()) print(result) # Output: [1, 3, 7, 2, 4, 8, 5, 9, 6] ``` # Constraints: 1. The input lists may not be of the same size. 2. Handle empty lists efficiently. 3. Must run with a time complexity of O(1) for `next` and `has_next` operations. 4. Optimize for space complexity as well, ensuring it\'s linear with respect to the total number of elements across all lists. # Performance: - Ensure your implementation is efficient both in terms of time and space.","solution":"from collections import deque from typing import List class ZigZagIterator: def __init__(self, list_of_lists: List[List[int]]): self.queue = deque() for lst in list_of_lists: if lst: self.queue.append(deque(lst)) def next(self) -> int: if self.queue: current_list = self.queue.popleft() value = current_list.popleft() if current_list: self.queue.append(current_list) return value raise StopIteration(\\"No more elements\\") def has_next(self) -> bool: return bool(self.queue)"},{"question":"You are given a binary search tree with unique integer values. Your task is to write a function that converts this binary search tree into a sorted doubly linked list in place. The elements of the doubly linked list should follow the in-order sequence of the binary tree. # Function Signature ```python def convert_bst_to_doubly_linked_list(root: TreeNode) -> TreeNode: ``` # Input * `root` (TreeNode): The root node of the binary search tree. # Output * (TreeNode): The head of the doubly linked list. # Constraints * The binary search tree will have `n` nodes where `1 <= n <= 10^4`. # Example Scenario: You\'ve been given the following binary search tree with nodes having values 4, 2, 5, 1, and 3: ``` 4 / 2 5 / 1 3 ``` The in-order traversal of this tree is `[1, 2, 3, 4, 5]`. Therefore, after the function is called, the doubly linked list should have this sequence with the head node\'s value being 1 and the sequence going forward and backward properly maintained. Example Invocation: ```python bst_root = TreeNode(4, left=TreeNode(2, left=TreeNode(1), right=TreeNode(3)), right=TreeNode(5)) head = convert_bst_to_doubly_linked_list(bst_root) current = head while current: print(current.val, end=\\" \\") current = current.right ``` Output: ``` 1 2 3 4 5 ``` # Important Notes * Make sure to handle cases like an empty tree and a single-node tree. * Your solution should run in O(n) time and use O(h) space, where `n` is the number of nodes and `h` is the height of the tree.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def convert_bst_to_doubly_linked_list(root: TreeNode) -> TreeNode: Converts a binary search tree to a sorted doubly linked list in place. Returns the head of the doubly linked list. if not root: return None # Helper function to perform the in-order traversal and link nodes def in_order_traverse(node): nonlocal last, head if not node: return # Traverse left subtree in_order_traverse(node.left) # Link the previous node (last) with the current one (node) if last: last.right = node node.left = last else: head = node # This will be the head of the doubly linked list last = node # Mark this node as the last processed node # Traverse right subtree in_order_traverse(node.right) last, head = None, None in_order_traverse(root) return head"},{"question":"A Unix-style file path simplification tool processes string-based paths to reduce redundant content such as multiple slashes, `.` (current directory), and `..` (parent directory references). Students are tasked with implementing a function to achieve this. Implement the `simplify_path(path: str) -> str` function that, given an absolute Unix-style path, returns its simplified canonical form. # Input * `path` (string): Absolute Unix-style file path. # Output * (string): Simplified canonical path. # Constraints * The input path is a non-empty string starting with a `/`, representing an absolute path. * Path segments consist of alphanumeric characters and the specific symbols `.` and `..`. # Examples * `simplify_path(\\"/home/\\")` -> `\\"/home\\"` * `simplify_path(\\"/a/./b/../../c/\\")` -> `\\"/c\\"` * `simplify_path(\\"/../\\")` -> `\\"/\\"` * `simplify_path(\\"/home//foo/\\")` -> `\\"/home/foo\\"` # Requirements Implement the function such that: * The function processes the path in O(n) time complexity. * It uses O(n) extra space where n is the length of the input path. # Scenario Imagine you are designing a script for a command-line tool used in file management and web server configurations. The tool must always return the canonical form of an input path, as specified above, to ensure uniform and correct directory access. Implement the `simplify_path` function, ensuring it handles edge cases like redundant slashes and leading/trailing/extra `..` according to requirements.","solution":"def simplify_path(path: str) -> str: components = path.split(\'/\') stack = [] for component in components: if component == \'\' or component == \'.\': continue elif component == \'..\': if stack: stack.pop() else: stack.append(component) return \'/\' + \'/\'.join(stack)"},{"question":"# Objective Implement the Union-Find data structure with both path compression and union by size. Then, use it to solve a problem related to finding the number of connected components in a dynamic graph. # Problem Statement You are given a list of `n` elements indexed from `0` to `n-1` and a series of union operations represented as pairs of indices. After performing all union operations, you need to return the number of connected components in the set. # Input * An integer `n`, the number of elements. * A list of tuples `unions`, where each tuple `(a, b)` represents a union operation between elements at indices `a` and `b`. # Output * An integer representing the number of connected components. # Constraints * `1 <= n <= 10^5` * `0 <= a, b < n` * `a` != `b` * The number of union operations will not exceed `2 * n`. # Example ```python Input: n = 5 unions = [(0, 1), (1, 2), (3, 4)] Output: 2 Explanation: Initially, we have 5 elements in 5 different sets: {0}, {1}, {2}, {3}, {4} After the first union (0, 1), we have: {0,1}, {2}, {3}, {4} After the second union (1, 2), we have: {0,1,2}, {3}, {4} After the last union (3, 4), we have: {0,1,2}, {3,4} Hence, there are 2 connected components. ``` # Function Signature ```python def count_components(n: int, unions: list[tuple[int, int]]) -> int: pass ``` # Implementation Requirements * Implement the Union-Find data structure with path compression and union by size. * Utilize the data structure to determine the number of connected components after performing all the union operations.","solution":"def count_components(n: int, unions: list[tuple[int, int]]) -> int: class UnionFind: def __init__(self, size): self.root = [i for i in range(size)] self.size = [1] * size self.component_count = size def find(self, x): if self.root[x] != x: self.root[x] = self.find(self.root[x]) # Path compression return self.root[x] def union(self, x, y): rootX = self.find(x) rootY = self.find(y) if rootX != rootY: # Union by size if self.size[rootX] > self.size[rootY]: self.root[rootY] = rootX self.size[rootX] += self.size[rootY] else: self.root[rootX] = rootY self.size[rootY] += self.size[rootX] self.component_count -= 1 def get_count(self): return self.component_count uf = UnionFind(n) for a, b in unions: uf.union(a, b) return uf.get_count()"},{"question":"# Queue Analysis Problem Problem Statement You are provided with two implementations of the Queue data structure: `ArrayQueue` and `LinkedListQueue`. Your task is to implement a two-level queueing system, where a primary queue delegates tasks to secondary queues based on specific criteria. The primary queue will use an array-based implementation, while the secondary queues will use linked list-based implementations. **Requirements**: 1. Implement the primary `ArrayQueue` class as specified. Expand its initial capacity when needed. 2. Implement the secondary `LinkedListQueue` class, which will be used to create multiple secondary queues. 3. Design a function `assign_task(task)` in the primary queue class that enqueues tasks to one of the secondary queues based on the task\'s category. 4. Implement a function `process_next()` that processes (dequeues and returns) the next task from the next available non-empty secondary queue. Input - Tasks to be enqueued, where each task is a tuple `(task_id, category)`. Assumption: there are three categories: \'A\', \'B\', and \'C\'. - The primary queue initialization parameter is capacity (integer). Output - The `process_next()` function should return the `task_id` of the processed task. Example ```python pq = ArrayQueue() pq.assign_task((1, \'A\')) pq.assign_task((2, \'B\')) pq.assign_task((3, \'C\')) pq.assign_task((4, \'C\')) print(pq.process_next()) # Should return 1 print(pq.process_next()) # Should return 2 print(pq.process_next()) # Should return 3 print(pq.process_next()) # Should return 4 ``` Constraints - Ensure efficient operations, particularly minimizing time complexity for frequent operations. - Handle edge cases such as attempting to process a task when all queues are empty. Function Signatures Below are the function signatures you should implement: ```python class ArrayQueue: def __init__(self, capacity): # Initialization logic here def assign_task(self, task): Assigns the task to the appropriate secondary queue based on category pass def process_next(self): Processes the next task from the next available non-empty secondary queue pass class LinkedListQueue: def __init__(self): # Initialization logic here def enqueue(self, value): # Logic for enqueue def dequeue(self): # Logic for dequeue def peek(self): # Logic for peek ``` Notes - You will need to instantiate and manage multiple `LinkedListQueue` instances in the primary `ArrayQueue`.","solution":"class ArrayQueue: def __init__(self, capacity=10): self.capacity = capacity self.queues = { \'A\': LinkedListQueue(), \'B\': LinkedListQueue(), \'C\': LinkedListQueue() } self.category_order = [\'A\', \'B\', \'C\'] self.current_index = 0 def assign_task(self, task): task_id, category = task if category in self.queues: self.queues[category].enqueue(task_id) else: raise ValueError(f\\"Unknown category: {category}\\") def process_next(self): for _ in range(len(self.category_order)): category = self.category_order[self.current_index] if not self.queues[category].is_empty(): self.current_index = (self.current_index + 1) % len(self.category_order) return self.queues[category].dequeue() self.current_index = (self.current_index + 1) % len(self.category_order) raise Exception(\\"All queues are empty\\") class LinkedListQueue: class Node: def __init__(self, value): self.value = value self.next = None def __init__(self): self.front = None self.rear = None self.size = 0 def enqueue(self, value): new_node = self.Node(value) if self.rear is not None: self.rear.next = new_node self.rear = new_node if self.front is None: self.front = new_node self.size += 1 def dequeue(self): if self.front is None: raise Exception(\\"Queue is empty\\") value = self.front.value self.front = self.front.next if self.front is None: self.rear = None self.size -= 1 return value def is_empty(self): return self.size == 0"},{"question":"You are tasked with implementing a data structure to store a collection of words and allow for efficient search queries. The search queries need to support exact matches and wildcard matches, where the wildcard character \'.\' can represent any letter. # Requirements: 1. Implement a class `WordDictionary` with the following methods: * `add_word(word: str) -> None`: Adds a word to the data structure. * `search(word: str) -> bool`: Returns `True` if there is any word in the data structure that matches the given word or pattern, and `False` otherwise. # Constraints: * All input strings are lowercase alphabets. * The length of words will be at most 100. # Implementation Guidelines: 1. Use a Trie (Prefix Tree) to store and search words efficiently. 2. Handle the wildcards in the `search` method. 3. Consider performance aspects; optimize for both time and space complexity. # Example Usage: ```python wd = WordDictionary() wd.add_word(\\"bad\\") wd.add_word(\\"dad\\") wd.add_word(\\"mad\\") assert not wd.search(\\"pad\\") # returns False assert wd.search(\\"bad\\") # returns True assert wd.search(\\".ad\\") # returns True assert wd.search(\\"b..\\") # returns True ``` # Edge Cases to Handle: 1. Empty word search. 2. Words consisting entirely of wildcards (e.g., \\"...\\"). 3. Mixed scenarios with wildcards and normal letters.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class WordDictionary: def __init__(self): self.root = TrieNode() def add_word(self, word: str) -> None: node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, word: str) -> bool: def search_in_node(word, node): for i, char in enumerate(word): if char == \'.\': for child in node.children.values(): if search_in_node(word[i + 1:], child): return True return False else: if char not in node.children: return False node = node.children[char] return node.is_end_of_word return search_in_node(word, self.root)"},{"question":"**Context**: Networking protocols and file I/O often require data to be converted between integer and byte array formats in both big-endian and little-endian formats. Ensuring correct conversion is critical for compatibility across different system architectures. In this task, you will write functions to convert integers to and from byte arrays in both endian formats. **Task**: You need to implement the following four functions: 1. `int_to_bytes_big_endian(num: int) -> bytes`: - Converts an integer `num` to a big-endian byte array. 2. `int_to_bytes_little_endian(num: int) -> bytes`: - Converts an integer `num` to a little-endian byte array. 3. `bytes_big_endian_to_int(bytestr: bytes) -> int`: - Converts a big-endian byte array `bytestr` to an integer. 4. `bytes_little_endian_to_int(bytestr: bytes) -> int`: - Converts a little-endian byte array `bytestr` to an integer. **Constraints**: - `num` will be a non-negative integer (0 ≤ num ≤ 2^64 - 1). - `bytestr` will be a non-empty byte array. - Do not use any external libraries for conversion except Python\'s standard library collections. **Examples**: ```python assert int_to_bytes_big_endian(305419896) == b\'x12x34x56x78\' assert int_to_bytes_little_endian(305419896) == b\'x78x56x34x12\' assert bytes_big_endian_to_int(b\'x12x34x56x78\') == 305419896 assert bytes_little_endian_to_int(b\'x78x56x34x12\') == 305419896 ``` **Requirements**: Ensure your implementation handles the examples correctly and efficiently, taking into account the performance and edge cases discussed in the analysis.","solution":"def int_to_bytes_big_endian(num: int) -> bytes: return num.to_bytes((num.bit_length() + 7) // 8, \'big\') or b\'x00\' def int_to_bytes_little_endian(num: int) -> bytes: return num.to_bytes((num.bit_length() + 7) // 8, \'little\') or b\'x00\' def bytes_big_endian_to_int(bytestr: bytes) -> int: return int.from_bytes(bytestr, \'big\') def bytes_little_endian_to_int(bytestr: bytes) -> int: return int.from_bytes(bytestr, \'little\')"},{"question":"# Task You are provided with a text file containing a binary string (a string composed only of \'0\' and \'1\'). Write a function called `count_grouped_binary_substrings` that takes the text file path as input, reads the binary string from the file, and returns the number of non-empty contiguous substrings that have the same number of 0\'s and 1\'s, with all the 0\'s and all the 1\'s grouped consecutively. The function signature should be: ```python def count_grouped_binary_substrings(file_path: str) -> int: pass ``` # Input - `file_path`: A string representing the path to the text file containing the binary string. # Output - An integer representing the count of valid grouped binary substrings. # Constraints 1. The binary string will contain only \'0\'s and \'1\'s. 2. The length of the string will be between 1 and 10^5. # Example Input file content: ``` 00110011 ``` Output: ``` 6 ``` Explanation: There are 6 substrings that have equal numbers of consecutive 1\'s and 0\'s: \\"0011\\", \\"01\\", \\"1100\\", \\"10\\", \\"0011\\", and \\"01\\". # Additional Notes * Ensure your function correctly handles edge cases, such as strings with no \'0\' or no \'1\'. * Optimize your code for performance, given the constraints.","solution":"def count_grouped_binary_substrings(file_path: str) -> int: with open(file_path, \'r\') as f: s = f.read().strip() groups = [] count = 1 # Create groups of consecutive \'0\'s and \'1\'s for i in range(1, len(s)): if s[i] == s[i-1]: count += 1 else: groups.append(count) count = 1 groups.append(count) # Now calculate the number of valid substrings result = 0 for i in range(1, len(groups)): result += min(groups[i-1], groups[i]) return result"},{"question":"Matrix Multiplication: Algorithm Implementation **Context**: You have been hired by a research lab to assist with a variety of matrix computations crucial for their data analysis operations. One of the core tasks is to compute the product of two matrices. Your goal is to implement an efficient and correct matrix multiplication function that can handle typical scenarios encountered in research computations. **Problem Statement**: Implement a function `matrix_multiply(multiplicand: List[List[int]], multiplier: List[List[int]]) -> List[List[int]]` that takes two lists of lists (representing matrices) and returns their product. **Specifications**: - The function should validate if the matrices can be legally multiplied (i.e., the number of columns of the multiplicand should equal the number of rows of the multiplier). - If the matrices are incompatible, the function should raise an appropriate exception with a descriptive message. - The result should be a new matrix (list of lists) containing the product of the multiplicand and multiplier. **Constraints**: - The matrices will contain only integer values. - The size of the matrices will not exceed (100 times 100). **Function Signature**: ```python def matrix_multiply(multiplicand: List[List[int]], multiplier: List[List[int]]) -> List[List[int]]: ``` **Example**: ```python multiplicand = [ [1, 2, 3], [4, 5, 6] ] multiplier = [ [7, 8], [9, 10], [11, 12] ] expected_output = [ [58, 64], [139, 154] ] assert matrix_multiply(multiplicand, multiplier) == expected_output ``` **Additional Notes**: - Ensure to handle edge cases such as matrices with zero dimensions. - Optimize your code for readability and maintainability.","solution":"from typing import List def matrix_multiply(multiplicand: List[List[int]], multiplier: List[List[int]]) -> List[List[int]]: # Check if matrices can be multiplied if len(multiplicand[0]) != len(multiplier): raise ValueError(\\"Cannot multiply matrices: incompatible dimensions.\\") # Initialize the result matrix with zeros result = [[0 for _ in range(len(multiplier[0]))] for _ in range(len(multiplicand))] # Perform the multiplication for i in range(len(multiplicand)): for j in range(len(multiplier[0])): for k in range(len(multiplier)): result[i][j] += multiplicand[i][k] * multiplier[k][j] return result"},{"question":"You are given a segment tree data structure with the following properties: * It supports range queries in (O(log n)) time. * It allows for point updates in (O(log n)) time. * It uses a commutative function provided during the tree\'s creation to combine segment values. You need to implement a segment tree that supports a wider range of operations. Specifically, you should add an additional method to support range updates (i.e., updating all elements within a range to a new value), while still maintaining efficient performance. Your segment tree should be able to handle the following methods: 1. **build_tree()**: Construct the tree from the initial array. 2. **update(p, v)**: Update the element at index `p` to the value `v`. 3. **query(l, r)**: Query the range `[l, r]` and return the result using the commutative function. 4. **range_update(l, r, v)**: Update all elements in the range `[l, r]` to the value `v`. # Function Specifications **Class Definition**: ```python class SegmentTree: def __init__(self, arr, function): self.tree = [None for _ in range(len(arr))] + arr self.size = len(arr) self.fn = function self.build_tree() def build_tree(self): # Build the segment tree def update(self, p, v): # Point update def query(self, l, r): # Range query def range_update(self, l, r, v): # Range update ``` # Input * `__init__(self, arr, function)`: Initializes the segment tree with the given array `arr` and a commutative function `function`. * `update(self, p, v)`: Updates the element at position `p` in the array to value `v`. * `query(self, l, r)`: Returns the result of the commutative function applied to the range `[l, r]` in the array. * `range_update(self, l, r, v)`: Updates all elements in the range `[l, r]` in the array to value `v`. # Output * `query(self, l, r)`: Returns the result of the commutative function applied to the range `[l, r]` in the array. # Constraints and Considerations * Assume 1 ≤ `n` ≤ 10^5, where `n` is the size of the array. * The commutative function will be valid and applicable for the range queries and updates. * Value updates (both point and range) should propagate correctly through the tree to ensure all queries reflect the updated values. # Example ```python # Example usage: arr = [2, 4, 5, 3, 4] seg_tree = SegmentTree(arr, max) # Range Query print(seg_tree.query(1, 3)) # Output: 5 # Point Update seg_tree.update(2, 6) print(seg_tree.query(1, 3)) # Output: 6 # Range Update seg_tree.range_update(0, 2, 7) print(seg_tree.query(0, 4)) # Output: 7 ``` Ensure your implementation handles all cases efficiently and correctly propagates updates.","solution":"class SegmentTree: def __init__(self, arr, function): self.n = len(arr) self.tree = [0] * (2 * self.n) self.lazy = [0] * self.n self.fn = function self.build_tree(arr) def build_tree(self, arr): for i in range(self.n): self.tree[i + self.n] = arr[i] for i in range(self.n - 1, 0, -1): self.tree[i] = self.fn(self.tree[i * 2], self.tree[i * 2 + 1]) def update(self, p, v): p += self.n self.tree[p] = v while p > 1: p //= 2 self.tree[p] = self.fn(self.tree[2 * p], self.tree[2 * p + 1]) def query(self, l, r): l += self.n r += self.n res = None while l <= r: if l % 2 == 1: res = self.tree[l] if res is None else self.fn(res, self.tree[l]) l += 1 if r % 2 == 0: res = self.tree[r] if res is None else self.fn(res, self.tree[r]) r -= 1 l //= 2 r //= 2 return res def range_update(self, l, r, v): for i in range(l, r + 1): self.update(i, v)"},{"question":"Context In computer systems, data can be represented in different byte orders (endianness). Big-endian ordering prioritizes the most significant byte, while little-endian ordering prioritizes the least significant byte. This makes it imperative to correctly convert between integers and byte arrays, particularly when working with systems using different endiannesses. Problem Statement You are to implement four functions for converting integers to bytes and vice versa for both big-endian and little-endian orderings. **Function Signatures**: ```python def int_to_bytes_big_endian(num: int) -> bytes: pass def int_to_bytes_little_endian(num: int) -> bytes: pass def bytes_big_endian_to_int(bytestr: bytes) -> int: pass def bytes_little_endian_to_int(bytestr: bytes) -> int: pass ``` **Input and Output** - `int_to_bytes_big_endian(num: int) -> bytes`: Converts an integer `num` to a byte array in big-endian order. - `int_to_bytes_little_endian(num: int) -> bytes`: Converts an integer `num` to a byte array in little-endian order. - `bytes_big_endian_to_int(bytestr: bytes) -> int`: Converts a byte array `bytestr` in big-endian order to an integer. - `bytes_little_endian_to_int(bytestr: bytes) -> int`: Converts a byte array `bytestr` in little-endian order to an integer. **Constraints** - `num` will be a non-negative integer. - `bytestr` will contain valid bytes. **Performance Requirements** - The solution should efficiently handle conversions for large integers (in the range of 10^18). **Example** Consider the integer `500` for byte conversions. - For `int_to_bytes_big_endian(500)`, the output `bytes` should be `b\'x01xf4\'`. - For `int_to_bytes_little_endian(500)`, the output `bytes` should be `b\'xf4x01\'`. - For `bytes_big_endian_to_int(b\'x01xf4\')`, the output should be `500`. - For `bytes_little_endian_to_int(b\'xf4x01\')`, the output should be `500`. Ensure to handle edge cases like zero and large integers appropriately.","solution":"def int_to_bytes_big_endian(num: int) -> bytes: Converts an integer to a byte array in big-endian order. return num.to_bytes((num.bit_length() + 7) // 8, \'big\') def int_to_bytes_little_endian(num: int) -> bytes: Converts an integer to a byte array in little-endian order. return num.to_bytes((num.bit_length() + 7) // 8, \'little\') def bytes_big_endian_to_int(bytestr: bytes) -> int: Converts a byte array in big-endian order to an integer. return int.from_bytes(bytestr, \'big\') def bytes_little_endian_to_int(bytestr: bytes) -> int: Converts a byte array in little-endian order to an integer. return int.from_bytes(bytestr, \'little\')"},{"question":"Cycle Detection in a Linked List Context: You have been hired by a tech company to assess and correct their current system which has issues with detecting loops in their sequence data. Your task is to write a function that detects whether there is a cycle in a singly linked list, using an efficient algorithm. Task: Write a function `detectCycle` that uses Floyd\'s Tortoise and Hare algorithm to determine if there is a cycle in a linked list. Function Signature: ```python def detectCycle(head: Node) -> bool: ``` Input: - `head`: The starting node of a singly linked list. `head` is of type `Node`, where `Node` is defined as: ```python class Node: def __init__(self, x): self.val = x self.next = None ``` Output: - Return `True` if there is a cycle in the linked list, otherwise return `False`. Constraints: - The linked list may contain up to 10^5 nodes. - You must solve it using O(1) (constant) space complexity and O(n) time complexity. Example: **Example 1:** Input: `head = [3, 2, 0, -4]` with a cycle that connects the last node back to the second node. Output: `True` **Example 2:** Input: `head = [1, 2]` with a cycle that connects the second node back to the first node. Output: `True` **Example 3:** Input: `head = [1]` with no cycle. Output: `False` Explanation: - Example 1: The linked list nodes are connected as follows: 3 -> 2 -> 0 -> -4 -> 2 (cycle detected). - Example 2: The nodes are 1 -> 2 -> 1 (cycle detected). - Example 3: The node is 1 (no cycle). In your implementation, carefully manage pointers and ensure to handle edge cases like an empty list or a short list with one node appropriately. **Note**: You do not need to create the linked list nodes yourself. Focus on writing the `detectCycle` function.","solution":"class Node: def __init__(self, x): self.val = x self.next = None def detectCycle(head: Node) -> bool: Detect if a linked list has a cycle. Uses Floyd\'s Tortoise and Hare algorithm to detect the cycle. :param head: The starting node of the linked list :return: True if there is a cycle, otherwise False if head is None: return False slow = head fast = head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: return True return False"},{"question":"Scenario You are designing a staircase in a mobile game where the player must climb a stairwell. The player can move up either 1 or 2 steps at a time. Your task is to determine the number of unique ways the player can reach the top of the staircase with `steps` number of steps. Task Description Implement a function to compute the number of distinct ways to reach the top of a staircase if the player can only move 1 or 2 steps at a time. Your implementation should be optimized for both time and memory usage. Function Signature ```python def count_ways_to_climb(steps: int) -> int: Determines the number of distinct ways to climb a staircase with given number of steps. :param steps: Integer representing the total number of steps. :return: Integer representing the distinct ways to climb to the top. pass ``` Input - `steps`: a positive integer (`1 <= steps <= 10^6`) Output - Return an integer representing the number of distinct ways to reach the top. Example ```python # Example 1 assert count_ways_to_climb(2) == 2 # Two ways: (1,1) or (2) # Example 2 assert count_ways_to_climb(3) == 3 # Three ways: (1,1,1), (1,2), or (2,1) ``` Constraints - The solution should be optimized for O(n) time complexity and preferably O(1) space complexity. Important Notes - Consider handling very large values of `steps` efficiently. - Ensure the function is robust and can handle edge cases accurately.","solution":"def count_ways_to_climb(steps: int) -> int: Determines the number of distinct ways to climb a staircase with given number of steps. :param steps: Integer representing the total number of steps. :return: Integer representing the distinct ways to climb to the top. if steps == 0: return 0 elif steps == 1: return 1 elif steps == 2: return 2 # Using O(1) space prev1, prev2 = 1, 2 for _ in range(3, steps + 1): current = prev1 + prev2 prev1, prev2 = prev2, current return prev2"},{"question":"**Problem Statement**: You are given a pattern string and a text string, and you need to determine if the text follows the same pattern. The conformance means a full match where there is a bijection (one-to-one correspondence) between characters in the pattern and non-empty words in the text. # Function Signature ```python def word_pattern(pattern: str, text: str) -> bool: ``` # Input * `pattern`: A string containing only lowercase letters. * `text`: A string containing lowercase words separated by single spaces. # Output * Returns a boolean value `True` if the text follows the pattern; otherwise, returns `False`. # Constraints 1. The pattern and text are non-empty. 2. Both pattern and text consist only of lowercase English letters and spaces in text (separating words). # Example ```python assert word_pattern(\\"abba\\", \\"dog cat cat dog\\") == True assert word_pattern(\\"abba\\", \\"dog cat cat fish\\") == False assert word_pattern(\\"aaaa\\", \\"dog cat cat dog\\") == False assert word_pattern(\\"abba\\", \\"dog dog dog dog\\") == False ``` # Notes * Consider edge cases such as differing lengths of pattern and text words, repeated mappings, and ensuring no word is mapped to multiple characters. # Performance Requirements * The solution should handle input cases efficiently with considerations for both time and space complexity.","solution":"def word_pattern(pattern: str, text: str) -> bool: words = text.split() if len(pattern) != len(words): return False char_to_word = {} word_to_char = {} for c, word in zip(pattern, words): if c in char_to_word: if char_to_word[c] != word: return False else: if word in word_to_char: return False char_to_word[c] = word word_to_char[word] = c return True"},{"question":"# Histogram Frequency Analysis You are tasked with implementing a function that calculates the frequency distribution or histogram of elements in a given list. A histogram representation is an important method for summarizing and visualizing the distribution of numerical data. Function Signature: ```python def get_histogram(input_list: list) -> dict: ``` Input: - `input_list: list`: A list of unordered elements. Elements can be integers, strings, or other hashable types. Output: - Returns a dictionary where the keys are the unique elements from `input_list` and the values are their respective counts. Constraints: 1. Do not use any additional libraries for computing the histogram. 2. Handle edge cases such as an empty list or a list with repeated elements. 3. Elements in the `input_list` can be of any hashable type. Example: ```python input_list_1 = [3, 3, 2, 1] assert get_histogram(input_list_1) == {1: 1, 2: 1, 3: 2} input_list_2 = [2, 3, 5, 5, 5, 6, 4, 3, 7] assert get_histogram(input_list_2) == {2: 1, 3: 2, 4: 1, 5: 3, 6: 1, 7: 1} input_list_3 = [\\"apple\\", \\"banana\\", \\"apple\\"] assert get_histogram(input_list_3) == {\\"apple\\": 2, \\"banana\\": 1} input_list_4 = [] assert get_histogram(input_list_4) == {} ``` Additional Task: Explain the implemented algorithm\'s time and space complexity within the code as comments before your function definition.","solution":"def get_histogram(input_list: list) -> dict: This function calculates the frequency distribution or histogram of elements in a given list. The algorithm iterates through each element in the input_list once (O(n) time complexity), where n is the number of elements in the list. For each element, it updates a dictionary to maintain the count of occurrences for each unique element. The space complexity is also O(n) in the worst case where all elements in the list are unique. Parameters: input_list (list): list of unordered elements (can be integers, strings, or other hashable types). Returns: dict: a dictionary where keys are the unique elements and values are their respective counts. histogram = {} for element in input_list: if element in histogram: histogram[element] += 1 else: histogram[element] = 1 return histogram"},{"question":"# Duplicate Elements Removal in Linked List As a software engineer at a data processing company, you are tasked with cleaning up datasets by removing duplicate elements from singly linked lists. You are provided with two approaches (with and without using additional memory) to handle duplicates, and you need to implement a solution that can handle both methods based on user input. Function Specifications Write a function `deduplicate_linked_list` that accepts the head of a singly linked list and a boolean flag `use_memory` to determine the deduplication method. ```python def deduplicate_linked_list(head: Node, use_memory: bool) -> None: pass ``` Input - `head` (Node): The head node of the singly linked list. - `use_memory` (bool): If True, use a set to track duplicates for efficient removal. If False, do not use additional memory. Output - The function returns None. Modify the linked list in place. Constraints - All nodes values are integers or strings. - The linked list can contain up to 10^4 nodes. Example ```python # Linked List: 1 -> 2 -> 3 -> 2 -> 4 -> 1 -> 5 head = Node(1) head.next = Node(2) head.next.next = Node(3) head.next.next.next = Node(2) head.next.next.next.next = Node(4) head.next.next.next.next.next = Node(1) head.next.next.next.next.next.next = Node(5) deduplicate_linked_list(head, use_memory=True) # Expected Linked List: 1 -> 2 -> 3 -> 4 -> 5 deduplicate_linked_list(head, use_memory=False) # Expected Linked List: 1 -> 2 -> 3 -> 4 -> 5 (no change as it is already deduplicated) ``` Notes - Ensure your function handles edge cases such as empty lists and lists with all duplicate values. - Consider performance implications based on the size of the list and the method chosen for deduplication.","solution":"class Node: def __init__(self, value=0, next=None): self.value = value self.next = next def deduplicate_linked_list(head: Node, use_memory: bool) -> None: if not head: return if use_memory: seen = set() current = head seen.add(current.value) while current.next: if current.next.value in seen: current.next = current.next.next else: seen.add(current.next.value) current = current.next else: current = head while current: runner = current while runner.next: if runner.next.value == current.value: runner.next = runner.next.next else: runner = runner.next current = current.next"},{"question":"Context You are working on a data transformation task where you need to preprocess data stored in nested lists (or arrays) into a flat structure. This is necessary for further analysis where flat data is required for efficient operations. Task Write a Python function `flatten(input_arr)` that takes a nested list (an array that can contain other arrays as elements) and returns a new list where all the elements are at the same level. Additionally, write an alternative function `flatten_iter(iterator)` that uses a generator to yield elements one at a time, suitable for very large nested lists where storing the entire flattened list may not be feasible. Requirements 1. **Function Definitions**: 1. `def flatten(input_arr: list) -> list:` * **Input**: A list `input_arr` that can contain nested lists. * **Output**: A single, flat list containing all elements from the nested structure. 2. `def flatten_iter(iterator: Iterable) -> Iterator:` * **Input**: An iterable `iterator` that can contain nested iterables. * **Output**: A generator yielding elements one at a time from the flattened structure. 2. **Constraints**: * Arrays can be nested to any depth. * The input can contain any type of elements, but only iterables (excluding strings) should be further flattened. 3. **Edge Cases**: Your solution should handle: * Empty nested arrays. * Arrays that include only one level of nesting and deeply nested structures. * Arrays that contain data types other than lists (but still iterable). 4. **Performance**: Aim for a solution that efficiently handles large and deeply nested arrays without causing stack overflow. Example ```python # Using flatten function input_arr = [1, [2, [3, 4], 5], 6, [[7, 8], 9], 10] print(flatten(input_arr)) # Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] # Using flatten_iter function input_iter = [1, [2, [3, 4], 5], [6, [7]], 8] print(list(flatten_iter(input_iter))) # Output: [1, 2, 3, 4, 5, 6, 7, 8] ``` Note: The provided snippets are a reference, but it\'s essential to implement the function independently without copying directly from the provided code.","solution":"from collections.abc import Iterable import collections def flatten(input_arr: list) -> list: Flattens a nested list into a single level list. Args: input_arr (list): A list which can contain nested lists. Returns: list: A flattened list with all elements at the same level. result = [] def _flatten(sub_arr): for item in sub_arr: if isinstance(item, list): _flatten(item) # Recursively flatten the nested list else: result.append(item) _flatten(input_arr) return result def flatten_iter(iterator: Iterable) -> Iterable: A generator that yields elements from a nested iterable in a flattened form. Args: iterator (Iterable): An iterable which can contain nested iterables. Yields: Each element from the nested structure, in a flattened form. for item in iterator: if isinstance(item, collections.abc.Iterable) and not isinstance(item, (str, bytes)): yield from flatten_iter(item) else: yield item"},{"question":"Pattern to String Matching **Context**: You work as a software engineer for a tech company that designs advanced natural language processing systems. One of the frequent tasks is to design efficient algorithms for pattern recognition and matching in text data. To assess your skills, you are tasked with implementing a function that checks if a given pattern matches a specific string format. **Objective**: Write a function `does_pattern_match` that verifies if a given pattern matches a string in a one-to-one correspondence. Function Signature ```python def does_pattern_match(pattern: str, text: str) -> bool: ``` Parameters - `pattern`: A string of lowercase letters representing the pattern. - `text`: A string of lowercase words separated by single spaces, representing the text to be checked. Return - A boolean value (`True` or `False`) indicating whether the text follows the same pattern defined by the pattern string. Constraints - The pattern contains only lowercase letters. - The text contains lowercase words separated by single spaces. - You may assume no leading or trailing spaces and no multiple spaces. Examples **Example 1**: ```python pattern = \\"abba\\" text = \\"dog cat cat dog\\" assert does_pattern_match(pattern, text) == True ``` **Example 2**: ```python pattern = \\"abba\\" text = \\"dog cat cat fish\\" assert does_pattern_match(pattern, text) == False ``` **Example 3**: ```python pattern = \\"aaaa\\" text = \\"dog cat cat dog\\" assert does_pattern_match(pattern, text) == False ``` **Example 4**: ```python pattern = \\"abba\\" text = \\"dog dog dog dog\\" assert does_pattern_match(pattern, text) == False ``` # Task Outline: 1. Split the text into a list of words. 2. Check if the lengths of the pattern and word list are equal. 3. If not, return False. 4. Use a dictionary to map pattern characters to words. 5. Use a set to ensure no two characters map to the same word. 6. Traverse the pattern and word list to fill the dictionary and set, checking for inconsistencies. Implement your function in an optimal manner considering edge cases and typical scenarios where such a pattern match check would be critical.","solution":"def does_pattern_match(pattern: str, text: str) -> bool: words = text.split() if len(pattern) != len(words): return False char_to_word = {} word_to_char = {} for p, word in zip(pattern, words): if p in char_to_word: if char_to_word[p] != word: return False else: char_to_word[p] = word if word in word_to_char: if word_to_char[word] != p: return False else: word_to_char[word] = p return True"},{"question":"# Minimum Spanning Tree with Kruskal’s Algorithm You are required to implement Kruskal\'s algorithm to find the Minimum Spanning Tree (MST) for a given undirected, weighted graph. The graph will be provided as a series of vertices and edges. Each edge will have a source vertex, a target vertex, and a weight. # Input The input will be in the following format: - The first line contains two integers `n` and `m`, where `n` is the number of vertices and `m` is the number of edges. - The next `m` lines each contain three integers `u`, `v`, and `weight`, representing an edge connecting vertices `u` and `v` with a given `weight`. # Output - Output a single integer - the sum of the weights of the edges in the MST. # Constraints * (1 leq n leq 10^5) - the number of vertices. * (0 leq m leq 10^6) - the number of edges. * (1 leq weight leq 10^4) - the weight of the edges. # Example Input ``` 5 6 1 2 3 1 3 8 2 4 5 3 4 2 3 5 4 4 5 6 ``` # Example Output ``` 14 ``` # Explanation For the example given, the MST consists of the edges: - (1, 2) with weight 3 - (2, 4) with weight 5 - (3, 4) with weight 2 - (3, 5) with weight 4 The sum of these weights is 14. # Implementation Implement the function `kruskal_mst(vertex_count: int, edges: List[Tuple[int, int, int]]) -> int`. The function should take the number of vertices and a list of edges (each edge represented as a tuple with source, target, and weight) as input and return the sum of the weights of the edges in the MST.","solution":"def kruskal_mst(vertex_count, edges): Returns the sum of the weights of the edges in the Minimum Spanning Tree (MST) using Kruskal\'s algorithm. vertex_count: int - the number of vertices edges: List[Tuple[int, int, int]] - a list of edges represented as tuples (u, v, weight) # Helper functions to implement union-find data structure. parent = list(range(vertex_count + 1)) rank = [0] * (vertex_count + 1) def find(v): if parent[v] != v: parent[v] = find(parent[v]) # Path compression return parent[v] def union(v1, v2): root1 = find(v1) root2 = find(v2) if root1 != root2: if rank[root1] > rank[root2]: parent[root2] = root1 elif rank[root1] < rank[root2]: parent[root1] = root2 else: parent[root2] = root1 rank[root1] += 1 # Sort edges by weight edges.sort(key=lambda x: x[2]) mst_weight = 0 mst_edges = 0 # Kruskal\'s algorithm to find MST for u, v, weight in edges: if find(u) != find(v): union(u, v) mst_weight += weight mst_edges += 1 if mst_edges == vertex_count - 1: # Early termination if we have enough edges. break return mst_weight"},{"question":"You are required to implement an encoding and decoding scheme for lists of strings. The goal is to create a single string out of a list of strings that can be easily transmitted and decoded back to the original list. # Detailed Requirements 1. **Function Name**: `encode` * **Input**: List of strings `List[str]` * **Output**: Encoded string `str` * **Description**: This function should convert the list of strings into a single string where each substring is prefixed with its length and a colon (\':\'). 2. **Function Name**: `decode` * **Input**: Encoded string `str` * **Output**: List of strings `List[str]` * **Description**: This function should take the encoded string produced by the `encode` function and return the original list of strings. # Input Constraints * Each string in the list and the encoded string will only contain printable ASCII characters. * You can assume that the length of each encoded and decoded item will fit within standard string length limits of the programming language used. # Examples ```python Example 1: encode([\\"hello\\", \\"world\\"]) -> \\"5:hello5:world\\" decode(\\"5:hello5:world\\") -> [\\"hello\\", \\"world\\"] Example 2: encode([\\"one\\", \\"two\\", \\"three\\"]) -> \\"3:one3:two5:three\\" decode(\\"3:one3:two5:three\\") -> [\\"one\\", \\"two\\", \\"three\\"] Example 3: encode([\\"\\"]) -> \\"0:\\" decode(\\"0:\\") -> [\\"\\"] ``` # Implementation Notes * Make sure to handle edge cases, such as empty list or single-character strings. * Ensure that your implementation can handle strings that themselves contain the delimiter `:` correctly. * Optimize for readability and efficiency.","solution":"def encode(strings): Encodes a list of strings into a single string. :param strings: List of strings to encode :return: Encoded string return \'\'.join(f\\"{len(s)}:{s}\\" for s in strings) def decode(encoded_str): Decodes a single string back into a list of strings. :param encoded_str: Encoded string :return: List of original strings result = [] i = 0 while i < len(encoded_str): # Find the length of the next string j = i while encoded_str[j] != \':\': j += 1 length = int(encoded_str[i:j]) i = j + 1 # Move past the \':\' # Append the actual string of that length result.append(encoded_str[i:i+length]) i += length return result"},{"question":"# Scenario You are tasked with improving a basic Hash Table implementation. Your goal is to implement a new feature within the existing `HashTable` class: a method that finds and returns all keys that hash to the same bucket. # Problem Statement Implement the method `keys_with_same_bucket` within the `HashTable` class. This method should compute the hash value of a given key, and then return a list of all keys in the hash table that map to the same hash value (bucket). # Function Signature ```python def keys_with_same_bucket(self, key: int) -> List[int]: pass ``` # Input and Output * **Input**: - An integer `key`. * **Output**: - A list of integers containing keys that hash to the same bucket as the provided `key`. # Constraints * The method should handle the existing size of the hash table. * Keys returned should be unique and valid (ignoring `_empty` and `_deleted` keys). # Example Behavior Given a hash table with the following key-value pairs: ```python hash_table = HashTable(size=11) hash_table.put(12, \\"A\\") hash_table.put(23, \\"B\\") hash_table.put(34, \\"C\\") ``` Calling `hash_table.keys_with_same_bucket(12)` should return `[12, 23]` if both keys hash to the same bucket in the table. # Implementation Guidelines 1. Hash the given key to find the bucket. 2. Traverse the `_keys` array and check the hash of each key. 3. Collect and return keys that have the same hash as the initial key. Implement the new method in the provided `HashTable` class and ensure your solution adheres to the specified complexity constraints. ```python class HashTable(object): _empty = object() _deleted = object() def __init__(self, size=11): # Initialization as given in the snippet def put(self, key, value): # Implementation as given in the snippet def get(self, key): # Implementation as given in the snippet def del_(self, key): # Implementation as given in the snippet def hash(self, key): # Implementation as given in the snippet def _rehash(self, old_hash): # Implementation as given in the snippet def __getitem__(self, key): # Implementation as given in the snippet def __delitem__(self, key): # Implementation as given in the snippet def __setitem__(self, key, value): # Implementation as given in the snippet def __len__(self): # Implementation as given in the snippet def keys_with_same_bucket(self, key): # Your implementation goes here ```","solution":"class HashTable(object): _empty = object() _deleted = object() def __init__(self, size=11): self.size = size self._keys = [self._empty] * self.size self._values = [self._empty] * self.size self._count = 0 def put(self, key, value): hash_value = self.hash(key) while self._keys[hash_value] not in (self._empty, self._deleted): if self._keys[hash_value] == key: break hash_value = self._rehash(hash_value) if self._keys[hash_value] in (self._empty, self._deleted): self._count += 1 self._keys[hash_value] = key self._values[hash_value] = value def get(self, key): hash_value = self.hash(key) start_slot = hash_value while self._keys[hash_value] != self._empty: if self._keys[hash_value] == key: return self._values[hash_value] hash_value = self._rehash(hash_value) if hash_value == start_slot: break return None def del_(self, key): hash_value = self.hash(key) while self._keys[hash_value] != self._empty: if self._keys[hash_value] == key: self._keys[hash_value] = self._deleted self._values[hash_value] = self._deleted self._count -= 1 return True hash_value = self._rehash(hash_value) return False def hash(self, key): return key % self.size def _rehash(self, old_hash): return (old_hash + 1) % self.size def __getitem__(self, key): return self.get(key) def __delitem__(self, key): self.del_(key) def __setitem__(self, key, value): self.put(key, value) def __len__(self): return self._count def keys_with_same_bucket(self, key): original_hash = self.hash(key) keys_in_same_bucket = [] for k in self._keys: if k not in (self._empty, self._deleted) and self.hash(k) == original_hash: keys_in_same_bucket.append(k) return keys_in_same_bucket"},{"question":"**Scenario**: You are developing a software solution that validates encoded messages against their original messages by ensuring the encoding maintains a consistent character mapping. One key part of this validation is to check if two given strings are isomorphic. # Problem Statement Implement the function `is_isomorphic(s: str, t: str) -> bool` to determine if two strings `s` and `t` are isomorphic. Two strings are isomorphic if the characters in `s` can be replaced to get `t`. All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character, but a character may map to itself. # Input * `s` (string): A string of length `n` (1 <= n <= 10^4). * `t` (string): A string of length `n`. # Output * Return `True` if the two strings are isomorphic; otherwise, return `False`. # Constraints 1. Length of `s` and `t` are equal. 2. Both strings consist of any possible characters including digits, letters, and special characters. 3. Minimum length of strings: 1 # Examples 1. Input: `s = \\"egg\\"`, `t = \\"add\\"` Output: `True` 2. Input: `s = \\"foo\\"`, `t = \\"bar\\"` Output: `False` 3. Input: `s = \\"paper\\"`, `t = \\"title\\"` Output: `True` # Additional Requirements 1. The time complexity should be O(n), where n is the length of the string. 2. The space complexity should be O(n). *Note*: The function implementation should handle edge cases such as different lengths, empty strings, and repeated characters correctly.","solution":"def is_isomorphic(s: str, t: str) -> bool: if len(s) != len(t): return False # Mappings of characters from s to t and t to s s_to_t = {} t_to_s = {} for char_s, char_t in zip(s, t): if char_s in s_to_t: if s_to_t[char_s] != char_t: return False if char_t in t_to_s: if t_to_s[char_t] != char_s: return False s_to_t[char_s] = char_t t_to_s[char_t] = char_s return True"},{"question":"Question # Scenario A company manages a dynamically changing collection of sorted numerical data that needs constant querying for the next higher element. The data is stored in a Binary Search Tree (BST) for efficiency. An important feature in their application is to find the in-order successor of any element in the BST. # Task Write a function `find_successor` to find the in-order successor of a given node in a BST. # Function Signature ```python def find_successor(root: TreeNode, node: TreeNode) -> Optional[TreeNode]: # Your implementation here ``` # Input - `root`: The root of the BST (TreeNode) — can be None. - `node`: A reference to a node (TreeNode) within the BST. # Output - Return the in-order successor of the given node. - If there is no successor, return None. # Constraints - The tree nodes will have integer values. - You can assume all values in the tree are unique. - If the given node is not part of the tree, provide a meaningful error message. # Example ```python # Define TreeNode with a structure (simple class with val, left, right attributes). class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None # Example Usage root = TreeNode(20) root.left = TreeNode(10) root.right = TreeNode(30) node = root.left # node with value 10 print(find_successor(root, node)) # Should return the node with value 20 ``` # Performance Requirements - Ensure that your solution runs efficiently even for larger BSTs (height >= 20). # Notes - Be careful with edge cases like the smallest or largest node in the BST. - You may assume that the `node` given is guaranteed to be present in the BST.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def find_successor(root: TreeNode, node: TreeNode) -> TreeNode: Finds the in-order successor of the given node in the BST. Parameters: root (TreeNode): The root of the BST node (TreeNode): The node whose in-order successor needs to be found Returns: TreeNode: The in-order successor if it exists, otherwise None if node.right: return find_min(node.right) succ = None current = root while current: if node.val < current.val: succ = current current = current.left elif node.val > current.val: current = current.right else: break return succ def find_min(node: TreeNode) -> TreeNode: Finds the minimum node in a given subtree. Parameters: node (TreeNode): The root of the subtree Returns: TreeNode: The node with the minimum value in the subtree current = node while current.left: current = current.left return current"},{"question":"Context: You are given a nested dictionary representing a hierarchical collection of books, devices, and sports activities assigned to different people. Each key in the dictionary represents a category (like a person), and the associated value is a list of items and their respective quantities. Your task is to extend the given function to traverse and print the elements in a more generalized format that can handle arbitrary nesting depths. Function Signature: ```python def generalized_tree_print(tree: dict): pass ``` Expected Input and Output Formats: - **Input**: A nested dictionary with keys as strings and values as lists or other dictionaries. - **Output**: Print the elements of the nested dictionary in a hierarchical format showing the structure clearly with arrows \'->\' between elements and indents for nested levels. Constraints: - Keys are unique strings. - Values are either lists (containing strings/numbers) or nested dictionaries of similar structure. - Depth of nesting may vary. Performance Requirements: - The function should handle dictionaries with up to 1,000 elements reasonably. Example Input: ```python tree = { \'a\': {\'Adam\': [\'Book\', 4]}, \'b\': { \'Bill\': [\'Computer\', 5, \'TV\', 6], \'Jill\': [\'Sports\', 1] }, \'c\': {\'Bill\': [\'Sports\', 3]}, \'d\': { \'Adam\': [\'Computer\', 3], \'Quin\': [\'Computer\', 3] }, \'e\': { \'Quin\': [\'Book\', 5, \'TV\', 2] }, \'f\': {\'Adam\': [\'Computer\', 7]} } ``` Example Output: ``` a -> Adam -> Book -> 4 b -> Bill -> Computer -> 5 -> TV -> 6 -> Jill -> Sports -> 1 c -> Bill -> Sports -> 3 d -> Adam -> Computer -> 3 -> Quin -> Computer -> 3 e -> Quin -> Book -> 5 -> TV -> 2 f -> Adam -> Computer -> 7 ``` Additional Information: - Ensure your function handles nested dictionaries of arbitrary depths by indenting nested structures appropriately. - Avoid assumptions about the fixed structure or depth of the input dictionaries. - You may use helper functions if needed to keep your code organized. **Note**: Do not use any built-in functions specific to Python\'s pretty-printing. The goal is to practice manual traversal and formatting.","solution":"def generalized_tree_print(tree, indent=0): Recursively traverses and prints a nested dictionary. Parameters: - tree: dict, nested dictionary to print - indent: int, current indentation level for key, value in tree.items(): print(\' \' * indent + str(key)) if isinstance(value, dict): generalized_tree_print(value, indent + 2) else: for item in value: print(\' \' * (indent + 2) + str(item))"},{"question":"**Context:** You are working on a data validation tool that receives input from various nested data sources. Your task is to flatten these inputs into a single list structure for simplified processing. **Task:** Write a Python function to flatten a nested list of varying depths into a one-dimensional list. **Function Signature:** ```python def flatten_nested_list(nested_list: list) -> list: ``` **Input:** - `nested_list`: A list that may contain integers, strings, and other lists of similar types, nested at any level. **Output:** - Returns a single flat list containing all the elements from the nested structure. **Constraints:** - Elements in the input nested list will be either integers, strings, or lists containing such elements. - The depth of nesting will not exceed 1000 levels. **Performance Requirement:** - The function should handle lists with up to 10^6 total elements efficiently. **Example:** ```python assert flatten_nested_list([1, [2, [3, [4]], 5], 6]) == [1, 2, 3, 4, 5, 6] assert flatten_nested_list([\'a\', [\'b\', [\'c\', \'d\']], \'e\']) == [\'a\', \'b\', \'c\', \'d\', \'e\'] assert flatten_nested_list([[], [1, [2]], []]) == [1, 2] assert flatten_nested_list([]) == [] ``` **Notes:** - Your solution should avoid processing individual characters of strings as nested elements. - Consider optimal means to prevent stack overflow with large depths of nested lists. **Scoring Criteria:** - **Correctness**: The function should return accurate results as specified. - **Efficiency**: The function should meet the performance requirements on large inputs. - **Edge Case Handling**: The function should correctly handle and return appropriate results for edge cases.","solution":"def flatten_nested_list(nested_list): Flattens a nested list of varying depths into a one-dimensional list. :param nested_list: list of integers, strings, and other lists of similar types. :return: a single flat list containing all the elements from the nested structure. flat_list = [] def _flatten(item): if isinstance(item, list): for sub_item in item: _flatten(sub_item) else: flat_list.append(item) _flatten(nested_list) return flat_list"},{"question":"# Sorting Visualization with Optimization Bubble Sort is a simple and well-known sorting algorithm. Your task is to implement an optimized version of Bubble Sort that minimizes the number of comparisons and exit early if the array is already sorted. Additionally, you need to enhance the visualization functionality to display the state of the array after every pass through the array. Requirements: 1. Implement the optimized Bubble Sort algorithm. 2. Include a parameter `simulate` to visualize the sorting process by printing the array state after each pass. 3. Implement the function to take both sorted and unsorted arrays and return the sorted array. 4. Ensure edge cases are considered, such as empty arrays and already sorted arrays. Function Signature: ```python def optimized_bubble_sort(arr: List[int], simulate: bool = False) -> List[int]: ``` Input Format: - `arr`: A list of integers to be sorted. - `simulate`: A boolean flag to print the array state after each pass (default is False). Output Format: - A list of integers sorted in ascending order. Constraints: - The input array can have up to (10^5) elements. Example: Input: ```python arr = [5, 3, 8, 4, 2], simulate = True ``` Output: ```python iteration 1: [3, 5, 4, 2, 8] iteration 2: [3, 4, 2, 5, 8] iteration 3: [3, 2, 4, 5, 8] iteration 4: [2, 3, 4, 5, 8] [2, 3, 4, 5, 8] ```","solution":"from typing import List def optimized_bubble_sort(arr: List[int], simulate: bool = False) -> List[int]: Perform an optimized Bubble Sort on the list `arr`. If `simulate` is True, print the array state after each pass. :param arr: List[int] - list of integers to be sorted :param simulate: bool - flag to indicate if the simulation of sorting should be printed :return: List[int] - sorted list of integers n = len(arr) for i in range(n): swapped = False for j in range(0, n - i - 1): if arr[j] > arr[j + 1]: arr[j], arr[j + 1] = arr[j + 1], arr[j] swapped = True if simulate: print(f\\"iteration {i + 1}: {arr}\\") if not swapped: break return arr"},{"question":"# Context: In a machine learning context, suppose you want to implement a simple classification algorithm using the nearest neighbor approach. You will be given a set of points each with a corresponding classification, and for a new data point, you need to determine its classification based on the closest point in the given set. # Task: Implement a function `classify_point(x, training_set)` that uses the nearest neighbor algorithm to classify the given point `x`. # Input: 1. `x` : a tuple representing the coordinates of a point (1 <= len(x) <= 100). 2. `training_set` : a dictionary where the keys are tuples representing the coordinates of points and values are integers representing their classifications. # Output: - Return the integer classification of the point `x` based on the nearest neighbor in `training_set`. # Constraints: - The training set dictionary will have at least 1 and at most 1000 elements. - Length of all tuples in both `x` and `training_set` will be the same and will not exceed 100. # Examples: ```python def classify_point(x, training_set): # Your implementation here # Example 1: x = (2.0, 3.0) training_set = {(1.0, 2.0): 1, (4.0, 4.0): 2} print(classify_point(x, training_set)) # Output: 1 # Example 2: x = (0.0, 0.0) training_set = {(5.0, 5.0): 1, (-2.0, -3.0): 2, (2.0, 1.0): 2} print(classify_point(x, training_set)) # Output: 2 ``` Write the function `classify_point(x, training_set)` which implements the nearest neighbor algorithm to determine the classification of a given point.","solution":"import math def classify_point(x, training_set): Classifies point x based on the nearest neighbor in the training_set. Args: x (tuple): A tuple representing the coordinates of a point. training_set (dict): A dictionary where keys are tuples representing coordinates of points and values are integers representing their classifications. Returns: int: The classification of the point x based on the nearest neighbor. def euclidean_distance(p1, p2): return math.sqrt(sum((a - b) ** 2 for a, b in zip(p1, p2))) nearest_neighbor = min(training_set, key=lambda point: euclidean_distance(x, point)) return training_set[nearest_neighbor]"},{"question":"Linked List Sortedness Check You have been provided with a utility function `is_sorted` that determines if a singly linked list is sorted in non-decreasing order. The function has been analyzed and is known to handle various edge cases and scenarios efficiently for its intended use. # Problem Statement Your task is to implement a function called `find_first_unsorted` that identifies the first node in a singly linked list where the order is violated (i.e., the first node which has a greater value than its next node). If the list is sorted, the function should return `None`. # Function Signature ```python def find_first_unsorted(head): # Implementation here ``` # Input * `head`: The head node of a singly linked list. Each node contains: * `val`: Integer value of the node. * `next`: Pointer to the next node. # Output * The function should return the first node where the value is greater than the next node\'s value. If the list is sorted, return `None`. # Constraints * The linked list can have **any number of elements**, including zero (an empty list), but values are all integers. # Example ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next # Create linked list: 1 -> 2 -> -1 -> 3 head = ListNode(1, ListNode(2, ListNode(-1, ListNode(3)))) assert find_first_unsorted(head).val == 2 # Create linked list: 1 -> 2 -> 3 -> 4 head = ListNode(1, ListNode(2, ListNode(3, ListNode(4)))) assert find_first_unsorted(head) == None # Create linked list: None (empty list) head = None assert find_first_unsorted(head) == None ``` # Additional Notes * Consider both iterative and recursive approaches to implement the solution. * Pay attention to edge cases such as empty lists or lists with a single node.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def find_first_unsorted(head): This function returns the first node in the linked list where the value is greater than the next node\'s value. If the list is sorted, return None. if not head or not head.next: return None current = head while current and current.next: if current.val > current.next.val: return current current = current.next return None"},{"question":"# Scenario You are designing a maze-solving robot that can navigate through a complex labyrinth. The labyrinth is represented as a graph, where each room is a node, and each passage is an edge connecting two nodes. Your robot needs to find various paths to navigate from the start room to the end room. Additionally, it must find the shortest path to optimize its movement. # Task Implement the graph traversal functions based on the following specifications: # Functions 1. **find_path(graph, start, end)**: * Find any valid path between start and end nodes. * **Input**: * `graph` (dict): Adjacency list representing the graph. * `start` (str): Starting node. * `end` (str): Ending node. * **Output**: List of nodes representing the path or None if no path exists. 2. **find_all_path(graph, start, end)**: * Find all valid paths between start and end nodes. * **Input**: * `graph` (dict): Adjacency list representing the graph. * `start` (str): Starting node. * `end` (str): Ending node. * **Output**: List of lists, where each list represents a valid path. 3. **find_shortest_path(graph, start, end)**: * Find the shortest path based on the number of edges between start and end nodes. * **Input**: * `graph` (dict): Adjacency list representing the graph. * `start` (str): Starting node. * `end` (str): Ending node. * **Output**: List of nodes representing the shortest path or None if no path exists. # Constraints * The graph will have fewer than 1000 nodes. * Every node name is unique and consists of only alphabetical characters. * Each graph is connected and acyclic. * No node will have more than 10 neighbors. # Example ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'A\', \'D\', \'E\'], \'C\': [\'A\', \'F\'], \'D\': [\'B\'], \'E\': [\'B\', \'F\'], \'F\': [\'C\', \'E\'] } # Example function calls print(find_path(graph, \'A\', \'F\')) # Output: [\'A\', \'C\', \'F\'] print(find_all_path(graph, \'A\', \'F\')) # Output: [[\'A\', \'C\', \'F\'], [\'A\', \'B\', \'E\', \'F\']] print(find_shortest_path(graph, \'A\', \'F\')) # Output: [\'A\', \'C\', \'F\'] ``` # Note Be mindful of performance considerations and edge cases. Ensure your solution handles graphs effectively as per the given constraints.","solution":"def find_path(graph, start, end): Finds any valid path between start and end nodes. def dfs(current, target, visited): if current == target: return [current] visited.add(current) for neighbor in graph.get(current, []): if neighbor not in visited: path = dfs(neighbor, target, visited) if path: return [current] + path visited.remove(current) return None return dfs(start, end, set()) def find_all_path(graph, start, end): Finds all valid paths between start and end nodes. def dfs(current, target, visited, path, all_paths): path.append(current) visited.add(current) if current == target: all_paths.append(path.copy()) else: for neighbor in graph.get(current, []): if neighbor not in visited: dfs(neighbor, target, visited, path, all_paths) path.pop() visited.remove(current) all_paths = [] dfs(start, end, set(), [], all_paths) return all_paths def find_shortest_path(graph, start, end): Finds the shortest path based on the number of edges between start and end nodes. from collections import deque queue = deque([(start, [start])]) visited = set() while queue: current, path = queue.popleft() if current == end: return path visited.add(current) for neighbor in graph.get(current, []): if neighbor not in visited: queue.append((neighbor, path + [neighbor])) visited.add(neighbor) return None"},{"question":"# Missing Ranges Finder **Objective**: Write a function to find all missing ranges in a given sorted array of unique integers from a given range [lo, hi]. **Function Signature**: ```python def find_missing_ranges(arr: List[int], lo: int, hi: int) -> List[Tuple[int, int]]: ``` **Input**: - `arr`: A sorted list of unique integers. - `lo`: An integer representing the lower bound of the range. - `hi`: An integer representing the upper bound of the range. **Output**: - A list of tuples, where each tuple represents a missing range from the array within the specified bounds. Each tuple is of the form `(start, end)`. **Constraints**: - The array `arr` will have a length between 0 and 10^6. - The integers `lo` and `hi` will be such that -10^9 <= lo <= hi <= 10^9. - Array `arr` contains unique values. - The given array may be empty, and `lo` can be equal to or less than `hi`. **Examples**: ```python find_missing_ranges([3, 5], 1, 10) -> [(1, 2), (4, 4), (6, 10)] find_missing_ranges([], 5, 10) -> [(5, 10)] find_missing_ranges([1, 2, 3, 4], 1, 4) -> [] ``` **Scenario**: In a networking context, you may need to find unused IP address ranges within a given subnet. Given the subnet range and a list of used IPs, your function should return the ranges of IPs that are not currently in use. **Edge Cases to Handle**: - The array is empty, resulting in the whole range `[lo, hi]` being reported as missing. - The array includes only boundary values. - All elements are present within the range. Write a well-structured function that thoroughly verifies its results through assertions or test cases.","solution":"from typing import List, Tuple def find_missing_ranges(arr: List[int], lo: int, hi: int) -> List[Tuple[int, int]]: res = [] arr = [lo - 1] + arr + [hi + 1] for i in range(len(arr) - 1): if arr[i] + 1 <= arr[i + 1] - 1: res.append((arr[i] + 1, arr[i + 1] - 1)) return res"},{"question":"# Scenario Zillow wants to efficiently manage its vast dataset of real estate properties in an organized way so that search, insert, and delete operations can be performed quickly. Each property entry is represented by a unique integer ID. Given the size and the nature of the database, a balanced tree data structure like a B-Tree is preferred. # Problem You are required to implement a B-Tree as described. Your implementation should support the following operations: 1. **Insert**: Add a new property ID to the B-Tree. 2. **Search**: Determine if a property ID exists in the B-Tree. 3. **Delete**: Remove a property ID from the B-Tree. 4. **Traverse**: Print all property IDs in sorted order. # Input and Output - The B-Tree should work with integer property IDs only. - Implement the following methods in your B-Tree class: - `insert_key(key: int)`: Inserts a new property ID. - `find(key: int) -> bool`: Returns `True` if the property ID exists, `False` otherwise. - `remove_key(key: int)`: Removes the property ID, if exists. - `traverse_tree()`: Prints IDs in sorted order. # Constraints - Assume you are working with integers ranging between -2^31 and 2^31 - 1. - Ensure that your B-Tree remains balanced after every insert and delete operation. - The minimum degree `t` of the B-Tree should be configurable upon initialization. # Example ```python if __name__ == \'__main__\': b_tree = BTree(t_val=3) b_tree.insert_key(10) b_tree.insert_key(20) b_tree.insert_key(5) b_tree.insert_key(6) b_tree.insert_key(12) b_tree.insert_key(30) b_tree.insert_key(7) b_tree.insert_key(17) print(b_tree.find(6)) # True print(b_tree.find(15)) # False b_tree.traverse_tree() # 5 6 7 10 12 17 20 30 b_tree.remove_key(6) b_tree.traverse_tree() # 5 7 10 12 17 20 30 ``` # Your Task Implement the B-Tree class with the specified methods.","solution":"class BTreeNode: def __init__(self, t, leaf=False): self.t = t self.leaf = leaf self.keys = [] self.children = [] def traverse(self): for i in range(len(self.keys)): if not self.leaf: self.children[i].traverse() print(self.keys[i], end=\' \') if not self.leaf: self.children[len(self.keys)].traverse() def search(self, k): i = 0 while i < len(self.keys) and k > self.keys[i]: i += 1 if i < len(self.keys) and self.keys[i] == k: return True if self.leaf: return False return self.children[i].search(k) def insert_non_full(self, k): i = len(self.keys) - 1 if self.leaf: self.keys.append(0) while i >= 0 and self.keys[i] > k: self.keys[i + 1] = self.keys[i] i -= 1 self.keys[i + 1] = k else: while i >= 0 and self.keys[i] > k: i -= 1 if len(self.children[i + 1].keys) == 2 * self.t - 1: self.split_child(i + 1, self.children[i + 1]) if self.keys[i + 1] < k: i += 1 self.children[i + 1].insert_non_full(k) def split_child(self, i, y): z = BTreeNode(self.t, y.leaf) self.children.insert(i + 1, z) self.keys.insert(i, y.keys[self.t - 1]) z.keys = y.keys[self.t: (2 * self.t - 1)] y.keys = y.keys[0: self.t - 1] if not y.leaf: z.children = y.children[self.t: (2 * self.t)] y.children = y.children[0: self.t] def remove(self, k): idx = self._find_key(k) if idx < len(self.keys) and self.keys[idx] == k: if self.leaf: self.keys.pop(idx) else: self._remove_internal_node(k, idx) else: if self.leaf: return flag = (idx == len(self.keys)) if len(self.children[idx].keys) < self.t: self._fill(idx) if flag and idx > len(self.keys): self.children[idx - 1].remove(k) else: self.children[idx].remove(k) def _remove_internal_node(self, k, idx): if len(self.children[idx].keys) >= self.t: pred = self._get_pred(idx) self.keys[idx] = pred self.children[idx].remove(pred) elif len(self.children[idx + 1].keys) >= self.t: succ = self._get_succ(idx) self.keys[idx] = succ self.children[idx + 1].remove(succ) else: self._merge(idx) self.children[idx].remove(k) def _get_pred(self, idx): cur = self.children[idx] while not cur.leaf: cur = cur.children[len(cur.keys)] return cur.keys[len(cur.keys) - 1] def _get_succ(self, idx): cur = self.children[idx + 1] while not cur.leaf: cur = cur.children[0] return cur.keys[0] def _fill(self, idx): if idx != 0 and len(self.children[idx - 1].keys) >= self.t: self._borrow_from_prev(idx) elif idx != len(self.keys) and len(self.children[idx + 1].keys) >= self.t: self._borrow_from_next(idx) else: if idx != len(self.keys): self._merge(idx) else: self._merge(idx - 1) def _borrow_from_prev(self, idx): child = self.children[idx] sibling = self.children[idx - 1] child.keys.insert(0, self.keys[idx - 1]) if not child.leaf: child.children.insert(0, sibling.children.pop()) self.keys[idx - 1] = sibling.keys.pop() def _borrow_from_next(self, idx): child = self.children[idx] sibling = self.children[idx + 1] child.keys.append(self.keys[idx]) if not child.leaf: child.children.append(sibling.children.pop(0)) self.keys[idx] = sibling.keys.pop(0) def _merge(self, idx): child = self.children[idx] sibling = self.children[idx + 1] child.keys.append(self.keys.pop(idx)) child.keys.extend(sibling.keys) if not child.leaf: child.children.extend(sibling.children) self.children.pop(idx + 1) def _find_key(self, k): idx = 0 while idx < len(self.keys) and self.keys[idx] < k: idx += 1 return idx class BTree: def __init__(self, t): self.t = t self.root = BTreeNode(t, True) def traverse_tree(self): if self.root: self.root.traverse() print() def find(self, k): return self.root.search(k) if self.root else False def insert_key(self, k): r = self.root if len(r.keys) == 2 * self.t - 1: s = BTreeNode(self.t, False) self.root = s s.children.insert(0, r) s.split_child(0, r) s.insert_non_full(k) else: r.insert_non_full(k) def remove_key(self, k): if not self.root: return self.root.remove(k) if len(self.root.keys) == 0: if not self.root.leaf: self.root = self.root.children[0] else: self.root = None"},{"question":"# Stutter Stack Transformation **Context**: You are given a stack, represented as a list in Python, where the bottom of the stack corresponds to the start of the list and the top of the stack is the end of the list. The goal is to replace every value in the stack with two occurrences of that value. For instance, if the stack is: `[3, 7, 1, 14, 9]`, the transformed stack should be: `[3, 3, 7, 7, 1, 1, 14, 14, 9, 9]`. Two auxiliary data structures, stack and queue, are provided: your task is to implement two methods to achieve the desired transformation. **Instructions**: 1. Implement two methods, `first_stutter` and `second_stutter`. 2. Both methods should take a list `stack` as an input parameter. 3. Output a list representing the stack after the transformation. 4. `first_stutter` should use an auxiliary stack for the transformation. 5. `second_stutter` should use an auxiliary queue for the transformation. 6. Ensure the methods handle edge cases such as an empty stack or a stack with one element correctly. **Constraints**: * The stack will contain integers only. * The stack\'s initial length will not exceed 1000 elements. * You should aim for a linear time complexity solution. **Function Signatures**: ```python def first_stutter(stack: list) -> list: pass def second_stutter(stack: list) -> list: pass ``` # Example ```python # Initially, stack is [3, 7, 1, 14, 9] print(first_stutter([3, 7, 1, 14, 9])) # Output: [3, 3, 7, 7, 1, 1, 14, 14, 9, 9] # Initially, stack is [3, 7, 1, 14, 9] print(second_stutter([3, 7, 1, 14, 9])) # Output: [3, 3, 7, 7, 1, 1, 14, 14, 9, 9] ```","solution":"def first_stutter(stack: list) -> list: Duplicate each element in the stack using an auxiliary stack. aux_stack = [] # Transfer elements to auxiliary stack with duplication while stack: element = stack.pop() aux_stack.append(element) aux_stack.append(element) # Transfer back to the original stack to maintain original order while aux_stack: stack.append(aux_stack.pop()) return stack def second_stutter(stack: list) -> list: Duplicate each element in the stack using an auxiliary queue. from collections import deque queue = deque() # Transfer elements to queue with duplication while stack: element = stack.pop() queue.appendleft(element) queue.appendleft(element) # Transfer back to the original stack to maintain original order while queue: stack.append(queue.popleft()) return stack"},{"question":"You are tasked with creating a text editor feature that can help compress and decompress text data using Run-Length Encoding (RLE). To do this, you need to define two functions: `encode_rle` and `decode_rle`. # Function Descriptions 1. **`encode_rle(input: str) -> str`**: - **Task**: Compress a given input string using Run-Length Encoding. - **Input**: A string `input` containing characters to be encoded. - **Output**: A string representing the run-length encoded version of the input. 2. **`decode_rle(input: str) -> str`**: - **Task**: Decompress a given input string that is encoded in the Run-Length Encoding format. - **Input**: A string `input` containing the run-length encoded data. - **Output**: A string representing the original uncompressed data. # Constraints - The input strings will only contain printable ASCII characters. - The length of the input will be at most 10^4 characters. # Examples Example 1: ```python encode_rle(\\"aaabbcccc\\") ``` **Output**: `\\"3a2b4c\\"` Example 2: ```python decode_rle(\\"3a2b4c\\") ``` **Output**: `\\"aaabbcccc\\"` Example 3: ```python encode_rle(\\"aabbaaa\\") ``` **Output**: `\\"2a2b3a\\"` Example 4: ```python decode_rle(\\"2a2b3a\\") ``` **Output**: `\\"aabbaaa\\"` # Instructions * Implement the functions in a way that they handle edge cases such as empty strings, single character inputs, and inputs without consecutive repeating characters. * Ensure that your functions are optimized for performance given the constraints.","solution":"def encode_rle(input: str) -> str: if not input: return \\"\\" encoded = [] count = 1 for i in range(1, len(input)): if input[i] == input[i - 1]: count += 1 else: encoded.append(f\\"{count}{input[i - 1]}\\") count = 1 encoded.append(f\\"{count}{input[-1]}\\") # last group return \'\'.join(encoded) def decode_rle(input: str) -> str: if not input: return \\"\\" decoded = [] count = 0 for char in input: if char.isdigit(): count = count * 10 + int(char) # handle numbers with more than one digit else: decoded.append(char * count) count = 0 return \'\'.join(decoded)"},{"question":"You are tasked with implementing a function that finds the nth digit in an infinite sequence created by concatenating all natural numbers together sequentially. For example, the sequence starts with \\"123456789101112131415...\\". # Function Signature ```python def find_nth_digit(n: int) -> int: pass ``` # Input - An integer `n` (1 ≤ n ≤ 2 * 10^9): represents the position in the sequence of concatenated natural numbers. # Output - An integer representing the nth digit in the infinite concatenated sequence of natural numbers. # Constraints - You should aim to achieve a logarithmic time complexity solution. - Handle integer arithmetic carefully to avoid overflow issues. # Example ```python assert find_nth_digit(1) == 1 assert find_nth_digit(10) == 1 assert find_nth_digit(11) == 0 assert find_nth_digit(189) == 9 assert find_nth_digit(190) == 1 assert find_nth_digit(191) == 0 ``` # Detailed Explanation 1. **Identifying the Length of the Number**: * Start with numbers of length 1 (1 to 9), then length 2 (10 to 99), length 3 (100 to 999), and so on. * Calculate the cumulative count of digits from all numbers with the same length and adjust `n` accordingly. 2. **Finding the Specific Number**: * Determine the exact number within the range that contains the nth digit. 3. **Extracting the nth Digit**: * Convert the identified number to a string and extract the appropriate digit. # Edge Cases - Handling transitions between lengths, especially for digit counts that end exactly at length changes (e.g., n is exactly at the last digit of a single-digit number or the first digit of a two-digit number). # Notes * Pay special attention to integer division and modulo operations when extracting the digit from the identified number. * The function should be robust to handle very large values of `n` up to 2 billion.","solution":"def find_nth_digit(n: int) -> int: # Initial settings: starting length of numbers is 1, and start is 1. length = 1 count = 9 start = 1 # Find the length of the number which contains the nth digit. while n > length * count: n -= length * count length += 1 count *= 10 start *= 10 # Find the actual number that contains the nth digit. start += (n - 1) // length # Convert the number to a string to find the exact digit. s = str(start) return int(s[(n - 1) % length])"},{"question":"# Problem: Cycle Detection in a Linked List Given a linked list, determine if it contains a cycle. You are provided with the definition of the Node class and need to implement the function `is_cyclic(head)` that returns `True` if there is a cycle in the linked list, and `False` otherwise. Input: * `head` (Node): The head of the singly linked list. Output: * `bool`: Return `True` if the linked list has a cycle, `False` otherwise. Constraints: * You must achieve this in O(n) time complexity. * You may not use extra space (i.e., constant O(1) space complexity). Edge Cases: 1. The list is empty (head is None). 2. The list contains only one node without a cycle. Example Scenarios: 1. **Scenario 1: Empty List** ```python head = None assert is_cyclic(head) == False ``` 2. **Scenario 2: Single Node Without Cycle** ```python node = Node(1) head = node assert is_cyclic(head) == False ``` 3. **Scenario 3: Single Node With Cycle** ```python node = Node(1) node.next = node head = node assert is_cyclic(head) == True ``` 4. **Scenario 4: Multiple Nodes Without Cycle** ```python node1 = Node(1) node2 = Node(2) node3 = Node(3) node1.next = node2 node2.next = node3 head = node1 assert is_cyclic(head) == False ``` 5. **Scenario 5: Multiple Nodes With Cycle** ```python node1 = Node(1) node2 = Node(2) node3 = Node(3) node4 = Node(4) node1.next = node2 node2.next = node3 node3.next = node4 node4.next = node2 # Cycle here head = node1 assert is_cyclic(head) == True ``` Implement the `is_cyclic` function to correctly handle these scenarios.","solution":"class Node: def __init__(self, value): self.value = value self.next = None def is_cyclic(head): Determines if a linked list contains a cycle. Args: head (Node): The head of the singly linked list. Returns: bool: True if the linked list has a cycle, False otherwise. if not head: return False slow = head fast = head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: return True return False"},{"question":"Given a string, write a function `longest_palindromic_substring(s: str) -> str` that returns the longest palindromic substring in `s`. Note that we only consider alphanumeric characters and ignore cases. For this problem, an empty string should return an empty string as well as the case where there are no palindromic sequences. # Requirements * Function Name: `longest_palindromic_substring` * Input: A single string `s` with length n (0 <= n <= 10^3) * Output: The longest palindromic substring in `s` # Additional Constraints * The function should ignore non-alphanumeric characters and be case-insensitive. * The function should have a time complexity no worse than O(n^2). * The function should have space complexity no worse than O(n). # Example ```python assert longest_palindromic_substring(\\"A man, a plan, a canal: Panama\\") == \\"amanaplanacanalpanama\\" assert longest_palindromic_substring(\\"race a car\\") == \\"racecar\\" assert longest_palindromic_substring(\\"\\") == \\"\\" ``` # Hint Consider cleaning the string by keeping only alphanumeric characters and making them all lowercase. Then, use dynamic programming or expand-around-center techniques to find the longest palindromic substring.","solution":"import re def longest_palindromic_substring(s: str) -> str: def clean_string(s): return re.sub(\'[^a-zA-Z0-9]\', \'\', s).lower() def is_palindrome(s): return s == s[::-1] cleaned_s = clean_string(s) n = len(cleaned_s) if n == 0: return \\"\\" longest_palindrome = cleaned_s[0] for i in range(n): for j in range(i + 1, n + 1): substring = cleaned_s[i:j] if is_palindrome(substring) and len(substring) > len(longest_palindrome): longest_palindrome = substring return longest_palindrome"},{"question":"# Matrix Decomposition Challenge Implement the Crout matrix decomposition algorithm that factors a given square matrix ( A ) into lower triangular matrix ( L ) and upper triangular matrix ( U ). In Crout\'s method, the diagonal elements of matrix ( U ) must be 1 and the matrix ( L ) should contain non-zero elements below and on the diagonal. Function Signature ```python def crout_matrix_decomposition(A: List[List[float]]) -> Tuple[List[List[float]], List[List[float]]]: # Implementation goes here ``` Input * ( A ) - A list of lists of floats ( (2 leq n leq 1000) ), representing a square matrix of size ( n ). Output * A tuple containing two lists of lists of floats representing matrices ( L ) and ( U ). Constraints * Ensure that you handle potential division by zero by setting extremely small values. * Test the implementation with both singular and non-singular matrices. * The input matrix ( A ) is guaranteed to be square. Edge Cases * Matrix with zero and very small elements. * Large values resulting in potential floating-point precision issues. Example ```python A = [ [1, 2, 3], [3, 4, 5], [6, 7, 8] ] L, U = crout_matrix_decomposition(A) print(\\"Matrix L:\\") for row in L: print(row) print(\\"Matrix U:\\") for row in U: print(row) ``` **Expected Output:** ``` Matrix L: [1.0, 0.0, 0.0] [3.0, -2.0, 0.0] [6.0, -5.0, 0.0] Matrix U: [1.0, 2.0, 3.0] [0.0, 1.0, 2.0] [0.0, 0.0, 1.0] ``` Note Make sure to validate that ( L times U = A ) is true for the returned matrices ( L ) and ( U ). Account for numerical imprecisions.","solution":"from typing import List, Tuple import numpy as np def crout_matrix_decomposition(A: List[List[float]]) -> Tuple[List[List[float]], List[List[float]]]: n = len(A) L = [[0.0] * n for _ in range(n)] U = [[0.0] * n for _ in range(n)] for j in range(n): U[j][j] = 1.0 for i in range(j, n): sum_L = sum(L[i][k] * U[k][j] for k in range(j)) L[i][j] = A[i][j] - sum_L for i in range(j + 1, n): sum_U = sum(L[j][k] * U[k][i] for k in range(j)) if L[j][j] == 0.0: L[j][j] = 1e-10 # Handle division by zero U[j][i] = (A[j][i] - sum_U) / L[j][j] return L, U"},{"question":"# Stack Minimum Value Removal Context You are a software engineer tasked with optimizing data retrieval in a last-in-first-out (LIFO) stack structure for a legacy system. Your objective is to implement a function that removes the smallest value from a stack while keeping the order of other elements intact. This task is critical for data cleanup operations in a stack-based logging system. Problem Write a function `remove_min` that accepts a stack represented as a list and removes the smallest value from it. The function should also preserve the order of the remaining elements in the stack. Function Signature ```python def remove_min(stack: list) -> list: pass ``` Input * A stack represented as a list of integers. The top of the stack corresponds to the last element of the list. Output * The modified stack with the smallest value removed. If the stack is empty, return the same empty stack. Constraints * You may assume that all integer elements of the stack are unique. * The input stack will contain at most 1000 elements. Example ```python # Example 1 input_stack = [2, 8, 3, -6, 7, 3] output_stack = remove_min(input_stack) # Output: [2, 8, 3, 7, 3] # Example 2 input_stack = [1] output_stack = remove_min(input_stack) # Output: [] # Example 3 input_stack = [] output_stack = remove_min(input_stack) # Output: [] ``` Tips * Consider maintaining an additional stack for auxiliary storage during your operations. * Be cautious of edge cases such as empty stacks or stacks with a single element. * Ensure the order of elements, excluding the minimum, remains the same.","solution":"def remove_min(stack: list) -> list: if not stack: return stack min_value = min(stack) new_stack = [] # Transfer elements to a new stack without the minimum value found_min = False for value in stack: if value == min_value and not found_min: found_min = True # Remove only the first occurrence else: new_stack.append(value) return new_stack"},{"question":"You have been tasked with implementing the `radix_sort` function to help a logistics company efficiently sort large arrays of parcel tracking numbers. Each tracking number is a non-negative integer. To ensure correctness and performance, please adhere to the specifications provided: Function Description ```python def radix_sort(arr: List[int], simulation: bool = False) -> List[int]: pass ``` Input * **arr**: A list of non-negative integers representing parcel tracking numbers. (1 ≤ len(arr) ≤ 10^5) * **simulation**: A boolean flag for whether to print intermediate sorting results (default is `False`). Output * A sorted list of integers. Constraints 1. The integers in `arr` will be within the range [0, 10^9]. 2. Sorting must be stable. 3. The function should sort the list in-place if possible to minimize extra space usage. Requirements 1. Implement the radix sort algorithm. 2. Ensure it handles edge cases efficiently. 3. If `simulation` is `True`, print the list status after each digit-level sorting iteration. # Example ```python radix_sort([170, 45, 75, 90, 802, 24, 2, 66], simulation=True) # Expected intermediate outputs: # iteration 0: 170 45 75 90 802 24 2 66 # iteration 1: 170 90 802 2 24 45 75 66 # iteration 2: 802 2 24 45 66 170 75 90 # iteration 3: 2 24 45 66 75 90 170 802 # Expected final output: [2, 24, 45, 66, 75, 90, 170, 802] radix_sort([3, 5, 1, 2, 4, 5]) # Expected output: [1, 2, 3, 4, 5, 5] ``` Notes 1. Feel free to include helper functions if necessary. 2. You should not use built-in sort functions.","solution":"from typing import List def counting_sort(arr: List[int], exp: int, simulation: bool): A function to do counting sort of arr[] according to the digit represented by exp (exp is 10^i where i is the current digit number) n = len(arr) output = [0] * n count = [0] * 10 # Store count of occurrences in count[] for i in range(n): index = arr[i] // exp count[index % 10] += 1 # Change count[i] so that count[i] now contains # actual position of this digit in output[] for i in range(1, 10): count[i] += count[i - 1] # Build the output array i = n - 1 while i >= 0: index = arr[i] // exp output[count[index % 10] - 1] = arr[i] count[index % 10] -= 1 i -= 1 # Copy the output array to arr[], so that arr now # contains sorted numbers according to current digit for i in range(len(arr)): arr[i] = output[i] if simulation: print(f\\"iteration {exp}: {\' \'.join(map(str, arr))}\\") def radix_sort(arr: List[int], simulation: bool = False) -> List[int]: The main function to that sorts arr[] of size n using Radix Sort # Find the maximum number to know number of digits max1 = max(arr) # Do counting sort for every digit. Note that instead # of passing digit number, exp is passed. exp is 10^i # where i is current digit number exp = 1 while max1 // exp > 0: counting_sort(arr, exp, simulation) exp *= 10 return arr"},{"question":"# Coding Challenge **Objective**: Implement a robust and efficient Hash Table based on the given code snippets, incorporating dynamic resizing and minimizing collisions. **Requirements** 1. **Read and understand the given code for `HashTable` and `ResizableHashTable`.** 2. **Implement a method in the `ResizableHashTable` class to shrink the table size by half when the number of elements drops below 1/3 of the current capacity.** # Input and Output Format * **Class**: `ResizableHashTable` * **Method to implement**: `__shrink()` * **Constraints**: - The table should shrink if the size drops below 1/3 of the current capacity. - Ensure efficient transfer of elements to the new array. - Ensure no data loss or corruption during shrinking. * **Performance**: - The shrinking operation should aim for O(n) complexity. # Function Signature ```python class ResizableHashTable(HashTable): # ... existing methods def __shrink(self): # Your code here ``` # Example ```python hash_table = ResizableHashTable() hash_table.put(1, \'A\') hash_table.put(2, \'B\') hash_table.put(3, \'C\') hash_table.del_(2) hash_table.del_(3) assert len(hash_table) == 1 # After deletion, if table size goes below 1/3 of current capacity, it should resize. # No explicit call to __shrink() is required, assume it\'s called internally when needed. # Verify table size, check preservation of entries. ``` Context **Scenario**: You are maintaining a large dataset in a Hash Table that grows and shrinks significantly. To use memory efficiently and maintain quick access times, the table size needs to resize according to the usage pattern. Grow table size dynamically when needed and shrink it when it becomes underutilized. **Task**: Add the shrinking capability to ensure optimal space and performance.","solution":"class HashTable: def __init__(self, capacity=10): self.capacity = capacity self.size = 0 self.table = [None] * self.capacity def hash_function(self, key): return hash(key) % self.capacity def put(self, key, value): index = self.hash_function(key) if self.table[index] is None: self.table[index] = [] updated = False for item in self.table[index]: if item[0] == key: item[1] = value updated = True break if not updated: self.table[index].append([key, value]) self.size += 1 def get(self, key): index = self.hash_function(key) if self.table[index] is not None: for item in self.table[index]: if item[0] == key: return item[1] return None def del_(self, key): index = self.hash_function(key) if self.table[index] is not None: for item in self.table[index]: if item[0] == key: self.table[index].remove(item) self.size -= 1 return True return False class ResizableHashTable(HashTable): def __init__(self, capacity=10): super().__init__(capacity) def put(self, key, value): super().put(key, value) if self.size > self.capacity * 0.7: # 70% load factor self.__resize(self.capacity * 2) def del_(self, key): item_deleted = super().del_(key) if self.size < self.capacity / 3: # 1/3 load factor self.__shrink() return item_deleted def __resize(self, new_capacity): old_table = self.table self.capacity = new_capacity self.table = [None] * self.capacity self.size = 0 for bucket in old_table: if bucket is not None: for key, value in bucket: self.put(key, value) def __shrink(self): new_capacity = max(self.capacity // 2, 10) # Minimum capacity should be 10 self.__resize(new_capacity)"}]'),N={name:"App",components:{PoemCard:S},data(){return{searchQuery:"",visibleCount:4,poemsData:O,isLoading:!1}},computed:{filteredPoems(){const r=this.searchQuery.trim().toLowerCase();return r?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(r)||e.solution&&e.solution.toLowerCase().includes(r)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(r=>setTimeout(r,1e3)),this.visibleCount+=4,this.isLoading=!1}}},z={class:"search-container"},L={class:"card-container"},C={key:0,class:"empty-state"},F=["disabled"],R={key:0},Y={key:1};function j(r,e,l,p,s,a){const m=g("PoemCard");return n(),i("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",z,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),_(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>s.searchQuery=o),placeholder:"Search..."},null,512),[[y,s.searchQuery]]),s.searchQuery?(n(),i("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>s.searchQuery="")}," ✕ ")):u("",!0)]),t("div",L,[(n(!0),i(b,null,v(a.displayedPoems,(o,f)=>(n(),w(m,{key:f,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(n(),i("div",C,' No results found for "'+d(s.searchQuery)+'". ',1)):u("",!0)]),a.hasMorePoems?(n(),i("button",{key:0,class:"load-more-button",disabled:s.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[s.isLoading?(n(),i("span",Y,"Loading...")):(n(),i("span",R,"See more"))],8,F)):u("",!0)])}const P=c(N,[["render",j],["__scopeId","data-v-870cc6f3"]]),M=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"drive/51.md","filePath":"drive/51.md"}'),B={name:"drive/51.md"},U=Object.assign(B,{setup(r){return(e,l)=>(n(),i("div",null,[x(P)]))}});export{M as __pageData,U as default};
