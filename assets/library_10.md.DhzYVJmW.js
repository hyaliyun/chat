import{_ as m,o as n,c as r,a as t,m as d,t as l,C as p,M as _,U as b,f as h,F as y,p as w,e as x,q as v}from"./chunks/framework.B1z0IdBH.js";const k={name:"PoemCard",props:{poem:{type:Object,required:!0}}},q={class:"poem-container"},T={class:"review"},j={class:"review-title"},R={class:"review-content"};function Y(i,e,u,c,s,a){return n(),r("div",q,[t("div",T,[t("div",j,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),d(l(u.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",R,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),d(l(u.poem.solution),1)])])])}const I=m(k,[["render",Y],["__scopeId","data-v-c26c8bae"]]),F=JSON.parse('[{"question":"Given two integer arrays `nums1` and `nums2` sorted in non-decreasing order, and two integers `m` and `n`, representing the number of elements in `nums1` and `nums2` respectively, merge `nums2` into `nums1` as one sorted array. Note: - The number of elements initialized in `nums1` and `nums2` are `m` and `n` respectively. - You may assume that `nums1` has enough space (size that is equal to `m + n`) to hold additional elements from `nums2`. Function signature: ``` def merge(nums1: List[int], m: int, nums2: List[int], n: int) -> None: Do not return anything, modify nums1 in-place instead. ```","solution":"from typing import List def merge(nums1: List[int], m: int, nums2: List[int], n: int) -> None: Merges nums2 into nums1 in-place. i, j, k = m - 1, n - 1, m + n - 1 while j >= 0: if i >= 0 and nums1[i] > nums2[j]: nums1[k] = nums1[i] i -= 1 else: nums1[k] = nums2[j] j -= 1 k -= 1"},{"question":"A **language** processing company is developing an algorithm to analyze the **reading habits** of users on their platform. You are provided with a 2D integer array `sessions`, where `sessions[i] = [userID, bookID, duration]` represents that the user with `userID` has read the book with `bookID` for `duration` minutes during a single reading session. The company wants to understand the **most engaged user** with each book by finding the total time each user has spent reading each book. Write a function that returns a 2D integer array representing each book and the most engaged user for that book. Each entry in this array should be of the form `[bookID, userID, totalDuration]`. If there are multiple users with the same total reading duration for a book, return the user with the smallest `userID`. The returned array should be sorted by `bookID` in ascending order.","solution":"def most_engaged_users(sessions): from collections import defaultdict # Dictionary to store total duration per user per book book_user_duration = defaultdict(lambda: defaultdict(int)) for session in sessions: userID, bookID, duration = session book_user_duration[bookID][userID] += duration result = [] for bookID in sorted(book_user_duration.keys()): most_engaged_user = min(book_user_duration[bookID].items(), key=lambda x: (-x[1], x[0])) result.append([bookID, most_engaged_user[0], most_engaged_user[1]]) return result"},{"question":"You are given a **0-indexed** integer array `temperature`, where `temperature[i]` denotes the temperature measured on the `i`th day. A day `i` is considered a **cold day** if it satisfies the following conditions: - There are at least `k` days before and after the `i`th day, - The temperatures for the `k` days **before** `i` are strictly decreasing, - The temperatures for the `k` days **after** `i` are strictly increasing. More formally, day `i` is a cold day if and only if `temperature[i - k] > temperature[i - k + 1] > ... > temperature[i] < ... < temperature[i + k - 1] < temperature[i + k]`. Return _a list of **all** days **(0-indexed)** that are considered cold days_. The order of the days in the returned list does **not** matter.","solution":"def find_cold_days(temperature, k): cold_days = [] n = len(temperature) for i in range(k, n - k): is_cold = True for j in range(1, k + 1): if not (temperature[i - j] > temperature[i - j + 1] and temperature[i + j - 1] < temperature[i + j]): is_cold = False break if is_cold: cold_days.append(i) return cold_days"},{"question":"You are participating in a programming contest with `n` problems numbered from `0` to `n - 1`. Each problem has a different scoring value represented by a **0-indexed** integer array `scores` where `scores[i]` is the score for solving the `i-th` problem. In addition, you are given an integer `minScore`. To pass the contest, you need to solve a subset of the problems such that the sum of their scores is at least `minScore`. However, there is a twist: you can choose to **skip** at most one problem while forming your subset. Your goal is to determine whether it is possible to pass the contest given this rule. Return _`true` if it is possible to pass the contest by choosing a subset of problems while possibly skipping one, or `false` otherwise_.","solution":"def can_pass_contest(scores, minScore): total_score = sum(scores) if total_score >= minScore: return True if len(scores) == 1: return scores[0] >= minScore max_score_to_skip = max(scores) total_score -= max_score_to_skip return total_score >= minScore"},{"question":"Given a grid of size `m x n` consisting of only 0s and 1s, an island is a group of 1s (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water. An island is considered to be \\"unique\\" if and only if it is not equivalent to any other island in the grid. Two islands are considered equivalent if one can be obtained from the other by rotation (90, 180, or 270 degrees clockwise) or by flipping (horizontally or vertically) any number of times. Write a function to identify the number of unique islands in the grid. You may assume both the height and width of the grid are at most 50. Return _the number of distinct islands present in the grid._ **Note:** - The grid consists of only 0s (water) and 1s (land). - An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically.","solution":"def numDistinctIslands(grid): def dfs(x, y, path, idx): grid[x][y] = 0 for i, j, p in ((0, 1, \\"r\\"), (1, 0, \\"d\\"), (0, -1, \\"l\\"), (-1, 0, \\"u\\")): nx, ny = x + i, y + j if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and grid[nx][ny] == 1: dfs(nx, ny, path, idx + p) path.append(idx) unique_islands = set() for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: path = [] dfs(i, j, path, \\"o\\") unique_islands.add(tuple(path)) return len(unique_islands)"},{"question":"You are given a list of strings `words` representing a dictionary, where each string consists of lowercase English letters. You need to implement a data structure that supports the following two operations: * `void addWord(String word)` Adds a word to the dictionary. * `boolean search(String word)` Returns `true` if the word is in the dictionary, `false` if it is not. A word may contain `\'.\'` which can be matched with any letter. Implement the `WordDictionary` class: * `WordDictionary()` Initializes the object. * `void addWord(String word)` Adds a word to the dictionary. * `boolean search(String word)` Returns `true` if the word is in the dictionary. A word may contain `\'.\'` which represents any one letter. **Example:** ``` WordDictionary wordDictionary = new WordDictionary(); wordDictionary.addWord(\\"bad\\"); wordDictionary.addWord(\\"dad\\"); wordDictionary.addWord(\\"mad\\"); wordDictionary.search(\\"pad\\"); // return False wordDictionary.search(\\"bad\\"); // return True wordDictionary.search(\\".ad\\"); // return True wordDictionary.search(\\"b..\\"); // return True ``` **Notes:** * All words added to the dictionary are non-empty and consist only of lowercase English letters. * Words cannot be removed from the dictionary once added.","solution":"class WordDictionary: def __init__(self): Initialize the WordDictionary object. self.words = [] def addWord(self, word): Adds a word into the data structure. :param word: str self.words.append(word) def search(self, word): Returns if the word is in the data structure. A word could contain the dot character \'.\' to represent any one letter. :param word: str :return: bool def is_match(word, pattern): if len(word) != len(pattern): return False for w, p in zip(word, pattern): if p != \'.\' and w != p: return False return True for w in self.words: if is_match(w, word): return True return False"},{"question":"A student is creating a pen-and-paper game and needs to define the rules for moving a pawn on a grid. The grid is represented as an `m x n` matrix, where each cell in the matrix contains either a `0` (indicating the cell is blocked) or a `1` (indicating the cell is open). The pawn can move up, down, left, or right, but cannot move diagonally and cannot move into blocked cells. Given the grid and a start position `(startX, startY)`, the student needs to determine if there is a valid path to an end position `(endX, endY)`. Implement a function that will determine whether the pawn can reach the end position from the start position. Your function should return `true` if there is a path, and `false` if there is not. You are given a 2D integer array `grid`, an integer `startX`, an integer `startY`, an integer `endX`, and an integer `endY`. The pawn starts at `(startX, startY)` and needs to reach `(endX, endY)`. ``` // Example: Input: grid = [ [1, 0, 0, 0], [1, 1, 1, 1], [0, 1, 0, 0], [1, 1, 1, 1] ], startX = 0, startY = 0, endX = 3, endY = 3 Output: true Input: grid = [ [1, 0, 0, 0], [1, 1, 0, 1], [0, 1, 0, 0], [1, 1, 0, 1] ], startX = 0, startY = 1, endX = 3, endY = 3 Output: false ``` The function should explore the possible routes efficiently and return the correct result based on the grid configuration and the start and end positions.","solution":"def is_path_exists(grid, startX, startY, endX, endY): Function to determine if a path exists in the grid from (startX, startY) to (endX, endY). if grid[startX][startY] == 0 or grid[endX][endY] == 0: return False rows = len(grid) cols = len(grid[0]) def is_valid(x, y): return 0 <= x < rows and 0 <= y < cols and grid[x][y] == 1 def dfs(x, y): if x == endX and y == endY: return True grid[x][y] = 2 # mark as visited for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if is_valid(nx, ny): if dfs(nx, ny): return True return False return dfs(startX, startY)"},{"question":"You are given a string `pattern` and a string `s`. The `pattern` string contains only lowercase English letters, and the string `s` contains a sequence of words separated by spaces. You need to determine if `s` follows the same pattern as `pattern`. A sequence of words follows a pattern if there is a one-to-one mapping between letters in `pattern` and words in `s`. Each letter in `pattern` maps to exactly one word in `s` and each word in `s` maps to exactly one letter in `pattern`. Return `true` if `s` follows the `pattern`, and `false` otherwise. For example, given `pattern = \\"abba\\"` and `s = \\"dog cat cat dog\\"`, the function should return `true` because there is a one-to-one mapping: \'a\' -> \\"dog\\" and \'b\' -> \\"cat\\". However, given `pattern = \\"abba\\"` and `s = \\"dog cat cat fish\\"`, the function should return `false` because \'a\' is supposed to map to \\"dog\\" only and not \\"fish\\".","solution":"def word_pattern(pattern, s): Determine if string s follows the same pattern as string pattern. :param pattern: str - the pattern string containing only lowercase English letters :param s: str - the string containing a sequence of words separated by spaces. :return: bool - True if s follows the same pattern as pattern, False otherwise. words = s.split() if len(pattern) != len(words): return False letter_to_word = {} word_to_letter = {} for letter, word in zip(pattern, words): if letter not in letter_to_word: letter_to_word[letter] = word if word not in word_to_letter: word_to_letter[word] = letter if letter_to_word[letter] != word or word_to_letter[word] != letter: return False return True"},{"question":"A company wants to perform a sentiment analysis of customer reviews. Each review is represented by a string that may contain multiple sentences. The sentiment of a review is determined by the frequency of specific positive words and negative words. The company already has two lists: `positiveWords` and `negativeWords`, each containing words that indicate positive or negative sentiments, respectively. Write a function `evaluateSentiment(review: str, positiveWords: List[str], negativeWords: List[str]) -> str` that takes a review string and the two sentiment word lists and returns either `\\"positive\\"`, `\\"negative\\"`, or `\\"neutral\\"` based on the following criteria: - If the number of positive words in the review is greater than the number of negative words, return `\\"positive\\"`. - If the number of negative words is greater than the number of positive words, return `\\"negative\\"`. - If the counts are equal, return `\\"neutral\\"`. Consider a word to be a contiguous sequence of non-space characters matching a word from the sentiment lists exactly (case-sensitive). Ignore punctuation and consider only spaces to separate words.","solution":"from typing import List def evaluateSentiment(review: str, positiveWords: List[str], negativeWords: List[str]) -> str: Evaluates the sentiment of a customer review based on the frequency of positive and negative words. Args: review (str): The customer review as a string. positiveWords (List[str]): List of words indicating positive sentiment. negativeWords (List[str]): List of words indicating negative sentiment. Returns: str: \\"positive\\" if positive words outnumber negative words, \\"negative\\" if negative words outnumber positive words, \\"neutral\\" if counts are equal. # Tokenize the review by splitting it into words words = review.split() # Count occurrences of positive and negative words pos_count = sum(1 for word in words if word in positiveWords) neg_count = sum(1 for word in words if word in negativeWords) # Determine the sentiment based on counts if pos_count > neg_count: return \\"positive\\" elif neg_count > pos_count: return \\"negative\\" else: return \\"neutral\\""},{"question":"You are given a string `s` consisting of lowercase English letters. You can perform the following operation on `s` any number of times: choose any non-empty substring and replace all the characters in that substring with the character that appears the most frequency in the substring. For example, given the string \\"aabac\\", you can replace the substring \\"aba\\" with \\"a\\" to get the new string \\"aaac\\". Return the minimum number of operations needed to convert `s` into a string where all the characters are the same.","solution":"def min_operations_to_unify_string(s): Returns the minimum number of operations needed to convert s into a string where all characters are the same. from collections import Counter # Calculate the frequency of each character in the string char_frequency = Counter(s) # Find the character with the maximum frequency max_freq = max(char_frequency.values()) # Minimum operations is equal to the total length of the string # minus the frequency of the most frequent character return len(s) - max_freq"},{"question":"Given a binary matrix `mat` represented as a list of lists where `0` represents water and `1` represents land, return the number of distinct islands in the matrix. An island is a group of connected `1`s (land) connected vertically or horizontally. You may assume all four edges of the matrix are surrounded by water.","solution":"def num_distinct_islands(mat): def dfs(i, j, base_i, base_j, shape): if 0 <= i < len(mat) and 0 <= j < len(mat[0]) and mat[i][j] == 1: mat[i][j] = 0 shape.add((i - base_i, j - base_j)) dfs(i + 1, j, base_i, base_j, shape) dfs(i - 1, j, base_i, base_j, shape) dfs(i, j + 1, base_i, base_j, shape) dfs(i, j - 1, base_i, base_j, shape) unique_islands = set() for i in range(len(mat)): for j in range(len(mat[0])): if mat[i][j] == 1: shape = set() dfs(i, j, i, j, shape) unique_islands.add(frozenset(shape)) return len(unique_islands)"},{"question":"Given a balanced binary search tree (BST) with `n` nodes, you need to implement an iterator over the BST that returns the nodes\' values in ascending order (from smallest to largest). Your iterator should be initialized with the root of the BST. Implement the `BSTIterator` class: - `BSTIterator(TreeNode root)`: Initializes an object of the `BSTIterator` class for a given `root` of the BST. - `int next()`: Returns the next smallest number in the BST. - `boolean hasNext()`: Returns `true` if there exists a next smallest number in the BST; otherwise returns `false`. **Constraints:** * `next()` and `hasNext()` should run in average O(1) time and use O(h) memory, where h is the height of the tree. * Assume that `TreeNode` is a class that represents a node in the binary search tree. It has the following structure: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ```","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BSTIterator: def __init__(self, root: TreeNode): Initializes an object of the BSTIterator class. The root of the BST is provided. self.stack = [] self._leftmost_inorder(root) def _leftmost_inorder(self, root): Helper function to traverse the leftmost path starting from the root. while root: self.stack.append(root) root = root.left def next(self) -> int: Returns the next smallest number in the BST. topmost_node = self.stack.pop() if topmost_node.right: self._leftmost_inorder(topmost_node.right) return topmost_node.val def hasNext(self) -> bool: Returns True if there exists a next smallest number in the BST; otherwise False. return len(self.stack) > 0"},{"question":"You are given an integer array `nums` and an integer `target`. You want to find two distinct indices `i` and `j` in the array such that `nums[i] + nums[j]` is as close as possible to `target`. Return the indices of the two numbers, `i` and `j`, in any order. It is guaranteed that there is exactly one solution that is closest to `target`. If there are multiple pairs that have the same difference with `target`, return any one of them.","solution":"def two_sum_closest(nums, target): Find two distinct indices i and j in the array such that nums[i] + nums[j] is as close as possible to target. Parameters: nums (list): List of integers. target (int): Target sum. Returns: tuple: Indices i and j. n = len(nums) if n < 2: return None closest_pair = None closest_diff = float(\'inf\') for i in range(n): for j in range(i+1, n): current_sum = nums[i] + nums[j] current_diff = abs(current_sum - target) if current_diff < closest_diff: closest_pair = (i, j) closest_diff = current_diff return closest_pair"},{"question":"You are given a string `s` and an integer `k`. Your task is to split `s` into **at most** `k` non-empty substrings such that each substring is a palindrome. Return `true` _if it is possible to split the string this way, or_ `false` _otherwise_. A **palindrome** is a string that reads the same forward and backward. Substrings should be contiguous parts of the original string.","solution":"def is_palindrome(s: str) -> bool: return s == s[::-1] def can_split_into_palindromes(s: str, k: int) -> bool: def dfs(start, k): if start == len(s) and k == 0: return True if k == 0: return False for end in range(start + 1, len(s) + 1): if is_palindrome(s[start:end]): if dfs(end, k - 1): return True return False return dfs(0, k)"},{"question":"You are given a directory structure represented as a nested dictionary, where keys are folder names, and values are either `None` (indicating an empty folder) or another dictionary representing the content of that folder. Write a function to print out the directory structure in a tree format, with appropriate indentation to show the hierarchy. The root directory should have no indentation, and each level of subdirectories should be indented with two spaces more than the previous level. The function should correctly handle an arbitrary number of nested subdirectories. Example: ```python directory = { \\"root\\": { \\"folder1\\": { \\"subfolder1\\": None, \\"subfolder2\\": { \\"subsubfolder1\\": None } }, \\"folder2\\": { \\"subfolder3\\": None }, \\"folder3\\": None } } ``` Output: ``` root folder1 subfolder1 subfolder2 subsubfolder1 folder2 subfolder3 folder3 ```","solution":"def print_directory_structure(directory, level=0): Prints the directory structure in a tree format with appropriate indentation. :param directory: The directory structure as a nested dictionary. :param level: The current level of recursion (used for indentation). Default is 0. if directory is None: return for folder in directory: print(\' \' * level + folder) print_directory_structure(directory[folder], level + 1) # Example usage: # directory = { # \\"root\\": { # \\"folder1\\": { # \\"subfolder1\\": None, # \\"subfolder2\\": { # \\"subsubfolder1\\": None # } # }, # \\"folder2\\": { # \\"subfolder3\\": None # }, # \\"folder3\\": None # } # } # print_directory_structure(directory)"},{"question":"Given a string `s`, find the length of the **longest substring** without repeating characters. Return the length of this longest substring. Note: Your solution should make use of the **sliding window** technique to achieve efficient time complexity.","solution":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. n = len(s) if n == 0: return 0 char_index_map = {} max_length = start = 0 for end in range(n): if s[end] in char_index_map: start = max(start, char_index_map[s[end]] + 1) char_index_map[s[end]] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"Implement a function that takes a string representing a mathematical expression and evaluates it to return the final result. The string expression can contain digits, \'+\', \'-\', \'*\', \'/\', \'(\', and \')\'. The division should truncate towards zero if the result is not an integer. You can assume the expression is always valid.","solution":"def evaluate_expression(expression): Parses and evaluates a given mathematical expression string. Args: expression (str): A string containing a mathematical expression. Returns: int: The result of evaluating the expression. def operate(op, second, first): if op == \'+\': return first + second elif op == \'-\': return first - second elif op == \'*\': return first * second elif op == \'/\': return int(first / second) # integer division truncating towards zero def precedence(op): if op in (\'+\', \'-\'): return 1 if op in (\'*\', \'/\'): return 2 return 0 def apply_operations(operators, values): while operators and operators[-1] in (\'+\', \'-\', \'*\', \'/\'): values.append(operate(operators.pop(), values.pop(), values.pop())) operators = [] values = [] i = 0 while i < len(expression): if expression[i] == \' \': i += 1 continue if expression[i] == \'(\': operators.append(expression[i]) elif expression[i].isdigit(): num = 0 while i < len(expression) and expression[i].isdigit(): num = num * 10 + int(expression[i]) i += 1 values.append(num) i -= 1 elif expression[i] == \')\': while operators and operators[-1] != \'(\': apply_operations(operators, values) operators.pop() else: # operator while (operators and precedence(operators[-1]) >= precedence(expression[i])): apply_operations(operators, values) operators.append(expression[i]) i += 1 while operators: apply_operations(operators, values) return values[0]"},{"question":"You are given a list of `n` full name strings, where each full name is comprised of a first name, possibly a middle name, and a last name, all separated by spaces. Your task is to sort these names lexicographically by last name. If two or more names have the same last name, they should be sorted lexicographically by their first name. If the last and first names are the same, sort by the middle name. Assume all full names have only alphabetic characters and at least a first name and a last name. Given the list of names, return the new list sorted as described.","solution":"def sort_names(names): Sorts a list of full names lexicographically by last name. If last names are the same, then by first name, and if first names are the same, then by middle name. return sorted(names, key=lambda name: (name.split()[-1], name.split()[0], \' \'.join(name.split()[1:-1])))"},{"question":"You are given two integers `a` and `b`, which represent the dimensions of a 2D grid. The grid is initially filled with zeroes. You are also given a 2D integer array `queries` where `queries[i] = [xi, yi, vi]`, indicating that you should increase each element of the sub-grid whose top-left corner is at `(0, 0)` and bottom-right corner is at `(xi, yi)` by `vi`. Return the final state of the grid after performing all the queries.","solution":"def apply_queries_to_grid(a, b, queries): Apply a list of queries to a grid of dimension a by b. Parameters: a (int): Number of rows of the grid. b (int): Number of columns of the grid. queries (list of list of ints): List of queries where each query is [xi, yi, vi]. Returns: list of list of ints: The final grid after applying all queries. grid = [[0 for _ in range(b)] for _ in range(a)] for xi, yi, vi in queries: for row in range(xi + 1): for col in range(yi + 1): grid[row][col] += vi return grid"},{"question":"You are given a string consisting of lowercase English letters. You need to partition the string into as few substrings as possible so that no letter appears in more than one substring. Return _the resulting longest length of any substring after you perform the partition_.","solution":"def partition_string(s): Partitions the input string such that no letter appears in more than one substring and returns the length of the longest substring created after partition. seen = set() substr_length = 0 max_length = 0 for char in s: if char in seen: max_length = max(max_length, substr_length) seen.clear() substr_length = 0 seen.add(char) substr_length += 1 max_length = max(max_length, substr_length) return max_length"},{"question":"A company maintains a database of employees organized in a hierarchical structure. Each employee is represented as a node with a unique employee ID and each node has a list of direct reports, which are other employee nodes reporting directly to that employee. Given the employee database represented as a tree with the root node being the company\'s CEO, write a function to find the `employeeID` with the highest number of direct reports. The tree node is defined as follows: ```python class Employee: def __init__(self, id: int, reports: List[\'Employee\']): self.id = id self.reports = reports ``` You may assume that the given tree is non-empty and all `employeeID`s are unique. If multiple employees have the same highest number of direct reports, return the smallest `employeeID`.","solution":"from typing import List class Employee: def __init__(self, id: int, reports: List[\'Employee\']): self.id = id self.reports = reports def employee_with_highest_reports(ceo: Employee) -> int: def dfs(employee: Employee) -> int: nonlocal max_reports, employee_with_max_reports count = len(employee.reports) if count > max_reports or (count == max_reports and employee.id < employee_with_max_reports): max_reports = count employee_with_max_reports = employee.id for report in employee.reports: dfs(report) return employee_with_max_reports max_reports = -1 employee_with_max_reports = float(\'inf\') return dfs(ceo)"},{"question":"You are given a string `s` which consists of letters \'x\' and \'y\'. In one operation, you can swap any two adjacent characters. Your goal is to transform the string into a monotonically increasing sequence of \'x\' characters followed by \'y\' characters (i.e., all the \'x\' characters should come before all the \'y\' characters). Write a function to determine the minimum number of swaps required to transform the string into this format.","solution":"def minimum_swaps_to_monotonic(s): Computes the minimum number of adjacent swaps required to convert the given string into a monotonically increasing sequence of \'x\' characters followed by \'y\' characters. :param s: Input string consisting of characters \'x\' and \'y\' :return: Minimum number of adjacent swaps required # Count total number of x and y in the string total_x = s.count(\'x\') total_y = len(s) - total_x # Count y\'s before the current position count_y_before = 0 # Count x\'s after the current position count_x_after = total_x min_swaps = float(\\"inf\\") for char in s: if char == \'x\': count_x_after -= 1 else: min_swaps = min(min_swaps, count_x_after + count_y_before) count_y_before += 1 # Final check for the last balance min_swaps = min(min_swaps, count_x_after + count_y_before) return min_swaps"},{"question":"You are given an array of strings `phrases` and an integer `k`. Each string in `phrases` consists of words separated by single spaces. A **phrase** is defined as a string containing exactly `k` length *contiguous* words from any string in `phrases`. Implement a method that extracts all possible phrases of exactly `k` contiguous words from the given strings, combines them all into a set, and returns a list of these phrases sorted in lexicographical order. For example, given `phrases` = [\\"the quick brown fox\\", \\"jumps over the lazy dog\\"] and `k` = 2, the method should return [\\"brown fox\\", \\"jumps over\\", \\"lazy dog\\", \\"over the\\", \\"quick brown\\", \\"the lazy\\", \\"the quick\\"].","solution":"def extract_phrases(phrases, k): Extract all possible phrases of exactly k contiguous words from the given strings, combine them all into a set, and return a list of these phrases sorted in lexicographical order. result_set = set() for phrase in phrases: words = phrase.split() for i in range(len(words) - k + 1): result_set.add(\' \'.join(words[i:i+k])) return sorted(result_set)"},{"question":"You are given a string `s` containing only letters \'a\' and \'b\'. You can perform the following operation on the string: - Choose any two adjacent characters and remove them if they are different. Formally, you can remove \'ab\' or \'ba\' in one move. Perform the above operation as many times as possible. Return the length of the smallest string that you can obtain by applying the above operation repeatedly. **Example:** - Input: `s = \\"abba\\"` - Output: `0` **Explanation:** By removing \'ab\' and \'ba\', we can turn the string into an empty one.","solution":"def smallest_string_length(s): Returns the length of the smallest string that can be obtained by repeatedly removing \'ab\' or \'ba\'. stack = [] for char in s: if stack and ((char == \'a\' and stack[-1] == \'b\') or (char == \'b\' and stack[-1] == \'a\')): stack.pop() else: stack.append(char) return len(stack)"},{"question":"Implement a system to manage an inventory of items with the following capabilities: * Add items to the inventory with a given name and price. * Update the price of an existing item. * Calculate the total value of the inventory, which is the sum of the prices of all items. Implement the `InventoryManager` class: * `InventoryManager()` Initializes the `InventoryManager` object. * `void addItem(String name, double price)` Adds an item with the specified `name` and `price` to the inventory. If the item already exists, its price is updated to the new `price`. * `double getTotalValue()` Returns the total value of all items in the inventory.","solution":"class InventoryManager: def __init__(self): Initializes the InventoryManager object. self.inventory = {} def addItem(self, name, price): Adds an item with the specified name and price to the inventory. If the item already exists, its price is updated to the new price. :param name: Name of the item :param price: Price of the item self.inventory[name] = price def getTotalValue(self): Returns the total value of all items in the inventory. :return: Total value of all items return sum(self.inventory.values())"},{"question":"You are given a list of integers `nums` which contains `n` integers, where each integer represents a different number in the range `1` to `n` inclusive. The list is guaranteed to contain all the numbers from `1` to `n`. Your task is to partition the list into the **fewest number of contiguous subarrays** such that each subarray contains every number from `1` to the length of that subarray exactly once. Return the **starting and ending indices** of each such subarray. For example, given `nums = [4, 3, 2, 1, 2, 1, 3, 4]`, one possible partitioning is to form subarrays `[4, 3, 2, 1]` and `[2, 1, 3, 4]`. Thus, you should return the list of tuples representing the starting and ending indices of these subarrays in `nums`.","solution":"def partition_into_contiguous_subarrays(nums): Partition the given list into the fewest number of contiguous subarrays such that each subarray contains every number from 1 to the length of that subarray exactly once. Returns a list of tuples containing the starting and ending indices of each subarray in `nums`. n = len(nums) partitions = [] i = 0 while i < n: # Use a set to keep track of the numbers in the current partition num_set = set() # Mark the start of the current partition start = i while i < n and nums[i] not in num_set: num_set.add(nums[i]) i += 1 # Mark the end of the current partition end = i - 1 partitions.append((start, end)) return partitions"},{"question":"You are given a non-empty string `s` representing an encoded message containing only digits. Each digit can be mapped to a letter using the following mapping: `\'1\' -> \'A\'`, `\'2\' -> \'B\'`, ..., `\'26\' -> \'Z\'`. To decode an encoded message, you can replace the digits with letters using this mapping. You need to determine the total number of ways to decode the message. For example, the string `\\"12\\"` can be decoded as `\\"AB\\"` (1 followed by 2) or `\\"L\\"` (12), which means that there are 2 ways to decode `\\"12\\"`. Return the _total number of ways_ to decode the message.","solution":"def numDecodings(s): Determine the total number of ways to decode the message. if not s or s[0] == \'0\': return 0 n = len(s) dp = [0] * (n + 1) dp[0] = 1 dp[1] = 1 if s[0] != \'0\' else 0 for i in range(2, n + 1): one_digit = int(s[i-1:i]) two_digits = int(s[i-2:i]) if 1 <= one_digit <= 9: dp[i] += dp[i-1] if 10 <= two_digits <= 26: dp[i] += dp[i-2] return dp[n]"},{"question":"You are given a **0-indexed** array `weights` of `n` integers where `weights[i]` represents the weight of the `i`-th item, and an integer `capacity` which represents the maximum weight a container can hold. You need to determine the **maximum number of containers** you can fill with exactly `capacity` weight using the given items. Each item can be used at most once. Define a container as a subset of items whose total weight equals exactly `capacity`. Return _the **maximum number** of such containers that can be filled_.","solution":"def max_containers(weights, capacity): from itertools import combinations weights_len = len(weights) count = 0 def count_combinations(weights, capacity): nonlocal count for r in range(1, len(weights) + 1): for combo in combinations(weights, r): if sum(combo) == capacity: count += 1 for item in combo: weights.remove(item) return while True: original_count = count count_combinations(weights, capacity) if count == original_count: break return count"},{"question":"You are given a binary tree in the form of an integer array `values` where each element represents a node\'s value. The structure of the tree is such that the left child of the node at index `i` is at index `2*i + 1` and the right child of the node at index `2*i + 2`. Return the _maximum depth_ of the tree. The **depth** of a node is the number of edges from the node to the tree\'s root node. Note: A tree with only a single node has a depth of 1.","solution":"def max_depth(values): Returns the maximum depth of the binary tree represented by `values`. :param values: List[int] :return: int if not values: return 0 def depth_helper(index): if index >= len(values) or values[index] is None: return 0 left_depth = depth_helper(2 * index + 1) right_depth = depth_helper(2 * index + 2) return 1 + max(left_depth, right_depth) return depth_helper(0)"},{"question":"You are given a **0-indexed** integer array `heights` of length `n` where `heights[i]` denotes the height of a person standing in a line. We say that a lineup is valid if for any two consecutive persons `i` and `i + 1`, the heights satisfy the condition `heights[i] <= heights[i + 1]` or `heights[i] >= heights[i + 1]`. Return the length of the longest **contiguous** subarray that forms a valid lineup.","solution":"def longest_valid_lineup(heights): Returns the length of the longest contiguous subarray that forms a valid lineup. A valid lineup means the subarray is either non-increasing or non-decreasing. if not heights: return 0 max_length = 1 current_length_inc = 1 current_length_dec = 1 for i in range(1, len(heights)): if heights[i] >= heights[i - 1]: current_length_inc += 1 else: current_length_inc = 1 if heights[i] <= heights[i - 1]: current_length_dec += 1 else: current_length_dec = 1 max_length = max(max_length, current_length_inc, current_length_dec) return max_length"},{"question":"Given an `m x n` matrix of integers representing an image, where each integer corresponds to the pixel value of the image, write a function that rotates the image 90 degrees clockwise **in-place**. The input array must be modified directly, and you may not use a secondary (copy) matrix to achieve the rotation. Return the resulting matrix after the rotation.","solution":"def rotate_image_90_degrees(matrix): Rotates the given n x n matrix 90 degrees clockwise in-place. :param matrix: List[List[int]], a 2D list representing the image. :return: The same matrix after being rotated 90 degrees clockwise. n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse() return matrix"},{"question":"You are given a list of positive integers representing the heights of bar buildings. You need to choose some of these buildings to construct the largest rectangle under the skyline. The rectangle can only be formed by consecutive buildings. Return _the area of the largest rectangle you can obtain under the skyline._","solution":"def largest_rectangle_area(heights): Returns the area of the largest rectangle under the skyline. :param heights: List[int] :return: int max_area = 0 stack = [] # Add a zero height at the end to process all buildings heights.append(0) for i, h in enumerate(heights): while stack and heights[stack[-1]] >= h: height = heights[stack.pop()] width = i if not stack else i - stack[-1] - 1 max_area = max(max_area, height * width) stack.append(i) return max_area"},{"question":"You are given a list of integers `nums` and an integer `x`. Your task is to determine the _minimum length of a contiguous subarray_ of which the sum is greater than or equal to `x`. If no such subarray exists, return `0`.","solution":"def min_subarray_len(nums, x): Returns the minimum length of a contiguous subarray of which the sum is greater than or equal to x. If no such subarray exists, returns 0. n = len(nums) min_length = float(\'inf\') start = 0 current_sum = 0 for end in range(n): current_sum += nums[end] while current_sum >= x: min_length = min(min_length, end - start + 1) current_sum -= nums[start] start += 1 return 0 if min_length == float(\'inf\') else min_length"},{"question":"You are given a string `sentence` consisting of space-separated words and an array of integers `indices` where each integer specifies a position within the original `sentence`. Your task is to rearrange the words in the sentence based on the order provided in `indices` and return the resulting sentence. Ensure that the final sentence maintains the same spacing between words as the original.","solution":"def rearrange_words(sentence, indices): Rearranges the words in the sentence based on the order provided in indices. Parameters: sentence (str): The original sentence consisting of space-separated words. indices (list of int): The indices specifying the new order of the words. Returns: str: The rearranged sentence. # Split the sentence into words words = sentence.split() # Create a new list for rearranged words based on the indices rearranged_words = [\\"\\" for _ in range(len(indices))] # Populate the rearranged list using the indices for idx, position in enumerate(indices): rearranged_words[idx] = words[position] # Join the rearranged words into a new sentence return \' \'.join(rearranged_words)"},{"question":"You are given a directed graph with `n` nodes labeled from `0` to `n-1`. The graph is represented by a list of `edges` where `edges[i] = [from_i, to_i]` indicates there is a direct edge from node `from_i` to node `to_i`. Additionally, each node has an associated value stored in the list `values`, where `values[i]` represents the value of node `i`. A path in the graph is a sequence of edges that connects a pair of nodes. The sum of a path is defined as the sum of the values of the nodes in the path. Return the maximum sum of any path in the graph. If no path exists, return 0. **Note:** * The graph may contain cycles. * A path with a single node should have its value considered as the sum of the path.","solution":"def find_max_path_sum(n, edges, values): from collections import defaultdict, deque # Create adjacency list for the graph graph = defaultdict(list) for from_node, to_node in edges: graph[from_node].append(to_node) def dfs(node, visited, dp): if dp[node] != -1: return dp[node] visited[node] = True max_sum = values[node] for neighbor in graph[node]: if not visited[neighbor]: max_sum = max(max_sum, values[node] + dfs(neighbor, visited, dp)) else: max_sum = max(max_sum, values[node] + dp[neighbor]) visited[node] = False dp[node] = max_sum return dp[node] visited = [False] * n dp = [-1] * n max_path_sum = 0 for node in range(n): if dp[node] == -1: max_path_sum = max(max_path_sum, dfs(node, visited, dp)) return max_path_sum"},{"question":"You are given a 2D list `board` representing an `m x n` binary matrix, where `0` represents water and `1` represents land. An **island** is a group of `1`s connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water. Return the number of islands.","solution":"def num_islands(board): Returns the number of islands in the given 2D binary matrix. if not board: return 0 rows = len(board) cols = len(board[0]) islands_count = 0 def dfs(i, j): if i < 0 or j < 0 or i >= rows or j >= cols or board[i][j] == 0: return board[i][j] = 0 # Mark the land as visited dfs(i + 1, j) dfs(i - 1, j) dfs(i, j + 1) dfs(i, j - 1) for i in range(rows): for j in range(cols): if board[i][j] == 1: islands_count += 1 dfs(i, j) return islands_count"},{"question":"Given a 2D binary grid of size `m x n`, where `0` represents a water cell and `1` represents a land cell, an island is defined as a group of `1`s (land) connected 4-directionally (horizontal or vertical). You may assume all four edges of the grid are surrounded by water. Write a function `maxAreaOfIsland` that takes the grid as input and returns the maximum area of an island in the grid. If there is no island, return `0`.","solution":"def maxAreaOfIsland(grid): Returns the maximum area of an island in the grid. def dfs(x, y): if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or grid[x][y] == 0: return 0 grid[x][y] = 0 # Mark the land as visited area = 1 area += dfs(x + 1, y) area += dfs(x - 1, y) area += dfs(x, y + 1) area += dfs(x, y - 1) return area max_area = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: max_area = max(max_area, dfs(i, j)) return max_area"},{"question":"You are given a string `s` consisting of lowercase English letters and you need to derive a new string by performing a series of operations. In each operation, you can select any character in `s` and remove it to form a new string. You must ensure that the final string is lexicographically smallest. Return the lexicographically smallest string that can be obtained after performing any number of such operations on `s`.","solution":"def lexicographically_smallest_string(s): Returns the lexicographically smallest string that can be obtained by removing any number of characters from the given string `s`. if not s: return \\"\\" return \\"\\".join(sorted(s))"},{"question":"You are given a string `s` consisting of lowercase alphabets and an integer `k`. You need to split this string into `k` contiguous substrings such that the difference between the lengths of the longest and the shortest substrings is minimized. If it is not possible to split the string into `k` parts, return an empty array. Otherwise, return the array containing the `k` substrings in the order they appear. Each substring should contain at least one character. **Note:** The sizes of the substrings do not have to be equal, but the difference in size should be as small as possible.","solution":"def split_string(s, k): Splits the string `s` into `k` contiguous substrings such that the difference between the lengths of the longest and the shortest substrings is minimized. Parameters: s (str): The input string. k (int): The number of substrings to split into. Returns: List[str]: The list containing `k` substrings or an empty list if not possible. n = len(s) if k > n: return [] # Calculate the base size and the remainder base_size = n // k remainder = n % k substrings = [] start = 0 for i in range(k): current_size = base_size + (1 if i < remainder else 0) substrings.append(s[start:start + current_size]) start += current_size return substrings"},{"question":"You are given an integer array `timestamps` where each element represents the occurrence time of an event in seconds, and an integer `window` representing a time window in seconds. Each event can be considered for analysis only if it occurs within the given `window` of any other event. Return _the maximum number of events that can be analyzed together within the given time window_.","solution":"def max_events_within_window(timestamps, window): Returns the maximum number of events that can be analyzed together within a given time window. :param timestamps: List[int], the occurrence times of events in seconds :param window: int, the time window in seconds :return: int, the maximum number of events that can be analyzed together within the given time window timestamps.sort() max_events = 0 for i in range(len(timestamps)): count = 0 for j in range(i, len(timestamps)): if timestamps[j] - timestamps[i] <= window: count += 1 else: break max_events = max(max_events, count) return max_events"},{"question":"Given a string `s` that represents a **non-negative** integer, add commas as thousand separators. Return the string with the added commas. Commas should be added in the traditional North American format: separating each group of three digits, starting from the right-hand side. For example, if `s` is `\\"1234567\\"`, the output should be `\\"1,234,567\\"`. If `s` is `\\"123\\"`, the output should be `\\"123\\"`.","solution":"def add_commas(s): Adds commas as thousand separators to the string `s` representing a non-negative integer. return \\"{:,}\\".format(int(s))"},{"question":"Implement a circular queue using a fixed-size array. A circular queue follows the First-In-First-Out (FIFO) principle but wraps around when the end of the array is reached. Implement the `MyCircularQueue` class: - `MyCircularQueue(int k)`: Initializes the circular queue with a maximum size of `k`. - `bool enQueue(int value)`: Inserts an element into the circular queue. Returns `true` if the operation is successful, otherwise returns `false`. - `bool deQueue()`: Removes an element from the circular queue. Returns `true` if the operation is successful, otherwise returns `false`. - `int Front()`: Gets the front item from the queue. If the queue is empty, return `-1`. - `int Rear()`: Gets the last item from the queue. If the queue is empty, return `-1`. - `bool isEmpty()`: Checks whether the circular queue is empty. - `bool isFull()`: Checks whether the circular queue is full. Implement the `MyCircularQueue` class with the mentioned methods.","solution":"class MyCircularQueue: def __init__(self, k: int): self.queue = [0] * k self.head = -1 self.tail = -1 self.max_size = k def enQueue(self, value: int) -> bool: if self.isFull(): return False if self.isEmpty(): self.head = 0 self.tail = (self.tail + 1) % self.max_size self.queue[self.tail] = value return True def deQueue(self) -> bool: if self.isEmpty(): return False if self.head == self.tail: self.head = -1 self.tail = -1 else: self.head = (self.head + 1) % self.max_size return True def Front(self) -> int: if self.isEmpty(): return -1 return self.queue[self.head] def Rear(self) -> int: if self.isEmpty(): return -1 return self.queue[self.tail] def isEmpty(self) -> bool: return self.head == -1 def isFull(self) -> bool: return (self.tail + 1) % self.max_size == self.head"},{"question":"A digital company stores logs of user activities. Each log entry is represented by a string with the format `userid-timestamp-action`. The `userid` is a unique identifier for a user, `timestamp` is a string in `YYYY-MM-DD HH:MM:SS` format, and `action` is one of `[\\"login\\", \\"logout\\", \\"purchase\\"]`. Write a function `most_active_user(logs)` that takes a list of logs and returns the `userid` of the user with the most activities (number of log entries) in the given list. If there are multiple users with the same number of activities, return the `userid` that comes first lexicographically. You can assume the logs are well-formed.","solution":"from collections import defaultdict def most_active_user(logs): Returns the userid of the user with the most activity logged. activity_count = defaultdict(int) # Count the number of activities for each user for log in logs: userid, _, _ = log.split(\'-\', 2) activity_count[userid] += 1 # Find the user with the most activities max_activities = 0 most_active_users = [] for userid, count in activity_count.items(): if count > max_activities: max_activities = count most_active_users = [userid] elif count == max_activities: most_active_users.append(userid) # Return the lexicographically smallest userid if there are ties return sorted(most_active_users)[0]"},{"question":"You are given an n x n 2D matrix `grid` representing an image, where each element is an integer that represents the pixel value at that specific coordinate. Your task is to \\"rotate\\" the image 90 degrees clockwise and return the new 2D matrix. To rotate the image 90 degrees clockwise: - The first row of the original matrix becomes the last column of the new matrix. - The second row of the original matrix becomes the second last column of the new matrix. - And so on... Write a function `rotateImage(grid: List[List[int]]) -> List[List[int]]` that takes the 2D matrix `grid` as input and returns the rotated matrix. For example, given the matrix: ``` [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] ``` Your function should return: ``` [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] ```","solution":"from typing import List def rotateImage(grid: List[List[int]]) -> List[List[int]]: Rotates the given n x n 2D matrix 90 degrees clockwise. Args: grid (List[List[int]]): A n x n 2D matrix representing the image. Returns: List[List[int]]: The rotated 2D matrix. # Get the size of the matrix n = len(grid) # Create an empty matrix to hold the rotated values rotated = [[0]*n for _ in range(n)] # Perform the rotation for i in range(n): for j in range(n): rotated[j][n-1-i] = grid[i][j] return rotated"},{"question":"Given a linked list, each node containing a digit from 0 to 9, where the head of the list represents the least significant digit of a non-negative integer. Write a function to add two such numbers and return the sum as a linked list in the same format (least significant digit at the head). For example, given the linked lists `(2 -> 4 -> 3)` and `(5 -> 6 -> 4)`, which represent the numbers 342 and 465 respectively, the function should return `(7 -> 0 -> 8)`, representing the number 807.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def add_two_numbers(l1, l2): dummy = ListNode() current = dummy carry = 0 while l1 or l2 or carry: val1 = l1.val if l1 else 0 val2 = l2.val if l2 else 0 total = val1 + val2 + carry carry = total // 10 current.next = ListNode(total % 10) current = current.next if l1: l1 = l1.next if l2: l2 = l2.next return dummy.next"},{"question":"You are given an array of integers `nums` where each element appears either once or twice. Return _an array of all the integers that appear **twice** in_ `nums`. The returned array should be in **sorted** order. Try to solve it in `O(n)` time and `O(1)` space (excluding the output array).","solution":"def find_duplicates(nums): Returns an array of integers that appear twice in nums, sorted in ascending order. duplicates = [] for num in nums: index = abs(num) - 1 if nums[index] < 0: duplicates.append(abs(num)) else: nums[index] = -nums[index] return sorted(duplicates)"},{"question":"Given an array of integers `nums` and an integer `k`, find the maximum sum of a non-empty subarray of `nums`, where the absolute difference between the sum and `k` is minimized. Return this minimum absolute difference. If there are multiple subarrays with the same absolute difference, return the smallest one in terms of sum.","solution":"def min_abs_diff_sum(nums, k): Finds the minimum absolute difference between the sum of a non-empty subarray and k. Args: nums (list<int>): List of integers. k (int): Target integer. Returns: int: The minimum absolute difference. n = len(nums) min_abs_diff = float(\'inf\') closest_sum = float(\'inf\') for i in range(n): curr_sum = 0 for j in range(i, n): curr_sum += nums[j] abs_diff = abs(curr_sum - k) if abs_diff < min_abs_diff: min_abs_diff = abs_diff closest_sum = curr_sum elif abs_diff == min_abs_diff: closest_sum = min(closest_sum, curr_sum) return min_abs_diff"},{"question":"Implement a `Dictionary` class that provides the following functionalities: 1. `addWord(word)`: Adds the given word to the dictionary. 2. `searchWord(word)`: Returns `True` if the given word is in the dictionary, and `False` otherwise. This search should support \\".\\" as a wildcard character, where \\".\\" can represent any single letter. The dictionary is initially empty. For example: - `addWord(\\"bad\\")` - `addWord(\\"dad\\")` - `addWord(\\"mad\\")` - `searchWord(\\"pad\\")` returns `False` (cannot find \\"pad\\" in the dictionary) - `searchWord(\\"bad\\")` returns `True` (can find \\"bad\\" in the dictionary) - `searchWord(\\".ad\\")` returns `True` (can find \\"bad\\", \\"dad\\", and \\"mad\\" in the dictionary) - `searchWord(\\"b..\\")` returns `True` (can find \\"bad\\")","solution":"import re class Dictionary: def __init__(self): self.words = [] def addWord(self, word): Adds the given word to the dictionary. self.words.append(word) def searchWord(self, word): Returns True if the given word is in the dictionary, supporting \\".\\" as a wildcard character where \\".\\" can represent any single letter. pattern = re.compile(f\\"^{word}\\") for w in self.words: if pattern.match(w): return True return False"},{"question":"You are given a string `s` containing just the characters `\'a\'`, `\'b\'`, and `\'c\'`. You need to remove all the adjacent duplicates in the string where duplicate removal is performed herein defined as: if two consecutive characters are the same, they are removed from the string. The removal of adjacent duplicates is performed iteratively until no more adjacent duplicates are present. Return the final string after all such duplicate removals have been made.","solution":"def remove_adjacent_duplicates(s: str) -> str: Removes all adjacent duplicates in the string s. stack = [] for char in s: if stack and stack[-1] == char: stack.pop() else: stack.append(char) return \'\'.join(stack)"},{"question":"You are given a string `expression` consisting of lowercase letters and the \'+\' character, representing a sum of unique variables (e.g. \\"a+b+c\\"). You have a dictionary `values` where the keys are variable names and the values are integers representing the corresponding variable\'s value (e.g. `{\'a\': 1, \'b\': 2, \'c\': 3}`). Calculate and return the result of the expression by summing up the values of the variables. Complete the function `evaluate_expression(expression: str, values: Dict[str, int]) -> int` which takes in an expression string and a values dictionary, and returns the evaluated result.","solution":"def evaluate_expression(expression: str, values: dict) -> int: Evaluates the given expression by summing up the values of variables in the dictionary. Parameters: - expression (str): A string representing the sum of variables (e.g., \\"a+b+c\\"). - values (dict): A dictionary containing the values for each variable. Returns: - int: The result of the expression. # Split the expression by \'+\' to get the list of variables variables = expression.split(\'+\') # Sum up the values of the variables using the provided dictionary result = sum(values[var] for var in variables) return result"},{"question":"You are given the head of a singly linked list. The list is sorted in non-decreasing order. Write a function to delete all duplicate nodes such that each element appears only once. Return the linked list sorted as well.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def delete_duplicates(head): Deletes all duplicate nodes from a sorted linked list. :param head: ListNode :return: ListNode current = head while current and current.next: if current.val == current.next.val: current.next = current.next.next else: current = current.next return head"},{"question":"You are given an integer array `arr` of `n` integers. We define a **subarray sum** as the sum of elements in a subarray of `arr`. A subarray is defined as a non-empty contiguous segment of `arr`. Given an integer `threshold`, determine the **minimum length** of a subarray of `arr` whose sum is greater than or equal to `threshold`. If no such subarray exists, return `-1`.","solution":"def min_length_subarray(arr, threshold): Returns the minimum length of a subarray with a sum greater than or equal to threshold. If no such subarray exists, return -1. n = len(arr) min_len = float(\'inf\') current_sum = 0 left = 0 for right in range(n): current_sum += arr[right] while current_sum >= threshold: min_len = min(min_len, right - left + 1) current_sum -= arr[left] left += 1 return min_len if min_len != float(\'inf\') else -1"},{"question":"You are given an array `rooms` where `rooms[i]` is the number of keys in the `i-th` room. Initially, you are in the first room and each key in the `i-th` room can unlock the `i-th` room (i.e., if you have the key for a certain room, you can enter that room). You can move freely between rooms as long as they are unlocked. Return _the minimum number of keys you need to collect to visit all rooms at least once_.","solution":"from typing import List def min_keys_to_visit_all_rooms(rooms: List[int]) -> int: Returns the minimum number of keys needed to visit all rooms at least once. Parameters: rooms (List[int]): A list where rooms[i] represents the number of keys in the i-th room. Returns: int: The minimum number of keys required to visit all rooms at least once. if not rooms: return 0 # BFS to find the minimum number of keys to visit all rooms n = len(rooms) visited = [False] * n queue = [0] visited[0] = True keys_collected = 0 while queue: current_room = queue.pop(0) keys_in_current_room = rooms[current_room] keys_collected += keys_in_current_room for next_room in range(n): if not visited[next_room]: visited[next_room] = True queue.append(next_room) return keys_collected"},{"question":"Write a function that takes a string `s` as input and returns the length of the longest palindrome that can be formed with the letters of `s`. The string may consist of both uppercase and lowercase letters. The palindrome does not need to be limited to dictionary words. Note that in the result, the characters are case-sensitive, meaning that \\"Aa\\" is not considered a palindrome.","solution":"from collections import Counter def longest_palindrome(s): Returns the length of the longest palindrome that can be formed with the letters of the input string `s`. char_count = Counter(s) length = 0 odd_found = False for count in char_count.values(): if count % 2 == 0: length += count else: length += count - 1 odd_found = True if odd_found: length += 1 return length"},{"question":"You are given a binary tree where the root node is at depth 0 and each parent node has two children. Write a function to determine the sum of values of all nodes at the deepest level. The binary tree is represented by a list of integers, where `-1` signifies a null node. Return _the sum of values of all nodes at the deepest level_. Ensure that your implementation efficiently handles large trees.","solution":"def deepest_level_sum(tree): Returns the sum of values of all nodes at the deepest level in the given binary tree. The binary tree is represented as a list where `-1` signifies a null node. if not tree or tree[0] == -1: return 0 current_level = [0] next_level = [] # BFS to find the deepest level while current_level: next_level = [] for index in current_level: left_index = 2 * index + 1 right_index = 2 * index + 2 if left_index < len(tree) and tree[left_index] != -1: next_level.append(left_index) if right_index < len(tree) and tree[right_index] != -1: next_level.append(right_index) if not next_level: break current_level = next_level # Calculate the sum of values at the deepest level return sum(tree[idx] for idx in current_level)"},{"question":"You are given a **0-indexed** array `heights` of `n` integers, representing the height of different mountains in a range. A mountain is defined as a sequence of elements that strictly increases and then strictly decreases. An element can be part of only one mountain. Determine the **length** of the longest mountain subarray and return it. A subarray `[heights[i], heights[i+1], ..., heights[j]]` is considered a mountain if and only if there exists `k` with `i < k < j` such that: - `heights[i] < heights[i+1] < ... < heights[k]` - `heights[k] > heights[k+1] > ... > heights[j]` The length of the mountain is defined as `j - i + 1`. If there is no mountain, return `0`.","solution":"def longest_mountain(heights): n = len(heights) if n < 3: return 0 max_len = 0 for i in range(1, n - 1): if heights[i - 1] < heights[i] > heights[i + 1]: left = i - 1 while left > 0 and heights[left - 1] < heights[left]: left -= 1 right = i + 1 while right < n - 1 and heights[right] > heights[right + 1]: right += 1 max_len = max(max_len, right - left + 1) return max_len"},{"question":"You are given two arrays, `arr1` and `arr2`, both of length `n`, where `arr1[i]` and `arr2[i]` represent the availability of a worker at hour `i` in a day (0 for unavailable, 1 for available). Implement the `WorkerAvailability` class: * `WorkerAvailability(vector<int>& arr1, vector<int>& arr2)` - Initializes the object with the two arrays of worker availability. * `int max_consecutive_hours()` - Returns the maximum number of consecutive hours during which at least one worker is available. The function should return the longest contiguous sequence of hours during which either worker is available.","solution":"class WorkerAvailability: def __init__(self, arr1, arr2): self.arr1 = arr1 self.arr2 = arr2 def max_consecutive_hours(self): max_hours = 0 current_hours = 0 for hour1, hour2 in zip(self.arr1, self.arr2): if hour1 == 1 or hour2 == 1: current_hours += 1 max_hours = max(max_hours, current_hours) else: current_hours = 0 return max_hours"},{"question":"Given a list of integers `nums` where each integer appears at most twice, return an array of all the integers that appear exactly twice. You must write an algorithm that runs in O(n) time and uses only constant extra space.","solution":"def find_duplicates(nums): Returns a list of integers that appear exactly twice in the input list. This function modifies the input list nums in-place to mark visited elements by flipping their sign. It then collects elements that were visited more than once. result = [] for i in range(len(nums)): index = abs(nums[i]) - 1 if nums[index] < 0: result.append(abs(nums[i])) else: nums[index] = -nums[index] return result"},{"question":"You are given a string `blocks` consisting of characters `\'W\'` and `\'B\'`, representing white and black blocks respectively, and an integer `k`. We call a substring of `blocks` a **contiguous** sequence of blocks within the string. Return the **minimum number of blocks** you must repaint to get at least one substring of length `k` that contains only the character `\'B\'`. If no such substring exists, return `-1`.","solution":"def minimum_repaints(blocks, k): n = len(blocks) if k > n: return -1 # Create initial window of size k repaint_count = sum(1 for block in blocks[:k] if block == \'W\') min_repaint = repaint_count # Sliding window technique for i in range(k, n): if blocks[i] == \'W\': repaint_count += 1 if blocks[i - k] == \'W\': repaint_count -= 1 min_repaint = min(min_repaint, repaint_count) return min_repaint"},{"question":"You are given an array of integers `nums` and an integer `k`. You need to find the `k` most frequent elements in the array. If there is a tie for the `k`th most frequent element, you may choose any of the tying elements. Return _an array of the `k` most frequent elements in **any order**_. **Note**: You may assume that the input array `nums` contains at least `k` distinct elements.","solution":"from collections import Counter import heapq def top_k_frequent(nums, k): Returns the k most frequent elements of the given integer array nums. If there is a tie for the kth most frequent element, any of them may be chosen. if len(nums) == 0: return [] # Count the frequency of each element in nums count = Counter(nums) # Use a heap to keep track of the k most frequent elements return heapq.nlargest(k, count.keys(), key=count.get)"},{"question":"You are given an integer array `arr` representing a number of coins placed in a row, where each integer represents the number of coins at that position. Your goal is to split all the coins into exactly two non-empty groups while minimizing the absolute difference between the total number of coins in each group. For example, if `arr = [1, 2, 3, 4, 5]`, you could split it into `[1, 2, 3]` and `[4, 5]` or `[1, 2, 3, 4]` and `[5]`. Return _an integer_ representing the minimum possible absolute difference between the total number of coins in the two groups after the split.","solution":"def min_diff_split_coins(arr): Returns the minimum possible absolute difference between the total number of coins in two groups. arr: List[int] - the list of integers representing the number of coins at each position. total_sum = sum(arr) n = len(arr) # We need to find a subset with the sum closest to total_sum // 2 target = total_sum // 2 dp = [False] * (target + 1) dp[0] = True for coin in arr: for t in range(target, coin - 1, -1): dp[t] = dp[t] or dp[t - coin] for t in range(target, -1, -1): if dp[t]: best_sum = t break group1 = best_sum group2 = total_sum - best_sum return abs(group1 - group2)"},{"question":"Given a string `s` which contains only lowercase letters, a **duplicate** letter is defined as a character that appears more than once in the string. Write a function to remove all **duplicate** letters such that each letter appears only once and the resulting string has all **unique** letters in their original order of appearance. Return the resulting string with all **unique** letters maintaining their first occurrence order.","solution":"def remove_duplicates(s): Removes all duplicate letters in the string such that each letter appears only once and maintains the original order of appearance. seen = set() result = [] for char in s: if char not in seen: seen.add(char) result.append(char) return \'\'.join(result)"},{"question":"You are given a list of meetings represented by tuples, where each tuple contains the start and end times of a meeting in the format (start, end). The list of meetings may not be sorted. Your task is to determine if a person can attend all meetings without any overlaps. Return `True` if a person can attend all the meetings, otherwise return `False`. Note that if two meetings end and start at the same time, they are considered non-overlapping.","solution":"def can_attend_all_meetings(meetings): Determines if a person can attend all meetings without any overlaps. Args: - meetings: list of tuples, where each tuple contains the start and end times of a meeting. Returns: - bool: True if a person can attend all the meetings without any overlaps, else False. # Sort the meetings by start time sorted_meetings = sorted(meetings, key=lambda x: x[0]) # Check for overlaps for i in range(1, len(sorted_meetings)): if sorted_meetings[i][0] < sorted_meetings[i-1][1]: return False return True"},{"question":"You are given a string `s` that consists of digits and lowercase English letters. You can remove some characters from the string so that the remaining characters form a subsequence that is a valid hexadecimal number (i.e., it only contains characters 0-9 and a-f and is non-empty). Return the lexicographically smallest valid hexadecimal number that you can obtain from `s`. If it is not possible to obtain a valid hexadecimal number, return an empty string.","solution":"def smallest_valid_hexadecimal(s): Return the lexicographically smallest valid hexadecimal number from the string `s`. If it is not possible to obtain a valid hexadecimal number, return an empty string. valid_chars = \'0123456789abcdef\' result = [c for c in s if c in valid_chars] return \'\'.join(sorted(result)) if result else \'\'"},{"question":"Given an integer array `arr`, you need to count the number of elements that have **exactly** three divisors. A number `x` is said to have exactly `3` divisors if there exist exactly three distinct integers `a`, `b`, and `c` such that `a * b * c = x`. Return _the **count** of such elements in the array_. If no such elements exist, return `0`.","solution":"import math def is_prime(n): Helper function to determine if a number `n` is prime. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def count_elements_with_three_divisors(arr): Counts the number of elements in the array `arr` that have exactly three divisors. count = 0 for num in arr: if num < 4: continue sqrt_num = int(math.sqrt(num)) if sqrt_num * sqrt_num == num and is_prime(sqrt_num): count += 1 return count"},{"question":"A restaurant\'s reservation system stores upcoming reservations in a list of tuples, where each tuple contains two integers representing the start and end times of a reservation. Given a new reservation request defined by a start time and an end time, write a function to determine if the new reservation can be added without overlapping any of the existing reservations. Write a function that takes in the list of existing reservations and the new reservation\'s start and end times, and returns a boolean indicating whether the new reservation can be made. For example, given the list of existing reservations: `[(1, 4), (5, 6), (8, 10)]` and a new reservation `(2, 5)`, the function should return `False` because it overlaps with `(1, 4)` and `(5, 6)`.","solution":"def can_add_reservation(existing_reservations, new_reservation): Determines if the new reservation can be added without overlapping any existing reservations. Args: existing_reservations (list of tuples): List of existing reservations where each tuple is (start, end). new_reservation (tuple): Tuple representing the new reservation (start, end). Returns: bool: True if the new reservation can be added, False otherwise. new_start, new_end = new_reservation for start, end in existing_reservations: # Check if there is an overlap if not (new_end <= start or new_start >= end): return False return True"},{"question":"You are given two integer arrays `nums1` and `nums2` of equal length. Your task is to assign elements from `nums2` to `nums1` such that the sum of `max(nums1[i], nums2[i])` for all valid `i` is minimized. You can reorder `nums2` as necessary to achieve this. Return the minimized sum after assigning `nums2` elements to `nums1`.","solution":"def min_sum_of_max(nums1, nums2): Returns the minimized sum of max(nums1[i], nums2[i]) for each i. nums1.sort() nums2.sort() total_sum = 0 for i in range(len(nums1)): total_sum += max(nums1[i], nums2[i]) return total_sum"},{"question":"You are given an integer array `nums` and an integer `k`. Return _the maximum sum of any non-empty subarray_ `nums` _can have such that the number of distinct elements in the subarray is at most_ `k`. If there is no such subarray, return `-1`.","solution":"def max_sum_subarray_with_k_distinct(nums, k): from collections import defaultdict n = len(nums) if n == 0 or k == 0: return -1 # Initialize variables left = 0 current_sum = 0 max_sum = float(\'-inf\') count = defaultdict(int) for right in range(n): # Add the current element to the window count[nums[right]] += 1 current_sum += nums[right] # Ensure the window contains at most k distinct numbers while len(count) > k: count[nums[left]] -= 1 current_sum -= nums[left] if count[nums[left]] == 0: del count[nums[left]] left += 1 # Update the max_sum if len(count) <= k: max_sum = max(max_sum, current_sum) return max_sum if max_sum != float(\'-inf\') else -1"},{"question":"You are given a list of intervals `intervals` where `intervals[i] = [starti, endi]`. Each interval represents a meeting time and overlaps may exist. Your task is to merge all overlapping intervals and return the merged intervals in sorted order. Implement the function `List<List<Integer>> mergeIntervals(List<List<Integer>> intervals)` which takes a list of intervals `intervals` and returns a list of merged intervals in sorted order (each sublist should be sorted as well).","solution":"def merge_intervals(intervals): Merges all overlapping intervals and returns the merged intervals in sorted order. :param intervals: List[List[int]] - A list of intervals where each interval is a list of two integers [starti, endi] :return: List[List[int]] - A list of merged and sorted intervals if not intervals: return [] # Sort intervals by the start time intervals.sort(key=lambda x: x[0]) merged_intervals = [intervals[0]] for current in intervals[1:]: last_merged = merged_intervals[-1] # If the current interval overlaps with the last merged interval, merge them if current[0] <= last_merged[1]: last_merged[1] = max(last_merged[1], current[1]) else: # Otherwise, add the current interval to the list merged_intervals.append(current) return merged_intervals"},{"question":"You are given an integer array `nums` and an integer `k`. Your task is to split `nums` into `k` consecutive subarrays such that the difference between the maximum sum of any subarray and the minimum sum of any subarray is minimized. Return _the minimum difference between the maximum and minimum subarray sums achieved by any way of splitting_ the array. Each subarray must be non-empty, and each element must be included in exactly one subarray. * For example, if `nums = [7,2,5,10,8]` and `k = 2`, then you could split the array into `[7,2,5]` and `[10,8]`, which gives maximum subarray sum as `18` and minimum subarray sum as `7`, and the difference is `18 - 14 = 4`.","solution":"def can_partition(nums, k, max_sum): current_sum = 0 required_subarrays = 1 for num in nums: if current_sum + num > max_sum: required_subarrays += 1 current_sum = num if required_subarrays > k: return False else: current_sum += num return True def minimize_difference(nums, k): left, right = max(nums), sum(nums) result = right while left <= right: mid = (left + right) // 2 if can_partition(nums, k, mid): result = mid right = mid - 1 else: left = mid + 1 return result"},{"question":"You are given a **0-indexed** integer array `nums` of length `n` and an integer `k`. You can perform the following operation exactly `k` times: select any element `nums[i]` and increment it by 1. Return _true if you can make `nums` a **non-decreasing** array using exactly `k` increments and false otherwise._ A **non-decreasing array** is an array whose each element is greater than or equal to its preceding element.","solution":"def canBeNonDecreasing(nums, k): Determines if it is possible to make the array non-decreasing using exactly k increments. Parameters: nums (list of int): The input array of integers. k (int): The number of increments allowed. Returns: bool: True if nums can be made non-decreasing using exactly k increments, false otherwise. n = len(nums) for i in range(1, n): if nums[i] < nums[i - 1]: diff = nums[i - 1] - nums[i] if k >= diff: k -= diff nums[i] += diff else: return False return k == 0"},{"question":"Given two strings `s1` and `s2`, find the minimum number of operations required to convert `s1` into `s2`. You have the following operations permitted on a string: - **Insert** a character. - **Delete** a character. - **Replace** a character. Implement the function `int minDistance(String word1, String word2)` that returns the minimum number of operations to convert `word1` into `word2`. This problem is a classic example of the Edit Distance algorithm.","solution":"def min_distance(s1, s2): Returns the minimum number of operations required to convert s1 into s2. Operations permitted: - Insert a character. - Delete a character. - Replace a character. m, n = len(s1), len(s2) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(m + 1): for j in range(n + 1): if i == 0: dp[i][j] = j # s1 is empty, insert all characters of s2 elif j == 0: dp[i][j] = i # s2 is empty, delete all characters of s1 elif s1[i-1] == s2[j-1]: dp[i][j] = dp[i-1][j-1] # Characters match, move to next else: dp[i][j] = 1 + min(dp[i-1][j], # Remove from s1 dp[i][j-1], # Insert into s1 dp[i-1][j-1]) # Replace character return dp[m][n]"},{"question":"You are given two strings, `s` and `t`, where `t` is an anagram of `s`. You need to find the index of the first occurrence of `t` in `s`. If `t` is not present in `s`, return `-1`. An anagram is produced by rearranging the letters of `t` to get another string. Note that the strings consist of lowercase English letters only.","solution":"def find_anagram_index(s, t): Returns the index of the first occurrence of an anagram of t in s. If no such anagram exists in s, returns -1. from collections import Counter len_s, len_t = len(s), len(t) if len_t > len_s: return -1 counter_t = Counter(t) window_counter = Counter(s[:len_t]) # Check if first window is an anagram if window_counter == counter_t: return 0 for i in range(1, len_s - len_t + 1): window_counter[s[i-1]] -= 1 if window_counter[s[i-1]] == 0: del window_counter[s[i-1]] window_counter[s[i + len_t - 1]] += 1 if window_counter == counter_t: return i return -1"},{"question":"Given a non-empty array of integers `arr`, write a function that checks if the array could represent a **preorder traversal** of a Binary Search Tree (BST). You may assume all elements in the array are unique. Return `true` if the array can represent a preorder traversal of a BST, and `false` otherwise. A preorder traversal of a tree first visits the root, then the left subtree, and finally the right subtree.","solution":"def can_represent_preorder_bst(arr): Determines if the given array can represent a preorder traversal of a BST. :param arr: List of integers representing the preorder traversal. :return: True if the array can represent a preorder traversal of a BST, False otherwise. stack = [] root = float(\'-inf\') for value in arr: # If we find a node which is on the right side and smaller than root, return False if value < root: return False # If value is in the right subtree of stack\'s top, keep removing items smaller than value while stack and stack[-1] < value: root = stack.pop() stack.append(value) return True"},{"question":"Given a binary tree, determine the depth of the deepest leaf node. The depth of a leaf node is defined as the number of edges from the root node to the leaf node. Return an integer representing the maximum depth of the tree. Example: ```plaintext 3 / 9 20 / 15 7 ``` The maximum depth of the above binary tree is 3.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def maxDepth(root): Returns the maximum depth of the binary tree. :param root: TreeNode, the root of the binary tree :return: int, the maximum depth of the tree if not root: return 0 left_depth = maxDepth(root.left) right_depth = maxDepth(root.right) return 1 + max(left_depth, right_depth)"},{"question":"Given a string `s` containing brackets `(` and `)` only, a valid _parenthesis string_ is defined as: - An empty string `\\"\\"` is valid. - If `A` is a valid string, then `A + A` is valid. - If `A` is a valid string, then `(A)` is valid. You are required to determine whether the input string `s` is a valid parenthesis string. Return `true` if `s` is valid, and `false` otherwise.","solution":"def is_valid_parenthesis_string(s): stack = [] for char in s: if char == \\"(\\": stack.append(char) elif char == \\")\\": if len(stack) == 0: return False stack.pop() return len(stack) == 0"},{"question":"You are given a list of non-negative integers representing the heights of blocks in a histogram. Your task is to find the area of the largest rectangle in the histogram. The width of each block is `1`, and the histogram extends from left to right. Return the maximum area of the rectangle that can be formed in the histogram.","solution":"def largest_rectangle_area(heights): Given a list of non-negative integers representing the heights of blocks in a histogram, finds the area of the largest rectangle in the histogram. Args: heights (List[int]): A list of non-negative integers representing the heights of the blocks. Returns: int: The area of the largest rectangle. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"You are given an array of integers `arr` and an integer `target`. Your task is to determine if there exist two integers in the array such that their sum is equal to `target`. Return `true` if such a pair exists, and `false` otherwise. You must implement a solution with a time complexity better than O(n^2).","solution":"def has_pair_with_sum(arr, target): Determines if there exist two integers in the array such that their sum is equal to the target. :param arr: List of integers. :param target: Target sum. :return: Boolean indicating if there exists a pair with the sum equals to target. complement_set = set() for num in arr: if target - num in complement_set: return True complement_set.add(num) return False"},{"question":"You are given a string `s` containing only lowercase English letters. Your task is to determine the character that appears the most frequently in the string. If there is a tie for the most frequent character, return the one that appears first lexicographically. Return this character as a single character string.","solution":"def most_frequent_character(s): Determines the character that appears the most frequently in the string. If there is a tie, returns the character that is first lexicographically. if not s: return \\"\\" from collections import Counter # Count the frequency of each character frequency = Counter(s) # Find the most frequent character(s) most_frequent = max(frequency.values()) # Find all characters with the highest frequency candidates = [char for char, count in frequency.items() if count == most_frequent] # Return the lexicographically smallest character return min(candidates)"},{"question":"You are given a list of non-negative integers representing the amount of money of each house aligned in a row. Each house uses a smart lock system which is connected to its adjacent houses. Therefore, if one house is broken into, the adjacent houses will automatically lock themselves for security. You cannot rob two adjacent houses. Write a function `rob` that returns the maximum amount of money you can rob tonight without alerting the smart lock system. Function Signature: `def rob(nums: List[int]) -> int:`","solution":"from typing import List def rob(nums: List[int]) -> int: Given a list of non-negative integers representing the amount of money of each house, returns the maximum amount of money you can rob tonight without alerting the smart lock system. if not nums: return 0 if len(nums) == 1: return nums[0] if len(nums) == 2: return max(nums[0], nums[1]) dp = [0] * len(nums) dp[0] = nums[0] dp[1] = max(nums[0], nums[1]) for i in range(2, len(nums)): dp[i] = max(dp[i-1], dp[i-2] + nums[i]) return dp[-1]"},{"question":"Given the root of a binary tree, return a list of all the nodes that are \\"lonely\\". A node is considered \\"lonely\\" if it is the only child of its parent. In other words, a node is lonely if its parent has exactly one child (and that child is the node itself). The order of nodes in the output list does not matter.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find_lonely_nodes(root): Given the root of a binary tree, return a list of all the nodes that are \\"lonely\\". if not root: return [] lonely_nodes = [] def dfs(node): if not node: return if node.left and not node.right: lonely_nodes.append(node.left.val) if not node.left and node.right: lonely_nodes.append(node.right.val) dfs(node.left) dfs(node.right) dfs(root) return lonely_nodes"},{"question":"Given an m x n integer matrix `matrix`, if an element is 0, set its entire row and column to 0. Do it in place. Implement the function `void setZeroes(int[][] matrix)` that modifies the input matrix in place. Example: If the input matrix is: ``` [ [1,1,1], [1,0,1], [1,1,1] ] ``` The matrix should be modified to: ``` [ [1,0,1], [0,0,0], [1,0,1] ] ``` Constraints: - The given matrix will have only non-negative integers.","solution":"def setZeroes(matrix): Modify the input matrix in place such that if an element is 0, all the elements in the corresponding row and column are set to 0. rows, cols = len(matrix), len(matrix[0]) zero_rows, zero_cols = set(), set() # First pass to find all rows and columns that should be zeroed for r in range(rows): for c in range(cols): if matrix[r][c] == 0: zero_rows.add(r) zero_cols.add(c) # Second pass to set the rows to zero for r in zero_rows: for c in range(cols): matrix[r][c] = 0 # Third pass to set the columns to zero for c in zero_cols: for r in range(rows): matrix[r][c] = 0"},{"question":"You are given a string `route` representing the movements of a robot. The robot moves on a 2D plane starting from the origin (0, 0). The string `route` consists of characters representing the following movements: \'U\' for up one unit, \'D\' for down one unit, \'L\' for left one unit, and \'R\' for right one unit. Your task is to determine if the robot returns to the origin after completing all movements in the `route`. Return _`true` if the robot returns to the origin, and `false` otherwise_.","solution":"def is_robot_return_to_origin(route): Determines if the robot returns to the origin position (0, 0) after completing the entire route. :param route: A string representing the movements of a robot. :return: True if the robot returns to the origin, False otherwise. x, y = 0, 0 for move in route: if move == \'U\': y += 1 elif move == \'D\': y -= 1 elif move == \'L\': x -= 1 elif move == \'R\': x += 1 return x == 0 and y == 0"},{"question":"Write a function that takes a string `s` as input and returns true if the brackets in the string are balanced and false otherwise. The string `s` contains only the characters \'(\', \')\', \'{\', \'}\', \'[\' and \']\'. A string is considered balanced if: 1. Every opening bracket has a corresponding closing bracket of the same type. 2. Opening brackets are closed in the correct order, meaning that a closing bracket never appears before the matching opening bracket. Your function should handle the input string efficiently, ensuring that the balance check operates with a time complexity that is linear with respect to the length of the string.","solution":"def is_balanced(s): Returns True if the brackets in the string are balanced, and False otherwise. stack = [] bracket_map = {\')\': \'(\', \'}\': \'{\', \']\': \'[\'} for char in s: if char in bracket_map.values(): stack.append(char) elif char in bracket_map: if stack == [] or bracket_map[char] != stack.pop(): return False else: # Invalid characters or unexpected input return False return stack == []"},{"question":"Given an integer array `A` of length `n` where `0 <= A[i] <= 500` and an integer `K`, return the maximum sum possible from `K` disjoint subsets of `A` such that each subset contains at least one element. Two subsets are disjoint if they do not share any elements. If it is not possible to form such subsets, return 0.","solution":"def max_sum_of_k_disjoint_subsets(A, K): Returns the maximum sum possible from K disjoint subsets of A where each subset contains at least one element. n = len(A) # If there are not enough elements to form K subsets, return 0 if K > n: return 0 # Sort the array in descending order A.sort(reverse=True) # The maximum sum possible from K disjoint subsets would be to take the sum # of the largest K elements from the sorted array. return sum(A[:K])"},{"question":"You are given a string `s` containing digits from \'0\' to \'9\'. Write a function to return the maximum number of unique substrings that can be formed by deleting some or none of the characters in `s`. **Note:** A substring is unique if it does not have any duplicate substring when read from the left or right.","solution":"def max_unique_substrings(s): Returns the maximum number of unique substrings that can be formed by deleting some or none of the characters in the string s. return len(s)"},{"question":"You are given an array of strings `words` and a string `pattern`. You need to return a list of strings found in `words` that match the `pattern`. A string matches the `pattern` if there exists a permutation of letters such that after replacing the letters of the pattern with the permutation, you get one of the strings from `words`. Only the order of letters is relevant; the same letter must match the same character in the pattern and different letters must match different characters. For example, given `words = [\\"abc\\",\\"deq\\",\\"mee\\",\\"aqq\\",\\"dkd\\",\\"ccc\\"]` and `pattern = \\"abb\\"`, the result should be `[\\"mee\\",\\"aqq\\"]`. Write a function `findAndReplacePattern` that accepts `words` and `pattern` and returns the list of matched strings.","solution":"def findAndReplacePattern(words, pattern): def get_pattern(s): mapping = {} result = [] next_char = \'a\' for char in s: if char not in mapping: mapping[char] = next_char next_char = chr(ord(next_char) + 1) result.append(mapping[char]) return \'\'.join(result) pattern_transformed = get_pattern(pattern) result = [] for word in words: if get_pattern(word) == pattern_transformed: result.append(word) return result"},{"question":"You are given a `m x n` matrix `matrix` where each element is either `0` or `1`. A block is defined as a group of `1`s connected horizontally or vertically (not diagonally). Write a function to return the largest block by its size. Implement the `MatrixBlocks` class: * `MatrixBlocks(int[][] matrix)` Initializes the object with the matrix `matrix`. * `int getLargestBlockSize()` Returns the size of the largest block of `1`s in the matrix.","solution":"class MatrixBlocks: def __init__(self, matrix): self.matrix = matrix self.rows = len(matrix) self.cols = len(matrix[0]) if self.rows > 0 else 0 def getLargestBlockSize(self): def dfs(i, j): if i < 0 or i >= self.rows or j < 0 or j >= self.cols or self.matrix[i][j] != 1: return 0 self.matrix[i][j] = -1 # mark as visited size = 1 size += dfs(i + 1, j) size += dfs(i - 1, j) size += dfs(i, j + 1) size += dfs(i, j - 1) return size max_block_size = 0 for i in range(self.rows): for j in range(self.cols): if self.matrix[i][j] == 1: max_block_size = max(max_block_size, dfs(i, j)) return max_block_size"},{"question":"Given a list of integers `nums`, return the length of the longest contiguous subarray such that all elements in the subarray are either strictly increasing or strictly decreasing.","solution":"def longest_contiguous_subarray(nums): Returns the length of the longest contiguous subarray where all elements are either strictly increasing or strictly decreasing. if not nums: return 0 max_len = 1 # At least one element in the list will form a subarray current_len = 1 # Check for strictly increasing for i in range(1, len(nums)): if nums[i] > nums[i - 1]: current_len += 1 else: max_len = max(max_len, current_len) current_len = 1 max_len = max(max_len, current_len) # Reset the current length for checking strictly decreasing current_len = 1 # Check for strictly decreasing for i in range(1, len(nums)): if nums[i] < nums[i - 1]: current_len += 1 else: max_len = max(max_len, current_len) current_len = 1 max_len = max(max_len, current_len) return max_len"},{"question":"You are given a 2D array `grid` representing a grid of obstacles where `1` represents an obstacle and `0` represents a free space. You start at the top-left corner of the grid and can move to any of the 8 adjacent cells (orthogonal and diagonal) but cannot move into obstacles. Your goal is to reach the bottom-right corner of the grid. Return _the length of the shortest path in terms of number of steps to reach the bottom-right corner from the top-left corner_. If there is no such path, return `-1`.","solution":"from collections import deque def shortest_path(grid): Returns the length of the shortest path in terms of number of steps to reach the bottom-right corner from the top-left corner in a grid where 1 represents obstacle and 0 represents free space. Moves can be made to any of the 8 adjacent cells. if not grid or not grid[0] or grid[0][0] == 1 or grid[-1][-1] == 1: return -1 n, m = len(grid), len(grid[0]) directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)] queue = deque([(0, 0, 1)]) grid[0][0] = 1 # Mark the start node as visited while queue: x, y, steps = queue.popleft() if x == n - 1 and y == m - 1: return steps for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] == 0: queue.append((nx, ny, steps + 1)) grid[nx][ny] = 1 # Mark the node as visited return -1"},{"question":"You are given a list of integers `nums` where the integers appear in pairs except for one integer that appears only once. In other words, every element in the list appears exactly twice, except for one element which appears only once. Find this single integer. Your solution should have a linear runtime complexity and use only a constant amount of extra space. Implement a function `findUnique(nums: List[int]) -> int` that returns the integer that appears only once.","solution":"from typing import List def findUnique(nums: List[int]) -> int: This function finds the single integer that appears only once in the list where every other integer appears exactly twice. The solution uses bitwise XOR to achieve O(n) runtime complexity and O(1) space complexity. unique_number = 0 for num in nums: unique_number ^= num return unique_number"},{"question":"You are given an array `nums` consisting of `n` positive integers. You are allowed to perform the following operation **any** number of times: - Select any two **adjacent** elements and replace both of them with their **Greatest Common Divisor (GCD)**. Your goal is to minimize the sum of the elements in the array after performing the operation any number of times. Return _the **minimum** possible sum of the array after any number of operations_.","solution":"from math import gcd from functools import reduce def min_possible_sum(nums): Returns the minimum possible sum of the array after performing the operation any number of times. The operation involves selecting any two adjacent elements and replacing both of them with their GCD. if not nums: return 0 return reduce(gcd, nums) * len(nums)"},{"question":"You are given a string `s` consisting of lowercase English letters. A good subsequence of `s` is a subsequence that contains all the vowels (\'a\', \'e\', \'i\', \'o\', \'u\') at least once. Your task is to find and return the length of the longest good subsequence of `s`. If no good subsequence exists, return -1. A subsequence is a sequence that can be derived from another string by deleting some or no elements without changing the order of the remaining elements.","solution":"def longest_good_subsequence(s): Returns the length of the longest good subsequence of s. A good subsequence must contain all vowels (\'a\', \'e\', \'i\', \'o\', \'u\') at least once. vowels = {\'a\', \'e\', \'i\', \'o\', \'u\'} found_vowels = set() for char in s: if char in vowels: found_vowels.add(char) # If we found all the vowels if len(found_vowels) == 5: break if len(found_vowels) == 5: return len(s) else: return -1"},{"question":"You have a list of strings `words` and a target string `target`. Your task is to find and return all words from the list that can be formed by reordering the characters in `target`. A word from `words` can be used multiple times. Each word in the list is case-sensitive. For example, given `words = [\\"bat\\", \\"tab\\", \\"rat\\", \\"tar\\", \\"star\\"]` and `target = \\"tba\\"`, the function should return `[\\"bat\\", \\"tab\\"]` since both \\"bat\\" and \\"tab\\" can be formed by rearranging the characters of `target`.","solution":"def find_anagrams(words, target): Returns a list of words from the input list that can be formed by reordering the characters in target. Parameters: words (list): A list of strings. target (str): The target string whose characters can be reordered. Returns: list: A list of words that can be formed by reordering the characters in target. from collections import Counter target_counter = Counter(target) result = [] for word in words: if Counter(word) == target_counter: result.append(word) return result"},{"question":"You are given an integer array `nums` and an integer `target`. Your task is to determine if there are **two distinct indices** `i` and `j` in the array such that `nums[i] + nums[j] = target`, and the **absolute difference** between `i` and `j` is at most `k`. Return `true` if such elements exist, otherwise return `false`.","solution":"def containsNearbySum(nums, target, k): Determines if there are two distinct indices i and j in the array such that nums[i] + nums[j] = target and the absolute difference between i and j is at most k. Args: nums: List[int] - List of integers. target: int - The target sum. k: int - The maximum allowed absolute difference between indices. Returns: bool - True if such elements exist, otherwise False. num_dict = {} for i, num in enumerate(nums): if (target - num) in num_dict: for j in num_dict[target - num]: if abs(i - j) <= k: return True if num in num_dict: num_dict[num].append(i) else: num_dict[num] = [i] return False"},{"question":"You are given a list of `n` non-negative integers representing the amount of rainwater trapped after it rains, where each integer represents the height of the bars in a histogram. Write an algorithm to compute the total amount of rainwater trapped.","solution":"def trap(height): Computes the total amount of rainwater trapped after it rains. :param height: List of non-negative integers representing the height of the bars. :type height: List[int] :return: Total amount of trapped rainwater. :rtype: int n = len(height) if n == 0: return 0 left_max = [0] * n right_max = [0] * n water_trapped = 0 # Fill left_max array left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) # Fill right_max array right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) # Calculate the total water trapped for i in range(n): water_trapped += min(left_max[i], right_max[i]) - height[i] return water_trapped"},{"question":"Given an integer array `nums`, move all instances of a specific value `val` to the end of the array while maintaining the relative order of the other elements. You must do this in-place and in O(n) time complexity. Return the modified array after moving the elements.","solution":"def move_value_to_end(nums, val): Given an array nums and a value val, move all instances of val to the end of the array while maintaining the relative order of the other elements. :param nums: List[int] - The list of integers :param val: int - The value to be moved to the end of the array :return: List[int] - The modified array last_non_val_index = 0 # Traverse through the array for i in range(len(nums)): if nums[i] != val: nums[last_non_val_index] = nums[i] last_non_val_index += 1 # Fill the remaining positions with val for i in range(last_non_val_index, len(nums)): nums[i] = val return nums"},{"question":"Given an integer array `arr` and an integer `m`, return _the length of the **longest subarray** where the sum of its elements is at most `m`_. For example, for `arr = [1, 2, 3, 4, 5]` and `m = 7`, the longest subarray could be `[1, 2, 3]` or `[3, 4]`, each with a sum of `6` or `7` respectively. The length of the longest subarray in this case would be `3`.","solution":"def longest_subarray_with_sum_at_most_m(arr, m): Returns the length of the longest subarray where the sum of its elements is at most m. max_length = 0 current_sum = 0 start = 0 for end in range(len(arr)): current_sum += arr[end] while current_sum > m and start <= end: current_sum -= arr[start] start += 1 max_length = max(max_length, end - start + 1) return max_length"},{"question":"You are given a string `s` that consists of lowercase English letters and some parentheses `\'(\'` and `\')\'`. You need to remove the minimum number of parentheses (either \'(\' or \')\') so that the resulting string is valid. A string is considered valid if it is empty or: - It can be written as `AB` (A concatenated with B), where `A` and `B` are valid strings. - It can be written as `(A)`, where `A` is a valid string. Return the resulting string after removing the minimum number of parentheses.","solution":"def minRemoveToMakeValid(s): Removes the minimum number of parentheses to make the string valid. Parameters: s (str): The string containing lowercase letters and parentheses. Returns: str: The resulting valid string. to_remove = set() stack = [] # Traverse the string to find misplaced parentheses. for i, char in enumerate(s): if char == \'(\': stack.append(i) elif char == \')\': if stack: stack.pop() else: to_remove.add(i) # Add any remaining \'(\' to the set of indices to remove. while stack: to_remove.add(stack.pop()) # Build the resulting string. result = [] for i, char in enumerate(s): if i not in to_remove: result.append(char) return \'\'.join(result)"},{"question":"You are given a sequence of integers representing the height of buildings in a row. Your task is to find the maximum area of a rectangle that can be formed using contiguous buildings with varying heights. Each building\'s width is `1`. Return the maximum area of the rectangle that can be formed.","solution":"def largest_rectangle_area(heights): Returns the maximum area of a rectangle that can be formed using contiguous buildings of varying heights. Each building has a width of 1. :param heights: List[int] - List of integers representing the heights of buildings. :return: int - The maximum area of a rectangle. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"In a binary tree, the path weight of a node is defined as the sum of all node values along the path from the root to that node (including the node itself). Given a binary tree, return the maximum path weight among all leaf nodes. For example, in the tree: ``` 10 / 2 10 / 20 1 -25 / 3 4 ``` The leaf nodes are `20`, `1`, `3`, and `4`. The path weights for these leaf nodes are `32`, `13`, `18`, and `19` respectively. The maximum path weight is `32`, which corresponds to the leaf node `20`.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def max_path_weight(root): def helper(node, current_sum): if not node: return float(\'-inf\') # return negative infinity to ignore non-existent nodes current_sum += node.value if not node.left and not node.right: # if it\'s a leaf node return current_sum return max(helper(node.left, current_sum), helper(node.right, current_sum)) return helper(root, 0)"},{"question":"You are given an array of integers `arr`, and an integer `k`. Your task is to find the number of unique substrings of length `k` in `arr` where each substring contains at least one odd number. Return the number of such unique substrings.","solution":"def count_unique_substrings_with_odd(arr, k): Returns the number of unique substrings of length k in arr where each substring contains at least one odd number. unique_substrings = set() for i in range(len(arr) - k + 1): substring = tuple(arr[i:i+k]) if any(x % 2 != 0 for x in substring): unique_substrings.add(substring) return len(unique_substrings)"},{"question":"You are given a list of `courses`, where `courses[i] = [course_i, prerequisite_i]` indicates that you must take course `prerequisite_i` before taking course `course_i`. Assume there are a total of `n` courses numbered from `0` to `n-1`. Write a function to determine if it is possible to finish all courses. Return `true` if you can finish all the courses, otherwise return `false`.","solution":"def can_finish(num_courses, prerequisites): Returns true if it\'s possible to finish all courses given the list of prerequisites, otherwise returns false. from collections import defaultdict, deque # Create an adjacency list for the graph representation adj_list = defaultdict(list) in_degree = [0] * num_courses # Build the graph for dest, src in prerequisites: adj_list[src].append(dest) in_degree[dest] += 1 # Find all the courses with no prerequisites queue = deque([i for i in range(num_courses) if in_degree[i] == 0]) # Counter for number of courses that have been processed processed_courses = 0 while queue: course = queue.popleft() processed_courses += 1 for neighbor in adj_list[course]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) # If all courses have been processed, return True, otherwise return False return processed_courses == num_courses"},{"question":"You are given an integer array `nums` consisting of `n` positive integers. A subarray of `nums` is a contiguous sequence of elements within `nums`. The **sum difference** of a subarray is defined as the difference between the maximum value and the minimum value within that subarray. Given an integer `k`, return _the maximum possible **sum difference** of any subarray of length_ `k` _within_ `nums`.","solution":"def max_sum_difference(nums, k): Finds the maximum possible sum difference of any subarray of length k. Args: nums (list): List of integers. k (int): Length of the subarray. Returns: int: The maximum possible sum difference of any subarray of length k. n = len(nums) max_diff = float(\'-inf\') for i in range(n - k + 1): subarray = nums[i:i+k] current_diff = max(subarray) - min(subarray) if current_diff > max_diff: max_diff = current_diff return max_diff"},{"question":"You are given a list of `n` integers representing daily stock prices over a period of `n` days. Develop an algorithm to find out the maximum profit you can achieve if you are allowed to buy and sell the stock only once. Note that you cannot sell a stock before you buy one. Write a function `maxProfit(prices)` that returns the maximum profit possible, or `0` if no profit can be achieved.","solution":"def maxProfit(prices): Returns the maximum profit from buying and selling the stock once. :param prices: List[int] - List representing daily stock prices. :return: int - Maximum profit possible, or 0 if no profit can be achieved. if not prices: return 0 min_price = float(\'inf\') max_profit = 0 for price in prices: # Update the minimum price observed so far if price < min_price: min_price = price # Calculate potential profit at current price and update max profit potential_profit = price - min_price if potential_profit > max_profit: max_profit = potential_profit return max_profit"},{"question":"You are given a directed acyclic graph (DAG) with `n` nodes labeled from `0` to `n-1`, and a list of `edges` where `edges[i] = [ui, vi, weighti]` represents a directed edge from node `ui` to node `vi` with an associated weight `weighti`. You are also given an integer `start` representing the starting node. Find the shortest path from the `start` node to all other nodes in the graph. If a node `j` is not reachable from the `start` node, return `-1` for that node. Return an array `dist` where `dist[j]` is the shortest distance from the `start` node to node `j` or `-1` if node `j` is not reachable.","solution":"import heapq from typing import List def shortest_path_in_dag(n: int, edges: List[List[int]], start: int) -> List[int]: Calculates the shortest path from the start node to all other nodes in a DAG. :param n: Number of nodes in the graph :param edges: List of edges where each edge is represented as [ui, vi, weighti] :param start: The starting node :return: List of shortest distances from start to each node, or -1 if a node is not reachable graph = {i: [] for i in range(n)} for ui, vi, weighti in edges: graph[ui].append((vi, weighti)) dist = [float(\'inf\')] * n dist[start] = 0 heap = [(0, start)] while heap: current_dist, u = heapq.heappop(heap) if current_dist > dist[u]: continue for v, weight in graph[u]: if dist[u] + weight < dist[v]: dist[v] = dist[u] + weight heapq.heappush(heap, (dist[v], v)) return [d if d != float(\'inf\') else -1 for d in dist]"},{"question":"You are given an array `points` where `points[i] = [xi, yi]` represents the coordinates of a point on a 2D plane. The `k` closest points to the origin `(0, 0)` are those points whose Euclidean distance to the origin is minimal. Implement a class `KClosestPoints` which includes the following methods: * `KClosestPoints(int[][] points, int k)`: Initializes the class with the array of points and the integer k. * `List<int[]> getKClosest()`: Returns the list of k closest points to the origin sorted by their distance to the origin. If two points have the same distance, the point with the smaller x-coordinate should appear first. If the x-coordinates are identical, the point with the smaller y-coordinate should come first.","solution":"from typing import List import heapq class KClosestPoints: def __init__(self, points: List[List[int]], k: int): self.points = points self.k = k def getKClosest(self) -> List[List[int]]: Returns the list of k closest points to the origin sorted by their distance to the origin. # Define a lambda to compute the Euclidean distance squared from the origin for a point def distance_squared(point): return point[0]**2 + point[1]**2 # Use a heap to get the k smallest distances heap = [] for point in self.points: # Add tuples of (distance squared, x coordinate, y coordinate) to the heap heapq.heappush(heap, (distance_squared(point), point)) # Extract the k closest points and sort by distance, and then lexicographically by (x, y) if distances are the same closest_points = [heapq.heappop(heap)[1] for _ in range(self.k)] closest_points.sort(key=lambda point: (distance_squared(point), point[0], point[1])) return closest_points"},{"question":"You are given an array of integers `nums`. A subsequence of `nums` is called **increasing** if it has at least 2 elements and the elements are in strictly increasing order. Find the length of the **longest** increasing subsequence that can be derived by removing some or no elements from `nums`. Return the length of this longest increasing subsequence. Example: Given `nums = [10, 9, 2, 5, 3, 7, 101, 18]`, the longest increasing subsequence is `[2, 3, 7, 101]`, so the function should return `4`. Note: The subsequence does not need to be consecutive elements of the array; it just needs to maintain the increasing order.","solution":"def length_of_lis(nums): Returns the length of the longest increasing subsequence in the array nums. if not nums: return 0 # Initialize DP array where dp[i] represents the length of the longest # increasing subsequence that ends with nums[i] dp = [1] * len(nums) # Build the dp array for i in range(1, len(nums)): for j in range(i): if nums[i] > nums[j]: dp[i] = max(dp[i], dp[j] + 1) # The length of the longest increasing subsequence is the maximum value in dp array return max(dp)"},{"question":"Given an integer array `heights` representing the heights of a series of buildings along a straight line, return the maximum water that can be trapped between any two buildings. Each pair of adjacent buildings is separated by a unit distance. The amount of water trapped between the `i-th` and `j-th` buildings (where `i < j`) is equal to `(j - i) * min(heights[i], heights[j])`.","solution":"def max_trapped_water(heights): Returns the maximum water that can be trapped between any two buildings. heights: List[int] - heights of the buildings return: int - maximum amount of water trapped if not heights: return 0 max_water = 0 left = 0 right = len(heights) - 1 while left < right: width = right - left height = min(heights[left], heights[right]) current_water = width * height max_water = max(max_water, current_water) # Move the pointers if heights[left] < heights[right]: left += 1 else: right -= 1 return max_water"},{"question":"Given a list of non-negative integers `nums`, you can perform the following operation any number of times: * Pick the largest element and reduce it by any value that is a power of 2 (the value must be less than or equal to the largest element). Return the minimum possible value of the largest element in the list after performing the above operation any number of times.","solution":"def min_possible_largest(nums): while any(num > 0 for num in nums): max_num = max(nums) if max_num == 0: break max_index = nums.index(max_num) power_of_2 = 1 while power_of_2 * 2 <= max_num: power_of_2 *= 2 nums[max_index] -= power_of_2 return max(nums)"},{"question":"Given an integer array `nums` and an integer `k`, return _the number of distinct substrings in `nums` that have an exact sum of_ `k`. A substring is a contiguous sequence of numbers within the array. For example: - If `nums` is `[1, 2, 3, 4]` and `k` is `3`, the possible substrings are `[1, 2]` and `[3]`, so the result would be `2`. - If `nums` is `[1, 1, 1, 1]` and `k` is `2`, there are the substrings `[1, 1]`, `[1, 1]`, and `[1, 1]`, but since we are looking for distinct substrings, the result would be `1`.","solution":"def count_distinct_subarrays_with_sum_k(nums, k): Returns the number of distinct subarrays in nums that have an exact sum of k. n = len(nums) distinct_subarrays = set() for start in range(n): current_sum = 0 subarray = [] for end in range(start, n): current_sum += nums[end] subarray.append(nums[end]) if current_sum == k: distinct_subarrays.add(tuple(subarray)) elif current_sum > k: break return len(distinct_subarrays)"},{"question":"You are given a string `s` that consists of lowercase English letters and an integer `k`. You can choose any character of the string and change it to any other lowercase English letter at most `k` times. Your task is to find the length of the longest substring containing the same letter after making the changes. Implement the `CharacterReplacement` class: - `CharacterReplacement()`: Initializes the object. - `int longestSubstringWithSameLetter(String s, int k)`: Returns an integer representing the length of the longest possible substring containing the same letter after performing the allowed changes.","solution":"from collections import defaultdict class CharacterReplacement: def __init__(self): pass def longestSubstringWithSameLetter(self, s: str, k: int) -> int: left = 0 max_length = 0 max_count = 0 count = defaultdict(int) for right in range(len(s)): count[s[right]] += 1 max_count = max(max_count, count[s[right]]) if (right - left + 1) - max_count > k: count[s[left]] -= 1 left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"You are given a **0-indexed** array `arr` consisting of `n` integers, and an integer `d`. An array is called **arithmetic with difference d** if the difference between consecutive elements is equal to `d`. For example, `arr = [2, 4, 6, 8]` is arithmetic with difference `d = 2` because the difference between each consecutive elements is `2`. However, `arr = [1, 3, 6, 7]` is not arithmetic with difference `d = 1` because the difference between `3` and `6` is `3`, which is not equal to `1`. In one **operation**, you can choose an index `i` and **change** `arr[i]` to any integer. Return _the **minimum number of operations** required to make the array arithmetic with difference `d`_.","solution":"def min_operations_to_arithmetic(arr, d): Returns the minimum number of operations required to make the array arithmetic with difference d. Parameters: arr (list of int): The input array. d (int): The required difference between consecutive elements. Returns: int: The minimum number of operations required. n = len(arr) if n <= 1: return 0 change_count = 0 for i in range(1, n): expected_value = arr[i - 1] + d if arr[i] != expected_value: change_count += 1 arr[i] = expected_value # Assuming we change the values in place for easy calculation return change_count"},{"question":"You are given a string `s` consisting of lowercase English letters. You can perform a series of moves on the string where in each move you can select any character and move it to the end of the string. Find and return the lexicographically smallest string that can be obtained after performing any number of moves.","solution":"def lexicographically_smallest_string(s): Returns the lexicographically smallest string that can be obtained by moving characters to the end of the string. return \'\'.join(sorted(s))"},{"question":"Given a `1-indexed` array of integers `arr` where `arr[i]` is the amount of money the `i-th` person has, return _the number of ways to split this array into three contiguous subarrays, such that the sum of each subarray is **strictly greater** than the sum of the previous subarray_. A subarray is a contiguous non-empty sequence of elements within an array.","solution":"def ways_to_split(arr): n = len(arr) if n < 3: return 0 total_ways = 0 for i in range(1, n-1): for j in range(i+1, n): left_sum = sum(arr[:i]) middle_sum = sum(arr[i:j]) right_sum = sum(arr[j:]) if left_sum < middle_sum < right_sum: total_ways += 1 return total_ways"},{"question":"You are given a string `s` and an integer `k`. Find the length of the longest substring of `s` that contains at most `k` distinct characters. If `k` is zero or if the string is empty, return 0. Your solution should have a time complexity of O(n).","solution":"def length_of_longest_substring_k_distinct(s, k): if k == 0 or not s: return 0 char_frequency = {} left = 0 max_length = 0 for right in range(len(s)): right_char = s[right] if right_char not in char_frequency: char_frequency[right_char] = 0 char_frequency[right_char] += 1 while len(char_frequency) > k: left_char = s[left] char_frequency[left_char] -= 1 if char_frequency[left_char] == 0: del char_frequency[left_char] left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"Given an array of integers `nums`, return the number of contiguous subarrays that have a sum equal to a given integer `target`.","solution":"def subarray_sum(nums, target): Returns the number of contiguous subarrays that have a sum equal to the given target. :param nums: List[int] - The input array of integers :param target: int - The sum that each contiguous subarray should equal to :return: int - The number of contiguous subarrays that sum up to the target count = 0 sum_so_far = 0 hashmap = {0: 1} for num in nums: sum_so_far += num if sum_so_far - target in hashmap: count += hashmap[sum_so_far - target] if sum_so_far in hashmap: hashmap[sum_so_far] += 1 else: hashmap[sum_so_far] = 1 return count"},{"question":"You are given a grid of size `m x n` consisting of `\'1\'`s (land) and `\'0\'`s (water). An **island** is a group of `\'1\'`s connected **4-directionally** (horizontal or vertical). A **closed island** is an island **totally (all left, top, right, bottom sides) surrounded by `\'0\'`s**. You may assume all four edges of the grid are completely surrounded by water. Return _the number of **closed islands**_. [Question 4]:","solution":"def closedIsland(grid): def dfs(i, j): if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]): return False if grid[i][j] == 1: return True grid[i][j] = 1 # mark it as visited (sink the island) top = dfs(i - 1, j) bottom = dfs(i + 1, j) left = dfs(i, j - 1) right = dfs(i, j + 1) return top and bottom and left and right if not grid: return 0 closed_islands_count = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 0 and dfs(i, j): closed_islands_count += 1 return closed_islands_count"},{"question":"Given a string `s` consisting of `n` characters, where each character is either \'L\' or \'R\', divide the string into as many balanced substrings as possible. A balanced substring is defined as a substring that has an equal number of \'L\' and \'R\' characters. Return the maximum number of balanced substrings possible.","solution":"def balanced_string_split(s): Returns the maximum number of balanced substrings possible. A balanced substring has an equal number of \'L\' and \'R\' characters. balance_count = 0 total_balanced = 0 for char in s: if char == \'L\': balance_count += 1 elif char == \'R\': balance_count -= 1 if balance_count == 0: total_balanced += 1 return total_balanced"},{"question":"Given a string `s` and a list of strings `dict`, you need to find and return the longest string in `dict` that can be formed by deleting some characters of the given string `s` without reordering the remaining characters. If there are multiple results, return the longest word with the smallest lexicographical order. If there is no possible result, return an empty string.","solution":"def find_longest_word(s, dict): def can_form_by_deleting(word): it = iter(s) return all(char in it for char in word) # Sort by length (desc) and then lexicographical order (asc) dict.sort(key=lambda x: (-len(x), x)) for word in dict: if can_form_by_deleting(word): return word return \\"\\""},{"question":"You are given a string `s` consisting of digits and a non-negative integer `d`. Your task is to determine the minimum number of changes needed to make `s` divisible by `d`. Each change involves replacing one digit in the string with any other digit from `0` to `9`. Return an integer representing the minimum number of changes required.","solution":"def min_changes_to_make_divisible(s, d): Determine the minimum number of changes required to make the string of digits `s` divisible by `d`. Parameters: - s: str, input string consisting of digits. - d: int, a non-negative integer. Returns: - int, minimum number of changes required. num = int(s) if num % d == 0: return 0 min_changes = len(s) for i in range(len(s)): original_digit = s[i] for new_digit in \'0123456789\': if new_digit != original_digit: new_s = s[:i] + new_digit + s[i+1:] if int(new_s) % d == 0: min_changes = min(min_changes, 1) return min_changes"},{"question":"You are given an array `tasks` where `tasks[i]` represents the processing time of the `i-th` task. Each task is assigned to one of two available servers. You need to distribute the tasks between the two servers such that the difference between the total processing times of the two servers is minimized. Return the minimum difference possible after distributing all the tasks between the two servers.","solution":"def min_difference(tasks): Returns the minimum difference possible after distributing all the tasks between the two servers. total_sum = sum(tasks) n = len(tasks) half_sum = total_sum // 2 dp = [[False] * (half_sum + 1) for _ in range(n + 1)] dp[0][0] = True for i in range(1, n + 1): for j in range(half_sum + 1): dp[i][j] = dp[i-1][j] if j >= tasks[i-1]: dp[i][j] = dp[i][j] or dp[i-1][j-tasks[i-1]] for j in range(half_sum, -1, -1): if dp[n][j]: return total_sum - 2 * j"},{"question":"We define a **smooth number** as a positive integer whose prime factors are all less than or equal to `p`. Given a positive integer `n` and a prime number `p`, return _the number of smooth numbers that are less than or equal to_ `n`.","solution":"def sieve_of_eratosthenes(max_number): is_prime = [True] * (max_number + 1) p = 2 while p * p <= max_number: if is_prime[p]: for i in range(p * p, max_number + 1, p): is_prime[i] = False p += 1 return [p for p in range(2, max_number + 1) if is_prime[p]] def count_smooth_numbers(n, p): primes = sieve_of_eratosthenes(p) smooth_numbers = set() def generate_smooth_numbers(current_product, start): if current_product > n: return smooth_numbers.add(current_product) for i in range(start, len(primes)): next_product = current_product * primes[i] generate_smooth_numbers(next_product, i) generate_smooth_numbers(1, 0) return len(smooth_numbers) - 1 # Exclude the number 1 itself # Example usage: # n = 10, p = 3, smooth numbers <= 10 are: 1, 2, 3, 4, 6, 8, 9. Total: 6 (excluding 1) # count_smooth_numbers(10, 3) => 6"},{"question":"Given a string `s`, write a function to determine if it is a permutation of a palindrome. A palindrome is a word or phrase that reads the same forwards and backwards (ignoring spaces, punctuation, and capitalization). A permutation is a rearrangement of letters. The function should return `true` if the string is a permutation of a palindrome and `false` otherwise.","solution":"def is_palindrome_permutation(s): Determines if the given string is a permutation of a palindrome. Parameters: s (str): The input string. Returns: bool: True if the string is a permutation of a palindrome, False otherwise. from collections import Counter # Remove non-alphanumeric characters and convert to lowercase. cleaned_str = \'\'.join(filter(str.isalnum, s)).lower() # Count frequency of each character. char_count = Counter(cleaned_str) # Check the number of characters with odd counts. odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # At most one character with an odd count is allowed for a permutation of a palindrome. return odd_count <= 1"},{"question":"Given an array of integers `nums` representing the cost of climbing stairs, where `nums[i]` is the cost of step `i`, you can either climb one or two steps. Return the minimum cost to reach the top of the floor. You start either from step `0` or step `1`.","solution":"def minCostClimbingStairs(nums): Returns the minimum cost to reach the top of the floor. Args: nums: A list of integers representing the cost of climbing stairs. Returns: An integer representing the minimum cost to reach the top. n = len(nums) if n == 0: return 0 if n == 1: return nums[0] dp = [0] * n dp[0] = nums[0] dp[1] = nums[1] for i in range(2, n): dp[i] = min(dp[i-1], dp[i-2]) + nums[i] return min(dp[-1], dp[-2])"},{"question":"# **Question 4**: You are given an array of integers `nums` where each integer appears exactly three times, except for one integer which appears exactly once. Write a function to find and return the single integer that appears only once. For example, if `nums = [2, 2, 3, 2, 4, 4, 4, 5, 5, 5, 1]`, the single integer is `3`. Return _the single integer that appears only once_.","solution":"def single_number(nums): Function to find the single integer in the array where every other integer appears exactly three times. Parameters: nums (list of int): The array of integers. Returns: int: The single integer that appears only once. ones, twos = 0, 0 for num in nums: ones = (ones ^ num) & ~twos twos = (twos ^ num) & ~ones return ones"},{"question":"Given an integer `n` representing the number of nodes in a **binary search tree (BST)** and an array `preorder` of length `n` containing the preorder traversal of the BST, construct the BST and return _the inorder traversal of its nodes\' values_.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def bstFromPreorder(preorder): if not preorder: return None def buildBST(preorder, lower, upper): if not preorder or preorder[0] < lower or preorder[0] > upper: return None value = preorder.pop(0) root = TreeNode(value) root.left = buildBST(preorder, lower, value) root.right = buildBST(preorder, value, upper) return root return buildBST(preorder, float(\'-inf\'), float(\'inf\')) def inorderTraversal(root): if not root: return [] return inorderTraversal(root.left) + [root.val] + inorderTraversal(root.right) def bstFromPreorderInorderTraversal(preorder): root = bstFromPreorder(preorder[:]) return inorderTraversal(root)"},{"question":"You are given a list of tuples where each tuple represents the coordinates of a point in a 2D plane. Each coordinate is an integer. Your task is to find the number of pairs of points that form a line parallel to the Y-axis. A pair of points (x1, y1) and (x2, y2) form a line parallel to the Y-axis if and only if x1 = x2. Return the total number of such pairs of points. Input: - A list of tuples representing the coordinates of points in the 2D plane. Output: - An integer representing the number of pairs of points that form vertical lines.","solution":"def count_vertical_pairs(points): from collections import defaultdict # Dictionary to store counts of each x-coordinate x_count = defaultdict(int) # Count each x-coordinate appearance in the list of points for x, y in points: x_count[x] += 1 # Calculate the number of pairs that form vertical lines pairs = 0 for count in x_count.values(): if count > 1: # If there are n points with the same x-coordinate, # the number of ways to choose 2 out of these n points is nC2 = n*(n-1)/2 pairs += count * (count - 1) // 2 return pairs"},{"question":"You are given a string `s` and an array of strings `dictionary`. You need to replace the words in `s` that match any word in `dictionary` with the word version surrounded by asterisks (*). Note that a word is defined as a sequence of characters separated by spaces, and the case of the words in the string `s` or the `dictionary` should be ignored during matching. Return the resulting string after performing the replacements.","solution":"def replace_words(s, dictionary): Replace words in string s that match any word in dictionary with the word surrounded by asterisks (*). The case is ignored during matching. Parameters: s (str): The input string. dictionary ([str]): List of words to be replaced. Returns: str: The resulting string after replacements. words = s.split() lower_dictionary = {word.lower() for word in dictionary} for i in range(len(words)): if words[i].lower() in lower_dictionary: words[i] = \'*\' + words[i] + \'*\' return \' \'.join(words)"},{"question":"Given an array of integers `nums` sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears at most twice while maintaining the relative order of the elements. Do not allocate extra space for another array; you must do this by modifying the input array in-place with O(1) extra memory. For example, given `nums = [1, 1, 1, 2, 2, 3]`, your function should modify the array to `nums = [1, 1, 2, 2, 3]` and return the new length of the array.","solution":"def remove_duplicates(nums): Removes duplicates in-place such that each unique element appears at most twice. :param nums: List of sorted integers :return: The new length of the array after removing duplicates if len(nums) < 3: return len(nums) # Start from the third element in the array write_position = 2 for i in range(2, len(nums)): if nums[i] != nums[write_position - 2]: nums[write_position] = nums[i] write_position += 1 return write_position"},{"question":"Given an array of positive integers `arr` representing the heights of columns where the width of each column is 1, find the two columns that together with the x-axis forms a container such that the container contains the most water. Return the maximum amount of water a container can store. The height of the water contained by the container is determined by the shorter column. You need to find the maximum area formed between two columns and output the maximum area.","solution":"def max_area(height): Finds the maximum area of water that can be contained by two columns and the x-axis. Parameters: height (List[int]): List of integers representing the heights of columns. Returns: int: The maximum area of water that can be contained. left = 0 right = len(height) - 1 max_area = 0 while left < right: # Calculate the width and the height of the current container width = right - left current_height = min(height[left], height[right]) # Calculate the area of the current container current_area = width * current_height # Update the maximum area if necessary max_area = max(max_area, current_area) # Move the pointer pointing to the shorter column inward if height[left] < height[right]: left += 1 else: right -= 1 return max_area"},{"question":"You are given an array `heights` representing the heights of columns where the width of each column is `1`. The array `heights` is such that `heights[i]` is the height of the `i-th` column. The \\"water\\" is poured into the columns and can fill the gaps between the columns. Design an algorithm to find how much water can be trapped between all the columns. **Note**: The water trapped in a gap is limited by the height of the shorter column on either side of the gap. Return _the total amount of water that can be trapped between the columns_.","solution":"def trap(height): Compute how much water can be trapped between the columns of varying heights. :param List[int] height: List of integers representing the heights of columns :return int: The total amount of water that can be trapped between the columns. if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) water_trapped = 0 for i in range(n): water_trapped += min(left_max[i], right_max[i]) - height[i] return water_trapped"},{"question":"You are given an integer array `heights` representing the heights of students line up in a row, from left to right, and the number of students `n`. Write a function to return the minimum number of students that must move to make the heights array non-decreasing. In other words, find the minimum number of students that must move so that each height is less than or equal to the height to its right. Note that it\'s acceptable for any student to move anywhere in the lineup.","solution":"def min_moves_to_non_decreasing(heights): # Find the longest non-decreasing subsequence n = len(heights) if n == 0: return 0 dp = [1] * n for i in range(1, n): for j in range(i): if heights[i] >= heights[j]: dp[i] = max(dp[i], dp[j] + 1) longest_non_decreasing_subseq = max(dp) min_moves = n - longest_non_decreasing_subseq return min_moves"},{"question":"Given a list of integers `nums` representing the position of houses along a street and an integer `k` representing the number of mailboxes to be placed, return the minimum total distance between the houses and the mailboxes. The distance between the house at position `i` and the mailbox at position `j` is `|i - j|`. The houses can share the same mailbox.","solution":"def min_total_distance(nums, k): This function returns the minimum total distance between the houses and the mailboxes. Parameters: nums (list): A list of integers representing the position of houses along a street. k (int): An integer representing the number of mailboxes to be placed. Returns: int: The minimum total distance between the houses and the mailboxes. nums.sort() n = len(nums) # Edge case: if number of mailboxes is more or equal to the number of houses if k >= n: return 0 # DP array to store result for subproblems dp = [[float(\'inf\')] * (k+1) for _ in range(n+1)] dp[0][0] = 0 # Cost is the distance for all houses within each mailbox range def compute_cost(l, r): mid = (l + r) // 2 cost = 0 for i in range(l, r+1): cost += abs(nums[i] - nums[mid]) return cost for i in range(1, n+1): for j in range(1, k+1): for p in range(i): dp[i][j] = min(dp[i][j], dp[p][j-1] + compute_cost(p, i-1)) return dp[n][k]"},{"question":"You are given an integer array `prices` representing the prices of goods in a store on different days. You are allowed to pick one day and buy any amount of goods, then pick another day later and sell the goods you bought. You want to maximize your profit. However, there is a restriction: there must be at least two days in between these two days where no transactions occur. Return _the maximum profit you can achieve under these conditions_. If no transactions can yield profit, return 0.","solution":"def max_profit_with_restriction(prices): Returns the maximum profit with the restriction that at least two days must be between the buy and sell days. n = len(prices) if n < 5: return 0 max_profit = 0 min_price_before = [0] * n max_price_after = [0] * n min_price_before[0] = prices[0] for i in range(1, n): min_price_before[i] = min(min_price_before[i - 1], prices[i]) max_price_after[n - 1] = prices[n - 1] for i in range(n - 2, -1, -1): max_price_after[i] = max(max_price_after[i + 1], prices[i]) for j in range(2, n - 2): max_profit = max(max_profit, max_price_after[j + 2] - min_price_before[j - 2]) return max_profit"},{"question":"Given an integer array `arr` and an integer `target`, return _the number of **contiguous subarrays** whose sum is equal to_ `target`. Two subarrays are considered different if they start or end at different indices in the array. Note that `arr` can contain both positive and negative integers.","solution":"def subarray_sum(arr, target): Returns the number of contiguous subarrays whose sum equals the target. count = 0 curr_sum = 0 sum_dict = {0: 1} for num in arr: curr_sum += num if (curr_sum - target) in sum_dict: count += sum_dict[curr_sum - target] if curr_sum in sum_dict: sum_dict[curr_sum] += 1 else: sum_dict[curr_sum] = 1 return count"},{"question":"You are given a string `s` representing a sentence containing words separated by spaces. Each word consists of lowercase and uppercase English letters. Rearrange the words in the sentence such that all words that start with a vowel (a, e, i, o, u, A, E, I, O, U) come before the words that start with a consonant. Preserve the relative order of the words within each group (vowels and consonants). Return the modified sentence as a single string.","solution":"def rearrange_sentence(s): Rearranges the words in the sentence such that all words that start with a vowel come before the words that start with a consonant. Preserves the relative order of the words within each group. Args: s (str): Input sentence. Returns: str: Rearranged sentence. vowels = \\"AEIOUaeiou\\" words = s.split() vowel_words = [word for word in words if word[0] in vowels] consonant_words = [word for word in words if word[0] not in vowels] return \' \'.join(vowel_words + consonant_words)"},{"question":"You are given an `m x n` matrix `grid` containing non-negative integers representing the height of each unit cell in a 2D elevation map. The \\"rain water\\" can flow from each cell to neighboring cells (up, down, left, or right) if and only if the neighboring cell has an elevation less than or equal to the current cell\'s elevation. Assume all four edges of the grid are surrounded by an infinitely high boundary, making the water unable to flow out of the grid. Water can only be trapped within basins formed by the surrounding elevations. Write a function to calculate the total volume of trapped water after sufficient rain. The input matrix `grid` is guaranteed to have at least two rows and two columns.","solution":"import heapq def trapRainWater(grid): Calculate the total volume of water that can be trapped in an m x n elevation map. Args: - grid: List[List[int]]: A 2D list of non-negative integers representing height of each unit cell Returns: - int: Total volume of trapped water if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) visited = [[False] * n for _ in range(m)] heap = [] # Initialize the heap by pushing all the boundary cells for i in range(m): heapq.heappush(heap, (grid[i][0], i, 0)) heapq.heappush(heap, (grid[i][n-1], i, n-1)) visited[i][0] = True visited[i][n-1] = True for j in range(n): heapq.heappush(heap, (grid[0][j], 0, j)) heapq.heappush(heap, (grid[m-1][j], m-1, j)) visited[0][j] = True visited[m-1][j] = True directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] total_water = 0 while heap: height, x, y = heapq.heappop(heap) for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny]: visited[nx][ny] = True total_water += max(0, height - grid[nx][ny]) heapq.heappush(heap, (max(height, grid[nx][ny]), nx, ny)) return total_water"},{"question":"Suppose you are given a table `Employees` with the following schema `Employees(EmployeeId int, DepartmentId int, Salary int)`. Write an SQL query to find the DepartmentId with the highest average salary. If there are multiple departments with the same highest average salary, return all of them. Output the result in a table with a single column `DepartmentId`.","solution":"def highest_avg_salary_department(): SQL query to find the DepartmentId with the highest average salary. Returns the DepartmentId with the highest average salary. query = SELECT DepartmentId FROM Employees GROUP BY DepartmentId HAVING AVG(Salary) = ( SELECT MAX(avg_salary) FROM ( SELECT AVG(Salary) as avg_salary FROM Employees GROUP BY DepartmentId ) AS avg_salaries ) return query"},{"question":"You are given a `list` of integers representing the prices of a stock on different days. You are allowed to complete at most **one transaction** (i.e., buy one and sell one share of the stock). Write a function that determines the maximum profit you can achieve from this transaction. If no profit can be achieved, return 0. The function should take a list of integers `prices` as input and return an integer representing the maximum possible profit. Your function should handle the case where it is not possible to make a positive profit gracefully. You are expected to implement an efficient solution that runs in O(n) time complexity.","solution":"def max_profit(prices): Determine the maximum profit from a single transaction of buying and selling stocks. If no profit is possible, return 0. :param prices: List[int], list of stock prices. :return: int, maximum possible profit. if not prices: return 0 min_price = prices[0] max_profit = 0 for price in prices: if price < min_price: min_price = price profit = price - min_price if profit > max_profit: max_profit = profit return max_profit"},{"question":"You are given a list of strings `words` and a string `prefix`. Each string in `words` consists of lowercase letters only. Define a **trie (prefix tree)** that initially contains all the words from the `words` list. Implement an algorithm that, given the `prefix`, returns the number of words that start with the given `prefix`. Implement the `Trie` class with the following methods: - `Trie(List<String> words)` Initializes the trie with the list of words. - `int countWordsStartingWith(String prefix)` Returns the number of words that start with the given prefix. For example, given `words = [\\"apple\\", \\"ape\\", \\"april\\", \\"appetizer\\"]` and `prefix = \\"ap\\"`, the method `countWordsStartingWith(\\"ap\\")` should return `4`. If the prefix was `\\"app\\"`, it should return `2`.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False self.count = 0 class Trie: def __init__(self, words): self.root = TrieNode() for word in words: self._insert(word) def _insert(self, word): current = self.root for char in word: if char not in current.children: current.children[char] = TrieNode() current = current.children[char] current.count += 1 current.is_end_of_word = True def countWordsStartingWith(self, prefix): current = self.root for char in prefix: if char in current.children: current = current.children[char] else: return 0 return current.count"},{"question":"You are given a list of `n` integers representing the lengths of **n** wooden planks. You can choose any two planks and join them to create a new plank whose length is the sum of the chosen planks. This operation costs an amount equal to the length of the new plank. Your task is to find the minimum total cost required to combine all the given planks into a single plank. Return the minimum cost of this process.","solution":"import heapq def min_cost_to_combine_planks(planks): Given a list of integers representing the lengths of wooden planks, calculates the minimum cost required to combine all the planks into a single plank. The cost of combining two planks is equal to the sum of their lengths. :param planks: List of integers :return: Minimum cost to combine all planks into one if len(planks) <= 1: return 0 # Use a min-heap to always combine the two smallest planks first heapq.heapify(planks) total_cost = 0 while len(planks) > 1: # Combine the two smallest planks first = heapq.heappop(planks) second = heapq.heappop(planks) cost = first + second total_cost += cost # Add the combined plank back into the heap heapq.heappush(planks, cost) return total_cost"},{"question":"You are given an array of integers `nums` representing a collection of unique numbers. A path in the given array can be defined as a sequence of indices such that for any two consecutive indices `i` and `j` in the sequence, the difference `|nums[i] - nums[j]`| is at most one. The length of a path is the number of indices in it. Your task is to determine the length of the longest such path. Return an integer representing the length of the longest path found in the array.","solution":"def longest_path(nums): Returns the length of the longest path where the absolute difference between consecutive elements is at most one. :param nums: List[int] - Array of unique integers :return: int - Length of the longest valid path if not nums: return 0 nums.sort() max_length = 1 current_length = 1 for i in range(1, len(nums)): if abs(nums[i] - nums[i-1]) <= 1: current_length += 1 else: max_length = max(max_length, current_length) current_length = 1 max_length = max(max_length, current_length) return max_length"},{"question":"You are given a **0-indexed** integer array `arr` and an integer `k`. In one operation, you can increase or decrease any element of `arr` by `1`. Return _the minimum number of operations required to make all elements of the array divisible by `k`_.","solution":"def min_operations_to_divisible(arr, k): Returns the minimum number of operations required to make all elements of the array divisible by k. total_operations = 0 # For each element in the array, calculate the remainder when divided by k. for num in arr: remainder = num % k # Calculate the minimum of the remainder and k - remainder. # This gives the minimum number of increments or decrements needed for divisibility. total_operations += min(remainder, k - remainder) return total_operations"},{"question":"You are given a string `s` that consists of lower-case letters and an integer array `charCounts` of length 26, where `charCounts[i]` represents the maximum number of times the i-th letter of the alphabet (0-indexed, \'a\' = 0, \'b\' = 1, ..., \'z\' = 25) can appear in any substring of `s`. Return the length of the longest substring of `s` that satisfies these maximum character count constraints.","solution":"def longest_substring_with_constraints(s, charCounts): Returns the length of the longest substring of s that satisfies the maximum character count constraints provided in charCounts. :param s: The input string consisting of lower-case letters. :param charCounts: A list of length 26 where charCounts[i] represents the maximum number of times the i-th letter of the alphabet can appear in any substring of s. :return: The length of the longest valid substring. from collections import defaultdict left = 0 char_map = defaultdict(int) max_len = 0 for right in range(len(s)): char_map[s[right]] += 1 while char_map[s[right]] > charCounts[ord(s[right]) - ord(\'a\')]: char_map[s[left]] -= 1 left += 1 max_len = max(max_len, right - left + 1) return max_len"},{"question":"Given a list of `n` integers where the integers form a continuous sequence (with possibly some numbers missing), identify the missing number such that the sequence becomes complete. The numbers are unique and the list is unsorted. **Constraints**: - Do not use any extra space - Achieve a time complexity better than O(n^2) Implement the function `findMissingNumber(int[] nums) -> int` that returns the missing number from the sequence.","solution":"def findMissingNumber(nums): Finds the missing number in a continuous sequence of unique integers. Args: nums (list of int): List of integers with one missing number. Returns: int: The missing number in the sequence. n = len(nums) + 1 total_sum = n * (n + 1) // 2 actual_sum = sum(nums) return total_sum - actual_sum"},{"question":"You are given an n x n 2D matrix `grid` representing an island, where grid[i][j] = 1 represents land and grid[i][j] = 0 represents water. The island has exactly one connected land cell sequence forming a closed loop, meaning it forms a path where you can start at any land cell and traverse through the land cells (horizontally or vertically) to return to the starting cell without crossing water cells. You need to find and return the length of the shortest bridge that can be built by flipping one 0 (water) to 1 (land) to connect the island with itself, forming a single continuous land mass.","solution":"from collections import deque def shortest_bridge(grid): Returns the length of the shortest bridge that can be built by flipping one 0 (water) to 1 (land) to connect the island with itself. def neighbors(x, y): for nx, ny in [(x-1, y), (x+1, y), (x, y-1), (x, y+1)]: if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]): yield nx, ny def bfs(queue): visited = set(queue) distance = 0 while queue: for _ in range(len(queue)): x, y = queue.popleft() for nx, ny in neighbors(x, y): if (nx, ny) not in visited: if grid[nx][ny] == 1: return distance queue.append((nx, ny)) visited.add((nx, ny)) distance += 1 def dfs(x, y): if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or grid[x][y] == 0 or (x, y) in visited: return visited.add((x, y)) queue.append((x, y)) for nx, ny in neighbors(x, y): dfs(nx, ny) visited = set() queue = deque() # Find the first island and mark all its land cells found_first_island = False for i in range(len(grid)): if found_first_island: break for j in range(len(grid[0])): if grid[i][j] == 1: dfs(i, j) found_first_island = True break # Perform BFS from all the cells of the first island to find the shortest bridge to the second island return bfs(queue)"},{"question":"Given a string `s`, find the length of the smallest substring that contains the maximum number of distinct characters. The string `s` will contain only lowercase English letters. If the string is empty, return `0`.","solution":"def smallest_substring_max_distinct(s): Returns the length of the smallest substring that contains the maximum number of distinct characters. if not s: return 0 max_distinct_chars = len(set(s)) n = len(s) min_len = n + 1 for i in range(n): seen_chars = set() for j in range(i, n): seen_chars.add(s[j]) if len(seen_chars) == max_distinct_chars: min_len = min(min_len, j - i + 1) break return min_len"},{"question":"Given a grid of size `m x n`, where each cell contains a positive integer representing its height, you are at the top-left cell (0, 0) and your goal is to reach the bottom-right cell (m-1, n-1). You can only move either down or right at any point in time. Return _the **minimum** sum of heights you can accumulate along a path from the top-left to the bottom-right_ cell. If it is impossible to reach the bottom-right cell, return `-1`.","solution":"def min_path_sum(grid): if not grid or not grid[0]: return -1 m, n = len(grid), len(grid[0]) # Create a 2D dp array to store the minimum path sum to reach each cell dp = [[float(\'inf\')] * n for _ in range(m)] dp[0][0] = grid[0][0] # Fill the dp array for i in range(m): for j in range(n): if i > 0: dp[i][j] = min(dp[i][j], dp[i-1][j] + grid[i][j]) if j > 0: dp[i][j] = min(dp[i][j], dp[i][j-1] + grid[i][j]) min_sum = dp[-1][-1] return min_sum if min_sum < float(\'inf\') else -1"},{"question":"Given a string `s` consisting of lowercase English letters, you need to remove the minimum number of characters to make the string a palindrome. Return the **length** of the resulting palindrome. A palindrome is a string that reads the same forward and backward.","solution":"def min_remove_to_palindrome_length(s): Returns the length of the resulting palindrome after removing the minimum number of characters. def longest_palindromic_subsequence_len(s): n = len(s) dp = [[0] * n for _ in range(n)] for i in range(n): dp[i][i] = 1 for cl in range(2, n+1): for i in range(n - cl + 1): j = i + cl - 1 if s[i] == s[j] and cl == 2: dp[i][j] = 2 elif s[i] == s[j]: dp[i][j] = dp[i+1][j-1] + 2 else: dp[i][j] = max(dp[i][j-1], dp[i+1][j]) return dp[0][n-1] longest_palindrome_length = longest_palindromic_subsequence_len(s) return longest_palindrome_length"},{"question":"You are given an array of integers `arr`. Write a function that shifts all the zeros to the end of the array while maintaining the relative order of the non-zero elements. You must do this **in-place** without making a copy of the array. For example, given the array `arr = [0, 1, 0, 3, 12]`, your function should modify the array to be `[1, 3, 12, 0, 0]`.","solution":"def move_zeros(arr): Shifts all the zeros in the array to the end while maintaining the relative order of the non-zero elements. This is done in-place without making a copy of the array. :param arr: List of integers insert_pos = 0 # Initialize the position to insert non-zero elements for num in arr: if num != 0: arr[insert_pos] = num # Place non-zero element at the current insert position insert_pos += 1 # Move insert position to the next index # After all non-zero elements are placed, fill the rest of the array with zeros while insert_pos < len(arr): arr[insert_pos] = 0 insert_pos += 1"},{"question":"Given two arrays `nums1` and `nums2`, where `nums1` is a subset of `nums2`. Find the next greater number for each element in `nums1` in the corresponding places of `nums2`. The Next Greater Number of a number `x` in `nums1` is the first greater number to its right in `nums2`. If it does not exist, return `-1` for this number. Return an array consisting of the next greater number for each element in `nums1`.","solution":"def nextGreaterElement(nums1, nums2): Finds the next greater number for each element in nums1 in the corresponding places of nums2. next_greater = {} stack = [] for num in nums2: while stack and stack[-1] < num: smaller = stack.pop() next_greater[smaller] = num stack.append(num) result = [next_greater.get(x, -1) for x in nums1] return result"},{"question":"You are given a matrix `m` of size `n x n` filled with integers. Rotate the matrix 90 degrees clockwise in place. This means you have to modify the input 2D matrix directly without using an extra 2D matrix. Return the rotated matrix. For example, if the given matrix is: ``` [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] ``` The rotated matrix should be: ``` [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] ```","solution":"def rotate_matrix_90_degrees(m): Rotates the given n x n matrix 90 degrees clockwise in place. :param m: List[List[int]], a 2D list representing the n x n matrix :return: The rotated matrix n = len(m) # Transpose the matrix for i in range(n): for j in range(i, n): m[i][j], m[j][i] = m[j][i], m[i][j] # Reverse each row for i in range(n): m[i].reverse() return m"},{"question":"You are given an undirected graph with `n` nodes labeled from `0` to `n-1` represented as an edge list `edges` where `edges[i] = [u_i, v_i]` denotes an edge between nodes `u_i` and `v_i`. Additionally, you are provided with a 2D integer array `restricted` where `restricted[j]` denotes nodes that are restricted and cannot be visited. You start at node `0` and your goal is to determine the maximum number of nodes you can reach without visiting any restricted node. Return _the maximum number of nodes that can be reached from node `0`_.","solution":"from collections import defaultdict, deque def max_reachable_nodes(n, edges, restricted): Returns the maximum number of nodes that can be reached from node 0 without visiting any restricted nodes. graph = defaultdict(list) restricted_set = set(restricted) for u, v in edges: graph[u].append(v) graph[v].append(u) visited = set() to_visit = deque([0]) reachable_count = 0 while to_visit: node = to_visit.popleft() if node in visited or node in restricted_set: continue visited.add(node) reachable_count += 1 for neighbor in graph[node]: if neighbor not in visited and neighbor not in restricted_set: to_visit.append(neighbor) return reachable_count"},{"question":"Design a data structure that supports the following operations on a list of integers: * `insert(int index, int value)`: Inserts a value at a specific index. * `delete(int index)`: Deletes the value at the specified index. * `get(int index)`: Returns the value at the specified index. * `rotate(int k)`: Rotates the list to the right by `k` steps. Implement the `CustomList` class: * `CustomList()` initializes the `CustomList` object. * `void insert(int index, int value)` inserts the value at the specified index in the list. * `void delete(int index)` deletes the value at the specified index in the list. * `int get(int index)` returns the value at the specified index in the list. * `void rotate(int k)` rotates the list to the right by `k` steps.","solution":"class CustomList: def __init__(self): self.data = [] def insert(self, index, value): self.data.insert(index, value) def delete(self, index): self.data.pop(index) def get(self, index): return self.data[index] def rotate(self, k): if len(self.data) == 0: return k = k % len(self.data) self.data = self.data[-k:] + self.data[:-k]"},{"question":"You are given an array of integers `arr` representing the heights of skyscrapers in a city, and an integer `viewPosition` which represents the position of a person standing in the city. The person can see a skyscraper if there are no taller skyscrapers blocking the view between them and the skyscraper in question. Return an array of all the skyscrapers that the person can see from their position in order of their appearance on the skyline. For example, given `arr = [2, 3, 5, 4, 2, 6]` and `viewPosition = 2`, the person at position `2` can see skyscrapers of heights `[5, 6]`. The person cannot see the skyscraper of height `4` because it is blocked by the skyscraper of height `5`.","solution":"def visible_skyscrapers(arr, viewPosition): Returns an array of all the skyscrapers that the person can see from their position in order of their appearance on the skyline. Parameters: arr (list): An array of integers representing the heights of skyscrapers. viewPosition (int): The position of a person standing in the city. Returns: list: List of integers representing the heights of visible skyscrapers. if not arr or viewPosition < 0 or viewPosition >= len(arr): return [] visible = [] max_height = arr[viewPosition] for height in arr[viewPosition:]: if height >= max_height: visible.append(height) max_height = height return visible"},{"question":"You are given a string `s` representing an arithmetic expression containing integers and the operators `\'+\'`, `\'-\'`, `\'*\'`, and `\'/\'` (no parentheses). Return _the **result** of evaluating the expression._ Note that: * The integer division should truncate toward zero. * The input string is guaranteed to be a valid arithmetic expression containing only non-negative integers and the operators `\'+\'`, `\'-\'`, `\'*\'`, and `\'/\'`.","solution":"def evaluate_expression(s): Evaluates the arithmetic expression contained in the string s and returns the result. The expression can include integers and the operators \'+\', \'-\', \'*\', \'/\'. Integer division should truncate toward zero. def apply_operator(operators, values): right = values.pop() left = values.pop() operator = operators.pop() if operator == \'+\': values.append(left + right) elif operator == \'-\': values.append(left - right) elif operator == \'*\': values.append(left * right) elif operator == \'/\': values.append(int(left / right)) # truncate toward zero import re tokens = re.findall(r\'d+|[+/*-]\', s) values = [] operators = [] precedence = {\'+\': 1, \'-\': 1, \'*\': 2, \'/\': 2} for token in tokens: if token.isdigit(): values.append(int(token)) else: while (operators and precedence[operators[-1]] >= precedence[token]): apply_operator(operators, values) operators.append(token) while operators: apply_operator(operators, values) return values[0]"},{"question":"You are given a string `query` and an array of strings `words`. Determine if the string `query` is a scrambled version of any of the strings in `words`. A scrambled version of a string can be formed by rearranging its letters. Return `true` if `query` is a scrambled version of any word in `words`, otherwise return `false`.","solution":"def is_scrambled_version(query, words): Determines if \'query\' is a scrambled version of any word in \'words\'. Args: query (str): The string to check. words (list of str): The list of words to compare against. Returns: bool: True if \'query\' is a scrambled version of any word in \'words\', False otherwise. sorted_query = \'\'.join(sorted(query)) for word in words: if \'\'.join(sorted(word)) == sorted_query: return True return False"},{"question":"Given an array of integers `arr` and an integer `k`, truncate the array such that each element appears at most `k` times in the final array. Return the truncated array while maintaining the order of first occurrences.","solution":"def truncate_array(arr, k): Truncate the array such that each element appears at most `k` times while maintaining the order of first occurrences. Parameters: arr (list of int): The input array of integers. k (int): The maximum number of occurrences for each element. Returns: list of int: The truncated array. from collections import defaultdict element_count = defaultdict(int) result = [] for num in arr: if element_count[num] < k: result.append(num) element_count[num] += 1 return result"},{"question":"You are given an array `items` of positive integers where `items[i]` represents the weight of the `i-th` item. You can place the items into one or more bins. Each bin can carry a total weight of at most `maxWeight`. You need to find the minimum number of bins required to carry all the items. Return _the minimum number of bins required_.","solution":"def min_bins_required(items, maxWeight): Returns the minimum number of bins required to carry all the items. Parameters: items (list): a list of positive integers representing the weights of the items. maxWeight (int): the maximum weight capacity of each bin. Returns: int: the minimum number of bins required. # Sort items in descending order items.sort(reverse=True) # List to keep track of bins and their current weight bins = [] # Place each item in the first bin that can accommodate it for item in items: placed = False for i in range(len(bins)): if bins[i] + item <= maxWeight: bins[i] += item placed = True break if not placed: # Create a new bin if the item could not be placed in any existing bin bins.append(item) return len(bins)"},{"question":"You are given an array of integers `arr` where some elements are duplicates and the rest are unique. Your task is to remove all duplicates in-place, such that each unique element appears only once. The order of the elements must be preserved, and the remaining space should be filled with zeros. You must do this in O(n) time and O(1) extra space. For example, given `arr = [4, 3, 2, 4, 1, 3, 2]`, modifying it in-place should result in `[4, 3, 2, 1, 0, 0, 0]`.","solution":"def remove_duplicates(arr): Removes duplicates from the array in-place such that each unique element appears only once. The order of the elements is preserved, and remaining spaces are filled with zeros. Parameters: arr (List[int]): The input array with possible duplicates. Returns: None: The input array is modified in-place. if not arr: return seen = set() write_index = 0 for num in arr: if num not in seen: seen.add(num) arr[write_index] = num write_index += 1 # Fill the rest of the array with zeros for i in range(write_index, len(arr)): arr[i] = 0"},{"question":"Given a list of `n` tasks, each task `i` has a duration of `tasks[i]` and its respective deadline of `deadlines[i]`. You are required to schedule all tasks in such a way that maximizes the count of tasks completed on or before their respective deadlines. Assuming each task takes exactly its duration in time units and can only be completed if it starts and finishes before or at its deadline, return the maximum number of tasks that can be completed on time.","solution":"def max_tasks_on_time(tasks, deadlines): Returns the maximum number of tasks that can be completed on or before their respective deadlines. Parameters: tasks (list of int): The durations of the tasks. deadlines (list of int): The respective deadlines of the tasks. Returns: int: The maximum number of tasks that can be completed on or before their respective deadlines. # Combine tasks and deadlines into one list of tuples (duration, deadline) combined = list(zip(tasks, deadlines)) # Sort the combined list by deadlines, and by durations if deadlines are the same combined.sort(key=lambda x: (x[1], x[0])) current_time = 0 count = 0 for duration, deadline in combined: if current_time + duration <= deadline: current_time += duration count += 1 return count"},{"question":"Write an algorithm that takes an integer array `arr` and an integer `target`, and returns an unique pair of integers from `arr` whose sum is closest to `target`. If there are multiple pairs with the same closest sum, return the pair with the smallest sum. If there are still multiple pairs, return the first occurring pair in the array. The result should be in the form of an integer array containing the pair of integers. For example, given the input array `arr = [1, 3, 4, 2, -1, 5]` and `target = 6`, the function should return `[1, 5]` as the pair whose sum `1 + 5 = 6` matches the target exactly. If the input array `arr = [10, 22, 28, 29, 30, 40]` and `target = 54`, the function should return `[22, 30]` since the closest sum `22 + 30 = 52` is closest to the target considering conditions specified.","solution":"def closest_pair(arr, target): Returns a pair of integers from arr whose sum is closest to the target. if len(arr) < 2: return [] arr = list(set(arr)) # Unique values only arr.sort() closest_sum = float(\'inf\') # Initialize with an infinitely large number result_pair = [] left, right = 0, len(arr) - 1 while left < right: current_sum = arr[left] + arr[right] if abs(target - current_sum) < abs(target - closest_sum): closest_sum = current_sum result_pair = [arr[left], arr[right]] elif abs(target - current_sum) == abs(target - closest_sum): if current_sum < closest_sum: closest_sum = current_sum result_pair = [arr[left], arr[right]] if current_sum < target: left += 1 else: right -= 1 return result_pair"},{"question":"You are given an integer array `tasks` where each task denotes the amount of time it takes to complete it. There are `n` workers available to complete these tasks, and each worker can perform only one task at a time. Each worker can complete multiple tasks sequentially one after the other. However, the tasks are assigned such that they will be finished in the minimum possible total time. Return _the minimum possible total time for all workers to complete all tasks._","solution":"def min_total_time(tasks, n): Returns the minimum possible total time for all workers to complete all tasks. Args: tasks: List[int] - A list of integers where each integer represents the time required to complete a task n: int - Number of workers available Returns: int - Minimum possible total time for all workers to complete all tasks if not tasks: return 0 tasks.sort(reverse=True) # Sort tasks in descending order to distribute bigger tasks first worker_times = [0] * n # Initialize each worker\'s total time to zero for task in tasks: # Assign each task to the worker who is currently the least loaded worker_times.sort() # Keep worker_times sorted worker_times[0] += task return max(worker_times) # The minimum possible total time to complete all tasks"},{"question":"You are given an integer array `heights` representing the heights of buildings in a row. If two buildings are **at least** 2 meters apart, a signal can be sent from the top of one building to the other building. Find and return the **total number** of such signal pairs that can be sent considering all pairs `(i, j)` where `0 <= i < j < heights.length` and `|i - j| >= 2`.","solution":"def count_signal_pairs(heights): Count the total number of pairs (i, j) such that a signal can be sent from building i to building j where |i - j| >= 2. Args: heights (list): List of integers representing building heights. Returns: int: Total count of valid signal pairs. n = len(heights) if n < 3: return 0 # No pair (i, j) can exist if less than 3 buildings # For each i, the count of valid pairs (i, j) where j >= i + 2 total_pairs = 0 for i in range(n - 2): valid_pairs_for_i = n - (i + 2) total_pairs += valid_pairs_for_i return total_pairs"},{"question":"You are given a string `str` and an integer array `indices` of the same length. The string `str` contains only lowercase letters, and the array `indices` contains distinct integers from `0` to `n-1`, where `n` is the length of the string. Reorder the string according to the given `indices` such that the character at the `i-th` position moves to `indices[i]` in the reordered string. Return the reordered string.","solution":"def reorder_string(s, indices): Reorder the string \'s\' according to the given \'indices\' array. Parameters: s (str): The input string. indices (List[int]): The indices indicating the new positions of characters in \'s\'. Returns: str: The reordered string. n = len(s) reordered = [\'\'] * n for i in range(n): reordered[indices[i]] = s[i] return \'\'.join(reordered)"},{"question":"A **broken keyboard** has some keys functioning and some not. Given a string `text` and a character array `functionalKeys`, return _an array of substrings that can be formed using only the functional keys_. Each substring should be ordered based on their appearance in the `text`. If no substring can be formed, return an empty array. A **substring** is a contiguous segment of a string.","solution":"def substrings_with_functional_keys(text, functionalKeys): Returns an array of substrings that can be formed using only the functional keys. Args: text (str): The input text to be analyzed. functionalKeys (list of str): The list of functional characters. Returns: list of str: An array of substrings that can be formed using the functional keys. functional_set = set(functionalKeys) result = [] current_substring = \\"\\" for char in text: if char in functional_set: current_substring += char else: if current_substring: result.append(current_substring) current_substring = \\"\\" if current_substring: result.append(current_substring) return result"},{"question":"You are given two strings `word1` and `word2`. Your task is to merge them into a single string by alternating the characters from `word1` and `word2` starting with the first character of `word1`. If one string runs out of characters before the other, append the remaining characters of the other string to the result. For example: - If `word1 = \\"abc\\"` and `word2 = \\"def\\"`, the merge should be `\\"adbecf\\"`. - If `word1 = \\"ab\\"` and `word2 = \\"zxcv\\"`, the merge should be `\\"azbxcv\\"`. Implement a function that returns the merged string based on the above rules.","solution":"def merge_alternately(word1, word2): Merges two strings by alternating their characters. If one string runs out of characters, appends the remaining characters of the other string. merged = [] len1, len2 = len(word1), len(word2) for i in range(max(len1, len2)): if i < len1: merged.append(word1[i]) if i < len2: merged.append(word2[i]) return \'\'.join(merged)"},{"question":"Given a directed graph represented by a list of edges, where each edge is represented as a pair `[from, to]`, and an integer `n` representing the number of nodes in the graph (nodes numbered from `0` to `n-1`), implement a function to check if the graph contains a cycle. Return `true` if there is a cycle, `false` otherwise. The function should follow these steps: * Use an appropriate graph traversal algorithm to detect cycles in a directed graph. * You may employ Depth-First Search (DFS) with a recursion stack or other methods to achieve this. For example: * Input: `n = 4, edges = [[0,1], [1,2], [2,3], [3,1]]` * Output: `true` * Input: `n = 3, edges = [[0,1], [1,2], [2,0]]` * Output: `true` * Input: `n = 3, edges = [[0,1], [1,2]]` * Output: `false`","solution":"def has_cycle(n, edges): Checks if the directed graph contains a cycle. :param n: Number of nodes :param edges: List of edges where each edge is represented as [from, to] :return: True if the graph contains a cycle, False otherwise from collections import defaultdict graph = defaultdict(list) for u, v in edges: graph[u].append(v) visited = [False] * n rec_stack = [False] * n def dfs(node): visited[node] = True rec_stack[node] = True for neighbor in graph[node]: if not visited[neighbor]: if dfs(neighbor): return True elif rec_stack[neighbor]: return True rec_stack[node] = False return False for node in range(n): if not visited[node]: if dfs(node): return True return False"},{"question":"Given a string `s` and an array of strings `words`, return an array of integers representing the number of times each word in `words` can be formed using the letters from `s`. Each letter in `s` can only be used once per word formation. If a word cannot be formed, the count for that word should be `0`.","solution":"from collections import Counter def count_words_can_be_formed(s, words): Returns an array of integers representing the number of times each word in \'words\' can be formed using the letters from \'s\'. s_counter = Counter(s) result = [] for word in words: word_counter = Counter(word) count_possible = True for char, count in word_counter.items(): if s_counter[char] < count: count_possible = False break result.append(int(count_possible)) return result"},{"question":"Write a function that takes two arguments: a string `text` and an array of words `words`. The function should return _a list of starting indices of all substrings in `text` that are a concatenation of each word in `words` exactly once and without any intervening characters_. Words in `words` may be repeated. The order in which the words are concatenated should be the same as in `words`. You may assume that `words` have the same length. For example, given: - text = \\"barfoothefoobarman\\" - words = [\\"foo\\", \\"bar\\"] The function should return: - [0, 9], because the substring \\"barfoo\\" starts at index 0 and \\"foobar\\" starts at index 9.","solution":"def find_substring_indices(text, words): Returns a list of starting indices of all substrings in text that are a concatenation of each word in words. Args: text (str): The input string in which to search. words (List[str]): The list of words to concatenate. Returns: List[int]: The starting indices of all concatenated substrings. if not text or not words or len(words[0]) == 0: return [] word_len = len(words[0]) total_len = word_len * len(words) word_count = len(words) # Count frequency of each word in words list from collections import Counter word_freq = Counter(words) result = [] # Slide a window of size equal to the total length of all words concatenated for i in range(len(text) - total_len + 1): seen = {} j = 0 while j < word_count: # Get the current substring from the text word_start = i + j * word_len word = text[word_start:word_start + word_len] # If the word is in our list if word in word_freq: seen[word] = seen.get(word, 0) + 1 # If the word frequency exceeds expected frequency, break if seen[word] > word_freq[word]: break else: break j += 1 if seen == word_freq: result.append(i) return result"},{"question":"Given an integer array `nums`, return the maximum difference you can get by changing **exactly one** element in the array. The difference is calculated as the maximum value of the array minus the minimum value of the array after the change. If the array has less than two elements, return `0`. For example: - Input: `nums = [8, 1, 2, 6, 4]` - Output: `8` - Input: `nums = [1, 1, 1, 1, 1]` - Output: `0`","solution":"def max_difference_after_change(nums): if len(nums) < 2: return 0 min_value = min(nums) max_value = max(nums) if min_value == max_value: return 0 potential_max_diff = max(max_value - min_value, (9 if max_value != 9 else max_value) - min_value, max_value - (0 if min_value != 0 else min_value)) return potential_max_diff"},{"question":"You are given an array `seats` where `seats[i]` is either `1` (occupied) or `0` (empty), representing a row of seats in a theater. Find the maximum distance to the closest person (i.e., `1`) for any seat (i.e., `0`). You may assume that at least one seat is empty and at least one seat is occupied. Return _the maximum distance to the closest person for any empty seat_.","solution":"def maxDistToClosest(seats): Returns the maximum distance to the closest person for any empty seat. Args: seats (list): A list of integers representing the seating arrangement. Returns: int: The maximum distance to the closest person. max_distance = 0 n = len(seats) last_person_index = -1 for i in range(n): if seats[i] == 1: if last_person_index == -1: # First person encountered max_distance = i else: max_distance = max(max_distance, (i - last_person_index) // 2) last_person_index = i # Handle case when the last seat is empty max_distance = max(max_distance, n - 1 - last_person_index) return max_distance"},{"question":"Given an array of integers `arr`, you need to **rearrange the elements to form the largest possible number**. Each element of the array contains single digits (i.e., between 0 to 9). The result should be returned as a string since the largest number might be very large. If the array is empty, return an empty string. For example: - Given `arr = [3, 30, 34, 5, 9]`, the largest formed number is `\\"9534330\\"`. - Given `arr = [1, 20, 23, 4, 8]`, the largest formed number is `\\"8423201\\"`.","solution":"from functools import cmp_to_key def largest_number(arr): Rearranges elements to form the largest possible number. Parameters: arr : list of int The list of single-digit integers. Returns: str The largest possible number formed as a string. if not arr: return \\"\\" # Convert all elements to strings for easier comparison arr = list(map(str, arr)) # Custom comparator to decide the order based on combined values def compare(x, y): if x + y > y + x: return -1 else: return 1 # Sort array using the custom comparator arr.sort(key=cmp_to_key(compare)) # Join sorted array into a single string result = \'\'.join(arr) # If the result is something like \\"0000\\", return single \\"0\\" if result[0] == \'0\': return \'0\' return result"},{"question":"Design a class `FrequencyStack` that simulates the operations of a stack-like data structure that supports frequency-based operations. - `FrequencyStack()` Initializes the `FrequencyStack` object. - `void push(int val)` Pushes an integer `val` onto the stack. - `int pop()` Removes and returns the most frequent element in the stack. If there is a tie for the most frequent element, the element closest to the top of the stack is removed and returned. You must implement the functions of the class such that each function works in **average** `O(1)` time complexity.","solution":"import collections class FrequencyStack: def __init__(self): self.freq = collections.Counter() self.stacks = collections.defaultdict(list) self.max_freq = 0 def push(self, val: int): self.freq[val] += 1 current_freq = self.freq[val] if current_freq > self.max_freq: self.max_freq = current_freq self.stacks[current_freq].append(val) def pop(self) -> int: val = self.stacks[self.max_freq].pop() if not self.stacks[self.max_freq]: self.max_freq -= 1 self.freq[val] -= 1 return val"},{"question":"Given a string `s`, determine if it can be constructed by taking a substring of it and appending multiple copies of the substring together. The substring must be at least one character long and can be repeated any number of times. Return _true_ if it can, or _false_ if it cannot.","solution":"def repeated_substring_pattern(s): Determines if the given string can be constructed by taking a substring of it and appending multiple copies of the substring together. Parameters: s (str): The input string. Returns: bool: True if the string can be constructed by repeating a substring, otherwise False. n = len(s) for i in range(1, n // 2 + 1): if n % i == 0: if s[:i] * (n // i) == s: return True return False"},{"question":"You are given a 2D grid of size `m x n` where each cell represents a coordinate on a Cartesian plane and the value in each cell represents the **elevation** at that coordinate. You need to determine the coordinates of the **highest peak** in the grid where you can reach the peak from any other cell by moving **only to adjacent cells with higher or equal elevation**. If there are multiple peaks of the same elevation, return the coordinates of the one that appears first when traversed in row-major order (i.e., left to right across each row starting from the top row). Return the coordinates of the highest peak as a list `[r, c]` where `r` is the row index and `c` is the column index.","solution":"def find_highest_peak(grid): Finds the coordinates of the highest peak in a 2D grid. Parameters: grid (List[List[int]]): 2D list representing the grid elevations. Returns: List[int]: Coordinates of the highest peak in the form [row, col]. if not grid or not grid[0]: return [] m, n = len(grid), len(grid[0]) highest_peak = float(\'-inf\') highest_coords = [] for r in range(m): for c in range(n): if grid[r][c] > highest_peak: highest_peak = grid[r][c] highest_coords = [r, c] elif grid[r][c] == highest_peak: continue return highest_coords"},{"question":"Design an algorithm to calculate the maximum sum of any non-empty subarray of a given array `nums` of length `n`. A subarray is a contiguous region of the array. You must not use any built-in functions that directly solve the problem. Return the maximum sum.","solution":"def max_subarray_sum(nums): Calculates the maximum sum of any non-empty subarray of the given array. Parameters: nums (list): A list of integers representing the array. Returns: int: The maximum sum of any non-empty subarray. if not nums: raise ValueError(\\"The input array cannot be empty\\") max_current = max_global = nums[0] for num in nums[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"You are given an array of integers `arr` of length `n`. Your task is to return an array of the same length where each element at index `i` is the product of all elements in the original array except the one at `i`. Write a function `productExceptSelf(arr)` that takes in an array of integers `arr` and returns the product array. You must implement it without using the division operation and in O(n) time complexity.","solution":"def productExceptSelf(arr): n = len(arr) result = [1] * n # Calculate products of all elements to the left of each element left_product = 1 for i in range(n): result[i] = left_product left_product *= arr[i] # Calculate products of all elements to the right of each element right_product = 1 for i in range(n - 1, -1, -1): result[i] *= right_product right_product *= arr[i] return result"},{"question":"You are given a list of integers `numbers` and an integer `k`. Create a new list `result` where each element in `result` is calculated as the sum of the elements in a sliding window of size `k` over `numbers`. More formally, `result[i]` should be the sum of `numbers[i]`, `numbers[i+1]`, ..., `numbers[i+k-1]`. Return the list `result`. If the length of `numbers` is less than `k`, return an empty list.","solution":"def sliding_window_sum(numbers, k): Returns a list of sums of elements in a sliding window of size \'k\' over \'numbers\'. If length of \'numbers\' is less than \'k\', returns an empty list. if len(numbers) < k: return [] result = [] window_sum = sum(numbers[:k]) result.append(window_sum) for i in range(1, len(numbers) - k + 1): window_sum = window_sum - numbers[i-1] + numbers[i+k-1] result.append(window_sum) return result"},{"question":"You are given an integer array `arr` consisting of `n` elements, and an integer `k`. Your task is to divide the array into **k** non-empty continuous subarrays such that the sum of each subarray is as large as possible while still having the smallest of these sums be as large as possible. Return _the **largest minimum sum** possible among the **k** subarrays_.","solution":"def can_split(nums, k, mid): Helper function to check if we can split `nums` into `k` parts with each part\'s sum being at least `mid`. current_sum = 0 parts_count = 1 for num in nums: current_sum += num if current_sum > mid: parts_count += 1 current_sum = num if parts_count > k: return False return True def max_min_sum(nums, k): Returns the largest minimum sum possible among `k` subarrays. low, high = max(nums), sum(nums) while low < high: mid = (low + high) // 2 if can_split(nums, k, mid): high = mid else: low = mid + 1 return low"},{"question":"You are given an array of integers `tasks` where `tasks[i]` indicates the time required to complete the `i-th` task. You are also given an integer `sessionTime` which represents the maximum time you have in one work session. Your goal is to complete all the tasks in a minimum number of work sessions. However, once a work session starts, it cannot be paused until all tasks assigned to that session are completed, and no task can be split between two sessions. Implement a function `minSessions(tasks, sessionTime)` that returns the minimum number of work sessions required to complete all the tasks. ```python def minSessions(tasks, sessionTime): # Your code here ```","solution":"def minSessions(tasks, sessionTime): def dfs(index, sessions): if index == len(tasks): return len(sessions) min_sessions = float(\'inf\') for i in range(len(sessions)): if sessions[i] + tasks[index] <= sessionTime: sessions[i] += tasks[index] min_sessions = min(min_sessions, dfs(index + 1, sessions)) sessions[i] -= tasks[index] sessions.append(tasks[index]) min_sessions = min(min_sessions, dfs(index + 1, sessions)) sessions.pop() return min_sessions tasks.sort(reverse=True) return dfs(0, [])"},{"question":"You are given an integer array `costs` where `costs[i]` represents the cost of hiring the `i-th` worker for a project. You are also given a budget `B` and an integer `k` that represents the number of workers you need to hire. You need to hire exactly `k` workers such that the total costs do not exceed the budget `B` and the product of the costs of these `k` workers is maximized. If it is not possible to hire `k` workers within the budget, return `-1`. Return the maximum product of the costs of the selected workers.","solution":"from itertools import combinations from functools import reduce import operator def maximizeProduct(costs, B, k): Finds the maximum product of the costs of exactly k workers such that the total costs do not exceed budget B. If not possible, returns -1. :param costs: List[int], list of costs of hiring each worker :param B: int, budget available :param k: int, number of workers to hire :return: int, maximum product of the costs of selected workers, or -1 if not possible if len(costs) < k: return -1 max_product = -1 # Generate all possible combinations of exactly k workers for comb in combinations(costs, k): if sum(comb) <= B: product = reduce(operator.mul, comb, 1) if product > max_product: max_product = product return max_product"},{"question":"Given a matrix of integers, write a function to find all the elements that are present in every row of the matrix in increasing order. The function should return the list of these elements sorted in ascending order. For example, consider the following matrix: ``` [[1, 2, 3, 4, 5], [2, 4, 5, 8, 10], [3, 5, 7, 9, 11], [1, 3, 5, 7, 9]] ``` The elements that are present in every row are `[5]`. Hence, the function should return `[5]`.","solution":"def common_elements(matrix): Finds all elements present in every row of the matrix in increasing order. :param matrix: List of lists where each list represents a row in the matrix. :return: List of common elements sorted in ascending order. if not matrix: return [] common_set = set(matrix[0]) for row in matrix[1:]: common_set &= set(row) return sorted(common_set)"},{"question":"Write a function that takes a string `s` as input, where `s` consists of words separated by spaces. The function should return the length of the **last word** in the string. If the last word does not exist, return 0. A word is defined as a contiguous sequence of non-space characters. Example: Input: \\"Hello World\\" Output: 5","solution":"def length_of_last_word(s): Returns the length of the last word in the string s. If the last word does not exist, returns 0. words = s.strip().split() if not words: return 0 return len(words[-1])"},{"question":"You are given a list of positive integers `nums` representing the number of bananas in each pile and an integer `h` representing the number of hours. During each hour, you can choose a pile and eat some bananas from it. You can decide to eat any number of bananas, but you must eat at least one and at most `k` bananas from a chosen pile per hour. Find the minimum integer `k` such that you can eat all the bananas within `h` hours. Return _the minimum integer `k` needed to finish all the bananas in the given number of hours._","solution":"def minEatingSpeed(nums, h): Determines the minimum integer k such that all bananas from piles in nums can be eaten in h hours. def canFinish(k): hours_needed = 0 for pile in nums: hours_needed += -(-pile // k) # This is the same as math.ceil(pile / k) return hours_needed <= h left, right = 1, max(nums) while left < right: mid = (left + right) // 2 if canFinish(mid): right = mid else: left = mid + 1 return left"},{"question":"Given an array of integers `arr` and an integer `k`, implement a function that returns the maximum sum of a subarray of length `k`. A subarray is a contiguous block of elements from the original array. For example, if `arr = [2, 1, 5, 1, 3, 2]` and `k = 3`, the subarray `[5, 1, 3]` yields the maximum sum of `9`. Can you achieve a time complexity of `O(n)`?","solution":"def max_sum_subarray(arr, k): Returns the maximum sum of a subarray of length k. if not arr or k <= 0 or k > len(arr): return 0 window_sum = sum(arr[:k]) max_sum = window_sum for i in range(len(arr) - k): window_sum = window_sum - arr[i] + arr[i + k] max_sum = max(max_sum, window_sum) return max_sum"},{"question":"Given an `n x n` matrix where each of the numbers in the matrix is in the range 1 to `n^2`, return a boolean that indicates whether the matrix is a **magic square** or not. A square is considered magical if the sums of the numbers in each row, each column, and both main diagonals are all the same.","solution":"def is_magic_square(matrix): n = len(matrix) if n == 0: return False # Calculate the sum of the first row target_sum = sum(matrix[0]) # Check the sums of all rows for row in matrix: if sum(row) != target_sum: return False # Check the sums of all columns for col in range(n): if sum(matrix[row][col] for row in range(n)) != target_sum: return False # Check the sum of the main diagonal if sum(matrix[i][i] for i in range(n)) != target_sum: return False # Check the sum of the anti-diagonal if sum(matrix[i][n - 1 - i] for i in range(n)) != target_sum: return False return True"},{"question":"Given a string `s`, return the length of the longest substring that contains at most two distinct characters. The substring \\"abbacc\\" has the longest substring \\"abb\\" or \\"bcc\\", both having length 3 when the longest substring with at most two distinct characters is considered. Return the length of this substring.","solution":"def length_of_longest_substring_two_distinct(s): Returns the length of the longest substring that contains at most two distinct characters. n = len(s) if n < 3: return n left = 0 right = 0 max_len = 2 hashmap = {} while right < n: if len(hashmap) < 3: hashmap[s[right]] = right right += 1 if len(hashmap) == 3: del_idx = min(hashmap.values()) del hashmap[s[del_idx]] left = del_idx + 1 max_len = max(max_len, right - left) return max_len"},{"question":"You are given an integer array `nums` of length `n` where `0 <= nums[i] < n`. The array represents the permutation of numbers from `0` to `n-1`. A permutation is a sequence where each number from `0` to `n-1` appears exactly once. You are required to implement the following methods for an `ArrayPermutation` class: - `ArrayPermutation(int[] nums)` Initializes the object with the permutation array `nums`. - `void swap(int i, int j)` Swaps the elements at indices `i` and `j` in the permutation array. - `int find(int target)` Returns the index of the `target` number in the permutation array. If the `target` number is not found, return `-1`. - `boolean isSorted()` Checks if the permutation array `nums` is in sorted order (i.e., `nums[i] == i` for all `i`). Returns `true` if it is sorted, `false` otherwise. Your task is to implement these methods for efficient operations on the permutation array.","solution":"class ArrayPermutation: def __init__(self, nums): self.nums = nums def swap(self, i, j): self.nums[i], self.nums[j] = self.nums[j], self.nums[i] def find(self, target): for index, num in enumerate(self.nums): if num == target: return index return -1 def isSorted(self): for i in range(len(self.nums)): if self.nums[i] != i: return False return True"},{"question":"You are given an array of positive integers `arr` and a positive integer `k`. Your task is to find the `k-th` smallest unique element in `arr`. If there are fewer than `k` unique elements in `arr`, return `-1`. For example, given the array `arr = [3, 1, 2, 4, 4, 2, 1, 5]` and `k = 3`, the unique elements are `[3, 4, 5]` in ascending order. The 3rd smallest unique element is `5`, so the function should return `5`. If `arr = [3, 1, 2, 3, 1, 2]` and `k = 2`, there are no unique elements available, so the function should return `-1`. Return the `k-th` smallest unique element in `arr`, or `-1` if it does not exist.","solution":"def kth_smallest_unique(arr, k): Returns the k-th smallest unique element in arr, or -1 if there are fewer than k unique elements. from collections import Counter # Count the frequency of each element in the array frequency = Counter(arr) # Extract the unique elements from the array unique_elements = [key for key, count in frequency.items() if count == 1] # If there are fewer unique elements than k, return -1 if len(unique_elements) < k: return -1 # Sort the unique elements in ascending order unique_elements.sort() # Return the k-th smallest unique element (1-indexed) return unique_elements[k - 1]"},{"question":"You are given a list of non-negative integers `nums` representing the amount of money of each house. A thief wants to rob houses to maximize their total stolen amount but cannot rob two adjacent houses due to security systems in place. Return _the maximum amount of money the thief can rob without alerting the security system._","solution":"def rob(nums): Returns the maximum amount of money the thief can rob without alerting the security system. :param nums: List[int] - List of non-negative integers representing money in each house. :return: int - Maximum amount of money that can be robbed. if not nums: return 0 if len(nums) == 1: return nums[0] if len(nums) == 2: return max(nums[0], nums[1]) dp = [0] * len(nums) dp[0] = nums[0] dp[1] = max(nums[0], nums[1]) for i in range(2, len(nums)): dp[i] = max(dp[i-1], nums[i] + dp[i-2]) return dp[-1]"},{"question":"You are given a list of integers representing the number of files in each folder on a computer. Each folder can be nested inside another folder, represented as a list within a list. Write a function to calculate the total number of files across all folders, including nested ones. For example, given `folders = [2, [0, [3, 4], 1], 1]`, the function should return 11, as there are `2 + (0 + (3 + 4) + 1) + 1 = 11` files in total.","solution":"def count_files(folders): Returns the total number of files across all folders, including nested ones. total_files = 0 def helper(sub_folders): nonlocal total_files for item in sub_folders: if isinstance(item, list): helper(item) else: total_files += item helper(folders) return total_files"},{"question":"Given an integer array `arr`, return _the length of the **longest divisible subset** in `arr`_. A divisible subset is a subset where for every pair `(a, b)` in the subset, either `a % b == 0` or `b % a == 0`. The subset must also be **increasing**.","solution":"def longest_divisible_subset(arr): if not arr: return 0 arr.sort() n = len(arr) dp = [1] * n max_length = 1 for i in range(n): for j in range(i): if arr[i] % arr[j] == 0: dp[i] = max(dp[i], dp[j] + 1) max_length = max(max_length, dp[i]) return max_length"},{"question":"Given a string `sentence` consisting of lowercase English letters and spaces, return _the length of the longest **substring** that contains at most two distinct characters._ A **substring** is a contiguous sequence of characters within a string. For example, in the string `\\"eceba\\"`, the substring `\\"ece\\"` has length 3 and contains exactly two distinct characters. If there are multiple substrings with the same maximal length, return the length of any one of them.","solution":"def longest_substring_with_two_distinct_chars(sentence): Returns the length of the longest substring with at most two distinct characters. if len(sentence) == 0: return 0 start = 0 max_length = 0 char_map = {} for end in range(len(sentence)): if sentence[end] not in char_map: char_map[sentence[end]] = 0 char_map[sentence[end]] += 1 while len(char_map) > 2: char_map[sentence[start]] -= 1 if char_map[sentence[start]] == 0: del char_map[sentence[start]] start += 1 max_length = max(max_length, end - start + 1) return max_length"},{"question":"You are given a 2D matrix containing only 0s and 1s. Each row of the matrix is sorted in a non-decreasing order. Implement a function `findMaxOnesRow(int[][] matrix)` that returns the index of the row with the maximum number of 1s. If there are multiple such rows, return the smallest index. Example: ``` Input: matrix = [[0,0,1,1],[0,1,1,1],[0,0,0,1]] Output: 1 Explanation: The second row has the maximum number of 1s. ```","solution":"def findMaxOnesRow(matrix): Returns the index of the row with the maximum number of 1s. If there are multiple such rows, returns the smallest index. max_ones = -1 index_of_max_ones_row = -1 for i, row in enumerate(matrix): count_ones = sum(row) if count_ones > max_ones: max_ones = count_ones index_of_max_ones_row = i return index_of_max_ones_row"},{"question":"You are given an array of integers `arr` where each element represents the height of a building at index `i`. The width of each building is 1. We want to paint the buildings such that each building can be painted with its maximum available color until some height `h`. We need to ensure that we paint all buildings in a continuous, ascending order such that the maximum height of the continuous range of buildings forms the largest rectangle possible in terms of total area. Return the maximum total area of the rectangle that can be formed by any such continuous, ascending subarray of building heights.","solution":"def largest_rectangle_area(heights): Returns the maximum area of a rectangle that can be formed in a continuous ascending subarray of building heights. max_area = 0 stack = [] for i, height in enumerate(heights): while stack and heights[stack[-1]] > height: h = heights[stack.pop()] w = i if not stack else i - stack[-1] - 1 max_area = max(max_area, h * w) stack.append(i) while stack: h = heights[stack.pop()] w = len(heights) if not stack else len(heights) - stack[-1] - 1 max_area = max(max_area, h * w) return max_area"},{"question":"Given a list of `n` cities numbered from `0` to `n-1` and a list of `m` queries where each query asks whether two cities are directly or indirectly connected by any number of roads, implement a system that can efficiently answer such connectivity queries. You are provided with two functions: - `addRoad(city1, city2)`: Adds a bidirectional road between `city1` and `city2`. - `areConnected(city1, city2)`: Returns `true` if there is a direct or indirect path connecting `city1` and `city2`, otherwise returns `false`. The system should optimize for numerous `areConnected` queries after all roads have been added. Implement the `CityConnectivity` class: * `CityConnectivity(int n)` Initializes the object with `n` cities. * `void addRoad(int city1, int city2)` Adds a bidirectional road between `city1` and `city2`. * `boolean areConnected(int city1, int city2)` Returns `true` if there is a path connecting `city1` and `city2`, otherwise returns `false`.","solution":"class CityConnectivity: def __init__(self, n: int): self.parent = list(range(n)) def find(self, city: int) -> int: if self.parent[city] != city: self.parent[city] = self.find(self.parent[city]) return self.parent[city] def union(self, city1: int, city2: int): root1 = self.find(city1) root2 = self.find(city2) if root1 != root2: self.parent[root2] = root1 def addRoad(self, city1: int, city2: int): self.union(city1, city2) def areConnected(self, city1: int, city2: int) -> bool: return self.find(city1) == self.find(city2)"},{"question":"You are given an unsorted array of integers `nums`. Write a function to find the smallest positive integer that does not appear in the array. Your algorithm should run in O(n) time and use constant extra space. Return the minimum positive integer that is missing from the array.","solution":"def first_missing_positive(nums): Returns the smallest positive integer that does not appear in the array. :param nums: List of integers :return: Smallest positive integer missing from the array n = len(nums) # Place each number in its right place, e.g. 3 should be at index 2 (nums[2]) for i in range(n): while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]: correct_index = nums[i] - 1 nums[i], nums[correct_index] = nums[correct_index], nums[i] # Find the smallest positive missing integer for i in range(n): if nums[i] != i + 1: return i + 1 # If all numbers are in place, the smallest missing positive integer is n + 1 return n + 1"},{"question":"Given an integer string `num` containing only the digits `\'0\'`, `\'1\'`, and `\'2\'`, return the length of the longest substring of `num` that contains only digits `\'0\'` and `\'1\'` and has an equal number of each. If no such substring exists, return `0`.","solution":"def longest_equal_01_substring(num): This function finds the length of the longest substring of `num` that contains only digits \'0\' and \'1\' and has an equal number of each. max_len = 0 count = {0: -1} # Store the first occurrence position of each balance value balance = 0 # Balance between number of \'0\'s and \'1\'s for i, digit in enumerate(num): if digit in \'01\': balance += 1 if digit == \'0\' else -1 if balance in count: max_len = max(max_len, i - count[balance]) else: count[balance] = i return max_len"},{"question":"A software company tracks the time it takes for their servers to process requests. Each request processing time is represented in an integer array `times`. The company wants to ensure that the average request processing time for any contiguous subarray of a given length `k` does not exceed a certain threshold `t`. Write a function to determine whether this is achievable. Specifically, return `true` if there exists at least one contiguous subarray of length `k` whose average processing time is less than or equal to `t`, otherwise return `false`.","solution":"def is_achievable(times, k, t): Determine if there is a contiguous subarray of length k whose average processing time is less than or equal to t. :param times: List[int] - Array of request processing times. :param k: int - The length of the subarray to consider. :param t: float - The threshold for the average processing time. :return: bool - True if such a subarray exists, False otherwise. n = len(times) if k > n: return False current_sum = sum(times[:k]) if current_sum / k <= t: return True for i in range(k, n): current_sum += times[i] - times[i - k] if current_sum / k <= t: return True return False"},{"question":"Alice and Bob are organizing a card game tournament. You are given a list of integers representing the scores of different players. Alice prefers players with even scores, whereas Bob prefers players with odd scores. Your task is to select the highest possible combined score from the list for Alice and Bob by choosing exactly one score for Alice and one for Bob. If it is not possible to select such a pair (either no even or no odd scores in the list), return -1.","solution":"def max_combined_score(scores): Returns the highest possible combined score by choosing exactly one even and one odd score. If it\'s not possible to select such a pair, returns -1. max_even = -1 max_odd = -1 for score in scores: if score % 2 == 0: if score > max_even: max_even = score else: if score > max_odd: max_odd = score if max_even == -1 or max_odd == -1: return -1 else: return max_even + max_odd"},{"question":"You are tasked with writing a function that simulates a simple text-based snake game. The game is played on a grid with a snake that moves in four possible directions: \\"U\\" (up), \\"D\\" (down), \\"L\\" (left), and \\"R\\" (right). The snake starts at the top-left corner of the grid (position (0,0)) and proceeds to follow a series of movement commands. If the snake moves outside the boundaries of the grid or if it runs into itself, the game ends. The function should accept the following inputs: - an integer `m` representing the number of rows in the grid, - an integer `n` representing the number of columns in the grid, - a string `commands` containing a sequence of movement commands (e.g., \\"RRDUL\\"). Return _a list of tuples representing the positions of the snake\'s segments at the end of the game_. If the game ends prematurely due to an invalid move, return _an empty list except the initial starting position [(0,0)]_. **Note**: The snake does not grow, and the head of the snake always lies at the last position in the returned list.","solution":"def simulate_snake_game(m, n, commands): Simulates a simple snake game on an m x n grid following the movement commands. Args: m (int): number of rows in the grid. n (int): number of columns in the grid. commands (str): sequence of movement commands (\'U\', \'D\', \'L\', \'R\'). Returns: list of tuples: positions of the snake\'s segments at the end of the game or [(0, 0)] if the game ends prematurely. directions = { \'U\': (-1, 0), \'D\': (1, 0), \'L\': (0, -1), \'R\': (0, 1) } snake_body = [(0, 0)] # Initial position head = (0, 0) for command in commands: if command in directions: new_head = (head[0] + directions[command][0], head[1] + directions[command][1]) # Check boundaries if new_head[0] < 0 or new_head[0] >= m or new_head[1] < 0 or new_head[1] >= n: return [(0, 0)] # Check self-collision if new_head in snake_body: return [(0, 0)] # Move the snake snake_body.append(new_head) head = new_head return snake_body"},{"question":"You are given two integers, `n` and `k`. Your task is to partition the number `n` into `k` non-negative integers such that the sum of their squares is maximized. Write a function `partitionAndMaximizeSquareSum(n, k)` that returns an array of `k` non-negative integers whose sum is `n` and the sum of their squares is the maximum possible. If there are multiple possible solutions, return any one of them.","solution":"def partitionAndMaximizeSquareSum(n, k): Partitions the number n into k non-negative integers such that the sum of their squares is maximized. if k == 0: return [] # Initially distribute n as evenly as possible quotient, remainder = divmod(n, k) # Create an initial partition with the quotient distributed partition = [quotient] * k # Distribute the remainder to maximize the square sum for i in range(remainder): partition[i] += 1 return partition"},{"question":"Given an m x n matrix `mat` and an integer `k`, return a matrix `answer` where each `answer[i][j]` is the sum of all elements `mat[r][c]` for which `i - k <= r <= i + k` and `j - k <= c <= j + k`. If a cell is out of the matrix bounds, it should be excluded from the sum.","solution":"def matrix_block_sum(mat, k): Returns a matrix where each cell is the sum of elements in a k-block around that cell. m, n = len(mat), len(mat[0]) # Initialize the answer matrix with zeroes answer = [[0] * n for _ in range(m)] for i in range(m): for j in range(n): # Sum elements in the k-block around cell (i, j) total = 0 for r in range(max(0, i - k), min(m, i + k + 1)): for c in range(max(0, j - k), min(n, j + k + 1)): total += mat[r][c] answer[i][j] = total return answer"},{"question":"You have a 2D grid of size `m x n`, where each cell in the grid contains a lowercase character. Your task is to check if there is a path from the **top-left** cell to the **bottom-right** cell such that the concatenation of all characters along the path forms a given target string `s`. You can move only rightward or downward at any point in time. Return `true` if such a path exists, and `false` otherwise.","solution":"def is_path_exists(grid, s): Determines if there is a path from the top-left to the bottom-right of a grid such that the concatenation of characters along the path forms the given target string s. :param grid: List[List[str]] - 2D grid of characters. :param s: str - target string. :return: bool - True if such a path exists, False otherwise. m, n = len(grid), len(grid[0]) def dfs(x, y, index): # If index is equal to length of s and we reached the bottom-right corner, return True if index == len(s): return True # If out of bounds or character doesn\'t match, return False if x >= m or y >= n or grid[x][y] != s[index]: return False # Move right or down recursively return dfs(x + 1, y, index + 1) or dfs(x, y + 1, index + 1) # Start DFS from the top-left cell with the first character of the string return dfs(0, 0, 0)"},{"question":"You are given an array of integers `heights` representing the heights of people in a queue. Each person in the queue has a height specified, and people are standing in a line from left to right. Your task is to find out how many people are not standing in their correct order if we rearrange the queue such that the heights are sorted in non-decreasing order. A person is considered to be \\"not standing in their correct order\\" if their height does not match the height in the correct position of the sorted array. Return _the **number** of people not standing in their correct order_.","solution":"def heightChecker(heights): Returns the number of people not standing in their correct order. sorted_heights = sorted(heights) return sum(1 for i in range(len(heights)) if heights[i] != sorted_heights[i])"},{"question":"Given a 2D grid of size `m x n` representing a field, each cell of the field is either an obstacle (represented by the value 1) or a clear path (represented by the value 0). You need to find the shortest path from the top-left corner to the bottom-right corner, knowing you can move only up, down, left, or right. If no such path exists, return -1. The length of a path is the number of steps taken.","solution":"from collections import deque def shortest_path(grid): if not grid or grid[0][0] == 1 or grid[-1][-1] == 1: return -1 m, n = len(grid), len(grid[0]) queue = deque([(0, 0, 0)]) # (row, col, steps) visited = set((0, 0)) directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] while queue: x, y, steps = queue.popleft() if x == m - 1 and y == n - 1: return steps for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited and grid[nx][ny] == 0: visited.add((nx, ny)) queue.append((nx, ny, steps + 1)) return -1"},{"question":"Given a string `s` which represents a series of keystrokes on a text editor, compile the final text after processing the keystrokes. The keystrokes are a combination of: - Lowercase letters (`a-z`), which are added to the final text. - A backspace character (`#`), which removes the last character from the final text. Return the final string after processing all keystrokes.","solution":"def compile_text(s): Compiles the final text after processing keystrokes. :param s: string representing series of keystrokes. :return: final compiled text. result = [] for char in s: if char == \'#\': if result: result.pop() else: result.append(char) return \'\'.join(result)"},{"question":"You are given an integer array `items` representing the cost of various items in a store and an integer `budget` representing the total amount of money you have. You need to determine the maximum number of items you can buy without exceeding your budget. You can buy each item at most once. Return the maximum number of items you can purchase.","solution":"def max_items_that_can_be_bought(items, budget): Returns the maximum number of items that can be bought without exceeding the given budget. :param items: List of integers representing the cost of items. :param budget: Integer representing the total amount of budget available. :return: Integer representing the maximum number of items that can be bought without exceeding the budget. items.sort() total_cost = 0 count = 0 for item in items: if total_cost + item <= budget: total_cost += item count += 1 else: break return count"},{"question":"Given a set of time intervals in the format `[start, end]`, where `start` and `end` are non-negative integers and `start < end`, merge all overlapping intervals and return the resulting list of non-overlapping intervals. Each interval is a pair of integers that represents a continuous time duration. For example, given intervals `[[1, 3], [2, 6], [8, 10], [15, 18]]`, the function should return `[[1, 6], [8, 10], [15, 18]]` as the intervals `[1, 3]` and `[2, 6]` overlap and are merged into `[1, 6]`. Write a function: ```python def mergeIntervals(intervals: List[List[int]]) -> List[List[int]]: ``` that takes a list of intervals and returns a list of merged intervals. # Constraints: - The intervals may be provided in any order. - The length of the intervals list will not exceed `10^4`. - The value of intervals will be within the range `0` to `10^4`.","solution":"from typing import List def mergeIntervals(intervals: List[List[int]]) -> List[List[int]]: This function takes a list of intervals and merges overlapping intervals. if not intervals: return [] # Sort the intervals based on the starting times intervals.sort(key=lambda x: x[0]) merged = [intervals[0]] for current in intervals[1:]: last_merged = merged[-1] if current[0] <= last_merged[1]: # There is an overlap last_merged[1] = max(last_merged[1], current[1]) else: merged.append(current) return merged"},{"question":"Given an array of strings `words`, return _the longest string in the array that can be constructed by concatenating other words in the array_. If there are multiple results, return any of them. If no such string exists, return an empty string. Note that each concatenated word must be formed by using other words from the array exactly once and not repeated.","solution":"def find_longest_concatenated_word(words): Returns the longest word in the array that can be constructed by concatenating other words in the array. If there are multiple results, return any of them. If no such word exists, return an empty string. word_set = set(words) def can_form(word): if word in memo: return memo[word] for i in range(1, len(word)): prefix = word[:i] suffix = word[i:] if prefix in word_set and suffix in word_set: memo[word] = True return True if prefix in word_set and can_form(suffix): memo[word] = True return True memo[word] = False return False words.sort(key=len, reverse=True) # Sort words by length in descending order memo = {} for word in words: word_set.remove(word) if can_form(word): return word word_set.add(word) return \\"\\""},{"question":"Given a list of intervals representing the reservation time slots of a meeting room, determine the minimum number of meeting rooms required. Each interval is a pair of start and end times. For example, given `[[0, 30], [5, 10], [15, 20]]`, the minimum number of meeting rooms required would be `2` because [0, 30] and [5, 10] overlap. Ensure your solution has a time complexity of O(n log n).","solution":"def min_meeting_rooms(intervals): Determines the minimum number of meeting rooms required given a list of intervals representing the reservation time slots of a meeting room. Args: intervals (list of list of int): A list of intervals [start, end]. Returns: int: Minimum number of meeting rooms required. if not intervals: return 0 # Separate out the start and end times and sort them start_times = sorted(interval[0] for interval in intervals) end_times = sorted(interval[1] for interval in intervals) start_pointer = 0 end_pointer = 0 used_rooms = 0 # Iterate through all meetings while start_pointer < len(intervals): # A new meeting is starting before the last one has ended, need a new room if start_times[start_pointer] < end_times[end_pointer]: used_rooms += 1 start_pointer += 1 else: # A meeting ended before the new one started, release a room end_pointer += 1 start_pointer += 1 return used_rooms"},{"question":"You are given a `0-indexed` array `nums` of length `n`, containing integers from `1` to `n`, where each number appears exactly once. Additionally, you are given an array `queries` where `queries[i]` is an integer. For each query `queries[i]`, find the index of `queries[i]` in array `nums` and move the element at that index to the beginning of the array `nums`. Return an array of `n` elements where the `i-th` element is the number of times the element originally at index `i` in `nums` is moved to the beginning of the array.","solution":"def query_indices(nums, queries): Returns an array where the i-th element is the number of times the element originally at index i in nums is moved to the beginning of the array. n = len(nums) original_positions = {num: i for i, num in enumerate(nums)} moves_count = [0] * n for query in queries: query_index = nums.index(query) # Increment the moves count for the original position of the query element original_position = original_positions[query] moves_count[original_position] += 1 # Move the queried element to the beginning nums = [nums[query_index]] + nums[:query_index] + nums[query_index+1:] return moves_count"},{"question":"Given a 2D `n x n` grid `matrix`, rotate the elements of the matrix 90 degrees clockwise in-place. * For example, if the initial matrix is: ``` [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] ``` The rotated matrix should be: ``` [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] ``` Rotate the matrix and return _the rotated matrix_.","solution":"def rotate_matrix(matrix): Rotates the given n x n matrix 90 degrees clockwise in-place. n = len(matrix) # Step 1: Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Step 2: Reverse each row for i in range(n): matrix[i].reverse() return matrix"},{"question":"You are given a matrix `grid` with `m` rows and `n` columns consisting of non-negative integers where each element represents the elevation at that point. The task is to determine if there is a path from the top-left corner (0,0) to the bottom-right corner (m-1,n-1) such that the maximum difference in elevation between any two consecutive cells on the path is minimized. You can move up, down, left, or right. Return the minimum possible value of the maximum difference in elevation between consecutive cells on this path.","solution":"import heapq def minimumEffortPath(heights): Calculate the minimum effort path from top-left to bottom-right in a grid with heights. This function uses Dijkstra\'s algorithm with a priority queue to find the minimum effort required. m, n = len(heights), len(heights[0]) efforts = [[float(\'inf\')] * n for _ in range(m)] efforts[0][0] = 0 heap = [(0, 0, 0)] # (effort, x, y) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] while heap: effort, x, y = heapq.heappop(heap) if (x, y) == (m-1, n-1): return effort for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n: new_effort = max(effort, abs(heights[nx][ny] - heights[x][y])) if new_effort < efforts[nx][ny]: efforts[nx][ny] = new_effort heapq.heappush(heap, (new_effort, nx, ny))"},{"question":"You are given a list of non-negative integers `nums`, representing the cost of purchasing `n` items. You also have an integer `target` that represents a budget. You want to determine whether it is possible to purchase a combination of items without exceeding the budget. Return _`True` if it\'s possible to purchase some combination of items within the budget and `False` otherwise_. You can assume you have an infinite supply of each item.","solution":"def can_purchase_within_budget(nums, target): Determine if it\'s possible to purchase a combination of items within the budget. :param nums: List of non-negative integers representing costs. :param target: An integer representing the budget. :return: True if it\'s possible to stay within the budget, False otherwise. # Initialize a list to hold possible sums up to the target. dp = [False] * (target + 1) dp[0] = True # Base case: a sum of 0 is always possible. # Iterate over each possible amount up to the target. for amount in range(target + 1): if dp[amount]: # Check each item cost to see if we can form a new amount. for cost in nums: if amount + cost <= target: dp[amount + cost] = True return dp[target]"},{"question":"You are given a string `s` and an array `pairs` of integers where `pairs[i] = [a, b]` indicates that you can swap the characters at index `a` and index `b` of string `s`. You want to sort the characters in each connected component of indices in string `s` and return the lexicographically smallest string that you can achieve. A connected component is a set of indices `i` where each index is connected either directly or indirectly through some pair in `pairs`. For example, given `s = \\"dcab\\"` and `pairs = [[0, 3], [1, 2]]`, you can swap characters at indices 0 and 3 to get \\"bcad,\\" and then swap characters at indices 1 and 2 to get \\"bacd.\\" Return _the lexicographically smallest string that can be obtained by swaps._","solution":"def smallestStringWithSwaps(s, pairs): from collections import defaultdict import heapq # Create a graph using adjacency list graph = defaultdict(list) for a, b in pairs: graph[a].append(b) graph[b].append(a) # Function to perform DFS and collect all connected indices and their characters def dfs(node, visited, indices, characters): stack = [node] while stack: u = stack.pop() if u not in visited: visited.add(u) indices.append(u) characters.append(s[u]) for v in graph[u]: if v not in visited: stack.append(v) visited = set() s = list(s) # Convert string to list for mutability # Traverse each component/connected indices and sort to get lexicographically smallest string for i in range(len(s)): if i not in visited: indices = [] characters = [] dfs(i, visited, indices, characters) indices.sort() characters.sort() for idx, char in zip(indices, characters): s[idx] = char return \'\'.join(s)"},{"question":"You are given a `2D` integer array `ranges` and an integer `value`. Each `ranges[i] = [start_i, end_i]` represents a range of integers from `start_i` to `end_i` both inclusive. Your task is to find out how many times the `value` appears within the ranges. You need to count the occurrences of `value` within all the provided ranges and return that count. If the `value` is not found in any of the ranges, return `0`.","solution":"def count_value_in_ranges(ranges, value): Returns the count of how many times the value appears within the provided ranges. :param ranges: List of lists, where each sublist contains two integers representing a range [start, end]. :param value: Integer value to count within the ranges. :return: Integer count of value appearances. count = 0 for start, end in ranges: if start <= value <= end: count += 1 return count"},{"question":"A string consists of lowercase alphabets and digits. Implement a function that rearranges the string such that all its digits appear at the end of the string, while maintaining the relative order of the non-digit characters and the digits. Return the rearranged string. For example, given the input string `\\"a1b2c3\\"`, the output should be `\\"abc123\\"`.","solution":"def rearrange_string(s): Rearranges the string such that all digits appear at the end, maintaining the relative order of both non-digit characters and digits. :param s: The input string consisting of lowercase alphabets and digits. :return: A rearranged string with all digits at the end. non_digits = [] digits = [] for char in s: if char.isdigit(): digits.append(char) else: non_digits.append(char) return \'\'.join(non_digits) + \'\'.join(digits)"},{"question":"You are given a list of integers `arr` and an integer `k`. You need to split the list into `k` contiguous subarrays such that the largest sum of any subarray is minimized. Implement the function `splitArray`: * `splitArray(int[] arr, int k)` which splits the list `arr` into `k` contiguous subarrays such that the largest sum of any subarray is as small as possible. Return this minimum possible largest sum. For example, if you are given the list `arr = [7,2,5,10,8]` and `k = 2`, one way to split the array is into `[7,2,5]` and `[10,8]` which has a largest sum of `18`.","solution":"def splitArray(arr, k): Function to split the array into k contiguous subarrays such that the largest sum of any subarray is minimized. def can_split(mid): current_sum = 0 count = 1 for num in arr: if current_sum + num > mid: count += 1 current_sum = num if count > k: return False else: current_sum += num return True left, right = max(arr), sum(arr) while left < right: mid = (left + right) // 2 if can_split(mid): right = mid else: left = mid + 1 return left"},{"question":"Given an array of integers `nums` and an integer `target`, return the number of distinct indices `i` such that `nums[i]` is equal to `target`. The function should have a time complexity of O(n). For example, given `nums = [1, 2, 3, 4, 2, 2, 3]` and `target = 2`, the function should return `3` because `2` appears at indices `1`, `4`, and `5`.","solution":"def count_target_occurrences(nums, target): Returns the number of distinct indices such that nums[i] is equal to target. Parameters: nums (list of int): The list of integers. target (int): The target integer. Returns: int: The count of target occurrences in the list. count = 0 for num in nums: if num == target: count += 1 return count"},{"question":"Given a 2D integer array `matrix` of dimensions `m x n`, where each element represents the height of the terrain at that point, return _all the cells that can flow water to both the Pacific and Atlantic oceans_. Water can flow from a cell to any adjacent cell directly north, south, east, or west if the adjacent cell\'s height is less than or equal to the current cell\'s height. The Pacific Ocean touches the left and top edges of the matrix, while the Atlantic Ocean touches the right and bottom edges. Return the answer as a list of coordinate pairs.","solution":"def pacific_atlantic(matrix): if not matrix or not matrix[0]: return [] m, n = len(matrix), len(matrix[0]) pacific_reachable = set() atlantic_reachable = set() def dfs(i, j, visited, prev_height): if ((i, j) in visited or i < 0 or i >= m or j < 0 or j >= n or matrix[i][j] < prev_height): return visited.add((i, j)) for x, y in [(i-1, j), (i+1, j), (i, j-1), (i, j+1)]: dfs(x, y, visited, matrix[i][j]) for i in range(m): dfs(i, 0, pacific_reachable, matrix[i][0]) dfs(i, n-1, atlantic_reachable, matrix[i][n-1]) for j in range(n): dfs(0, j, pacific_reachable, matrix[0][j]) dfs(m-1, j, atlantic_reachable, matrix[m-1][j]) return list(pacific_reachable & atlantic_reachable)"},{"question":"You are given a **0-indexed** integer array `arr` consisting of `n` elements. In one operation, you can choose any two indices `i` and `j` (0 <= i, j < n) such that `arr[i] != arr[j]`, and set either `arr[i]` to `arr[j]` or `arr[j]` to `arr[i]`. Return the _minimum number of operations needed to make all elements in the array equal._","solution":"def min_operations_to_equal_elements(arr): Returns the minimum number of operations needed to make all elements in the array equal. An operation is defined as choosing indices `i` and `j` such that `arr[i] != arr[j]` and setting either `arr[i]` to `arr[j]` or `arr[j]` to `arr[i]`. from collections import Counter frequency = Counter(arr) max_frequency = max(frequency.values()) return len(arr) - max_frequency"},{"question":"Given a list of unique integers `nums` and an integer `target`, return `true` if the two numbers sum up to the `target`. Otherwise, return `false`. You may assume that each input would have exactly one solution, and you may not use the same element twice.","solution":"def find_pair_with_sum(nums, target): Returns True if there are two numbers in `nums` that add up to `target`, otherwise returns False. :param nums: List of unique integers :param target: The target sum :return: Boolean indicating if there is a pair that sums to target seen = set() for num in nums: if target - num in seen: return True seen.add(num) return False"},{"question":"You are given a string `s` consisting of lowercase English letters. A \\"keep\\" operation involves removing a contiguous substring containing at most one distinct character from the string. The goal is to determine if it is possible to remove the entire string using the minimum number of \\"keep\\" operations. Return _the minimum number of \\"keep\\" operations needed to remove the whole string_.","solution":"def min_keep_operations(s): Returns the minimum number of \\"keep\\" operations needed to remove the entire string. if not s: return 0 operations = 1 for i in range(1, len(s)): if s[i] != s[i - 1]: operations += 1 return operations"},{"question":"You are given an array of integers `arr` where the ith element represents the amount of money inside the ith house. Thieves can only rob houses such that they never rob two adjacent houses (i.e., each house can only be robbed if neither of the adjacent houses to it has been robbed). Return the maximum amount of money the thieves can rob without alerting the police.","solution":"def rob_houses(arr): Given an array of integers where each element represents the amount of money in a house, return the maximum amount of money the thieves can rob without robbing two adjacent houses. if not arr: return 0 if len(arr) == 1: return arr[0] max_money = [0] * len(arr) max_money[0] = arr[0] max_money[1] = max(arr[0], arr[1]) for i in range(2, len(arr)): max_money[i] = max(max_money[i-1], arr[i] + max_money[i-2]) return max_money[-1]"},{"question":"You are given an array of integers `arr` and an integer `target`. Your task is to return _the **first continuous subarray** of `arr` that sums up to the `target`_. If no such subarray is found, return an empty array. For example, if `arr = [1, 2, 3, 4, 5]` and `target = 9`, the function should output `[2, 3, 4]` because the subarray `[2, 3, 4]` sums up to `9`.","solution":"def find_subarray_with_given_sum(arr, target): Returns the first continuous subarray of `arr` that sums up to `target`. If no such subarray is found, returns an empty array. current_sum = 0 start_index = 0 subarray_dict = {} for end_index in range(len(arr)): current_sum += arr[end_index] # Check if the current sum is the target if current_sum == target: return arr[start_index:end_index + 1] # If the current sum minus target exists in the dictionary, we have found a subarray if (current_sum - target) in subarray_dict: start_index = subarray_dict[current_sum - target] + 1 return arr[start_index:end_index + 1] # Store the current sum with its corresponding index subarray_dict[current_sum] = end_index return []"},{"question":"You are given a list of `employee` objects, where each `employee` has a **unique ID**, a **manager ID**, and a **project count** indicating the number of projects they are currently handling. The employees form a **hierarchical structure** such that each employee reports to exactly one manager directly or indirectly under a corporate CEO, who has a manager ID of -1. Implement a system which can provide the following functionalities: * `int totalProjectsManagedBy(int managerId)` Returns the total number of projects managed by the manager and all the employees in their hierarchy. * `int maxHierarchyLevelUnder(int managerId)` Returns the maximum number of levels under the specified manager. Implement the `Company` class: * `Company(List<Employee> employees)` Initializes the system with a list of employees. * `int totalProjectsManagedBy(int managerId)` Returns the total number of projects managed by the manager and all the employees in their hierarchy, given the manager\'s ID. * `int maxHierarchyLevelUnder(int managerId)` Returns the maximum number of levels under the specified manager, given the manager\'s ID. The `Employee` class is defined as follows: ```python class Employee: def __init__(self, id: int, managerId: int, projectCount: int): self.id = id self.managerId = managerId self.projectCount = projectCount ```","solution":"class Employee: def __init__(self, id: int, managerId: int, projectCount: int): self.id = id self.managerId = managerId self.projectCount = projectCount class Company: def __init__(self, employees): self.employees = employees self.manager_to_employees = {} self.id_to_employee = {} for e in employees: if e.managerId not in self.manager_to_employees: self.manager_to_employees[e.managerId] = [] self.manager_to_employees[e.managerId].append(e) self.id_to_employee[e.id] = e def totalProjectsManagedBy(self, managerId): if managerId not in self.id_to_employee: return 0 total_projects = 0 queue = [managerId] while queue: current_manager_id = queue.pop(0) if current_manager_id in self.id_to_employee: current_employee = self.id_to_employee[current_manager_id] total_projects += current_employee.projectCount if current_manager_id in self.manager_to_employees: queue.extend([e.id for e in self.manager_to_employees[current_manager_id]]) return total_projects def maxHierarchyLevelUnder(self, managerId): if managerId not in self.id_to_employee: return 0 max_level = 0 queue = [(managerId, 1)] while queue: current_manager_id, level = queue.pop(0) max_level = max(max_level, level) if current_manager_id in self.manager_to_employees: for e in self.manager_to_employees[current_manager_id]: queue.append((e.id, level + 1)) return max_level"},{"question":"Given a string `s` consisting of only lowercase English letters, you need to calculate the length of the **longest substring** of `s` that contains at most two distinct characters. Implement the `SubstringCalculator` class: * `SubstringCalculator(String s)` Initializes the object with the string `s`. * `int longestSubstringWithTwoDistinctChars()` Returns the length of the **longest substring** of `s` that contains at most two distinct characters. You must design an algorithm that works in `O(n)` time complexity where `n` is the length of the string `s`.","solution":"class SubstringCalculator: def __init__(self, s): self.s = s def longestSubstringWithTwoDistinctChars(self): Returns the length of the longest substring that contains at most two distinct characters. n = len(self.s) if n < 3: return n left = 0 right = 0 max_len = 2 hashmap = {} while right < n: if len(hashmap) < 3: hashmap[self.s[right]] = right right += 1 if len(hashmap) == 3: del_idx = min(hashmap.values()) del hashmap[self.s[del_idx]] left = del_idx + 1 max_len = max(max_len, right - left) return max_len"},{"question":"You are given a `0-indexed` array `peaks` of integers representing the height of mountains in a row. You must perform the following operation any number of times to equalize the row: Select any two adjacent mountains and reduce one of their heights by exactly `1`. Return _the minimum number of operations needed to make all the mountains the same height_.","solution":"def min_operations_to_equalize_mountains(peaks): Returns the minimum number of operations needed to make all the mountains the same height. Args: peaks (list of int): A list of integers representing the heights of the mountains. Returns: int: The minimum number of operations required. if not peaks: return 0 max_height = max(peaks) total_operations = sum(max_height - height for height in peaks) return total_operations"},{"question":"Given an integer array `heights` representing the heights of buildings, return _the total amount of **water** that can be **trapped** after raining_. The width of each building is 1. Use the two-pointer approach to achieve optimal time complexity. For example, given the heights `[0,1,0,2,1,0,1,3,2,1,2,1]`, the water trapped is `6`.","solution":"def trap(heights): Returns the total amount of water that can be trapped after raining. :param heights: List of integers representing the heights of buildings. :return: An integer representing the total amount of water trapped. if not heights: return 0 left, right = 0, len(heights) - 1 left_max, right_max = heights[left], heights[right] water_trapped = 0 while left < right: if left_max < right_max: left += 1 left_max = max(left_max, heights[left]) water_trapped += max(0, left_max - heights[left]) else: right -= 1 right_max = max(right_max, heights[right]) water_trapped += max(0, right_max - heights[right]) return water_trapped"},{"question":"You are given a linked list, where each node contains an integer value. Design a function `removeDuplicates` that removes all duplicate values from the list such that each element appears only once. The function should modify the linked list in-place and maintain the order of the first occurrences of each element. Return the modified linked list.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def removeDuplicates(head): Removes duplicates from a linked list. Args: head (ListNode): The head of the linked list. Returns: ListNode: The head of the modified linked list with duplicates removed. if not head: return head current = head seen = set([current.val]) while current.next: if current.next.val in seen: current.next = current.next.next else: seen.add(current.next.val) current = current.next return head def linked_list_to_list(head): Helper function to convert linked list to list. result = [] current = head while current: result.append(current.val) current = current.next return result"},{"question":"You are given two strings `s` and `t` containing only lowercase letters. Write a function to determine if `t` is an anagram of `s`. An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once. Your function should return `True` if `t` is an anagram of `s` and `False` otherwise. Write an algorithm with `O(n)` runtime complexity, where `n` is the length of the strings.","solution":"def is_anagram(s, t): Returns True if t is an anagram of s, False otherwise. if len(s) != len(t): return False # Create a dictionary to count characters in s count_s = {} for char in s: count_s[char] = count_s.get(char, 0) + 1 # Create a dictionary to count characters in t count_t = {} for char in t: count_t[char] = count_t.get(char, 0) + 1 # Compare both dictionaries return count_s == count_t"},{"question":"You are given a list of `n` noodles represented by an array `lengths`, where `lengths[i]` is the length of the `i-th` noodle. Your task is to determine the maximum number of pairs of noodles that can be combined to form a balanced noodle of at least a given length `m`. A pair of noodles is considered balanced if the sum of their lengths is at least `m`. Return the maximum number of balanced noodle pairs that can be formed.","solution":"def max_noodle_pairs(lengths, m): lengths = sorted(lengths) i, j = 0, len(lengths) - 1 count = 0 while i < j: if lengths[i] + lengths[j] >= m: count += 1 i += 1 j -= 1 else: i += 1 return count"},{"question":"You are given a string `s` consisting of lowercase English alphabets. Your task is to determine the minimum number of character deletions required such that no two adjacent characters are the same. For example, for `s = \\"aab\\"`, the output should be `1`, as deleting one of the `a` characters makes `s` equal to `\\"ab\\"`, where no two adjacent characters are the same. Write a function: ```python def min_deletions(s: str) -> int: # Your code here ``` that takes the input string `s` and returns the minimum number of deletions required.","solution":"def min_deletions(s: str) -> int: Returns the minimum number of deletions required such that no two adjacent characters are the same. if not s: return 0 deletions = 0 for i in range(1, len(s)): if s[i] == s[i - 1]: deletions += 1 return deletions"},{"question":"You are given an integer array `nums`. Two players, Player 1 and Player 2, take turns to pick a number from either end of the array (i.e., the first or last element in the array). Player 1 always starts first. Both players play optimally. Determine if Player 1 can be guaranteed to win or end the game in a tie if they both play optimally, assuming both players know the sequence of moves that will happen in advance. Return `true` if Player 1 can be guaranteed to win or tie, otherwise return `false`.","solution":"def can_player1_win(nums): Determines if Player 1 can be guaranteed to win or end the game in a tie, assuming both players play optimally. Args: nums (list of int): The input array of integers. Returns: bool: True if Player 1 can be guaranteed to win or tie, False otherwise. n = len(nums) # dp[i][j] will be the maximum score player 1 can achieve more than player 2 with subarray nums[i:j+1] dp = [[0] * n for _ in range(n)] # Initialize the dp array where the subarray have only one element for i in range(n): dp[i][i] = nums[i] # Fill the dp array for subarrays longer than one element for length in range(2, n + 1): # length ranges from 2 to n for i in range(n - length + 1): j = i + length - 1 dp[i][j] = max(nums[i] - dp[i + 1][j], nums[j] - dp[i][j - 1]) return dp[0][n - 1] >= 0"},{"question":"You are given a list of integers `arr` and an integer `k`. The task is to determine the **minimum sum of any subarray** of length `k` within the list. A subarray is a contiguous portion of the array. Return the _minimum sum of any subarray of length `k` in the given list_.","solution":"def min_sum_subarray(arr, k): Returns the minimum sum of any subarray of length k. if not arr or k <= 0 or k > len(arr): raise ValueError(\\"Invalid input\\") current_sum = sum(arr[:k]) min_sum = current_sum for i in range(k, len(arr)): current_sum += arr[i] - arr[i - k] min_sum = min(min_sum, current_sum) return min_sum"},{"question":"You are given a string `pattern` and a string `s`. Determine if `s` follows the same pattern. Here, \\"follow\\" means a full match, such that there is a one-to-one correspondence between a letter in `pattern` and a word in `s`. For example, given `pattern = \\"abba\\"` and `s = \\"dog cat cat dog\\"`, return `true`; given `pattern = \\"abba\\"` and `s = \\"dog cat cat fish\\"`, return `false`. Return _a boolean_ indicating whether `s` follows `pattern`.","solution":"def word_pattern(pattern: str, s: str) -> bool: Determine if s follows the same pattern as pattern. :param pattern: A string pattern where each character represents a distinct element. :param s: A string consisting of words separated by spaces. :return: A boolean indicating whether s follows pattern. words = s.split() if len(pattern) != len(words): return False char_to_word = {} word_to_char = {} for ch, word in zip(pattern, words): if ch not in char_to_word: if word in word_to_char: return False char_to_word[ch] = word word_to_char[word] = ch else: if char_to_word[ch] != word: return False return True"},{"question":"You are given two integers, `n` (number of nodes) and `m` (number of edges), representing a directed acyclic graph (DAG). Additionally, you are provided with an array, `edges`, where `edges[i] = [u, v]` denotes a directed edge from node `u` to node `v`. Find the length of the longest path in the DAG. Report the length of the longest path, or return `0` if there is no path (i.e., in case of isolated nodes).","solution":"from typing import List def find_longest_path(n: int, m: int, edges: List[List[int]]) -> int: from collections import defaultdict, deque # Create adjacency list and indegree array graph = defaultdict(list) indegree = [0] * n for u, v in edges: graph[u].append(v) indegree[v] += 1 # Topological sort using Kahn\'s algorithm topo_order = [] zero_indegree_queue = deque([i for i in range(n) if indegree[i] == 0]) while zero_indegree_queue: node = zero_indegree_queue.popleft() topo_order.append(node) for neighbor in graph[node]: indegree[neighbor] -= 1 if indegree[neighbor] == 0: zero_indegree_queue.append(neighbor) # If topo_order does not contain all nodes, the graph wasn\'t a DAG if len(topo_order) != n: return 0 # Initialize distances to each node in topo order distances = [0] * n for node in topo_order: for neighbor in graph[node]: if distances[neighbor] < distances[node] + 1: distances[neighbor] = distances[node] + 1 return max(distances) if distances else 0"},{"question":"You are given an integer array `data` consisting of `0`s and `1`s only. A segment of `data` is defined as any consecutive subarray of `data` of length `n`. The **hamming distance** between two segments of the same length is defined as the number of positions at which the corresponding elements are different. Given an integer `k`, find _the maximum hamming distance_ between any two non-overlapping segments of length `k` from `data`. If it is impossible to find such segments, return `-1`._","solution":"def max_hamming_distance(data, k): Returns the maximum hamming distance between two non-overlapping segments of length k. If it is impossible to find such segments, returns -1. n = len(data) # To have two non-overlapping segments of length k, data must be at least 2 * k long if n < 2 * k: return -1 max_dist = 0 for i in range(n - 2 * k + 1): for j in range(i + k, n - k + 1): dist = sum(1 for x, y in zip(data[i:i+k], data[j:j+k]) if x != y) if dist > max_dist: max_dist = dist return max_dist"},{"question":"Given an array of integers `arr`, return the maximum sum of any contiguous subarray of `arr`. A contiguous subarray is the segment of the array where all elements are consecutive. For instance, the contiguous subarray of `[1, 2, -3, 4, 5]` could be `[1, 2]`, `[4, 5]`, etc. If the array contains only negative numbers, the maximum sum should be the largest negative number.","solution":"def max_subarray_sum(arr): Returns the maximum sum of any contiguous subarray of arr. if not arr: return 0 # Handle case for empty array current_max = arr[0] global_max = arr[0] for num in arr[1:]: current_max = max(num, current_max + num) global_max = max(global_max, current_max) return global_max"},{"question":"You are given an array of non-negative integers representing the heights of buildings at different positions along a street. The distance between any two adjacent buildings is the same, and the width between two adjacent buildings is 1. The buildings are formulated such that they create a histogram-like structure when viewed from the side, where the height of each building represents the height at that specific position. Find the maximum volume of water (in square units) that can be trapped between buildings after it rains. Return _the maximum volume of water that can be trapped_.","solution":"def trap(height): Calculate the maximum amount of rainwater that can be trapped between the buildings after it rains. :param height: List[int] - a list of non-negative integers representing the heights of buildings. :return: int - the maximum volume of water that can be trapped. if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n water_trapped = 0 # Fill left_max array left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) # Fill right_max array right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) # Calculate the trapped water for i in range(n): water_trapped += min(left_max[i], right_max[i]) - height[i] return water_trapped"},{"question":"You are given an integer array `nums` and an integer `k`. Your task is to count the number of distinct pairs `(i, j)` such that `nums[i] + nums[j] = k` and `i != j`. Note that pairs `(i, j)` and `(j, i)` are considered the same and should only be counted once. Implement a function `int countPairs(int[] nums, int k)` that returns the number of distinct pairs.","solution":"def count_pairs(nums, k): Returns the number of distinct pairs (i, j) such that nums[i] + nums[j] = k and i != j. Pairs (i, j) and (j, i) are considered the same and counted only once. seen = set() pairs = set() for num in nums: target = k - num if target in seen: pairs.add((min(num, target), max(num, target))) seen.add(num) return len(pairs)"},{"question":"Given an unsorted integer array `nums`, find the smallest missing positive integer. You must implement an algorithm with `O(n)` time complexity. Return the smallest missing positive integer. Example: ``` Input: nums = [3,4,-1,1] Output: 2 Input: nums = [1,2,0] Output: 3 ```","solution":"def first_missing_positive(nums): Returns the smallest missing positive integer from an unsorted list of integers. The solution should have O(n) time complexity. n = len(nums) # Put each number in its right place for i in range(n): while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]: nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1] # Find the first position which does not have the correct number for i in range(n): if nums[i] != i + 1: return i + 1 return n + 1"},{"question":"You are given a string `s` consisting of lowercase letters, and an integer `k`. You need to remove the `k` most frequent characters from the string. If there are multiple characters with the same frequency, remove the characters in alphabetical order. Return the transformed string after performing the removals. The final string should be created by concatenating the remaining characters in their original order from `s`.","solution":"def remove_k_most_frequent(s, k): from collections import Counter # Count the frequency of each character in the string freq = Counter(s) # Sort characters by frequency (highest first), and alphabetically if frequencies are equal sorted_chars = sorted(freq.items(), key=lambda x: (-x[1], x[0])) # Find the k most frequent characters to remove chars_to_remove = {char for char, _ in sorted_chars[:k]} # Build the result string by excluding the characters to remove result = \'\'.join(char for char in s if char not in chars_to_remove) return result"},{"question":"You are given a grid of size `m x n` consisting of non-negative integers representing the maximum height of bars, where the value at `grid[i][j]` represents the height at position (i, j). You are also given an integer `t` representing the target height you want to achieve by removing the maximum amount of bars but without exceeding the target height. Return the maximum height that can be achieved without exceeding the target height in any cell of the grid, keeping the matrix structure intact.","solution":"def max_target_height(grid, t): Returns the maximum height achievable in the grid without exceeding the target height t by removing the maximum amount of bars. m = len(grid) n = len(grid[0]) if m > 0 else 0 max_height = 0 for i in range(m): for j in range(n): if grid[i][j] <= t: max_height = max(max_height, grid[i][j]) return max_height"},{"question":"Given a **0-indexed** array `heights` representing the heights of `n` buildings. A building `i` can see another building `j` if `i < j` and there is no building `k` such that `i < k < j` and `heights[k] >= heights[i]`. Return _the **total number of buildings** that can see at least one other building._","solution":"def can_see_building(heights): Returns the total number of buildings that can see at least one other building. n = len(heights) visible_count = 0 for i in range(n): can_see = False for j in range(i + 1, n): if heights[j] >= heights[i]: can_see = True break if can_see: visible_count += 1 return visible_count"},{"question":"Given an `n x n` matrix containing `0`s and `1`s, where `0` represents water and `1` represents land, determine the size of the largest island. An island is a group of `1`s connected vertically or horizontally. You may assume that all four edges of the matrix are surrounded by water. Return an integer representing the size of the largest island in the matrix.","solution":"def largest_island(matrix): Returns the size of the largest island (group of connected 1s) in the matrix. param matrix: List of lists representing the n x n matrix return: Integer representing the size of the largest island if not matrix or not matrix[0]: return 0 n = len(matrix) visited = [[False] * n for _ in range(n)] def dfs(x, y): Depth-first search to explore the island and calculate its size. param x, y: Coordinates of the current cell return: The size of the island if x < 0 or x >= n or y < 0 or y >= n or matrix[x][y] == 0 or visited[x][y]: return 0 visited[x][y] = True size = 1 # Current cell # Explore the four directions size += dfs(x + 1, y) size += dfs(x - 1, y) size += dfs(x, y + 1) size += dfs(x, y - 1) return size max_size = 0 for i in range(n): for j in range(n): if matrix[i][j] == 1 and not visited[i][j]: max_size = max(max_size, dfs(i, j)) return max_size"},{"question":"You are given an array of integers `nums` and an integer `k`. Your task is to determine _the maximum number of distinct elements in any contiguous subarray of length `k` in `nums`_. Return _an integer representing the maximum number of distinct elements possible_.","solution":"def max_distinct_elements(nums, k): Returns the maximum number of distinct elements in any contiguous subarray of length `k`. from collections import defaultdict if k > len(nums): return len(set(nums)) count = defaultdict(int) distinct_count = 0 max_distinct = 0 for i in range(k): if count[nums[i]] == 0: distinct_count += 1 count[nums[i]] += 1 max_distinct = distinct_count for i in range(k, len(nums)): if count[nums[i-k]] == 1: distinct_count -= 1 count[nums[i-k]] -= 1 if count[nums[i]] == 0: distinct_count += 1 count[nums[i]] += 1 max_distinct = max(max_distinct, distinct_count) return max_distinct"},{"question":"Given an array of `n` positive integers representing the daily revenue of a store, your task is to find the maximum length of a contiguous subarray where the daily revenue never decreases. A subarray is defined as a contiguous block of elements within the original array. For example, given the array `[10, 20, 20, 30, 25, 25, 20, 20, 20, 30]`, the contiguous subarray `[20, 20, 30, 30]` has a length of 4, which is the maximum length of all subarrays where the daily revenue never decreases. Write a function to return the length of this subarray.","solution":"def max_length_non_decreasing_subarray(arr): Returns the length of the longest contiguous subarray with non-decreasing daily revenue. if not arr: return 0 max_length = 1 current_length = 1 for i in range(1, len(arr)): if arr[i] >= arr[i - 1]: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length"},{"question":"You are given an array of integers `nums` representing the amount of money in each bank account. You are allowed to choose one bank account and transfer some money from it to another account. However, the amount of money transferred must be a power of 2. Your goal is to make the amounts in all bank accounts equal or determine that it\'s not possible. Write a function that returns `true` if it\'s possible to make all accounts equal using the allowed operations, otherwise, return `false`.","solution":"def is_possible_to_make_equal(nums): Determines if it\'s possible to make all bank account amounts equal by transferring amounts that are powers of 2. :param nums: List[int] - List of integers representing the amounts in each bank account :return: bool - True if it\'s possible to make all accounts equal, otherwise False def gcd(x, y): while y: x, y = y, x % y return x if len(nums) == 0: return True # Calculate the GCD of all the numbers current_gcd = nums[0] for num in nums[1:]: current_gcd = gcd(current_gcd, num) # Check each number after dividing by the GCD if it\'s a power of 2 for num in nums: divided_value = num // current_gcd # it should be exactly one 1 bit in binary representation for power of 2 if divided_value & (divided_value - 1) != 0: return False return True"},{"question":"Given a list of integers `nums`, return the length of the **longest subsequence** such that elements of the subsequence are consecutive integers. A subsequence is obtained by deleting some or no elements from the original list without changing the order of the remaining elements.","solution":"def longest_consecutive_subsequence(nums): Given a list of integers `nums`, returns the length of the longest subsequence such that elements of the subsequence are consecutive integers. if not nums: return 0 num_set = set(nums) longest_streak = 0 for num in nums: # Only start counting if `num` is the start of a sequence if num - 1 not in num_set: current_num = num current_streak = 1 while current_num + 1 in num_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"Given a square matrix `mat` of size `n x n`, determine the sum of the matrix\'s diagonals. The principal diagonal is the diagonal that runs from the top left to the bottom right of the matrix. The secondary diagonal is the diagonal that runs from the top right to the bottom left. Return the sum of the principal diagonal and the secondary diagonal. If there is an overlap (which happens when `n` is odd), do not double count the intersection element.","solution":"def diagonal_sum(mat): Returns the sum of the principal and secondary diagonals of a square matrix without double counting the middle element if the size of matrix is odd. Parameters: mat (list of list of int): The input square matrix of size n x n. Returns: int: The sum of the principal and secondary diagonals. n = len(mat) total_sum = 0 for i in range(n): total_sum += mat[i][i] # Principal diagonal total_sum += mat[i][n-1-i] # Secondary diagonal # If the matrix has an odd size, subtract the middle element once if n % 2 == 1: middle_index = n // 2 total_sum -= mat[middle_index][middle_index] return total_sum"},{"question":"You are given a string `expression` that represents a mathematical expression containing non-negative integers and operators `+`, `-`, `*`, `/`. The expression string contains no parentheses, and all integers in the expression are guaranteed to fit within the bounds of a 32-bit signed integer. The operators have the same precedence level where `*` and `/` should be evaluated before `+` and `-`. Implement a function to evaluate the given expression and return the result as an integer. Note that division between two integers should truncate toward zero. Write a function: ```python def calculate(expression: str) -> int: ``` that takes a string `expression` as input and returns an integer, the result of evaluating the expression. Example: ```python evaluate_expression(\\"3+2*2\\") # returns 7 evaluate_expression(\\" 3/2 \\") # returns 1 evaluate_expression(\\" 3+5 / 2 \\") # returns 5 ``` Note: - The provided expression will always be valid. - There will be no division by zero operations in the input.","solution":"def calculate(expression: str) -> int: Evaluates a mathematical expression containing non-negative integers and the operators +, -, *, /. The expression contains no parentheses and respects operator precedence (* and / before + and -). Division between two integers should truncate towards zero. :param expression: str: A valid mathematical expression string. :return: int: The result of the evaluation. # Initialize variables stack = [] num = 0 op = \\"+\\" # Ensure no spaces in the expression expression = expression.replace(\\" \\", \\"\\") for i, ch in enumerate(expression): if ch.isdigit(): num = num * 10 + int(ch) # If the current character is an operator or if it\'s the last character in the expression if ch in \\"+-*/\\" or i == len(expression) - 1: if op == \\"+\\": stack.append(num) elif op == \\"-\\": stack.append(-num) elif op == \\"*\\": stack.append(stack.pop() * num) elif op == \\"/\\": stack.append(int(stack.pop() / num)) # Use int() to truncate towards zero # Update the operation and reset the number op = ch num = 0 return sum(stack)"},{"question":"You are given an integer array `tasks` where `tasks[i]` represents the number of distinct times task i needs to be completed. To perform a task, you need a certain amount of consecutive days, and the number of days required for task i is represented by `days[i]`. You want to minimize the number of days during which you have to work to complete all tasks. Keep in mind the following: - Each task can only be performed on consecutive days. - You can do only one task per day. Return _the minimum number of days needed to complete all the tasks_. If it is not possible to complete all tasks, return `-1`.","solution":"def min_days_to_complete_tasks(tasks, days): Returns the minimum number of days needed to complete all tasks. If it\'s not possible to complete all tasks, return -1. :param tasks: List of integers where tasks[i] is the number of times task i needs to be completed. :param days: List of integers where days[i] is the number of consecutive days required to complete task i. :return: Minimum number of days to complete all tasks or -1 if not possible. if len(tasks) != len(days): return -1 total_days = 0 for task, day in zip(tasks, days): if day > task: return -1 total_days += day return total_days"},{"question":"A string `s` is called a **balanced parentheses string** if it is one of the following: * An empty string `\\"\\"`. * `s = \\"(\\" + A + \\")\\"`, where `A` is a balanced parentheses string. * `s = A + B`, where `A` and `B` are balanced parentheses strings. Given a balanced parentheses string `s`, you can insert a pair of parentheses `()` into any position in `s` to form a new balanced parentheses string. Your task is to return the **maximum depth** of balanced parentheses in the resulting string if we insert exactly one pair of parentheses. The **depth** of a balanced parentheses string is defined as the maximum depth of parentheses nesting in the string. For instance, the depth of `\\"((()))\\"` is 3, the depth of `\\"()\\"` is 1, and the depth of `\\"(()())\\"` is 2.","solution":"def max_depth_after_insertion(s: str) -> int: Given a balanced parentheses string s, returns the maximum depth of balanced parentheses in the resulting string after inserting exactly one pair of parentheses. current_depth = 0 max_depth = 0 for char in s: if char == \'(\': current_depth += 1 max_depth = max(max_depth, current_depth) elif char == \')\': current_depth -= 1 return max_depth + 1"},{"question":"Given a list of distinct integers `arr`, find the largest product that can be formed by multiplying any three of the integers. Return the maximum product.","solution":"def maximum_product_of_three(arr): Returns the largest product that can be formed by multiplying any three of the integers in the list. arr.sort() return max(arr[-1] * arr[-2] * arr[-3], arr[0] * arr[1] * arr[-1])"},{"question":"Implement a class RecentCounter to count recent requests. The class should have the following methods: * `RecentCounter()` Initializes the counter with an empty request log. * `int ping(int t)` Adds a new request at time `t`, where `t` represents some time in milliseconds, and returns the number of requests that have happened in the last 3000 milliseconds (including the new request). Note that each call to `ping` will have a strictly larger value of `t` than the previous call.","solution":"from collections import deque class RecentCounter: def __init__(self): self.requests = deque() def ping(self, t: int) -> int: self.requests.append(t) while self.requests[0] < t - 3000: self.requests.popleft() return len(self.requests)"},{"question":"Given a list of intervals representing the start and end times of multiple meetings, return the minimum number of conference rooms required. Each interval will be represented as a list of two integers `[start, end]`, where `start` is the starting time and `end` is the ending time of the meeting. Assume that no two meetings will end at the same time they start. For example: ``` Input: intervals = [[0, 30], [5, 10], [15, 20]] Output: 2 Input: intervals = [[7, 10], [2, 4]] Output: 1 ```","solution":"import heapq def minMeetingRooms(intervals): Determine the minimum number of conference rooms required. Args: intervals (List[List[int]]): List of intervals where each interval consists of [start, end] Returns: int: Minimum number of conference rooms required if not intervals: return 0 # Initialize a heap free_rooms = [] # Sort the meetings in increasing order of their start time. intervals.sort(key=lambda x: x[0]) # Add the first meeting. We have to give a new room to the first meeting. heapq.heappush(free_rooms, intervals[0][1]) # For all the remaining meeting rooms for i in intervals[1:]: # If the room due to free up the earliest is free, assign that room to this meeting. if free_rooms[0] <= i[0]: heapq.heappop(free_rooms) # If a new room is to be assigned, then also add to the heap. heapq.heappush(free_rooms, i[1]) # The size of the heap is the number of rooms allocated. return len(free_rooms)"},{"question":"You are given a grid of size `m x n` representing a room with three different possible states: a wall, an empty spot, or a person. A person can move to an adjacent empty spot (horizontally or vertically) and tries to reach the bottom-right corner of the room. However, there are walls they cannot pass through. Write a function that finds and returns the shortest path a person needs to take to reach the bottom-right corner from the top-left corner. If there is no path available, return `-1`.","solution":"from collections import deque def shortest_path(grid): Finds the shortest path from the top-left corner to the bottom-right corner in a grid. Parameters: grid (List[List[int]]): A 2D list representing the grid where 0 is an empty spot, 1 is a wall and 2 is the person starting position. Returns: int: The length of the shortest path if it exists, otherwise -1. if not grid: return -1 m, n = len(grid), len(grid[0]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] start = (0, 0) end = (m-1, n-1) # Check if start or end are blocked if grid[start[0]][start[1]] == 1 or grid[end[0]][end[1]] == 1: return -1 queue = deque([(start[0], start[1], 0)]) # (row, col, distance) visited = set() visited.add(start) while queue: r, c, dist = queue.popleft() # Check if we have reached the end if (r, c) == end: return dist for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < m and 0 <= nc < n and (nr, nc) not in visited and grid[nr][nc] == 0: visited.add((nr, nc)) queue.append((nr, nc, dist + 1)) return -1"},{"question":"Given an array of integers `nums` representing the position of houses along a street, return _the minimum number of heaters required to cover all the houses_. Each heater warms houses whose distance to the heater is less than or equal to its radius. The position of the heaters can be any integer along the street.","solution":"def find_min_heaters(nums): Returns the minimum number of heaters required to cover all the houses. Args: nums (list): list of integers representing the position of houses along a street. Returns: int: minimum number of heaters needed. if not nums: return 0 nums.sort() heaters_count = 0 i = 0 n = len(nums) while i < n: heaters_count += 1 location = nums[i] # Place heater at the current house i += 1 # Move i to the farthest house that can be covered by this heater while i < n and nums[i] <= location + 1: i += 1 # Location of the heater has been determined # Move i to the first house not covered by this heater location = nums[i - 1] + 1 while i < n and nums[i] <= location: i += 1 return heaters_count"},{"question":"Given a list of integers `nums`, one can perform a \\"merge operation\\" multiple times on `nums`, where in each merge operation, two adjacent elements are selected and replaced with their sum. The objective is to minimize the possible difference between the maximum and minimum elements in the list after performing a series of merge operations. Return the minimal possible difference between the maximum and minimum elements of the list after any sequence of merge operations is completed.","solution":"def min_difference_after_merges(nums): Returns the minimal possible difference between the maximum and minimum elements of the list after any sequence of merge operations is completed. # If the list is empty, the difference is 0 if not nums: return 0 # After enough merge operations, you are left with only one element: the sum of all elements. total_sum = sum(nums) # Since we are considering sums, and the list collapses to a single element # the minimax difference is always zero, because the maximum and minimum will be equal. return 0"},{"question":"You are given an **m x n** 2D grid containing characters `grid`, where each character represents a piece of fruit. Every such character is either \'`A`\' (apple), \'`B`\' (banana), or \'`O`\' (orange). You need to collect fruits by going through the grid starting from the top-left corner to the bottom-right corner while moving only down or right at each step. Your goal is to collect the maximum number of apples along the way. Write a function `maxApples(grid)` that returns the maximum number of apples you can collect.","solution":"def maxApples(grid): Returns the maximum number of apples (\'A\') that can be collected when traversing the grid from the top-left to the bottom-right corner, moving only down or right. if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) # Creating a 2D dp array to store the maximum apples collected up to each cell dp = [[0] * n for _ in range(m)] # Initialize the first cell dp[0][0] = 1 if grid[0][0] == \'A\' else 0 # Fill the first row for j in range(1, n): dp[0][j] = dp[0][j-1] + (1 if grid[0][j] == \'A\' else 0) # Fill the first column for i in range(1, m): dp[i][0] = dp[i-1][0] + (1 if grid[i][0] == \'A\' else 0) # Fill the rest of the dp array for i in range(1, m): for j in range(1, n): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + (1 if grid[i][j] == \'A\' else 0) # The answer is the bottom-right corner of the dp array return dp[m-1][n-1]"},{"question":"You are given a string `s` consisting of lowercase English letters and a list of words `dict` containing unique strings. Your task is to find all the start indices of `s`\'s substrings that are concatenations of each word in `dict` exactly once, and without any intervening characters. Each word in `dict` has the same length. Return all the start indices of the concatenation in any order. If there are no such substrings, return an empty list.","solution":"def findSubstring(s, words): Returns all the start indices of substring(s) that are concatenations of each word in words exactly once. if not s or not words: return [] word_length = len(words[0]) word_count = len(words) substring_length = word_length * word_count # Build a word frequency dictionary word_frequency = {} for word in words: if word in word_frequency: word_frequency[word] += 1 else: word_frequency[word] = 1 result_indices = [] for i in range(word_length): left = i right = i curr_frequency = {} word_used = 0 while right + word_length <= len(s): # Extract word from right pointer word = s[right:right+word_length] right += word_length if word in word_frequency: if word in curr_frequency: curr_frequency[word] += 1 else: curr_frequency[word] = 1 word_used += 1 # If there are more than needed of any word, shift the left pointer to the right to balance while curr_frequency[word] > word_frequency[word]: left_word = s[left:left+word_length] left += word_length curr_frequency[left_word] -= 1 word_used -= 1 # If all words are used the correct number of times, record the start index if word_used == word_count: result_indices.append(left) else: # Reset the count and move on curr_frequency.clear() word_used = 0 left = right return result_indices"},{"question":"You are given an unsorted array of integers `nums`. Your task is to find and return _all the triplets_ `[nums[i], nums[j], nums[k]]` such that `i < j < k` and `nums[i] + nums[j] + nums[k] == 0`. Each triplet should be sorted in ascending order, and the triplets should be sorted in ascending order lexicographically. Return the final list of triplets.","solution":"def three_sum(nums): Finds all unique triplets in the array which gives the sum of zero. Args: nums: List[int] - The list of integers. Returns: List[List[int]] - The list of triplets with elements in ascending order. nums.sort() triplets = [] n = len(nums) for i in range(n - 2): if i > 0 and nums[i] == nums[i - 1]: continue left, right = i + 1, n - 1 while left < right: total = nums[i] + nums[left] + nums[right] if total == 0: triplets.append([nums[i], nums[left], nums[right]]) while left < right and nums[left] == nums[left + 1]: left += 1 while left < right and nums[right] == nums[right - 1]: right -= 1 left += 1 right -= 1 elif total < 0: left += 1 else: right -= 1 return triplets"},{"question":"You are given an integer array `arr` and an integer `k`. Your task is to find the length of the shortest contiguous subarray that contains at least `k` distinct integers. If no such subarray exists, return `-1`.","solution":"def shortest_subarray_with_k_distinct(arr, k): Returns the length of the shortest contiguous subarray that contains at least k distinct integers. If no such subarray exists, return -1. from collections import defaultdict n = len(arr) if k > n: return -1 # Impossible to have k distinct elements if k > n l, r = 0, 0 min_length = float(\'inf\') count = defaultdict(int) distinct_count = 0 while r < n: count[arr[r]] += 1 if count[arr[r]] == 1: distinct_count += 1 while distinct_count >= k: min_length = min(min_length, r - l + 1) count[arr[l]] -= 1 if count[arr[l]] == 0: distinct_count -= 1 l += 1 r += 1 return min_length if min_length != float(\'inf\') else -1"},{"question":"You are given an integer array `nums` and an integer target. Write a function to determine if there are two integers in the array whose sum is equal to the target. Return true if such a pair exists, otherwise, return false. The function should use a hash map to achieve an efficient solution.","solution":"def has_pair_with_sum(nums, target): Determines if there are two integers in the array whose sum equals the target. :param nums: List[int] - List of integers :param target: int - Target sum :return: bool - True if such a pair exists, otherwise False seen = set() for num in nums: complement = target - num if complement in seen: return True seen.add(num) return False"},{"question":"You are given a list of positive integers `tasks`, where `tasks[i]` represents the time it takes to complete the ith task. You are also given an integer `k` which indicates the maximum number of tasks that can be executed concurrently by the processor. Each task must be completed without interruption once it is started. Your goal is to determine the minimum time required to complete all the tasks given the concurrency limit. Return _the minimum total time needed to finish all tasks_.","solution":"import heapq def min_time_to_complete_tasks(tasks, k): Computes the minimum total time needed to finish all tasks given the concurrency limit k. :param tasks: List of integers representing the time it takes to complete each task. :param k: Integer representing the maximum number of tasks that can be run concurrently. :return: Integer representing the minimum time to complete all tasks. if not tasks: return 0 # Min-heap to keep track of the finish time of tasks in each worker slot heap = [0] * k for time in tasks: # Pop the smallest finish time from the heap (indicates available time slot) available_time = heapq.heappop(heap) # Add the current task\'s time to the available time slot new_finish_time = available_time + time # Push the new finish time back into the heap heapq.heappush(heap, new_finish_time) # The maximum value in the heap represents the total time needed for all tasks to complete return max(heap)"},{"question":"You are given a 2D grid representing a labyrinth where each cell contains a number that shows the cost of moving through that cell. The goal is to find the path from the top-left corner (0,0) to the bottom-right corner (n-1,m-1) that minimizes the cost. You can only move right or down at any point in time. Return _the minimum cost to reach the bottom-right corner of the grid from the top-left_. The grid is represented as a 2D list `grid` of integers, where `grid[i][j]` represents the cost of cell `(i, j)`.","solution":"def min_cost_path(grid): Returns the minimum cost to reach the bottom-right corner of the grid from the top-left. Movement is restricted to right or down. if not grid or not grid[0]: return 0 n, m = len(grid), len(grid[0]) dp = [[0] * m for _ in range(n)] dp[0][0] = grid[0][0] for i in range(1, n): dp[i][0] = dp[i-1][0] + grid[i][0] for j in range(1, m): dp[0][j] = dp[0][j-1] + grid[0][j] for i in range(1, n): for j in range(1, m): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[n-1][m-1]"},{"question":"You are given an array of integers `arr` of length `n` and an integer `k`. You need to find the maximum sum of a continuous subarray of length `k`. Return this maximum sum.","solution":"def max_sum_subarray_length_k(arr, k): Returns the maximum sum of a continuous subarray of length k. Args: arr (list of int): The input array of integers. k (int): The length of the subarray. Returns: int: The maximum sum of a subarray of length k. if len(arr) < k: raise ValueError(\\"Array length must be at least k.\\") # Calculate the sum of the first subarray of length k max_sum = sum(arr[:k]) current_sum = max_sum # Slide the window of size k and update the sums for i in range(k, len(arr)): current_sum += arr[i] - arr[i - k] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"Given an array of integers `arr`, partition it into two (possibly empty) subsequences `X` and `Y` such that every element in `X` is strictly less than every element in `Y`. Return `true` if it is possible to achieve such a partition, or `false` otherwise.","solution":"def can_partition(arr): Determine if it\'s possible to partition the array into two subsequences X and Y such that every element in X is strictly less than every element in Y. if not arr: # An empty array or a single element array can always be partitioned return True # Check if the array is already sorted in strictly increasing order n = len(arr) for i in range(1, n): if arr[i-1] >= arr[i]: return False return True"},{"question":"You are given an array of integers `tasks` where `tasks[i]` represents the time it takes to complete the `i-th` task. There are **two workers** who will work on completing these tasks. Each worker can only work on one task at a time. The goal is to divide the tasks between the two workers such that the **completion time** (i.e., the time when both workers have completed all their tasks) is minimized. Write a function that takes in the `tasks` array and returns the **minimum completion time**. Assume that **both workers** begin at the same time. ```python def minCompletionTime(tasks: List[int]) -> int: # Your implementation here ```","solution":"def minCompletionTime(tasks): Given a list of tasks where each task takes a certain time to complete, the function returns the minimum completion time when two workers are used. Args: tasks (List[int]): A list of integers where each integer represents the time it takes to complete that task. Returns: int: The minimum completion time. # Sort tasks to try to balance them more effectively tasks.sort(reverse=True) # Initialize two workers\' timelines worker1 = 0 worker2 = 0 # Distribute tasks between workers for task in tasks: if worker1 <= worker2: worker1 += task else: worker2 += task # The completion time is the maximum of the two workers\' times return max(worker1, worker2)"},{"question":"You are given a list of integers `arr` that may contain duplicates. Your task is to find all unique triplets in the list which gives the sum of zero. Note that each triplet should be sorted in ascending order and the result should not contain duplicate triplets. Return the list of all such unique triplets.","solution":"def three_sum(arr): Returns a list of all unique triplets in arr that sum to zero. Each triplet should be sorted in ascending order. arr.sort() result = [] length = len(arr) for i in range(length - 2): if i > 0 and arr[i] == arr[i - 1]: continue left, right = i + 1, length - 1 while left < right: total = arr[i] + arr[left] + arr[right] if total == 0: result.append([arr[i], arr[left], arr[right]]) while left < right and arr[left] == arr[left + 1]: left += 1 while left < right and arr[right] == arr[right - 1]: right -= 1 left += 1 right -= 1 elif total < 0: left += 1 else: right -= 1 return result"},{"question":"You are given a 2D integer array `transactions` where `transactions[i] = [buyerId, sellerId, amount]`, representing a transaction where the buyer with `buyerId` pays the seller with `sellerId` an `amount` of money. Your task is to determine the net balance of each person. Return a 2D integer array `balances` where each element is `[personId, netBalance]`, representing the net balance of the person with `personId`. The `netBalance` is calculated as the total amount received by the person minus the total amount paid by the person. Ensure that `balances` is sorted in ascending order by `personId`.","solution":"def net_balance(transactions): Returns the net balance of each person given the transactions. :param transactions: List of transactions where each transaction is [buyerId, sellerId, amount] :return: 2D list where each element is [personId, netBalance] balance_map = {} # Calculate net balance for each person for buyerId, sellerId, amount in transactions: if buyerId not in balance_map: balance_map[buyerId] = 0 if sellerId not in balance_map: balance_map[sellerId] = 0 balance_map[buyerId] -= amount balance_map[sellerId] += amount # Convert balance_map to a sorted list balances = sorted([[personId, balance] for personId, balance in balance_map.items()]) return balances"},{"question":"You are given a 2D character grid of size `m x n` representing a map. Each cell in the grid contains either a `\'1\'` (representing land) or a `\'0\'` (representing water). An **island** is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are surrounded by water. Return _the number of distinct islands in the grid_.","solution":"def num_islands(grid): Returns the number of distinct islands in the given grid. if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) visited = [[False] * n for _ in range(m)] def dfs(x, y): if x < 0 or x >= m or y < 0 or y >= n or grid[x][y] == \'0\' or visited[x][y]: return visited[x][y] = True dfs(x+1, y) dfs(x-1, y) dfs(x, y+1) dfs(x, y-1) island_count = 0 for i in range(m): for j in range(n): if grid[i][j] == \'1\' and not visited[i][j]: dfs(i, j) island_count += 1 return island_count"},{"question":"You are given an array of integers `arr` where `arr[i]` represents the height of the `i-th` building in a row. A building with height `h` is said to have a **view** if there is no building taller than `h` to its right. Return _an array containing the indices of all the buildings that have a **view**._ The buildings should be listed in the same order as they appear in the original array.","solution":"def buildings_with_view(arr): Returns the indices of buildings that have a view. if not arr: return [] stack = [] max_height = -1 for i in range(len(arr) - 1, -1, -1): if arr[i] > max_height: stack.append(i) max_height = arr[i] return stack[::-1]"},{"question":"You are given an integer array `heights` representing the skyline of a city where `heights[i]` is the height of the building at the `i-th` position. The width of each building is `1`. There are some rainwater trapped between the buildings after a rainfall. Write a function that computes _the total amount of rainwater trapped_, ensuring that the function runs in `O(n)` time with constant extra space.","solution":"def trap(height): Returns the total amount of rainwater trapped. Args: height: List[int] - a list of integers representing the height of buildings. Returns: int - the total amount of rainwater trapped. if not height: return 0 left, right = 0, len(height) - 1 left_max, right_max = height[left], height[right] water_trapped = 0 while left < right: if left_max < right_max: left += 1 left_max = max(left_max, height[left]) water_trapped += max(0, left_max - height[left]) else: right -= 1 right_max = max(right_max, height[right]) water_trapped += max(0, right_max - height[right]) return water_trapped"},{"question":"You are given a list of integers `nums` and an integer `target`. Your task is to find the number of unique pairs `(i, j)` in the list such that `nums[i] + nums[j]` is equal to the `target`. Each element in the list can be used only once in a pair, and the pairs `(i, j)` and `(j, i)` are considered the same, so you should count them once. Return _the number of such unique pairs_. Note that the output might be a large number, so return it **modulo** `10^9 + 7`.","solution":"def count_pairs(nums, target): Returns the number of unique pairs (i, j) in the list such that nums[i] + nums[j] equals the target. The result is given modulo 10^9 + 7. MOD = 10**9 + 7 nums.sort() pairs = set() seen = set() for num in nums: if target - num in seen: pairs.add((min(num, target - num), max(num, target - num))) seen.add(num) return len(pairs) % MOD"},{"question":"Given a string `s` and a list of words `words`, determine if `s` is a concatenation of each word in `words` exactly once and without any intervening characters. The words can appear in any order. Return `true` if `s` can be formed this way, otherwise return `false`.","solution":"def can_form_by_concatenation(s, words): Determines if the string `s` can be formed by concatenating all words from the list `words` exactly once and in any order. Parameters: s (str): The string to be checked. words (list): List of words to concatenate. Returns: bool: True if `s` can be formed, else False. from collections import Counter # Combine the words to see if they add up to the given string `s` combined_words = \'\'.join(words) # If the combined length does not match `s`, return False early if len(combined_words) != len(s): return False # Use Counter to count characters in `s` and combined words return Counter(s) == Counter(combined_words)"},{"question":"You are given a string `s` containing digits from `\'2\'` to `\'9\'` inclusive, representing the mappings of letters on a standard telephone keypad. Return all possible letter combinations that the number could represent. Note that the order of the combinations does not matter. For example, if `s = \\"23\\"`: - The digit `\'2\'` corresponds to the letters `\'abc\'`. - The digit `\'3\'` corresponds to the letters `\'def\'`. Thus, the possible letter combinations are `[\\"ad\\", \\"ae\\", \\"af\\", \\"bd\\", \\"be\\", \\"bf\\", \\"cd\\", \\"ce\\", \\"cf\\"]`. If `s` is empty, return an empty list.","solution":"from typing import List def letter_combinations(digits: str) -> List[str]: Return all possible letter combinations that the number could represent. if not digits: return [] # Mapping of digits to letters phone_mapping = { \'2\': \'abc\', \'3\': \'def\', \'4\': \'ghi\', \'5\': \'jkl\', \'6\': \'mno\', \'7\': \'pqrs\', \'8\': \'tuv\', \'9\': \'wxyz\' } def backtrack(index: int, path: str): # If the path length is equal to digits length, add to results if len(path) == len(digits): result.append(path) return # Get the letters that the current digit can represent, and loop through them possible_letters = phone_mapping[digits[index]] for letter in possible_letters: backtrack(index + 1, path + letter) result = [] backtrack(0, \\"\\") return result"},{"question":"You are given an integer array `weights` where `weights[i]` is the weight of the `i`-th object. You are also given an integer `capacity` which represents the maximum weight that a knapsack can carry. You need to find the maximum total weight that can be accommodated in the knapsack without exceeding the capacity. Each item can only be included once in the knapsack. Return _an integer_ representing the maximum weight that can be carried by the knapsack.","solution":"def knapsack_max_weight(weights, capacity): Returns the maximum weight that can be accommodated in the knapsack without exceeding the capacity. n = len(weights) # Initialize a DP array with zeros. dp[j] represents the maximum weight for capacity j. dp = [0] * (capacity + 1) for weight in weights: # Traverse the dp array backwards to avoid recomputing results with the same weight for j in range(capacity, weight - 1, -1): dp[j] = max(dp[j], dp[j - weight] + weight) return dp[capacity]"},{"question":"You are given a string `s` consisting of lowercase English letters and an integer `k`. In one operation, you can select any substring of `s` and remove all its characters from the string. Your goal is to perform the minimum number of operations needed to make sure that no character in `s` appears more than `k` times. Return the minimum number of operations required. Implement a function `int minOperations(String s, int k)` that returns the minimum number of operations needed to satisfy the above condition.","solution":"from collections import Counter def min_operations(s: str, k: int) -> int: Returns the minimum number of operations needed to make sure that no character in the string `s` appears more than `k` times. Parameters: - s (str): The input string consisting of lowercase English letters. - k (int): The maximum number of allowed repetitions for a character. Returns: - int: The minimum number of operations required. counter = Counter(s) operations = 0 for char, count in counter.items(): if count > k: operations += (count - 1) // k return operations"},{"question":"You are given a string `s` that consists of digits from \'0\' to \'9\' and a number `k`. You can select exactly `k` adjacent digits in the string and remove them, making the string shorter by `k` characters. It is guaranteed that `k` will be less than the length of the string `s`. Your task is to return the smallest possible string after removing the `k` digits. Consider the following example: If `s = \\"1432219\\"` and `k = 3`, then the smallest possible string is `\\"1219\\"` after removing the digits \\"432\\". If `s = \\"10200\\"` and `k = 1`, then the smallest possible string is `\\"0200\\"` after removing the digit \\"1\\". The function should return a string representing the smallest possible sequence that can be obtained after removing `k` digits from `s`.","solution":"def remove_k_digits(s, k): Removes k digits from string s to make it the smallest possible number. Args: s (str): the input string consisting of digits. k (int): the number of digits to remove. Returns: str: the smallest possible string after removing k digits. stack = [] for digit in s: while k > 0 and stack and stack[-1] > digit: stack.pop() k -= 1 stack.append(digit) # If we still need to remove more digits, remove from the end stack = stack[:-k] if k > 0 else stack # Join stack to form the number and strip leading zeros return \'\'.join(stack).lstrip(\'0\') or \'0\'"},{"question":"Write a function `maxProduct` that takes in an array of integers `nums` and returns the maximum product of any non-empty contiguous subarray. The function should handle both positive and negative numbers efficiently.","solution":"def maxProduct(nums): Returns the maximum product of any non-empty contiguous subarray. if not nums: return 0 current_max = current_min = global_max = nums[0] for num in nums[1:]: if num < 0: current_max, current_min = current_min, current_max current_max = max(num, current_max * num) current_min = min(num, current_min * num) global_max = max(global_max, current_max) return global_max"},{"question":"Imagine you are given a binary string `s` of length `n`, consisting of only \'0\'s and \'1\'s. You are allowed to flip exactly one \'0\' to \'1\' to maximize the length of a contiguous substring of \'1\'s. Determine the length of the longest contiguous substring of \'1\'s you can achieve by performing this operation. If the string does not contain any \'0\', return `n`. Implement an algorithm that solves this problem in `O(n)` time. For example, given `s = \\"1101100111\\"`, you can flip the first \'0\', resulting in the string \\"1111100111\\", and the longest contiguous substring of \'1\'s will be 5.","solution":"def longest_ones(s): Returns the length of the longest contiguous substring of \'1\'s that can be achieved by flipping exactly one \'0\' to \'1\'. Parameters: s (str): The binary string of length n. Returns: int: Length of the longest contiguous substring of \'1\'s. n = len(s) if \'0\' not in s: return n max_len = 0 left = 0 count_zeros = 0 for right in range(n): if s[right] == \'0\': count_zeros += 1 while count_zeros > 1: if s[left] == \'0\': count_zeros -= 1 left += 1 max_len = max(max_len, right - left + 1) return max_len"},{"question":"You are given a list of `points` on a 2D plane, where `points[i] = [xi, yi]` represents the coordinates of the `i`-th point. Find the pair of points with the smallest Euclidean distance between them, and return the coordinates of these two points. If multiple pairs have the same smallest distance, return any one of them. The Euclidean distance between points `(xi, yi)` and `(xj, yj)` is defined as `sqrt((xi - xj)² + (yi - yj)²)`.","solution":"import math def closest_pair_of_points(points): Finds the pair of points with the smallest Euclidean distance between them. Parameters: points (List[List[int]]): A list of points on a 2D plane. Returns: Tuple[List[int], List[int]]: The coordinates of the two points with the smallest distance. min_distance = float(\'inf\') closest_pair = None for i in range(len(points)): for j in range(i + 1, len(points)): dist = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) if dist < min_distance: min_distance = dist closest_pair = (points[i], points[j]) return closest_pair"},{"question":"You are given a string `s` of lowercase English letters and an integer `k`. Your task is to partition the string into as many parts as possible so that each letter appears in at most one part, and then return the length of these parts. Each part should be continuous in the original string. For instance, if the string is \\"abacbc\\" and `k` is 2, one possible partition is \\"a|bacbc\\", which gives lengths [1, 5]. Note that the individual lengths [1, 5] sum up to the total length of the string. The goal is to return the lengths of all such parts.","solution":"def partition_labels(s): Partitions the string s into as many parts as possible so that each letter appears in at most one part and returns the lengths of these parts. last_occurrence = {ch: i for i, ch in enumerate(s)} j = anchor = 0 result = [] for i, ch in enumerate(s): j = max(j, last_occurrence[ch]) if i == j: result.append(i - anchor + 1) anchor = i + 1 return result"},{"question":"You are given an array of integers `nums` and an integer `target`. You need to count the number of pairs `(i, j)` in the array such that `nums[i] + nums[j] == target`, where `i` and `j` are distinct indices. Note that pairs `(i, j)` and `(j, i)` are considered the same and should only be counted once. Implement a function `countPairs` that takes an array of integers and a target integer as input and returns the number of such pairs. **Function signature**: ```python def countPairs(nums: List[int], target: int) -> int: ``` # Example: - Input: `nums = [1, 2, 3, 4, 3]`, `target = 6` - Output: `2` - Explanation: The pairs that sum up to 6 are (2, 3) and (3, 4). - Input: `nums = [1, 1, 1, 1]`, `target = 2` - Output: `6` - Explanation: All pairs (0, 1), (0, 2), (0, 3), (1, 2), (1, 3), and (2, 3) sum up to 2.","solution":"from typing import List def countPairs(nums: List[int], target: int) -> int: pair_count = 0 seen = {} for num in nums: complement = target - num if complement in seen: pair_count += seen[complement] if num in seen: seen[num] += 1 else: seen[num] = 1 return pair_count"},{"question":"You are given a string `s` consisting of only digits and an integer `k`. Insert commas into `s` to separate every `k` digits counting from the right end of the string. Return the modified string with commas inserted. The length of `s` is guaranteed to be at least `1` and `k` is guaranteed to be a positive integer.","solution":"def insert_commas(s, k): Inserts commas into the string `s` to separate every `k` digits counting from the right end of the string. Parameters: s (str): The input string consisting of only digits. k (int): The interval between commas. Returns: str: The modified string with commas inserted. # Reverse the string to make it easier to insert commas from the right s = s[::-1] # Insert commas parts = [s[i:i+k] for i in range(0, len(s), k)] # Join the parts with commas and reverse the result again return \\",\\".join(parts)[::-1]"},{"question":"You are given a list of integers `numbers` and a target integer `k`. Your task is to find all unique pairs of elements in the list that sum up to `k`. A pair consists of two different elements from `numbers` (i.e., `numbers[i]` and `numbers[j]` where `i != j`) and should be reported in a list of tuples. Each tuple should be sorted in ascending order, and the pairs of tuples should be sorted in ascending order based on the first element of each tuple. If no such pairs exist, return an empty list.","solution":"def find_pairs_with_sum(numbers, k): Finds all unique pairs in \'numbers\' that sum up to \'k\'. Each pair is represented as a tuple and the list is sorted. pairs = set() seen = set() for number in numbers: complement = k - number if complement in seen: pair = tuple(sorted((number, complement))) pairs.add(pair) seen.add(number) return sorted(pairs)"},{"question":"In a social network, each user is represented by a unique ID, and the friendships between users are represented by an undirected graph. You are given a list of integer pairs `friendships`, where each pair `(a, b)` denotes a bidirectional friendship between user `a` and user `b`. Implement the `FriendsNetwork` class: * `FriendsNetwork(int[][] friendships)` – Initializes the network with the given list of friendships. * `void addFriendship(int a, int b)` – Adds a bidirectional friendship between users `a` and `b`. * `void removeFriendship(int a, int b)` – Removes the bidirectional friendship between users `a` and `b`. * `List<Integer> getFriendsList(int user)` – Returns a list of all friends of the given `user`. The list should be returned in ascending order. The initial list of friendships and subsequent operations should dynamically update the network and ensure consistency in the friendships represented.","solution":"class FriendsNetwork: def __init__(self, friendships): Initializes the network with the given list of friendships. self.network = {} for a, b in friendships: if a not in self.network: self.network[a] = set() if b not in self.network: self.network[b] = set() self.network[a].add(b) self.network[b].add(a) def addFriendship(self, a, b): Adds a bidirectional friendship between users `a` and `b`. if a not in self.network: self.network[a] = set() if b not in self.network: self.network[b] = set() self.network[a].add(b) self.network[b].add(a) def removeFriendship(self, a, b): Removes the bidirectional friendship between users `a` and `b`. if a in self.network and b in self.network[a]: self.network[a].remove(b) if b in self.network and a in self.network[b]: self.network[b].remove(a) def getFriendsList(self, user): Returns a list of all friends of the given `user`. if user in self.network: return sorted(list(self.network[user])) return []"},{"question":"Given a 2-dimensional binary grid `grid` where `0` represents water and `1` represents land, find the length of the shortest path from the top-left corner to the bottom-right corner by flipping at most one `0` to `1`. If such a path does not exist, return `-1`. The path can only be constructed by moving horizontally or vertically.","solution":"from collections import deque def shortest_path_with_one_flip(grid): rows, cols = len(grid), len(grid[0]) if rows == 1 and cols == 1: return 1 if grid[0][0] == 1 else -1 def bfs(start): queue = deque([(start, 0, 0)]) visited = [[[False, False] for _ in range(cols)] for _ in range(rows)] visited[start[0]][start[1]][0] = True while queue: (r, c), dist, flip = queue.popleft() if (r, c) == (rows - 1, cols - 1): return dist + 1 for dr, dc in ((1, 0), (0, 1), (-1, 0), (0, -1)): nr, nc = r + dr, c + dc if 0 <= nr < rows and 0 <= nc < cols: if grid[nr][nc] == 1 and not visited[nr][nc][flip]: visited[nr][nc][flip] = True queue.append(((nr, nc), dist + 1, flip)) elif grid[nr][nc] == 0 and flip == 0 and not visited[nr][nc][1]: visited[nr][nc][1] = True queue.append(((nr, nc), dist + 1, 1)) return -1 return bfs((0, 0))"},{"question":"Given a string `s`, you need to find the longest substring that contains at most two distinct characters. **Examples:** 1. Input: `s = \\"eceba\\"` Output: `3` Explanation: The substring is `\\"ece\\"` which its length is 3. 2. Input: `s = \\"ccaabbb\\"` Output: `5` Explanation: The substring is `\\"aabbb\\"` which its length is 5. **Note:** - The length of the input string `s` will be in the range `[1, 10^4]`.","solution":"def length_of_longest_substring_two_distinct(s: str) -> int: Returns the length of the longest substring that contains at most two distinct characters. if len(s) < 3: return len(s) # Sliding window left and right pointers left, right = 0, 0 # Hashmap to store the count of characters in the current window window_counts = {} max_len = 2 while right < len(s): # Add the character at the right pointer to the window window_counts[s[right]] = window_counts.get(s[right], 0) + 1 right += 1 # If we have more than 2 distinct characters in the window, shrink the window from the left while len(window_counts) > 2: window_counts[s[left]] -= 1 if window_counts[s[left]] == 0: del window_counts[s[left]] left += 1 # Update the maximum length found max_len = max(max_len, right - left) return max_len"},{"question":"You are given an integer array `heights` representing the heights of students standing in a line. Each student can see the person directly in front and directly behind them, except for the students at the ends of the line. A student is considered \\"lonely\\" if they have a height greater than both their neighbors (only consider neighbors if they exist). Write a function to find the total count of \\"lonely\\" students in the line. Return the number of \\"lonely\\" students in the array.","solution":"def count_lonely_students(heights): Returns the count of lonely students in the list of heights. if len(heights) < 3: return 0 lonely_count = 0 for i in range(1, len(heights) - 1): if heights[i] > heights[i - 1] and heights[i] > heights[i + 1]: lonely_count += 1 return lonely_count"},{"question":"You are given two arrays of integers `arr1` and `arr2`, each containing unique elements sorted in ascending order. A _common subsequence_ of `arr1` and `arr2` is a sequence that appears in the same relative order in both arrays but not necessarily consecutively. Return the longest common subsequence (LCS) of `arr1` and `arr2` as an array. If there are multiple LCS of the same length, return **any of them**.","solution":"def longest_common_subsequence(arr1, arr2): Returns the longest common subsequence of the two arrays. m, n = len(arr1), len(arr2) # Create a DP table to store lengths of longest common subsequence. dp = [[0] * (n + 1) for _ in range(m + 1)] # Build the dp table in bottom-up manner for i in range(1, m + 1): for j in range(1, n + 1): if arr1[i - 1] == arr2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) # Reconstruct the longest common subsequence from the dp table. i, j = m, n lcs = [] while i > 0 and j > 0: if arr1[i - 1] == arr2[j - 1]: lcs.append(arr1[i - 1]) i -= 1 j -= 1 elif dp[i - 1][j] > dp[i][j - 1]: i -= 1 else: j -= 1 # The lcs array is constructed in reverse order. lcs.reverse() return lcs"},{"question":"Given a list of integers `nums`, return the number of **unique triplets** `[nums[i], nums[j], nums[k]]` such that `i != j`, `i != k`, and `j != k`, and `nums[i] + nums[j] + nums[k] == 0`. The solution set must not contain duplicate triplets.","solution":"def three_sum(nums): nums.sort() triplets = set() n = len(nums) for i in range(n): # Avoid duplicates for the current number if i > 0 and nums[i] == nums[i-1]: continue lo, hi = i+1, n-1 while lo < hi: total = nums[i] + nums[lo] + nums[hi] if total == 0: triplets.add((nums[i], nums[lo], nums[hi])) lo += 1 hi -= 1 while lo < hi and nums[lo] == nums[lo-1]: lo += 1 while lo < hi and nums[hi] == nums[hi+1]: hi -= 1 elif total < 0: lo += 1 else: hi -= 1 return list(triplets)"},{"question":"Given an integer `x`, return _the smallest integer `y` such that `y` is a power of two and `y` is greater than or equal to `x`_. If `x` is already a power of two, return `x`. You must write an algorithm that runs in logarithmic time.","solution":"def next_power_of_two(x): Returns the smallest power of two that is greater than or equal to x. If x is already a power of two, return x. if x < 1: raise ValueError(\\"Input must be a positive integer\\") # If x is already a power of two, return x if (x & (x - 1)) == 0: return x # Find the smallest power of two greater than x result = 1 while result < x: result <<= 1 return result"},{"question":"You are given a `k`-ary tree where each node has at most `k` children. Write a function to determine the maximum depth of the tree. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. The tree is represented using a node class with an integer value and a list of children nodes.","solution":"class Node: def __init__(self, value): self.value = value self.children = [] def maxDepth(root): Calculates the maximum depth of a k-ary tree. Parameters: - root (Node): The root node of the k-ary tree. Returns: - int: The maximum depth of the tree. if not root: return 0 if not root.children: return 1 max_child_depth = max(maxDepth(child) for child in root.children) return max_child_depth + 1"},{"question":"You are given two strings `s1` and `s2`, both consisting of lowercase English letters. Define the **score** of a substring as the sum of the positions of its characters in the English alphabet (`a` is 1, `b` is 2, ..., `z` is 26). A **substring** is a contiguous segment of a string. * For example, the score of the substring \\"abc\\" is `1 + 2 + 3 = 6`. Return _the **maximum** score of any substring that appears in both `s1` and `s2`._","solution":"def get_char_score(c): return ord(c) - ord(\'a\') + 1 def get_substring_score(s): return sum(get_char_score(c) for c in s) def max_score_common_substring(s1, s2): max_score = 0 s2_substrings = set() for i in range(len(s2)): for j in range(i + 1, len(s2) + 1): s2_substrings.add(s2[i:j]) for i in range(len(s1)): for j in range(i + 1, len(s1) + 1): substring = s1[i:j] if substring in s2_substrings: max_score = max(max_score, get_substring_score(substring)) return max_score"},{"question":"You are given a string `s` and an integer `k`. Your task is to split the string into `k` contiguous substrings such that the length of the shortest substring is maximized. Return an array of `k` substrings. If there are multiple solutions, return any of them. **Note**: The substrings should not overlap, and the concatenation of the substrings should result in the original string `s`.","solution":"def split_into_k_substrings(s, k): Split the string \'s\' into \'k\' contiguous substrings such that the length of the shortest substring is maximized. Return an array of \'k\' substrings. n = len(s) # total length of the string min_length = n // k # minimum possible length of each substring extra_chars = n % k # extra characters to be distributed result = [] start = 0 for i in range(k): # Calculate the length of the current substring current_length = min_length + (1 if i < extra_chars else 0) result.append(s[start:start + current_length]) start += current_length return result"},{"question":"Write a function that calculates the median of two sorted arrays `nums1` and `nums2` of size `n` and `m` respectively. The overall run time complexity should be `O(log(min(n, m)))`. The median is the value separating the higher half from the lower half of a data sample. If the total number of elements is odd, the median is the middle element. If the total number of elements is even, the median is the average of the two middle elements. Return the median of the two sorted arrays.","solution":"def findMedianSortedArrays(nums1, nums2): Finds the median of two sorted arrays with time complexity O(log(min(len(nums1), len(nums2)))). def get_kth_element(arr1, arr2, k): Helper function to get the k-th element in the merged and sorted array of arr1 and arr2. len1, len2 = len(arr1), len(arr2) index1, index2 = 0, 0 while True: if index1 == len1: return arr2[index2 + k - 1] if index2 == len2: return arr1[index1 + k - 1] if k == 1: return min(arr1[index1], arr2[index2]) new_index1 = min(index1 + k // 2 - 1, len1 - 1) new_index2 = min(index2 + k // 2 - 1, len2 - 1) pivot1, pivot2 = arr1[new_index1], arr2[new_index2] if pivot1 <= pivot2: k -= (new_index1 - index1 + 1) index1 = new_index1 + 1 else: k -= (new_index2 - index2 + 1) index2 = new_index2 + 1 total_length = len(nums1) + len(nums2) if total_length % 2 == 1: return get_kth_element(nums1, nums2, total_length // 2 + 1) else: return (get_kth_element(nums1, nums2, total_length // 2) + get_kth_element(nums1, nums2, total_length // 2 + 1)) / 2"},{"question":"You are given a list of integers `nums` and a target integer `target`. Your task is to determine if there are three distinct integers in `nums` whose sum is equal to `target`. Return `true` if such a combination exists, otherwise return `false`. Your solution should aim for an optimal time complexity.","solution":"def three_sum(nums, target): Determines if there are three distinct integers in nums whose sum equals target. Args: nums (list): List of integers. target (int): Target sum. Returns: bool: True if such a combination exists, False otherwise. nums.sort() # Sort the array first n = len(nums) for i in range(n - 2): if i > 0 and nums[i] == nums[i - 1]: continue # Avoid duplicates for the first element left, right = i + 1, n - 1 while left < right: current_sum = nums[i] + nums[left] + nums[right] if current_sum == target: return True elif current_sum < target: left += 1 else: right -= 1 return False"},{"question":"You are given a string `s` and an array `indices` of the same length where `indices[i]` represents the position of the character `s[i]` in the shuffled string. Return the shuffled string, where the character at the `i`th position of the `shuffled` string is the character `s[indices[i]]` from the original string.","solution":"def restore_string(s, indices): Returns the shuffled string where the character at the i-th position of the shuffled string is the character s[indices[i]]. :param s: str - The original string :param indices: List[int] - List of indices representing the new positions of the characters :return: str - The shuffled string # Initialize a list with the same length as the input string shuffled = [\'\'] * len(s) # Place each character in the shuffled list according to the indices for i, index in enumerate(indices): shuffled[index] = s[i] # Join the list into a string and return return \'\'.join(shuffled)"},{"question":"You are given two arrays `points1` and `points2` where `points1[i]` and `points2[j]` represent the coordinates of points in a 2D plane. Your task is to count the number of **rectangles** that can be formed using pairs of points from `points1` and `points2` as diagonally opposite corners. Return _the total count of such rectangles_. For example, if `points1` contains the points `[(1,2), (2,1)]` and `points2` contains `[(2,2), (1,1)]`, valid rectangles using these points as vertices include: - Rectangle formed by corners `(1, 2)`, `(2, 1)`, `(2, 2)`, and `(1, 1)`. Note that both pairs of points used to form the rectangle must be from the two different arrays (`points1` and `points2`).","solution":"def count_rectangles(points1, points2): Returns the count of rectangles formed using given pairs of points as diagonally opposite corners. point_set = set(points2) count = 0 for i in range(len(points1)): for j in range(i + 1, len(points1)): if (points1[i][0], points1[j][1]) in point_set and (points1[j][0], points1[i][1]) in point_set: count += 1 return count"},{"question":"Consider a list of integers, called `nums`, and an integer `k`. Write a function that finds the **maximum sum of a non-empty subarray of size `k` or less**. The subarray does not need to be contiguous, but **order must be maintained**. Your function should return this maximum sum. For example, given `nums = [4, 1, -2, 3, 5]` and `k = 3`, the optimal subarray would be `[4, 3, 5]` resulting in a sum of `12`. If `nums = [10, -2, 3, 1, 5]` and `k = 2`, the optimal subarray would be `[10, 5]` resulting in a sum of `15`.","solution":"from itertools import combinations def max_sum_subarray(nums, k): Finds the maximum sum of a non-empty subarray of size k or less. Args: nums: List of integers. k: Integer denoting the maximum size of subarray. Returns: Integer representing the maximum sum. if not nums or k <= 0: return 0 max_sum = float(\'-inf\') # Initialize to the lowest possible value for size in range(1, k+1): for combo in combinations(nums, size): current_sum = sum(combo) if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"You are given an array `arr` of positive integers and an integer `k`. Find the maximum sum of a contiguous subarray of length `k` in `arr`. Return _the_ _starting index_ _of this subarray_. If there are multiple subarrays with the same maximum sum, return the starting index of the first one.","solution":"def max_sum_subarray_index(arr, k): Returns the starting index of the subarray of length k with the maximum sum in arr. # Check for edge case where k is greater than the length of the array if k > len(arr): return -1 max_sum = -float(\'inf\') current_sum = 0 max_start_index = 0 for i in range(len(arr)): current_sum += arr[i] if i >= k: current_sum -= arr[i - k] if i >= k - 1 and current_sum > max_sum: max_sum = current_sum max_start_index = i - k + 1 return max_start_index"},{"question":"You are given a **0-indexed** array `nums` consisting of `n` integers, and a positive integer `m`. You need to partition the array into `m` continuous subarrays such that the **maximum** sum among these subarrays is minimized. Return _the minimized maximum sum_ that can be achieved by partitioning the array into `m` subarrays. For example, given `nums = [7, 2, 5, 10, 8]` and `m = 2`, the array can be partitioned as `[7, 2, 5]` and `[10, 8]` which results in the maximum sum of the subarrays being `15`.","solution":"def splitArray(nums, m): def can_split(nums, m, max_sum): sub_array_sum = 0 sub_array_count = 1 for num in nums: if sub_array_sum + num > max_sum: sub_array_count += 1 sub_array_sum = num if sub_array_count > m: return False else: sub_array_sum += num return True left, right = max(nums), sum(nums) while left < right: mid = (left + right) // 2 if can_split(nums, m, mid): right = mid else: left = mid + 1 return left"},{"question":"You are given a 2D integer array `matrix` where each cell contains a value representing the height of the terrain at that point, and an integer `T`. Water can flow from a cell to any of its 4 neighboring cells (up, down, left, or right) but only if the height of the neighboring cell is less than or equal to the height of the current cell. Determine if there is a path from the top-left corner of the matrix to the bottom-right corner such that the maximum height encountered along this path is at most `T`. Return `true` if such a path exists, otherwise return `false`.","solution":"def can_reach_with_max_height(matrix, T): Returns True if there is a path from the top-left to the bottom-right corner of the matrix such that the maximum height encountered along this path is at most T, otherwise False. rows, cols = len(matrix), len(matrix[0]) visited = [[False] * cols for _ in range(rows)] def dfs(x, y, max_height): if x < 0 or x >= rows or y < 0 or y >= cols or visited[x][y] or matrix[x][y] > max_height: return False if x == rows - 1 and y == cols - 1: return True visited[x][y] = True # Check all 4 directions if (dfs(x + 1, y, max_height) or dfs(x - 1, y, max_height) or dfs(x, y + 1, max_height) or dfs(x, y - 1, max_height)): return True visited[x][y] = False return False return dfs(0, 0, T)"},{"question":"You are given a 2D grid of size `m x n` representing a box, and you have `k` balls. The box is open on the top and bottom sides. Each cell in the box is either a wall, `1`, or an empty cell, `0`. A ball dropped into the box will travel in the following way: * If the ball hits an empty cell, it will move down to the next cell directly below it. * If the ball hits a wall, it will get stuck and stop moving. You need to determine the position of each ball after it has fallen through the box. The balls can only be dropped into the top row of the box, and each ball is dropped into a specific column. You are given an array `drop` where `drop[i]` is the column index where the `i-th` ball is dropped. Return an integer array `positions` where `positions[i]` is the column index where the `i-th` ball will come out of the box, or `-1` if the ball gets stuck in the box.","solution":"def find_ball_position(grid, drop): This function returns the position of each ball after it has fallen through the box. m, n = len(grid), len(grid[0]) positions = [] def fall_through_box(column): for row in range(m): if grid[row][column] == 1: return -1 elif grid[row][column] == 0: pass return column for column in drop: positions.append(fall_through_box(column)) return positions"},{"question":"Given a string `s` containing only characters \'(\', \')\', \'{\', \'}\', \'[\' and \']\', return the minimum number of bracket pairs you need to remove to make the string valid. A string is considered valid if it is empty or if it can be made by concatenating valid strings. For example, \\"()\\" and \\"()[]{}\\" are valid but \\"(]\\" and \\"([)]\\" are not.","solution":"def min_remove_to_make_valid(s): Returns the minimum number of bracket pairs you need to remove to make the string valid. stack = [] invalid_indices = set() for i, char in enumerate(s): if char in \\"({[\\": stack.append(i) elif char in \\")}]\\": if stack and ( (char == \\")\\" and s[stack[-1]] == \\"(\\") or (char == \\"}\\" and s[stack[-1]] == \\"{\\") or (char == \\"]\\" and s[stack[-1]] == \\"[\\") ): stack.pop() else: invalid_indices.add(i) invalid_indices = invalid_indices.union(set(stack)) return len(invalid_indices)"},{"question":"You are given an array of integers `arr`, where some elements of `arr` appear twice, and others appear once. Your task is to find all the elements that appear twice. Implement a function `findDuplicates` that takes the array `arr` and returns a list of integers representing the elements that appear twice in the array. The order of the returned elements does not matter. Optimize the function to run in O(n) time and use O(1) additional space.","solution":"def findDuplicates(arr): Returns a list of elements that appear twice in the given array. Args: arr (list of int): Array of integers where some elements appear twice, and others appear once. Returns: list of int: List of integers that appear twice in the array. result = [] for i in range(len(arr)): index = abs(arr[i]) - 1 if arr[index] < 0: result.append(abs(arr[i])) else: arr[index] = -arr[index] return result"},{"question":"Given a binary tree, return the sum of values of its deepest leaves. A node on a binary tree is considered a deepest leaf if it is a leaf node at the maximum depth of the tree. A binary tree is represented using level order traversal, where each group of children is separated by the `null` value (see examples).","solution":"# Definition for a binary tree node. class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def deepest_leaves_sum(root): Returns the sum of values of the deepest leaves in the binary tree. if not root: return 0 from collections import deque queue = deque([root]) while queue: level_sum = 0 for _ in range(len(queue)): node = queue.popleft() level_sum += node.val if node.left: queue.append(node.left) if node.right: queue.append(node.right) return level_sum"},{"question":"Given an array of integers `nums`, and an integer `k`, return _the top_ `k` _frequently occurring elements in the array_. Your solution should handle large data sets efficiently. Implement the `Solution` class: * `Solution(int[] nums, int k)` Initializes the object with the integer array `nums` and the integer `k`. * `int[] topKFrequent()` Returns an array of the top `k` frequently occurring elements in `nums`.","solution":"from collections import Counter import heapq class Solution: def __init__(self, nums, k): self.nums = nums self.k = k def topKFrequent(self): # Count the frequency of each element count = Counter(self.nums) # Use a heap to find the top k elements return heapq.nlargest(self.k, count.keys(), key=count.get)"},{"question":"You are given an `n x n` matrix representing a 2D grid of integers. Each cell in the grid can be either a `0` (empty) or a `1` (occupied by an obstacle). You are required to find the length of the shortest path from the top-left corner (0, 0) to the bottom-right corner (n-1, n-1). If there is no such path, return `-1`. The path can only be constructed by moving between adjacent cells, either up, down, left, or right, and no cell on the path can be occupied by an obstacle. Return _the length of the shortest path from the top-left corner to the bottom-right corner of the grid (or `-1` if no such path exists)_.","solution":"from collections import deque def shortest_path_in_grid(grid): n = len(grid) if n == 0 or grid[0][0] == 1 or grid[n-1][n-1] == 1: return -1 # Directions for moving up, down, left, and right directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 1)]) # (x, y, distance) visited = set((0, 0)) while queue: x, y, dist = queue.popleft() if x == n-1 and y == n-1: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < n and (nx, ny) not in visited and grid[nx][ny] == 0: queue.append((nx, ny, dist + 1)) visited.add((nx, ny)) return -1"},{"question":"You are given a list of integers `nums` and a target integer `k`. You need to rotate the sublists within `nums` to the right by one position. Specifically, for every contiguous subarray of length `k`, rotate the elements such that the last element of the subarray moves to the first position, and all other elements move one position to the right. Return the modified list after all such rotations. Note that the length of `nums` is guaranteed to be a multiple of `k`.","solution":"def rotate_sublists(nums, k): Rotates every contiguous subarray of length k in nums to the right by one position. Parameters: nums (list of int): The list of integers to be rotated. k (int): The length of each sublist to rotate. Returns: list of int: The list after rotating the sublists. n = len(nums) for i in range(0, n, k): nums[i:i+k] = [nums[i+k-1]] + nums[i:i+k-1] return nums"},{"question":"You are given a **0-indexed** string `s` of length `n` consisting of lowercase English letters. A substring of `s` is defined as a contiguous sequence of characters within the string. A substring is called **distinct** if it contains no duplicate characters. Write a function to find the length of the longest distinct substring of `s`. If the string contains no distinct substrings, return `0`. __Example:__ * For `s = \\"abcabcbb\\"`, the longest distinct substring is `\\"abc\\"`, with length 3. * For `s = \\"bbbbb\\"`, the longest distinct substring is `\\"b\\"`, with length 1. * For `s = \\"pwwkew\\"`, the longest distinct substring is `\\"wke\\"`, with length 3.","solution":"def length_of_longest_distinct_substring(s: str) -> int: Return the length of the longest distinct substring in given string s. A distinct substring has no duplicate characters. n = len(s) if n == 0: return 0 max_len = 0 start = 0 seen = {} for end in range(n): if s[end] in seen: start = max(start, seen[s[end]] + 1) seen[s[end]] = end max_len = max(max_len, end - start + 1) return max_len"},{"question":"Given an undirected, connected tree with `n` nodes labeled from `1` to `n` and `n - 1` edges. You are given a 2D array `edges` where `edges[i] = [u, v]` indicates that there is an undirected edge between nodes `u` and `v` in the tree. Each node has an integer value associated with it represented by an integer array `values`, where `values[i]` is the value of the node labeled `i + 1`. You are also given an integer array `queries`, where each element in `queries` represents the number of the node whose value you need to double. Return the sum of all node values after processing all the queries.","solution":"def process_tree(n, edges, values, queries): Process the tree based on the given edges, values, and queries. Doubles the value of the nodes specified in the queries and returns the sum of all node values after processing. :param n: int, number of nodes in the tree :param edges: List[List[int]], the edges between nodes :param values: List[int], the initial values of the nodes :param queries: List[int], the list of queries specifying which nodes to double the value :return: int, the sum of all node values after processing the queries # Initialize an adjacency list for the tree (though it\'s not actually used, process is simple here) tree = {i: [] for i in range(1, n + 1)} for u, v in edges: tree[u].append(v) tree[v].append(u) # Process all queries for query in queries: node_index = query - 1 # convert node label to zero-based index values[node_index] *= 2 # Return the sum of all node values return sum(values)"},{"question":"You are given an array of integers `nums` and an integer `threshold`. You can perform a series of operations on the array where, in each operation, you can decrease any element of the array by 1. Return the minimum number of operations required such that the sum of the array after each operation does not exceed `threshold`.","solution":"def min_operations(nums, threshold): Returns the minimum number of operations required such that the sum of the array after each operation does not exceed threshold. total_sum = sum(nums) operations = 0 # We continue to decrease elements until the total_sum is not greater than threshold while total_sum > threshold: max_val = max(nums) max_index = nums.index(max_val) # Decrease the maximum element by 1 nums[max_index] -= 1 total_sum -= 1 operations += 1 return operations"},{"question":"Given an integer array `arr` where the elements are either `0` or `1`, you can change up to `k` values from `0` to `1`. Return _the maximum length of a contiguous subarray containing only_ `1`_\'s after making at most_ `k` _changes_.","solution":"def longest_ones(arr, k): Returns the maximum length of a contiguous subarray containing only 1\'s after changing at most k 0\'s to 1\'s. :param arr: List[int] -- array of integers where the elements are either 0 or 1 :param k: int -- maximum number of changes from 0 to 1 :return: int -- maximum length of contiguous subarray containing only 1\'s left = 0 max_length = 0 zeros_count = 0 for right in range(len(arr)): if arr[right] == 0: zeros_count += 1 while zeros_count > k: if arr[left] == 0: zeros_count -= 1 left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"You are given two strings `s1` and `s2` representing two non-negative integers. The goal is to add these two numbers and return the sum as a string. The strings consist of digits and do not contain any leading zeros except for the number zero itself. You **cannot** use any built-in functions that directly convert the strings to integers or handle large integers. Implement the function to perform this addition manually, simulating the process of \\"elementary school\\" addition.","solution":"def add_strings(s1, s2): Adds two non-negative integer strings and returns the sum as a string. # Initialize pointers for both strings i, j = len(s1) - 1, len(s2) - 1 carry = 0 result = [] # Process both strings from the end to the beginning while i >= 0 or j >= 0 or carry: n1 = int(s1[i]) if i >= 0 else 0 n2 = int(s2[j]) if j >= 0 else 0 # Calculate the sum of the digits plus carry total = n1 + n2 + carry carry = total // 10 result.append(str(total % 10)) # Move to the next digits i -= 1 j -= 1 # The result is built in reverse order return \'\'.join(result[::-1])"},{"question":"You are given a string `s` representing a compressed version of a string where each character is followed by an integer representing the number of times that character appears consecutively. For example, the string `\\"a2b1c5a3\\"` represents the expanded string `\\"aabcccccaaa\\"`. Implement a function to decompress the string and return the expanded form. Note: - The input string will always be valid and follow the described format. - The expanded string may contain characters beyond \'a\' to \'z\'.","solution":"def decompress_string(s): Decompresses the given compressed string and returns the expanded form. :param s: Compressed string where each character is followed by an integer indicating the number of times it appears consecutively :type s: str :return: Expanded string :rtype: str expanded_string = [] i = 0 while i < len(s): char = s[i] count = 0 # Move to the number following the character i += 1 while i < len(s) and s[i].isdigit(): count = count * 10 + int(s[i]) i += 1 expanded_string.append(char * count) return \'\'.join(expanded_string)"},{"question":"You are given a positive integer `n` representing the number of nodes in an **undirected connected graph**. The nodes are numbered from `0` to `n - 1` (**inclusive**). You are also given a 2D integer array `edges`, where `edges[i] = [node1, node2]` denotes that there is an **edge** between `node1` and `node2` in the graph. Return _the number of connected components in the graph after removing a specified edge from each node to its neighboring nodes_. If a node has no edges, consider it as a separate component.","solution":"def count_components_after_removal(n, edges): Returns the number of connected components in the graph after removing a specified edge from each node to its neighboring nodes. Parameters: n (int): number of nodes in the graph edges (List[List[int]]): list of edges between nodes Returns: int: number of connected components # Creating the adjacency list graph = {i: [] for i in range(n)} for edge in edges: u, v = edge graph[u].append(v) graph[v].append(u) visited = [False] * n components = 0 def dfs(node): stack = [node] while stack: current = stack.pop() for neighbor in graph[current]: if not visited[neighbor]: visited[neighbor] = True stack.append(neighbor) for node in range(n): if not visited[node]: visited[node] = True components += 1 dfs(node) return components"},{"question":"You are given a binary tree where each node contains an integer value. Implement a function `sumOfDeepestLeaves` to calculate the sum of the values of the deepest leaves in the tree. Two nodes are considered to be at the same level if they have the same distance from the root. Nodes are the deepest if they have the maximum distance from the root. Return the sum of these deepest leaves\' values.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sumOfDeepestLeaves(root): if not root: return 0 from collections import deque max_level = 0 deepest_sum = 0 queue = deque([(root, 0)]) while queue: node, level = queue.popleft() if level > max_level: max_level = level deepest_sum = node.val elif level == max_level: deepest_sum += node.val if node.left: queue.append((node.left, level + 1)) if node.right: queue.append((node.right, level + 1)) return deepest_sum"},{"question":"Given an **integer array** `nums`, return _the **length** of the longest continuous **subarray**_ that contains only unique elements. A **subarray** is a contiguous part of the array, and an element from the array can appear in the subarray **exactly once**.","solution":"def longest_unique_subarray(nums): Returns the length of the longest continuous subarray that contains only unique elements. n = len(nums) if n == 0: return 0 seen = {} start = 0 max_length = 0 for end in range(n): if nums[end] in seen: start = max(start, seen[nums[end]] + 1) seen[nums[end]] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"You are given a string `s` and an array of strings `words`. All the strings in `words` are of the same length. Return _the number of substrings of `s` that are concatenations of each string in words exactly once without any intervening characters_. You can return the substrings in any order. The order of the words does not matter.","solution":"def findSubstring(s, words): Returns the starting indices of substring(s) in `s` that are the concatenation of each word in `words` exactly once without intervening characters. :param s: String in which to search :param words: List of words to be concatenated :return: List of starting indices of the concatenation substring(s) from collections import Counter if not s or not words or not words[0]: return [] word_len = len(words[0]) num_words = len(words) total_len = word_len * num_words words_count = Counter(words) result = [] for i in range(len(s) - total_len + 1): seen = Counter() for j in range(num_words): word_index = i + j * word_len word = s[word_index:word_index + word_len] if word in words_count: seen[word] += 1 if seen[word] > words_count[word]: break else: break else: result.append(i) return result"},{"question":"You are given a 2D grid of letters represented by a list of strings. Your task is to find the number of unique paths from the top-left corner to the bottom-right corner of the grid such that each path spells out a word composed of distinct letters. You can move right or down at any step. Each letter in the grid can be used only once in a single path. Given the grid, return the number of such unique paths. Since the answer may be large, return the answer **modulo `10^9 + 7`**. Example: Input: ``` [ [\\"a\\", \\"b\\", \\"c\\"], [\\"d\\", \\"e\\", \\"f\\"], [\\"g\\", \\"h\\", \\"i\\"] ] ``` Output: `Number of unique paths from (0,0) to (2,2)`","solution":"MOD = 10**9 + 7 def unique_paths(grid): Returns the number of unique paths from the top-left to the bottom-right of the grid such that each path spells out a word composed of distinct letters. def dfs(x, y, visited): if x == len(grid) - 1 and y == len(grid[0]) - 1: return 1 paths = 0 if x < len(grid) - 1 and grid[x+1][y] not in visited: visited.add(grid[x+1][y]) paths = (paths + dfs(x + 1, y, visited)) % MOD visited.remove(grid[x+1][y]) if y < len(grid[0]) - 1 and grid[x][y+1] not in visited: visited.add(grid[x][y+1]) paths = (paths + dfs(x, y + 1, visited)) % MOD visited.remove(grid[x][y+1]) return paths visited = set() visited.add(grid[0][0]) return dfs(0, 0, visited)"},{"question":"You are given a list of `n` integers `nums` and an integer `target`. Return indices of the three numbers such that their sum is closest to `target`. You may assume that each input would have exactly one solution, and you may not use the same element more than once. The function should return the indices as a list of three integers in any order.","solution":"def three_sum_closest(nums, target): nums.sort() # Sort the array to use two-pointer approach closest_sum = float(\'inf\') closest_indices = [] for i in range(len(nums) - 2): left, right = i + 1, len(nums) - 1 while left < right: current_sum = nums[i] + nums[left] + nums[right] if abs(current_sum - target) < abs(closest_sum - target): closest_sum = current_sum closest_indices = [i, left, right] if current_sum < target: left += 1 elif current_sum > target: right -= 1 else: return [i, left, right] return closest_indices"},{"question":"You are given a list of `transactions` where each transaction is represented with a tuple `(sender, receiver, amount)`. A transaction `(sender, receiver, amount)` means that the `sender` transfers `amount` of money to the `receiver`. Your task is to determine the net balance of each individual involved in the transactions. The net balance is defined as the total amount of money received minus the total amount of money sent. Return a dictionary where the keys are the individuals and the values are their respective net balances. If an individual has a net balance of zero, they should not appear in the result. You can assume that no two transactions are identical.","solution":"def calculate_net_balances(transactions): Calculate the net balances of individuals involved in the transactions. Parameters: transactions (list of tuples): A list of transactions where each transaction is represented as a tuple (sender, receiver, amount). Returns: dict: A dictionary where keys are individuals and values are their respective net balances. balance_dict = {} for sender, receiver, amount in transactions: # Update the sender\'s balance if sender in balance_dict: balance_dict[sender] -= amount else: balance_dict[sender] = -amount # Update the receiver\'s balance if receiver in balance_dict: balance_dict[receiver] += amount else: balance_dict[receiver] = amount # Remove individuals with a net balance of zero net_balances = {person: balance for person, balance in balance_dict.items() if balance != 0} return net_balances"},{"question":"You are given a list of `n` different tasks, where each task has a specific duration in minutes. Tasks are represented as an array of integers `tasks`, where `tasks[i]` is the duration of the `ith` task. You have `two` workers who can work simultaneously on tasks. Your objective is to assign the tasks to the two workers in such a way that the **maximum** duration of tasks assigned to either worker is minimized. Return _the **minimum possible** maximum duration of tasks assigned to either worker_. For example, given tasks `[5, 8, 1, 4]`, the optimal assignment is to give tasks `[5, 4]` to one worker and `[8, 1]` to the other worker. The maximum duration for either worker is `9`.","solution":"def can_assign_tasks(tasks, max_time): # Start with two workers worker1_time, worker2_time = 0, 0 for task in sorted(tasks, reverse=True): if worker1_time + task <= max_time: worker1_time += task elif worker2_time + task <= max_time: worker2_time += task else: return False return True def minimize_max_task_duration(tasks): left, right = max(tasks), sum(tasks) while left < right: mid = (left + right) // 2 if can_assign_tasks(tasks, mid): right = mid else: left = mid + 1 return left"},{"question":"You are given a string `s` consisting of lowercase Latin letters and an integer `count`. Your task is to return the smallest lexicographically string possible by removing exactly `count` characters from the string `s`. Note that the final string should preserve the relative order of the original string\'s characters.","solution":"def remove_characters(s, count): Returns the smallest lexicographically string by removing exactly \'count\' characters from \'s\'. stack = [] to_remove = count for char in s: while stack and to_remove > 0 and stack[-1] > char: stack.pop() to_remove -= 1 stack.append(char) # If there are still characters to remove, remove from the end result = stack[:-to_remove] if to_remove else stack return \'\'.join(result)"},{"question":"You are given a binary string `s` of length `n`, representing a sequence of people standing in a line. Each character in `s` can either be \'0\' (indicating a person who is wearing a mask) or \'1\' (indicating a person who is not wearing a mask). According to health guidelines, two people who are standing next to each other must not be both unmasked. You can change the state of any person (from \'0\' to \'1\' or from \'1\' to \'0\') in one unit of time. Determine the minimum number of changes required to ensure the guideline is followed for the entire string.","solution":"def min_changes_to_follow_guideline(s): Returns the minimum number of changes required to follow the health guidelines. n = len(s) prev_char = None changes = 0 for char in s: # If previous character and current one are both \'1\', a change is needed if prev_char == \'1\' and char == \'1\': changes += 1 prev_char = \'0\' # Change current \'1\' to \'0\' to follow the guideline else: prev_char = char return changes"},{"question":"You are given a **0-indexed** string `s` consisting of only lowercase English letters. A **sequence** of indices `(i1, i2, ..., ik)` is called a **good subsequence** if the concatenation of `s[i1]`, `s[i2]`, ..., `s[ik]` is a palindrome. Return the length of the longest **good subsequence** of `s` that can be achieved by deleting some (or no) characters of the string.","solution":"def longest_good_subsequence_length(s): Returns the length of the longest good subsequence of `s` that can be achieved by deleting some (or no) characters of the string. A good subsequence is defined as a sequence of indices whose concatenation is a palindrome. Parameters: s (str): a string consisting of only lowercase English letters. Returns: int: the length of the longest good subsequence. from collections import Counter if not s: return 0 count = Counter(s) max_odd_freq_char = None length = 0 for char, freq in count.items(): if freq % 2 == 0: length += freq else: length += freq - 1 if max_odd_freq_char is None or freq > count[max_odd_freq_char]: max_odd_freq_char = char if max_odd_freq_char: length += 1 return length"},{"question":"You are given a string `s` of length `n` consisting of lowercase English letters and an integer `k`. Your task is to modify the string `s` such that you can re-arrange the string into a palindrome. You can modify the string by replacing at most `k` characters in `s` with any lowercase English letter. Return _a boolean value indicating whether it is possible to rearrange `s` into a palindrome by performing at most `k` modifications._","solution":"def can_form_palindrome_with_modifications(s, k): from collections import Counter # Count frequency of each character in the string freq = Counter(s) # Count the number of characters with odd frequencies odd_count = sum(1 for count in freq.values() if count % 2 != 0) # In a palindrome, at most one character with an odd frequency is allowed # We need to convert (odd_count - 1) odd frequencies to even, needing (odd_count - 1) modifications # Thus, check if the necessary modifications do not exceed k return (odd_count - 1) // 2 <= k"},{"question":"Given an integer array `arr` representing the stock prices of a company on different days, return the maximum profit you could achieve if you can make at most two transactions. A transaction is defined as buying and then selling one share of the stock. Note that you cannot engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again). Write a function `maxProfitWithTwoTransactions(arr)` that takes in the array `arr` and returns an integer representing the maximum profit.","solution":"def maxProfitWithTwoTransactions(arr): Given an integer array representing the stock prices of a company on different days, return the maximum profit achieved with at most two transactions. if not arr or len(arr) < 2: return 0 n = len(arr) # dp[i] will store the maximum profit as \'i\' transactions. profits = [[0] * n for _ in range(3)] # Up to 2 transactions for k in range(1, 3): max_diff = -arr[0] for i in range(1, n): profits[k][i] = max(profits[k][i - 1], arr[i] + max_diff) max_diff = max(max_diff, profits[k - 1][i] - arr[i]) return profits[2][n - 1]"},{"question":"You are given an array of integers `arr` and an integer `k`. Find the **maximum number** of `subarrays` of `arr` of length `k` that are **distinct**. Two subarrays are considered distinct if they contain different sequences of elements. Implement the `SubarrayFinder` class: * `SubarrayFinder(int[] arr, int k)` Initializes the `SubarrayFinder` class with the array `arr` and the integer `k`. * `int countDistinctSubarrays()` Returns the number of distinct subarrays of length `k` from the array `arr`.","solution":"class SubarrayFinder: def __init__(self, arr, k): self.arr = arr self.k = k def countDistinctSubarrays(self): if self.k <= 0 or self.k > len(self.arr): return 0 subarrays = set() for i in range(len(self.arr) - self.k + 1): subarray = tuple(self.arr[i:i + self.k]) subarrays.add(subarray) return len(subarrays)"},{"question":"Given the `root` of a binary tree, return _a list of the sums of the values of each level_. The tree is indexed from level 0 at the root, which means the sum of the root\'s value is the first element in the list, the sum of the second level (children of the root) is the second element, and so on. If the tree is empty, return an empty list.","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_sums(root): Returns a list of sums of the values for each level of the binary tree. if not root: return [] result = [] queue = deque([root]) while queue: level_sum = 0 level_size = len(queue) for _ in range(level_size): node = queue.popleft() level_sum += node.val if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level_sum) return result"},{"question":"You are given an `n x n` grid representing a 2D maze. An empty cell is represented by `0`, and a wall is represented by `1`. You are also given a starting position `(startRow, startCol)` and an ending position `(endRow, endCol)`. You can move up, down, left, or right to adjacent empty cells. Determine the minimum number of moves required to reach the ending position from the starting position. If it is not possible to reach the end, return `-1`. Return _the minimum number of moves required to reach the ending position from the starting position_.","solution":"from collections import deque def min_moves_maze(grid, startRow, startCol, endRow, endCol): rows, cols = len(grid), len(grid[0]) if grid[startRow][startCol] == 1 or grid[endRow][endCol] == 1: return -1 directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(startRow, startCol, 0)]) # (row, col, distance) visited = set((startRow, startCol)) while queue: r, c, dist = queue.popleft() if (r, c) == (endRow, endCol): return dist for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < rows and 0 <= nc < cols and grid[nr][nc] == 0 and (nr, nc) not in visited: visited.add((nr, nc)) queue.append((nr, nc, dist + 1)) return -1"},{"question":"You are given a list of integers `nums` representing stock prices on different days. You need to find the maximum profit you can achieve. You can complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times) with the following restriction: After you sell your stock, you cannot buy stock on the next day (i.e., cooldown one day). Return _the maximum profit_ you can achieve from this list of stock prices.","solution":"def max_profit_with_cooldown(prices): Calculate the maximum profit with a cooldown period of one day after each sell. Args: prices (List[int]): List of stock prices. Returns: int: Maximum profit achievable. if not prices: return 0 n = len(prices) if n == 1: return 0 # Initialize DP arrays hold = [0] * n # Max profit when holding stock on day i sold = [0] * n # Max profit when selling stock on day i rest = [0] * n # Max profit when resting (cooling down) on day i # Base cases hold[0] = -prices[0] for i in range(1, n): hold[i] = max(hold[i-1], rest[i-1] - prices[i]) sold[i] = hold[i-1] + prices[i] rest[i] = max(rest[i-1], sold[i-1]) return max(sold[-1], rest[-1])"},{"question":"You are given an array of integers `heights` representing the height of students in a classroom. Students are initially standing in a row in the order they appear in `heights`. A student can see over the student in front of them if the student in front is shorter. A student cannot see if the student in front has the same height or is taller. Return an array of integers representing the number of students each student can see when looking ahead. The output array should be of the same length as the input array `heights`, where each element at index `i` contains the number of students that the student at index `i` can see.","solution":"def number_of_students_can_see(heights): Returns an array of integers representing the number of students each student can see when looking ahead. :param heights: List[int] heights of students :return: List[int] number of students each student can see n = len(heights) result = [0] * n for i in range(n): count = 0 for j in range(i + 1, n): if heights[j] <= heights[i]: count += 1 else: break result[i] = count return result"},{"question":"Given an integer array `nums`, find and return the length of the longest subsequence such that all elements of the subsequence are sorted in increasing order and the absolute difference between any two consecutive elements of the subsequence is `1`. For example, given `nums = [1, 2, 3, 4, 5]`, the output should be `5` because the whole array is a valid subsequence.","solution":"def longest_consecutive_subsequence(nums): Returns the length of the longest subsequence where all elements are sorted in increasing order and the absolute difference between any two consecutive elements is 1. if not nums: return 0 nums_set = set(nums) longest_length = 0 for num in nums: if num - 1 not in nums_set: # start of a new sequence current_num = num current_length = 1 while current_num + 1 in nums_set: current_num += 1 current_length += 1 longest_length = max(longest_length, current_length) return longest_length"},{"question":"**[Question 4]** You are given an array of non-negative integers `nums`, where each element in the array represents the maximum jump length you can make from that position. Your goal is to determine if you can reach the last index starting from the first index. Return `true` _if you can reach the last index, or_ `false` _otherwise_.","solution":"def can_jump(nums): Determines if you can reach the last index starting from the first index. :param nums: List of non-negative integers representing max jump lengths. :return: Boolean value whether you can reach the last index. max_reach = 0 for i, jump in enumerate(nums): if i > max_reach: return False max_reach = max(max_reach, i + jump) return max_reach >= len(nums) - 1"},{"question":"You are given an array `tasks` where `tasks[i]` represents the amount of time required to complete the i-th task. You have to schedule these tasks in such a way that each task is finished before its corresponding deadline `deadline[i]`. Implement a function `bool canCompleteTasks(vector<int>& tasks, vector<int>& deadline)` that determines if it is possible to complete all the tasks before their deadlines given that you can work on only one task at a time. The function should return `true` if all tasks can be scheduled within their deadlines, and `false` otherwise.","solution":"def canCompleteTasks(tasks, deadlines): Determines if all tasks can be completed before their respective deadlines. :param tasks: List[int], an array where each element represents the time required for a task :param deadlines: List[int], an array where each element represents the deadline for a task :return: bool, True if all tasks can be completed before their deadlines, False otherwise # Combine tasks and deadlines into one list of tuples (task_time, deadline) task_deadline_pairs = list(zip(tasks, deadlines)) # Sort the tasks by their deadlines task_deadline_pairs.sort(key=lambda x: x[1]) current_time = 0 for task_time, deadline in task_deadline_pairs: current_time += task_time if current_time > deadline: return False return True"},{"question":"A **linked list cycle** occurs when a linked list loops back to one of its previous nodes, creating an infinite loop. Your task is to identify if a given singly linked list has a cycle in it. Specifically, you need to write a function that detects whether a cycle exists in the linked list. Define a class `ListNode` alongside the function accordingly: - `class ListNode`: - `int val` - `ListNode next` Implement the function `bool hasCycle(ListNode head)` that returns `true` if there is a cycle in the linked list, or `false` otherwise. **Follow-up challenge**: Can you solve it using O(1) (i.e., constant) memory?","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def hasCycle(head): Detects if a cycle exists in a linked list. :param head: ListNode - The head of the linked list. :return: bool - True if there is a cycle, False otherwise. slow, fast = head, head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: return True return False"},{"question":"You are given a balanced binary search tree (BST) and an integer `k`. The task is to find the `kth` smallest element in the BST. Write a function that takes the root of the BST and the integer `k` and returns the `kth` smallest element. Assume that `k` is always valid (1 ≤ k ≤ number of nodes in the BST).","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def kth_smallest(root, k): Finds the kth smallest element in a BST. :param root: TreeNode, the root of the binary search tree :param k: int, the k-th position to find the smallest element :return: int, k-th smallest element in the given BST def inorder(node): if node is None: return [] return inorder(node.left) + [node.val] + inorder(node.right) inorder_sequence = inorder(root) return inorder_sequence[k-1]"},{"question":"You are given a string `s` consisting of only digits (`0`-`9`). You can swap any two adjacent digits at most once. Return the lexicographically smallest string possible after performing at most one swap. **Notes:** * You cannot swap the same pair of digits more than once. * You can choose not to perform any swap if the current string is already the smallest possible.","solution":"def smallest_possible_string(s): Returns the lexicographically smallest string possible after performing at most one swap of adjacent digits. n = len(s) for i in range(n - 1): if s[i] > s[i + 1]: # Swap and break s = s[:i] + s[i + 1] + s[i] + s[i + 2:] return s return s"},{"question":"You are given a string `s` consisting of lowercase English letters, and an integer array `shift` of the same length. Each element `shift[i]` represents the number of positions by which the character `s[i]` should be shifted forward in the alphabet. After all shifts are applied, return the final transformed string. Note that after \'z\', it wraps around to \'a\'. For example, shifting \'z\' by 1 will result in \'a\'.","solution":"def shift_characters(s, shift): Shifts each character in the string `s` forward by the corresponding value in the `shift` list. Wraps around after \'z\' to \'a\'. Parameters: s (str): input string of lowercase English letters. shift (list): list of integers representing shift values. Returns: str: the resulting string after all shifts are applied. def shift_char(c, shift_value): # Calculate new character position new_position = (ord(c) - ord(\'a\') + shift_value) % 26 # Return shifted character return chr(ord(\'a\') + new_position) return \'\'.join(shift_char(c, shift_value) for c, shift_value in zip(s, shift))"},{"question":"Given a positive integer `num`, write a function to check whether it contains every digit from `1` to `9` at least once. Return `true` if it does, and `false` otherwise. For example: - `containsAllDigits(123456789)` returns `true`. - `containsAllDigits(9876543210)` returns `true`, since `0` can be present but is not required. - `containsAllDigits(13579)` returns `false`.","solution":"def containsAllDigits(num): Check if the number contains every digit from 1 to 9 at least once. Parameters: num (int): Positive integer to check Returns: bool: True if it contains all digits from 1 to 9, False otherwise digit_set = set(str(num)) required_digits = {str(d) for d in range(1, 10)} return required_digits.issubset(digit_set)"},{"question":"You are given an array of integers `nums` and an integer `k`. Your task is to split the array into `k` non-empty subarrays such that the maximum sum among these subarrays is minimized. Return _the minimized maximum sum_ of the split subarrays. For instance, if the array `nums` consists of `[7,2,5,10,8]` and `k=2`, one optimal way to split it might be `[7,2,5]` and `[10,8]`, resulting in the minimized maximum sum of `18`. Use a binary search approach combined with a greedy algorithm to achieve the desired results.","solution":"def splitArray(nums, k): def canSplit(mid): current_sum = 0 subarrays_needed = 1 for num in nums: if current_sum + num > mid: subarrays_needed += 1 current_sum = num if subarrays_needed > k: return False else: current_sum += num return True left, right = max(nums), sum(nums) while left < right: mid = (left + right) // 2 if canSplit(mid): right = mid else: left = mid + 1 return left"},{"question":"Given two strings `s1` and `s2`, write a function that determines the minimum number of operations required to convert `s1` into `s2`. The allowed operations are: - Insert a character - Delete a character - Replace a character Each of these operations counts as one step. Return the minimum number of steps required to make the two strings identical. This is a typical problem that can be solved using dynamic programming.","solution":"def min_distance(s1, s2): Returns the minimum number of operations required to convert s1 into s2. Allowed operations are insert, delete, and replace a character. m, n = len(s1), len(s2) # Create a 2D DP array with (m+1)x(n+1) to hold subproblem results dp = [[0] * (n + 1) for _ in range(m + 1)] # Initialize the base case when one of the strings is empty for i in range(m + 1): dp[i][0] = i for j in range(n + 1): dp[0][j] = j # Fill the DP table for i in range(1, m + 1): for j in range(1, n + 1): if s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1 return dp[m][n]"},{"question":"You are given a list of strings `words`. Each word consists of lowercase English letters and can appear multiple times in the list. Your task is to return a list of lists of words where each sublist contains words that are anagrams of each other. The output list should contain the sublists in no particular order. For example: - If `words = [\\"bat\\", \\"tab\\", \\"cat\\", \\"act\\", \\"tac\\", \\"rat\\"]`, the function should return `[[\'act\', \'cat\', \'tac\'], [\'bat\', \'tab\'], [\'rat\']]`. Note that each word belongs to one and only one sublist, and each sublist contains all words that are anagrams of each other.","solution":"from collections import defaultdict def group_anagrams(words): Groups the words into lists of anagrams. :param words: List of strings :return: List of lists containing anagrams anagrams = defaultdict(list) for word in words: # Sort the word to form the key sorted_word = \'\'.join(sorted(word)) # Append the original word to the appropriate anagram group anagrams[sorted_word].append(word) # Return the list of anagram groups return list(anagrams.values())"},{"question":"Given an integer array `nums` of length `n`, where every integer between `1` and `n` (inclusive) appears exactly once except one number which appears twice and another number which is missing. Determine the number which appears twice and the number which is missing. Return these two numbers in an array in the form `[duplicate, missing]`.","solution":"def find_duplicate_and_missing(nums): Returns the number which appears twice and the number which is missing. The return value is an array in the form [duplicate, missing]. n = len(nums) correct_sum = n * (n + 1) // 2 correct_sum_sq = n * (n + 1) * (2*n + 1) // 6 actual_sum = sum(nums) actual_sum_sq = sum(x * x for x in nums) sum_diff = correct_sum - actual_sum sum_sq_diff = correct_sum_sq - actual_sum_sq duplicate = (sum_sq_diff - sum_diff * sum_diff) // (2 * sum_diff) missing = sum_diff + duplicate return [duplicate, missing]"},{"question":"A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward (ignoring spaces, punctuation, and capitalization). You are given a string `s`, determine the minimum number of insertions needed to make the string a palindrome. Return the minimum number of insertions required.","solution":"def min_insertions_to_make_palindrome(s): Returns the minimum number of insertions needed to make the string `s` a palindrome. def lcs(str1, str2): m = len(str1) n = len(str2) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): if str1[i - 1] == str2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[m][n] reversed_s = s[::-1] lcs_len = lcs(s, reversed_s) return len(s) - lcs_len"},{"question":"You are given a string `s` that contains a mix of letters and digits. Write a function that returns a permutation of `s` where the positions of digits remain unchanged, and only the letters are sorted in **ascending order**. If it is not possible to rearrange the letters to be in ascending order without changing the positions of the digits, return the same string `s`.","solution":"def sort_letters(s): Returns a permutation of s where the positions of digits remain unchanged, and only the letters are sorted in ascending order. chars = [c for c in s if c.isalpha()] chars.sort() result = [] letter_idx = 0 for c in s: if c.isalpha(): result.append(chars[letter_idx]) letter_idx += 1 else: result.append(c) return \'\'.join(result)"},{"question":"You are given a list of integers `arr` and an integer `d`. Each element in `arr` represents the heights of buildings. Suppose you can jump from a building to another if and only if the height of the destination building is at most `d` units lower or higher than the current building. Return _the maximum number of buildings you can visit starting from any building in the list_.","solution":"def max_buildings(arr, d): def dfs(i, visited): if visited[i]: return 0 visited[i] = True max_visits = 1 for neighbor in range(i + 1, min(i + d + 1, len(arr))): if abs(arr[i] - arr[neighbor]) <= d: max_visits = max(max_visits, 1 + dfs(neighbor, visited)) for neighbor in range(i - 1, max(i - d, -1), -1): if abs(arr[i] - arr[neighbor]) <= d: max_visits = max(max_visits, 1 + dfs(neighbor, visited)) visited[i] = False return max_visits if not arr: return 0 max_buildings_visited = 0 visited = [False] * len(arr) for i in range(len(arr)): max_buildings_visited = max(max_buildings_visited, dfs(i, visited)) return max_buildings_visited"},{"question":"Given an integer array `arr`, rotate the array to the right by `k` steps, where `k` is a non-negative integer. **Note**: You must modify the array in place with O(1) extra space and do not return anything.","solution":"def rotate(arr, k): Rotates the array to the right by k steps. n = len(arr) k = k % n # Handle cases where k is greater than the length of the array arr[:] = arr[-k:] + arr[:-k] # Reassign the rotated parts to the array"},{"question":"You are given a `k`-dimensional hypercuboid, which can be represented as a list of `k` ranges where each range is a list of two integers `[l, u]` denoting the lower and upper bounds respectively for that dimension (`0 <= l <= u`). Implement a function that calculates the total number of integer points (i.e., points with integer coordinates) that lie within this hypercuboid. Each dimension\'s bounds are inclusive, meaning a point on the lower or upper bound is considered inside the hypercuboid.","solution":"def count_hypercuboid_points(ranges): Calculate the total number of integer points within the k-dimensional hypercuboid. :param ranges: List of lists where each sublist contains two integers [l, u] representing the lower and upper bounds respectively. :return: Integer representing the total number of integer points within the hypercuboid. total_points = 1 for l, u in ranges: total_points *= (u - l + 1) return total_points"},{"question":"You are given a list of non-negative integers `nums` and two non-negative integers `a` and `b`. Your task is to split the list `nums` into two subarrays such that the sum of one subarray does not exceed `a` and the sum of the other subarray does not exceed `b`. Each integer in the list must be assigned to exactly one of the two subarrays. Return _`true`_ if it\'s possible to split the list this way, otherwise return _`false`_.","solution":"def can_split(nums, a, b): Determines if the list `nums` can be split into two subarrays such that the sum of one subarray does not exceed `a` and the sum of the other subarray does not exceed `b`. Arguments: nums -- a list of non-negative integers a -- a non-negative integer representing the maximum sum of the first subarray b -- a non-negative integer representing the maximum sum of the second subarray Returns: True if the list can be split as described, otherwise False. total = sum(nums) if total > (a + b): return False from itertools import combinations for i in range(len(nums) + 1): for comb in combinations(nums, i): if sum(comb) <= a and sum(nums) - sum(comb) <= b: return True return False"},{"question":"You are given an integer array `arr` sorted in non-decreasing order, and you need to return the smallest positive integer that does not appear in `arr`. Write a function `findMissingPositive(arr)` that returns this smallest positive integer. * For example, given the input array `[1, 2, 3, 4, 5]`, the function should return `6`. Given the input array `[-5, -3, 0, 2, 3]`, the function should return `1`.","solution":"def findMissingPositive(arr): Finds the smallest positive integer that does not appear in the sorted array `arr`. Args: arr (List[int]): A list of integers sorted in non-decreasing order. Returns: int: The smallest positive integer not present in the array. smallest_missing = 1 for num in arr: if num == smallest_missing: smallest_missing += 1 return smallest_missing"},{"question":"Given an array of integers `arr`, return the **smallest** subarray whose sum is greater than or equal to a given integer `target`. If no such subarray exists, return `-1`. A **subarray** is a contiguous sequence of elements within the array.","solution":"def smallest_subarray_with_sum(arr, target): Returns the smallest subarray length whose sum is greater than or equal to target. If no such subarray exists, returns -1. n = len(arr) min_len = float(\'inf\') current_sum = 0 start = 0 for end in range(n): current_sum += arr[end] while current_sum >= target: min_len = min(min_len, end - start + 1) current_sum -= arr[start] start += 1 if min_len == float(\'inf\'): return -1 else: return min_len"},{"question":"Given an integer array `nums` of length `n` where all elements are unique, you are allowed to perform the following operations on the array: * Swap any two elements. * Reverse any subarray of the array. You need to determine if it is possible to sort the array `nums` in ascending order using a combination of the above operations. Return `true` if it is possible to sort the array, otherwise return `false`.","solution":"def can_be_sorted(nums): Checks if the array can be sorted using the allowed operations: swap any two elements and reverse any subarray. The function returns True because with the given operations, any array can be sorted. return True"},{"question":"Given a binary tree, write a function to invert the binary tree. The inversion of a binary tree means swapping the left and right child of every node. The function should take the root of the binary tree as input and return the root of the inverted binary tree. Assume the binary tree node is represented as: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` Return _the root of the inverted binary tree_.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def invert_tree(root): Inverts a binary tree by swapping the left and right child of every node. :param root: TreeNode, the root of the binary tree :return: TreeNode, the root of the inverted binary tree if root is None: return None # Swap the left and right children root.left, root.right = root.right, root.left # Recursively invert the left and right subtrees invert_tree(root.left) invert_tree(root.right) return root"},{"question":"You are given a string `s` consisting of lowercase English letters and you have to perform a number of queries on this string. Each query consists of a single character, and for each query, you need to determine the number of distinct substrings of `s` that start and end with the queried character. Return an array of integers where each element corresponds to the answer for a particular query.","solution":"def distinct_substrings_count(s, queries): Returns the number of distinct substrings that start and end with each queried character. :param s: A string consisting of lowercase English letters. :param queries: A list of query characters. :return: A list of integers where each element corresponds to the number of distinct substrings for the matching query character. from collections import defaultdict # Function to count distinct substrings starting and ending with same character char_indices = defaultdict(list) for idx, char in enumerate(s): char_indices[char].append(idx) result = [] for char in queries: indices = char_indices[char] n = len(indices) result.append(n * (n + 1) // 2) # Number of distinct substrings for the character return result"},{"question":"You are given an array of `transactions` where `transactions[i] = [from, to, amount]` indicates that the person with `id = from` gave `amount` dollars to the person with `id = to`. Given that each person has a unique `id` from `0` to `n-1` and each transaction is listed exactly once, return the smallest number of transactions that are required to balance the debt among all persons. A transaction `[x, y, amount]` means that person `x` pays `amount` dollars to person `y`. For example, given the transactions `[[0,1,10], [2,0,5]]`, the result would be `2` transactions to balance the debts, which could be performed as follows: - Person `1` pays `5` dollars to person `0` - Person `1` pays `5` dollars to person `2`","solution":"def minTransfers(transactions): from collections import defaultdict def dfs(idx, balance): while idx < len(balance) and balance[idx] == 0: idx += 1 if idx == len(balance): return 0 result = float(\'inf\') for i in range(idx + 1, len(balance)): if balance[i] * balance[idx] < 0: balance[i] += balance[idx] result = min(result, 1 + dfs(idx + 1, balance)) balance[i] -= balance[idx] return result balance_map = defaultdict(int) for t in transactions: balance_map[t[0]] -= t[2] balance_map[t[1]] += t[2] balance = list(balance_map.values()) return dfs(0, balance)"},{"question":"You are given a string `s`, which consists of lowercase English letters and has a length of `n`. You can choose any single character from the string and move it to the end of the string. You can perform this operation at most once. Determine the lexicographically smallest string that can be obtained through zero or one such operation. Return the resultant string.","solution":"def lexicographically_smallest_string(s): Returns the lexicographically smallest string that can be obtained by moving one character to the end of the string at most once. n = len(s) if n <= 1: return s # Find the lexicographically smallest string by simulating the move operation min_str = s for i in range(n): new_str = s[:i] + s[i+1:] + s[i] if new_str < min_str: min_str = new_str return min_str"},{"question":"You are given an infinite number of two types of tiles: a `2x1` tile and a `1x2` tile. You are tasked with covering a `n x 2` grid using these tiles. You should place the tiles such that the entire grid is covered without any overlaps or gaps. Calculate the number of distinct ways to achieve this. Note that: - The `2x1` tile can be placed either vertically or horizontally. - The `1x2` tile can be placed either horizontally or vertically. Return the number of distinct ways to cover the grid.","solution":"def count_ways(n): Returns the number of distinct ways to cover a n x 2 grid using 2x1 and 1x2 tiles. # Initialize dp array where dp[i] represents the number of ways to cover a i x 2 grid dp = [0] * (n + 1) # Base cases if n == 0: return 1 if n == 1: return 1 # Initial values for the first two indexes dp[0] = 1 dp[1] = 1 # Fill dp array using the recurrence relation for i in range(2, n+1): dp[i] = dp[i-1] + dp[i-2] return dp[n]"},{"question":"You are given two **0-indexed** integer arrays `tasks` and `workers`, where `tasks[i]` represents the amount of work required for the ith task and `workers[j]` represents the amount of work that the jth worker can handle. Each worker can complete at most one task, and each task can be completed by at most one worker. Each task must be fully handled by one worker and cannot be divided among multiple workers. Return _the **minimum** number of tasks that cannot be completed given the constraints._","solution":"def min_uncompleted_tasks(tasks, workers): Returns the minimum number of tasks that cannot be completed given the tasks and workers capacities. tasks.sort() workers.sort() i, j = 0, 0 while i < len(tasks) and j < len(workers): if tasks[i] <= workers[j]: i += 1 j += 1 return len(tasks) - i"},{"question":"You are given an array of integers `nums` where each integer represents the number of minutes a person needs to finish a given task. The tasks need to be completed by a team of people working together, but each task can only be performed by one person. Each person can perform multiple tasks, but no two tasks can be performed at the same time by the same person. Determine the **minimum** number of people required such that all tasks can be completed within `x` minutes. Return the minimum number of people required.","solution":"from typing import List def min_people_required(nums: List[int], x: int) -> int: Determines the minimum number of people required such that all tasks can be completed within x minutes. Args: nums: List of integers representing the number of minutes a person needs to finish a task. x: Integer representing the maximum permissible time for completing tasks. Returns: Integer representing the minimum number of people required. nums.sort(reverse=True) people = [] for task_time in nums: placed = False for i in range(len(people)): if people[i] + task_time <= x: people[i] += task_time placed = True break if not placed: people.append(task_time) return len(people)"},{"question":"You are given an array of integers `arr` where each element represents the amount of money in a house. There are `n` houses in a row, and you need to maximize the amount of money you can rob tonight. However, you cannot rob two adjacent houses. Return the maximum amount of money you can rob without alerting the police.","solution":"def rob(nums): Returns the maximum amount of money you can rob without robbing two adjacent houses. Parameters: nums (List[int]): List of integers where each integer represents the amount of money in a house Returns: int: Maximum amount of money you can rob if not nums: return 0 if len(nums) == 1: return nums[0] rob_next_plus_one = 0 rob_next = nums[-1] for i in range(len(nums) - 2, -1, -1): current = max(rob_next, rob_next_plus_one + nums[i]) rob_next_plus_one = rob_next rob_next = current return rob_next"},{"question":"You are given a queue of integers `tasks` and an integer `cooldown`. Each integer represents a different type of task that takes 1 unit of time to complete. Tasks of the same type must be executed at least `cooldown` units of time apart. Your goal is to determine the minimum total time required to execute all the tasks in the queue. If a task cannot be executed before the cooldown period is over, you must wait (i.e., idle time) until the cooldown period is satisfied. Return the minimum total time required to execute all the tasks in the queue. ```python def least_interval(tasks, cooldown): # Your code here # Example usage: tasks = [1, 2, 1, 2, 3, 1] cooldown = 2 print(least_interval(tasks, cooldown)) # Output: 7 ```","solution":"def least_interval(tasks, cooldown): from collections import Counter, deque task_counts = Counter(tasks) max_task_count = max(task_counts.values()) max_count_tasks = sum(1 for count in task_counts.values() if count == max_task_count) intervals = (max_task_count - 1) * (cooldown + 1) + max_count_tasks return max(intervals, len(tasks))"},{"question":"You are given a binary tree with `n` nodes. Each node is uniquely numbered from `1` to `n`. The tree may be skewed or balanced, but it\'s guaranteed to be a valid binary tree. Each node is defined by its value and possibly its left and right children. Implement a function to find the lowest common ancestor (LCA) of two given nodes in the binary tree. The LCA is defined as the deepest node that has both `p` and `q` as its descendants (where we allow a node to be a descendant of itself). You are provided the root of the tree and the values of the two nodes `p` and `q`. Return the value of their lowest common ancestor.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def lowest_common_ancestor(root: TreeNode, p: int, q: int) -> int: if not root: return None if root.val == p or root.val == q: return root.val left_lca = lowest_common_ancestor(root.left, p, q) right_lca = lowest_common_ancestor(root.right, p, q) if left_lca and right_lca: return root.val return left_lca if left_lca else right_lca"},{"question":"Given a list of integers `nums` and an integer target `k`, return the maximum number of consecutive elements in `nums` that sum up to exactly `k`. If there are no such subarrays, return 0. For example, - Input: nums = [1, 2, 3, 4, 5], k = 9 - Output: 3 Explanation: The subarray [2, 3, 4] sums up to 9, and its length is 3.","solution":"def max_consecutive_subarray_sum(nums, k): Returns the maximum number of consecutive elements in nums that sum up to exactly k. If there are no such subarrays, returns 0. max_length = 0 current_sum = 0 start = 0 for end in range(len(nums)): current_sum += nums[end] while current_sum > k and start <= end: current_sum -= nums[start] start += 1 if current_sum == k: max_length = max(max_length, end - start + 1) return max_length"},{"question":"Given a **2D** integer array `grid` representing a grid of cells where `0` represents water and `1` represents land, return the **size** of the largest island. An island is a group of contiguous land cells connected horizontally or vertically (not diagonally). You may perform at most one transformation: change `one` water cell (`0`) to a land cell (`1`) to maximize the size of the island.","solution":"def largest_island(grid): def dfs(r, c, index): if 0 <= r < n and 0 <= c < n and grid[r][c] == 1: grid[r][c] = index size = 1 for dr, dc in directions: size += dfs(r + dr, c + dc, index) return size return 0 def get_neighbors(r, c): neighbors = [] for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < n and 0 <= nc < n: neighbors.append((nr, nc)) return neighbors n = len(grid) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] index = 2 sizes = {} for r in range(n): for c in range(n): if grid[r][c] == 1: sizes[index] = dfs(r, c, index) index += 1 max_island = max(sizes.values(), default=0) for r in range(n): for c in range(n): if grid[r][c] == 0: seen_indices = set() potential_size = 1 for nr, nc in get_neighbors(r, c): if grid[nr][nc] > 1 and grid[nr][nc] not in seen_indices: seen_indices.add(grid[nr][nc]) potential_size += sizes[grid[nr][nc]] max_island = max(max_island, potential_size) return max_island"},{"question":"You are given a string `s` of lowercase letters. You need to remove the minimum number of characters from the string so that every letter appears at most twice. Return _the resulting string after the removal_. If there are multiple valid results, you may return **any of them**.","solution":"def remove_excessive_characters(s): Remove the minimum number of characters from the string so that every letter appears at most twice. from collections import Counter count = Counter(s) result = [] # Create a temporary dictionary to keep track of occurrences of each letter in the result temp_count = {char: 0 for char in count} for char in s: if temp_count[char] < 2: result.append(char) temp_count[char] += 1 return \'\'.join(result)"},{"question":"You are given a **0-indexed** integer array `nums` consisting of `n` elements, and an integer `target`. You need to determine if there exist three distinct indices `i`, `j`, and `k` in `nums` such that `nums[i] + nums[j] + nums[k] = target`. Construct a boolean array `answer` that contains a single element which is `true` if such indices exist, and `false` otherwise. Return _the constructed array_ `answer`.","solution":"def three_sum_exists(nums, target): Determines if there exist three distinct indices i, j, k in nums such that nums[i] + nums[j] + nums[k] equals target. Args: nums: List[int] - The list of integers. target: int - The target sum to find. Returns: List[bool]: A boolean list with one element that is True if such indices exist, False otherwise. n = len(nums) # Brute force approach with O(n^3) complexity to check all triplets for i in range(n): for j in range(i + 1, n): for k in range(j + 1, n): if nums[i] + nums[j] + nums[k] == target: return [True] return [False]"},{"question":"You are given a string `s` consisting only of lowercase English letters. A substring is defined as a contiguous sequence of characters within the string. You need to modify the string such that after the modification, all substrings of length `k` have exactly `k` distinct characters, for any given `k` from `1` to `min(len(s), 26)`. To achieve this, you can replace characters in the original string with any lowercase English letters. Return _the **minimum** number of modifications required to achieve this condition._","solution":"def min_modifications_to_distinct_substrings(s, k): Returns the minimum number of modifications required to ensure all substrings of length k have exactly k distinct characters. if not s or k <= 0 or k > len(s): return 0 n = len(s) min_replacements = float(\'inf\') def is_valid_substring(substr): return len(set(substr)) == len(substr) for i in range(n - k + 1): substring = s[i:i + k] if not is_valid_substring(substring): unique_chars = set(substring) modifications_needed = k - len(unique_chars) min_replacements = min(min_replacements, modifications_needed) return min_replacements if min_replacements != float(\'inf\') else 0"},{"question":"You are given a 2D grid of size `m x n` where each cell is either `0` (empty) or `1` (wall). You need to find the shortest path from the top-left corner of the grid (cell `(0, 0)`) to the bottom-right corner (cell `(m-1, n-1)`) while breaking at most one wall. If such a path does not exist, return `-1`. You can move up, down, left, or right from a cell.","solution":"from collections import deque def shortest_path_with_one_wall_break(grid): Find the shortest path from top-left to bottom-right, breaking at most one wall. m, n = len(grid), len(grid[0]) if grid[0][0] == 1 or grid[m-1][n-1] == 1: return -1 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] visited = [[[False, False] for _ in range(n)] for _ in range(m)] visited[0][0][0] = True queue = deque([(0, 0, 0)]) # (x, y, broken) steps = 0 while queue: for _ in range(len(queue)): x, y, broken = queue.popleft() if x == m-1 and y == n-1: return steps for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n: if grid[nx][ny] == 0 and not visited[nx][ny][broken]: visited[nx][ny][broken] = True queue.append((nx, ny, broken)) elif grid[nx][ny] == 1 and broken == 0 and not visited[nx][ny][1]: visited[nx][ny][1] = True queue.append((nx, ny, 1)) steps += 1 return -1"},{"question":"You are given an integer array `heights` representing the heights of trees in a forest. There is a lumberjack who can cut down a tree if it is higher than a certain height `h`. After cutting down the tree, the lumberjack collects logs equal to the difference between the tree\'s height and `h`. Determine the maximum logs that the lumberjack can collect given a specific cutting height `h`. Return the maximum possible logs that can be collected.","solution":"def max_logs(heights, h): Returns the maximum logs that the lumberjack can collect given the cutting height h. :param heights: List[int], list of tree heights in the forest. :param h: int, the cutting height. :return: int, the maximum logs that can be collected. return sum(height - h for height in heights if height > h)"},{"question":"You are given a **0-indexed** integer array `arr` of length `n`. You need to split the array into multiple contiguous subarrays such that each element in the array belongs to exactly one subarray. The **split cost** of a subarray is defined as the difference between the maximum and minimum elements in the subarray. Your task is to find the minimum possible sum of the split costs of the subarrays after splitting the array in any possible way. Return this minimum sum.","solution":"def min_split_cost(arr): This function returns the minimum possible sum of the split costs of the subarrays after splitting the array in any possible way. The split cost of a subarray is defined as the difference between the maximum and minimum elements in the subarray. The optimal solution is to consider each individual element as its own subarray, because the split cost of a single-element subarray is zero. :param arr: List[int] - the input array :return: int - the minimum sum of split costs return 0"},{"question":"You are given a 2D grid of `m` rows and `n` columns representing a map where `1` represents land, and `0` represents water. A **cell** represents a single unit of land or water. Two cells are considered connected if they are next to each other horizontally or vertically (not diagonally). An **island** is a connected set of land cells. Implement a function to count the number of distinct islands in the grid. An island is **distinct** if its structure (shape of the island) is different from any other island in the grid. The structure of an island is represented by the relative position and orientation of each land cell to an arbitrary starting point within the island. Return _the total number of distinct islands in the grid_.","solution":"def number_of_distinct_islands(grid): def dfs(x, y, direction): stack = [(x, y, direction)] path = [] while stack: i, j, d = stack.pop() if 0 <= i < m and 0 <= j < n and grid[i][j] == 1: grid[i][j] = 0 path.append(d) stack.append((i+1, j, \'D\')) stack.append((i-1, j, \'U\')) stack.append((i, j+1, \'R\')) stack.append((i, j-1, \'L\')) return tuple(path) if not grid: return 0 m, n = len(grid), len(grid[0]) unique_islands = set() for i in range(m): for j in range(n): if grid[i][j] == 1: island_shape = dfs(i, j, \'S\') unique_islands.add(island_shape) return len(unique_islands)"},{"question":"Given a 2D integer grid `grid` where each cell contains 0\'s and 1\'s, return _the number of distinct islands_. An island is a group of connected 1\'s (horizontal or vertical). Two islands are considered distinct if and only if one island is not equal to another (disregarding translations and rotations).","solution":"def num_distinct_islands(grid): Given a 2D grid of 0\'s and 1\'s, return the number of distinct islands, considering two islands distinct if one is not equal to another (disregarding translations and rotations). def dfs(i, j, direction): Perform Depth-First Search to explore the entire island if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == 0: return grid[i][j] = 0 # mark as visited shape.append(direction) # explore neighbors dfs(i - 1, j, \\"U\\") dfs(i + 1, j, \\"D\\") dfs(i, j - 1, \\"L\\") dfs(i, j + 1, \\"R\\") shape.append(\\"0\\") # backtracking shapes = set() for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: shape = [] dfs(i, j, \\"S\\") # start exploring the island shapes.add(tuple(shape)) # add the shape of this island to the set return len(shapes)"},{"question":"Given a string `s` containing only the characters `a` and `b`, you are allowed to replace exactly one character in `s` with any other character to form a new string. Return the length of the longest contiguous substring of the new string that contains only one distinct character. **Example:** Input: `s = \\"aababba\\"` Output: `4` Explanation: Replace the first \'b\' with \'a\' to get \\"aaaabba\\" which has the longest contiguous substring \\"aaaa\\" of length 4.","solution":"def longest_substring_after_replacement(s: str) -> int: Returns the length of the longest contiguous substring that contains only one distinct character in a new string formed by replacing exactly one character in the input string `s`. max_length = 1 def max_length_with_replacement(char): max_len = 0 left = 0 count_diff_char = 0 for right in range(len(s)): if s[right] != char: count_diff_char += 1 while count_diff_char > 1: if s[left] != char: count_diff_char -= 1 left += 1 max_len = max(max_len, right - left + 1) return max_len max_length = max(max_length, max_length_with_replacement(\'a\')) max_length = max(max_length, max_length_with_replacement(\'b\')) return max_length"},{"question":"Given two strings `s1` and `s2`, return `true` if `s2` contains a permutation of `s1`. Otherwise, return `false`.","solution":"from collections import Counter def check_inclusion(s1, s2): Returns true if s2 contains a permutation of s1, otherwise false. len_s1 = len(s1) len_s2 = len(s2) if len_s1 > len_s2: return False s1_count = Counter(s1) window_count = Counter(s2[:len_s1]) if s1_count == window_count: return True for i in range(len_s1, len_s2): start_char = s2[i - len_s1] new_char = s2[i] window_count[new_char] += 1 window_count[start_char] -= 1 if window_count[start_char] == 0: del window_count[start_char] if window_count == s1_count: return True return False"},{"question":"You are given a binary tree where each node has a value that is an integer. The value of a path from the root node to a leaf node is the sum of the node values along that path. A \\"good\\" path is defined as a path that has a sum equal to a given target sum. Write a function that returns the number of \\"good\\" paths in the tree. You may assume the tree node structure is as follows: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` Given the root of the binary tree and an integer `targetSum`, return the number of \\"good\\" paths in the tree.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def count_good_paths(root, targetSum): Returns the number of paths from root to leaf that sum up to targetSum. def dfs(node, current_sum): if not node: return 0 current_sum += node.val # Check if we have reached a leaf node with the required sum if not node.left and not node.right: return 1 if current_sum == targetSum else 0 # Process left and right subtrees left_paths = dfs(node.left, current_sum) right_paths = dfs(node.right, current_sum) return left_paths + right_paths return dfs(root, 0)"},{"question":"You are given an array of positive integers `heights` representing the height of different buildings, and an integer `k`. In one operation, you can increase the height of any building by `1`. Your task is to make all the buildings of equal height with the minimum number of operations. Return _the **minimum number** of operations needed to make all the buildings equal in height_ given the integer `k` as the maximum number of operations you can perform. If it is not possible to make all buildings equal in height within `k` operations, return `-1`.","solution":"def min_operations_to_equal_height(heights, k): Calculate the minimum number of operations to make all buildings the same height. If not possible within k operations, return -1. max_height = max(heights) total_operations = sum(max_height - height for height in heights) if total_operations <= k: return total_operations else: return -1"},{"question":"You are given a string `s` containing only characters `\'a\'` and `\'b\'`. You can delete any number of characters from the string `s`. Your task is to construct the longest possible substring that contains no more than `k` consecutive characters `a` and no more than `k` consecutive characters `b`. Return the length of such a maximum substring.","solution":"def longest_substring_no_more_than_k_consecutive(s, k): Returns the length of the longest substring of `s` that contains no more than `k` consecutive characters `a` and `k` consecutive characters `b`. max_length = 0 current_a_count = 0 current_b_count = 0 start = 0 for end in range(len(s)): if s[end] == \'a\': current_a_count += 1 current_b_count = 0 else: # s[end] == \'b\' current_a_count = 0 current_b_count += 1 while current_a_count > k or current_b_count > k: if s[start] == \'a\': current_a_count -= 1 else: current_b_count -= 1 start += 1 max_length = max(max_length, end - start + 1) return max_length"},{"question":"You are given a list of integers `nums` representing a sequence of steps. Each element `nums[i]` indicates the number of steps you must move forward (if `nums[i]` is positive) or backward (if `nums[i]` is negative) from the current position `i`. Initially, you start at position `0`. Your goal is to determine whether you can reach the last position of the list (i.e., `nums[length - 1]`) starting from the first position. Return _a boolean value indicating if it\'s possible to reach the last position, given the step sequence in_ `nums`.","solution":"def can_reach_end(nums): Given a list of integers nums representing a sequence of steps, determine whether you can reach the last position. Args: nums (list): A list of integers indicating steps forward or backward at each position. Returns: bool: True if it is possible to reach the last position, False otherwise. n = len(nums) max_reach = 0 for i in range(n): if i > max_reach: return False max_reach = max(max_reach, i + nums[i]) if max_reach >= n - 1: return True return False"},{"question":"You are given a binary tree where each node contains an integer value. Return the level order traversal of its nodes\' values. (i.e., from left to right, level by level). _For example, given the binary tree `{3,9,20,null,null,15,7}`, you should return its level order traversal as: `[[3], [9,20], [15,7]]`._","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_order_traversal(root): Return the level order traversal of a binary tree\'s nodes\' values. Args: root (TreeNode): The root of the binary tree. Returns: List[List[int]]: The level order traversal of each node\'s values. if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) current_level = [] for _ in range(level_size): node = queue.popleft() current_level.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(current_level) return result"},{"question":"You are given a list of integers `arr` and a target integer `sum`. Write a function that returns the **count** of **unique triplets** in the list that add up to the target `sum`. Each triplet should be represented in non-decreasing order, and the function should return the total number of such triplets without counting duplicate triplets. Two triplets are considered the same if they contain the exact same integers, regardless of order. For example, the triplets `(1, 2, 3)` and `(3, 2, 1)` represent the same triplet and should only be counted once.","solution":"def count_unique_triplets(arr, target_sum): Returns the count of unique triplets in the list that add up to the target sum. arr.sort() triplets = set() n = len(arr) for i in range(n - 2): left, right = i + 1, n - 1 while left < right: current_sum = arr[i] + arr[left] + arr[right] if current_sum == target_sum: triplets.add((arr[i], arr[left], arr[right])) left += 1 right -= 1 elif current_sum < target_sum: left += 1 else: right -= 1 return len(triplets)"},{"question":"Given the `head` of a singly linked list, reverse the list, and return the reversed list. Implement an algorithm with O(n) time complexity and O(1) space complexity.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_list(head): Reverses a singly linked list. :param head: ListNode, the head of the singly linked list :return: ListNode, the head of the reversed singly linked list prev = None current = head while current is not None: next_node = current.next current.next = prev prev = current current = next_node return prev"},{"question":"Given an unsorted array of integers `arr`, write a function that finds and returns all unique triplets in the array that sum up to zero. Note that each triplet should be in non-descending order, and no duplicate triplets should be included in the result.","solution":"def three_sum(arr): Returns all unique triplets in the array that sum up to zero. Each triplet should be in non-descending order, with no duplicates. :param arr: List[int] - The input array of integers. :return: List[List[int]] - List of unique triplets that sum up to zero. arr.sort() result = [] n = len(arr) for i in range(n - 2): if i > 0 and arr[i] == arr[i - 1]: continue left, right = i + 1, n - 1 while left < right: current_sum = arr[i] + arr[left] + arr[right] if current_sum == 0: result.append([arr[i], arr[left], arr[right]]) while left < right and arr[left] == arr[left + 1]: left += 1 while left < right and arr[right] == arr[right - 1]: right -= 1 left += 1 right -= 1 elif current_sum < 0: left += 1 else: right -= 1 return result"},{"question":"You are given an integer array `arr` and an integer `threshold`. A subarray is called \\"balanced\\" if the sum of its elements is less than or equal to `threshold`. You need to find the length of the longest balanced subarray in `arr`. Return the length of this subarray. If there is no such subarray, return `0`.","solution":"def longest_balanced_subarray(arr, threshold): Returns the length of the longest balanced subarray in arr where the sum of its elements is less than or equal to threshold. n = len(arr) max_length = 0 for i in range(n): current_sum = 0 for j in range(i, n): current_sum += arr[j] if current_sum <= threshold: max_length = max(max_length, j - i + 1) else: break return max_length"},{"question":"You are given an array of integers where each element represents the maximum number of steps you can jump forward from that position. Start from the first element of the array and determine if you can reach the last element. Return `True` if you can reach the last element, otherwise return `False`. For example, given the array `[2, 3, 1, 1, 4]`, you can reach the last element by jumping 1 step from position 0 to 1, then 3 steps to the last position.","solution":"def can_jump(nums): Determine if you can reach the last index starting from the first index. :param nums: List[int], array where each element represents the maximum number of steps you can jump forward from that position. :return: bool, True if you can reach the last element, otherwise False. max_reach = 0 for i, num in enumerate(nums): if i > max_reach: return False max_reach = max(max_reach, i + num) if max_reach >= len(nums) - 1: return True return False"},{"question":"**[Question 4]: Given an array of integers, where a \\"peak\\" element is an element that is strictly greater than its neighbors, find and return the index of any peak element. If the array contains multiple peaks, return the index to any one of the peaks. You may assume that the array does not contain adjacent equal elements and that the bounds outside the array are considered as negative infinity.**","solution":"def find_peak_element(nums): Find a peak element and return its index. A peak element is an element in the array that is greater than its neighbors. :param nums: List[int] - list of integers :return: int - index of a peak element left, right = 0, len(nums) - 1 while left < right: mid = (left + right) // 2 if nums[mid] > nums[mid + 1]: right = mid else: left = mid + 1 return left"},{"question":"You are given the head of a singly linked list and an integer `n`. You are required to remove the `n`-th node from the end of the list and return the head of the modified list. The linked list can be represented as follows: ```plaintext head -> node1 -> node2 -> ... -> noden-1 -> nodeth -> noden+1 -> ... -> nodem -> null ``` Where `head` is the first node of the list, and `null` signifies the end of the list. Implement the function `removeNthFromEnd` that takes the head of the linked list and the integer `n` as input and modifies the list by removing the `n`-th node from the end. For example, given the head of the linked list `1 -> 2 -> 3 -> 4 -> 5` and `n = 2`, the function should modify the list to `1 -> 2 -> 3 -> 5` and return the new head.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def removeNthFromEnd(head, n): Removes the n-th node from the end of the list and returns the head of the modified list. dummy = ListNode(0) # Create a dummy node to handle edge cases dummy.next = head first = dummy second = dummy # Move first n+1 steps ahead to maintain a gap for _ in range(n + 1): first = first.next # Move both pointers until first reaches the end while first is not None: first = first.next second = second.next # Remove the nth node from end second.next = second.next.next return dummy.next"},{"question":"Given a string `s` that consists of only two characters, `\'a\'` and `\'b\'`, you can delete any two adjacent characters if they are different. Your task is to compute the length of the shortest string that can be obtained after performing any number of deletions. Note that the order of deletions can affect the final result. Return _an integer_ representing the length of the resultant shortest string.","solution":"def shortest_length(s): Returns the length of the shortest string that can be obtained after performing any number of deletions of two adjacent different characters. :param s: string consisting of only \'a\' and \'b\'. :return: integer length of the shortest possible string. stack = [] for char in s: if stack and stack[-1] != char: stack.pop() else: stack.append(char) return len(stack)"},{"question":"You are given a list of non-negative integers `candidates` and a non-negative integer `target`. Each number in `candidates` can be used an unlimited number of times. Find all possible unique combinations in `candidates` where the chosen numbers sum to `target`. The same repeated number may be chosen from `candidates` an unlimited number of times. The combinations may be returned in any order. Return _a list of all unique combinations of_ `candidates` _where the chosen numbers sum to_ `target`.","solution":"def combination_sum(candidates, target): Returns a list of all unique combinations of candidates where the chosen numbers sum to target. Each number in candidates can be used an unlimited number of times. result = [] def backtrack(current_combination, current_sum, start): if current_sum == target: result.append(list(current_combination)) return if current_sum > target: return for i in range(start, len(candidates)): current_combination.append(candidates[i]) backtrack(current_combination, current_sum + candidates[i], i) current_combination.pop() backtrack([], 0, 0) return result"},{"question":"You are given an integer array `elements`, where each `elements[i]` represents the number of elements in the `i-th` cluster. Your task is to merge the clusters, following these rules: - You can only merge two adjacent clusters at a time. - The cost of merging two clusters is the sum of their sizes. Determine the minimum cost required to merge all clusters into one cluster. _Return the minimum cost to merge all the clusters._","solution":"def min_merge_cost(elements): Calculate the minimum cost to merge all clusters into one cluster. :param elements: List[int] - a list where each element represents the size of the i-th cluster. :return: int - the minimum cost to merge all clusters into one. import heapq # if there is only one or no cluster, no merging is needed if len(elements) <= 1: return 0 # Convert the list into a priority queue (min-heap) heapq.heapify(elements) total_cost = 0 # While there are more than one clusters to merge while len(elements) > 1: # Take the two smallest clusters first = heapq.heappop(elements) second = heapq.heappop(elements) # Merge them cost = first + second total_cost += cost # Add the merged cluster back to the priority queue heapq.heappush(elements, cost) return total_cost"},{"question":"You are tasked with designing a system to manage bookings in a restaurant. The restaurant has multiple tables and multiple time slots. Each booking is a reservation for a specific table at a specific time slot. The system should support adding new bookings, cancelling existing bookings, and checking the availability of tables for a given time slot. The system should be able to handle multiple bookings and efficiently update the status of table reservations. Implement a class `RestaurantBookingSystem` with the following functions: - `RestaurantBookingSystem(int numTables, int numTimeSlots)`: Initializes the system with a specified number of tables and time slots. - `boolean book(int table, int timeSlot)`: Books a specified table at a specific time slot. Returns `true` if the booking was successful, `false` if the table is already booked at that time. - `boolean cancel(int table, int timeSlot)`: Cancels a booking for a specific table and time slot. Returns `true` if the cancellation was successful, `false` if there was no booking at that time. - `List<Integer> availableTables(int timeSlot)`: Returns a list of table numbers that are available for a given time slot, sorted in ascending order. If no tables are available, returns an empty list.","solution":"class RestaurantBookingSystem: def __init__(self, numTables, numTimeSlots): self.numTables = numTables self.numTimeSlots = numTimeSlots self.bookings = [[False for _ in range(numTimeSlots)] for _ in range(numTables)] def book(self, table, timeSlot): if self.bookings[table][timeSlot]: return False self.bookings[table][timeSlot] = True return True def cancel(self, table, timeSlot): if not self.bookings[table][timeSlot]: return False self.bookings[table][timeSlot] = False return True def availableTables(self, timeSlot): available = [] for table in range(self.numTables): if not self.bookings[table][timeSlot]: available.append(table) return available"},{"question":"You are given an array of integers `arr` and an integer `n` which represents the minimum size of a subarray. Your task is to find the maximum possible sum of a subarray of size `n` from the original array `arr`. If no such subarray exists, return `0`. Implement a function that accepts `arr` and `n` and returns the maximum sum of a subarray of size `n`.","solution":"def max_subarray_sum(arr, n): Returns the maximum possible sum of a subarray of size `n` from the original array `arr`. if len(arr) < n: return 0 # Compute the initial sum of the first subarray of size `n` max_sum = current_sum = sum(arr[:n]) # Iterate through the array using a sliding window for i in range(n, len(arr)): current_sum += arr[i] - arr[i - n] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"You are given a string `s` that consists of several words (not necessarily distinct) separated by spaces, and a string `target` representing a single word. Find the word in the string `s` that appears immediately before each occurrence of the word `target` and return these words in the order they appear. If `target` is the first word or if it doesn\'t appear in the string, return an empty list. Words in `s` are assumed to be separated by a single space without any leading or trailing spaces. You may assume that the string contains only lowercase letters and spaces.","solution":"def words_before_target(s, target): Returns a list of words that appear immediately before each occurrence of the word target in the string s. :param s: The original string containing words separated by spaces. :param target: The word for which we need to find preceding words. :return: A list of words occurring immediately before each occurrence of the target word. words = s.split() result = [] for i in range(1, len(words)): if words[i] == target: result.append(words[i-1]) return result"},{"question":"Given an integer array `nums`, you need to find the length of the longest subsequence such that the differences between consecutive elements of the subsequence are all the same. Return the length of this longest subsequence. Note: A subsequence of an array is a sequence that can be derived from the array by deleting some or no elements without changing the order of the remaining elements.","solution":"def longest_arith_seq_length(nums): Finds the length of the longest arithmetic subsequence in the array nums. :param nums: List[int], the input array of integers :return: int, the length of the longest arithmetic subsequence if not nums: return 0 n = len(nums) if n <= 2: return n dp = {} longest = 2 for i in range(n): for j in range(i + 1, n): diff = nums[j] - nums[i] if (i, diff) in dp: dp[(j, diff)] = dp[(i, diff)] + 1 else: dp[(j, diff)] = 2 longest = max(longest, dp[(j, diff)]) return longest"},{"question":"Given an integer `n`, return a list of all **prime numbers** less than `n`. A **prime number** is a natural number greater than 1 that has no positive divisors other than 1 and itself.","solution":"def primes_less_than(n): Returns a list of all prime numbers less than n. if n <= 2: return [] sieve = [True] * n sieve[0] = sieve[1] = False # 0 and 1 are not prime numbers for start in range(2, int(n**0.5) + 1): if sieve[start]: for multiple in range(start*start, n, start): sieve[multiple] = False return [num for num, is_prime in enumerate(sieve) if is_prime]"},{"question":"You are given a string `s` consisting of `n` lowercase letters. A substring is defined as a contiguous block of characters within a string. Write a function to determine the number of distinct non-empty substrings that can be formed from `s`. For example, given the string `s = \\"abc\\"`, the distinct substrings are `\\"a\\"`, `\\"b\\"`, `\\"c\\"`, `\\"ab\\"`, `\\"bc\\"`, and `\\"abc\\"`. Therefore, the function should return `6`.","solution":"def count_distinct_substrings(s): Returns the number of distinct non-empty substrings that can be formed from the string s. n = len(s) substrings = set() # Generate all substrings and add them to the set for i in range(n): for j in range(i + 1, n + 1): substrings.add(s[i:j]) return len(substrings)"},{"question":"Given a binary tree, write a function that returns the **level order traversal** of its nodes\' values. (i.e., from left to right, level by level). You should use a Breadth-First Search (BFS) algorithm to solve this problem. Return the result as a list of lists where each sublist represents one level of the tree. The TreeNode class is defined as follows: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` The function signature should be: ```python def levelOrder(root: TreeNode) -> List[List[int]]: ``` You can assume the input tree will have at least one node.","solution":"from collections import deque from typing import List class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def levelOrder(root: TreeNode) -> List[List[int]]: if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) level_nodes = [] for _ in range(level_size): node = queue.popleft() level_nodes.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level_nodes) return result"},{"question":"Given a string `s` containing only lowercase letters, return _the first non-repeating character_ in it. If all characters are repeating, return `\\"_blank_\\"`. You may assume that the string contains at most one character that is non-repeating.","solution":"def first_non_repeating_char(s): Returns the first non-repeating character in the given string. If all characters are repeating, returns \'_blank_\'. char_count = {} # Count the occurrence of each character for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Find the first character with a count of 1 for char in s: if char_count[char] == 1: return char # If no such character is found, return \'_blank_\' return \\"_blank_\\""},{"question":"You are given an array `nums` consisting of **positive** integers. Each element in the array represents the number of minutes a task takes to complete. You are also given an integer `k` representing the maximum number of different tasks you can attempt in one session. Your goal is to maximize the number of minutes spent on tasks while ensuring that no more than `k` different tasks are completed in a single session. Return the maximum number of minutes spent in a single session that adheres to the given constraints.","solution":"def max_minutes(nums, k): Returns the maximum number of minutes spent in a single session that adheres to the given constraint of no more than k different tasks. nums.sort(reverse=True) return sum(nums[:k])"},{"question":"You are given a list of `n` integers representing the scores of `n` students on a test. You are asked to find the highest possible average score after removing exactly `k` students\' scores from the list. The average score is defined as the sum of the remaining scores divided by the number of remaining scores. Return the highest possible average score after removing exactly `k` students\' scores. If it\'s not possible to remove `k` students, return `-1`.","solution":"def highest_possible_average(scores, k): Returns the highest possible average score after removing exactly k students\' scores. Parameters: - scores (list of int): List of integers representing the scores of students. - k (int): Number of students to remove. Returns: - float: The highest possible average score after removing k scores. n = len(scores) if k >= n: return -1 # Not possible to remove k students scores.sort(reverse=True) remaining_scores = scores[:n-k] highest_avg = sum(remaining_scores) / len(remaining_scores) return highest_avg"},{"question":"You are given a directed acyclic graph (DAG) represented by an integer `n` which is the number of nodes and a 2D integer array `edges` where `edges[i] = [u_i, v_i]` indicates a direct edge from node `u_i` to node `v_i`. Each node represents a course and each directed edge represents a prerequisite relationship. You are also given an integer array `order` representing an order in which the courses are taken. Determine if the given `order` is a valid course schedule. Return `true` if the `order` is valid, otherwise, return `false`.","solution":"def is_valid_course_schedule(n, edges, order): from collections import defaultdict, deque # Create an adjacency list for the graph graph = defaultdict(list) for u, v in edges: graph[u].append(v) # Create a dictionary to hold the index of each node in the order array order_index = {course: i for i, course in enumerate(order)} # Check all edges to ensure each edge respects the given order for u, v in edges: if order_index[u] > order_index[v]: # if u appears after v in order, the order is invalid return False return True"},{"question":"You are given an n x n grid representing a maze where \'.\' represents an open cell and \'#\' represents a wall. You are also given the starting coordinates (startRow, startCol) in the maze. Your task is to implement a function that determines the length of the shortest path from the starting point to the bottom-right corner of the maze. If there is no such path, return -1. You may move up, down, left, or right, but may not move diagonally. The input grid is guaranteed to have an open cell at the beginning (startRow, startCol) and at the bottom-right corner.","solution":"from collections import deque def shortest_path_maze(grid, startRow, startCol): Find the shortest path from the start position to the bottom-right corner of the maze. :param grid: List[List[str]], a 2D list representing the maze :param startRow: int, the starting row index :param startCol: int, the starting column index :return: int, the length of the shortest path or -1 if no path exists n = len(grid) if grid[startRow][startCol] == \'#\' or grid[n-1][n-1] == \'#\': return -1 # Define possible moves (right, down, left, up) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # Breadth-First Search (BFS) initialization queue = deque([(startRow, startCol, 0)]) # (row, col, distance) visited = set([(startRow, startCol)]) while queue: row, col, dist = queue.popleft() if row == n-1 and col == n-1: return dist for dr, dc in directions: newRow, newCol = row + dr, col + dc if 0 <= newRow < n and 0 <= newCol < n and grid[newRow][newCol] == \'.\' and (newRow, newCol) not in visited: visited.add((newRow, newCol)) queue.append((newRow, newCol, dist + 1)) return -1"},{"question":"You are given an `n x n` integer matrix `grid`, where each integer represents the height of a building. A move in the grid is allowed only if you move to an adjacent cell (up, down, left, or right) and the height of the adjacent building is less than or equal to the current cell\'s height plus one. Starting from the top-left corner of the grid (0, 0), find the minimum number of moves required to reach the bottom-right corner of the grid (n-1, n-1). If it is not possible to reach the bottom-right corner, return `-1`.","solution":"from collections import deque def min_moves(grid): Returns the minimum number of moves required to reach the bottom-right corner from the top-left corner in the grid, or -1 if it is not possible. n = len(grid) if grid[0][0] == -1 or grid[n-1][n-1] == -1: return -1 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 0)]) # (x, y, moves) visited = {(0, 0)} while queue: x, y, moves = queue.popleft() if (x, y) == (n-1, n-1): return moves for direction in directions: nx, ny = x + direction[0], y + direction[1] if 0 <= nx < n and 0 <= ny < n and (nx, ny) not in visited: if grid[nx][ny] <= grid[x][y] + 1: queue.append((nx, ny, moves+1)) visited.add((nx, ny)) return -1 # if the bottom-right corner is not reachable"},{"question":"Given a triangle array `triangle` where `triangle[i]` is a list of `i + 1` integers representing the `i`-th row of a triangle, return _the minimum path sum from top to bottom_. Each step you may move to adjacent numbers on the row below. For example, if you are on `triangle[i][j]`, you may move to `triangle[i + 1][j]` or `triangle[i + 1][j + 1]`.","solution":"def minimum_total(triangle): Given a triangle array, returns the minimum path sum from top to bottom. if not triangle: return 0 # Start from the second last row of the triangle and move upwards for i in range(len(triangle) - 2, -1, -1): for j in range(len(triangle[i])): # For each element, choose the minimum path sum to the bottom triangle[i][j] += min(triangle[i + 1][j], triangle[i + 1][j + 1]) # The top element will have the minimum path sum return triangle[0][0]"},{"question":"You are given a 2D integer array `intervals` where each `intervals[i] = [starti, endi]` represents a start and end time for an event. All `intervals` are non-overlapping except possibly touching at endpoints (e.g., `[1,3]` and `[3,5]`). Determine if it is possible to attend all events without any overlap. Return _true_ if you can attend all events, _false_ otherwise.","solution":"def can_attend_all_events(intervals): Determines if it is possible to attend all events without any overlap. Parameters: intervals (list of lists): List of intervals where each interval is represented by [start, end] Returns: bool: True if it is possible to attend all events, False otherwise # Sort intervals by start time intervals.sort(key=lambda x: x[0]) # Iterate through the intervals to check for overlaps for i in range(1, len(intervals)): # Check if the current interval overlaps with the previous interval if intervals[i][0] < intervals[i-1][1]: return False return True"},{"question":"You are given a **2D grid** of integers where each integer represents the height of a building and a list of four integers `[tr1, tc1, tr2, tc2]` representing the top-left and bottom-right coordinates of a subgrid within the 2D grid. Write a function to find the **maximum height** of the buildings in the defined subgrid. Return _an integer_ which is the maximum height found within the specified subgrid.","solution":"def max_height_in_subgrid(grid, coordinates): Returns the maximum height of buildings in the defined subgrid. Parameters: grid (List[List[int]]): 2D grid representing heights of buildings. coordinates (List[int]): List of four integers [tr1, tc1, tr2, tc2] representing the top-left and bottom-right coordinates of the subgrid. Returns: int: The maximum height in the specified subgrid. tr1, tc1, tr2, tc2 = coordinates max_height = float(\'-inf\') for i in range(tr1, tr2 + 1): for j in range(tc1, tc2 + 1): if grid[i][j] > max_height: max_height = grid[i][j] return max_height"},{"question":"You are given a string `s` and a list of words `words` that contains non-overlapping substrings of `s`. Each substring in `words` appears exactly once in `s`. Your task is to concatenate the words in such a manner that the resulting string exactly matches `s` and return the original list `words`, but this time sorted in the order they appear in `s`. For example, if `s = \\"codingassessmenttask\\"` and `words = [\\"task\\", \\"assessment\\", \\"coding\\"]`, then the sorted list should be `[\\"coding\\", \\"assessment\\", \\"task\\"]`. Note: The input list `words` will always form exactly the string `s` when concatenated in some order.","solution":"def sort_words_in_string_order(s, words): Given a string s and a list of words that are substrings of s and appear exactly once in s, this function returns the list sorted in the order the words appear in s. positions = {word: s.index(word) for word in words} sorted_words = sorted(words, key=lambda word: positions[word]) return sorted_words"},{"question":"You are given an integer array `height` representing the heights of buildings arranged in a row. A building\'s skyline is represented by an integer value that indicates its height. Two buildings are said to have an **unobstructed view** of each other if there are no buildings taller than either of them in between. Return _the list of pairs_ `(i, j)` _such that_ `0 <= i < j < height.length` _and the buildings at positions_ `i` _and_ `j` _have an unobstructed view of each other_.","solution":"def unobstructed_views(buildings): Returns a list of pairs (i, j) such that buildings at positions i and j have an unobstructed view of each other. Args: buildings (List[int]): An array representing building heights. Returns: List[Tuple[int, int]]: A list of pairs (i, j) with unobstructed views. n = len(buildings) result = [] for i in range(n): max_height = buildings[i] for j in range(i+1, n): if buildings[j] >= max_height: max_height = buildings[j] result.append((i, j)) elif buildings[j] > buildings[i]: break return result"},{"question":"Given the `head` of a singly linked list and a value `x`, partition the linked list so that all nodes less than `x` come before nodes greater than or equal to `x`. You should preserve the original relative order of the nodes in each of the two partitions. Implement the `ListNode` class and the partition function as follows: Implement the `ListNode` class: * `ListNode(int val)` Initializes the object with the value `val` and sets `next` to null. * `val` Integer value of the node * `next` Reference to the next node in the linked list And the partition function: * `ListNode partition(ListNode head, int x)` - Rearranges the linked list and returns the head of the modified list.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def partition(head, x): less_head = less = ListNode(0) greater_head = greater = ListNode(0) while head: if head.val < x: less.next = head less = less.next else: greater.next = head greater = greater.next head = head.next greater.next = None less.next = greater_head.next return less_head.next"},{"question":"Given an array of integers `nums` and an integer threshold `k`, find the longest contiguous subarray such that the sum of elements in the subarray is less than or equal to `k`. Return the length of the longest subarray. If no such subarray exists, return `0`.","solution":"def longest_subarray(nums, k): Given an array of integers nums and an integer threshold k, find the longest contiguous subarray such that the sum of elements in the subarray is less than or equal to k. Return the length of the longest subarray. If no such subarray exists, return 0. n = len(nums) curr_sum = 0 start = 0 max_length = 0 for end in range(n): curr_sum += nums[end] while curr_sum > k and start <= end: curr_sum -= nums[start] start += 1 max_length = max(max_length, end - start + 1) return max_length"},{"question":"You are given a **0-indexed** integer array `nums`, where `nums[i]` represents the amount of money on the `i`-th day. You are allowed to choose two disjoint subarrays from `nums` such that the sum of the elements within each subarray is maximized. A subarray is a contiguous non-empty sequence of elements within an array. Return _the maximum possible sum_ of the elements from two disjoint subarrays. Note that the two subarrays cannot overlap.","solution":"def maxSumTwoNoOverlap(nums, firstLen, secondLen): def max_sum_subarray(arr, sub_len): max_sum = total = sum(arr[:sub_len]) for i in range(sub_len, len(arr)): total += arr[i] - arr[i - sub_len] max_sum = max(max_sum, total) return max_sum n = len(nums) max_first = max_second = 0 prefix_first = [0] * n prefix_second = [0] * n cur_first = cur_second = 0 for i in range(n): cur_first += nums[i] cur_second += nums[i] if i >= firstLen: cur_first -= nums[i - firstLen] if i >= secondLen: cur_second -= nums[i - secondLen] if i >= firstLen - 1: prefix_first[i] = max(prefix_first[i - 1], cur_first) if i >= secondLen - 1: prefix_second[i] = max(prefix_second[i - 1], cur_second) max_sum = 0 cur_first = cur_second = 0 for j in range(n - 1, -1, -1): cur_first += nums[j] cur_second += nums[j] if j <= n - firstLen - 1: cur_first -= nums[j + firstLen] if j <= n - secondLen - 1: cur_second -= nums[j + secondLen] if j <= n - firstLen: max_sum = max(max_sum, prefix_second[j - 1] + cur_first) if j <= n - secondLen: max_sum = max(max_sum, prefix_first[j - 1] + cur_second) return max_sum"},{"question":"You are given a string `formula` representing a chemical formula. The formula contains only uppercase letters that represent chemical elements, numbers that represent the count of atoms of that element, and parentheses for grouping. The formula might be nested and the counts are not necessarily single digits (they can be multiple digits). You need to return a dictionary where the keys are the elements and the values are their respective counts in the formula. The order of elements in the dictionary should be lexicographically sorted. Example: - For the input `formula = \\"K4(ON(SO3)2)2\\"`, the output should be `{\\"K\\": 4, \\"N\\": 2, \\"O\\": 14, \\"S\\": 4}`. Create a function that parses the chemical formula and counts the number of each type of atom.","solution":"import re from collections import defaultdict from collections import Counter def count_of_atoms(formula): Count the number of each type of atom in a chemical formula. Args: formula (str): The chemical formula to parse. Returns: dict: A dictionary where keys are elements and values are their counts. def parse(): stack = [Counter()] i = 0 n = len(formula) while i < n: if formula[i] == \'(\': stack.append(Counter()) i += 1 elif formula[i] == \')\': top = stack.pop() i += 1 i_start = i while i < n and formula[i].isdigit(): i += 1 multiplier = int(formula[i_start:i] or 1) for elem in top: stack[-1][elem] += top[elem] * multiplier else: i_start = i i += 1 while i < n and formula[i].islower(): i += 1 elem = formula[i_start:i] i_start = i while i < n and formula[i].isdigit(): i += 1 count = int(formula[i_start:i] or 1) stack[-1][elem] += count return stack.pop() counts = parse() return dict(sorted(counts.items()))"},{"question":"Given a list of strings, return the longest common prefix string amongst all the strings in the list. If there is no common prefix, return an empty string. Example: Input: [\\"flower\\",\\"flow\\",\\"flight\\"] Output: \\"fl\\" Input: [\\"dog\\",\\"racecar\\",\\"car\\"] Output: \\"\\"","solution":"def longest_common_prefix(strs): Returns the longest common prefix string amongst all the strings in the list. If there is no common prefix, return an empty string. if not strs: return \\"\\" # Start with the first string in the list as the initial prefix prefix = strs[0] # Compare the prefix with each string in the list for s in strs[1:]: while not s.startswith(prefix): # Trim the last character from the prefix until a common prefix is found prefix = prefix[:-1] if not prefix: return \\"\\" return prefix"},{"question":"You are given a string `s` consisting of lowercase letters, and a string `t`. Write a function that returns the minimum window substring of `s` which contains all the characters in `t` (including duplicates). If there is no such window in `s` that covers all characters in `t`, return an empty string `\\"\\"`. If there are multiple such minimum-length windows, return the one that appears first. For example: - `Input: s = \\"ADOBECODEBANC\\", t = \\"ABC\\"` - `Output: \\"BANC\\"` - `Input: s = \\"a\\", t = \\"a\\"` - `Output: \\"a\\"`","solution":"def min_window(s, t): from collections import Counter if not s or not t: return \\"\\" dict_t = Counter(t) required = len(dict_t) l, r = 0, 0 formed = 0 window_counts = {} ans = float(\\"inf\\"), None, None while r < len(s): character = s[r] window_counts[character] = window_counts.get(character, 0) + 1 if character in dict_t and window_counts[character] == dict_t[character]: formed += 1 while l <= r and formed == required: character = s[l] if r - l + 1 < ans[0]: ans = (r - l + 1, l, r) window_counts[character] -= 1 if character in dict_t and window_counts[character] < dict_t[character]: formed -= 1 l += 1 r += 1 if ans[0] == float(\\"inf\\"): return \\"\\" else: return s[ans[1]: ans[2] + 1]"},{"question":"You are given a matrix `mat` of size `m x n` consisting of non-negative integers. Your task is to find the **maximum sum of a submatrix** with the constraints that the submatrix must be rectangular in shape and not exceed a specified dimension `r x c`. Return _the maximum sum_ achievable under these conditions.","solution":"def max_sum_submatrix(mat, r, c): Returns the maximum sum of a submatrix with dimensions r x c in the given m x n matrix mat. Parameters: mat (list of list of int): The input matrix with non-negative integers. r (int): The number of rows in the submatrix. c (int): The number of columns in the submatrix. Returns: int: The maximum sum of a submatrix with dimensions r x c. m = len(mat) n = len(mat[0]) if r > m or c > n: return 0 # If the desired submatrix exceeds the matrix\'s dimensions. # Precompute the prefix sum matrix prefix_sum = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): prefix_sum[i][j] = mat[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1] max_sum = float(\'-inf\') for i in range(r, m + 1): for j in range(c, n + 1): current_sum = prefix_sum[i][j] - prefix_sum[i - r][j] - prefix_sum[i][j - c] + prefix_sum[i - r][j - c] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"You are given a string `s` containing only lowercase characters. In one move, you can remove any palindromic subsequence from the string. Return the minimum number of moves needed to make the given string empty. A subsequence is defined as a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements. A string is considered a palindrome if it reads the same forward and backward.","solution":"def min_moves_to_make_empty(s): Returns the minimum number of moves needed to make the given string empty. if not s: return 0 if s == s[::-1]: return 1 return 2"},{"question":"You are given an array of distinct integers `arr` and an integer `target`. Your task is to find all unique triplets in the array that sum up to the `target` number. Each triplet should be sorted in ascending order, and the triplets themselves should be sorted in ascending order based on the first element, then the second element, and finally the third element if necessary. Return _a list of all unique triplets that sum up to the `target`_. **Example:** ```plaintext Input: arr = [-1, 0, 1, 2, -1, -4], target = 0 Output: [[-1, -1, 2], [-1, 0, 1]] ```","solution":"def three_sum(arr, target): Finds all unique triplets in the array that sum up to the target number. arr.sort() triplets = [] for i in range(len(arr) - 2): if i > 0 and arr[i] == arr[i - 1]: continue left, right = i + 1, len(arr) - 1 while left < right: current_sum = arr[i] + arr[left] + arr[right] if current_sum == target: triplets.append([arr[i], arr[left], arr[right]]) while left < right and arr[left] == arr[left + 1]: left += 1 while left < right and arr[right] == arr[right - 1]: right -= 1 left += 1 right -= 1 elif current_sum < target: left += 1 else: right -= 1 return triplets"},{"question":"Given an array of integers `arr`, find the shortest continuous subarray, if any, that when sorted makes the whole array sorted in non-decreasing order. Return the length of this subarray. A **continuous subarray** is a subarray where the elements are contiguous or adjacent in the original array. * For `arr = [2, 6, 4, 8, 10, 9, 15]`, sorting `arr[1:5]` results in the whole array being sorted. The length of this subarray is 5. * For `arr = [1, 2, 3, 4]`, the whole array is already sorted, so the length of the subarray is 0.","solution":"def findUnsortedSubarray(arr): Returns the length of the shortest subarray that needs to be sorted for the entire array to become sorted in non-decreasing order. n = len(arr) if n <= 1: return 0 start, end = -1, -1 max_val, min_val = float(\'-inf\'), float(\'inf\') for i in range(n): max_val = max(max_val, arr[i]) if arr[i] < max_val: end = i for i in range(n - 1, -1, -1): min_val = min(min_val, arr[i]) if arr[i] > min_val: start = i if start == -1 and end == -1: return 0 return end - start + 1"},{"question":"You are given a linked list where each node contains an integer value. Your task is to remove all duplicate values from the linked list such that each value appears only once. The order of nodes should be preserved as in the original list. Return the head of the modified linked list.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def remove_duplicates(head): Remove duplicates from a sorted linked list and return the head of the modified list. if not head: return head current = head seen = set() seen.add(current.val) while current and current.next: if current.next.val in seen: current.next = current.next.next else: seen.add(current.next.val) current = current.next return head"},{"question":"Given a connected undirected graph represented in adjacency list format, write a function to find the shortest path length between two given nodes, `start` and `end`. If there is no path between `start` and `end`, return -1. The adjacency list is represented as a dictionary where the keys are node values and the values are lists of connected nodes. Ensure your function handles graphs with multiple nodes and varying connectivity efficiently.","solution":"from collections import deque def bfs_shortest_path(graph, start, end): Find the shortest path between start and end in a graph using BFS. Return the length of the shortest path. If no path exists, return -1. if start == end: return 0 visited = set() queue = deque([(start, 0)]) while queue: current, distance = queue.popleft() if current == end: return distance if current not in visited: visited.add(current) for neighbor in graph[current]: if neighbor not in visited: queue.append((neighbor, distance + 1)) return -1"},{"question":"You are given a string `s` representing a sentence, and an integer `k`. You need to return the `k` most frequent words in the sentence. If there is a tie, the words should be returned in alphabetical order. The words are case-insensitive. Words are defined as strings of letters (both uppercase and lowercase). Punctuation marks are not part of the words. For example, the input sentence \\"The day is sunny; the the the Sunny is is\\" and `k = 4` would output `[\\"the\\", \\"is\\", \\"sunny\\", \\"day\\"]`.","solution":"from collections import Counter import re def most_frequent_words(s, k): Returns the k most frequent words in the sentence. Words are case-insensitive, and ties are resolved alphabetically. # Normalize the sentence to lowercase and remove punctuation s = s.lower() words = re.findall(r\'bw+b\', s) # Count the frequency of each word word_counts = Counter(words) # Sort the words by frequency and then alphabetically sorted_words = sorted(word_counts.items(), key=lambda x: (-x[1], x[0])) # Extract the top k words most_frequent = [word for word, _ in sorted_words[:k]] return most_frequent"},{"question":"You are given an array of strings `words` and a string `target`. Your task is to determine if `target` can be constructed by concatenating any subset of the strings in `words`. All strings in `words` and the `target` itself consist only of lowercase English letters. Return `true` if it is possible to construct the `target`, otherwise return `false`.","solution":"def can_construct_target(words, target): Determine if the target string can be constructed by concatenating any subset of the strings in words. Parameters: words (list of str): Array of strings available for concatenation. target (str): The target string to be constructed. Returns: bool: True if the target can be constructed, False otherwise. def can_construct(remaining_target, memo): if remaining_target == \\"\\": return True if remaining_target in memo: return memo[remaining_target] for word in words: if remaining_target.startswith(word): suffix = remaining_target[len(word):] if can_construct(suffix, memo): memo[remaining_target] = True return True memo[remaining_target] = False return False memo = {} return can_construct(target, memo)"},{"question":"Given a list of non-negative integers `nums`, you are tasked with arranging them such that they form the largest possible number. Return the largest number you can form as a string. For example, given `[10, 2]`, the largest formed number is `\\"210\\"`. Write a function that accomplishes this using a custom sorting method. The input array may have leading zeros, but the output should not have any leading zeros, unless the number itself is `0`.","solution":"from functools import cmp_to_key def largest_number(nums): Given a list of non-negative integers, arranges them to form the largest possible number. Parameters: nums (list): List of non-negative integers. Returns: str: The largest number formed as a string. if not nums: return \\"0\\" # Custom comparator to decide the order of concatenation def compare(x, y): # Return negative if x+y is greater than y+x, otherwise positive if x + y > y + x: return -1 elif x + y < y + x: return 1 else: return 0 # Convert integers to strings for comparison nums_str = [str(num) for num in nums] # Sort using the custom comparator nums_str.sort(key=cmp_to_key(compare)) # If the largest num is \'0\', the result is \'0\' if nums_str[0] == \'0\': return \'0\' # Join all numbers to form the largest number return \'\'.join(nums_str)"},{"question":"You are given a list of integers `heights` representing the height of trees in a forest. Each integer in the list represents the height of a tree at that index. You can cut down one or more trees such that the trees that remain form a continuous segment of the original list. Your task is to determine the minimum number of trees that need to be cut to achieve this. Return _the minimum number of trees that need to be cut down to create a continuous segment of trees with strictly increasing heights_.","solution":"def min_cuts_to_increasing_segment(heights): Returns the minimum number of trees that need to be cut down to create a continuous segment of trees with strictly increasing heights. n = len(heights) if n == 0: return 0 # Create LIS and LDS arrays lis = [1] * n for i in range(1, n): for j in range(i): if heights[i] > heights[j]: lis[i] = max(lis[i], lis[j] + 1) lds = [1] * n for i in range(n-2, -1, -1): for j in range(i+1, n): if heights[i] < heights[j]: lds[i] = max(lds[i], lds[j] + 1) max_increasing_segment = 0 for i in range(n): max_increasing_segment = max(max_increasing_segment, lis[i] + lds[i] - 1) return n - max_increasing_segment"},{"question":"You are given an array of strings `words` and a string `chars`. A string is considered **good** if it can be formed by characters from `chars` without rearranging the characters in `chars`. Note that each character in `chars` can only be used once, and `chars` may contain duplicate characters that are needed to form a good string. Return the **total length** of all good strings that can be formed using characters from `chars`. For example, if `words = [\\"cat\\", \\"bt\\", \\"hat\\", \\"tree\\"]` and `chars = \\"atach\\"`, then the good strings are \\"cat\\" and \\"hat\\", which have lengths 3 and 3. Thus, the total length is 6. reiben the total point sum of rescueenting answer since 2 strings have been formed:","solution":"def count_characters(words, chars): Returns the total length of all good strings that can be formed using characters from chars. from collections import Counter chars_count = Counter(chars) total_length = 0 for word in words: word_count = Counter(word) if all(word_count[char] <= chars_count[char] for char in word_count): total_length += len(word) return total_length"},{"question":"You are given an m x n integer matrix `grid` where each element represents the altitude at that position. A **peak** in the grid is an element that is strictly greater than its four neighbors (left, right, up, down). Return the list of coordinates `[i, j]` of all the peaks in the grid. If a peak is on the boundary of the grid, consider only its in-bounds neighbors for comparison. Sort the coordinates in lexicographic order.","solution":"def find_peaks(grid): Returns the list of coordinates [i, j] of all the peaks in the grid. if not grid or not grid[0]: return [] def is_peak(i, j): current = grid[i][j] # Check all four neighbors if i > 0 and grid[i-1][j] >= current: return False if i < len(grid) - 1 and grid[i+1][j] >= current: return False if j > 0 and grid[i][j-1] >= current: return False if j < len(grid[0]) - 1 and grid[i][j+1] >= current: return False return True peaks = [] for i in range(len(grid)): for j in range(len(grid[0])): if is_peak(i, j): peaks.append([i, j]) peaks.sort() return peaks"},{"question":"Given a `k`-ary tree represented as an adjacency list, where each node has at most `k` children and the tree is rooted at node `0`, return _the level order traversal of the tree_. The tree is given as a list of lists `adj`, where `adj[i]` is a list of integers representing the children of node `i`.","solution":"from collections import deque def level_order_traversal(adj): Given a k-ary tree represented as an adjacency list adj, performs a level order traversal and returns the levels as a list of lists. Parameters: adj (List[List[int]]): Adjacency list representing the k-ary tree. Returns: List[List[int]]: Level order traversal of the tree. if not adj: return [] result = [] queue = deque([0]) # Start with the root node (0) while queue: level_size = len(queue) level_nodes = [] for _ in range(level_size): node = queue.popleft() level_nodes.append(node) for child in adj[node]: queue.append(child) result.append(level_nodes) return result"},{"question":"Given a list of integers `nums` where each integer represents the height of a building situated at position `i` on a line, find out _the maximum amount of water that can be trapped between two buildings post-rain_. The buildings are represented as vertical lines on a graph, and the amount of water trapped is measured in square units. Return the maximum water that can be trapped. For example, given the list `[1, 8, 6, 2, 5, 4, 8, 3, 7]`, the maximum water that can be trapped is `49`.","solution":"def max_water_trapped(nums): Returns the maximum amount of water that can be trapped between two buildings. left, right = 0, len(nums) - 1 max_water = 0 while left < right: height = min(nums[left], nums[right]) width = right - left max_water = max(max_water, height * width) if nums[left] < nums[right]: left += 1 else: right -= 1 return max_water"},{"question":"You are given an array of integers `nums` and an integer `target`. Your task is to find all unique pairs of integers in the array that sum up to the `target`. Return the pairs as a list of tuples `(a, b)`, such that `a < b`. Each pair (a, b) in the output should be sorted (in non-descending order) and the list of pairs should be sorted lexicographically. For example, given `nums = [1, 2, 3, 4, 5, 6]` and `target = 7`, the output should be `[(1, 6), (2, 5), (3, 4)]`. Write a function that implements this behavior. The function signature should be: ```python def two_sum_pairs(nums: List[int], target: int) -> List[Tuple[int, int]]: ```","solution":"from typing import List, Tuple def two_sum_pairs(nums: List[int], target: int) -> List[Tuple[int, int]]: nums.sort() seen = set() pairs = set() for num in nums: complement = target - num if complement in seen: pairs.add((min(num, complement), max(num, complement))) seen.add(num) return sorted(pairs)"},{"question":"You are given an array of integers `arr`, and an integer `k`. You can perform the following operation as many times as you want: pick two indices `i` and `j` (0 ≤ i, j < arr.length) and if `arr[i] + arr[j]` is divisible by `k`, replace one of these elements (either `arr[i]` or `arr[j]`) with the `k`. Your task is to determine if it is possible to make all the elements in the array equal by performing the above operation. Return `true` if you can make all elements equal, otherwise return `false`.","solution":"def can_make_all_elements_equal(arr, k): Returns True if it is possible to make all the elements in the array equal by repeatedly performing the operation defined in the problem, otherwise False. # Check if all elements have the same remainder when divided by k remainder = arr[0] % k for num in arr: if num % k != remainder: return False return True"},{"question":"Given an array of integers `nums`, design an algorithm to find the length of the longest subsequence such that all elements of the subsequence are in increasing order. A subsequence is an ordered subset of the array\'s elements having the same relative order as the original array. You are required to return the length of this subsequence.","solution":"def length_of_lis(nums): Returns the length of the longest increasing subsequence in the given array nums. if not nums: return 0 # dp array to keep track of the length of the longest increasing subsequence ending at each index dp = [1] * len(nums) for i in range(1, len(nums)): for j in range(i): if nums[i] > nums[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"You are given a list of `products` and a string `searchWord`. Each product in the list is represented by a string, and the list is sorted lexicographically. You want to design a system such that when each character of the `searchWord` is typed, suggestions of at most three product names from the list are displayed. These suggestions should start with the characters typed so far. If there are more than three products that match, the system should display the first three. Return a list of lists of the suggested products after each character of `searchWord` is typed. For example, given `products = [\\"mobile\\", \\"mouse\\", \\"moneypot\\", \\"monitor\\", \\"mousepad\\"]` and `searchWord = \\"mouse\\"`, the suggested products after each character is typed would be: - After typing \\"m\\": [\\"mobile\\", \\"moneypot\\", \\"monitor\\"] - After typing \\"mo\\": [\\"mobile\\", \\"moneypot\\", \\"monitor\\"] - After typing \\"mou\\": [\\"mouse\\", \\"mousepad\\"] - After typing \\"mous\\": [\\"mouse\\", \\"mousepad\\"] - After typing \\"mouse\\": [\\"mouse\\", \\"mousepad\\"] Return the list of lists of suggested products accordingly.","solution":"def suggestedProducts(products, searchWord): Returns a list of lists of the suggested products after each character of searchWord is typed. :param products: List of product names sorted lexicographically. :param searchWord: The search word being typed. :return: List of lists of suggested products. products.sort() result = [] prefix = \\"\\" for char in searchWord: prefix += char suggestions = [product for product in products if product.startswith(prefix)] result.append(suggestions[:3]) return result"},{"question":"A startup is developing a new scheduling system, and you are tasked with implementing a specific feature. You are given a list of meetings, each with a start time and an end time represented as integer tuples `(start, end)`. Your task is to determine if a person can attend all the given meetings without any overlap. Implement a function `canAttendAllMeetings(meetings)` that takes a list of tuples `meetings`, where each tuple contains two integers representing the start and end times of each meeting. Return `True` if the person can attend all meetings without any overlap; otherwise, return `False`. Meetings are considered overlapping if one starts before the previous one ends. For example: - Input: `[(0, 30), (5, 10), (15, 20)]` - Output: `False` (since the meeting `(5, 10)` overlaps with `(0, 30)`). - Input: `[(5, 8), (9, 15)]` - Output: `True` (since there is no overlap between the meetings).","solution":"def canAttendAllMeetings(meetings): Determine if a person can attend all given meetings without any overlap. :param meetings: List of tuples, each containing two integers (start, end) representing meeting times. :return: True if the person can attend all meetings without overlap, otherwise False. # Sort meetings by their start time meetings.sort(key=lambda x: x[0]) for i in range(1, len(meetings)): # If the start time of the current meeting is less than the end time of the previous meeting, there\'s overlap if meetings[i][0] < meetings[i - 1][1]: return False return True"},{"question":"You are given a string `s` consisting solely of letters \'a\', \'b\', and \'c\'. You are allowed to replace any letter with another letter from the set {\'a\', \'b\', \'c\'}. Find the minimum number of replacements needed to make the string such that no three consecutive characters are the same. Return the minimum number of replacements required.","solution":"def min_replacements(s): Returns the minimum number of replacements needed to ensure that no three consecutive characters in the string are the same. replacements = 0 i = 0 n = len(s) while i < n - 2: # If we find three consecutive characters the same if s[i] == s[i+1] == s[i+2]: # We need to replace one of these replacements += 1 # Skipping next two, since we already handled replacement i += 3 else: i += 1 return replacements"},{"question":"Given a string `s` consisting of open and closed parentheses, return the minimum number of parentheses you must add to make `s` valid. A string is valid if it is correctly balanced, meaning every open parenthesis has a corresponding closed parenthesis and they are correctly nested.","solution":"def minAddToMakeValid(s): Returns the minimum number of parentheses to add to make the string valid. open_count = 0 close_count = 0 for char in s: if char == \'(\': open_count += 1 elif char == \')\': if open_count > 0: open_count -= 1 else: close_count += 1 return open_count + close_count"},{"question":"You are given two **0-indexed** integer arrays `original` and `modified`, of equal length `n`, and an integer `k`. The array `original` represents the initial states of `n` switches, where each element is either `0` (off) or `1` (on). The array `modified` represents the desired states of the switches. In one operation, you can flip the state of any **contiguous subarray** of length `k` in `original`. Flipping a subarray means converting all `0`s to `1`s and all `1`s to `0`s within that subarray. Return _the **minimum number** of operations required to transform_ `original` _to_ `modified`. If it is not possible to achieve the transformation, return `-1`.","solution":"def min_operations(original, modified, k): n = len(original) flips = 0 flip_operation = [0] * n flip_count = 0 for i in range(n): if i >= k: flip_count ^= flip_operation[i - k] if (original[i] ^ flip_count) != modified[i]: if i + k > n: return -1 flip_operation[i] = 1 flip_count ^= 1 flips += 1 return flips"},{"question":"You are given an integer array `nums` and an integer `target`. Your task is to find three distinct integers in the array `nums` such that the sum is closest to the given `target`. Write a function that returns the sum of the three integers. If there are multiple answers, return the sum of the three integers whose combined difference with `target` is the smallest in absolute value. Ensure that your solution considers optimized approaches for larger inputs. Example: ```python # example function signature def three_sum_closest(nums: List[int], target: int) -> int: # your code here ```","solution":"from typing import List def three_sum_closest(nums: List[int], target: int) -> int: nums.sort() closest_sum = float(\'inf\') for i in range(len(nums) - 2): left, right = i + 1, len(nums) - 1 while left < right: current_sum = nums[i] + nums[left] + nums[right] if abs(current_sum - target) < abs(closest_sum - target): closest_sum = current_sum if current_sum < target: left += 1 elif current_sum > target: right -= 1 else: return current_sum return closest_sum"},{"question":"You are given an array of integers `arr` where each element represents the height of a plant. You are tasked with watering the plants such that the heights of all plants are eventually equal. You can water a plant to increase its height by 1 unit in each operation. Return _the **minimum number of watering operations** required to make the heights of all plants equal_.","solution":"def min_waterings(arr): Returns the minimum number of watering operations required to make the heights of all plants equal. :param arr: List of integers where each integer represents the height of a plant. :return: Integer representing the minimum number of watering operations required. max_height = max(arr) total_operations = sum(max_height - height for height in arr) return total_operations"},{"question":"You are given a circular array `nums` of integers. A circular array means the end of the array wraps around to the beginning. Implement a method that returns the starting index of the longest contiguous subarray of equal values. If there is a tie, return the smallest starting index. For example, given `nums` = [1, 2, 3, 1, 1, 1, 2, 2], the result should be `3` since the longest contiguous subarray of equal values is [1, 1, 1] starting at index 3. Including the wrap-around, given `nums` = [2, 2, 2, 1], the result should be `0` for the subarray [2, 2, 2] starting at index 0.","solution":"def longest_contiguous_subarray_start_index(nums): Returns the starting index of the longest contiguous subarray of equal values in a circular array. if not nums: return -1 max_len = 0 max_start_index = 0 n = len(nums) current_val = nums[0] current_len = 1 current_start_index = 0 for i in range(1, 2 * n): index = i % n if nums[index] == current_val: current_len += 1 else: if current_len > max_len: max_len = current_len max_start_index = current_start_index elif current_len == max_len: max_start_index = min(max_start_index, current_start_index) current_val = nums[index] current_len = 1 current_start_index = index if current_len > max_len: max_len = current_len max_start_index = current_start_index elif current_len == max_len: max_start_index = min(max_start_index, current_start_index) return max_start_index"},{"question":"Given a list of meetings represented by their start and end times, determine if a person could attend all meetings without any overlaps. The list is represented by an array of `intervals`, where each interval is an array of two integers `[start, end]`. Implement the function `canAttendMeetings`. * `boolean canAttendMeetings(int[][] intervals)`: This function receives an array of intervals and returns a boolean indicating whether a person can attend all the meetings.","solution":"def canAttendMeetings(intervals): Returns True if a person can attend all meetings without any overlaps, False otherwise. # Sort the intervals by start time intervals.sort(key=lambda x: x[0]) # Check for any overlaps for i in range(1, len(intervals)): if intervals[i][0] < intervals[i-1][1]: return False return True"},{"question":"You are given a string `s` and an integer `k`. The string contains only lowercase English letters. You need to determine whether you can rearrange the characters in the string such that there are at most `k` characters between two consecutive occurrences of the same character. If it is possible, return `true`; otherwise, return `false`.","solution":"from collections import Counter from heapq import heappush, heappop def rearrangeString(s, k): Determines if it is possible to rearrange the characters in the string \'s\' such that there are at most \'k\' characters between two consecutive occurrences of the same character. :param s: Input string :param k: An integer representing the distance constraint :return: Boolean indicating whether rearrangement is possible if k == 0: return True char_count = Counter(s) max_heap = [] for char, count in char_count.items(): heappush(max_heap, (-count, char)) queue = [] result = [] while max_heap: count, char = heappop(max_heap) result.append(char) queue.append((char, count+1)) if len(queue) >= k: char, count = queue.pop(0) if -count > 0: heappush(max_heap, (count, char)) return len(result) == len(s)"},{"question":"You are given a string `s` consisting of lowercase English letters. In one move, you can change any vowel (a, e, i, o, u) in the string to another vowel. The goal is to make `s` alternating vowels and consonants (starting with either a vowel or a consonant). Return the **minimum** number of moves required to achieve this. If it\'s not possible, return -1.","solution":"def min_moves_to_alternating_vowels_consonants(s): Returns the minimum number of moves required to make the string s alternating vowels and consonants. vowels = {\'a\', \'e\', \'i\', \'o\', \'u\'} if not s: return 0 def is_vowel(char): return char in vowels def check_and_count(start_with_vowel): Check and count the number of moves needed if the alternation starts with a vowel or a consonant. moves = 0 for i, char in enumerate(s): if i % 2 == 0: # supposed to be vowel or consonant based on start_with_vowel flag if start_with_vowel and not is_vowel(char): moves += 1 elif not start_with_vowel and is_vowel(char): moves += 1 else: # supposed to be consonant or vowel based on start_with_vowel flag if start_with_vowel and is_vowel(char): moves += 1 elif not start_with_vowel and not is_vowel(char): moves += 1 return moves start_with_vowel_moves = check_and_count(True) start_with_consonant_moves = check_and_count(False) # Choose the minimum of two scenarios return min(start_with_vowel_moves, start_with_consonant_moves)"},{"question":"You are given a **0-indexed** integer array `heights` representing the height of students in a line. A group of students can form a team if the following conditions are satisfied: 1. The team consists of exactly `k` consecutive students. 2. The height of each student in the team should be in strictly increasing order. Return _the maximum number of such teams you can form from the array_. If no valid teams can be formed, return `0`.","solution":"def max_number_of_teams(heights, k): Returns the maximum number of teams of exactly k consecutive students where heights are strictly increasing. :param heights: The list of heights of students. :param k: The number of consecutive students in a team. :return: The maximum number of such teams. if k == 1: return len(heights) max_teams = 0 n = len(heights) for i in range(n - k + 1): is_valid_team = True for j in range(i, i + k - 1): if heights[j] >= heights[j + 1]: is_valid_team = False break if is_valid_team: max_teams += 1 return max_teams"},{"question":"You are given a string `s` containing lowercase and uppercase English letters. You need to insert exactly one space between each pair of adjacent letters that are different cases (one lowercase and one uppercase or one uppercase and one lowercase). Return _the modified string_. If there are consecutive letters of the same case, they should not be separated by a space. For example, if the input string is `\\"aBcDeF\\"`, the output should be `\\"a B c D e F\\"`.","solution":"def insert_spaces(s): Inserts exactly one space between each pair of adjacent letters that are different cases. :param s: Input string containing both lowercase and uppercase letters. :return: Modified string with spaces inserted between letters of different cases. result = [] for i in range(len(s)): if i > 0 and ((s[i].islower() and s[i-1].isupper()) or (s[i].isupper() and s[i-1].islower())): result.append(\' \') result.append(s[i]) return \'\'.join(result)"},{"question":"You are given an array `heights` representing the heights of buildings positioned on a 2D landscape. Each height represents a building of unit width rising from the ground level. The goal is to return the **maximum rectangular area** that can be formed using the buildings, constrained by their heights. You must consider buildings to be adjacent to each other without gaps, and the area should be calculated using the widest span you can form considering each building’s height as the shortest building in that span. Return an integer representing the maximum rectangular area. Example: - Input: `heights = [2, 1, 5, 6, 2, 3]` - Output: `10` This is because a rectangle of height `2` can be formed spanning from index `2` to index `4` (inclusive) resulting in an area of `10` (2 heights * 5 width).","solution":"def largest_rectangle_area(heights): Calculate the largest rectangular area possible using the buildings\' heights. :param heights: List[int] - List of building heights :return: int - Maximum rectangular area stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"Given an integer array `nums` of even length, partition it into two subsets `A` and `B` such that the sum of both subsets is equal. If such a partition is not possible, return `false`. Otherwise, return `true`. You must use all the integers in `nums` exactly once.","solution":"def can_partition(nums): Determine if the given list of numbers can be partitioned into two subsets such that the sum of the subsets is equal. :param nums: List[int] - The list of even length integers. :return: bool - True if such a partition is possible, False otherwise. total_sum = sum(nums) # If total sum is odd, can\'t partition into two equal subsets if total_sum % 2 != 0: return False target = total_sum // 2 n = len(nums) # Initialize the DP array dp = [False] * (target + 1) dp[0] = True # Process each number for num in nums: for j in range(target, num - 1, -1): dp[j] = dp[j] or dp[j - num] return dp[target]"},{"question":"Given a `0-indexed` array `heights` where `heights[i]` represents the height of the `i-th` person in a line, return a new array of the same length where each index `i` contains the number of people in front of the `i-th` person who have a height greater than or equal to `heights[i]`. A person `P` is considered \\"in front\\" of person `Q` if `P` appears at a lower index than `Q` in the array.","solution":"def count_people_in_front_with_greater_or_equal_height(heights): Returns a list where each index contains number of people in front with height >= heights[i] result = [0] * len(heights) for i in range(1, len(heights)): count = 0 for j in range(i): if heights[j] >= heights[i]: count += 1 result[i] = count return result"},{"question":"You are given a binary tree where each node is either 0 or 1. A binary tree is uni-valued if every node in the tree has the same value. Write a function to determine if the given binary tree is uni-valued or not. The function should take the root of the binary tree as an input and return `true` if the binary tree is uni-valued, and `false` otherwise.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_unival_tree(root): Determines if the binary tree is uni-valued (all nodes have the same value). :param root: TreeNode, the root of the binary tree :return: bool, True if the binary tree is uni-valued, False otherwise if not root: return True def dfs(node): if not node: return True if node.val != root.val: return False return dfs(node.left) and dfs(node.right) return dfs(root)"},{"question":"Given a string `num` representing a non-negative integer, return _the smallest integer that can be formed by rearranging the digits of `num` that is divisible by 3_. If no such arrangement exists, return \\"-1\\".","solution":"def smallest_divisible_by_3(num: str) -> str: Given a string `num` representing a non-negative integer, return the smallest integer that can be formed by rearranging the digits of `num` that is divisible by 3. If no such arrangement exists, return \\"-1\\". digits = list(num) sum_digits = sum(int(d) for d in digits) if sum_digits % 3 != 0: return \\"-1\\" digits.sort() smallest_num = \'\'.join(digits) return smallest_num"},{"question":"You are given a `rows x cols` grid representing a map where `grid[i][j] = 0` represents water and `grid[i][j] = 1` represents land. An island in the grid is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are surrounded by water. You need to find and return the maximum distance between any two land cells. If there is no land or the entire grid is land, return `-1`. To solve this, remember: - You can only move up, down, left, or right from a cell. - You need to find the two land cells such that the Manhattan distance between them is maximized. The Manhattan distance between two land cells `(x1, y1)` and `(x2, y2)` is `|x1 - x2| + |y1 - y2|`.","solution":"from collections import deque def max_distance(grid): rows, cols = len(grid), len(grid[0]) queue = deque() # Start by adding all land cells to the queue as starting points for r in range(rows): for c in range(cols): if grid[r][c] == 1: queue.append((r, c)) # If there are no land or the entire grid is land if not queue or len(queue) == rows * cols: return -1 directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] distance = -1 # Perform a BFS traversal while queue: distance += 1 for _ in range(len(queue)): r, c = queue.popleft() for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < rows and 0 <= nc < cols and grid[nr][nc] == 0: grid[nr][nc] = 1 # Mark the cell as visited queue.append((nr, nc)) return distance"},{"question":"Given an unsorted array of integers, rearrange the elements in such a way that they form an alternating sequence of peaks and valleys. A peak is an element that is greater than its neighboring elements, and a valley is an element that is smaller than its neighboring elements. If the resulting array is `[a0, a1, a2, ...]`, then `a0 <= a1 >= a2 <= a3 >= a4 <= ...` or `a0 >= a1 <= a2 >= a3 <= a4 >= ...`. Your task is to modify the array in place to meet this requirement. Write a function `void wiggleSort(int[] nums)` that accepts the unsorted integer array `nums` and modifies it in place to produce the alternating peaks and valleys sequence.","solution":"def wiggleSort(nums): Rearranges the elements of the array in such a way that they form an alternating sequence of peaks and valleys. for i in range(len(nums) - 1): if (i % 2 == 0 and nums[i] > nums[i + 1]) or (i % 2 == 1 and nums[i] < nums[i + 1]): # Swap elements to meet the condition nums[i], nums[i + 1] = nums[i + 1], nums[i]"},{"question":"You are given an unsorted integer array `nums`, where `nums` can contain duplicate integers. Your task is to return an element that appears more than `n/3` times in the array, where `n` is the length of `nums`. If no such element exists, return `-1`. The algorithm should run in linear time and use constant space.","solution":"def find_element_appearing_more_than_n_by_3(nums): Returns an element that appears more than n/3 times in the array nums. If no such element exists, returns -1. if not nums: return -1 n = len(nums) candidate1, candidate2, count1, count2 = None, None, 0, 0 # Moore\'s Voting Algorithm to find candidates for num in nums: if candidate1 is not None and candidate1 == num: count1 += 1 elif candidate2 is not None and candidate2 == num: count2 += 1 elif count1 == 0: candidate1, count1 = num, 1 elif count2 == 0: candidate2, count2 = num, 1 else: count1 -= 1 count2 -= 1 # Verify the candidates count1, count2 = 0, 0 for num in nums: if num == candidate1: count1 += 1 elif num == candidate2: count2 += 1 if count1 > n // 3: return candidate1 if count2 > n // 3: return candidate2 return -1"},{"question":"Given a binary tree, where each node contains a `0` or `1`, you need to find and return the maximum length of an alternating path that starts at any node and ends at another node (or the same node) in the tree. An **alternating path** is defined as a path where the values of the nodes in the path alternate between `0` and `1`. A path can only travel through connected nodes, and each node can be visited at most once. For example, given the binary tree with nodes `root = [0,1,0,null,null,1,0]`, the maximum length of an alternating path would be `3`.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def max_alternating_path_length(root): def dfs(node, prev_val, length): if not node: return length if node.val != prev_val: left_len = dfs(node.left, node.val, length + 1) right_len = dfs(node.right, node.val, length + 1) return max(left_len, right_len) else: left_len = dfs(node.left, node.val, 0) right_len = dfs(node.right, node.val, 0) return length if not root: return 0 left_max = dfs(root.left, root.val, 1) right_max = dfs(root.right, root.val, 1) return max(left_max, right_max)"},{"question":"Given a set of integers, write an algorithm to identify all triplets in the array that sum to a given target value. The output should be a list of unique triplets. Each triplet should be a list of exactly three integers from the array, and the order within each triplet does not matter. The algorithm should not return duplicate triplets, and the order of the triplets in the output list does not matter. For example, given the array `[-1, 0, 1, 2, -1, -4]` and the target value `0`, the algorithm might return `[[-1, -1, 2], [-1, 0, 1]]`. Note that the solution set must not contain duplicate triplets, and the order of the triplets in the output does not matter. Ensure that your algorithm has a reasonable time complexity.","solution":"def three_sum(nums, target): Returns a list of unique triplets in the array that sum to a given target value. Parameters: nums (List[int]): The input list of integers. target (int): The target sum value. Returns: List[List[int]]: A list of unique triplets that sum to the target value. nums.sort() triplets = [] for i in range(len(nums) - 2): if i > 0 and nums[i] == nums[i - 1]: continue # skip duplicate elements left, right = i + 1, len(nums) - 1 while left < right: current_sum = nums[i] + nums[left] + nums[right] if current_sum == target: triplets.append([nums[i], nums[left], nums[right]]) while left < right and nums[left] == nums[left + 1]: left += 1 # skip duplicate elements while left < right and nums[right] == nums[right - 1]: right -= 1 # skip duplicate elements left += 1 right -= 1 elif current_sum < target: left += 1 else: right -= 1 return triplets"},{"question":"Determine if a given string can be rearranged to form a palindrome. A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward (ignoring spaces, punctuation, and capitalization). **Example:** * \\"A man a plan a canal Panama\\" can be rearranged to \\"A man a canal a plan Panama\\", which is a palindrome. * \\"racecar\\" is already a palindrome. * \\"hello\\" cannot be rearranged to form a palindrome. Return a boolean indicating whether the given string can be rearranged to form a palindrome.","solution":"def can_form_palindrome(s): Determines if a given string can be rearranged to form a palindrome. :param s: Input string to check :return: True if the string can be rearranged to form a palindrome, False otherwise # Normalize the string: remove spaces, punctuations, and convert to lowercase normalized_str = \'\'.join(char.lower() for char in s if char.isalnum()) # Count the frequency of each character char_count = {} for char in normalized_str: char_count[char] = char_count.get(char, 0) + 1 # A string can form a palindrome if at most one character has an odd frequency odd_count = 0 for count in char_count.values(): if count % 2 != 0: odd_count += 1 return odd_count <= 1"},{"question":"An [**abundant number**](https://en.wikipedia.org/wiki/Abundant_number) is a **positive integer** that is smaller than the sum of its **proper divisors** (positive divisors excluding the number itself). For a given integer `m`, your task is to write a function that determines whether `m` is an abundant number. Return `true` if `m` is abundant, otherwise return `false`.","solution":"def is_abundant_number(m): Determines if a number m is an abundant number. Parameters: m (int): The number to check. Returns: bool: True if m is an abundant number, False otherwise. if m <= 0: return False sum_of_divisors = 0 for i in range(1, m // 2 + 1): if m % i == 0: sum_of_divisors += i return sum_of_divisors > m"},{"question":"You are given an array of integers `arr` and an integer `pivot`. Rearrange the elements of `arr` in such a way that all elements less than `pivot` appear before all elements equal to `pivot`, which in turn must appear before all elements greater than `pivot`. Maintain the order of elements less than `pivot` and greater than `pivot` the same as in the original array. Return the rearranged array.","solution":"def pivot_array(arr, pivot): Rearranges array elements such that all elements less than pivot come first, followed by elements equal to pivot, then elements greater than pivot. The relative order within each group is maintained. :param arr: List of integers to be rearranged. :param pivot: The pivot value against which the arrangement is done. :return: Rearranged array. less_than = [x for x in arr if x < pivot] equal_to = [x for x in arr if x == pivot] greater_than = [x for x in arr if x > pivot] return less_than + equal_to + greater_than"},{"question":"You are given an array of integers `nums` and a positive integer `k`. You are allowed to choose any subsequence of `nums` (possibly empty) and remove it, and repeat the process up to `k` times. The cost of removing a subsequence is the sum of the elements of the subsequence. Return the minimum possible sum of the elements left in the array after performing the removal operation exactly `k` times.","solution":"def minimum_sum_after_k_removals(nums, k): Returns the minimum possible sum of the elements left in the array after performing the removal operation exactly k times. nums.sort() # Sort the array to maximize the sum of removed subsequences return sum(nums[k:]) # Sum of the elements left after removing k smallest elements # Example usage: # nums = [4, 3, 2, 10, 12] # k = 2 # This returns 25 because the sum of the remaining numbers after removing the two smallest (2 and 3) is 4 + 10 + 12 = 26 # print(minimum_sum_after_k_removals(nums, k))"},{"question":"You are given a string `s` consisting of lowercase English letters and you are allowed to perform the following operation any number of times: Choose a non-empty subsequence of `s` and remove all its occurrences from `s`. Find the minimum number of operations required to make the string empty. A subsequence of a string is a new string generated from the original string with some characters(can be none) deleted without changing the relative order of the remaining characters. For example, the subsequences of \\"abc\\" are \\"\\", \\"a\\", \\"b\\", \\"c\\", \\"ab\\", \\"ac\\", \\"bc\\", and \\"abc\\".","solution":"def min_operations_to_empty(s): Returns the minimum number of operations required to make the string empty by removing any non-empty subsequence any number of times. if not s: return 0 # Since the task is to count distinct characters, we can simplify: unique_chars = set(s) return len(unique_chars)"},{"question":"Given a string `s`, return _the length of the longest palindromic substring in `s`_. A **palindrome** is a string that reads the same backward as forward. Use a dynamic programming approach to solve this problem. For example: - Input: `s = \\"babad\\"` - Output: `3` - Explanation: The answer is \\"bab\\" or \\"aba\\", both of which are length 3. - Input: `s = \\"cbbd\\"` - Output: `2` - Explanation: The answer is \\"bb\\", which is length 2.","solution":"def longest_palindromic_substring_length(s): Returns the length of the longest palindromic substring in s. n = len(s) if n == 0: return 0 dp = [[False] * n for _ in range(n)] max_length = 1 # Every single character is a palindrome for i in range(n): dp[i][i] = True start = 0 # Check for a palindrome of length 2 for i in range(n - 1): if s[i] == s[i + 1]: dp[i][i + 1] = True start = i max_length = 2 # Check for palindromes of length greater than 2 for k in range(3, n + 1): # Fix the starting index for i in range(n - k + 1): # Determine the ending index of the substring from starting index i and length k j = i + k - 1 # Check for sub-string from ith index to jth index if s[i] == s[j] and dp[i + 1][j - 1]: dp[i][j] = True if k > max_length: start = i max_length = k return max_length"},{"question":"Given a list of distinct integers `nums`, find all unique triplets in the list which give the sum of zero. Note that all triplets must be ordered such that `nums[a] < nums[b] < nums[c]` and `a < b < c`. Return all the triplets in lexicographical order, each triplet being a list of integers `[nums[a], nums[b], nums[c]]`. If no such triplets exist, return an empty list. For instance, given `nums = [-1, 0, 1, 2, -1, -4]`, the function should return `[[-1, -1, 2], [-1, 0, 1]]`.","solution":"def three_sum(nums): Returns all unique triplets in the list which give the sum of zero. The triplets are returned in lexicographical order. nums.sort() result = [] n = len(nums) for i in range(n-2): if i > 0 and nums[i] == nums[i-1]: continue l, r = i+1, n-1 while l < r: total = nums[i] + nums[l] + nums[r] if total == 0: result.append([nums[i], nums[l], nums[r]]) while l < r and nums[l] == nums[l+1]: l += 1 while l < r and nums[r] == nums[r-1]: r -= 1 l += 1 r -= 1 elif total < 0: l += 1 else: r -= 1 # Sort the result list lexicographically result.sort() return result"},{"question":"You are given a matrix `grid` of size `m x n`, consisting only of `0`s and `1`s. In one move, you can choose any `1` in the grid and change it to a `0`, or choose any `0` in the grid and change it to a `1`. The goal is to have all rows of the matrix be the same, either consisting entirely of `1`s or entirely of `0`s. Compute and return the minimum number of moves required to achieve this goal.","solution":"def min_moves_to_make_grid_rows_same(grid): Calculates the minimum number of moves to make all rows of the grid the same, either all 1s or all 0s. Parameters: grid (List[List[int]]): A 2D list representation of the grid with 0s and 1s. Returns: int: The minimum number of moves required. m = len(grid) n = len(grid[0]) if m > 0 else 0 # Count the number of 1s and 0s in the grid count_1s = sum(cell for row in grid for cell in row) count_0s = m * n - count_1s # To make all rows the same, either we need to convert all elements to 0 or all to 1 # To convert all to 1s, we need to flip all 0s # To convert all to 0s, we need to flip all 1s return min(count_1s, count_0s)"},{"question":"You are given a **0-indexed** array `arr` of `n` integers and an integer `x`. Find the **length of the longest subarray** where the absolute difference between any two elements in this subarray is at most `x`. Return _the length of this subarray_. If there is no such subarray, return `0`.","solution":"def longest_subarray(arr, x): Finds the length of the longest subarray where the absolute difference between any two elements is at most x. Parameters: arr (list of int): The input array of integers. x (int): The integer defining the maximum allowed absolute difference. Returns: int: The length of the longest subarray satisfying the condition. from collections import deque if not arr: return 0 max_len = 0 min_deque, max_deque = deque(), deque() left = 0 for right in range(len(arr)): while min_deque and arr[min_deque[-1]] > arr[right]: min_deque.pop() while max_deque and arr[max_deque[-1]] < arr[right]: max_deque.pop() min_deque.append(right) max_deque.append(right) while arr[max_deque[0]] - arr[min_deque[0]] > x: left += 1 if min_deque[0] < left: min_deque.popleft() if max_deque[0] < left: max_deque.popleft() max_len = max(max_len, right - left + 1) return max_len"},{"question":"You are given a linked list, which might contain a cycle. Determine if the linked list has a cycle in it. A cycle is present if while traversing the list, you revisit a node you have previously seen. Return `true` if there is a cycle, otherwise, return `false`. Try to solve it using constant space.","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def hasCycle(head): Returns true if there is a cycle in the linked list, otherwise false. slow = head fast = head while fast is not None and fast.next is not None: slow = slow.next fast = fast.next.next if slow == fast: return True return False"},{"question":"You are given a string `s` consisting only of the characters \'0\' and \'1\'. You can flip exactly one character (change a \'0\' to \'1\' or vice versa) in the string. Your task is to determine the maximum number of consecutive \'1\'s you can obtain by flipping exactly one character. Return _the length of the longest sequence of consecutive \'1\'s_ achievable after exactly one flip.","solution":"def max_consecutive_ones(s): Returns the maximum number of consecutive \'1\'s obtainable by flipping exactly one \'0\' to \'1\' in the string s. # Edge case: empty string if not s: return 0 n = len(s) max_ones = 0 zero_count = 0 left = 0 for right in range(n): if s[right] == \'0\': zero_count += 1 while zero_count > 1: if s[left] == \'0\': zero_count -= 1 left += 1 max_ones = max(max_ones, right - left + 1) return max_ones"},{"question":"A company has multiple departments, each offering a variety of projects. Each project has a start time and an end time. You are tasked with determining the minimum number of meeting rooms required for the projects in all departments combined. Given a list of `projects`, where each project is represented by a tuple `(start_time, end_time)`, return the minimum number of simultaneous meeting rooms required so that all projects can be completed without any scheduling conflicts. The start and end times are inclusive. (Note: Projects are sorted by their start times in ascending order).","solution":"import heapq def min_meeting_rooms(projects): Determines the minimum number of meeting rooms required for the list of projects. Parameters: projects (list of tuple): A list of projects where each project is represented as (start_time, end_time) Returns: int: The minimum number of meeting rooms required if not projects: return 0 # Initialize a min heap. heap = [] for project in projects: start_time, end_time = project # If the earliest end time in heap is less than or equal to the start time of current project, # free up that room (remove the end_time from heap) if heap and heap[0] <= start_time: heapq.heappop(heap) # Add the current project end time into the heap heapq.heappush(heap, end_time) # The size of the heap will tell us the number of meeting rooms required. return len(heap)"},{"question":"You are given a matrix `mat` with `m` rows and `n` columns containing integers. Your task is to find the number of \\"peaks\\" in the matrix. A cell `(i, j)` is considered a peak if it is greater than all of its four potential neighbors (up, down, left, right). Boundary cells are considered peaks if they are greater than their neighboring cells within the boundary. Return the number of peaks found in the matrix.","solution":"def count_peaks(mat): Counts the number of peaks in a given matrix. A peak is defined as a cell that is greater than its four potential neighbors (up, down, left, right). Parameters: mat (List[List[int]]): 2D list representing the matrix. Returns: int: Number of peaks in the matrix. if not mat or not mat[0]: return 0 m = len(mat) n = len(mat[0]) peaks = 0 def is_peak(i, j): current_val = mat[i][j] # Check up if i > 0 and mat[i-1][j] >= current_val: return False # Check down if i < m - 1 and mat[i+1][j] >= current_val: return False # Check left if j > 0 and mat[i][j-1] >= current_val: return False # Check right if j < n - 1 and mat[i][j+1] >= current_val: return False return True for i in range(m): for j in range(n): if is_peak(i, j): peaks += 1 return peaks"},{"question":"You are given a string `s` consisting of lowercase letters and an integer `k`.** You need to construct a new string by replacing exactly `k` characters in `s` with any lowercase letter such that the new string contains the longest possible substring with all identical characters. Return _the length of the longest substring with all identical characters you can achieve after doing the above operation._ For example, if `s = \\"aabbcc\\"` and `k = 2`, you can replace the two \'c\'s with \'a\'s to get \\"aaaaaa\\", which has a substring \\"aaaaaa\\" of length 6.","solution":"def longest_substring_after_replacements(s, k): Returns the length of the longest substring with all identical characters after replacing exactly k characters in the string s. # Frequency map of character count = {} max_len = 0 left = 0 for right in range(len(s)): count[s[right]] = count.get(s[right], 0) + 1 # Window size current_window_size = right - left + 1 if (current_window_size - max(count.values())) <= k: max_len = max(max_len, current_window_size) else: # If the condition fails, shrink the window count[s[left]] -= 1 left += 1 return max_len"},{"question":"Given an array of integers `arr`, return the length of the longest subarray consisting only of unique elements. If there are multiple subarrays with the same maximum length, return the one that appears first in the array. You may assume that all elements in `arr` are non-negative integers.","solution":"def longest_unique_subarray_length(arr): Returns the length of the longest subarray consisting only of unique elements. If there are multiple subarrays with the same maximum length, return the one that appears first. if not arr: return 0 seen = {} max_len = 0 start = 0 for end, value in enumerate(arr): if value in seen: start = max(start, seen[value] + 1) seen[value] = end max_len = max(max_len, end - start + 1) return max_len"},{"question":"Given an array of integers `arr`, return the length of the longest subarray that contains an equal number of odd and even numbers. If there are multiple such subarrays, return the length of any one of them. Implement a function `int longestEqualOddEvenSubarray(int[] arr)` that takes an array `arr` as input and returns the length of the longest subarray with an equal number of odd and even numbers.","solution":"def longestEqualOddEvenSubarray(arr): Returns the length of the longest subarray with an equal number of odd and even numbers. max_len = 0 prefix_sum = 0 prefix_sum_map = {0: -1} for i in range(len(arr)): if arr[i] % 2 == 0: prefix_sum += 1 else: prefix_sum -= 1 if prefix_sum in prefix_sum_map: max_len = max(max_len, i - prefix_sum_map[prefix_sum]) else: prefix_sum_map[prefix_sum] = i return max_len"},{"question":"You are implementing a text editor that includes a version history feature. Each time a modification is made to the document, the state should be saved as a new version. Users can also undo changes to revert to a previous version of the document. Implement the `TextEditor` class: - `TextEditor()` Initializes the text editor with an empty document. - `void type(String content)` Appends `content` to the end of the document. - `void undo()` Reverts the document to the previous version. If there are no previous versions, the document remains unchanged. - `String currentVersion()` Returns the current state of the document. If the document is empty, return an empty string.","solution":"class TextEditor: def __init__(self): self.versions = [\\"\\"] # Initial state with empty document self.current_index = 0 def type(self, content): current_version = self.versions[self.current_index] + content self.versions = self.versions[:self.current_index + 1] # Discard future versions self.versions.append(current_version) self.current_index += 1 def undo(self): if self.current_index > 0: self.current_index -= 1 def currentVersion(self): return self.versions[self.current_index]"},{"question":"A **hiker** is making a journey across a mountainous terrain represented by a **0-indexed** integer array `terrain` where each element represents the height of the terrain at that point. The hiker starts at the first index and aims to reach the last index by moving to adjacent points (either left or right). There\'s a limit to how much height difference the hiker can climb in a single step, defined by the integer `step_limit`. Given the `terrain` array and `step_limit`, determine the **minimum number of steps** required for the hiker to reach the last index from the first index. If it\'s not possible to reach the last index, return -1.","solution":"from collections import deque def min_steps_to_reach_end(terrain, step_limit): n = len(terrain) if n == 1: return 0 queue = deque([(0, 0)]) # (current index, steps taken) visited = {0} while queue: index, steps = queue.popleft() for neighbor in (index - 1, index + 1): if 0 <= neighbor < n and neighbor not in visited: if abs(terrain[neighbor] - terrain[index]) <= step_limit: if neighbor == n - 1: return steps + 1 queue.append((neighbor, steps + 1)) visited.add(neighbor) return -1"},{"question":"Given the `root` of a binary tree, each node contains an integer value. Write a function that returns the sum of all left leaves in the tree. A leaf is a node with no children. A left leaf is a leaf that is the left child of its parent. Construct a recursive approach that traverses the tree efficiently and ensure the function can handle edge cases such as an empty tree or a tree with only one node.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sum_of_left_leaves(root): Returns the sum of all left leaves in the binary tree. if not root: return 0 def dfs(node, is_left): if not node: return 0 if not node.left and not node.right: return node.val if is_left else 0 return dfs(node.left, True) + dfs(node.right, False) return dfs(root, False)"},{"question":"You are given an array of integers `arr` and an integer `d`. Starting from any index in the array, you can jump to another index at most `d` distance away. However, you can only jump to a new index if the value at the new index is **strictly greater** than the value at the current index. Return _the maximum number of indices you can visit_ beginning from any index in the array.","solution":"def max_jumps(arr, d): n = len(arr) dp = [0] * n def dfs(i): if dp[i] != 0: return dp[i] maximum = 1 for direction in (-1, 1): for j in range(1, d + 1): ni = i + direction * j if ni < 0 or ni >= n or arr[ni] >= arr[i]: break maximum = max(maximum, 1 + dfs(ni)) dp[i] = maximum return maximum return max(dfs(i) for i in range(n))"},{"question":"You are given a string `s` representing an encoded string where repetitions of substrings are denoted by a positive integer followed by that substring, enclosed in square brackets. For example, the string \\"3[a]2[bc]\\" would be encoded as \\"aaabcbc\\". Write a function that decodes the string and returns the expanded form. The input string is always valid and follows the format mentioned. Note that nested repetitions can occur, such as \\"3[a2[c]]\\", which should be decoded as \\"accaccacc\\". Implement the function `String decodeString(String s)` to return the expanded form of the input string.","solution":"def decodeString(s): Decodes the input string which contains encoded characters with repetitions indicated by integers followed by substrings in brackets. stack, current_num, current_str = [], 0, \'\' for char in s: if char.isdigit(): current_num = current_num * 10 + int(char) elif char == \'[\': stack.append((current_str, current_num)) current_str, current_num = \'\', 0 elif char == \']\': last_str, num = stack.pop() current_str = last_str + current_str * num else: current_str += char return current_str"},{"question":"Given an integer array `heights`, where `heights[i]` represents the height of the `i-th` building in a row, return the amount of **trapped water** that accumulates between the buildings when it rains. The amount of trapped water is calculated by summing up the water above each building, considering that water is only trapped between taller buildings and the current one. The challenge is to compute the trapped water in `O(n)` time complexity, where you ensure every unit of space between these buildings is filled entirely by the rainwater.","solution":"def trap_water(heights): Calculate the total amount of trapped water between the buildings. Args: heights (List[int]): list of heights of the buildings Returns: int: total amount of trapped water if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n trapped_water = 0 left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) for i in range(n): trapped_water += min(left_max[i], right_max[i]) - heights[i] return trapped_water"},{"question":"Given an array of integers `arr`, you can perform the following operation on the array any number of times: choose any subarray and reverse it. Determine if it is possible to sort `arr` in non-decreasing order using the given operation. Return `true` if it is possible, otherwise return `false`.","solution":"def can_sort_by_reversing_subarray(arr): Determine if it is possible to sort the array in non-decreasing order by reversing any subarray any number of times. return arr == sorted(arr)"},{"question":"Given a string `s` consisting only of characters \'a\', \'b\', and \'c\', you need to remove the minimum number of characters from the string such that each character appears in the resultant string the same number of times. Return the length of the resultant string after deletions. For example, if the input string is `aaabbbccc`, the output should be `9` because all characters already appear equally. If the input string is `aaabbcc`, the output should be `6` because you need to remove one \'a\'.","solution":"from collections import Counter def min_deletions_to_equalize(s): Returns the length of the resultant string after performing the minimal deletions so that each character (\'a\', \'b\', \'c\') appears the same number of times. counter = Counter(s) # Find the minimum frequency among \'a\', \'b\', \'c\' min_freq = min(counter.get(\'a\', 0), counter.get(\'b\', 0), counter.get(\'c\', 0)) # Calculate the length of the resultant string result_length = 3 * min_freq return result_length"},{"question":"Given a string `s` consisting of lowercase English letters, you need to find the length of the longest substring without repeating characters and return that length.","solution":"def length_of_longest_substring(s): Returns the length of the longest substring without repeating characters. char_index_map = {} longest_substring_length = 0 start_index = 0 for current_index, char in enumerate(s): if char in char_index_map and char_index_map[char] >= start_index: start_index = char_index_map[char] + 1 char_index_map[char] = current_index longest_substring_length = max(longest_substring_length, current_index - start_index + 1) return longest_substring_length"},{"question":"You are given a binary tree with `n` nodes, where each node has a unique value from `1` to `n`. You need to implement a system that supports adding new nodes to the binary tree and querying paths within the tree. The tree initially contains only the root node with value `1`. Implement the `BinaryTree` class with the following methods: * `void addNode(int parent, int child, string direction)`: Adds a new node with value `child` as a left or right child of the node with value `parent`. The direction is specified by the string `direction`, which can be either `\\"left\\"` or `\\"right\\"`. It is guaranteed that `parent` already exists and `child` does not exist in the tree. * `List<int> getPath(int node)`: Returns a list of node values representing the path from the root to the node with value `node`. If the node does not exist, return an empty list.","solution":"class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None class BinaryTree: def __init__(self): # Initialize the tree with the root node having value 1 self.root = TreeNode(1) self.nodes = {1: self.root} def addNode(self, parent, child, direction): Adds a new node with value `child` as a left or right child of the node with value `parent`. The direction is specified by the string `direction`, which can be either \\"left\\" or \\"right\\". It is guaranteed that parent already exists and child does not exist in the tree. if parent in self.nodes: parent_node = self.nodes[parent] new_node = TreeNode(child) if direction == \\"left\\": parent_node.left = new_node elif direction == \\"right\\": parent_node.right = new_node self.nodes[child] = new_node def getPath(self, node): Returns a list of node values representing the path from the root to the node with value `node`. If the node does not exist, return an empty list. def dfs(current, target, path): if not current: return False path.append(current.value) if current.value == target: return True # Recurse on left and right if dfs(current.left, target, path) or dfs(current.right, target, path): return True path.pop() return False path = [] if dfs(self.root, node, path): return path return []"},{"question":"Given an array of integers `arr` and an integer `m`, determine if you can partition the array into `m` subarrays (continuous subarrays) such that the maximum sum of any subarray is minimized. Return this minimized maximum sum. For example, if `arr = [7, 2, 5, 10, 8]` and `m = 2`, you can partition the array into `[7, 2, 5]` and `[10, 8]` with the maximum sum of any subarray being `18`. This is the minimized maximum sum you can achieve by partitioning the array into 2 subarrays.","solution":"def can_partition(arr, m, max_sum): count, current_sum = 1, 0 for num in arr: if current_sum + num > max_sum: count += 1 current_sum = num if count > m: return False else: current_sum += num return True def minimize_max_sum(arr, m): left, right = max(arr), sum(arr) while left < right: mid = (left + right) // 2 if can_partition(arr, m, mid): right = mid else: left = mid + 1 return left"},{"question":"You are given an array of integers `arr`, which represents the number of books on different shelves arranged in a row. You can perform a \\"booking\\" operation that consists of selecting a continuous subarray of shelves and moving all books from these shelves to the first shelf in the subarray. Your task is to determine the minimum number of booking operations required to move all books to the first shelf of the array. For example, if `arr = [0, 3, 0, 2, 1]`, the initial state is: ``` Shelf 0: 0 books Shelf 1: 3 books Shelf 2: 0 books Shelf 3: 2 books Shelf 4: 1 book ``` After a sequence of booking operations, the final state should have all books on Shelf 0, i.e.,, ``` Shelf 0: 6 books Shelf 1: 0 books Shelf 2: 0 books Shelf 3: 0 books Shelf 4: 0 books ``` Return an integer representing the minimum number of booking operations required to achieve this goal.","solution":"def min_bookings(arr): Returns the minimum number of booking operations required to move all books to the first shelf. # We won\'t need to move books from already empty shelves # Calculate the number of non-zero shelves excluding the first one, # because we need to move books from each of these individual shelves to the first one. num_bookings = len([x for x in arr[1:] if x > 0]) return num_bookings"},{"question":"Write a function that takes an integer `n` and generates a list of length `n` containing the first `n` Fibonacci numbers. If `n` is less than 1, return an empty list. The Fibonacci sequence is defined as `F(0) = 0`, `F(1) = 1`, and `F(n) = F(n-1) + F(n-2)` for `n >= 2`.","solution":"def generate_fibonacci(n): Generates a list of the first n Fibonacci numbers. If n is less than 1, returns an empty list. if n < 1: return [] fibonacci_list = [0] if n > 1: fibonacci_list.append(1) for i in range(2, n): fibonacci_list.append(fibonacci_list[-1] + fibonacci_list[-2]) return fibonacci_list"},{"question":"Given an integer array `arr` of non-negative integers, you are tasked to form the largest possible integer by concatenating the array elements. Return _the largest integer you can form as a string._ Note that the result may be very large, so you should avoid any integer overflow and return the output as a string.","solution":"from functools import cmp_to_key def compare(x, y): if x + y > y + x: return -1 elif x + y < y + x: return 1 else: return 0 def largest_number(arr): Returns the largest possible integer (as a string) that can be formed by concatenating elements of the array. arr = map(str, arr) # Convert all elements to string sorted_arr = sorted(arr, key=cmp_to_key(compare)) largest_num = \'\'.join(sorted_arr) # To deal with case where only zeros are in the list if largest_num[0] == \'0\': return \'0\' return largest_num"},{"question":"You are given an array of integers `arr` and an integer `k`. Your task is to find the length of the shortest subarray that, when sorted, results in the entire array being sorted in non-decreasing order. If the array is already sorted, return 0. Note that the input array can contain duplicates.","solution":"def shortest_unsorted_subarray_length(arr, k): Finds the length of the shortest subarray that, when sorted, results in the entire array being sorted in non-decreasing order. If the array is already sorted, return 0. Parameters: arr (list): List of integers. k (int): Integer k (not utilized in this function but part of the function signature as per the question). Returns: int: Length of the shortest subarray to be sorted. n = len(arr) if n == 0: return 0 left, right = 0, n - 1 # Find the first element which is out of order from the beginning while left < n - 1 and arr[left] <= arr[left + 1]: left += 1 # If the array is already sorted if left == n - 1: return 0 # Find the first element which is out of order from the end while right > 0 and arr[right] >= arr[right - 1]: right -= 1 # Determine the min and max of the subarray that needs to be sorted subarray_max = max(arr[left:right+1]) subarray_min = min(arr[left:right+1]) # Extend the left boundary to include any numbers which are more than the min of the subarray while left > 0 and arr[left - 1] > subarray_min: left -= 1 # Extend the right boundary to include any numbers which are lower than the max of the subarray while right < n - 1 and arr[right + 1] < subarray_max: right += 1 return right - left + 1"},{"question":"You are given an integer `n`. Your task is to generate all possible binary representations of length `n` that do not contain consecutive `1`s. Return all such binary representations in an array, sorted in lexicographical order.","solution":"def generate_binary_representations(n): def helper(n, prev): if n == 0: return [\'\'] if prev: # can only append \'0\' as the previous character is \'1\' suffixes = helper(n - 1, False) return [\'0\' + suffix for suffix in suffixes] else: # can append both \'0\' and \'1\' suffixes_zero = helper(n - 1, False) suffixes_one = helper(n - 1, True) return [\'0\' + suffix for suffix in suffixes_zero] + [\'1\' + suffix for suffix in suffixes_one] result = helper(n, False) return sorted(result)"},{"question":"You are given an array of `n` integers, `arr`, and an integer `k`. Define a subarray of `arr` as any contiguous segment of `arr`. The **uniqueness score** of a subarray is defined as the number of distinct integers in the subarray. Return _the count of subarrays with a uniqueness score of exactly `k`_.","solution":"def count_subarrays_with_unique_k(arr, k): Returns the count of subarrays with exactly k distinct integers. from collections import defaultdict def at_most_k_distinct(nums, k): count = 0 left = 0 freq = defaultdict(int) for right in range(len(nums)): freq[nums[right]] += 1 while len(freq) > k: freq[nums[left]] -= 1 if freq[nums[left]] == 0: del freq[nums[left]] left += 1 count += right - left + 1 return count return at_most_k_distinct(arr, k) - at_most_k_distinct(arr, k - 1)"},{"question":"You are given an integer array `nums` and an integer `target`. Your task is to determine if there are two distinct indices `i` and `j` in the array such that `nums[i] + nums[j] == target`. If so, return **true**. Otherwise, return **false**. The function should be optimized for efficiency. **Note** that the function should return as soon as such a pair is found.","solution":"def has_pair_with_sum(nums, target): Determines if there exists two distinct indices i and j in the array such that nums[i] + nums[j] == target. :param nums: List of integers :param target: Integer target sum :return: True if such a pair exists, False otherwise seen = set() for num in nums: complement = target - num if complement in seen: return True seen.add(num) return False"},{"question":"You are given a 2D grid of size `rows x cols` representing a chessboard. Each cell in the grid can be empty (`0`) or contain a queen (`1`). The cell at `(0, 0)` initially contains a queen, and the initial position of the queen cannot be moved. A queen can move any number of steps in a straight line vertically, horizontally, or diagonally. Write a function to determine whether any queen on the board can attack another queen. Return a boolean value indicating whether there is any such attacking pair of queens.","solution":"def can_attack_each_other(board): Determines if any queen on the board can attack another queen. :param board: 2D list representing the chessboard, where 0 is empty and 1 is queen. :return: boolean indicating if any queens can attack each other. rows = len(board) cols = len(board[0]) # Track if any queen is found in rows, columns, and diagonals row_check = [False] * rows col_check = [False] * cols pos_diag_check = [False] * (rows + cols - 1) neg_diag_check = [False] * (rows + cols - 1) for r in range(rows): for c in range(cols): if board[r][c] == 1: if row_check[r] or col_check[c] or pos_diag_check[r + c] or neg_diag_check[r - c + cols - 1]: return True row_check[r] = True col_check[c] = True pos_diag_check[r + c] = True neg_diag_check[r - c + cols - 1] = True return False"},{"question":"You are given a list of `tasks` where `tasks[i] = [task_id, task_priority]` representing the ID and the priority of task `i`. Tasks with a smaller `task_priority` value have higher priority. You are required to process these tasks in the order of their priority. Implement a class `TaskScheduler` that schedules the tasks based on their priorities: * `TaskScheduler(int[][] tasks)` - Initializes the scheduler with a list of tasks. * `int getNextTask()` - Retrieves and returns the ID of the highest-priority task that hasn\'t been processed yet. If all tasks are processed, return `-1`. * `void markAsCompleted(int task_id)` - Marks the task with the given `task_id` as completed. If the task with the given `task_id` does not exist or is already completed, do nothing.","solution":"import heapq class TaskScheduler: def __init__(self, tasks): Initializes the TaskScheduler with a list of tasks. Each task is a pair [task_id, task_priority]. # Creating a min-heap based on task priority self.task_heap = [(task_priority, task_id) for task_id, task_priority in tasks] heapq.heapify(self.task_heap) self.completed_tasks = set() def getNextTask(self): Retrieves and returns the ID of the highest-priority task that hasn\'t been processed yet. If all tasks are processed, return -1. while self.task_heap: priority, task_id = heapq.heappop(self.task_heap) if task_id not in self.completed_tasks: return task_id return -1 def markAsCompleted(self, task_id): Marks the task with the given task_id as completed. If the task with the given task_id does not exist or is already completed, do nothing. self.completed_tasks.add(task_id)"},{"question":"Given a list of unique words, `words`, find all pairs of distinct indices `(i, j)` in the given list, so that the concatenation of the two words `words[i] + words[j]` is a palindrome. A palindrome is a string that reads the same backward as forward. For example, given `words = [\\"code\\", \\"edoc\\", \\"da\\", \\"d\\"]`, your output should be `[(0, 1), (1, 0), (2, 3)]` because: - `words[0] + words[1]` = \\"code\\" + \\"edoc\\" = \\"codeedoc\\" which is a palindrome. - `words[1] + words[0]` = \\"edoc\\" + \\"code\\" = \\"edoccode\\" which is a palindrome. - `words[2] + words[3]` = \\"da\\" + \\"d\\" = \\"dad\\" which is a palindrome. Implement the function `findPalindromePairs(words)` that returns a list of tuples representing the palindrome pairs.","solution":"def find_palindrome_pairs(words): Returns a list of pairs of indices (i, j) such that words[i] + words[j] is a palindrome. def is_palindrome(s): return s == s[::-1] result = [] for i in range(len(words)): for j in range(len(words)): if i != j: if is_palindrome(words[i] + words[j]): result.append((i, j)) return result"},{"question":"Given a **0-indexed** integer array `nums` and an integer `target`, determine if there are **three** distinct elements in the array that add up to the `target`. Return `true` _if such a combination exists, and_ `false` _otherwise._","solution":"def three_sum(nums, target): Determines if there are three distinct elements in the array that add up to the target. Parameters: nums (list of int): The integer array. target (int): The target sum. Returns: bool: True if such a combination exists, False otherwise. nums.sort() # Sort the list to facilitate two-pointer approach n = len(nums) for i in range(n - 2): left, right = i + 1, n - 1 while left < right: current_sum = nums[i] + nums[left] + nums[right] if current_sum == target: return True elif current_sum < target: left += 1 else: right -= 1 return False"},{"question":"You are given a string `s` representing a sequence of lowercase English letters. You need to determine the length of the longest substring without repeating characters. Return the length of this longest substring. Example: - Input: s = \\"abcabcbb\\" - Output: 3 - Explanation: The answer is \\"abc\\", with the length of 3. Solve this problem by utilizing efficient algorithms to ensure optimal performance for large input sizes.","solution":"def length_of_longest_substring(s): Given a string s, find the length of the longest substring without repeating characters. char_index = {} longest = 0 start = 0 for end, char in enumerate(s): if char in char_index and char_index[char] >= start: start = char_index[char] + 1 char_index[char] = end longest = max(longest, end - start + 1) return longest"},{"question":"You are given an integer array of unique positive integers `nums` representing `n` nodes labeled from `1` to `n`. You need to construct a binary search tree (BST) from these integers. Then, perform an in-order traversal of the BST. Return the in-order traversal of the binary search tree as an array. The in-order traversal of a BST should return the node values in ascending order.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def insert_into_bst(root, val): if not root: return TreeNode(val) if val < root.val: root.left = insert_into_bst(root.left, val) else: root.right = insert_into_bst(root.right, val) return root def bst_from_list(nums): if not nums: return None root = None for num in nums: root = insert_into_bst(root, num) return root def inorder_traversal(root): return inorder_helper(root, []) def inorder_helper(node, traversal): if node: inorder_helper(node.left, traversal) traversal.append(node.val) inorder_helper(node.right, traversal) return traversal def bst_inorder_traversal(nums): root = bst_from_list(nums) return inorder_traversal(root)"},{"question":"You are given a list of strings `words` where each string consists of lowercase letters and represents a word. Two words are considered to be similar if they have the same character frequencies for each character. Your task is to group these words into sets of similar words. Return a list of lists, where each sublist contains words that are similar to each other. For example, if `words` is `[\\"tac\\", \\"cat\\", \\"bat\\", \\"tab\\", \\"rat\\"]`, the output should be `[[\'tac\', \'cat\'], [\'bat\', \'tab\'], [\'rat\']]`.","solution":"from collections import defaultdict def group_similar_words(words): Group words into sets of similar words based on character frequencies. Parameters: words (List[str]): A list of words consisting of lowercase letters. Returns: List[List[str]]: A list of lists where each sublist contains words that are similar to each other. groups = defaultdict(list) for word in words: # Create a frequency tuple so that we can use it as a hashable key in the dictionary. freq_tuple = tuple(sorted(word)) groups[freq_tuple].append(word) return list(groups.values())"},{"question":"Given an integer array `arr` where each element represents the cost of painting a house, and an integer `h` representing the maximum number of houses that can be painted, return the minimum total cost to paint exactly `h` houses such that no two adjacent houses are painted. If it is not possible to paint `h` houses with the given conditions, return `-1`.","solution":"def min_cost_to_paint_houses(arr, h): Returns the minimum total cost to paint exactly h houses such that no two adjacent houses are painted. If it is not possible to paint h houses with the given conditions, returns -1. n = len(arr) # If the number of houses to be painted is more than available or impossible to paint without painting two consecutive if h > (n + 1) // 2: return -1 # Initialize DP table dp = [[float(\'inf\')] * (h+1) for _ in range(n)] # Fill the first row in dp table for i in range(n): dp[i][1] = arr[i] # Fill the rest of the table for j in range(2, h+1): for i in range(j-1, n): for k in range(j-2, i-1): dp[i][j] = min(dp[i][j], dp[k][j-1] + arr[i]) return min(dp[i][h] for i in range(h-1, n))"},{"question":"You are given two strings `s1` and `s2` consisting of lowercase letters. You can swap the character at position `i` in `s1` with the character at position `i` in `s2` any number of times. The goal is to make the two strings as lexicographically similar as possible. In other words, you want the difference between the strings when compared lexicographically to be minimized. Return _the **minimum lexicographical difference** you can achieve after performing any number of swaps_. A string `a` is lexicographically smaller than a string `b` (of the same length) if in the first position where `a` and `b` differ, string `a` has a letter that appears earlier in the alphabet than the corresponding letter in `b`. For example, `\\"abc\\"` is lexicographically smaller than `\\"abd\\"` because the first position they differ is at the third letter, and `\'c\'` comes before `\'d\'`.","solution":"def min_lexicographical_difference(s1, s2): Returns the minimum lexicographical difference achievable by making any number of swaps between characters at corresponding positions in s1 and s2 s1_sorted = sorted(s1) s2_sorted = sorted(s2) return \\"\\".join(s1_sorted), \\"\\".join(s2_sorted)"},{"question":"Given a matrix `mat` of size `m x n` where every row is sorted in non-decreasing order, return **the median** of the matrix. The matrix does not contain duplicate elements. Use an algorithm that has a time complexity better than `O(m * n)`. The returned median must be an integer.","solution":"def median_of_matrix(mat): Returns the median of a matrix where each row is sorted in non-decreasing order. The matrix does not contain duplicate elements. m = len(mat) n = len(mat[0]) # Helper function to count numbers less than or equal to mid in the matrix def count_less_equal(mid): count = 0 for row in mat: # Binary search for each row l, r = 0, n while l < r: mid_idx = (l + r) // 2 if row[mid_idx] <= mid: l = mid_idx + 1 else: r = mid_idx count += l return count k = (m * n + 1) // 2 low, high = mat[0][0], mat[-1][-1] while low < high: mid = (low + high) // 2 if count_less_equal(mid) < k: low = mid + 1 else: high = mid return low"},{"question":"You are given a list of strings `logs`, each representing a log entry in the format `\\"user_id action\\"`, where `user_id` is a unique identifier and `action` is either `\\"enter\\"` or `\\"exit\\"`. Implement a function `findUsers(logs)` that returns a list of user_ids who are currently inside the system. Assume the logs are ordered by the time of action. An \\"enter\\" action signifies a user entering the system, and an \\"exit\\" action signifies a user leaving the system.","solution":"def findUsers(logs): This function takes a list of logs in the format \\"user_id action\\" and returns a list of user_ids who are currently inside the system. Args: logs (list): A list of strings, each representing a log entry in the format \\"user_id action\\". Returns: list: A list of user_ids who are currently inside the system. current_users = set() for log in logs: user_id, action = log.split() if action == \\"enter\\": current_users.add(user_id) elif action == \\"exit\\" and user_id in current_users: current_users.remove(user_id) return list(current_users)"},{"question":"You are designing a networked system and need to ensure that messages can be broadcast from one central server to all other servers in the system. You are given an `n x n` matrix `graph` where `graph[i][j]` is `1` if there is a direct connection between server `i` and server `j`, and `0` otherwise. Return `_true_` if the central server (server `0`) can reach all other servers either directly or indirectly through other servers, and `_false_` otherwise. A direct connection means there is an edge between the two servers. Indirect connection means that there exists a path through one or more other servers.","solution":"def can_broadcast_to_all_servers(graph): Checks if the central server (server 0) can broadcast to all other servers, either directly or indirectly through other servers. Parameters: graph (list of list of int): n x n adjacency matrix representing the graph. Returns: bool: True if the central server can reach all other servers, False otherwise. n = len(graph) visited = [False] * n def dfs(node): Depth First Search to mark all reachable nodes from the given node. visited[node] = True for adjacent in range(n): if graph[node][adjacent] == 1 and not visited[adjacent]: dfs(adjacent) # Start DFS from the central server (server 0) dfs(0) # Check if all servers are visited return all(visited)"},{"question":"You are given two strings `s` and `t` consisting of lowercase English letters. You need to determine if string `t` can be derived from string `s` by deleting some or none of the characters without changing the order of the remaining characters. Return `true` if string `t` can be formed from string `s` in this way, or `false` otherwise.","solution":"def can_form_from(s, t): Determine if string t can be derived from string s by deleting some or none of the characters without changing the order of the remaining characters. :param s: Source string. :param t: Target string. :return: Boolean indicating if t can be formed from s. it = iter(s) return all(char in it for char in t)"},{"question":"You are given a grid of size `m x n`, represented by a 2D integer array `grid` where `grid[i][j]` can be either `0` (empty cell) or `1` (occupied cell). Your task is to find the largest square containing only `1`s and return its area. Note that a square is defined as a contiguous subarray where all the elements are `1`. For example, a `2 x 2` square in the grid would be: ``` 1 1 1 1 ``` If no such square exists, return `0`.","solution":"def maximal_square(grid): Function to find the largest square containing only 1\'s in a 2D grid and return its area. :param grid: List[List[int]] - 2D List representing the grid :return: int - Area of the largest square containing only 1\'s if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) dp = [[0] * n for _ in range(m)] max_side = 0 for i in range(m): for j in range(n): if grid[i][j] == 1: if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side = max(max_side, dp[i][j]) return max_side * max_side"},{"question":"You are given an array of integers `arr` representing the amount of water in `n` glasses positioned in a line. You can perform a series of operations to balance the water levels. In one operation, you can choose any glass and pour water from it into the adjacent (left or right) glass. Each pouring operation transfers exactly one unit of water. You are required to minimize the maximum amount of water in any glass after performing any number of operations. Return _the minimum possible maximum amount of water_ in any glass after the operations.","solution":"def minimize_max_water(arr): Returns the minimum possible maximum amount of water in any glass after performing the operations. total_water = sum(arr) n = len(arr) # The highest the maximum can be is when water is perfectly distributed # i.e., all glasses have ceil(total_water / n) left = total_water // n right = (total_water + n - 1) // n return right"},{"question":"Given a list of `n` integers, sort the list by the frequency of the values. If multiple values have the same frequency, sort them in ascending order. Return the sorted list. For example, given `nums = [1, 1, 2, 2, 2, 3]`, the sorted order by frequency is `[3, 1, 1, 2, 2, 2]` because the value `3` appears once, `1` appears twice, and `2` appears three times.","solution":"from collections import Counter def sort_by_frequency(nums): Sort the list by the frequency of values. If multiple values have the same frequency, they are sorted in ascending order. Args: nums (list): List of integers to be sorted. Returns: list: Sorted list of integers by frequency. freq = Counter(nums) return sorted(nums, key=lambda x: (freq[x], x))"},{"question":"You are given a string `s` consisting of lowercase English letters. Your task is to remove the minimum number of characters from `s` so that no two adjacent characters are the same. Return the result string after the transformations. If there are multiple results, return the lexicographically smallest one.","solution":"def remove_adjacent_duplicates(s): Removes the minimum number of characters from the string so that no two adjacent characters are the same. stack = [] for char in s: if stack and stack[-1] == char: continue stack.append(char) return \'\'.join(stack)"},{"question":"You are given a forest of undirected, unweighted trees represented as an adjacency list in the form of an array of arrays, where each sub-array contains exactly two elements representing an edge between two nodes. Your task is to find the diameter of the largest tree in the forest. The diameter of a tree is the length (number of edges) of the longest path between any two nodes in the tree. Implement the `ForestDiameter` class: * `ForestDiameter(int[][] forest)` - Initializes the object with the forest defined by the list of edges. * `int largestDiameter()` - Returns the diameter of the largest tree in the forest.","solution":"from collections import defaultdict, deque class ForestDiameter: def __init__(self, forest): self.graph = defaultdict(list) for u, v in forest: self.graph[u].append(v) self.graph[v].append(u) def largestDiameter(self): def bfs(start): visited = set() q = deque([(start, 0)]) furthest_node = start max_distance = 0 while q: node, distance = q.popleft() if node not in visited: visited.add(node) if distance > max_distance: max_distance = distance furthest_node = node for neighbor in self.graph[node]: if neighbor not in visited: q.append((neighbor, distance + 1)) return furthest_node, max_distance def tree_diameter(node): furthest_node, _ = bfs(node) _, diameter = bfs(furthest_node) return diameter visited_forest = set() max_diameter = 0 for node in self.graph.keys(): if node not in visited_forest: visited_forest.update(self.graph.keys()) max_diameter = max(max_diameter, tree_diameter(node)) return max_diameter"},{"question":"You are given a **0-indexed** integer array `nums` of size `n`. The elements of `nums` represent the heights of trees in a row. In one operation, you can choose any tree and cut it down to a lower height, but you cannot increase its height. More formally, you can set `nums[i]` to any value `h` such that `0 <= h <= nums[i]`. Your task is to determine the minimum number of operations required so that the absolute difference between the heights of any two adjacent trees is at most one. Return _the minimum number of operations needed_.","solution":"def min_operations(nums): n = len(nums) if n <= 1: return 0 operations = 0 for i in range(1, n): if abs(nums[i] - nums[i-1]) > 1: # calculate the difference needed to meet the condition diff = abs(nums[i] - nums[i-1]) - 1 operations += diff # adjust the height of the current tree (reduce it\'s height) if nums[i] > nums[i-1]: nums[i] -= diff else: nums[i] += diff return operations"},{"question":"You are given a **0-indexed** integer array `nums`. In one operation, you can choose an integer `x` from `nums` and increase or decrease it by `1`. Your goal is to make all the elements in `nums` **equal**. Return the minimum number of operations required to make all elements in `nums` equal.","solution":"def min_operations(nums): Returns the minimum number of operations required to make all elements in nums equal. median = sorted(nums)[len(nums) // 2] operations = sum(abs(num - median) for num in nums) return operations"},{"question":"You are given two strings `s` and `t`, and you can perform the following operation on string `s` any number of times: 1. Select a non-empty substring of `s` and rearrange its characters in any order. Determine whether it is possible to make `s` equal to `t` by using the above operation any number of times. Return `true` if it is possible, `false` otherwise.","solution":"def can_be_equal(s, t): Determines if string s can be transformed to string t by selecting any non-empty substring of s and rearranging its characters any number of times. Args: s (str): The source string. t (str): The target string. Returns: bool: True if s can be transformed to t, False otherwise. return sorted(s) == sorted(t)"},{"question":"You are given an unsorted integer array `nums` of size `n` and an integer `k`. Your task is to determine whether there exist `k` distinct indices `i1, i2, ..., ik` such that the sum of the elements at these indices equals zero. Return `true` if such indices exist and `false` otherwise.","solution":"from itertools import combinations def k_sum_zero(nums, k): Determines if there exist k distinct indices such that the sum of elements at these indices equals zero. # Generate all combinations of indices for length k for comb in combinations(range(len(nums)), k): if sum(nums[i] for i in comb) == 0: return True return False"},{"question":"You are given a list of strings `words` and a string `target`. Your goal is to determine whether you can form the `target` string using exactly the same characters from any one of the strings in `words`. Each character from the chosen word can be used only once. Return `true` if it\'s possible, otherwise return `false`. For example, given `words = [\\"abc\\", \\"def\\", \\"ghi\\"]` and `target = \\"cab\\"`, the function should return `true` because the word \\"abc\\" can be rearranged to form \\"cab\\". If the `target` was \\"dabc\\", the function should return `false` since none of the words in the list can form the `target`.","solution":"def can_form_target(words, target): Determines if the target string can be formed using exactly the same characters from any one of the strings in words. :param words: List of strings. :param target: Target string. :return: Boolean indicating whether target can be formed. from collections import Counter target_counter = Counter(target) for word in words: if Counter(word) == target_counter: return True return False"},{"question":"You are given a string `s` of length `n` containing only the characters `(` and `)`. Your task is to find the minimum number of moves required to make the string valid. A valid string is defined as a string where every opening parenthesis `(` has a corresponding closing parenthesis `)` and they are correctly nested. In one move, you can insert a single parenthesis either `(` or `)` at any position in the string. Return _the minimum number of moves required to make the string valid_.","solution":"def min_moves_to_make_valid(s): Returns the minimum number of moves required to make the string of parentheses valid. open_brackets = 0 required_moves = 0 for char in s: if char == \'(\': open_brackets += 1 elif char == \')\': if open_brackets > 0: open_brackets -= 1 else: required_moves += 1 required_moves += open_brackets return required_moves"},{"question":"You are given a 2D grid of size `m x n` representing a labyrinth, where each cell is either a wall (`\'#\'`) or a free space (`\'.\'`). You are also given two integers `start` and `end`, representing the coordinates of the starting and ending points in the grid. Determine if there exists a path from the starting position to the ending position, moving only up, down, left, or right, and not passing through walls. Return `true` if such a path exists, and `false` otherwise.","solution":"def has_path_bfs(grid, start, end): Determines if there is a path from start to end in the given labyrinth represented by a 2D grid. Args: grid (List[List[str]]): 2D list representing the labyrinth where \'#\' is a wall and \'.\' is free space. start (Tuple[int, int]): Coordinates of the start position (row, col). end (Tuple[int, int]): Coordinates of the end position (row, col). Returns: bool: True if a path exists from start to end, False otherwise. if not grid: return False m, n = len(grid), len(grid[0]) start_x, start_y = start end_x, end_y = end if grid[start_x][start_y] == \'#\' or grid[end_x][end_y] == \'#\': return False from collections import deque queue = deque([(start_x, start_y)]) visited = set() visited.add((start_x, start_y)) directions = [(0, 1), (0, -1), (1, 0), (-1, 0)] while queue: x, y = queue.popleft() if (x, y) == (end_x, end_y): return True for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited and grid[nx][ny] == \'.\': queue.append((nx, ny)) visited.add((nx, ny)) return False"},{"question":"Given a linked list of integers `head`, and an integer `k`, remove the `k`-th node from the end of the list and return its head. Note that `k` is always valid. Make sure your algorithm runs in `O(n)` time and uses constant extra space.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def remove_kth_from_end(head: ListNode, k: int) -> ListNode: Removes the k-th node from the end of the list and returns its head. dummy = ListNode(0) dummy.next = head first = dummy second = dummy for _ in range(k + 1): first = first.next while first is not None: first = first.next second = second.next second.next = second.next.next return dummy.next"},{"question":"Given a list of integers `arr`, where each integer represents the number of times an item has been sold on a specific day, determine the maximum number of consecutive days where the number of sales does not decrease. Implement the function `maxNonDecreasingDays(arr)` that returns the maximum number of consecutive non-decreasing days. For example, given the input `arr = [2, 2, 3, 5, 3, 4, 4, 6]`, the function should return `4` because the longest sequence of consecutive non-decreasing values is `[3, 4, 4, 6]`.","solution":"def maxNonDecreasingDays(arr): if not arr: return 0 max_length = 1 current_length = 1 for i in range(1, len(arr)): if arr[i] >= arr[i - 1]: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length"},{"question":"A new company plans to install a hierarchical network of devices. Each device is represented as a node in a tree, starting with the root device at level 0. The company needs to ensure that every device is connected such that it follows the hierarchical pattern without any cycles. You are given an integer `n` representing the number of devices and a list `edges` where each element `edges[i]` is a tuple `(u, v)` representing a directed edge from device `u` to device `v`. Determine if the given `edges` can form a valid hierarchical tree with `n` devices and no cycles. Return `true` if the `edges` form a valid tree, otherwise return `false`.","solution":"def is_valid_tree(n, edges): Determines if the given edges can form a valid hierarchical tree with n devices and no cycles. Args: n (int): The number of devices. edges (List[Tuple[int, int]]): A list of tuples representing directed edges between devices. Returns: bool: True if the edges form a valid tree, otherwise False. parent = [-1] * n def find(x): if parent[x] == -1: return x return find(parent[x]) def union(x, y): xset = find(x) yset = find(y) if xset != yset: parent[xset] = yset return True return False # For a graph to be a valid tree, it must be connected and have exactly n-1 edges. if len(edges) != n - 1: return False for u, v in edges: if not union(u, v): return False return True"},{"question":"You are given an array of `n` integers, each representing the height of a building on a street. The buildings are arranged from left to right. You are also provided two integers `start` and `end`, where `start` is the index of the starting building and `end` is the index of the ending building. You need to determine if there exists a path from the building at index `start` to the building at index `end` such that the height of the buildings along the path is strictly increasing. You can only move from a building to the next one on the right. Return `true` if such a path exists, and `false` otherwise.","solution":"def can_reach_increasing_path(buildings, start, end): Determines if there exists a path from the building at index `start` to the building at index `end` such that the height of the buildings along the path is strictly increasing. Args: buildings (List[int]): a list of integers representing the height of buildings. start (int): starting index. end (int): ending index. Returns: bool: True if such a path exists, False otherwise. # If start equals end, we already have a valid path. if start == end: return True # Traverse the array from start to end for i in range(start, end): if buildings[i] >= buildings[i+1]: return False return True"},{"question":"Given a 2D grid of size `m x n` where each cell represents a cost to traverse through that cell, determine the minimum cost to get from the top-left corner to the bottom-right corner of the grid. You can only move right or down at each step. * For example, given the following grid: ``` [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] ``` The minimum cost path would be `1 -> 3 -> 1 -> 1 -> 1 -> 2 -> 1` with a total cost of `10`.","solution":"def min_path_cost(grid): Returns the minimum cost to get from the top-left corner to the bottom-right corner of the grid. Only right or down moves are allowed. :param grid: List[List[int]] :return: int if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) dp = [[0] * n for _ in range(m)] dp[0][0] = grid[0][0] # Initialize the first row for j in range(1, n): dp[0][j] = dp[0][j - 1] + grid[0][j] # Initialize the first column for i in range(1, m): dp[i][0] = dp[i - 1][0] + grid[i][0] # Fill the rest of the dp table for i in range(1, m): for j in range(1, n): dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] return dp[-1][-1]"},{"question":"Given a string `s` and a dictionary of strings `wordDict`, return _the **index pairs** of the substrings in_ `s` _that are present in_ `wordDict`. _A **substring** is a contiguous sequence of characters within the string._ Return the answer as an array of pairs `[start, end]` representing the starting and ending indices (inclusive) of the substring in the string `s`. The pairs should be returned in **lexicographical order** based on their starting indices. If two pairs have the same starting index, the pair with the smaller ending index should come first.","solution":"def find_substring_indices(s, wordDict): Returns the index pairs of substrings in `s` that are present in `wordDict`. result = [] for word in wordDict: start = 0 while start < len(s): start = s.find(word, start) if start == -1: break end = start + len(word) - 1 result.append([start, end]) start += 1 result.sort(key=lambda x: (x[0], x[1])) return result"},{"question":"Given an array of positive integers `nums`, find the contiguous subarray (containing at least one number) which has the largest product and return the product. Your solution should have a time complexity of O(n).","solution":"def max_product(nums): Returns the largest product of a contiguous subarray within the given array. if not nums: return 0 current_max = current_min = global_max = nums[0] for num in nums[1:]: if num < 0: current_max, current_min = current_min, current_max current_max = max(num, current_max * num) current_min = min(num, current_min * num) global_max = max(global_max, current_max) return global_max"},{"question":"A software company assigns employee IDs to its employees based on their arrival order. Each employee ID is generated by converting the ordinal number (1st, 2nd, 3rd, etc.) of their arrival order into a string format that represents the sequence number in a binary encoding system. For instance, 1 (first arrival) would be \\"1\\", 2 (second arrival) would be \\"10\\", 3 (third arrival) would be \\"11\\", and so on. Given a list of arrival times for multiple employees, write a function that returns a list of employee IDs corresponding to their arrival times. The input list `arrivals` will contain unique integer values representing the arrival times in any arbitrary order. Ensure the returned list of IDs follows the order of the arrival times provided in the input. Output the list of employee IDs in string format.","solution":"def assign_employee_ids(arrivals): Assigns employee IDs to employees based on their arrival order in a binary format. Parameters: arrivals (list): List of integers representing arrival times. Returns: list: List of employee IDs in binary format corresponding to the order of arrivals. sorted_arrivals = sorted(arrivals) ids = {} for i, arrival in enumerate(sorted_arrivals): ids[arrival] = bin(i + 1)[2:] return [ids[arrival] for arrival in arrivals]"},{"question":"You are given a circular array `nums` of positive and negative integers. Calculate the total maximum sum of any contiguous subarray of `nums` under the constraint that elements can be removed from the start and end to form the subarray. In other words, the subarray can wrap around the circular array. Return the maximum possible sum of such subarray.","solution":"def max_subarray_sum_circular(nums): Calculate the total maximum sum of any contiguous subarray of a circular array. Args: nums (list): List of integers representing the circular array. Returns: int: Maximum possible sum of a contiguous subarray. def kadane_max(array): max_end_here = max_so_far = array[0] for x in array[1:]: max_end_here = max(x, max_end_here + x) max_so_far = max(max_so_far, max_end_here) return max_so_far def kadane_min(array): min_end_here = min_so_far = array[0] for x in array[1:]: min_end_here = min(x, min_end_here + x) min_so_far = min(min_so_far, min_end_here) return min_so_far total_sum = sum(nums) max_kadane = kadane_max(nums) min_kadane = kadane_min(nums) if max_kadane < 0: return max_kadane return max(max_kadane, total_sum - min_kadane)"},{"question":"You are given a string `s` consisting of lowercase English letters and an integer array `indices` of the same length. The string `s` has to be reconstructed by placing each character from `s` at the index specified in the array `indices`. Return _the reconstructed string_.","solution":"def restore_string(s, indices): Restores and returns the original string by placing each character at the given index specified in the indices array. :param s: str, the input string of lowercase English letters. :param indices: List[int], the array of indices. :return: str, the rearranged string. restored = [\'\'] * len(s) for i, index in enumerate(indices): restored[index] = s[i] return \'\'.join(restored)"},{"question":"You are given a square grid of characters `grid` of size `n x n`, where each cell contains a lowercase English letter. You need to find and return the largest square sub-grid that is composed of the same character. The side length of the largest such square sub-grid is the desired output. Implement the following method: * `int largestSquareSubGrid(char[][] grid)` that takes in a 2D array of characters representing the grid and returns an integer representing the side length of the largest square sub-grid consisting of the same character. The grid is represented as `grid[i][j]`, where `i` is the row index and `j` is the column index. Example Input: ``` grid = [ [\'a\', \'b\', \'a\', \'a\'], [\'a\', \'a\', \'a\', \'a\'], [\'b\', \'a\', \'a\', \'a\'], [\'b\', \'b\', \'a\', \'a\'] ] ``` Example Output: ``` 2 ``` Explanation: The largest square sub-grid consisting of the same character has a side length of 2 and can be found at several positions in the grid, such as the bottom-right corner where the sub-grid is ``` [ [\'a\', \'a\'], [\'a\', \'a\'] ] ```","solution":"def largestSquareSubGrid(grid): if not grid: return 0 n = len(grid) dp = [[0] * n for _ in range(n)] max_side_length = 0 for i in range(n): for j in range(n): if i == 0 or j == 0: dp[i][j] = 1 elif grid[i][j] == grid[i-1][j] == grid[i][j-1] == grid[i-1][j-1]: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 else: dp[i][j] = 1 max_side_length = max(max_side_length, dp[i][j]) return max_side_length"},{"question":"Design a class that simulates a stack using only two queues. Implement the `MyStack` class with the following methods: * `void push(int x)`: Pushes element x to the top of the stack. * `int pop()`: Removes the element on the top of the stack and returns it. * `int top()`: Returns the element on the top of the stack. * `boolean empty()`: Returns true if the stack is empty, false otherwise. **Notes:** * You must use only standard queue operations - enqueue (`add`), dequeue (`remove`), size, and is empty (`isEmpty`). * Stack operations should be efficient, aiming for amortized O(1) time complexity where feasible.","solution":"from collections import deque class MyStack: def __init__(self): self.queue1 = deque() self.queue2 = deque() def push(self, x: int) -> None: self.queue1.append(x) def pop(self) -> int: while len(self.queue1) > 1: self.queue2.append(self.queue1.popleft()) popped_element = self.queue1.popleft() self.queue1, self.queue2 = self.queue2, self.queue1 return popped_element def top(self) -> int: while len(self.queue1) > 1: self.queue2.append(self.queue1.popleft()) top_element = self.queue1[0] self.queue2.append(self.queue1.popleft()) self.queue1, self.queue2 = self.queue2, self.queue1 return top_element def empty(self) -> bool: return not self.queue1"},{"question":"You are given a list of integers `arr` which represents the heights of a series of buildings. You are also given an integer `step` which represents the maximum height you can move from one building to another. You need to determine if it is possible to move from the first building to the last building by moving either to the next building or skipping up to `step` buildings, but only if the height difference between the two buildings is no more than `step`. Return a boolean `True` if you can reach the last building, otherwise return `False`.","solution":"def can_reach_end(arr, step): Determines if you can move from the first building to the last building given that you can only move to the next building or skip up to `step` buildings, and only if the height difference between buildings is no more than `step`. :param arr: List of integers representing the building heights. :param step: Integer representing the maximum height difference and skip count. :return: Boolean value indicating whether reaching the last building is possible. n = len(arr) visited = [False] * n visited[0] = True stack = [0] while stack: current = stack.pop() if current == n - 1: return True for next_building in range(current + 1, min(current + step + 1, n)): if not visited[next_building] and abs(arr[next_building] - arr[current]) <= step: visited[next_building] = True stack.append(next_building) return False"},{"question":"You are given an array `tasks` where `tasks[i]` represents the time in minutes required to complete the `i-th` task. Each task can only be done by one person, but there are two people available to work on these tasks. You need to assign each task to a person such that the maximum completion time for both people is minimized. More formally, you should partition the `tasks` array into two non-empty subsets, where the sum of the times in one subset is assigned to person A, and the sum of the times in the other subset is assigned to person B. Return the minimized maximum time required by any person to complete their assigned tasks.","solution":"def min_completion_time(tasks): Returns the minimized maximum completion time for distributing tasks between two people. tasks.sort(reverse=True) time_A, time_B = 0, 0 for task in tasks: if time_A <= time_B: time_A += task else: time_B += task return max(time_A, time_B)"},{"question":"Given an `n x n` 2D matrix `grid` of integers where each cell has a value of 0 or 1, determine the size (i.e., the number of cells) of the largest **plus sign** of `1`s in the grid. A **plus sign** is defined by choosing a cell `(r, c)` as the center and extending in all four cardinal directions; left, right, up, and down, with each direction consisting of contiguous cells with the value `1`. The size of the plus sign can be referred to as its order which is determined by the minimum number of 1s in all four directions extending from a central 1. If no plus sign exists, return 0.","solution":"def order_of_largest_plus_sign(n, grid): if n == 0: return 0 left = [[0] * n for _ in range(n)] right = [[0] * n for _ in range(n)] up = [[0] * n for _ in range(n)] down = [[0] * n for _ in range(n)] for r in range(n): for c in range(n): if grid[r][c] == 1: left[r][c] = (left[r][c-1] if c > 0 else 0) + 1 up[r][c] = (up[r-1][c] if r > 0 else 0) + 1 for r in range(n-1, -1, -1): for c in range(n-1, -1, -1): if grid[r][c] == 1: right[r][c] = (right[r][c+1] if c < n-1 else 0) + 1 down[r][c] = (down[r+1][c] if r < n-1 else 0) + 1 max_order = 0 for r in range(n): for c in range(n): if grid[r][c] == 1: order = min(left[r][c], right[r][c], up[r][c], down[r][c]) max_order = max(max_order, order) return max_order"},{"question":"You are working on a scheduling system that needs to keep track of appointments. Implement the `Scheduler` class: - `bool book(int start, int end)` which schedules a new appointment from `start` to `end` (exclusive), and returns `true` if the appointment was successfully booked. Returns `false` if the new appointment conflicts with any existing ones (i.e., there is any overlap). Note that an appointment `[start1, end1)` conflicts with another appointment `[start2, end2)` if `start1 < end2` and `start2 < end1`.","solution":"class Scheduler: def __init__(self): self.appointments = [] def book(self, start, end): Try to schedule a new appointment from start to end (exclusive). :param start: int, start time of the appointment :param end: int, end time of the appointment :return: bool, True if the appointment was successfully booked, False otherwise for s, e in self.appointments: if start < e and s < end: return False self.appointments.append((start, end)) return True"},{"question":"Given a directed graph with `n` nodes and `m` edges, each edge is represented as a triplet `(u, v, w)`, where `u` is the starting node, `v` is the ending node, and `w` is the weight of the edge. Return the shortest path from node `0` to node `n-1`. If there is no path, return `-1`.","solution":"import heapq def shortest_path(n, edges): Returns the shortest path from node 0 to node n-1 in a directed graph with n nodes. If there is no path from node 0 to node n-1, return -1. # Build the graph graph = [[] for _ in range(n)] for u, v, w in edges: graph[u].append((v, w)) # Dijkstra\'s algorithm pq = [(0, 0)] # (distance, node) distances = {i: float(\'inf\') for i in range(n)} distances[0] = 0 while pq: current_distance, u = heapq.heappop(pq) if u == n-1: return current_distance if current_distance > distances[u]: continue for v, weight in graph[u]: distance = current_distance + weight if distance < distances[v]: distances[v] = distance heapq.heappush(pq, (distance, v)) return -1 if distances[n-1] == float(\'inf\') else distances[n-1]"},{"question":"You are given a non-negative integer `num` along with an array of integers `digits`, which contains unique digits from 0 to 9. Your task is to determine the smallest number greater than `num` that can be formed using the digits in the `digits` array. If no such number exists, return `-1`.","solution":"from itertools import permutations def next_greater_number(num, digits): Returns the smallest number greater than `num` that can be formed using the digits in the `digits` array. If no such number exists, returns `-1`. digits = sorted(digits) num_str = str(num) # Generate all permutations of the digits for length in range(len(num_str), len(digits) + 1): for perm in permutations(digits, length): perm_number = int(\'\'.join(map(str, perm))) if perm_number > num: return perm_number return -1"},{"question":"Given a binary tree, implement a class `BinaryTree` with methods `insert(int value)` to insert a node with the given value into the tree, and `List<Integer> rightView()` that returns a list of all the nodes you can see from the right side of the tree. The nodes in the returned list should be ordered from top to bottom as they appear from the right side view.","solution":"class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None class BinaryTree: def __init__(self): self.root = None def insert(self, value): new_node = TreeNode(value) if self.root is None: self.root = new_node else: self._insert_recursive(self.root, new_node) def _insert_recursive(self, current, new_node): if new_node.value < current.value: if current.left is None: current.left = new_node else: self._insert_recursive(current.left, new_node) else: if current.right is None: current.right = new_node else: self._insert_recursive(current.right, new_node) def rightView(self): result = [] if not self.root: return result queue = [(self.root, 0)] last_node_at_level = {} while queue: node, level = queue.pop(0) last_node_at_level[level] = node.value if node.left: queue.append((node.left, level + 1)) if node.right: queue.append((node.right, level + 1)) for level in range(len(last_node_at_level)): result.append(last_node_at_level[level]) return result"},{"question":"You are given two integer arrays `arr1` and `arr2` that are both non-decreasing and may have different lengths. Your task is to return a new sorted integer array containing the intersection of the two given arrays. Each element in the result should appear as many times as it shows in both arrays. You must solve the problem with the following constraints: **do not** use any extra space other than the inputs and the output, and the time complexity should be **O(n + m)** where `n` and `m` are the lengths of `arr1` and `arr2`, respectively.","solution":"def intersect_sorted_arrays(arr1, arr2): Returns the intersection of two sorted arrays. Each element in the result should appear as many times as it shows in both arrays. Time complexity: O(n + m) intersection = [] i, j = 0, 0 while i < len(arr1) and j < len(arr2): if arr1[i] == arr2[j]: intersection.append(arr1[i]) i += 1 j += 1 elif arr1[i] < arr2[j]: i += 1 else: j += 1 return intersection"},{"question":"Given an integer array `arr`, your task is to determine if there exists a pair of distinct indices `(i, j)` such that the sum of elements between and including these indices is zero. Specifically, return `true` if there are such indices `i` and `j` (`i <= j`), and `false` otherwise. Note that the array may contain both positive and negative integers. Write a function that takes an integer array `arr` as input and outputs a boolean indicating the existence of such a subarray with sum zero.","solution":"def has_zero_sum_subarray(arr): Returns True if there exists a subarray with sum zero, False otherwise. prefix_sum = 0 prefix_sum_set = set() for num in arr: prefix_sum += num if prefix_sum == 0 or prefix_sum in prefix_sum_set: return True prefix_sum_set.add(prefix_sum) return False"},{"question":"Given two strings `word1` and `word2`, find the length of their longest common subsequence. A subsequence of a string is a new string generated from the original string with some characters(can be none) deleted without changing the relative order of the remaining characters. For example, \\"abc\\", \\"ab\\", and \\"a\\" are subsequences of \\"abc\\". If there is no common subsequence, return 0. You must solve this problem in `O(m * n)` time complexity, where `m` and `n` are the lengths of `word1` and `word2`, respectively.","solution":"def longest_common_subsequence(word1, word2): Returns the length of the longest common subsequence of word1 and word2. m, n = len(word1), len(word2) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): if word1[i - 1] == word2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[m][n]"},{"question":"There is a directed graph with `n` nodes labeled from `0` to `n - 1`. You are given a 2D list `edges` where `edges[i] = [a, b]` indicates there\'s a directed edge from node `a` to node `b`. You are also given a list `restricted` which contains some nodes that are restricted and should not be included in any path. Return _the number of connected components from the starting node `0` considering the restricted nodes_ where two nodes are in the same component if there is a way to reach one from the other without passing through restricted nodes. Note that node `0` will never be in the list of restricted nodes.","solution":"def count_components(n, edges, restricted): from collections import defaultdict, deque # Convert restricted list to set for O(1) lookups restricted_set = set(restricted) # Building the graph using adjacency list graph = defaultdict(list) for a, b in edges: graph[a].append(b) graph[b].append(a) # BFS to find all reachable nodes from node 0 visited = set() queue = deque([0]) visited.add(0) count = 0 while queue: node = queue.popleft() count += 1 for neighbor in graph[node]: if neighbor not in visited and neighbor not in restricted_set: visited.add(neighbor) queue.append(neighbor) return count"},{"question":"You are given a list of integers `nums` representing the number of stones in each pile. In each move, you can merge any two adjacent piles into one, and the cost of merging is the sum of the two piles\' stones. After the merge, the resulting pile is the sum of the two merged piles. Your task is to determine the minimum cost to merge all the piles into one single pile. Return the minimum cost.","solution":"def min_merge_cost(nums): import heapq if not nums: return 0 # Convert the list to a heap heapq.heapify(nums) total_cost = 0 while len(nums) > 1: # Extract the two smallest piles first = heapq.heappop(nums) second = heapq.heappop(nums) # The cost to merge these two piles current_cost = first + second total_cost += current_cost # Push the merged pile back into the heap heapq.heappush(nums, current_cost) return total_cost"},{"question":"You are given two integer arrays `arr1` and `arr2` of equal length. In one operation, you can swap any two elements, one from `arr1` and one from `arr2`, provided the difference between the two elements is no more than a given integer `d`. You can perform this operation any number of times. The goal is to maximize the sum of elements in `arr1` after performing the operations. Return _the maximum sum of_ `arr1` _that can be achieved_.","solution":"def maximize_sum(arr1, arr2, d): Maximizes the sum of elements in arr1 by swapping elements between arr1 and arr2 with the condition that absolute difference between swapped elements is no more than d. # Sorting both arrays arr1.sort() arr2.sort() # Finding if there are any possible beneficial swaps for i in range(len(arr1)): for j in range(len(arr2)): if abs(arr1[i] - arr2[j]) <= d and arr2[j] > arr1[i]: # Swap elements arr1[i], arr2[j] = arr2[j], arr1[i] return sum(arr1)"},{"question":"You are given an array `heights` representing the heights of buildings in a row. The width of each building is the same. A building `i` can receive water from the sky if there exists no taller building to the left and no taller building to the right within the height range of building `i`. The skyline is the maximum height encountered when traversing the array from left to right and the maximum height encountered when traversing from right to left. Return a list of booleans where each boolean represents whether a building can receive water from the sky. The list should be in the same order as the input array `heights`.","solution":"def can_receive_water(heights): Returns a list where each boolean value indicates whether the corresponding building in the heights list can receive water from the sky. n = len(heights) max_left = [0] * n max_right = [0] * n result = [False] * n if n == 0: return result max_left[0] = heights[0] for i in range(1, n): max_left[i] = max(max_left[i - 1], heights[i]) max_right[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): max_right[i] = max(max_right[i + 1], heights[i]) for i in range(n): if heights[i] >= max_left[i] and heights[i] >= max_right[i]: result[i] = True return result"},{"question":"Given an array of meeting time intervals `intervals` where `intervals[i] = [starti, endi]`, find the minimum number of conference rooms required. Each interval represents a meeting with a start time `starti` and an end time `endi`. Return the minimum number of conference rooms required to schedule all the meetings without any overlap.","solution":"import heapq def min_meeting_rooms(intervals): Given a list of meeting intervals where each interval is a list of [start_time, end_time], this function returns the minimum number of conference rooms required. if not intervals: return 0 # First, sort the intervals by their start times intervals.sort(key=lambda x: x[0]) # Initialize a min-heap to keep track of end times of meetings heap = [] # Add the end time of the first meeting heapq.heappush(heap, intervals[0][1]) for i in range(1, len(intervals)): # If the earliest end time is less than the start time of the current meeting, # it means a room has been freed up. if heap[0] <= intervals[i][0]: heapq.heappop(heap) # Push the current meeting\'s end time into the heap heapq.heappush(heap, intervals[i][1]) # The size of the heap will give the minimum number of rooms required return len(heap)"},{"question":"You are given two strings `s` and `t`, where `s` is a subsequence of `t`. You need to delete the minimum number of characters from `t` so that `s` is still a subsequence of `t`, but without changing the order of the characters in `s`. Return _the length of the modified string `t` after the required deletions_. If it is not possible to retain `s` as a subsequence in `t`, return `-1`.","solution":"def min_deletions_to_keep_subsequence(s, t): Returns the length of the modified string t after deleting the minimum number of characters while keeping s as a subsequence of the modified t. If it\'s not possible to retain s as a subsequence of t, returns -1. s_len = len(s) t_len = len(t) s_idx = 0 # Pointer for string s # Traverse the string t for char in t: if s_idx < s_len and char == s[s_idx]: s_idx += 1 if s_idx == s_len: # s is a subsequence of t return t_len - s_len else: # s is not a subsequence of t return -1"},{"question":"Given a collection of `n` distinct integers, return an array of all possible subsets (the power set). The solution set must not contain duplicate subsets. You may return the solution in any order.","solution":"def subsets(nums): Returns all possible subsets (the power set) of a list of distinct integers. result = [] subset = [] def backtrack(start): result.append(subset.copy()) for i in range(start, len(nums)): subset.append(nums[i]) backtrack(i + 1) subset.pop() backtrack(0) return result"},{"question":"Given an integer array representing the daily temperatures, return a list where each element in the list is the number of days you would have to wait until a warmer temperature. If there is no future day for which this is possible, put `0` instead. Example: ``` Input: temperatures = [73, 74, 75, 71, 69, 72, 76, 73] Output: [1, 1, 4, 2, 1, 1, 0, 0] ``` Use a stack to solve this problem efficiently.","solution":"def dailyTemperatures(temperatures): Returns a list of how many days until a warmer temperature for each day in the list of temperatures. If there is no future day for which it is possible, the result is 0. :param temperatures: List[int] - list of daily temperatures :return: List[int] - list of days until a warmer temperature n = len(temperatures) result = [0] * n stack = [] for i in range(n): while stack and temperatures[i] > temperatures[stack[-1]]: prev_index = stack.pop() result[prev_index] = i - prev_index stack.append(i) return result"},{"question":"You are given a 0-indexed integer array `heights` representing the heights of buildings along a street. The buildings are arranged in a line, and `heights[i]` represents the height of the `i-th` building. You can remove a contiguous segment of buildings from the street to form a new subarray. Your task is to return the maximum height difference in the remaining subarray after removing exactly one contiguous segment. In other words, find the maximum difference between the tallest and shortest buildings in the segment that remains after you remove one contiguous segment of buildings from the original array.","solution":"def max_height_diff_after_removal(heights): Returns the maximum height difference in the remaining subarray after removing exactly one contiguous segment of buildings. Parameters: heights (List[int]): List of integers representing the heights of buildings. Returns: int: Maximum height difference in the remaining subarray. n = len(heights) # Edge case: If there\'s only one building, there\'s no segment to remove if n == 1: return 0 # Find the max and min heights in the original array overall_max = max(heights) overall_min = min(heights) # Initialize the results we\'ll use to track the min and max values in the removed portions prefix_max = [0] * n suffix_max = [0] * n prefix_min = [0] * n suffix_min = [0] * n # Build prefix max and min arrays prefix_max[0] = heights[0] prefix_min[0] = heights[0] for i in range(1, n): prefix_max[i] = max(prefix_max[i - 1], heights[i]) prefix_min[i] = min(prefix_min[i - 1], heights[i]) # Build suffix max and min arrays suffix_max[-1] = heights[-1] suffix_min[-1] = heights[-1] for i in range(n - 2, -1, -1): suffix_max[i] = max(suffix_max[i + 1], heights[i]) suffix_min[i] = min(suffix_min[i + 1], heights[i]) # Initialize max difference result max_diff = 0 # Check removing each possible contiguous segment for i in range(n): if i == 0: # If we remove the first segment current_max = suffix_max[i + 1] current_min = suffix_min[i + 1] elif i == n - 1: # If we remove the last segment current_max = prefix_max[i - 1] current_min = prefix_min[i - 1] else: current_max = max(prefix_max[i - 1], suffix_max[i + 1]) current_min = min(prefix_min[i - 1], suffix_min[i + 1]) max_diff = max(max_diff, current_max - current_min) return max_diff"},{"question":"Write a function that takes a string `s` as input and returns the length of the longest substring of `s` that consists of the same character. For example, given the string \\"aaabbccaa\\", the longest substring of the same character is \\"aaa\\", with a length of 3. If there are multiple substrings with the same maximum length, return the length of any one of them.","solution":"def longest_same_char_substring(s): Returns the length of the longest substring of `s` that consists of the same character. if not s: return 0 max_length = 1 current_length = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: current_length += 1 else: if current_length > max_length: max_length = current_length current_length = 1 return max(max_length, current_length)"},{"question":"You are given an integer array `followers` where `followers[i]` represents the number of followers the `ith` user has. You are also given a 2D integer array `queries` where `queries[j] = [x, y, bound]` represents a query for the number of users that have at least `x` followers and at most `y` followers within the given `bound` for the number of queries. The `bound` indicates the range within the `followers` list to be searched for each query. For each query, you need to return the number of users within the specified range who have a number of followers within the specified bounds. You should implement the `UserFollowers` class: - `UserFollowers(int[] followers, int[][] queries)` initializes the object with the `followers` array and `queries` array. - `int[] answerQueries()` processes all the queries and returns an array of results for each query. Each result in the output array corresponds to the number of users that satisfy the conditions of the corresponding query in the input array.","solution":"class UserFollowers: def __init__(self, followers, queries): Initialize the object with followers array and queries array. self.followers = followers self.queries = queries def answerQueries(self): Process all the queries and return an array of results for each query. result = [] for x, y, bound in self.queries: count = 0 for follower in self.followers[:bound]: if x <= follower <= y: count += 1 result.append(count) return result"},{"question":"You are given a rectangular grid of size `m x n` consisting of only the characters `\'.\'` and `\'*\'`. Each `\' * \'` represents an obstacle while each `\'.\'` represents an open space. You start at the top-left corner of the grid and want to reach the bottom-right corner. Write an algorithm to find the number of different paths you can take to reach the bottom-right corner from the top-left corner, moving only right or down, and avoiding obstacles. If there is no path, return 0.","solution":"def unique_paths_with_obstacles(grid): Returns the number of unique paths from top-left to bottom-right in a grid. You can only move right or down and should avoid obstacles (*). if not grid or grid[0][0] == \'*\' or grid[-1][-1] == \'*\': return 0 m, n = len(grid), len(grid[0]) # Initialize a 2D dp array with zeros dp = [[0] * n for _ in range(m)] # Start point dp[0][0] = 1 # Fill the dp array for i in range(m): for j in range(n): if grid[i][j] == \'*\': dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[-1][-1]"},{"question":"You are tasked with implementing an autocomplete system. Given a list of strings `dictionary` that serves as the autocomplete dictionary and a string `input`, return a list of strings from the dictionary that start with the given `input`. The returned list should be sorted in lexicographical order. If no string matches the input, return an empty list. The system should be case-insensitive, meaning the `input` can match strings from the dictionary regardless of case differences.","solution":"def autocomplete(dictionary, input): Returns a list of strings from the dictionary that start with the given input. The comparison is case-insensitive. input_lower = input.lower() result = [word for word in dictionary if word.lower().startswith(input_lower)] return sorted(result)"},{"question":"You are given an undirected graph represented as an adjacency list where nodes are labeled from `1` to `n`, and each node has a varying number of neighbors. You are also given two integers `start` and `end`, representing the starting node and the destination node. Your task is to determine the **minimum number of edges** that must be traversed to go from the `start` node to the `end` node. Return _the minimum number of edges needed to reach the `end` node from `start`_. If there is no possible path, return `-1`.","solution":"from collections import deque def shortest_path_length(graph, start, end): Returns the minimum number of edges required to reach the end node from the start node in an undirected graph. :param graph: A dictionary representing the adjacency list of the graph. :param start: The starting node. :param end: The destination node. :return: The minimum number of edges needed to reach the end node from start node, or -1 if there is no possible path. if start == end: return 0 visited = set() queue = deque([(start, 0)]) while queue: current_node, current_distance = queue.popleft() if current_node not in visited: visited.add(current_node) for neighbor in graph.get(current_node, []): if neighbor == end: return current_distance + 1 queue.append((neighbor, current_distance + 1)) return -1"},{"question":"You are given a linked list where each node contains an integer value. Define a function to sort this linked list in **ascending order** and return the sorted list. The function should be able to handle lists with a large number of nodes efficiently. You are expected to implement a sorting algorithm with a time complexity of `O(n log n)`.","solution":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def merge_sort_list(head): if not head or not head.next: return head def split(head): slow, fast = head, head.next while fast and fast.next: slow = slow.next fast = fast.next.next middle = slow.next slow.next = None return head, middle def merge(l1, l2): dummy = ListNode() current = dummy while l1 and l2: if l1.value < l2.value: current.next = l1 l1 = l1.next else: current.next = l2 l2 = l2.next current = current.next current.next = l1 or l2 return dummy.next def merge_sort(node): if not node or not node.next: return node left, right = split(node) left = merge_sort(left) right = merge_sort(right) return merge(left, right) return merge_sort(head)"},{"question":"Given two integers `n` and `k`, where `n` represents the total number of elements in a set, and `k` represents the size of the subsets to be formed, return all possible combinations of `k` elements out of the set `{1, 2, ..., n}`. Each combination should be returned as a list of integers, and the list of all combinations should be returned as a list of lists. The combinations may be returned in any order.","solution":"from itertools import combinations def combine(n, k): Returns all possible combinations of k elements out of the set {1, 2, ..., n}. :param n: total number of elements in the set :param k: size of the subsets to be formed :return: list of lists containing all possible combinations return [list(c) for c in combinations(range(1, n+1), k)]"},{"question":"Given two matrices `A` and `B` of dimensions `n x m` and `m x p` respectively, perform matrix multiplication and return the resulting matrix. The elements of the matrices are integers. Ensure that your implementation handles the matrix multiplication rules accurately and efficiently.","solution":"def matrix_multiply(A, B): Multiplies two matrices A and B. A should be of dimensions n x m. B should be of dimensions m x p. Returns the resulting matrix of dimensions n x p. n = len(A) m = len(A[0]) p = len(B[0]) # Initialize the result matrix with zeros result = [[0] * p for _ in range(n)] # Perform matrix multiplication for i in range(n): for j in range(p): for k in range(m): result[i][j] += A[i][k] * B[k][j] return result"},{"question":"Given an integer array `nums`, you need to find the **maximum length** of a subarray that has a sum equal to `k`. If there isn\'t one, return `0` instead. Note that a subarray is a contiguous part of the original array. You may assume the sum of the empty subarray as `0`.","solution":"def max_subarray_length(nums, k): Returns the maximum length of a subarray that has a sum equal to k. If there isn\'t one, return 0 instead. sum_to_index = {0: -1} current_sum = 0 max_length = 0 for i in range(len(nums)): current_sum += nums[i] if current_sum - k in sum_to_index: max_length = max(max_length, i - sum_to_index[current_sum - k]) if current_sum not in sum_to_index: sum_to_index[current_sum] = i return max_length"},{"question":"Given a string `s` consisting of lowercase alphabets and a character `target`, return the length of the shortest substring of `s` that contains all occurrences of `target`. If `target` does not appear in `s`, return `-1`.","solution":"def shortest_substring_containing_target(s, target): Returns the length of the shortest substring that contains all occurrences of the target character. if target not in s: return -1 # Find all indices of the target character indices = [i for i, char in enumerate(s) if char == target] # If there are no occurrences, return -1 if not indices: return -1 # Return the length of the shortest substring containing all target characters return indices[-1] - indices[0] + 1"},{"question":"Given a binary tree, imagine yourself standing on the right side of it. Return _an array of the values of the nodes you can see ordered from top to bottom_. A node is visible if there is no node to its right.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def right_side_view(root): Returns the values of the nodes that are visible from the right side. if not root: return [] right_view = [] level_nodes = [root] while level_nodes: next_level_nodes = [] for node in level_nodes: if node.left: next_level_nodes.append(node.left) if node.right: next_level_nodes.append(node.right) right_view.append(level_nodes[-1].val) level_nodes = next_level_nodes return right_view"},{"question":"You are given a city map represented as a 2D grid of integers. Each cell in the grid contains a positive integer which represents the height of a building at that location. Your task is to determine the amount of water that could be trapped after a rainstorm. Water can only be trapped where there are buildings of greater height on all four neighboring sides (up, down, left, and right). The amount of water trapped is determined by the shortest of these four heights minus the height of the building at that location. Implement a function that returns the total amount of water trapped by all the buildings in the city map.","solution":"import heapq def trapRainWater(heightMap): if not heightMap or not heightMap[0]: return 0 rows, cols = len(heightMap), len(heightMap[0]) visited = [[False] * cols for _ in range(rows)] heap = [] for r in range(rows): for c in range(cols): if r == 0 or c == 0 or r == rows - 1 or c == cols - 1: heapq.heappush(heap, (heightMap[r][c], r, c)) visited[r][c] = True total_water = 0 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] while heap: height, r, c = heapq.heappop(heap) for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < rows and 0 <= nc < cols and not visited[nr][nc]: visited[nr][nc] = True total_water += max(0, height - heightMap[nr][nc]) heapq.heappush(heap, (max(height, heightMap[nr][nc]), nr, nc)) return total_water"},{"question":"Given a **0-indexed** integer array `nums` of length `n`, your task is to determine if it is possible to split the array into two non-empty subsets such that the sum of the elements in one subset is equal to the sum of the elements in the other subset. If such a split is possible, return `true`; otherwise, return `false`. Note that each element of the array must belong to exactly one of the subsets and the sums of the two subsets do not have to be contiguous.","solution":"def can_partition(nums): Determine if the input array can be partitioned into two subsets with equal sums. :param nums: A list of integers. :return: A boolean value indicating if the array can be partitioned. total_sum = sum(nums) # If the total_sum is odd, we cannot partition it into two equal subsets if total_sum % 2 != 0: return False target = total_sum // 2 # Initialize a set to keep track of possible sums possible_sums = {0} for num in nums: new_sums = set() for s in possible_sums: new_sums.add(s + num) possible_sums.update(new_sums) if target in possible_sums: return True return False"},{"question":"Given a string `s` and a list of words `lst`, return _the shortest substring of_ `s` _that contains all the words from_ `lst`. _If there is no such substring, return an empty string._ The words in `lst` can appear in any order in the substring but must be whole words and not parts of other words. Words are separated by spaces in the string `s`.","solution":"def shortest_substring_with_all_words(s, lst): from collections import Counter, defaultdict words = s.split() word_count = Counter(lst) current_count = defaultdict(int) n = len(words) required_words = len(word_count) formed_words = 0 left = 0 min_length = float(\'inf\') min_left, min_right = 0, 0 for right in range(n): if words[right] in word_count: current_count[words[right]] += 1 if current_count[words[right]] == word_count[words[right]]: formed_words += 1 while formed_words == required_words: if right - left < min_length: min_length = right - left min_left = left min_right = right if words[left] in word_count: current_count[words[left]] -= 1 if current_count[words[left]] < word_count[words[left]]: formed_words -= 1 left += 1 if min_length == float(\'inf\'): return \\"\\" return \' \'.join(words[min_left:min_right + 1])"},{"question":"You are given a list of non-negative integers `nums`. A subarray is a contiguous portion of the array. The **product** of a subarray is the product of all the elements within it. Determine whether the array contains a subarray whose product is a **perfect square**. A perfect square is an integer that is the square of an integer. If such a subarray exists, return _`true`_, otherwise return _`false`_.","solution":"def is_perfect_square(num): Helper function to check if a number is a perfect square. if num < 0: return False root = int(num**0.5) return root * root == num def has_subarray_with_perfect_square_product(nums): Function to check if there exists a subarray whose product is a perfect square. n = len(nums) if n == 0: return False for i in range(n): product = 1 for j in range(i, n): product *= nums[j] if is_perfect_square(product): return True return False"},{"question":"You are given an integer array `height` where `height[i]` represents the height of the `ith` tree. You need to cut some trees to form a new row of trees such that the height of each tree in the new row is greater than the height of the previous tree starting from the leftmost to the rightmost. Determine the length of the longest possible row you can form. Return _the length of this row_.","solution":"def longest_ascending_subsequence(height): Returns the length of the longest possible row such that each element in the row is greater than the previous element. Parameters: height (list of int): List of tree heights. Returns: int: Length of the longest possible row. if not height: return 0 n = len(height) lis = [1] * n # Initialize LIS values for all indexes # Compute optimized LIS values in a bottom-up manner for i in range(1, n): for j in range(i): if height[i] > height[j] and lis[i] < lis[j] + 1: lis[i] = lis[j] + 1 # Return the maximum value in lis[] return max(lis)"},{"question":"Given an array of integers `nums`, find a subarray that has the maximum product of its elements. The subarray must contain at least one number. Return the maximum product that can be obtained.","solution":"def max_product(nums): Returns the maximum product of any subarray in nums. if not nums: return 0 max_prod = nums[0] min_prod = nums[0] result = nums[0] for num in nums[1:]: if num < 0: max_prod, min_prod = min_prod, max_prod max_prod = max(num, max_prod * num) min_prod = min(num, min_prod * num) result = max(result, max_prod) return result"},{"question":"You are given a **0-indexed** 2D integer array `segments` where `segments[i] = [starti, endi]`, representing the start and end points of line segments on a number line. A point `p` is considered **covered** by a segment if `starti <= p <= endi` for any segment `[starti, endi]`. Your task is to find the total length of the number line that is covered by at least one segment in `segments`. The segments may overlap, and you should ensure that overlapping sections are not counted more than once. Return _the total length covered by the segments_.","solution":"def covered_length(segments): Returns the total length of the number line that is covered by at least one segment in the list. Overlapping segments are considered only once in the total length. # Sort segments by their starting points (and by end points if starting points are the same) segments.sort() # Variable to store the total covered length total_length = 0 # Variable to keep track of the end of the last added segment in the covered length current_end = -float(\'inf\') for start, end in segments: if start > current_end: # If the new segment starts after the current end, add the full length of the segment total_length += end - start + 1 current_end = end else: # If the new segment overlaps or touches the current covered segment if end > current_end: total_length += end - current_end current_end = end return total_length"},{"question":"Given a string `s` and an integer `k`, you need to apply `k` operations on the string. In one operation, you can choose any character in the string `s` and change it to any other alphabetic character. Your task is to determine the minimum number of distinct characters in the final string after performing exactly `k` operations. Return the minimum number of distinct characters that can be achieved in the final string after exactly `k` operations.","solution":"def min_distinct_characters(s, k): Returns the minimum number of distinct characters that can be achieved in the string s after performing exactly k operations. from collections import Counter char_count = Counter(s) current_distinct = len(char_count) # If k >= len(s), we can change every character to the same character if k >= len(s): return 1 # Sort the character counts in ascending order sorted_counts = sorted(char_count.values()) i = 0 while k > 0 and i < len(sorted_counts): if k >= sorted_counts[i]: k -= sorted_counts[i] current_distinct -= 1 else: break i += 1 return current_distinct"},{"question":"You are given a 2D grid representing a city, where each cell is either a building (1) or an empty plot (0). Your goal is to determine the optimal location to build a post office so that the sum of the Manhattan distances from the post office to all the buildings is minimized. The Manhattan distance between two points (x1, y1) and (x2, y2) is defined as `|x1 - x2| + |y1 - y2|`. Write an algorithm to find the coordinates of the best location to build the post office. If there are multiple optimal locations, return any one of them.","solution":"def find_best_post_office_location(grid): Finds the best location to build a post office such that the sum of the Manhattan distances from the post office to all the buildings is minimized. buildings_x = [] buildings_y = [] for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: buildings_x.append(i) buildings_y.append(j) if not buildings_x: return None buildings_x.sort() buildings_y.sort() median_x = buildings_x[len(buildings_x) // 2] median_y = buildings_y[len(buildings_y) // 2] return (median_x, median_y)"},{"question":"You are given an integer array `nums` representing the number of coins in each pile. Each time you pick up one coin from any pile, it takes you 1 second. You can pick up multiple coins, but only from different piles simultaneously. Return _the **minimum** time required to collect at least `k` coins_.","solution":"def min_time_to_collect_coins(nums, k): Returns the minimum time required to collect at least k coins. Parameters: nums (list of int): The number of coins in each pile. k (int): The number of coins to be collected. Returns: int: Minimum time to collect at least k coins. # Sort the piles in descending order to pick the most coins first nums.sort(reverse=True) total_coins = 0 time = 0 for coins in nums: if total_coins >= k: break total_coins += coins time += 1 return time"},{"question":"You are given a 2D grid of size `m x n` representing a maze, with some cells blocked and some cells open. Your goal is to find and return the length of the shortest path from the top-left corner (0, 0) to the bottom-right corner (m-1, n-1). You can move up, down, left, or right, but you cannot move into a blocked cell. If there is no valid path, return `-1`. The grid cells contain the following values: * `0` represents an open cell. * `1` represents a blocked cell. The maze is represented as a 2D list of integers called `grid`.","solution":"from collections import deque def shortest_path_in_maze(grid): Returns the length of the shortest path in the maze from (0, 0) to (m-1, n-1). If there is no valid path, returns -1. if not grid or grid[0][0] == 1 or grid[-1][-1] == 1: return -1 m, n = len(grid), len(grid[0]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # up, down, left, right # BFS setup queue = deque([(0, 0, 1)]) # (row, col, distance) visited = set() visited.add((0, 0)) while queue: row, col, dist = queue.popleft() # If we\'ve reached the bottom-right corner if row == m-1 and col == n-1: return dist # Explore all four directions for dr, dc in directions: r, c = row + dr, col + dc if 0 <= r < m and 0 <= c < n and grid[r][c] == 0 and (r, c) not in visited: queue.append((r, c, dist + 1)) visited.add((r, c)) return -1"},{"question":"Implement a function `detectCycle(head)` that detects if a cycle exists in a given singly linked list. If a cycle is detected, return the node where the cycle begins. If there is no cycle, return null. A cycle is defined as a situation where a node’s next pointer points to one of the previous nodes in the linked list. The input to the function is a ListNode representing the head of the singly linked list.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def detectCycle(head): Detect a cycle in a linked list. If a cycle exists, return the node where the cycle begins. If there is no cycle, return None. if not head or not head.next: return None slow = head fast = head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: # Cycle detected break else: return None # No cycle detected # Find the start of the cycle slow = head while slow != fast: slow = slow.next fast = fast.next return slow"},{"question":"You are given a list of integers `weights` where `weights[i]` represents the weight of the `i-th` item. You need to split this list into two sublists such that the absolute difference between the sum of these two sublists is minimized. Return _the minimum possible absolute difference_. Note that both sublists must have at least one item.","solution":"def minimum_difference(weights): Returns the minimum possible absolute difference between the sum of two sublists which can be formed from the given list of weights. Note: Both sublists must have at least one item. total_sum = sum(weights) n = len(weights) dp = [False] * (total_sum // 2 + 1) dp[0] = True for weight in weights: for j in range(total_sum // 2, weight - 1, -1): dp[j] = dp[j] or dp[j - weight] for i in range(total_sum // 2, -1, -1): if dp[i]: return abs(total_sum - 2 * i)"},{"question":"Given a string `s`, you need to split it into as many part groups as possible such that each letter appears in at most one group. Return a list of integers representing the size of these parts. The order does not matter for the result. If the input string cannot be split into such parts, return an empty list. * Example: * Input: `s = \\"abacaba\\"` * Output: `[1, 2, 1, 1, 1, 1, 1]` or `[5, 2]` or any other valid grouping. * Example: * Input: `s = \\"abcde\\"` * Output: `[1, 1, 1, 1, 1]`","solution":"def splitStringIntoGroups(s): Splits the input string `s` into as many part groups as possible such that each letter appears in at most one group. Returns a list of integers representing the size of these parts. last_occurrence = {char: idx for idx, char in enumerate(s)} parts = [] start, end = 0, 0 for idx, char in enumerate(s): end = max(end, last_occurrence[char]) if idx == end: parts.append(end - start + 1) start = end + 1 return parts"},{"question":"Given an array of integers `arr` and an integer `k`, return _the number of **unique subsets** of the array where the sum of the elements in each subset is divisible by `k`_. A **subset** is a selection of elements (possibly none) that maintains the order and does not rearrange the elements.","solution":"from itertools import combinations def count_unique_subsets(arr, k): Returns the number of unique subsets of the array where the sum of the elements in each subset is divisible by k. unique_sums = set() n = len(arr) # Check all possible subsets for i in range(n + 1): for subset in combinations(arr, i): subset_sum = sum(subset) if subset_sum % k == 0: unique_sums.add(subset) return len(unique_sums)"},{"question":"You are given two strings `s1` and `s2` which only consist of lowercase letters. Your task is to determine if one string can be obtained by performing a **single swap** of any two characters in the other string. Return `true` if it\'s possible and `false` otherwise.","solution":"def can_be_obtained_by_single_swap(s1, s2): Returns True if s1 can be obtained by a single swap of any two characters in s2, otherwise returns False. if len(s1) != len(s2): return False # Find the indices where the characters differ differences = [(i, s1[i], s2[i]) for i in range(len(s1)) if s1[i] != s2[i]] # If there are no differences, the strings are already equal if not differences: return True # If there are exactly 2 differences, check if swapping resolves the differences if len(differences) == 2: (i1, a1, b1), (i2, a2, b2) = differences return a1 == b2 and a2 == b1 return False"},{"question":"Given a string `s` representing a valid arithmetic expression that contains only non-negative integers, the operators `+`, `-`, `*`, and `/`, and empty spaces, write a program to evaluate this expression and return its result as an integer. The division should truncate towards zero. You can assume that the given expression is always valid.","solution":"def evaluate_expression(s): def apply_operator(operators, values): right = values.pop() left = values.pop() op = operators.pop() if op == \'+\': values.append(left + right) elif op == \'-\': values.append(left - right) elif op == \'*\': values.append(left * right) elif op == \'/\': values.append(int(left / right)) # int() truncates towards zero operators = [] values = [] i, n = 0, len(s) while i < n: if s[i] == \' \': i += 1 continue if s[i] in \'0123456789\': value = 0 while i < n and s[i] in \'0123456789\': value = value * 10 + int(s[i]) i += 1 values.append(value) elif s[i] in \'+-*/\': while (operators and operators[-1] in \'*/\' and s[i] in \'+-*/\'): apply_operator(operators, values) operators.append(s[i]) i += 1 while operators: apply_operator(operators, values) return values[0]"},{"question":"You are given an integer array `stocks` where `stocks[i]` represents the stock price on the `i-th` day. A trader can make multiple transactions (i.e., buy one and sell one share of the stock multiple times). However, he must sell the stock before he buys again. Write a function that calculates the _maximum profit_ the trader can achieve. Note that a trader cannot engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again). ```python def maxProfit(stocks: List[int]) -> int: # Your implementation here ``` Return _the maximum profit_ as an integer.","solution":"def maxProfit(stocks): Calculate the maximum profit that can be achieved by trading stocks with multiple buy-sell transactions. Parameters: stocks (List[int]): List of stock prices per day. Returns: int: Maximum profit. if not stocks: return 0 max_profit = 0 for i in range(1, len(stocks)): if stocks[i] > stocks[i - 1]: max_profit += stocks[i] - stocks[i - 1] return max_profit"},{"question":"Given an array of integers `nums` where `nums[i]` represents the number of stones in the `i-th` pile, your task is to determine whether the first player to move can guarantee a win. Both players take turns picking any number of stones from one pile during each turn. The player who picks the last stone(s) from the last non-empty pile wins the game. Assume both players play optimally. Return `true` if the first player can guarantee a win, and `false` otherwise.","solution":"def can_first_player_win(nums): Determine if the first player can guarantee a win. :param nums: List[int], represents the number of stones in each pile. :return: bool, True if the first player can guarantee a win, False otherwise. # Using a Nim game theory solution where the first player wins if the XOR of all piles is non-zero. nim_sum = 0 for pile in nums: nim_sum ^= pile return nim_sum != 0"},{"question":"Given an integer `n`, return a string concatenation of the integers from 1 to `n` with a twist: replace every number divisible by 3 with \\"Fizz\\", every number divisible by 5 with \\"Buzz\\", and every number divisible by both 3 and 5 with \\"FizzBuzz\\". The final result should be a single string, with no extra spaces or delimiters between the transformed numbers.","solution":"def fizz_buzz_concat(n): Returns a concatenated string of integers from 1 to n with the following conditions: - Replace numbers divisible by 3 with \\"Fizz\\" - Replace numbers divisible by 5 with \\"Buzz\\" - Replace numbers divisible by both 3 and 5 with \\"FizzBuzz\\" result = \\"\\" for i in range(1, n + 1): if i % 3 == 0 and i % 5 == 0: result += \\"FizzBuzz\\" elif i % 3 == 0: result += \\"Fizz\\" elif i % 5 == 0: result += \\"Buzz\\" else: result += str(i) return result"},{"question":"You are given a string `s` representing a column of numbers, where each digit is either \'1\' or \'0\'. You can perform a \\"flip\\" operation which flips all the digits in the column (changing \'1\' to \'0\' and \'0\' to \'1\'). Write a function to determine the minimum number of flips required to make the string consist of only \'1\'s or only \'0\'s. Return the minimum number of flips needed.","solution":"def min_flips(s): Returns the minimum number of flips required to make the string `s` consist of all \'1\'s or all \'0\'s. count_0_to_1 = s.count(\'0\') count_1_to_0 = s.count(\'1\') return min(count_0_to_1, count_1_to_0)"},{"question":"You are given an integer array `arr` and an integer `k`. Determine the number of **unique** pairs `(i, j)` in the array where `i != j` and `arr[i] + arr[j]` is divisible by `k`. That is, _count the pairs_ `(i, j)` _such that_ `arr[i] + arr[j]` _modulo_ `k` _is equal to zero_. Return the total count of such pairs.","solution":"def count_divisible_pairs(arr, k): Determines the number of unique pairs (i, j) in the array where i != j and arr[i] + arr[j] is divisible by k. Parameters: arr (list of int): The array of integers. k (int): The integer divisor. Returns: int: The count of such unique pairs. # Create a dictionary to store remainder counts remainder_counts = {} # Count occurrences of each remainder when divided by k for num in arr: remainder = num % k if remainder in remainder_counts: remainder_counts[remainder] += 1 else: remainder_counts[remainder] = 1 total_pairs = 0 # Iterate through the remainders and calculate pairs for remainder in remainder_counts: if remainder == 0 or remainder * 2 == k: # If the remainder is 0 or exactly half of k, # we can only form pairs within the same group count = remainder_counts[remainder] total_pairs += count * (count - 1) // 2 elif remainder < k - remainder: # Pair each item with remainder \'r\' with each item # with remainder \'k-r\' count_r = remainder_counts[remainder] count_k_r = remainder_counts.get(k - remainder, 0) total_pairs += count_r * count_k_r return total_pairs"},{"question":"You are given an array of integers `arr` and an integer `target`. Your goal is to determine the number of distinct pairs of elements `(a, b)` in `arr` such that their sum is equal to `target`. Each element in the array can be used at most once in a pair. Return the number of such pairs.","solution":"def count_pairs_with_sum(arr, target): Returns the number of distinct pairs (a, b) in arr such that a + b = target. seen = set() pairs = set() for num in arr: complement = target - num if complement in seen: pairs.add(tuple(sorted((num, complement)))) seen.add(num) return len(pairs)"},{"question":"Write a function that takes in a list of integers representing the prices of different items and an integer `budget` representing the amount of money you have. The function should return the maximum number of items you can buy without exceeding the budget. Each item can be bought only once. Here is the function signature: ```python def maxItems(prices: List[int], budget: int) -> int: ``` The function should first sort the list of prices in ascending order and then iterate over the sorted list, summing the prices until adding another item would exceed the budget, at which point it should return the count of items bought.","solution":"from typing import List def maxItems(prices: List[int], budget: int) -> int: Finds the maximum number of items that can be purchased with a given budget. Parameters: prices (List[int]): A list of prices of different items. budget (int): The available budget to spend on the items. Returns: int: The maximum number of items that can be bought without exceeding the budget. prices.sort() total_spent = 0 items_bought = 0 for price in prices: if total_spent + price <= budget: total_spent += price items_bought += 1 else: break return items_bought"},{"question":"You are given an array of unique integers `nums` sorted in ascending order. Implement a function that takes in `nums` and returns a balanced binary search tree (BST) that has `nums` as its in-order traversal. A balanced BST is defined as a binary tree in which the depth of the two subtrees of every node never differs by more than one.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sortedArrayToBST(nums): Converts a sorted array of unique integers into a balanced BST. if not nums: return None # Helper function to construct BST def constructBST(low, high): if low > high: return None mid = (low + high) // 2 node = TreeNode(nums[mid]) node.left = constructBST(low, mid - 1) node.right = constructBST(mid + 1, high) return node return constructBST(0, len(nums) - 1)"},{"question":"You are given a list of transactions where each transaction is a list with the format `[userId, timestamp, amount]`. Each transaction represents that a user with `userId` made a transaction of `amount` at a given `timestamp`. Your task is to calculate the moving average of the transaction amounts for each user over a sliding window of `k` transactions. Implement the `TransactionMovingAverage` class which will have the following methods: * `TransactionMovingAverage(int k)` - Initializes the object with the sliding window size `k`. * `void addTransaction(int userId, int timestamp, int amount)` - Adds a new transaction for the given `userId`. * `double getMovingAverage(int userId)` - Returns the moving average of the transaction amounts for the given `userId` over the last `k` transactions. You may assume that the timestamps are added in non-decreasing order.","solution":"from collections import defaultdict, deque class TransactionMovingAverage: def __init__(self, k): self.k = k self.user_transactions = defaultdict(deque) self.user_sums = defaultdict(int) def addTransaction(self, userId, timestamp, amount): user_deque = self.user_transactions[userId] user_sums = self.user_sums user_deque.append(amount) user_sums[userId] += amount if len(user_deque) > self.k: user_sums[userId] -= user_deque.popleft() def getMovingAverage(self, userId): user_deque = self.user_transactions[userId] if len(user_deque) == 0: return 0.0 return self.user_sums[userId] / len(user_deque)"},{"question":"Given a string `s` that contains only digits (0-9) and characters `?`, replace each `?` with any digit from 0 to 9 such that the final string does not contain any two consecutive digits that are the same. Return the resultant string. If there are multiple possible results, return any of them. Assume that the input string is non-empty.","solution":"def replace_question_marks(s): Replace each \'?\' in the string with any digit (0-9) such that no two consecutive digits are the same. Return the resultant string. # Convert string to list to modify it easily s_list = list(s) n = len(s_list) for i in range(n): if s_list[i] == \'?\': for digit in \'0123456789\': if (i > 0 and s_list[i-1] == digit) or (i < n-1 and s_list[i+1] == digit): continue s_list[i] = digit break return \'\'.join(s_list)"},{"question":"You are given an integer array `nums` where the elements are in the range `[1, n]` inclusive, and `n` is the length of the array. Each number appears exactly once, but a random shuffle of the array applies an unknown number of swaps between two elements. Given the resulting array `nums`, return _**the minimum number of swaps required** to sort the array in ascending order_. If the array is already sorted, return `0`.","solution":"def min_swaps_to_sort(nums): Returns the minimum number of swaps required to sort the array in ascending order. n = len(nums) sorted_nums = sorted(nums) index_dic = {v: i for i, v in enumerate(nums)} swaps = 0 for i in range(n): if nums[i] != sorted_nums[i]: swaps += 1 swap_index = index_dic[sorted_nums[i]] # Swap elements in the original array nums[i], nums[swap_index] = nums[swap_index], nums[i] # Update the indices in the index dictionary index_dic[nums[swap_index]] = swap_index index_dic[nums[i]] = i return swaps"},{"question":"You are given an integer array `nums` of even length, where different numbers in the array represent different types of candies. Each number in `nums` is a positive integer representing a type of candy. Your task is to divide all the candies between two children such that each child gets exactly half of the candies. To maximize the happiness of each child, you should ensure that each child gets as many different types of candies as possible. Return the maximum number of different types of candies each child can get if you divide the candies optimally. Implement the function `maxCandiesTypes(nums: List[int]) -> int` to solve the problem.","solution":"from typing import List def maxCandiesTypes(nums: List[int]) -> int: unique_candies = len(set(nums)) max_candies_each_child_can_get = len(nums) // 2 return min(unique_candies, max_candies_each_child_can_get)"},{"question":"Given a linked list, write a function to rearrange it in such a way that the odd-indexed nodes appear before the even-indexed nodes. The relative order among the odd-indexed nodes and the even-indexed nodes should remain the same as in the input. For example, if the linked list is represented as `L0 -> L1 -> L2 -> L3 -> L4`, you need to rearrange it to `L0 -> L2 -> L4 -> L1 -> L3`.","solution":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def rearrange_linked_list(head): Rearranges a linked list so odd-indexed nodes appear before even-indexed nodes. if not head or not head.next: return head odd = head even = head.next even_head = even while even and even.next: odd.next = even.next odd = odd.next even.next = odd.next even = even.next odd.next = even_head return head"},{"question":"You are given an array `nums` of `n` integers where `n` is even. The array `nums` is considered balanced if the sum of the first half of the array is equal to the sum of the second half of the array. You are allowed to replace any element of the array with any integer value. Return _the minimum number of replacements needed to make the array balanced_. For example, given the array `nums = [1, 2, 3, 4, 5, 6]`, one possible solution to make it balanced is to replace the last element with `-9` to get `nums = [1, 2, 3, 4, 5, -9]`. This results in the first half sum being `1 + 2 + 3 = 6` and the second half sum being `4 + 5 + (-9) = 0`. Note that replacements need to be optimal to achieve the result in minimum steps.","solution":"def min_replacements_to_balance(nums): Returns the minimum number of replacements needed to make the array balanced. n = len(nums) half = n // 2 first_half_sum = sum(nums[:half]) second_half_sum = sum(nums[half:]) diff = abs(first_half_sum - second_half_sum) # If the array is already balanced, no replacements are needed. if diff == 0: return 0 # If not, the minimum number of replacements needed is 1 (by replacing # one element from either half to balance the overall sum). return 1 # Example usage: # nums = [1, 2, 3, 4, 5, 6] # print(min_replacements_to_balance(nums)) # Output: 1"},{"question":"You are given two integer arrays `nums1` and `nums2`, where `nums1` is a subset of `nums2`. Find the next greater element for each element in `nums1` from the array `nums2`. The next greater element of a number `x` in `nums1` is the first greater number to its right in `nums2`. If it does not exist, return -1 for this number. The elements in `nums1` and `nums2` are unique. Return an array `result` where `result[i]` is the next greater element for `nums1[i]` in `nums2`.","solution":"def nextGreaterElement(nums1, nums2): Find the next greater element for each element in nums1 from nums2. :param nums1: List[int] :param nums2: List[int] :return: List[int] next_greater = {} stack = [] # Traverse nums2 in reverse order to determine the next greater element for each for num in reversed(nums2): while stack and stack[-1] <= num: stack.pop() next_greater[num] = stack[-1] if stack else -1 stack.append(num) # Create the result list based on nums1 result = [next_greater[num] for num in nums1] return result"},{"question":"A social network app tracks the friendship relations between users. Each user is represented by a unique integer and the friendships are given as a list of pairs. We define the **degree** of a user as the number of unique friends the user has. Given the list of friendships and an integer `k`, return _the list of users who have exactly `k` friends_. The output list should be sorted in increasing order of users\' unique integers. If no such user exists, return an empty list.","solution":"def users_with_k_friends(friendships, k): from collections import defaultdict # Dictionary to count friends for each user friend_count = defaultdict(int) # Counting each user\'s friends for u1, u2 in friendships: friend_count[u1] += 1 friend_count[u2] += 1 # Collecting users with exactly k friends result = [user for user, count in friend_count.items() if count == k] # Returning the sorted result return sorted(result)"},{"question":"You are given a binary search tree (BST) with `n` nodes. Each node in the BST has an integer value. You are also given an integer `k`. Your task is to find the `k`-th smallest value in the BST. Return _the_ `k`-th smallest value _in the tree_. If the binary search tree does not have `k` elements, return `-1`.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def kth_smallest(root, k): Returns the k-th smallest value in the BST rooted at \'root\'. If the tree has less than k elements, return -1. def inorder_traverse(node): if node is None: return [] return inorder_traverse(node.left) + [node.val] + inorder_traverse(node.right) elements = inorder_traverse(root) if k > len(elements): return -1 return elements[k - 1]"},{"question":"You are given a **0-indexed** integer array `heights` representing the heights of students standing in a line. You want to organize them into a non-decreasing order. However, you can only perform the following operation: choose any student and move them to the end of the line. Return _the minimum number of such operations needed to sort the array in non-decreasing order_.","solution":"def min_operations_to_sort(heights): Returns the minimum number of operations to sort the array in non-decreasing order by choosing any student and moving them to the end of the line. n = len(heights) if n <= 1: return 0 # Find the length of the longest non-decreasing subsequence longest_nds_length = 1 current_length = 1 for i in range(1, n): if heights[i] >= heights[i - 1]: current_length += 1 else: longest_nds_length = max(longest_nds_length, current_length) current_length = 1 longest_nds_length = max(longest_nds_length, current_length) # Minimum operations needed are total length minus length of longest nds return n - longest_nds_length"},{"question":"You are given a string `s` consisting of lowercase letters, and you need to select a substring `t` such that the frequency of each character in `t` is exactly the same as in a given string `p`. Return _the starting indices of `t` in `s`, or an empty list if no such substring exists_. The output should be in increasing order of indices.","solution":"from collections import Counter def find_anagrams(s, p): Returns the starting indices of the substrings in `s` that match the frequency pattern of `p`. result = [] p_len = len(p) s_len = len(s) if p_len > s_len: return result p_count = Counter(p) s_count = Counter(s[:p_len-1]) for i in range(p_len-1, s_len): s_count[s[i]] += 1 # add the current character to the window current_start_idx = i - p_len + 1 if s_count == p_count: result.append(current_start_idx) s_count[s[current_start_idx]] -= 1 # remove the character that\'s left the window if s_count[s[current_start_idx]] == 0: del s_count[s[current_start_idx]] return result"},{"question":"You are given a 2D array `mat` representing an `n x n` matrix where each element represents the elevation of a cell. Your task is to find the maximum water that can be trapped after raining. Water can only be trapped over an elevation of at least `2`, and the trapped water should be surrounded by non-water elements such that water does not overflow from the boundaries. Return the amount of water trapped in the matrix.","solution":"import heapq def trapRainWater(mat): if not mat or not mat[0]: return 0 n = len(mat) m = len(mat[0]) heap = [] visited = [[False] * m for _ in range(n)] # Push all the boundary cells into the heap for i in range(n): for j in range(m): if i == 0 or j == 0 or i == n-1 or j == m-1: heapq.heappush(heap, (mat[i][j], i, j)) visited[i][j] = True # To store the directions for 4-side exploration (up, down, left, right) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] water_trapped = 0 while heap: height, x, y = heapq.heappop(heap) for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny]: visited[nx][ny] = True water_trapped += max(0, height - mat[nx][ny]) heapq.heappush(heap, (max(height, mat[nx][ny]), nx, ny)) return water_trapped"},{"question":"You are given a string `s` containing only lowercase alphabetic characters. Your task is to remove the minimum number of characters from `s` so that the remaining characters form a string with no two identical characters next to each other. If there are multiple solutions, you can return any. Return the modified string with no two identical characters adjacent to each other.","solution":"def remove_adjacent_duplicates(s): Removes minimum number of characters from the string `s` so that no two identical characters are next to each other. Parameters: s (str): The input string containing only lowercase alphabetic characters. Returns: str: The modified string with no two identical characters adjacent. if not s: return s result = [s[0]] for i in range(1, len(s)): if s[i] != s[i-1]: result.append(s[i]) return \'\'.join(result)"},{"question":"Given a 2D `m x n` board of characters and a string `word`, return _true_ if `word` exists in the grid. The word can be constructed from letters of sequentially adjacent cells, where \\"adjacent\\" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once. For example, given the board: ``` [ [\'A\',\'B\',\'C\',\'E\'], [\'S\',\'F\',\'C\',\'S\'], [\'A\',\'D\',\'E\',\'E\'] ] ``` And the word `\\"ABCCED\\"`, your function should return `true`.","solution":"def exist(board, word): def dfs(board, word, i, j, k): if not (0 <= i < len(board)) or not (0 <= j < len(board[0])) or board[i][j] != word[k]: return False if k == len(word) - 1: return True tmp, board[i][j] = board[i][j], \'/\' res = dfs(board, word, i+1, j, k+1) or dfs(board, word, i-1, j, k+1) or dfs(board, word, i, j+1, k+1) or dfs(board, word, i, j-1, k+1) board[i][j] = tmp return res for i in range(len(board)): for j in range(len(board[0])): if dfs(board, word, i, j, 0): return True return False"},{"question":"You are given a string `s` consisting of only lowercase English letters. Your task is to determine if you can obtain a string that contains all letters of the alphabet at least once by rearranging the characters of `s` and appending an arbitrary number of lowercase English letters to the end. If it is possible, return `True`; otherwise, return `False`.","solution":"def can_form_full_alphabet(s): Determines if a string can contain all letters of the alphabet at least once by rearranging its characters and appending extra letters if needed. Params: s (string): input string consisting of only lowercase English letters Returns: bool: True if it\'s possible to form a full alphabet, False otherwise # Create a set of characters found in the string char_set = set(s) # Create a set of all lowercase English letters all_letters_set = set(\'abcdefghijklmnopqrstuvwxyz\') # Check if all letters of the alphabet are present in the string set return all_letters_set.issubset(char_set)"},{"question":"Given a string `s` consisting of distinct lowercase letters, and an integer `k`, partition the string into `k` contiguous substrings. The goal is to minimize the maximum length among all `k` substrings. Return the minimized maximum length. If it is not possible to partition the string in the described manner, return `-1`.","solution":"def minimize_max_length(s, k): Minimize the maximum length among all k substrings. Parameters: s (str): A string consisting of distinct lowercase letters. k (int): An integer to partition the string into k contiguous substrings. Returns: int: The minimized maximum length or -1 if it is not possible. n = len(s) if k > n: return -1 if k == n: return 1 # Binary search to find the minimal possible maximum length. l, r = 1, n def can_partition(max_len): partitions = 1 current_len = 0 for char in s: current_len += 1 if current_len > max_len: partitions += 1 current_len = 1 if partitions > k: return False return True while l < r: mid = (l + r) // 2 if can_partition(mid): r = mid else: l = mid + 1 return l"},{"question":"You are working with an `n x n` grid. Each cell of the grid contains a positive integer. You want to find the maximum sum of integers in any path from the top-left to the bottom-right corner of the grid. You can only move either right or down at any point in time. Write a function that takes this grid as input and returns the maximum sum achievable.","solution":"def max_path_sum(grid): Returns the maximum sum of integers in any path from the top-left to the bottom-right corner of the grid. You can only move either right or down at any point in time. :param grid: List[List[int]] - the input n x n grid of positive integers :return: int - the maximum path sum n = len(grid) # Create a DP table to store maximum path sum results dp = [[0]*n for _ in range(n)] dp[0][0] = grid[0][0] # Initialize the first row of the DP table for i in range(1, n): dp[0][i] = dp[0][i-1] + grid[0][i] # Initialize the first column of the DP table for j in range(1, n): dp[j][0] = dp[j-1][0] + grid[j][0] # Fill the rest of the DP table for i in range(1, n): for j in range(1, n): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[n-1][n-1]"},{"question":"Given an array of integers `heights` representing the heights of students standing in a line, return _the **minimum** number of students that must move to make the heights **non-decreasing** from left to right_.","solution":"def min_students_to_move(heights): Returns the minimum number of students that must move to make the heights non-decreasing from left to right. :param heights: List[int] -> List of heights of students. :return: int -> Minimum number of students to move. n = len(heights) if n == 0: return 0 # Find the longest non-decreasing subsequence dp = [1] * n for i in range(1, n): for j in range(i): if heights[i] >= heights[j]: dp[i] = max(dp[i], dp[j] + 1) # Minimum moves required are the students not in the longest non-decreasing subsequence longest_nondecreasing_subseq = max(dp) return n - longest_nondecreasing_subseq"},{"question":"You are given a 2D matrix `mat` of dimensions `m x n`, filled with non-negative integers. Consider a matrix `blockSum` of the same dimensions where each element `blockSum[i][j]` is equal to the sum of all elements `mat[r][c]` for which `i - K <= r <= i + K` and `j - K <= c <= j + K`, and `(r, c)` is within the bounds of the matrix. Given `mat`, `m`, `n`, and a non-negative integer `K`, return the matrix `blockSum`. Ensure your algorithm runs efficiently, ideally in `O(m * n)` time.","solution":"def matrixBlockSum(mat, K): Calculates the block sum of a matrix with a given K. m, n = len(mat), len(mat[0]) # Create an auxiliary 2D prefix sum array prefix = [[0] * (n + 1) for _ in range(m + 1)] # Fill the prefix sum array for i in range(m): for j in range(n): prefix[i + 1][j + 1] = mat[i][j] + prefix[i + 1][j] + prefix[i][j + 1] - prefix[i][j] # Calculate the block sum using the prefix sum array result = [[0] * n for _ in range(m)] for i in range(m): for j in range(n): # Calculate boundaries of the submatrix r1 = max(0, i - K) r2 = min(m - 1, i + K) c1 = max(0, j - K) c2 = min(n - 1, j + K) result[i][j] = prefix[r2 + 1][c2 + 1] - prefix[r1][c2 + 1] - prefix[r2 + 1][c1] + prefix[r1][c1] return result"},{"question":"You are given a list of integers `nums` and an integer `x`. You need to make all the elements of `nums` equal to the same integer by incrementing an element by `x` any number of times. Determine whether it is possible to make all the elements equal. If it is possible, return `true`; otherwise, return `false`.","solution":"def can_make_all_elements_equal(nums, x): Determines if it is possible to make all elements equal by incrementing elements by x any number of times. Args: nums: List[int] - List of integers. x: int - Increment value. Returns: bool - True if possible, else False. # Determine the remainder when each element is divided by x remainder = nums[0] % x # Check if all elements have the same remainder when divided by x for num in nums: if num % x != remainder: return False return True"},{"question":"Suppose you are given a binary tree. Implement a function `invertTree(TreeNode* root)` that inverts the binary tree, essentially flipping it upside down by swapping the left and right children of every node. Your function should return the root of the inverted tree.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def invertTree(root): Invert a binary tree by swapping the left and right children of every node. :param root: Root of the binary tree :type root: TreeNode :return: Root of the inverted binary tree :rtype: TreeNode if root is None: return None # Swap the left and right children root.left, root.right = root.right, root.left # Recursively invert the left and right subtrees invertTree(root.left) invertTree(root.right) return root"},{"question":"You are given a list of `n` integers `arr`, where each element represents the required amount of storage for a file. There are `m` servers available, each with a fixed storage capacity `c`. Your task is to distribute the files onto the servers in a way that maximizes the number of files that can be fully stored across the servers without exceeding their capacity. Each server can store multiple files as long as their total storage does not exceed `c`. Return _an integer_ representing the maximum number of files that can be fully stored across the `m` servers without exceeding their capacity.","solution":"def max_files_stored(arr, m, c): Returns the maximum number of files that can be fully stored across m servers without exceeding their capacity. :param arr: list of integers, where each element represents the storage required by a file :param m: integer, the number of available servers :param c: integer, the capacity of each server :return: integer, the maximum number of files that can be fully stored arr.sort() count = 0 servers = [0] * m # Initialize servers with zero used capacity for file in arr: for i in range(m): if servers[i] + file <= c: servers[i] += file count += 1 break # Break since we have placed this file return count"},{"question":"A **neighborhood string** is defined as a string where every pair of consecutive characters differs by exactly one position in the English alphabet. For example, the string `”abc”` is a neighborhood string because `’b’` is after `’a’` and `’c’` is after `’b’`. Given a string `s`, determine whether it qualifies as a neighborhood string. Return `true` if `s` is a neighborhood string, and `false` otherwise. Note that the string will contain only lowercase English letters.","solution":"def is_neighborhood_string(s): Returns True if the given string s is a neighborhood string, otherwise False. if len(s) < 2: return True for i in range(len(s) - 1): if abs(ord(s[i]) - ord(s[i + 1])) != 1: return False return True"},{"question":"Given an array of integers `arr` representing the arrival times of trains at a station, and another array `dep` representing the departure times of the same trains, your task is to determine the minimum number of platforms required at the station such that no train has to wait. Each train will only occupy one platform from its arrival time to its departure time. For example: - `arr = [900, 940, 950, 1100, 1500, 1800]` - `dep = [910, 1200, 1120, 1130, 1900, 2000]` You should return the minimum number of platforms required to accommodate all trains without any of them having to wait.","solution":"def find_min_platforms(arr, dep): Determines the minimum number of platforms required at the station such that no train has to wait. Parameters: arr (list of int): Arrival times of trains. dep (list of int): Departure times of trains. Returns: int: The minimum number of platforms required. # Sort both the arrays arr.sort() dep.sort() n = len(arr) # Variables to keep track of required platforms platforms_needed = 1 result = 1 i = 1 j = 0 # Similar to merge in merge sort while (i < n and j < n): if arr[i] <= dep[j]: platforms_needed += 1 i += 1 elif arr[i] > dep[j]: platforms_needed -= 1 j += 1 if (platforms_needed > result): result = platforms_needed return result"},{"question":"Given an array of integers `nums` and an integer `k`, return the **smallest sum** of any **contiguous subarray** of length `k` in _`nums`_. A **subarray** is a contiguous part of an array.","solution":"def smallest_sum_of_subarray(nums, k): Returns the smallest sum of any contiguous subarray of length k in nums. if not nums or k > len(nums): return None # Calculate the initial sum of the first subarray of length k current_sum = sum(nums[:k]) min_sum = current_sum # Use a sliding window to find the minimum sum of any subarray of length k for i in range(k, len(nums)): current_sum = current_sum - nums[i - k] + nums[i] min_sum = min(min_sum, current_sum) return min_sum"},{"question":"Given the `head` of a singly linked list, write a function to reverse the list and return the reversed list\'s head. Your algorithm should operate in-place, meaning you cannot use additional data structures to store the nodes.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverseList(head): Reverses a singly linked list. Parameters: head (ListNode): The head of the singly linked list. Returns: ListNode: The new head of the reversed singly linked list. prev = None current = head while current is not None: next_node = current.next current.next = prev prev = current current = next_node return prev"},{"question":"Implement a function `is_valid_tree` that determines if a given set of edges can form a valid tree. The function should take two arguments: `n`, the number of nodes labeled from `0` to `n-1`, and an array `edges` where each element is a pair `[u, v]` representing an undirected edge connecting nodes `u` and `v`. Return `true` if the edges form a valid tree, and `false` otherwise. A valid tree must satisfy the following conditions: - It must be connected, meaning there is a path between any two nodes. - It must have exactly `n-1` edges.","solution":"def is_valid_tree(n, edges): Determines if the given edges form a valid tree for n nodes. if len(edges) != n - 1: return False # Create adjacency list adjacency_list = {i: [] for i in range(n)} for u, v in edges: adjacency_list[u].append(v) adjacency_list[v].append(u) # Check if the graph is connected using DFS visited = set() def dfs(node): if node in visited: return visited.add(node) for neighbor in adjacency_list[node]: dfs(neighbor) dfs(0) # The graph is a valid tree if all nodes are visited return len(visited) == n"},{"question":"You are given a list of `n` tickets where each ticket has a unique identifier and a `status`. The status can be either `\\"open\\"`, `\\"closed\\"`, or `\\"pending\\"`. You are tasked with organizing these tickets into a report. The report should classify the tickets into three categories based on their status. Each category should list the unique identifiers of the tickets under it. _Return a dictionary with three keys: `\\"open\\"`, `\\"closed\\"`, and `\\"pending\\"`, each containing a list of unique identifiers of the tickets with the corresponding status. If no tickets exist for a particular status, return an empty list for that status._","solution":"def organize_tickets(tickets): Organizes tickets into a report based on their status. Args: tickets (list of dicts): List of tickets where each ticket is a dict with \'id\' and \'status\'. Returns: dict: Dictionary with \'open\', \'closed\', and \'pending\' as keys and lists of ticket ids as values. report = { \\"open\\": [], \\"closed\\": [], \\"pending\\": [] } for ticket in tickets: if ticket[\'status\'] in report: report[ticket[\'status\']].append(ticket[\'id\']) return report"},{"question":"Given an array of integers `arr`, determine if it is possible to rearrange the elements of `arr` such that the sum of any two adjacent elements is not divisible by a given integer `k`. If such a rearrangement is possible, return the rearranged array; otherwise, return an empty array.","solution":"def rearrange_array(arr, k): Rearranges the elements of `arr` such that the sum of any two adjacent elements is not divisible by `k`. If not possible, returns an empty array. Parameters: arr (list of int): The input array of integers. k (int): The specified integer for divisibility check. Returns: list of int: The rearranged array, or an empty array if not possible. from collections import Counter # Count the frequency of each remainder when divided by k counts = Counter(n % k for n in arr) # Sort elements by remainder frequency sorted_arr = sorted(arr, key=lambda x: counts[x % k]) n = len(arr) for i in range(n - 1): if (sorted_arr[i] + sorted_arr[i + 1]) % k == 0: return [] return sorted_arr"},{"question":"You are given an integer array `nums` and an integer `k`. A **k-inverse pairs** array is an array where there are exactly `k` inverse pairs. An inverse pair is a pair of indices `(i, j)` where `0 <= i < j < nums.length` and `nums[i] > nums[j]`. Given two integers `n` and `k`, return the number of different arrays consisting of numbers from `1` to `n` that have exactly `k` inverse pairs.","solution":"def k_inverse_pairs(n, k): MOD = 10**9 + 7 dp = [[0] * (k + 1) for _ in range(n + 1)] dp[0][0] = 1 for i in range(1, n + 1): for j in range(k + 1): dp[i][j] = dp[i - 1][j] if j > 0: dp[i][j] += dp[i][j - 1] if j >= i: dp[i][j] -= dp[i - 1][j - i] dp[i][j] %= MOD return dp[n][k]"},{"question":"Given an integer array `arr`, write a function to find the maximum sum of a contiguous subarray (containing at least one number). A contiguous subarray is a subarray within `arr` that consists of consecutive elements from `arr`. Use the Kadane\'s Algorithm to achieve the solution effectively. Return the maximum sum obtained from such a subarray.","solution":"def max_subarray_sum(arr): Function to find the maximum sum of a contiguous subarray using Kadane\'s Algorithm. :param arr: List[int] - List of integers :return: int - Maximum sum of a contiguous subarray if not arr: return 0 max_current = max_global = arr[0] for num in arr[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"You are given a list of strings `words` where each string consists of lowercase English letters. You need to concatenate the strings in such a way that the resultant string should be the lexicographically smallest string possible. Return this smallest concatenated string as the result.","solution":"def lexicographically_smallest_concatenation(words): Concatenate the given list of strings in such a way that the resultant string is the lexicographically smallest string possible. Args: words (List[str]): List of strings to concatenate. Returns: str: Lexicographically smallest concatenated string. # Sort the words based on the criteria that the concatenation of two words produces the smaller string sorted_words = sorted(words, key=lambda x: (x*len(words))) return \'\'.join(sorted_words)"},{"question":"You are given an undirected graph represented by an integer `n` which is the number of vertices and a list of `edges` where each edge is a pair of integers representing a connection between two vertices. Write a function to find the size of the largest connected component in the graph. A connected component is defined as a maximal set of vertices such that there is a path between any two vertices in that set. Function signature: ```python def largest_connected_component(n: int, edges: List[List[int]]) -> int: ```","solution":"from typing import List from collections import defaultdict, deque def largest_connected_component(n: int, edges: List[List[int]]) -> int: def bfs(start: int) -> int: queue = deque([start]) visited.add(start) component_size = 0 while queue: node = queue.popleft() component_size += 1 for neighbor in graph[node]: if neighbor not in visited: visited.add(neighbor) queue.append(neighbor) return component_size # Create an adjacency list for the graph graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) largest_size = 0 visited = set() for vertex in range(n): if vertex not in visited: component_size = bfs(vertex) largest_size = max(largest_size, component_size) return largest_size"},{"question":"Given a list of strings `words` and a string `chars`, you need to find the sum of the lengths of all good strings in `words`. A string is considered good if it can be formed by characters from `chars` (each character can only be used once). Return the total length of all good strings. **Example:** ```python Input: words = [\\"cat\\", \\"bt\\", \\"hat\\", \\"tree\\"] chars = \\"atach\\" Output: 6 ``` Explanation: - The string \\"cat\\" can be formed from \\"chars\\" (length 3). - The string \\"hat\\" can be formed from \\"chars\\" (length 3). - The strings \\"bt\\" and \\"tree\\" cannot be formed from \\"chars\\". - Thus, the answer is 3 + 3 = 6. Write a function to implement the above behavior: ```python def countCharacters(words: List[str], chars: str) -> int: # your code here ```","solution":"from typing import List from collections import Counter def countCharacters(words: List[str], chars: str) -> int: Returns the sum of the lengths of all good strings in words. A string is considered good if it can be formed by characters from chars. Each character in chars can only be used once. chars_count = Counter(chars) total_length = 0 for word in words: word_count = Counter(word) if all(word_count[c] <= chars_count[c] for c in word_count): total_length += len(word) return total_length"},{"question":"You are given an integer array `heights` representing the heights of buildings along a street taken in order from left to right. A building is considered a **viewpoint** if no building to its right has a greater or equal height. Return an array of indices representing the positions of all viewpoint buildings.","solution":"def find_viewpoints(heights): Returns an array of indices representing the positions of all viewpoint buildings. n = len(heights) if n == 0: return [] viewpoints = [] max_height = -float(\'inf\') # Traverse the array from right to left for i in range(n-1, -1, -1): if heights[i] > max_height: viewpoints.append(i) max_height = heights[i] return viewpoints[::-1]"},{"question":"You are given an array of integers `arr` and an integer `k`. A sliding window of size `k` is moving from the very left of the array to the very right. You can only see the `k` numbers in the window. Each move, your window slides right by one position. Return the median array of all sliding windows of size `k`. If the median is not an integer, include the decimal point. Note that the median of an array is the middle element when the array is sorted. If the array has an even size, the median is the average of the two middle elements.","solution":"from typing import List from bisect import insort, bisect_left def median_sliding_window(arr: List[int], k: int) -> List[float]: Returns the median array of all sliding windows of size `k`. medians = [] window = sorted(arr[:k]) def get_median(window): mid = len(window) // 2 if len(window) % 2 == 0: return (window[mid - 1] + window[mid]) / 2.0 else: return window[mid] for i in range(len(arr) - k + 1): # Calculate the current median median = get_median(window) medians.append(median) # Remove the element that is sliding out of the window if i + k < len(arr): outgoing = arr[i] incoming = arr[i + k] window.remove(outgoing) insort(window, incoming) return medians"},{"question":"You are given the head node of a singly linked list where each node contains a positive integer value. Write a function to determine whether the linked list is a \\"happy\\" linked list. A linked list is considered \\"happy\\" if the sequence of values it contains forms a \\"happy number.\\" A number is defined as \\"happy\\" if, starting with any positive integer, and repeatedly replacing the number by the sum of the squares of its digits, eventually leads to 1. If the process results in a cycle (i.e., it repeats a number other than 1), then the number is not happy. Your function should return `true` if the linked list is happy, otherwise, return `false`.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def is_happy_number(n): def sum_of_squares(num): return sum(int(digit) ** 2 for digit in str(num)) seen = set() while n != 1 and n not in seen: seen.add(n) n = sum_of_squares(n) return n == 1 def linked_list_to_number(head): num = 0 factor = 1 current = head while current: num += current.val * factor factor *= 10 current = current.next return num def is_happy_linked_list(head): number = linked_list_to_number(head) return is_happy_number(number)"},{"question":"You are given an integer array `nums` and an integer `k`. Define a contiguous subarray of `nums` as \\"good\\" if there are exactly `k` distinct integers in that subarray. Your task is to count the number of \\"good\\" subarrays of `nums`. Return the number of \\"good\\" subarrays in `nums`.","solution":"from collections import defaultdict def count_good_subarrays(nums, k): def at_most_k_distinct(nums, k): count = defaultdict(int) left = 0 result = 0 for right in range(len(nums)): count[nums[right]] += 1 while len(count) > k: count[nums[left]] -= 1 if count[nums[left]] == 0: del count[nums[left]] left += 1 result += right - left + 1 return result return at_most_k_distinct(nums, k) - at_most_k_distinct(nums, k - 1)"},{"question":"Design a function to convert a given string `s` to Snake Case. In Snake Case, all letters are lowercased, and spaces or any punctuations are replaced by underscores (`_`). Implement the function `to_snake_case`: ```python def to_snake_case(s: str) -> str: # Function implementation ``` The function should take the following parameter: - `s` (a string consisting of alphabetical characters, spaces, and punctuations) The function should return: - The string converted to Snake Case. For example: ```python print(to_snake_case(\\"Hello World!\\")) # Output: \\"hello_world\\" print(to_snake_case(\\"Convert to Snake Case.\\")) # Output: \\"convert_to_snake_case\\" ```","solution":"import re def to_snake_case(s: str) -> str: Converts a given string `s` to Snake Case. # Replace all non-alphanumeric characters with underscore s = re.sub(r\'W+\', \'_\', s) # Convert all letters to lower case s = s.lower() # Remove leading and trailing underscores if any s = s.strip(\'_\') return s"},{"question":"You are given an array `nums` of integers and an integer `k`. Your task is to determine whether the array contains two distinct indices `i` and `j` such that `nums[i] == nums[j]` and the absolute difference between `i` and `j` is at most `k`. If such elements exist, return `true`; otherwise, return `false`. For example, given the array `nums = [1, 2, 3, 1, 2, 3]` and `k = 2`, the function should return `false` because although the array contains duplicates, the indices of the duplicated elements are more than `k` apart. However, if `k` was `3`, the function should return `true` because `nums[3] == nums[0]` satisfies the condition with `|3-0| = 3`.","solution":"def contains_nearby_duplicate(nums, k): Determines if the array contains two distinct indices i and j such that nums[i] == nums[j] and the absolute difference between i and j is at most k. :param nums: List[int] - Array of integers :param k: int - Maximum allowed index difference :return: bool - True if such elements exist, False otherwise index_map = {} for i, num in enumerate(nums): if num in index_map and i - index_map[num] <= k: return True index_map[num] = i return False"},{"question":"You are given a 2D list `logs` where `logs[i] = [user_id, action_type]` represents the actions performed by users. There are three types of actions: `\\"login\\"`, `\\"logout\\"`, and `\\"purchase\\"`. Each user can perform any number of actions in any order, but a `purchase` is only valid if it is made between a `login` and a subsequent `logout`. Write a function to find the number of valid `purchase` actions for each user. Return a dictionary where the keys are `user_id`s and the values are the count of valid `purchase` actions for that user. If a user has no valid `purchase` actions, they should still appear in the dictionary with a count of `0`.","solution":"def count_valid_purchases(logs): Returns a dictionary where keys are user_id and values are the count of valid \'purchase\' actions for that user. users = {} user_sessions = {} for user_id, action_type in logs: if user_id not in users: users[user_id] = 0 user_sessions[user_id] = {\'logged_in\': False, \'valid_purchases\': 0} if action_type == \\"login\\": user_sessions[user_id][\'logged_in\'] = True elif action_type == \\"logout\\": user_sessions[user_id][\'logged_in\'] = False elif action_type == \\"purchase\\": if user_sessions[user_id][\'logged_in\']: users[user_id] += 1 return users"},{"question":"You are given a binary tree in which each node holds a value between 1 and 9, inclusive. You need to find all root-to-leaf paths where each path\'s sum of node values equals a given value `targetSum`. Each path should be returned as a list of the node values, in the order from the root to the leaf. If there are multiple paths that yield the same sum, return all of them. If no such path exists, return an empty list. Write a function `findPaths` that takes the root of the binary tree and an integer `targetSum`, and returns a list of lists of integers, where each list represents a root-to-leaf path with the sum equal to `targetSum`.","solution":"from typing import List, Optional class TreeNode: def __init__(self, val: int = 0, left: Optional[\'TreeNode\'] = None, right: Optional[\'TreeNode\'] = None): self.val = val self.left = left self.right = right def findPaths(root: Optional[TreeNode], targetSum: int) -> List[List[int]]: def dfs(node: Optional[TreeNode], currentSum: int, path: List[int], paths: List[List[int]]): if not node: return currentSum += node.val path.append(node.val) if not node.left and not node.right and currentSum == targetSum: paths.append(list(path)) else: dfs(node.left, currentSum, path, paths) dfs(node.right, currentSum, path, paths) path.pop() paths = [] dfs(root, 0, [], paths) return paths"},{"question":"You are given an array of integers `arr` and an integer `k`. Your task is to rearrange the elements of `arr` such that every element at index `i` is replaced by the product of the previous `k` elements before it in the array (consider 1 as the initial product for the first `k` elements). If there are fewer than `k` elements before it, use only the available elements. Return the modified array after applying this transformation. For example, if `arr = [1, 2, 3, 4, 5]` and `k = 2`, the resulting array would be `[1, 1, 2, 6, 12]`.","solution":"def replace_with_product_of_previous_k(arr, k): Replaces every element at index i in arr with the product of the previous k elements before it. If there are fewer than k elements before it, use only the available elements. if not arr or k <= 0: return arr n = len(arr) result = [0] * n for i in range(n): product = 1 for j in range(max(0, i - k), i): product *= arr[j] result[i] = product return result"},{"question":"You are given a grid of integers `grid` with `m` rows and `n` columns. Each cell in the grid contains a value representing the altitude at that point. You are also given two points, `start` and `end`, which are coordinates on this grid. You need to find the path from `start` to `end` such that the maximum altitude difference between any two consecutive points on the path is minimized. The path can move horizontally or vertically to adjacent cells. Return the minimum possible value of the maximum altitude difference for any path from `start` to `end`. For example, the grid below and the coordinates `start = (0, 0)` and `end = (2, 2)`: ``` grid = [ [1, 3, 5], [4, 5, 6], [7, 8, 9] ] ``` One possible path would be (0,0) -> (0,1) -> (1,1) -> (2,1) -> (2,2). The altitude differences along this path are: |3-1| = 2, |5-3| = 2, |8-5| = 3, |9-8| = 1. The maximum altitude difference for this path is 3. You need to find the path with the smallest possible maximum altitude difference. Return the minimum of those maximum differences.","solution":"import heapq def minimum_max_difference(grid, start, end): Returns the minimum possible value of the maximum altitude difference for any path from start to end in the grid. grid: List[List[int]], a 2D list representing the grid. start: Tuple[int, int], the starting coordinate. end: Tuple[int, int], the ending coordinate. m, n = len(grid), len(grid[0]) directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] def valid(row, col): return 0 <= row < m and 0 <= col < n min_heap = [(0, start)] max_diff = [[float(\'inf\')] * n for _ in range(m)] max_diff[start[0]][start[1]] = 0 while min_heap: current_diff, (x, y) = heapq.heappop(min_heap) if (x, y) == end: return current_diff for dx, dy in directions: nx, ny = x + dx, y + dy if valid(nx, ny): next_diff = max(current_diff, abs(grid[nx][ny] - grid[x][y])) if next_diff < max_diff[nx][ny]: max_diff[nx][ny] = next_diff heapq.heappush(min_heap, (next_diff, (nx, ny))) return -1 # should never reach here given the problem constraints"},{"question":"The CEO of a tech company wants to understand the average productivity of their employees. Each employee\'s daily productivity is recorded in an integer array `productivity`. The company wants to find the maximum average productivity of any contiguous subarray of a specified length `k`, where `k` is a positive integer and `k` is not greater than the length of the productivity array. Write a function that computes and returns the maximum average productivity of any contiguous subarray of length `k`.","solution":"def max_average_productivity(productivity, k): Computes the maximum average productivity of any contiguous subarray of length k. :param productivity: List[int] - List of integers representing daily productivity of employees. :param k: int - The length of the subarray to consider. :return: float - The maximum average productivity of any contiguous subarray of length k. if k <= 0 or k > len(productivity): raise ValueError(\\"k must be a positive integer and not greater than the length of the productivity array.\\") current_sum = sum(productivity[:k]) max_sum = current_sum for i in range(k, len(productivity)): current_sum = current_sum - productivity[i - k] + productivity[i] if current_sum > max_sum: max_sum = current_sum return max_sum / k"},{"question":"A web application provides access to various modules through a hierarchical permission system. You are given a list of `roles` indicating the permissions hierarchy, where `roles[i] = [managerRole, subRole]` means `managerRole` manages the `subRole`. You are also provided a list of `users` where `users[i] = [userName, role]` indicates that the user `userName` has the `role` role. Your task is to implement the function `getSubPermissionUsers(managerRole)` which returns a list of all users directly or indirectly managed by the `managerRole`. If no users are managed by `managerRole`, return an empty list. The order of the returned list does not matter.","solution":"def getSubPermissionUsers(managerRole, roles, users): from collections import defaultdict, deque # Build the role hierarchy role_hierarchy = defaultdict(list) for manager, sub in roles: role_hierarchy[manager].append(sub) # Initialize a queue for BFS queue = deque([managerRole]) all_sub_roles = set() # Perform BFS to get all sub-roles managed by managerRole while queue: current_role = queue.popleft() for sub_role in role_hierarchy[current_role]: if sub_role not in all_sub_roles: all_sub_roles.add(sub_role) queue.append(sub_role) # Collect all users who are in the collected sub-roles result_users = [] for user, role in users: if role in all_sub_roles: result_users.append(user) return result_users"},{"question":"You are given a list of course pairs `prerequisites` where `prerequisites[i] = [ai, bi]` indicates that you must take course `bi` before course `ai`. There are a total of `numCourses` courses you need to take, numbered from `0` to `numCourses - 1`. Return _true_ if you can finish all courses, otherwise return _false_.","solution":"from typing import List def can_finish(numCourses: int, prerequisites: List[List[int]]) -> bool: from collections import defaultdict, deque # Create a graph representation of the prerequisites graph = defaultdict(list) in_degree = [0] * numCourses # Build the graph and count the in-degree for each course for dest, src in prerequisites: graph[src].append(dest) in_degree[dest] += 1 # Initialize a queue with courses that have no prerequisites queue = deque([i for i in range(numCourses) if in_degree[i] == 0]) count = 0 while queue: course = queue.popleft() count += 1 for neighbor in graph[course]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) # If count of courses processed equals the total number of courses, return True return count == numCourses"},{"question":"Given a linked list, rotate the linked list to the right by `k` places. The linked list is defined by its `Node` structure, where each node contains an integer value and a reference to the next node in the list. Assume `k` is non-negative. Return the head of the rotated linked list after applying the right rotation by `k` places. The rotation rule works as follows: 1. Moving the last node to be the first node of the list counts as one right rotation. 2. You have to minimize the total number of operations to achieve the desired rotation. For example, if the linked list is `1 -> 2 -> 3 -> 4 -> 5` and `k = 2`, the list after rotation will be `4 -> 5 -> 1 -> 2 -> 3`.","solution":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def rotateRight(head, k): if not head or not head.next or k == 0: return head # Compute the length of the list and make it circular. old_tail = head length = 1 while old_tail.next: old_tail = old_tail.next length += 1 old_tail.next = head # make it circular # Find the new tail after rotation. k = k % length new_tail = head for _ in range(length - k - 1): new_tail = new_tail.next new_head = new_tail.next # Break the circular list. new_tail.next = None return new_head"},{"question":"Given an array of integers `nums`, you are tasked with finding the **next greater element** for each element in the array. The **next greater element** for an element `x` is the first greater element on the right side of `x` in the array. If there is no greater element for `x`, then the **next greater element** is `-1`. Return an array where each element at index `i` contains the next greater element for the element at `nums[i]`.","solution":"def next_greater_elements(nums): Given an array of integers, find the next greater element for each element in the array. result = [-1] * len(nums) stack = [] for i, num in enumerate(nums): while stack and nums[stack[-1]] < num: result[stack.pop()] = num stack.append(i) return result"},{"question":"You are given an array of integers `arr` and an integer `k`. Your task is to rearrange the elements of `arr` such that every `k` consecutive numbers follow a pattern of increasing and decreasing order. Specifically, every consecutive segment of `k` numbers in `arr` should start with the largest number and then each next number should be smaller than the previous one, and then the pattern should repeat for the next segment of `k` numbers. Return the modified array. For example, if `arr = [10, 5, 20, 7, 8, 30, 15, 18]` and `k = 3`, the output should be `[20, 10, 5, 30, 18, 15,...]`.","solution":"def rearrange_array(arr, k): Rearrange the elements of arr such that every k consecutive numbers follow a pattern where they are in decreasing order. n = len(arr) for i in range(0, n, k): segment = arr[i:i+k] arr[i:i+k] = sorted(segment, reverse=True) return arr"},{"question":"Given a binary tree, your task is to find the length of the longest path which comprises nodes connected in lexicographical order (that is, each node\'s value is greater than or equal to the previous node\'s value in the path). The path can start and end at any node in the tree. _Input_: - A pointer to the root node of a binary tree where each node has an integer value. _Output_: - Return an integer denoting the length of the longest lexicographical path in the tree. Example: ``` Input: 2 / 1 3 / 4 5 Output: 3 Explanation: The longest path is 3 -> 4 -> 5. ```","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def longest_lexicographical_path(root: TreeNode) -> int: def dfs(node, parent_val): if not node: return 0 left_length = dfs(node.left, node.val) right_length = dfs(node.right, node.val) if node.val >= parent_val: return max(left_length, right_length) + 1 return 0 def longest_path_from_node(node): if not node: return 0 left_length = longest_path_from_node(node.left) right_length = longest_path_from_node(node.right) current_length = dfs(node, float(\'-inf\')) return max(left_length, right_length, current_length) return longest_path_from_node(root)"},{"question":"Given an array of integers `nums`, determine whether there is a non-empty subsequence that sums to zero. A subsequence is defined as a sequence derived by deleting some or no elements from the array without changing the order of the remaining elements. Return `true` if such a subsequence exists, otherwise return `false`.","solution":"def has_zero_sum_subsequence(nums): Determines if there is a non-empty subsequence that sums to zero. Parameters: nums (list of int): The list of integers. Returns: bool: True if there is a non-empty subsequence that sums to zero, otherwise False. # Initialize a set to keep track of prefix sums prefix_sums = set() current_sum = 0 for num in nums: current_sum += num # Check if the current prefix sum or zero exists in the set if current_sum == 0 or current_sum in prefix_sums: return True # Add current prefix sum to the set prefix_sums.add(current_sum) return False"},{"question":"You are given an undirected graph represented as an adjacency list, where each node is labeled with a unique value. Each edge between two nodes has a certain weight. Implement an algorithm to find the **minimum spanning tree** (MST) of the graph using Kruskal\'s algorithm. The minimum spanning tree is a subset of the edges that connects all the vertices together, without any cycles and with the minimum possible total edge weight. You should implement the `Kruskal` class: * `Kruskal(int n, int[][] edges)` Initializes the object with `n` nodes and a list of edges where `edges[i] = [u, v, w]` represents an edge between nodes `u` and `v` with weight `w`. * `List<int[]> mst()` Returns a list of edges that forms the minimum spanning tree. Each edge should be represented as `[u, v, w]`. Ensure that the resulting minimum spanning tree spans all nodes in the graph, or return an empty list if such a tree cannot be formed.","solution":"class Kruskal: def __init__(self, n, edges): self.n = n self.edges = edges def find(self, parent, i): if parent[i] == i: return i return self.find(parent, parent[i]) def union(self, parent, rank, x, y): root_x = self.find(parent, x) root_y = self.find(parent, y) if rank[root_x] < rank[root_y]: parent[root_x] = root_y elif rank[root_x] > rank[root_y]: parent[root_y] = root_x else: parent[root_y] = root_x rank[root_x] += 1 def mst(self): # Sort edges based on their weight self.edges.sort(key=lambda x: x[2]) parent = list(range(self.n)) rank = [0] * self.n mst_edges = [] edge_count = 0 index = 0 while edge_count < self.n - 1 and index < len(self.edges): u, v, w = self.edges[index] index += 1 root_u = self.find(parent, u) root_v = self.find(parent, v) if root_u != root_v: edge_count += 1 mst_edges.append([u, v, w]) self.union(parent, rank, root_u, root_v) # If we do not have (n-1) edges, return empty list because it means we haven\'t connected all nodes if edge_count != self.n - 1: return [] return mst_edges"},{"question":"You are given an `m x n` grid filled with non-negative integers representing the height of each cell. The \\"peak\\" of the grid is defined as the cell with the maximum height. Define the \\"water flow\\" from cell (i, j) as the longest increasing path of cells from (i, j) to the peak, where movement is allowed to the four adjacent cells (left, right, up, down) only if the adjacent cell has a higher height. Write a function that finds the longest increasing path in the grid starting from any cell and returns its length.","solution":"def longestIncreasingPath(matrix): if not matrix or not matrix[0]: return 0 m, n = len(matrix), len(matrix[0]) cache = [[-1] * n for _ in range(m)] directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] def dfs(i, j): if cache[i][j] != -1: return cache[i][j] max_length = 1 for di, dj in directions: ni, nj = i + di, j + dj if 0 <= ni < m and 0 <= nj < n and matrix[ni][nj] > matrix[i][j]: max_length = max(max_length, 1 + dfs(ni, nj)) cache[i][j] = max_length return max_length max_path = 0 for i in range(m): for j in range(n): max_path = max(max_path, dfs(i, j)) return max_path"},{"question":"You are given an undirected graph represented as an adjacency list, where each node is labeled uniquely from `1` to `n`. Implement a function to determine if the graph is bipartite. A graph is bipartite if you can split its set of nodes into two sets A and B such that every edge connects a node in set A to a node in set B. Return _`true` if the given graph is bipartite, otherwise return `false`._","solution":"from collections import deque def is_bipartite(graph): Determines if the given undirected graph is bipartite. Args: graph (dict): The adjacency list representing the graph. Keys are unique node labels, values are lists of neighboring node labels. Returns: bool: True if the graph is bipartite, False otherwise. color = {} for node in graph: if node not in color: queue = deque([node]) color[node] = 0 # Start coloring this component with color 0 while queue: current_node = queue.popleft() current_color = color[current_node] for neighbor in graph[current_node]: if neighbor not in color: color[neighbor] = 1 - current_color queue.append(neighbor) elif color[neighbor] == current_color: return False return True"},{"question":"A company has a network of computers connected by cables. The network is represented as a graph with `n` nodes, where each node represents a computer and each edge represents a cable connecting two computers with a certain data transfer time. You are given a 2D integer array `connections` where `connections[i] = [computer1i, computer2i, timei]` indicates that there is a cable connecting `computer1i` and `computer2i` with a data transfer time of `timei`. Find the minimum data transfer time to connect all computers in such a way that every computer is reachable from every other computer. If it is impossible to connect all the computers, return `-1`.","solution":"def minimum_cost_to_connect_computers(n, connections): Calculate the minimum data transfer time to connect all computers. :param n: Number of computers :param connections: List of connections where each connection is represented as [computer1, computer2, time] :return: Minimum data transfer time to connect all computers or -1 if it is impossible parent = list(range(n)) rank = [0] * n def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: if rank[rootX] > rank[rootY]: parent[rootY] = rootX elif rank[rootX] < rank[rootY]: parent[rootX] = rootY else: parent[rootY] = rootX rank[rootX] += 1 return True return False connections.sort(key=lambda x: x[2]) total_cost = 0 edges_used = 0 for u, v, weight in connections: if union(u-1, v-1): total_cost += weight edges_used += 1 if edges_used == n - 1: return total_cost return -1 if edges_used < n - 1 else total_cost"},{"question":"Given a string `s`, find the length of the **longest substring** that contains at most `k` distinct characters. Write a function that accepts the string `s` and the integer `k` as its parameters and returns the length of the longest substring with at most `k` distinct characters. You need to achieve this in linear time using a sliding window approach.","solution":"def length_of_longest_substring_k_distinct(s, k): Returns the length of the longest substring with at most k distinct characters. from collections import defaultdict # Validate inputs if k == 0 or not s: return 0 left, right = 0, 0 max_length = 0 char_count = defaultdict(int) while right < len(s): char_count[s[right]] += 1 while len(char_count) > k: char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 max_length = max(max_length, right - left + 1) right += 1 return max_length"},{"question":"Given a string `s` consisting of only characters \'a\' and \'b\', you can perform the following operations: 1. Choose any two adjacent characters and remove them if they are different. 2. The goal is to transform the string into an empty string by repeatedly applying the above operation as many times as possible. Return a boolean indicating whether it is possible to remove all characters from the string `s`.","solution":"def can_transform_to_empty_string(s): Determines whether it is possible to transform the given string into an empty string by repeatedly removing any two adjacent characters if they are different. :param s: A string of characters \'a\' and \'b\' :return: True if it is possible to transform the string into an empty string, False otherwise. # Initialize an empty stack stack = [] # Iterate through each character in the string for char in s: # If stack is not empty and the top of the stack is different from the current character, # it means we can remove this pair, so we pop the top of the stack. if stack and stack[-1] != char: stack.pop() else: # Otherwise, we push the current character to the stack stack.append(char) # If the stack is empty, it means the string can be reduced to an empty string return len(stack) == 0"},{"question":"You are given a string `s` consisting of lowercase English letters. You are allowed to perform unlimited operations where in each operation, you can choose any character in the string and remove it. Your goal is to create the lexicographically smallest possible string by performing these operations. Return the resulting string.","solution":"def lexicographically_smallest_string(s): Given a string s consisting of lowercase English letters, this function returns the lexicographically smallest string by removing all characters. # Since we can remove all characters as many times as we want, # the lexicographically smallest string is an empty string. return \'\'"},{"question":"You have a rectangular matrix of integers `matrix` where each element represents the height of a cell. Water is poured onto the cells such that the matrix becomes a series of depressions that can trap water. Write an algorithm to calculate the total amount of water that can be trapped after it rains. Water can flow from a cell to its four adjacent cells if the adjacent cell\'s height is lower or equal. A cell is considered to be part of a depression if it can trap water. Return _the **total volume** of water trapped_ in the matrix.","solution":"import heapq def trap_rain_water(matrix): if not matrix or not matrix[0]: return 0 n, m = len(matrix), len(matrix[0]) visited = [[False] * m for _ in range(n)] heap = [] # Push all the cells on the border into the heap for i in range(n): heapq.heappush(heap, (matrix[i][0], i, 0)) heapq.heappush(heap, (matrix[i][m-1], i, m-1)) visited[i][0] = visited[i][m-1] = True for j in range(m): heapq.heappush(heap, (matrix[0][j], 0, j)) heapq.heappush(heap, (matrix[n-1][j], n-1, j)) visited[0][j] = visited[n-1][j] = True directions = [(0, 1), (0, -1), (1, 0), (-1, 0)] water_trapped = 0 while heap: height, x, y = heapq.heappop(heap) for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny]: visited[nx][ny] = True water_trapped += max(0, height - matrix[nx][ny]) heapq.heappush(heap, (max(height, matrix[nx][ny]), nx, ny)) return water_trapped"},{"question":"Given an integer array `nums`, return the number of **inversions** required to sort the array in non-decreasing order. An **inversion** is a pair of elements `(nums[i], nums[j])` such that `i < j` and `nums[i] > nums[j]`. Implement the function `int countInversions(int[] nums)` that returns the count of such inversions.","solution":"def countInversions(nums): Returns the number of inversions required to sort the array in non-decreasing order. Args: nums (List[int]): The list of integers. Returns: int: The count of inversions. def merge_sort(arr, temp_arr, left, right): if left >= right: return 0 mid = (left + right) // 2 inversions = merge_sort(arr, temp_arr, left, mid) inversions += merge_sort(arr, temp_arr, mid + 1, right) inversions += merge(arr, temp_arr, left, mid, right) return inversions def merge(arr, temp_arr, left, mid, right): i = left j = mid + 1 k = left inversions = 0 while i <= mid and j <= right: if arr[i] <= arr[j]: temp_arr[k] = arr[i] i += 1 else: temp_arr[k] = arr[j] inversions += (mid - i + 1) j += 1 k += 1 while i <= mid: temp_arr[k] = arr[i] i += 1 k += 1 while j <= right: temp_arr[k] = arr[j] j += 1 k += 1 for i in range(left, right + 1): arr[i] = temp_arr[i] return inversions temp_arr = [0] * len(nums) return merge_sort(nums, temp_arr, 0, len(nums) - 1)"},{"question":"You are tasked with organizing a series of concerts for a music festival. Each concert has a starting and ending time and is represented by an interval [start, end]. You are given a list of `n` intervals where each interval [start, end] represents a concert. Two concerts cannot be scheduled at the same time, i.e., their intervals cannot overlap. Your objective is to find the maximum number of non-overlapping concerts you can attend. Return _the maximum number of non-overlapping concerts you can attend_.","solution":"def max_non_overlapping_concerts(concerts): Returns the maximum number of non-overlapping concerts. concert list[[int, int]]: A list of intervals [start, end] representing the concerts Returns ------- int: The maximum number of non-overlapping concerts if not concerts: return 0 # Sort the concerts by their ending time concerts.sort(key=lambda x: x[1]) max_concerts = 0 last_end_time = float(\'-inf\') for start, end in concerts: if start >= last_end_time: max_concerts += 1 last_end_time = end return max_concerts"},{"question":"A **Run-Length Encoded (RLE)** string is a way to represent a string where each group of consecutive repeating characters in the original string is represented by the character followed by the number of repetitions. For example, the string `aaabbcccc` would be represented as `a3b2c4`. Given an RLE string and a number `k`, return the `k`-th character in the original string. If `k` is out of bounds, return an empty string.","solution":"def rle_kth_character(rle_string, k): Given a Run-Length Encoded (RLE) string and a number k, return the k-th character in the original string. If k is out of bounds, return an empty string. original_length = 0 i = 0 n = len(rle_string) # Decode RLE string to find the k-th character while i < n: char = rle_string[i] i += 1 count_str = \'\' # Read the number associated with the character while i < n and rle_string[i].isdigit(): count_str += rle_string[i] i += 1 count = int(count_str) original_length += count # Check if k-th character is within this segment if k <= original_length: return char return \\"\\" # Example usage: # rle_string = \\"a3b2c4\\" # k = 5 # print(rle_kth_character(rle_string, k)) # Output: \\"b\\""},{"question":"Implement a function to check whether a given string is a valid palindrome considering alphanumeric characters and ignoring cases. For example, \\"A man, a plan, a canal: Panama\\" is a valid palindrome, while \\"race a car\\" is not. Your function should return a boolean value: `true` if the input string is a palindrome and `false` otherwise.","solution":"def is_palindrome(s): Checks whether the given string is a valid palindrome considering only alphanumeric characters and ignoring cases. :param s: A string to be checked for palindrome property. :return: True if the string is a palindrome, False otherwise. filtered_chars = [char.lower() for char in s if char.isalnum()] return filtered_chars == filtered_chars[::-1]"},{"question":"You are given an integer array `nums` and a **positive** integer `target`. You need to determine the number of **unique** triplets `(a, b, c)` in the array such that `a + b + c = target`. Each triplet should be ordered such that `a <= b <= c` and should be returned in one line as a space-separated string. Return _the number of unique triplets_.","solution":"from typing import List def count_unique_triplets(nums: List[int], target: int) -> int: Returns the number of unique triplets (a, b, c) in the array such that a + b + c = target and a <= b <= c. nums.sort() triplet_set = set() n = len(nums) for i in range(n - 2): j = i + 1 k = n - 1 while j < k: total = nums[i] + nums[j] + nums[k] if total == target: triplet_set.add((nums[i], nums[j], nums[k])) j += 1 k -= 1 elif total < target: j += 1 else: k -= 1 return len(triplet_set)"},{"question":"You are given an integer array `nums` consisting of `n` elements, where each element represents the score of a player in a game. You need to form groups of players such that the sum of scores within each group is as close as possible to a target score `T`. The score of a group is considered to be the sum of the scores of its members. Your task is to determine the minimum number of groups required to partition the players such that the sum of any group\'s score does not exceed `T`. Return the minimum number of groups needed.","solution":"def min_groups(nums, T): Returns the minimum number of groups required to partition the players such that the sum of scores within each group is as close as possible to a target score T. nums.sort(reverse=True) groups = [] for score in nums: for group in groups: if sum(group) + score <= T: group.append(score) break else: groups.append([score]) return len(groups)"},{"question":"You are given a list of `jobs`, where each job is represented as a pair of integers `[start, end]` indicating the start time and end time of the job. It is guaranteed that the jobs are sorted by their end time. You need to find the maximum number of non-overlapping jobs that can be scheduled. Example: Input: `[[1, 3], [2, 5], [3, 9], [6, 8]]` Output: `2`","solution":"def max_non_overlapping_jobs(jobs): Given a list of jobs where each job is represented by [start, end] and is sorted by their end time, find the maximum number of non-overlapping jobs that can be scheduled. if not jobs: return 0 count = 1 last_end_time = jobs[0][1] for i in range(1, len(jobs)): if jobs[i][0] >= last_end_time: count += 1 last_end_time = jobs[i][1] return count"},{"question":"You are given a non-negative integer represented as a non-empty array of digits, where the most significant digit is at the head of the array. Each element in the array contains a single digit. Implement a function that increments the integer by one and returns the resulting array of digits. Make sure your solution handles the cases where you have a carry from the last digit. Example: ``` Input: [1,2,3] Output: [1,2,4] ``` Example: ``` Input: [9,9,9] Output: [1,0,0,0] ```","solution":"def plus_one(digits): Increments the non-negative integer represented by the list of digits by one and returns the resulting list of digits. n = len(digits) carry = 1 # Initialize carry as 1 since we are adding one to the number for i in range(n - 1, -1, -1): new_digit = digits[i] + carry if new_digit == 10: digits[i] = 0 else: digits[i] = new_digit carry = 0 break if carry == 1: digits.insert(0, 1) return digits"},{"question":"You are given an integer array `nums` and an integer `k`. Your task is to determine whether it is possible to rearrange the array `nums` so that the difference between all adjacent elements is at most `k`. If it is possible, return the rearranged array; otherwise, return an empty array. The difference between two integers `a` and `b` is defined as `|a - b|`.","solution":"def rearrange_array(nums, k): Rearranges `nums` so that the difference between all adjacent elements is at most `k`. Returns the rearranged array if possible, otherwise returns an empty array. nums.sort() result = [nums[0]] for i in range(1, len(nums)): if abs(nums[i] - result[-1]) > k: return [] result.append(nums[i]) return result"},{"question":"A palindromic number is a number that remains the same when its digits are reversed. For example, `121` is a palindromic number as it remains `121` after reversing, while `123` is not a palindromic number as it becomes `321` after reversing. Given an integer `num`, find the closest palindromic number. If there are multiple possibilities, return the smaller number. If the number is already a palindrome, return it as is. Note that the return value must be a positive integer.","solution":"def is_palindrome(n): Helper function to check if a number is a palindrome. return str(n) == str(n)[::-1] def closest_palindromic_number(num): Returns the closest palindromic number to the given number. If the number is already a palindrome, it returns the number itself. if is_palindrome(num): return num lower, higher = num - 1, num + 1 while True: if lower > 0 and is_palindrome(lower): return lower if is_palindrome(higher): return higher lower -= 1 higher += 1"},{"question":"Given an array of integers `arr`, return the sum of elements within a given range for each query. A query is represented as a pair of integers `[left, right]` where `left` and `right` are the indices of the array. Implement a function that receives `arr` and an array of queries, and returns an array of the sums for each query range. Example: - Input: `arr = [1, 2, 3, 4, 5]`, `queries = [[0, 2], [1, 3], [2, 4]]` - Output: `[6, 9, 12]` Explanation: - The sum of elements from index `0` to `2` is `1 + 2 + 3 = 6`. - The sum of elements from index `1` to `3` is `2 + 3 + 4 = 9`. - The sum of elements from index `2` to `4` is `3 + 4 + 5 = 12`.","solution":"def range_sum(arr, queries): Returns an array of sums for each query range in arr. result = [] for left, right in queries: result.append(sum(arr[left:right+1])) return result"},{"question":"You are given a binary tree, and you need to determine the `kth` smallest element in the tree. The `kth` smallest element refers to the element that would appear in the `kth` position if the tree\'s elements were sorted in ascending order. The binary tree is represented by its root node `root`, and each node has an integer value. You may assume that `k` is always valid, i.e., `1 ≤ k ≤ number of elements in the tree`. Return the `kth` smallest element from the binary tree. You need to implement the following function: ``` int kthSmallest(TreeNode* root, int k); ``` Where: - `root`: A pointer to the root node of the binary tree. - `k`: An integer representing the index of the smallest element to find. Note: - The function should complete in `O(H + k)` time complexity, where `H` is the height of the tree. - You may assume that values in the tree are unique.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def kthSmallest(root, k): Finds the kth smallest element in the binary tree. :param root: TreeNode, the root of the binary tree :param k: int, the index of the smallest element to find (1-based index) :return: int, the kth smallest element def inorder_traversal(node): if not node: return [] return inorder_traversal(node.left) + [node.val] + inorder_traversal(node.right) sorted_elements = inorder_traversal(root) return sorted_elements[k - 1]"},{"question":"You are given a string `s` and an integer `k`. The task is to determine if you can rearrange the characters in the string such that there are at most `k` distinct characters between any two identical characters. If possible, return one valid arrangement. If not, return an empty string. For example, given `s = \\"aabbcc\\"` and `k = 2`, a valid rearrangement would be `\\"abacbc\\"`. If no such arrangement exists, return an empty string.","solution":"from collections import Counter import heapq def rearrange_string(s, k): if k <= 1: return s counter = Counter(s) max_heap = [(-value, key) for key, value in counter.items()] heapq.heapify(max_heap) result = [] queue = [] while max_heap: cnt, ch = heapq.heappop(max_heap) result.append(ch) queue.append((ch, cnt + 1)) if len(queue) < k: continue ch_waiting, cnt_waiting = queue.pop(0) if -cnt_waiting > 0: heapq.heappush(max_heap, (cnt_waiting, ch_waiting)) return \\"\\".join(result) if len(result) == len(s) else \\"\\""},{"question":"Given an array of integers `nums` representing the population counts of different cities, find the city that has the minimum population and return its index. If there are multiple cities with the same minimum population, return the smallest index. Assume the population counts are non-negative integers. **Example:** ``` Input: nums = [5, 3, 9, 3, 2, 8, 2] Output: 4 Explanation: The minimum population is 2, which occurs at indices 4 and 6. The smallest index is 4. ```","solution":"def min_population_index(nums): Returns the index of the city with the minimum population. If there are multiple cities with the same minimum population, returns the smallest index. if not nums: return -1 # In case the input list is empty min_population = min(nums) return nums.index(min_population)"},{"question":"Given an integer array `height` representing the heights of poles standing in a line, calculate the amount of water that can be trapped between the poles after it rains. Note that the leftmost and rightmost poles do not trap any water since water spills off the edges. Water can only be trapped if there are taller poles to the left and right of a given pole, forming a container. Return the total amount of trapped water units.","solution":"def trap(height): Given an integer array representing the heights of poles, calculate the amount of water that can be trapped. if not height or len(height) < 3: return 0 left = 0 right = len(height) - 1 left_max = height[left] right_max = height[right] trapped_water = 0 while left < right: if height[left] < height[right]: left += 1 left_max = max(left_max, height[left]) trapped_water += left_max - height[left] else: right -= 1 right_max = max(right_max, height[right]) trapped_water += right_max - height[right] return trapped_water"},{"question":"You are given an array of integers `nums` and an integer `k`. Your task is to construct a string by repeating each number in `nums` exactly `k` times, placing a hyphen `-` between consecutive numbers, but excluding the hyphen after the last number in the string. If `k` is zero or the array is empty, return an empty string. Return _the constructed string based on these rules_.","solution":"def construct_repeated_string(nums, k): Constructs a string by repeating each number in `nums` exactly `k` times, placing a hyphen \'-\' between consecutive numbers, but excluding the hyphen after the last number in the string. Parameters: nums (list of int): The list of numbers to be repeated. k (int): The number of times each number in the list needs to be repeated. Returns: str: The constructed string based on the given rules. if k == 0 or not nums: return \\"\\" result_parts = [] for num in nums: repeated_part = str(num) * k result_parts.append(repeated_part) return \'-\'.join(result_parts)"},{"question":"You are given an integer array `nums` and an integer `k`. The array `nums` is sorted in ascending order. Your task is to find the `k` closest elements to a given integer `x` in the array. The result should also be sorted in ascending order. If there is a tie, the smaller elements are always preferred. Return _a list of the `k` closest elements to `x` sorted in ascending order_.","solution":"def find_closest_elements(nums, k, x): Returns the k closest elements to x in the sorted array nums. If there is a tie, the smaller elements are always preferred. The result is also sorted in ascending order. left, right = 0, len(nums) - 1 # Narrow down the window to k elements while right - left >= k: if abs(nums[left] - x) > abs(nums[right] - x): left += 1 else: right -= 1 # Return the sliced sorted array from left to left+k return nums[left:left + k]"},{"question":"Given a string `expression` that contains only digits `0-9`, `+`, `-`, and `.` (representing decimal point), implement a function to evaluate and return the result of the arithmetic expression with correct operator precedence (addition and subtraction only). The input string will be non-empty and will contain well-formed expressions.","solution":"def evaluate_expression(expression): Evaluates a string expression containing only digits, \'+\', \'-\', and \'.\'. Only handles addition and subtraction with correct precedence. tokens = [] num = \\"\\" # Tokenize the string for char in expression: if char in \'0123456789.\': num += char elif char in \'+-\': if num: tokens.append(float(num)) num = \\"\\" tokens.append(char) if num: tokens.append(float(num)) # Evaluate the expression result = tokens[0] i = 1 while i < len(tokens): op = tokens[i] num = tokens[i + 1] if op == \'+\': result += num elif op == \'-\': result -= num i += 2 return result"},{"question":"You are given a list of integers `arr` and another integer `d`. A **distance-`d` afraid** subarray of `arr` is a subarray in which the maximum difference between any two elements is less than or equal to `d`. Write a function `findMaxAfraidSubarrayLength(arr: List[int], d: int) -> int` to find the length of the longest **distance-`d` afraid** subarray. If there are multiple longest subarrays, return the length of any one of them. The subarray must be non-empty.","solution":"from typing import List def findMaxAfraidSubarrayLength(arr: List[int], d: int) -> int: if not arr: return 0 max_length = 1 start = 0 for end in range(1, len(arr)): min_value = min(arr[start:end + 1]) max_value = max(arr[start:end + 1]) if max_value - min_value <= d: max_length = max(max_length, end - start + 1) else: start += 1 return max_length"},{"question":"You are given a **0-indexed** integer array `ratings`, where `ratings[i]` represents the quality rating of the `i-th` employee. Each employee must receive at least one recognition star. Employees with a higher rating than their immediate neighbors should receive more stars than their neighbors. Return _the **minimum** number of recognition stars required to distribute among all the employees adhering to these constraints._","solution":"def min_recognition_stars(ratings): Returns the minimum number of recognition stars required to distribute among all the employees. n = len(ratings) if n == 0: return 0 stars = [1] * n # First pass: Traverse from left to right to ensure right higher rating gets more stars than the left neighbor for i in range(1, n): if ratings[i] > ratings[i - 1]: stars[i] = stars[i - 1] + 1 # Second pass: Traverse from right to left to ensure left higher rating gets more stars than the right neighbor for i in range(n - 2, -1, -1): if ratings[i] > ratings[i + 1]: stars[i] = max(stars[i], stars[i + 1] + 1) return sum(stars)"},{"question":"You are given a **0-indexed** integer array `nums` of length `n` consisting of only `0`s and `1`s. You are allowed to perform at most one operation where you can choose any index `i` and flip `nums[i]` (i.e., change a `0` to `1` or a `1` to `0`). Your goal is to maximize the length of any contiguous subarray consisting of only `1`s after at most one flip. Return the length of the longest contiguous subarray of `1`s that can be obtained after performing at most one flip or without performing any flip.","solution":"def longest_contiguous_ones(nums): Returns the length of the longest contiguous subarray of 1s that can be obtained after performing at most one flip. if not nums: return 0 max_ones = 0 left = 0 zero_count = 0 for right in range(len(nums)): if nums[right] == 0: zero_count += 1 while zero_count > 1: if nums[left] == 0: zero_count -= 1 left += 1 max_ones = max(max_ones, right - left + 1) return max_ones"},{"question":"You are given two strings `s1` and `s2`. Determine if one string can be transformed into the other by performing the following operations any number of times: 1. Insert a character. 2. Delete a character. 3. Replace a character. Write a function `bool canTransform(string s1, string s2)` that returns `true` if `s1` can be transformed into `s2` with the above operations, and `false` otherwise. To clarify, the function should determine if the transformation can occur by implementing the **edit distance algorithm** where you compare the transformation rules.","solution":"def canTransform(s1, s2): Returns true if s1 can be transformed into s2 by insert, delete, or replace operations, otherwise returns false. Uses the edit distance algorithm to determine the transformability. len1, len2 = len(s1), len(s2) # Create a DP table to store the minimum edit distance dp = [[0]*(len2+1) for _ in range(len1+1)] # Initialize the dp table for i in range(len1+1): for j in range(len2+1): if i == 0: dp[i][j] = j # Insert all characters of s2 elif j == 0: dp[i][j] = i # Delete all characters of s1 elif s1[i-1] == s2[j-1]: dp[i][j] = dp[i-1][j-1] # If characters are the same, no operation needed else: dp[i][j] = 1 + min(dp[i-1][j], # Delete character from s1 dp[i][j-1], # Insert character into s1 dp[i-1][j-1]) # Replace character in s1 return dp[len1][len2] == 0"},{"question":"Given a list of unique integers `nums`, write a function that returns all possible permutations of the list. Each permutation must be a new list and you can return the permutations in any order. Implement the following function: * `List<List<Integer>> permute(List<Integer> nums)` For example, given `nums = [1, 2, 3]`, the function should return: * `[[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]`","solution":"from typing import List from itertools import permutations def permute(nums: List[int]) -> List[List[int]]: Returns all possible permutations of a list of unique integers. return [list(p) for p in permutations(nums)]"},{"question":"You are given an integer array `nums` representing an elevation map where the width of each bar is `1`. Compute how much water it can trap after raining. The elevation map is represented by an integer array `nums`, where the value at each index represents the height of the elevation at that point. Return _the total units of water trapped_.","solution":"def trap_water(elevation_map): Calculate the total units of water that can be trapped. :param elevation_map: List[int], elevation map where the width of each bar is 1 :return: int, total units of water that can be trapped if not elevation_map: return 0 n = len(elevation_map) left_max = [0] * n right_max = [0] * n # Fill left_max from left to right left_max[0] = elevation_map[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], elevation_map[i]) # Fill right_max from right to left right_max[n - 1] = elevation_map[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], elevation_map[i]) # Calculate the total water trapped total_water = 0 for i in range(n): total_water += min(left_max[i], right_max[i]) - elevation_map[i] return total_water"},{"question":"You have an array of integers `arr` and an integer `d`. Every value in the array represents a person’s position on a number line. In one step, a person can move to a position that is at most `d` units away from their current position. Return _the minimum number of steps required for all the persons to be at the same position_.","solution":"def min_steps_to_same_position(arr, d): Returns the minimum number of steps required for all persons to be at the same position. Parameters: arr (list): A list of integers representing positions of persons. d (int): The maximum distance a person can move in one step. Returns: int: The minimum number of steps required. # Check for edge cases if not arr or d <= 0: return 0 min_position = min(arr) max_position = max(arr) def steps_to_position(target): return sum(abs(pos - target) // d for pos in arr) min_steps = float(\'inf\') for target in range(min_position, max_position + 1): current_steps = steps_to_position(target) min_steps = min(min_steps, current_steps) return min_steps"},{"question":"You are given a string `s` of length `n` consisting of lowercase alphabets. You are allowed to perform the following operations on the string as many times as you like: * Swap any two adjacent characters if the absolute difference of their ASCII values is an even number (`abs(ord(s[i]) - ord(s[i+1])) % 2 == 0`). * Delete any single character from the string. Your task is to determine the **lexicographically smallest** string that can be obtained after performing the above operations any number of times. Return this resulting string.","solution":"def get_lexicographically_smallest_string(s): Returns the lexicographically smallest string that can be obtained by performing the specified operations on input string s. return \'\'.join(sorted(s))"},{"question":"Given an integer array `times` representing the time taken by each student to complete a test, you are to stack the answer sheets in the specified order. You can only add one sheet at a time to the top of the stack in a way that maintains a strictly increasing order of times. If it is not possible to maintain the strictly increasing order, you must put the rest of the answer sheets aside without adding them to the stack. Return the maximum number of answer sheets you can stack in the desired order.","solution":"def max_answer_sheets(times): Returns the maximum number of answer sheets that can be stacked in strictly increasing order of times. Args: times: List[int] - An array of integers representing the time taken by each student to complete a test. Returns: int - The maximum number of answer sheets that can be stacked. if not times: return 0 longest_increasing_subsequence = [1] * len(times) for i in range(1, len(times)): for j in range(i): if times[i] > times[j]: longest_increasing_subsequence[i] = max(longest_increasing_subsequence[i], longest_increasing_subsequence[j] + 1) return max(longest_increasing_subsequence)"},{"question":"You are given a string `s` representing a sequence of characters. You need to create the lexicographically smallest string by removing exactly `k` characters from it. Note that you cannot rearrange the characters of the string. Return _the resulting string_. Compose one additional question that seamlessly integrates with the existing set, adhering to all the above guidelines. Your new question should appear as if it were part of the original examination, indistinguishable in quality and relevance from the provided samples. Output one new question only. Do not output any example, constraints or solution.","solution":"def removeElement(nums, val): Removes all occurrences of val in nums in-place and returns the new length of nums. k = 0 # Pointer for the next place to insert non-val elements for num in nums: if num != val: nums[k] = num k += 1 return k"},{"question":"An encoded string is given as `s`. To decode the string, follow the rule where `k[encoded_string]` denotes that the `encoded_string` inside the square brackets is repeated exactly `k` times. The `k` is guaranteed to be a positive integer. You may assume that the input string is well-formed and always follows this format: `k[encoded_string]`. Your task is to write a function to decode the given string `s` and return the decoded string.","solution":"def decode_string(s): Decodes the given encoded string s following the k[encoded_string] format. def helper(index): result = \\"\\" while index < len(s) and s[index] != \']\': if s[index].isdigit(): k = 0 while s[index].isdigit(): k = k * 10 + int(s[index]) index += 1 index += 1 # skipping the \'[\' decoded_string, index = helper(index) index += 1 # skipping the \']\' result += decoded_string * k else: result += s[index] index += 1 return result, index decoded, _ = helper(0) return decoded"},{"question":"Write a function that takes in a string `s` containing a mix of alphabets and digits. Extract all the digits from the string and check if they form a strictly increasing sequence. Return `true` if they form a strictly increasing sequence, and `false` otherwise. # Example ```python # Example usage: s = \\"a1b3c5d7\\" # Expected output: True s = \\"a3b2c4\\" # Expected output: False ```","solution":"def is_strictly_increasing_digits(s): Checks if the digits in the string s form a strictly increasing sequence. :param s: Input string containing a mix of alphabets and digits :return: True if the digits form a strictly increasing sequence, False otherwise digits = [int(char) for char in s if char.isdigit()] return all(earlier < later for earlier, later in zip(digits, digits[1:]))"},{"question":"Given a **0-indexed** integer array `arr` and an integer `target`, determine if there exists a contiguous subarray whose sum is equal to `target`. Return `_true_` if such a subarray exists and `_false_` otherwise. The subarray must contain at least one element.","solution":"def is_subarray_sum_target(arr, target): Determines if there exists a contiguous subarray whose sum is equal to target. :param arr: List of integers :param target: Integer target sum :return: Boolean indicating if such subarray exists current_sum = 0 sum_dict = {0: -1} # Initialize with {0: -1} to handle the case where subarray starts from index 0 for i, num in enumerate(arr): current_sum += num if (current_sum - target) in sum_dict: return True sum_dict[current_sum] = i return False"},{"question":"You are given a **0-indexed** integer array `nums` which contains `n` unique elements. Your task is to find out if you can rearrange the elements of `nums` to form an **increasing subsequence** of length `k` that is strictly increasing and is a subsequence of `nums`. Return _a boolean value_ `true` if such a subsequence exists and `false` otherwise. For example, if nums = [3, 1, 2, 4] and k = 3, you can rearrange the elements to form the increasing subsequence [1, 2, 3] which is a subsequence of `nums`.","solution":"def can_form_increasing_subsequence(nums, k): Determine if an increasing subsequence of length k can be formed from nums. n = len(nums) if k > n: return False # Use a simple loop to form a possible increasing subsequence of length k subsequence = [] for num in sorted(nums): if len(subsequence) < k: subsequence.append(num) if len(subsequence) == k: break return len(subsequence) == k"},{"question":"Given a list of integers, write a function to return all the possible unique subsets. The solution set should not contain duplicate subsets and can be returned in any order.","solution":"from typing import List def subsets(nums: List[int]) -> List[List[int]]: Generates all possible unique subsets of the given list of integers. result = [] nums.sort() def backtrack(start, path): result.append(path) for i in range(start, len(nums)): if i > start and nums[i] == nums[i-1]: # skip duplicates continue backtrack(i + 1, path + [nums[i]]) backtrack(0, []) return result"},{"question":"Given a list of swapped pairs `pairs` where each pair [u, v] indicates that `u` and `v` can be swapped, and a string `s`, determine the lexicographically smallest string that can be obtained by applying any number of swaps on the characters in the string. Return _the lexicographically smallest string that can be obtained after performing the swaps_.","solution":"def smallestStringWithSwaps(s, pairs): from collections import defaultdict def dfs(node, idx, visited, adj, chars, indices): visited[node] = True chars.append(s[node]) indices.append(node) for neighbor in adj[node]: if not visited[neighbor]: dfs(neighbor, idx, visited, adj, chars, indices) n = len(s) adj = defaultdict(list) for u, v in pairs: adj[u].append(v) adj[v].append(u) visited = [False] * n answer = list(s) for i in range(n): if not visited[i]: chars = [] indices = [] dfs(i, i, visited, adj, chars, indices) chars.sort() indices.sort() for idx, char in zip(indices, chars): answer[idx] = char return \'\'.join(answer)"},{"question":"You are given an array of integers `heights` where `heights[i]` represents the height of the `i`th building in a city. The city council has decided to restrict the skyline by ensuring that no building can have a view over a particular height `maxHeight`. To comply with this regulation, they need to reduce the heights of some buildings. Your task is to return the **minimum** number of reductions needed to make sure all buildings comply with the `maxHeight` restriction. A reduction involves decreasing the height of a single building by `1`. Return the minimum number of reductions required to ensure all buildings are at most `maxHeight`.","solution":"def min_reductions_to_max_height(heights, maxHeight): Returns the minimum number of reductions needed to ensure all buildings are at most maxHeight. Parameters: heights (list of int): List of integers representing the heights of buildings. maxHeight (int): Maximum allowed height for the buildings. Returns: int: Minimum number of reductions needed. reductions = 0 for height in heights: if height > maxHeight: reductions += height - maxHeight return reductions"},{"question":"You are given an integer array `nums` and an integer `k`. A number is called a k-highest in the array if it appears at least `k` times in the array. Find and return a list of all the k-highest numbers in non-decreasing order. If no k-highest number is found, return an empty list. Example: ``` Input: nums = [4, 1, 2, 2, 3, 1, 2, 3, 4, 3], k = 3 Output: [2, 3] ``` Explanation: - The number `2` appears 3 times. - The number `3` appears 3 times. - Therefore, [2, 3] are the k-highest numbers in the list.","solution":"def find_k_highest(nums, k): from collections import Counter # Count the frequency of each number in the array frequency_count = Counter(nums) # Filter the numbers that have a frequency of at least k k_highest_numbers = [num for num, count in frequency_count.items() if count >= k] k_highest_numbers.sort() return k_highest_numbers"},{"question":"You are given a `0-indexed` integer array `gain` of length `n` representing the net gain in altitude at each point along a path. The array `gain` starts at point `0` and each `gain[i]` represents the altitude change from the previous point to the next. Return _the highest altitude reached at any point along the path_. Note that the starting altitude is `0`.","solution":"def largestAltitude(gain): Returns the highest altitude reached at any point along the path. :param gain: List[int] - List of net gains in altitude at each point. :return: int - The highest altitude reached. altitude = 0 max_altitude = 0 for g in gain: altitude += g if altitude > max_altitude: max_altitude = altitude return max_altitude"},{"question":"You are given an integer array `heights` representing the heights of columns of bricks in a skyline. You need to return the maximum **rectangle area** that can be formed by picking consecutive columns. The height of the rectangle is determined by the minimum height among the selected consecutive columns. The width of the rectangle is the number of consecutive columns selected. Given `heights`, return the _maximum rectangle area_ that can be formed.","solution":"def largestRectangleArea(heights): Returns the maximum rectangle area that can be formed by picking consecutive columns. :param heights: List[int] :return: int stack = [] max_area = 0 index = 0 while index < len(heights): # If this bar is higher than the bar at stack top, push it to the stack if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: # Pop the top top_of_stack = stack.pop() # Calculate the area with heights[top_of_stack] as the smallest bar area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) # Now pop the remaining bars from stack and calculate area while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"Given a `string s` consisting of characters \'a\', \'b\', and \'c\', you can perform the following operation on `s` any number of times: Choose any `substring` of `s` and replace it with any character from \'a\', \'b\', or \'c\'. Return _the length of the shortest string_ you can obtain after performing any number of the given operations.","solution":"def min_length_string(s): Returns the length of the shortest string that can be obtained by replacing any substring with any character \'a\', \'b\', or \'c\'. As \'a\', \'b\', and \'c\' can replace each other, the shortest possible string would be of length 1 (e.g., replacing the entire string with \'a\'). # The shortest string we can obtain is always length 1 return 1"},{"question":"You are given an `n x n` binary matrix `grid` representing a map of `1`s and `0`s. A group of `1`s forms an island. An island is surrounded by water and is formed by connecting adjacent `1`s horizontally or vertically. You may assume all four edges of the grid are surrounded by water. You can only perform the following operation: choose any `0` cell and change it to `1`. Find the minimum number of operations to change the grid such that there is only one island. An island is considered to be isolated if there are no `1`s in its adjacent cells. Return _the minimum number of operations needed to connect all islands in the grid into one single island_.","solution":"def min_operations_to_one_island(grid): Returns the minimum number of operations to connect all islands in the grid into one single island. from collections import deque def bfs(i, j, visited): queue = deque([(i, j)]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] visited[i][j] = True island = [] while queue: x, y = queue.popleft() island.append((x, y)) for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and not visited[nx][ny] and grid[nx][ny] == 1: visited[nx][ny] = True queue.append((nx, ny)) return island def find_islands(): visited = [[False]*len(grid[0]) for _ in range(len(grid))] islands = [] for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1 and not visited[i][j]: island = bfs(i, j, visited) islands.append(island) return islands def calculate_distance(island1, island2): min_distance = float(\'inf\') for (x1, y1) in island1: for (x2, y2) in island2: distance = abs(x1 - x2) + abs(y1 - y2) - 1 min_distance = min(min_distance, distance) return min_distance islands = find_islands() if len(islands) <= 1: return 0 min_operations = float(\'inf\') for i in range(len(islands)): for j in range(i+1, len(islands)): distance = calculate_distance(islands[i], islands[j]) min_operations = min(min_operations, distance) return min_operations"},{"question":"You are given an array of integers `arr` and an integer `d`. A contiguous subarray `[arr[i], arr[i+1], ..., arr[j]]` of `arr` is called **smooth** if the difference between the maximum and minimum elements in the subarray is at most `d`. Write an algorithm to find the length of the longest **smooth** subarray. Return the length of this subarray.","solution":"def longest_smooth_subarray(arr, d): Returns the length of the longest smooth subarray. A subarray is considered smooth when the difference between the maximum and minimum elements in the subarray is at most d. Args: arr (list of int): A list of integers. d (int): The maximum allowed difference between min and max in the subarray. Returns: int: The length of the longest smooth subarray. from collections import deque min_deque, max_deque = deque(), deque() left, max_length = 0, 0 for right in range(len(arr)): while min_deque and arr[min_deque[-1]] >= arr[right]: min_deque.pop() while max_deque and arr[max_deque[-1]] <= arr[right]: max_deque.pop() min_deque.append(right) max_deque.append(right) while arr[max_deque[0]] - arr[min_deque[0]] > d: left += 1 if min_deque[0] < left: min_deque.popleft() if max_deque[0] < left: max_deque.popleft() max_length = max(max_length, right - left + 1) return max_length"},{"question":"You are given an integer array `arr` of size `n` and an integer `k`. We want to determine if there is a **non-empty** subarray in `arr` whose sum is a multiple of `k`. A subarray is a contiguous part of the array. Return `true` if such a subarray exists, otherwise return `false`.","solution":"def check_subarray_sum(arr, k): Determines if there is a non-empty subarray whose sum is a multiple of k. Parameters: arr (list of int): The array of integers. k (int): The integer which the subarray sum should be a multiple of. Returns: bool: True if such a subarray exists, False otherwise. if k == 0: return any(arr[i] + arr[i - 1] == 0 for i in range(1, len(arr))) prefix_sums = {0: -1} current_sum = 0 for i, num in enumerate(arr): current_sum += num mod = current_sum % k if mod in prefix_sums: if i - prefix_sums[mod] > 1: return True else: prefix_sums[mod] = i return False"},{"question":"You are given a string `s` consisting of lowercase English letters. You are also given an integer array `indices` of the same length as `s`, where each element in `indices` represents the desired final position of the corresponding character in `s`. Construct and return the final string after rearranging the characters of `s` according to the positions specified in `indices`.","solution":"def restore_string(s, indices): Rearranges the characters of the string s according to the positions specified in indices. :param s: A string of lowercase English letters :param indices: A list of integers specifying the final positions of the corresponding characters in s :return: The rearranged string # Initialize an array of the same length as s with placeholder characters restored = [\'\'] * len(s) # Place each character in its desired position for char, index in zip(s, indices): restored[index] = char # Join and return the rearranged characters as a string return \'\'.join(restored)"},{"question":"Design and implement a Sudoku solver. Write a function `solveSudoku` that takes as input a partially filled 9x9 2D array of characters `board` representing a Sudoku puzzle and modifies the `board` in place to solve the puzzle. A sudoku puzzle follows these rules: 1. Each of the digits 1-9 must occur exactly once in each row. 2. Each of the digits 1-9 must occur exactly once in each column. 3. Each of the digits 1-9 must occur exactly once in each of the 9 3x3 sub-boxes of the grid. 4. The \'.\' character represents an empty cell that needs to be filled. The function should return `true` if a solution exists and `false` otherwise. ```python def solveSudoku(board: List[List[str]]) -> None: Do not return anything, modify board in-place instead. # Your code here ```","solution":"from typing import List def solveSudoku(board: List[List[str]]) -> bool: def is_valid(board: List[List[str]], row: int, col: int, num: str) -> bool: # Check if num is not in the current row for x in range(9): if board[row][x] == num: return False # Check if num is not in the current column for y in range(9): if board[y][col] == num: return False # Check if num is not in the current 3x3 sub-box start_row, start_col = 3 * (row // 3), 3 * (col // 3) for i in range(3): for j in range(3): if board[start_row + i][start_col + j] == num: return False return True def solve(board: List[List[str]]) -> bool: for row in range(9): for col in range(9): if board[row][col] == \'.\': for num in map(str, range(1, 10)): if is_valid(board, row, col, num): board[row][col] = num if solve(board): return True board[row][col] = \'.\' return False return True return solve(board)"},{"question":"Suppose you are given a **binary search tree (BST)** with `n` nodes containing distinct integer values. You need to find the **kth smallest element** in this BST. The tree\'s nodes are arranged such that for any given node: - The left subtree of the node contains values less than the node\'s own value. - The right subtree of the node contains values greater than the node\'s own value. Given the root of the BST and an integer `k`, return the kth smallest value (1-indexed) in the tree.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def kth_smallest(root, k): def inorder_traversal(node): if not node: return [] return inorder_traversal(node.left) + [node.val] + inorder_traversal(node.right) elements = inorder_traversal(root) return elements[k-1] if 0 < k <= len(elements) else None"},{"question":"You are given two lists of integers `nums1` and `nums2`. Your goal is to find the maximum length of a subarray that appears in both `nums1` and `nums2`. Return _the maximum length of such subarray_.","solution":"def find_length(nums1, nums2): Finds the maximum length of a subarray that appears in both nums1 and nums2. Args: nums1 (List[int]): The first list of integers. nums2 (List[int]): The second list of integers. Returns: int: The maximum length of a subarray that appears in both lists. n, m = len(nums1), len(nums2) dp = [[0] * (m + 1) for _ in range(n + 1)] max_length = 0 for i in range(1, n + 1): for j in range(1, m + 1): if nums1[i - 1] == nums2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 max_length = max(max_length, dp[i][j]) return max_length"},{"question":"You are given an input string `s` containing only digits and the characters `?` and `*`. Your task is to find all possible decoded versions of the string, assuming the following rules: - Each `?` can be replaced with any single digit from `0` to `9`. - Each `*` can be replaced with any sequence of one or more digits, where each digit can be from `0` to `9`. Return a list of all possible decoded versions of the string `s`. The order in the result list does not matter. If no valid version exists, return an empty list.","solution":"from itertools import product def generate_combinations(s): Returns all possible decoded versions of the string based on the given rules. Each \'?\' can be replaced with a single digit from \'0\' to \'9\'. Each \'*\' can be replaced with any sequence of one or more digits. if not s: return [] def expand_star(): # \'*\' could be any sequence of digits from \'1\' to \'9\', inclusive return [str(i) for i in range(1, 10)] def dfs(index, path, result): if index == len(s): result.append(\'\'.join(path)) return if s[index] == \'?\': for d in \'0123456789\': path.append(d) dfs(index + 1, path, result) path.pop() elif s[index] == \'*\': for seq in expand_star(): path.append(seq) dfs(index + 1, path, result) path.pop() else: path.append(s[index]) dfs(index + 1, path, result) path.pop() result = [] dfs(0, [], result) return result"},{"question":"Given a string `s` that consists of letters and digits, determine if it is a valid **hexadecimal number**. Hexadecimal numbers can contain lowercase letters \'a\' to \'f\', uppercase letters \'A\' to \'F\', and digits from \'0\' to \'9\'. They may also start with an optional prefix \\"0x\\" or \\"0X\\". Return `true` if the string `s` is a valid hexadecimal number, and `false` otherwise.","solution":"def is_hexadecimal(s): Determines if a given string is a valid hexadecimal number. Parameters: s (str): The string to check. Returns: bool: True if the string is a valid hexadecimal number, False otherwise. if len(s) == 0: return False # Check for optional “0x” or “0X” prefix if s[:2].lower() == \\"0x\\": s = s[2:] if len(s) == 0: return False # Check if the remaining characters are valid hexadecimal characters for char in s: if not (char.isdigit() or \'a\' <= char.lower() <= \'f\'): return False return True"},{"question":"You are given an array of integers `nums` and an integer `k`. Move the first `k` elements of the array to the end of the array. Return the modified array. Note that `k` can be greater than the length of the array, in which case you should consider `k % len(nums)` positions. Write a function `rotate_array(nums, k)` that accomplishes this task.","solution":"def rotate_array(nums, k): Moves the first k elements of the array to the end. If k is greater than the length of nums, k is considered as k % len(nums). :param nums: List of integers :param k: Integer, the number of elements to move to the end :return: Modified list if not nums: return [] n = len(nums) k = k % n # handle cases where k > len(nums) return nums[k:] + nums[:k]"},{"question":"You are given a string `s` and an integer `k`. The string `s` can be transformed by shifting each of its letters by a given number of positions, where a shift means `A` becomes `B`, `B` becomes `C`, and so on. A shift can wrap around so that `Z` becomes `A`. A single shift is defined as moving one letter to its next letter. Write a function to determine if the string `s` with each character shifted by exactly `k` positions can be rearranged to form a palindrome. A palindrome is a string that reads the same backward as forward. Return `true` if it is possible to form a palindrome with the given shift, otherwise return `false`.","solution":"def can_form_palindrome(s, k): def shift_character(c, k): return chr((ord(c) - ord(\'A\') + k) % 26 + ord(\'A\')) shifted_s = \'\'.join(shift_character(c, k) for c in s) freq = {} for char in shifted_s: if char in freq: freq[char] += 1 else: freq[char] = 1 odd_count = 0 for count in freq.values(): if count % 2 != 0: odd_count += 1 if len(s) % 2 == 0 and odd_count == 0: return True elif len(s) % 2 == 1 and odd_count == 1: return True else: return False"},{"question":"Given an integer array `arr` of length `n`, write a function that returns `true` if there are three ascending elements in the array that form an arithmetic progression, otherwise return `false`. An arithmetic progression is a sequence of numbers where the difference between consecutive terms is constant.","solution":"def has_arithmetic_progression(arr): Returns true if there are three ascending elements in the array that form an arithmetic progression. if len(arr) < 3: return False for i in range(len(arr) - 2): for j in range(i + 1, len(arr) - 1): for k in range(j + 1, len(arr)): if arr[j] - arr[i] == arr[k] - arr[j]: return True return False"},{"question":"Given a string `word`, construct the lexicographically smallest string that can be obtained by applying the following operation exactly once: Pick any character from `word` and remove it to form a new string. For example, given `word = \\"abcd\\"`, you can remove \'b\' to get \\"acd\\", which is lexicographically smaller than \\"abdc\\" if you removed \'c\'. Return the lexicographically smallest string that can be obtained by applying this operation exactly once.","solution":"def smallest_string_after_removal(word): Returns the lexicographically smallest string that can be obtained by removing exactly one character from `word`. smallest_string = word[1:] # Initialize with first character removed for i in range(len(word)): candidate = word[:i] + word[i+1:] if candidate < smallest_string: smallest_string = candidate return smallest_string"},{"question":"Given an integer array `arr`, write a function to determine if it is a **disjoint** sequence. A sequence is considered **disjoint** if no element in the sequence repeats and the absolute difference between every pair of consecutive elements is greater than 1. Return `true` if the array is disjoint, and `false` otherwise.","solution":"def is_disjoint_sequence(arr): Determines if the given array is a disjoint sequence. A sequence is considered disjoint if: - No element in the sequence repeats. - The absolute difference between every pair of consecutive elements is greater than 1. Parameters: arr (list): The integer array to be checked. Returns: bool: True if the sequence is disjoint, False otherwise. if len(arr) == 0: return True elements_seen = set() for i in range(len(arr)): if arr[i] in elements_seen: return False elements_seen.add(arr[i]) if i > 0 and abs(arr[i] - arr[i-1]) <= 1: return False return True"},{"question":"You are given a `2D` grid of size `m x n` representing a map where `0` represents water and `1` represents land. An **island** is a group of `1`\'s (land) connected **4-directionally** (horizontal or vertical). You may assume all four edges of the grid are surrounded by water. The **area** of an island is the number of `1`\'s in the island. A maximum rectangle is defined as the largest sub-grid of the grid that contains only `1`\'s. Return _the **area** of the largest maximum rectangle present in any of the islands._","solution":"def max_rectangle_area(grid): def max_histogram_area(heights): stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area if not grid: return 0 max_area = 0 m, n = len(grid), len(grid[0]) heights = [0] * n for row in grid: for i in range(n): if row[i] == 0: heights[i] = 0 else: heights[i] += 1 max_area = max(max_area, max_histogram_area(heights)) return max_area"},{"question":"Given an array of integers `arr` of length `n` sorted in ascending order, and an integer `target`, locate two distinct indices i and j in such a way that `i < j` and `arr[i] + arr[j]` is as close as possible to the `target`. Return the pair of indices `(i, j)`. If there are multiple pairs with the same minimal difference, return any one of them.","solution":"def find_closest_pair(arr, target): Given a sorted array `arr` and an integer `target`, this function returns two distinct indices (i, j) such that arr[i] + arr[j] is as close as possible to the target. The indices satisfy i < j. n = len(arr) left, right = 0, n - 1 closest_pair = (0, 1) closest_diff = float(\'inf\') while left < right: current_sum = arr[left] + arr[right] current_diff = abs(current_sum - target) if current_diff < closest_diff: closest_diff = current_diff closest_pair = (left, right) if current_sum < target: left += 1 elif current_sum > target: right -= 1 else: break # If current_sum == target, it\'s the closest possible pair return closest_pair"},{"question":"You are given a list of tuples `points` where each tuple represents the coordinates (x, y) of points on a 2D plane. Write a function to find and return the **n**th nearest point to the origin (0, 0). If n exceeds the number of points in the list, return None. **Note:** The distance between two points (x1, y1) and (x2, y2) is calculated as the Euclidean distance. You may assume there are no duplicate points.","solution":"import math def nth_nearest_point(points, n): Returns the nth nearest point to the origin (0, 0). :param points: A list of tuples representing points in a 2D plane :param n: The rank of the nearest point to find :return: The nth nearest point as a tuple or None if n exceeds the number of points if n > len(points): return None # Calculate the Euclidean distance for each point from the origin points_with_distance = [(point, math.sqrt(point[0]**2 + point[1]**2)) for point in points] # Sort points by their distance points_with_distance.sort(key=lambda x: x[1]) # Extract the nth nearest point return points_with_distance[n-1][0]"},{"question":"You are given an integer array `nums` and an integer `k`. A subarray in the given array is defined as an `interesting subarray` if the sum of the subarray is equal to `k`. Suppose you are allowed to rearrange at most one element from one subarray to another at most once. Return the maximum length of the `interesting subarray` achievable after performing such an operation. If it is not possible to form any `interesting subarray`, return `0`.","solution":"def max_length_interesting_subarray(nums, k): Returns the maximum length of the interesting subarray where the subarray sum equals k after rearranging at most one element. # Calculate the maximum subarray sum equal to k without rearrangement def max_subarray_sum_equal_to_k(nums, k): sum_dict = {} current_sum = 0 max_length = 0 for i, num in enumerate(nums): current_sum += num if current_sum == k: max_length = i + 1 # subarray from start to current index if (current_sum - k) in sum_dict: max_length = max(max_length, i - sum_dict[current_sum - k]) if current_sum not in sum_dict: sum_dict[current_sum] = i return max_length # Without any rearrangement max_len_no_rearrange = max_subarray_sum_equal_to_k(nums, k) # Trying rearrangement of at most one element n = len(nums) max_len_with_rearrange = 0 for i in range(n): for j in range(i + 1, n): if nums[i] != nums[j]: nums[i], nums[j] = nums[j], nums[i] temp_max_len = max_subarray_sum_equal_to_k(nums, k) max_len_with_rearrange = max(max_len_with_rearrange, temp_max_len) nums[i], nums[j] = nums[j], nums[i] # revert the change return max(max_len_no_rearrange, max_len_with_rearrange)"},{"question":"You are given two strings `str1` and `str2`. Determine if the entire string `str2` can be found as a subsequence in `str1`. A subsequence of a string is a new string that is formed by deleting some (or none) of the characters from the original string without reordering the remaining characters. If `str2` is a subsequence of `str1`, return `true`, otherwise return `false`. Implement a function `boolean isSubsequence(String str1, String str2)` that returns whether `str2` is a subsequence of `str1`.","solution":"def is_subsequence(str1, str2): Determines if str2 is a subsequence of str1. Parameters: str1 (str): The main string. str2 (str): The string to check as a subsequence. Returns: bool: True if str2 is a subsequence of str1, False otherwise. iter_str1 = iter(str1) return all(char in iter_str1 for char in str2)"},{"question":"Given a string `s` composed of only lowercase English letters, you need to rotate the string to the right by `k` places. For example, if `s = \\"abcdefg\\"` and `k = 2`, the new string after rotating is `fgabcde`. If `k` is larger than the length of the string, it should be reduced modulo the length of the string. Return _the resulting string_ after performing the rotation.","solution":"def rotate_string(s, k): Rotates the string s to the right by k places. If k is larger than the length of the string, it is reduced modulo the length of the string. n = len(s) k = k % n # Reduce k modulo the length of the string return s[-k:] + s[:-k]"},{"question":"Given an array of integers `nums` and an integer `k`, return _the number of non-empty consecutive subarrays that sum to_ `k`. A subarray is a contiguous part of an array. For example, given `nums = [1, 1, 1]` and `k = 2`, the resulting count is `2` since there are two subarrays [1, 1] that sum up to `k`.","solution":"def subarray_sum(nums, k): Returns the number of non-empty consecutive subarrays that sum to k. :param nums: List of integers :param k: Integer :return: Integer count = 0 current_sum = 0 sum_dict = {0: 1} # Dictionary to store the cumulative sum frequencies for num in nums: current_sum += num if current_sum - k in sum_dict: count += sum_dict[current_sum - k] sum_dict[current_sum] = sum_dict.get(current_sum, 0) + 1 return count"},{"question":"You are given a `m x n` `2D` matrix `grid` consisting of `0`s (free cells) and `1`s (obstacles). You can move either up, down, left, or right from the free cells. Find the shortest path from the top-left corner `(0, 0)` to the bottom-right corner `(m-1, n-1)` and return the length of the path. If there is no such path, return `-1`. Note that you cannot move through obstacles and you cannot move outside the boundaries of the grid.","solution":"from collections import deque def shortest_path(grid): Returns the shortest path from the top-left corner (0, 0) to the bottom-right corner (m-1, n-1) in a grid. If no such path exists, returns -1. if not grid or grid[0][0] == 1 or grid[-1][-1] == 1: return -1 m, n = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 1)]) visited = set((0, 0)) while queue: x, y, length = queue.popleft() if x == m - 1 and y == n - 1: return length for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited and grid[nx][ny] == 0: queue.append((nx, ny, length + 1)) visited.add((nx, ny)) return -1"},{"question":"You are given an integer array `arr` and an integer `k`. The array contains integers in possibly unsorted order. Your task is to find the `k`-th smallest element in the array without changing the original array. Return the `k`-th smallest element of the array. If `k` is greater than the number of elements in the array, return `-1`. The array may contain duplicate elements, and they should be treated as distinct for ranking purposes.","solution":"import heapq from typing import List def find_kth_smallest(arr: List[int], k: int) -> int: Returns the k-th smallest element in the array without altering the original array. If k is greater than the number of elements in the array, returns -1. if k > len(arr): return -1 # Copy the array to avoid modifying the original array copied_arr = list(arr) # Find the k-th smallest element using a heap heapq.heapify(copied_arr) for _ in range(k - 1): heapq.heappop(copied_arr) return heapq.heappop(copied_arr)"},{"question":"You are given an array of integers `heights` representing the heights of trees in a forest. A fire spreads among the trees according to the following rules: * Each tree can catch fire from any neighboring tree that is already on fire. * Initially, the fire starts at one specific tree (given by its index). * Every minute, all trees that are on fire from the previous minute can spread the fire to their adjacent trees. Your task is to determine the minimum number of minutes required to set the entire forest on fire. Return _the minimum number of minutes to burn down all the trees if it is possible or_ `-1` _if not all trees can be burned_.","solution":"from collections import deque def min_minutes_to_burn_forest(heights, start): Returns the minimum number of minutes to set the entire forest on fire starting from a specific tree. If not all trees can be burned, returns -1. :param heights: List[int] trees\' heights representing the forest. :param start: int, index of the tree where the fire starts. :return: int, minimum number of minutes to burn down all the trees or -1 if not possible. if not heights: return -1 n = len(heights) visited = [False] * n queue = deque([(start, 0)]) # (index, time) visited[start] = True min_minutes = 0 while queue: index, minutes = queue.popleft() min_minutes = max(min_minutes, minutes) neighbors = [] if index - 1 >= 0: neighbors.append(index - 1) if index + 1 < n: neighbors.append(index + 1) for neighbor in neighbors: if not visited[neighbor]: visited[neighbor] = True queue.append((neighbor, minutes + 1)) return min_minutes if all(visited) else -1"},{"question":"You are given an array of integers `arr` and an integer `k`. A pair of indices `(i, j)` is called an **important inversion** if `i < j` and `arr[i] > k * arr[j]`. Your task is to count the number of important inversions in the given array. Implement a function `int countImportantInversions(int[] arr, int k)` that returns the total number of important inversions in the array.","solution":"def countImportantInversions(arr, k): Counts the number of important inversions in the array. Parameters: arr (list): List of integers. k (int): The given integer. Returns: int: Number of important inversions. count = 0 n = len(arr) for i in range(n): for j in range(i + 1, n): if arr[i] > k * arr[j]: count += 1 return count"},{"question":"You are given a 2D list `intervals` where `intervals[i] = [start_i, end_i]` represents the start and end of the `i-th` interval. The task is to merge all overlapping intervals and return a new 2D list representing the merged intervals. Two intervals `[start_i, end_i]` and `[start_j, end_j]` are considered overlapping if `start_i <= end_j` and `start_j <= end_i`. The return list should be sorted by the start of each interval.","solution":"def merge_intervals(intervals): Merges overlapping intervals. Args: intervals (List[List[int]]): A list of intervals where each interval is a list of two integers. Returns: List[List[int]]: A new list of merged intervals. if not intervals: return [] # Sort intervals by the starting time intervals.sort(key=lambda x: x[0]) merged = [] for interval in intervals: # If the list of merged intervals is empty or if the current interval # does not overlap with the previous, simply append it. if not merged or merged[-1][1] < interval[0]: merged.append(interval) else: # Otherwise, there is an overlap, so we merge the current and previous intervals. merged[-1][1] = max(merged[-1][1], interval[1]) return merged"},{"question":"A **subarray** is a contiguous part of an array. The **sum** of a subarray is the sum of its elements. * For example, for the array `nums = [1,2,3,4]`, the sum of the subarray `[2,3]` is `2 + 3 = 5`. Given an integer array `nums` and an integer `k`, return _the length of the shortest non-empty subarray with a sum of at least `k`_. If there is no such subarray, return `-1`. Implement the `shortestSubarray` method: * `int shortestSubarray(int[] nums, int k)` which takes an integer array `nums` and an integer `k`, and returns the length of the shortest subarray with the sum at least `k`.","solution":"from collections import deque def shortestSubarray(nums, k): Returns the length of the shortest subarray with sum at least k. If no such subarray exists, returns -1. n = len(nums) prefix_sums = [0] * (n + 1) for i in range(n): prefix_sums[i + 1] = prefix_sums[i] + nums[i] result = float(\'inf\') deque_index = deque() for i in range(n + 1): while deque_index and prefix_sums[i] - prefix_sums[deque_index[0]] >= k: result = min(result, i - deque_index.popleft()) while deque_index and prefix_sums[i] <= prefix_sums[deque_index[-1]]: deque_index.pop() deque_index.append(i) return result if result != float(\'inf\') else -1"},{"question":"You are given two integers, `n` and `m`, which represent the number of rows and columns of a grid, respectively. The grid is initially empty. You are tasked with filling this grid with integer values. Define a 2D integer array `operations` where each `operations[i] = [type, r, c, k]` specifies an operation on the grid: - If `type` is `1`, add the value `k` to the element at position `(r, c)`. - If ` type` is `2`, set the element at position `(r, c)` to the maximum value of itself and `k`. After performing all the operations, return the updated grid. **Note:** Rows and columns are 0-indexed. The initial grid has all elements set to `0`.","solution":"def update_grid(n, m, operations): Updates the grid based on the given operations. Parameters: n (int): Number of rows. m (int): Number of columns. operations (list of lists): List of operations where each operation is in the form of [type, r, c, k]. Returns: list of lists: The updated grid. # Initialize the grid with zeros grid = [[0] * m for _ in range(n)] # Apply each operation to the grid for op in operations: if op[0] == 1: # Add k to the element at position (r, c) grid[op[1]][op[2]] += op[3] elif op[0] == 2: # Set the element at position (r, c) to the max of itself and k grid[op[1]][op[2]] = max(grid[op[1]][op[2]], op[3]) return grid"},{"question":"You are given a list of `n` positive integers representing the heights of `n` buildings arranged in a row. The rainwater can trap in the valleys between the buildings if there is a higher building on both the left and the right sides of the valley. Write a function to calculate the total amount of rainwater that can be trapped after it rains. Return the total water trapped.","solution":"def trap_rain_water(heights): Calculate the total amount of rainwater that can be trapped after it rains. Args: heights (list): A list of positive integers representing the heights of buildings. Returns: int: The total amount of rainwater that can be trapped. if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n # Fill left_max array left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i-1], heights[i]) # Fill right_max array right_max[n-1] = heights[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], heights[i]) # Calculate the water trapped water_trapped = 0 for i in range(n): water_trapped += min(left_max[i], right_max[i]) - heights[i] return water_trapped"},{"question":"Given a string `s` that represents a code consisting of `\'0\'` and `\'1\'`, the characters are divided into blocks of consecutive characters, and each block is a segment of the code. Return the number of segments in the code that consist of only \'1\'s. A segment is defined as a contiguous sequence of \'1\'s surrounded by \'0\'s or by the boundaries of the string.","solution":"def count_ones_segments(s): Returns the number of segments in the code that consist only of \'1\'s. :param s: Input string consisting of \'0\' and \'1\' :type s: str :return: Number of segments of consecutive \'1\'s :rtype: int count = 0 segments = s.split(\'0\') for segment in segments: if \'1\' in segment: count += 1 return count"},{"question":"You are given a string `s` and an array of strings `words` where each string in `words` consists of lowercase English letters. Each string in `words` can be written as a concatenation of one or more strings in `s`. Return the number of strings in `words` that are substrings of `s`.","solution":"def num_of_substrings(s, words): Returns the number of strings in words that are substrings of s. Parameters: s (str): The string in which to look for substrings. words (list of str): The list of strings to check as substrings of s. Returns: int: The number of substrings in words that are substrings of s. count = 0 for word in words: if word in s: count += 1 return count"},{"question":"Given an integer array `height` representing the height of adjacent buildings in a straight line, calculate the maximum amount of water that can be trapped between the buildings after a rain. The array `height` has a minimum length of 3 and there is guaranteed to be at least one valley between two peaks in the array.","solution":"def trap(height): Calculate the maximum amount of water that can be trapped between buildings after a rain. if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - height[i] return trapped_water"},{"question":"Given a binary matrix `grid` of size `m x n`, consisting of `0`s (representing wall) and `1`s (representing path), you are initially positioned at the top-left corner of the grid (start from `grid[0][0]`). Your goal is to determine the shortest path from the starting cell to the bottom-right corner (end at `grid[m-1][n-1]`). You can move in four possible directions: up, down, left, and right. However, some cells may block the path and you cannot move through cells with a value of `0`. Determine the minimum number of steps required to reach the bottom-right corner from the top-left corner. If there is no possible path, return `-1`. You may assume that: - `m` and `n` are positive integers. - `grid` is a binary matrix consisting of only `0`s and `1`s. - The cells `grid[0][0]` and `grid[m-1][n-1]` are guaranteed to be `1`. Write a function `shortestPath(grid: List[List[int]]) -> int` to solve the problem.","solution":"from collections import deque from typing import List def shortestPath(grid: List[List[int]]) -> int: if not grid or not grid[0]: return -1 m, n = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # Initialize a queue for BFS with the starting point queue = deque([(0, 0, 1)]) # (row, column, distance) visited = set((0, 0)) while queue: x, y, dist = queue.popleft() # If we\'ve reached the bottom-right corner if x == m - 1 and y == n - 1: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 1 and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1 # If there is no valid path"},{"question":"You are given a string `s` which represents a simplified version of a Unix-style absolute path. A Unix-style absolute path starts with `\'/\'`, followed by subsequent directories, each separated by `\'/\'`, and end with a directory or a file. For example, `\\"/home/\\"` and `\\"/usr/local/bin\\"` are valid absolute paths, while `\\"/../\\"` and `\\"/home//foo/\\"` are not. Your task is to simplify the given absolute path such that the resultant path does not contain any `\'.\'` (current directory), `\'..\'` (parent directory) or multiple consecutive `\'/\'` characters. The resultant path should be the shortest equivalent path. Return the simplified path.","solution":"def simplify_path(path): Simplifies a given Unix-style absolute path. :param path: A string representing an absolute Unix-style path. :return: A simplified version of the given path. components = path.split(\'/\') stack = [] for component in components: if component == \'..\': if stack: stack.pop() elif component and component != \'.\': stack.append(component) return \'/\' + \'/\'.join(stack)"},{"question":"Write a function that takes a list of integers `arr` and an integer `target` and returns a tuple of two numbers from the list such that the sum of those two numbers is closest to the `target`. If there are multiple pairs with the same closest sum, return any of them. The function should assume that there is at least one pair of integers in the list.","solution":"def closest_sum_pair(arr, target): Find the pair of numbers in arr such that their sum is closest to target. :param arr: List of integers :param target: Integer target :return: Tuple of two integers from the list if len(arr) < 2: raise ValueError(\\"The input list must contain at least two numbers.\\") closest_pair = None closest_diff = float(\'inf\') # Sort the array arr.sort() # Use two pointers approach to find the closest pair left, right = 0, len(arr) - 1 while left < right: current_sum = arr[left] + arr[right] current_diff = abs(target - current_sum) if current_diff < closest_diff: closest_diff = current_diff closest_pair = (arr[left], arr[right]) # Move the pointers if current_sum < target: left += 1 elif current_sum > target: right -= 1 else: # If current_sum is exactly equal to target return (arr[left], arr[right]) return closest_pair"},{"question":"You are given a **0-indexed** integer array `heights` of length `n` representing the height of `n` bars. Assume that each bar has a width of `1`. Find the area of the largest rectangle that can be formed within the bars, where its sides are parallel to the x-axis and y-axis. The area of the rectangle is the number of bars included in it multiplied by the height of the smallest bar in the rectangle. Return the area of the largest rectangle that can be formed from the bars in the histogram.","solution":"def largest_rectangle_area(heights): Returns the area of the largest rectangle that can be formed from the bars in the histogram. :param heights: List[int], list of heights of the bars :return: int, the area of the largest rectangle # Initialize max_area to 0 stack = [] max_area = 0 # Go through each bar in heights index = 0 while index < len(heights): # As long as the stack is empty or the current bar is at least as tall as the bar at the top of the stack if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: # Pop the top of the stack and calculate the area top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) # Now, pop the remaining bars from stack and calculate area while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"Given a 2D matrix `matrix` of integers where every row and column is sorted in ascending order, write a function that searches for a given integer `target` in `matrix`. The function should return `true` if `target` is found, and `false` otherwise. For example, consider the following matrix: ``` [ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ] ``` If `target` = 5, the function should return `true`. If `target` = 20, the function should return `false`.","solution":"def search_matrix(matrix, target): Searches for a given target in a 2D matrix where every row and column is sorted in ascending order. Args: matrix (list of list of int): The 2D matrix to be searched. target (int): The target integer to be searched in the matrix. Returns: bool: True if target is found, and False otherwise. if not matrix or not matrix[0]: return False rows, cols = len(matrix), len(matrix[0]) row, col = 0, cols - 1 # start from the top right corner while row < rows and col >= 0: if matrix[row][col] == target: return True elif matrix[row][col] > target: col -= 1 else: row += 1 return False"},{"question":"You are given a `contacts` list of strings representing a collection of contact names and a `query` string. Implement a class `ContactSearch` that supports querying the contact list to return all the names that start with the `query` string. The class should support the following functions: - **addContact(String contact)**: Adds a new contact name to the contacts list. - **removeContact(String contact)**: Removes an existing contact name from the contacts list. - **search(String query)**: Returns a list of all contact names that start with the given query string, in lexicographical order. Implement the `ContactSearch` class: * `ContactSearch()` initializes the contact list as an empty list. * `addContact(String contact)` adds a contact to the contacts list. * `removeContact(String contact)` removes a contact from the contacts list if it exists. * `search(String query)` returns a list of contacts that start with the given query string in lexicographical order.","solution":"class ContactSearch: def __init__(self): self.contacts = [] def addContact(self, contact): Adds a new contact name to the contacts list. self.contacts.append(contact) self.contacts.sort() def removeContact(self, contact): Removes an existing contact name from the contacts list. if contact in self.contacts: self.contacts.remove(contact) def search(self, query): Returns a list of all contact names that start with the given query string, in lexicographical order. result = [contact for contact in self.contacts if contact.startswith(query)] return result"},{"question":"Given an integer array `nums`, you need to determine whether there exists a contiguous subarray of length at least 2 that sums up to a multiple of `k`. An integer `x` is a multiple of `k` if there exists an integer `n` such that `x = n * k`. Return `true` if such a subarray exists, otherwise return `false`. **Note:** - The subarray should have at least two elements. - `k` can be any integer including 0.","solution":"def checkSubarraySum(nums, k): if not nums or len(nums) < 2: return False # Dictionary to store the sum modulo k, initial value 0 to handle zero-sum subarray mod_dict = {0: -1} cum_sum = 0 for i, num in enumerate(nums): cum_sum += num if k != 0: cum_sum = cum_sum % k if cum_sum in mod_dict: if i - mod_dict[cum_sum] > 1: return True else: mod_dict[cum_sum] = i return False"},{"question":"Given a list of unique integers representing a permutation of numbers from 1 to `n`, find _the next lexicographically greater permutation_ of this list. If such a permutation does not exist, return the list sorted in ascending order. Please implement a function that modifies the list in-place and uses only constant extra memory.","solution":"def next_permutation(nums): Modifies the list of integers in-place to the next lexicographical permutation. If no such permutation exists, sorts the list in ascending order. n = len(nums) # Step 1: Find the largest index k such that nums[k] < nums[k + 1]. If no such index exists, the permutation is the last permutation. k = n - 2 while k >= 0 and nums[k] >= nums[k + 1]: k -= 1 if k == -1: nums.reverse() return # Step 2: Find the largest index l greater than k such that nums[k] < nums[l]. l = n - 1 while l > k and nums[k] >= nums[l]: l -= 1 # Step 3: Swap the value of nums[k] with that of nums[l]. nums[k], nums[l] = nums[l], nums[k] # Step 4: Reverse the sequence from nums[k + 1] up to and including the final element nums[n - 1]. nums[k + 1:] = reversed(nums[k + 1:])"},{"question":"Given an array of `n` integers `nums` and an integer `target`, return _the number of pairs of indices_ `(i, j)` _such that_ `i < j` _and_ `nums[i] + nums[j] == target`. Each element in the array can only be used once in a pair, and the same pair of indices should not be counted more than once.","solution":"def count_pairs(nums, target): Returns the number of pairs (i, j) such that i < j and nums[i] + nums[j] == target. count = 0 seen = {} for i, num in enumerate(nums): complement = target - num if complement in seen: count += seen[complement] seen[num] = seen.get(num, 0) + 1 return count"},{"question":"Write a function to find the **longest common prefix string** amongst an array of strings. If there is no common prefix, return an empty string \\"\\". Your function should have the following signature: `string longestCommonPrefix(vector<string>& strs)`.","solution":"def longestCommonPrefix(strs): Returns the longest common prefix string amongst an array of strings. If there is no common prefix, returns an empty string \\"\\". if not strs: return \\"\\" # Find the shortest string in the list shortest_str = min(strs, key=len) for i, char in enumerate(shortest_str): for other_str in strs: if other_str[i] != char: return shortest_str[:i] return shortest_str"},{"question":"You are given two strings `s` and `p`, both consisting only of lowercase English letters. Your task is to find all the start indices of `p`\'s anagrams in `s`. The anagrams do not need to be contiguous, but the order of characters must match. The solution should run in linear time complexity. Return the list of start indices in ascending order.","solution":"from collections import Counter def find_anagrams(s, p): Returns a list of start indices of p\'s anagrams in s. p_length = len(p) s_length = len(s) if p_length > s_length: return [] p_counter = Counter(p) current_counter = Counter(s[:p_length]) result = [] if p_counter == current_counter: result.append(0) for i in range(1, s_length - p_length + 1): current_counter[s[i-1]] -= 1 if current_counter[s[i-1]] == 0: del current_counter[s[i-1]] current_counter[s[i + p_length - 1]] += 1 if p_counter == current_counter: result.append(i) return result"},{"question":"Design a data structure that enables the addition of new integers and the retrieval of the median (the middle value) of the current set of integers efficiently. You should implement the following methods: 1. `addNumber(int num)`: Adds the integer `num` to the data structure. 2. `findMedian()`: Returns the median of all integers currently added to the data structure. Note: The median is the middle value in an ordered integer list. If the list has even number of elements, the median is the average of the two middle numbers.","solution":"import heapq class MedianFinder: def __init__(self): Initialize the MedianFinder data structure. - max_heap stores the smaller half values (as max heap in negative form) - min_heap stores the larger half values self.max_heap = [] # A max-heap to maintain the lower half of elements. self.min_heap = [] # A min-heap to maintain the upper half of elements. def addNumber(self, num: int): Adds a num into the data structure. heapq.heappush(self.max_heap, -num) if self.max_heap and self.min_heap and (-self.max_heap[0] > self.min_heap[0]): heapq.heappush(self.min_heap, -heapq.heappop(self.max_heap)) if len(self.max_heap) > len(self.min_heap) + 1: heapq.heappush(self.min_heap, -heapq.heappop(self.max_heap)) if len(self.min_heap) > len(self.max_heap): heapq.heappush(self.max_heap, -heapq.heappop(self.min_heap)) def findMedian(self) -> float: Returns the median of current numbers. if len(self.max_heap) > len(self.min_heap): return -self.max_heap[0] else: return (-self.max_heap[0] + self.min_heap[0]) / 2"},{"question":"Given an array `intervals` where `intervals[i] = [starti, endi]` represents an interval. Two intervals overlap if they share a common point. Return _the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping_. If no intervals need to be removed, return `0`.","solution":"def eraseOverlapIntervals(intervals): Given a collection of intervals, find the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping. Args: intervals (List[List[int]]): A list of interval pairs [start, end]. Returns: int: The minimum number of intervals to remove. if not intervals: return 0 # Sort intervals based on the end time intervals.sort(key=lambda x: x[1]) # Initialize the count of intervals to remove and the end of the previous interval count = 0 prev_end = intervals[0][1] for i in range(1, len(intervals)): # If the current interval starts before the end of the previous interval, # then it\'s overlapping and needs to be removed. if intervals[i][0] < prev_end: count += 1 else: # Otherwise, update the end to be the end of the current interval prev_end = intervals[i][1] return count"},{"question":"You are given an integer array `heights` representing the heights of buildings. The array is such that the heights are in increasing order up to a certain index `p` and then in decreasing order. Determine the index `p` of the peak or highest building. This index satisfies the maximum condition `heights[p] > heights[p-1]` and `heights[p] > heights[p+1]`. If the array does not form this shape, return `-1`.","solution":"def find_peak(heights): Returns the index of the peak or highest building in the array. If no valid peak is found, returns -1. if len(heights) < 3: return -1 n = len(heights) for i in range(1, n - 1): if heights[i] > heights[i - 1] and heights[i] > heights[i + 1]: return i return -1"},{"question":"You are given a 2D matrix `grid` of size `m x n` representing a garden. Each cell in the grid has a value representing the height of the flower planted in that cell. The height is given as an integer. Your task is to water the garden such that the flower\'s height can be increased. You have a watering technique that can only be applied to blocks of cells in a rectangular region and increases the height of each flower in that region by 1 unit. Follow these steps to water the garden: 1. Identify all the blocks of cells in the grid whose flower height is greater than a given threshold `t`. 2. Apply the watering technique to these blocks. 3. Return the total number of units of water used after watering these blocks once. Assume that increasing the height of one flower by 1 unit requires 1 unit of water. Here is an example: For `grid = [[1,2,3], [4,1,2], [3,4,1]]` and `t = 2`, `blocks = [[1,2],[2,2],[3,4]]`. The total units of water needed would be 4.","solution":"def water_garden(grid, t): Returns the total number of units of water used to increase the height of flowers whose height is greater than the given threshold t by 1 unit. :param grid: List[List[int]] - 2D grid representing the garden :param t: int - threshold value for flower height :return: int - total units of water used total_water = 0 for row in grid: for height in row: if height > t: total_water += 1 return total_water"},{"question":"You are given a list of non-negative integers `nums` and an integer `k`. We want to form a new list `result` where each element is the sum of at most `k` consecutive elements from `nums`. Specifically, the `i`-th element of `result` should be the sum of elements from `nums` starting from the `i`-th position to the position `i + k - 1`. If there are fewer than `k` elements remaining at any position, use all the remaining elements. Return the `result` as a list of integers.","solution":"def sum_consecutive_elements(nums, k): Given a list of non-negative integers nums and an integer k, returns a list where each element is the sum of at most k consecutive elements. result = [] n = len(nums) for i in range(n): sum_k = sum(nums[i:i+k]) result.append(sum_k) return result"},{"question":"Given a list of integers `numList`, return a new list containing all the elements of `numList` such that each element is only included once, maintaining their original order. For instance, given the list `[4, 5, 8, 4, 5, 2, 1, 8, 2]`, the output should be `[4, 5, 8, 2, 1]` since `4`, `5`, `8`, and `2` appear multiple times and are included only once in their first occurrence.","solution":"def remove_duplicates(numList): Returns a new list with duplicates removed, maintaining original order. seen = set() unique_list = [] for num in numList: if num not in seen: seen.add(num) unique_list.append(num) return unique_list"},{"question":"Given a string `s`, return _the longest substring of `s` which contains only vowels_. If there are multiple such substrings with the same length, return the one that appears first in `s`. Vowels in this context are \'a\', \'e\', \'i\', \'o\', \'u\'.","solution":"def longest_vowel_substring(s): Returns the longest substring of s which contains only vowels. If there are multiple such substrings with the same length, returns the one that appears first in s. vowels = set(\'aeiou\') max_length = 0 longest_substring = \\"\\" start = 0 while start < len(s): if s[start] in vowels: end = start while end < len(s) and s[end] in vowels: end += 1 current_substring = s[start:end] if len(current_substring) > max_length: max_length = len(current_substring) longest_substring = current_substring start = end else: start += 1 return longest_substring"},{"question":"You are given an integer array `nums` of length `n` and an integer `k`. Your task is to determine whether there exists a subarray of `nums` of length `k` such that the average of the elements in the subarray is greater than or equal to a given integer `x`. If such a subarray exists, return `true`; otherwise, return `false`. A subarray is a contiguous part of an array, and the average of a subarray is the sum of its elements divided by the number of elements in that subarray. For example, if the array is `[1, 4, 2, 5]` and `k = 2`, the possible subarrays of length `2` are `[1, 4]`, `[4, 2]`, and `[2, 5]`.","solution":"def check_subarray_average(nums, k, x): Determines if there exists a subarray of length k in nums such that the average of its elements is greater than or equal to x. Args: nums (list of int): List of integers representing the array. k (int): Length of the subarray. x (int): Value to compare the average against. Returns: bool: True if such a subarray exists, otherwise False. subarray_sum = sum(nums[:k]) if subarray_sum / k >= x: return True for i in range(k, len(nums)): subarray_sum += nums[i] - nums[i - k] if subarray_sum / k >= x: return True return False"},{"question":"You are given a 0-indexed 2D integer matrix `grid` of dimensions `m x n` representing a maze where `0` represents an empty space and `1` represents a wall. You start at the top-left corner of the maze (i.e., `grid[0][0]`) and need to reach the bottom-right corner (i.e., `grid[m-1][n-1]`). You can only move up, down, left, or right. Return the minimum number of steps required to reach the bottom-right corner of the maze, or `-1` if it is not possible to reach the destination.","solution":"from collections import deque def min_steps_in_maze(grid): Returns the minimum number of steps required to reach the bottom-right corner of the maze. Returns -1 if it is not possible to reach the destination. :param grid: List[List[int]] - the maze as a 2D list :return: int - the minimum number of steps or -1 if not possible if not grid or grid[0][0] == 1: return -1 m, n = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 0)]) # (row, col, steps) visited = set((0, 0)) while queue: row, col, steps = queue.popleft() # If we reached the bottom-right corner, return the steps count if row == m - 1 and col == n - 1: return steps # Explore neighbors for dr, dc in directions: new_row, new_col = row + dr, col + dc if 0 <= new_row < m and 0 <= new_col < n and (new_row, new_col) not in visited and grid[new_row][new_col] == 0: visited.add((new_row, new_col)) queue.append((new_row, new_col, steps + 1)) return -1 # If there\'s no way to reach the bottom-right corner"},{"question":"You are given a 2D integer array `grid` representing an m x n matrix where each cell can have one of three values: - 0 representing an empty cell, - 1 representing a fresh orange, or - 2 representing a rotten orange. Every minute, any fresh orange that is adjacent (4-directionally) to a rotten orange becomes rotten. Return the minimum number of minutes that must elapse until no cell has a fresh orange. If this is impossible, return -1. **Note**: - Adjacency includes the four cardinal directions: up, down, left, and right. - Cells that are out of the grid\'s boundaries are considered non-existing, and thus cannot be rotted.","solution":"from collections import deque def orangesRotting(grid): Returns the minimum number of minutes that must elapse until no cell has a fresh orange. If this is impossible, return -1. rows, cols = len(grid), len(grid[0]) queue = deque() fresh_count = 0 # Initialize the queue and count fresh oranges for r in range(rows): for c in range(cols): if grid[r][c] == 2: queue.append((r, c, 0)) elif grid[r][c] == 1: fresh_count += 1 # 4-directional movement vectors directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] minutes_elapsed = 0 while queue: x, y, minutes = queue.popleft() minutes_elapsed = max(minutes_elapsed, minutes) for dr, dc in directions: nx, ny = x + dr, y + dc # If in bounds and has a fresh orange if 0 <= nx < rows and 0 <= ny < cols and grid[nx][ny] == 1: grid[nx][ny] = 2 # Rot the fresh orange fresh_count -= 1 queue.append((nx, ny, minutes + 1)) return minutes_elapsed if fresh_count == 0 else -1"},{"question":"Given a 2D grid of integers `grid`, return the maximum sum of a *hourglass* shape. An *hourglass* shape is defined as follows: - A 3x3 grid. - The sum includes all the elements of the hourglass shape: ``` a b c d e f g ``` For example, in the matrix: ``` 1 1 1 0 0 0 0 1 0 0 0 0 1 1 1 0 0 0 0 0 2 4 4 0 0 0 0 2 0 0 0 0 1 2 4 0 ``` The hourglass with the maximum sum is: ``` 2 4 4 2 1 2 4 ``` which gives a sum of 19. You need to return this maximum hourglass sum found in `grid`. The grid will have a minimum dimension of 3x3.","solution":"def hourglass_sum(grid): Returns the maximum hourglass sum in a 2D grid. rows = len(grid) cols = len(grid[0]) max_sum = float(\'-inf\') for i in range(rows - 2): for j in range(cols - 2): top = grid[i][j] + grid[i][j + 1] + grid[i][j + 2] mid = grid[i + 1][j + 1] bot = grid[i + 2][j] + grid[i + 2][j + 1] + grid[i + 2][j + 2] hourglass = top + mid + bot if hourglass > max_sum: max_sum = hourglass return max_sum"},{"question":"Write a function that takes a string representing a mathematical expression and returns the result of the expression. The expression can contain non-negative integers, \'+\', \'-\', \'*\', \'/\', and parentheses \'()\'. You must follow the standard order of operations (parentheses first, then multiplication and division, and finally addition and subtraction from left to right). Ensure your solution handles nested parentheses and operator precedence correctly.","solution":"def evaluate_expression(expression): Evaluate a mathematical expression string containing non-negative integers, \'+\', \'-\', \'*\', \'/\', and parentheses \'()\'. import re import operator # Operators definition ops = {\'+\': operator.add, \'-\': operator.sub, \'*\': operator.mul, \'/\': operator.truediv} def parse_expression(expression): num, stack, op = 0, [], \'+\' while len(expression) > 0: char = expression.pop(0) if char.isdigit(): num = num * 10 + int(char) if char == \'(\': num = parse_expression(expression) if char in ops or char == \')\' or len(expression) == 0: if op == \'+\': stack.append(num) elif op == \'-\': stack.append(-num) elif op == \'*\': stack[-1] *= num elif op == \'/\': stack[-1] = int(stack[-1] / num) if char == \')\': break num, op = 0, char return sum(stack) return parse_expression(list(expression)) # Example #print(evaluate_expression(\\"3+(2*2)-1\\")) # Should output 6"},{"question":"You are given a list of `n` integers `nums` where each integer appears exactly three times, except for one integer that appears exactly once. Find the integer that appears only once.","solution":"def single_number(nums): Returns the integer that appears exactly once. # Initialize a dictionary to count the occurrences of each number count = {} # Populate the dictionary with the count of each number for num in nums: if num in count: count[num] += 1 else: count[num] = 1 # Find and return the number that appears exactly once for num, cnt in count.items(): if cnt == 1: return num"},{"question":"Given a binary tree, determine if it is height-balanced. A height-balanced binary tree is defined as: * A binary tree in which the left and right subtrees of every node differ in height by no more than 1. You are given the root node of the binary tree. Return _True_ if the tree is height-balanced, else return _False_. For example: ``` Input: 1 / 2 3 / 4 5 Output: True ``` For this binary tree: ``` Input: 1 / 2 3 / 4 5 Output: False ```","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_balanced(root): Determine if the binary tree is height-balanced. def check_height(node): if not node: return 0, True left_height, left_balanced = check_height(node.left) right_height, right_balanced = check_height(node.right) height = 1 + max(left_height, right_height) if not left_balanced or not right_balanced: return height, False if abs(left_height - right_height) > 1: return height, False return height, True _, balanced = check_height(root) return balanced"},{"question":"You are given a list of student scores in a class as well as the number of students who should be awarded scholarships. Implement a function `award_scholarships(scores, k)` where `scores` is a list of integers representing the scores of the students and `k` is an integer representing the number of scholarships to be awarded. The function should return a list of `k` scores that represent the top `k` highest scores in the class. If there are multiple students with the same score, they all should be considered for the scholarship, and the list should have exactly `k` elements. **Function Signature:** ```python def award_scholarships(scores: List[int], k: int) -> List[int]: # your code here ```","solution":"from typing import List def award_scholarships(scores: List[int], k: int) -> List[int]: Returns the top k scores from the list of student scores. If multiple students have the same score, they are all considered, but the list should have exactly k elements. if k == 0 or not scores: return [] # Sort scores in descending order sorted_scores = sorted(scores, reverse=True) result = [] current_count = 0 # Find top k scores considering possible ties for score in sorted_scores: if current_count < k: result.append(score) current_count += 1 else: if score == result[-1]: result.append(score) else: break return result[:k]"},{"question":"Write a function `find_single_number` that takes an array of integers where every element appears twice except for one. Find that single one.","solution":"def find_single_number(nums): Returns the single number that appears only once in the list where every other element appears twice. :param nums: List of integers :return: Single integer that appears only once # Using XOR operation to find the single number single_number = 0 for num in nums: single_number ^= num return single_number"},{"question":"Given a linked list, return the list after reversing every group of `k` nodes. If the number of nodes is not a multiple of `k` then left-out nodes in the end should remain as it is. You may not alter the values in the nodes, only nodes themselves may be changed.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverseKGroup(head, k): def reverse_linked_list(head, k): prev = None current = head while k > 0: next_node = current.next current.next = prev prev = current current = next_node k -= 1 return prev count = 0 node = head while node and count != k: # find the k+1 node node = node.next count += 1 if count == k: # if k+1 node is found reversed_head = reverse_linked_list(head, k) head.next = reverseKGroup(node, k) return reversed_head return head"},{"question":"You are given an array `arr` of integers. Your task is to shift all zeros in the array to the end while maintaining the relative order of the non-zero elements. Return _the modified array_ after all zeros have been shifted to the end.","solution":"def shift_zeros_to_end(arr): Shifts all zeros in the array to the end while maintaining the relative order of the non-zero elements. Parameters: arr (list): The input list of integers Returns: list: The modified list with all zeros shifted to the end non_zero_elements = [x for x in arr if x != 0] zero_elements = [x for x in arr if x == 0] return non_zero_elements + zero_elements"},{"question":"Given a binary tree, imagine each node has a value representing some water content. Write a function that, given the root of the binary tree, computes the total amount of water contained in the tree. Additionally, you are asked to perform an in-order traversal of the binary tree and return the values of the nodes in the order they are visited. Return both the total water content and the in-order traversal in a tuple.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def compute_water_and_inorder_traversal(root): Computes the total water content of the binary tree and performs an in-order traversal. Parameters: root (TreeNode): The root of the binary tree. Returns: tuple: total water content and a list of values in in-order traversal. total_water = 0 inorder_list = [] def inorder_traverse(node): nonlocal total_water if node: inorder_traverse(node.left) total_water += node.value inorder_list.append(node.value) inorder_traverse(node.right) inorder_traverse(root) return total_water, inorder_list"},{"question":"You are given two binary strings `a` and `b`, and you are tasked with finding their sum (a binary string). Return the result as a binary string. The input strings are guaranteed to be non-empty and contain only \'1\' or \'0\'. You are required to solve this without using any built-in functions for handling large integers or directly converting the input strings to integers.","solution":"def add_binary_strings(a, b): Returns the sum of two binary strings. max_len = max(len(a), len(b)) # Padding the shorter string with zeros a = a.zfill(max_len) b = b.zfill(max_len) carry = 0 result = [] for i in range(max_len - 1, -1, -1): total = carry total += 1 if a[i] == \'1\' else 0 total += 1 if b[i] == \'1\' else 0 result.append(\'1\' if total % 2 == 1 else \'0\') carry = 0 if total < 2 else 1 if carry != 0: result.append(\'1\') result.reverse() return \'\'.join(result)"},{"question":"Imagine you are given an array of integer coordinates `points` where each element represents a point on a 2D plane as `[x, y]`. Your task is to find the smallest rectangle that can enclose all the given points such that the sides of the rectangle are parallel to the coordinate axes. Return the area of the smallest enclosing rectangle.","solution":"def min_area_rect(points): Returns the area of the smallest rectangle that can enclose all the given points. points: List[List[int]], a list of [x, y] coordinates. if not points: return 0 # Extract x and y coordinates separately x_coordinates = [point[0] for point in points] y_coordinates = [point[1] for point in points] # Find the minimum and maximum x and y values min_x = min(x_coordinates) max_x = max(x_coordinates) min_y = min(y_coordinates) max_y = max(y_coordinates) # Calculate the area of the smallest enclosing rectangle width = max_x - min_x height = max_y - min_y area = width * height return area"},{"question":"Given a **0-indexed** binary string `s` which initially consists of only \'0\'s, you are given an array of operations `ops` where each operation `ops[i]` is a list of two integers `[l, r]` representing a range. For every operation, toggle all the bits in the substring `s[l:r]` (inclusive) from \'0\' to \'1\' and vice versa. Return _the minimum number of operations needed to make all characters in the string \'s\' equal to \'1\'._","solution":"def min_operations_to_all_ones(s, ops): def toggle(s, l, r): s = list(s) # convert string to list for mutability for i in range(l, r + 1): s[i] = \'1\' if s[i] == \'0\' else \'0\' return \'\'.join(s) count = 0 current_string = s for op in ops: l, r = op current_string = toggle(current_string, l, r) count += 1 if current_string == \'1\' * len(s): break return count"},{"question":"You are given a string `s` where each character can be an uppercase letter, a lowercase letter, or a digit. You need to transform the string such that each character is replaced by the next character in the sequence. For uppercase letters, \'A\' should wrap around to \'Z\', for lowercase letters, \'a\' should wrap around to \'z\', and for digits, \'0\' should wrap around to \'9\'. Return the transformed string. For example, given the input string `s = \\"AbzZy9\\"`, the output should be `\\"BcaAz0\\"`. Implement the function `transformString(String s)` that takes a string `s` and returns the transformed string according to the above rules.","solution":"def transformString(s): def next_char(c): if \'A\' <= c <= \'Z\': return chr(((ord(c) - ord(\'A\') + 1) % 26) + ord(\'A\')) elif \'a\' <= c <= \'z\': return chr(((ord(c) - ord(\'a\') + 1) % 26) + ord(\'a\')) elif \'0\' <= c <= \'9\': return chr(((ord(c) - ord(\'0\') + 1) % 10) + ord(\'0\')) return c # If it\'s not an uppercase, lowercase, or digit, return as is. return \'\'.join(next_char(c) for c in s)"},{"question":"You are given two strings `s` and `t`. You can perform the following operation exactly once: choose a non-empty substring in `s` and delete it. A substring is a contiguous sequence of characters within a string. Return `true` if it\'s possible to transform `s` into `t` by performing the operation, otherwise return `false`.","solution":"def can_transform(s, t): Returns True if it\'s possible to transform s into t by deleting exactly one non-empty substring from s. if s == t: return False for i in range(len(s)): for j in range(i + 1, len(s) + 1): if s[:i] + s[j:] == t: return True return False"},{"question":"Given a binary tree, determine if it is **height-balanced**. A height-balanced binary tree is defined as: * A binary tree in which the left and right subtrees of every node differ in height by no more than 1. Return `true` if the binary tree is height-balanced, and `false` otherwise. The definition for a binary tree node is as follows: ``` class TreeNode { int val; TreeNode left; TreeNode right; TreeNode(int x) { val = x; } } ```","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def is_balanced(root): def check_height(node): if not node: return 0, True left_height, left_balanced = check_height(node.left) right_height, right_balanced = check_height(node.right) current_height = 1 + max(left_height, right_height) current_balanced = left_balanced and right_balanced and abs(left_height - right_height) <= 1 return current_height, current_balanced _, balanced = check_height(root) return balanced"},{"question":"Consider a `n x n` board full of water represented by `~`. You have a list of `islands` represented by coordinates `[x, y]` where there is land on the board. Each `island` is represented by `#`. You can perform daily operations to expand the islands. In one operation, each piece of land can spread to its four neighboring cells (up, down, left, right), turning water (`~`) into land (`#`). Given the coordinates of the initial islands and the size of the board `n`, determine the minimum number of days required to transform the entire board into land (`#`). If it is not possible to cover the entire board, return `-1`.","solution":"from collections import deque def min_days_to_cover_board(n, islands): Returns the minimum number of days required to transform the entire board into land. Parameters: n (int): The size of the board. islands (list of tuples): The initial coordinates of the islands. Returns: int: Minimum number of days to cover the board with land or -1 if not possible. if not islands: return -1 if n > 0 else 0 board = [[\'~\'] * n for _ in range(n)] queue = deque() for x, y in islands: board[x][y] = \'#\' queue.append((x, y, 0)) # (x, y, days) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] max_days = 0 while queue: x, y, days = queue.popleft() for direction in directions: nx, ny = x + direction[0], y + direction[1] if 0 <= nx < n and 0 <= ny < n and board[nx][ny] == \'~\': board[nx][ny] = \'#\' queue.append((nx, ny, days + 1)) max_days = max(max_days, days + 1) for row in board: if \'~\' in row: return -1 # If there\'s still water left, return -1 return max_days"},{"question":"You are given a 2D integer array `events` where `events[i] = [startTime, endTime, value]` representing an event that starts at `startTime`, ends at `endTime`, and has a `value` associated with it. You can attend an event if it doesn\'t overlap with any other event you have attended. You can choose at most `k` non-overlapping events to attend. Return _the maximum sum of values of the events you can attend_.","solution":"def max_value_of_events(events, k): events.sort(key=lambda x: x[1]) dp = [[0] * (k + 1) for _ in range(len(events) + 1)] start_times = [event[0] for event in events] def find_last_non_conflicting(i): low, high = 0, i - 1 while low <= high: mid = (low + high) // 2 if events[mid][1] < events[i][0]: if events[mid + 1][1] < events[i][0]: low = mid + 1 else: return mid else: high = mid - 1 return -1 for i in range(1, len(events) + 1): for j in range(1, k + 1): last_non_conflict = find_last_non_conflicting(i - 1) include = events[i - 1][2] + (dp[last_non_conflict + 1][j - 1] if last_non_conflict != -1 else 0) exclude = dp[i - 1][j] dp[i][j] = max(include, exclude) return dp[len(events)][k]"},{"question":"You are given a string `s` consisting of lowercase English letters, and an array of strings `words`. You need to select a non-empty subsequence from `s` and determine if it can form one of the strings in `words` when concatenated in order without reordering the characters. Return the length of the longest such subsequence. If no such subsequence exists, return 0.","solution":"def is_subsequence(s, word): Checks if word is a subsequence of s. it = iter(s) return all(char in it for char in word) def longest_subseq_length(s, words): Finds the length of the longest subsequence from s that can form one of the words in words. longest_length = 0 for word in words: if is_subsequence(s, word): longest_length = max(longest_length, len(word)) return longest_length"},{"question":"You are given an integer array `nums`. Return the sum of elements in `nums` such that no two selected elements are adjacent in the original array. You may assume the array is non-empty. For example, if `nums = [3, 2, 5, 10, 7]`, you can pick 3, 5, and 7 to get a maximum sum of 15.","solution":"def max_non_adjacent_sum(nums): Returns the maximum sum of non-adjacent numbers in the array nums. if not nums: return 0 incl = 0 excl = 0 for num in nums: new_excl = max(incl, excl) incl = excl + num excl = new_excl return max(incl, excl)"},{"question":"Given a string representing a mathematical expression containing digits, \'+\', \'-\', \'*\', \'/\', \'(\', and \')\', write a function `int evaluateExpression(string s)` that evaluates the expression and returns its value. The given expression is guaranteed to be valid and will not contain any spaces. The order of operations follows standard mathematical conventions: 1. Parentheses 2. Multiplication and division (from left to right) 3. Addition and subtraction (from left to right) For example: * `evaluateExpression(\\"3+2*2\\")` returns `7`. * `evaluateExpression(\\" 3/2 \\")` returns `1`. * `evaluateExpression(\\"(1+(4+5+2)-3)+(6+8)\\")` returns `23`.","solution":"def evaluateExpression(s): Evaluates a mathematical expression and returns its value. :param s: str :return: int def helper(tokens): stack = [] num = 0 sign = \'+\' while tokens: tok = tokens.pop(0) if tok.isdigit(): num = num * 10 + int(tok) if tok == \'(\': num = helper(tokens) if (not tok.isdigit() and tok != \' \') or not tokens: if sign == \'+\': stack.append(num) elif sign == \'-\': stack.append(-num) elif sign == \'*\': stack[-1] = stack[-1] * num elif sign == \'/\': stack[-1] = int(stack[-1] / num) # truncating towards zero sign = tok num = 0 if tok == \')\': break return sum(stack) tokens = list(s) return helper(tokens)"},{"question":"You are given a list of non-negative integers `heights` representing the heights of a series of bars. Each bar has a width of `1`. Imagine this as a histogram where the width of each bar distance is `1`. You need to calculate the area of the largest rectangular region that can be contained within the boundaries created by these bars. Return _the area of the largest rectangle that can be achieved_. For example, given `heights = [2, 1, 5, 6, 2, 3]`, the largest rectangular area would be `10`, which is the area of the rectangle formed by heights `5` and `6` (width `2`).","solution":"def largest_rectangle_area(heights): Calculate the area of the largest rectangle that can be formed within the histogram represented by heights. :param heights: List[int] - A list of non-negative integers representing the heights of the bars. :return: int - The area of the largest rectangle. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"Given a list of integers `arr`, return an integer representing the length of the longest contiguous subarray whose elements can be rearranged to form a strictly increasing sequence. **Note**: A strictly increasing sequence is one where each subsequent element is greater than the previous one.","solution":"def longest_contiguous_subarray(arr): if not arr: return 0 max_length = 1 current_length = 1 for i in range(1, len(arr)): if arr[i] != arr[i-1]: current_length += 1 else: current_length = 1 max_length = max(max_length, current_length) return max_length"},{"question":"You are given an array of integers, where each integer represents a meeting end time. The meeting has a fixed duration of `duration` minutes. Your task is to return the minimum number of meeting rooms required to accommodate all the meetings without any overlap. The end times of two meetings can coincide with the start time of the next meeting.","solution":"def min_meeting_rooms(end_times, duration): Returns the minimum number of meeting rooms required to accommodate all the meetings without any overlap. :param end_times: List of integers representing the end times of meetings. :param duration: Integer representing the duration of each meeting. :return: Integer representing the minimum number of meeting rooms required. if not end_times: # handle the case of an empty list return 0 # Convert end times into start and end tuples meetings = [(end_time - duration, end_time) for end_time in end_times] meetings.sort() # Sort by start times import heapq heap = [] # Min-heap to keep track of end times for meeting in meetings: if heap and heap[0] <= meeting[0]: # If the room due to free up the earliest is free before the current meeting starts heapq.heappop(heap) heapq.heappush(heap, meeting[1]) return len(heap) # The size of the heap is the number of rooms needed"},{"question":"You are given two integer arrays `A` and `B` of the same length. You need to transform array `A` into array `B` by performing a series of operations. In one operation, you can select any two adjacent elements in `A` and swap their positions. Determine the minimum number of operations required to transform `A` into `B`, or return `-1` if it is not possible to transform `A` into `B`.","solution":"def min_operations_to_transform(A, B): Returns the minimum number of adjacent swaps required to transform array A into array B. If it is not possible, returns -1. if sorted(A) != sorted(B): return -1 swap_count = 0 a = A.copy() for i in range(len(B)): if a[i] != B[i]: swap_index = a.index(B[i], i) while swap_index > i: a[swap_index], a[swap_index - 1] = a[swap_index - 1], a[swap_index] swap_index -= 1 swap_count += 1 return swap_count"},{"question":"You are given a binary string `s` and an integer `k`. Find the length of the longest contiguous substring containing only `1`\'s, with at most `k` allowed consecutive changes of `0`\'s to `1`\'s. Return the length of this longest substring. A contiguous substring is defined as a sequence of characters within a string that appear consecutively.","solution":"def longest_consecutive_ones(s, k): Returns the length of the longest contiguous substring containing only \'1\'s, with at most \'k\' allowed consecutive changes of \'0\'s to \'1\'s. max_length = 0 start = 0 zero_count = 0 for end in range(len(s)): if s[end] == \'0\': zero_count += 1 while zero_count > k: if s[start] == \'0\': zero_count -= 1 start += 1 max_length = max(max_length, end - start + 1) return max_length"},{"question":"Given a list of integers representing the stock prices of a company in chronological order, determine the maximum possible profit from buying and selling one share of the stock. You must buy before you sell. Return the maximum profit you can achieve; if no profit is possible, return 0. Example: Input: `prices = [7, 1, 5, 3, 6, 4]` Output: `5` In this example, buying at `1` and selling at `6`, provides the maximum profit, which is `6 - 1 = 5`.","solution":"def max_profit(prices): Returns the maximum possible profit from buying and selling one share of the stock. If no profit is possible, return 0. if not prices: return 0 min_price = float(\'inf\') max_profit = 0 for price in prices: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"There is a **directed acyclic graph** (DAG) with `n` vertices, where each vertex is labeled from `0` to `n - 1` (**inclusive**). The edges in the graph are represented as a 2D integer array `edges`, where each `edges[i] = [ui, vi]` denotes a **directed** edge from vertex `ui` to vertex `vi`. You need to determine the length of the longest path in the graph. Given `edges` and the integer `n`, return _the length of the longest path in the graph_.","solution":"from collections import defaultdict, deque def longest_path(n, edges): # Build a graph and in-degrees array graph = defaultdict(list) in_degrees = [0] * n for u, v in edges: graph[u].append(v) in_degrees[v] += 1 # Queue for all nodes with no incoming edges queue = deque() for i in range(0, n): if in_degrees[i] == 0: queue.append((i, 0)) # (node, current_path_length) longest_path_length = 0 while queue: node, current_path_length = queue.popleft() longest_path_length = max(longest_path_length, current_path_length) for neighbor in graph[node]: in_degrees[neighbor] -= 1 if in_degrees[neighbor] == 0: queue.append((neighbor, current_path_length + 1)) return longest_path_length"},{"question":"You are given a **2D** integer array `employees` where `employees[i] = [hours_i, salary_i]` represents the hours worked and salary earned by the `i-th` employee. You are also given an integer `target_hours` which specifies the minimum number of hours an employee needs to work to be considered satisfactory. A team is considered **satisfactory** if all its members are satisfactory. Your task is to maximize the average salary of any satisfactory team. If no satisfactory team exists, return `0`. Return the **maximum average salary** of any satisfactory team rounded to two decimal places.","solution":"def max_average_salary(employees, target_hours): satisfactory_employees = [salary for hours, salary in employees if hours >= target_hours] if not satisfactory_employees: return 0.00 total_salary = sum(satisfactory_employees) average_salary = total_salary / len(satisfactory_employees) return round(average_salary, 2)"},{"question":"You are given a list of tasks, each of which takes a certain amount of time to complete. You are also given `n` workers, where each worker can complete exactly one task at a time. Your task is to assign the tasks to the workers such that the time it takes to complete all tasks is minimized. Each worker can only work on one task at a time, and a task cannot be split between workers. Given an array `tasks`, where `tasks[i]` represents the time required to complete the `ith` task, return the minimum possible time to complete all tasks when using the `n` workers. **Example:** ```plaintext Input: tasks = [3, 2, 3], n = 2 Output: 3 Explanation: Allocate time slots as follows: - Worker 1: [3] - Worker 2: [2, 3] Minimum time to complete all tasks is 3 units. ```","solution":"import heapq def min_time_to_complete_tasks(tasks, n): Given an array `tasks` where `tasks[i]` represents the time required to complete the `ith` task, and a number `n` representing the number of workers, this function returns the minimum possible time to complete all tasks using `n` workers. if not tasks: return 0 # Create a min-heap to represent the workers\' time schedules workers = [0] * n heapq.heapify(workers) for task in tasks: # Assign the task to the worker who has the least total time min_worker_time = heapq.heappop(workers) heapq.heappush(workers, min_worker_time + task) # The time required to complete all tasks is the maximum time among all workers return max(workers)"},{"question":"You are given a string `equation` representing a rational equation in the form of `numerator/denominator`. The `numerator` and `denominator` are both valid integer arithmetic expressions involving addition (`+`) and subtraction (`-`). Return the result of the equation as a simplified fraction in the form of `a/b`, where `a` and `b` are coprime integers (i.e., their greatest common divisor is `1`). Assume that the input will always result in a valid fraction, and `b` (the denominator) will always be positive in the simplified form.","solution":"from fractions import Fraction def simplify_fraction(equation): Simplifies the given fraction equation to its simplest form a/b. Args: equation (str): A string representing a fraction in the form \'numerator/denominator\'. Returns: str: Simplified fraction in the form \'a/b\' where a and b are coprime integers. # Split the equation into numerator and denominator numerator_expr, denominator_expr = equation.split(\'/\') # Evaluate the expressions to get integer values numerator = eval(numerator_expr) denominator = eval(denominator_expr) # Get the simplified fraction using the Fraction class from the fractions module simplified_fraction = Fraction(numerator, denominator) # Return the string representation of the simplified fraction return f\\"{simplified_fraction.numerator}/{simplified_fraction.denominator}\\""},{"question":"Given an array of integers `arr` where every integer appears exactly twice except for one integer which appears exactly once, write a function to find and return the single integer that appears only once. Implement your solution with a time complexity of O(n) and a space complexity of O(1).","solution":"def single_number(arr): Finds the single integer that appears only once in an array where every other integer appears exactly twice. :param arr: List of integers :return: The integer that appears only once unique = 0 for num in arr: unique ^= num return unique"},{"question":"You are given an array of integers representing `daily` stock prices for a company over the period of `n` days. Your task is to determine the maximum profit you can achieve from a single buy-and-sell transaction. You can only buy one share of the stock and sell one share of the stock, but you must buy the stock before you sell it. Write a function that takes the array of daily stock prices as input and returns the maximum profit possible. If no profitable transaction is possible, return 0. ```python def max_profit(prices: List[int]) -> int: # Your code here ```","solution":"from typing import List def max_profit(prices: List[int]) -> int: if not prices or len(prices) < 2: return 0 min_price = prices[0] max_profit = 0 for price in prices[1:]: min_price = min(min_price, price) profit = price - min_price max_profit = max(max_profit, profit) return max_profit"},{"question":"You are given an array of strings `words` and a string `s`. Your task is to determine if `s` can be formed by concatenating a sequence of words from the array `words` (each word can be used multiple times). Return `true` if `s` can be formed, otherwise return `false`.","solution":"def can_form_string(words, s): Returns True if the string s can be formed by concatenating a sequence of words from the array words (each word can be used multiple times). Otherwise returns False. # Initialize a set to store the words for quick lookup word_set = set(words) # Initialize a list to handle dynamic programming approach dp = [False] * (len(s) + 1) dp[0] = True # Base case: an empty string can be formed trivially for i in range(1, len(s) + 1): for word in word_set: if dp[i - len(word)] and s[i - len(word):i] == word: dp[i] = True break # No need to check further if condition satisfied return dp[-1]"},{"question":"You are given two **0-indexed** integer arrays `startTime` and `endTime` of length `n`, where `startTime[i]` and `endTime[i]` represent the start and end times of the `i`th job, respectively. An array `profit` of length `n` represents the profit associated with the `i`th job. You\'re also given an integer `k`, which represents the maximum number of jobs you can select. Your task is to select the **maximum** number of non-overlapping jobs such that the sum of the selected profits is maximized. Return _the maximum profit you can achieve by selecting at most `k` jobs_.","solution":"# Function to find the maximum profit you can achieve by selecting at most k jobs def max_profit(startTime, endTime, profit, k): # Combining the start time, end time, and profit into a list of jobs jobs = list(zip(startTime, endTime, profit)) # Sorting jobs by their end times jobs.sort(key=lambda x: x[1]) # Memoization dictionary to store maximum profit at each step dp = {} def dfs(i, remaining_jobs): if remaining_jobs == 0 or i == len(jobs): return 0 if (i, remaining_jobs) in dp: return dp[(i, remaining_jobs)] # Binary search to find the next non-overlapping job l, r = i + 1, len(jobs) while l < r: mid = (l + r) // 2 if jobs[mid][0] >= jobs[i][1]: r = mid else: l = mid + 1 # Include the current job include = jobs[i][2] + dfs(l, remaining_jobs - 1) # Exclude the current job exclude = dfs(i + 1, remaining_jobs) dp[(i, remaining_jobs)] = max(include, exclude) return dp[(i, remaining_jobs)] return dfs(0, k)"},{"question":"Implement a class `FrequencyTracker` which keeps track of the frequency of elements in a dynamically updating array. The class should support the following operations: * `FrequencyTracker()` Initializes the `FrequencyTracker` object. * `void add(int number)` Adds `number` to the array. * `void deleteOne(int number)` Removes one occurrence of `number` from the array. If `number` does not exist, do nothing. * `int getFrequency(int number)` Returns the frequency of `number` in the array. If the number does not exist, return 0.","solution":"class FrequencyTracker: def __init__(self): self.frequency = {} def add(self, number): if number in self.frequency: self.frequency[number] += 1 else: self.frequency[number] = 1 def deleteOne(self, number): if number in self.frequency: self.frequency[number] -= 1 if self.frequency[number] == 0: del self.frequency[number] def getFrequency(self, number): return self.frequency.get(number, 0)"},{"question":"You are given a string `s` consisting of lowercase English letters, where each character in the string represents a colored tile. You can pick any substring of `s` and rearrange the characters within it at most once. The goal is to determine the maximum number of adjacent tiles of the same color that you can obtain. Return the maximum number of adjacent tiles of the same color after the optimal rearrangement.","solution":"def max_adjacent_tiles(s): Determine the maximum number of adjacent tiles of the same color after rearranging at most one substring of the input string. from collections import Counter # Get the frequency of each character frequency = Counter(s) max_freq = max(frequency.values()) # Determine the current maximum number of adjacent tiles cur_max = 1 cur_count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: cur_count += 1 cur_max = max(cur_max, cur_count) else: cur_count = 1 return max(cur_max, max_freq)"},{"question":"You are given two sorted arrays `nums1` and `nums2` of size `m` and `n` respectively. Both arrays are assumed to be non-empty and contain no duplicate elements. Your task is to find the length of the longest common subsequence (LCS) that can be formed by elements from `nums1` and `nums2`. The elements of the subsequence need not be contiguous, but their relative order should be maintained as in the original arrays. Return _the length of the longest common subsequence_.","solution":"def longest_common_subsequence(nums1, nums2): Returns the length of the longest common subsequence between two sorted arrays nums1 and nums2. m = len(nums1) n = len(nums2) # Create a 2D array to store the length of LCS dp = [[0] * (n + 1) for _ in range(m + 1)] # Fill the dp array for i in range(1, m + 1): for j in range(1, n + 1): if nums1[i - 1] == nums2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[m][n]"},{"question":"You are given an integer array `nums` representing the amount of money of each house, where the houses form a circular arrangement. You are a thief planning to rob houses such that adjacent houses in the circular arrangement cannot both be robbed on the same night. Write a function to determine the maximum amount of money you can rob tonight without alerting the police.","solution":"def rob(nums): Given an array nums representing the amount of money in each house in a circular arrangement, return the maximum amount of money that can be robbed without alerting the police. :param nums: List[int] :return: int if not nums: return 0 elif len(nums) == 1: return nums[0] elif len(nums) == 2: return max(nums[0], nums[1]) def rob_linear(houses): rob1, rob2 = 0, 0 for n in houses: new_rob = max(rob1 + n, rob2) rob1 = rob2 rob2 = new_rob return rob2 # Since it\'s a circle, we need to consider two cases: # 1. Rob from house 0 to house n-2 (excluding the last house) # 2. Rob from house 1 to house n-1 (excluding the first house) return max(rob_linear(nums[:-1]), rob_linear(nums[1:]))"},{"question":"You are given a string `s` consisting of lowercase English letters. You need to find the first letter to appear twice. Return that letter. If no letter appears twice, return an empty string.","solution":"def first_repeated_letter(s): Returns the first letter to appear twice in the string s. If no letter appears twice, returns an empty string. seen = set() for letter in s: if letter in seen: return letter seen.add(letter) return \\"\\""},{"question":"You are given an array of integers `height` representing the height of the terrain at different points. The width of each segment between points is 1. It can rain over this terrain, and water accumulates in pools based on the heights of the terrain. The depth of the water at any point is defined as the difference between the height of the tallest terrain to the left and the right of that point and the height of the terrain at that point. You need to return _the total amount of water that would accumulate after it rains_.","solution":"def trap(height): Return the total amount of water that would accumulate after it rains. :param height: List[int] - an array representing the height of the terrain. :return: int - total amount of water accumulated. if not height: return 0 left_max = [0] * len(height) right_max = [0] * len(height) left_max[0] = height[0] for i in range(1, len(height)): left_max[i] = max(left_max[i-1], height[i]) right_max[-1] = height[-1] for i in range(len(height)-2, -1, -1): right_max[i] = max(right_max[i+1], height[i]) water_trapped = 0 for i in range(len(height)): water_trapped += min(left_max[i], right_max[i]) - height[i] return water_trapped"},{"question":"You are given a list of transactions where each transaction is represented by a string `transactions[i]` with details: `<name>:<time>:<amount>:<city>`. You want to identify all transactions that are potentially suspicious. A transaction is considered suspicious if it meets any of the following conditions: 1. The amount exceeds 1000. 2. There exists another transaction with the same name that occurs within +/- 60 minutes of `transactions[i]` (including itself) and occurs in a different city. Return _a list of all the potentially suspicious transactions in any order_.","solution":"def get_suspicious_transactions(transactions): Returns a list of potentially suspicious transactions based on the given rules. :param transactions: List of transaction strings in the format <name>:<time>:<amount>:<city> :return: List of strings containing potentially suspicious transactions suspicious_transactions = [] transaction_list = [] for transaction in transactions: name, time, amount, city = transaction.split(\':\') transaction_list.append({ \'name\': name, \'time\': int(time), \'amount\': int(amount), \'city\': city, \'transaction\': transaction }) for i, t in enumerate(transaction_list): if t[\'amount\'] > 1000: suspicious_transactions.append(t[\'transaction\']) for j in range(len(transaction_list)): if i != j: t_other = transaction_list[j] if (t[\'name\'] == t_other[\'name\'] and t[\'city\'] != t_other[\'city\'] and abs(t[\'time\'] - t_other[\'time\']) <= 60): if t[\'transaction\'] not in suspicious_transactions: suspicious_transactions.append(t[\'transaction\']) if t_other[\'transaction\'] not in suspicious_transactions: suspicious_transactions.append(t_other[\'transaction\']) return suspicious_transactions"},{"question":"You are given a string `s` and an array of words. Each word consists of lowercase English letters. Your task is to determine how many words in the array can be formed by rearranging exactly the letters in `s`. For example, if `s = \\"abc\\"`, - `words = [\\"abc\\", \\"bca\\", \\"cab\\", \\"abcd\\"]` should return `3` because \\"abc\\", \\"bca\\", and \\"cab\\" can be formed by rearranging the letters in `s`, but \\"abcd\\" cannot as it contains an extra \'d\'. Return _the number of words that can be formed by rearranging exactly the letters in `s`_.","solution":"from collections import Counter def count_words_formed(s, words): Returns the count of words that can be formed by rearranging the letters in the string `s`. s_counter = Counter(s) count = 0 for word in words: if Counter(word) == s_counter: count += 1 return count"},{"question":"You are given a **balanced binary tree** represented as a list where parent nodes are listed before their children and `None` signifies missing nodes. Your task is to find and return the **lowest common ancestor** (LCA) of two given nodes in the binary tree. The LCA of two nodes `p` and `q` is defined as the lowest node that is an ancestor of both `p` and `q` (including `p` and `q` themselves). The binary tree is guaranteed to have all node values unique. Refer to the following specifications for your function: - The function should receive the binary tree represented as a list, and the two node values for which the LCA needs to be found. - Return the value of the LCA node. Example: ``` Input: tree = [3, 5, 1, 6, 2, 0, 8, None, None, 7, 4], p = 5, q = 1 Output: 3 ``` In this example, the input tree corresponds to the following binary tree: ``` 3 / 5 1 / / 6 2 0 8 / 7 4 ``` The LCA of nodes 5 and 1 is 3.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def build_tree(index, tree_list): if index >= len(tree_list) or tree_list[index] is None: return None node = TreeNode(tree_list[index]) node.left = build_tree(2*index + 1, tree_list) node.right = build_tree(2*index + 2, tree_list) return node def find_lca(root, p, q): if root is None or root.val == p or root.val == q: return root left = find_lca(root.left, p, q) right = find_lca(root.right, p, q) if left is not None and right is not None: return root return left if left is not None else right def lowest_common_ancestor(tree, p, q): root = build_tree(0, tree) lca_node = find_lca(root, p, q) return lca_node.val if lca_node else None"},{"question":"You are given an `m x n` integer matrix `grid` representing a maze where: - `0` represents an open path you can travel - `1` represents a wall you cannot pass through You start at the top-left corner of the maze at position `(0, 0)` and the goal is to reach the bottom-right corner at position `(m-1, n-1)`. You can move up, down, left, or right, but you cannot move diagonally. Write a function to determine the minimum number of steps required to reach the goal. If it is not possible to reach the goal, return `-1`.","solution":"from collections import deque def min_steps(grid): Returns the minimum number of steps required to reach the bottom-right corner of the maze from the top-left corner. If it is not possible to reach the goal, return -1. if not grid or grid[0][0] == 1 or grid[-1][-1] == 1: return -1 m, n = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] def is_valid(x, y): return 0 <= x < m and 0 <= y < n and grid[x][y] == 0 queue = deque([(0, 0, 0)]) # (x, y, steps) visited = set((0, 0)) while queue: x, y, steps = queue.popleft() if (x, y) == (m-1, n-1): return steps for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, steps + 1)) return -1"},{"question":"You are given a list of `words` and a list of `queries`. Each query consists of a prefix string. Your task is to return an array of integers where the ith element is the number of words in the list that start with the prefix given by the ith query. Implement a function that processes multiple queries efficiently and returns the correct counts for each prefix query.","solution":"def count_words_with_prefix(words, queries): For each query (prefix), count how many words in the list start with the given prefix. :param words: List of words. :param queries: List of prefix queries. :return: List of counts where each element is the number of words starting with the corresponding prefix query. from collections import defaultdict # Create a dictionary to store counts of prefixes prefix_count = defaultdict(int) # Count all possible prefixes in the words for word in words: prefix = \'\' for char in word: prefix += char prefix_count[prefix] += 1 # Collect counts for each query result = [] for query in queries: result.append(prefix_count[query]) return result"},{"question":"You are given two strings `s` and `t`. Determine if the given string `t` can be obtained by removing exactly one character from string `s`. If possible, return `true`; otherwise, return `false`.","solution":"def can_form_by_removing_one_char(s, t): Determines if string t can be obtained by removing exactly one character from string s. Args: s (str): The original string. t (str): The target string to be obtained. Returns: bool: True if t can be obtained by removing exactly one character from s, otherwise False. if len(s) - len(t) != 1: return False # Attempt to find the mismatch index between the two strings. for i in range(len(t)): if s[i] != t[i]: return s[i+1:] == t[i:] # If no mismatch found till the end, it means the difference is the last character. return True"},{"question":"You are given a string `s` consisting of lowercase English letters and an integer `k`. You need to construct a new string by reordering the letters of `s` such that every character that appears in `s` appears exactly once in the new string. If it is impossible to construct such a string, return an empty string. Otherwise, return the lexicographically smallest string possible that can be obtained by reordering the letters of `s` with the above constraints. Return _the **reordered** string or an empty string if it is not possible_.","solution":"def smallest_reordered_string(s, k): Constructs a new string by reordering the letters of s such that every character that appears in s appears exactly once in the new string and return the smallest lexicographical string. If it is impossible, return an empty string. Args: s (str): The input string. k (int): Unused parameter for this problem. Returns: str: The reordered string or an empty string if impossible. # Create a frequency dictionary for characters in the string from collections import Counter freq = Counter(s) # Check if any character appears more than once which would make it impossible for value in freq.values(): if value > 1: return \\"\\" # Return the lexicographically smallest string by sorting the keys return \'\'.join(sorted(freq.keys()))"},{"question":"Given a string `s` and an array of strings `words`, determine if `s` is an interleaving of all the strings in `words`. An interleaving of `words` is a string containing all characters of `words` and maintaining the relative order of characters from each string. Return `true` if `s` can be formed by interleaving the strings in `words`; otherwise, return `false`.","solution":"def is_interleaving(s, words): Determine if the string `s` is an interleaving of the strings in `words`. Parameters: s (str): The target string. words (list of str): List of strings to interleave. Returns: bool: True if `s` is an interleaving of `words`, False otherwise. def dfs(s, words, indices): if not s and all(i == len(words[j]) for j, i in enumerate(indices)): return True if not s: return False for idx, (w, i) in enumerate(zip(words, indices)): if i < len(w) and s[0] == w[i]: new_indices = indices[:] new_indices[idx] += 1 if dfs(s[1:], words, new_indices): return True return False return dfs(s, words, [0] * len(words))"},{"question":"You are given an integer array `arr` and an integer `k`. A contiguous subarray is called \\"good\\" if the product of all the elements in the subarray is less than `k`. Return _the number of good subarrays._ Example: - Input: `arr = [10, 5, 2, 6]`, `k = 100` - Output: 8","solution":"def num_subarray_product_less_than_k(arr, k): if k <= 1: return 0 product = 1 left = 0 count = 0 for right in range(len(arr)): product *= arr[right] while product >= k and left <= right: product /= arr[left] left += 1 count += (right - left + 1) return count"},{"question":"A company wants to monitor the performance of its employees. Each employee is assigned a score based on their performance during a specific period. Your task is to find out which employee has the highest cumulative score for any given subset of days. You are given an integer array `scores` where `scores[i]` represents the score of the employee on the `i-th` day. You are also given multiple queries, and each query is represented as a pair of integers `[start, end]` indicating the range of days for which you need to compute the cumulative score. Summing the scores over the specified range will give the score for that period. Return an array of integers where each element is the highest cumulative score for the corresponding query.","solution":"def highest_cumulative_scores(scores, queries): Returns the highest cumulative score for each query from the scores array. :param scores: List[int] - a list of integers representing the scores of employees :param queries: List[List[int]] - a list of queries where each query is a list of two integers [start, end] :return: List[int] - a list of integers representing the highest cumulative scores for each query results = [] for start, end in queries: cumulative_score = sum(scores[start:end+1]) results.append(cumulative_score) return results"},{"question":"You are given a list of integers `nums` representing the value of different houses along a street. You are a robber planning to rob these houses, but you cannot rob two adjacent houses because you would trigger the alarm. Given this, implement a function `maxRobbery(nums)` that returns the maximum amount of money you can rob tonight without robbing two consecutive houses. The function signature is `int maxRobbery(List<Integer> nums)`. If there are no houses, return `0`.","solution":"def maxRobbery(nums): Returns the maximum amount of money the robber can rob tonight without robbing two consecutive houses. if not nums: return 0 n = len(nums) if n == 1: return nums[0] # Initialize two variables to keep track of the maximum profit prev1, prev2 = 0, 0 for num in nums: temp = prev1 prev1 = max(prev2 + num, prev1) prev2 = temp return prev1"},{"question":"You are given an array of integers `nums` and an integer `k`. Design an algorithm that processes multiple sliding window queries efficiently. Each query consists of an integer `i`, and you need to determine the minimum element within the subarray starting from index `i` to index `i + k - 1` (both inclusive). The value of `k` is fixed for all queries. Implement the `SlidingWindowMinimum` class: * `SlidingWindowMinimum(int[] nums, int k)` Initializes the object with the integer array `nums` and the fixed integer `k`. * `int getMin(int i)` Returns the minimum element of the subarray starting from index `i` to index `i + k - 1`. If the window is out of the bounds of the array, return `-1`. The function `getMin` must run in `O(1)` average time complexity after an initial preprocessing step that runs in `O(n)` time complexity, where `n` is the length of `nums`.","solution":"from collections import deque class SlidingWindowMinimum: def __init__(self, nums, k): self.nums = nums self.k = k self.min_deque = deque() self.preprocess() def preprocess(self): Preprocess the sliding window minimum for all possible windows. self.min_arr = [None] * len(self.nums) for i in range(len(self.nums)): while self.min_deque and self.nums[self.min_deque[-1]] >= self.nums[i]: self.min_deque.pop() self.min_deque.append(i) # Remove elements which are out of this window if self.min_deque[0] <= i - self.k: self.min_deque.popleft() # Start storing values when i is at least k-1 if i >= self.k - 1: self.min_arr[i - self.k + 1] = self.nums[self.min_deque[0]] def getMin(self, i): Return the minimum element in the sliding window starting at index i. if i < 0 or i + self.k - 1 >= len(self.nums): return -1 return self.min_arr[i]"},{"question":"Given a string `s` and an integer `k`, you need to check if you can rearrange the characters in `s` such that the same characters are at least `k` distance apart from each other. If it is possible, return `true`, otherwise return `false`.","solution":"from collections import Counter import heapq def can_rearrange_chars(s, k): if k <= 1: return True char_freq = Counter(s) max_heap = [(-freq, char) for char, freq in char_freq.items()] heapq.heapify(max_heap) queue = [] result = [] while max_heap: freq, char = heapq.heappop(max_heap) result.append(char) queue.append((freq + 1, char)) # store (freq + 1, char) to reinsert back to heap if len(queue) >= k: # We maintain queue of size k item = queue.pop(0) if -item[0] > 0: heapq.heappush(max_heap, item) return len(result) == len(s)"},{"question":"Given a directed graph represented by an integer `n` specifying the number of nodes and a 2D integer array `edges` of length `m` where `edges[i] = [u, v, w]` denotes a directed edge from node `u` to node `v` with a weight `w`, find the shortest path from node `0` to all other nodes. Return an array `dist` where `dist[i]` denotes the shortest distance from node `0` to node `i`. If a node is unreachable, its distance should be reported as `-1`. Use Dijkstra\'s algorithm for this purpose.","solution":"import heapq def dijkstra(n, edges): Implements Dijkstra\'s algorithm to find the shortest path from node 0 to all other nodes. Parameters: n (int): The number of nodes in the graph. edges (List[List[int]]): The edges of the graph where each edge is represented as [u, v, w]. u: Starting node of the edge. v: Ending node of the edge. w: Weight of the edge. Returns: List[int]: The shortest distances from node 0 to all other nodes. If a node is unreachable, its distance is -1. graph = {i: [] for i in range(n)} for u, v, w in edges: graph[u].append((v, w)) # Distance table, initialized to infinity dist = [float(\'inf\')] * n dist[0] = 0 # Priority queue for the minimum distance pq = [(0, 0)] # (distance, node) while pq: curr_dist, u = heapq.heappop(pq) if curr_dist > dist[u]: continue for v, weight in graph[u]: distance = curr_dist + weight if distance < dist[v]: dist[v] = distance heapq.heappush(pq, (distance, v)) return [d if d != float(\'inf\') else -1 for d in dist]"},{"question":"Given an integer array `arr` and an integer `k`, rearrange the array such that every `k` consecutive elements form a subarray, and each subarray has its elements sorted in non-decreasing order. Return _the modified array_. If it\'s not possible to rearrange the array as required, return `-1`. Note that the array can have duplicates, and the total number of elements in the array may not necessarily be divisible by `k`.","solution":"def rearrange_and_sort_subarrays(arr, k): Rearranges the array such that every k consecutive elements form a sorted subarray. Args: arr (list): The list of integers to be rearranged. k (int): The size of each subarray. Returns: list: The modified array with sorted subarrays of size k or -1 if it\'s not possible. if k <= 0 or not arr: return -1 length = len(arr) # If k is greater than the array length, return the sorted array if k >= length: return sorted(arr) # Otherwise, sort each k-length subarray result = [] for i in range(0, length, k): subarray = arr[i:i+k] result.extend(sorted(subarray)) return result"},{"question":"You are given a list of integers `heights` where each integer represents the height of a building. You need to return _the maximum area of water that can be trapped between any two buildings_. The width between two buildings is calculated as the number of buildings between them plus one. The trapped water area is calculated as the minimum height of the two buildings chosen multiplied by the width between them. Consider the buildings positioned at indices `i` and `j` with `i < j`.","solution":"def max_water_area(heights): Returns the maximum area of water that can be trapped between any two buildings. Args: heights: List[int] - a list of integers representing the heights of the buildings Returns: int - the maximum water area max_area = 0 left, right = 0, len(heights) - 1 while left < right: height = min(heights[left], heights[right]) width = right - left max_area = max(max_area, height * width) if heights[left] < heights[right]: left += 1 else: right -= 1 return max_area"},{"question":"Write a function that takes in a string representing a **mathematical expression** containing only non-negative integers and the operators `+`, `-`, `*`, and `/` (where `/` represents integer division). The function should evaluate the expression and return the result as an integer. The given expression is guaranteed to be valid and follows the standard order of operations (PEMDAS/BODMAS rules). You may assume there are no leading or trailing spaces, and the input represents a valid expression.","solution":"def evaluate_expression(expression): Evaluates a mathematical expression containing non-negative integers and +, -, *, / operators and returns the result as an integer. def helper(tokens): stack, num, sign = [], 0, \'+\' while tokens: token = tokens.pop(0) if token.isdigit(): num = int(token) if token in \\"+-*/\\" or not tokens: if sign == \'+\': stack.append(num) elif sign == \'-\': stack.append(-num) elif sign == \'*\': stack.append(stack.pop()*num) elif sign == \'/\': stack.append(int(stack.pop()/num)) sign = token num = 0 return sum(stack) # splitting the expression into tokens tokens = [] current_token = [] for char in expression: if char.isdigit(): current_token.append(char) else: if current_token: tokens.append(\'\'.join(current_token)) current_token = [] tokens.append(char) if current_token: tokens.append(\'\'.join(current_token)) return helper(tokens)"},{"question":"Your task is to implement a data structure that simulates a **stack** which supports **pushing, popping**, and **retrieving the minimum element in constant time**. The `Stack` should have the following methods: - `push(int x)`: Pushes element `x` onto the stack. - `pop()`: Removes the top element from the stack. - `top()`: Gets the top element of the stack. - `getMin()`: Retrieves the minimum element in the stack. Note that `pop`, `top`, and `getMin` should all operate in constant time.","solution":"class MinStack: def __init__(self): Initialize your data structure here. self.stack = [] self.min_stack = [] def push(self, x: int): Push element x onto stack. :param x: Element to push self.stack.append(x) if not self.min_stack or x <= self.min_stack[-1]: self.min_stack.append(x) def pop(self): Removes the element on the top of the stack. if self.stack: if self.stack[-1] == self.min_stack[-1]: self.min_stack.pop() self.stack.pop() def top(self) -> int: Get the top element. :return: Top element if self.stack: return self.stack[-1] return None def getMin(self) -> int: Retrieve the minimum element in the stack. :return: Minimum element if self.min_stack: return self.min_stack[-1] return None"},{"question":"Given a 2D grid of size `m x n` represented by a binary matrix `grid`, where `0` represents water and `1` represents land, find and return _the length of the shortest path between two land cells_. You can move up, down, left, or right from a land cell. If there is no such path, return `-1`.","solution":"from collections import deque def shortestPath(grid): Function to find the shortest path between two land cells in a binary matrix. Parameters: grid (list of list of int): 2D binary matrix representing the grid Returns: int: Length of the shortest path between two land cells, or -1 if no such path exists m, n = len(grid), len(grid[0]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] def bfs(start_x, start_y): visited = [[False]*n for _ in range(m)] queue = deque([(start_x, start_y, 0)]) visited[start_x][start_y] = True while queue: x, y, dist = queue.popleft() for dx, dy in directions: nx, ny = x+dx, y+dy if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny]: if grid[nx][ny] == 1: return dist + 1 if grid[nx][ny] == 0: visited[nx][ny] = True queue.append((nx, ny, dist+1)) return float(\'inf\') shortest_path = float(\'inf\') found_land = False for i in range(m): for j in range(n): if grid[i][j] == 1: found_land = True shortest_path = min(shortest_path, bfs(i, j)) return -1 if shortest_path == float(\'inf\') else shortest_path"},{"question":"A warehouse manager needs to optimize the storage of various products in a series of bins. Each bin has a fixed capacity, and each product type has a specific volume. You are given an array `products` where `products[i]` represents the volume of product type `i`, and an integer `binCapacity` representing the maximum capacity of each bin. Write a function that returns the **minimum number of bins required** to store all the products such that no bin\'s total volume exceeds `binCapacity`. If it\'s not possible to fit all products within the given bins, return `-1`.","solution":"def min_bins(products, binCapacity): Given a list of product volumes and a bin capacity, returns the minimum number of bins required to store all the products. If it\'s not possible, returns -1. products.sort(reverse=True) bins = [] for volume in products: placed = False for i in range(len(bins)): if bins[i] + volume <= binCapacity: bins[i] += volume placed = True break if not placed: if volume > binCapacity: return -1 bins.append(volume) return len(bins)"},{"question":"You are given a string `s` of length `n` which contains only the characters \'a\' and \'b\'. You are allowed to delete at most `k` characters from the string. Your task is to determine the length of the longest substring that contains only one unique character after making at most `k` deletions. Return the length of the longest substring.","solution":"def longest_substring_with_k_deletions(s, k): Returns the length of the longest substring that contains only one unique character after making at most k deletions. n = len(s) if n == 0: return 0 def longest_substring_with_k_replace(char): max_length = 0 left = 0 max_count = 0 counts = {\'a\': 0, \'b\': 0} for right in range(n): counts[s[right]] += 1 max_count = max(max_count, counts[s[right]]) while (right - left + 1) - max_count > k: counts[s[left]] -= 1 left += 1 max_length = max(max_length, right - left + 1) return max_length return max(longest_substring_with_k_replace(\'a\'), longest_substring_with_k_replace(\'b\'))"},{"question":"You are given an integer array `nums` representing the amount of money of each house designated by index. You are also given several queries represented by a list of intervals `queries`, where each query is a pair of indices representing a range of houses. For each query, determine the maximum amount of money that can be robbed without alerting the police (i.e., you cannot rob two adjacent houses). Return an array of results where each result corresponds to a query in `queries`.","solution":"def rob(nums, queries): Determines the maximum amount of money that can be robbed for each query without alerting the police. def rob_linear(houses): Helper function to implement the house robber algorithm for a linear street of houses. if not houses: return 0 if len(houses) == 1: return houses[0] if len(houses) == 2: return max(houses) dp = [0] * len(houses) dp[0] = houses[0] dp[1] = max(houses[0], houses[1]) for i in range(2, len(houses)): dp[i] = max(dp[i-1], dp[i-2] + houses[i]) return dp[-1] results = [] for start, end in queries: sub_array = nums[start:end+1] max_robbed = rob_linear(sub_array) results.append(max_robbed) return results"},{"question":"You are given a string `s` consisting of lowercase English letters. A **palindrome** is a string that reads the same forward and backward. You are allowed to replace exactly one character in `s` with any other lowercase English letter. Your task is to determine whether it is possible to create a palindrome by performing this operation at most once. If it is possible, return `true`; otherwise, return `false`.","solution":"def can_be_palindrome(s): Check if string s can be turned into a palindrome by changing at most one character. Parameters: s (str): The input string Returns: bool: True if the string can be turned into a palindrome, False otherwise n = len(s) # Count how many mismatched pairs there are mismatch_count = 0 for i in range(n // 2): if s[i] != s[n - 1 - i]: mismatch_count += 1 if mismatch_count > 1: return False return True"},{"question":"Write a function that takes a string `s` containing only the characters `A`, `B`, and `C`, and an integer `k`. Return the length of the longest substring in `s` that contains at most `k` different characters. If there is no such substring, return `0`.","solution":"def longest_substring_with_k_chars(s, k): Returns the length of the longest substring in `s` that contains at most `k` different characters. if k == 0: return 0 window_start = 0 max_length = 0 char_frequency = {} for window_end in range(len(s)): right_char = s[window_end] if right_char not in char_frequency: char_frequency[right_char] = 0 char_frequency[right_char] += 1 while len(char_frequency) > k: left_char = s[window_start] char_frequency[left_char] -= 1 if char_frequency[left_char] == 0: del char_frequency[left_char] window_start += 1 max_length = max(max_length, window_end - window_start + 1) return max_length"},{"question":"You are given a **directed acyclic graph** (DAG) represented as an **adjacency list**, where each node is a unique integer and the list contains pairs of nodes indicating the direction of the edge from the first node to the second node. Implement a function to find the **longest path** in the graph. Return the length of the longest path.","solution":"def find_longest_path(adj_list): Finds the length of the longest path in a directed acyclic graph (DAG). Args: adj_list (dict): The adjacency list of the DAG where keys are nodes and values are lists of neighboring nodes. Returns: int: The length of the longest path in the graph. def topological_sort(node, visited, stack): Helper function to perform a topological sort on the graph. visited[node] = True if node in adj_list: for neighbor in adj_list[node]: if not visited[neighbor]: topological_sort(neighbor, visited, stack) stack.append(node) def longest_path_from_node(node): Helper function to find the longest path from a given node using Dynamic Programming. if dp[node] is not None: return dp[node] max_length = 0 if node in adj_list: for neighbor in adj_list[node]: max_length = max(max_length, 1 + longest_path_from_node(neighbor)) dp[node] = max_length return max_length # Initialize visited dictionary and stack for topological sort visited = {node: False for node in adj_list} stack = [] # Perform topological sort for all nodes to get the ordering of nodes for node in adj_list: if not visited[node]: topological_sort(node, visited, stack) # Initialize the dp dictionary for memoization dp = {node: None for node in adj_list} # Calculate the longest path for all nodes longest_path_length = 0 while stack: node = stack.pop() longest_path_length = max(longest_path_length, longest_path_from_node(node)) return longest_path_length"},{"question":"You are given an array of `n` integers, `nums`, where each element represents the score of a student in a class. You are also provided with an integer `k`, which indicates the number of top scores you are interested in. Write a function to find the `k` highest scores in the array `nums`. Ensure your function returns the scores in descending order. If there are fewer than `k` unique scores, include all unique scores in the output. Return an array of the `k` highest scores sorted in descending order.","solution":"def top_k_scores(nums, k): Returns the k highest scores in descending order. If there are fewer than k unique scores, returns all unique scores in descending order. :param nums: List of integers representing scores :param k: Integer representing the number of top scores to return :return: List of top k scores in descending order # Convert the list to a set to get unique scores and sort them in descending order unique_scores = sorted(set(nums), reverse=True) # Return the top k scores return unique_scores[:k]"},{"question":"Given the head of a singly linked list, reverse the list, and return the reversed list. A singly linked list is a data structure containing a series of nodes, where each node contains a value and a reference to the next node in the sequence. Each node is defined as: ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next ``` Write a function `reverseList` that takes the head of a singly linked list and returns the head of the newly reversed list.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverseList(head): Reverses a singly linked list. Parameters: head (ListNode): The head of the singly linked list. Returns: ListNode: The head of the reversed list. prev = None current = head while current is not None: next_temp = current.next # Store next node current.next = prev # Reverse current node\'s pointer prev = current # Move prev and current one step forward current = next_temp return prev"},{"question":"A city planning committee wants to optimize the layout of their parks to ensure that every resident has access to at least one park within a certain distance. Given a 2D grid `city_area` of size `m x n`, where `0` represents an empty space, `1` represents an existing park, and `-1` represents an obstacle that cannot be traversed, you need to determine the minimum distance from each empty space to the nearest park. Return a 2D grid of the same size where each cell contains the minimum distance to the nearest park, or `-1` if the cell is an obstacle or cannot reach any park. If there are multiple parks, consider the shortest distance to any of them. Use the Manhattan distance as the distance metric.","solution":"from collections import deque def min_distance_to_park(city_area): Returns a 2D grid where each cell contains the minimum distance to the nearest park. -1 if the cell is an obstacle or cannot reach any park. if not city_area: return [] rows, cols = len(city_area), len(city_area[0]) result = [[-1] * cols for _ in range(rows)] queue = deque() # Enqueue all parks and mark distances for obstacles for r in range(rows): for c in range(cols): if city_area[r][c] == 1: queue.append((r, c)) result[r][c] = 0 elif city_area[r][c] == -1: result[r][c] = -1 directions = [(1, 0), (0, 1), (-1, 0), (0, -1)] # BFS to find the shortest path to the nearest park while queue: x, y = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and result[nx][ny] == -1 and city_area[nx][ny] == 0: result[nx][ny] = result[x][y] + 1 queue.append((nx, ny)) return result"},{"question":"You are given an integer array `tasks` where `tasks[i]` represents the amount of time required to complete the `i-th` task. Each task can be completed in either one or two hours. Your goal is to pair the tasks in such a way that every pair of tasks must take exactly two hours to complete. Return the minimum number of pairs required to complete all the tasks, or return `-1` if it is impossible to create the required pairs.","solution":"def min_pairs_to_complete_tasks(tasks): This function returns the minimum pairs required to make every pair of tasks equal to 2 hours or -1 if it\'s impossible. Parameters: tasks (List[int]): List of integers where each integer is 1 or 2. Returns: int: Minimum number of pairs or -1 if impossible. if not tasks: return 0 ones = tasks.count(1) twos = tasks.count(2) if ones % 2 != 0: return -1 return twos + ones // 2"},{"question":"You are tasked with implementing a simplified text editor that supports the following functionalities: * **Append** characters to the end of the current text. * **Delete** the last `k` characters from the current text. * **Retrieve** the last `k` characters from the current text without modifying it. Implement the `TextEditor` class: * `TextEditor()` Initializes the object with an empty string. * `void append(String text)` Adds the provided `text` to the end of the current string in the text editor. * `void delete(int k)` Deletes the last `k` characters from the current string in the text editor. If `k` exceeds the length of the current string, delete the entire string. * `String retrieve(int k)` Returns a string containing the last `k` characters from the current string. If `k` exceeds the length of the current string, return the entire string.","solution":"class TextEditor: def __init__(self): self.text = \\"\\" def append(self, text): self.text += text def delete(self, k): if k >= len(self.text): self.text = \\"\\" else: self.text = self.text[:-k] def retrieve(self, k): if k >= len(self.text): return self.text else: return self.text[-k:]"},{"question":"You are given an `m x n` binary matrix `grid`, where `0` represents an empty cell and `1` represents a blocked cell. You are also given an array `start` containing the starting point\'s coordinates `[x, y]` and an array `end` containing the ending point\'s coordinates `[a, b]`. You need to find the shortest path from `start` to `end` such that you only move either up, down, left, or right. Return _the length of the shortest path_ from `start` to `end`, or `-1` if no such path exists.","solution":"from collections import deque def shortest_path_binary_matrix(grid, start, end): Finds the shortest path from start to end in a binary matrix. Args: grid (list of lists): The binary matrix. start (list): The starting point [x, y]. end (list): The ending point [a, b]. Returns: int: The length of the shortest path, or -1 if no such path exists. m, n = len(grid), len(grid[0]) sx, sy = start ex, ey = end if grid[sx][sy] == 1 or grid[ex][ey] == 1: return -1 directions = [(0,1), (1,0), (0,-1), (-1,0)] queue = deque([(sx, sy, 0)]) visited = set((sx, sy)) while queue: x, y, dist = queue.popleft() if (x, y) == (ex, ey): return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 0 and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1"},{"question":"You are given a **0-indexed** integer array `nums` consisting of `n` positive integers. You are allowed to perform the following operation any number of times: Choose two adjacent elements in the array and replace both of them with their sum. The goal is to minimize the size of the array by performing the operation until no more adjacent elements can be selected. Return _the minimum possible size of the array after performing the operation._","solution":"def minimize_array_size(nums): Minimizes the size of the array by performing the operation of replacing two adjacent elements with their sum any number of times. Parameters: nums (list of int): The input list of positive integers. Returns: int: The minimum possible size of the array. # If the array is empty or has only one element, return its size if len(nums) < 2: return len(nums) # The minimum possible size of the array after performing the operation return 1"},{"question":"You are given an array of integers `arr` and an integer `k`. Determine whether you can find a pair of integers in `arr` such that their sum is equal to `k`. Return `true` if such a pair exists, and `false` otherwise. **Note:** Each element in the array can be used only once, and you may assume that the array contains no duplicate elements.","solution":"def has_pair_with_sum(arr, k): Determines if there are any two distinct integers in the array `arr` that sum up to `k`. Parameters: - arr (list of int): The array of integers. - k (int): The target sum. Returns: - bool: True if there is a pair of integers in `arr` that sum up to `k`, False otherwise. seen = set() for number in arr: complement = k - number if complement in seen: return True seen.add(number) return False"},{"question":"You are given three integer arrays `num1`, `num2`, and `num3` that are both sorted in ascending order. A **magic triplet** is a triplet `(x, y, z)` such that `x` belongs to `num1`, `y` belongs to `num2`, and `z` belongs to `num3`, and they meet the condition `x < y < z`. Write a function to determine the maximum sum of all possible magic triplets, or return `0` if no such triplet exists.","solution":"def max_sum_magic_triplet(num1, num2, num3): This function finds the maximum sum of all possible magic triplets (x, y, z) such that x belongs to num1, y belongs to num2, z belongs to num3 and x < y < z. If no such triplet exists, it returns 0. max_sum = 0 found_triplet = False for x in num1: for y in num2: if y > x: for z in num3: if z > y: found_triplet = True max_sum = max(max_sum, x + y + z) return max_sum if found_triplet else 0"},{"question":"Given a list of `n` courses represented as pairs `[courseA, courseB]`, where `courseA` is a prerequisite for `courseB`, determine if it is possible to finish all courses. Return `true` if you can finish all courses, or `false` if there is a cycle in the prerequisites that makes it impossible to complete all courses. The list of courses and prerequisites may not necessarily define a connected graph.","solution":"from collections import defaultdict, deque def can_finish(num_courses, prerequisites): Determine if it is possible to finish all courses given the prerequisites. Args: num_courses (int): The total number of courses. prerequisites (list): A list of pairs representing prerequisites. Returns: bool: True if it\'s possible to finish all courses, False otherwise. in_degree = [0] * num_courses adj_list = defaultdict(list) for crs, pre in prerequisites: adj_list[pre].append(crs) in_degree[crs] += 1 zero_in_degree_queue = deque([i for i in range(num_courses) if in_degree[i] == 0]) visited = 0 while zero_in_degree_queue: course = zero_in_degree_queue.popleft() visited += 1 for neighbor in adj_list[course]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: zero_in_degree_queue.append(neighbor) return visited == num_courses"},{"question":"Given two arrays of integers, `weights` and `values`, and an integer `maxWeight`, determine the maximum total value that can be obtained by selecting a subset of the items such that the total weight does not exceed `maxWeight`. Each item can only be selected once. Return the maximum total value obtainable. Note that the total weight is the sum of the weights of the selected items, and the total value is the sum of the values of the selected items.","solution":"def knapsack(weights, values, maxWeight): Returns the maximum total value that can be obtained by selecting a subset of items where the total weight does not exceed maxWeight. :param weights: List[int], the weights of the items :param values: List[int], the values of the items :param maxWeight: int, the maximum total weight allowed :return: int, the maximum total value obtainable within the weight constraint n = len(weights) dp = [[0] * (maxWeight + 1) for _ in range(n + 1)] for i in range(n + 1): for w in range(maxWeight + 1): if i == 0 or w == 0: dp[i][w] = 0 elif weights[i-1] <= w: dp[i][w] = max(values[i-1] + dp[i-1][w-weights[i-1]], dp[i-1][w]) else: dp[i][w] = dp[i-1][w] return dp[n][maxWeight]"},{"question":"Given an array of integers `arr`, return a 2D array of integers `result` such that `result[i] = [start_index, end_index]` represents the start and end indices of the longest consecutive subarray `arr[start_index:end_index + 1]` in which the difference between any two consecutive elements is consistent and equal. If there are multiple subarrays of the same maximum length, return the indices of the first one. If the array is empty, return an empty list.","solution":"def longest_consistent_subarray(arr): Returns the start and end indices of the longest consecutive subarray with consistent differences between consecutive elements. If the array is empty, return an empty list. if not arr: return [] max_length = 1 curr_length = 1 start_index = 0 end_index = 0 temp_start = 0 for i in range(1, len(arr)): if i == 1: diff = arr[i] - arr[i - 1] if arr[i] - arr[i - 1] == diff: curr_length += 1 if curr_length > max_length: max_length = curr_length start_index = temp_start end_index = i else: diff = arr[i] - arr[i - 1] temp_start = i - 1 curr_length = 2 return [start_index, end_index]"},{"question":"You are given a list of integers `candies` where `candies[i]` represents the number of candies in the `i-th` bag. You are also given an integer `extraCandies`, which represents the number of extra candies you can give to any of the children. Return a list of boolean values representing whether the ith child can have the greatest number of candies among all the children if they were given all the `extraCandies`. For instance, if `candies` = [2,3,5,1,3] and `extraCandies` = 3, the result should be `[true, true, true, false, true]`. Note: The list should not include intermediate calculations, explanations, or specific example answers, and should align with the style and structure of the existing questions.","solution":"def kids_with_candies(candies, extraCandies): Returns a list of boolean values representing whether the ith child can have the greatest number of candies among all the children if they were given all the extraCandies. max_candies = max(candies) return [candy + extraCandies >= max_candies for candy in candies]"},{"question":"You are given a `0-indexed` string `s` consisting of lowercase English letters, and an integer `k`. A palindrome is a string that reads the same forward and backward. Your task is to remove up to `k` characters from `s` so that the resulting string is a palindrome. You must determine the smallest possible `k` for which it is possible to convert `s` into a palindrome. Return _the smallest number of characters to remove to make the string a palindrome_.","solution":"def min_removals_to_palindrome(s: str, k: int) -> int: Computes the smallest number of characters to remove to make string s a palindrome. Args: s (str): The input string. k (int): The maximum number of characters that can be removed. Returns: int: The minimum number of characters to remove to make s a palindrome. n = len(s) # Function to find longest palindromic subsequence def longest_palindromic_subseq(s: str) -> int: dp = [[0] * n for _ in range(n)] for i in range(n): dp[i][i] = 1 for cl in range(2, n + 1): for i in range(n - cl + 1): j = i + cl - 1 if s[i] == s[j] and cl == 2: dp[i][j] = 2 elif s[i] == s[j]: dp[i][j] = dp[i + 1][j - 1] + 2 else: dp[i][j] = max(dp[i][j - 1], dp[i + 1][j]) return dp[0][n - 1] lps_length = longest_palindromic_subseq(s) min_removals = n - lps_length return min_removals if min_removals <= k else -1"},{"question":"Given an array of integers `arr`, consider all possible subarrays. For each subarray, compute the product of its elements. Return the sum of these products for all subarrays. A **subarray** is a contiguous part of the original array. For example, the subarrays of `[1, 2, 3]` are `[1]`, `[2]`, `[3]`, `[1, 2]`, `[2, 3]`, and `[1, 2, 3]`. Consider the array `[1, 2, 3]`: - The product of `[1]` is 1. - The product of `[2]` is 2. - The product of `[3]` is 3. - The product of `[1, 2]` is 2. - The product of `[2, 3]` is 6. - The product of `[1, 2, 3]` is 6. The sum of these products is `1 + 2 + 3 + 2 + 6 + 6 = 20`. Given an array `arr`, return the sum of the products of all its subarrays.","solution":"def sum_of_subarray_products(arr): Returns the sum of the products of all subarrays of the input array `arr`. n = len(arr) total_sum = 0 # Iterate over all possible starting points of subarrays for start in range(n): product = 1 # Iterate over all possible ending points of subarrays starting from \'start\' for end in range(start, n): product *= arr[end] total_sum += product return total_sum"},{"question":"Given a string `s` and a list of strings `words`, determine the number of subsequences of `s` that are equal to any word in `words`. A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements. Return the number of matching subsequences.","solution":"def num_matching_subsequences(s, words): Function to determine the number of subsequences of `s` that are equal to any word in `words`. Args: s (str): the main string. words (List[str]): list of words to match as subsequences. Returns: int: the count of matching subsequences. def is_subsequence(s, word): it = iter(s) return all(char in it for char in word) return sum(is_subsequence(s, word) for word in words)"},{"question":"Given a string `s` representing a sentence where each word consists of lowercase English letters, and a list of `k` lowercase English words `forbiddenWords`, determine if it is possible to remove one or more words from the sentence such that no forbidden word appears as a contiguous subsequence in the resulting sentence. Return `YES` if it is possible, otherwise return `NO`. A subsequence here means any sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.","solution":"def is_removal_possible(sentence, forbiddenWords): Determines if it is possible to remove one or more words such that no forbidden word appears as a contiguous subsequence in the resulting sentence. Parameters: sentence (str): The input sentence. forbiddenWords (list): List of forbidden words. Returns: str: \\"YES\\" if it is possible, otherwise \\"NO\\". words = sentence.split() for fword in forbiddenWords: fword_list = list(fword) f_idx = 0 for word in words: word_list = list(word) temp_idx = 0 while f_idx < len(fword_list) and temp_idx < len(word_list): if fword_list[f_idx] == word_list[temp_idx]: f_idx += 1 temp_idx += 1 if f_idx >= len(fword_list): break if f_idx >= len(fword_list): return \\"YES\\" return \\"NO\\""},{"question":"Given an *m* x *n* matrix of characters `board` and a string `word`, return `true` if `word` exists in the grid. The word can be constructed from letters of sequentially adjacent cells, where \\"adjacent\\" cells are horizontally or vertically neighboring. The same letter cell may not be used more than once. For example, given `board = [[\'A\',\'B\',\'C\',\'E\'], [\'S\',\'F\',\'C\',\'S\'], [\'A\',\'D\',\'E\',\'E\']]` and `word = \\"ABCCED\\"`, the function should return `true` since the word \\"ABCCED\\" can be constructed as follows: ``` [ [\'A\',\'B\',\'C\',\'E\'], [\'S\',\'F\',\'C\',\'S\'], [\'A\',\'D\',\'E\',\'E\'] ] ``` The starting point is the top left \'A\'. The path then goes B -> C -> C -> E -> D. The constraints are: - *m* == `board.length` - *n* == `board[i].length` - 1 <= *m*, *n* <= 200 - 1 <= `word.length` <= 10^3 - `board` and `word` consists only of lowercase and uppercase English letters.","solution":"def exist(board, word): Check if the word exists in the grid. Parameters: board (List[List[str]]): 2D grid of characters word (str): word to search for in the grid Returns: bool: True if the word exists in the grid, otherwise False def dfs(board, word, i, j, k): if k == len(word): return True # Check bounds and character match if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != word[k]: return False temp = board[i][j] board[i][j] = \\"\\" # Recursively search in all 4 possible directions res = dfs(board, word, i + 1, j, k + 1) or dfs(board, word, i - 1, j, k + 1) or dfs(board, word, i, j + 1, k + 1) or dfs(board, word, i, j - 1, k + 1) board[i][j] = temp # backtracking return res for i in range(len(board)): for j in range(len(board[0])): if dfs(board, word, i, j, 0): return True return False"},{"question":"You are given a string `s` consisting of lowercase English letters. A \\"balancing\\" operation consists of removing two adjacent characters that are the same (e.g., \\"aa\\" or \\"bb\\"). Continuously perform this operation until no more adjacent characters are the same. Return the resulting string after all possible balancing operations have been performed. If the resulting string is empty, return an empty string.","solution":"def balance_string(s): Continuously removes adjacent matching characters from the string until no more adjacent matching characters exist and returns the resulting string. Args: s (str): Input string consisting of lowercase English letters. Returns: str: The resulting string after all balancing operations have been performed. stack = [] for char in s: if stack and stack[-1] == char: stack.pop() else: stack.append(char) return \'\'.join(stack)"},{"question":"You are given a `string` that represents a valid expression consisting of numbers and operators (`+`, `-`, `*`, `/`). The expression is fully parenthesized, meaning that each operation is explicitly surrounded by parentheses, and each pair of parentheses encapsulates a sub-expression that needs to be evaluated independently. Write a function that evaluates the expression and returns the result as an integer. Note that each division operation is integer division which truncates towards zero.","solution":"def evaluate_expression(expression): Evaluates a fully parenthesized expression containing integers and the operators +, -, *, / (integer division). Args: expression (str): A string representing a fully parenthesized expression. Returns: int: The result of evaluating the expression. def evaluate(tokens): token = tokens.pop(0) if token == \'(\': left_operand = evaluate(tokens) operator = tokens.pop(0) right_operand = evaluate(tokens) tokens.pop(0) # Remove the closing parenthesis if operator == \'+\': return left_operand + right_operand elif operator == \'-\': return left_operand - right_operand elif operator == \'*\': return left_operand * right_operand elif operator == \'/\': return left_operand // right_operand else: return int(token) import re tokens = re.findall(r\'d+|[()+-*/]\', expression) return evaluate(tokens)"},{"question":"You are given a list of `houses` and `heaters` positioned on a horizontal line, both of which are arrays of integers sorted in non-decreasing order. Each house can be warmed by a heater that is positioned within its radius. The radius of a heater is the maximum distance that a house can be away from the heater and still be warmed by it. Your task is to find the minimum radius needed for every house to be warmed by at least one heater. Return _the minimum radius required_ such that each house is within the radius of at least one heater.","solution":"def find_minimum_radius(houses, heaters): Find the minimum radius required for each house to be within the radius of at least one heater. Args: houses (List[int]): List of house positions. heaters (List[int]): List of heater positions. Returns: int: The minimum radius required. # Sort the houses and heaters arrays if they are not sorted houses.sort() heaters.sort() def closest_heater_distance(house, heaters): Find the minimum distance to the closest heater for a given house. Args: house (int): Position of the house. heaters (List[int]): List of heater positions. Returns: int: The minimum distance to the closest heater. left, right = 0, len(heaters) - 1 while left <= right: mid = (left + right) // 2 if heaters[mid] == house: return 0 # house is exactly at the heater elif heaters[mid] < house: left = mid + 1 else: right = mid - 1 dist_left = abs(house - heaters[right]) if right >= 0 else float(\'inf\') dist_right = abs(house - heaters[left]) if left < len(heaters) else float(\'inf\') return min(dist_left, dist_right) max_radius = 0 for house in houses: max_radius = max(max_radius, closest_heater_distance(house, heaters)) return max_radius"},{"question":"You are given a string `s` containing only digits and lowercase English letters. Each digit from `1` to `9` corresponds to a group of lowercase English letters according to the mapping: `\'2\' -> \\"abc\\"`, `\'3\' -> \\"def\\"`, `\'4\' -> \\"ghi\\"`, `\'5\' -> \\"jkl\\"`, `\'6\' -> \\"mno\\"`, `\'7\' -> \\"pqrs\\"`, `\'8\' -> \\"tuv\\"`, `\'9\' -> \\"wxyz\\"`. Return _all possible letter combinations that the number could represent_ in **lexicographical** order. You can return the answer in **any** order if the input string is empty, return an empty list.","solution":"from itertools import product def letter_combinations(s): Returns all possible letter combinations that the string of digits could represent. if not s: return [] digit_to_chars = { \'2\': \\"abc\\", \'3\': \\"def\\", \'4\': \\"ghi\\", \'5\': \\"jkl\\", \'6\': \\"mno\\", \'7\': \\"pqrs\\", \'8\': \\"tuv\\", \'9\': \\"wxyz\\" } # Filter digits and corresponding characters groups = [digit_to_chars[digit] for digit in s if digit in digit_to_chars] # Handle the case where no valid digits exist in input if not groups: return [] # Calculate the product of these character groups combinations = product(*groups) # Convert the tuples to strings result = [\'\'.join(combination) for combination in combinations] # Return the combinations in lexicographical order return sorted(result)"},{"question":"You are given an integer array `nums` and an integer `k`. Move each element in the array `nums` k steps to the right. If `k` is negative, move the elements k steps to the left. The array should be rotated in-place with O(1) extra space complexity. Return the modified array after rotation.","solution":"def rotate(nums, k): Rotates the array nums by k steps. If k is positive, rotate to the right; if k is negative, rotate to the left. This function modifies the array in-place and has O(1) extra space complexity. Parameters: nums (List[int]): The input array. k (int): The number of steps to rotate the array. Returns: List[int]: The array after rotation. n = len(nums) if n == 0 or k == 0: return nums k = k % n # Handle cases where k is larger than the length of the array if k < 0: k += n # Convert negative k to a positive equivalent rotation # Define a helper function to reverse a portion of the array def reverse(start, end): while start < end: nums[start], nums[end] = nums[end], nums[start] start += 1 end -= 1 reverse(0, n - 1) # Reverse the entire array reverse(0, k - 1) # Reverse the first k elements reverse(k, n - 1) # Reverse the rest of the array return nums"},{"question":"Given a linked list where each node contains an integer, find and return the node at which the intersection of two singly linked lists begins. If there is no intersection, return null. The linked lists are non-cyclical and may have different lengths. Your function should have a time complexity of O(m + n), where m and n are the lengths of the two linked lists. Use constant memory space, excluding the input and output parameters.","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def getIntersectionNode(headA, headB): Find the node at which the intersection of two singly linked lists begins. If there is no intersection, return None. :type headA: ListNode :type headB: ListNode :rtype: ListNode if not headA or not headB: return None pointerA = headA pointerB = headB while pointerA is not pointerB: pointerA = headA if pointerA is None else pointerA.next pointerB = headB if pointerB is None else pointerB.next return pointerA"},{"question":"You are given an array of integers `logs` where `logs[i]` represents the length of the `i-th` log. You are also given an integer `K`. You need to cut these logs in such a way that each resulting piece has a maximum length of `K`. Return _the minimum number of cuts needed to ensure that every piece has a length of at most `K`_.","solution":"def minCuts(logs, K): Returns the minimum number of cuts needed to ensure that every piece has a length of at most K. cuts = 0 for log in logs: if log > K: cuts += (log - 1) // K return cuts"},{"question":"You are given a 2D grid of size `m x n` representing a box. You have `k` horizontal dominos and `k` vertical dominos of size `1 x 2` or `2 x 1`, respectively. Your task is to place all the dominos on the grid such that no two dominos overlap and every cell in the grid is either covered by exactly one domino or left empty. Determine if it is possible to place all the dominos satisfying the conditions above. Return _true_ if it is possible, otherwise return _false_.","solution":"def can_place_dominos(m, n, k): Determines if it is possible to place all dominos such that no two dominos overlap and every cell in the grid is either covered by exactly one domino or left empty. :param m: Number of rows in the grid :param n: Number of columns in the grid :param k: Number of horizontal and vertical dominos :return: True if possible to place all dominos, otherwise False total_cells = m * n total_domino_cells = k * 2 if total_domino_cells > total_cells: return False empty_cells = total_cells - total_domino_cells if empty_cells % 2 != 0: return False if total_domino_cells % 2 == 0: if (k * 2) <= (m * n): return True else: return False return True"},{"question":"You are given a matrix `grid` of size `m x n` where each cell represents a plot of land. A cell with a value of `1` represents land that can be developed, and a cell with a value of `0` represents water that cannot be developed. Your task is to determine the maximum area of connected land parcels (cells with value `1`) that can be developed. Two cells are considered connected if they are adjacent horizontally or vertically. Return the maximum area of connected land parcels in `grid`.","solution":"def max_area_of_island(grid): Calculate the maximum area of connected land parcels (cells with value 1) in the grid. :param grid: List[List[int]], a 2D list representing a grid of lands (1) and waters (0) :return: int, the maximum area of connected lands if not grid: return 0 m, n = len(grid), len(grid[0]) visited = [[False for _ in range(n)] for _ in range(m)] def dfs(x, y): if x < 0 or x >= m or y < 0 or y >= n or grid[x][y] == 0 or visited[x][y]: return 0 visited[x][y] = True area = 1 area += dfs(x - 1, y) area += dfs(x + 1, y) area += dfs(x, y - 1) area += dfs(x, y + 1) return area max_area = 0 for i in range(m): for j in range(n): if grid[i][j] == 1 and not visited[i][j]: max_area = max(max_area, dfs(i, j)) return max_area"},{"question":"You are given a string `s` consisting of lowercase English letters, and an integer `k`. You need to construct a new string by rearranging the characters of `s` such that the new string is lexicographically smallest and no two adjacent characters are the same. If it is not possible to construct such a string, return `\\"\\"`. Otherwise, return _the lexicographically smallest string that can be formed by rearranging `s` following the given condition_.","solution":"import heapq from collections import Counter def rearrange_string(s, k): Rearranges the characters of `s` such that no two adjacent characters are the same and returns the lexicographically smallest string. If it\'s not possible, returns an empty string. if k == 0: return \'\'.join(sorted(s)) counter = Counter(s) max_heap = [] for char, freq in counter.items(): heapq.heappush(max_heap, (-freq, char)) result = [] wait_queue = [] while max_heap: freq, char = heapq.heappop(max_heap) result.append(char) wait_queue.append((freq + 1, char)) if len(wait_queue) >= k: front = wait_queue.pop(0) if front[0] < 0: heapq.heappush(max_heap, front) return \'\'.join(result) if len(result) == len(s) else \\"\\""},{"question":"A city is represented as a 2D grid of size `m x n`, where each cell is either land (`1`) or water (`0`). You are given two coordinates `(x1, y1)` and `(x2, y2)`, corresponding to two land cells in the grid. You need to find the shortest path from the land cell at `(x1, y1)` to the land cell at `(x2, y2)` such that you can move horizontally or vertically to an adjacent cell. Return the **length** of the shortest path, or `-1` if there is no valid path. **Note**: The path should not traverse any water cells (`0`).","solution":"from collections import deque def shortest_path(grid, start, end): Returns the length of the shortest path between start and end coordinates in grid. grid: 2D list representing the city grid. start: tuple (x1, y1) representing the start cell coordinates. end: tuple (x2, y2) representing the end cell coordinates. m, n = len(grid), len(grid[0]) x1, y1 = start x2, y2 = end # Check if start or end points are water or out of bounds if grid[x1][y1] == 0 or grid[x2][y2] == 0: return -1 # Directions arrays for moving up, down, left, and right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] visited = set() queue = deque([(x1, y1, 0)]) # (current_x, current_y, distance) while queue: current_x, current_y, distance = queue.popleft() if (current_x, current_y) == (x2, y2): return distance for direction in directions: new_x, new_y = current_x + direction[0], current_y + direction[1] if 0 <= new_x < m and 0 <= new_y < n and (new_x, new_y) not in visited and grid[new_x][new_y] == 1: visited.add((new_x, new_y)) queue.append((new_x, new_y, distance + 1)) return -1"},{"question":"You are given a binary tree in which each node contains an integer value. Write a program to find the maximum path sum. The path must start and end at any node in the tree, and each node can only be visited once. A path sum is the sum of the node values in the path. Implement the `BinaryTree` class as follows: * `BinaryTree(TreeNode root)` initializes the object with the root of the binary tree. * `int maxPathSum()` returns the maximum path sum of the binary tree. Here, `TreeNode` is a class representing a node in the binary tree, with the following structure: ```plaintext class TreeNode { int val; TreeNode left; TreeNode right; TreeNode(int val) { this.val = val; } } ```","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BinaryTree: def __init__(self, root: TreeNode): self.root = root def maxPathSum(self) -> int: Returns the maximum path sum of the binary tree. A path can start and end at any node in the tree. self.max_sum = float(\'-inf\') def dfs(node: TreeNode) -> int: if not node: return 0 left_max = max(dfs(node.left), 0) right_max = max(dfs(node.right), 0) # Max path including the current node price_newpath = node.val + left_max + right_max # Update global max_sum self.max_sum = max(self.max_sum, price_newpath) # For recursion, return the max gain if continue the same path return node.val + max(left_max, right_max) dfs(self.root) return self.max_sum"},{"question":"Given an integer array `arr` of size `n`, determine the number of **distinct pairs** `(i, j)` (where `i < j`) that satisfy the equation `arr[i] + arr[j] = target`, with `target` being an integer value provided as input. Return the count of all such pairs.","solution":"def count_pairs_with_sum(arr, target): Function to count the number of distinct pairs (i, j) where i < j that satisfy the equation arr[i] + arr[j] = target n = len(arr) count = 0 seen = {} # Iterate over each element in the array for i in range(n): # Calculate the complement that we need to reach the target complement = target - arr[i] # Check if the complement exists in the seen dictionary # and also make sure we do not consider the same element twice if complement in seen: count += seen[complement] # Add the current element to the seen dictionary if arr[i] in seen: seen[arr[i]] += 1 else: seen[arr[i]] = 1 return count"},{"question":"You are given a string `s` representing an encoded message where each character in the string represents a different digit according to the mapping: `\'1\' -> \'A\'` to `\'26\' -> \'Z\'`. You need to determine the total number of ways to decode the message. Implement a function that returns this total count. Consider that the encoded message can contain invalid segments that cannot be decoded. Note: The message will not contain any leading zeros.","solution":"def num_decodings(s): Function to calculate the number of ways to decode an encoded message. # Base case: if the string is empty if not s: return 0 # dp array where dp[i] represents the number of ways to decode s[:i] dp = [0] * (len(s) + 1) dp[0] = 1 # An empty string has one way to be decoded. # If the first character is \'0\', there\'s no valid way to decode it. dp[1] = 0 if s[0] == \'0\' else 1 for i in range(2, len(s) + 1): # Check the last single digit (s[i-1]) if s[i-1] != \'0\': dp[i] += dp[i-1] # Check the last two digits (s[i-2:i]) two_digit = int(s[i-2:i]) if 10 <= two_digit <= 26: dp[i] += dp[i-2] return dp[-1]"},{"question":"You are given a string `s` of lowercase English letters and an integer array `indices` of the same length. The string `s` is an incorrectly sorted version of some specific string. Each character of the string `s` was moved from its original position in the string to a new position such that the character at the `i`-th position of `s` is now at position `indices[i]` in the correctly ordered string. Return the correctly ordered string. For example, if `s = \\"aiohn\\"` and `indices = [3,1,4,2,0]`, the correctly ordered string should be `\\"nihao\\"`.","solution":"def restoreString(s, indices): Returns the correctly ordered string based on the provided indices. Parameters: s (str): A string of lowercase English letters. indices (List[int]): A list of integers representing the new positions of each character in the string. Returns: str: The correctly ordered string. n = len(s) restored = [\'\'] * n for i in range(n): restored[indices[i]] = s[i] return \'\'.join(restored)"},{"question":"You are given a 2D grid of size `m x n` where each cell represents a cost to traverse through that cell. You need to find a path from the top-left corner to the bottom-right corner such that the total cost is minimized. You can only move to the right or down from a cell. Implement the method `minPathSum`, which takes the grid as input and returns the minimum path sum from the top-left corner to the bottom-right corner of the grid.","solution":"def minPathSum(grid): Finds the minimum path sum from the top-left corner to the bottom-right corner of the given grid where you can only move right or down. :param grid: List[List[int]] 2D grid of integers :return: int minimum path sum m = len(grid) n = len(grid[0]) # Initialize the DP table dp = [[0] * n for _ in range(m)] dp[0][0] = grid[0][0] # Initialize the first column for i in range(1, m): dp[i][0] = dp[i-1][0] + grid[i][0] # Initialize the first row for j in range(1, n): dp[0][j] = dp[0][j-1] + grid[0][j] # Populate the DP table for i in range(1, m): for j in range(1, n): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[m-1][n-1]"},{"question":"Given a 2D binary matrix `matrix`, return the largest square containing only `1`s and return its area. The matrix is filled with `0`s and `1`s only.","solution":"def maximalSquare(matrix): if not matrix or not matrix[0]: return 0 rows, cols = len(matrix), len(matrix[0]) dp = [[0] * cols for _ in range(rows)] max_side = 0 for i in range(rows): for j in range(cols): if matrix[i][j] == \'1\': if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side = max(max_side, dp[i][j]) return max_side * max_side"},{"question":"You are given `n` non-negative integers representing the heights of vertical lines drawn on a 2D plane at each `x`-coordinate from `0` to `n-1`. The lines, together with the x-axis, form a series of water containers. Write a function that finds the two lines that together with the x-axis form a container that would hold the most water. Return the maximum amount of water a container can store.","solution":"def max_area(heights): Given a list of heights, find the maximum area of water that can be trapped. Args: heights (list): A list of non-negative integers representing heights. Returns: int: The maximum area of water that can be contained. left, right = 0, len(heights) - 1 max_water = 0 while left < right: height = min(heights[left], heights[right]) width = right - left current_water = height * width max_water = max(max_water, current_water) if heights[left] < heights[right]: left += 1 else: right -= 1 return max_water"},{"question":"You are given a **0-indexed** integer array `nums` of size `n` and an integer `k`. Your task is to partition the array into `k` non-empty subsets whose sums are all equal. Return `true` if it is possible to partition the array in this way, and `false` otherwise. Example: ``` Input: nums = [4, 3, 2, 3, 5, 2, 1], k = 4 Output: true Explanation: It\'s possible to partition the array into 4 subsets (5), (1, 4), (2, 3), and (2, 3) with equal sum. ```","solution":"def can_partition_k_subsets(nums, k): Determines if it\'s possible to partition the array into k non-empty subsets with equal sum. total_sum = sum(nums) if total_sum % k != 0: return False target_sum = total_sum // k used = [False] * len(nums) nums.sort(reverse=True) # Optimize by trying larger numbers first def backtrack(start_index, number_of_subsets, current_sum): if number_of_subsets == 1: return True if current_sum == target_sum: return backtrack(0, number_of_subsets - 1, 0) for i in range(start_index, len(nums)): if not used[i] and current_sum + nums[i] <= target_sum: used[i] = True if backtrack(i + 1, number_of_subsets, current_sum + nums[i]): return True used[i] = False return False return backtrack(0, k, 0)"},{"question":"You are given a **0-indexed** integer array `nums` of size `n`. Each element in the array is a positive integer. Your task is to reorder the array in such a way that for every `i` from `1` to `n - 2`, the following condition holds: `nums[i-1] < nums[i] > nums[i+1]`. If there are multiple solutions, return any of them. If it is impossible to reorder the array to meet the condition, return an empty array.","solution":"def reorder(nums): Reorders the array so that nums[i-1] < nums[i] > nums[i+1] for every i from 1 to n-2 if possible. Returns an empty array if it\'s not possible. n = len(nums) if n < 3: return [] nums.sort() for i in range(1, n - 1, 2): nums[i], nums[i + 1] = nums[i + 1], nums[i] return nums"},{"question":"You are given a **0-indexed** integer array `heights` of length `n` representing the height of students in a line. You need to arrange the students such that every student is shorter than the student immediately ahead. If it is already not possible to arrange them in complete order, return the minimum number of swaps needed to achieve the desired arrangement. A swap involves choosing any two students and exchanging their positions. Hint: Consider using a sorting algorithm to assess the positions where swaps are required.","solution":"def minimum_swaps_to_sort(heights): Returns the minimum number of swaps needed to sort the array such that every student is shorter than the one immediately ahead. n = len(heights) # Create a sorted array with original indices sorted_heights = sorted([(height, i) for i, height in enumerate(heights)]) # Create a visited array to mark elements as already swapped/correct place visited = [False] * n swaps = 0 for i in range(n): # If already visited or already in the correct place if visited[i] or sorted_heights[i][1] == i: continue # Calculate the size of the cycle cycle_size = 0 x = i while not visited[x]: visited[x] = True x = sorted_heights[x][1] cycle_size += 1 # Number of swaps for each cycle is cycle_size - 1 if cycle_size > 0: swaps += cycle_size - 1 return swaps"},{"question":"Given a string `s` and an integer `numRows`, create a zigzag pattern of the string based on the number of rows and return the string read row-wise. For example, if `s = \\"PAYPALISHIRING\\"` and `numRows = 3`, the pattern would be: ``` P A H N A P L S I I G Y I R ``` And the returned string would be `\\"PAHNAPLSIIGYIR\\"`. Implement an algorithm that constructs the zigzag string for the given `s` and `numRows`.","solution":"def convert(s, numRows): if numRows == 1 or numRows >= len(s): return s rows = [\'\'] * min(numRows, len(s)) cur_row = 0 going_down = False for char in s: rows[cur_row] += char if cur_row == 0 or cur_row == numRows - 1: going_down = not going_down cur_row += 1 if going_down else -1 return \'\'.join(rows)"},{"question":"Given an integer string `s` representing a non-negative integer, split the string into two non-empty parts such that the difference between the two integer values formed by the parts is minimized. Return the two parts in the form of a string array. If there are multiple answers, return any of them.","solution":"def split_min_diff(s): Given an integer string `s`, split it into two non-empty parts such that the difference between the two integer values formed by the parts is minimized. min_diff = float(\'inf\') split_point = 0 for i in range(1, len(s)): part1 = int(s[:i]) part2 = int(s[i:]) diff = abs(part1 - part2) if diff < min_diff: min_diff = diff split_point = i return [s[:split_point], s[split_point:]]"},{"question":"Given a list of non-negative integers representing the amount of rainwater trapped at each bar\'s elevation when it rains, where the width of each bar is 1, return _the maximum amount of water that can be trapped_ by the elevation map. For example, given the list `[0,1,0,2,1,0,1,3,2,1,2,1]`, the maximum amount of trapped water is `6`.","solution":"def trap(height): Calculate the amount of water that can be trapped after raining. :param height: List[int] - the elevation map where the width of each bar is 1. :return: int - the maximum amount of water that can be trapped. if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i-1], height[i]) right_max[n-1] = height[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], height[i]) water_trapped = 0 for i in range(n): water_trapped += min(left_max[i], right_max[i]) - height[i] return water_trapped"},{"question":"You are given a 2D integer array `matrix` where each row is sorted in ascending order and each column is sorted in ascending order, and an integer `target`. Return _the row and column indices of_ `target` _if it is present in_ `matrix`, otherwise return `[-1, -1]`. Use an algorithm with `O(m + n)` complexity, where `m` is the number of rows and `n` is the number of columns.","solution":"def search_matrix(matrix, target): Searches for the target in a sorted 2D matrix where each row and each column is sorted in ascending order. Args: matrix (list of list of int): The 2D matrix to search within. target (int): The target number to search for. Returns: list: A list with the row and column indices of the target if found, otherwise [-1, -1]. if not matrix: return [-1, -1] m, n = len(matrix), len(matrix[0]) row, col = 0, n - 1 while row < m and col >= 0: if matrix[row][col] == target: return [row, col] elif matrix[row][col] > target: col -= 1 else: row += 1 return [-1, -1]"},{"question":"You are given a list of `n` integers representing the heights of `n` buildings aligned from left to right. The buildings form a skyline, where the `i-th` building has a height of `height[i]`. You are allowed to select a continuous subarray of these buildings and increase the height of every building within this subarray by 1. However, in order to avoid monotony, after increasing the heights of the selected buildings, there should be at least one building with a height that remains greater than or equal to the maximum height of the new altered skyline, ensuring our view point is always the highest. Find the maximum possible height for the lowest building within the altered subarray that can be obtained. Return the maximum possible minimum height after the operation.","solution":"def max_possible_min_height(heights): n = len(heights) max_height = max(heights) min_height = min(heights) # If all heights are already max height, return max height as no modification will make it higher. if min_height == max_height: return max_height # Otherwise, increment every building height by 1 and re-calculate the minimum max height. return min_height + 1"},{"question":"You are given an array `arr` of integers, and you need to perform some operations to transform it. In one operation, you can choose any two adjacent elements of `arr` and add the smaller one to the larger one. Your task is to return _the minimum possible value_ of the **maximum element** in the array after performing any number of operations.","solution":"def min_possible_max(arr): Returns the minimum possible value of the maximum element in the array after performing the given operations. By always combining the larger value with the smaller, we can reduce the maximum element in the list. Using a heap allows us to efficiently find and combine the smallest elements. while len(arr) > 1: arr.sort() # Sort array to combine smallest elements smallest1 = arr.pop(0) # Remove smallest element smallest2 = arr.pop(0) # Remove next smallest element new_element = smallest1 + smallest2 # Combine them arr.append(new_element) # Include result back in the array return arr[0]"},{"question":"You are given a linked list where each node contains an integer value. Your task is to implement a method `reverseKGroup` that reverses the nodes of the list `k` at a time and returns the modified list. `k` is a positive integer and is less than or equal to the length of the list. If the number of nodes is not a multiple of `k`, then the nodes left in the end should remain as they are. The function should not alter the values inside the nodes, only the nodes themselves may be changed. For example, given the linked list `1 -> 2 -> 3 -> 4 -> 5` and `k = 2`, the function should return `2 -> 1 -> 4 -> 3 -> 5`.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverseKGroup(head, k): def reverse_linked_list(head, k): new_head, ptr = None, head while k: next_node = ptr.next ptr.next = new_head new_head = ptr ptr = next_node k -= 1 return new_head count = 0 ptr = head while count < k and ptr: ptr = ptr.next count += 1 if count == k: reversed_head = reverse_linked_list(head, k) head.next = reverseKGroup(ptr, k) return reversed_head return head"},{"question":"A gardener is planting flowers along a single row of flowerbeds. Each flowerbed can either be planted with a flower or left empty. You are given a string `flowerbed` consisting of characters `\'F\'` and `\'.\'` only, where `\'F\'` represents a flower and `\'.\'` represents an empty space. No two flowers can be planted in adjacent flowerbeds, meaning there must be at least one empty space between any two flowers. You are also given an integer `n` representing the number of new flowers the gardener wants to plant. Determine if it is possible to plant all `n` flowers in the flowerbed without violating the no-adjacent-flowers rule. Return _`true` if it is possible to plant all `n` flowers without violating the rule, otherwise return `false`_.","solution":"def can_place_flowers(flowerbed, n): Determine if it is possible to plant `n` flowers in the `flowerbed` without violating the no-adjacent-flowers rule. flowerbed = list(flowerbed) length = len(flowerbed) # Traverse the flowerbed to try planting flowers for i in range(length): # Check if the current position is empty and the next and previous positions are empty or boundary if flowerbed[i] == \'.\' and (i == 0 or flowerbed[i - 1] == \'.\') and (i == length - 1 or flowerbed[i + 1] == \'.\'): # Plant a flower here flowerbed[i] = \'F\' n -= 1 # If all required flowers are planted, return True if n <= 0: return True # If remaining flowers can\'t be planted, return False return n <= 0"},{"question":"Given the `root` of a binary tree, return a list of the values of all nodes that have exactly one child. If there are no such nodes, return an empty list. A node is considered to have exactly one child if it has either a single left child or a single right child, but not both. Ensure the order of the returned values follows an in-order traversal of the original tree.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find_one_child_nodes(root): Returns the list of values of all nodes that have exactly one child in an in-order traversal order. result = [] def inorder_traversal(node): if node: inorder_traversal(node.left) if (node.left and not node.right) or (not node.left and node.right): result.append(node.val) inorder_traversal(node.right) inorder_traversal(root) return result"},{"question":"The existing questions focus on complex data structure problems and algorithmic challenges. They vary in length and depth, each introducing intricate scenarios requiring a strong grasp of algorithms and programming concepts. Here’s an additional question that aligns with the provided set: [Question 4]: You are given an `n`-length array containing only positive integers. Your task is to partition this array into `k` non-empty contiguous subarrays such that the sum of the maximum values of these subarrays is minimized. Return _the minimized sum of the maximum values of the subarrays_. For example, given the array `[10, 2, 20, 5, 15]` and `k = 3`, one optimal partitioning would be `([10], [2, 20], [5, 15])` with the maximum values being `[10, 20, 15]` and the minimized sum of these being `45`.","solution":"def min_maximum_sum_partition(arr, k): Partition an array into k contiguous subarrays such that the sum of the maximum values of these subarrays is minimized, and return the minimized sum. Parameters: arr (list): List of positive integers. k (int): Number of subarrays to partition. Returns: int: The minimized sum of the maximum values of the subarrays. def is_valid_partition(max_sum): current_sum = 0 count = 1 for num in arr: if current_sum + num > max_sum: count += 1 current_sum = num if count > k: return False else: current_sum += num return True low, high = max(arr), sum(arr) while low < high: mid = (low + high) // 2 if is_valid_partition(mid): high = mid else: low = mid + 1 return low"},{"question":"You are given a string `s` that consists of lowercase English letters and digits. You need to find the **longest substring** of `s` that consists of distinct characters. For example, given the string `\\"abcabcbb\\"`, the answer is `\\"abc\\"`, which has a length of 3. If there are multiple substrings with the same maximum length, return the leftmost one. Return the longest substring with all distinct characters.","solution":"def longest_distinct_substring(s): Returns the longest substring of `s` that consists of distinct characters. last_seen = {} start = 0 max_length = 0 start_index_of_max = 0 for end in range(len(s)): if s[end] in last_seen: start = max(start, last_seen[s[end]] + 1) last_seen[s[end]] = end if end - start + 1 > max_length: max_length = end - start + 1 start_index_of_max = start return s[start_index_of_max:start_index_of_max + max_length]"},{"question":"Given an array of integers `nums` where each integer represents the number of candies in a jar. You have an unlimited number of operations and in each operation, you can select any jar and remove half (rounded down) of its candies. Your objective is to minimize the total number of candies in all jars combined. Return the minimum total number of candies possible after performing the operations optimally.","solution":"def minTotalCandiesAfterOperations(nums): Function to minimize the total number of candies in all jars after performing the optimal operations of removing half (rounded down) of candies. return sum(0 if x == 0 else 1 for x in nums)"},{"question":"You are given a list of integers `arr` representing the heights of trees arranged in a line. A tree can be cut down if it is taller than the tree to its immediate right. After cutting down such a tree, the height of the remaining stump is considered to be `0`. The goal is to cut down the minimum number of trees such that for every remaining tree, its height is less than or equal to the height of the tree to its immediate right. Write a function that returns the minimum number of trees that need to be cut down to achieve this goal. You may assume that `arr` consists of at least two elements.","solution":"def min_trees_to_cut(arr): Returns the minimum number of trees to cut down to ensure each remaining tree\'s height is less than or equal to its immediate right tree\'s height. n = len(arr) cuts = 0 for i in range(n - 1): if arr[i] > arr[i + 1]: cuts += 1 arr[i] = 0 # Simulate cutting down the tree return cuts"},{"question":"Given a list of `n` integers `arr`, find an integer `m` such that any integer between `1` and `m` (inclusive) can be written as the sum of one or more distinct elements from `arr`. Return the smallest possible value of `m` that meets the criteria.","solution":"def smallest_m(arr): Finds the smallest integer m such that any integer between 1 and m (inclusive) can be written as the sum of one or more distinct elements from arr. arr.sort() m = 1 # Initialize m to 1, the smallest number we want to cover for num in arr: if num > m: break m += num return m"},{"question":"Given an unsorted array of integers `nums`, find the length of the longest subarray where the absolute difference between any two elements is no greater than `1`. Return the length of this subarray.","solution":"def longest_subarray(nums): from collections import defaultdict if not nums: return 0 frequency_map = defaultdict(int) for num in nums: frequency_map[num] += 1 max_length = 0 for num in frequency_map: current_length = frequency_map[num] if (num + 1) in frequency_map: current_length += frequency_map[num + 1] max_length = max(max_length, current_length) return max_length"},{"question":"Create a **Simple Stack** class that supports the following operations: * `SimpleStack()`: Initializes the stack. * `void push(int x)`: Pushes integer `x` onto the stack. * `int pop()`: Removes the element on top of the stack and returns it. If the stack is empty, return `-1`. * `int top()`: Gets the top element of the stack without removing it. If the stack is empty, return `-1`. * `boolean isEmpty()`: Returns `true` if the stack is empty, `false` otherwise.","solution":"class SimpleStack: def __init__(self): Initializes the stack. self.stack = [] def push(self, x): Pushes integer x onto the stack. self.stack.append(x) def pop(self): Removes the element on top of the stack and returns it. If the stack is empty, returns -1. if self.isEmpty(): return -1 return self.stack.pop() def top(self): Gets the top element of the stack without removing it. If the stack is empty, returns -1. if self.isEmpty(): return -1 return self.stack[-1] def isEmpty(self): Returns True if the stack is empty, False otherwise. return len(self.stack) == 0"},{"question":"You are given a list of non-negative integers representing the heights of vertical bars, where each bar has a width of 1. Imagine it rains over the bars and water is trapped between them. The task is to calculate how much water is trapped after it rains. Return an integer representing the total amount of trapped water. For example: Given the list `[0,1,0,2,1,0,1,3,2,1,2,1]`, the total amount of trapped water is `6`.","solution":"def trap(height): Calculate the total amount of trapped water given a list of heights. Args: height (List[int]): List of non-negative integers representing the heights of bars. Returns: int: Total amount of trapped water. if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - height[i] return trapped_water"},{"question":"You are given a `rows x cols` binary matrix `grid` where `0` represents a sea cell and `1` represents a land cell. A **block** of land cells is formed by connecting adjacent land cells horizontally and vertically. Given the grid, consider forming the **largest block** of land cells by flipping exactly one sea cell (`0`) to a land cell (`1`). Return _the size of the largest block of land cells you can form by flipping exactly one cell_. If no flip can result in a larger block, return the size of the current largest block of land cells.","solution":"def largest_block(grid): Returns the size of the largest block of land cells that can be formed by flipping exactly one sea cell (0) to a land cell (1) in the given grid. rows = len(grid) cols = len(grid[0]) def dfs(r, c, block_id): # Depth First Search to mark all connected land cells with a block ID stack = [(r, c)] block_size = 0 while stack: x, y = stack.pop() if 0 <= x < rows and 0 <= y < cols and grid[x][y] == 1: grid[x][y] = block_id block_size += 1 stack.extend([(x-1, y), (x+1, y), (x, y-1), (x, y+1)]) return block_size block_sizes = {} block_id = 2 # Starting block ID from 2, as 0 represents sea and 1 represents unvisited land # Mark all blocks with different IDs and calculate their sizes for r in range(rows): for c in range(cols): if grid[r][c] == 1: size = dfs(r, c, block_id) block_sizes[block_id] = size block_id += 1 max_block = max(block_sizes.values(), default=0) if max_block == rows * cols: return max_block def neighbors(r, c): for nr, nc in [(r-1, c), (r+1, c), (r, c-1), (r, c+1)]: if 0 <= nr < rows and 0 <= nc < cols: yield nr, nc # Evaluate potential flips for r in range(rows): for c in range(cols): if grid[r][c] == 0: observed_blocks = set() for nr, nc in neighbors(r, c): if grid[nr][nc] > 1: observed_blocks.add(grid[nr][nc]) potential_size = 1 + sum(block_sizes[bid] for bid in observed_blocks) max_block = max(max_block, potential_size) return max_block # Note: The algorithm in the solution modifies the input grid; it should be copied if used elsewhere."},{"question":"Given a list of integers `nums`, you are tasked with finding the **length of the longest subsequence that is strictly increasing**. A subsequence is a sequence derived from another sequence where some elements might be deleted without changing the order of the remaining elements. For example, given the list `nums = [10, 9, 2, 5, 3, 7, 101, 18]`, your task is to find the length of the longest strictly increasing subsequence. In this case, it would be `4` as one of the longest increasing subsequences is `[2, 3, 7, 101]`.","solution":"def length_of_lis(nums): Finds the length of the longest strictly increasing subsequence. Parameters: nums (List[int]): The input list of integers. Returns: int: The length of the longest strictly increasing subsequence. if not nums: return 0 dp = [1] * len(nums) for i in range(1, len(nums)): for j in range(i): if nums[i] > nums[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"Given a string `s` representing an expression containing numbers, operators `+`, `-`, `*`, and `(`,`)`, implement a basic calculator to evaluate it and return its value. The integer division should truncate toward zero. You may assume that the given string expression is valid, and there will be no division by zero. The expression does not contain any whitespace, and the precedence of the operators is `*` > `+` = `-`.","solution":"def evaluate_expression(s): def precedence(op): if op == \'+\' or op == \'-\': return 1 if op == \'*\': return 2 return 0 def apply_op(operands, operators): right = operands.pop() left = operands.pop() operator = operators.pop() if operator == \'+\': operands.append(left + right) elif operator == \'-\': operands.append(left - right) elif operator == \'*\': operands.append(left * right) def evaluate(tokens): operands = [] operators = [] i = 0 while i < len(tokens): if tokens[i] == \'(\': operators.append(tokens[i]) elif tokens[i].isdigit(): val = 0 while i < len(tokens) and tokens[i].isdigit(): val = val * 10 + int(tokens[i]) i += 1 operands.append(val) i -= 1 elif tokens[i] == \')\': while operators and operators[-1] != \'(\': apply_op(operands, operators) operators.pop() else: while (operators and operators[-1] != \'(\' and precedence(operators[-1]) >= precedence(tokens[i])): apply_op(operands, operators) operators.append(tokens[i]) i += 1 while operators: apply_op(operands, operators) return operands[-1] return evaluate(s)"},{"question":"Write a function that takes a string `s` representing a date in the format \\"YYYY-MM-DD\\" and returns the day of the week for that date. The day should be one of \\"Monday\\", \\"Tuesday\\", \\"Wednesday\\", \\"Thursday\\", \\"Friday\\", \\"Saturday\\", or \\"Sunday\\". You may assume that the input string is a valid date from the year 1900 onwards.","solution":"from datetime import datetime def day_of_week(s: str) -> str: Given a string `s` representing a date in the format \\"YYYY-MM-DD\\", return the day of the week for that date. date_obj = datetime.strptime(s, \\"%Y-%m-%d\\") return date_obj.strftime(\\"%A\\")"},{"question":"You are given two strings `s` and `t`. You want to know if it is possible to create string `t` by rearranging the characters of string `s` and inserting exactly one character at any position in the rearranged string. Return `_true_` if `t` can be formed this way and `_false_` otherwise. Each input string only consists of lowercase English letters.","solution":"def can_form_t_by_rearranging_and_inserting(s, t): Returns True if it is possible to create string t by rearranging the characters of string s and inserting exactly one character, otherwise returns False. if len(t) != len(s) + 1: return False from collections import Counter s_counter = Counter(s) t_counter = Counter(t) differences = 0 for char in t_counter: if t_counter[char] > s_counter[char]: differences += t_counter[char] - s_counter[char] return differences == 1"},{"question":"Given a binary tree, return the **maximum width** of the tree. The maximum width of a tree is the maximum width among all levels. The width of one level is defined as the length between the end-nodes (the leftmost and rightmost non-null nodes), inclusive. For example, if the input binary tree is `[1, 3, 2, 5, 3, null, 9]`, the output should be `4` because at the level with nodes `5, 3, null, 9`, there are 4 nodes between the leftmost and the rightmost non-null nodes. Return _the **maximum width**_ of the input tree as an integer. If the tree is empty, return `0`.","solution":"from collections import deque class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def maximum_width_of_binary_tree(root): if not root: return 0 max_width = 0 queue = deque([(root, 0)]) # (node, current_position) while queue: level_length = len(queue) _, first_index = queue[0] # first node\'s position at current level _, last_index = queue[-1] # last node\'s position at current level # Calculate the current level width and update max_width max_width = max(max_width, last_index - first_index + 1) for _ in range(level_length): node, index = queue.popleft() if node.left: queue.append((node.left, 2 * index)) if node.right: queue.append((node.right, 2 * index + 1)) return max_width"},{"question":"You are given a list of projects and their respective durations in days. Each project can be completed independently. A company employs several workers, each capable of managing one project at a time. The company aims to assign projects in a way that ensures all projects are completed as early as possible. Implement the function `min_days_to_complete_projects(projects: List[int], workers: int) -> int` that computes the minimum number of days required to complete all given projects when evenly distributed among the workers. Each worker can start a new project only after finishing the current one. Return the minimum number of days needed to complete all projects. # Example: - Input: `projects = [2, 3, 5, 7]`, `workers = 2` - Output: `10` # Explanation: One optimal assignment of projects to workers could be: - Worker 1: [7, 3] (7 days for first project, then 3 more days for second) - Worker 2: [5, 2] (5 days for first project, then 2 more days for second) Thus, both workers finish their projects within a span of 10 days.","solution":"from typing import List def min_days_to_complete_projects(projects: List[int], workers: int) -> int: def feasible(days: int) -> bool: required_workers = 1 current_time = 0 for project in projects: if current_time + project <= days: current_time += project else: required_workers += 1 current_time = project if required_workers > workers: return False return True low, high = max(projects), sum(projects) while low < high: mid = (low + high) // 2 if feasible(mid): high = mid else: low = mid + 1 return low"},{"question":"Given a string `s`, return the longest palindromic substring in `s`. # Example 1: - Input: \\"babad\\" - Output: \\"bab\\" - Note: \\"aba\\" is also a valid answer. # Example 2: - Input: \\"cbbd\\" - Output: \\"bb\\" # Example 3: - Input: \\"a\\" - Output: \\"a\\" # Example 4: - Input: \\"ac\\" - Output: \\"a\\" # Constraints: - 1 <= s.length <= 1000 - `s` consist of only digits and English letters.","solution":"def longest_palindromic_substring(s: str) -> str: Returns the longest palindromic substring in s. def expand_around_center(s: str, left: int, right: int) -> str: while left >= 0 and right < len(s) and s[left] == s[right]: left -= 1 right += 1 return s[left + 1:right] if not s or len(s) == 1: return s longest = \\"\\" for i in range(len(s)): # Odd length palindrome temp = expand_around_center(s, i, i) if len(temp) > len(longest): longest = temp # Even length palindrome temp = expand_around_center(s, i, i + 1) if len(temp) > len(longest): longest = temp return longest"},{"question":"You are given an array `heights` representing the heights of buildings, where `heights[i]` is the height of the ith building. You can view the ocean on the right side of the array. A building has an ocean view if all the buildings to its right have a smaller height. Write a function to return the indices of buildings that have an ocean view oriented to the right. Implement the following function: ```python def findBuildingsWithOceanView(heights: List[int]) -> List[int]: ``` # Example: > Input: `heights = [4, 2, 3, 1]` Output: `[0, 2, 3]` Explanation: Building 0 has a height of 4, and there are no taller buildings to the right. Building 2 has a height of 3, and all buildings to its right (just building 3) have a smaller height. Building 3 has a height of 1, and there are no buildings to its right. Building 1 does not have an ocean view because building 2 is taller.","solution":"def findBuildingsWithOceanView(heights): Returns the indices of buildings that have an ocean view. :param heights: List[int] - List of building heights :return: List[int] - List of indices of buildings with ocean views n = len(heights) if n == 0: return [] max_height_so_far = 0 result = [] for i in range(n-1, -1, -1): if heights[i] > max_height_so_far: result.append(i) max_height_so_far = heights[i] result.reverse() return result"},{"question":"You are managing a network of computers in an office. Each computer is represented by a node in a graph, and each direct connection between two computers is represented by an undirected edge. The office network is represented by a list of such edges. However, some connections may be missing, meaning the network might be disconnected. Your task is to find the minimum number of edges required to make the entire network connected. If it\'s impossible to connect all computers, return -1. Given `n` as the number of computers and a list `edges` where each `edges[i] = [u, v]` represents a connection between computers `u` and `v`, determine the minimum number of edges needed to connect all the computers.","solution":"def min_edges_to_connect_network(n, edges): Returns the minimum number of edges required to make the entire network connected. If it\'s impossible, returns -1. n: int - Number of computers edges: List[List[int]] - Direct connections between computers if len(edges) < n - 1: return -1 # Not enough edges to potentially connect all nodes from collections import defaultdict # Create an adjacency list representation of the graph graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) visited = set() def dfs(node): stack = [node] while stack: current = stack.pop() for neighbor in graph[current]: if neighbor not in visited: visited.add(neighbor) stack.append(neighbor) connected_components = 0 for node in range(n): if node not in visited: visited.add(node) connected_components += 1 dfs(node) # To connect c components, we need at least (c - 1) edges return connected_components - 1"},{"question":"You are given an integer array `nums` of size `n` consisting of both positive and negative integers. A subarray is a contiguous segment of the array. Define the **product** of a subarray as the product of all its elements. Write a function to find the length of the longest subarray whose product is positive. Return the length of this subarray. If there is no such subarray, return 0.","solution":"def longest_positive_product_subarray(nums): Finds the length of the longest subarray with a positive product. Parameters: nums (List[int]): The input list of integers. Returns: int: The length of the longest subarray with a positive product. If no such subarray exists, returns 0. max_len, current_positive_len, current_negative_len = 0, 0, 0 for num in nums: if num > 0: current_positive_len += 1 current_negative_len = current_negative_len + 1 if current_negative_len > 0 else 0 elif num < 0: current_positive_len, current_negative_len = (current_negative_len + 1 if current_negative_len > 0 else 0, current_positive_len + 1) else: current_positive_len, current_negative_len = 0, 0 max_len = max(max_len, current_positive_len) return max_len"},{"question":"You are given a matrix of integers `grid` where each element represents the cost of entering that cell. You are initially positioned at the top-left corner (cell `[0][0]`) and your goal is to reach the bottom-right corner (cell `[n-1][m-1]`) while following these rules: - You can only move either right or down at any point in time. - You cannot move into a cell with a value of `-1` (representing an obstacle). Return the minimum cost of a path from the top-left corner to the bottom-right corner. If there is no valid path, return `-1`.","solution":"def min_path_cost(grid): Returns the minimum cost to travel from the top-left to bottom-right of the grid. If there is no valid path, returns -1. :param grid: List of List of integers representing the cost grid :return: Minimum cost or -1 if no valid path if not grid or not grid[0]: return -1 n = len(grid) m = len(grid[0]) # Initialize dp array dp = [[float(\'inf\')] * m for _ in range(n)] # Starting point if grid[0][0] == -1: return -1 dp[0][0] = grid[0][0] # Fill dp array for i in range(n): for j in range(m): if grid[i][j] == -1: continue if i > 0 and grid[i-1][j] != -1: dp[i][j] = min(dp[i][j], dp[i-1][j] + grid[i][j]) if j > 0 and grid[i][j-1] != -1: dp[i][j] = min(dp[i][j], dp[i][j-1] + grid[i][j]) return dp[-1][-1] if dp[-1][-1] != float(\'inf\') else -1"},{"question":"Write a function `findPairs` that accepts an array `nums` and an integer `k`, and returns the number of unique pairs `(i, j)` such that `nums[i] + nums[j] = k` and `i < j`. The array may contain duplicate elements, and each element can only be used in one pair.","solution":"def findPairs(nums, k): Returns the number of unique pairs (i, j) such that nums[i] + nums[j] = k and i < j. Each element can only be used in one pair. seen, used = set(), set() count = 0 for num in nums: diff = k - num if diff in seen and diff not in used and num not in used: count += 1 used.add(num) used.add(diff) seen.add(num) return count"},{"question":"You are given a ***0-indexed*** integer array `arr` of length `n`, and an integer `k`. Your task is to remove the `k-th` occurrence of the largest element in the array. If the `k-th` occurrence does not exist, return the array unchanged. Otherwise, remove the element and return the resulting array. For example, consider `arr = [3, 1, 4, 4, 5, 5, 5, 2]` and `k = 2`: * The largest element is `5`, which occurs `3` times. * The `2nd` occurrence of `5` is at index `4`. * After removing it, the resulting array is `[3, 1, 4, 4, 5, 5, 2]`. Return the modified array.","solution":"def remove_kth_occurrence_of_largest(arr, k): Removes the k-th occurrence of the largest element in the array. If the k-th occurrence does not exist, returns the array unchanged. Parameters: arr(list): a list of integers k(int): an integer indicating which occurrence of the largest element to remove Returns: list: the modified array if not arr or k <= 0: return arr largest = max(arr) occurrence_count = 0 for i, value in enumerate(arr): if value == largest: occurrence_count += 1 if occurrence_count == k: return arr[:i] + arr[i+1:] # If k-th occurrence does not exist return arr"},{"question":"You are given an array of integers `heights` representing the heights of students in a row. Each integer `height[i]` is the height of the `i`th student in the row. A student can see the board if and only if there are no students taller than or of the same height directly in front of them. The row can be rearranged such that each student can see the board. Return the minimum number of swaps needed to ensure that every student can see the board. A swap is defined as exchanging the position of two students in the row.","solution":"def minimum_swaps_to_see_board(heights): Returns the minimum number of swaps needed to ensure that every student can see the board. n = len(heights) indexed_heights = list(enumerate(heights)) indexed_heights.sort(key=lambda x: x[1]) visited = [False] * n swaps = 0 for i in range(n): if visited[i] or indexed_heights[i][0] == i: continue cycle_size = 0 j = i while not visited[j]: visited[j] = True j = indexed_heights[j][0] cycle_size += 1 if cycle_size > 0: swaps += (cycle_size - 1) return swaps"},{"question":"You are given a string `s` and an array of strings `dict` where each string in `dict` is of the same length. All characters in `dict` and `s` are lowercase English letters. Your task is to replace characters in `s` by forming the longest sequence that is identical to any string in `dict`. You can only replace characters in `s` with a character at the same position in one of the strings from `dict`. Return _the **length of the longest sequence** you can form from_ `s` _by using the characters from one of the strings in_ `dict`_. If no such sequence can be formed, return `0`._","solution":"def longest_sequence(s, dict): Returns the length of the longest sequence that can be formed from s using characters from the given dictionary. :param s: Original string :param dict: List of dictionary strings :return: Length of the longest sequence if not s or not dict: return 0 max_length = 0 dict_len = len(dict[0]) # Iterate through each string in the dict for word in dict: current_length = 0 for i in range(min(len(s), dict_len)): if s[i] == word[i]: current_length += 1 max_length = max(max_length, current_length) return max_length"},{"question":"You are given a list of non-negative integers representing the heights of blocks arranged in a line. The width of each block is `1`. The blocks form a histogram, and each block can potentially trap rainfall between them. Write a function to calculate _the total amount of rainwater that can be trapped after it rains_.","solution":"def trap_rainwater(heights): Calculates the total amount of rainwater that can be trapped. :param heights: List[int] - list of non-negative integers representing the heights of blocks :return: int - total amount of trapped rainwater if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n # Fill left_max array left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) # Fill right_max array right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) # Calculate trapped water trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - heights[i] return trapped_water"},{"question":"Given a string `s` containing only the characters `\'(\'` and `\')\'`, find the length of the longest valid (well-formed) parentheses substring. You must solve the problem with a linear time complexity `O(n)` and constant space complexity `O(1)`.","solution":"def longest_valid_parentheses(s): Returns the length of the longest valid (well-formed) parentheses substring in the given string. :param s: string containing only \'(\' and \')\' :return: length of the longest valid parentheses substring left = right = max_length = 0 # Left to right traversal for char in s: if char == \'(\': left += 1 else: right += 1 if left == right: max_length = max(max_length, 2 * right) elif right > left: left = right = 0 left = right = 0 # Right to left traversal for char in reversed(s): if char == \'(\': left += 1 else: right += 1 if left == right: max_length = max(max_length, 2 * left) elif left > right: left = right = 0 return max_length"},{"question":"You are given two sorted arrays `nums1` and `nums2` of size `m` and `n` respectively, and an integer `k`. Find the `kth` smallest element in the union of `nums1` and `nums2`. You must solve it in `O(log(min(m, n)))` time complexity.","solution":"def findKth(nums1, nums2, k): def kthSmallest(arr1, arr2, start1, start2, k): if start1 >= len(arr1): return arr2[start2 + k - 1] if start2 >= len(arr2): return arr1[start1 + k - 1] if k == 1: return min(arr1[start1], arr2[start2]) midVal1 = float(\'inf\') midVal2 = float(\'inf\') if start1 + k // 2 - 1 < len(arr1): midVal1 = arr1[start1 + k // 2 - 1] if start2 + k // 2 - 1 < len(arr2): midVal2 = arr2[start2 + k // 2 - 1] if midVal1 < midVal2: return kthSmallest(arr1, arr2, start1 + k // 2, start2, k - k // 2) else: return kthSmallest(arr1, arr2, start1, start2 + k // 2, k - k // 2) return kthSmallest(nums1, nums2, 0, 0, k)"},{"question":"You are provided with a string containing only lowercase alphabets. You need to find the length of the longest substring without repeating characters. Return an integer representing the length of this substring. For instance, the longest substring without repeating characters in \\"abcabcbb\\" is \\"abc\\", which has a length of 3.","solution":"def length_of_longest_substring(s): Returns the length of the longest substring without repeating characters. char_index_map = {} longest = 0 start = 0 for index, char in enumerate(s): if char in char_index_map and char_index_map[char] >= start: start = char_index_map[char] + 1 char_index_map[char] = index longest = max(longest, index - start + 1) return longest"},{"question":"You are given a string `s` that represents a valid parentheses sequence. Each character in `s` is either `\'(\'` or `\')\'`. A valid parentheses sequence is a string that can be formed by `()` and by concatenation of multiple valid parentheses sequences. You need to find the maximum depth of the parentheses in the string `s`. The depth of the parentheses is defined as the maximum number of nested pairs of parentheses in the string. Return the maximum depth of the given parentheses sequence.","solution":"def max_depth(s: str) -> int: Returns the maximum depth of the given parentheses sequence. Parameters: s (str): A string representing a valid parentheses sequence. Returns: int: The maximum depth of nested parentheses in the sequence. max_depth = 0 current_depth = 0 for char in s: if char == \'(\': current_depth += 1 if current_depth > max_depth: max_depth = current_depth elif char == \')\': current_depth -= 1 return max_depth"},{"question":"You are given a string `s` consisting of digits and lowercase English letters. You are allowed to remove exactly one digit from the string so that the resulting string, when interpreted as an integer (ignoring any leading zeroes), becomes the largest possible integer. Return the resulting string after the removal. For example, given the string `\\"1432219\\"`, removing the digit `1` results in `\\"432219\\"`, which is the largest possible integer from the removals.","solution":"def remove_digit_to_maximize(s): Remove exactly one digit from the string s to get the largest possible integer. n = len(s) max_number_str = \'\' for i in range(n): temp_str = s[:i] + s[i+1:] if temp_str.lstrip(\'0\') > max_number_str: max_number_str = temp_str.lstrip(\'0\') return max_number_str or \'0\'"},{"question":"Given a list of points represented by their Cartesian coordinates `(x, y)`, and an integer `k`, return the `k` closest points to the origin `(0, 0)`. The distance between two points `(x1, y1)` and `(x2, y2)` is the Euclidean distance, which is defined as `sqrt((x2 - x1)^2 + (y2 - y1)^2)`. You may return the answer in any order. The input list is guaranteed to have at least `k` points.","solution":"import heapq import math def k_closest_points(points, k): Returns the k closest points to the origin (0, 0). :param points: List of tuples [(x1, y1), (x2, y2), ...] :param k: Integer, number of closest points to return :return: List of tuples [(x1, y1), (x2, y2), ...] representing the k closest points def euclidean_distance(point): x, y = point return math.sqrt(x**2 + y**2) return heapq.nsmallest(k, points, key=euclidean_distance)"},{"question":"Given a non-negative integer `n`, create a function to check whether it is a palindrome in its binary form. A number is considered a palindrome if it reads the same forward and backward in its binary representation. Return `true` if the binary representation of `n` is a palindrome, otherwise return `false`.","solution":"def is_binary_palindrome(n): Returns True if the binary representation of n is a palindrome, otherwise False. binary_rep = bin(n)[2:] # Get the binary representation and remove the \'0b\' prefix return binary_rep == binary_rep[::-1]"},{"question":"You are given an array of integers `heights` representing the height of a cylinder at each position. The width of each cylinder is 1. Among all the rectangles that can be formed using the cylinders, return the area of the largest rectangle that can be formed. Each rectangle must be entirely within the bounds of the `heights` array, and it must be composed of consecutive elements from the array. (Note: The heights array represents a histogram where each bar\'s width is 1, and the objective is to find the largest rectangular area that can fit under the histogram).","solution":"def largest_rectangle_area(heights): Calculate the area of the largest rectangle that can be formed using the heights of the cylinders. :param heights: List[int] - A list of positive integers representing the heights of the cylinders. :return: int - The area of the largest rectangle. # Initializing stack and result variable stack = [] max_area = 0 # Iterate over all heights for i, h in enumerate(heights): start = i while stack and stack[-1][1] > h: index, height = stack.pop() max_area = max(max_area, height * (i - index)) start = index stack.append((start, h)) # Process the remaining elements in the stack for i, h in stack: max_area = max(max_area, h * (len(heights) - i)) return max_area"},{"question":"You are given a **0-indexed** integer array `heights` representing the heights of the buildings in a row. Buildings of the same height can block the view of each other from either direction. Calculate the total number of buildings with a clear view of the sunset. Note that a building has a clear view of the sunset if there are no taller buildings to its right. Return _the number of buildings with a clear view of the sunset._","solution":"def count_buildings_with_sunset_view(heights): Returns the number of buildings with a clear view of the sunset. A building has a clear view of the sunset if there are no taller buildings to its right. Parameters: heights (list of int): The heights of the buildings in a row. Returns: int: The number of buildings with a clear view of the sunset. n = len(heights) count = 0 max_height = 0 for i in range(n-1, -1, -1): if heights[i] > max_height: count += 1 max_height = heights[i] return count"},{"question":"Implement a library management system that can do the following: * Add a new book to the system. * Search for books by title. * Checkout a book. * Return a book. Implement the `Library` class: * `Library()` Initializes the library system. * `void addBook(String title, int copies)` Adds a book with the given title and number of copies to the system. If the book is already in the system, increase the number of copies by the given amount. * `List<String> search(String query)` Returns a list of book titles in the system that contain the query string (case insensitive). The returned list is sorted in lexicographic order. * `boolean checkout(String title)` Decreases the number of copies of the book by one. If there are no more copies available, returns `false`. * `void returnBook(String title)` Increases the number of copies of the book by one. If the book was not previously in the system, it adds the book with one copy.","solution":"class Library: def __init__(self): self.books = {} def addBook(self, title, copies): if title in self.books: self.books[title] += copies else: self.books[title] = copies def search(self, query): query = query.lower() result = [title for title in self.books if query in title.lower()] return sorted(result) def checkout(self, title): if title in self.books and self.books[title] > 0: self.books[title] -= 1 return True return False def returnBook(self, title): if title in self.books: self.books[title] += 1 else: self.books[title] = 1"},{"question":"Given a string `s` containing only lowercase letters, you need to find the length of the longest substring without repeating characters. Implement a function `int lengthOfLongestSubstring(String s)` that returns the length of this substring. The algorithm should have a linear runtime complexity.","solution":"def lengthOfLongestSubstring(s): Returns the length of the longest substring without repeating characters. char_index_map = {} longest = 0 start = 0 for i, c in enumerate(s): if c in char_index_map and char_index_map[c] >= start: start = char_index_map[c] + 1 char_index_map[c] = i longest = max(longest, i - start + 1) return longest"},{"question":"You are given a list of **m positive integers** `nums` and an integer `target`. Your task is to determine if any combination of numbers in the list (including the possibility of using the same number multiple times) can sum up to exactly the `target`. Return `true` if such a combination exists, otherwise return `false`.","solution":"def can_sum(nums, target): Determines if any combination of numbers from the list nums can sum to the target. Args: nums (list of int): A list of positive integers. target (int): The target sum. Returns: bool: True if a combination exists, False otherwise. dp = [False] * (target + 1) dp[0] = True # Base case: it\'s always possible to form a target sum of 0 for i in range(1, target + 1): for num in nums: if i >= num and dp[i - num]: dp[i] = True break return dp[target]"},{"question":"Given a `m x n` matrix `grid` containing only 0s and 1s, an island is a group of 1s (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water. An island is considered to be isolated if it does not touch the boundary of the grid. Determine the number of isolated islands in the grid.","solution":"def num_isolated_islands(grid): Returns the number of isolated islands in the grid. An island is isolated if it doesn\'t touch the boundary of the grid. def mark_island(i, j): if i < 0 or i >= m or j < 0 or j >= n or grid[i][j] == 0: return grid[i][j] = 0 # Mark the cell as water to AVOID re-visiting. mark_island(i-1, j) # up mark_island(i+1, j) # down mark_island(i, j-1) # left mark_island(i, j+1) # right m, n = len(grid), len(grid[0]) # Mark the cells connected to the boundary as water to exclude them from counting. for i in range(m): if grid[i][0] == 1: mark_island(i, 0) if grid[i][n-1] == 1: mark_island(i, n-1) for j in range(n): if grid[0][j] == 1: mark_island(0, j) if grid[m-1][j] == 1: mark_island(m-1, j) # Count the remaining isolated islands isolated_islands_count = 0 for i in range(1, m-1): for j in range(1, n-1): if grid[i][j] == 1: isolated_islands_count += 1 mark_island(i, j) return isolated_islands_count"},{"question":"You are given an `m x n` binary matrix `matrix` and an integer `k`, where each cell in the matrix contains either `0` or `1`. An island is a group of `1`s (representing land) connected 4-directionally (horizontal or vertical). You may assume all four edges of the grid are surrounded by `0`s (representing water). The size of an island is the number of `1`s in that island. Find the `k`th largest island\'s size in the matrix. If there are fewer than `k` islands, return `-1`.","solution":"def kth_largest_island(matrix, k): def dfs(i, j): if i < 0 or i >= len(matrix) or j < 0 or j >= len(matrix[0]) or matrix[i][j] == 0: return 0 matrix[i][j] = 0 # mark as visited size = 1 size += dfs(i+1, j) size += dfs(i-1, j) size += dfs(i, j+1) size += dfs(i, j-1) return size if not matrix or not matrix[0]: return -1 islands_sizes = [] for i in range(len(matrix)): for j in range(len(matrix[0])): if matrix[i][j] == 1: island_size = dfs(i, j) islands_sizes.append(island_size) if len(islands_sizes) < k: return -1 islands_sizes.sort(reverse=True) return islands_sizes[k-1]"},{"question":"You are given a string `s` containing only lowercase letters, and an array of `queries`. Each query is a pair of integers `[i, j]` where `0 <= i <= j < s.length`. For each query, determine the longest substring within the range `[i, j]` that contains no repeating characters and return the length of that substring. Return _an array `results` where `results.length == queries.length` and `results[k]` is the answer to the `kth` query_.","solution":"def length_of_longest_substring(s, queries): Returns an array of the lengths of the longest substrings with no repeating characters for each query in the list of queries. Parameters: s (str): input string queries (list): List of queries, each query is a pair of integers [i, j] Returns: list: List of lengths of the longest substrings for each query results = [] for i, j in queries: substring = s[i:j+1] longest = 0 window_start = 0 char_index_map = {} for window_end in range(len(substring)): right_char = substring[window_end] if right_char in char_index_map: window_start = max(window_start, char_index_map[right_char] + 1) char_index_map[right_char] = window_end longest = max(longest, window_end - window_start + 1) results.append(longest) return results"},{"question":"You are given a **0-indexed** integer array `heights` representing the heights of people standing in a queue. Each person wants to move to the end of the queue, but they can only move if everyone in front of them is shorter than them. For example, if `heights = [4, 2, 3, 5]`, the person with height `5` can move to the end because everyone in front of them (i.e., `4`, `2`, and `3`) is shorter. Similarly, the person with height `3` cannot move to the end because the person in front of them (i.e., `4`) is taller. Determine if the last person in the queue can move to the end. Return `true` if they can move to the end of the queue, otherwise return `false`.","solution":"def can_move_to_end(heights): Determines if the last person in the queue can move to the end. Parameters: heights (list of int): the heights of people in the queue. Returns: bool: True if the last person can move to the end, otherwise False. if not heights: return False last_height = heights[-1] for height in heights[:-1]: if height >= last_height: return False return True"},{"question":"Given an array `people` where `people[i]` represents the weight of the `i-th` person, and an integer `limit` which indicates the maximum weight a boat can carry. Each boat can carry at most two people at the same time, provided the sum of their weights is at most `limit`. Return the minimum number of boats required to carry every person.","solution":"def numRescueBoats(people, limit): Returns the minimum number of boats required to carry every person. Args: people (list of int): Array where people[i] represents the weight of the i-th person. limit (int): Maximum weight a boat can carry. Returns: int: Minimum number of boats required. people.sort() left, right = 0, len(people) - 1 boats = 0 while left <= right: if people[left] + people[right] <= limit: left += 1 right -= 1 boats += 1 return boats"},{"question":"Write a program that receives an integer array `arr` and an integer `k`, and returns the number of unique pairs `(i, j)` where `0 <= i < j < arr.length` such that `arr[i] + arr[j] == k`. Each pair `(i, j)` should be counted only once, regardless of the values of `arr[i]` and `arr[j]`.","solution":"def count_unique_pairs(arr, k): Returns the number of unique pairs (i, j) where 0 <= i < j < len(arr) and arr[i] + arr[j] == k. seen = set() unique_pairs = set() for i in range(len(arr)): complement = k - arr[i] if complement in seen: pair = tuple(sorted((arr[i], complement))) unique_pairs.add(pair) seen.add(arr[i]) return len(unique_pairs)"},{"question":"You are given an integer array `arr` and an integer `k`. A partition is defined as splitting the array into two contiguous subarrays `left` and `right` such that: 1. Each element in `left` is less than or equal to every element in `right`. 2. The length of `left` is exactly `k`. If such a partition exists, return the index where the partition starts. If multiple answers exist, return the smallest index. If no valid partition exists, return `-1`. For example, given the array `arr = [1, 3, 2, 4, 5]` and `k = 2`, a valid partition would be at index `2` where `left` is `[1, 3]` and `right` is `[2, 4, 5]`.","solution":"def partition_array(arr, k): Returns the index where the partition starts such that the length of left subarray is exactly k and each element in left is less than or equal to every element in right. If no valid partition exists, return -1. if k >= len(arr): return -1 left_max = [0] * k left_max[0] = arr[0] for i in range(1, k): left_max[i] = max(left_max[i - 1], arr[i]) right_min = [0] * (len(arr) - k) right_min[-1] = arr[-1] for i in range(len(arr) - k - 2, -1, -1): right_min[i] = min(right_min[i + 1], arr[i + k]) for i in range(k - 1, len(arr) - k): if left_max[k - 1] <= right_min[i - (k - 1)]: return k return -1"},{"question":"Given a string `s` consisting of lowercase English letters, you can perform operations to change a character at any position to any other lowercase English letter. Your goal is to obtain a string with no duplicate adjacent characters. Return the minimum number of operations required to achieve this.","solution":"def min_operations_to_avoid_adjacent_duplicates(s): Returns the minimum number of operations required to make the given string contain no duplicate adjacent characters. Parameters: s (str): Input string consisting of lowercase English letters. Returns: int: Minimum number of operations required. if not s: return 0 operations = 0 n = len(s) for i in range(1, n): if s[i] == s[i-1]: operations += 1 return operations"},{"question":"Given an `m x n` matrix `mat` and an integer `k`, return the maximum sum of any `k x k` submatrix in `mat`. A `k x k` submatrix is a contiguous block of `k` rows and `k` columns taken from the matrix. - Example: ```python mat = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] k = 2 ``` The answer would be `28` since `[ [5, 6], [8, 9] ]` is the submatrix with the largest sum. Write a function `maxSumSubmatrix` that returns the sum of the maximum `k x k` submatrix.","solution":"def maxSumSubmatrix(mat, k): Returns the maximum sum of any k x k submatrix in mat. if not mat or not mat[0] or k == 0: return 0 m, n = len(mat), len(mat[0]) max_sum = float(\'-inf\') for i in range(m - k + 1): for j in range(n - k + 1): current_sum = 0 for p in range(k): for q in range(k): current_sum += mat[i + p][j + q] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"You are given an integer array `height` representing the height of buildings in a row. Two buildings are represented by two different indices `i` and `j` (i < j). These buildings can form a container to hold water. Return _the maximum amount of water a container can store_.","solution":"def max_area(height): Calculates the maximum amount of water that a container can store, formed by two buildings represented by heights in the input list. :param height: List[int] - an array of integers representing building heights :return: int - maximum amount of water the container can store left = 0 right = len(height) - 1 max_water = 0 while left < right: # Calculate the current amount of water current_water = min(height[left], height[right]) * (right - left) max_water = max(max_water, current_water) # Move the pointer pointing to the shorter building if height[left] < height[right]: left += 1 else: right -= 1 return max_water"},{"question":"In an array of integers `nums`, you are allowed to perform the following operation any number of times: - Select any two indices `i` and `j` such that `i != j`. - Increment `nums[i]` by `nums[j]`. Your task is to determine whether it is possible to make all elements in the array equal. Return `true` if it is possible to make all elements equal using the above operations, otherwise return `false`.","solution":"def can_make_all_elements_equal(nums): Determines whether it is possible to make all elements in the array equal using the given operations. return len(set(nums)) == 1"},{"question":"Consider an array of integers `nums`. A **dominant** number in this array is defined as a number that is strictly greater than every other number in the array. If such a dominant number exists, return the index of this number. If no such number exists, return `-1`. Note that the array may contain negative numbers and duplicates.","solution":"def find_dominant_index(nums): Finds the index of the dominant number in the given array of integers. Returns -1 if there is no dominant number. if len(nums) == 0: return -1 max_num = max(nums) max_index = nums.index(max_num) # Check if it\'s strictly greater than every other number. for i, num in enumerate(nums): if i != max_index and max_num <= num: return -1 return max_index"},{"question":"You are given an integer array `nums` representing the population of various cities and an integer `k`. Your task is to find the **kth most populous city**. If there are multiple cities with the same population, treat them as separate entities. Return the population of the **kth most populous city**. For example, if `nums = [3, 1, 2, 4, 2]` and `k = 2`, the function should return `3` because after sorting in descending order we get `[4, 3, 2, 2, 1]` where 3 is the 2nd most populous city.","solution":"def kth_most_populous_city(nums, k): Returns the kth most populous city population from the given list of populations. :param nums: List[int] - List of populations of various cities. :param k: int - The rank of the most populous city to find. :return: int - Population of the kth most populous city. sorted_populations = sorted(nums, reverse=True) return sorted_populations[k-1]"},{"question":"You are managing a warehouse and need to optimize space usage. The warehouse is represented as a 2D grid of dimensions `m x n`, where each cell in the grid can either be empty (represented by `0`) or occupied by an item (represented by `1`). You want to find the largest rectangle that contains only empty cells (0s) in the grid, and return its area.","solution":"def maximalRectangle(matrix): :param matrix: List[List[int]] - 2D grid of dimensions m x n :return: int - area of the largest rectangle containing only empty cells (0s) if not matrix: return 0 m, n = len(matrix), len(matrix[0]) heights = [0] * n max_area = 0 for i in range(m): for j in range(n): heights[j] = heights[j] + 1 if matrix[i][j] == 0 else 0 max_area = max(max_area, largestRectangleArea(heights)) return max_area def largestRectangleArea(heights): Helper to calculate largest rectangle area in a histogram :param heights: List[int] :return: int stack = [] max_area = 0 heights.append(0) for i, h in enumerate(heights): while stack and heights[stack[-1]] > h: height = heights[stack.pop()] width = i if not stack else i - stack[-1] - 1 max_area = max(max_area, height * width) stack.append(i) return max_area"},{"question":"You are given an array of integers `difficulty` where `difficulty[i]` represents the difficulty of the ith job, and an array `worker` where `worker[i]` represents the skill level of the ith worker. Each worker can only complete a job if their skill level is greater than or equal to the job\'s difficulty. Each job can be done by at most one worker, and each worker can complete at most one job. Return _the maximum number of jobs_ that can be completed.","solution":"def max_jobs(difficulty, worker): Returns the maximum number of jobs that can be completed given the difficulty of jobs and skill level of workers. :param difficulty: List of integers representing the difficulty of each job. :param worker: List of integers representing the skill level of each worker. :return: Integer representing the maximum number of jobs that can be completed. # Sort job difficulties and worker skills difficulty.sort() worker.sort() i, j = 0, 0 completed_jobs = 0 # Traverse through workers and jobs while i < len(worker) and j < len(difficulty): if worker[i] >= difficulty[j]: # Worker can complete the job completed_jobs += 1 j += 1 # Move to the next worker regardless of job completion i += 1 return completed_jobs"},{"question":"You are given a string `s` which contains only lowercase English letters and a character `c`. Your task is to find the shortest distance from the given character `c` to each character in the string `s` and return an integer array representing these shortest distances for every index in the string. Each index in the output array should represent the minimum distance to character `c` from that position in the string `s`.","solution":"def shortest_to_char(s, c): Returns the list of shortest distances from character `c` to each character in the string `s`. n = len(s) result = [float(\'inf\')] * n # First pass: Left to right prev = float(\'-inf\') for i in range(n): if s[i] == c: prev = i result[i] = min(result[i], abs(i - prev)) # Second pass: Right to left prev = float(\'inf\') for i in range(n-1, -1, -1): if s[i] == c: prev = i result[i] = min(result[i], abs(i - prev)) return result"},{"question":"Given a string `s` and an integer `n`, return _all substrings of length `n` that can be found in `s`. Each substring should only appear once in the output, regardless of how many times it appears in the original string. You can return the answer in **any order**._","solution":"def unique_substrings(s, n): Returns all unique substrings of length n from the input string s. :param s: Input string :param n: Length of substrings :return: List of unique substrings of length n if n > len(s) or n <= 0: return [] substrings = set() for i in range(len(s) - n + 1): substrings.add(s[i:i+n]) return list(substrings)"},{"question":"An array of integers `nums` is given where the majority element is the element that appears more than `n/2` times in the array. Assume that the array always contains a majority element. Write a function to find and return the majority element in the given array `nums`.","solution":"def majority_element(nums): Returns the majority element in nums, which appears more than n/2 times. count = 0 candidate = None for num in nums: if count == 0: candidate = num count += (1 if num == candidate else -1) return candidate"},{"question":"You are given a `m x n` matrix `mat` of integers where each row is sorted in ascending order. Return _the number of common elements in all the rows of the matrix_. You must solve the problem with a time complexity better than or equal to `O(m * n)`. Write a function `findCommonElements(mat)` to accomplish this task.","solution":"from collections import Counter def findCommonElements(mat): Returns the number of common elements in all rows of the matrix \'mat\'. if not mat: return 0 # Initialize a Counter with the elements of the first row counter = Counter(mat[0]) # Intersect the counts with subsequent rows for row in mat[1:]: row_counter = Counter(row) for key in counter.keys(): if key in row_counter: counter[key] = min(counter[key], row_counter[key]) else: counter[key] = 0 # Remove elements with zero count and count the common elements common_elements_count = sum(1 for count in counter.values() if count > 0) return common_elements_count"},{"question":"You are given a `words` list containing various strings. Return a list of all strings in `words` that are **anagrams** of **any other string** in the list. Two strings are anagrams if and only if their characters can be rearranged to form each other. Ensure that the returned list does not contain any duplicates.","solution":"def find_anagrams(words): Returns a list of all strings in `words` that are anagrams of any other string in the list. from collections import defaultdict anagrams = defaultdict(list) for word in words: # Sort the characters of the word and use as a key sorted_word = \'\'.join(sorted(word)) anagrams[sorted_word].append(word) # Filter out those lists with only one word as they cannot be anagrams with any other word result = [] for word_list in anagrams.values(): if len(word_list) > 1: result.extend(word_list) return list(set(result))"},{"question":"You are given two integer arrays `arr1` and `arr2` both of size `n`. You can perform the following operation any number of times (including zero times): choose any two indices `i` and `j` where `0 <= i, j < n` and swap the elements `arr1[i]` and `arr2[j]`. Your goal is to make both arrays non-decreasing. If it is possible to achieve this, return _true_; otherwise, return _false_.","solution":"def can_sort_arrays(arr1, arr2): def is_sorted(arr): return all(arr[i] <= arr[i + 1] for i in range(len(arr) - 1)) n = len(arr1) if is_sorted(arr1) and is_sorted(arr2): return True for i in range(n): for j in range(n): arr1[i], arr2[j] = arr2[j], arr1[i] if is_sorted(arr1) and is_sorted(arr2): return True arr1[i], arr2[j] = arr2[j], arr1[i] return False"},{"question":"Given a **0-indexed** integer array `heights` representing the heights of buildings along a street, return the number of buildings you can see when looking from the left to the right. A building `i` can see building `j` if `j > i` and for every `k` in the range `(i, j)`, `heights[k] < heights[j]`. In other words, building `i` can see building `j` if there is no taller building or building of the same height between them. Return the number of buildings you can see from the leftmost building to the rightmost building, inclusive.","solution":"def count_visible_buildings(heights): Returns the number of buildings that can be seen from the leftmost building to the rightmost building. Parameters: heights (list): A list of integers representing the heights of buildings. Returns: int: The number of visible buildings. visible_buildings = 0 max_height_seen = 0 for height in heights: if height > max_height_seen: visible_buildings += 1 max_height_seen = height return visible_buildings"},{"question":"You are managing a warehouse where products are stored in a single row. Each product is represented by an integer indicating their weight. Given a list of weights `weights` representing the weights of the products in the warehouse, your task is to find the **maximum possible sum of weights** that can be obtained by selecting non-overlapping subarrays of length exactly `k`. A subarray is a contiguous part of an array. Return _the maximum possible sum_.","solution":"def max_sum_subarrays(weights, k): Returns the maximum possible sum of weights that can be obtained by selecting non-overlapping subarrays of length exactly k. if len(weights) < k: return 0 # Calculate initial sum of first window current_sum = sum(weights[:k]) max_sum = current_sum # Calculate sums of remaining windows for i in range(1, len(weights) - k + 1): current_sum = current_sum - weights[i - 1] + weights[i + k - 1] if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"Given an integer array `heights` representing the heights of buildings, find the maximum area of water that can be trapped between the buildings. The width of the container is defined as the difference in indices of the buildings, and the height is the shorter of the two heights of the buildings. Return the maximum area of water that can be trapped.","solution":"def max_area(heights): Given an integer array `heights` representing the heights of buildings, find the maximum area of water that can be trapped between the buildings. left = 0 right = len(heights) - 1 max_area = 0 while left < right: # Calculate the width width = right - left # Calculate the height as the shorter of the two heights height = min(heights[left], heights[right]) # Calculate the area current_area = width * height # Update max_area if the current_area is greater if current_area > max_area: max_area = current_area # Move the pointers to potentially find a greater area. if heights[left] < heights[right]: left += 1 else: right -= 1 return max_area"},{"question":"You are given a list of integers `nums` and a target integer `k`. Write a function that returns `true` if there is a continuous subarray of `nums` whose elements sum up to `k`, and `false` otherwise. The subarray must contain at least one number. A continuous subarray is defined as a sequence of consecutive elements from the list.","solution":"def check_subarray_sum(nums, k): Returns true if there is a continuous subarray of nums whose elements sum up to k. n = len(nums) for start in range(n): current_sum = 0 for end in range(start, n): current_sum += nums[end] if current_sum == k: return True return False"},{"question":"You are given a list `intervals` where each interval is represented as a pair of integers `[start, end]`. An interval `[a, b]` is covered by another interval `[c, d]` if and only if `c <= a` and `b <= d`. Return _the minimum number of intervals you need to remove to make sure no interval is covered by another interval in the list_.","solution":"def removeCoveredIntervals(intervals): # Sort intervals. First by start time, and then by end time in descending order intervals.sort(key=lambda x: (x[0], -x[1])) count = 0 prev_end = 0 for start, end in intervals: if end > prev_end: count += 1 prev_end = end # Number of intervals we need to remove return len(intervals) - count"},{"question":"You are given a 2D integer matrix `grid` where each cell contains a positive integer which represents the number of candies in that cell. You can start at any cell in the leftmost column and move to any cell in the rightmost column by only moving to the right, up, or down to an adjacent cell. Return _the maximum number of candies you can collect by the time you reach any cell in the rightmost column_.","solution":"def max_candies(grid): Returns the maximum number of candies that can be collected by moving from the leftmost column to the rightmost column in a given 2D grid. if not grid or not grid[0]: return 0 rows = len(grid) cols = len(grid[0]) # Initialize dp table with the same dimensions as grid dp = [[0] * cols for _ in range(rows)] # Copy the first column from grid to dp for r in range(rows): dp[r][0] = grid[r][0] # Fill the dp table for c in range(1, cols): for r in range(rows): max_prev = dp[r][c-1] # Move right from the same row if r > 0: max_prev = max(max_prev, dp[r-1][c-1]) # Move right-up from the row above if r < rows - 1: max_prev = max(max_prev, dp[r+1][c-1]) # Move right-down from the row below dp[r][c] = grid[r][c] + max_prev # Find the maximum candies collected in any cell of the last column max_candies_collected = max(dp[r][cols-1] for r in range(rows)) return max_candies_collected"},{"question":"You are given a binary search tree (BST) with `n` nodes. Each node has a value. Your task is to compute the sum of all node values for every level of the tree and return these sums in a list where each element corresponds to a level sum starting from the root level. If the tree is empty (i.e., `n == 0`), return an empty list. Complete the function `level_sum(root: Optional[TreeNode]) -> List[int]`. The input `root` is the root node of the BST, and the TreeNode structure is provided as: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ```","solution":"from typing import Optional, List from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_sum(root: Optional[TreeNode]) -> List[int]: if not root: return [] results = [] queue = deque([root]) while queue: level_length = len(queue) level_sum = 0 for _ in range(level_length): node = queue.popleft() level_sum += node.val if node.left: queue.append(node.left) if node.right: queue.append(node.right) results.append(level_sum) return results"},{"question":"Given a list of `n` integers, return the **length of the longest strictly increasing subsequence**. A subsequence is a sequence derived from another sequence by deleting some or no elements without changing the order of the remaining elements. For example, consider the list `[10, 9, 2, 5, 3, 7, 101, 18]`: - One longest increasing subsequence is `[2, 3, 7, 101]`, which has a length of 4. - Another valid subsequence could be `[2, 5, 7, 18]`. You need to calculate the length of the longest such subsequence that can be extracted from the given list of integers.","solution":"def length_of_lis(nums): Returns the length of the longest strictly increasing subsequence in the list of integers. if not nums: return 0 # This list will store the longest increasing subsequence length ending at each index dp = [1] * len(nums) for i in range(1, len(nums)): for j in range(i): if nums[i] > nums[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"You are given two integer arrays `arr1` and `arr2` both of length `n` and an integer `x`. You are allowed to rearrange the order of elements in `arr2` any way you want. Determine if there exists a permutation of `arr2` such that for every index `i` (where `0 <= i < n`), the sum of `arr1[i]` and the corresponding element in the permutation of `arr2` is greater than or equal to `x`. Return _`true` if such a permutation exists, otherwise return `false`._","solution":"def can_rearrange_to_meet_target(arr1, arr2, x): Determines if there exists a permutation of arr2 such that for every index i (0 <= i < n), the sum of arr1[i] and the corresponding element in the permutation of arr2 is >= x. arr1.sort() arr2.sort(reverse=True) for i in range(len(arr1)): if arr1[i] + arr2[i] < x: return False return True"},{"question":"Develop a function that takes in a list of `non-negative` integers representing heights of blocks and an integer `d`, then returns the total number of `pits` in the landscape. A pit is defined as a sequence of consecutive blocks where the height decreases and then increases, forming a \\"U\\" shape. The depth of the pit is determined by the difference between the highest blocks surrounding the pit and the lowest block inside the pit. Only include a pit in the count if its depth is greater than or equal to `d`.","solution":"def count_pits(heights, d): Counts the number of pits in the landscape which have a depth of at least d. Parameters: heights (list of int): List of non-negative integers representing the heights of blocks. d (int): Minimum depth of the pit to be counted. Returns: int: Total number of pits that meet the depth requirement. n = len(heights) if n < 3: return 0 # Not enough blocks to form a pit. pit_count = 0 for i in range(1, n-1): if heights[i] < heights[i-1] and heights[i] < heights[i+1]: left = right = heights[i] l = i - 1 r = i + 1 while l > 0 and heights[l] <= heights[l-1]: left = min(left, heights[l]) l -= 1 while r < n - 1 and heights[r] <= heights[r+1]: right = min(right, heights[r]) r += 1 pit_depth = min(heights[l], heights[r]) - heights[i] if pit_depth >= d: pit_count += 1 return pit_count"},{"question":"You are given two strings `s` and `t` of length `n` and `m`, respectively, and an integer `k`. You can perform one of the following operations on `s` at most `k` times to convert it into `t`: - Insert a character at any position in `s`. - Delete a character from any position in `s`. - Replace a character at any position in `s` with any character. Return _true_ if it is possible to convert `s` into `t` using at most `k` operations, otherwise return _false_.","solution":"def can_convert_with_k_operations(s, t, k): Determines if s can be converted into t with at most k operations. Parameters: s (str): Source string. t (str): Target string. k (int): Maximum number of operations allowed. Returns: bool: True if s can be converted to t with at most k operations, False otherwise. n = len(s) m = len(t) # If the total length difference is greater than k, it\'s not possible if abs(n - m) > k: return False # To find the minimum number of operations required: # Use Dynamic Programming to compute the minimum edit distance dp = [[0] * (m + 1) for _ in range(n + 1)] for i in range(n + 1): for j in range(m + 1): if i == 0: dp[i][j] = j # Insert all characters of t elif j == 0: dp[i][j] = i # Delete all characters of s elif s[i - 1] == t[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = 1 + min(dp[i - 1][j], # Remove dp[i][j - 1], # Insert dp[i - 1][j - 1]) # Replace # If the edit distance is within k, it\'s possible return dp[n][m] <= k"},{"question":"Given an array of integers `nums` representing stock prices on different days, and an integer `k`, find the maximum profit you can achieve by making at most `k` transactions. A transaction is defined as buying and then selling one share of the stock. Note that you cannot engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again). Implement the function `maxProfit(int k, int[] prices)` that returns the maximum profit. If no profit can be made, return `0`.","solution":"def maxProfit(k, prices): Calculate the maximum profit with at most `k` transactions. n = len(prices) if n == 0: return 0 # If k is greater or equal to half the number of prices, it\'s equivalent to unlimited transactions if k >= n // 2: return sum(max(prices[i + 1] - prices[i], 0) for i in range(n - 1)) # Dynamic programming table profits = [[0] * n for _ in range(k + 1)] for t in range(1, k + 1): max_so_far = -prices[0] for d in range(1, n): profits[t][d] = max(profits[t][d - 1], prices[d] + max_so_far) max_so_far = max(max_so_far, profits[t - 1][d] - prices[d]) return profits[k][-1]"},{"question":"You are given a string `s` which consists of alphanumeric characters and parentheses \'(\', \')\'. Your task is to determine if the parentheses are balanced, considering the following rules: - Open parentheses must be closed by the same type of parentheses in the correct order. - Every closing parenthesis has a corresponding opening parenthesis of the same type. Implement the function `bool isBalanced(string s)` that: - Returns `true` if the input string has balanced parentheses; otherwise, returns `false`. For example: - Given `\\"a(b)c(d)e(f)g\\"`, the function should return `true`. - Given `\\"a(b)c)(d)e(f)g\\"`, the function should return `false`.","solution":"def isBalanced(s): Returns True if the parentheses in the string `s` are balanced, False otherwise. stack = [] for char in s: if char == \'(\': stack.append(char) elif char == \')\': if not stack or stack.pop() != \'(\': return False return not stack"},{"question":"Given a string `s` and a dictionary of strings `wordDict`, return `true` or `false` to determine if `s` can be segmented into one or more dictionary words. You may assume that the dictionary does not contain duplicate words. For example, given `s = \\"leetcode\\"` and `wordDict = [\\"leet\\", \\"code\\"]`, return `true` because `\\"leetcode\\"` can be broken into `\\"leet\\"` and `\\"code\\"`. Implement the `wordBreak` function: * `boolean wordBreak(String s, List<String> wordDict)` Returns `true` if `s` can be segmented into one or more dictionary words, and `false` otherwise.","solution":"def wordBreak(s, wordDict): Returns True if the string s can be segmented into one or more dictionary words. dp = [False] * (len(s) + 1) dp[0] = True for i in range(1, len(s) + 1): for j in range(i): if dp[j] and s[j:i] in wordDict: dp[i] = True break return dp[len(s)]"},{"question":"You are given a binary tree where each node contains a value from 0 to 9. Each root-to-leaf path in the tree represents a number formed by concatenating the values of the nodes along the path. Your task is to find the sum of all the numbers formed from root to leaf paths. The tree structure is defined as follows: class TreeNode { public int val; public TreeNode left; public TreeNode right; } Return the total sum of all the numbers.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sumNumbers(root: TreeNode) -> int: def dfs(node, current_number): if not node: return 0 current_number = current_number * 10 + node.val # If it\'s a leaf, return the current number formed if not node.left and not node.right: return current_number # Otherwise, keep going deeper left_sum = dfs(node.left, current_number) right_sum = dfs(node.right, current_number) return left_sum + right_sum return dfs(root, 0)"},{"question":"You are given an integer array `nums` where the elements are sorted in ascending order. However, the array has been rotated at an unknown pivot such that the resulting array is not completely sorted. Write a function `findMin` to determine the smallest element in the array. Note that the rotation implies that the array satisfies the property where `nums[0]` can be greater than `nums[n-1]`. Assume there are no duplicate elements in the array. Example: ``` Input: nums = [4,5,6,7,0,1,2] Output: 0 ``` Return the minimum value in the rotated sorted array.","solution":"def findMin(nums): This function finds the minimum element in a rotated sorted array. left, right = 0, len(nums) - 1 while left < right: mid = (left + right) // 2 if nums[mid] > nums[right]: left = mid + 1 else: right = mid return nums[left]"},{"question":"You are given `n` points in a 2D plane as an array `points` where `points[i] = [xi, yi]` represents the coordinates of the `i-th` point. A point `(xi, yi)` is **dominated** by another point `(xj, yj)` if both `xi <= xj` and `yi <= yj`. Find the largest number of points that can be picked such that each point is dominated by at least one other point from the set (excluding the point itself). Return the maximum number of such points that can be picked.","solution":"def max_dominated_points(points): Returns the maximum number of points that can be picked such that each point is dominated by at least one other point from the set (excluding the point itself). points.sort(key=lambda p: (p[0], p[1])) max_points = 0 n = len(points) for i in range(n): for j in range(i + 1, n): if points[i][0] <= points[j][0] and points[i][1] <= points[j][1]: max_points += 1 break return max_points"},{"question":"You have a binary tree where each node contains an integer value. Write a function to determine if the binary tree is \\"complete\\". A complete binary tree is a binary tree in which every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and `n` nodes. The function should return `True` if the binary tree is complete, otherwise return `False`.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_complete_binary_tree(root): if not root: return True queue = [root] end = False while queue: node = queue.pop(0) if node: if end: return False queue.append(node.left) queue.append(node.right) else: end = True return True"},{"question":"Imagine you are working with a **0-indexed** list of integers. You need to maintain this list using the following operations: 1. **Insert** a given integer `x` at the end of the list. 2. **Delete** all occurrences of a specific integer `y` from the list. 3. **Get Frequency** of a particular integer `z` in the list. Implement the `IntegerList` class: * `IntegerList()` Initializes an empty list. * `void insert(int x)` Appends integer `x` to the end of the list. * `void delete(int y)` Removes all instances of integer `y` from the list. * `int getFrequency(int z)` Returns the number of occurrences of integer `z` in the list. You need to handle the operations in their respective methods appropriately and efficiently.","solution":"class IntegerList: def __init__(self): Initializes an empty list. self.lst = [] def insert(self, x): Appends integer x to the end of the list. self.lst.append(x) def delete(self, y): Removes all instances of integer y from the list. self.lst = [i for i in self.lst if i != y] def getFrequency(self, z): Returns the number of occurrences of integer z in the list. return self.lst.count(z)"},{"question":"You are given a matrix `grid` of size `m x n` and an integer `k`. The matrix consists of only `0`s and `1`s. A path is valid if it starts at the top-left cell `(0, 0)`, moves to the bottom-right cell `(m-1, n-1)`, and only moves right or down at each step. The cost of a path is defined as the total number of `1`s in the cells that the path visits. Write a function that returns `True` if there exists a valid path with a cost of at most `k`, otherwise return `False`.","solution":"def has_valid_path_with_cost(grid, k): def dfs(x, y, cost): if x >= m or y >= n or cost > k: return False if x == m-1 and y == n-1: return cost + grid[x][y] <= k return dfs(x+1, y, cost + grid[x][y]) or dfs(x, y+1, cost + grid[x][y]) m = len(grid) n = len(grid[0]) return dfs(0, 0, 0)"},{"question":"You are given an integer array `arr` and an integer `k`. Your task is to determine the number of contiguous subarrays within `arr` where the sum of the elements is divisible by `k`. The test cases are generated such that the number of subarrays always fits within the **64-bit** integer range.","solution":"def subarrays_div_by_k(arr, k): Returns the number of contiguous subarrays where the sum of the elements is divisible by k. :param arr: List[int] - array of integers :param k: int - integer k :return: int - number of subarrays count = 0 prefix_sum = 0 mod_count = {0: 1} for num in arr: prefix_sum += num mod = prefix_sum % k # Ensure positive mod value to handle negative numbers if mod < 0: mod += k if mod in mod_count: count += mod_count[mod] mod_count[mod] += 1 else: mod_count[mod] = 1 return count"},{"question":"You are given a binary tree in which each node contains an integer value. Your task is to collect all the values of the nodes in a tree in a level order manner. Level order traversal visits each level of the tree from left to right, top to bottom. Return a list of lists, where each list contains the node values at each level of the tree. The root node is at level 0. If the tree is empty, return an empty list. Example: If the tree is: ``` 3 / 9 20 / 15 7 ``` The output should be: ``` [ [3], [9, 20], [15, 7] ] ``` Implement the function `levelOrderTraversal(root: TreeNode) -> List[List[int]]` to achieve this goal.","solution":"from collections import deque from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def levelOrderTraversal(root: Optional[TreeNode]) -> List[List[int]]: if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) current_level = [] for _ in range(level_size): node = queue.popleft() current_level.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(current_level) return result"},{"question":"You are given a **0-indexed** array of integers `attendance` representing the number of students attending a special class on each day. The class lasts for `k` days but students may attend multiple sessions. The school has a special rule that if a student attends a class, they cannot attend on the next day. Determine the **maximum** number of students that can attend the class over the `k` days using this rule. Return _the **maximum** number of students_ that can attend the class.","solution":"def max_students(attendance, k): Returns the maximum number of students that can attend the class over k days given the constraint that they cannot attend on consecutive days. Parameters: attendance (list): List of integers representing the attendance on each day. k (int): Number of days the class lasts. Returns: int: Maximum number of students that can attend. if k == 0 or not attendance: return 0 dp = [0] * k # dp[i] will store the maximum attendance possible up to day i dp[0] = attendance[0] for i in range(1, k): if i == 1: dp[i] = max(attendance[i], dp[i-1]) else: dp[i] = max(dp[i-1], dp[i-2] + attendance[i]) return dp[k-1]"},{"question":"You are given a string `s` consisting of only lowercase English letters. In one operation, you can: - Choose any character in the string and remove all of its occurrences from `s`. Return the minimum number of operations required to make the resulting string have no two consecutive identical characters.","solution":"def min_operations_to_remove_consecutive_duplicates(s): Returns the minimum number of operations required to make the string have no two consecutive identical characters by removing all occurrences of chosen characters in one operation. if not s: return 0 prev_char = s[0] operations = 0 consecutive_duplicates = False for i in range(1, len(s)): if s[i] == prev_char: consecutive_duplicates = True else: prev_char = s[i] if consecutive_duplicates: return len(set(s)) else: return 0"},{"question":"You are given a binary string `s` that consists only of characters \'0\' and \'1.\' Your task is to find the **maximum** number of substrings you can remove from `s` such that all the remaining substrings can be rearranged to form a palindrome. A **substring** is a contiguous sequence of characters within a string. Return the _maximum number of substrings that can be removed_.","solution":"def max_substrings_to_remove_for_palindrome(s): Returns the maximum number of substrings that can be removed so that the remaining substrings can be rearranged to form a palindrome. # Count the number of \'0\'s and \'1\'s count_0 = s.count(\'0\') count_1 = s.count(\'1\') # The minimum number of those counts will be the number of substrings that can be removed return min(count_0, count_1)"},{"question":"[Question] 4: You are given a list of integers `arr` representing the positions of stones in a row. A frog is initially located at position `arr[0]`. The frog can hop to the next stone which is exactly `d` units away. The frog can also skip one stone and jump to the one that is `2 * d` units away. However, the frog can only hop or jump to stones that are infused with magical energy, and this is represented by having only multiples of `d` in the array. Your task is to determine the maximum number of hops the frog can make in this manner. If a hop is not possible at any point, the frog stops. Return the _maximum number of hops_ the frog can make. For example, given `arr = [0, 4, 8, 12, 16, 20]` and `d = 4`, the frog can make a maximum of 5 hops: `0 -> 4 -> 8 -> 12 -> 16 -> 20`.","solution":"def max_hops(arr, d): Returns the maximum number of hops a frog can make. max_hops = 0 current_idx = 0 while True: possible_next_steps = [i for i in range(current_idx+1, len(arr)) if arr[i] == arr[current_idx] + d or arr[i] == arr[current_idx] + 2*d] if not possible_next_steps: break current_idx = possible_next_steps[0] max_hops += 1 return max_hops"},{"question":"You are given two non-empty strings, `s1` and `s2`, consisting of lowercase English letters. Determine if `s2` can be obtained by rotating `s1` by any number of positions. A rotation by `k` positions moves the first `k` characters to the end of the string while keeping the remaining characters in their original order. For example, if `s1 = \\"abcdef\\"` and `k = 2`, the rotation results in `s1` becoming `\\"cdefab\\"`. Return `true` if `s2` can be obtained by rotating `s1`, and `false` otherwise.","solution":"def can_rotate_to(s1, s2): Returns True if s2 can be obtained by rotating s1 by any number of positions. if len(s1) != len(s2): return False # Concatenate s1 to itself to handle rotations s1_extended = s1 + s1 # Check if s2 is a substring of the extended string return s2 in s1_extended"},{"question":"Given a string `s` and a character `c` that occurs in `s`, return _an array of integers representing the shortest distance from each character in `s` to the character `c`_. If the character `c` appears multiple times in the string, select the closest occurrence for each character in `s`. [Question] 4","solution":"def shortest_to_char(s, c): Returns an array of integers representing the shortest distance from each character in s to the character c. n = len(s) result = [n] * n position = -n for i in range(n): if s[i] == c: position = i result[i] = i - position for i in range(n - 1, -1, -1): if s[i] == c: position = i result[i] = min(result[i], abs(i - position)) return result"},{"question":"You are given an array of integers `arr`, and you need to find a contiguous sub-array containing at least one number, which has the largest sum. Additionally, return the starting and ending indices (0-based) of this sub-array. If there are multiple sub-arrays with the same maximum sum, return the one with the smallest starting index. If there is still a tie, return the one with the smallest ending index. Return an array `[max_sum, start_index, end_index]`, where `max_sum` is the sum of the sub-array, and `start_index` and `end_index` are the starting and ending indices of the sub-array, respectively.","solution":"def max_sub_array(arr): Finds the contiguous sub-array with the largest sum and returns the sum along with the starting and ending indices of this sub-array. :param arr: List of integers :return: A list [max_sum, start_index, end_index] max_sum = float(\'-inf\') current_sum = 0 start = 0 start_temp = 0 end = 0 for i in range(len(arr)): if current_sum <= 0: current_sum = arr[i] start_temp = i else: current_sum += arr[i] if current_sum > max_sum: max_sum = current_sum start = start_temp end = i elif current_sum == max_sum and (start_temp < start or (start_temp == start and i < end)): start = start_temp end = i return [max_sum, start, end]"},{"question":"You are given a 2D grid of size `m x n` where each cell is represented by a pair of integers `[height, rainfall]`. The `height` represents the elevation of the cell, and the `rainfall` represents the amount of water that falls on that cell during a rainstorm. Water can only flow from cell A to cell B if the elevation of A is greater than or equal to the elevation of B and they are adjacent (up, down, left, right). Calculate and return the total volume of water that will accumulate in each cell after a rainstorm, assuming that water cannot flow off the edges of the grid.","solution":"def calculate_water_volume(grid): Calculate the total volume of water that will accumulate in each cell after a rainstorm. m, n = len(grid), len(grid[0]) if grid else 0 if m == 0 or n == 0: return 0 # Directions for up, down, left, right movements directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Initialize the accumulative water volume grid with rainfalls water_volume = [[grid[i][j][1] for j in range(n)] for i in range(m)] # Create a min-heap for the boundary cells for priority in processing import heapq min_heap = [] visited = [[False]*n for _ in range(m)] # Push all boundary cells into the min_heap for i in range(m): heapq.heappush(min_heap, (grid[i][0][0], i, 0)) heapq.heappush(min_heap, (grid[i][n-1][0], i, n-1)) visited[i][0] = True visited[i][n-1] = True for j in range(n): heapq.heappush(min_heap, (grid[0][j][0], 0, j)) heapq.heappush(min_heap, (grid[m-1][j][0], m-1, j)) visited[0][j] = True visited[m-1][j] = True # Process cells in the min-heap while min_heap: height, x, y = heapq.heappop(min_heap) for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny]: visited[nx][ny] = True current_height = max(height, grid[nx][ny][0]) water_volume[nx][ny] += max(current_height - grid[nx][ny][0], 0) heapq.heappush(min_heap, (current_height, nx, ny)) return water_volume"},{"question":"You are given a string `s` that consists of a mixture of uppercase and lowercase letters and an array of integers `indices` of the same length. The `indices` array is a permutation of numbers ranging from `0` to `len(s) - 1`. Your task is to reconstruct the string by rearranging the characters in `s` based on the order of `indices`, and you should return the newly shuffled string. For example, if you have `s = \\"abc\\"` and `indices = [2, 1, 0]`, then the shuffled string will be `\\"cba\\"`.","solution":"def restore_string(s, indices): Reconstructs the string `s` by rearranging the characters based on the order of `indices`. # Create a list of the same length as `s` to store the rearranged characters rearranged = [\'\'] * len(s) # Place each character of `s` in its new position according to `indices` for i, index in enumerate(indices): rearranged[index] = s[i] # Join the list back into a string and return the result return \'\'.join(rearranged)"},{"question":"You are given a string `text`. A **word** is defined as a contiguous substring of `text` that consists of only alphabetical characters and is bounded by non-alphabetical characters or the boundaries of the string. Write a function that returns the length of the shortest word in the given string. If there are no words in the string, return `0`.","solution":"def length_of_shortest_word(text): Returns the length of the shortest word in the given text. A word is defined as a contiguous substring of text that consists of only alphabetical characters. import re # Find all words in the text using regex words = re.findall(r\'[a-zA-Z]+\', text) if not words: return 0 # Find the length of the shortest word return min(len(word) for word in words)"},{"question":"You are given a `Node` class that represents a node in a binary tree. Each node contains an integer value and pointers to its left and right children. Write a function to serialize the binary tree to a string and deserialize the string back to the binary tree. Implement the following methods: * `string serialize(Node* root)` : This method encodes a tree to a single string. * `Node* deserialize(string data)` : This method decodes the string back to the binary tree. You may assume that the input tree is binary search tree. The serialized string is such that it can be deserialized back to the original tree structure.","solution":"class Node: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def serialize(root): Encodes a tree to a single string. def dfs(node): if not node: return \\"None,\\" return str(node.val) + \\",\\" + dfs(node.left) + dfs(node.right) return dfs(root) def deserialize(data): Decodes your encoded data to tree. def dfs(nodes): val = next(nodes) if val == \\"None\\": return None node = Node(int(val)) node.left = dfs(nodes) node.right = dfs(nodes) return node return dfs(iter(data.split(\',\')))"},{"question":"Imagine you have an array of integers representing the population count of different cities. You are required to construct a new string array where each string represents a binary number of a city\'s population count. The binary number should be left-padded with zeros to ensure each binary string is of the same length, which is equal to the length of the binary representation of the city with the highest population. Write a function that takes an array of integers and returns the new string array with the binary representations. For example, given the input array `[3, 7, 2]`, the highest population is `7` which has a binary representation of `111`. Therefore, the output should be `[\\"011\\", \\"111\\", \\"010\\"]`.","solution":"def population_to_binary_string(populations): Returns a list of binary string representations of city populations, left-padded with zeros such that each binary string has the same length as the binary representation of the highest population number. if not populations: return [] # Find the highest population to determine the length of the binary strings max_population = max(populations) max_length = len(bin(max_population)) - 2 # subtract 2 to remove \'0b\' prefix binary_strings = [ bin(population)[2:].zfill(max_length) for population in populations ] return binary_strings"},{"question":"You are given a 0-indexed integer array `nums` of size `n` representing a **permutation** of the numbers from `0` to `n-1`. You are also given an integer `k`. You must perform exactly `k` swaps on the array where, in each swap, you select any two distinct indices `i` and `j` such that `0 <= i, j < n` and swap `nums[i]` with `nums[j]`. The goal is to minimize the maximum difference between any two adjacent numbers in the resulting array. Return the minimum possible value of the maximum difference between any two adjacent numbers after performing exactly `k` swaps.","solution":"def minMaxDifferenceAfterKSwaps(nums, k): Returns the minimum possible value of the maximum difference between any two adjacent numbers after performing exactly k swaps. n = len(nums) if n <= 1: return 0 nums.sort() min_diff = float(\'inf\') for i in range(n - 1): min_diff = min(min_diff, nums[i + 1] - nums[i]) return min_diff"},{"question":"Given a string `s` and a dictionary of words `wordDict`, return _all the possible sentences you can form by concatenating words from the dictionary following the order in `s`._ You may reuse the dictionary words as many times as needed. The order of words in each sentence must be the same as their order in `s`. The saturation of words within the sentence must match the input order as well.","solution":"def wordBreak(s, wordDict): Returns all possible sentences by concatenating words from the dictionary following the order in `s`. memo = {} def dfs(ind): if ind in memo: return memo[ind] if ind == len(s): return [\\"\\"] res = [] for word in wordDict: if s.startswith(word, ind): for sub_sentence in dfs(ind + len(word)): if sub_sentence: res.append(word + \\" \\" + sub_sentence) else: res.append(word) memo[ind] = res return res return dfs(0)"},{"question":"You are given a **string** `s` consisting of lowercase English letters and a **list** of `queries` where each query is a list of two integers `[left, right]`. For each query, find the count of distinct characters in the substring of `s` that lies between the indices `left` and `right` (inclusive). Return an array of answers where each answer corresponds to the result of a single query. Example: - Input: `s = \\"abcba\\"`, `queries = [[0, 2], [1, 4], [0, 4]]` - Output: `[3, 3, 3]`","solution":"def count_distinct_characters(s, queries): Returns the count of distinct characters in the substring of `s` between indices `left` and `right` (inclusive) for each query. Parameters: s (str): the input string consisting of lowercase English letters. queries (list of list of int): a list where each element is a list of two integers [left, right]. Returns: list of int: a list of counts of distinct characters for each query. results = [] for left, right in queries: substring = s[left:right+1] distinct_chars_count = len(set(substring)) results.append(distinct_chars_count) return results"},{"question":"Given a string `s` that consists of only digits, remove the minimum number of digits such that the remaining digits are in a non-decreasing order. Return the resulting string with the removed digits being the minimum possible.","solution":"def remove_min_to_non_decreasing(s): Removes the minimum number of digits such that the remaining digits are in non-decreasing order. stack = [] for digit in s: while stack and stack[-1] > digit: stack.pop() stack.append(digit) return \'\'.join(stack)"},{"question":"You are given an array of integers `nums` and an integer `target`. You need to find the length of the shortest subarray whose sum is greater than or equal to `target`. If there is no such subarray, return `-1`. A subarray is a contiguous part of an array. Your function should return the minimum length of such a subarray, or `-1` if no such subarray exists.","solution":"def min_subarray_len(nums, target): Return the length of the shortest subarray with a sum >= target. If no such subarray exists, return -1. n = len(nums) min_len = float(\'inf\') left = 0 current_sum = 0 for right in range(n): current_sum += nums[right] while current_sum >= target: min_len = min(min_len, right - left + 1) current_sum -= nums[left] left += 1 return min_len if min_len != float(\'inf\') else -1"},{"question":"You are given a list of non-negative integers `nums` and an integer `target`. Return the number of subsets of `nums` that sum up to `target`. A subset is defined as any combination of elements from the list, with each element being included or not included independently of the other elements. The order of elements in the subset does not matter. Consider that the empty subset is valid and its sum is `0`.","solution":"def count_subsets(nums, target): Returns the number of subsets of `nums` that sum up to `target`. def helper(index, current_sum): # Base cases if current_sum == target: return 1 if index == len(nums) or current_sum > target: return 0 # Include the current element include = helper(index + 1, current_sum + nums[index]) # Exclude the current element exclude = helper(index + 1, current_sum) return include + exclude return helper(0, 0)"},{"question":"Given a non-negative integer `n`, generate the `n`-th Fibonacci number. The Fibonacci sequence is defined as follows: - F(0) = 0 - F(1) = 1 - F(n) = F(n-1) + F(n-2) for n > 1 Implement an algorithm to compute the `n`-th Fibonacci number efficiently, avoiding the straightforward recursive approach due to its exponential time complexity. Your solution should run in linear time.","solution":"def fibonacci(n): Returns the n-th Fibonacci number. if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"Given the head of a singly linked list, return _the linked list in reversed order_. The input list should be reversed in place, which means you must **not** allocate any new nodes. Instead, change the `next` pointer of each node in order to reverse the list.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_list(head: ListNode) -> ListNode: Reverses a singly linked list in place. :param head: The head node of the linked list. :return: The new head node of the reversed linked list. prev = None curr = head while curr: next_temp = curr.next curr.next = prev prev = curr curr = next_temp return prev"},{"question":"Given an integer array `arr`, find and return the maximum sum of any non-empty subarray of `arr` where no two consecutive elements are included in the subarray. A subarray is a contiguous sub-sequence of elements within an array. # Function Signature ```python def max_non_consecutive_subarray_sum(arr: List[int]) -> int: pass ``` # Sample Input ```python arr = [3, 2, 5, 10, 7] ``` # Sample Output ```python 15 # Explanation: The non-consecutive subarray [3, 10] or [2, 10, 3] or [5, 7] gives the maximum sum 15. ```","solution":"from typing import List def max_non_consecutive_subarray_sum(arr: List[int]) -> int: n = len(arr) if n == 0: return 0 if n == 1: return arr[0] # dp[i] will store the maximum sum possible when considering up to the ith element dp = [0] * n dp[0] = arr[0] dp[1] = max(arr[0], arr[1]) for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + arr[i]) return dp[-1] # Example usage: arr = [3, 2, 5, 10, 7] print(max_non_consecutive_subarray_sum(arr)) # Output: 15"},{"question":"Given an array of integers `nums`, return _the length of the longest contiguous subarray where the absolute difference between any two elements is less than or equal to a given integer `limit`_. A subarray is a contiguous, non-empty sequence of elements within an array.","solution":"from collections import deque import heapq def longest_subarray(nums, limit): Returns the length of the longest contiguous subarray such that the absolute difference between any two elements is less than or equal to the given limit. max_len = 0 queue_min = deque() queue_max = deque() start = 0 for end in range(len(nums)): while queue_max and nums[end] > queue_max[-1]: queue_max.pop() while queue_min and nums[end] < queue_min[-1]: queue_min.pop() queue_max.append(nums[end]) queue_min.append(nums[end]) while queue_max and queue_min and (queue_max[0] - queue_min[0] > limit): if queue_max[0] == nums[start]: queue_max.popleft() if queue_min[0] == nums[start]: queue_min.popleft() start += 1 max_len = max(max_len, end - start + 1) return max_len"},{"question":"Write a function that takes a string `s` which represents a valid arithmetic expression containing only non-negative integers, \'+\', \'-\', \'*\', \'/\' operators, and empty spaces. Return _the result of evaluating the arithmetic expression_. Note that division should truncate towards zero. It is guaranteed that the given expression is always valid.","solution":"def evaluate_expr(s): Evaluates a valid arithmetic expression containing only non-negative integers, \'+\', \'-\', \'*\', \'/\' operators, and empty spaces. Division truncates towards zero. def operate(op, second, first): if op == \'+\': return first + second if op == \'-\': return first - second if op == \'*\': return first * second if op == \'/\': return int(first / second) # truncate towards zero num, stack, op = 0, [], \'+\' s = s.replace(\' \', \'\') + \'+\' for i, ch in enumerate(s): if ch.isdigit(): num = num * 10 + int(ch) elif ch in \'+-*/\': if op == \'+\': stack.append(num) elif op == \'-\': stack.append(-num) elif op in \'*/\': stack.append(operate(op, num, stack.pop())) num, op = 0, ch return sum(stack)"},{"question":"You are given an integer array `nums` and an integer `target`. Suppose we want to form a combination of `k` elements from `nums` such that the sum of these elements is equal to `target`. Return _all possible combinations of `k` elements_ from `nums` that add up to `target`. Each combination should be unique, and the order of elements within each combination does not matter. You may assume that all given numbers in `nums` are distinct and that there is a solution for at least one combination. You can return the combinations in any order, but make sure to exclude duplicates from the final result.","solution":"from itertools import combinations def combination_sum_k(nums, target, k): Returns all unique combinations of k elements from nums that sum to target. result = [] for comb in combinations(nums, k): if sum(comb) == target: result.append(list(comb)) return result"},{"question":"You are given an array `tasks` where `tasks[i]` represents the time duration it takes to complete the `i-th` task. You have a total of `n` workers available, and each worker can only work on one task at a time. Write a function that returns _the minimum amount of time required to complete all the tasks_ if you can assign multiple tasks to each worker but each task must be completed by only one worker. You must solve this problem using a greedy algorithm.","solution":"def min_time_to_complete(tasks, n): Returns the minimum amount of time required to complete all the tasks given a number of workers. Parameters: tasks (list): List of integers representing the time duration of each task. n (int): Number of workers available. Returns: int: Minimum time to complete all tasks. # Sort tasks in descending order tasks.sort(reverse=True) # Initialize list to keep track of time worked by each worker workers = [0] * n # Greedily assign each task to the worker with the least amount of work so far for task in tasks: workers.sort() workers[0] += task # The maximum work by any worker will be the minimum time to finish all tasks return max(workers)"},{"question":"There are some robots lined up in a row. Each robot has an associated height represented as an integer in an array `heights` where `heights[i]` is the height of the `ith` robot. A robot can see another robot if it\'s shorter (strictly) than the robot looking for others in the same direction (left or right). For each robot, you are asked to calculate two values: 1. The number of robots it can see to its left. 2. The number of robots it can see to its right. Return the combined result as a 2D list `result` where `result[i] = [left[i], right[i]]`, and `left[i]` is the number of robots the `ith` robot can see to its left, while `right[i]` is the number of robots it can see to its right.","solution":"def count_visible_robots(heights): n = len(heights) result = [[0, 0] for _ in range(n)] # Calculate left view count for each robot for i in range(n): count = 0 for j in range(i - 1, -1, -1): if heights[j] < heights[i]: count += 1 else: break result[i][0] = count # Calculate right view count for each robot for i in range(n): count = 0 for j in range(i + 1, n): if heights[j] < heights[i]: count += 1 else: break result[i][1] = count return result"},{"question":"You are given an integer array `arr` and an integer `target`. In one operation, you can choose an element of the array and add or subtract 1 from it. Return _the minimum number of operations required to make the sum of the array equal to_ `target`. Since the answer may be very large, return it **modulo** `10^9 + 7`.","solution":"def min_operations_to_reach_target(arr, target): mod = 10**9 + 7 current_sum = sum(arr) diff = abs(target - current_sum) return diff % mod"},{"question":"Given an array of integers `prices` representing the daily prices of a stock, where `prices[i]` is the price of the stock on the `i-th` day, your task is to return the **maximum profit** you can achieve. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times), but you must sell the stock before you buy it again. Write a function to compute the maximum profit. The function should have the following signature: ```python def maxProfit(prices: List[int]) -> int: ```","solution":"from typing import List def maxProfit(prices: List[int]) -> int: Calculate the maximum profit that can be achieved from given stock prices. Parameters: prices (List[int]): List of stock prices where prices[i] is the price of the stock on the i-th day. Returns: int: The maximum profit that can be achieved. if not prices: return 0 max_profit = 0 for i in range(1, len(prices)): if prices[i] > prices[i - 1]: max_profit += prices[i] - prices[i - 1] return max_profit"},{"question":"You are given a list of `n` tasks represented by integers. Each task can be executed in one unit of time. A cooldown period of `k` units of time is required between two consecutive executions of the same task. The goal is to determine the minimum time required to finish all tasks while adhering to the cooldown constraint. Return _an integer representing the minimum time needed to complete all tasks_.","solution":"from collections import Counter, deque def min_time_to_finish_tasks(tasks, k): Calculates the minimum time required to finish all tasks with a cooldown constraint. Parameters: tasks (list): List of tasks represented by integers. k (int): Cooldown period between consecutive execution of the same task. Returns: int: Minimum time required to finish all tasks. if not tasks: return 0 task_counts = Counter(tasks) max_count = max(task_counts.values()) max_count_tasks = list(task_counts.values()).count(max_count) # Calculate the number of slots of cooldown we need total_slots = (max_count - 1) * (k + 1) + max_count_tasks return max(total_slots, len(tasks))"},{"question":"Given a string `s` representing a sentence with disposable and important words, write a function `important_words(s: str) -> List[str]` that extracts and returns the important words in the correct order. Important words are distinguished by starting with an identifier symbol which is an asterisk `*`. All words in the input will be separated by exactly one space. **Example 1:** **Input:** `s = \\"this is an *important sentence with some *crucial words\\"` **Output:** `[\\"important\\", \\"crucial\\"]` **Example 2:** **Input:** `s = \\"*priority and nonpriority items in a *list\\"` **Output:** `[\\"priority\\", \\"list\\"]` **Example 3:** **Input:** `s = \\"a normal sentence without any markers\\"` **Output:** `[]` **Constraints:** * `1 <= s.length <= 100` * `s` consists of lower-case English letters and spaces only.","solution":"from typing import List def important_words(s: str) -> List[str]: Extracts and returns important words from the sentence. Important words start with an asterisk (*). words = s.split() important = [word[1:] for word in words if word.startswith(\'*\')] return important"},{"question":"Given an array of integers, determine whether the array can be partitioned into two subsets such that the sum of elements in both subsets is the same. Implement the `canPartition` method that takes an array `nums` as its parameter and returns a boolean `true` if the array can be partitioned into two subsets with equal sum, and `false` otherwise. Example: - Input: nums = [1, 5, 11, 5] - Output: true - Explanation: The array can be partitioned as [1, 5, 5] and [11]. - Input: nums = [1, 2, 3, 5] - Output: false - Explanation: The array cannot be partitioned into two subsets with equal sum.","solution":"def canPartition(nums): Determines whether the given array can be partitioned into two subsets such that the sum of elements in both subsets is the same. :param nums: A list of integers. :return: A boolean value: True if the array can be partitioned; False otherwise. total_sum = sum(nums) # If total sum is odd, it\'s not possible to partition it into equal subsets if total_sum % 2 != 0: return False target = total_sum // 2 n = len(nums) # Initialize a boolean dp array where dp[i] means if a sum i can be formed dp = [False] * (target + 1) dp[0] = True # There\'s always a way to get zero sum(subset of no elements) for num in nums: for i in range(target, num - 1, -1): dp[i] = dp[i] or dp[i - num] return dp[target]"},{"question":"Given two positive integers `x` and `y` representing the dimensions of a grid, and a list of coordinates `obstacles`, each of which represents the position of an obstacle on the grid, determine the number of distinct paths from the top-left corner `(0, 0)` to the bottom-right corner `(x-1, y-1)`. You may only move either down or right at any point in time. Return the total number of distinct paths that navigate around the obstacles.","solution":"def unique_paths_with_obstacles(x, y, obstacles): Returns the number of distinct paths from the top-left to the bottom-right corner of an x by y grid, navigating around obstacles. :param x: int - the number of rows in the grid :param y: int - the number of columns in the grid :param obstacles: list of tuples - list containing coordinates of obstacles :return: int - number of distinct paths # Create a 2D list initialized to 0 grid = [[0] * y for _ in range(x)] # Set the start position to 1 if it\'s not an obstacle if (0, 0) not in obstacles: grid[0][0] = 1 # Fill the grid using dynamic programming for i in range(x): for j in range(y): if (i, j) in obstacles: grid[i][j] = 0 else: if i > 0: grid[i][j] += grid[i-1][j] if j > 0: grid[i][j] += grid[i][j-1] # The value at the bottom-right corner is the number of unique paths return grid[x-1][y-1]"},{"question":"You are given a 2D list `grid` representing a city grid map where each cell is either a `1` (building) or `0` (empty land). You are also given an integer `d` representing the maximum allowed Manhattan distance that a building can cover for fire safety. Your task is to return the number of buildings that can be reached by at least one fire truck within the specified distance `d`. A building is reachable if there is any cell within `d` distance that is empty land (`0`) where a fire truck can be stationed. The Manhattan distance between two cells `(i, j)` and `(x, y)` is defined as `|i - x| + |j - y|`. Return the count of buildings that are reachable.","solution":"def count_reachable_buildings(grid, d): Count buildings that can be reached by at least one fire truck within the specified distance d. rows = len(grid) cols = len(grid[0]) if rows > 0 else 0 reachable_count = 0 for i in range(rows): for j in range(cols): if grid[i][j] == 1: # Building found is_reachable = False # Check all cells within distance d for x in range(max(0, i - d), min(rows, i + d + 1)): for y in range(max(0, j - d), min(cols, j + d + 1)): if abs(i - x) + abs(j - y) <= d and grid[x][y] == 0: is_reachable = True break if is_reachable: break if is_reachable: reachable_count += 1 return reachable_count"},{"question":"You are given a string `s` consisting of lowercase English alphabet letters and an integer `k`. You can remove any number of characters from the string `s` to form a new string such that the new string has exactly `k` distinct characters. Your goal is to maximize the length of this new string. If it is impossible to form such a string, return `-1`. Return the length of the longest new string with exactly `k` distinct characters.","solution":"def longest_substring_with_k_distinct(s, k): Returns the length of the longest substring with exactly k distinct characters. If it is impossible to form such a substring, return -1. if k == 0: return 0 n = len(s) if n == 0: return -1 from collections import defaultdict char_count = defaultdict(int) left = 0 max_length = -1 for right in range(n): char_count[s[right]] += 1 while len(char_count) > k: char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 if len(char_count) == k: max_length = max(max_length, right - left + 1) return max_length"},{"question":"You are given an integer array `nums` with unique elements. Find the largest subsequence such that the difference between consecutive elements in the subsequence is consistent. In other words, for any subsequence `[a1, a2, ..., an]`, the difference `a2 - a1` should be equal to `a3 - a2`, and so on. Return the length of such a subsequence. For clarity, the differences between elements should be the same, and the subsequence should be as long as possible.","solution":"def longest_arithmetic_subsequence(nums): Returns the length of the longest arithmetic subsequence. if len(nums) <= 1: return len(nums) longest_length = 1 dp = [{} for _ in range(len(nums))] for i in range(len(nums)): for j in range(i): diff = nums[i] - nums[j] if diff in dp[j]: dp[i][diff] = dp[j][diff] + 1 else: dp[i][diff] = 2 longest_length = max(longest_length, dp[i][diff]) return longest_length"},{"question":"You are given an integer array `nums` of size `n` and an integer `k`. Your task is to reorganize the array such that the absolute difference between any two adjacent elements is at most `k`. If it\'s not possible to reorganize the array in such a way, return an empty list. Implement the `rearrangeArray` function: * `List<Integer> rearrangeArray(List<Integer> nums, int k)`: * Reorganizes the array such that the absolute difference between any two adjacent elements is at most `k`. Returns the reorganized list if possible, otherwise returns an empty list. Example: ``` Input: nums = [3, 6, 1, 8], k = 4 Output: [3, 6, 1, 8] or any valid permutation that satisfies the condition ``` Note: * The given array may contain both positive and negative integers. * You may assume that the input provided will always be valid, and the size of the array will not be exceeding reasonable limits for practical purposes.","solution":"def rearrangeArray(nums, k): Reorganizes the array such that the absolute difference between any two adjacent elements is at most k. Returns the reorganized list if possible, otherwise returns an empty list. if not nums: return [] nums.sort() n = len(nums) def valid_arrangement(arr): for i in range(n - 1): if abs(arr[i] - arr[i + 1]) > k: return False return True for i in range(n): arranged = nums[i:] + nums[:i] if valid_arrangement(arranged): return arranged return []"},{"question":"You are given two strings `str1` and `str2`, and an integer array `indices` of the same length as `str2`. The two strings initially have the same length. The integer array `indices` represents the positions in `str1` that need to be replaced with characters from `str2` to create a new target string. Specifically, for every `indices[i] = j`, replace the character at index `j` in `str1` with the character at index `i` in `str2`. Return _the resulting string after making all replacements_. It is guaranteed that all indices in `str1` to be replaced are unique and within the bounds of `str1`.","solution":"def replace_indices(str1, str2, indices): Replaces characters in str1 with characters from str2 at specified indices. :param str1: The original string to be modified. :param str2: The string containing replacement characters. :param indices: The list of indices in str1 where replacements should be done. :return: The resulting string after replacements. str1_list = list(str1) for i, index in enumerate(indices): str1_list[index] = str2[i] return \'\'.join(str1_list)"},{"question":"You are given an integer `array` and an integer `target`. Your task is to find all unique pairs of integers in the array that sum up to the given `target`. Each pair must be sorted in ascending order, and the result should be a list of these pairs sorted in ascending order lexicographically. Note that the same number cannot be used twice to form a pair.","solution":"def find_pairs(array, target): Returns all unique pairs of integers from the array that sum up to the given target. Each pair is sorted in ascending order, and the result list is sorted lexicographically. array.sort() pairs = set() lookup = {} for num in array: complement = target - num if complement in lookup: pairs.add((min(num, complement), max(num, complement))) lookup[num] = num return sorted(list(pairs))"},{"question":"Given a `string s` consisting of lowercase letters, you need to partition the string into as many parts as possible so that each letter appears in at most one part. Return the array of integers representing the size of these parts. For example, given `s = \\"ababcbacadefegdehijhklij\\"`, the partition is `[\\"ababcbaca\\", \\"defegde\\", \\"hijhklij\\"]`, which returns `[9, 7, 8]`. The order of occurrence of characters should be maintained in the partitioned parts, ensuring that the original sequence is retained.","solution":"def partitionLabels(s): Returns the list of sizes of partitions such that each letter appears in at most one part. Parameters: s (str): Input string consisting of lowercase letters. Returns: list: List of sizes of the partitioned parts. # Dictionary to store the last occurrence of each character in the string last_occurrences = {char: idx for idx, char in enumerate(s)} # Initialize variables partitions = [] start = 0 end = 0 # Iterate through the string for idx, char in enumerate(s): # Update the end index to the last occurrence of the current character end = max(end, last_occurrences[char]) # If the current index reaches the end index, a partition is found if idx == end: partitions.append(end - start + 1) start = idx + 1 # Update the start index for the next partition return partitions"},{"question":"You are given an integer array `nums` where `nums[i]` represents the number of candies in the `i`-th jar. You have two kinds of operations to perform: 1. Choose any jar with at least one candy and remove exactly one candy from it. 2. Choose any two jars and transfer one candy from one jar to the other (this operation can only be performed if both jars have at least one candy). You can perform these operations any number of times (including zero times). Return _the **minimum number of operations** needed such that all jars contain the same number of candies_.","solution":"def min_operations_to_equal_candies(nums): Returns the minimum number of operations needed such that all jars contain the same number of candies. if not nums: return 0 min_candies = min(nums) operations = sum(candies - min_candies for candies in nums) return operations"},{"question":"You are given a **binary tree** with `n` nodes, each node containing a `value`. Define a path in the binary tree as a sequence of nodes connected by edges, where each node is visited exactly once. A path\'s length is determined by the number of nodes in it. Return _the **length** of the **longest** path in the tree such that every subpath of that path has the same node value_.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def longest_univalue_path(root): Returns the length of the longest path in the tree such that every subpath of that path has the same node value. def longest_path(node): if not node: return 0, 0 # (max_length_with_node, max_length_with_parent) left_len, left_with_parent = longest_path(node.left) right_len, right_with_parent = longest_path(node.right) left = right = 0 if node.left and node.left.value == node.value: left = left_with_parent + 1 if node.right and node.right.value == node.value: right = right_with_parent + 1 max_length_with_node = max(left_len, right_len, left + right) max_length_with_parent = max(left, right) return max_length_with_node, max_length_with_parent max_length, _ = longest_path(root) return max_length"},{"question":"You are given a 2D character array `board` representing a `boggle game board` with dimensions `m x n`, and a list of strings `words` representing words to search on the board. Each word must be constructed from letters of sequentially adjacent cells, where \\"adjacent\\" cells are those horizontally, vertically, or diagonally neighboring. Each cell on the board can only be used once for each word. Write a function to return a list of all words on the board that can be constructed from the words list. The words in the output can be in any order. Your task is to return all the words found in the boggle board. The function should run in an optimal time complexity given the constraints.","solution":"def find_words(board, words): Returns a list of words found in the boggle board. Parameters: board (List[List[str]]): A 2D list representing a boggle game board. words (List[str]): A list of words to search for in the board. Returns: List[str]: A list of words found in the boggle board. def dfs(board, word, i, j, index): if index == len(word): return True if i < 0 or j < 0 or i >= len(board) or j >= len(board[0]) or board[i][j] != word[index]: return False temp = board[i][j] board[i][j] = \'#\' # mark as visited found = (dfs(board, word, i + 1, j, index + 1) or dfs(board, word, i - 1, j, index + 1) or dfs(board, word, i, j + 1, index + 1) or dfs(board, word, i, j - 1, index + 1) or dfs(board, word, i + 1, j + 1, index + 1) or dfs(board, word, i - 1, j - 1, index + 1) or dfs(board, word, i + 1, j - 1, index + 1) or dfs(board, word, i - 1, j + 1, index + 1)) board[i][j] = temp return found found_words = set() for word in words: for i in range(len(board)): for j in range(len(board[0])): if dfs(board, word, i, j, 0): found_words.add(word) break return list(found_words)"},{"question":"You are given a string `s` and an integer array `indices` of the same length. The string `s` represents a jumbled word, and the `indices` array holds the correct position of each character in the original word. Reconstruct and return the original word by placing the characters at their correct position according to the `indices` array. For example, if `s = \\"aiohn\\"` and `indices = [3, 1, 4, 2, 0]`, then the original word is \\"nihao\\".","solution":"def restore_string(s, indices): Reconstructs and returns the original word by placing the characters of s at the correct position according to the indices array. :param s: str : The jumbled word :param indices: List[int] : The correct positions of each character in s :return: str : The original word original_word = [\'\'] * len(s) for char, index in zip(s, indices): original_word[index] = char return \'\'.join(original_word)"},{"question":"You are given a list of non-negative integers representing the heights of stacks of boxes. Each move consists of choosing any stack of boxes and removing one box from it. Your goal is to make all stacks the same height using the minimum number of moves. Return the minimum number of moves required to achieve this.","solution":"def min_moves_to_equal_height(heights): Returns the minimum number of moves required to make all stacks the same height. :param heights: List of non-negative integers representing stack heights :return: Minimum number of moves to make all stacks the same height if not heights or len(heights) == 1: return 0 min_height = min(heights) moves = sum(height - min_height for height in heights) return moves"},{"question":"You are given an array of integers `nums` and an integer `k`. Your task is to determine whether there exists a **subarray** of length `k` such that the **sum** of its elements is divisible by `k`. Implement the function `bool checkSubarraySum(nums, k)`, which returns `true` if such a subarray exists and `false` otherwise.","solution":"def checkSubarraySum(nums, k): Determine whether there exists a subarray of length `k` such that the sum of its elements is divisible by `k`. Args: nums: List[int] - list of integers k: int - integer value Returns: bool - True if such a subarray exists, otherwise False if k == 0: return False for i in range(len(nums) - k + 1): if sum(nums[i:i + k]) % k == 0: return True return False"},{"question":"Given a linked list, return _the middle node of the linked list_. If there are two middle nodes, return the second middle node.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def middleNode(head): Returns the middle node of the linked list. If there are two middle nodes, returns the second middle node. slow = head fast = head while fast and fast.next: slow = slow.next fast = fast.next.next return slow"},{"question":"You are given a list of non-negative integers `nums` and an integer `target`. Each element in the list can be used multiple times to sum up to `target`. Return the total number of combinations that can be formed to achieve the target sum using the given numbers. The order of combinations does not matter for this problem.","solution":"def combination_sum(nums, target): Returns the total number of combinations that sum up to target using the given numbers. Each number can be used multiple times. def dfs(t): if t < 0: return 0 if t == 0: return 1 if t in memo: return memo[t] count = 0 for num in nums: count += dfs(t - num) memo[t] = count return count memo = {} return dfs(target)"},{"question":"You are given a list of airline ticket `pairs` represented by pairs of strings `[from, to]`, where `from` is the starting airport and `to` is the destination airport. Reconstruct the itinerary in order starting from `\\"JFK\\"`. The itinerary must **end at the final destination**. If there are multiple valid itineraries, return the itinerary that has the smallest lexicographical order when read as a single concatenated string. You may assume all tickets form at least one valid itinerary. All airports are represented by three capital letters, and the input graph may not be connected. Function Signature: `List<String> findItinerary(List<List<String>> tickets)`.","solution":"from collections import defaultdict from typing import List def findItinerary(tickets: List[List[str]]) -> List[str]: # Step 1: Create the graph flight_map = defaultdict(list) for ticket in sorted(tickets): flight_map[ticket[0]].append(ticket[1]) # Step 2: Sort the adjacencies in lexicographical order for origin in flight_map: flight_map[origin].sort(reverse=True) # Step 3: Hierholzer\'s algorithm to find an Eulerian path def dfs(node): while flight_map[node]: dfs(flight_map[node].pop()) itinerary.append(node) itinerary = [] dfs(\\"JFK\\") return itinerary[::-1] # reverse to get the correct order"},{"question":"You are given an array of `n` integers. You need to find all pairs of elements that sum up to a given target value. Return a list of all such unique pairs. Each pair should be a tuple with the smaller element appearing first. The pairs should be returned in sorted order based on the first element of the pair, and for pairs with the same first element, based on the second element.","solution":"def two_sum_pairs(arr, target): Finds all unique pairs in the array that sum up to the given target value. :param arr: List[int] - List of integers :param target: int - Target sum :return: List[Tuple[int, int]] - List of unique pairs that sum up to target pairs = set() seen = set() for num in arr: complement = target - num if complement in seen: pairs.add((min(num, complement), max(num, complement))) seen.add(num) return sorted(pairs)"},{"question":"You are given two strings `a` and `b`, both containing only lowercase letters. You need to merge these two strings into a single sorted string in non-decreasing order by alternatively picking characters from each string. If one string is exhausted before the other, append the remaining characters of the other string to the merged string. Return _the merged string in non-decreasing order_. For example, given `a = \\"ace\\"` and `b = \\"bd\\"`, the merged string would be `\\"aabbcd\\"`.","solution":"def merge_and_sort(a, b): Merges two strings a and b into a single sorted string in non-decreasing order by alternatively picking characters from each string. :param a: First string :param b: Second string :return: Merged and sorted string result = [] length_a, length_b = len(a), len(b) i, j = 0, 0 while i < length_a and j < length_b: if a[i] < b[j]: result.append(a[i]) i += 1 else: result.append(b[j]) j += 1 while i < length_a: result.append(a[i]) i += 1 while j < length_b: result.append(b[j]) j += 1 return \'\'.join(result)"},{"question":"Given an integer array `nums` of length `n`, write a function to determine if there exist **three distinct indices** `i`, `j`, `k` such that `nums[i] + nums[j] + nums[k] == 0`. Return `true` if such indices exist, otherwise, return `false`. Ensure your solution has a time complexity better than `O(n^3)`.","solution":"def three_sum(nums): Determines if there are three distinct indices i, j, k such that nums[i] + nums[j] + nums[k] == 0. :param nums: List[int] - List of integers :return: bool - True if such indices exist, False otherwise nums.sort() n = len(nums) for i in range(n): if i > 0 and nums[i] == nums[i-1]: continue left, right = i + 1, n - 1 while left < right: s = nums[i] + nums[left] + nums[right] if s == 0: return True elif s < 0: left += 1 else: right -= 1 return False"},{"question":"You are given a list of integers `ratings` representing the ratings of `n` employees. Each employee wants a certain number of candies based on their rating according to the following rules: * Each employee must receive at least one candy. * Employees with a higher rating get more candies than their neighbors. Return _the minimum number of candies you need to distribute to the employees to satisfy the above conditions_.","solution":"def min_candies(ratings): Given a list of ratings, compute the minimum number of candies needed to distribute to employees according to the problem\'s rules. n = len(ratings) if n == 0: return 0 candies = [1] * n # Ensure higher rated employees get more candies than left neighbor for i in range(1, n): if ratings[i] > ratings[i - 1]: candies[i] = candies[i - 1] + 1 # Ensure higher rated employees get more candies than right neighbor for i in range(n - 2, -1, -1): if ratings[i] > ratings[i + 1]: candies[i] = max(candies[i], candies[i + 1] + 1) return sum(candies)"},{"question":"You are given a string `expression` representing a basic mathematical expression that includes non-negative integers and the operators `+`, `-`, `*`, and `/`. The expression does not contain any parentheses and all operations are left-to-right on a single level of precedence (i.e., `*` and `/` do not take precedence over `+` and `-`). Implement a function `evaluateExpression(String expression)` that parses and evaluates the string, returning the correct result as an integer. Your function should handle invalid expressions gracefully and return `0` if the input expression is invalid.","solution":"def evaluateExpression(expression): Evaluates a basic mathematical expression with non-negative integers and +, -, *, / operators considering left to right precedence, returning the result as an integer. Parameters: expression (str): The mathematical expression Returns: int: The result of the evaluation import operator # Define operators ops = { \'+\': operator.add, \'-\': operator.sub, \'*\': operator.mul, \'/\': lambda x, y: int(operator.truediv(x, y)), # Ensure integer division } # Split the expression by whitespace to form tokens tokens = expression.split() # Check if the tokens form a valid expression if len(tokens) % 2 == 0: return 0 # Initialize the initial value result = 0 try: # The first token must be a number result = int(tokens[0]) # Iterate through tokens in pairs: (operator, number) for i in range(1, len(tokens), 2): op = tokens[i] num = int(tokens[i + 1]) result = ops[op](result, num) except (ValueError, KeyError, IndexError, ZeroDivisionError): return 0 return result"},{"question":"You are given a 2D grid of characters `grid` representing a crossword puzzle, and a list of strings `words`. Your task is to find out if all the words in the list can be placed in the grid according to standard crossword rules: the words can be placed either horizontally or vertically, and they must not overlap in contradiction with the existing letters in the grid. You are required to determine the feasibility of placing each word in the list on the grid. If it is possible to place all the words in the grid, return `true`; otherwise, return `false`.","solution":"def can_place_words(grid, words): Check if all the words in the list can be placed in the grid according to crossword rules. def can_place_word(word, row, col, direction): if direction == \'horizontal\': if col + len(word) > len(grid[0]): return False for i in range(len(word)): if grid[row][col + i] not in (word[i], \'.\'): return False return True elif direction == \'vertical\': if row + len(word) > len(grid): return False for i in range(len(word)): if grid[row + i][col] not in (word[i], \'.\'): return False return True def place_word(word, row, col, direction): if direction == \'horizontal\': for i in range(len(word)): grid[row][col + i] = word[i] elif direction == \'vertical\': for i in range(len(word)): grid[row + i][col] = word[i] for word in words: placed = False for row in range(len(grid)): for col in range(len(grid[0])): if can_place_word(word, row, col, \'horizontal\'): place_word(word, row, col, \'horizontal\') placed = True break if can_place_word(word, row, col, \'vertical\'): place_word(word, row, col, \'vertical\') placed = True break if placed: break if not placed: return False return True"},{"question":"You are given a string `s` containing only lowercase English letters. A **duplicate removal** consists of choosing two adjacent and equal letters, and removing them. For example, a duplicate removal on \\"abbaca\\" results in \\"aaca\\". You repeatedly make duplicate removals on `s` until no more duplicate letters can be removed. Return _the final string after all such duplicate removals have been made._ You must make the removal operations in **linear time O(n)** where `n` is the length of the string `s`.","solution":"def remove_duplicates(s: str) -> str: Given a string s consisting of lowercase English letters, repeatedly removes adjacent duplicate characters until no more such characters can be removed and returns the resultant string. Args: s (str): The input string containing only lowercase English letters. Returns: str: The string after all possible duplicate removals. stack = [] for char in s: if stack and stack[-1] == char: stack.pop() else: stack.append(char) return \'\'.join(stack)"},{"question":"You are given an array of `n` positive integers `nums`. A single `operation` on the array consists of selecting any element and either incrementing or decrementing it by `1`. The array is considered to be `balanced` if all its elements are equal. Your task is to determine the minimum number of `operations` required to make the array `balanced`. Return _the minimum number of operations needed_ to balance the array.","solution":"def min_operations_to_balance(nums): Returns the minimum number of operations needed to make all elements of the array equal. An operation is selecting any element and incrementing/decrementing it by 1. n = len(nums) nums.sort() median = nums[n // 2] return sum(abs(num - median) for num in nums)"},{"question":"You are given an integer array `nums` and an integer `k`. Your task is to determine whether there are two distinct indices `i` and `j` in the array such that the absolute difference between `nums[i]` and `nums[j]` is at most `k`, and the absolute difference between `i` and `j` is at most `k`. Implement a function `containsNearbyAlmostDuplicate`: * `boolean containsNearbyAlmostDuplicate(int[] nums, int k)` returns `true` if such elements exist, otherwise returns `false`.","solution":"def containsNearbyAlmostDuplicate(nums, k): Returns True if there are two distinct indices i and j in the array such that the absolute difference between nums[i] and nums[j] is at most k, and the absolute difference between i and j is at most k. Parameters: nums (list of ints): The integer array to be checked. k (int): The maximum allowed difference between i and j. Returns: bool: True if such elements exist, otherwise False. if k < 1: return False value_indices = {} for i, num in enumerate(nums): if num in value_indices: for j in value_indices[num]: if abs(i - j) <= k: return True value_indices[num].append(i) else: value_indices[num] = [i] return False"},{"question":"You are given a list of projects and a list of dependencies, where a dependency is represented by a pair of projects `(a, b)`, meaning project `b` cannot start until project `a` is finished. Given the number of projects `numProjects` and the list of dependencies, generate the build order of the projects. If there is no way to generate such an order (i.e., due to a cycle), return an empty list. **Definition of buildOrder:** - Parameters: `int numProjects`, `List<Pair<Integer, Integer>> dependencies` - Returns: `List<Integer>` **Examples:** 1. Input: `numProjects = 4`, `dependencies = [(2, 1), (3, 1), (1, 0)]` Output: `[2, 3, 1, 0]` 2. Input: `numProjects = 4`, `dependencies = [(2, 1), (3, 1), (1, 2)]` Output: `[]`","solution":"from collections import defaultdict, deque from typing import List, Tuple def buildOrder(numProjects: int, dependencies: List[Tuple[int, int]]) -> List[int]: in_degree = {i: 0 for i in range(numProjects)} graph = defaultdict(list) for dest, src in dependencies: graph[src].append(dest) in_degree[dest] += 1 zero_in_degree_queue = deque([k for k, v in in_degree.items() if v == 0]) topo_order = [] while zero_in_degree_queue: vertex = zero_in_degree_queue.popleft() topo_order.append(vertex) for neighbor in graph[vertex]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: zero_in_degree_queue.append(neighbor) if len(topo_order) == numProjects: return topo_order else: return []"},{"question":"Given an array of integers `arr`, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum. The subarray must have its elements in non-decreasing order. If there are multiple subarrays with the same largest sum, return the length of the longest one. Implement the function `int maxSumOfIncreasingSubarray(int[] arr)`.","solution":"def maxSumOfIncreasingSubarray(arr): Returns the sum of the contiguous non-decreasing subarray with the largest sum. If there are multiple subarrays with the same sum, the length of the longest one is preferred. n = len(arr) if n == 0: return 0 max_sum = current_sum = arr[0] max_length = current_length = 1 for i in range(1, n): if arr[i] >= arr[i - 1]: current_sum += arr[i] current_length += 1 else: if current_sum > max_sum or (current_sum == max_sum and current_length > max_length): max_sum = current_sum max_length = current_length current_sum = arr[i] current_length = 1 if current_sum > max_sum or (current_sum == max_sum and current_length > max_length): max_sum = current_sum max_length = current_length return max_sum"},{"question":"You are given a **0-indexed** integer array `heights` representing the height of buildings. A **sunset view** is defined for a building if the height of the building is strictly greater than all the buildings to its right. Return the list of indices of all buildings that have a sunset view in **ascending order**.","solution":"def sunset_views(heights): Returns the list of indices of all buildings that have a sunset view in ascending order. A building has a sunset view if its height is strictly greater than all the buildings to its right. :param heights: List[int] - List of integers representing the heights of buildings. :return: List[int] - List of indices of buildings that have a sunset view in ascending order. sunset_view_buildings = [] max_height_so_far = float(\'-inf\') for i in range(len(heights) - 1, -1, -1): if heights[i] > max_height_so_far: sunset_view_buildings.append(i) max_height_so_far = heights[i] return sorted(sunset_view_buildings)"},{"question":"You are given a linked list, and you need to remove the nth node from the end of the list and return its head. Implement a function `removeNthFromEnd` that takes two arguments: the head of a singly linked list and an integer n which represents the position from the end. It should modify the list in-place without using extra space for another list. If the linked list is empty or `n` is not within the valid range, handle such edge cases appropriately. ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def removeNthFromEnd(head: ListNode, n: int) -> ListNode: # Your code here ```","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def removeNthFromEnd(head: ListNode, n: int) -> ListNode: def get_length(node: ListNode) -> int: length = 0 current = node while current: length += 1 current = current.next return length length = get_length(head) if n > length or n <= 0: return head dummy = ListNode(0) dummy.next = head current = dummy for _ in range(length - n): current = current.next current.next = current.next.next return dummy.next"},{"question":"You are given an integer array `nums`. Your task is to find and return the index of the smallest peak element. A peak element is an element that is greater than its neighbors. For corner elements, we need to consider only one neighbor. If multiple peak elements exist, return the index of the first such element. Assume that the array contains at least one peak element.","solution":"def find_smallest_peak(nums): Returns the index of the smallest peak element in the array `nums`. A peak element is an element that is greater than its neighbors. Args: nums (List[int]): List of integers. Returns: int: Index of the smallest peak element. n = len(nums) for i in range(n): if (i == 0 or nums[i] > nums[i - 1]) and (i == n - 1 or nums[i] > nums[i + 1]): return i"},{"question":"Given a sequence of integers represented by an integer array `arr` and an integer `d`, you can jump from index `i` to index `j` in the array only if `i < j` and `arr[i] > arr[j]` and `j` is within the range `[i + 1, i + d]`. You cannot jump outside of the array bounds. Your task is to determine the maximum number of indices you can visit starting from any index in the array. Return _the maximum number of indices you can visit_.","solution":"def max_jumps(arr, d): n = len(arr) dp = [0] * n def dfs(i): if dp[i] != 0: return dp[i] max_reach = 1 # Starting at i itself for direction in [-1, 1]: # Check both left and right sides for step in range(1, d + 1): j = i + step * direction if j < 0 or j >= n or arr[j] >= arr[i]: break max_reach = max(max_reach, 1 + dfs(j)) dp[i] = max_reach return max_reach result = 0 for i in range(n): result = max(result, dfs(i)) return result"},{"question":"Given two integers `x` and `y`, and an integer array `nums` of length `n`, return an array `result` such that for each element `i` in `nums`, `result[i]` is the sum of all distinct elements in `nums` that are divisible by either `x` or `y`. If no such elements exist for `i`, set `result[i]` to -1.","solution":"def sum_divisible_by_x_or_y(nums, x, y): Returns an array where each element is the sum of all distinct elements in \'nums\' that are divisible by either \'x\' or \'y\'. If no such elements exist, set the element to -1. divisible_elements = {num for num in nums if num % x == 0 or num % y == 0} if not divisible_elements: return [-1] * len(nums) total_sum = sum(divisible_elements) return [total_sum] * len(nums)"},{"question":"You are given an array of integers where each integer represents a different color of a marble. You need to form the largest possible contiguous subarray such that no more than two distinct colors are present in the subarray. Return _the length of the longest such subarray_.","solution":"def max_length_subarray_two_colors(arr): from collections import defaultdict if not arr: return 0 max_length = 0 start = 0 color_count = defaultdict(int) for end in range(len(arr)): color_count[arr[end]] += 1 while len(color_count) > 2: color_count[arr[start]] -= 1 if color_count[arr[start]] == 0: del color_count[arr[start]] start += 1 max_length = max(max_length, end - start + 1) return max_length"},{"question":"Write a function that simulates the following coin change problem: Given an integer `amount` representing a target amount of money, and an array `coins` representing the available denominations of coins, return the minimum number of coins needed to make up that amount. If it is not possible to reach the target amount with the given coin denominations, return `-1`. You may assume that you have an infinite number of each denomination.","solution":"def coin_change(coins, amount): Return the fewest number of coins that you need to make up the amount. If that amount of money cannot be made up by any combination of the coins, return -1. # Create a list to store the minimum coins needed for each amount from 0 to amount dp = [float(\'inf\')] * (amount + 1) dp[0] = 0 # Base case: 0 coins needed to make the amount 0 # Build up the dp array for coin in coins: for x in range(coin, amount + 1): dp[x] = min(dp[x], dp[x - coin] + 1) # Check if we have found a solution for the amount return dp[amount] if dp[amount] != float(\'inf\') else -1"},{"question":"A company has employees working in a hierarchy. You are given an integer array `manager` where `manager[i]` is the direct manager of the `i-th` employee, and manager[headID] = -1. You are also given an integer array `informTime` where `informTime[i]` is the time it takes for the `i-th` employee to inform all of their direct subordinates. Return the total time it takes for the head to inform all employees. [Question 5]:","solution":"from collections import defaultdict, deque def numOfMinutes(n, headID, manager, informTime): Returns the total time it takes for the head to inform all employees. :param n: Number of employees :param headID: The ID of the head/CEO :param manager: Integer array where manager[i] is the direct manager of the i-th employee :param informTime: Integer array where informTime[i] is the time it takes for the i-th employee to inform all of their direct subordinates :return: Total time to inform all employees # Create an adjacency list to represent the hierarchy employee_tree = defaultdict(list) for i in range(n): if manager[i] != -1: employee_tree[manager[i]].append(i) # Function to perform DFS and return total inform time def dfs(employee_id): max_time = 0 for subordinate in employee_tree[employee_id]: max_time = max(max_time, dfs(subordinate)) return max_time + informTime[employee_id] return dfs(headID)"},{"question":"You are given an integer array `nums` sorted in non-decreasing order. You need to remove some duplicates in-place such that each unique element appears at most twice, and return the new length. Do not allocate extra space for another array; you must do this by modifying the input array in-place with O(1) extra memory. Given an integer `k`, return `true` if and only if the modified length of the array after removing duplicates is equal to `k`.","solution":"def remove_duplicates(nums): Remove duplicates in-place such that each unique element appears at most twice. :param nums: List[int] - sorted integer array :return: int - the new length of the array if not nums: return 0 # Use two pointers approach insert_pos = 1 # start from the second position count = 1 # count occurrences of each element for i in range(1, len(nums)): if nums[i] == nums[i - 1]: count += 1 else: count = 1 if count <= 2: # allow at most twice nums[insert_pos] = nums[i] # move acceptable element to the position insert_pos += 1 return insert_pos def check_array_length(nums, k): Check if after removing the duplicates, the new length of the array equals k. :param nums: List[int] - input array sorted in non-decreasing order :param k: int - expected new length of the array after removing duplicates :return: bool - True if the new length matches k, otherwise False new_length = remove_duplicates(nums) return new_length == k"},{"question":"You are given a 2D grid of integers representing a map where `0` represents water and any positive number represents land. Each land cell has an elevation, and water always flows downhill to neighboring cells (up, down, left, or right) with a lower elevation. If a cell is on the edge of the grid, water can flow off the map. Write an algorithm to determine the set of cells where water can flow to both the Pacific and Atlantic oceans. The Pacific Ocean touches the left and top edges of the grid, and the Atlantic Ocean touches the right and bottom edges. Return a list of coordinates (row, column) for the cells from where water can flow to both oceans. * For example, given the grid: ``` [ [1, 2, 2, 3, 5], [3, 2, 3, 4, 4], [2, 4, 5, 3, 1], [6, 7, 1, 4, 5], [5, 1, 1, 2, 4] ] ``` The set of coordinates would be: ``` [ [0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0] ] ```","solution":"def pacific_atlantic(matrix): if not matrix or not matrix[0]: return [] rows, cols = len(matrix), len(matrix[0]) pacific_reachable = [[False for _ in range(cols)] for _ in range(rows)] atlantic_reachable = [[False for _ in range(cols)] for _ in range(rows)] def dfs(r, c, reachable): reachable[r][c] = True for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]: new_r, new_c = r + dr, c + dc if 0 <= new_r < rows and 0 <= new_c < cols and not reachable[new_r][new_c] and matrix[r][c] <= matrix[new_r][new_c]: dfs(new_r, new_c, reachable) for i in range(rows): dfs(i, 0, pacific_reachable) dfs(i, cols - 1, atlantic_reachable) for j in range(cols): dfs(0, j, pacific_reachable) dfs(rows - 1, j, atlantic_reachable) result = [] for r in range(rows): for c in range(cols): if pacific_reachable[r][c] and atlantic_reachable[r][c]: result.append([r, c]) return result"},{"question":"Given an integer array `nums` sorted in non-decreasing order, remove some duplicates in-place such that each unique element appears at most twice. Return the new length of the array after removing the duplicates while ensuring the first part of the array contains the unique elements up to the new length in non-decreasing order. Note that the remaining elements in the array after the new length do not matter.","solution":"def remove_duplicates(nums): Removes some duplicates in-place such that each unique element appears at most twice. Returns the new length of the array after removing the duplicates while ensuring the first part of the array contains the unique elements up to the new length in non-decreasing order. :param nums: List[int] - an integer array sorted in non-decreasing order :return: int - the new length of the array if not nums: return 0 write_index = 1 count = 1 for i in range(1, len(nums)): if nums[i] == nums[i - 1]: count += 1 else: count = 1 if count <= 2: nums[write_index] = nums[i] write_index += 1 return write_index"},{"question":"You are given an m x n matrix `mat` and an integer `target`. Your task is to determine if `target` appears in `mat`. This matrix `mat` has the following properties: - Each row is sorted in non-decreasing order. - The first integer of each row is greater than the last integer of the previous row. Write a function to implement the search. For example: Given the matrix: ``` mat = [ [1, 4, 7, 11, 15], [18, 21, 23, 26, 30], [35, 36, 39, 43, 50] ] ``` And `target = 23`, the function should return `true`. If `target = 20`, the function should return `false`.","solution":"def search_matrix(mat, target): Returns True if target is found in the matrix mat, else returns False. if not mat or not mat[0]: return False rows = len(mat) cols = len(mat[0]) # Start from the top-right corner of the matrix row = 0 col = cols - 1 while row < rows and col >= 0: if mat[row][col] == target: return True elif mat[row][col] < target: row += 1 else: col -= 1 return False"},{"question":"Given a string `s`, your task is to determine whether it is possible to make `s` a palindrome by deleting **at most one** character. A palindrome is a string that reads the same backward as forward. Write a function `boolean canBePalindrome(String s)` that returns `true` if it is possible to make `s` a palindrome by deleting at most one character, otherwise returns `false`. Examples: - `canBePalindrome(\\"abca\\")` should return `true` (by deleting \'c\' or \'b\') - `canBePalindrome(\\"racecar\\")` should return `true` (no deletion needed as it is already a palindrome) - `canBePalindrome(\\"abcdef\\")` should return `false` (more than one deletion would be necessary)","solution":"def canBePalindrome(s): Determine if it is possible to make `s` a palindrome by deleting at most one character. Args: s (str): The input string. Returns: bool: True if it is possible to make `s` a palindrome by deleting at most one character, otherwise False. def is_palindrome_range(i, j): Helper function to check if s is a palindrome in the range [i, j]. return all(s[k] == s[j - k + i] for k in range(i, j)) left, right = 0, len(s) - 1 while left < right: if s[left] != s[right]: # Check by removing the left character or the right character return is_palindrome_range(left + 1, right) or is_palindrome_range(left, right - 1) left += 1 right -= 1 return True"},{"question":"There are `n` people standing in a circle waiting to be executed. The counting out begins at some point in the circle and proceeds around the circle in a fixed direction. In each step, a certain number of people are skipped and the next person is executed. You are given `n` and an integer `k`, which represents the step count (i.e., every `k-th` person is executed). The task is to return the position of the last person standing (0-indexed).","solution":"def josephus(n, k): Solves the Josephus problem. Parameters: n (int): The number of people standing in the circle. k (int): The step count (the k-th person is executed). Returns: int: The position of the last person standing (0-indexed). if n == 1: return 0 else: return (josephus(n-1, k) + k) % n"},{"question":"You are given a list of `n` integers, each representing the height of a building in a skyline. Each building’s width is exactly `1`. Your task is to calculate the **maximum rectangular area** that can be formed by choosing a contiguous group of buildings and varying their heights. Implement the function `maxRectangleArea(heights)` that takes a list `heights` containing the heights of the buildings and returns the maximum rectangular area that can be formed within the skyline. ---","solution":"def maxRectangleArea(heights): Calculate the maximum rectangular area in a histogram. Args: - heights (List[int]): List of integers representing the heights of the buildings. Returns: - int: The maximum rectangular area. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"You are given an array `arr` consisting of `n` integers, and an integer `k`. A segment of the array is defined as any contiguous subarray. You need to find the number of distinct segments such that the sum of the elements in the segment is exactly `k`. Since the answer may be large, return the result **modulo** `109 + 7`. **Note** that: * A subarray is a contiguous non-empty part of an array.","solution":"def count_segments_with_sum_k(arr, k): Returns the number of distinct segments of arr where the sum of the elements in the segment is exactly k. The result is given modulo 109 + 7. mod = 10**9 + 7 sum_count = dict() sum_count[0] = 1 # There is one way to get a sum of 0 current_sum = 0 result = 0 for num in arr: current_sum += num if (current_sum - k) in sum_count: result = (result + sum_count[current_sum - k]) % mod if current_sum in sum_count: sum_count[current_sum] += 1 else: sum_count[current_sum] = 1 return result"},{"question":"You are given an m x n binary matrix grid where 0 represents a sea cell and 1 represents a land cell. A **connected island** is a group of adjacent cells with the value 1. Two cells are considered adjacent if they are horizontally or vertically neighboring. The grid also contains exactly one island surrounded by sea, and it is guaranteed that this island has exactly one cell that can be expanded in four directions (up, down, left, right) to create a larger island. Determine the minimum number of 0s (sea) that need to be converted to 1s (land) to expand the island by exactly one cell. Return the minimum number of 0s that need to be converted in order to expand the island by one cell.","solution":"def min_water_to_land(grid): m, n = len(grid), len(grid[0]) # Helper function to perform DFS and mark cells as visited def dfs(x, y, visited): if not (0 <= x < m and 0 <= y < n) or (x, y) in visited or grid[x][y] == 0: return visited.add((x, y)) for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: dfs(x + dx, y + dy, visited) # Find the island\'s cells using DFS starting from any land cell found island = set() found_island = False for i in range(m): for j in range(n): if grid[i][j] == 1: dfs(i, j, island) found_island = True break if found_island: break # Find the minimum 0s to convert to 1s to expand the island by exactly one cell min_conversion = float(\'inf\') for x, y in island: for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 0: conversion_count = 1 # Note: The problem guarantees we will always find a valid expansion min_conversion = min(min_conversion, conversion_count) return min_conversion"},{"question":"You are given an integer array `arr` consisting of only `1s` and `0s`. You can perform the following operation any number of times: pick any two adjacent indices `i` and `j` such that `arr[i] == 0` and `arr[j] == 1`, then swap `arr[i]` and `arr[j]`. Return the minimum number of such operations required to sort the array in non-decreasing order. If the array is already sorted, return `0`.","solution":"def min_operations_to_sort_binary_array(arr): Returns the minimum number of operations required to sort the binary array in non-decreasing order. # Variable to count the number of ones encountered count_ones = 0 # Variable to count the minimum number of operations operations = 0 # Loop through the array in reverse order # since we are effectively moving all the 1s to the right for num in arr: if num == 1: count_ones += 1 else: operations += count_ones return operations"},{"question":"You are given an array of integers `arr` and an integer `k`. Your task is to find the maximum number of subarrays of length `k` that have the same sum. A subarray is any contiguous subarray of the original array. Return _the maximum number of subarrays with length `k` that have the same sum_. If no such subarrays exist, return `0`.","solution":"from collections import defaultdict def max_subarrays_with_same_sum(arr, k): Returns the maximum number of subarrays of length `k` that have the same sum. n = len(arr) if n < k: return 0 # Dictionary to count the sums of the subarrays sum_count = defaultdict(int) # Calculate the sum of the first `k` elements current_sum = sum(arr[:k]) sum_count[current_sum] += 1 # Iterate over the remaining elements to count subarrays for i in range(k, n): current_sum += arr[i] - arr[i - k] sum_count[current_sum] += 1 # Find the maximum count in the dictionary return max(sum_count.values())"},{"question":"You are provided with an undirected graph represented by `adjList`, where `adjList[i]` contains the list of nodes adjacent to the node `i`. Each node has a unique integer identifier from `0` to `n-1`. Determine if the given graph is bipartite. A graph is bipartite if you can partition its set of nodes into two distinct sets such that no two nodes within the same set are adjacent. Return `true` if the graph is bipartite, otherwise return `false`.","solution":"def isBipartite(adjList): Determine if the given graph is bipartite. :param adjList: List of lists where adjList[i] contains the list of nodes adjacent to node i :return: True if the graph is bipartite, False otherwise color = {} def dfs(node, current_color): if node in color: return color[node] == current_color color[node] = current_color return all(dfs(neigh, 1 - current_color) for neigh in adjList[node]) return all(dfs(node, 0) for node in range(len(adjList)) if node not in color)"},{"question":"**[Question 4]:** You are given an integer array `arr` of size `n`. An element `arr[i]` of the array is called a **peak** if it is greater than or equal to its neighbors. Formally, an element `arr[i]` is a peak if and only if `(i == 0 or arr[i] >= arr[i-1]) and (i == n-1 or arr[i] >= arr[i+1])`. Return _all the peaks in the array_ `arr`.","solution":"def find_peaks(arr): Finds and returns all the peak elements in the array. A peak element is one that is greater than or equal to its neighbors. peaks = [] if not arr: # if arr is empty, return empty list return peaks n = len(arr) for i in range(n): if (i == 0 or arr[i] >= arr[i-1]) and (i == n-1 or arr[i] >= arr[i+1]): peaks.append(arr[i]) return peaks"},{"question":"Given a 2D integer matrix `matrix`, where each row is sorted in ascending order and each column is sorted in ascending order, write a function that finds a given target value in the matrix. Return `true` if the target is found, and `false` otherwise.","solution":"def search_matrix(matrix, target): Searches for target in a 2D matrix where each row is sorted in ascending order and each column is sorted in ascending order. Returns True if the target is found, and False otherwise. if not matrix or not matrix[0]: return False rows = len(matrix) cols = len(matrix[0]) # Start from the top-right corner. row = 0 col = cols - 1 while row < rows and col >= 0: if matrix[row][col] == target: return True elif matrix[row][col] > target: col -= 1 else: row += 1 return False"},{"question":"You are given an integer array `heights` representing the heights of columns where the width of each column is `1`. Find two indices `i` and `j` (where `i < j`) such that the area contained by the container formed by the two columns `heights[i]` and `heights[j]` is maximal. Return the maximum area.","solution":"def max_area(heights): Returns the maximum area of water container that can be formed by the heights array. :param heights: List[int] :return: int max_area = 0 left, right = 0, len(heights) - 1 while left < right: height = min(heights[left], heights[right]) width = right - left current_area = height * width max_area = max(max_area, current_area) if heights[left] < heights[right]: left += 1 else: right -= 1 return max_area"},{"question":"Given a binary array `nums`, you need to flip **at most** one `0` to `1`. Return _the **maximum** length of the contiguous subarray consisting only of `1`s that can be obtained by performing at most one flip_. If there is no `0` in the array, return the length of the entire array.","solution":"def findMaxConsecutiveOnes(nums): Returns the maximum length of the contiguous subarray consisting only of 1s that can be obtained by flipping at most one 0 to 1. max_ones = 0 left, right = 0, 0 zero_count = 0 while right < len(nums): if nums[right] == 0: zero_count += 1 while zero_count > 1: if nums[left] == 0: zero_count -= 1 left += 1 max_ones = max(max_ones, right - left + 1) right += 1 return max_ones"},{"question":"You are given a list of non-negative integers representing the heights of walls with unit width, arranged from left to right. It is raining, and water is trapped between the walls. Your task is to write a function that calculates the total amount of water trapped. For instance, given the array `height = [0,1,0,2,1,0,1,3,2,1,2,1]`, return `6` as the total units of water trapped.","solution":"def trap(height): Given a list of non-negative integers representing the heights of walls, this function returns the total amount of water that can be trapped between the walls. Parameters: height (list of int): The list of heights of the walls. Returns: int: The total units of water trapped. if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) water_trapped = 0 for i in range(n): water_trapped += min(left_max[i], right_max[i]) - height[i] return water_trapped"},{"question":"You are given a list of strings `patterns` and a string `text`. A pattern is considered a \\"floating match\\" for a substring of `text` if the subsequence formed by removing zero or more characters (without reordering the remaining characters) from the pattern matches exactly the substring. For example, the pattern \\"abc\\" would match the substrings \\"abc\\", \\"a_c\\", \\"_ac\\", etc., where underscores represent any character. Return _an array of booleans_ such that the `i-th` element is `true` if `patterns[i]` is a floating match for any substring of `text`, and `false` otherwise. Write an algorithm to determine the floating match patterns efficiently.","solution":"def floating_match(patterns, text): Return a boolean array indicating whether each pattern is a floating match for any substring of the text. :param patterns: List of strings :param text: String :return: List of booleans def is_subsequence(pattern, text): Helper function to check if pattern is a subsequence of text. it = iter(text) return all(char in it for char in pattern) result = [] for pattern in patterns: result.append(is_subsequence(pattern, text)) return result"},{"question":"Given an integer `n`, return _the total number of distinct binary search trees (BSTs) that can be formed with `n` distinct nodes_. Each distinct BST is defined by its unique structure, not the node values. The order of nodes within the tree matters but each node can be considered as uniquely identified by its position in the tree structure.","solution":"def num_trees(n): Calculate the total number of distinct binary search trees (BSTs) that can be formed with `n` distinct nodes. Parameters: n (int): Number of distinct nodes Returns: int: Number of distinct BSTs if n == 0 or n == 1: return 1 # Create an array to store solutions to subproblems dp = [0] * (n + 1) dp[0] = dp[1] = 1 # Fill the dp array for i in range(2, n + 1): for j in range(1, i + 1): dp[i] += dp[j - 1] * dp[i - j] return dp[n]"},{"question":"An **n-ary tree** is a tree in which a node can have at most `n` children. Given an `n-ary tree`, return _the level order traversal_ of its nodes\' values. **N-level order traversal** means that nodes on the same level are visited from left to right. The input will be a root node of the n-ary tree, and each node has a unique value. You need to return a list of lists, where each list represents a level in the tree.","solution":"class Node: def __init__(self, val=None, children=None): self.val = val self.children = children if children is not None else [] def level_order(root): Returns the level order traversal of an n-ary tree. :param root: Root node of the n-ary tree. :return: List of lists, where each list contains the values of nodes at that level. if not root: return [] results, queue = [], [root] while queue: level = [] next_queue = [] for node in queue: level.append(node.val) next_queue.extend(node.children) results.append(level) queue = next_queue return results"},{"question":"You are given an array of positive integers `nums` representing the amount of money of each house, arranged in a line. Calculate the maximum amount of money you can rob tonight without alerting the police, abiding by the following rule: **you cannot rob two adjacent houses** as it will trigger the alarm system. Each house `i` has an associated value `nums[i]` which represents the money in that house. Return the maximum amount of money you can rob given these constraints.","solution":"def rob(nums): Calculate the maximum amount of money you can rob tonight without alerting the police. :param nums: List[int] - List representing the amount of money at each house. :return: int - Maximum amount of money you can rob. if not nums: return 0 if len(nums) == 1: return nums[0] # Initialize the two previous rob amounts prev1, prev2 = 0, 0 for num in nums: # Calculate the maximum money if robbing current house or not current = max(prev1, prev2 + num) # Update the previous rob amounts for the next iteration prev2 = prev1 prev1 = current return prev1"},{"question":"You are given a string `s` consisting of lowercase letters and an integer `k`. You need to modify the string such that every character that appears more than `k` times consecutively in the string is reduced to exactly `k` occurrences. Return the resulting string after the modification. For example, given `s = \\"aabbccddeeeeffff\\"` and `k = 2`, the resulting string should be `\\"aabbccddeeff\\"` because each character appears at most `2` times consecutively.","solution":"def reduce_consecutive_characters(s, k): Reduces every character that appears more than `k` times consecutively to exactly `k` occurrences. Parameters: s (str): Input string consisting of lowercase letters. k (int): Maximum allowed consecutive occurrences of any character. Returns: str: The modified string after reduction. result = [] count = 1 for i in range(1, len(s) + 1): if i < len(s) and s[i] == s[i - 1]: count += 1 else: result.append(s[i - 1] * min(count, k)) count = 1 return \'\'.join(result)"},{"question":"Write a function that takes a list of integers as input and returns a new list containing all the prime numbers from the given list. A prime number is a number greater than 1 that has no positive divisors other than 1 and itself. Ensure that your solution is efficient in terms of time complexity.","solution":"def is_prime(n): Check if a number n is a prime number. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def primes_from_list(lst): Returns a list of prime numbers from the given list. return [num for num in lst if is_prime(num)]"},{"question":"You are given an array of integers `arr` and an integer `x`. You need to find if there exist three elements in `arr` that sum up to `x`. Return `true` if such elements exist, otherwise return `false`.","solution":"def find_three_elements_sum_to_x(arr, x): Given an array of integers arr and an integer x, returns true if there are three elements in arr that sum up to x, else false. arr.sort() # First, sort the array n = len(arr) for i in range(n - 2): left, right = i + 1, n - 1 while left < right: current_sum = arr[i] + arr[left] + arr[right] if current_sum == x: return True elif current_sum < x: left += 1 else: right -= 1 return False"},{"question":"You are given a string `s` containing only lowercase letters, and a list of words `dict` containing unique words. Your task is to find all the starting indices of `dict`\'s words\' anagrams in `s`. An anagram is any permutation of a word. For example, \\"abc\\" has the following anagrams: \\"abc\\", \\"acb\\", \\"bac\\", \\"bca\\", \\"cab\\", and \\"cba\\". Implement the function `findAnagrams(s: str, dict: List[str]) -> List[int]` that returns a list of starting indices of the substrings in `s` which are anagrams of any word in `dict`. # Example ``` Input: s = \\"cbaebabacd\\" dict = [\\"abc\\", \\"bac\\"] Output: [0, 6] EXPLANATION: At index 0, the substring is \\"cba\\", which is an anagram of \\"abc\\". At index 6, the substring is \\"bac\\", which is an anagram of \\"bac\\". ```","solution":"from typing import List from collections import Counter def findAnagrams(s: str, dict: List[str]) -> List[int]: res = [] dict_counter = [Counter(word) for word in dict] word_length = len(dict[0]) for i in range(len(s) - word_length + 1): substr = s[i:i+word_length] substr_counter = Counter(substr) if any(substr_counter == d_counter for d_counter in dict_counter): res.append(i) return res"},{"question":"You are given an array of integers `arr` and an integer `k`. Implement a function that returns the number of contiguous subarrays where the product of all the elements in the subarray is less than `k`. A contiguous subarray is a subarray that is derived from the original array by deleting some elements from the start and end but not from the middle of the array. For example, given `arr = [10, 5, 2, 6]` and `k = 100`, the contiguous subarrays that have a product less than `k` are `[10, 5]`, `[5]`, `[5, 2]`, `[2]`, `[2, 6]`, and `[6]`. So, the function should return `6`.","solution":"def num_subarrays_with_product_less_than_k(arr, k): if k <= 1: return 0 product = 1 count = 0 left = 0 for right in range(len(arr)): product *= arr[right] while product >= k and left <= right: product /= arr[left] left += 1 count += right - left + 1 return count"},{"question":"Given a list of integers `nums`, where each integer represents the number of citations a researcher has received for their papers, return the researcher\'s h-index. The h-index is defined as the maximum value of `h` such that the given researcher has published `h` papers that have each been cited at least `h` times. Use an efficient algorithm to find the h-index with a time complexity better than O(n^2).","solution":"def h_index(citations): Returns the h-index for a given list of citations. The h-index is defined as the maximum value of h such that there are h papers with at least h citations each. :param citations: List[int] - a list of integers representing the number of citations of each paper :return: int - the h-index citations.sort(reverse=True) h = 0 for i, c in enumerate(citations): if c >= i + 1: h = i + 1 else: break return h"},{"question":"You are given a string `s` of length `n` consisting only of lowercase English letters. You need to determine the length of the shortest substring of `s` that contains all the distinct characters present in the entire string `s`. If `s` contains no characters, return `0`. For example, if `s = \\"abac\\"`, the shortest substring containing all distinct characters (\\"a\\", \\"b\\", and \\"c\\") is `\\"bac\\"` with length `3`.","solution":"def shortest_substring_with_all_distinct_chars(s): from collections import defaultdict if not s: return 0 n = len(s) distinct_chars = set(s) required_char_count = len(distinct_chars) left = 0 right = 0 min_length = float(\'inf\') current_char_count = defaultdict(int) formed = 0 while right < n: char = s[right] current_char_count[char] += 1 if current_char_count[char] == 1: formed += 1 while left <= right and formed == required_char_count: if right - left + 1 < min_length: min_length = right - left + 1 char = s[left] current_char_count[char] -= 1 if current_char_count[char] == 0: formed -= 1 left += 1 right += 1 return min_length"},{"question":"Given a string `s`, return _the length of the longest substring where all its characters are unique_. If the string is empty, return `0`. Examples: - Input: `s = \\"abcabcbb\\"` Output: `3` Explanation: The answer is `\\"abc\\"`, with the length of `3`. - Input: `s = \\"bbbbb\\"` Output: `1` Explanation: The answer is `\\"b\\"`, with the length of `1`. - Input: `s = \\"pwwkew\\"` Output: `3` Explanation: The answer is `\\"wke\\"`, with the length of `3`. Note that the answer must be a substring, `\\"pwke\\"` is a subsequence and not a substring.","solution":"def length_of_longest_substring(s): Returns the length of the longest substring with all unique characters. char_index = {} max_length = 0 start = 0 for end in range(len(s)): if s[end] in char_index: start = max(start, char_index[s[end]] + 1) char_index[s[end]] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"You are given a 2D grid of size `m x n` representing a map of a city where each cell of the grid can be one of the following three values: - `0` representing an empty land that you can pass through. - `1` representing a building that cannot be passed through. - `2` representing a road that you can drive through. Your task is to find the shortest path from the top-left corner (grid[0][0]) to the bottom-right corner (grid[m-1][n-1]) that only goes through roads (`2`). If it is not possible to reach the bottom-right corner from the top-left corner by only driving through roads, return -1. You can only move up, down, left, or right at any step.","solution":"from collections import deque def shortest_path(grid): Finds the shortest path from the top-left to the bottom-right corner of the grid by only traveling through roads (cells with value 2). Returns the length of the path or -1 if it\'s not possible to reach the destination. if not grid or grid[0][0] != 2 or grid[-1][-1] != 2: return -1 m, n = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 0)]) # (row, col, distance) visited = set((0, 0)) while queue: x, y, dist = queue.popleft() if (x, y) == (m-1, n-1): return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 2 and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1"},{"question":"You are given a list of integers, `arr`, where each integer represents a different kind of candy. Each kind of candy is represented by a different positive integer. Alice can eat some candies, but she must follow these rules: 1. She can pick exactly half of the candies in `arr`. 2. She should have as many different kinds of candies as possible. Return _the **maximum** number of different kinds of candies Alice can eat by following the above rules._","solution":"def max_number_of_different_candies(arr): Returns the maximum number of different kinds of candies Alice can eat by following the rules. unique_candies = set(arr) max_possible_candies = len(arr) // 2 return min(len(unique_candies), max_possible_candies)"},{"question":"Given a string `s` and an integer `k`, find the lexicographically smallest string that can be obtained by performing the following operation at most `k` times: choose a character from `s` and move it to the front of the string. Note that the operation can be performed on any position, not necessarily adjacent characters. If `k` is zero, return the original string `s`.","solution":"def smallest_string(s, k): Returns the lexicographically smallest string by moving characters to the front at most k times. :param s: Input string :param k: Number of moves :return: Lexicographically smallest string if k == 0: return s min_str = s n = len(s) for i in range(n): # The string formed by moving s[i] to the front new_str = s[i] + s[:i] + s[i+1:] for j in range(1, k): # Move smallest character to the front of the new_string to further minimize it min_char_idx = min(range(1, len(new_str)), key=lambda x: new_str[x]) new_str = new_str[min_char_idx] + new_str[:min_char_idx] + new_str[min_char_idx+1:] if new_str < min_str: min_str = new_str return min_str"},{"question":"You are given a grid where each cell contains an integer representing the number of coins in that cell. You start at the top-left corner of the grid and can only move right or down to reach the bottom-right corner. _Find the maximum number of coins you can collect_ on your way to the bottom-right corner. You are **not** allowed to revisit any cell and must stay within the grid boundaries.","solution":"def max_coins(grid): Returns the maximum number of coins that can be collected from top-left to bottom-right of the grid moving only right or down. if not grid or not grid[0]: return 0 rows = len(grid) cols = len(grid[0]) # Create a 2D array to store maximum coins collected at each cell dp = [[0 for _ in range(cols)] for _ in range(rows)] # Initialize the starting point dp[0][0] = grid[0][0] # Fill the first row (can only come from the left) for j in range(1, cols): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column (can only come from above) for i in range(1, rows): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp array for i in range(1, rows): for j in range(1, cols): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] # The bottom-right corner contains the maximum number of coins collected return dp[rows-1][cols-1]"},{"question":"You are given a string `s` and a dictionary of words `wordDict`. The string `s` can be segmented into a space-separated sequence of one or more dictionary words if and only if a valid segmentation exists. Return _true_ if `s` can be segmented, and _false_ otherwise. The dictionary of words `wordDict` contains no duplicates.","solution":"def word_break(s, wordDict): Determine if the string s can be segmented into a space-separated sequence of one or more dictionary words. Parameters: s (str): The string to be segmented. wordDict (set): The set of words to be used for segmentation. Returns: bool: True if the string can be segmented, False otherwise. dp = [False] * (len(s) + 1) dp[0] = True # an empty string can always be segmented for i in range(1, len(s) + 1): for j in range(i): if dp[j] and s[j:i] in wordDict: dp[i] = True break return dp[len(s)]"},{"question":"You are given a list of bank transactions represented as a list of tuples. Each tuple contains three elements: (timestamp, accountID, amount), where: - `timestamp` is an integer representing the time at which the transaction happened, - `accountID` is a string representing the unique ID of the customer\'s account, - `amount` is an integer representing the amount of money deposited or withdrawn (negative for withdrawal, positive for deposit). Your task is to implement the `Bank` class that supports the following methods: - `Bank()`: Initializes the bank with no accounts. - `void addTransaction(int timestamp, string accountID, int amount)`: Adds a new transaction to the bank. - `double getBalance(string accountID)`: Returns the current balance of the account with the given `accountID`. If the account does not exist, return 0. Each transaction must be processed in the order of their timestamps. This means that calling `addTransaction` multiple times should preserve the temporal order of transactions for each account. The balance of any account is the sum of all amounts in the transactions associated with that account. # Example ```python bank = Bank() bank.addTransaction(1, \\"acc1\\", 100) bank.addTransaction(2, \\"acc1\\", -50) bank.addTransaction(3, \\"acc2\\", 200) print(bank.getBalance(\\"acc1\\")) # Output: 50 print(bank.getBalance(\\"acc2\\")) # Output: 200 print(bank.getBalance(\\"acc3\\")) # Output: 0 ```","solution":"class Bank: def __init__(self): self.transactions = {} def addTransaction(self, timestamp, accountID, amount): if accountID not in self.transactions: self.transactions[accountID] = [] self.transactions[accountID].append((timestamp, amount)) def getBalance(self, accountID): if accountID not in self.transactions: return 0 return sum(amount for _, amount in self.transactions[accountID])"},{"question":"You are given a string `s` and an array of strings `words`. All the strings in `words` are of the same length. A **concatenated substring** in the string `s` is formed by concatenating all the strings in `words` exactly once without any intervening characters and in any order. Your task is to return the **starting index** of each concatenated substring in `s`. The output should be an array of starting indices in ascending order. If no such starting index exists, return an empty array. Example: ``` Input: s = \\"barfoothefoobarman\\", words = [\\"foo\\",\\"bar\\"] Output: [0, 9] Explanation: The concatenated substrings are \\"barfoo\\" and \\"foobar\\". ```","solution":"def findSubstring(s, words): from collections import Counter if not s or not words or not words[0]: return [] word_length = len(words[0]) num_words = len(words) total_length = word_length * num_words word_count = Counter(words) result = [] for i in range(len(s) - total_length + 1): seen = Counter() for j in range(num_words): word_start = i + j * word_length word = s[word_start:word_start + word_length] if word not in word_count: break seen[word] += 1 if seen[word] > word_count[word]: break if seen == word_count: result.append(i) return result"},{"question":"A company has a list of projects, each with a start day and an end day. The company needs to maximize the number of projects they can complete, but they can only work on one project at a time. You are given an array `projects` where `projects[i]` is a tuple `(start_i, end_i)` representing the start and end day of the ith project. Write a function that returns the maximum number of projects the company can complete. The function should use a greedy algorithm to ensure the company completes the maximum number of projects possible.","solution":"def max_projects(projects): Returns the maximum number of non-overlapping projects the company can complete. # Sort projects based on their end day sorted_projects = sorted(projects, key=lambda x: x[1]) # Track the last end day we can work on last_end_day = float(\'-inf\') num_projects = 0 for project in sorted_projects: if project[0] > last_end_day: # If the project\'s start day is after the last end day we finished num_projects += 1 last_end_day = project[1] return num_projects"},{"question":"You are given an array of integers `height` representing the height of trees in a forest. Your task is to calculate the maximum volume of water that can be trapped after it rains. The width of each tree is 1 unit. You need to find the two trees such that the container forms with the most water. Return the maximum amount of water that can be trapped between the two trees.","solution":"def max_area(height): Calculate the maximum volume of water that can be trapped between two trees. Parameters: height (List[int]): A list of integers representing the height of trees. Returns: int: Maximum volume of water that can be trapped. left, right = 0, len(height) - 1 max_area = 0 while left < right: # The volume is determined by the shorter of the two heights current_height = min(height[left], height[right]) # The width is the difference between the indices width = right - left # Calculate the current area and update maximum area if necessary current_area = current_height * width max_area = max(max_area, current_area) # Move the pointers if height[left] < height[right]: left += 1 else: right -= 1 return max_area"},{"question":"Given a string `s`, you need to split `s` into at most two palindromic substrings. Return `true` if it is possible to split `s` such that both substrings are palindromes and `false` otherwise. A string is a palindrome if it reads the same forward and backward.","solution":"def is_palindrome(s): Helper function to check if a given string is a palindrome. return s == s[::-1] def can_split_into_two_palindromes(s): Checks if the string \'s\' can be split into at most two palindromic substrings. n = len(s) for i in range(1, n): # We iterate from 1 to n-1 to get all possible splits if is_palindrome(s[:i]) and is_palindrome(s[i:]): return True return is_palindrome(s) # Check if the entire string itself is a palindrome # Example usage: # print(can_split_into_two_palindromes(\\"ababa\\")) # True # print(can_split_into_two_palindromes(\\"abcd\\")) # False"},{"question":"You are given a string `s` consisting of digits and lowercase English letters. You need to evaluate whether the string is a valid password based on the following rules: 1. It must be at least 8 characters long. 2. It must contain at least one lowercase letter. 3. It must contain at least one digit. Write a function `isValidPassword(s: str) -> bool` that returns `True` if `s` is a valid password according to the above rules, and `False` otherwise.","solution":"def isValidPassword(s: str) -> bool: Evaluates if the password is valid based on the following rules: 1. It must be at least 8 characters long. 2. It must contain at least one lowercase letter. 3. It must contain at least one digit. :param s: the password string :return: True if valid, False otherwise if len(s) < 8: return False has_lowercase = any(char.islower() for char in s) has_digit = any(char.isdigit() for char in s) return has_lowercase and has_digit"},{"question":"You are given a list of integers representing the prices of `n` items and an integer `k` representing a budget limit. You need to determine the maximum number of items that can be purchased without exceeding the budget `k`. You may assume that each item can only be purchased once and the list of prices is positive and unsorted. Return the maximum number of items that can be bought within the budget.","solution":"def max_items_within_budget(prices, budget): Returns the maximum number of items that can be purchased without exceeding the budget. :param prices: List of integers representing the prices of items. :param budget: Integer representing the budget limit. :return: Integer representing the maximum number of items that can be purchased. prices.sort() total_cost = 0 items_count = 0 for price in prices: if total_cost + price <= budget: total_cost += price items_count += 1 else: break return items_count"},{"question":"You are developing a text editor that includes an auto-completion feature. Your task is to implement the `AutoCompleteSystem` class which helps provide autocomplete suggestions based on previous sentences a user has typed. Create a class `AutoCompleteSystem` with the following functionalities: - `AutoCompleteSystem(String[] sentences, int[] times)`: Initializes the object with a list of sentences and the corresponding times they have been typed (represented by `sentences` and `times` respectively). The `times` array and `sentences` array are of the same length, and `times[i]` stands for the number of times the `sentences[i]` has been typed. - `List<String> input(char c)`: This method is called each time a user types a character. It processes the current input character `c`: * If the character is `#`, finalize the current sentence (i.e., add it to the history of sentences typed and reset the current input to an empty string). * If the character is not `#`, add it to the current input string and return the top 3 historical sentences that start with the current input string (sorted by the number of times they have been typed). If less than 3 matches are found, return all of them. The priority for sorting should be: 1. The number of times the sentence has been typed (higher frequency first). 2. If two sentences have been typed the same number of times, the smaller lexicographical order comes first. Assumptions: - The length of each `sentences[i]` and `times[i]` will not exceed 1000. - Each input character will be either lowercase English letters, spaces, or the special character `#`. - The sum of the characters across all input sequences will not exceed 10000.","solution":"import heapq from collections import defaultdict class AutoCompleteSystem: def __init__(self, sentences, times): self.history = defaultdict(int) for sentence, time in zip(sentences, times): self.history[sentence] += time self.current_input = \\"\\" def input(self, c): if c == \'#\': self.history[self.current_input] += 1 self.current_input = \\"\\" return [] else: self.current_input += c candidates = [(self.history[s], s) for s in self.history if s.startswith(self.current_input)] candidates.sort(key=lambda x: (-x[0], x[1])) return [s for _, s in candidates[:3]]"},{"question":"Given a string `s` which consists of lowercase letters and the character `*` which can represent any one lowercase letter, return _the string formed after replacing each `*` with any lowercase letter such that the resulting string does not contain any consecutive repeated letters_. If there are multiple solutions, return any of them.","solution":"def replace_asterisks(s): Replaces each \'*\' in the string with a lowercase letter such that the resulting string does not contain any consecutive repeated letters. n = len(s) s = list(s) for i in range(n): if s[i] == \'*\': for c in \'abcdefghijklmnopqrstuvwxyz\': if (i > 0 and s[i-1] == c) or (i < n-1 and s[i+1] == c): continue s[i] = c break return \'\'.join(s)"},{"question":"Write a function to solve a Sudoku puzzle by filling the empty cells. A sudoku solution must satisfy **all of the following rules**: 1. Each of the digits `1-9` must occur exactly once in each row. 2. Each of the digits `1-9` must occur exactly once in each column. 3. Each of the digits `1-9` must occur exactly once in each of the 9 `3x3` sub-boxes of the grid. The \'.\' character indicates empty cells. Example: ``` Input: [ [\\"5\\",\\"3\\",\\".\\",\\".\\",\\"7\\",\\".\\",\\".\\",\\".\\",\\".\\"], [\\"6\\",\\".\\",\\".\\",\\"1\\",\\"9\\",\\"5\\",\\".\\",\\".\\",\\".\\"], [\\".\\",\\"9\\",\\"8\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\"], [\\"8\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\"3\\"], [\\"4\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\"3\\",\\".\\",\\".\\",\\"1\\"], [\\"7\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\".\\",\\".\\",\\".\\",\\"6\\"], [\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\"8\\",\\".\\"], [\\".\\",\\".\\",\\".\\",\\"4\\",\\"1\\",\\"9\\",\\".\\",\\".\\",\\"5\\"], [\\".\\",\\".\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\".\\",\\"7\\",\\"9\\"] ] ``` Output: ``` [ [\\"5\\",\\"3\\",\\"4\\",\\"6\\",\\"7\\",\\"8\\",\\"9\\",\\"1\\",\\"2\\"], [\\"6\\",\\"7\\",\\"2\\",\\"1\\",\\"9\\",\\"5\\",\\"3\\",\\"4\\",\\"8\\"], [ \\"1\\",\\"9\\",\\"8\\",\\"3\\",\\"4\\",\\"2\\",\\"5\\",\\"6\\",\\"7\\"], [\\"8\\",\\"5\\",\\"9\\",\\"7\\",\\"6\\",\\"1\\",\\"4\\",\\"2\\",\\"3\\"], [\\"4\\",\\"2\\",\\"6\\",\\"8\\",\\"5\\",\\"3\\",\\"7\\",\\"9\\",\\"1\\"], [\\"7\\",\\"1\\",\\"3\\",\\"9\\",\\"2\\",\\"4\\",\\"8\\",\\"5\\",\\"6\\"], [\\"9\\",\\"6\\",\\"1\\",\\"5\\",\\"3\\",\\"7\\",\\"2\\",\\"8\\",\\"4\\"], [\\"2\\",\\"8\\",\\"7\\",\\"4\\",\\"1\\",\\"9\\",\\"6\\",\\"3\\",\\"5\\"], [\\"3\\",\\"4\\",\\"5\\",\\"2\\",\\"8\\",\\"6\\",\\"1\\",\\"7\\",\\"9\\"] ] ```","solution":"def solve_sudoku(board): Solves the sudoku puzzle by filling the empty cells. def can_place(board, r, c, num): for i in range(9): if board[r][i] == str(num) or board[i][c] == str(num) or board[3 * (r // 3) + i // 3][3 * (c // 3) + i % 3] == str(num): return False return True def solve(board): for r in range(9): for c in range(9): if board[r][c] == \'.\': for num in range(1, 10): if can_place(board, r, c, num): board[r][c] = str(num) if solve(board): return True board[r][c] = \'.\' return False return True solve(board) return board"},{"question":"Given an array of unique positive integers `elements`, return an array of the same length where each element at index `i` represents the product of all the elements in the input array except the one at `i`. You should solve this without using the division operation and in O(n) time complexity.","solution":"def product_except_self(elements): Given a list of unique positive integers, returns an array where each element at index i represents the product of all the elements in the input array except the one at i. :param elements: List[int] - A list of unique positive integers :return: List[int] - A list of products n = len(elements) if n == 0: return [] left_products = [1] * n right_products = [1] * n result = [1] * n # Calculate left products for i in range(1, n): left_products[i] = left_products[i-1] * elements[i-1] # Calculate right products for i in range(n-2, -1, -1): right_products[i] = right_products[i+1] * elements[i+1] # Calculate result products for i in range(n): result[i] = left_products[i] * right_products[i] return result"},{"question":"Write a function that takes a list of integers and returns a list of lists where each sublist represents a sequence of consecutive integers from the original list. For example, given the list `[1, 2, 3, 6, 7, 8, 10, 11]`, the output should be `[[1, 2, 3], [6, 7, 8], [10, 11]]`. If the list is empty, return an empty list.","solution":"def find_consecutive_sequences(nums): if not nums: return [] sequences = [] current_sequence = [nums[0]] for i in range(1, len(nums)): if nums[i] == nums[i - 1] + 1: current_sequence.append(nums[i]) else: sequences.append(current_sequence) current_sequence = [nums[i]] sequences.append(current_sequence) # Add the last sequence return sequences"},{"question":"You are given a string `word`. You need to find the longest substring of `word` such that all characters in the substring are unique. Return the length of this longest substring. In the case where `word` is empty, return `0`.","solution":"def length_of_longest_substring(word): Returns the length of the longest substring with all unique characters. Parameters: word (str): Input string Returns: int: Length of the longest substring with all unique characters if not word: return 0 char_index = {} max_length = 0 start = 0 for i, char in enumerate(word): if char in char_index and char_index[char] >= start: start = char_index[char] + 1 char_index[char] = i max_length = max(max_length, i - start + 1) return max_length"},{"question":"You are given an integer matrix `grid` where each cell has a value equal to `0`, `1`, or `2`, representing: - `0` - An empty cell. - `1` - A house. - `2` - An obstacle (cannot be passed through). You can only move up, down, left, or right. Find the shortest distance from an empty cell to reach all houses. The shortest distance is defined as the sum of the shortest paths from the empty cell to each house. Return _the **minimum** distance_. If it is not possible to reach all houses from any empty cell, return `-1`.","solution":"from collections import deque from itertools import product def shortest_distance_from_empty_to_all_houses(grid): def bfs(start_row, start_col): visited = [[False] * len(grid[0]) for _ in range(len(grid))] distance = [[0] * len(grid[0]) for _ in range(len(grid))] queue = deque([(start_row, start_col, 0)]) visit_count = 0 while queue: row, col, dist = queue.popleft() if visited[row][col]: continue visited[row][col] = True distance[row][col] = dist for d_row, d_col in [(0, 1), (1, 0), (0, -1), (-1, 0)]: n_row, n_col = row + d_row, col + d_col if 0 <= n_row < len(grid) and 0 <= n_col < len(grid[0]) and not visited[n_row][n_col] and grid[n_row][n_col] != 2: queue.append((n_row, n_col, dist + 1)) return [[distance[r][c] for c in range(len(grid[0]))] for r in range(len(grid))] house_count = sum(grid[r][c] == 1 for r, c in product(range(len(grid)), range(len(grid[0])))) if house_count == 0: return -1 # No houses to consider dist_sum = [[0] * len(grid[0]) for _ in range(len(grid))] house_reach = [[0] * len(grid[0]) for _ in range(len(grid))] for r, c in product(range(len(grid)), range(len(grid[0]))): if grid[r][c] == 1: # BFS from each house house_distances = bfs(r, c) for i, j in product(range(len(grid)), range(len(grid[0]))): if grid[i][j] == 0 and house_distances[i][j] != 0: dist_sum[i][j] += house_distances[i][j] house_reach[i][j] += 1 min_dist = float(\'inf\') for r, c in product(range(len(grid)), range(len(grid[0]))): if grid[r][c] == 0 and house_reach[r][c] == house_count: min_dist = min(min_dist, dist_sum[r][c]) return min_dist if min_dist != float(\'inf\') else -1"},{"question":"You\'re given the task of implementing a to-do list application. Each task in the to-do list is represented by a string, and the tasks are sorted according to their priority, from high to low. You need to implement a function that can perform the following operations: 1. **Add a Task**: Add a new task with a priority to the to-do list. If a task with the same description already exists, update its priority to the new one. 2. **Remove a Task**: Remove a task from the to-do list by its description. 3. **Get Next Task**: This returns the highest priority task that has not been marked as completed yet. If no such task exists, return an empty string. 4. **Complete a Task**: Mark a task as completed by its description. The to-do list should maintain the order of tasks based on their priority, and allow efficient operations as described. Implement these functionalities and return the tasks in the order of their priority for any queries to the list.","solution":"class ToDoList: def __init__(self): self.tasks = {} def add_task(self, description, priority): Add a new task with a priority to the to-do list. self.tasks[description] = { \\"priority\\": priority, \\"is_completed\\": False } self.tasks = dict(sorted(self.tasks.items(), key=lambda item: item[1][\'priority\'], reverse=True)) def remove_task(self, description): Remove a task from the to-do list by its description. if description in self.tasks: del self.tasks[description] def get_next_task(self): Returns the highest priority task that has not been marked as completed yet. for description, details in self.tasks.items(): if not details[\'is_completed\']: return description return \\"\\" def complete_task(self, description): Mark a task as completed by its description. if description in self.tasks: self.tasks[description][\'is_completed\'] = True"},{"question":"Write a function to generate all possible valid IP addresses from a given string `s` containing only digits. A valid IP address consists of exactly four integers (each integer can be between 0 and 255, and cannot have leading zeros) separated by periods (`.`). You need to insert periods in the string in such a way that the resulting string is a valid IP address. Return all possible valid IP address combinations. You may return the answer in **any order**. The length of `s` will be between 4 and 12, inclusive.","solution":"def restore_ip_addresses(s): def is_valid(segment): return int(segment) <= 255 if segment[0] != \'0\' else len(segment) == 1 def backtrack(start=0, dots=0, path=[]): if dots == 4: if start == len(s): result.append(\\".\\".join(path)) return for i in range(1, 4): if start + i <= len(s): segment = s[start:start + i] if is_valid(segment): backtrack(start + i, dots + 1, path + [segment]) result = [] backtrack() return result"},{"question":"A maze is represented by a 2D grid where `0` represents open cells and `1` represents walls. You are given the start cell and the destination cell. You can move up, down, left, or right in the grid, but you cannot pass through walls. Determine if there exists a path from the start cell to the destination cell. If a path exists, return `true`, otherwise return `false`.","solution":"def does_path_exist(grid, start, destination): rows, cols = len(grid), len(grid[0]) directions = [(0, 1), (0, -1), (1, 0), (-1, 0)] def is_valid(x, y): return 0 <= x < rows and 0 <= y < cols and grid[x][y] == 0 def dfs(x, y): if not is_valid(x, y): return False if (x, y) == destination: return True grid[x][y] = -1 # mark visited for dx, dy in directions: if dfs(x + dx, y + dy): return True return False return dfs(start[0], start[1])"},{"question":"A **binary string** is a string consisting of only `0`s and `1`s. Given a binary string `s` of length `n`, you are allowed to perform at most one operation where you can choose any single character and flip it (i.e., change a `0` to `1` or a `1` to `0`). Return the length of the longest contiguous substring of `1`s that can be obtained after performing the operation at most once.","solution":"def longest_ones_after_flip(s): Returns the length of the longest contiguous substring of `1`s that can be obtained after flipping at most one character in the binary string `s`. max_ones = 0 count_left_ones = [0] * (len(s) + 1) count_right_ones = [0] * (len(s) + 1) for i in range(len(s)): if s[i] == \'1\': count_left_ones[i + 1] = count_left_ones[i] + 1 for i in range(len(s) - 1, -1, -1): if s[i] == \'1\': count_right_ones[i] = count_right_ones[i + 1] + 1 for i in range(len(s)): if s[i] == \'0\': max_ones = max(max_ones, count_left_ones[i] + 1 + count_right_ones[i+1]) else: max_ones = max(max_ones, count_left_ones[i] + count_right_ones[i+1] - 1) return min(max_ones, len(s)) if \'0\' in s else len(s)"},{"question":"You are given two strings, `s1` and `s2`, both of which are **0-indexed** and consist of lowercase English letters. Your task is to merge these two strings into a new string `s` by following these conditions: 1. You start with an empty string `s`. 2. You choose one of the two strings (`s1` or `s2`) and append the next character from this string to `s`. 3. Once you switch from appending characters from `s1` to `s2` (or vice versa), you cannot switch back again (i.e., you can switch from appending from `s1` to `s2` only once, and from `s2` to `s1` only once). Return the lexicographically smallest string `s` possible by merging `s1` and `s2` following the above rules.","solution":"def merge_strings(s1, s2): n1, n2 = len(s1), len(s2) i, j = 0, 0 merged_string = [] while i < n1 and j < n2: if s1[i:] <= s2[j:]: merged_string.append(s1[i]) i += 1 else: merged_string.append(s2[j]) j += 1 if i < n1: merged_string.extend(s1[i:]) if j < n2: merged_string.extend(s2[j:]) return \'\'.join(merged_string)"},{"question":"You are given an integer array `arr` representing the prices of various items in a store over consecutive days. You are tasked with finding the maximum profit you can achieve by buying one item and then selling it at a later day. The purchase must be made before the sale (i.e., you cannot sell before you buy). If no profit can be made, return `0`. For example, given the array `arr = [7,1,5,3,6,4]`, you can buy the item on day 2 (price = 1) and sell it on day 5 (price = 6) for a profit of `6-1=5`. However, if the array was `arr = [7,6,4,3,1]`, no profit can be made, so the result is `0`. Return the _maximum profit_ you can achieve from this transaction or `0` if no profit can be made.","solution":"def max_profit(arr): Finds the maximum profit that can be achieved by buying and then later selling an item. If no profit can be made, returns 0. Parameters: arr (list): List of integers representing prices over consecutive days. Returns: int: The maximum profit or 0 if no profit can be made. if not arr or len(arr) < 2: return 0 min_price = arr[0] max_profit = 0 for price in arr[1:]: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"Given a dictionary of words `wordDict` and two arbitrary words `startWord` and `endWord`, determine the minimum number of transformations needed to convert `startWord` to `endWord` where each transformation changes exactly one letter and the resulting word must be in `wordDict`. If no such transformation sequence exists, return `-1`. Each of the intermediate words in the transformation sequence must also be in `wordDict`.","solution":"from collections import deque def ladderLength(startWord, endWord, wordDict): Returns the minimum number of transformations needed to convert startWord to endWord using words in wordDict. Each transformation changes exactly one letter. if endWord not in wordDict: return -1 wordDict.add(endWord) queue = deque([(startWord, 1)]) visited = set() visited.add(startWord) while queue: current_word, steps = queue.popleft() if current_word == endWord: return steps for i in range(len(current_word)): for c in \'abcdefghijklmnopqrstuvwxyz\': next_word = current_word[:i] + c + current_word[i+1:] if next_word in wordDict and next_word not in visited: visited.add(next_word) queue.append((next_word, steps + 1)) return -1"},{"question":"You are given a list of `points` in the 2D plane. Each point is represented as a tuple `(x, y)`, where `x` and `y` are integers. Write a function to find the smallest rectangle that can be formed by any four of these points such that the sides of the rectangle are parallel to the x and y axes. If no such rectangle exists, return `0`. The rectangle\'s area is defined as the product of its width and height. If there are multiple smallest rectangles, return the area of any one of them.","solution":"def min_area_rect(points): Returns the area of the smallest rectangle that can be formed by any four of these points such that the sides of the rectangle are parallel to the x and y axes. If no such rectangle exists, returns 0. if len(points) < 4: return 0 point_set = set(points) min_area = float(\'inf\') found = False for i in range(len(points)): for j in range(i + 1, len(points)): (x1, y1) = points[i] (x2, y2) = points[j] if x1 != x2 and y1 != y2: # need to check for diagonal points if (x1, y2) in point_set and (x2, y1) in point_set: area = abs((x2 - x1) * (y2 - y1)) min_area = min(min_area, area) found = True return min_area if found else 0"},{"question":"Write a function `findAllConcatenatedWords` that takes a list of strings `words` and returns all the words that can be formed by concatenating two or more words from the list. A concatenated word is defined as a string that is comprised entirely of at least two shorter words in the given list. **Example:** ```python words = [\\"cat\\", \\"cats\\", \\"dog\\", \\"catsdog\\"] findAllConcatenatedWords(words) ``` Output: ```python [\\"catsdog\\"] ``` **Note:** - The provided list could have duplicates, but they should be considered only once. - Words can only be concatenated from the given list and not any other words.","solution":"def findAllConcatenatedWords(words): Finds all the concatenated words in the given list of words. word_set = set(words) memo = {} def canForm(word): if word in memo: return memo[word] for i in range(1, len(word)): prefix = word[:i] suffix = word[i:] if prefix in word_set and (suffix in word_set or canForm(suffix)): memo[word] = True return True memo[word] = False return False concatenated_words = [] for word in words: if canForm(word): concatenated_words.append(word) return concatenated_words"},{"question":"Given a list of `n` integers, determine if it is possible to divide the list into two subsets such that the sum of the elements in both subsets is equal. Return `true` if such a division is possible, or `false` otherwise. The function should be efficient with respect to both time and space complexity.","solution":"def can_partition(nums): Determines if it is possible to partition the list into two subsets such that the sum of the elements in both subsets is equal. total_sum = sum(nums) # If the total sum is odd, it is not possible to partition into two equal subsets if total_sum % 2 != 0: return False target = total_sum // 2 n = len(nums) # dp[i] will be True if a subset with sum i can be formed with the elements in the list dp = [False] * (target + 1) dp[0] = True for num in nums: for j in range(target, num - 1, -1): dp[j] = dp[j] or dp[j - num] return dp[target]"},{"question":"You are given an array of integers `nums` representing the grayscale values of pixels in an image. Each integer is between 0 and 255 representing the intensity of the grayscale. The goal is to detect any edges in the image. An edge is defined as a significant difference in intensity between two adjacent pixels. Given an integer `threshold`, detect the edges in the image by doing the following: - Compare each pixel\'s intensity with the next pixel (i.e., `nums[i]` and `nums[i + 1]`). - If the absolute difference between the two pixels is greater than or equal to `threshold`, mark `nums[i]` as an edge (you can represent it by marking it with `1`). - If not, mark it as not an edge (you can represent it by marking it with `0`). Return an array of the same length as `nums` where each element indicates whether the corresponding pixel is an edge (1) or not (0). Note that the last pixel will always be marked as `0` since it has no adjacent pixel to compare with.","solution":"def detect_edges(nums, threshold): Detects edges in the grayscale image represented by nums using the given threshold. Args: nums (list of int): list of grayscale values of pixels (0-255). threshold (int): the threshold to detect edges. Returns: list of int: list of 0s and 1s where 1 indicates an edge and 0 indicates no edge. edges = [0] * len(nums) for i in range(len(nums) - 1): if abs(nums[i] - nums[i + 1]) >= threshold: edges[i] = 1 return edges"},{"question":"You are given a matrix `mat` of integers with dimensions `m x n`. You need to return a new matrix `res` where `res[i][j]` is the sum of all elements in the original matrix `mat` in the rectangle defined by the top-left corner `(0, 0)` and the bottom-right corner `(i, j)`. The dimensions of `res` should be the same as `mat`.","solution":"def sum_matrix(mat): Returns a new matrix res where res[i][j] is the sum of elements in the submatrix from (0,0) to (i,j) for a given m x n matrix. m = len(mat) n = len(mat[0]) res = [[0] * n for _ in range(m)] for i in range(m): for j in range(n): res[i][j] = mat[i][j] if i > 0: res[i][j] += res[i - 1][j] if j > 0: res[i][j] += res[i][j - 1] if i > 0 and j > 0: res[i][j] -= res[i - 1][j - 1] return res"},{"question":"Given a string `str` consisting of lowercase English letters, return the **first non-repeating character** in it. If there are no non-repeating characters, return an empty string.","solution":"def first_non_repeating_char(s): Returns the first non-repeating character in the string s. If there is no non-repeating character, returns an empty string. char_count = {} # Count the occurrences of each character for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Find the first character with a count of 1 for char in s: if char_count[char] == 1: return char return \\"\\" # Example test case s = \\"swiss\\" print(first_non_repeating_char(s)) # Output: \\"w\\""},{"question":"Given a 2D integer array `matrix`, where each of the rows is sorted in ascending order, find the `k-th smallest` element in the matrix. Note that it is the `k-th smallest` element in the sorted order, not the `k-th` distinct element. For example, given the matrix: ``` [ [1, 5, 9], [10, 11, 13], [12, 13, 15] ] ``` and `k = 8`, the `k-th smallest` element is `13`. Assume `k` is always valid, `1 <= k <= n^2` where `n` is the number of rows and columns in the matrix.","solution":"import heapq def kthSmallest(matrix, k): n = len(matrix) min_heap = [] # Initialize the heap with the first element of each row for r in range(min(n, k)): heapq.heappush(min_heap, (matrix[r][0], r, 0)) # Extract-min k times while k: element, r, c = heapq.heappop(min_heap) if c + 1 < n: heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1)) k -= 1 return element"},{"question":"Given a string `s` which represents a valid parentheses expression, implement a function to remove the minimum number of parentheses to make the string balanced. Return the resulting balanced string. For example, given the input string `\\"(a)())()\\"`, the function should return `\\"a)())()\\"`.","solution":"def remove_min_parentheses(s): Remove the minimum number of parentheses to make the string balanced. Args: s (str): The input string representing a valid parentheses expression. Returns: str: The resulting balanced string. stack = [] remove_indices = set() # First pass to identify positions to remove for index, char in enumerate(s): if char == \'(\': stack.append(index) elif char == \')\': if stack: stack.pop() else: remove_indices.add(index) # Add unmatched \'(\' remaining in the stack to remove set remove_indices.update(stack) # Second pass to build the resulting string result = [] for index, char in enumerate(s): if index not in remove_indices: result.append(char) return \'\'.join(result)"},{"question":"You are given a list of strings `words`, where each string represents a sequence of lowercase alphabet characters. Implement a class `WordDictionary` with the following methods: * `WordDictionary()` Initializes the object. * `void addWord(String word)` Adds a word to the dictionary. * `boolean search(String word)` Returns `true` if there is any string in the dictionary that matches `word` or `false` otherwise. `word` may contain the \'.\' character, which can represent any one letter. Example: ``` WordDictionary wordDictionary = new WordDictionary(); wordDictionary.addWord(\\"bad\\"); wordDictionary.addWord(\\"dad\\"); wordDictionary.addWord(\\"mad\\"); wordDictionary.search(\\"pad\\"); // returns false wordDictionary.search(\\"bad\\"); // returns true wordDictionary.search(\\".ad\\"); // returns true wordDictionary.search(\\"b..\\"); // returns true ```","solution":"class WordDictionary: def __init__(self): self.words = [] def addWord(self, word: str) -> None: self.words.append(word) def search(self, word: str) -> bool: for w in self.words: if self.match(w, word): return True return False def match(self, w: str, word: str) -> bool: if len(w) != len(word): return False for i in range(len(word)): if word[i] != \'.\' and word[i] != w[i]: return False return True"},{"question":"Given a linked list of integers, write a function to determine if the linked list has a cycle in it. Implement the `hasCycle(ListNode head)` method that returns `true` if there\'s a cycle in the linked list, and `false` otherwise. Use Floyd’s Cycle-Finding Algorithm (also known as Tortoise and Hare Algorithm) to achieve this.","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def hasCycle(head): Determine if a linked list has a cycle in it. Uses Floyd’s Cycle-Finding Algorithm (Tortoise and Hare Algorithm). :param head: ListNode, the head of the linked list :return: bool, True if there is a cycle, False otherwise if not head or not head.next: return False slow = head fast = head.next while slow != fast: if not fast or not fast.next: return False slow = slow.next fast = fast.next.next return True"},{"question":"You are given an array of integers `arr` and an integer `k`. You can perform the following operations on the array as many times as needed: pick any subarray of length `k`, and reverse it. Return _the lexicographically smallest array that can be obtained by performing the above operation any number of times_. In case there are multiple valid solutions, return the smallest one.","solution":"def reverseSubarrayToSmallestLexicographical(arr, k): Returns the lexicographically smallest array by reversing any subarray of length k any number of times. n = len(arr) if k == 1: return sorted(arr) else: return sorted(arr)"},{"question":"You are given two integer arrays `nums1` and `nums2`, both of which are sorted in non-decreasing order. Merge the two sorted arrays into one sorted array and return it. You should not use any extra memory and aim to merge in O(n) time complexity, where n is the total number of elements in `nums1` and `nums2`. Write a function that returns the merged array.","solution":"def merge_sorted_arrays(nums1, nums2): Merges two sorted arrays into one sorted array without using extra memory. Parameters: nums1 (list of int): First sorted array. nums2 (list of int): Second sorted array. Returns: list of int: Merged sorted array. i, j = 0, 0 merged_array = [] # Traverse both arrays and merge them into a single sorted array while i < len(nums1) and j < len(nums2): if nums1[i] <= nums2[j]: merged_array.append(nums1[i]) i += 1 else: merged_array.append(nums2[j]) j += 1 # Append remaining elements from nums1 while i < len(nums1): merged_array.append(nums1[i]) i += 1 # Append remaining elements from nums2 while j < len(nums2): merged_array.append(nums2[j]) j += 1 return merged_array"},{"question":"Given a binary tree, imagine each node contains a value representing the amount of time needed to process that node. The tree is traversed in a specific manner which starts at the root and can move to any node\'s left or right child. The traversal must account for the time spent processing each node. Write an algorithm that determines the **minimum total time** required to traverse from the root to any leaf node, where the total time is the sum of the processing times of all nodes on the path from the root to that leaf. Return the minimum total time as an integer.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def min_processing_time(root: TreeNode) -> int: Returns the minimum total processing time required to traverse from the root to any leaf node in the binary tree. if not root: return 0 if not root.left and not root.right: return root.value left_time = right_time = float(\'inf\') if root.left: left_time = min_processing_time(root.left) if root.right: right_time = min_processing_time(root.right) return root.value + min(left_time, right_time)"},{"question":"You are given a string representing a complex number. The complex number can be in the form of `a+bi` where `a` and `b` are integers, and `i` represents the imaginary unit. Perform multiplication of two complex numbers given as strings, and return the result as a string. The input strings are valid complex numbers as per the above form. The multiplication of two complex numbers `(a+bi) * (c+di)` can be found using the formula: [ (a+bi) * (c+di) = (ac - bd) + (ad + bc)i ] Given two strings `num1` and `num2` representing two complex numbers, return the result of their multiplication as a string.","solution":"def complex_number_multiply(num1, num2): Multiplies two complex numbers given as strings and returns the result as a string. def parse_complex_number(num): a, b = num[:-1].split(\'+\') return int(a), int(b) a1, b1 = parse_complex_number(num1) a2, b2 = parse_complex_number(num2) real_part = a1 * a2 - b1 * b2 imaginary_part = a1 * b2 + b1 * a2 return f\\"{real_part}+{imaginary_part}i\\""},{"question":"Given an array of `n` integers, find the **maximum** sum of elements in any **contiguous subarray** of the array. A **contiguous subarray** is a sequence of consecutive elements in an array. Implement an efficient algorithm to solve this problem. If the array contains only negative numbers, the largest element should be returned.","solution":"def max_subarray_sum(nums): Returns the maximum sum of elements in any contiguous subarray. If the array contains only negative numbers, the largest element is returned. Utilizes Kadane\'s Algorithm. if not nums: raise ValueError(\\"Input array cannot be empty\\") current_sum = max_sum = nums[0] for num in nums[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"You are given an integer array `nums`, and an integer `k`. Return _the maximum number of consecutive elements you can obtain in `nums` such that the sum of these elements does not exceed `k`_.","solution":"def max_consecutive_elements(nums, k): Returns the maximum number of consecutive elements such that their sum does not exceed k. :param nums: List of integers. :param k: An integer. :return: The maximum number of consecutive elements. max_length = 0 current_sum = 0 left = 0 for right in range(len(nums)): current_sum += nums[right] while current_sum > k: current_sum -= nums[left] left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"You are given a binary tree where each node has a value from `0` to `25`, representing the letters \'a\' to \'z\': value `0` represents \'a\', value `1` represents \'b\', and so on. Create a function to find the lexicographically smallest string that starts at a leaf of this tree and ends at the root. As the tree may have multiple leaves, return the smallest string that can be built. Here is the signature of the function: ```python def smallestFromLeaf(root: TreeNode) -> str: # Function implementation ``` Where `TreeNode` is defined as: ```python class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None ```","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def smallestFromLeaf(root: TreeNode) -> str: def dfs(node, path): if not node: return path.append(chr(node.val + ord(\'a\'))) if not node.left and not node.right: paths.append(\'\'.join(reversed(path))) dfs(node.left, path) dfs(node.right, path) path.pop() paths = [] dfs(root, []) return min(paths)"},{"question":"You are given a list of events represented by their start and end times as `[[start1, end1], [start2, end2], ...]`. Implement a class `RoomAllocator` to allocate rooms such that no two events in a single room overlap. You should provide the following methods: * `RoomAllocator(list<vector<int>> events)` Initializes the RoomAllocator with a list of events. * `int minimumRoomsRequired()` Returns the minimum number of rooms required to accommodate all events without overlap.","solution":"import heapq class RoomAllocator: def __init__(self, events): self.events = events def minimumRoomsRequired(self): if not self.events: return 0 # Sort events by their start time self.events.sort(key=lambda x: x[0]) # Initialize a min-heap min_heap = [] # Add the end time of the first event heapq.heappush(min_heap, self.events[0][1]) # Iterate over the remaining events for i in range(1, len(self.events)): # If the current event starts after the earliest ending event, they can share the room if self.events[i][0] >= min_heap[0]: heapq.heappop(min_heap) # Allocate the current event to a room (either a new one or reuse an existing one) heapq.heappush(min_heap, self.events[i][1]) # The size of the heap will be the number of rooms required return len(min_heap)"},{"question":"You are given a string `s` consisting of lowercase English letters. A character `c` can be called a **special character** if it appears exactly once in `s`. Your task is to find the **index** of the first special character in `s`. If there is no special character, return `-1`. If there are multiple special characters, return the index of the first one that appears in `s`.","solution":"def first_special_character_index(s): Returns the index of the first special character in s. If there are no special characters, returns -1. # Dictionary to store the frequency of each character frequency = {} # Count the frequency of each character in the string for char in s: if char in frequency: frequency[char] += 1 else: frequency[char] = 1 # Find the first character with frequency of 1 for index, char in enumerate(s): if frequency[char] == 1: return index # If no special character is found, return -1 return -1"},{"question":"You are given an array `heights` representing the heights of buildings in a cityscape. The cityscape is viewed from left to right, and each building\'s height is represented as an integer in the array. Your task is to determine the total amount of \\"skyline\\" visible when the cityscape is viewed from the left. The skyline is defined as the number of distinct building heights that are visible when looking from the leftmost building to the rightmost one. Return the total number of distinct heights in this \\"skyline.\\"","solution":"def skyline(heights): Returns the total number of distinct heights in the skyline viewed from left to right. # Use a set to keep track of distinct heights distinct_heights = set() for height in heights: distinct_heights.add(height) return len(distinct_heights)"},{"question":"Given a string `s` consisting of lowercase English letters, we need to create as many \\"balanced\\" strings as possible. A string is considered balanced if it has equal numbers of the letters \'a\', \'b\', and \'c\'. Return _the **maximum** number of balanced strings that can be formed from `s`_. For example, given the string `s = \\"abcabcabc\\"`, the output would be 3, because we can split `s` into three balanced strings \\"abc\\", \\"abc\\", and \\"abc\\".","solution":"def max_balanced_strings(s): This function returns the maximum number of balanced strings that can be formed from `s`. A balanced string has equal numbers of the letters \'a\', \'b\', and \'c\'. count_a = s.count(\'a\') count_b = s.count(\'b\') count_c = s.count(\'c\') return min(count_a, count_b, count_c)"},{"question":"You are given a list of integers, `nums`, representing a binary array where each element is either 0 or 1. An operation consists of flipping a subarray (changing all `0`s to `1`s and all `1`s to `0`s). Your task is to find the maximum number of `1`s you can obtain in the array by performing exactly one flip operation on any subarray of `nums`. Return _the maximum number of `1`s_ after performing one flip operation. For example, given the binary array `[1, 0, 0, 1, 0]`, the optimal subarray to flip is `[0, 0, 1]`, yielding the transformed array `[1, 1, 1, 0, 1]` with `4` `1`s.","solution":"def max_ones_after_flip(nums): Returns the maximum number of 1s after performing one subarray flip on nums. total_ones = sum(nums) max_flip_gain = cur_flip_gain = 0 for num in nums: cur_flip_gain += 1 if num == 0 else -1 if cur_flip_gain < 0: cur_flip_gain = 0 max_flip_gain = max(max_flip_gain, cur_flip_gain) return total_ones + max_flip_gain"},{"question":"Given an array of integers `arr` and an integer `k`, return _the length of the longest subsequence such that the **absolute difference between any two consecutive elements** is less than or equal to `k`_. A subsequence is derived from the array by deleting some or no elements without changing the order of the remaining elements. For example, given `arr = [3, 10, 2, 1, 20]` and `k = 4`, one possible subsequence is `[3, 2, 1]` with length `3` since the absolute difference between `3 and 2` is `1` and between `2 and 1` is `1`, both less than or equal to `k`. The test cases are generated such that the answer always exists and `1 <= arr.length <= 1000`.","solution":"def longest_subsequence(arr, k): Returns the length of the longest subsequence such that the absolute difference between any two consecutive elements is less than or equal to k. n = len(arr) dp = [1] * n # dp[i] will store the length of the longest subsequence ending at index i for i in range(1, n): for j in range(i): if abs(arr[i] - arr[j]) <= k: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"A company has `n` employees with unique IDs ranging from `0` to `n-1`. Each employee reports directly to exactly one manager except for the CEO, who does not report to anyone. Given a list `manager` where `manager[i]` is the ID of the manager for employee `i`, and `manager[i]` is `-1` if `i` is the CEO, and another list `importance` where `importance[i]` is the importance value of employee `i`. You need to return the total importance value of a given employee `id` and all their direct and indirect subordinates. [Your function should be efficient in terms of both time and space complexity.]","solution":"def getTotalImportance(n, manager, importance, id): from collections import defaultdict, deque # Create an adjacency list to represent the hierarchy subordinates = defaultdict(list) for i in range(n): if manager[i] != -1: subordinates[manager[i]].append(i) # Do a breadth-first search to calculate the total importance total_importance = 0 queue = deque([id]) while queue: current_id = queue.popleft() total_importance += importance[current_id] for subordinate in subordinates[current_id]: queue.append(subordinate) return total_importance"},{"question":"You are given an array of integers `nums` with a length of `n`. Your task is to rotate the array to the right by `k` steps, where `k` is non-negative. Implement a function that returns _the rotated array_.","solution":"def rotate(nums, k): Rotates the array nums to the right by k steps. Args: nums: List[int] - the array to be rotated k: int - number of steps to rotate the array Returns: List[int] - the rotated array n = len(nums) k = k % n # Normalize k to ensure it falls within the array length return nums[-k:] + nums[:-k]"},{"question":"You are given an array `nums` consisting of integers. An operation allows you to select an index `i` (0 ≤ i < n-1) and increment both `nums[i]` and `nums[i+1]` by 1. Return the minimum number of operations required to make all elements in the array equal. If it is not possible to make all elements equal, return -1.","solution":"def min_operations_to_equalize(nums): Returns the minimum number of operations required to make all elements in the array equal. If it is not possible, returns -1. if len(nums) < 2: return 0 # An array with one or zero elements is already equal. nums_even_parity = (nums[0] % 2 == 0) for num in nums: if (num % 2 == 0) != nums_even_parity: return -1 return (max(nums) - min(nums)) // 2"},{"question":"Given the `head` of a singly linked list, reverse the list and return its new `head`. Make sure your solution works in **O(n)** time complexity and utilizes **O(1)** auxiliary space.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_list(head): Reverses a singly linked list and returns its new head. Parameters: head (ListNode): The head of the singly linked list. Returns: ListNode: The new head of the reversed list. prev = None current = head while current: next_node = current.next current.next = prev prev = current current = next_node return prev"},{"question":"You are given a 2D list `matrix` of integers where each row is sorted in non-decreasing order and each column is sorted in non-decreasing order. Your task is to find the `k-th` smallest number in the matrix. Implement a function `int kthSmallest(int[][] matrix, int k)` that accomplishes this task. Note that the `k-th` smallest element is the `k`-th smallest element in the combined sorted order of all elements in the matrix.","solution":"import heapq def kth_smallest(matrix, k): Returns the k-th smallest number in a 2D matrix where each row and column are sorted. :param matrix: List[List[int]] - 2D list of integers sorted in non-decreasing order both row and column wise. :param k: int - The k-th position to find. :return: int - The k-th smallest number in the matrix. n = len(matrix) # Min-heap to keep track of the smallest elements min_heap = [] for r in range(min(k, n)): # We only take the first k rows in consideration, as any more rows have no effect on the answer heapq.heappush(min_heap, (matrix[r][0], r, 0)) # Extract min k-1 times for i in range(k-1): num, r, c = heapq.heappop(min_heap) if c + 1 < n: heapq.heappush(min_heap, (matrix[r][c+1], r, c+1)) # The k-th smallest will be at the root of the min-heap return heapq.heappop(min_heap)[0]"},{"question":"Given an array of integers where each integer represents the height of a building in a skyline, determine the **maximum area** of a rectangle that can be formed using any number of contiguous buildings. The height of the rectangle is determined by the shortest building in the selected range. The width of the rectangle is the number of buildings in the selected range.","solution":"def max_rectangle_area(heights): Returns the maximum area of a rectangle that can be formed using any number of contiguous buildings. :param heights: List[int] represents the heights of the buildings. :return: int, the maximum rectangle area. max_area = 0 stack = [] for index, height in enumerate(heights): start_index = index while stack and stack[-1][1] > height: start_index, h = stack.pop() max_area = max(max_area, h * (index - start_index)) stack.append((start_index, height)) while stack: start_index, height = stack.pop() max_area = max(max_area, height * (len(heights) - start_index)) return max_area"},{"question":"You are given an array of integers `nums` representing an initial array of integers. Design an algorithm to apply a series of operations to transform the given array. Implement the `ArrayTransformer` class: * `ArrayTransformer(nums)` Initializes the object with the integer array `nums`. * `void reverseSubarray(l, r)` Reverses the elements of the array from index `l` to `r` inclusive. Indexing is 0-based. * `void incrementSubarray(l, r, inc)` Increments each element of the array from index `l` to `r` inclusive by `inc`. Indexing is 0-based. * `void multiplySubarray(l, r, m)` Multiplies each element of the array from index `l` to `r` inclusive by `m`. Indexing is 0-based. * `List<Integer> getArray()` Returns the current state of the array.","solution":"class ArrayTransformer: def __init__(self, nums): self.nums = nums def reverseSubarray(self, l, r): self.nums[l:r+1] = self.nums[l:r+1][::-1] def incrementSubarray(self, l, r, inc): for i in range(l, r+1): self.nums[i] += inc def multiplySubarray(self, l, r, m): for i in range(l, r+1): self.nums[i] *= m def getArray(self): return self.nums"},{"question":"You are given a list of `n` tasks, where each task is represented by an integer `i` and has a duration `tasks[i]`. You are also given a cooldown time `cooldown` which is the minimum amount of time that must pass before the same task can be executed again. Write a function to return the minimum time required to complete all the given tasks once. * For example, if `tasks = [1,2,1,3,1]` and `cooldown = 2`, something like `1 -> 2 -> idle -> 1 -> 3 -> idle -> 1` would be a valid execution plan.","solution":"def minimum_time_required(tasks, cooldown): Calculate the minimum time required to complete all the given tasks with cooldown period. :param tasks: List of tasks (can be repeated) :param cooldown: An integer representing the cooldown period :return: Minimum time required to complete all tasks last_occurrence = {} time = 0 for task in tasks: if task in last_occurrence and time - last_occurrence[task] <= cooldown: time = last_occurrence[task] + cooldown + 1 last_occurrence[task] = time time += 1 return time"},{"question":"You are given a list of job applications where each application is represented as an integer representing the number of years of experience the applicant has. Develop a function that groups the applications based on the years of experience into buckets of k years. Then, return the bucket with the most applications. If there is a tie, return the bucket with the smallest range of years. For example, if k = 5, the ranges would be [0-4], [5-9], [10-14], etc. and the applicants are grouped accordingly.","solution":"from collections import defaultdict def group_applications(applications, k): Groups applications by years of experience into buckets of k years. Returns the bucket with the most applications. If there is a tie, returns the bucket with the smallest range of years. if not applications or k <= 0: return [] bucket_dict = defaultdict(int) for experience in applications: bucket_start = (experience // k) * k bucket_dict[bucket_start] += 1 max_count = max(bucket_dict.values()) candidates = [key for key, value in bucket_dict.items() if value == max_count] return[min(candidates), min(candidates) + k - 1]"},{"question":"You are given a list of integers `nums` representing a complete sequence of numbers from `1` to `n`, but with one number missing in the sequence. Provide a function that, given the list `nums`, finds and returns the missing number in the sequence. The input list will always contain `n - 1` distinct numbers from the sequence.","solution":"def find_missing_number(nums): Given a list of integers representing a complete sequence of numbers from 1 to n, but with one number missing in the sequence, this function finds and returns the missing number. n = len(nums) + 1 expected_sum = n * (n + 1) // 2 actual_sum = sum(nums) return expected_sum - actual_sum"},{"question":"Given a 2D matrix `grid` of size `m x n` and an integer `threshold`, return the maximum possible side length of a square with a sum less than or equal to the `threshold` that can be obtained from this matrix.","solution":"def maxSideLength(grid, threshold): Returns the maximum side length of a square with a sum less than or equal to the threshold. m, n = len(grid), len(grid[0]) def get_prefix_sum_matrix(matrix): Helper function to compute prefix sums for the given matrix rows, cols = len(matrix), len(matrix[0]) prefix_sum = [[0] * (cols + 1) for _ in range(rows + 1)] for r in range(1, rows + 1): for c in range(1, cols + 1): prefix_sum[r][c] = (matrix[r - 1][c - 1] + prefix_sum[r - 1][c] + prefix_sum[r][c - 1] - prefix_sum[r - 1][c - 1]) return prefix_sum def get_sum_from_prefix_sum(prefix_sum, r1, c1, r2, c2): Helper function to get sum from (r1, c1) to (r2, c2) using prefix sums return (prefix_sum[r2 + 1][c2 + 1] - prefix_sum[r1][c2 + 1] - prefix_sum[r2 + 1][c1] + prefix_sum[r1][c1]) prefix_sum = get_prefix_sum_matrix(grid) max_length = 0 # Try every possible length until max possible square within bounds for length in range(1, min(m, n) + 1): found = False for i in range(m - length + 1): for j in range(n - length + 1): if get_sum_from_prefix_sum(prefix_sum, i, j, i + length - 1, j + length - 1) <= threshold: max_length = length found = True break if found: break return max_length"},{"question":"You are given an integer array `nums` of sufficient length, where each element represents the height of bars in a histogram. Each bar has a width of 1. The bars form a series of adjacent, equally-spaced columns. Determine the largest rectangular area that can be formed in the histogram by choosing contiguous bars. The area is calculated by multiplying the height of the shortest bar in the chosen set of bars by the number of bars in that set. Return the maximum rectangular area that can be formed in the histogram.","solution":"def largestRectangleArea(nums): Calculate the largest rectangular area in a histogram. Parameters: nums (List[int]): List of heights representing the histogram. Returns: int: The area of the largest rectangle that can be formed. stack = [] max_area = 0 # Append 0 to handle remaining bars in stack at the end. nums.append(0) for i, height in enumerate(nums): while stack and nums[stack[-1]] > height: h = nums[stack.pop()] w = i if not stack else i - stack[-1] - 1 max_area = max(max_area, h * w) stack.append(i) nums.pop() # Restore original list (optional but cleaner) return max_area"},{"question":"You are given a list of `n` integers representing the scores of `n` different students in a class. Each student can be assigned a letter grade based on their score: \'A\' for scores 90 and above, \'B\' for scores between 80 (inclusive) and 90 (exclusive), \'C\' for scores between 70 (inclusive) and 80 (exclusive), \'D\' for scores between 60 (inclusive) and 70 (exclusive), and \'F\' for scores below 60. Write a function `assign_grades(scores)` that takes a list of integers `scores` and returns a list of corresponding letter grades. The order of the grades in the output list should correspond to the order of the scores in the input list.","solution":"def assign_grades(scores): Given a list of scores, returns a list of corresponding grades. Parameters: scores (list of int): List of integer scores. Returns: list of str: List of corresponding letter grades. grades = [] for score in scores: if score >= 90: grades.append(\'A\') elif score >= 80: grades.append(\'B\') elif score >= 70: grades.append(\'C\') elif score >= 60: grades.append(\'D\') else: grades.append(\'F\') return grades"},{"question":"You are given an integer array `arr`. Your task is to determine whether the array can be rearranged such that the absolute difference between any two adjacent elements is not greater than 1. Return `true` if such a rearrangement is possible, otherwise return `false`.","solution":"def can_rearrange(arr): Determines whether the array can be rearranged such that the absolute difference between any two adjacent elements is not greater than 1. Args: arr (List[int]): The input array of integers. Returns: bool: True if such a rearrangement is possible, otherwise False. arr.sort() for i in range(len(arr) - 1): if abs(arr[i] - arr[i + 1]) > 1: return False return True"},{"question":"You are given a list of integers representing points scored in different games by a player. Your task is to find the maximum possible average of any subarray of length `k`. You need to return this maximum average as a floating point number. The value of `k` is guaranteed to be less than or equal to the size of the list and greater than zero.","solution":"def find_max_average(nums, k): Returns the maximum average of any subarray of length k. Parameters: nums (list of int): List of integers representing points scored in different games. k (int): Length of the subarray. Returns: float: Maximum average of any subarray of length k. n = len(nums) max_sum = current_sum = sum(nums[:k]) for i in range(k, n): current_sum = current_sum + nums[i] - nums[i - k] max_sum = max(max_sum, current_sum) return max_sum / k"},{"question":"Given an array `nums` of `n` positive integers, where `n` is even, split the array into two subsets with `n/2` elements each such that the sum of the two subsets is as close as possible. Return _the minimum possible difference between the sums of the two subsets._","solution":"from itertools import combinations def minimum_subset_difference(nums): Splits the array into two subsets of equal size such that the difference between the sums is minimized. Returns the minimum possible difference between the sums of the two subsets. n = len(nums) total_sum = sum(nums) half_n = n // 2 all_combinations = list(combinations(nums, half_n)) min_diff = float(\'inf\') for subset in all_combinations: subset_sum = sum(subset) other_subset_sum = total_sum - subset_sum diff = abs(subset_sum - other_subset_sum) if diff < min_diff: min_diff = diff return min_diff"},{"question":"Given a list of integers representing the heights of buildings on a 2D city skyline, return _the indices of buildings that have an unobstructed view of the sunset_. A building has an unobstructed view of the sunset if it is not blocked by any taller or equally tall building to its right. The buildings are given in left-to-right order in the list, so the rightmost building always has an unobstructed view. Assume the buildings can be of varying heights and the list can be empty. For an empty list, return an empty list of indices.","solution":"def buildings_with_sunset_view(buildings): Returns the indices of buildings that have an unobstructed view of the sunset. :param buildings: List of integers representing the heights of buildings. :return: List of indices of buildings with unobstructed sunset view. n = len(buildings) if n == 0: return [] result = [n-1] # The rightmost building always has an unobstructed view. tallest = buildings[n-1] for i in range(n-2, -1, -1): if buildings[i] > tallest: result.append(i) tallest = buildings[i] return result[::-1]"},{"question":"You are given an array of positive integers `candies` where `candies[i]` represents the number of candies of the `ith` type you have. You also have `k` friends that you want to share these candies with. Each friend should receive an equal number of candies of each type, with any leftover candies discarded. Determine _the maximum number of candies each friend can receive_. Return the maximum number of candies each friend can receive considering the constraints.","solution":"def max_candies_per_friend(candies, k): Returns the maximum number of candies each friend can receive. :param candies: List[int] - List of integers where candies[i] is the number of candies of the ith type. :param k: int - The number of friends. :return: int - The maximum number of candies each friend can receive of each type. # Initialize the maximum number of candies per friend to a large number max_candies = float(\'inf\') # For each type of candy, calculate the maximum number per friend by dividing # by the number of friends, update the minimum value found. for candy_count in candies: max_candies = min(max_candies, candy_count // k) return max_candies"},{"question":"You are given a **directed graph** represented as an adjacency list, where a node `u` has a directed edge to another node `v` if and only if `u` appears in the list corresponding to `v`. Your task is to determine if there is a **cycle** in the graph. Return `true` if there is at least one cycle, and `false` if there are no cycles. Implement the function `boolean hasCycle(Map<Integer, List<Integer>> graph`), where `graph` is the adjacency list representation of the directed graph.","solution":"def has_cycle(graph): Determines if there is a cycle in the given graph. Parameters: graph (dict): A dictionary representing the adjacency list of the graph. Returns: bool: True if there is a cycle in the graph, False otherwise. def visit(node): if node in visiting: return True if node in visited: return False visiting.add(node) for neighbor in graph.get(node, []): if visit(neighbor): return True visiting.remove(node) visited.add(node) return False visiting = set() visited = set() for node in graph: if visit(node): return True return False"},{"question":"You are given a **0-indexed** binary integer array `bins` where each element is either `0` or `1`. Your goal is to find the maximum length of a contiguous subarray that contains **at most one** `0`. Return _the length of the longest such subarray in_ `bins`.","solution":"def max_length_subarray_with_one_zero(bins): Returns the maximum length of a contiguous subarray that contains at most one zero. max_length = 0 left = 0 zero_count = 0 for right in range(len(bins)): if bins[right] == 0: zero_count += 1 while zero_count > 1: if bins[left] == 0: zero_count -= 1 left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"You are given a **0-indexed** array of integers `nums` and an integer `k`. Your task is to determine if there is any continuous subarray of length `k` that contains only distinct elements. Return `true` if such a subarray exists, and `false` otherwise.","solution":"def has_distinct_subarray(nums, k): Determines if there is any continuous subarray of length `k` that contains only distinct elements. :param nums: List[int], List of integers :param k: int, Length of the subarray to check :return: bool, True if a subarray of length k with distinct elements exists, False otherwise n = len(nums) if k > n: return False window = set() for i in range(k): if nums[i] in window: return False window.add(nums[i]) for i in range(k, n): window.remove(nums[i - k]) if nums[i] in window: return False window.add(nums[i]) return True"},{"question":"You are given two strings `s` and `t` of the same length consisting of uppercase English letters. Your task is to check whether it is possible to make `s` equal to `t` by performing the following operation any number of times: * Choose any character in `s` and replace it with another uppercase English letter. Return `true` if it is possible to make `s` equal to `t`, and `false` otherwise. **Note:** Both strings have the same length and contain only uppercase English letters.","solution":"def can_transform(s: str, t: str) -> bool: Returns whether it is possible to make s equal to t by replacing any character in s with another uppercase English letter. # Using sets to check if there are no unique characters in t that are # not present in s return set(t).issubset(set(s))"},{"question":"Imagine you are working with a binary tree where each node contains a value, and you need to support two types of operations. Implement the `BinaryTreeOperations` class: * `BinaryTreeOperations(int[] nodeValues)` initializes the tree using an array of node values. * `int sumValues(int targetLevel)` returns the sum of the values of all nodes at the specified `targetLevel` in the tree. * `void incrementSubtree(int node, int value)` increments all values in the subtree rooted at the given `node` by the specified `value`. The tree is represented in a level-order format, where the root node is the first element of the array, its children are the next elements, and so forth.","solution":"class BinaryTreeOperations: def __init__(self, nodeValues): Initializes the binary tree with a list of node values in level-order format. self.tree = nodeValues def sumValues(self, targetLevel): Sum the values of all nodes at the specified targetLevel in the tree. start_index = (2**targetLevel) - 1 end_index = (2**(targetLevel + 1)) - 1 return sum(self.tree[start_index:end_index]) def incrementSubtree(self, node, value): Increment all values in the subtree rooted at the given node by the specified value. if node < 0 or node >= len(self.tree): return q = [node] while q: current = q.pop(0) self.tree[current] += value left_child = 2 * current + 1 right_child = 2 * current + 2 if left_child < len(self.tree): q.append(left_child) if right_child < len(self.tree): q.append(right_child)"},{"question":"You are given a string `s` which consists of only lowercase English letters. A character in string `s` is considered a **vowel** if it is one of the following characters: \'a\', \'e\', \'i\', \'o\', \'u\'. A substring of `s` is any contiguous segment of `s`. Write a function that returns the total number of substrings of `s` that start and end with a vowel. Note that every single character in `s` as well as `s` itself are considered valid substrings.","solution":"def count_vowel_substrings(s): Returns the total number of substrings of s that start and end with a vowel. vowels = set(\'aeiou\') n = len(s) count = 0 for i in range(n): if s[i] in vowels: for j in range(i, n): if s[j] in vowels: count += 1 return count"},{"question":"You are given a `m x n` binary matrix `grid`, where `0` represents a sea cell and `1` represents a land cell. A **connected island** is formed by connecting adjacent land cells horizontally or vertically. Return the number of **distinct islands**. An island is considered to be the same as another if and only if one island can be translated (and not rotated or reflected) to equal the other. Implement the function as: ```python def numDistinctIslands(grid: List[List[int]]) -> int: ``` Your function should return an integer representing the number of distinct islands.","solution":"def numDistinctIslands(grid): def dfs(x, y, origin): stack = [(x, y)] shape = set() while stack: i, j = stack.pop() if (i, j) not in visited: visited.add((i, j)) shape.add((i - origin[0], j - origin[1])) for di, dj in directions: ni, nj = i + di, j + dj if 0 <= ni < m and 0 <= nj < n and grid[ni][nj] == 1: stack.append((ni, nj)) return frozenset(shape) m, n = len(grid), len(grid[0]) visited = set() directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] unique_islands = set() for i in range(m): for j in range(n): if grid[i][j] == 1 and (i, j) not in visited: island_shape = dfs(i, j, (i, j)) if island_shape: unique_islands.add(island_shape) return len(unique_islands)"},{"question":"You are given an array of integers `arr` where each element represents the height of a building. Each building has a unit width. The city planners want to create a new skyline by adding a limited number of floors to the buildings, up to `maxAdd` floors in total across all buildings, to maximize the height of the shortest building in the new skyline. Write a function that returns the maximum possible height of the shortest building after adding up to `maxAdd` floors in total. If the array is empty, return `0`.","solution":"def maximize_min_height(arr, maxAdd): if not arr: return 0 def can_achieve_height(target, available_floors): required_floors = sum(max(0, target - height) for height in arr) return required_floors <= available_floors low, high = min(arr), max(arr) + maxAdd while low < high: mid = (low + high + 1) // 2 if can_achieve_height(mid, maxAdd): low = mid else: high = mid - 1 return low"},{"question":"You are given a string `s` and an integer `k`. You can choose any character of the string and change it to any character you want. You can perform this operation at most `k` times. Your task is to determine the length of the longest substring that contains the same character after performing the operations. Return _the length of the longest substring with same characters achieved by performing at most `k` operations._ For example: - Input: `s = \\"AABABBA\\", k = 1` - Output: `4` Explanation: Replace the one \'B\' in the substring \\"AABA\\" to \'A\' to form \\"AAAA\\". The longest substring with same characters is \\"AAAA\\" with length 4. - Input: `s = \\"ABAB\\", k = 2` - Output: `4` Explanation: Replace the two \'A\'s in the substring \\"ABAB\\" to \'B\' to form \\"BBBB\\". The longest substring with same characters is \\"BBBB\\" with length 4.","solution":"def characterReplacement(s, k): Returns the length of the longest substring that contains the same character after performing at most k operations. count = {} max_length = 0 left = 0 for right in range(len(s)): count[s[right]] = count.get(s[right], 0) + 1 while (right - left + 1) - max(count.values()) > k: count[s[left]] -= 1 if count[s[left]] == 0: del count[s[left]] left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"You are given an integer array `nums` of length `n`. A subarray is a contiguous non-empty sequence of elements from the array. You can perform the following operation any number of times: choose a subarray of length `k` and reverse it. Your task is to determine if you can make the array `nums` non-decreasing by performing the operation described. Return `true` if it is possible, otherwise return `false`.","solution":"def can_be_non_decreasing(nums, k): Determine if the array \'nums\' can be made non-decreasing by reversing subarrays of length \'k\'. n = len(nums) if k == 1: return nums == sorted(nums) if k >= n: return True for start in range(k): subsequence = nums[start::k] if subsequence != sorted(subsequence): return False return True"},{"question":"You are given an integer array `nums` and an integer `k`. A continuous subarray is a subarray that is derived by deleting some (possibly none) of the elements from the start of the array and some (possibly none) from the end of the array. Your task is to find and return the length of the longest continuous subarray that has a sum less than or equal to `k`. If no such subarray exists, return `0`.","solution":"def longest_subarray_with_sum_leq_k(nums, k): Returns the length of the longest continuous subarray with sum less than or equal to k. max_length = 0 current_sum = 0 start = 0 for end in range(len(nums)): current_sum += nums[end] while current_sum > k and start <= end: current_sum -= nums[start] start += 1 max_length = max(max_length, end - start + 1) return max_length"},{"question":"Given a list of `n` integers `nums` and an integer `target`, return the **indices** of the two numbers such that they add up to `target`. You may assume that each input would have exactly one solution, and you may not use the same element twice. You can return the answer in any order. Implement the function `List[int] two_sum(List[int] nums, int target)` which takes the list `nums` and the integer `target`, and returns a list of two integers representing the indices of the solution pair. Note: - Your solution should be optimized in terms of time complexity.","solution":"from typing import List def two_sum(nums: List[int], target: int) -> List[int]: Returns the indices of the two numbers that add up to the target. Args: nums -- list of integers target -- integer target sum Returns: List of two integers representing the indices num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return [num_to_index[complement], i] num_to_index[num] = i # Example usage: # result = two_sum([2, 7, 11, 15], 9) # print(result) # Output: [0, 1]"},{"question":"A **perfect string** is a string that contains no two adjacent characters that are the same. Given a non-empty string `s` consisting of lowercase English letters, determine the minimum number of operations required to transform `s` into a perfect string. In one operation, you can replace any character in the string with any other lowercase English letter. Return _an integer representing the minimum number of operations needed_ to make `s` a perfect string.","solution":"def min_operations_to_make_perfect_string(s): Returns the minimum number of operations required to transform s into a perfect string. :param s: str - Input string consisting of lowercase English letters. :return: int - Minimum number of operations. operations = 0 n = len(s) for i in range(1, n): if s[i] == s[i - 1]: operations += 1 return operations"},{"question":"A robot is located at the top-left corner of a `m x n` grid (marked \'Start\' in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked \'End\' in the diagram below). Determine the number of unique paths that the robot can take to reach the bottom-right corner of the grid. Note that `m` and `n` will be at least 1. Example Diagram: ```plaintext (Start) --> [] --> [] --> ... --> [] | ... | [] --> [] --> (End) ```","solution":"def unique_paths(m, n): Returns the number of unique paths from the top-left corner to the bottom-right corner of a m x n grid. Parameters: m (int): The number of rows in the grid. n (int): The number of columns in the grid. Returns: int: The number of unique paths. # Create a 2D array with m rows and n columns filled with 1s dp = [[1] * n for _ in range(m)] # Iterate through the array updating the number of ways to get to each cell for i in range(1, m): for j in range(1, n): dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[-1][-1]"},{"question":"Given a list of integers `nums`, your task is to rearrange the elements to form the lexicographically largest permutation. If the list is already the largest permutation, rearrange it to the smallest permutation instead. Return the modified list.","solution":"def rearrange_permutation(nums): This function rearranges a list of integers to form the lexicographically largest permutation. If the list is already the largest permutation, it returns the smallest permutation instead. :param nums: List of integers :return: A list of integers rearranged accordingly # Generate the next lexicographical permutation n = len(nums) # Step 1: Find the largest index k such that nums[k] < nums[k + 1] k = n - 2 while k >= 0 and nums[k] >= nums[k + 1]: k -= 1 # If no such index exists, the array is the largest permutation if k == -1: return sorted(nums) # Step 2: Find the largest index l > k such that nums[k] < nums[l] l = n - 1 while nums[k] >= nums[l]: l -= 1 # Step 3: Swap the value of nums[k] with that of nums[l] nums[k], nums[l] = nums[l], nums[k] # Step 4: Reverse the sequence from nums[k + 1] up to and including the final element nums[k + 1:] = reversed(nums[k + 1:]) return nums"},{"question":"You are given an array of integers `nums` where each element appears either once or twice. Return an array of all the integers that appear exactly twice in the input array. Your solution should have a time complexity of O(n) and a space complexity of O(1), not counting the output array. You can assume that the input array is not sorted.","solution":"def find_duplicates(nums): Returns a list of integers that appear exactly twice in the input list nums. result = [] for num in nums: index = abs(num) - 1 if nums[index] < 0: result.append(index + 1) nums[index] = -nums[index] return result"},{"question":"Given an array of unique integers `nums` sorted in increasing order, implement a function to return the total number of arithmetic slices present in the array. An arithmetic slice is defined as a sequence of at least three elements where the difference between consecutive elements is constant. For example, in the array `[1, 3, 5, 7, 9]`, `[1, 3, 5]`, `[3, 5, 7]`, and `[5, 7, 9]` are all arithmetic slices, and they share the same difference of `2`. Your function should return the count of all such possible arithmetic slices in the given array.","solution":"def number_of_arithmetic_slices(nums): Returns the total number of arithmetic slices in the array. n = len(nums) if n < 3: return 0 total_slices = 0 current_slices = 0 for i in range(2, n): if nums[i] - nums[i - 1] == nums[i - 1] - nums[i - 2]: current_slices += 1 total_slices += current_slices else: current_slices = 0 return total_slices"},{"question":"You are given a string `s` and an array `words` containing non-empty strings. A string is a concatenation of each word in `words` exactly once and without any extra characters in between; however, words can be in any order. Determine if `s` is formed by the concatenation of every word in `words` exactly once. Return _`true` if `s` can be formed, otherwise return `false`_.","solution":"def can_form_string_from_words(s, words): Determines if the string s can be formed by concatenating all words in words exactly once. :param s: Input string to check :param words: List of words to form the string :return: True if the string can be formed, False otherwise from collections import Counter # Create a counter of characters in the input string s_counter = Counter(s) # Create a counter of characters from the concatenation of all words words_counter = Counter(\'\'.join(words)) # Compare both counters return s_counter == words_counter"},{"question":"Given an integer array `nums`, return the largest product that can be obtained from three of its elements.","solution":"def maximum_product_of_three(nums): Returns the largest product that can be obtained from three elements in the nums array. nums.sort() return max(nums[-1] * nums[-2] * nums[-3], nums[0] * nums[1] * nums[-1])"},{"question":"You are given an integer array `nums` and an integer `threshold`. Count the number of substrings in `nums` whose product of all its elements is less than `threshold`. A substring is defined as a contiguous sequence of elements within the array. _Return the count of such substrings._ A substring is defined as a contiguous subsequence of elements within the array. Two substrings are considered different if they start or end at different positions.","solution":"def count_subarrays_with_product_less_than_threshold(nums, threshold): Count the number of subarrays (contiguous subsequences) such that the product of all its elements is less than the given threshold. :param nums: List[int] - List of integers representing the array. :param threshold: int - The threshold value. :return: int - The count of substrings with product less than threshold. n = len(nums) count = 0 product = 1 left = 0 for right in range(n): product *= nums[right] while product >= threshold and left <= right: product //= nums[left] left += 1 count += (right - left + 1) return count"},{"question":"You are given an **n x n** grid `grid` represented as a 2D array of integers, where each integer is a non-negative number representing the height of that cell. Water can flow from a cell to its **four neighboring cells** (up, down, left, or right) and can only do so if the neighboring cell\'s height is less than or equal to the current cell\'s height. The grid also has an **ocean** on the top and the left edges, and another **ocean** on the bottom and the right edges. Water can flow from each cell to any adjacent edge (top, bottom, left, or right) that is directly connected to an ocean. Find all cells from which water can flow to both the top/left ocean and the bottom/right ocean. Return the result as a list of coordinate pairs `(r, c)`.","solution":"def pacificAtlantic(grid): if not grid or not grid[0]: return [] n, m = len(grid), len(grid[0]) # Initialize sets to keep track of reachable cells for each ocean pacific_reachable = set() atlantic_reachable = set() def dfs(r, c, reachable_set, prev_height): if ((r, c) in reachable_set or r < 0 or r >= n or c < 0 or c >= m or grid[r][c] < prev_height): return reachable_set.add((r, c)) for dr, dc in ((0, 1), (1, 0), (0, -1), (-1, 0)): dfs(r + dr, c + dc, reachable_set, grid[r][c]) for i in range(n): dfs(i, 0, pacific_reachable, grid[i][0]) dfs(i, m - 1, atlantic_reachable, grid[i][m - 1]) for j in range(m): dfs(0, j, pacific_reachable, grid[0][j]) dfs(n - 1, j, atlantic_reachable, grid[n - 1][j]) return list(pacific_reachable & atlantic_reachable)"},{"question":"You are given two strings `s1` and `s2` which consist of only lowercase English letters. Your task is to check if you can obtain `s2` by shuffling the characters in `s1` and optionally removing some characters from `s1`. If it is possible, return `true`; otherwise, return `false`. For example, given `s1` = \\"abppplee\\" and `s2` = \\"apple\\", return `true` because you can shuffle `s1` to \\"ppalleee\\" and remove the unnecessary \'p\', \'l\', \'e\', and \'e\' to get \\"apple\\".","solution":"from collections import Counter def can_obtain_s2_by_shuffling_s1(s1, s2): Check if it is possible to obtain s2 by shuffling the characters in s1 and optionally removing some characters. Parameters: - s1: str : a string of lowercase English letters - s2: str : a string of lowercase English letters Returns: - bool: True if it is possible to obtain s2, otherwise False counter_s1 = Counter(s1) counter_s2 = Counter(s2) for char in counter_s2: if counter_s2[char] > counter_s1[char]: return False return True"},{"question":"You are given a linked list where each node contains a positive integer value. Write a function to swap every two adjacent nodes and return its head. You must not modify the values in the list\'s nodes, only nodes themselves may be changed. For example, given the linked list `1 -> 2 -> 3 -> 4`, you should return the list as `2 -> 1 -> 4 -> 3`.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def swap_pairs(head): Swap every two adjacent nodes in a linked list and return its head. dummy = ListNode(0) dummy.next = head current = dummy while current.next and current.next.next: first = current.next second = current.next.next # Swap nodes first.next = second.next second.next = first current.next = second # Move to the next pair current = first return dummy.next"},{"question":"Given a list of integers, `nums`, return the number of unique pairs `(i, j)` such that `nums[i]` + `nums[j]` is an even number and `i < j`. Two pairs `(i, j)` and `(k, l)` are considered unique if there is at least one distinct index between them (i.e., `i != k` or `j != l`).","solution":"def count_even_sum_pairs(nums): Returns the number of unique pairs (i, j) such that nums[i] + nums[j] is an even number and i < j. n = len(nums) count = 0 for i in range(n): for j in range(i + 1, n): if (nums[i] + nums[j]) % 2 == 0: count += 1 return count"},{"question":"Given an integer `n`, generate the `nth` row of Pascal\'s Triangle. In Pascal\'s Triangle, each number is the sum of the two numbers directly above it. The first few rows of Pascal\'s Triangle are: ``` [ [1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1], ... ] ``` Return the nth row of Pascal\'s Triangle as a list.","solution":"def generate_pascals_triangle_row(n): Returns the nth row of Pascal\'s Triangle. if n == 0: return [1] row = [1] for k in range(1, n + 1): next_value = row[-1] * (n - k + 1) // k row.append(next_value) return row"},{"question":"You are given two strings `order` and `str`. `order` represents the order of characters in an alien language, and `str` is a string of words written in that language. Return _a new string `str` reordered according to the order of characters in `order`_. If there are characters in `str` that aren’t in `order`, they should appear at the end of the result in their original order. # Example - **Input:** `order = \\"cba\\"`, `str = \\"abcd\\"` - **Output:** `cbad` # Explanation: Characters `a`, `b`, and `c` appear in `order`, so they are reordered accordingly. Character`d` does not appear in `order` and thus appears at the end in its original order.","solution":"def custom_sort(order, s): \'\'\' Reorder the string s according to the order of characters in order string. Parameters: order (str): String representing the order of characters in alien language. s (str): Input string which we need to reorder. Returns: str: New string reordered according to order. \'\'\' # Create a dictionary to store the order of each character order_dict = {char: index for index, char in enumerate(order)} # Sorting logic sorted_s = sorted(s, key=lambda char: order_dict.get(char, len(order))) return \'\'.join(sorted_s)"},{"question":"You are given an array of integers `heights` representing the height of buildings along a street where `heights[i]` is the height of the `i`-th building. A building is considered visible if its height is greater than all the buildings to its right. Write a function that returns the list of indices of all visible buildings in ascending order. For example, given the input array `[4, 2, 3, 1]`, the output should be `[0, 2, 3]` as the buildings at indices 0, 2, and 3 are visible.","solution":"def find_visible_buildings(heights): Returns a list of indices of all visible buildings arranged in ascending order. A building is visible if its height is greater than all buildings to its right. Parameters: heights (list[int]): List of heights of the buildings. Returns: list[int]: List of indices of visible buildings sorted in ascending order. if not heights: return [] visible_indices = [] max_height = heights[-1] visible_indices.append(len(heights) - 1) # the last building is always visible # Traverse the heights array in reverse order (right to left) for i in range(len(heights) - 2, -1, -1): if heights[i] > max_height: visible_indices.append(i) max_height = heights[i] return sorted(visible_indices)"},{"question":"You are given a string `s` consisting of only lowercase English letters. You can apply the following operation any number of times: Choose any two **different** characters and replace all occurrences of one of them with the other character. Your goal is to make the string `s` contain exactly one distinct character in as few operations as possible. Return _the minimum number of operations needed to make the string contain exactly one distinct character_.","solution":"def min_operations_to_single_char(s): Returns the minimum number of operations needed to make the string `s` contain exactly one distinct character. Args: s (str): The input string consisting of only lowercase English letters. Returns: int: The minimum number of operations needed. from collections import Counter # Get the frequency counts of each character in the string char_count = Counter(s) # Find the character with the maximum frequency max_freq = max(char_count.values()) # Minimum operations needed will be the total length of the string # minus the maximum frequency of any single character return len(s) - max_freq"},{"question":"Given an integer array `nums`, return the number of **arithmetic subarrays** of `nums`. A subarray `nums[i..j]` is arithmetic if the difference between any two consecutive elements is the same. A subarray is a contiguous sequence of elements within the array. A single element subarray is not considered arithmetic.","solution":"def number_of_arithmetic_subarrays(nums): def count_arithmetic_slices(A): n = len(A) if n < 3: return 0 count = 0 dp = [0] * n for i in range(2, n): if A[i] - A[i-1] == A[i-1] - A[i-2]: dp[i] = dp[i-1] + 1 count += dp[i] return count return count_arithmetic_slices(nums)"},{"question":"Given a binary string `s`, return _the minimum number of swaps required to make the string alternating_, where an alternating string is defined as a string where no two adjacent characters are the same. If it is not possible to make the string alternating, return `-1`.","solution":"def min_swaps_to_alternate(s): Returns the minimum number of swaps required to make the binary string s alternating. If it is not possible to make the string alternating, returns -1. n = len(s) # Case for alternating pattern starting with \'0\' count0 = count1 = 0 for i in range(n): if i % 2 == 0: if s[i] != \'0\': count0 += 1 if s[i] != \'1\': count1 += 1 else: if s[i] != \'1\': count0 += 1 if s[i] != \'0\': count1 += 1 # Checking if it\'s possible to make the alternating string if count0 % 2 != 0 and count1 % 2 != 0: return -1 if count0 % 2 == 0 and count1 % 2 != 0: return count0 // 2 if count0 % 2 != 0 and count1 % 2 == 0: return count1 // 2 return min(count0 // 2, count1 // 2)"},{"question":"You are given a **0-indexed** array `heights` representing the heights of buildings, and an integer `k`. You can perform the following operation on the array: for any building, you can increase the height of one of its adjacent buildings by 1 and decrease its own height by 1. However, you can only perform this operation at most `k` times. Your goal is to minimize the height difference between the tallest and shortest building after performing the operations. Return the **minimum possible** difference between the maximum and minimum heights of the buildings after at most `k` operations.","solution":"def minimize_height_difference(heights, k): Returns the minimum possible difference between the maximum and minimum heights of the buildings after at most k operations. if not heights: return 0 n = len(heights) heights.sort() min_diff = heights[-1] - heights[0] for i in range(1, n): if heights[i] - heights[i-1] > 1 and k > 0: min_diff -= 1 k -= 1 return max(0, min_diff - k)"},{"question":"Given the guidelines, here is a new question that fits well with the existing set: [Question 4]: You are given a string `s` consisting only of characters \'a\', \'b\', and \'c\'. You can choose any two adjacent characters and swap them. Your goal is to make the string `s` lexicographically smallest possible. Return the lexicographically smallest string you can make with the given swaps. Note that a string `x` is lexicographically smaller than a string `y` if `x` comes before `y` in dictionary order.","solution":"def make_smallest_lexicographic_string(s): Returns the lexicographically smallest string possible by swapping any two adjacent characters. arr = list(s) n = len(arr) for i in range(n - 1): for j in range(n - 1 - i): if arr[j] > arr[j + 1]: arr[j], arr[j + 1] = arr[j + 1], arr[j] return \'\'.join(arr)"},{"question":"Given a linked list, where each node contains an integer value, segregate the linked list nodes so that all nodes with even values appear before nodes with odd values. The relative order of the even and odd nodes should be preserved. Write a function that returns the head of the modified linked list. Your solution must maintain the original relative order of nodes within the even and odd partitions and must run in `O(n)` time with `O(1)` space.","solution":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def segregate_even_odd(head): if not head: return head even_head = even_tail = None odd_head = odd_tail = None current = head while current: next_node = current.next current.next = None if current.value % 2 == 0: if even_head is None: even_head = even_tail = current else: even_tail.next = current even_tail = even_tail.next else: if odd_head is None: odd_head = odd_tail = current else: odd_tail.next = current odd_tail = odd_tail.next current = next_node if even_tail: even_tail.next = odd_head return even_head else: return odd_head"},{"question":"A robot is initially located at the origin (0, 0) on a 2D plane. The robot can be controlled to move one step at a time in either of four directions: \'L\' (left), \'R\' (right), \'U\' (up), or \'D\' (down). Given a string `instructions` consisting of these four directions, return _the minimum number of steps required for the robot to return to the origin after executing all the given instructions_.","solution":"def min_steps_to_return_to_origin(instructions): Returns the minimum number of steps required for the robot to return to the origin after executing all the given instructions. horizontal, vertical = 0, 0 for inst in instructions: if inst == \'L\': horizontal -= 1 elif inst == \'R\': horizontal += 1 elif inst == \'U\': vertical += 1 elif inst == \'D\': vertical -= 1 return abs(horizontal) + abs(vertical)"},{"question":"You are given an integer array `nums` sorted in non-decreasing order. Your task is to remove some duplicates in place such that each unique element appears at most twice. The relative order of the elements should be kept the same, and you should not use extra space for another array. Return the length of the modified array. For example, given `nums = [1, 1, 1, 2, 2, 3]`, you should return `5` with `nums` being modified to `[1, 1, 2, 2, 3, _]` where `_` can be any value.","solution":"def remove_duplicates(nums): Removes duplicates in a sorted array such that each unique element appears at most twice. Modifies the input nums in-place and returns length of the modified array. if not nums: return 0 # Maximum number of occurrences allowed for each element max_occurrences = 2 # Index of the next position to place the verified number insert_position = 1 # Count occurrences of current number count = 1 for i in range(1, len(nums)): if nums[i] == nums[i - 1]: if count < max_occurrences: nums[insert_position] = nums[i] insert_position += 1 count += 1 else: nums[insert_position] = nums[i] insert_position += 1 count = 1 return insert_position"},{"question":"You are given two arrays of integers `nums1` and `nums2` which represent two sets of elements. These sets are **not sorted** and may contain duplicate elements. Write a function that returns an array representing their **intersection**. Each element in the result must appear as many times as it shows in both arrays. The result can be in any order.","solution":"def intersect(nums1, nums2): Find the intersection of two arrays, where each element in the result appears as many times as it shows in both arrays. The result can be in any order. from collections import Counter counter1 = Counter(nums1) counter2 = Counter(nums2) intersection = [] for num in counter1: if num in counter2: times = min(counter1[num], counter2[num]) intersection.extend([num] * times) return intersection"},{"question":"You are given a 2D integer array `matrix` where each element `matrix[i][j]` represents the height of a land cell. Water can flow only to neighboring cells north, south, east, and west if the height of the neighboring cell is less than or equal to the current cell\'s height. Water can flow out of a cell to the Pacific or Atlantic ocean if the cell is on the border of the matrix and to neighboring cells accordingly. The Pacific ocean touches the left and top edges of the matrix, and the Atlantic ocean touches the right and bottom edges. Return a list of grid coordinates where water can flow to both the Pacific and Atlantic oceans. The returned coordinates should be sorted lexicographically.","solution":"def pacific_atlantic(matrix): if not matrix or not matrix[0]: return [] rows, cols = len(matrix), len(matrix[0]) pacific_reachable = [[False for _ in range(cols)] for _ in range(rows)] atlantic_reachable = [[False for _ in range(cols)] for _ in range(rows)] def dfs(i, j, reachable, ocean_name=\\"\\"): reachable[i][j] = True directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] for direction in directions: x, y = i + direction[0], j + direction[1] if 0 <= x < rows and 0 <= y < cols and not reachable[x][y] and matrix[x][y] >= matrix[i][j]: dfs(x, y, reachable, ocean_name) for i in range(rows): dfs(i, 0, pacific_reachable, \\"Pacific\\") dfs(i, cols - 1, atlantic_reachable, \\"Atlantic\\") for j in range(cols): dfs(0, j, pacific_reachable, \\"Pacific\\") dfs(rows - 1, j, atlantic_reachable, \\"Atlantic\\") result = [] for i in range(rows): for j in range(cols): if pacific_reachable[i][j] and atlantic_reachable[i][j]: result.append([i, j]) return sorted(result)"},{"question":"You are given a string `s` consisting of lowercase English letters. A _valid substring_ is defined as a contiguous substring that does not contain any repeating characters. Implement a function `findLongestValidSubstring` that takes the string `s` and returns the length of the longest _valid substring_. The solution should have a time complexity of `O(n)`.","solution":"def findLongestValidSubstring(s): Returns the length of the longest valid substring without repeating characters. :param s: A string consisting of lowercase English letters. :return: An integer representing the length of the longest valid substring. char_index_map = {} longest = 0 start = 0 for end, char in enumerate(s): if char in char_index_map and char_index_map[char] >= start: start = char_index_map[char] + 1 char_index_map[char] = end longest = max(longest, end - start + 1) return longest"},{"question":"Given a 2D grid of integers representing a map where `1` represents land and `0` represents water, design an algorithm to find and return the size of the largest island. An island is a group of adjacent land cells connected vertically or horizontally (not diagonally). You can assume there is only one largest island, and if there are no land cells in the grid, return `0`. **Clarification:** The size of an island is the total number of land cells making up the island. Use Depth-First Search (DFS) or Breadth-First Search (BFS) to explore the grid.","solution":"def largest_island(grid): Returns the size of the largest island in the given grid. def dfs(grid, i, j): # If out of bounds or at water cell, return 0 if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == 0: return 0 # Mark the cell as visited grid[i][j] = 0 size = 1 # Explore all four directions size += dfs(grid, i + 1, j) size += dfs(grid, i - 1, j) size += dfs(grid, i, j + 1) size += dfs(grid, i, j - 1) return size max_island_size = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: # Calculate the size of each island island_size = dfs(grid, i, j) # Update the maximum island size found max_island_size = max(max_island_size, island_size) return max_island_size"},{"question":"You are given a binary matrix `grid` of size `m x n`. The rows of the matrix represent different paths and the columns represent different checkpoints along these paths. If `grid[i][j]` is `1`, it indicates that a path between the i-th path and the j-th checkpoint is possible; otherwise, if `grid[i][j]` is `0`, no path exists. Your goal is to check if there exists a path from any cell in the first row to any cell in the last row following these conditions: * You can only move to an adjacent cell in the next row. In other words, from `grid[i][j]`, you may only move to `grid[i+1][k]` provided the value at this cell is `1`. * Return `true` if such a path exists; otherwise, return `false`.","solution":"def is_possible_path(grid): Given a binary matrix `grid`, this function checks if there exists a path from any cell in the first row to any cell in the last row following the conditions. if not grid: return False m, n = len(grid), len(grid[0]) if m == 1: # If there\'s only one row, check if there\'s any 1 in that row. return any(grid[0]) # Initialize the possible paths with the first row cells that are 1 possible_paths = set(idx for idx, val in enumerate(grid[0]) if val == 1) # Traverse the grid row by row for i in range(1, m): next_paths = set() for j in possible_paths: for k in range(max(j-1, 0), min(j+2, n)): if grid[i][k] == 1: next_paths.add(k) possible_paths = next_paths if not possible_paths: return False return bool(possible_paths)"},{"question":"You are given an integer array ` heights` representing the height of square buildings arranged in a row. You are also given a positive integer `threshold`. A building is considered \\"unobstructed\\" if it is taller than the `threshold` and if there is no taller building to its right. Return _an integer array_ `result` _where_ `result[i]` _represents True if the_ `i-th` _building is unobstructed and False otherwise._","solution":"def unobstructed_buildings(heights, threshold): Returns a list where each element represents if the corresponding building is unobstructed. A building is unobstructed if it is taller than the threshold and has no taller building to its right. :param heights: List of integers representing heights of buildings :param threshold: Integer threshold :return: List of boolean values n = len(heights) result = [False] * n max_right = 0 for i in range(n-1, -1, -1): if heights[i] > threshold and heights[i] > max_right: result[i] = True max_right = max(max_right, heights[i]) return result"},{"question":"You are given a rectangular grid `m x n` filled with different colors. Each cell contains a single color represented by an integer. Two cells in the grid are **connected** if they are in the same row or column and have the same color. A color group is a set of connected cells all having the same color. Your task is to find the largest color group on the grid and return its size. In the event of a tie (multiple groups of the same size), return the size of any one of the largest color groups.","solution":"def largest_color_group(grid): Returns the size of the largest color group in the given grid. :param grid: List of List of integers representing the grid. :return: Integer representing the size of the largest color group. if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) def dfs(x, y, color): Depth-First Search to count the size of the color group. if x < 0 or x >= m or y < 0 or y >= n or grid[x][y] != color: return 0 grid[x][y] = -1 # Mark as visited size = 1 size += dfs(x + 1, y, color) size += dfs(x - 1, y, color) size += dfs(x, y + 1, color) size += dfs(x, y - 1, color) return size largest_group = 0 for i in range(m): for j in range(n): if grid[i][j] != -1: color = grid[i][j] group_size = dfs(i, j, color) largest_group = max(largest_group, group_size) return largest_group"},{"question":"You are managing a collection of library books. Each book has a unique `bookID` and belongs to a specific genre. You are given a list of tuples `books`, where each tuple contains two elements: `(bookID, genre)`. The library wants to reorganize the books so that no two books of the same genre are adjacent to each other on the shelf. Return `true` if it is possible to rearrange the books in such a way, otherwise, return `false`.","solution":"from collections import Counter import heapq def can_reorganize_books(books): Determines if books can be reorganized so that no two books of the same genre are adjacent. Parameters: books (list of tuples): List of tuples where each tuple contains a bookID and a genre. Returns: bool: True if books can be reorganized, otherwise False. if not books: return True # Count frequency of each genre genre_count = Counter([genre for _, genre in books]) # Convert counts to a max-heap max_heap = [(-count, genre) for genre, count in genre_count.items()] heapq.heapify(max_heap) prev_count, prev_genre = 0, None while max_heap: count, genre = heapq.heappop(max_heap) # Place the previous genre back into the max heap if prev_count < 0: heapq.heappush(max_heap, (prev_count, prev_genre)) # Add the current genre to the result (hypothetical placement) prev_count, prev_genre = count + 1, genre return (prev_count == 0)"},{"question":"Given an integer array `nums`, return the length of the longest increasing subsequence. A subsequence is a sequence that can be derived from an array by deleting some or no elements without changing the order of the remaining elements. For example, the longest increasing subsequence of the array `[10, 9, 2, 5, 3, 7, 101, 18]` is `[2, 3, 7, 101]`, so you should return 4.","solution":"def length_of_LIS(nums): Returns the length of the longest increasing subsequence in the array nums. if not nums: return 0 n = len(nums) dp = [1] * n # dp[i] represents the length of LIS ending at index i for i in range(1, n): for j in range(i): if nums[i] > nums[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"You are given an integer array `heights` representing the heights of students in a class. Another integer array `photos` of the same length represents the height of students in a photo session. Each student can only appear once in the photo and each photo session can include students of different heights but only in strictly increasing order of their heights. Return _the minimum number of students to be removed from the class so that all the students in the class can appear in the next photo session in increasing order without violating the given constraints_.","solution":"def min_students_to_remove(heights): Returns the minimum number of students to be removed so that all remaining students can be arranged in strictly increasing order of their heights. n = len(heights) if n == 0: return 0 # Find the longest increasing subsequence (LIS) lis = [1] * n for i in range(1, n): for j in range(i): if heights[i] > heights[j]: lis[i] = max(lis[i], lis[j] + 1) # The number of students to remove to get the longest increasing subsequence longest_increasing_subsequence_length = max(lis) return n - longest_increasing_subsequence_length"},{"question":"You are given an integer array `nums` and an integer `k`. Your task is to count the number of subarrays whose product of elements is less than `k`. Return the count of such subarrays.","solution":"def count_subarrays_with_product_less_than_k(nums, k): Returns the count of subarrays whose product of elements is less than k. if k <= 1: return 0 count = 0 product = 1 left = 0 for right in range(len(nums)): product *= nums[right] while product >= k and left <= right: product //= nums[left] left += 1 count += (right - left + 1) return count"},{"question":"You are given a matrix `grid` of size `n x m`, consisting of **non-negative** integers. You are initially positioned at the top-left corner of the matrix `(0, 0)`. Each element in the matrix represents the number of points you can collect upon passing through that cell. You can only move **right** or **down** from any cell. Your goal is to reach the bottom-right corner of the matrix `(n-1, m-1)` while collecting the maximum number of points possible. Return the **maximum** number of points you can collect by the time you reach the bottom-right corner.","solution":"def max_points(grid): Given a grid of non-negative integers, returns the maximum number of points that can be collected moving from top-left to bottom-right corner, only moving right or down. :param grid: List[List[int]] - The 2D grid of points :return: int - The maximum points collected if not grid or not grid[0]: return 0 n = len(grid) m = len(grid[0]) # Create a dp table with the same dimensions as the grid dp = [[0] * m for _ in range(n)] # Start from the top-left corner dp[0][0] = grid[0][0] # Initialize the first row (only rightward movement possible) for j in range(1, m): dp[0][j] = dp[0][j - 1] + grid[0][j] # Initialize the first column (only downward movement possible) for i in range(1, n): dp[i][0] = dp[i - 1][0] + grid[i][0] # Fill in the rest of the dp table for i in range(1, n): for j in range(1, m): dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] # The bottom-right corner will have the maximum points collected return dp[n - 1][m - 1]"},{"question":"You are given a 2D grid of size `m x n` representing a map of `1`s (land) and `0`s (water), where a group of connected `1`s (horizontally or vertically) forms an island. An island is considered diverse if it contains exactly two different values represented by `X` and `Y`. _Return the number of diverse islands in the grid_. Every cell in the grid may contain either `X`, `Y`, or `0` (water).","solution":"def num_diverse_islands(grid): if not grid: return 0 m, n = len(grid), len(grid[0]) visited = [[False] * n for _ in range(m)] def dfs(x, y): stack = [(x, y)] elements = set() while stack: cx, cy = stack.pop() if visited[cx][cy]: continue visited[cx][cy] = True elements.add(grid[cx][cy]) # Explore neighbors for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = cx + dx, cy + dy if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny]: if grid[nx][ny] in \'XY\': stack.append((nx, ny)) return elements diverse_islands_count = 0 for i in range(m): for j in range(n): if grid[i][j] in \'XY\' and not visited[i][j]: elements = dfs(i, j) if len(elements) == 2: diverse_islands_count += 1 return diverse_islands_count"},{"question":"You are given an integer array `nums` containing `n` distinct numbers in the range `[0, n]`. Implement a function to return the only number in the range that is missing from the array.","solution":"def missingNumber(nums): Given an array containing n distinct numbers taken from 0, 1, 2, ..., n, find the one that is missing from the array. Args: nums (list of int): The input array. Returns: int: The missing number. n = len(nums) total_sum = n * (n + 1) / 2 actual_sum = sum(nums) return int(total_sum - actual_sum)"},{"question":"You are given a matrix `grid` of integers where each cell in the matrix contains a positive integer. You start at the top-left cell `(0, 0)` and your goal is to reach the bottom-right cell `(n-1, m-1)` with the minimum cost path. The cost of a path is the sum of the values of the cells that are part of the path. You can only move right or down from a cell. Return _the minimum cost to reach the bottom-right cell from the top-left cell_. Use dynamic programming to optimize the solution.","solution":"def minPathSum(grid): Returns the minimum path sum from top-left to bottom-right in a given grid. if not grid or not grid[0]: return 0 n, m = len(grid), len(grid[0]) # Initialize dp array with the same dimensions as grid dp = [[0] * m for _ in range(n)] # Set the initial point (top-left corner) dp[0][0] = grid[0][0] # Fill the first row for j in range(1, m): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column for i in range(1, n): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp array for i in range(1, n): for j in range(1, m): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] # The bottom-right corner will contain the minimum path sum return dp[n-1][m-1]"},{"question":"You are given a binary string `s` and a positive integer `k`. You have to partition the string `s` into exactly `k` non-empty substrings such that the partition is valid. A partition is valid if each substring has an equal number of `0`s and `1`s. If multiple partitions are possible, return any of them. If no valid partition exists, return an empty list.","solution":"def partition_binary_string(s, k): Partitions the binary string `s` into exactly `k` non-empty substrings such that each substring has an equal number of \'0\'s and \'1\'s. If no valid partition exists, returns an empty list. :param s: Binary string :param k: Number of partitions :return: List of partitions or empty list if no valid partition exists count_0 = s.count(\'0\') count_1 = s.count(\'1\') # If the total numbers of \'0\'s and \'1\'s are not the same or are not divisible by k, return an empty list if count_0 != count_1 or count_0 % k != 0: return [] substrings = [] target_count = count_0 // k count_0, count_1 = 0, 0 current_substring = [] for char in s: current_substring.append(char) if char == \'0\': count_0 += 1 else: count_1 += 1 if count_0 == target_count and count_1 == target_count: substrings.append(\'\'.join(current_substring)) current_substring = [] count_0, count_1 = 0, 0 return substrings"},{"question":"You are given an integer array `heights` representing the heights of a row of buildings. You are situated on the left side and want to see the maximum number of buildings sequentially starting from the left that you can see without any building being blocked by a taller building in front of it. A building is blocked if there is any taller building between you and that particular building. Return _the number of buildings you can see_.","solution":"def can_see_buildings(heights): Returns the number of buildings visible sequentially from the left side. count = 0 current_max_height = 0 for height in heights: if height > current_max_height: count += 1 current_max_height = height return count"},{"question":"You are given a list of integers `nums` and an integer `target`. Your goal is to find all the unique triplets in the list which gives the sum of zero when added. To ensure the triplets are unique, the triplets should be sorted in non-descending order and no two triplets should have the same set of numbers. Return all such unique triplets as a list of lists. If there are no such triplets, return an empty list. For example, given `nums = [-1, 0, 1, 2, -1, -4]` and `target = 0`, one possible return is `[[-1, -1, 2], [-1, 0, 1]]`, depending on the order in which the triplets are found. The output lists should not contain duplicate triplets.","solution":"def three_sum(nums, target): Returns a list of unique triplets in the list which gives the sum of zero when added. :param nums: List[int] - list of integers :param target: int - the target sum, usually zero for this problem :return: List[List[int]] - list of unique triplets nums.sort() res = [] for i in range(len(nums) - 2): if i > 0 and nums[i] == nums[i - 1]: continue # skip same element to avoid duplicate triplets l, r = i + 1, len(nums) - 1 while l < r: sum = nums[i] + nums[l] + nums[r] if sum == target: res.append([nums[i], nums[l], nums[r]]) while l < r and nums[l] == nums[l + 1]: l += 1 while l < r and nums[r] == nums[r - 1]: r -= 1 l += 1 r -= 1 elif sum < target: l += 1 else: r -= 1 return res"},{"question":"Given an array of integers `nums`, partition the array into two contiguous subarrays left and right so that: - Every element in left is less than or equal to every element in right. - Both left and right are non-empty. - Left has the smallest possible size to satisfy the required condition. Return _the length of left after the partitioning_.","solution":"def partitionDisjoint(nums): Given an array nums, partition the array into two subarrays left and right such that every element in left is less than or equal to every element in right. Returns the length of left after partitioning. max_left = nums[0] max_seen = nums[0] partition_idx = 0 for i in range(1, len(nums) - 1): max_seen = max(max_seen, nums[i]) if nums[i] < max_left: max_left = max_seen partition_idx = i return partition_idx + 1"},{"question":"Given a matrix `mat` and an integer `target`, return _the position of the element_ in `mat` that is closest to `target`. If there are multiple elements with the same minimum distance to the target, return the position of the one that appears first in reading order (i.e., top to bottom, left to right). If the matrix is empty, return `(-1, -1)`.","solution":"def closest_element_position(mat, target): Returns the position of the element in mat that is closest to target. If multiple elements have the same minimum distance, return the first one in reading order (top to bottom, left to right). If the matrix is empty, return (-1, -1). :param mat: List[List[int]], the input matrix :param target: int, the target value :return: Tuple[int, int], position of the closest element in the matrix if not mat or not mat[0]: return (-1, -1) closest_pos = (-1, -1) min_dist = float(\'inf\') for i in range(len(mat)): for j in range(len(mat[0])): dist = abs(mat[i][j] - target) if dist < min_dist: min_dist = dist closest_pos = (i, j) return closest_pos"},{"question":"You are given an integer array `nums` and two integers `k` and `t`. Write a function to determine if there are two distinct indices `i` and `j` in the array such that `abs(nums[i] - nums[j]) <= t` and `abs(i - j) <= k`. Return `true` if such indices exist, otherwise return `false`.","solution":"def contains_nearby_almost_duplicate(nums, k, t): Determine if there are two distinct indices i and j in the array such that abs(nums[i] - nums[j]) <= t and abs(i - j) <= k. Args: nums: List[int] - List of integers. k: int - Maximum index difference. t: int - Maximum value difference. Returns: bool - True if such indices exist, otherwise False. if t < 0 or k <= 0: return False num_dict = {} for i, num in enumerate(nums): bucket = num // (t + 1) if bucket in num_dict: return True if bucket - 1 in num_dict and abs(num - num_dict[bucket - 1]) <= t: return True if bucket + 1 in num_dict and abs(num - num_dict[bucket + 1]) <= t: return True num_dict[bucket] = num if i >= k: del num_dict[nums[i - k] // (t + 1)] return False"},{"question":"Write a function that receives an array of integers `nums` and an integer `k`, and returns _the maximum sum of a non-empty subarray_ with at most one deletion of an element. A subarray is a contiguous part of an array.","solution":"def maximum_sum_subarray_with_one_deletion(nums, k): Returns the maximum sum of a non-empty subarray with at most one deletion of an element. if not nums: return 0 n = len(nums) if n == 1: return nums[0] # Initialize forward and backward arrays to store maximum subarray sums forward = [0] * n backward = [0] * n # Calculate the maximum sum subarrays ending at each index forward[0] = nums[0] for i in range(1, n): forward[i] = max(nums[i], forward[i - 1] + nums[i]) # Calculate the maximum sum subarrays starting at each index backward[n - 1] = nums[n - 1] for i in range(n - 2, -1, -1): backward[i] = max(nums[i], backward[i + 1] + nums[i]) # Find the maximum sum subarray with at most one deletion max_sum = max(forward) for i in range(1, n - 1): max_sum = max(max_sum, forward[i - 1] + backward[i + 1]) return max_sum"},{"question":"You are given a **0-indexed** integer array `arr` of length `n` and an integer `m`. You can perform the following operation on `arr` at most `m` times: 1. Choose any two elements `arr[i]` and `arr[j]` (where `0 <= i, j < n`), and increase `arr[i]` by 1, while decreasing `arr[j]` by 1. Your goal is to maximize the minimum value in the array `arr` after performing at most `m` operations. Return _the maximum possible minimum value of the array_.","solution":"def maximize_min_value(arr, m): Returns the maximum possible minimum value of the array `arr` after at most `m` operations. n = len(arr) def can_achieve_min_value(min_value): moves_needed = 0 for num in arr: if num < min_value: moves_needed += min_value - num return moves_needed <= m left = min(arr) right = min(arr) + m result = left while left <= right: mid = (left + right) // 2 if can_achieve_min_value(mid): result = mid left = mid + 1 else: right = mid - 1 return result"},{"question":"Given an array of integers `arr` and an integer `k`, return the *kth* smallest element in the array. Note that it is the *kth* smallest element in the sorted order, not the *kth* distinct element. For example, given `arr = [3, 2, 1, 5, 6, 4]` and `k = 2`, the output should be `2`. If `arr = [3, 2, 3, 1, 2, 4, 5, 5, 6]` and `k = 4`, the output should be `3`.","solution":"def kth_smallest(arr, k): Returns the k-th smallest element in the array \'arr\'. arr_sorted = sorted(arr) return arr_sorted[k-1]"},{"question":"You are given a list of `edges` representing the connections between nodes in an undirected graph. Each `edge` is a pair `[u, v]` indicating a connection between node `u` and node `v`. Write a function to detect if there is a cycle in the graph. If a cycle exists, return `true`. Otherwise, return `false`. Each node in the graph is a distinct integer starting from `0`. The graph may also be disconnected.","solution":"def find_parent(parent, i): if parent[i] == -1: return i if parent[i] != -1: return find_parent(parent, parent[i]) def union(parent, x, y): x_set = find_parent(parent, x) y_set = find_parent(parent, y) if x_set != y_set: parent[x_set] = y_set def has_cycle(edges, n): Function to detect cycle in an undirected graph. :param edges: List of edges where each edge is represented as a pair of nodes [u, v]. :param n: Number of nodes in the graph. :return: True if there is a cycle, otherwise False. parent = [-1]*(n) for edge in edges: x = find_parent(parent, edge[0]) y = find_parent(parent, edge[1]) if x == y: return True union(parent, x, y) return False"},{"question":"Given an array of integers `arr` and an integer `k`, partition the array into `k` subsets such that the sum of integers in each subset is maximized. Return _the minimized sum of the largest subset_. You may assume that both the array and `k` are such that a valid partitioning is always possible. For example, given `arr = [1, 2, 3, 4, 5]` and `k = 2`, the partitioning into subsets would be `[[1, 2, 3], [4, 5]]` with subset sums `[6, 9]`. The minimized sum of the largest subset is the smallest possible largest subset sum over all valid partitionings.","solution":"def can_partition(nums, k, max_sum): # This helper function checks if we can partition the array into `k` or fewer parts # so that no part has a sum greater than `max_sum`. current_sum = 0 required_parts = 1 for num in nums: if current_sum + num > max_sum: required_parts += 1 current_sum = num if required_parts > k: return False else: current_sum += num return True def minimized_largest_sum(arr, k): low = max(arr) high = sum(arr) while low < high: mid = (low + high) // 2 if can_partition(arr, k, mid): high = mid else: low = mid + 1 return low"},{"question":"You are given a 2D grid of size `m x n` where each cell represents a coordinate and contains a value representing the cost to enter that cell. Find the minimum cost to travel from the top-left corner of the grid to the bottom-right corner. You can only move right or down from a cell. Return the minimum cost to reach the bottom-right corner.","solution":"def min_cost_path(grid): Given a 2D grid of costs, returns the minimum cost to travel from the top-left corner to the bottom-right corner. :param grid: List[List[int]] - the 2D grid of costs :return: int - the minimum traversal cost if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) dp = [[0] * n for _ in range(m)] dp[0][0] = grid[0][0] # Initialize the first column for i in range(1, m): dp[i][0] = dp[i-1][0] + grid[i][0] # Initialize the first row for j in range(1, n): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill up the dp table for i in range(1, m): for j in range(1, n): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[m-1][n-1]"},{"question":"Given two integers `a` and `b`, return _the greatest common divisor (GCD) of `a` and `b`._ The greatest common divisor of two numbers is the largest positive integer that divides both numbers without leaving a remainder.","solution":"def gcd(a, b): Returns the greatest common divisor (GCD) of a and b using the Euclidean algorithm. while b != 0: a, b = b, a % b return abs(a)"},{"question":"Given a binary tree, return the **right side view** of the tree. The right side view of a binary tree is the set of nodes visible when the tree is viewed from the right side. You may assume that the binary tree follows the below structure: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` Your function should take the root of the binary tree as its argument and return a list of integers representing the values of the nodes visible from the right side.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def right_side_view(root): Returns the right side view of the binary tree rooted at \'root\'. if not root: return [] from collections import deque queue = deque([(root, 0)]) right_view = [] max_level = -1 while queue: node, level = queue.popleft() if level > max_level: right_view.append(node.val) max_level = level if node.right: queue.append((node.right, level + 1)) if node.left: queue.append((node.left, level + 1)) return right_view"},{"question":"You are given a string `s` consisting of lowercase English letters. You are allowed to rearrange the characters of the string. A _consecutive substring_ is defined as any substring where all the characters are the same. Return the maximum number of **consecutive substrings** you can obtain by rearranging the characters of `s`.","solution":"def max_consecutive_substrings(s): Returns the maximum number of consecutive substrings with all the same characters that can be obtained by rearranging the characters of the string s. # Create a dictionary to count occurrences of each character char_count = {} for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # The maximum number of consecutive substrings is the number of unique characters return len(char_count)"},{"question":"You are given an integer array `arr` and an integer `k`. Write a function `findMaximizedCapital` to determine the maximum possible capital that can be obtained by completing at most `k` distinct investments. Each investment `i` has an initial capital requirement `capital[i]` and a profit `profit[i]`. You can start with any initial capital and can perform the investments in any order as long as the total available capital is enough to meet the requirements of the investments. Return the maximum capital achievable after making the maximum number of `k` investments.","solution":"import heapq def findMaximizedCapital(k, W, profits, capital): Determines the maximum possible capital after completing at most `k` investments. Parameters ---------- k : int The maximum number of investments that can be completed. W : int The initial available capital. profits : List[int] The profits from each investment. capital : List[int] The capital requirements for each investment. Returns ------- int The maximum capital achievable after making the investments. investments = [(capital[i], profits[i]) for i in range(len(profits))] investments.sort(key=lambda x: x[0]) max_heap = [] current = 0 for _ in range(k): while current < len(investments) and investments[current][0] <= W: heapq.heappush(max_heap, -investments[current][1]) current += 1 if not max_heap: break W += -heapq.heappop(max_heap) return W"},{"question":"Given an integer array `nums`, return `true` _if the array can be **rearranged** to form a **consecutive sequence of numbers** without any gaps, or_ `false` _otherwise_. A **consecutive sequence** is characterized by each number appearing exactly once, starting from the minimum element in the array and continuing without interruption to the maximum element._","solution":"def can_form_consecutive_sequence(nums): Returns True if the array can be rearranged to form a consecutive sequence of numbers without any gaps. if not nums: return False min_num = min(nums) max_num = max(nums) expected_length = max_num - min_num + 1 return expected_length == len(nums) and len(set(nums)) == len(nums)"},{"question":"A company conducts an annual coding competition where participants solve problems to earn points. The results are given as a list of pairs, where each pair consists of a participant\'s ID and the points they earned in a single problem. Implement the `Leaderboard` class: * `Leaderboard()` initializes the leaderboard with an empty data structure. * `void addScore(int participantId, int score)` updates the leaderboard by adding the given `score` to the participant\'s total points. * `int top(int K)` returns the sum of the top `K` participants\' scores. * `void reset(int participantId)` resets the score of the specified participant to `0`, thereby removing them from the leaderboard. You can assume that `K` is always valid, i.e., `1 <= K <= number of participants`.","solution":"import heapq from collections import defaultdict class Leaderboard: def __init__(self): self.scores = defaultdict(int) def addScore(self, participantId, score): self.scores[participantId] += score def top(self, K): return sum(heapq.nlargest(K, self.scores.values())) def reset(self, participantId): if participantId in self.scores: del self.scores[participantId]"},{"question":"You are given an array of **n** positive integers `arr` and an integer `target`. Your task is to determine if there are exactly two different elements of the array whose product is equal to `target`. Return `True` if such elements exist, otherwise return `False`. Note that the elements of the pair should be at different indices.","solution":"def two_product(arr, target): Determines if there are exactly two different elements in the array whose product is equal to the target. :param arr: List[int] - the list of positive integers :param target: int - the target product :return: bool - True if such elements exist, False otherwise seen = set() for num in arr: if num == 0 and target == 0: continue if target % num == 0: complement = target // num if complement in seen: return True seen.add(num) return False"},{"question":"You are given an integer array `nums`. Write a function that returns the shortest subarray with a sum that is at least `target`. If there is no such subarray, return `0` instead.","solution":"def min_subarray_len(target, nums): n = len(nums) min_len = float(\'inf\') current_sum = 0 left = 0 for right in range(n): current_sum += nums[right] while current_sum >= target: min_len = min(min_len, right - left + 1) current_sum -= nums[left] left += 1 return min_len if min_len != float(\'inf\') else 0"},{"question":"Write a function that takes in a string `s` containing a mix of letters and digits, and shifts all the letters in `s` by a given number `k` positions in the alphabet, wrapping around if necessary (i.e., \'z\' shifted by 1 becomes \'a\'). Digits should remain unchanged. The function should return the transformed string.","solution":"def shift_letters(s, k): Shifts all the letters in the string s by k positions in the alphabet. Digits remain unchanged. Parameters: s (str): The input string containing letters and digits. k (int): The number of positions to shift the letters. Returns: str: The transformed string. def shift_character(c, k): if c.isalpha(): if c.islower(): return chr((ord(c) - ord(\'a\') + k) % 26 + ord(\'a\')) else: return chr((ord(c) - ord(\'A\') + k) % 26 + ord(\'A\')) return c return \'\'.join(shift_character(c, k) for c in s)"},{"question":"Given a string `s` which contains lowercase letters, you need to remove the minimum number of characters from `s` so that the remaining string does not contain any of its characters appearing more than once. Return _the lexicographically smallest string possible after the removal_. **Note**: * The lexicographical order of characters is the order in which they appear in the dictionary. For instance, `\'a\'` comes before `\'b\'`, and so on. * You must retain the relative order of the characters from the original string `s`. For example, given `s = \\"cbacdcbc\\"`, the output should be `\\"acdb\\"` since this is the lexicographically smallest string we can obtain by removing characters so that none repeat.","solution":"def remove_duplicate_letters(s): Returns the lexicographically smallest string that can be obtained by removing characters so that no characters appear more than once. last_occurrence = {ch: idx for idx, ch in enumerate(s)} stack = [] added = set() for idx, ch in enumerate(s): if ch in added: continue while stack and ch < stack[-1] and idx < last_occurrence[stack[-1]]: removed = stack.pop() added.remove(removed) stack.append(ch) added.add(ch) return \'\'.join(stack)"},{"question":"Given a `linked list`, each node containing an integer value, write a function that reorders the list to arrange all nodes with odd indices followed by nodes with even indices. Note that the relative order among odd-index nodes and even-index nodes should be preserved. Return the head of the reordered linked list. For example, given the linked list `1 -> 2 -> 3 -> 4 -> 5`, the function should return the list reordered as `1 -> 3 -> 5 -> 2 -> 4`.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def oddEvenList(head): if not head or not head.next: return head odd = head even = head.next even_head = even while even and even.next: odd.next = even.next odd = odd.next even.next = odd.next even = even.next odd.next = even_head return head"},{"question":"You are given two integer arrays `nums` and `indices` of the same length `n`. For each element in the `indices` array, you need to remove the element from the `nums` array at the corresponding index. Return a new array after all removals have been performed. Note that each element of `nums` is guaranteed to be unique, and each element of `indices` refers to a valid index in `nums` before any removals. The removals should be performed in the order given in the `indices` array.","solution":"def remove_elements(nums, indices): Removes elements from nums at the indices specified in indices list. Parameters: nums (list of int): The array of numbers from which elements will be removed. indices (list of int): The array of indices specifying which elements to remove. Returns: list of int: The array after specified elements have been removed. indices.sort(reverse=True) for index in indices: nums.pop(index) return nums"},{"question":"Given an integer `n`, write a function that returns the **Gray code** sequence of length `2^n`. A Gray code sequence is a sequence of `2^n` integers where: - Each integer is within the range `[0, 2^n - 1]`. - The binary representation of successive integers in the sequence differs by exactly one bit. - The binary representation of the first and last integers in the sequence also differs by exactly one bit. Return _the sequence of integers representing the Gray code_.","solution":"def gray_code(n): Returns the Gray code sequence of length 2^n. result = [] for i in range(1 << n): result.append(i ^ (i >> 1)) return result"},{"question":"You are given an array `heights` where `heights[i]` represents the height of the i-th building. Buildings may receive rainwater, which is trapped between the tallest buildings to their left and right. Write a function that returns _the total amount of rainwater that can be trapped_. The buildings are represented as a stack of 1x1 blocks, and there may be multiple scenarios to consider to get the optimal result. **Note:** The array `heights` will have at least one element and all elements are non-negative integers.","solution":"def trapRainWater(heights): Calculate the total amount of rainwater that can be trapped between the buildings. :param heights: List[int] - an array of building heights :return: int - total amount of trapped rainwater if not heights: return 0 left_max = [0] * len(heights) right_max = [0] * len(heights) water_trapped = 0 # Fill left_max array to store the maximum height to the left of each position left_max[0] = heights[0] for i in range(1, len(heights)): left_max[i] = max(left_max[i-1], heights[i]) # Fill right_max array to store the maximum height to the right of each position right_max[-1] = heights[-1] for i in range(len(heights) - 2, -1, -1): right_max[i] = max(right_max[i+1], heights[i]) # Calculate the water trapped in each position for i in range(len(heights)): water_trapped += min(left_max[i], right_max[i]) - heights[i] return water_trapped"},{"question":"Given two integers `n` and `k`, return the `kth` permutation sequence of the numbers from `1` to `n`. The returned permutation should be in lexicographic order. You can assume `n` will be between 1 and 9 inclusive.","solution":"from math import factorial def get_permutation_sequence(n, k): Returns the kth permutation sequence of the numbers from 1 to n in lexicographic order. numbers = list(range(1, n+1)) k -= 1 # convert to zero-based index permutation = [] for i in range(n, 0, -1): fact = factorial(i - 1) index = k // fact k %= fact permutation.append(numbers.pop(index)) return \'\'.join(map(str, permutation))"},{"question":"Given a string `s` and an array `indices` where `indices[i]` denotes the new position of the character at the `i-th` index in the original string `s`, reconstruct and return the shuffled string. The array `indices` is a permutation of the numbers `0` to `s.length - 1`.","solution":"def shuffle_string(s, indices): Returns the shuffled string based on the given indices. :param s: Original string to shuffle :param indices: List of new positions for each character in the original string :return: Shuffled string shuffled = [\'\'] * len(s) for i, index in enumerate(indices): shuffled[index] = s[i] return \'\'.join(shuffled)"},{"question":"Given a binary tree, write a function `getNodeNumbers(TreeNode root)` that returns an array of size two. The first element of the array should be the count of leaf nodes (nodes with no children) in the tree, and the second element should be the count of internal nodes (nodes that have at least one child). The function signature is provided for clarity: ``` public int[] getNodeNumbers(TreeNode root) ``` Assume TreeNode is defined as: ``` class TreeNode { int val; TreeNode left; TreeNode right; TreeNode(int x) { val = x; } } ``` If the tree is empty (i.e., root is null), return `[0, 0]`.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def getNodeNumbers(root): Returns an array where the first element is the count of leaf nodes and the second element is the count of internal nodes. if not root: return [0, 0] def count_nodes(node): if not node.left and not node.right: return (1, 0) leaves = 0 internals = 1 if node.left: left_leaves, left_internals = count_nodes(node.left) leaves += left_leaves internals += left_internals if node.right: right_leaves, right_internals = count_nodes(node.right) leaves += right_leaves internals += right_internals return (leaves, internals) return list(count_nodes(root))"},{"question":"You are given an array of integers `nums` and an integer `target`. Your goal is to find two distinct indices `i` and `j` in the array such that the sum of `nums[i]` and `nums[j]` is equal to `target`. Return an array containing the indices `i` and `j` in any order. Function Signature: `def two_sum(nums: List[int], target: int) -> List[int]:`","solution":"def two_sum(nums, target): Returns indices of the two numbers such that they add up to the target. :param nums: List[int] - List of integers :param target: int - Target sum :return: List[int] - Indices of the two numbers that add up to target num_to_index = {} for index, num in enumerate(nums): complement = target - num if complement in num_to_index: return [num_to_index[complement], index] num_to_index[num] = index"},{"question":"A string `s` is called a good string if no two consecutive characters are the same. Given a string `s` consisting of lowercase letters, you need to determine the maximum number of good strings that can be obtained by deleting some (possibly none, but not all) characters from `s`. Each good string should be a non-empty subsequence of `s`. Return the maximum number of good strings that can be obtained.","solution":"def max_good_strings(s): Returns the maximum number of good strings (non-empty) that can be obtained by deleting some (possibly none, but not all) characters from s. Each good string is a non-empty subsequence of s. if not s: return 0 count = 1 # Since we always have at least one good string (the string itself if we delete none) for i in range(1, len(s)): if s[i] != s[i-1]: count += 1 return count"},{"question":"Given an array of integers `arr` and an integer `k`, find the _kth smallest element_ in the array. You must solve it with a worst-case time complexity better than O(n^2). Return _the **kth smallest element** in the array._","solution":"def partition(arr, low, high): pivot = arr[high] i = low for j in range(low, high): if arr[j] < pivot: arr[i], arr[j] = arr[j], arr[i] i += 1 arr[i], arr[high] = arr[high], arr[i] return i def quickselect(arr, low, high, k): if low == high: return arr[low] pivot_index = partition(arr, low, high) if k == pivot_index: return arr[k] elif k < pivot_index: return quickselect(arr, low, pivot_index - 1, k) else: return quickselect(arr, pivot_index + 1, high, k) def kth_smallest(arr, k): if k < 1 or k > len(arr): return None return quickselect(arr, 0, len(arr) - 1, k - 1)"},{"question":"Develop a function `int[] rotateArray(int[] nums, int k)` to rotate an array `nums` of size `n` to the right by `k` steps. Example: - Input: `nums = [1,2,3,4,5,6,7]`, `k = 3` - Output: `[5,6,7,1,2,3,4]` The rotation should be done in place with O(1) extra space complexity. Ensure that the function handles cases where `k` is greater than `n`. **Note:** Do not use the built-in array methods to solve this challenge.","solution":"def rotateArray(nums, k): Rotate the array nums to the right by k steps. n = len(nums) k = k % n # In case k is greater than the length of the array def reverse(start, end): while start < end: nums[start], nums[end] = nums[end], nums[start] start += 1 end -= 1 # Reverse the entire array reverse(0, n - 1) # Reverse the first k elements reverse(0, k - 1) # Reverse the remaining n-k elements reverse(k, n - 1) return nums"},{"question":"You are given an array of strings `words` and a string `chars`. A string is considered **formed** by the string `chars` if it can be composed using the letters in `chars`, with each letter from `chars` used at most once. Return the sum of the lengths of all strings in `words` that can be formed by `chars`.","solution":"from collections import Counter def count_chars(words, chars): Returns the sum of the lengths of all strings in words that can be formed by chars. chars_count = Counter(chars) total_length = 0 for word in words: word_count = Counter(word) can_form = True for letter, count in word_count.items(): if chars_count[letter] < count: can_form = False break if can_form: total_length += len(word) return total_length"},{"question":"You are given a string `s` that represents a binary number (consisting only of \'0\'s and \'1\'s) of length `n`. Your goal is to transform the binary number into a string of all \'0\'s. In one move, you can select a substring containing all \'1\'s and flip all the \'1\'s to \'0\'s. You wish to determine the minimum number of moves needed to turn `s` into a string of all \'0\'s. Return the minimum number of moves required.","solution":"def min_moves_to_zero(s): Given a binary string s, determine the minimum number of moves needed to turn the binary string to all \'0\'s. In each move, you can flip all \'1\'s in a contiguous substring to \'0\'s. :param s: str, binary string consisting of \'0\'s and \'1\'s :return: int, minimum number of moves # Count the number of contiguous segments of \'1\'s count = 0 n = len(s) i = 0 while i < n: if s[i] == \'1\': count += 1 while i < n and s[i] == \'1\': i = i + 1 i = i + 1 return count"},{"question":"You are given a string `s` consisting of lowercase letters. You can perform operations on the string by selecting any character and removing it. Return _the length of the **shortest** string you can obtain by performing zero or more operations so that no two adjacent characters are the same_. For example, if you have the string `aab`, you can remove one \'a\' to make it `ab`, which results in no two adjacent characters being the same.","solution":"def min_length_no_adjacent_duplicates(s): Returns the length of the shortest string with no adjacent duplicate characters. if not s: return 0 result = [] for char in s: if result and result[-1] == char: continue result.append(char) return len(result)"},{"question":"You are given a string `s` and an integer `k`. You need to determine whether you can rearrange the characters of the string to form a palindrome with **exactly** `k` distinct characters. If it is possible, return `True`, otherwise return `False`. Note that the palindrome does not necessarily need to use all characters of the string `s`.","solution":"from collections import Counter def can_form_palindrome_with_k_distinct(s, k): Determine if it is possible to rearrange the characters of the string to form a palindrome with exactly k distinct characters. :param s: the input string :param k: the number of distinct characters desired in the palindrome :return: True if such a palindrome can be formed, False otherwise if k > len(s): return False character_count = Counter(s) odd_count = sum(1 for count in character_count.values() if count % 2 != 0) return odd_count <= 1 and len(character_count) >= k"},{"question":"You are tasked with developing a navigation system for a simple robotic vacuum cleaner. The vacuum cleaner operates on a grid with dimensions `m x n`, where each cell in the grid can either be empty or contain an obstacle. The vacuum cleaner can move up, down, left, or right into an empty cell, but cannot move into cells containing obstacles. The vacuum cleaner starts at a specified starting position `(startRow, startCol)` within the grid and its goal is to reach a target position `(targetRow, targetCol)`. You need to implement the `VacuumCleaner` class with the following methods: - `VacuumCleaner(int[][] grid)` Initializes the vacuum cleaner with the provided grid. - `boolean move(int newRow, int newCol)` Moves the vacuum cleaner to the specified position if it is an empty cell and returns `true`. If the move is invalid (i.e., the position is outside the grid boundaries or contains an obstacle), it returns `false`. - `boolean canReachTarget(int targetRow, int targetCol)` Returns `true` if the vacuum cleaner can reach the specified target position from its current position following any sequence of valid moves. Otherwise, returns `false`. Your implementation should handle the constraints of the grid and ensure that the robot can navigate around obstacles to reach its destination if possible.","solution":"class VacuumCleaner: def __init__(self, grid): self.grid = grid self.m = len(grid) self.n = len(grid[0]) self.start_pos = None for i in range(self.m): for j in range(self.n): if grid[i][j] == \'S\': self.start_pos = (i, j) break if self.start_pos: break def move(self, newRow, newCol): if 0 <= newRow < self.m and 0 <= newCol < self.n and self.grid[newRow][newCol] == 0: self.start_pos = (newRow, newCol) return True return False def canReachTarget(self, targetRow, targetCol): def is_valid_move(x, y): return 0 <= x < self.m and 0 <= y < self.n and self.grid[x][y] == 0 and (x, y) not in visited def dfs(x, y): if (x, y) == (targetRow, targetCol): return True visited.add((x, y)) for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: new_x, new_y = x + dx, y + dy if is_valid_move(new_x, new_y) and dfs(new_x, new_y): return True return False visited = set() start_x, start_y = self.start_pos return dfs(start_x, start_y)"},{"question":"Given a binary search tree (BST), write a function to find the **k-th smallest** element in it. You may assume that `k` is always valid, 1 ≤ k ≤ BST\'s total elements. Implement the `KthSmallestInBST` class: * `KthSmallestInBST(TreeNode root)` Initializes the object with the root of the binary search tree `root`. * `int kthSmallest(int k)` Returns the k-th smallest element in the binary search tree.","solution":"# Definition for a binary tree node. class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class KthSmallestInBST: def __init__(self, root: TreeNode): self.root = root def kthSmallest(self, k: int) -> int: def inorder(node): return inorder(node.left) + [node.val] + inorder(node.right) if node else [] in_order_list = inorder(self.root) return in_order_list[k - 1]"},{"question":"Given a binary tree, return _the sum of node values that are located at the **deepest level** of the tree_. If the tree is empty, return `0`. Your function should efficiently navigate through the tree structure to determine the nodes positioned at the deepest level and compute their cumulative value.","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def deepest_leaves_sum(root): Returns the sum of node values that are located at the deepest level of the tree. Args: root (TreeNode): The root of the binary tree. Returns: int: Sum of deepest level node values. if not root: return 0 queue = deque([root]) level_sum = 0 while queue: level_sum = 0 level_length = len(queue) for _ in range(level_length): node = queue.popleft() level_sum += node.val if node.left: queue.append(node.left) if node.right: queue.append(node.right) return level_sum"},{"question":"Given a list of integers `arr`, you are required to implement a class `Solution` which supports two operations: * `Solution(int[] arr)` which initializes the object with the integer list `arr`. * `int findMajority(int k)` which finds and returns the element that appears more than `len(arr) / k` times in the array. If no such element exists, return `-1`. If there are multiple elements that satisfy this condition, return any one of them. Note: You can assume that `k` will always be greater than `1`.","solution":"class Solution: def __init__(self, arr): Initialize the object with the integer list arr. self.arr = arr def findMajority(self, k): Finds and returns the element that appears more than len(arr) / k times in the array arr. If no such element exists, return -1. threshold = len(self.arr) // k frequency = {} # Count the frequency of each element for num in self.arr: if num in frequency: frequency[num] += 1 else: frequency[num] = 1 # Find the majority element based on threshold for num, count in frequency.items(): if count > threshold: return num return -1"},{"question":"You have been offered a job that pays in two different ways: `method1` and `method2`. For `n` days, `method1` provides an array `payments1` where `payments1[i]` indicates the payment for the `i-th` day if you work according to `method1`. Similarly, `method2` provides an array `payments2` where `payments2[i]` indicates the payment for the `i-th` day if you follow `method2`. However, you can only work according to one method throughout all `n` days. Determine which method you should choose to maximize your total earnings over the `n` days, and: * If `method1` provides higher total payment, return `1`. * If `method2` provides higher total payment, return `2`. * If both methods provide the same total payment, return `0`.","solution":"def choose_method(payments1, payments2): Determines which payment method provides higher total earnings over n days. Args: payments1 (list): A list of integers indicating daily payments using method 1 for n days. payments2 (list): A list of integers indicating daily payments using method 2 for n days. Returns: int: 1 if method 1 provides higher total payment, 2 if method 2 provides higher total payment, 0 if both methods provide the same total payment. total1 = sum(payments1) total2 = sum(payments2) if total1 > total2: return 1 elif total2 > total1: return 2 else: return 0"},{"question":"Write a function to perform a basic string compression using the counts of repeated characters. For instance, the string \\"aabcccccaaa\\" would become \\"a2b1c5a3\\". If the \\"compressed\\" string would not become smaller than the original string, your function should return the original string. You can assume the string has only uppercase and lowercase letters (a - z). Implement the function `compress` with the following signature: `def compress(s: str) -> str`.","solution":"def compress(s: str) -> str: Returns the compressed version of the string `s` using the counts of repeated characters. If the compressed string is not smaller than the original, returns the original string. if not s: return s compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: compressed.append(s[i - 1] + str(count)) count = 1 # Append the last set of characters compressed.append(s[-1] + str(count)) compressed_string = \'\'.join(compressed) return compressed_string if len(compressed_string) < len(s) else s"},{"question":"You are given a **0-indexed** string `colors` of length `n` containing the characters \'R\', \'G\', and \'B\'. The string represents the color of the tiles in a row on a floor. You are also given a **0-indexed** integer array `neededTime` of length `n` where `neededTime[i]` is the time (in seconds) that you need to spend to remove the `i-th` tile. In one operation, you can remove any tile. Return _the minimum time required_ such that there are no two adjacent tiles of the same color.","solution":"def minCost(colors, neededTime): n = len(colors) if n == 0: return 0 total_time = 0 i = 0 while i < n - 1: if colors[i] == colors[i + 1]: max_time = neededTime[i] sum_time = neededTime[i] while i < n - 1 and colors[i] == colors[i + 1]: sum_time += neededTime[i + 1] max_time = max(max_time, neededTime[i + 1]) i += 1 total_time += sum_time - max_time i += 1 return total_time"},{"question":"Given a directed, weighted graph represented as an adjacency list, where each node is labeled from `0` to `n-1`, implement an algorithm to find the **shortest path** from a given source node to all other nodes using **Dijkstra\'s algorithm**. The adjacency list is given as an array of `n` lists, where `graph[i]` contains pairs `[j, w]` representing an edge from node `i` to node `j` with weight `w`. Return an array `dist` of length `n` where `dist[i]` is the shortest distance from the source node to node `i`. If there is no path from the source to a node, the distance should be considered as infinity (`float(\'inf\')` in Python).","solution":"import heapq def dijkstra(graph, source): Returns the shortest path from source to all other nodes in the graph using Dijkstra\'s algorithm. :param graph: List[List[Tuple[int, int]]], adjacency list of the graph where graph[i] contains pairs [j, w] representing an edge from node `i` to node `j` with weight `w`. :param source: int, the source node :return: List[float], the shortest distance from the source node to each node. If a node is unreachable, the distance will be float(\'inf\') n = len(graph) dist = [float(\'inf\')] * n dist[source] = 0 priority_queue = [(0, source)] # (distance, node) while priority_queue: current_dist, current_node = heapq.heappop(priority_queue) # If the distance in the priority queue is greater than the known distance, skip processing if current_dist > dist[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_dist + weight # Only consider this new path if it\'s better if distance < dist[neighbor]: dist[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return dist"},{"question":"Write a function to find the maximum number of points you can obtain by bursting balloons. You are given `n` balloons, numbered from `0` to `n-1`. Each balloon is associated with a positive integer value `nums[i]`. When you burst the `i-th` balloon, you will gain points equal to `nums[left] * nums[i] * nums[right]`, where `left` and `right` are the indices of the balloons adjacent to `i`. After the burst, the `left` and `right` balloons become adjacent. You may assume `nums[-1] = nums[n] = 1` if `i` is out of bounds. Implement an algorithm to find the maximum points. Input: `[3, 1, 5, 8]` Output: `167`","solution":"def maxCoins(nums): Find the maximum number of points obtained by bursting balloons. :param nums: List[int] - list of balloon values :return: int - maximum points obtained n = len(nums) nums = [1] + nums + [1] dp = [[0] * (n + 2) for _ in range(n + 2)] for length in range(1, n + 1): for left in range(1, n - length + 2): right = left + length - 1 for k in range(left, right + 1): dp[left][right] = max(dp[left][right], nums[left - 1] * nums[k] * nums[right + 1] + dp[left][k - 1] + dp[k + 1][right]) return dp[1][n]"},{"question":"You are given a string `s` and an array of indices representing the starting position of substrings. The substrings represented by the given indices are all the same length. Your task is to determine the maximum number of these substrings that are identical, and return this maximum count. For example, given the input string \\"ababc\\" and indices `[0, 2]` with a substring length of `2`, the substrings are \\"ab\\" and \\"ab\\", thus the output should be `2`. Return an integer representing the maximum count of identical substrings.","solution":"def max_identical_substrings(s, indices, length): Calculate the maximum count of identical substrings. Parameters: s (str): The given string. indices (list of int): List of starting positions for substrings. length (int): Length of each substring. Returns: int: The maximum count of identical substrings. substring_count = {} for index in indices: substring = s[index:index + length] if substring in substring_count: substring_count[substring] += 1 else: substring_count[substring] = 1 # Return the highest count found among the substrings max_count = max(substring_count.values()) if substring_count else 0 return max_count"},{"question":"You are given an array of integers `heights` representing the heights of buildings in a row. The goal is to remove some buildings such that the array forms a \\"mountain\\". A \\"mountain\\" array is defined as an array that: - Has at least 3 elements. - There exists some index `i` (0-indexed) with `0 < i < heights.length - 1` such that: - `heights[0] < heights[1] < ... < heights[i]` - `heights[i] > heights[i+1] > ... > heights[heights.length - 1]` Return the minimum number of buildings you need to remove to make `heights` a mountain array. If it\'s not possible to form a mountain array, return 0.","solution":"def minimum_removals_to_make_mountain(heights): n = len(heights) if n < 3: return 0 # Longest increasing subsequence ending at each index lis = [1] * n for i in range(1, n): for j in range(i): if heights[i] > heights[j]: lis[i] = max(lis[i], lis[j] + 1) # Longest decreasing subsequence starting from each index lds = [1] * n for i in range(n-2, -1, -1): for j in range(i+1, n): if heights[i] > heights[j]: lds[i] = max(lds[i], lds[j] + 1) max_mountain = 0 for i in range(1, n-1): if lis[i] > 1 and lds[i] > 1: max_mountain = max(max_mountain, lis[i] + lds[i] - 1) if max_mountain < 3: return 0 return n - max_mountain"},{"question":"You are given an array of integers `arr` representing the **heights** of `n` buildings. The buildings are numbered from `0` to `n - 1`. You are also given another integer `k` representing the maximum number of adjacent buildings that can be painted in one operation. You can paint any number of buildings, but each operation increases the total height of any selected group of at most `k` adjacent buildings by 1 unit. Return _the **minimum number of operations** required to ensure that all buildings have the same height._","solution":"def min_operations_to_equal_heights(arr, k): Returns the minimum number of operations required to make all buildings of equal height. # Determine the maximum and minimum heights in the array max_height = max(arr) min_height = min(arr) # Difference in height that needs to be made up height_diff = max_height - min_height # The number of operations required to increase the height of buildings # In each operation, we can increase the height of up to k buildings by 1 unit operations = height_diff // k if height_diff % k != 0: operations += 1 return operations"},{"question":"Given an array of integers `heights` representing the heights of buildings situated in a street, arrange the buildings in such a way that they form a skyline viewed from the street. The goal is to maximize the number of buildings that can be seen from the street. A building `i` of height `heights[i]` can be seen if and only if there is no building `j` with `j < i` and `heights[j] >= heights[i]`. Return the maximum number of buildings that can be seen from the street in such an arrangement. Note that you are allowed to rearrange the buildings in the `heights` array to achieve the desired outcome.","solution":"def max_visible_buildings(heights): Returns the maximum number of buildings that can be seen from the street by arranging the buildings in such a way that maximizes visibility. # Sort the buildings in ascending order to arrange them for maximum visibility heights.sort() return len(heights)"},{"question":"You are given an array of integers `nums` sorted in non-decreasing order, and an integer `target`. Remove all occurrences of `target` from the array. Return the number of elements remaining after removal. Do not allocate extra space for another array, modify the input array in-place with O(1) extra memory.","solution":"def remove_target(nums, target): Removes all occurrences of target from the sorted array nums. Returns the number of elements remaining after removal. Modifies the input array in-place. write_index = 0 for num in nums: if num != target: nums[write_index] = num write_index += 1 return write_index"},{"question":"Given an array of integers `nums` and an integer `target`, return _the **count** of pairs `(i, j)` where `0 <= i < j < nums.length` such that `nums[i] + nums[j]` is **equal** to `target`_. Ensure that each pair is counted only once. For example, given nums = [1, 2, 3, 4, 5] and target = 5, the output should be 2 (pairs: (1, 4) and (2, 3)).","solution":"def count_pairs(nums, target): Returns the count of pairs (i, j) where 0 <= i < j < nums.length such that nums[i] + nums[j] equals target. count = 0 visited_pairs = set() for i in range(len(nums)): for j in range(i + 1, len(nums)): if nums[i] + nums[j] == target and (nums[i], nums[j]) not in visited_pairs: count += 1 visited_pairs.add((nums[i], nums[j])) return count"},{"question":"You need to build a string representation of a **Zig-Zag** pattern from a given string. The string is written in a zig-zag pattern on a given number of rows (for this problem let\'s call it `numRows`), then read line by line. For example, the string \\"PAYPALISHIRING\\" with `numRows` equal to `3` is written as follows: ``` P A H N A P L S I I G Y I R ``` and thus the output would be \\"PAHNAPLSIIGYIR\\". You are given a string `s` and an integer `numRows`. Return _the string formed by reading the characters in each row from top to bottom in a zig-zag pattern_. Note: 1. `numRows` will be greater than or equal to 1. 2. If `numRows` is `1`, then the string will be the same as the input string. [Question 4]:","solution":"def convert(s, numRows): Convert the string \'s\' into a zig-zag pattern on \'numRows\' rows and return the string formed by reading line by line. if numRows <= 1 or numRows >= len(s): return s rows = [\'\'] * min(numRows, len(s)) cur_row = 0 going_down = False for c in s: rows[cur_row] += c if cur_row == 0 or cur_row == numRows - 1: going_down = not going_down cur_row += 1 if going_down else -1 return \'\'.join(rows)"},{"question":"Given a list of non-negative integers `nums`, arrange them such that they form the largest possible number. Note that since the result may be very large, you should return a string representation of the number. For example, given `[3, 30, 34, 5, 9]`, the largest formed number is `\\"9534330\\"`. Given an array of integers `nums`, return the largest number that can be formed by concatenating the integers.","solution":"from typing import List def largest_number(nums: List[int]) -> str: Given a list of non-negative integers, arrange them such that they form the largest possible number. Return the number in string form. import functools def compare(x, y): if x + y > y + x: return -1 elif y + x > x + y: return 1 else: return 0 # Convert all integers to strings nums = list(map(str, nums)) # Sort with custom comparator nums.sort(key=functools.cmp_to_key(compare)) # Edge case: when input is all zeros if nums[0] == \\"0\\": return \\"0\\" # Join the sorted list into one string return \\"\\".join(nums)"},{"question":"You have a list of points on a 2D plane, each represented as a tuple `(x, y)`, with `x` and `y` being integers. There is also a start point `(sx, sy)` and an end point `(ex, ey)`. You need to determine the minimum number of moves required to travel from the start point to the end point, while only being allowed to move to an adjacent point from the given list of points. Two points `(a, b)` and `(c, d)` are considered adjacent if they share the same x-coordinate or y-coordinate, that is, `a == c` or `b == d`. If it is not possible to reach the endpoint, return `-1`.","solution":"from collections import deque, defaultdict def min_moves(points, start, end): Calculates the minimum number of moves required to travel from the start point to the end point. graph = build_graph(points) return bfs(graph, start, end) def build_graph(points): Build graph where each point is a node and there is an edge between nodes if they share the same x or y coordinate. graph = defaultdict(list) x_map = defaultdict(list) # Map x-coordinate to all points with that x y_map = defaultdict(list) # Map y-coordinate to all points with that y for (x, y) in points: x_map[x].append((x, y)) y_map[y].append((x, y)) for x in x_map: for point1 in x_map[x]: for point2 in x_map[x]: if point1 != point2: graph[point1].append(point2) for y in y_map: for point1 in y_map[y]: for point2 in y_map[y]: if point1 != point2: graph[point1].append(point2) return graph def bfs(graph, start, end): Perform BFS to find the shortest path from start to end. if start == end: return 0 queue = deque([(start, 0)]) visited = set() visited.add(start) while queue: current_point, moves = queue.popleft() for neighbor in graph[current_point]: if neighbor == end: return moves + 1 if neighbor not in visited: visited.add(neighbor) queue.append((neighbor, moves + 1)) return -1"},{"question":"You are given a 2D array representing a `maze` where `0` represents an open path and `1` represents a wall. Write a function to determine if there is a path from the starting point (0, 0) to the destination (n-1, m-1). The path can only be constructed by moving left, right, up, and down. Return a boolean value indicating whether such a path exists. Assume the maze dimensions will be such that the starting and ending points are always within the array.","solution":"def is_path_exist(maze): Determines if there is a path from the top-left corner to the bottom-right corner of a maze. :param maze: List[List[int]] - 2D array representing the maze where 0 is an open path and 1 is a wall. :return: bool - True if a path exists, otherwise False. if not maze or not maze[0] or maze[0][0] != 0 or maze[-1][-1] != 0: return False def dfs(x, y): if not (0 <= x < len(maze)) or not (0 <= y < len(maze[0])) or maze[x][y] == 1: return False if (x, y) == (len(maze) - 1, len(maze[0]) - 1): return True maze[x][y] = 1 # mark as visited return dfs(x + 1, y) or dfs(x - 1, y) or dfs(x, y + 1) or dfs(x, y - 1) return dfs(0, 0)"},{"question":"Given an integer array `nums`, implement a function called `findLongestSubsequence` that finds the length of the longest subsequence such that all elements of the subsequence are sorted in strictly increasing order. You need to optimize the function to handle arrays with up to `10^4` elements efficiently. The function should return the length of the longest increasing subsequence.","solution":"import bisect def findLongestSubsequence(nums): Returns the length of the longest strictly increasing subsequence in nums. if not nums: return 0 lis = [] for num in nums: pos = bisect.bisect_left(lis, num) if pos == len(lis): lis.append(num) else: lis[pos] = num return len(lis)"},{"question":"Given an integer array `arr` of length `n`, return `true` if there exists an element `x` in `arr` such that both `x + 1` and `x - 1` are also present in `arr`, or `false` otherwise. The array may contain both positive and negative integers, and duplicates are allowed. For example, given the array `[5, 3, 4, 7, 2]`, the function should return `true` because the element `3` has both `4` and `2` in the array. If the array is `[1, 5, 2, 9]`, the function should return `false` because no element has both the next and the previous values within the array as required.","solution":"def has_x_plus_and_minus(arr): Returns True if there exists an element x in arr such that both x + 1 and x - 1 are also in arr, otherwise returns False. arr_set = set(arr) for x in arr: if (x + 1) in arr_set and (x - 1) in arr_set: return True return False"},{"question":"Given an integer array `arr`, find the maximum length of a subarray with equal number of 0s and 1s. Return _the length of the longest subarray that contains an equal number of 0s and 1s_.","solution":"def findMaxLength(nums): Find the maximum length of a subarray with equal number of 0s and 1s. count_map = {0: -1} # Initialize the count map with an initial count of 0 at index -1 max_length = 0 count = 0 for i, num in enumerate(nums): count = count + 1 if num == 1 else count - 1 if count in count_map: max_length = max(max_length, i - count_map[count]) else: count_map[count] = i return max_length"},{"question":"You have a sorted array of distinct integers `arr` and an integer `k`. Return _the **kth** smallest element in the sorted array that is **not** present in the array_. For example, if the array is `[1, 3]` and `k` is `1`, the output should be `2`, as `2` is the smallest element not present in the given array.","solution":"def find_kth_missing(arr, k): Find the kth smallest element missing from the sorted array of distinct integers arr. :param arr: List of distinct integers sorted in aascending order. :param k: Integer representing the kth missing element to find. :return: The kth smallest missing element. missing_count = 0 current = 1 i = 0 while True: if i < len(arr) and arr[i] == current: i += 1 else: missing_count += 1 if missing_count == k: return current current += 1"},{"question":"Given an array of integers representing the integers in a circular arrangement, return the maximum length of a contiguous subarray that sums up to a given target `k`. The subarray can wrap around the ends of the array. If no such subarray exists, return -1. _For example, given the array `[3, 1, 2, 1, 1, 3]` and target `6`, the longest subarray that sums to `6` could be `[3, 1, 2]` or `[2, 1, 1, 1, 1]`, both with length 3._","solution":"def max_subarray_len_circular(arr, k): Returns the maximum length of a contiguous subarray that sums up to a given target `k` in a circular array. If no such subarray exists, returns -1. n = len(arr) max_len = -1 def subarray_sum(arr, k): curr_sum = 0 sum_dict = {0: -1} max_len = -1 for i in range(len(arr)): curr_sum += arr[i] if (curr_sum - k) in sum_dict: max_len = max(max_len, i - sum_dict[curr_sum - k]) if curr_sum not in sum_dict: sum_dict[curr_sum] = i return max_len # Check the normal array once max_len = max(max_len, subarray_sum(arr, k)) # Check the circular part total_sum = sum(arr) if total_sum >= k: inv_k = total_sum - k inv_subarray_len = subarray_sum([-x for x in arr], inv_k) if inv_subarray_len != -1: max_len = max(max_len, n - inv_subarray_len) return max_len"},{"question":"There are `n` people standing in a circle and they are numbered from `1` to `n` in clockwise order. A counting-out game progresses in steps. During each step, the person at the current starting point counts out `k-1` people (including themselves), so the `k-th` person is removed from the circle and the person immediately clockwise from them becomes the new starting point. This process is repeated until only one person remains. Given two integers `n` and `k`, return the position (1-based index) of the last remaining person in the circle.","solution":"def last_remaining(n, k): Returns the position (1-based index) of the last remaining person in the circle. result = 0 for i in range(2, n + 1): result = (result + k) % i return result + 1"},{"question":"Given an array of integers `heights` representing the height of buildings and an integer `k`, find _the maximum number of buildings you can paint such that the absolute difference in heights between any two adjacent painted buildings is less than or equal to `k`_. Return the number of buildings you can paint.","solution":"def maxPaintedBuildings(heights, k): n = len(heights) if n <= 1: return n dp = [1] * n for i in range(1, n): if abs(heights[i] - heights[i - 1]) <= k: dp[i] = dp[i - 1] + 1 else: dp[i] = 1 return max(dp)"},{"question":"Given a 2D grid of characters, return the number of distinct connected components of characters that are the same. Two characters are considered connected if they are adjacent horizontally or vertically (not diagonally) and have the same character value. Implement the function `int numDistinctComponents(char[][] grid)` which returns the number of distinct connected components in the grid.","solution":"def numDistinctComponents(grid): Returns the number of distinct connected components of same characters in a 2D grid. if not grid or not grid[0]: return 0 nrows = len(grid) ncols = len(grid[0]) visited = [[False] * ncols for _ in range(nrows)] def dfs(r, c, character): if r < 0 or r >= nrows or c < 0 or c >= ncols or visited[r][c] or grid[r][c] != character: return visited[r][c] = True directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] for dr, dc in directions: dfs(r + dr, c + dc, character) component_count = 0 for row in range(nrows): for col in range(ncols): if not visited[row][col]: component_count += 1 dfs(row, col, grid[row][col]) return component_count"},{"question":"You have an infinite number of buckets, and each bucket is either full of red, green, or blue balls. You were given two integer arrays `needed` and `found`, each of length 3, where: * `needed[0]` is the count of red balls you need, `needed[1]` is the count of green balls you need, and `needed[2]` is the count of blue balls you need. * `found[0]` is the count of red balls you have, `found[1]` is the count of green balls you have, and `found[2]` is the count of blue balls you have. Implement a function: * `bool canCollectAllBalls(int[] needed, int[] found)` This function should return `true` if you have at least as many balls of each color as you need, and `false` otherwise.","solution":"def canCollectAllBalls(needed, found): Returns True if the number of balls found is at least as many as needed for each color. Otherwise, returns False. # Check if the number of balls found for each color meets or exceeds the number needed for i in range(3): if found[i] < needed[i]: return False return True"},{"question":"Given a string `s`, your task is to determine if it contains a **valid parenthesis sequence**. A string is considered a valid parenthesis sequence if every opening parenthesis \'(\' has a corresponding closing parenthesis \')\', and the pairs of parentheses are properly nested. For example: - `\\"()\\"` is a valid parenthesis sequence. - `\\"(()(()))\\"` is a valid parenthesis sequence. - `\\"(()\\"` is not a valid parenthesis sequence. - `\\")(\\"` is not a valid parenthesis sequence. Write a function that takes a string `s` as input and returns `true` if it is a valid parenthesis sequence and `false` otherwise.","solution":"def is_valid_parenthesis_sequence(s): Determines if a given string s is a valid parenthesis sequence. A string is considered a valid parenthesis sequence if every opening parenthesis \'(\' has a corresponding closing parenthesis \')\', and the pairs of parentheses are properly nested. Parameters: s (str): The input string containing parentheses. Returns: bool: True if the string is a valid parenthesis sequence, False otherwise. stack = [] for char in s: if char == \'(\': stack.append(\'(\') elif char == \')\': if stack and stack[-1] == \'(\': stack.pop() else: return False return len(stack) == 0"},{"question":"You are given a string `s` consisting of lowercase English letters and an integer `k`. You want to split the string into exactly `k` non-empty substrings such that the maximum number of distinct characters in a single substring is minimized. Return the minimized value of the maximum number of distinct characters in any substring after the split.","solution":"def split_string_minimize_max_distinct_chars(s, k): Splits the string s into exactly k non-empty substrings such that the maximum number of distinct characters in a single substring is minimized. Returns the minimized value of this maximum number. def can_split_with_max_distinct_chars(max_distinct): Helper function to check if we can split the string into k parts with each part having at most max_distinct distinct characters count = 0 used_chars = set() for char in s: used_chars.add(char) if len(used_chars) > max_distinct: count += 1 used_chars = {char} count += 1 # for the last group return count <= k left, right = 1, len(set(s)) result = right while left <= right: mid = (left + right) // 2 if can_split_with_max_distinct_chars(mid): result = mid right = mid - 1 else: left = mid + 1 return result"},{"question":"Given two integers `n` and `k`, your task is to construct a permutation of the numbers from `1` to `n` in which the absolute difference between any two adjacent elements is at most `k`. Return _any permutation that satisfies the condition_, or an empty array if no such permutation exists.","solution":"def construct_permutation(n, k): Constructs a permutation of numbers from 1 to n where the absolute difference between any two adjacent elements is at most k. Returns the permutation or an empty list if no such permutation exists. if k < 1 or k >= n: return [] permutation = [] for i in range(1, n+1): permutation.append(i) return permutation"},{"question":"You are given a string `s` consisting of lowercase English letters. A character in `s` can be **removed** if it contributes to the string being balanced. A string is considered **balanced** if the number of occurrences of each character is even. You are allowed to remove **at most one character** from `s`. Determine if it is possible to make the string balanced by performing at most one removal. Return `true` if the string can be balanced this way, and `false` otherwise.","solution":"def can_be_balanced(s): from collections import Counter count = Counter(s) num_odds = sum(1 for char_count in count.values() if char_count % 2 != 0) return num_odds <= 1 # Example usage # print(can_be_balanced(\\"aabbcc\\")) # Expected Output: True # print(can_be_balanced(\\"aaabbbccc\\")) # Expected Output: False # print(can_be_balanced(\\"aabbccdde\\")) # Expected Output: True # print(can_be_balanced(\\"a\\")) # Expected Output: True"},{"question":"You are given a list of `n` integers `nums` and an integer `k`. A **continuous subarray** is a sequence of consecutive elements from the array. The task is to find the total number of continuous subarrays whose sum equals to `k`. Return _the number of continuous subarrays that sum to_ `k`. **Note:** The integers in the array can be negative, zero, or positive. The implementation should consider cases with large input sizes efficiently.","solution":"def subarray_sum(nums, k): Finds the number of continuous subarrays whose sum equals k. :param nums: List of integers :param k: Target sum :return: Number of subarrays that sum to k # Dictionary to store (prefix_sum : count of occurrences) prefix_sum_counts = {0: 1} count = 0 current_sum = 0 for num in nums: current_sum += num # Check if there is a prefix sum that when subtracted results in k if (current_sum - k) in prefix_sum_counts: count += prefix_sum_counts[current_sum - k] # Update the prefix sum counts if current_sum in prefix_sum_counts: prefix_sum_counts[current_sum] += 1 else: prefix_sum_counts[current_sum] = 1 return count"},{"question":"You are given a string `code` which represents a series of nested lists constructed using the characters `\'[\'` and `\']\'`. Each `[` signifies the start of a new sublist, and each `]` signifies the end of a sublist. The string `code` is guaranteed to be a valid nested list representation. Your task is to determine the **maximum nesting depth** of the lists and sublists in the given string. For example, if `code = \\"[[[]]]\\"`, the maximum nesting depth is `3`. Return _the maximum nesting depth of the nested lists_. **Note:** A list or sublist containing no further nested lists has a depth of `1`.","solution":"def max_nesting_depth(code: str) -> int: Returns the maximum nesting depth of the given nested list string. max_depth = 0 current_depth = 0 for char in code: if char == \'[\': current_depth += 1 max_depth = max(max_depth, current_depth) elif char == \']\': current_depth -= 1 return max_depth"},{"question":"You are given a string `text` and an integer array `numCodes` where `numCodes[i]` represents the number of times the `i-th` character from \'a\' to \'z\' can be used to form a new string. Return the _lexicographically smallest string_ that can be formed using the characters according to the given `numCodes`. If it is not possible to create any valid string, return an empty string. The resulting string should use exactly the number of characters given in `numCodes` without exceeding the specified counts.","solution":"def smallest_lexicographical_string(numCodes): Returns the lexicographically smallest string that can be formed using the characters according to `numCodes`, where `numCodes[i]` represents the number of times the i-th character from \'a\' to \'z\' can be used. :param numCodes: List of integers :return: Lexicographically smallest string or an empty string if not possible result = [] for i in range(26): result.append(chr(97 + i) * numCodes[i]) # chr(97) is \'a\', chr(98) is \'b\', etc. return \'\'.join(result)"},{"question":"Given a 2D grid of size `m x n` representing an **obstacle course**, where obstacles are represented by a `1` and empty spaces by a `0`, find the shortest path from the top-left corner to the bottom-right corner. You can move up, down, left, or right but cannot move into an obstacle. The path may **not** revisit any cell unless other paths are found to be longer or equal in length. If a path does not exist, return -1. Return the length of the shortest path if it exists.","solution":"from collections import deque def shortest_path_obstacle_course(grid): Returns the length of the shortest path from the top-left to the bottom-right in a 2D grid obstacle course condition. Returns -1 if no such path exists. if not grid or grid[0][0] == 1 or grid[-1][-1] == 1: return -1 rows, cols = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 0)]) # (row, column, distance) visited = set((0, 0)) while queue: r, c, dist = queue.popleft() if r == rows - 1 and c == cols - 1: return dist for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < rows and 0 <= nc < cols and (nr, nc) not in visited and grid[nr][nc] == 0: queue.append((nr, nc, dist + 1)) visited.add((nr, nc)) return -1"},{"question":"Given a string `str` containing only lowercase alphabets, you need to determine if `str` is a valid **palindrome permutation**. A **palindrome permutation** is a string that can be rearranged to form a palindrome. Return `true` if `str` is a valid palindrome permutation and `false` otherwise. A palindrome is a word that reads the same backward as forward.","solution":"def is_palindrome_permutation(s): Determine if a string is a valid palindrome permutation. :param s: String containing only lowercase alphabets. :return: True if the string is a valid palindrome permutation, False otherwise. from collections import Counter # Count the frequency of each character char_counts = Counter(s) # Determine how many characters have an odd count odd_count = sum(1 for count in char_counts.values() if count % 2 != 0) # A valid palindrome permutation can have at most one character with an odd count return odd_count <= 1"},{"question":"Given a string `s` containing alphanumeric characters and a non-negative integer `n`, find the **n-th lexicographically smallest** substring of `s`. If there are fewer than `n` substrings, return _an **empty string**_ `\\" \\"`. Note that substrings are considered distinct if their starting or ending indices differ, and the comparison is case-sensitive (i.e., uppercase letters are considered smaller than lowercase ones).","solution":"def nth_lexicographical_substring(s, n): Returns the n-th lexicographically smallest substring of s. If there are fewer than n substrings, returns an empty string \\" \\". substrings = set() # Generate substrings and add to set to ensure uniqueness for i in range(len(s)): for j in range(i + 1, len(s) + 1): substrings.add(s[i:j]) # Sort substrings lexicographically sorted_substrings = sorted(substrings) # Return the n-th lexicographically smallest substring if it exists return sorted_substrings[n - 1] if n <= len(sorted_substrings) else \\" \\""},{"question":"Given an integer array `nums` and an integer `k`, you need to find the `k` most frequent elements in the array and return them in any order. Your solution should be optimized for performance, considering both time and space complexities.","solution":"from collections import Counter import heapq def top_k_frequent(nums, k): Returns the k most frequent elements in the array nums. if not nums or k <= 0: return [] count = Counter(nums) return [item for item, _ in heapq.nlargest(k, count.items(), key=lambda x: x[1])]"},{"question":"Given a string `arr` consisting of parentheses (`\'(\'` and `\')\'`), compute the minimum number of parentheses that need to be removed to make the string valid. A string is considered valid if the parentheses are properly matched. For example, in the string `\\"()())()\\"`, removing the parenthesis at index 4 results in the string `\\"()()()\\"`, which is valid.","solution":"def min_removals_to_make_valid(arr): Computes the minimum number of parentheses that need to be removed to make the string valid. Parameters: arr (str): A string consisting of parentheses (\'(\' and \')\'). Returns: int: The minimum number of removals required to make the string valid. # Initialization of required variables balance = 0 # Balance between \'(\' and \')\' removals = 0 # Minimum removals required to balance the string # Iterate through the characters in the string for char in arr: if char == \'(\': balance += 1 # Increment balance for open parenthesis elif char == \')\': if balance == 0: # If balance is 0 and we encounter a closing parenthesis, # it means it\'s an unmatched closing parenthesis. removals += 1 else: # If there\'s already an open parenthesis to match with, # decrement the balance. balance -= 1 # Sum of unmatched open and closing parentheses is the result return removals + balance"},{"question":"You are given an array of integers `nums` and a non-negative integer `d`. Your task is to find the number of pairs `(i, j)` where `i < j` such that `nums[j] - nums[i] == d`. Return the count of such pairs.","solution":"def count_pairs(nums, d): Returns the number of pairs (i, j) where i < j such that nums[j] - nums[i] == d. :param nums: List of integers. :param d: A non-negative integer. :return: Count of such pairs. count = 0 n = len(nums) for i in range(n): for j in range(i+1, n): if nums[j] - nums[i] == d: count += 1 return count"},{"question":"Given an array of positive integers, `arr`, and an integer `k`, where `k` is an index in the array, rotate the array to the right by `k` steps. For example, if `arr` is `[1, 2, 3, 4, 5, 6, 7]` and `k` is `3`, the array should be rotated to `[5, 6, 7, 1, 2, 3, 4]`. Return the modified array after `k` rotations.","solution":"def rotate_array(arr, k): Rotates the array to the right by k steps. Args: arr (list): A list of positive integers. k (int): The number of steps to rotate the array. Returns: list: The rotated array. n = len(arr) k = k % n # handle cases where k is greater than the array length return arr[-k:] + arr[:-k]"},{"question":"You are given an array `prices` where `prices[i]` is the price of a given stock on the `i-th` day. You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock. Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return `0`. You must solve this in `O(n)` time complexity.","solution":"def max_profit(prices): Returns the maximum profit that can be achieved from buying and selling on different days. If no profit can be achieved, returns 0. :param prices: List of stock prices. :type prices: List[int] :return: Maximum profit. :rtype: int # Base case: If the prices list is empty or contains only one element, no profit can be made if not prices or len(prices) < 2: return 0 min_price = prices[0] # Initialize with the first price max_profit = 0 # Initialize max profit to 0 # Iterate over the prices starting from the second element for price in prices[1:]: # Calculate the potential profit for the current price profit = price - min_price # Update the max profit if the current profit is higher if profit > max_profit: max_profit = profit # Update the min price if the current price is lower if price < min_price: min_price = price return max_profit"},{"question":"You are given a list of integers `nums`. A subarray is a contiguous part of an array. Return the length of the longest subarray where the difference between the maximum and minimum elements is less than or equal to `k`.","solution":"from collections import deque def longest_subarray_with_diff(nums, k): Returns the length of the longest subarray where the difference between the maximum and minimum elements is less than or equal to k. if not nums: return 0 max_deque, min_deque = deque(), deque() left = 0 max_length = 0 for right, num in enumerate(nums): while max_deque and nums[max_deque[-1]] <= num: max_deque.pop() max_deque.append(right) while min_deque and nums[min_deque[-1]] >= num: min_deque.pop() min_deque.append(right) while nums[max_deque[0]] - nums[min_deque[0]] > k: left += 1 if max_deque[0] < left: max_deque.popleft() if min_deque[0] < left: min_deque.popleft() max_length = max(max_length, right - left + 1) return max_length"},{"question":"Given a list of integers `rooms` where each integer represents the number of keys in a room, and an array `keys` of arrays, where `keys[i]` contains the keys present in room `i`, determine if you can visit all rooms starting from room `0`. Each key in a room `keys[i][j]` corresponds to a room index that you can visit. Return _a boolean indicating whether all rooms can be visited or not_.","solution":"def can_visit_all_rooms(rooms): Determine if all rooms can be visited starting from room 0. Parameters: rooms (List[List[int]]): A list of lists where each sublist represents the keys present in a room. Returns: bool: True if all rooms can be visited, False otherwise. visited = [False] * len(rooms) stack = [0] while stack: room = stack.pop() if not visited[room]: visited[room] = True stack.extend(keys for keys in rooms[room] if not visited[keys]) return all(visited)"},{"question":"You are given an `n x n` 2D matrix `grid` representing an image where each cell can have a value of 0 or 1. A `1` in the matrix represents a part of an object, and a `0` represents empty space. Your task is to find the **largest square** containing only 1\'s and return the area of that square. You need to write a function that takes this grid as an input and returns the area of the largest square that can be formed with only 1\'s in it. The area is defined as the number of 1\'s in the square. Complete the function so that it implements the most efficient solution possible given the constraints of the problem. Example: Input: ``` grid = [ [1, 0, 1, 0, 0], [1, 0, 1, 1, 1], [1, 1, 1, 1, 1], [1, 0, 0, 1, 0] ] ``` Output: ``` 4 ``` (Note: The largest square with only 1\'s has an area of 2x2 = 4.)","solution":"def maximal_square_area(grid): if not grid or not grid[0]: return 0 rows, cols = len(grid), len(grid[0]) dp = [[0] * cols for _ in range(rows)] max_side = 0 for i in range(rows): for j in range(cols): if grid[i][j] == 1: if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side = max(max_side, dp[i][j]) return max_side * max_side"},{"question":"You are given a string `s` that represents a mathematical expression in Reverse Polish Notation. Evaluate the expression and return its result. The valid operators are `+`, `-`, `*`, and `/`. Each operand may be an integer or another expression. Note that division between two integers should truncate toward zero. For example, given the Reverse Polish Notation `s = \\"2 1 + 3 *\\"`, the result is 9. Given the string `s`, return _the result of evaluating the RPN expression_.","solution":"def evalRPN(s): Evaluates an expression in Reverse Polish Notation (RPN) and returns the result. Args: - s (str): A string containing the RPN expression. Returns: - int: The result of the evaluated RPN expression. tokens = s.split() stack = [] for token in tokens: if token in \\"+-*/\\": b = stack.pop() a = stack.pop() if token == \'+\': stack.append(a + b) elif token == \'-\': stack.append(a - b) elif token == \'*\': stack.append(a * b) elif token == \'/\': stack.append(int(a / b)) else: stack.append(int(token)) return stack[0]"},{"question":"Given an array `points` where `points[i] = [xi, yi]` represents the coordinates of a point on a 2D plane, return the number of **rectangles** that can be formed using these points as vertices. A rectangle is defined as a quadrilateral with four right angles, and edges parallel to the x and y axes. # Notes: - Two points `A(xa, ya)` and `B(xb, yb)` are said to be at the same x-coordinate if `xa = xb`, and similarly for the y-coordinate. - A rectangle can only be formed if it is axis-aligned (sides are parallel to the x or y axis).","solution":"def count_rectangles(points): Count the number of rectangles that can be formed using given points on a 2D plane. Rectangles must be axis-aligned. :param points: List of [x, y] coordinates :return: Number of rectangles that can be formed from collections import defaultdict # Dictionary to maintain a set of all y-coordinates for every x-coordinate x_dict = defaultdict(set) # Fill the dictionary for x, y in points: x_dict[x].add(y) count = 0 # List of all x coordinates sorted x_keys = sorted(x_dict.keys()) n = len(x_keys) # Iterate over pairs of x-coordinates for i in range(n): for j in range(i + 1, n): x1, x2 = x_keys[i], x_keys[j] # Find the common y-coordinates between vertical lines (x1, y) and (x2, y) common_y = x_dict[x1].intersection(x_dict[x2]) # If there are at least two common y-coordinates, calculate combinations if len(common_y) >= 2: # Number of ways to pick 2 out of len(common_y) num_y = len(common_y) count += (num_y * (num_y - 1)) // 2 return count"},{"question":"You are given a string `s` consisting of lowercase English letters. The string can be split into non-overlapping substrings where each substring is the largest possible segment of consecutive identical characters. Calcuate the number of such substrings. Return the _maximum_ number of substrings the given string `s` can be split into. For example, the string `\\"aaabb\\"` The function should return `3` because it can be split into [\\"aaa\\", \\"bb\\"].","solution":"def max_number_of_substrings(s): if not s: return 0 count = 1 for i in range(1, len(s)): if s[i] != s[i-1]: count += 1 return count"},{"question":"You are given a set of `n` points on a 2D plane represented as an array `points` of size `n x 2`, where `points[i] = [xi, yi]` is the coordinate of the `i`-th point. You need to find the pair of points that are the closest to each other and return the Euclidean distance between them. The Euclidean distance between two points `(x1, y1)` and `(x2, y2)` is given by the formula: [ sqrt{(x2 - x1)^2 + (y2 - y1)^2} ] It is guaranteed that there is exactly one pair of points with the minimum distance.","solution":"import math def euclidean_distance(point1, point2): Calculate the Euclidean distance between two points in 2D space. x1, y1 = point1 x2, y2 = point2 return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2) def find_closest_pair(points): Find the closest pair of points in the given list and return the Euclidean distance between them. min_distance = float(\'inf\') closest_pair = None n = len(points) for i in range(n): for j in range(i + 1, n): distance = euclidean_distance(points[i], points[j]) if distance < min_distance: min_distance = distance closest_pair = (points[i], points[j]) return min_distance # Example usage: # points = [[1, 2], [2, 3], [4, 5]] # print(find_closest_pair(points)) # Would print the smallest Euclidean distance between any two points in the list"},{"question":"You are given a grid `matrix` representing a field of strawberries, where each element is either `\'S\'` (representing a strawberry plant) or `\'.\'` (representing an empty spot). Your task is to determine the maximum number of strawberries that can be collected in a single row or column by drawing a single straight line across the grid. The line can be either horizontal or vertical. Return _the maximum number of strawberries that can be collected by such a line._","solution":"def max_strawberries(matrix): Returns the maximum number of strawberries that can be collected by drawing a single straight line horizontally or vertically. :param matrix: List[List[str]] - the grid representing the field :return: int - the maximum number of strawberries that can be collected if not matrix or not matrix[0]: return 0 max_strawberries = 0 # Check rows for row in matrix: max_strawberries = max(max_strawberries, row.count(\'S\')) # Check columns for col in range(len(matrix[0])): col_count = sum(matrix[row][col] == \'S\' for row in range(len(matrix))) max_strawberries = max(max_strawberries, col_count) return max_strawberries"},{"question":"You are given a list of integers representing the cost of items. Your goal is to maximize the number of unique items you can buy with a budget `B`. Implement the function: ```python def max_items(costs: List[int], B: int) -> int: ``` The function takes two arguments: - `costs`: A list of integers where each integer represents the cost of an item. - `B`: An integer representing the budget you have to spend. The function should return an integer representing the maximum number of unique items you can buy without exceeding the budget `B`. You can assume all costs are positive integers.","solution":"from typing import List def max_items(costs: List[int], B: int) -> int: Returns the maximum number of unique items that can be bought with a given budget B. Arguments: costs -- list of integers, where each integer represents the cost of an item B -- an integer representing the budget Returns: The maximum number of unique items that can be bought without exceeding the budget B. costs.sort() total_cost = 0 items_bought = 0 for cost in costs: if total_cost + cost <= B: total_cost += cost items_bought += 1 else: break return items_bought"},{"question":"You are given an integer array `heights` representing the heights of `n` buildings, where `heights[i]` is the height of the `i-th` building. You are also given an integer `bricks` representing the number of bricks you have, and an integer `ladders` representing the number of ladders you have. You need to reach the last building in the array by jumping from one building to the next according to the following rules: 1. If the height of the next building is less than or equal to the current building, you can move to the next building without using any resources. 2. If the height of the next building is greater than the current building, you can use one ladder or some bricks to bridge the difference in height. One ladder can be used to bridge any height difference, and one brick can be used to bridge a unit height difference. Return the maximum number of buildings you can reach given the `bricks` and `ladders` you have.","solution":"import heapq def furthest_building(heights, bricks, ladders): Returns the furthest building index one can reach given the heights, bricks, and ladders. min_heap = [] total_bricks_used = 0 for i in range(len(heights) - 1): climb = heights[i + 1] - heights[i] if climb > 0: heapq.heappush(min_heap, climb) if len(min_heap) <= ladders: continue else: total_bricks_used += heapq.heappop(min_heap) if total_bricks_used > bricks: return i return len(heights) - 1"},{"question":"You are given an unsorted array of integers. Write a function to find a pair of integers in the array such that their sum is equal to a given target number. If such a pair exists, return the indices of the two numbers. If no such pair exists, return an empty list. **Note**: Each input would have exactly one solution, and you may not use the same element twice.","solution":"def find_pair_with_sum(nums, target): Finds a pair of integers in the provided list such that their sum is equal to the target number. Returns the indices of the two numbers if such a pair exists, otherwise returns an empty list. num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return [num_to_index[complement], i] num_to_index[num] = i return []"},{"question":"Given an array of integers `nums` and an integer `k`, return the number of unique k-length subarrays whose sum is less than or equal to a given integer `target`. A subarray is a contiguous non-empty sequence of elements within an array.","solution":"def count_subarrays(nums, k, target): Returns the number of unique k-length subarrays whose sum is less than or equal to target. count = 0 for i in range(len(nums) - k + 1): subarray = nums[i:i + k] if sum(subarray) <= target: count += 1 return count"},{"question":"You are given an array of strings `words` where each string consists of lowercase English letters and each word is unique. A word `W` is considered to be \'special\' if it contains all the vowels `a`, `e`, `i`, `o`, `u` at least once. Write a function that returns the total count of \'special\' words in the `words` array.","solution":"def is_special(word): Checks if the word contains all the vowels \'a\', \'e\', \'i\', \'o\', \'u\' at least once. required_vowels = set(\'aeiou\') return required_vowels.issubset(set(word)) def count_special_words(words): Returns the count of \'special\' words in the words array. A word is considered \'special\' if it contains all the vowels: \'a\', \'e\', \'i\', \'o\', \'u\'. return sum(1 for word in words if is_special(word))"},{"question":"Given a social network graph represented as an adjacency list `graph` where each node in the graph represents a user and the edges represent friendships between users, write a function to return the list of users who have exactly `k` friends. The users should be returned in ascending order of their user IDs. If no users have exactly `k` friends, return an empty list. The adjacency list `graph[i]` contains a list of user IDs representing the friends of the `i-th` user. Note: The graph is undirected, meaning if user `i` is friends with user `j`, then `j` is also friends with `i`.","solution":"def users_with_exact_k_friends(graph, k): Returns a list of users who have exactly k friends. The users are returned in ascending order of their user IDs. :param graph: List of lists where each sublist represents the friends of a user :param k: Number of friends to match :return: List of user IDs with exactly k friends sorted in ascending order users = [] for user, friends in enumerate(graph): if len(friends) == k: users.append(user) return sorted(users)"},{"question":"A company is trying to optimize the performance of their network by minimizing the total communication time between different departments. The departments are connected by a certain number of bidirectional cables, and each cable has a specific time delay to send information. The company provides you with an integer `n` representing the number of departments and an array `edges` where each element is a tuple `(a, b, t)` representing a cable connecting department `a` to department `b` with a communication time delay `t`. Your task is to determine the minimum total communication time required to enable all departments to communicate with each other. If it\'s impossible for all departments to communicate, return `-1`.","solution":"def find(parent, i): if parent[i] == i: return i return find(parent, parent[i]) def union(parent, rank, x, y): rootX = find(parent, x) rootY = find(parent, y) if rank[rootX] < rank[rootY]: parent[rootX] = rootY elif rank[rootX] > rank[rootY]: parent[rootY] = rootX else: parent[rootY] = rootX rank[rootX] += 1 def minimum_communication_time(n, edges): if n == 1: return 0 edges.sort(key=lambda edge: edge[2]) parent = [i for i in range(n)] rank = [0] * n min_time = 0 edge_count = 0 for edge in edges: a, b, t = edge rootA = find(parent, a) rootB = find(parent, b) if rootA != rootB: union(parent, rank, rootA, rootB) min_time += t edge_count += 1 if edge_count == n - 1: break if edge_count != n - 1: return -1 return min_time"},{"question":"You are given a tree with `n` nodes rooted at node `0`. Each node is labeled from `0` to `n-1`. You are also given an array `parents` where `parents[i]` is the parent of the `i-th` node. Return an array `answers` of size `n` where `answers[i]` is the number of nodes in the subtree rooted at node `i`, including `i` itself.","solution":"def subtree_sizes(n, parents): from collections import defaultdict # Create an adjacency list for the tree children = defaultdict(list) for child, parent in enumerate(parents): if parent != -1: children[parent].append(child) def dfs(node): size = 1 # include the current node for child in children[node]: size += dfs(child) answer[node] = size return size answer = [0] * n dfs(0) # Start DFS traversal from the root node (0) return answer"},{"question":"Given an integer array `nums`, return the maximum difference between two elements `nums[i]` and `nums[j]` (i.e., `nums[j] - nums[i]`) such that `i < j`. If no such `i` and `j` exist, return `-1`.","solution":"def maximum_difference(nums): Returns the maximum difference between two elements nums[i] and nums[j] such that i < j. Returns -1 if no such elements exist. if not nums or len(nums) < 2: return -1 min_value = nums[0] max_diff = -1 for j in range(1, len(nums)): if nums[j] > min_value: max_diff = max(max_diff, nums[j] - min_value) min_value = min(min_value, nums[j]) return max_diff"},{"question":"You are given a 2D grid of size `m x n` where each cell represents a resteraund and contains an integer value that represents the number of people that can fit into that resteraund at one time. Write a function `maxHungryPeople` that returns the maximum number of people that can be placed into the resteraund by selecting non-overlapping subgrids. Two subgrids are considered non-overlapping if they do not share any common cells (even corners). Note that you can select subgrids of any dimension as long as they are non-overlapping. # Function Signature ```python def maxHungryPeople(grid: List[List[int]]) -> int: # your code here ```","solution":"from typing import List def maxHungryPeople(grid: List[List[int]]) -> int: def helper(dp: List[List[int]]) -> int: max_sum = 0 for row in dp: max_sum += sum(row) return max_sum m, n = len(grid), len(grid[0]) dp = [[grid[i][j] for j in range(n)] for i in range(m)] total_people = 0 for i in range(m): for j in range(n): if (i == 0 or j == 0 or dp[i-1][j] == 0 or dp[i][j-1] == 0): total_people += grid[i][j] dp[i][j] = 0 else: dp2 = [[0] * n for _ in range(m)] for x in range(i, m): for y in range(j, n): dp2[x][y] = min(dp2[x-1][y] if x > 0 else grid[x][y], dp2[x][y-1] if y > 0 else grid[x][y], grid[x][y]) if (x > 0 and y > 0) else grid[x][y] subgrid_people = helper(dp2) total_people = max(total_people, subgrid_people) return total_people"},{"question":"Given a positive integer `num`, return _the sum of its digits after repeatedly transforming `num` by replacing it with the sum of its digits, until it becomes a single-digit number_. For example, given `num = 38`, the process would be `38 -> 3 + 8 = 11 -> 1 + 1 = 2`, so the result should be `2`.","solution":"def sum_of_digits(num): Returns the sum of the digits of a number until it becomes a single-digit number. while num >= 10: num = sum(int(digit) for digit in str(num)) return num"},{"question":"You are given a binary tree root representing a complete binary tree. Every level, except possibly the last, is completely filled, and all nodes are as far left as possible. Determine the number of nodes in the tree without traversing the entire tree. Return _an integer_ representing the number of nodes in the given binary tree.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def countNodes(root): if not root: return 0 left_depth = get_depth(root, True) right_depth = get_depth(root, False) if left_depth == right_depth: return (2 ** left_depth) - 1 else: return 1 + countNodes(root.left) + countNodes(root.right) def get_depth(node, is_left): depth = 0 while node: depth += 1 node = node.left if is_left else node.right return depth"},{"question":"You are given a string `s` consisting of lowercase English letters. A letter is considered a **happy letter** if the number of times it appears in the string is greater than the length of the string divided by 3. Return _a list of all happy letters in `s`_. The list should be returned in **alphabetical order**. If no such letter exists, return an empty list.","solution":"def happy_letters(s): Returns a list of happy letters in the string `s`. A letter is happy if it appears more times than len(s) / 3. The result is sorted in alphabetical order. from collections import Counter count_threshold = len(s) / 3 frequency = Counter(s) # Filter out letters that meet the threshold happy = [letter for letter, count in frequency.items() if count > count_threshold] # Sort the letters alphabetically happy.sort() return happy"},{"question":"You are given a string `s` consisting only of lowercase English letters. A substring is defined as any contiguous sequence of characters within the string. The \\"goodness\\" of a substring is defined as the number of distinct characters in that substring. Given an integer `k`, find the length of the longest substring of `s` that has a goodness of exactly `k`. If no such substring exists, return `-1`.","solution":"def longest_substring_with_goodness_k(s, k): Find the length of the longest substring with goodness exactly k. :param s: A string consisting only of lowercase English letters. :param k: An integer representing the required goodness. :return: The length of the longest substring with goodness exactly k, or -1 if no such substring exists. from collections import defaultdict n = len(s) if n == 0 or k == 0: return -1 left = 0 char_count = defaultdict(int) distinct_count = 0 max_length = -1 for right in range(n): if char_count[s[right]] == 0: distinct_count += 1 char_count[s[right]] += 1 while distinct_count > k: char_count[s[left]] -= 1 if char_count[s[left]] == 0: distinct_count -= 1 left += 1 if distinct_count == k: max_length = max(max_length, right - left + 1) return max_length if max_length != -1 else -1"},{"question":"Given an input array of integers `nums` and another integer `k`, transform the array such that every element in the array appears exactly `k` times. The condition is that all elements must appear exactly `k` times and any transformation should not change the relative order of the elements in the original array. If it is not possible to transform the array to satisfy the condition, return an empty array. Otherwise, return the transformed array as a new list.","solution":"def transform_array(nums, k): from collections import Counter, defaultdict count = Counter(nums) # Check if it\'s possible to transform for val in count.values(): if val != k: return [] result = [] appearance = defaultdict(int) for num in nums: if appearance[num] < k: result.append(num) appearance[num] += 1 return result"},{"question":"Given an array of integers and a target value, determine if there are two numbers in the array that add up to the target value. Return the indices of the two numbers in the form of a tuple `(index1, index2)`. Ensure that the solution has a time complexity of `O(n)`. If no such pair exists, return an empty tuple.","solution":"def two_sum(nums, target): Given an array of integers and a target value, determine if there are two numbers in the array that add up to the target value. Return the indices of the two numbers in the form of a tuple (index1, index2). If no such pair exists, return an empty tuple. :param nums: List[int], a list of integers :param target: int, the target sum :return: tuple, the indices of the two numbers that sum up to the target num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return (num_to_index[complement], i) num_to_index[num] = i return ()"},{"question":"Given a string `s` consisting of only lowercase letters, return _the length of the longest contiguous substring that contains at most two distinct characters_. Implement the function `int longestSubstringWithTwoDistinct(String s)` which processes the input string `s` and returns the length of the longest substring that fits the criteria.","solution":"def longestSubstringWithTwoDistinct(s): Returns the length of the longest contiguous substring that contains at most two distinct characters. if len(s) == 0: return 0 left = 0 max_length = 0 char_map = {} for right in range(len(s)): char_map[s[right]] = char_map.get(s[right], 0) + 1 while len(char_map) > 2: char_map[s[left]] -= 1 if char_map[s[left]] == 0: del char_map[s[left]] left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"You are given two string arrays `words1` and `words2`. A string `b` is a subset of string `a` if every letter in `b` occurs in `a` including multiplicity. For example, \\"wrr\\" is a subset of \\"warrior,\\" but is not a subset of \\"world\\" or \\"elloworld.\\" Return an array of all the strings in `words1` which are subsets of all the strings in `words2`.","solution":"from collections import Counter def is_subset(a, b): Checks if string b is a subset of string a. counter_a = Counter(a) counter_b = Counter(b) for char, count in counter_b.items(): if counter_a[char] < count: return False return True def wordSubsets(words1, words2): Returns an array of all the strings in words1 which are subsets of all the strings in words2. def merge_max_count(words): merged_count = Counter() for word in words: word_count = Counter(word) for char, count in word_count.items(): merged_count[char] = max(merged_count[char], count) return merged_count words2_count = merge_max_count(words2) result = [] for word in words1: if is_subset(word, words2_count): result.append(word) return result"},{"question":"Given a `string` containing only characters `\'(\'` and `\')\'`, you need to find the **length** of the longest valid (well-formed) parentheses substring. Return the length of this longest valid parentheses substring.","solution":"def longest_valid_parentheses(s): Given a string `s` containing only \'(\' and \')\', find the length of the longest valid (well-formed) parentheses substring. Parameters: s (str): input string containing only \'(\' and \')\' Returns: int: length of the longest valid parentheses substring max_len = 0 stack = [-1] # Initialize stack with -1 to handle edge cases for i, char in enumerate(s): if char == \'(\': stack.append(i) else: stack.pop() if not stack: stack.append(i) else: max_len = max(max_len, i - stack[-1]) return max_len"},{"question":"You are given a **binary tree** where each node has an integer value. Return the **sum of the values of the deepest leaves** in the tree. A leaf is a node with no children, and the deepest leaves are the nodes with the greatest depth. Note that depth is measured by the number of edges along the longest path from the root to a leaf.","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def deepest_leaves_sum(root): if not root: return 0 queue = deque([root]) while queue: level_sum = 0 for _ in range(len(queue)): node = queue.popleft() level_sum += node.val if node.left: queue.append(node.left) if node.right: queue.append(node.right) return level_sum"},{"question":"Given an array of integers `nums`, a **subarray** is a contiguous non-empty sequence of numbers within the array. You need to find the length of the longest subarray that contains **only unique elements**. For example, given the array `[1, 2, 1, 3, 4, 2]`, the longest subarray with all unique elements is `[1, 3, 4]`, so the function should return `3`. Write a function called `longestUniqueSubarray` that takes in an array `nums` of integers and returns the length of the longest subarray with all unique elements.","solution":"def longestUniqueSubarray(nums): Returns the length of the longest subarray with all unique elements. if not nums: return 0 seen = {} max_length = 0 start = 0 for end, value in enumerate(nums): if value in seen: start = max(start, seen[value] + 1) seen[value] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"You are given an unsorted array of integers `nums`. A \\"peak\\" element in this array is an element that is strictly greater than its neighbors. Given that the array contains `n` elements, where `n >= 3`, and `nums[0]` and `nums[n-1]` are considered to have a neighbor on only one side, implement a function to find a peak element and return its index. If the array has multiple peak elements, return the index of any of them. Note: You may assume `nums[i] != nums[i+1]` for all valid `i`. Your solution should aim for a time complexity of O(log n).","solution":"def find_peak_element(nums): Finds a peak element in the list nums and returns its index. A peak element is an element that is strictly greater than its neighbors. left, right = 0, len(nums) - 1 while left < right: mid = (left + right) // 2 if nums[mid] > nums[mid + 1]: right = mid else: left = mid + 1 return left"},{"question":"You are given a binary tree where each node contains an integer value. Design an algorithm to find the largest subtree (by number of nodes) that is a valid Binary Search Tree (BST), along with the size of that subtree. A valid BST: - The left subtree of a node contains only nodes with values less than the node\'s value. - The right subtree of a node contains only nodes with values greater than the node\'s value. - Both the left and right subtrees must also be binary search trees. Return the size of the largest valid BST subtree. (Note: If the entire tree is a valid BST, then return the number of nodes in the entire tree.)","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def largestBSTSubtree(root: TreeNode) -> int: def helper(node): if not node: # A base case where the subtree is empty, considered a valid BST with size 0 return 0, float(\'inf\'), float(\'-inf\'), 0 l_size, l_min, l_max, l_bst_size = helper(node.left) r_size, r_min, r_max, r_bst_size = helper(node.right) if l_max < node.val < r_min: # If current node is forming a BST with its left and right subtrees size = 1 + l_size + r_size return size, min(node.val, l_min), max(node.val, r_max), size return 1 + l_size + r_size, float(\'-inf\'), float(\'inf\'), max(l_bst_size, r_bst_size) return helper(root)[3]"},{"question":"A company has a list of projects, each defined by its profit and the number of workers required to complete it. You are given two integer arrays `profits` and `workers`, where `profits[i]` is the profit of the `i-th` project and `workers[i]` is the number of workers required to complete the `i-th` project. Additionally, you have a list of available staff members each with a specific skill level, represented by the integer array `staff`. A staff member can only work on a project if their skill level is greater than or equal to the number of workers required for the project. Your task is to determine the maximum total profit the company can achieve given that each staff member can work on at most one project. Return _the maximum total profit the company can achieve_.","solution":"def max_total_profit(profits, workers, staff): projects = sorted(zip(profits, workers), key=lambda x: (-x[0], x[1])) available_staff = sorted(staff, reverse=True) total_profit = 0 for profit, worker_required in projects: for i in range(len(available_staff)): if available_staff[i] >= worker_required: total_profit += profit available_staff.pop(i) break return total_profit"},{"question":"You are given a string `s` consisting of lowercase English letters. You are allowed to shuffle the letters of `s` to create a new string. Return `True` if and only if it is possible to get another string `t` from `s` such that `t` is a palindrome and `t != s`. Otherwise, return `False`.","solution":"def can_form_different_palindrome(s): from collections import Counter # Count characters char_count = Counter(s) # Check how many characters have odd frequencies odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # To form a palindrome, at most one character is allowed to have an odd frequency if odd_count > 1: return False # Check if there\'s only one unique character in s if len(set(s)) == 1: return False return True"},{"question":"Given an integer array `nums`, return a boolean indicating if it is possible to partition the array into two subsets such that the sum of the elements in both subsets is equal.","solution":"def can_partition(nums): Returns True if the array can be partitioned into two subsets with equal sum, False otherwise. total_sum = sum(nums) # If the total sum is odd, it is not possible to partition it into equal subsets if total_sum % 2 != 0: return False target = total_sum // 2 n = len(nums) dp = [False] * (target + 1) dp[0] = True for num in nums: for i in range(target, num - 1, -1): dp[i] = dp[i] or dp[i - num] return dp[target]"},{"question":"Given a 2D integer array `matrix` representing a grid of `m x n` dimensions, where each cell contains either `0` (empty) or `1` (occupied), find the size of the largest square containing only `1`s and return its area. A square is defined by having the same number of rows and columns, and all the cells inside the square must be `1`s. Write a function to implement this. ```python def maximalSquare(matrix: List[List[int]]) -> int: # Your code here ```","solution":"def maximalSquare(matrix): if not matrix or not matrix[0]: return 0 m, n = len(matrix), len(matrix[0]) dp = [[0] * n for _ in range(m)] max_side = 0 for i in range(m): for j in range(n): if matrix[i][j] == 1: if i == 0 or j == 0: dp[i][j] = 1 # first row or first column else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side = max(max_side, dp[i][j]) return max_side * max_side"},{"question":"You are given the `root` of a binary search tree (BST) and an integer `target`. Write a function to find the value in the BST that is closest to the `target`. If there are multiple values with the same difference to the target, return the smallest value. You must solve it in O(h) time complexity, where h is the height of the BST.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def closest_value(root, target): Finds the value in the BST that is closest to the target. closest = root.val while root: if abs(root.val - target) < abs(closest - target) or (abs(root.val - target) == abs(closest - target) and root.val < closest): closest = root.val if target < root.val: root = root.left else: root = root.right return closest"},{"question":"Given a positive integer `n`, you must construct a binary tree with `n` nodes such that the binary tree satisfies the following conditions: 1. Each node is labeled with a unique integer from 1 to `n`. 2. The tree is a complete binary tree. 3. The sum of values along any root-to-leaf path is minimized. Return the level-order traversal of the tree nodes\' values as a list of lists.","solution":"from collections import deque def construct_min_sum_tree(n): Constructs a binary tree with `n` nodes such that: 1. Each node is labeled with a unique integer from 1 to `n`. 2. The tree is a complete binary tree. 3. The sum of values along any root-to-leaf path is minimized. Returns the level-order traversal of the tree nodes\' values as a list of lists. if n <= 0: return [] # Initialize a queue to construct the complete binary tree queue = deque() level_order = [] # Start by inserting the root node with value 1 node_id = 1 queue.append(node_id) while queue: level_size = len(queue) level = [] for _ in range(level_size): node = queue.popleft() level.append(node) # Add children to the queue left_child = node * 2 right_child = node * 2 + 1 if left_child <= n: queue.append(left_child) if right_child <= n: queue.append(right_child) level_order.append(level) return level_order"},{"question":"You are given a list of `n` integers representing different heights of columns. The width of each column is 1. Form a rectangle using a subset of these columns such that the rectangle has the maximum possible area. The height of the rectangle is determined by the shortest column in the subset, and the width is the number of columns in the subset. Return _the size of the maximum possible rectangle_.","solution":"def largest_rectangle_area(heights): Calculates the size of the maximum possible rectangle in a histogram. Parameters: heights (list of int): List of integers representing the heights of columns. Returns: int: The size of the maximum possible rectangle. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"Given a `matrix` of integers where each element represents the height at that point, find the size of the largest square containing only 1s and return its area. A square consists of 1s if and only if all the cells within that square are 1.","solution":"def maximalSquare(matrix): if not matrix or not matrix[0]: return 0 rows, cols = len(matrix), len(matrix[0]) dp = [[0] * cols for _ in range(rows)] max_side = 0 for i in range(rows): for j in range(cols): if matrix[i][j] == 1: if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side = max(max_side, dp[i][j]) return max_side ** 2"},{"question":"You are given a string `s` and an integer `n`. Rotate the string to the right by `n` places, where a single rotation moves the last character of the string to the front. Return the _rotated string_ after `n` rotations.","solution":"def rotate_string(s, n): Rotates the string to the right by n places. if not s: return s n = n % len(s) # In case n is greater than the length of the string return s[-n:] + s[:-n]"},{"question":"You are given a string `s` and an integer `n`. You can perform the following operation on `s` at most `n` times: Choose a substring of `s` and change all its characters to any single character of your choice. Return the length of the longest substring containing the same character that you can achieve after performing the operation at most `n` times.","solution":"def longest_substring_with_same_char(s, n): Returns the length of the longest substring containing the same character after performing at most n operations. from collections import Counter max_len = 0 start = 0 freq = Counter() max_count = 0 for end in range(len(s)): freq[s[end]] += 1 max_count = max(max_count, freq[s[end]]) if (end - start + 1) - max_count > n: freq[s[start]] -= 1 start += 1 max_len = max(max_len, end - start + 1) return max_len"},{"question":"You are given a string `encryptedMessage` representing a message that has been encrypted by shifting each character by `k` positions in the alphabet. Characters have been shifted circularly, meaning after \'z\', it wraps back to \'a\'. Write a function to decrypt the message by shifting the characters back by `k` positions. Return the decoded string.","solution":"def decrypt_message(encryptedMessage, k): Decrypts the given encrypted message by shifting each character back by k positions. Parameters: encryptedMessage (str): The encrypted message string. k (int): The number of positions each character is shifted in the alphabet. Returns: str: The decrypted message string. decrypted_message = [] for char in encryptedMessage: if char.isalpha(): shifted = ord(char) - k if char.islower(): if shifted < ord(\'a\'): shifted += 26 elif char.isupper(): if shifted < ord(\'A\'): shifted += 26 decrypted_message.append(chr(shifted)) else: decrypted_message.append(char) return \'\'.join(decrypted_message)"},{"question":"You are given an array of integers `arr` and an integer `x`. You need to find all the pairs of integers in the array whose sum is equal to `x`. Return a list of all unique pairs in the form `(a, b)` such that `a <= b`. The pairs should be sorted in ascending order. If there are no such pairs, return an empty list. For example, * If `arr = [1, 2, 3, 4, 3]` and `x = 6`, the pairs are `[(2, 4), (3, 3)]`. * If `arr = [0, -1, 2, -3, 1]` and `x = -2`, the pairs are `[(-3, 1)]`.","solution":"def find_pairs_with_sum(arr, x): Return a list of pairs in the array whose sum is equal to x. pairs = set() seen = set() for number in arr: target = x - number if target in seen: pairs.add((min(number, target), max(number, target))) seen.add(number) return sorted(list(pairs))"},{"question":"Given an integer `n`, return all the structurally unique **BST\'s** (binary search trees), which has exactly `n` nodes of unique values from `1` to `n`. Return the result in any order. Each BST must have its nodes arranged such that the left subtree of a node contains only nodes with keys **less than the node\'s key**, and the right subtree contains only nodes with keys **greater than the node\'s key**.","solution":"from typing import List class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def generate_trees(n: int) -> List[TreeNode]: if n == 0: return [] def build_trees(start, end): if start > end: return [None] all_trees = [] for i in range(start, end + 1): left_trees = build_trees(start, i - 1) right_trees = build_trees(i + 1, end) for L in left_trees: for R in right_trees: current_tree = TreeNode(i) current_tree.left = L current_tree.right = R all_trees.append(current_tree) return all_trees return build_trees(1, n)"},{"question":"Given a directed acyclic graph (DAG) with `n` vertices numbered from `0` to `n-1`, represented by the edges list `edges` where `edges[i] = [ai, bi]` means there is a directed edge from vertex `ai` to vertex `bi`, find the number of different paths from vertex `0` to vertex `n-1`. _Remember that in a DAG, all paths are directed and acyclic (no cycles), ensuring that it is always possible to search for paths without the risk of looping back._","solution":"def count_paths(n, edges): Returns the number of different paths from vertex 0 to vertex n-1 in a DAG. Parameters: n (int): Number of vertices in the graph. edges (list[list[int]]): The edges in the graph where edge[i] = [a_i, b_i] means there is a directed edge from vertex a_i to vertex b_i. Returns: int: Number of different paths from vertex 0 to vertex n-1. from collections import defaultdict, deque graph = defaultdict(list) for u, v in edges: graph[u].append(v) def topological_sort(): indegree = [0] * n for u in graph: for v in graph[u]: indegree[v] += 1 queue = deque([i for i in range(n) if indegree[i] == 0]) topo_order = [] while queue: node = queue.popleft() topo_order.append(node) for neighbor in graph[node]: indegree[neighbor] -= 1 if indegree[neighbor] == 0: queue.append(neighbor) return topo_order topo_order = topological_sort() paths = [0] * n paths[0] = 1 for node in topo_order: for neighbor in graph[node]: paths[neighbor] += paths[node] return paths[n-1]"},{"question":"You are given an array of integers `nums`. A single operation consists of picking any two elements from the array and replacing them with their sum. Repeat this operation until there\'s only one element left in the array. Return _the maximum possible value_ of the final element.","solution":"def get_maximum_final_element(nums): Returns the maximum possible value of the final element after repeatedly picking any two elements and replacing them with their sum. return sum(nums)"},{"question":"You are given a **0-indexed** array `heights` consisting of `n` positive integers where `heights[i]` represents the height of a building at position `i`. Each building casts a shadow to its right extending up to the height of the building (inclusive). The **shadow length** of a building at position `i` can be described as the number of positions `j` such that `i < j <= min(i + heights[i], n - 1)`. Return _the total number of positions on the street that are covered by at least one building\'s shadow_.","solution":"def count_shadow_positions(heights): Returns the total number of positions on the street that are covered by at least one building\'s shadow. n = len(heights) covered = [0] * n for i in range(n): max_shadow = min(i + heights[i], n - 1) for j in range(i + 1, max_shadow + 1): covered[j] = 1 return sum(covered)"},{"question":"Given a string `s` consisting of lower-case English letters, you are to determine if it is a valid palindrome considering only alphanumeric characters and ignoring cases. Note that an empty string is considered a valid palindrome. Implement a function that takes string `s` and returns a boolean value indicating whether the input string `s` is a valid palindrome or not.","solution":"def is_palindrome(s): Determine if the input string s is a valid palindrome, considering only alphanumeric characters and ignoring cases. Parameters: s (str): The input string. Returns: bool: True if the input string is a valid palindrome, False otherwise. # Normalize the string by filtering out non-alphanumeric characters and converting to lower case normalized_str = \'\'.join(char.lower() for char in s if char.isalnum()) # Check if the normalized string is equal to its reverse return normalized_str == normalized_str[::-1]"},{"question":"You are given a string expression containing only non-negative integers, addition (+), subtraction (-) and multiplication (*) operators. The task is to evaluate the expression and return the result. The example expression can be \\"3+2*2\\" and should be evaluated taking into account the operator precedence (multiplication before addition and subtraction). Note that the expression is always valid and does not contain any spaces.","solution":"def evaluate_expression(expression): Evaluates a string expression containing only non-negative integers, addition (+), subtraction (-) and multiplication (*) operators. The expression is evaluated based on operator precedence. def helper(s, idx): stack = [] num = 0 sign = \'+\' while idx < len(s): char = s[idx] if char.isdigit(): num = num * 10 + int(char) if char in \\"+-*\\": if sign == \'+\': stack.append(num) elif sign == \'-\': stack.append(-num) elif sign == \'*\': stack.append(stack.pop() * num) sign = char num = 0 idx += 1 if sign == \'+\': stack.append(num) elif sign == \'-\': stack.append(-num) elif sign == \'*\': stack.append(stack.pop() * num) return sum(stack) return helper(expression, 0)"},{"question":"You are given an integer array `nums` and an integer `target`. The objective is to determine if there exist four elements in `nums` whose sum is equal to `target`. Write a function `fourSum(nums, target)` that returns all such unique quadruplets in the array such that their sum equals `target`. Note that the solution set must not contain duplicate quadruplets. ```python def fourSum(nums, target): # Your implementation here ```","solution":"def fourSum(nums, target): def kSum(nums, target, k): res = [] if not nums: return res average_value = target // k if average_value < nums[0] or average_value > nums[-1]: return res if k == 2: return twoSum(nums, target) for i in range(len(nums)): if i == 0 or nums[i - 1] != nums[i]: for subset in kSum(nums[i + 1:], target - nums[i], k - 1): res.append([nums[i]] + subset) return res def twoSum(nums, target): res = [] s = set() for num in nums: if res and res[-1][1] == num: continue if target - num in s: res.append([target - num, num]) s.add(num) return res nums.sort() return kSum(nums, target, 4)"},{"question":"You are given a list of `n` strings `words` and a string `pattern`. Return _a list of all the strings in_ `words` _that match the pattern_. A string matches the pattern if there is a _bijective mapping_ between each character in the pattern and each character in the string. No two characters may map to the same character, but a character may map to itself. Return the result in **any order**.","solution":"def find_and_replace_pattern(words, pattern): def match(word): if len(word) != len(pattern): return False p_to_w, w_to_p = {}, {} for w_char, p_char in zip(word, pattern): if p_char not in p_to_w and w_char not in w_to_p: p_to_w[p_char] = w_char w_to_p[w_char] = p_char elif p_to_w.get(p_char) != w_char or w_to_p.get(w_char) != p_char: return False return True return [word for word in words if match(word)]"}]'),A={name:"App",components:{PoemCard:I},data(){return{searchQuery:"",visibleCount:4,poemsData:F,isLoading:!1}},computed:{filteredPoems(){const i=this.searchQuery.trim().toLowerCase();return i?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(i)||e.solution&&e.solution.toLowerCase().includes(i)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(i=>setTimeout(i,1e3)),this.visibleCount+=4,this.isLoading=!1}}},z={class:"search-container"},L={class:"card-container"},C={key:0,class:"empty-state"},N=["disabled"],D={key:0},E={key:1};function S(i,e,u,c,s,a){const f=p("PoemCard");return n(),r("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",z,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),_(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>s.searchQuery=o),placeholder:"Search..."},null,512),[[b,s.searchQuery]]),s.searchQuery?(n(),r("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>s.searchQuery="")}," ✕ ")):h("",!0)]),t("div",L,[(n(!0),r(y,null,w(a.displayedPoems,(o,g)=>(n(),x(f,{key:g,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(n(),r("div",C,' No results found for "'+l(s.searchQuery)+'". ',1)):h("",!0)]),a.hasMorePoems?(n(),r("button",{key:0,class:"load-more-button",disabled:s.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[s.isLoading?(n(),r("span",E,"Loading...")):(n(),r("span",D,"See more"))],8,N)):h("",!0)])}const G=m(A,[["render",S],["__scopeId","data-v-b1ba6f42"]]),B=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"library/10.md","filePath":"library/10.md"}'),P={name:"library/10.md"},O=Object.assign(P,{setup(i){return(e,u)=>(n(),r("div",null,[v(G)]))}});export{B as __pageData,O as default};
