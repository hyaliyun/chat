import{_ as h,o as n,c as i,a as t,m as c,t as d,C as g,M as _,U as y,f as u,F as b,p as v,e as w,q as x}from"./chunks/framework.B1z0IdBH.js";const k={name:"PoemCard",props:{poem:{type:Object,required:!0}}},T={class:"poem-container"},q={class:"review"},A={class:"review-title"},E={class:"review-content"};function I(r,e,l,p,s,a){return n(),i("div",T,[t("div",q,[t("div",A,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),c(d(l.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",E,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),c(d(l.poem.solution),1)])])])}const C=h(k,[["render",I],["__scopeId","data-v-6f24cb7f"]]),S=JSON.parse('[{"question":"# Question: Inventory Management System for a Warehouse Context You are developing an inventory management system for a warehouse. This system needs to keep track of the items in stock and manage inventory operations such as adding new items, updating existing items, and retrieving item information. Task Implement a Python class `Inventory` that manages the inventory in a warehouse with the following methods: 1. `add_item(name: str, quantity: int, price: float) -> None`: Adds a new item to the inventory. If the item already exists, increment its quantity by the given amount and update its price. 2. `update_item(name: str, quantity: int, price: float) -> None`: Updates the quantity and price of an existing item. If the item does not exist, raise a `ValueError`. 3. `delete_item(name: str) -> None`: Removes an item from the inventory. If the item does not exist, raise a `ValueError`. 4. `get_item(name: str) -> Tuple[int, float]`: Returns the quantity and price of the given item. If the item does not exist, raise a `ValueError`. Input - Each method will take the necessary parameters as described above. Output - Each method will perform operations according to their description. - The `get_item` method will return a tuple containing the quantity and price of the given item. Constraints 1. All item names will be strings. 2. The quantity will be a non-negative integer. 3. The price will be a non-negative float. 4. Method invocations will follow the required sequence to guarantee valid interactions. Example ```python from typing import Dict, Tuple class Inventory: def __init__(self): self.items: Dict[str, Tuple[int, float]] = {} def add_item(self, name: str, quantity: int, price: float) -> None: if name in self.items: existing_quantity, _ = self.items[name] self.items[name] = (existing_quantity + quantity, price) else: self.items[name] = (quantity, price) def update_item(self, name: str, quantity: int, price: float) -> None: if name in self.items: self.items[name] = (quantity, price) else: raise ValueError(\\"Item does not exist\\") def delete_item(self, name: str) -> None: if name in self.items: del self.items[name] else: raise ValueError(\\"Item does not exist\\") def get_item(self, name: str) -> Tuple[int, float]: if name in self.items: return self.items[name] else: raise ValueError(\\"Item does not exist\\") # Example usage inventory = Inventory() inventory.add_item(\'apple\', 50, 1.2) inventory.add_item(\'banana\', 30, 0.5) print(inventory.get_item(\'apple\')) # Output: (50, 1.2) inventory.update_item(\'apple\', 100, 1.3) print(inventory.get_item(\'apple\')) # Output: (100, 1.3) inventory.delete_item(\'banana\') # print(inventory.get_item(\'banana\')) # Raises ValueError: Item does not exist ``` Notes - Ensure your solution handles cases where operations might involve non-existent items appropriately by raising `ValueError` where specified. - Maintain good coding practices by ensuring the class methods perform the specified tasks efficiently.","solution":"from typing import Dict, Tuple class Inventory: def __init__(self): self.items: Dict[str, Tuple[int, float]] = {} def add_item(self, name: str, quantity: int, price: float) -> None: if name in self.items: existing_quantity, _ = self.items[name] self.items[name] = (existing_quantity + quantity, price) else: self.items[name] = (quantity, price) def update_item(self, name: str, quantity: int, price: float) -> None: if name in self.items: self.items[name] = (quantity, price) else: raise ValueError(\\"Item does not exist\\") def delete_item(self, name: str) -> None: if name in self.items: del self.items[name] else: raise ValueError(\\"Item does not exist\\") def get_item(self, name: str) -> Tuple[int, float]: if name in self.items: return self.items[name] else: raise ValueError(\\"Item does not exist\\")"},{"question":"# Cache System Design In this task, you will be required to design and implement a custom cache system with two different types of cache policies: Least Recently Used (LRU) and First In, First Out (FIFO). There are two parts to this task: Part A: LRUCache Implement a cache system with the Least Recently Used (LRU) policy. Create a class `LRUCache` that includes the following methods: 1. `__init__(self, capacity: int)`: Initializes the cache with a given capacity. 2. `put(self, key: int, value: int)`: Inserts a key-value pair into the cache. If the cache reaches its capacity, it removes the least recently used item. 3. `get(self, key: int) -> int`: Fetches the value associated with the key. If the key is not found, return `-1`. 4. `__str__(self) -> str`: Returns a string representation of the cache\'s current state. Part B: FIFOCache Implement a cache system with the First In, First Out (FIFO) policy. Create a class `FIFOCache` that includes the following methods: 1. `__init__(self, capacity: int)`: Initializes the cache with a given capacity. 2. `put(self, key: int, value: int)`: Inserts a key-value pair into the cache. If the cache reaches its capacity, it removes the oldest inserted item. 3. `get(self, key: int) -> int`: Fetches the value associated with the key. If the key is not found, return `-1`. 4. `__str__(self) -> str`: Returns a string representation of the cache\'s current state. # Input and Output * `put(key, value)` accepts an integer key and value. * `get(key)` accepts a single key and returns the associated value. * Both classes should handle standard caching operations efficiently. # Performance Requirements Ensure that your implementation meets the specified time complexities: * Insertions and updates (`put`): O(1) * Retrievals (`get`): O(1) * String representation should be efficient. # Example ```python # Part A: LRUCache lru_cache = LRUCache(2) lru_cache.put(1, 1) lru_cache.put(2, 2) print(lru_cache) # {1: 1, 2: 2} print(lru_cache.get(1)) # 1 lru_cache.put(3, 3) # LRU key 2 is evicted print(lru_cache) # {1: 1, 3: 3} print(lru_cache.get(2)) # -1 # Part B: FIFOCache fifo_cache = FIFOCache(2) fifo_cache.put(1, 1) fifo_cache.put(2, 2) print(fifo_cache) # {1: 1, 2: 2} print(fifo_cache.get(1)) # 1 fifo_cache.put(3, 3) # FIFO key 1 is evicted print(fifo_cache) # {2: 2, 3: 3} print(fifo_cache.get(2)) # 2 ``` Implement the classes `LRUCache` and `FIFOCache` with the specified methods and ensure your code passes the above examples.","solution":"from collections import OrderedDict class LRUCache: def __init__(self, capacity: int): self.capacity = capacity self.cache = OrderedDict() def put(self, key: int, value: int): if key in self.cache: self.cache.move_to_end(key) self.cache[key] = value if len(self.cache) > self.capacity: self.cache.popitem(last=False) def get(self, key: int) -> int: if key in self.cache: self.cache.move_to_end(key) return self.cache[key] return -1 def __str__(self) -> str: return str(self.cache) class FIFOCache: def __init__(self, capacity: int): self.capacity = capacity self.cache = OrderedDict() def put(self, key: int, value: int): if key not in self.cache: if len(self.cache) >= self.capacity: self.cache.popitem(last=False) self.cache[key] = value def get(self, key: int) -> int: return self.cache.get(key, -1) def __str__(self) -> str: return str(self.cache)"},{"question":"# Coding Assessment Question - Balanced Brackets Scenario: You have been hired to work on the backend of an integrated development environment (IDE). One essential feature the IDE needs is to check if the code written by programmers has balanced brackets. Brackets include parenthesis `()`, square brackets `[]`, and curly braces `{}`. Your task is to write a function that evaluates whether the brackets in a string are balanced or not. Question: **Function Signature:** ```python def are_brackets_balanced(s: str) -> bool: ``` **Input:** * A single string `s` which can contain any characters, including letters, numbers, and special characters. **Output:** * Return `True` if the brackets in `s` are balanced. * Return `False` otherwise. **Constraints:** * The input `s` will have a length up to 10,000 characters. **Examples:** ```python are_brackets_balanced(\\"(a + b) * (c + d)\\") # Expected output: True are_brackets_balanced(\\"{[()]}\\") # Expected output: True are_brackets_balanced(\\"{[(a + b) - {c * d}] / e}\\")# Expected output: True are_brackets_balanced(\\"[(])\\") # Expected output: False are_brackets_balanced(\\"([)]\\") # Expected output: False are_brackets_balanced(\\"a + b (c + d)\\") # Expected output: True are_brackets_balanced(\\"{[}\\") # Expected output: False ``` **Notes:** * The input string can contain any characters, but only `()`, `{}`, and `[]` are significant for this check. * The function should be case-sensitive. * Ensure the implementation efficiently handles strings at the higher end of the constraint. **Hint:** You can use a stack data structure to keep track of opened brackets and ensure they are closed in the correct order.","solution":"def are_brackets_balanced(s: str) -> bool: # A stack to keep track of opening brackets stack = [] # A map to keep track of the matches for each closing bracket matching_bracket = {\')\': \'(\', \']\': \'[\', \'}\': \'{\'} # Traverse each character in the string for char in s: if char in matching_bracket.values(): # If it\'s an opening bracket stack.append(char) elif char in matching_bracket.keys(): # If it\'s a closing bracket if stack == [] or stack.pop() != matching_bracket[char]: return False return stack == [] # Return True if stack is empty, False otherwise"},{"question":"# Context You are developing a feature for a text editor application that includes a function for formatting paragraphs. The application must ensure that each line in a paragraph does not exceed a specified number of characters to maintain a neat and readable layout. # Objective Implement a function that takes a paragraph of text and a maximum line length, and formats the paragraph such that no line exceeds the maximum length. Words should not be split across lines, and space should be minimized at the end of each line. # Function Signature ```python def format_paragraph(paragraph: str, max_length: int) -> list[str]: Format a given paragraph into lines with at most max_length characters :param paragraph: A string representing the paragraph of text :param max_length: Maximum number of characters per line :return: List of strings, each representing a line of formatted text Example: >>> format_paragraph(\\"This is a sample paragraph for testing the text formatting function.\\", 14) [\'This is a\', \'sample\', \'paragraph for\', \'testing the\', \'text\', \'formatting\', \'function.\'] >>> format_paragraph(\\"Another example with a different max length.\\", 12) [\'Another\', \'example with\', \'a different\', \'max length.\'] ``` # Constraints and Requirements 1. Assume the input `paragraph` is a non-empty string and words in the paragraph are separated by single spaces. 2. The `max_length` must be a positive integer greater than zero. 3. Each line in the returned list should contain words that fit within the given `max_length`. 4. Raise a `ValueError` if the `max_length` is less than the length of the longest word in the paragraph. # Examples - Input: `\\"This is a sample paragraph for testing the text formatting function.\\"`, `14` Output: `[\'This is a\', \'sample\', \'paragraph for\', \'testing the\', \'text\', \'formatting\', \'function.\']` - Input: `\\"Another example with a different max length.\\"`, `12` Output: `[\'Another\', \'example with\', \'a different\', \'max length.\']` - Input: `\\"Short sentence.\\"`, `20` Output: `[\'Short sentence.\']` # Notes 1. The function should ensure that no words are split across lines. 2. Properly handle paragraphs where lines may end with multiple spaces if they fit within the `max_length`. 3. Test the function with various paragraphs and maximum lengths to ensure correct behavior.","solution":"def format_paragraph(paragraph: str, max_length: int) -> list[str]: Format a given paragraph into lines with at most max_length characters :param paragraph: A string representing the paragraph of text :param max_length: Maximum number of characters per line :return: List of strings, each representing a line of formatted text words = paragraph.split() if any(len(word) > max_length for word in words): raise ValueError(\\"The max_length is less than the length of the longest word.\\") lines = [] current_line = [] current_length = 0 for word in words: if current_length + len(word) + len(current_line) > max_length: lines.append(\\" \\".join(current_line)) current_line = [word] current_length = len(word) else: current_line.append(word) current_length += len(word) if current_line: lines.append(\\" \\".join(current_line)) return lines"},{"question":"# Problem Statement Write a function that takes a string containing only digits (0-9) and returns a string representing the maximum number you can form by deleting exactly one digit from the string. Function Signature ```python def max_number_by_deleting_one_digit(num: str) -> str: Computes the maximum number possible by deleting exactly one digit from the given string of digits. Parameters: num (str): The input string containing only digits (0-9). Returns: str: The maximum number possible as a string. ``` Input Constraints - `num` will be a non-empty string containing only digits. - The length of `num` will be between 2 and 100 (2 ≤ len(num) ≤ 100). Output Requirements - A string representing the maximum possible number obtained by deleting exactly one digit. Examples ```python assert max_number_by_deleting_one_digit(\\"12345\\") == \\"2345\\" assert max_number_by_deleting_one_digit(\\"251\\") == \\"51\\" assert max_number_by_deleting_one_digit(\\"10\\") == \\"1\\" assert max_number_by_deleting_one_digit(\\"1001\\") == \\"101\\" ``` # Additional Context This problem is a common task in string manipulation and requires the candidate to efficiently iterate and compare to determine the optimal digit to remove. It tests the understanding of algorithmic implementation and time complexity management with string operations.","solution":"def max_number_by_deleting_one_digit(num: str) -> str: Computes the maximum number possible by deleting exactly one digit from the given string of digits. Parameters: num (str): The input string containing only digits (0-9). Returns: str: The maximum number possible as a string. max_number = \'\' for i in range(len(num)): candidate = num[:i] + num[i+1:] if candidate > max_number: max_number = candidate return max_number"},{"question":"# Problem Statement Given a string `s` consisting of lowercase English letters, find and return the length of the longest palindrome that can be built with those letters. # Function Signature ```python def longest_palindrome_length(s: str) -> int: ``` # Input - `s` (str): The input string. Constraints: 1 <= len(s) <= 10^5 # Output - The function should return the length of the longest palindrome that can be formed using the characters of `s`. # Example ```python assert longest_palindrome_length(\\"abccccdd\\") == 7 assert longest_palindrome_length(\\"a\\") == 1 assert longest_palindrome_length(\\"abc\\") == 1 assert longest_palindrome_length(\\"aabbcc\\") == 6 assert longest_palindrome_length(\\"bb\\") == 2 ``` # Constraints - Use a greedy approach to solve the problem. - Focus on optimal time and space complexity. - Consider that all characters in the string are lowercase English letters. # Performance Requirements - The function should run in O(n) time complexity, where n is the length of the string. - The space complexity should be O(1), as the space used for counting characters should not grow with input size.","solution":"def longest_palindrome_length(s: str) -> int: Returns the length of the longest palindrome that can be formed using the characters in the given string. from collections import Counter char_count = Counter(s) length = 0 odd_count_present = False for count in char_count.values(): if count % 2 == 0: length += count else: length += count - 1 odd_count_present = True if odd_count_present: length += 1 return length"},{"question":"# String Compression - Efficient In-Place Transformation You are given a list of characters that represents a string. Implement an in-place algorithm to compress the string using the following approach: For a character that appears once, keep it unchanged. For a character sequence that appears consecutively, replace the sequence with the character followed by the number of occurrences. The run-length encoding should shorten the string if possible. **Task**: Implement the given compression algorithm, ensuring to handle the in-place transformation without using additional space for another list. **Function Signature**: ```python def compress(chars: list) -> int: Compresses a list of characters in-place using run-length encoding. Args: chars (list): List of individual characters. Returns: int: The new length of the compressed list. ``` **Input/Output**: - **Input**: A list `chars` where each element is a single character (characters are limited to lowercase English letters and digits). - **Output**: The function returns the new length of the list after compression, but the list itself is modified in-place to reflect the compressed version. **Constraints**: - The list can be empty. - The list can contain any character from \'a\' to \'z\' and \'0\' to \'9\'. - The list size can be up to 10^5. **Performance**: - Ensure the implementation has a time complexity of O(n). - Optimize the algorithm to handle edge cases efficiently. **Examples**: ```python >>> chars = [\\"a\\",\\"a\\",\\"b\\",\\"b\\",\\"c\\",\\"c\\",\\"c\\"] >>> compress(chars) 6 >>> chars[:6] [\\"a\\",\\"2\\",\\"b\\",\\"2\\",\\"c\\",\\"3\\"] >>> chars = [\\"a\\"] >>> compress(chars) 1 >>> chars[:1] [\\"a\\"] >>> chars = [\\"a\\",\\"b\\",\\"b\\",\\"b\\",\\"c\\", \\"c\\", \\"d\\"] >>> compress(chars) 6 >>> chars[:6] [\\"a\\",\\"b\\",\\"3\\",\\"c\\",\\"2\\",\\"d\\"] >>> chars = [\\"o\\",\\"o\\",\\"o\\",\\"o\\",\\"o\\",\\"o\\",\\"o\\",\\"o\\",\\"o\\"] >>> compress(chars) 2 >>> chars[:2] [\\"o\\",\\"9\\"] >>> chars = [] >>> compress(chars) 0 >>> chars[:0] [] ``` **Additional Challenge**: Discuss in the comments the scenarios where the compression may not result in a shorter list and how the algorithm has been optimized to handle such cases. Aim to minimize memory usage and keep the solution in-place without using extra space for storing characters.","solution":"def compress(chars: list) -> int: Compresses a list of characters in-place using run-length encoding. Args: chars (list): List of individual characters. Returns: int: The new length of the compressed list. n = len(chars) if n == 0: return 0 write_index = 0 i = 0 while i < n: char = chars[i] count = 0 while i < n and chars[i] == char: i += 1 count += 1 chars[write_index] = char write_index += 1 if count > 1: for digit in str(count): chars[write_index] = digit write_index += 1 return write_index"},{"question":"# Problem Statement You are to implement a function `find_nearest_greater_elements` that takes an unsorted list of integers and returns a list where each element is replaced by the nearest greater element on its right. If there is no greater element on the right, replace it with -1. # Input * A list of integers `arr`, where (1 leq text{len(arr)} leq 10^5). # Output * A list of integers where each element is replaced by the nearest greater element on its right, or -1 if no such element exists. # Function Signature ```python def find_nearest_greater_elements(arr: list) -> list: pass ``` # Constraints * The solution should aim to be efficient with respect to both time and space complexity. * Avoid using brute-force solutions which might be too slow for large input sizes. # Example ```python >>> find_nearest_greater_elements([2, 5, 9, 3, 1, 7, 4]) [5, 9, -1, 7, 7, -1, -1] >>> find_nearest_greater_elements([10, 6, 5, 8, 11, 7]) [11, 8, 8, 11, -1, -1] >>> find_nearest_greater_elements([3, 2, 1]) [-1, -1, -1] ``` # Detailed Explanation * Traverse the list from right to left, using a stack to keep track of potential nearest greater elements. * For each element in the list: * Pop elements from the stack which are less than or equal to the current element. * If the stack is not empty after this, the nearest greater element is the one at the top of the stack. * If the stack is empty, there is no greater element on the right, so the element should be replaced with -1. * Push the current element onto the stack before moving to the next one. By using this approach, we can achieve the goal efficiently without unnecessary computations.","solution":"def find_nearest_greater_elements(arr: list) -> list: Replaces each element in arr with the nearest greater element on its right. If no such element exists, replace it with -1. n = len(arr) result = [-1] * n stack = [] for i in range(n - 1, -1, -1): while stack and stack[-1] <= arr[i]: stack.pop() if stack: result[i] = stack[-1] stack.append(arr[i]) return result"},{"question":"# Problem Statement You need to design a system that manages a library of books and allows users to perform various operations such as adding, searching, issuing, and returning books. Your solution should handle various edge cases and ensure efficient performance for each operation. # Objectives 1. **Class `Library` with the following methods:** - **Method `__init__(self)`:** - **Description**: Initializes an empty library. - **Method `add_book(self, title: str) -> None`:** - **Input**: - `title`: A string representing the title of the book to add to the library. - **Output**: None - **Constraints**: - A book with the same title can only be added once. - Raise a `ValueError` if a book with the given title is already present in the library. - **Method `search_book(self, query: str) -> List[str]`:** - **Input**: - `query`: A string representing a part of the title to search for. - **Output**: A list of strings representing book titles that contain the query substring. - **Constraints**: - The search should be case-insensitive. - The list should be sorted in alphabetical order. - **Method `issue_book(self, title: str) -> None`:** - **Input**: - `title`: A string representing the title of the book to issue. - **Output**: None - **Constraints**: - A book can only be issued if it is available in the library. - Raise a `ValueError` if the book is not present in the library. - **Method `return_book(self, title: str) -> None`:** - **Input**: - `title`: A string representing the title of the book to return. - **Output**: None - **Constraints**: - A book can only be returned if it was previously issued. - Raise a `ValueError` if the book was not issued by the library. # Examples ```python # Initializing a new Library instance lib = Library() # Adding books to the library lib.add_book(\\"The Great Gatsby\\") lib.add_book(\\"To Kill a Mockingbird\\") lib.add_book(\\"1984\\") # Searching for books assert lib.search_book(\\"great\\") == [\\"The Great Gatsby\\"] assert lib.search_book(\\"kill\\") == [\\"To Kill a Mockingbird\\"] # Issuing and returning books lib.issue_book(\\"The Great Gatsby\\") try: lib.issue_book(\\"The Great Gatsby\\") except ValueError as e: assert str(e) == \\"Book is already issued.\\" lib.return_book(\\"The Great Gatsby\\") try: lib.return_book(\\"The Great Gatsby\\") except ValueError as e: assert str(e) == \\"Book was not issued.\\" try: lib.add_book(\\"1984\\") except ValueError as e: assert str(e) == \\"Book is already present in the library.\\" ``` You are expected to write a complete implementation of the `Library` class and ensure it passes all the provided tests.","solution":"class Library: def __init__(self): self.books = set() self.issued_books = set() def add_book(self, title: str) -> None: if title in self.books: raise ValueError(\\"Book is already present in the library.\\") self.books.add(title) def search_book(self, query: str) -> list: query = query.lower() result = [book for book in self.books if query in book.lower()] result.sort() return result def issue_book(self, title: str) -> None: if title not in self.books: raise ValueError(\\"Book is not present in the library.\\") if title in self.issued_books: raise ValueError(\\"Book is already issued.\\") self.issued_books.add(title) def return_book(self, title: str) -> None: if title not in self.issued_books: raise ValueError(\\"Book was not issued.\\") self.issued_books.remove(title)"},{"question":"# Problem Statement In a string containing a mix of alphanumeric characters and spaces, the task is to determine the longest substring that consists of the same character. Write a function `longest_uniform_substring` that will take such a string and return the longest substring of identical characters along with its length. # Function Signature ```python def longest_uniform_substring(s: str) -> (str, int): ``` # Input and Output * **Input**: A string `s` consisting of alphanumeric characters and spaces. * **Output**: A tuple `(substring, length)` where `substring` is the longest substring of identical characters and `length` is its length. If there are multiple such substrings with the same length, return the first one encountered. # Constraints - The string `s` will have a length in the range [1, 1000]. - The string `s` will contain at least one character. - The alphanumeric characters include lowercase and uppercase letters from \'a\' to \'z\', \'A\' to \'Z\', and digits from \'0\' to \'9\'. - Spaces are included as valid characters in the string. # Example ```python assert longest_uniform_substring(\\"aaabbcaaaa\\") == (\\"aaaa\\", 4) assert longest_uniform_substring(\\"qwewrrr\\") == (\\"rrr\\", 3) assert longest_uniform_substring(\\"aAaAAAa\\") == (\\"AAA\\", 3) ``` # Notes - The function should properly handle strings with mixed case characters (e.g., \'A\' is different from \'a\'). - It should correctly handle strings that contain only spaces or digits, treating them as valid substrings. # Example Call ```python result = longest_uniform_substring(\\"aaabbcaaaa\\") print(result) # Should output (\\"aaaa\\", 4) ```","solution":"def longest_uniform_substring(s: str) -> (str, int): if not s: # If the string is empty return (\\"\\", 0) max_substr = \\"\\" max_length = 0 current_char = s[0] current_length = 1 for i in range(1, len(s)): if s[i] == current_char: current_length += 1 else: if current_length > max_length: max_length = current_length max_substr = current_char * max_length current_char = s[i] current_length = 1 # Final check at the end of the loop if current_length > max_length: max_length = current_length max_substr = current_char * max_length return (max_substr, max_length)"},{"question":"# Problem Statement You are provided with the task to analyze strings for their uniqueness. A string is considered \\"unique\\" if all of its characters are different. The goal is to find the longest substring of a given string where all characters are unique. Write a function that takes a string as input and returns the length of the longest substring with all unique characters. # Input * A single string `s` of length `n` (1 <= n <= 10^4), which contains only lowercase English letters. # Output * An integer representing the length of the longest substring with unique characters. # Constraints * The input string is guaranteed to have at least one character. # Function Signature ```python def longest_unique_substring(s: str) -> int: pass ``` # Examples ```python >>> longest_unique_substring(\\"abcabcbb\\") 3 # \\"abc\\" is the longest unique substring >>> longest_unique_substring(\\"bbbbb\\") 1 # \\"b\\" is the longest unique substring >>> longest_unique_substring(\\"pwwkew\\") 3 # \\"wke\\" is the longest unique substring >>> longest_unique_substring(\\"a\\") 1 # \\"a\\" is the only character and thus the longest unique substring >>> longest_unique_substring(\\"abcabcad\\") 4 # \\"bcad\\" is the longest unique substring ``` **Note**: This question involves understanding data structures such as sets or dictionaries for tracking characters and requires attention to detail in managing the sliding window technique to optimize the solution. Consider edge cases where the string might have repeating characters consecutively or only one repeating character surrounded by unique characters.","solution":"def longest_unique_substring(s: str) -> int: char_map = {} left = 0 max_length = 0 for right in range(len(s)): if s[right] in char_map: left = max(left, char_map[s[right]] + 1) char_map[s[right]] = right max_length = max(max_length, right - left + 1) return max_length"},{"question":"# Coding Assessment Question: String Transformation and Manipulation Objective Implement functions for transforming and manipulating strings to handle various edge cases and provide additional flexibility. Problem Statement You are given a string consisting of alphanumeric characters and spaces. Your task is to: 1. Write a function `remove_vowels(text: str) -> str` that removes all vowels (a, e, i, o, u) from the given string. 2. Write a function `reverse_words(text: str) -> str` that reverses the order of words in the given string while maintaining the original word order of alphabetic characters. Requirements 1. **remove_vowels**: * The function should return the input string with all vowels removed. * The input string will consist of both uppercase and lowercase characters and spaces. 2. **reverse_words**: * The function should return the input string with the order of words reversed. * Each word is defined as a sequence of alphabetic characters separated by spaces. Example ```python def remove_vowels(text: str) -> str: # Your implementation here def reverse_words(text: str) -> str: # Your implementation here # Example usage: example_text1 = \\"Hello World\\" example_text2 = \\"Python is fun\\" print(remove_vowels(example_text1)) # Output: \\"Hll Wrld\\" print(remove_vowels(example_text2)) # Output: \\"Pythn s fn\\" print(reverse_words(example_text1)) # Output: \\"World Hello\\" print(reverse_words(example_text2)) # Output: \\"fun is Python\\" ``` Constraints * The length of the input string `text` will be at least 1 and at most (10^6) characters. * Each character in `text` will be an uppercase or lowercase alphabetic character or a space. * No special characters or punctuations will be present in the input string.","solution":"def remove_vowels(text: str) -> str: Removes all vowels (a, e, i, o, u) from the given string. vowels = set(\\"aeiouAEIOU\\") return \'\'.join([char for char in text if char not in vowels]) def reverse_words(text: str) -> str: Reverses the order of words in the given string while maintaining the original word order of alphabetic characters. words = text.split() return \' \'.join(reversed(words))"},{"question":"# Coding Assessment Question **Scenario**: You\'re working on a new analytical tool that will help visualize data as minimal spanning trees. For this task, you need to enhance an existing `Graph` class to support computation of the Minimum Spanning Tree (MST) using Prim\'s algorithm for a given graph. **Requirements**: 1. **Update Graph Representation**: Ensure the graph can handle both directed and undirected edges, but MST will only be computed for undirected graphs. 2. **Prim\'s Algorithm Implementation**: Implement `prim_mst` to find the MST of the graph. 3. **Edge Case Handling**: Ensure the solution can handle disconnected graphs by providing appropriate messages. **Function Implementation**: 1. **mod_add_edge(from_vertex: int, to_vertex: int, weight: int) -> None** - Parameters: - `from_vertex`: The source vertex. - `to_vertex`: The destination vertex. - `weight`: The weight of the edge. - Adds an undirected edge from `from_vertex` to `to_vertex` with the specified weight. 2. **prim_mst() -> None** - Computes the Minimum Spanning Tree of the graph using Prim\'s algorithm and prints the edges in the MST along with their weights. If the graph is disconnected, print \\"Graph is disconnected, no MST exists\\". **Input**: ```python g = Graph() g.mod_add_edge(0, 1, 10) g.mod_add_edge(0, 2, 6) g.mod_add_edge(0, 3, 5) g.mod_add_edge(1, 3, 15) g.mod_add_edge(2, 3, 4) ``` **Output**: ```python # Minimum Spanning Tree edges: 0 - 3 with weight 5 3 - 2 with weight 4 0 - 1 with weight 10 # Total weight of MST: 19 ``` **Constraints**: - The graph can contain up to 1000 vertices. - Edge weights can range from 1 to 1000. - Ensure the solution handles graphs with no edges, disconnected vertices, and self-loops appropriately. Ensure your implementation is correct and efficient for the given constraints by testing with various graph configurations including sparse and dense graphs, and graphs with varying edge weights.","solution":"import heapq from collections import defaultdict class Graph: def __init__(self): self.graph = defaultdict(list) def mod_add_edge(self, from_vertex, to_vertex, weight): self.graph[from_vertex].append((weight, to_vertex)) self.graph[to_vertex].append((weight, from_vertex)) def prim_mst(self): if not self.graph: print(\\"Graph is empty, no MST exists\\") return start_vertex = list(self.graph.keys())[0] visited = set() min_heap = [] min_cost = 0 def add_edges(vertex): for weight, to_vertex in self.graph[vertex]: if to_vertex not in visited: heapq.heappush(min_heap, (weight, vertex, to_vertex)) add_edges(start_vertex) mst_edges = [] while min_heap and len(visited) < len(self.graph): weight, from_vertex, to_vertex = heapq.heappop(min_heap) if to_vertex not in visited: visited.add(to_vertex) min_cost += weight mst_edges.append((from_vertex, to_vertex, weight)) add_edges(to_vertex) if len(visited) != len(self.graph): print(\\"Graph is disconnected, no MST exists\\") else: print(\\"Minimum Spanning Tree edges:\\") for from_vertex, to_vertex, weight in mst_edges: print(f\\"{from_vertex} - {to_vertex} with weight {weight}\\") print(f\\"Total weight of MST: {min_cost}\\") # Example usage: g = Graph() g.mod_add_edge(0, 1, 10) g.mod_add_edge(0, 2, 6) g.mod_add_edge(0, 3, 5) g.mod_add_edge(1, 3, 15) g.mod_add_edge(2, 3, 4) g.prim_mst()"},{"question":"# Question **Balanced Parentheses with Star** You are given a string `s` that consists of `(`, `)`, and `*` characters. The `*` character can be treated as either a single `(`, a single `)`, or an empty string. Your task is to determine if the string `s` is a valid string where every open parenthesis `(` has a corresponding close parenthesis `)`. Write a function `checkValidString(s: str) -> bool` that returns True if the string is valid, and False otherwise. Input * A string `s` (1 ≤ len(s) ≤ 100). Output * Return a boolean value indicating whether the string is valid. Definitions and Clarifications * A valid string means that for every open parenthesis `(` in the string, there is a corresponding close parenthesis `)`, taking into account that `*` can substitute for either `(`, `)` or be omitted completely. Examples ```python >>> checkValidString(\\"(*))\\") True >>> checkValidString(\\"(*)\\") True >>> checkValidString(\\"(()*\\") True >>> checkValidString(\\")*(\\") False >>> checkValidString(\\")**(\\") False ``` # Scenario Imagine you\'re working on a parser for a programming language where strings can contain a placeholder character that should be evaluated as either a left or right parenthesis or nothing at all. This parser must verify that the resulting or intermediate strings meet the balance criteria for parentheses to ensure correctness and prevent syntax errors during compilation. Your task is to implement a validation function that uses the placeholder `*` to check if the string is balanced. Requirements * Account for all possible substitutions of `*` to evaluate if the string maintains valid parentheses structure. * Ensure the solution is efficient given the constraints and edge cases. Performance * Craft your implementation to handle the length of the string up to the upper limit efficiently and correctly evaluate all possible combinations of `*`.","solution":"def checkValidString(s: str) -> bool: Function to determine if the string with parentheses and stars is valid. # Two variables to keep track of minimum and maximum possible open parentheses min_open = 0 max_open = 0 for char in s: if char == \'(\': min_open += 1 max_open += 1 elif char == \')\': if min_open > 0: min_open -= 1 max_open -= 1 else: # char == \'*\' if min_open > 0: min_open -= 1 max_open += 1 # If at any point, max_open is negative, we have unmatched closing parenthesis if max_open < 0: return False # min_open must be 0 at the end to have a valid balance return min_open == 0"},{"question":"# Question: Sort List of Dictionaries **Context**: You are developing a feature for an e-commerce application where products need to be displayed in a sorted order based on multiple attributes. Each product is represented as a dictionary with keys such as `\'name\'`, `\'price\'`, and `\'rating\'`. Your task is to implement a sorting utility that sorts a list of these product dictionaries first by `\'price\'` (ascending) and then by `\'rating\'` (descending) in cases where two products have the same price. **Task**: Write a function `sort_products(products: List[Dict[str, Union[str, float]]]) -> List[Dict[str, Union[str, float]]]` that sorts the given list of product dictionaries. **Function Specifications**: ```python def sort_products(products: List[Dict[str, Union[str, float]]]) -> List[Dict[str, Union[str, float]]]: Sort a list of product dictionaries by price and rating. ``` **Input**: 1. A list of dictionaries `products`, where each dictionary represents a product with the following keys: - `\'name\'`: A string representing the product name. - `\'price\'`: A float representing the product price. - `\'rating\'`: A float representing the product rating. **Output**: 1. A list of dictionaries sorted first by `\'price\'` in ascending order and then by `\'rating\'` in descending order for products with the same price. **Constraints**: 1. All elements in the list `products` are valid dictionaries containing the required keys. 2. Raise a `ValueError` with a relevant message if any dictionary is missing one of the required keys. **Examples**: ```python products = [ {\'name\': \'Product A\', \'price\': 20.0, \'rating\': 4.3}, {\'name\': \'Product B\', \'price\': 15.0, \'rating\': 4.8}, {\'name\': \'Product C\', \'price\': 20.0, \'rating\': 4.5}, {\'name\': \'Product D\', \'price\': 30.0, \'rating\': 3.9} ] sorted_products = sort_products(products) assert sorted_products == [ {\'name\': \'Product B\', \'price\': 15.0, \'rating\': 4.8}, {\'name\': \'Product C\', \'price\': 20.0, \'rating\': 4.5}, {\'name\': \'Product A\', \'price\': 20.0, \'rating\': 4.3}, {\'name\': \'Product D\', \'price\': 30.0, \'rating\': 3.9} ] ``` **Note**: 1. Consider how to handle edge cases where there are duplicate products or products with the same name but different prices and ratings. 2. Ensure that the function operates efficiently for lists of up to 1000 products.","solution":"from typing import List, Dict, Union def sort_products(products: List[Dict[str, Union[str, float]]]) -> List[Dict[str, Union[str, float]]]: Sort a list of product dictionaries by price (ascending) and rating (descending). required_keys = {\'name\', \'price\', \'rating\'} # Verify all products contain required keys for product in products: if not required_keys.issubset(product.keys()): raise ValueError(f\\"Product {product} is missing one of the required keys: \'name\', \'price\', \'rating\'.\\") # Sort by price (ascending) and then by rating (descending) sorted_products = sorted(products, key=lambda x: (x[\'price\'], -x[\'rating\'])) return sorted_products"},{"question":"# Parsing Nested JSON Structures You are tasked with implementing a parser that extracts all integer values from a nested JSON structure. The parser should traverse all levels of the JSON data, identify integer values, and collect them into a list. # Requirements 1. Implement the function `extract_integers_from_json(json_data: dict) -> list[int]` which recursively searches through the given JSON object and collects all integers. # Inputs * **json_data**: A dictionary representing the JSON object, which can have nested dictionaries and lists containing integer values. # Outputs * A list of integers extracted from the JSON object. # Constraints 1. The JSON object may be arbitrarily nested but will only contain dictionaries, lists, and integers. 2. Non-integer values (e.g., strings, floats) should be ignored. # Example ```python def extract_integers_from_json(json_data): integers = [] def recurse(data): if isinstance(data, dict): for key, value in data.items(): recurse(value) elif isinstance(data, list): for item in data: recurse(item) elif isinstance(data, int): integers.append(data) recurse(json_data) return integers # Example Usage: json_data = { \\"level1\\": { \\"level2\\": [1, 2, {\\"level3\\": 3, \\"other\\": \\"string\\"}, 4], \\"another_list\\": [5, {\\"level3_2\\": 6}] }, \\"top_level\\": 7 } print(extract_integers_from_json(json_data)) # Output: [1, 2, 3, 4, 5, 6, 7] ``` # Explanation In this example, the `json_data` contains several levels of nested dictionaries and lists. The function extracts all the integers across these levels and returns them as a list. In this case, the integers 1, 2, 3, 4, 5, 6, and 7 are extracted and returned in a single list.","solution":"def extract_integers_from_json(json_data): Recursively extract all integer values from a nested JSON structure. Parameters: - json_data (dict): The JSON object to search within. Returns: - list[int]: A list of integers found in the JSON object. integers = [] def recurse(data): if isinstance(data, dict): for key, value in data.items(): recurse(value) elif isinstance(data, list): for item in data: recurse(item) elif isinstance(data, int): integers.append(data) recurse(json_data) return integers"},{"question":"# Problem Statement A common algorithmic task involves operating on an array of integers to compute cumulative values. This problem asks you to implement such a solution by performing the following steps: 1. **Prefix Sum Calculation**: Implement a function to compute the prefix sums of an array. 2. **Range Sum Query**: Implement a function to compute the sum of elements within a specified subarray. 3. **Range Update Query**: Implement a function for range updates that adds a given value to all elements within a specified subarray. 4. **Maximum Subarray Sum**: Implement a function to find the maximum sum of any contiguous subarray using the prefix sums. # Function Signatures ```python def compute_prefix_sums(arr: list[int]) -> list[int]: pass def range_sum_query(prefix_sums: list[int], left: int, right: int) -> int: pass def range_update_query(arr: list[int], left: int, right: int, val: int) -> list[int]: pass def maximum_subarray_sum(arr: list[int]) -> int: pass ``` # Input/Output Formats * **compute_prefix_sums**: - **Input**: A list `arr` of integers. - **Output**: A list of integers representing the prefix sums of `arr`. * **range_sum_query**: - **Input**: A list `prefix_sums` of integers (as computed by `compute_prefix_sums`), and two integers `left` and `right` representing the inclusive indices of the subarray. - **Output**: An integer representing the sum of elements in `arr[left:right+1]`. * **range_update_query**: - **Input**: A list `arr` of integers, two integers `left` and `right` representing the inclusive indices for the range, and an integer `val` to add to each element within the range. - **Output**: A new list with the updated values. * **maximum_subarray_sum**: - **Input**: A list `arr` of integers. - **Output**: An integer representing the maximum sum of any contiguous subarray. # Constraints * `1 <= len(arr) <= 10^5` * `-10^9 <= arr[i], val <= 10^9` * `0 <= left <= right < len(arr)` # Example ```python arr = [1, 2, 3, 4, 5] prefix_sums = compute_prefix_sums(arr) assert prefix_sums == [1, 3, 6, 10, 15] range_sum = range_sum_query(prefix_sums, 1, 3) assert range_sum == 9 updated_arr = range_update_query(arr, 1, 3, 2) assert updated_arr == [1, 4, 5, 6, 5] max_subarray_sum = maximum_subarray_sum(arr) assert max_subarray_sum == 15 ``` # Implementation Notes 1. **Prefix Sum Calculation**: Compute prefix sums where each element at index `i` is the sum of elements from the start of the array up to `i`. 2. **Range Sum Query**: Use the prefix sums to quickly calculate the sum of any specified subarray. 3. **Range Update Query**: Modify the array in place to add a given value to a range of elements. 4. **Maximum Subarray Sum**: Utilize Kadane\'s algorithm to find the maximum sum of any contiguous subarray efficiently.","solution":"def compute_prefix_sums(arr: list[int]) -> list[int]: prefix_sums = [0] * len(arr) prefix_sums[0] = arr[0] for i in range(1, len(arr)): prefix_sums[i] = prefix_sums[i - 1] + arr[i] return prefix_sums def range_sum_query(prefix_sums: list[int], left: int, right: int) -> int: if left == 0: return prefix_sums[right] else: return prefix_sums[right] - prefix_sums[left - 1] def range_update_query(arr: list[int], left: int, right: int, val: int) -> list[int]: for i in range(left, right + 1): arr[i] += val return arr def maximum_subarray_sum(arr: list[int]) -> int: max_ending_here = max_so_far = arr[0] for x in arr[1:]: max_ending_here = max(x, max_ending_here + x) max_so_far = max(max_so_far, max_ending_here) return max_so_far"},{"question":"# Problem Description You are tasked with implementing a Most Recently Used (MRU) Cache which will be initialized with a given capacity. The cache should support the following operations: - `refer(key: T)`: Adds the provided key to the cache. If the cache is full, it will remove the most recently used key before adding the new key. - `fetch(key: T) -> bool`: Checks if the provided key exists in the cache. If the key exists, it is considered as accessed but does not affect its position. - `display() -> List[T]`: Returns a list of all keys in the cache in their current order from most recently used to least recently used. **Input Constraints** - `cache_capacity: int` (1 ≤ cache_capacity ≤ 10^4) - Keys can be any hashable type such as int, str, etc. **Output Description** - Implement the specified functions. - Your cache must support efficient operations with correct time complexities: - `refer`: O(1) for adding a new key or promoting an existing key. - `fetch`: O(1) to check existence without changing the key\'s position. **Example Input** ```python mru_cache = MRUCache(3) mru_cache.refer(1) mru_cache.refer(2) mru_cache.refer(3) print(mru_cache.display()) # Output: [3, 2, 1] mru_cache.refer(4) print(mru_cache.display()) # Output: [4, 3, 2] print(mru_cache.fetch(2)) # Output: True print(mru_cache.display()) # Output: [4, 3, 2] print(mru_cache.fetch(1)) # Output: False print(mru_cache.display()) # Output: [4, 3, 2] ``` **Detailed Instructions** 1. Implement the `MRUCache` class with: - An `__init__` method to initialize the cache size. - A `refer` method to add keys and manage cache size by removing the most recently used key if needed. - A `fetch` method to check for key existence without affecting its position. - A `display` method to view the current cache state. This problem requires handling the MRU caching mechanism with efficient time complexities for `refer` and `fetch` operations, similar in style and complexity to the original LRU caching problem.","solution":"from collections import OrderedDict class MRUCache: def __init__(self, capacity: int): self.capacity = capacity self.cache = OrderedDict() def refer(self, key): if key in self.cache: del self.cache[key] elif len(self.cache) == self.capacity: self.cache.popitem(last=False) # Remove the most recently used item (first item) self.cache[key] = True # Add the key as the most recently used def fetch(self, key) -> bool: return key in self.cache def display(self): return list(self.cache.keys())[::-1] # Return from most recently used to least recently used"},{"question":"# Problem Statement You are assigned to develop a function that processes and queries a list of products in an e-commerce system. Each product has the following attributes: `name`, `category`, `price`, and `stock_quantity`. # Objectives 1. **Implement the function to store and manage the product data**. 2. **Create a helper function to update the stock quantity of a product when a sale is made**. 3. **Provide a query function that filters products based on price range and category**. # Requirements 1. Implement the function `process_product_operation` which accepts the following parameters: * `operation` (str): The operation to be performed. It can be one of `\\"add_product\\"`, `\\"update_stock\\"`, or `\\"query_products\\"`. * `data` (dict): A dictionary containing the relevant data for the operation. * `products` (list): A list of dictionaries where each dictionary represents a product. 2. The `process_product_operation` function should perform the following: * `\\"add_product\\"`: Add a new product to the list `products`. * Example `data` format: `{\\"name\\": \\"product1\\", \\"category\\": \\"category1\\", \\"price\\": 100.0, \\"stock_quantity\\": 10}` * `\\"update_stock\\"`: Update the stock quantity of an existing product. * Example `data` format: `{\\"name\\": \\"product1\\", \\"quantity_sold\\": 2}` * `\\"query_products\\"`: Query and return a list of products filtered by price range and category. * Example data format: `{\\"min_price\\": 10.0, \\"max_price\\": 100.0, \\"category\\": \\"category1\\"}` 3. Ensure the function handles invalid operations and returns appropriate error messages. 4. Implement validation for each operation: * For `\\"add_product\\"`, check if all required fields are provided. * For `\\"update_stock\\"`, ensure the product exists and the stock quantity does not drop below 0. * For `\\"query_products\\"`, verify valid price range and category. 5. Return the result of operation or updated list of products as required. # Input Format * `operation`: A string denoting the operation type. * `data`: A dictionary containing data related to the operation. * `products`: A list of dictionaries, each representing a product. # Output Format Depending on the operation, either a success message, the updated list of products, or error messages. # Example ```python products = [] process_product_operation(\\"add_product\\", {\\"name\\": \\"Product1\\", \\"category\\": \\"Cat1\\", \\"price\\": 50.0, \\"stock_quantity\\": 20}, products) # Output: \\"Product added successfully\\" process_product_operation(\\"update_stock\\", {\\"name\\": \\"Product1\\", \\"quantity_sold\\": 5}, products) # Output: \\"Stock updated successfully\\" result = process_product_operation(\\"query_products\\", {\\"min_price\\": 10.0, \\"max_price\\": 100.0, \\"category\\": \\"Cat1\\"}, products) # Output: [{\\"name\\": \\"Product1\\", \\"category\\": \\"Cat1\\", \\"price\\": 50.0, \\"stock_quantity\\": 15}] ``` # Constraint * The list of products should be mutable and consistent across multiple function calls ensuring data persistence within the session.","solution":"def process_product_operation(operation, data, products): Processes product operation for an e-commerce system. Parameters: operation (str): Can be one of \\"add_product\\", \\"update_stock\\", or \\"query_products\\". data (dict): Contains the relevant data for the operation. products (list): A list of product dictionaries. Returns: str or list: Success message, updated products list, or error message. if operation == \\"add_product\\": if not all(k in data for k in (\\"name\\", \\"category\\", \\"price\\", \\"stock_quantity\\")): return \\"Error: Missing required fields for adding product.\\" products.append({ \\"name\\": data[\\"name\\"], \\"category\\": data[\\"category\\"], \\"price\\": data[\\"price\\"], \\"stock_quantity\\": data[\\"stock_quantity\\"], }) return \\"Product added successfully\\" elif operation == \\"update_stock\\": product = next((item for item in products if item[\\"name\\"] == data[\\"name\\"]), None) if product is None: return \\"Error: Product not found.\\" if product[\\"stock_quantity\\"] < data[\\"quantity_sold\\"]: return \\"Error: Insufficient stock quantity.\\" product[\\"stock_quantity\\"] -= data[\\"quantity_sold\\"] return \\"Stock updated successfully\\" elif operation == \\"query_products\\": min_price = data.get(\\"min_price\\", float(\'-inf\')) max_price = data.get(\\"max_price\\", float(\'inf\')) category = data.get(\\"category\\", None) filtered_products = [ product for product in products if min_price <= product[\\"price\\"] <= max_price and (category is None or product[\\"category\\"] == category) ] return filtered_products else: return \\"Error: Invalid operation.\\""},{"question":"# Coding Question You are asked to develop a Python program that simulates the functionality of a simplified bank account management system. The system should allow users to create accounts, deposit and withdraw funds, and check their balance. Objective Enhance the existing functions for account management and introduce additional features to improve the system\'s usability and robustness. 1. **Enhance Existing Functions**: - Improve the `create_account` function to ensure unique account IDs for each user. - Modify the `deposit` and `withdraw` functions to include validation checks for the amount being deposited or withdrawn. Ensure amounts are positive and appropriate error messages are provided for invalid transactions. 2. **Add New Functionalities**: - Implement a function `transfer` to enable fund transfers between two accounts. - Implement comprehensive input validation in the `main` function, prompting users until valid input (account ID, amount) is provided. Function Implementations - **create_account(username: str) -> dict**: - Input: A string (username). - Output: Returns a dictionary representing the new account with a unique account ID, username, and an initial balance of 0. Raise a `ValueError` if the username already exists. - **deposit(account_id: int, amount: float) -> float**: - Add the amount to the account\'s balance if valid. Raise a `ValueError` for invalid amounts (e.g., negative values). - **withdraw(account_id: int, amount: float) -> float**: - Deduct the amount from the account\'s balance if funds are sufficient. Raise a `ValueError` for invalid amounts or insufficient funds. - **transfer(from_account_id: int, to_account_id: int, amount: float) -> None**: - Transfer the specified amount from one account to another if sufficient funds are available. Raise a `ValueError` for invalid amounts or insufficient funds. Example ```python >>> account1 = create_account(\\"Alice\\") >>> account2 = create_account(\\"Bob\\") >>> deposit(account1[\'account_id\'], 1000.0) 1000.0 >>> withdraw(account1[\'account_id\'], 200.0) 800.0 >>> transfer(account1[\'account_id\'], account2[\'account_id\'], 100.0) None >>> check_balance(account1[\'account_id\']) 700.0 >>> check_balance(account2[\'account_id\']) 100.0 ``` **Note**: The system should maintain a record of the accounts in memory for the duration of the program and support the above functionalities robustly with appropriate error handling.","solution":"class BankAccount: accounts = {} current_id = 1 @classmethod def create_account(cls, username: str) -> dict: for account in cls.accounts.values(): if account[\'username\'] == username: raise ValueError(\\"Username already exists.\\") account = { \'account_id\': cls.current_id, \'username\': username, \'balance\': 0.0 } cls.accounts[cls.current_id] = account cls.current_id += 1 return account @classmethod def deposit(cls, account_id: int, amount: float) -> float: if amount <= 0: raise ValueError(\\"Deposit amount must be positive.\\") if account_id not in cls.accounts: raise ValueError(\\"Account ID does not exist.\\") cls.accounts[account_id][\'balance\'] += amount return cls.accounts[account_id][\'balance\'] @classmethod def withdraw(cls, account_id: int, amount: float) -> float: if amount <= 0: raise ValueError(\\"Withdrawal amount must be positive.\\") if account_id not in cls.accounts: raise ValueError(\\"Account ID does not exist.\\") if cls.accounts[account_id][\'balance\'] < amount: raise ValueError(\\"Insufficient funds.\\") cls.accounts[account_id][\'balance\'] -= amount return cls.accounts[account_id][\'balance\'] @classmethod def transfer(cls, from_account_id: int, to_account_id: int, amount: float) -> None: if amount <= 0: raise ValueError(\\"Transfer amount must be positive.\\") if from_account_id not in cls.accounts or to_account_id not in cls.accounts: raise ValueError(\\"One or both account IDs do not exist.\\") if cls.accounts[from_account_id][\'balance\'] < amount: raise ValueError(\\"Insufficient funds in the source account.\\") cls.withdraw(from_account_id, amount) cls.deposit(to_account_id, amount) @classmethod def check_balance(cls, account_id: int) -> float: if account_id not in cls.accounts: raise ValueError(\\"Account ID does not exist.\\") return cls.accounts[account_id][\'balance\']"},{"question":"# Missing Number in Sequences **Context:** You are given a list of integers that is supposed to contain all the numbers from 0 to `n`, but one number is missing. Your task is to identify the missing number in the list. This is a common problem that can be solved with various techniques, including sorting, hash sets, or mathematical formulae. **Task:** Write a function that returns the missing number from the list of integers ranging from 0 to `n`. **Function Signature:** ```python def find_missing_number(arr: list[int]) -> int: ``` **Input:** - `arr` (list of integers): A list containing integers from 0 to n with exactly one missing number. **Output:** - `int`: The missing number. **Constraints:** - 1 <= len(arr) <= 1000 (This ensures the array is not too large.) - The list will contain n distinct integers in the range [0, n] with exactly one number missing. **Example:** ```python >>> find_missing_number([3, 0, 1]) 2 >>> find_missing_number([0, 1, 2, 4]) 3 ``` **Performance Requirements:** - The function should aim to solve the problem in O(n) time complexity.","solution":"def find_missing_number(arr): Returns the missing number from the list of integers ranging from 0 to n. n = len(arr) # Calculate the expected sum of numbers from 0 to n using the formula expected_sum = n * (n + 1) / 2 # Calculate the sum of elements in the array actual_sum = sum(arr) # The difference between the expected sum and the actual sum is the missing number return int(expected_sum - actual_sum)"},{"question":"**Scenario**: In a world driven by data processing, you are tasked with managing a large dataset of numbers. The dataset contains both positive and negative integers, and you need to find a contiguous subarray that has the largest sum. Efficiently solving this problem is crucial, as it will help identify important patterns in the data. **Problem Statement**: Write a function `max_subarray_sum(nums: list[int]) -> int` that finds the contiguous subarray within a list (containing at least one number) which has the largest sum and returns this sum. # Input: 1. `nums`: A list of integers. # Output: An integer representing the largest sum of the contiguous subarray. # Constraints: - The length of `nums` is at least 1. - The elements in `nums` are both positive and negative integers. # Examples: ```python assert max_subarray_sum([4, -1, 2, 1]) == 6 # Subarray: [4, -1, 2, 1] assert max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6 # Subarray: [4, -1, 2, 1] assert max_subarray_sum([1]) == 1 # Subarray: [1] assert max_subarray_sum([-1, -2, -3, -4]) == -1 # Subarray: [-1] assert max_subarray_sum([2, 2, -1, 2, 2]) == 7 # Subarray: [2, 2, -1, 2, 2] ``` # Additional Notes: - The function should have a time complexity of O(n), where n is the length of the input list. - Consider both large positive and large negative subarrays for comprehensive testing. - Ensure the function is robust and handles edge cases gracefully, especially subarrays containing only negative numbers.","solution":"def max_subarray_sum(nums): Finds the contiguous subarray with the largest sum. :param nums: List of integers :return: Largest sum of the contiguous subarray if not nums: raise ValueError(\\"Input list must contain at least one element\\") max_current = max_global = nums[0] for num in nums[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"# Context When dealing with large datasets or high-frequency operations, efficiently calculating moving averages becomes a priority. A moving average for a given window size provides the mean of elements within that window as it slides through the dataset. # Problem Implement a class that maintains a fixed-size sliding window and allows for computing the moving average of the last N elements. Initially, the sliding window would be empty, and elements are added one by one using a method. # Task 1. Implement a class `MovingAverage` with the following methods: - `__init__(self, size: int)`: Initializes the object with the window size. - `add_element(self, val: int) -> None`: Adds an integer to the sliding window. - `get_moving_average(self) -> float`: Returns the current moving average of the elements in the window. # Requirements 1. **Constructor**: `__init__(self, size: int)` - **Input**: An integer `size` representing the size of the moving window (1 ≤ size ≤ (10^4)). - **Output**: Initializes an instance of `MovingAverage`. - **Constraints**: - The window size `size` should be at least 1 and at most 10,000. 2. **Method 1**: `add_element(self, val: int) -> None` - **Input**: An integer `val` (|val| ≤ (10^5)). - **Output**: Adds the integer to the sliding window. - **Constraints**: - If the number of elements exceeds the window size, remove the oldest element. 3. **Method 2**: `get_moving_average(self) -> float` - **Input**: No arguments. - **Output**: Returns the current moving average of the elements in the window as a float. - **Constraints**: - If there are fewer elements than the window size, compute the average of the available elements. # Examples ```python # Initialize with window size 3 ma = MovingAverage(3) # Add elements and get moving average ma.add_element(1) assert ma.get_moving_average() == 1.0 # Only one element ma.add_element(10) assert ma.get_moving_average() == 5.5 # Average of [1, 10] ma.add_element(3) assert ma.get_moving_average() == 4.666666666666667 # Average of [1, 10, 3] ma.add_element(5) assert ma.get_moving_average() == 6.0 # Average of [10, 3, 5] ```","solution":"from collections import deque class MovingAverage: def __init__(self, size: int): Initialize the MovingAverage with the required window size. self.size = size self.window = deque() self.current_sum = 0 def add_element(self, val: int) -> None: Add an element to the sliding window. if len(self.window) == self.size: self.current_sum -= self.window.popleft() self.window.append(val) self.current_sum += val def get_moving_average(self) -> float: Return the moving average of the current elements in the window. return self.current_sum / len(self.window)"},{"question":"**Problem Statement**: Create a function that calculates the Greatest Common Divisor (GCD) of two integers using both the Euclidean algorithm (iterative method) and a recursive approach. Your task is to implement these two methods and handle common edge cases and error conditions properly. # Function Signatures: ```python def gcd_recursive(a: int, b: int) -> int: pass def gcd_iterative(a: int, b: int) -> int: pass ``` # Input: The functions `gcd_recursive` and `gcd_iterative` should accept the following inputs: - `a` and `b` are integers. # Output: - Both functions should return an integer, representing the GCD of the two input values. - If either input is not an integer, raise a `ValueError` with the message `\\"<function_name>() only accepts integral values\\"`. - If both inputs are zero, raise a `ValueError` with the message `\\"GCD is not defined for both inputs as zero\\"`. # Examples: ```python gcd_recursive(48, 18) # Expected output: 6 gcd_iterative(54, 24) # Expected output: 6 gcd_recursive(0, 5) # Expected output: 5 gcd_iterative(20, 0) # Expected output: 20 ``` # Constraints: - Both functions must compute the result in (O(log(min(a, b)))) time complexity. - Both functions must handle the edge cases and errors as specified.","solution":"def gcd_recursive(a: int, b: int) -> int: Calculate the GCD using the recursive Euclidean algorithm. if not isinstance(a, int) or not isinstance(b, int): raise ValueError(\\"gcd_recursive() only accepts integral values\\") if a == 0 and b == 0: raise ValueError(\\"GCD is not defined for both inputs as zero\\") if b == 0: return abs(a) return gcd_recursive(b, a % b) def gcd_iterative(a: int, b: int) -> int: Calculate the GCD using the iterative Euclidean algorithm. if not isinstance(a, int) or not isinstance(b, int): raise ValueError(\\"gcd_iterative() only accepts integral values\\") if a == 0 and b == 0: raise ValueError(\\"GCD is not defined for both inputs as zero\\") a, b = abs(a), abs(b) while b != 0: a, b = b, a % b return a"},{"question":"# Context You are working with a binary tree data structure in Python and need to enhance its functionality with new operations. A specific operation, `invert_tree`, already inverts the binary tree. # Task Implement a method `find_all_paths(self) -> List[List[int]]` within the `BinaryTree` class that finds all root-to-leaf paths in the binary tree. Each path should be represented as a list of node values. # Function Signature ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BinaryTree: def __init__(self, root=None): self.root = root def find_all_paths(self) -> List[List[int]]: # Your code here ``` # Input * No input parameters are required. The function should work with the existing binary tree. # Output * The function returns a list of lists, where each inner list represents a root-to-leaf path. # Constraints * The number of nodes in the tree is in the range [0, 500]. * The value of each node is an integer between `-1000` and `1000`. # Example ```python >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> bt = BinaryTree(root) >>> bt.find_all_paths() [[1, 2, 4], [1, 2, 5], [1, 3]] >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> bt = BinaryTree(root) >>> bt.find_all_paths() [[1, 2]] ``` # Notes * A root-to-leaf path is defined as a sequence of nodes starting from the root node and ending at any leaf node. * Return an empty list if the binary tree is empty. * Ensure to handle both balanced and unbalanced binary trees effectively.","solution":"from typing import List class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BinaryTree: def __init__(self, root=None): self.root = root def find_all_paths(self) -> List[List[int]]: if not self.root: return [] def dfs(node, path, paths): if not node: return path.append(node.val) if not node.left and not node.right: paths.append(path.copy()) else: dfs(node.left, path, paths) dfs(node.right, path, paths) path.pop() # backtrack paths = [] dfs(self.root, [], paths) return paths"},{"question":"# User CRUD with HTTP Requests **Objective**: Write a script to handle basic CRUD operations (Create, Read, Update, Delete) for user data via HTTP requests using a REST API. **Task**: 1. Implement a class `UserAPI` that has methods for each CRUD operation: - `create_user(data: dict) -> dict` - `get_user(user_id: int) -> dict` - `update_user(user_id: int, data: dict) -> dict` - `delete_user(user_id: int) -> dict` 2. Integrate the class methods to handle JSON data and HTTP response status codes effectively. 3. Ensure the script can be executed standalone via the `__main__` block allowing the user to interact with these methods from the command line. ```python import requests class UserAPI: def __init__(self, base_url: str): self.base_url = base_url def create_user(self, data: dict) -> dict: Create a new user with provided data. Args: data: A dictionary containing user information. Returns: A dictionary with the response from the server. # Code implementation here pass def get_user(self, user_id: int) -> dict: Retrieve user information by user ID. Args: user_id: The ID of the user to retrieve. Returns: A dictionary with the user data. # Code implementation here pass def update_user(self, user_id: int, data: dict) -> dict: Update user information with provided data. Args: user_id: The ID of the user to update. data: A dictionary containing the user information to update. Returns: A dictionary with the response from the server. # Code implementation here pass def delete_user(self, user_id: int) -> dict: Delete a user by user ID. Args: user_id: The ID of the user to delete. Returns: A dictionary with the response from the server. # Code implementation here pass if __name__ == \\"__main__\\": base_url = \\"https://api.example.com/users\\" api = UserAPI(base_url) # Example Usage # Create a new user new_user_data = {\\"name\\": \\"John Doe\\", \\"email\\": \\"john@example.com\\"} print(api.create_user(new_user_data)) # Get user by ID user_id = 1 print(api.get_user(user_id)) # Update user by ID update_data = {\\"name\\": \\"John Doe Jr.\\"} print(api.update_user(user_id, update_data)) # Delete user by ID print(api.delete_user(user_id)) ``` **Constraints**: - The API endpoint is expected to have standard REST endpoints (e.g., POST `/users`, GET `/users/{id}`, PUT `/users/{id}`, DELETE `/users/{id}`). - The base URL will be valid and accessible. - The user data will be provided in a correct JSON format. **Expected Input/Output**: - **Input**: JSON data for creating or updating a user, and user ID for retrieving or deleting. - **Output**: A JSON response from the server indicating the result of the operation. **Examples**: 1. Creating a new user with data `{\\"name\\": \\"John Doe\\", \\"email\\": \\"john@example.com\\"}` - [Output]: `{\\"id\\": 1, \\"name\\": \\"John Doe\\", \\"email\\": \\"john@example.com\\"}` 2. Retrieving a user by ID `1`: - [Output]: `{\\"id\\": 1, \\"name\\": \\"John Doe\\", \\"email\\": \\"john@example.com\\"}` 3. Updating a user with ID `1` with data `{\\"name\\": \\"John Doe Jr.\\"}`: - [Output]: `{\\"id\\": 1, \\"name\\": \\"John Doe Jr.\\", \\"email\\": \\"john@example.com\\"}` 4. Deleting a user by ID `1`: - [Output]: `{\\"message\\": \\"User deleted\\"}` **Performance Requirements**: - Ensure the HTTP requests are made efficiently and handle potential errors such as HTTP timeouts or invalid responses gracefully.","solution":"import requests class UserAPI: def __init__(self, base_url: str): self.base_url = base_url def create_user(self, data: dict) -> dict: Create a new user with provided data. Args: data: A dictionary containing user information. Returns: A dictionary with the response from the server. response = requests.post(f\\"{self.base_url}/users\\", json=data) response.raise_for_status() # Raises HTTPError, if one occurred return response.json() def get_user(self, user_id: int) -> dict: Retrieve user information by user ID. Args: user_id: The ID of the user to retrieve. Returns: A dictionary with the user data. response = requests.get(f\\"{self.base_url}/users/{user_id}\\") response.raise_for_status() # Raises HTTPError, if one occurred return response.json() def update_user(self, user_id: int, data: dict) -> dict: Update user information with provided data. Args: user_id: The ID of the user to update. data: A dictionary containing the user information to update. Returns: A dictionary with the response from the server. response = requests.put(f\\"{self.base_url}/users/{user_id}\\", json=data) response.raise_for_status() # Raises HTTPError, if one occurred return response.json() def delete_user(self, user_id: int) -> dict: Delete a user by user ID. Args: user_id: The ID of the user to delete. Returns: A dictionary with the response from the server. response = requests.delete(f\\"{self.base_url}/users/{user_id}\\") response.raise_for_status() # Raises HTTPError, if one occurred return response.json() if __name__ == \\"__main__\\": base_url = \\"https://api.example.com\\" api = UserAPI(base_url) # Example Usage # Create a new user new_user_data = {\\"name\\": \\"John Doe\\", \\"email\\": \\"john@example.com\\"} print(api.create_user(new_user_data)) # Get user by ID user_id = 1 print(api.get_user(user_id)) # Update user by ID update_data = {\\"name\\": \\"John Doe Jr.\\"} print(api.update_user(user_id, update_data)) # Delete user by ID print(api.delete_user(user_id))"},{"question":"# Problem Statement: You are required to implement an **Interval Union-Find Data Structure**. This structure should efficiently manage a set of disjoint intervals and support union and find operations on intervals. Specifically, the interval union operation should merge overlapping or adjacent intervals, and the interval find operation should determine the interval that contains a given point. Function Signatures: 1. `__init__(self) -> None`: Initialize the data structure with no intervals. 2. `add_interval(self, start: int, end: int) -> None`: Add a new interval [`start`, `end`). If this interval overlaps with or touches any existing intervals, merge them. 3. `find_interval(self, point: int) -> Optional[Tuple[int, int]]`: Find and return the interval that contains the given point as a tuple `(start, end)`. If the point is not contained in any interval, return `None`. Constraints: - Intervals are defined using closed-open notation [start, end) meaning they include the start point but do not include the end point. - You can assume interval endpoints are within the range [0, 10^9]. - The number of intervals added will not exceed 10^5. - Points for find operations will also be within the range [0, 10^9]. - There will be at most 10^5 operations (combined add and find calls). Example: ```python >>> iu = IntervalUnionFind() >>> iu.add_interval(1, 5) >>> iu.add_interval(10, 15) >>> iu.find_interval(3) (1, 5) >>> iu.find_interval(7) None >>> iu.add_interval(4, 12) >>> iu.find_interval(11) (1, 15) >>> iu.find_interval(2) (1, 15) ``` # Implementation: You are required to implement the `IntervalUnionFind` class to meet the given specifications. Ensure efficient merging of intervals and fast retrieval of the interval containing a point. Pay special attention to edge cases such as adding overlapping or adjacent intervals.","solution":"class IntervalUnionFind: def __init__(self) -> None: self.intervals = [] def add_interval(self, start: int, end: int) -> None: new_intervals = [] added = False for s, e in self.intervals: if e < start or end < s: # No overlap new_intervals.append((s, e)) else: # Overlap, merge intervals start = min(start, s) end = max(end, e) added = True new_intervals.append((start, end)) new_intervals.sort() self.intervals = new_intervals def find_interval(self, point: int) -> \\"Optional[Tuple[int, int]]\\": for s, e in self.intervals: if s <= point < e: return (s, e) return None"},{"question":"# Problem Description You are given a string `input_string` containing lowercase alphabets only. Your task is to write a function `longest_repeating_substring` that finds the length of the longest substring in which all the characters are the same. # Input * `input_string` (str): A string consisting of lowercase alphabetic characters only. # Output * The function should return an integer representing the length of the longest substring where all characters are the same. # Constraints * The length of `input_string` is between 0 and 10^5. # Example ```python >>> longest_repeating_substring(\\"aaabb\\") 3 >>> longest_repeating_substring(\\"abbbbbcc\\") 5 >>> longest_repeating_substring(\\"abc\\") 1 >>> longest_repeating_substring(\\"\\") 0 >>> longest_repeating_substring(\\"a\\") 1 ``` # Requirements * Implement the function `longest_repeating_substring` that meets the specifications. * Ensure the code efficiently handles strings of length up to 10^5.","solution":"def longest_repeating_substring(input_string): Finds the length of the longest substring where all characters are the same. if not input_string: return 0 max_length = 1 current_length = 1 n = len(input_string) for i in range(1, n): if input_string[i] == input_string[i-1]: current_length += 1 else: max_length = max(max_length, current_length) current_length = 1 return max(max_length, current_length)"},{"question":"# Problem Statement You are required to implement a Python function that reverses the letters of each word in a given string, but maintains the order of words and the original whitespace characters. # Input - A string `s` containing space-separated words, where 1 <= len(s) <= 10,000. The string can contain multiple contiguous spaces. # Output - A new string with each word\'s letters reversed but with the words in their original order and the same whitespace character positions. # Constraints - The function should have a time complexity of O(n), where n is the length of the input string. - The function should handle whitespace characters correctly, preserving the original spacing in the output. # Example ```python >>> reverse_words(\\"The quick brown fox\\") \\"ehT kciuq nworb xof\\" >>> reverse_words(\\" Hello World \\") \\" olleH dlroW \\" >>> reverse_words(\\"Python is fun\\") \\"nohtyP si nuf\\" >>> reverse_words(\\" Keep Calm and Code On \\") \\" peeK mlac dna edoC nO \\" ``` # Hints 1. Consider splitting the input string into words while preserving whitespace for easier manipulation. 2. Use string manipulation techniques to reverse each word individually. ```python def reverse_words(s: str) -> str: Reverses the letters of each word in a given string while preserving the order of words and spaces. Args: s (str): The input string to process. Returns: str: A new string with each word\'s letters reversed. pass if __name__ == \\"__main__\\": import doctest doctest.testmod() ```","solution":"def reverse_words(s: str) -> str: Reverses the letters of each word in a given string while preserving the order of words and spaces. Args: s (str): The input string to process. Returns: str: A new string with each word\'s letters reversed. return \' \'.join(word[::-1] for word in s.split(\' \'))"},{"question":"# Coding Assessment Question You are given two integers `x` and `y`, and your task is to implement a function `mod_exp(x: int, y: int, p: int) -> int` that returns the result of `(x^y) % p`, where `^` represents exponentiation. Input * Two integers `x` and `y`, where (1 <= x <= 10^9) and (0 <= y <= 10^9). * An integer `p` where (1 <= p <= 10^9). Output * An integer representing the result of `(x^y) % p`. Example ```python assert mod_exp(2, 5, 13) == 6 assert mod_exp(7, 3, 11) == 2 assert mod_exp(10, 0, 3) == 1 ``` Constraints * You may assume that the inputs will be valid integers in the specified range. * The function should handle large inputs efficiently, especially considering the potentially large value of `y`. Function Signature ```python def mod_exp(x: int, y: int, p: int) -> int: pass ``` Notes 1. Aim for an optimized solution that leverages efficient exponentiation techniques, given the large potential values for `x` and `y`. 2. While the primary focus is on correctness, ensure the implementation handles edge cases such as `y` being zero or `p` being a large prime number.","solution":"def mod_exp(x: int, y: int, p: int) -> int: Returns (x^y) % p using an efficient modular exponentiation method. result = 1 x = x % p # Update x if it is more than or equal to p if x == 0: return 0 # In case x is divisible by p while y > 0: # If y is odd, multiply x with the result if (y & 1) == 1: result = (result * x) % p # Now y must be even y = y >> 1 # y = y // 2 x = (x * x) % p # Change x to x^2 return result"},{"question":"# Context You have been tasked by a creative games development studio wanting to show the importance of customizing data structures. They want to visualize how priority queues handle dynamic data effectively. # Task Implement a class called `CustomPriorityQueue` that simulates a max-priority queue using a max-heap. The queue should support the following operations: inserting an element, extracting the maximum element, and peeking at the maximum element without removal. # Class Definition ```python class CustomPriorityQueue: def __init__(self): self.heap = [] def insert(self, value: int): # Inserts \'value\' into the priority queue following max-heap rules. pass def extract_max(self) -> int: # Removes and returns the maximum value from the priority queue. pass def peek_max(self) -> int: # Returns the maximum value from the priority queue without removal. pass def _heapify_up(self, index: int): # Ensures the max-heap property is maintained after insertion. pass def _heapify_down(self, index: int): # Ensures the max-heap property is maintained after extraction. pass ``` # Specifications * **Method Descriptions**: - `insert(value: int)`: Insert an integer value into the priority queue. - `extract_max() -> int`: Remove and return the maximum integer from the priority queue. - `peek_max() -> int`: Return the maximum integer in the priority queue without removal. - `_heapify_up(index: int)`: An internal helper method to maintain heap properties when adding a new element. - `_heapify_down(index: int)`: An internal helper method to maintain heap properties when removing the max element. * **Input Format**: - The `insert` method will receive a single integer value. - The `extract_max` and `peek_max` methods do not receive input values. * **Constraints**: - Only integer values are allowed in the priority queue. - Ensure the time complexity for `insert` and `extract_max` operations aligns with O(log n). * **Output Format**: - The `extract_max` method should return an integer value. - The `peek_max` method should return an integer value. - If the queue is empty, `extract_max` and `peek_max` should raise an `IndexError` with the message \\"Priority queue is empty\\". # Example ```python >>> pq = CustomPriorityQueue() >>> pq.insert(10) >>> pq.insert(5) >>> pq.insert(20) >>> pq.peek_max() 20 >>> pq.extract_max() 20 >>> pq.peek_max() 10 >>> pq.extract_max() 10 >>> pq.extract_max() 5 >>> pq.extract_max() IndexError: Priority queue is empty ``` # Notes * Make sure to handle an empty priority queue scenario properly by raising an appropriate exception. * The class should not use any built-in heaps or priority queues from standard libraries. * Consider edge cases such as repeatedly inserting and extracting elements from the priority queue. * Ensure the custom priority queue maintains its max-heap properties after each operation.","solution":"class CustomPriorityQueue: def __init__(self): self.heap = [] def insert(self, value: int): self.heap.append(value) self._heapify_up(len(self.heap) - 1) def extract_max(self) -> int: if not self.heap: raise IndexError(\\"Priority queue is empty\\") if len(self.heap) == 1: return self.heap.pop() max_value = self.heap[0] self.heap[0] = self.heap.pop() self._heapify_down(0) return max_value def peek_max(self) -> int: if not self.heap: raise IndexError(\\"Priority queue is empty\\") return self.heap[0] def _heapify_up(self, index: int): parent_index = (index - 1) // 2 if index > 0 and self.heap[index] > self.heap[parent_index]: self.heap[index], self.heap[parent_index] = self.heap[parent_index], self.heap[index] self._heapify_up(parent_index) def _heapify_down(self, index: int): child_index = 2 * index + 1 if child_index < len(self.heap): if child_index + 1 < len(self.heap) and self.heap[child_index + 1] > self.heap[child_index]: child_index += 1 if self.heap[child_index] > self.heap[index]: self.heap[index], self.heap[child_index] = self.heap[child_index], self.heap[index] self._heapify_down(child_index)"},{"question":"Write a function called `find_duplicate_emails` that identifies duplicate email addresses from a list of email addresses and returns a dictionary where the keys are the duplicate email addresses and the values are the number of times each email address appears in the list. # Function to Implement Implement the function `find_duplicate_emails(email_list: list) -> dict` which takes a list of email addresses as input and returns a dictionary with the duplicate emails and their counts. The dictionary should only include email addresses that appear more than once in the list. # Constraints * The input list can contain any number of email addresses. * Each email address in the input list is a string and is assumed to be in a valid email format. * The function should ignore case when determining duplicates (i.e., \\"test@example.com\\" is considered the same as \\"Test@Example.com\\"). * If there are no duplicate email addresses, return an empty dictionary. # Expected Input and Output * **Input**: A list of email addresses. * **Output**: A dictionary containing the duplicate emails and their counts. # Example ```python find_duplicate_emails([ \\"test@example.com\\", \\"user@domain.com\\", \\"admin@example.com\\", \\"Test@example.com\\", \\"user@domain.com\\", \\"test@Example.com\\" ]) ``` Expected output: ```python { \\"test@example.com\\": 3, \\"user@domain.com\\": 2 } ``` You may assume that the input list will be non-empty and contain valid email addresses. The function should handle case insensitivity and count duplicates correctly.","solution":"def find_duplicate_emails(email_list): Identifies duplicate email addresses from a list of email addresses and returns a dictionary where the keys are the duplicate email addresses and the values are the count of each email. :param email_list: List of email addresses :return: Dictionary with duplicate emails as keys and counts as values email_count = {} for email in email_list: normalized_email = email.lower() if normalized_email in email_count: email_count[normalized_email] += 1 else: email_count[normalized_email] = 1 duplicates = {email: count for email, count in email_count.items() if count > 1} return duplicates"},{"question":"Context In computational geometry and graphics, transforming objects via rotation, scaling, and translation is a routine operation. For a given set of 2D points representing vertices of a polygon, these transformations can be applied to manipulate the shape accordingly. # Problem Statement Write a function, `transform_polygon(points, translation, scaling, rotation)`, that takes a list of 2D points representing the vertices of a polygon, a translation vector, a scaling factor, and a rotation angle. Your task is to apply the specified transformations in the following order: scaling, rotation, and then translation to the polygon vertices and return the transformed vertices. # Function Signature ```python def transform_polygon(points: List[Tuple[float, float]], translation: Tuple[float, float], scaling: float, rotation: float) -> List[Tuple[float, float]]: pass ``` # Input * `points`: A list of tuples, where each tuple contains two floats representing the x and y coordinates of a vertex. * `translation`: A tuple containing two floats representing the x and y direction to translate the polygon. * `scaling`: A float representing the factor by which to scale the polygon. * `rotation`: A float representing the angle in radians to rotate the polygon counter-clockwise around the origin. # Output * A list of tuples, where each tuple contains two floats representing the new x and y coordinates of the transformed vertices. # Constraints * The list `points` will contain at least three vertices. * The translation vector will be a valid coordinate (both elements finite). * The scaling factor will be a positive non-zero float. * The rotation angle will be a finite floating point number. # Examples ```python points = [(1.0, 1.0), (1.0, 2.0), (2.0, 2.0), (2.0, 1.0)] translation = (1.0, 1.0) scaling = 2.0 rotation = 0.785398 # π/4 radians transformed_points = transform_polygon(points, translation, scaling, rotation) print(transformed_points) ``` # Explanation In this example, the `transform_polygon` function first scales the points (doubles their distance from the origin), then rotates them counterclockwise by 45 degrees (π/4 radians), and finally translates them by (1,1). The resulting list of transformed points is returned. # Performance Requirements Your solution should efficiently handle transformations even for polygons with a large number of vertices (e.g., tens of thousands) within a reasonable time frame.","solution":"import math from typing import List, Tuple def transform_polygon(points: List[Tuple[float, float]], translation: Tuple[float, float], scaling: float, rotation: float) -> List[Tuple[float, float]]: transformed_points = [] cos_theta = math.cos(rotation) sin_theta = math.sin(rotation) for (x, y) in points: # Apply scaling x_scaled = x * scaling y_scaled = y * scaling # Apply rotation x_rotated = x_scaled * cos_theta - y_scaled * sin_theta y_rotated = x_scaled * sin_theta + y_scaled * cos_theta # Apply translation x_translated = x_rotated + translation[0] y_translated = y_rotated + translation[1] transformed_points.append((x_translated, y_translated)) return transformed_points"},{"question":"# Sum of Two Numbers Scenario You are developing a simple financial application that needs to determine if any two unique numbers in a given list of integers sum up to a target value. This functionality might be part of a larger feature where users are checking for specific sum combinations in their transactions. Task Implement a function `has_pair_with_sum(numbers, target)` that: - Takes a list of integers `numbers` and an integer `target` as input. - Returns `True` if there are any two different integers in the list that add up to `target`, `False` otherwise. Your solution should make use of an efficient algorithm to handle potential large inputs. Function Signature ```python def has_pair_with_sum(numbers: list[int], target: int) -> bool: pass ``` Input Constraints * 1 <= len(numbers) <= 10^5 * -10^9 <= numbers[i] <= 10^9 * -10^9 <= target <= 10^9 Example ```python numbers1 = [10, 15, 3, 7] target1 = 17 numbers2 = [1, 2, 3, 4, 5] target2 = 10 numbers3 = [-2, 1, 4, 7, 5] target3 = 9 assert has_pair_with_sum(numbers1, target1) == True assert has_pair_with_sum(numbers2, target2) == False assert has_pair_with_sum(numbers3, target3) == True ``` Requirements 1. Edge cases must be considered (e.g., lists with only one element, negative numbers, very large or very small values). 2. Performance requirement: The solution should efficiently find the pair, particularly for lists with large sizes and within reasonable time constraints. Hint You might find it helpful to use a set to keep track of the numbers you have already seen, which can assist in determining if the complementary value required to reach the target is present.","solution":"def has_pair_with_sum(numbers, target): Determines if there are any two unique integers in the list that sum up to the target value. Args: numbers (list of int): List of integers target (int): The target sum Returns: bool: True if there exists a pair with sum equal to target, False otherwise seen = set() for num in numbers: complement = target - num if complement in seen: return True seen.add(num) return False"},{"question":"You are given a list of integers where every integer appears exactly twice, except for one integer which appears exactly once. Your task is to find the integer that appears only once. Write a function called `find_unique(lst: list) -> int` which takes a list of integers as an argument and returns the integer that appears only once in the list. # Input Format - A list `lst` containing integers where every integer appears exactly twice except for one integer that appears exactly once. # Output Format - Return an integer representing the unique integer. # Constraints - All the integers in the list are non-negative. - The list is guaranteed to contain at least three integers. - The length of the list does not exceed 10^6. # Example ```python def test_find_unique(): assert find_unique([4, 1, 2, 1, 2]) == 4 assert find_unique([2, 2, 3, 4, 4]) == 3 assert find_unique([7, 3, 5, 3, 5, 9, 7]) == 9 test_find_unique() ``` # Performance Requirements * The function should have a linear runtime complexity, ideally O(n), and should use constant space, ideally O(1). This question integrates seamlessly with the provided set by using a different computational problem that still tests fundamental data structure manipulation and algorithmic skills.","solution":"def find_unique(lst): This function finds the unique integer in a list where every integer appears exactly twice except for one. unique_number = 0 for num in lst: unique_number ^= num return unique_number"},{"question":"# Recursive String Emit Function You are provided with an application that generates a unique string based on a series of recursive patterns. The function you need to develop should accept an integer `n` and generate a string based on a specific pattern of digits and letters. Your task is to implement a recursive function which builds a string as follows: - Start with the base string \\"A\\" - For each recursive call, the function appends the next integer value followed by the next letter in the alphabet. **Example**: - For `n = 1`, the returned string should be \\"A1B\\". - For `n = 2`, the returned string should be \\"A1B2C\\". - For `n = 5`, the returned string should be \\"A1B2C3D4E5F\\". **Function Definition**: - **`generate_recursive_pattern(n: int) -> str`**: This function takes a single integer `n` and returns the string according to the described pattern. **Input/Output Specifications**: - **`generate_recursive_pattern`**: - **Input**: - `n` (int): A positive integer that controls the length of the generated string. - **Output**: - (str): The generated pattern string. - **Exceptions**: - Raise `ValueError` if `n` is not a positive integer. **Example**: Given the following inputs: - For `generate_recursive_pattern`: ```python generate_recursive_pattern(3) ``` Output: ```python \'A1B2C3D\' ``` **Constraints**: - You may assume `1 <= n <= 26` (due to the limitation of the alphabet). - Ensure proper unit tests to validate your solution. - Handle invalid inputs with appropriate exception handling. Implement the string pattern generation function using Python and ensure the solution is efficient.","solution":"def generate_recursive_pattern(n): Generates a string based on a specific recursive pattern starting with \'A\'. For each call, appends the next integer and letter of the alphabet. :param n: a positive integer controlling the length of the generated string :return: the generated string pattern :raises ValueError: if n is not a positive integer if not isinstance(n, int) or n <= 0: raise ValueError(\\"n must be a positive integer\\") def helper(count, char): if count > n: return char return char + str(count) + helper(count + 1, chr(ord(char) + 1)) return helper(1, \'A\')"},{"question":"# Question: You are tasked with implementing a function that reads a JSON file containing a list of employee records and processes it to summarize the employees by their department. Your function should follow these steps: 1. Read the JSON file from the specified file path. 2. Parse the JSON content to extract employee information. 3. Group the employees by their department. 4. For each department, calculate the total number of employees and the average salary. 5. Return the summary as a dictionary where each key is a department name and the value is another dictionary with keys `total_employees` and `average_salary`. Each employee record in the JSON file has the following structure: ```json { \\"name\\": \\"John Doe\\", \\"department\\": \\"Engineering\\", \\"salary\\": 75000 } ``` Specifications: * **Function Name**: `summarize_employees_by_department` * **Inputs**: - `file_path`: A string representing the file path of the JSON file. * **Outputs**: - A dictionary summarizing the employees by department. * **Constraints**: - Assume that the JSON file is correctly formatted and all employee records have the required fields. - Handle possible errors such as file not found or read errors gracefully. - Round the average salary to 2 decimal places. Example: ```python file_path = \\"employees.json\\" print(summarize_employees_by_department(file_path)) # Possible output: # { # \\"Engineering\\": { # \\"total_employees\\": 10, # \\"average_salary\\": 80000.00 # }, # \\"HR\\": { # \\"total_employees\\": 5, # \\"average_salary\\": 50000.00 # } # ... # } ``` **Note**: Ensure your function is self-contained and does not depend on side effects such as global variables.","solution":"import json from collections import defaultdict from statistics import mean def summarize_employees_by_department(file_path): try: with open(file_path, \'r\') as file: employees = json.load(file) except (FileNotFoundError, json.JSONDecodeError): return {} department_summary = defaultdict(lambda: {\\"total_employees\\": 0, \\"salary_sum\\": 0.0}) for employee in employees: dept = employee[\\"department\\"] salary = employee[\\"salary\\"] department_summary[dept][\\"total_employees\\"] += 1 department_summary[dept][\\"salary_sum\\"] += salary summary = {} for dept, data in department_summary.items(): total_employees = data[\\"total_employees\\"] average_salary = round(data[\\"salary_sum\\"] / total_employees, 2) summary[dept] = { \\"total_employees\\": total_employees, \\"average_salary\\": average_salary } return summary"},{"question":"# Coding Assessment Question You are designing a software system to track inventory in a bookstore. The inventory must be continuously updated as books are sold or new stock is added. To manage this, you decide to write a function that updates the inventory based on a list of transactions. Each transaction is represented as a dictionary with the following keys: - `\\"action\\"`: A string that can be either `\\"add\\"` or `\\"remove\\"`, indicating whether the stock is being increased or decreased. - `\\"isbn\\"`: A string representing the ISBN of the book. - `\\"quantity\\"`: An integer indicating the number of books involved in the transaction. The function should update the stock based on these transactions and return the current inventory. The inventory is represented as a dictionary where the keys are ISBNs and the values are integers representing the current stock of each book. If a transaction attempts to remove more books than are currently in stock, the stock for that book should not fall below zero. Function Signature ```python def update_inventory(inventory: dict, transactions: list) -> dict: ``` Input - `inventory`: A dictionary where the keys are ISBNs (strings) and the values are integers representing the current stock of each book. - `transactions`: A list of dictionaries, where each dictionary represents a transaction with the keys `\\"action\\"`, `\\"isbn\\"`, and `\\"quantity\\"` as described. Output - Return the updated inventory as a dictionary with the keys being ISBNs and the values being integers representing the updated stock of each book. Constraints - Each `isbn` in the transactions will always be a non-empty string. - Each `quantity` in the transactions is a non-negative integer. - Ensure the inventory does not contain negative quantities of any book. Examples 1. Given an inventory: ```python inventory = { \\"978-0140449136\\": 5, \\"978-1982137274\\": 2 } transactions = [ {\\"action\\": \\"add\\", \\"isbn\\": \\"978-0140449136\\", \\"quantity\\": 3}, {\\"action\\": \\"remove\\", \\"isbn\\": \\"978-1982137274\\", \\"quantity\\": 1}, {\\"action\\": \\"add\\", \\"isbn\\": \\"978-0451524935\\", \\"quantity\\": 7}, {\\"action\\": \\"remove\\", \\"isbn\\": \\"978-0140449136\\", \\"quantity\\": 10} ] ``` Calling `update_inventory(inventory, transactions)` should return: ```python { \\"978-0140449136\\": 0, \\"978-1982137274\\": 1, \\"978-0451524935\\": 7 } ``` 2. Given an inventory: ```python inventory = { \\"978-0140449266\\": 10 } transactions = [ {\\"action\\": \\"remove\\", \\"isbn\\": \\"978-0140449266\\", \\"quantity\\": 5}, {\\"action\\": \\"add\\", \\"isbn\\": \\"978-0140449266\\", \\"quantity\\": 2}, {\\"action\\": \\"remove\\", \\"isbn\\": \\"978-0140449266\\", \\"quantity\\": 20} ] ``` Calling `update_inventory(inventory, transactions)` should return: ```python { \\"978-0140449266\\": 7 } ```","solution":"def update_inventory(inventory, transactions): Updates the inventory based on a list of transactions. Parameters: inventory (dict): A dictionary where keys are ISBNs and values are integers representing the current stock of each book. transactions (list): A list of dictionaries, each representing a transaction with keys \\"action\\", \\"isbn\\", and \\"quantity\\". Returns: dict: The updated inventory. for transaction in transactions: action = transaction[\\"action\\"] isbn = transaction[\\"isbn\\"] quantity = transaction[\\"quantity\\"] if action == \\"add\\": if isbn in inventory: inventory[isbn] += quantity else: inventory[isbn] = quantity elif action == \\"remove\\": if isbn in inventory: inventory[isbn] = max(0, inventory[isbn] - quantity) return inventory"},{"question":"# Task You are given a list of words where each word consists of lowercase English letters. Your goal is to write a function that finds the longest word in the list that can be constructed one character at a time by other words in the list. If there are multiple possible answers, return the smallest lexicographically. # Function Signature ```python def longest_word(words: list) -> str: pass ``` # Input * `words` (list): A list of strings, where each string consists of only lowercase English letters. # Output * Returns a single string representing the longest word that can be constructed one character at a time by other words in the list. If no such word exists, return an empty string. # Constraints * The length of the input list does not exceed 10^3. * The length of individual words does not exceed 30. # Example ```python words = [\\"w\\",\\"wo\\",\\"wor\\",\\"worl\\", \\"world\\"] assert longest_word(words) == \\"world\\" words = [\\"a\\", \\"banana\\", \\"app\\", \\"appl\\", \\"ap\\", \\"apply\\", \\"apple\\"] assert longest_word(words) == \\"apple\\" ``` # Notes 1. A word must be constructed by adding exactly one character at a time from other words in the list. 2. Consider edge cases such as multiple words with the same length and the smallest lexicographical order. 3. The input list contains unique words.","solution":"def longest_word(words: list) -> str: words_set = set(words) words.sort(key=lambda x: (-len(x), x)) def can_build(word): return all(word[:k] in words_set for k in range(1, len(word))) for word in words: if can_build(word): return word return \\"\\""},{"question":"# Question: User Activity Log Analysis for E-Commerce Platform You are tasked with analyzing user activity logs for an e-commerce platform. Each activity log entry is a JSON object containing the following fields: \\"user_id\\", \\"timestamp\\", \\"action\\", and \\"product_id\\". Your objective is to implement a Python function that identifies the most frequently viewed product by each user. Function Signature ```python def most_frequent_product_view(logs: List[dict]) -> dict: Analyzes user activity logs to identify the most frequently viewed product by each user. :param logs: A list of dictionaries representing user activity logs. :return: A dictionary where keys are user_ids and values are product_ids of the most frequently viewed products. :raises ValueError: If the logs are empty or not in the expected format. pass ``` # Requirements 1. **Input**: A list of JSON objects (dictionaries) representing activity logs. 2. **Output**: A dictionary where each key is a \\"user_id\\" and the value is the \\"product_id\\" of the most frequently viewed product by that user. 3. **Errors**: Raise a `ValueError` if the input list is empty or contains entries not conforming to the expected format. # Constraints - Logs entries follow a consistent structure with \\"user_id\\", \\"timestamp\\", \\"action\\", and \\"product_id\\". - Assume the \\"action\\" field only contains the value \\"view\\" for product views. - `user_id`, `action`, and `product_id` are strings. - Use exception handling for any unexpected input or error scenarios. # Performance - The function should efficiently process a list of at least 10,000 log entries. # Example ```python # Sample activity logs logs = [ {\\"user_id\\": \\"user1\\", \\"timestamp\\": \\"2023-09-15T12:34:56Z\\", \\"action\\": \\"view\\", \\"product_id\\": \\"prod123\\"}, {\\"user_id\\": \\"user1\\", \\"timestamp\\": \\"2023-09-15T13:34:56Z\\", \\"action\\": \\"view\\", \\"product_id\\": \\"prod123\\"}, {\\"user_id\\": \\"user1\\", \\"timestamp\\": \\"2023-09-15T14:34:56Z\\", \\"action\\": \\"view\\", \\"product_id\\": \\"prod124\\"}, {\\"user_id\\": \\"user2\\", \\"timestamp\\": \\"2023-09-15T15:34:56Z\\", \\"action\\": \\"view\\", \\"product_id\\": \\"prod123\\"}, {\\"user_id\\": \\"user2\\", \\"timestamp\\": \\"2023-09-15T16:34:56Z\\", \\"action\\": \\"view\\", \\"product_id\\": \\"prod124\\"}, {\\"user_id\\": \\"user2\\", \\"timestamp\\": \\"2023-09-15T17:34:56Z\\", \\"action\\": \\"view\\", \\"product_id\\": \\"prod124\\"} ] try: result = most_frequent_product_view(logs) print(result) # Output: {\'user1\': \'prod123\', \'user2\': \'prod124\'} except ValueError as e: print(repr(e)) ```","solution":"from collections import defaultdict from typing import List, Dict def most_frequent_product_view(logs: List[dict]) -> Dict[str, str]: if not logs: raise ValueError(\\"Logs are empty\\") user_product_views = defaultdict(lambda: defaultdict(int)) for log in logs: if not all(key in log for key in [\\"user_id\\", \\"timestamp\\", \\"action\\", \\"product_id\\"]): raise ValueError(\\"Log entries do not conform to the expected format\\") if log[\'action\'] != \'view\': continue user = log[\'user_id\'] product = log[\'product_id\'] user_product_views[user][product] += 1 most_frequent_views = {} for user, product_counts in user_product_views.items(): most_frequent_product = max(product_counts, key=product_counts.get) most_frequent_views[user] = most_frequent_product return most_frequent_views"},{"question":"# Coding Assessment Question Scenario A renowned museum is organizing a temporary exhibition where they need to display ancient artifacts. Each exhibit has a value and occupying space respectively. The exhibition space available in the museum is limited, and the goal is to maximize the total value of the displayed exhibits. You need to write an algorithm to select the artifacts to be displayed to maximize the total value without exceeding the available space. Task Write a Python function `maximize_exhibit_value(value: list, space: list, max_space: int) -> int` that calculates the maximum value achievable given the constraints imposed by the limited exhibition space. Function Signature ```python def maximize_exhibit_value(value: list, space: list, max_space: int) -> int: ``` Input - `value`: a list of integers where each integer represents the value of an exhibit. - `space`: a list of integers where each integer represents the space occupied by an exhibit corresponding to the values list. - `max_space`: a positive integer representing the maximum available exhibition space. Output - Return an integer representing the maximum value of the displayed exhibits. Constraints - The length of `value` and `space` lists will be equal. - All numbers in `value` and `space` will be non-negative. - `max_space` will be a non-negative integer. - If `max_space` is 0, the function should return 0. Examples ```python >>> maximize_exhibit_value([10, 40, 30, 50], [5, 4, 6, 3], 10) 90 >>> maximize_exhibit_value([60, 100, 120], [10, 20, 30], 50) 220 >>> maximize_exhibit_value([10, 20, 30], [1, 1, 1], 0) 0 ``` Requirements - Your solution must ensure that all edge cases are handled properly. - Provide efficient performance adhering to the outlined complexities.","solution":"def maximize_exhibit_value(value, space, max_space): n = len(value) dp = [[0 for _ in range(max_space + 1)] for _ in range(n + 1)] for i in range(1, n + 1): for w in range(max_space + 1): if space[i-1] <= w: dp[i][w] = max(dp[i-1][w], dp[i-1][w - space[i-1]] + value[i-1]) else: dp[i][w] = dp[i-1][w] return dp[n][max_space]"},{"question":"# Scenario: You are working on a contact management application, and you need to implement a feature that allows users to search for a specific contact by name. The contacts are stored in a simple list, and each contact is represented as a dictionary. # Task: Implement a Python function `search_contact(contacts, name_query)` that searches for contacts by name and returns a list of matching contacts. The search should be case-insensitive and should return partial matches as well. # Function Specification: Input: - `contacts`: A list of dictionaries, where each dictionary represents a contact with at least the keys `\'name\'` and `\'phone_number\'`. - `name_query`: A string representing the name or part of the name to search for. Output: - A list of dictionaries representing the matching contacts. Each dictionary should have the keys `\'name\'` and `\'phone_number\'`. Constraints: - The search should be case-insensitive. - Return an empty list if there are no matches. - Ensure the function has a maximum execution time of 1 second for large contact lists (up to 10,000 entries). # Example: ```python # Example usage contacts = [ {\'name\': \'Alice Johnson\', \'phone_number\': \'555-1234\'}, {\'name\': \'Bob Smith\', \'phone_number\': \'555-5678\'}, {\'name\': \'Charlie Brown\', \'phone_number\': \'555-8765\'} ] result = search_contact(contacts, \'alice\') print(result) ``` Expected Output: ```python [ {\'name\': \'Alice Johnson\', \'phone_number\': \'555-1234\'} ] ```","solution":"def search_contact(contacts, name_query): Searches for contacts by name and returns a list of matching contacts. Args: - contacts (list): A list of dictionaries, each representing a contact with keys \'name\' and \'phone_number\'. - name_query (str): The name or part of the name to search for. Returns: - list: A list of dictionaries representing the matching contacts. # Convert the name_query to lower case for case-insensitive search name_query_lower = name_query.lower() # Filter the contact list for matches matching_contacts = [ contact for contact in contacts if name_query_lower in contact[\'name\'].lower() ] return matching_contacts"},{"question":"# Merge Intervals and Compute Gap You are given a list of integer intervals represented as pairs of start and end times [start, end]. Your task is to write a function that merges all overlapping intervals and then computes the combined length of all gaps between the merged intervals. Function Signature ```python def merge_intervals_and_compute_gap(intervals: List[List[int]]) -> int: pass ``` Requirements 1. **Merge Intervals**: - Combine all overlapping intervals so that there are no overlaps in the resulting list. - Ensure the intervals are sorted first by their start times, and then by their end times in case of equal start times. 2. **Compute Gap**: - Calculate the sum of all gaps (space between consecutive intervals) after merging. - The gap is defined as the difference between the start of the current interval and the end of the previous interval. Example ```python # Example 1 intervals = [[1, 3], [6, 9], [2, 5], [10, 15]] result = merge_intervals_and_compute_gap(intervals) # Merged intervals: [[1, 5], [6, 9], [10, 15]] # Gaps: (6 - 5) + (10 - 9) = 1 + 1 = 2 assert result == 2 # Example 2 intervals = [[1, 4], [5, 6], [8, 10], [11, 12]] result = merge_intervals_and_compute_gap(intervals) # Merged intervals: [[1, 4], [5, 6], [8, 10], [11, 12]] # Gaps: (5 - 4) + (8 - 6) + (11 - 10) = 1 + 2 + 1 = 4 assert result == 4 # Example 3 intervals = [[1, 3], [3, 6]] result = merge_intervals_and_compute_gap(intervals) # Merged intervals: [[1, 6]] # Gaps: No gaps assert result == 0 ``` Constraints - All intervals are given as pairs of integers where the first number is less than or equal to the second number. - The intervals may be unsorted. - The intervals can be overlapping, non-overlapping, or touching. - A gap is only counted if the intervals are strictly non-overlapping. Implementation Steps 1. **Sort the intervals** by the start times. 2. **Merge the intervals** by iterating through the sorted list. 3. **Calculate the gaps** by checking the difference between the end of the previous interval and the start of the current interval during the merge process. Solution Template ```python def merge_intervals_and_compute_gap(intervals: List[List[int]]) -> int: if not intervals: return 0 # Sort intervals by start times (and end times to handle same start cases) intervals.sort(key=lambda x: (x[0], x[1])) merged_intervals = [] for interval in intervals: if not merged_intervals or merged_intervals[-1][1] < interval[0]: merged_intervals.append(interval) else: merged_intervals[-1][1] = max(merged_intervals[-1][1], interval[1]) gap_sum = 0 for i in range(1, len(merged_intervals)): gap_sum += merged_intervals[i][0] - merged_intervals[i-1][1] return gap_sum ``` In this exercise, you will practice manipulating intervals, merging them, and computing gaps, which are foundational skills in algorithms related to ranges and intervals.","solution":"from typing import List def merge_intervals_and_compute_gap(intervals: List[List[int]]) -> int: if not intervals: return 0 # Sort intervals by start times (and end times to handle same start cases) intervals.sort(key=lambda x: (x[0], x[1])) merged_intervals = [] for interval in intervals: if not merged_intervals or merged_intervals[-1][1] < interval[0]: merged_intervals.append(interval) else: merged_intervals[-1][1] = max(merged_intervals[-1][1], interval[1]) gap_sum = 0 for i in range(1, len(merged_intervals)): gap_sum += merged_intervals[i][0] - merged_intervals[i-1][1] return gap_sum"},{"question":"# Valid IP Address Generation Challenge **Context**: Given a string containing only digits, restore it by returning all possible valid IP address combinations. A valid IP address consists of exactly four integers (each between 0 and 255) separated by single dots. There must be exactly three dots, and each integer must not have any leading zeros. **Prompt**: Create a function to generate all possible valid IP addresses from a given string of digits. Utilize a recursive approach to explore potential splits of the string into valid IP segments. **Function Signature**: ```python def restore_ip_addresses(s: str) -> list: Generates all possible valid IP addresses from a given string of digits. :param s: The input string containing only digits :return: A list of strings representing all valid IP addresses ``` # Requirements: 1. **Input**: A single string `s` (1 ≤ len(s) ≤ 20). 2. **Output**: A list of valid IP addresses built from the string `s`. 3. Avoid leading zeros in each segment, except when the segment itself is \'0\'. 4. Ensure that no segment exceeds the value 255. 5. Handle large input efficiently using an optimal recursive approach. # Examples: ```python >>> restore_ip_addresses(\\"25525511135\\") [\'255.255.11.135\', \'255.255.111.35\'] >>> restore_ip_addresses(\\"0000\\") [\'0.0.0.0\'] >>> restore_ip_addresses(\\"1111\\") [\'1.1.1.1\'] >>> restore_ip_addresses(\\"101023\\") [\'1.0.10.23\', \'1.0.102.3\', \'10.1.0.23\', \'10.10.2.3\', \'101.0.2.3\'] ``` # Constraints: 1. The numbers in sections must not have leading zeros unless they are \'0\'. 2. Each segment must be between 0 and 255. 3. Your code should be concise, well-commented, and follow best practices in readability and performance. 4. Implement a recursive approach to generate and validate potential IP segments.","solution":"def restore_ip_addresses(s: str) -> list: def is_valid(segment): # Check if the segment is between 0 and 255 and has no leading zeros unless it is \'0\' return int(segment) <= 255 and (segment == \\"0\\" or not segment.startswith(\\"0\\")) def backtrack(start, path): # If we reach the end and the path has exactly four segments, add to result if start == len(s) and len(path) == 4: result.append(\\".\\".join(path)) return # If the path has four segments but we haven\'t reached the end of the string, return if len(path) == 4: return # Try out segments of length 1 to 3 for length in range(1, 4): if start + length <= len(s): # avoid going out of bounds segment = s[start:start + length] if is_valid(segment): backtrack(start + length, path + [segment]) result = [] if 4 <= len(s) <= 12: # Early return case if the length of s is too small or too large backtrack(0, []) return result"},{"question":"# Longest Increasing Subsequence You are tasked with enhancing a data analysis tool to identify trends in numerical data. Specifically, you need to calculate the length of the longest increasing subsequence (LIS) within a given list of integers. This feature will help analyze the longest stretch of growth in datasets. Task Write a function `longest_increasing_subsequence` that finds the length of the longest strictly increasing subsequence in a given list of integers. Function Signature ```python def longest_increasing_subsequence(arr: List[int]) -> int: ``` Input - `arr` (List[int]): A list of integers representing the dataset (1 ≤ len(arr) ≤ 10^5). Output - An integer representing the length of the longest strictly increasing subsequence within the given list. Constraints - The integers in the list can be positive, negative, or zero. Example ```python longest_increasing_subsequence([10, 22, 9, 33, 21, 50, 41, 60, 80]) -> 6 longest_increasing_subsequence([3, 10, 2, 1, 20]) -> 3 longest_increasing_subsequence([3, 2]) -> 1 ``` Explanation 1. For the array `[10, 22, 9, 33, 21, 50, 41, 60, 80]`: - The longest increasing subsequence is `[10, 22, 33, 50, 60, 80]` which has length 6. 2. For the array `[3, 10, 2, 1, 20]`: - The longest increasing subsequence is `[3, 10, 20]` which has length 3. 3. For the array `[3, 2]`: - The longest increasing subsequence is `[3]` or `[2]`, both of which have length 1. Make sure to handle large input sizes efficiently.","solution":"from bisect import bisect_left from typing import List def longest_increasing_subsequence(arr: List[int]) -> int: Finds the length of the longest strictly increasing subsequence in a given list of integers. if not arr: return 0 # This will store the end elements of potential increasing subsequences subsequence_ends = [] for num in arr: # Find the position where the number can be placed in the subsequence_ends pos = bisect_left(subsequence_ends, num) # If num is larger than any element in subsequence_ends if pos >= len(subsequence_ends): subsequence_ends.append(num) else: # Replace the element at index pos with num subsequence_ends[pos] = num # Length of subsequence_ends will be the length of the LIS return len(subsequence_ends)"},{"question":"# Programming Question: Find the Unique Element **Context**: Working with arrays and analyzing their properties is a fundamental part of many software applications, including data analysis, signal processing, and statistical computing. **Problem Statement**: Write a function `find_unique(arr: List[int]) -> int` that identifies and returns the unique (non-repeating) element in an array where every other element appears exactly twice. This problem is important for understanding patterns in data and for performing efficient searches in unsorted datasets. **Function Signature**: ```python from typing import List def find_unique(arr: List[int]) -> int: pass ``` **Input**: * A single list `arr` of integers, where `1 <= len(arr) <= 10^5`, and every element except for one appears exactly twice. **Output**: * An integer representing the unique element which appears only once in the array. **Constraints**: * All elements in `arr` will be integers, and can range from `-10^6` to `10^6`. * The array will contain at least one element which appears only once. * The function should have linear time complexity, O(n), considering the large input size. * Use only a constant amount of extra space, O(1). **Examples**: ```python find_unique([1, 2, 2, 3, 1]) # Output: 3 find_unique([4, 5, 6, 5, 4]) # Output: 6 find_unique([7, 7, 8, 9, 9]) # Output: 8 ``` **Notes**: * The input list is not necessarily sorted. * Consider using bitwise XOR for an efficient solution.","solution":"from typing import List def find_unique(arr: List[int]) -> int: Identifies and returns the unique (non-repeating) element in an array where every other element appears exactly twice. unique = 0 for num in arr: unique ^= num return unique"},{"question":"# Problem Statement: You are developing an image processing utility and need to calculate the aspect ratio of given dimensions. The aspect ratio is a critical element in various display and design applications. # Requirements: Implement a function `calculate_aspect_ratio(width: int, height: int) -> str` that calculates the aspect ratio of the image given the width and height in pixels. The function should: 1. Raise a `ValueError` with a descriptive message if either width or height is less than or equal to zero. 2. Return a string representing the aspect ratio in the form \\"W:H\\", where W and H are the greatest common divisor (GCD)-reduced width and height. # Input: * Two integers representing width and height. # Output: * A string representing the aspect ratio in the form \\"W:H\\". # Constraints: * (0 < text{width}, text{height} leq 10^6) # Example: ```python def calculate_aspect_ratio(width: int, height: int) -> str: pass # Example Usage: try: print(calculate_aspect_ratio(1920, 1080)) # Should output \\"16:9\\" except ValueError as e: print(e) try: print(calculate_aspect_ratio(0, 1080)) # Should raise ValueError except ValueError as e: print(e) # Output: \\"Width cannot be 0 or negative\\" try: print(calculate_aspect_ratio(1920, 0)) # Should raise ValueError except ValueError as e: print(e) # Output: \\"Height cannot be 0 or negative\\" ``` # Note: * Ensure proper error handling for invalid inputs. * Focus on correctly reducing the width and height to their simplest form using the GCD.","solution":"import math def calculate_aspect_ratio(width: int, height: int) -> str: if width <= 0: raise ValueError(\\"Width must be greater than zero.\\") if height <= 0: raise ValueError(\\"Height must be greater than zero.\\") gcd_value = math.gcd(width, height) reduced_width = width // gcd_value reduced_height = height // gcd_value return f\\"{reduced_width}:{reduced_height}\\""},{"question":"**Efficient Data Lookup** # Context: You are developing a mobile application that needs quick access to user profiles based on user IDs. User profiles are stored in a key-value format, with user IDs as keys and profile data as values. The user IDs are unique, and profile data is represented as a dictionary containing user details like name, age, email, etc. # Objective: Write a new class `UserProfileLookup` that allows efficient insertion, lookup, and removal of user profiles. # Constraints: - The implementation should support fast query times for operations. - The `UserProfileLookup` class should handle up to a million users efficiently. - Ensure the methods are optimized for performance. # Specifications: 1. Class Name: `UserProfileLookup` 2. Shall contain the methods: * `insert(user_id: int, profile: dict) -> None`: Inserts or updates the user profile associated with the given user_id. * `lookup(user_id: int) -> dict`: Returns the profile data associated with the user_id if it exists, otherwise returns an empty dictionary. * `remove(user_id: int) -> None`: Removes the profile associated with the user_id if it exists. 3. For simplicity, assume all user IDs and profile data are valid and properly formatted. # Expected input and output formats: - **Input formats**: * `insert(user_id: int, profile: dict)`: An integer user ID and a dictionary containing profile data. * `lookup(user_id: int)`: An integer user ID. * `remove(user_id: int)`: An integer user ID. - **Output formats**: * `lookup(user_id: int)`: Returns a dictionary containing profile data or an empty dictionary if the user does not exist. * `insert(user_id: int, profile: dict)`: No output needed. * `remove(user_id: int)`: No output needed. # Example Usage: ```python # Initialize the UserProfileLookup object lookup = UserProfileLookup() # Insert user profiles lookup.insert(1, {\\"name\\": \\"Alice\\", \\"age\\": 30, \\"email\\": \\"alice@example.com\\"}) lookup.insert(2, {\\"name\\": \\"Bob\\", \\"age\\": 25, \\"email\\": \\"bob@example.com\\"}) # Lookup user profiles profile = lookup.lookup(1) # returns {\\"name\\": \\"Alice\\", \\"age\\": 30, \\"email\\": \\"alice@example.com\\"} profile = lookup.lookup(3) # returns {} # Remove user profile lookup.remove(2) profile = lookup.lookup(2) # returns {} ``` # Performance Requirements: - Ensure that all operations (insert, lookup, and remove) have an average time complexity of O(1). # Implementation Details: - You may use dictionary data structures to achieve the desired performance. - Consider edge cases such as updating existing profiles and removing non-existent user IDs.","solution":"class UserProfileLookup: def __init__(self): self.profiles = {} def insert(self, user_id: int, profile: dict) -> None: Inserts or updates the user profile associated with the given user_id. self.profiles[user_id] = profile def lookup(self, user_id: int) -> dict: Returns the profile data associated with the user_id if it exists, otherwise returns an empty dictionary. return self.profiles.get(user_id, {}) def remove(self, user_id: int) -> None: Removes the profile associated with the user_id if it exists. if user_id in self.profiles: del self.profiles[user_id]"},{"question":"# Scenario You are building a function to determine whether a string is a valid palindrome, while ignoring all non-alphanumeric characters and case differences. This is a common preprocessing step in text analysis and data cleaning. # Problem Statement Write a function `is_palindrome(s: str) -> bool` that takes a string `s` and determines whether it is a valid palindrome. The function should ignore spaces, punctuation, and case sensitivity. # Input/Output Format * **Input**: * A string `s` where `0 <= len(s) <= 10^5` * **Output**: * A boolean value `True` if the string is a palindrome, otherwise `False`. # Constraints * The function should ignore all non-alphanumeric characters. * The function should be case insensitive. # Example ```python >>> is_palindrome(\\"A man, a plan, a canal: Panama\\") True >>> is_palindrome(\\"race a car\\") False >>> is_palindrome(\\" \\") True ``` # Guidance Ensure your function runs efficiently with the given constraints. You may use regular expressions or other methods to filter out non-alphanumeric characters, but keep time complexity considerations in mind.","solution":"import re def is_palindrome(s: str) -> bool: Determines if the given string is a valid palindrome, ignoring non-alphanumeric characters and case differences. # Remove all non-alphanumeric characters and convert to lower case cleaned_str = re.sub(r\'[^a-zA-Z0-9]\', \'\', s).lower() # Check if the cleaned string is equal to its reverse return cleaned_str == cleaned_str[::-1]"},{"question":"# Background You are working on a logging system for a software application that keeps track of user activity. The system records each action a user takes along with a timestamp in the format \'YYYY-MM-DD HH:MM:SS\'. To analyze user activity, you need to process these log entries to find specific patterns and details. # Task Implement a function that processes a list of log entries and provides useful information. Your function should count the number of actions per user and identify the most recent action taken by each user. # Function Signature ```python def process_logs(logs: list) -> dict: pass ``` # Input - `logs` (list): A list of strings, where each string is a log entry in the format \'timestamp username action\'. # Output - `result` (dict): A dictionary containing two keys: - \\"action_count\\": A dictionary where the keys are usernames and the values are the number of actions taken by each user. - \\"latest_action\\": A dictionary where the keys are usernames and the values are the most recent action taken by each user. # Example ```python logs = [ \\"2023-10-01 12:00:00 john login\\", \\"2023-10-01 12:05:00 jane view\\", \\"2023-10-01 12:10:00 john logout\\", \\"2023-10-01 12:15:00 john login\\", \\"2023-10-01 12:20:00 jane logout\\", \\"2023-10-01 12:25:00 john view\\" ] result = process_logs(logs) assert result == { \\"action_count\\": { \\"john\\": 4, \\"jane\\": 2 }, \\"latest_action\\": { \\"john\\": \\"view\\", \\"jane\\": \\"logout\\" } } ``` # Constraints - Each log entry is unique. - There will be at most 1000 log entries. - The usernames will be alphanumeric strings of length <= 20. - The actions will be alphanumeric strings of length <= 20.","solution":"def process_logs(logs: list) -> dict: Processes the logs and returns the action count and latest action per user. Args: logs (list): A list of log entries in the format \'timestamp username action\'. Returns: dict: A dictionary with two keys, \\"action_count\\" and \\"latest_action\\". from collections import defaultdict action_count = defaultdict(int) latest_action = {} for log in logs: parts = log.split() timestamp, username, action = parts[0] + \\" \\" + parts[1], parts[2], parts[3] action_count[username] += 1 if username not in latest_action or latest_action[username][0] < timestamp: latest_action[username] = (timestamp, action) # Transform latest_action to only include the action latest_action = {user: info[1] for user, info in latest_action.items()} return { \\"action_count\\": dict(action_count), \\"latest_action\\": latest_action }"},{"question":"# Shortest Path in Weighted Graph Problem Description You are given a weighted directed graph represented by an adjacency list and a source node. Your task is to find the shortest path from the source node to all other nodes in the graph. If a node is unreachable from the source node, its distance should be represented as infinity (`float(\'inf\')`). Function Signature Write a Python function `shortest_path(graph: Dict[int, List[Tuple[int, int]]], source: int) -> List[float]` that takes two parameters: - `graph`: A dictionary where keys are the nodes and values are lists of tuples representing the edges. Each tuple consists of two integers where the first integer is the destination node and the second integer is the weight of the edge. - `source`: An integer representing the source node. Return The function should return a list of distances from the source node to every other node, where the `i-th` element represents the shortest distance from the source node to node `i`. If a node is unreachable, its distance should be `float(\'inf\')`. Constraints - The number of nodes `N` is between 2 and 100. - The number of edges `E` is between 1 and 200. - Edge weights are positive integers. Example ```python def shortest_path(graph: Dict[int, List[Tuple[int, int]]], source: int) -> List[float]: # Your code here # Example Test Cases graph1 = { 0: [(1, 4), (2, 1)], 1: [(3, 1)], 2: [(1, 2), (3, 5)], 3: [] } source1 = 0 print(shortest_path(graph1, source1)) # Output: [0, 3, 1, 4] graph2 = { 0: [(1, 2)], 1: [(2, 3)], 2: [], 3: [(1, 1)] } source2 = 0 print(shortest_path(graph2, source2)) # Output: [0, 2, 5, inf] ``` In these examples, the first graph finds the shortest paths from node 0 to all other nodes. In the second graph, node 3 is unreachable, hence its distance is `inf`. Requirements - Implement the `shortest_path` function to solve the problem using Dijkstra\'s algorithm or another suitable shortest path algorithm. - Ensure optimal performance within the given constraints.","solution":"import heapq from typing import List, Dict, Tuple def shortest_path(graph: Dict[int, List[Tuple[int, int]]], source: int) -> List[float]: Finds the shortest path from the source node to all other nodes in the weighted directed graph using Dijkstra\'s algorithm. :param graph: A dictionary where keys are nodes and values are lists of tuples (neighbor, weight). :param source: The source node. :return: A list of shortest distances from the source node to every other node. If a node is unreachable, the distance is float(\'inf\'). # Number of nodes in the graph num_nodes = len(graph) # Initialize distances array with infinity distances = [float(\'inf\')] * num_nodes distances[source] = 0 # Priority queue to process nodes in increasing order of distance priority_queue = [(0, source)] # (distance, node) while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) # If current_distance is greater than the recorded shortest distance, skip this one if current_distance > distances[current_node]: continue # Explore neighbors for neighbor, weight in graph.get(current_node, []): distance = current_distance + weight # If found a shorter path to the neighbor, update and push to queue if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances"},{"question":"# Scenario You have been approached by a logistics company to develop a system that can efficiently manage and perform operations on their package delivery routes. The company operates a fleet of delivery vehicles that navigate through a grid-like city map with intersections and streets. Your task is to implement a solution that models the city map as a weighted, undirected graph and supports the following operations: 1. Addition of intersections and streets. 2. Removal of intersections and streets. 3. Finding the shortest path between two intersections. 4. Finding the Minimum Spanning Tree (MST) of the city map. 5. Detecting if there exists a cycle in the routes in the graph. # Task Implement the following methods in a class `CityMap`: 1. `add_intersection(self, label: int) -> None`: * Adds an intersection with the given `label` to the city map. 2. `remove_intersection(self, label: int) -> None`: * Removes the intersection with the given `label` and all associated streets from the city map. 3. `add_street(self, start: int, end: int, weight: float) -> None`: * Adds a street between the intersections `start` and `end` with the given `weight`. 4. `remove_street(self, start: int, end: int) -> None`: * Removes the street between the intersections `start` and `end`. 5. `shortest_path(self, start: int, end: int) -> List[int]`: * Finds and returns the shortest path from intersection `start` to intersection `end` using Dijkstra\'s algorithm. 6. `minimum_spanning_tree(self) -> List[Tuple[int, int, float]]`: * Computes and returns the edges of the Minimum Spanning Tree (MST) using Kruskal\'s algorithm. 7. `has_cycle(self) -> bool`: * Detects if there exists a cycle in the current map. * Returns `True` if a cycle is found and `False` otherwise. # Constraints: 1. The number of intersections `n` will not exceed `10^4`. 2. The number of streets `m` will not exceed `2 * 10^4`. 3. The weight of each street will be a positive floating point number. # Performance Requirement: Ensure the shortest path and MST operations run efficiently within the given constraints. # Example: ```python # Initialize CityMap city_map = CityMap() # Add intersections city_map.add_intersection(1) city_map.add_intersection(2) city_map.add_intersection(3) # Add streets city_map.add_street(1, 2, 5.0) city_map.add_street(2, 3, 3.0) city_map.add_street(1, 3, 10.0) # Find shortest path shortest_path = city_map.shortest_path(1, 3) print(shortest_path) # Output: [1, 2, 3] # Compute Minimum Spanning Tree (MST) mst = city_map.minimum_spanning_tree() print(mst) # Output: [(2, 3, 3.0), (1, 2, 5.0)] # Check for cycles has_cycle = city_map.has_cycle() print(has_cycle) # Output: False # Remove a street city_map.remove_street(1, 3) # Remove an intersection city_map.remove_intersection(3) ``` ``` **Note**: Do not use any built-in libraries for graph algorithms.","solution":"import heapq class CityMap: def __init__(self): self.graph = {} self.edges = [] def add_intersection(self, label: int) -> None: if label not in self.graph: self.graph[label] = {} def remove_intersection(self, label: int) -> None: if label in self.graph: for neighbor in self.graph[label]: del self.graph[neighbor][label] del self.graph[label] self.edges = [e for e in self.edges if e[0] != label and e[1] != label] def add_street(self, start: int, end: int, weight: float) -> None: if start not in self.graph or end not in self.graph: raise ValueError(\\"Both intersections must be present in the city map.\\") self.graph[start][end] = weight self.graph[end][start] = weight self.edges.append((start, end, weight)) def remove_street(self, start: int, end: int) -> None: if start in self.graph and end in self.graph[start]: del self.graph[start][end] del self.graph[end][start] self.edges = [e for e in self.edges if not (e[0] == start and e[1] == end or e[0] == end and e[1] == start)] def shortest_path(self, start: int, end: int) -> list: if start not in self.graph or end not in self.graph: raise ValueError(\\"Both intersections must be present in the city map.\\") distances = {vertex: float(\'infinity\') for vertex in self.graph} previous_nodes = {vertex: None for vertex in self.graph} distances[start] = 0 pq = [(0, start)] while pq: current_distance, current_vertex = heapq.heappop(pq) if current_distance > distances[current_vertex]: continue for neighbor, weight in self.graph[current_vertex].items(): distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance previous_nodes[neighbor] = current_vertex heapq.heappush(pq, (distance, neighbor)) path = [] current_vertex = end while previous_nodes[current_vertex] is not None: path.append(current_vertex) current_vertex = previous_nodes[current_vertex] if path: path.append(start) path.reverse() return path def minimum_spanning_tree(self) -> list: # Kruskal\'s algorithm edges = sorted(self.edges, key=lambda e: e[2]) parent = {} rank = {} def find(node): if parent[node] != node: parent[node] = find(parent[node]) return parent[node] def union(node1, node2): root1 = find(node1) root2 = find(node2) if root1 != root2: if rank[root1] > rank[root2]: parent[root2] = root1 else: parent[root1] = root2 if rank[root1] == rank[root2]: rank[root2] += 1 for node in self.graph: parent[node] = node rank[node] = 0 mst = [] for edge in edges: u, v, weight = edge if find(u) != find(v): union(u, v) mst.append(edge) return mst def has_cycle(self) -> bool: parent = {} def find(node): if parent[node] != node: parent[node] = find(parent[node]) return parent[node] def union(node1, node2): root1 = find(node1) root2 = find(node2) if root1 != root2: parent[root2] = root1 for node in self.graph: parent[node] = node for u, v, weight in self.edges: root1 = find(u) root2 = find(v) if root1 == root2: return True union(u, v) return False"},{"question":"# Question: Sorting an Almost Sorted Array An almost sorted array is an array where each element is at most \'k\' positions away from its actual position in a sorted array. Your task is to write a function that sorts such an array efficiently. **Objective**: Write a function `sort_almost_sorted_array(arr, k)` that sorts an almost sorted array where each element is at most \'k\' positions away from its actual position. **Function Signature**: ```python def sort_almost_sorted_array(arr: List[int], k: int) -> List[int]: pass ``` **Input**: - `arr`: A list of integers representing the almost sorted array. - `k`: An integer representing the maximum distance any element is from its sorted position. **Output**: - A list of integers representing the sorted array. **Constraints**: - The length of `arr` will be at most 100,000. - The value of \'k\' will be at most 1000. **Example**: ```python arr1 = [3, 2, 1, 5, 4, 6, 7] k1 = 2 output1 = sort_almost_sorted_array(arr1, k1) # Expected output: [1, 2, 3, 4, 5, 6, 7] arr2 = [10, 9, 8, 7, 4, 70, 60, 50] k2 = 4 output2 = sort_almost_sorted_array(arr2, k2) # Expected output: [4, 7, 8, 9, 10, 50, 60, 70] arr3 = [24, 18, 12, 15, 17, 19] k3 = 3 output3 = sort_almost_sorted_array(arr3, k3) # Expected output: [12, 15, 17, 18, 19, 24] ``` **Requirements**: - Consider utilizing a min-heap for efficient sorting. - Focus on minimizing the time complexity of the algorithm to handle large datasets. **Helpful Tips**: - A min-heap can help in retrieving the smallest element quickly, maintaining sorted order when elements are dequeued. - Heap insertion and deletion should be handled within the constraints of \'k\' positions.","solution":"import heapq from typing import List def sort_almost_sorted_array(arr: List[int], k: int) -> List[int]: Sorts an almost sorted array where each element is at most \'k\' positions away from its actual position. # Result array to store the sorted elements result = [] # Create a min-heap and add the first k+1 elements to it min_heap = arr[:k+1] heapq.heapify(min_heap) # For the remaining elements in the array, extract the minimum element and add the current element to the heap for i in range(k+1, len(arr)): result.append(heapq.heappop(min_heap)) heapq.heappush(min_heap, arr[i]) # Extract the remaining elements from the heap while min_heap: result.append(heapq.heappop(min_heap)) return result"},{"question":"Warehouse Robot Path Planning You are tasked with implementing a simple path planning algorithm for a warehouse robot. The warehouse is represented as a 2D grid where each cell can be either empty, an obstacle, or the destination. The robot starts at a given position on the grid and must find the shortest path to the destination while avoiding obstacles. You will implement an A* search algorithm to solve this problem. # Specifications 1. **Function**: `find_path(grid: List[List[int]], start: Tuple[int, int], destination: Tuple[int, int]) -> Optional[List[Tuple[int, int]]]` * **Inputs**: * `grid`: A 2D list representing the warehouse layout. A cell value can be `0` (empty), `1` (obstacle), or `2` (destination). * `start`: A tuple representing the starting coordinates (row, column). * `destination`: A tuple representing the destination coordinates (row, column), which will always have a value of `2` in the grid. * **Output**: * A list of tuples representing the path from the start to the destination, inclusive. Return `None` if no path exists. # Constraints * The grid size can be up to `1000 x 1000` cells. * There will be exactly one destination cell, and it will always be reachable if you correctly implement the pathfinding algorithm. * The robot can move up, down, left, or right (but not diagonally). # Performance Requirements * Ensure the solution is efficient and runs within a reasonable time frame for large grids. * Handle edge cases such as the start position being the same as the destination, and the presence of obstacles surrounding the start or destination. # Example ```python grid = [ [0, 1, 0, 0, 0], [0, 1, 0, 1, 0], [0, 0, 0, 1, 0], [0, 1, 1, 1, 0], [2, 0, 0, 0, 0] ] start = (0, 0) destination = (4, 0) path = find_path(grid, start, destination) print(path) # Expected Output: [(0, 0), (1, 0), (2, 0), (3, 0), (4, 0)] ``` **Note**: You may design and use additional helper functions or classes as required to complete the implementation.","solution":"import heapq from typing import List, Tuple, Optional def heuristic(a: Tuple[int, int], b: Tuple[int, int]) -> int: Calculate the Manhattan distance between points a and b. return abs(a[0] - b[0]) + abs(a[1] - b[1]) def find_path(grid: List[List[int]], start: Tuple[int, int], destination: Tuple[int, int]) -> Optional[List[Tuple[int, int]]]: Finds the shortest path in a 2D grid from start to destination avoiding obstacles. Uses A* algorithm. # Initialize open list and closed set open_list = [] closed_set = set() came_from = {} # Add the start position to the open list heapq.heappush(open_list, (0, start)) # Cost from start to the current node g_score = {start: 0} f_score = {start: heuristic(start, destination)} # Directions for movement (Up, Down, Left, Right) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] while open_list: # Get the node with the lowest f_score value _, current = heapq.heappop(open_list) # If we have reached the destination, reconstruct the path if current == destination: path = [] while current in came_from: path.append(current) current = came_from[current] path.append(start) path.reverse() return path closed_set.add(current) for direction in directions: neighbor = (current[0] + direction[0], current[1] + direction[1]) if (0 <= neighbor[0] < len(grid) and 0 <= neighbor[1] < len(grid[0]) and grid[neighbor[0]][neighbor[1]] != 1 and neighbor not in closed_set): tentative_g_score = g_score[current] + 1 if neighbor not in g_score or tentative_g_score < g_score[neighbor]: came_from[neighbor] = current g_score[neighbor] = tentative_g_score f_score[neighbor] = tentative_g_score + heuristic(neighbor, destination) if neighbor not in [i[1] for i in open_list]: heapq.heappush(open_list, (f_score[neighbor], neighbor)) # If there is no valid path return None"},{"question":"# Task: Validate a Password Context You are developing a security feature for an application that requires users to create secure passwords. To enforce password strength, the application must verify that passwords meet certain criteria. Objective Write a function `validate_password` that checks if a given password meets the following security requirements: 1. Contains at least one lowercase letter. 2. Contains at least one uppercase letter. 3. Contains at least one digit. 4. Contains at least one special character (`!@#%^&*()-_=+`). 5. Is at least 8 characters long. # Function Signature ```python def validate_password(password: str) -> bool: pass ``` # Input * **password** (str): A string representing the password to be validated. # Output * **bool**: `True` if the password meets all the requirements, otherwise `False`. # Constraints * The length of the password string will be in the range [1, 100]. # Example Scenarios Example 1 * **Input**: `\\"Password123!\\"` * **Output**: `True` * **Explanation**: The password contains at least one lowercase letter, one uppercase letter, one digit, one special character, and is at least 8 characters long. Example 2 * **Input**: `\\"pass\\"` * **Output**: `False` * **Explanation**: The password is not long enough and does not contain an uppercase letter, a digit, or a special character. Example 3 * **Input**: `\\"Secure!@#*\\"` * **Output**: `False` * **Explanation**: The password does not contain any digits. # Performance Requirements * The function should operate in linear time relative to the length of the password. # Points to Consider * Handle edge cases where the password is exactly 8 characters long. * Ensure the function returns the correct result for passwords that are just on the boundary of meeting or not meeting the criteria.","solution":"def validate_password(password: str) -> bool: Validates whether the password meets the security requirements. Args: password (str): The password to be validated. Returns: bool: True if the password meets the requirements, False otherwise. if len(password) < 8: return False has_lowercase = has_uppercase = has_digit = has_special = False special_characters = \\"!@#%^&*()-_=+\\" for char in password: if char.islower(): has_lowercase = True elif char.isupper(): has_uppercase = True elif char.isdigit(): has_digit = True elif char in special_characters: has_special = True if has_lowercase and has_uppercase and has_digit and has_special: return True return False"},{"question":"# Question: Implementing Custom Stack with Minimum Functionality Design a custom stack data structure that supports typical stack operations (`push`, `pop`, `peek`) and a new operation `get_min` that returns the smallest element in the stack. The `get_min` operation should run in O(1) time. **Function Signature:** ```python class CustomStack: def __init__(self): pass def push(self, val: int) -> None: pass def pop(self) -> int: pass def peek(self) -> int: pass def get_min(self) -> int: pass ``` **Input:** * For `push`, `val` is an integer. The length of the stack can be up to (10^5), and the integer values range between (-10^9) and (10^9). **Output:** * For `pop` and `peek`, return the top element of the stack. If the stack is empty, raise an exception. * For `get_min`, return the smallest element in the stack. If the stack is empty, raise an exception. **Constraints:** * Operations `push`, `pop`, `peek`, and `get_min` should all run efficiently. * Handle edge cases such as attempting operations on an empty stack. **Examples:** ```python stack = CustomStack() stack.push(5) stack.push(3) stack.push(7) assert stack.get_min() == 3 assert stack.pop() == 7 assert stack.peek() == 3 stack.push(2) assert stack.get_min() == 2 assert stack.pop() == 2 assert stack.get_min() == 3 ```","solution":"class CustomStack: def __init__(self): self.stack = [] self.min_stack = [] def push(self, val: int) -> None: self.stack.append(val) if not self.min_stack or val <= self.min_stack[-1]: self.min_stack.append(val) def pop(self) -> int: if not self.stack: raise IndexError(\\"pop from an empty stack\\") val = self.stack.pop() if val == self.min_stack[-1]: self.min_stack.pop() return val def peek(self) -> int: if not self.stack: raise IndexError(\\"peek from an empty stack\\") return self.stack[-1] def get_min(self) -> int: if not self.min_stack: raise IndexError(\\"get_min from an empty stack\\") return self.min_stack[-1]"},{"question":"# Newton\'s Second Law Calculator Newton\'s Second Law of Motion states that the force acting on an object is equal to the mass of the object multiplied by its acceleration. The law is described by the equation: [ F = m cdot a ] Where: - ( F ) is the force acting on the object (in Newtons). - ( m ) is the mass of the object (in kilograms). - ( a ) is the acceleration of the object (in meters per second squared). Your task is to write a function `calculate_missing` that calculates one missing parameter (either `force`, `mass`, or `acceleration`) given the other two. # Function Signature ```python def calculate_missing(force: float, mass: float, acceleration: float) -> dict[str, float]: ``` # Parameters - `force (float)`: The force acting on the object (in Newtons); can be zero if to be computed. - `mass (float)`: The mass of the object (in kilograms); can be zero if to be computed. - `acceleration (float)`: The acceleration of the object (in meters per second squared); can be zero if to be computed. # Returns - `result (dict)`: A dictionary containing the name and computed value of the missing parameter. # Constraints - Only one among `force`, `mass`, and `acceleration` should be zero to be computed. - The `mass` can\'t be negative or zero. - The `acceleration` can\'t be negative or zero. # Errors Raise appropriate errors if: - More than one or none of the parameters is zero. - The mass or acceleration is negative or zero. # Examples As part of the task, your function should handle the following cases: ```python >>> calculate_missing(force=0, mass=10, acceleration=5) {\'force\': 50.0} >>> calculate_missing(force=10, mass=0, acceleration=2) {\'mass\': 5.0} >>> calculate_missing(force=10, mass=10, acceleration=0) {\'acceleration\': 1.0} >>> calculate_missing(force=0, mass=0, acceleration=5) Traceback (most recent call last): ... ValueError: One and only one argument must be 0 >>> calculate_missing(force=0, mass=10, acceleration=-5) Traceback (most recent call last): ... ValueError: Acceleration cannot be negative >>> calculate_missing(force=0, mass=-10, acceleration=5) Traceback (most recent call last): ... ValueError: Mass cannot be negative or zero ``` Write your implementation of the function `calculate_missing`, ensuring it handles all the given examples and edge cases.","solution":"def calculate_missing(force: float, mass: float, acceleration: float) -> dict[str, float]: Calculates the missing parameter in Newton\'s Second Law of Motion. Parameters: - force (float): The force acting on the object (in Newtons); can be zero if to be computed. - mass (float): The mass of the object (in kilograms); can be zero if to be computed. - acceleration (float): The acceleration of the object (in meters per second squared); can be zero if to be computed. Returns: - result (dict): A dictionary containing the name and computed value of the missing parameter. # Count the number of zero (missing) parameters zero_count = sum(map(lambda x: x == 0, [force, mass, acceleration])) if zero_count != 1: raise ValueError(\\"One and only one argument must be 0\\") if mass < 0: raise ValueError(\\"Mass cannot be negative or zero\\") if acceleration < 0: raise ValueError(\\"Acceleration cannot be negative or zero\\") if force == 0: return {\'force\': mass * acceleration} if mass == 0: return {\'mass\': force / acceleration} if acceleration == 0: return {\'acceleration\': force / mass}"},{"question":"# Stock Price Prediction Challenge Context: You are working as a data scientist for a fintech company. Your team is developing an automated trading system that predicts stock prices based on historical data. To create a robust prediction model, you need to implement an algorithm that will determine the best days to buy and sell stocks to maximize profit. You are given daily stock prices, and your task is to find the maximum profit that can be achieved by completing at most one transaction (i.e., buying and selling one share of the stock). Task: Write a Python function to find the maximum profit from an array of stock prices. The function should return the maximum profit that can be achieved by buying and then later selling the stock. Input: 1. `prices` (List[int]): A list of integers representing the stock prices on different days. Output: 1. An integer representing the maximum profit that can be achieved. Example: ```python prices = [7, 1, 5, 3, 6, 4] print(max_profit(prices)) ``` Expected Output: ``` 5 ``` Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5. Example: ```python prices = [7, 6, 4, 3, 1] print(max_profit(prices)) ``` Expected Output: ``` 0 ``` Explanation: In this case, no transaction is done, and the maximum profit = 0. # Constraints: * The length of `prices` list will be between 1 and 10^5. * All elements in `prices` will be integers, and each will represent a price in the range 0 to 10^4. # Requirements: 1. Your solution should exhibit a time complexity of O(n). 2. Ensure that your function handles edge cases such as the list having less than two prices. # Note: * The algorithm should make sure to not perform any transaction if it results in a loss. * If the `prices` list has less than two elements, the maximum profit should be 0.","solution":"def max_profit(prices): Returns the maximum profit that can be achieved by buying and then selling the stock. :param prices: List[int] - List of daily stock prices :return: int - Maximum profit if len(prices) < 2: return 0 min_price = float(\'inf\') max_profit = 0 for price in prices: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"# Problem Statement: Write a function that takes an array of integers and returns an array containing the next greater element for each element in the input array. The next greater element for an element `x` is the first greater element on the right side of `x` in the array. If no such element exists, output `-1` for that element. # Input: An array of integers `arr`. # Output: An array where each index `i` contains the next greater element of `arr[i]`, or `-1` if no such element exists. # Constraints: * The array length will be between 1 and 10^5. * Each element in the array will be a valid integer within the range of -10^9 to 10^9. # Function Signature: ```python def next_greater_element(arr: [int]) -> [int]: # Your implementation goes here ``` # Examples: ```python assert next_greater_element([2, 1, 2, 4, 3]) == [4, 2, 4, -1, -1] assert next_greater_element([5, 7, 1, 2, 6]) == [7, -1, 2, 6, -1] assert next_greater_element([1, 3, 2, 4]) == [3, 4, 4, -1] assert next_greater_element([4, 3, 2, 1]) == [-1, -1, -1, -1] assert next_greater_element([10]) == [-1] ```","solution":"def next_greater_element(arr): Returns an array where each index `i` contains the next greater element of `arr[i]`, or `-1` if no such element exists. if not arr: return [] n = len(arr) result = [-1] * n stack = [] for i in range(n): while stack and arr[stack[-1]] < arr[i]: index = stack.pop() result[index] = arr[i] stack.append(i) return result"},{"question":"# Question You are given the task of writing a function `string_to_base64(s: str) -> str` that converts a given input string to its Base64 encoded representation. This function should properly encode the input string according to Base64 encoding. Input - A string `s` representing the input text. It can contain alphanumeric characters, spaces, and special characters. Output - A string representing the Base64 encoded version of the input. Constraints - The input string is non-empty. - Base64 encoding should follow standard conventions using the character set \\"A-Za-z0-9+/\\". Expected Time Complexity - O(n), where n is the length of the input string. Example ```python >>> string_to_base64(\\"Hello World!\\") \'SGVsbG8gV29ybGQh\' >>> string_to_base64(\\"Python\\") \'UHl0aG9u\' >>> string_to_base64(\\"\\") Traceback (most recent call last): ... ValueError: Empty string was passed to the function >>> string_to_base64(\\"Text with spaces.\\") \'VGV4dCB3aXRoIHNwYWNlcy4=\' >>> string_to_base64(\\"Special Characters: !@#\\") \'U3BlY2lhbCBDaGFyYWN0ZXJzOiAhQCM=\' ``` Notes - You need to validate the input to ensure it is not empty. - The function should handle conversion accurately for any valid ASCII input string. Write the function `string_to_base64` with the described specifications, ensuring that your function correctly handles and raises errors for invalid inputs.","solution":"import base64 def string_to_base64(s: str) -> str: Converts a given input string to its Base64 encoded representation. Parameters: s (str): Input string. Returns: str: Base64 encoded representation of the input string. Raises: ValueError: If the input string is empty. if len(s) == 0: raise ValueError(\\"Empty string was passed to the function\\") encoded = base64.b64encode(s.encode(\'utf-8\')).decode(\'utf-8\') return encoded"},{"question":"# Coding Assessment Question **Objective**: Implement a function to determine the course completion status based on course progress and required exam knowledge. Given the percentage of course completion and the percentage of knowledge required to pass the exam, determine if a student can successfully complete the course. # Problem Statement You are given two values: course completion percentage and required exam knowledge percentage. Write a function `can_complete_course` that returns `True` if the student can pass the course based on the given percentages and `False` otherwise. # Requirements: - If `course_completeness` or `required_knowledge` is not within the range of 0 to 100, raise a `ValueError` indicating invalid input. - Return a boolean indicating course completion status. # Function Signature ```python def can_complete_course(course_completeness: float, required_knowledge: float) -> bool: ``` # Input Format: - `course_completeness` (float): The percentage of the course that the student has completed. - `required_knowledge` (float): The percentage of knowledge required to pass the exam. # Output Format: - `bool`: `True` if the student can complete the course, `False` otherwise. # Constraints: - `course_completeness`, `required_knowledge` must be between 0 and 100 inclusive. # Example ```python # Example Input course_completeness = 75.0 required_knowledge = 70.0 # Function Call print(can_complete_course(course_completeness, required_knowledge)) # Expected Output True ``` # Additional Examples ```python >>> can_complete_course(course_completeness=60.0, required_knowledge=80.0) False >>> can_complete_course(course_completeness=85.0, required_knowledge=85.0) True >>> can_complete_course(course_completeness=-20.0, required_knowledge=70.0) Traceback (most recent call last): ... ValueError: Invalid input: course completeness and required knowledge percentages must be between 0 and 100 inclusive ``` # Notes: - Be strict on input validations. - Ensure performance efficiency. - Perform thorough testing, particularly for edge cases.","solution":"def can_complete_course(course_completeness: float, required_knowledge: float) -> bool: Determine if a student can complete the course. Both course_completeness and required_knowledge must be between 0 and 100 inclusive. The student can complete the course if course_completeness is greater than or equal to required_knowledge. Args: course_completeness (float): The percentage of the course completed by the student. required_knowledge (float): The percentage of knowledge required to pass the exam. Returns: bool: `True` if the student can complete the course, otherwise `False`. Raises: ValueError: If course_completeness or required_knowledge is not within range 0-100 inclusive. if not (0 <= course_completeness <= 100 and 0 <= required_knowledge <= 100): raise ValueError(\\"Invalid input: course completeness and required knowledge percentages must be between 0 and 100 inclusive\\") return course_completeness >= required_knowledge"},{"question":"# Coding Question: File Content Duplicator with Error Handling **Scenario**: You are working on a file processing system that reads content from a source file, processes it by appending a timestamp, and writes it to a target file. Your system must be resilient and handle common file I/O issues, such as the source file not existing or permission errors when writing to the target file. **Requirements**: 1. Implement a function `duplicate_file_content_with_timestamp(source_file_path: str, target_file_path: str) -> None` that reads content from the source file, appends the current timestamp, and writes it to the target file. 2. The function should handle scenarios where the source file does not exist by raising a `FileNotFoundError` with an appropriate message. 3. The function should handle permission errors during reading or writing by raising a `PermissionError` with an appropriate message. 4. If any other exceptions occur during the process, the function should raise a `RuntimeError` with a message indicating an unexpected error. **Input**: * `source_file_path` - The path to the source file (a valid file path string). * `target_file_path` - The path to the target file (a valid file path string). **Output**: * None if the operation is successful. * Raises a `FileNotFoundError` for a missing source file. * Raises a `PermissionError` for any read or write permission issues. * Raises a `RuntimeError` for any other unexpected issues. **Constraints**: * The file paths provided will be valid strings. * The source file will contain ASCII text. **Example**: ```python import os import time def duplicate_file_content_with_timestamp(source_file_path: str, target_file_path: str) -> None: try: with open(source_file_path, \'r\') as source_file: content = source_file.read() except FileNotFoundError: raise FileNotFoundError(f\\"Source file \'{source_file_path}\' does not exist.\\") except PermissionError: raise PermissionError(f\\"Permission denied while reading the source file \'{source_file_path}\'.\\") except Exception as e: raise RuntimeError(f\\"An unexpected error occurred while reading the source file: {str(e)}\\") timestamp = time.strftime(\\"%Y-%m-%d %H:%M:%S\\", time.gmtime()) content_with_timestamp = f\\"{content}nTimestamp: {timestamp}\\" try: with open(target_file_path, \'w\') as target_file: target_file.write(content_with_timestamp) except PermissionError: raise PermissionError(f\\"Permission denied while writing to the target file \'{target_file_path}\'.\\") except Exception as e: raise RuntimeError(f\\"An unexpected error occurred while writing to the target file: {str(e)}\\") # Example use case try: duplicate_file_content_with_timestamp(\\"source.txt\\", \\"target.txt\\") print(\\"File content duplicated successfully with timestamp\\") except (FileNotFoundError, PermissionError, RuntimeError) as e: print(e) ``` **Hints**: * Use Python\'s `os` module to check file existence. * Use the `time` module to get the current timestamp. * Ensure that the file handling is done within appropriate `try-except` blocks to handle different exceptions.","solution":"import time def duplicate_file_content_with_timestamp(source_file_path: str, target_file_path: str) -> None: try: with open(source_file_path, \'r\') as source_file: content = source_file.read() except FileNotFoundError: raise FileNotFoundError(f\\"Source file \'{source_file_path}\' does not exist.\\") except PermissionError: raise PermissionError(f\\"Permission denied while reading the source file \'{source_file_path}\'.\\") except Exception as e: raise RuntimeError(f\\"An unexpected error occurred while reading the source file: {str(e)}\\") timestamp = time.strftime(\\"%Y-%m-%d %H:%M:%S\\", time.gmtime()) content_with_timestamp = f\\"{content}nTimestamp: {timestamp}\\" try: with open(target_file_path, \'w\') as target_file: target_file.write(content_with_timestamp) except PermissionError: raise PermissionError(f\\"Permission denied while writing to the target file \'{target_file_path}\'.\\") except Exception as e: raise RuntimeError(f\\"An unexpected error occurred while writing to the target file: {str(e)}\\")"},{"question":"# Circular Array Rotation **Scenario**: You are working on a data processing application where certain datasets are represented as circular arrays. Your task is to implement a feature that allows rotation of these circular arrays a given number of times. **Objective**: Write a function `circular_array_rotation(arr: List[int], k: int) -> List[int]` that returns the array after it has been rotated `k` times to the right. **Input**: - `arr` (List[int]): An initial array of integers. - `k` (int): The number of times the array should be rotated to the right. **Output**: - The array (List[int]) after being rotated `k` times to the right. **Constraints**: - 1 <= len(arr) <= 10^5 - -10^3 <= arr[i] <= 10^3 - 1 <= k <= 10^5 **Performance Requirements**: - Your implementation should handle the upper constraint limits efficiently, particularly regarding time complexity. **Example**: ```python initial_array = [3, 8, 9, 7, 6] rotations = 3 result = circular_array_rotation(initial_array, rotations) # Expected output [9, 7, 6, 3, 8] ``` Implement the function `circular_array_rotation` following the specified guidelines and ensure to handle performance and edge cases effectively.","solution":"from typing import List def circular_array_rotation(arr: List[int], k: int) -> List[int]: Rotates the array `arr` to the right `k` times. n = len(arr) # Avoid doing extra rotations k %= n # Effective rotation return arr[-k:] + arr[:-k]"},{"question":"# Coding Assessment Question Scenario You are working on a team developing software to simulate a game similar to \\"Tetris.\\" One of the tasks is to keep track of removing full rows from a game grid. The game grid is represented as a 2D list of integers where 1 represents an occupied cell and 0 represents an empty cell. Your task is to design a function that removes all fully occupied rows from the grid and returns the resulting grid after compressing remaining rows to the bottom, filling any empty rows at the top with zeros. Function Definition Write a function `remove_full_rows(grid: List[List[int]]) -> List[List[int]]` that takes a 2D list of integers `grid` representing the game grid and returns the game grid after removing all fully occupied rows and compressing the remaining rows to the bottom. Input * `grid: List[List[int]]`: A 2D list of integers representing the game grid (1 ≤ len(grid) ≤ 100, 1 ≤ len(grid[0]) ≤ 100). Output * A 2D list of integers representing the game grid after removing fully occupied rows and compressing the remaining rows. Example ```python >>> grid = [ ... [0, 1, 0, 1], ... [1, 1, 1, 1], ... [0, 0, 1, 0], ... [1, 1, 1, 1] ... ] >>> remove_full_rows(grid) [ [0, 0, 0, 0], [0, 0, 0, 0], [0, 1, 0, 1], [0, 0, 1, 0] ] ``` Constraints * Each sublist in grid represents a row of the game grid. * Fully occupied rows contain all 1s and should be removed. * Remaining rows should move down to fill the empty space while new empty rows filled with 0s should appear on top. * Ensure efficient implementation to handle the grid size limits. Performance Requirements Your solution should handle the upper constraints efficiently within reasonable time and space complexity. Edge Cases to Consider * The grid might contain no fully occupied rows. * Multiple consecutive fully occupied rows. * The grid might be as small as 1x1 or as large as 100x100.","solution":"from typing import List def remove_full_rows(grid: List[List[int]]) -> List[List[int]]: rows_to_keep = [row for row in grid if not all(cell == 1 for cell in row)] num_full_rows = len(grid) - len(rows_to_keep) new_grid = [[0] * len(grid[0]) for _ in range(num_full_rows)] + rows_to_keep return new_grid"},{"question":"# String Compression In data processing and storage systems, compression of repetitive sequences can significantly optimize space and efficiency. Your task involves implementing a function that compresses a given string by summarizing consecutive repeated characters with their count, followed by the character itself. Task Objective: Write a function `compress_string(input_string: str) -> str` that compresses consecutive repeated characters in the string. Function Specifications: * **Input**: * `input_string` (str): a string containing any printable ASCII characters, including spaces. The input is guaranteed to be non-empty. * **Output**: * (str): a compressed string where each sequence of repeated characters is replaced by the count of repetitions followed by the character itself. Constraints: * Single characters should not be followed by ‘1’ (e.g., \\"a\\" should remain \\"a\\" and not become \\"a1\\"). * Upper and lower case letters should be treated as different characters (e.g., \\"aA\\" should remain \\"aA\\"). Error Handling: * If the input is not a string, raise a `TypeError` with a message: \\"Expected a string as input\\". Example usages: ```python >>> compress_string(\\"aaabbccc\\") \'3a2b3c\' >>> compress_string(\\"abcd\\") \'abcd\' >>> compress_string(\\"aaaa\\") \'4a\' >>> compress_string(\\"aA\\") \'aA\' >>> compress_string(123) Traceback (most recent call last): ... TypeError: Expected a string as input ``` You are encouraged to think about edge cases such as single-character inputs, string with no repeating characters, and mixed-case scenarios. This problem tests your ability to handle string manipulation efficiently and correctly. Implement the function keeping in mind the given constraints and edge cases.","solution":"def compress_string(input_string: str) -> str: if not isinstance(input_string, str): raise TypeError(\\"Expected a string as input\\") compressed = [] count = 1 for i in range(1, len(input_string)): if input_string[i] == input_string[i - 1]: count += 1 else: if count > 1: compressed.append(f\\"{count}{input_string[i - 1]}\\") else: compressed.append(input_string[i - 1]) count = 1 if count > 1: compressed.append(f\\"{count}{input_string[-1]}\\") else: compressed.append(input_string[-1]) return \'\'.join(compressed)"},{"question":"# Question: String Compression and Decompression You are required to implement two functions: `compress` and `decompress`, which perform simple string compression and decompression respectively. The compression algorithm should identify consecutive characters in the input string and replace them with the character followed by the number of consecutive occurrences. For decompression, the process should revert these changes to restore the original string. Compress Function The `compress` function should reduce the size of a string by transforming sequences of the same character into the character followed by the number of occurrences. Decompress Function The `decompress` function should take an input string in the compressed format and revert it to its original uncompressed form. # Input For `compress`: * A string `input_str` that consists of alphanumeric characters only. For `decompress`: * A compressed string `input_compressed` that represents the original string with consecutive characters replaced by the character followed by the number of its occurrences. # Output For `compress`: * A string that represents the compressed form of `input_str`. For `decompress`: * A string that represents the original uncompressed form of `input_compressed`. # Constraints * Ensure that both `compress` and `decompress` functions handle edge cases including single character strings, strings without any repeated characters, and strings with maximum length of 1000 characters. * The `compress` function should achieve actual compression in cases where the compressed string is shorter than the original string. # Example ```python def compress(input_str: str) -> str: compressed = [] count = 1 for i in range(1, len(input_str) + 1): if i < len(input_str) and input_str[i] == input_str[i - 1]: count += 1 else: compressed.append(input_str[i - 1] + str(count)) count = 1 return \\"\\".join(compressed) def decompress(input_compressed: str) -> str: decompressed = [] i = 0 while i < len(input_compressed): char = input_compressed[i] count = \\"\\" i += 1 while i < len(input_compressed) and input_compressed[i].isdigit(): count += input_compressed[i] i += 1 decompressed.append(char * int(count)) return \\"\\".join(decompressed) # Example usages compressed_string = compress(\\"aaabbcccc\\") # Expected output: \\"a3b2c4\\" original_string = decompress(compressed_string) # Expected output: \\"aaabbcccc\\" ```","solution":"def compress(input_str: str) -> str: if not input_str: return \\"\\" compressed = [] count = 1 for i in range(1, len(input_str) + 1): if i < len(input_str) and input_str[i] == input_str[i - 1]: count += 1 else: compressed.append(input_str[i - 1] + str(count)) count = 1 return \\"\\".join(compressed) def decompress(input_compressed: str) -> str: if not input_compressed: return \\"\\" decompressed = [] i = 0 while i < len(input_compressed): char = input_compressed[i] count = \\"\\" i += 1 while i < len(input_compressed) and input_compressed[i].isdigit(): count += input_compressed[i] i += 1 decompressed.append(char * int(count)) return \\"\\".join(decompressed)"},{"question":"# Coding Assessment Question You need to design a function that finds the longest word in a given string. If multiple words are of the same maximum length, return the first one encountered. Words will be defined as contiguous sequences of alphabetic characters, and non-alphabetic characters will act as delimiters. The function should ignore any leading or trailing delimiters. If the input string is empty, return an empty string. Function Signature `def longest_word(sentence: str) -> str:` Input * `sentence`: A string that may contain alphabetic and non-alphabetic characters. Output * Returns the longest word found in the input string. Constraints * Extract words using alphabetic characters only (case insensitive). * Consider non-alphabetic characters as delimiters. * An empty input string should return an empty string. Examples ```python >>> longest_word(\\"The quick brown fox jumped over the lazy dog!\\") \'jumped\' >>> longest_word(\\"What a wonderful world\\") \'wonderful\' >>> longest_word(\\"To be, or not to be; that is the question.\\") \'question\' >>> longest_word(\\"Hello-World!!!\\") \'Hello\' >>> longest_word(\\"\\") \'\' ``` # Your Implementation ```python def longest_word(sentence: str) -> str: import re words = re.findall(r\'[a-zA-Z]+\', sentence) if not words: return \'\' return max(words, key=len) ``` Notes Ensure that your function handles all given edge cases appropriately, including input strings with various delimiters and mixed characters. Validate the function with provided examples and any additional test cases you can think of that align with the problem constraints.","solution":"def longest_word(sentence: str) -> str: import re words = re.findall(r\'[a-zA-Z]+\', sentence) if not words: return \'\' return max(words, key=len)"},{"question":"# Problem Statement You are given a string representing a mixed list of integers and words enclosed in square brackets and separated by commas, like this: `\\"[1,apple,3,banana,5,orange]\\"`. Your task is to write a function `separate_and_sum` that processes the string, separates the integers and the words, sorts the words alphabetically, and returns the sorted list of words along with the sum of the integers. Input - A single string with the format described, representing a mixed list of integers and words. The string always starts with `[` and ends with `]`. Output - A tuple consisting of: 1. A list of words sorted alphabetically. 2. An integer representing the sum of all the integers in the list. Constraints - The input string contains at least one integer and one word. - Words consist of only lower-case alphabetic characters (a-z) and are all unique. - Integers are non-negative and no larger than 10^6. - The number of elements (integers and words combined) does not exceed 1000. Function Signature ```python def separate_and_sum(input_str: str) -> (list, int): ``` Example Suppose the input string is: ```text \\"[1,apple,3,banana,5,orange]\\" ``` After separating and processing, the output should be: ```text ([\'apple\', \'banana\', \'orange\'], 9) ``` Here are the detailed steps: 1. Extract elements from the string: `[1, \'apple\', 3, \'banana\', 5, \'orange\']` 2. Separate the integers and words: - Integers: [1, 3, 5] - Words: [\'apple\', \'banana\', \'orange\'] 3. Sum the integers: 1 + 3 + 5 = 9 4. Sort the words alphabetically: [\'apple\', \'banana\', \'orange\'] Thus, the function should return (`[\'apple\', \'banana\', \'orange\']`, 9). Requirements - Implement the function in Python. - Ensure the function correctly handles the provided string input format and processes the elements as described. - Use efficient string manipulation and sorting methods to handle the input within the constraints.","solution":"def separate_and_sum(input_str: str) -> (list, int): Processes the input string, separates the integers and the words, sorts the words alphabetically, and returns the sorted list of words along with the sum of the integers. Parameters: input_str (str): The input string in the format \\"[1,apple,3,banana,5,orange]\\" Returns: tuple: A tuple containing a list of words sorted alphabetically and the sum of integers. # Removing the square brackets and splitting the string by comma elements = input_str.strip(\'[]\').split(\',\') integers = [] words = [] for element in elements: if element.isdigit(): integers.append(int(element)) else: words.append(element) sum_of_integers = sum(integers) sorted_words = sorted(words) return (sorted_words, sum_of_integers)"},{"question":"# Scenario: You are developing a card game application. One of the key tasks is to manage and shuffle a deck of cards using a reliable method to ensure fair play. Each deck contains 52 unique cards represented by strings such as \\"2H\\" (2 of Hearts), \\"AD\\" (Ace of Diamonds), \\"10S\\" (10 of Spades), etc. # Task: Write a function named `shuffle_deck` that takes a list of 52 card strings and returns a new shuffled list representing the shuffled deck. Additionally, write a function named `validate_deck` that checks if a given list of 52 card strings forms a valid and complete deck of cards. # Function Definitions: 1. **shuffle_deck(deck: List[str]) -> List[str]** - Shuffles the given deck of cards and returns the shuffled deck. 2. **validate_deck(deck: List[str]) -> bool** - Validates the given deck to ensure it has all 52 unique cards. # Input and Output Formats: - **Input**: - `deck` (List[str]): A list of 52 card strings. - **Output**: - Returns the shuffled list of cards for `shuffle_deck`. - Returns `True` if the deck is valid and complete, `False` otherwise for `validate_deck`. # Constraints: 1. The `deck` list will contain exactly 52 elements, where each element is a string representing a card. 2. A valid deck should contain every combination of ranks (2-10, J, Q, K, A) and suits (Hearts, Diamonds, Clubs, Spades). 3. Raises appropriate exceptions for invalid inputs, such as non-list inputs or lists of incorrect length. # Examples: - **Example 1**: ```python validate_deck([\\"2H\\", \\"3H\\", \\"4H\\", \\"5H\\", \\"6H\\", \\"7H\\", \\"8H\\", \\"9H\\", \\"10H\\", \\"JH\\", \\"QH\\", \\"KH\\", \\"AH\\", \\"2D\\", \\"3D\\", \\"4D\\", \\"5D\\", \\"6D\\", \\"7D\\", \\"8D\\", \\"9D\\", \\"10D\\", \\"JD\\", \\"QD\\", \\"KD\\", \\"AD\\", \\"2C\\", \\"3C\\", \\"4C\\", \\"5C\\", \\"6C\\", \\"7C\\", \\"8C\\", \\"9C\\", \\"10C\\", \\"JC\\", \\"QC\\", \\"KC\\", \\"AC\\", \\"2S\\", \\"3S\\", \\"4S\\", \\"5S\\", \\"6S\\", \\"7S\\", \\"8S\\", \\"9S\\", \\"10S\\", \\"JS\\", \\"QS\\", \\"KS\\", \\"AS\\"]) # Output: True ``` - **Example 2**: ```python shuffle_deck([\\"2H\\", \\"3H\\", \\"4H\\", \\"5H\\", \\"6H\\", \\"7H\\", \\"8H\\", \\"9H\\", \\"10H\\", \\"JH\\", \\"QH\\", \\"KH\\", \\"AH\\", \\"2D\\", \\"3D\\", \\"4D\\", \\"5D\\", \\"6D\\", \\"7D\\", \\"8D\\", \\"9D\\", \\"10D\\", \\"JD\\", \\"QD\\", \\"KD\\", \\"AD\\", \\"2C\\", \\"3C\\", \\"4C\\", \\"5C\\", \\"6C\\", \\"7C\\", \\"8C\\", \\"9C\\", \\"10C\\", \\"JC\\", \\"QC\\", \\"KC\\", \\"AC\\", \\"2S\\", \\"3S\\", \\"4S\\", \\"5S\\", \\"6S\\", \\"7S\\", \\"8S\\", \\"9S\\", \\"10S\\", \\"JS\\", \\"QS\\", \\"KS\\", \\"AS\\"]) # Output: A different permutation of the original deck, such as: # [\\"7D\\", \\"5S\\", \\"10H\\", \\"9C\\", \\"2H\\", \\"QS\\", \\"KH\\", etc.] ```","solution":"import random def shuffle_deck(deck: list) -> list: Shuffles the given deck of cards and returns the shuffled deck. if not isinstance(deck, list) or len(deck) != 52: raise ValueError(\\"Input must be a list of 52 card strings.\\") shuffled_deck = deck[:] random.shuffle(shuffled_deck) return shuffled_deck def validate_deck(deck: list) -> bool: Validates the given deck to ensure it has all 52 unique cards. if not isinstance(deck, list) or len(deck) != 52: return False suits = [\'H\', \'D\', \'C\', \'S\'] ranks = [\'2\', \'3\', \'4\', \'5\', \'6\', \'7\', \'8\', \'9\', \'10\', \'J\', \'Q\', \'K\', \'A\'] valid_deck = {rank + suit for suit in suits for rank in ranks} return set(deck) == valid_deck"},{"question":"# Scenario You have been tasked with developing a feature for an inventory management system in a retail store. This feature will help in tracking the number of items on hand for each product and notify the store when an item needs to be reordered. The system should let the manager update the inventory based on sales and new shipments. # Task Write a class `Inventory` that manages the inventory for various products. The class should support adding new products, updating stock levels, and checking if a product needs to be reordered based on a reorder threshold. The class should have methods to add stock, deduct stock, and check if reorder is needed. # Class and Method Signatures ```python class Inventory: def __init__(self): pass def add_product(self, product_id: str, stock: int, reorder_threshold: int): pass def add_stock(self, product_id: str, quantity: int): pass def deduct_stock(self, product_id: str, quantity: int): pass def needs_reorder(self, product_id: str) -> bool: pass ``` # Input - `add_product`: Adds a new product to the inventory with initial stock and a reorder threshold. - `product_id` (str): Unique identifier for the product. - `stock` (int): Initial number of items in stock. - `reorder_threshold` (int): The stock level below which a reorder is needed. - `add_stock`: Increases the stock level of a product by the specified quantity. - `product_id` (str): Unique identifier for the product. - `quantity` (int): Number of items to add to the current stock. - `deduct_stock`: Decreases the stock level of a product by the specified quantity. - `product_id` (str): Unique identifier for the product. - `quantity` (int): Number of items to deduct from the current stock. - `needs_reorder`: Checks if the stock level of a product is below its reorder threshold. - `product_id` (str): Unique identifier for the product. # Output - `needs_reorder`: Returns `True` if the stock level of the product is below the reorder threshold, otherwise `False`. # Constraints - All `product_id` values are unique. - `stock`, `quantity`, and `reorder_threshold` are non-negative integers. - The system should handle adding, deducting, and checking stock for any number of products. - Raise a `ValueError` if `deduct_stock` is called with a quantity greater than the current stock. # Examples ```python inventory = Inventory() # Adding products inventory.add_product(\\"apple\\", 50, 10) inventory.add_product(\\"banana\\", 30, 5) # Adding stock inventory.add_stock(\\"apple\\", 20) print(inventory.needs_reorder(\\"apple\\")) # False # Deducting stock inventory.deduct_stock(\\"banana\\", 27) print(inventory.needs_reorder(\\"banana\\")) # True # Attempting to deduct too much stock should raise ValueError inventory.deduct_stock(\\"apple\\", 100) # ValueError: Not enough stock to deduct. ```","solution":"class Inventory: def __init__(self): self.products = {} def add_product(self, product_id: str, stock: int, reorder_threshold: int): self.products[product_id] = { \\"stock\\": stock, \\"reorder_threshold\\": reorder_threshold } def add_stock(self, product_id: str, quantity: int): if product_id in self.products: self.products[product_id][\\"stock\\"] += quantity else: raise ValueError(f\\"Product {product_id} does not exist in the inventory.\\") def deduct_stock(self, product_id: str, quantity: int): if product_id in self.products: if self.products[product_id][\\"stock\\"] >= quantity: self.products[product_id][\\"stock\\"] -= quantity else: raise ValueError(\\"Not enough stock to deduct.\\") else: raise ValueError(f\\"Product {product_id} does not exist in the inventory.\\") def needs_reorder(self, product_id: str) -> bool: if product_id in self.products: return self.products[product_id][\\"stock\\"] < self.products[product_id][\\"reorder_threshold\\"] raise ValueError(f\\"Product {product_id} does not exist in the inventory.\\")"},{"question":"Scenario You are working at a logistics company that is striving to optimize the delivery routes of its delivery trucks. The company has gathered data on past delivery times and distances between various locations. You are tasked with implementing a k-means clustering algorithm to categorize delivery routes into different clusters based on delivery time and distance. # Task Implement the following functions necessary for the k-means clustering algorithm: 1. `initialize_centroids`: Randomly initialize centroids. 2. `assign_clusters`: Assign each delivery route to the nearest centroid. 3. `update_centroids`: Update centroids based on the current clustering. 4. `converged`: Determine if the centroids have converged. 5. `calculate_sse`: Calculate the sum of squared errors to evaluate the clustering. You will use a given dataset of delivery routes with their respective times and distances to perform the clustering and evaluate its effectiveness. # Function Definitions **Function 1**: `initialize_centroids(k: int, data: list) -> list` - **Input**: Number of clusters `k` and a list of delivery routes (each route is a tuple of time and distance). - **Output**: List of initialized centroids. - **Example**: ```python data = [(30, 5), (45, 10), (50, 15), (70, 20)] initialize_centroids(2, data) # Output: [(30, 5), (50, 15)] # Example of potential centroids ``` **Function 2**: `assign_clusters(data: list, centroids: list) -> list` - **Input**: A list of delivery routes and a list of centroids. - **Output**: List of cluster indices assigned to each delivery route. - **Example**: ```python data = [(30, 5), (45, 10), (50, 15), (70, 20)] centroids = [(30, 5), (50, 15)] assign_clusters(data, centroids) # Output: [0, 1, 1, 1] ``` **Function 3**: `update_centroids(clusters: list, data: list, k: int) -> list` - **Input**: List of cluster indices, list of delivery routes, and number of clusters `k`. - **Output**: List of updated centroids. - **Example**: ```python data = [(30, 5), (45, 10), (50, 15), (70, 20)] clusters = [0, 0, 1, 1] k = 2 update_centroids(clusters, data, k) # Output: [(37.5, 7.5), (60.0, 17.5)] ``` **Function 4**: `converged(old_centroids: list, new_centroids: list, tolerance: float) -> bool` - **Input**: List of old centroids, list of new centroids, and a tolerance value. - **Output**: Boolean indicating if the centroids have converged. - **Example**: ```python old_centroids = [(30, 5), (50, 15)] new_centroids = [(30.1, 5.1), (50.0, 15.0)] tolerance = 0.1 converged(old_centroids, new_centroids, tolerance) # Output: True ``` **Function 5**: `calculate_sse(clusters: list, data: list, centroids: list) -> float` - **Input**: List of cluster indices, list of delivery routes, and list of centroids. - **Output**: Sum of squared errors. - **Example**: ```python data = [(30, 5), (45, 10), (50, 15), (70, 20)] clusters = [0, 0, 1, 1] centroids = [(37.5, 7.5), (60.0, 17.5)] calculate_sse(clusters, data, centroids) # Output: sse value ``` # Constraints - The number of clusters `k` and the number of delivery routes are positive integers. - The delivery time and distance are non-negative floats. - Handle edge cases where clusters are initialized with the same centroid or have no data points. # Expected Workflow 1. Initialize `k` centroids randomly. 2. Assign each delivery route to the nearest centroid. 3. Update centroids based on current cluster assignments. 4. Check for convergence and repeat steps 2-3 until the centroids converge. 5. Calculate the sum of squared errors to evaluate the effectiveness of the clustering.","solution":"import random import math def initialize_centroids(k, data): Initialize k centroids randomly from the given data. return random.sample(data, k) def assign_clusters(data, centroids): Assign each data point to the nearest centroid. clusters = [] for point in data: distances = [math.sqrt((point[0] - c[0])**2 + (point[1] - c[1])**2) for c in centroids] closest_centroid = distances.index(min(distances)) clusters.append(closest_centroid) return clusters def update_centroids(clusters, data, k): Update the centroids based on the current cluster assignments. new_centroids = [] for i in range(k): cluster_points = [data[j] for j in range(len(data)) if clusters[j] == i] if cluster_points: avg_time = sum([p[0] for p in cluster_points]) / len(cluster_points) avg_distance = sum([p[1] for p in cluster_points]) / len(cluster_points) new_centroids.append((avg_time, avg_distance)) else: new_centroids.append((0, 0)) return new_centroids def converged(old_centroids, new_centroids, tolerance): Check if the centroids have converged within the specified tolerance. for oc, nc in zip(old_centroids, new_centroids): if math.sqrt((oc[0]-nc[0])**2 + (oc[1]-nc[1])**2) > tolerance: return False return True def calculate_sse(clusters, data, centroids): Calculate the sum of squared errors for the current clustering. sse = 0 for i, point in enumerate(data): centroid = centroids[clusters[i]] sse += (point[0] - centroid[0])**2 + (point[1] - centroid[1])**2 return sse"},{"question":"# Binary Search Tree (BST) Operations Your task is to implement a Binary Search Tree (BST) with the ability to insert elements, delete elements, and find the lowest common ancestor of two given nodes. Each operation should be a separate function that integrates correctly within the BST structure. Also, you should provide a function to display the in-order traversal of the BST. Function Signatures: 1. `class Node:` - **Attributes**: - `key`: the value stored in the node - `left`: reference to the left child node - `right`: reference to the right child node 2. `class BST:` - **Methods**: 1. `def __init__(self):` - **Input**: None - **Output**: Initializes an empty BST 2. `def insert(self, key: int):` - **Input**: - `key`: an integer value to insert into the BST - **Output**: None 3. `def delete(self, key: int):` - **Input**: - `key`: an integer value to delete from the BST - **Output**: None 4. `def find_LCA(self, n1: int, n2: int) -> int:` - **Input**: - `n1`: first node value - `n2`: second node value - **Output**: - The value of the lowest common ancestor 5. `def in_order_traversal(self) -> list[int]:` - **Input**: None - **Output**: Returns a list of all node values in the BST arranged in ascending order Constraints: - The BST must handle edge cases such as insertion and deletion of duplicate values appropriately. - All node values are unique. - The values of `n1` and `n2` for the `find_LCA` method will always be present in the tree. - Input values can range from -10⁶ to 10⁶. Example: ```python bst = BST() bst.insert(20) bst.insert(10) bst.insert(30) bst.insert(5) bst.insert(15) bst.insert(25) bst.insert(35) print(bst.in_order_traversal()) # Output: [5, 10, 15, 20, 25, 30, 35] bst.delete(20) print(bst.in_order_traversal()) # Output: [5, 10, 15, 25, 30, 35] print(bst.find_LCA(5, 15)) # Output: 10 print(bst.find_LCA(25, 35)) # Output: 30 ``` Notes: - Ensure the BST operations maintain the property of the BST. - Implement the node deletion method considering the three possible scenarios: deleting a leaf node, deleting a node with one child, and deleting a node with two children. - The lowest common ancestor should be determined using the properties of BST for efficient computation.","solution":"class Node: def __init__(self, key): self.key = key self.left = None self.right = None class BST: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = Node(key) else: self._insert(self.root, key) def _insert(self, node, key): if key < node.key: if node.left: self._insert(node.left, key) else: node.left = Node(key) elif key > node.key: if node.right: self._insert(node.right, key) else: node.right = Node(key) def delete(self, key): self.root = self._delete(self.root, key) def _delete(self, node, key): if not node: return node if key < node.key: node.left = self._delete(node.left, key) elif key > node.key: node.right = self._delete(node.right, key) else: if not node.left: return node.right elif not node.right: return node.left temp_val = self._minValueNode(node.right) node.key = temp_val.key node.right = self._delete(node.right, temp_val.key) return node def _minValueNode(self, node): current = node while current.left: current = current.left return current def find_LCA(self, n1, n2): return self._find_LCA(self.root, n1, n2).key def _find_LCA(self, node, n1, n2): if not node: return None if node.key > n1 and node.key > n2: return self._find_LCA(node.left, n1, n2) if node.key < n1 and node.key < n2: return self._find_LCA(node.right, n1, n2) return node def in_order_traversal(self): res = [] self._in_order_traversal(self.root, res) return res def _in_order_traversal(self, node, res): if node: self._in_order_traversal(node.left, res) res.append(node.key) self._in_order_traversal(node.right, res)"},{"question":"# Question You are tasked with developing a function that detects and corrects common spelling errors in a given document. The typical spelling errors include the following types: 1. Single-character insertion (e.g., \\"speling\\" should be corrected to \\"spelling\\"). 2. Single-character deletion (e.g., \\"speling\\" should be corrected to \\"spelling\\"). 3. Single-character substitution (e.g., \\"spelking\\" should be corrected to \\"spelling\\"). 4. Two adjacent characters swapped (e.g., \\"spelilng\\" should be corrected to \\"spelling\\"). Your task is to write a function that identifies the misspelled words in the document and suggests the correct spelling based on a given dictionary of correctly spelled words. # Requirements Your function should: 1. Identify misspelled words in the text. 2. Suggest the most plausible correction for each misspelled word using the smallest edit distance (Levenshtein distance). 3. Ensure that the solution can handle documents with large amounts of text efficiently. # Function Signature ```python from typing import List, Dict def correct_spelling(text: str, dictionary: List[str]) -> Dict[str, str]: Correct misspelled words in the text based on the provided dictionary. :param text: A string containing the document text. :param dictionary: A list of correctly spelled words. :return: A dictionary mapping each incorrect word to its corrected form. pass ``` # Input * `text` (str): A document containing text with potential spelling errors. * `dictionary` (List[str]): A list containing correctly spelled words. # Output * Returns a dictionary where each key is a misspelled word and the corresponding value is the suggested correct spelling. # Constraints * The document text will contain only alphabetic characters and spaces. * The provided dictionary will not contain any duplicate words. # Sample Scenario Given the text: ``` I have just finised readng a book caled \\"The Art of Spelking Correction\\". ``` and the dictionary: ``` [\\"finished\\", \\"reading\\", \\"book\\", \\"called\\", \\"The\\", \\"Art\\", \\"of\\", \\"Spelling\\", \\"Correction\\"] ``` the function should return: ``` { \\"finised\\": \\"finished\\", \\"readng\\": \\"reading\\", \\"caled\\": \\"called\\", \\"Spelking\\": \\"Spelling\\" } ```","solution":"from typing import List, Dict def levenshtein_distance(word1: str, word2: str) -> int: Calculate the Levenshtein distance between two words. m, n = len(word1), len(word2) if m < n: word1, word2 = word2, word1 m, n = n, m previous_row = range(n + 1) for i, c1 in enumerate(word1): current_row = [i + 1] for j, c2 in enumerate(word2): insertions = previous_row[j + 1] + 1 deletions = current_row[j] + 1 substitutions = previous_row[j] + (c1 != c2) current_row.append(min(insertions, deletions, substitutions)) previous_row = current_row return previous_row[-1] def correct_spelling(text: str, dictionary: List[str]) -> Dict[str, str]: Correct misspelled words in the text based on the provided dictionary. :param text: A string containing the document text. :param dictionary: A list of correctly spelled words. :return: A dictionary mapping each incorrect word to its corrected form. words = text.split() corrections = {} for word in words: if word not in dictionary: min_distance = float(\'inf\') correction = word for correct_word in dictionary: distance = levenshtein_distance(word, correct_word) if distance < min_distance: min_distance = distance correction = correct_word corrections[word] = correction return corrections"},{"question":"# Question: Implement the `fraction_to_decimal` function that converts a given fraction to its decimal representation. If the decimal representation has a repeating sequence, enclose the repeating part in parentheses. # Function Signature ```python def fraction_to_decimal(numerator: int, denominator: int) -> str: ``` # Input: - `numerator` (int): The numerator of the fraction, which can be positive or negative. - `denominator` (int): The denominator of the fraction, which can be positive or negative. # Output: - (str): A string representing the decimal form of the fraction. # Examples: ```python >>> fraction_to_decimal(1, 2) \'0.5\' >>> fraction_to_decimal(2, 1) \'2\' >>> fraction_to_decimal(2, 3) \'0.(6)\' >>> fraction_to_decimal(4, 333) \'0.(012)\' >>> fraction_to_decimal(1, 6) \'0.1(6)\' >>> fraction_to_decimal(-22, 7) \'-3.(142857)\' >>> fraction_to_decimal(-50, 8) \'-6.25\' ``` # Constraints: - The function should handle numerators and denominators within the range of standard 32-bit integers. - The denominator will never be zero. - The function should correctly manage the signs of the inputs. - Ensure efficient handling of large numbers and proper identification of repeating sequences in the decimal output. # Notes: - Negative results should have a \'-\' sign in front. - The function should handle fractions that convert to both terminating and repeating decimals. - Consider edge cases involving zero and the transition from positive to negative numbers.","solution":"def fraction_to_decimal(numerator: int, denominator: int) -> str: if numerator == 0: return \'0\' # Determine sign of the result sign = \'-\' if (numerator * denominator) < 0 else \'\' # Work with absolute values to simplify numerator, denominator = abs(numerator), abs(denominator) # Initial integer part of the fraction integer_part = numerator // denominator remainder = numerator % denominator if remainder == 0: return sign + str(integer_part) decimal_part = [] remainder_map = {} while remainder != 0: if remainder in remainder_map: index = remainder_map[remainder] decimal_part.insert(index, \'(\') decimal_part.append(\')\') break remainder_map[remainder] = len(decimal_part) remainder *= 10 decimal_part.append(str(remainder // denominator)) remainder %= denominator return sign + str(integer_part) + \'.\' + \'\'.join(decimal_part)"},{"question":"# Question: **Find the First Repeating Character** # Background In many text processing tasks, it is useful to identify characters that repeat within a string. This information can help in optimizing various text analytics algorithms. For this reason, you need to develop a method to find the first repeating character in a given string. # Problem Write a function `find_first_repeating_char` that takes a string and returns the first character that repeats. If no characters repeat, return `None`. # Requirements: - The function should identify and return the first character that repeats when scanning the string from left to right. - If no character repeats, the function should return `None`. # Function Signature ```python def find_first_repeating_char(s: str) -> str: pass ``` # Input - `s` (str): A non-empty string consisting of ASCII characters. # Output - (str): The first character that repeats in the string, or `None` if no character repeats. # Examples 1. `find_first_repeating_char(\\"stress\\")` should return `\'s\'` 2. `find_first_repeating_char(\\"programming\\")` should return `\'r\'` 3. `find_first_repeating_char(\\"leetcode\\")` should return `\'e\'` 4. `find_first_repeating_char(\\"abcdef\\")` should return `None` 5. `find_first_repeating_char(\\"aabbcc\\")` should return `\'a\'` # Constraints - The length of the string `n` will be between 1 and 10^6. # Notes - The characters are case-sensitive, meaning \'A\' and \'a\' are considered different. - The function should aim for an efficient solution in terms of both time and space complexity, given the constraints. You are expected to write an efficient solution to handle the potential large size of the input string.","solution":"def find_first_repeating_char(s: str) -> str: Finds the first repeating character in the string s. If no character repeats, returns None. seen_characters = set() for char in s: if char in seen_characters: return char seen_characters.add(char) return None"},{"question":"Path Finding in Weighted Graph **Objective**: Implement a function to find the shortest path between two nodes in a weighted directed graph using Dijkstra\'s algorithm. **Scenario**: Given a weighted directed graph represented by an adjacency list, find the shortest path from a start node to a target node. Return the path as a list of nodes and the total distance of this path. Function Signature ```python def shortest_path(graph: Dict[str, List[Tuple[str, float]]], start: str, target: str) -> Tuple[List[str], float]: pass ``` Input * `graph`: A dictionary where keys are node identifiers and values are lists of tuples. Each tuple represents a directed edge from the key node to another node with a given weight. * Example: `{\'A\': [(\'B\', 1), (\'C\', 4)], \'B\': [(\'C\', 2), (\'D\', 5)], \'C\': [(\'D\', 1)], \'D\': []}` * `start`: A string representing the starting node. * `target`: A string representing the target node. Output * A tuple containing two elements: * A list of strings representing the sequence of nodes from the start to the target forming the shortest path. * A float representing the total distance of the shortest path. Constraints 1. The graph contains between 1 and 1000 nodes. 2. Edge weights are positive floating-point numbers. 3. The start and target nodes are guaranteed to be present in the graph. 4. It\'s guaranteed that there exists a path between the start and target nodes. Performance Requirements * The solution should have a time complexity of `O((V + E) log V)`, where `V` is the number of vertices (nodes) and `E` is the number of edges. **Example** ```python graph = { \'A\': [(\'B\', 1), (\'C\', 4)], \'B\': [(\'C\', 2), (\'D\', 5)], \'C\': [(\'D\', 1)], \'D\': [] } start = \'A\' target = \'D\' # Sample output # ([\'A\', \'B\', \'C\', \'D\'], 4.0) ``` Write the function `shortest_path` implementing the above logic. Ensure thorough testing with various graph structures to verify correct shortest path identification. --- This question fits well into a coding assessment set by maintaining comparable style, complexity, length, topic alignment, and uniqueness. It evaluates the candidate\'s understanding of graph algorithms and the ability to implement Dijkstra\'s algorithm efficiently.","solution":"import heapq from typing import Dict, List, Tuple def shortest_path(graph: Dict[str, List[Tuple[str, float]]], start: str, target: str) -> Tuple[List[str], float]: Finds the shortest path in a weighted directed graph using Dijkstra\'s algorithm. :param graph: A dictionary where keys are node identifiers and values are lists of tuples. Each tuple contains a node and the weight of the edge from the key node to this node. :param start: The start node. :param target: The target node. :return: A tuple containing: - A list of nodes representing the sequence of nodes from start to target forming the shortest path. - The total distance of the shortest path. # Distance from start to each node initialized to infinity distances = {node: float(\'inf\') for node in graph} distances[start] = 0 # Distance to start node is 0 # Priority queue to retrieve the next node with the smallest distance priority_queue = [(0, start)] # To track the path previous_nodes = {node: None for node in graph} while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) # Early exit if we reach the target if current_node == target: break if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance previous_nodes[neighbor] = current_node heapq.heappush(priority_queue, (distance, neighbor)) # Reconstruct the path path = [] node = target while node is not None: path.insert(0, node) node = previous_nodes[node] return path, distances[target]"},{"question":"# Question: Rotate String to Make Another String Given two strings `s` and `goal`, write a function that returns true if and only if `s` can become `goal` after some number of shifts to the left. A string is said to be a \\"shift\\" of another string if and only if it can be obtained by moving some of the characters of one string to the front without altering the order of characters. Function Signature ```python def can_rotate_string(s: str, goal: str) -> bool: pass ``` Input - `s` (string): The original string to be rotated. - `goal` (string): The target string to achieve by rotating `s`. Output - A boolean value indicating whether `s` can become `goal` after some number of shifts. Examples ```python # Example 1 s = \\"abcde\\" goal = \\"cdeab\\" # Output: True # Example 2 s = \\"abcde\\" goal = \\"abced\\" # Output: False # Example 3 s = \\"rotation\\" goal = \\"ationrot\\" # Output: True ``` Constraints - Both `s` and `goal` are non-empty strings and consist of lowercase English letters only. - The length of `s` and `goal` will be at most 100. Requirements - Aim to solve the problem using a time complexity no worse than `O(N)`, where `N` is the length of the strings. - Consider edge cases such as when `s` and `goal` have different lengths and when the goal string is already aligned with the original string. # Solution Approach To determine if one string can be obtained by rotating another, you can concatenate the original string to itself (to handle wrapping around) and then check if the goal string exists as a substring in this concatenated string.","solution":"def can_rotate_string(s: str, goal: str) -> bool: Determines if string \'s\' can be rotated to become string \'goal\'. if len(s) != len(goal): return False # Concatenate s with itself to handle rotations and check if goal is a substring double_s = s + s return goal in double_s"},{"question":"# Problem Statement You are given two string arrays representing a list of employees and their respective departments. Your task is to group all employees by their departments, then sort both the department groups and the employees within each department alphabetically. # Task Write a function `group_and_sort_employees` that takes in two lists of strings, `employees` and `departments`. Your function should return a dictionary where the keys are the department names, and the values are lists of employees in those departments, sorted alphabetically. # Input * `employees`: A list of strings representing the names of employees. * `departments`: A list of strings where each element corresponds to the department of the employee at the same index in the `employees` list. # Output * A dictionary where keys are department names, and values are lists of employee names sorted alphabetically within each department. # Constraints * The length of `employees` and `departments` will be the same, and each will have at most 1,000 elements. # Examples ```python def group_and_sort_employees(employees: list[str], departments: list[str]) -> dict[str, list[str]]: pass # Example Usage employees = [\\"Alice\\", \\"Bob\\", \\"Charlie\\", \\"David\\", \\"Eve\\"] departments = [\\"HR\\", \\"Engineering\\", \\"Engineering\\", \\"HR\\", \\"Sales\\"] print(group_and_sort_employees(employees, departments)) # Output: # { # \\"Engineering\\": [\\"Bob\\", \\"Charlie\\"], # \\"HR\\": [\\"Alice\\", \\"David\\"], # \\"Sales\\": [\\"Eve\\"] # } ``` # Notes * You need to handle edge cases, such as when the input lists are empty. * Ensure the function is performant for the input constraints.","solution":"def group_and_sort_employees(employees, departments): from collections import defaultdict department_dict = defaultdict(list) for employee, department in zip(employees, departments): department_dict[department].append(employee) # Sort the employees within each department for dept in department_dict: department_dict[dept].sort() # Convert the defaultdict back to a regular dict for the final output return dict(sorted(department_dict.items()))"},{"question":"# Coding Assessment Question **Context**: In many computing applications, it is essential to process and analyze strings in various formats and lengths. One common task is to determine the longest substring within a given string that is composed of the same character repeated. **Problem Statement**: Write a function that identifies the longest substring in a given string that consists of the same character repeated one or more times. If multiple such substrings have the same length, return the one that appears first. **Function Signature**: ```python def longest_repeated_substring(s: str) -> str: Finds the longest substring consisting of the same character. Parameters: s (str): The input string. Returns: str: The longest repeated character substring. ``` **Input**: 1. **s**: A non-empty string (e.g., \\"aaabbcaaaaadd\\") **Output**: - A string representing the longest substring made up of the same character. **Constraints**: - The input string will only contain printable ASCII characters. **Performance Requirements**: - The solution should work efficiently even for strings of considerable length. **Examples**: ```python >>> longest_repeated_substring(\\"aaabbcaaaaadd\\") \'aaaa\' >>> longest_repeated_substring(\\"aabbbccccccddd\\") \'cccccc\' >>> longest_repeated_substring(\\"abababaaaa\\") \'aaaa\' ``` Ensure your implementation handles edge cases effectively and efficiently processes diverse and longer input strings.","solution":"def longest_repeated_substring(s: str) -> str: if not s: return \\"\\" max_length = 1 max_char = s[0] current_length = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: current_length += 1 else: if current_length > max_length: max_length = current_length max_char = s[i - 1] current_length = 1 # Check last sequence if current_length > max_length: max_length = current_length max_char = s[-1] return max_char * max_length"},{"question":"# Problem Statement # Course Schedule You are tasked with determining if all the courses in a curriculum can be completed. The curriculum is represented as a list of prerequisite pairs. To complete a course, you may need to complete some other courses first. If there is a cycle in the prerequisite pairs, it is impossible to complete the curriculum. Write a function that determines whether you can finish all courses given the prerequisites. **Input:** * an integer `numCourses`: the total number of courses (1 <= numCourses <= 10000). * a list of lists `prerequisites` where each list contains two integers `[a, b]` representing course `a` has `b` as a prerequisite. **Output:** * a boolean value `True` if it is possible to complete all courses; otherwise, `False`. **Example:** ```python Input: numCourses = 4 prerequisites = [[1,0],[2,1],[3,2],[1,3]] Output: False ``` In this example, there is a cycle (1 -> 3 -> 2 -> 1), making it impossible to complete all courses. ```python Input: numCourses = 2 prerequisites = [[1,0]] Output: True ``` In this example, you can complete course 0 first, then course 1. # Constraints: * The number of edges in the prerequisite list (i.e., the number of prerequisite pairs) does not exceed 50,000. * No two pairs ` [a, b]` will have the same value. # Task: 1. Implement a function `canFinish` to determine if all courses can be completed given the prerequisites. 2. Use an efficient graph traversal algorithm to detect cycles in the graph. 3. Ensure your solution handles larger input sizes within reasonable time limits. # Function signature: ```python def canFinish(numCourses: int, prerequisites: List[List[int]]) -> bool: # your code here ``` **Note:** Consider edge cases and thoroughly test your implementation to handle all potential scenarios. Ensure your code is optimized for performance to avoid exceeding time limits on larger inputs.","solution":"from typing import List def canFinish(numCourses: int, prerequisites: List[List[int]]) -> bool: from collections import defaultdict, deque # Create a graph in the form of adjacency list graph = defaultdict(list) for course, prereq in prerequisites: graph[prereq].append(course) # Maintain an indegree list to track the number of prerequisites for each course indegree = [0] * numCourses for course, prereq in prerequisites: indegree[course] += 1 # Initialize the queue with courses that have no prerequisites queue = deque([i for i in range(numCourses) if indegree[i] == 0]) # Perform BFS visited = 0 while queue: current = queue.popleft() visited += 1 for neighbor in graph[current]: indegree[neighbor] -= 1 if indegree[neighbor] == 0: queue.append(neighbor) # If all courses are visited, it\'s possible to finish, else it\'s not return visited == numCourses"},{"question":"# Prime Sieve Optimization Background The Sieve of Eratosthenes is a classical algorithm to find all prime numbers up to a given limit `n`. The standard implementation of this algorithm involves marking the multiples of each prime number starting from 2. However, for very large values of `n`, the algorithm\'s performance can be optimized by reducing the number of unnecessary operations. Task Optimize the Sieve of Eratosthenes by incorporating the following enhancements: 1. Instead of marking all multiples of each prime number, mark only those starting from the square of the prime. 2. Skip even numbers entirely after processing 2, as they are not prime (other than 2 itself). 3. Report the list of prime numbers found within the given limit `n`, as well as the total count of these primes. Your function should have the following signature: ```python def optimized_sieve_of_eratosthenes(n: int) -> tuple[list[int], int]: ``` Constraints * The function should work efficiently for values of `n` up to at least (10^6). * Handle edge cases where `n` is less than 2 appropriately. * Ensure the algorithm only performs necessary computations to find all primes up to `n`. Example Usage ```python # Test case 1 primes, count = optimized_sieve_of_eratosthenes(10) assert primes == [2, 3, 5, 7], \\"Test Case 1 Failed\\" assert count == 4, \\"Test Case 1 Failed\\" # Test case 2 primes, count = optimized_sieve_of_eratosthenes(30) assert primes == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29], \\"Test Case 2 Failed\\" assert count == 10, \\"Test Case 2 Failed\\" print(f\\"Primes: {primes}, Count: {count}\\") ``` Notes * Write appropriate unit tests to verify your optimized sieve implementation. * Handle edge cases and potential exceptions properly.","solution":"def optimized_sieve_of_eratosthenes(n: int) -> tuple[list[int], int]: if n < 2: return ([], 0) # Initialize the sieve sieve = [True] * (n + 1) sieve[0] = sieve[1] = False # 0 and 1 are not primes # Start with the first prime number, which is 2 primes = [2] if n >= 2 else [] # Only consider odd numbers from 3 onwards for number in range(3, n + 1, 2): if sieve[number]: primes.append(number) for multiple in range(number * number, n + 1, number * 2): sieve[multiple] = False return (primes, len(primes))"},{"question":"# Coding Assessment Question Create a function that simulates a simple caching mechanism to enhance the performance of retrieving frequently accessed data from a server. Your task is to implement an LRU (Least Recently Used) cache, which improves data retrieval speed by storing recently accessed data in memory. Function Signature ```python class LRUCache: def __init__(self, capacity: int): Initialize the LRU cache with a maximum capacity. def get(self, key: int) -> int: Retrieve the value associated with the key from the cache. If the key does not exist, return -1. def put(self, key: int, value: int) -> None: Insert the key-value pair into the cache. If the cache reaches its capacity, it should invalidate the least recently used item. ``` Input Specifications: - **capacity** (*int*): The maximum number of items that can be stored in the cache. Output Specifications: - For the `get` method: returns the value associated with the key if present in the cache, otherwise returns -1. - For the `put` method: does not return anything. It only inserts or updates the key-value pair in the cache and handles capacity limits. Example Usage: ```python cache = LRUCache(2) cache.put(1, 1) cache.put(2, 2) assert cache.get(1) == 1 # returns 1 cache.put(3, 3) # evicts key 2 assert cache.get(2) == -1 # returns -1 (not found) cache.put(4, 4) # evicts key 1 assert cache.get(1) == -1 # returns -1 (not found) assert cache.get(3) == 3 # returns 3 assert cache.get(4) == 4 # returns 4 ``` Constraints: - The operations `get` and `put` must run in O(1) average time complexity. - You may use built-in Python data structures like dictionaries and lists but avoid using any third-party libraries. Notes: - The cache should maintain the insertion order of items such that the least recently used item is always identified. - Use robust error-checking mechanisms to handle edge cases where operations are performed on an empty cache. This question tests the ability to implement a common caching mechanism, handling object-oriented programming, understanding data structures, and managing performance constraints effectively.","solution":"from collections import OrderedDict class LRUCache: def __init__(self, capacity: int): self.cache = OrderedDict() self.capacity = capacity def get(self, key: int) -> int: if key not in self.cache: return -1 else: self.cache.move_to_end(key) # mark as recently used return self.cache[key] def put(self, key: int, value: int) -> None: if key in self.cache: self.cache.move_to_end(key) # mark as recently used self.cache[key] = value if len(self.cache) > self.capacity: self.cache.popitem(last=False) # remove least recently used item"},{"question":"# Implement a Trie for Efficient Prefix Searching Context You are asked to implement a Trie (Prefix Tree) to efficiently store and search for words with common prefixes. This data structure is powerful for handling tasks like autocomplete suggestions and dictionary lookup based on prefixes. Requirements Write a class `Trie` with the following methods: 1. **`__init__(self)`**: Initialize your Trie with an empty root. 2. **`insert(self, word: str)`**: Insert a given word into the Trie. 3. **`search(self, word: str) -> bool`**: Return `True` if the word is in the Trie, else `False`. 4. **`starts_with(self, prefix: str) -> bool`**: Return `True` if there is any word in the Trie that begins with the given prefix, else `False`. Input and Output * **Input**: * `insert` method should accept a string `word`. * `search` and `starts_with` methods should accept a string `word` or `prefix`, respectively. * **Output**: * `search` and `starts_with` methods should return a boolean indicating the presence of the word or prefix. Constraints * Words and prefixes are non-empty strings with lowercase Latin characters (a-z). * Words will be at most 100 characters long. * Up to (10^5) words can be inserted in the Trie. Example ```python trie = Trie() trie.insert(\\"apple\\") assert trie.search(\\"apple\\") == True # returns True assert trie.search(\\"app\\") == False # returns False assert trie.starts_with(\\"app\\") == True # returns True trie.insert(\\"app\\") assert trie.search(\\"app\\") == True # returns True ``` Explanation 1. **`trie = Trie()`**: Initializes a new Trie. 2. **`trie.insert(\\"apple\\")`**: Inserts the word \\"apple\\" into the Trie. 3. **`trie.search(\\"apple\\")`**: Searches for the word \\"apple\\" and returns `True`. 4. **`trie.search(\\"app\\")`**: Searches for the word \\"app\\" and returns `False` because \\"app\\" was not inserted as a complete word. 5. **`trie.starts_with(\\"app\\")`**: Checks if there is any word starting with \\"app\\" in the Trie and returns `True` as \\"apple\\" starts with \\"app\\". 6. **`trie.insert(\\"app\\")`**: Inserts the word \\"app\\" into the Trie. 7. **`trie.search(\\"app\\")`**: Searches for the word \\"app\\" and returns `True` since \\"app\\" was inserted as a complete word.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str) -> None: current = self.root for char in word: if char not in current.children: current.children[char] = TrieNode() current = current.children[char] current.is_word = True def search(self, word: str) -> bool: current = self.root for char in word: if char not in current.children: return False current = current.children[char] return current.is_word def starts_with(self, prefix: str) -> bool: current = self.root for char in prefix: if char not in current.children: return False current = current.children[char] return True"},{"question":"# Battleship Game Hit Detection You are tasked with implementing a function that determines if a given point on a grid hits a battleship. The game of Battleship is played on an `NxN` grid, and there are one or more battleships placed on this grid. Each battleship is represented by its coordinates and occupies a straight line of cells either horizontally or vertically. Your function will check if a given point hits any of the ships. Function Specifications Write a function `is_hit` with the following signature: ```python def is_hit(grid_size: int, ships: list[dict], point: dict) -> bool: ``` Input - `grid_size`: An integer `N` representing the size of the grid (NxN). - `ships`: A list of dictionaries, each dictionary represents a single battleship with the following keys: - `\\"start\\"` (dict): The starting point of the battleship with keys `\\"x\\"` (int) and `\\"y\\"` (int). - `\\"end\\"` (dict): The ending point of the battleship with keys `\\"x\\"` (int) and `\\"y\\"` (int). - `point`: A dictionary containing the coordinates of the point to be checked with keys: - `\\"x\\"` (int): The x-coordinate of the point. - `\\"y\\"` (int): The y-coordinate of the point. Output The function should return a boolean: - `True` if the point hits any battleship. - `False` if the point does not hit any battleship. Constraints * The grid size `N` will be such that `1 <= N <= 1000`. * No ships will overlap each other. * Ships will always be either completely horizontal or completely vertical. * The point coordinates will always be within the boundary of the grid. Example ```python grid_size = 10 ships = [ {\\"start\\": {\\"x\\": 1, \\"y\\": 1}, \\"end\\": {\\"x\\": 1, \\"y\\": 4}}, {\\"start\\": {\\"x\\": 3, \\"y\\": 3}, \\"end\\": {\\"x\\": 6, \\"y\\": 3}}, ] point = {\\"x\\": 3, \\"y\\": 3} result = is_hit(grid_size, ships, point) print(result) # Output: True ``` Notes 1. A ship that starts at `(1, 1)` and ends at `(1, 4)` occupies the cells `(1, 1), (1, 2), (1, 3), (1, 4)`. 2. To check if the point hits the ship, ensure it lies within the bounding box defined by the start and end of each ship.","solution":"def is_hit(grid_size: int, ships: list, point: dict) -> bool: Determines if a given point hits any battleship on an NxN grid. Parameters: - grid_size: Integer representing the size of the grid (NxN). - ships: List of dictionaries, each dictionary represents a ship with: - \\"start\\": Dict with keys \\"x\\" and \\"y\\" indicating the start coordinates of the ship. - \\"end\\": Dict with keys \\"x\\" and \\"y\\" indicating the end coordinates of the ship. - point: Dict with keys \\"x\\" and \\"y\\" indicating the point\'s coordinates. Returns: - True if the point hits any battleship, False otherwise. for ship in ships: start_x, start_y = ship[\\"start\\"][\\"x\\"], ship[\\"start\\"][\\"y\\"] end_x, end_y = ship[\\"end\\"][\\"x\\"], ship[\\"end\\"][\\"y\\"] # Check if the point lies on a vertical ship if start_x == end_x == point[\\"x\\"] and start_y <= point[\\"y\\"] <= end_y or start_x == end_x == point[\\"x\\"] and end_y <= point[\\"y\\"] <= start_y: return True # Check if the point lies on a horizontal ship if start_y == end_y == point[\\"y\\"] and start_x <= point[\\"x\\"] <= end_x or start_y == end_y == point[\\"y\\"] and end_x <= point[\\"x\\"] <= start_x: return True return False"},{"question":"# Problem Statement You are given a scenario where you need to manage a list of student records efficiently. Each student record includes a student\'s first name, last name, and grade. You need to implement a function to parse the list of student records and perform various operations as specified by additional constraints. # Task **Implement a class `StudentRecords` with the following methods:** 1. `__init__(self, records)`: Initialize the object with a list of student records where each record is a dictionary with keys \'first_name\', \'last_name\', and \'grade\'. 2. `add_record(self, first_name, last_name, grade)`: Add a new student record to the list. 3. `remove_record(self, first_name, last_name)`: Remove a student record from the list by matching the first and last name. 4. `get_grades(self, first_name, last_name)`: Retrieve the grade of the student by their first and last name. 5. `average_grade(self)`: Calculate the average grade of all students in the list. # Specifications: - Raise a `ValueError` if attempting to add a record with a non-integer grade or if the grade is outside the 0-100 range. - Raise a `ValueError` if attempting to remove or get a grade for a student not present in the records. - Each method should handle edge cases such as empty records list and ensure the list remains consistent (e.g., no duplicate records). # Input Format: - A list of student records where each record is a dictionary with \'first_name\', \'last_name\', and \'grade\' keys. # Output Format: - The `get_grades` method should return an integer. - The `average_grade` method should return a float rounded to two decimal places. # Examples: ```python records = [ {\\"first_name\\": \\"John\\", \\"last_name\\": \\"Doe\\", \\"grade\\": 85}, {\\"first_name\\": \\"Jane\\", \\"last_name\\": \\"Smith\\", \\"grade\\": 92} ] sr = StudentRecords(records) sr.add_record(\\"Alice\\", \\"Johnson\\", 78) >>> sr.get_grades(\\"Alice\\", \\"Johnson\\") 78 sr.remove_record(\\"John\\", \\"Doe\\") try: sr.get_grades(\\"John\\", \\"Doe\\") except ValueError as e: print(e) >>> \'Student John Doe not found\' >>> sr.average_grade() 85.00 ``` # Constraints: - The grades should be integer values between 0 and 100. - The first name and last name should be strings.","solution":"class StudentRecords: def __init__(self, records): self.records = records def add_record(self, first_name, last_name, grade): if not isinstance(grade, int) or not (0 <= grade <= 100): raise ValueError(\\"Grade must be an integer between 0 and 100.\\") for record in self.records: if record[\\"first_name\\"] == first_name and record[\\"last_name\\"] == last_name: raise ValueError(\\"Duplicate student record.\\") self.records.append({\\"first_name\\": first_name, \\"last_name\\": last_name, \\"grade\\": grade}) def remove_record(self, first_name, last_name): for record in self.records: if record[\\"first_name\\"] == first_name and record[\\"last_name\\"] == last_name: self.records.remove(record) return raise ValueError(f\\"Student {first_name} {last_name} not found.\\") def get_grades(self, first_name, last_name): for record in self.records: if record[\\"first_name\\"] == first_name and record[\\"last_name\\"] == last_name: return record[\\"grade\\"] raise ValueError(f\\"Student {first_name} {last_name} not found.\\") def average_grade(self): if not self.records: return 0.00 total_grade = sum(record[\\"grade\\"] for record in self.records) return round(total_grade / len(self.records), 2)"},{"question":"**Graph Path Finder** You need to implement a function `has_path` that determines if there is a path between two nodes in an undirected graph. The graph is represented as an adjacency list where the keys are the node labels and the values are lists of neighboring nodes. # Function Signature ```python def has_path(graph: dict[int, list[int]], start: int, end: int) -> bool: ``` # Parameters * `graph` (Dict[int, List[int]]): A dictionary representing an undirected graph. The keys are integers representing node labels, and the values are lists of neighboring nodes (0 <= len(graph) <= 100, 0 <= len(graph[node]) <= 100). * `start` (int): The starting node in the graph (0 <= start <= 100). * `end` (int): The target node in the graph (0 <= end <= 100). # Output * bool: `True` if there exists a path between `start` and `end`, `False` otherwise. # Constraints * The graph is undirected, meaning if node A is a neighbor of node B, then node B is also a neighbor of node A. * All elements of the graph are distinct. # Examples ```python >>> has_path({0: [1, 2], 1: [0, 3], 2: [0, 3], 3: [1, 2]}, 0, 3) True >>> has_path({0: [1, 2], 1: [0], 2: [0], 3: []}, 0, 3) False >>> has_path({}, 1, 2) False ``` # Requirements 1. You must implement the function without using any global variables. 2. You should handle invalid inputs gracefully by returning `False`. 3. Use a breadth-first search or depth-first search approach to search for a path. # Tips 1. Consider edge cases such as an empty graph, the start node being the same as the end node, or nodes with no neighbors. 2. Optimize for performance within the provided constraints. 3. Ensure proper handling of cycles in the graph by keeping track of visited nodes.","solution":"def has_path(graph: dict[int, list[int]], start: int, end: int) -> bool: Determines if there is a path between two nodes in an undirected graph. if start == end: return True visited = set() stack = [start] while stack: node = stack.pop() if node == end: return True if node not in visited: visited.add(node) stack.extend(neigh for neigh in graph.get(node, []) if neigh not in visited) return False"},{"question":"# Coding Assessment Question: Implementing the Positive Subarray Sum Context In array manipulation problems, it\'s often necessary to identify significant subsets of the data that meet specific criteria. This exercise will validate your ability to handle array traversal and conditional summation by asking you to implement a function that calculates the sum of the largest contiguous subarray consisting of positive numbers. Problem Statement Write a function `max_positive_subarray_sum(arr: List[int]) -> int` that returns the sum of the largest contiguous subarray containing only positive numbers in the given list `arr`. Input and Output * The input will be a list of integers `arr`. * The output should be an integer which is the sum of the largest subarray with all positive elements. Constraints * The length of the list `arr` will be between 1 and 10^5. * The elements of the list `arr` will be between -10^6 and 10^6. Edge Cases * Consider how to handle arrays with no positive numbers, arrays where all elements are positive, and arrays with interspersed positive and negative numbers. * Ensure the implementation is efficient with O(n) time complexity. Example ```python def max_positive_subarray_sum(arr: List[int]) -> int: Return the sum of the largest contiguous subarray with all positive elements. :param arr: list of integers :return: sum of the largest positive subarray >>> max_positive_subarray_sum([1, -2, 3, 4, -5, 6, 7]) 13 >>> max_positive_subarray_sum([-1, -2, -3, -4]) 0 >>> max_positive_subarray_sum([5, 4, -1, 7, 8]) 15 >>> max_positive_subarray_sum([-1, 2, 3, -2, 4]) 5 >>> max_positive_subarray_sum([1, 2, 3, 4, 5]) 15 pass ``` Implement the function and ensure it passes all the provided tests.","solution":"def max_positive_subarray_sum(arr): Return the sum of the largest contiguous subarray with all positive elements. :param arr: list of integers :return: sum of the largest positive subarray max_sum = 0 current_sum = 0 for num in arr: if num > 0: current_sum += num else: max_sum = max(max_sum, current_sum) current_sum = 0 # Check last segment sum max_sum = max(max_sum, current_sum) return max_sum"},{"question":"Coding Assessment Question Context: You are required to implement a function that calculates the maximum flow in a given flow network using the Ford-Fulkerson algorithm with the Edmonds-Karp implementation. This algorithm finds the maximal flow from a source vertex to a sink vertex in a flow network. Task: Implement the function `max_flow(graph: List[List[int]], source: int, sink: int) -> int` which: 1. Accepts a 2D list of integers representing the adjacency matrix of the flow network. 2. Each element `graph[i][j]` represents the capacity of the edge from node `i` to node `j`. 3. Returns an integer representing the maximum flow from the source vertex to the sink vertex. Input: - `graph`: A 2D list of integers of size `n x n`, where `n` is the number of vertices in the flow network. - `source`: An integer representing the source vertex. - `sink`: An integer representing the sink vertex. Output: - An integer representing the maximum flow from the source vertex to the sink vertex. Constraints: 1. `2 <= n <= 100` (The number of vertices). 2. `0 <= graph[i][j] <= 1000` (Valid capacities of the edges in the graph). 3. `0 <= source < n` 4. `0 <= sink < n` 5. There is always a valid path from the source to the sink. Example: ```python graph = [ [0, 16, 13, 0, 0, 0], [0, 0, 10, 12, 0, 0], [0, 4, 0, 0, 14, 0], [0, 0, 9, 0, 0, 20], [0, 0, 0, 7, 0, 4], [0, 0, 0, 0, 0, 0] ] source = 0 sink = 5 assert max_flow(graph, source, sink) == 23 ``` Note: Implement the function based on the Edmonds-Karp algorithm which uses Breadth-First Search (BFS) to find the augmenting paths efficiently. You may use the following function skeleton: ```python def max_flow(graph: List[List[int]], source: int, sink: int) -> int: pass ```","solution":"from typing import List from collections import deque def bfs(rGraph: List[List[int]], s: int, t: int, parent: List[int]) -> bool: Returns true if there is a path from source \'s\' to sink \'t\' in residual graph. Also fills parent[] to store the path. visited = [False] * len(rGraph) queue = deque() queue.append(s) visited[s] = True while queue: u = queue.popleft() # Checking all adjacent vertices of u for v, capacity in enumerate(rGraph[u]): if visited[v] is False and capacity > 0: queue.append(v) visited[v] = True parent[v] = u # If we reached sink in BFS starting from source, return true if v == t: return True # We didn\'t reach sink in BFS starting from source, return false return False def max_flow(graph: List[List[int]], source: int, sink: int) -> int: Returns the maximum flow from source to sink in the given graph. n = len(graph) rGraph = [row[:] for row in graph] # Residual graph where rGraph[i][j] indicates residual capacity of edge from i to j parent = [-1] * n # To store the path max_flow = 0 # Initialize the maximum flow to zero # Augment the flow while there is a path from source to sink while bfs(rGraph, source, sink, parent): # Find the maximum flow through the path found by BFS path_flow = float(\'Inf\') s = sink while s != source: path_flow = min(path_flow, rGraph[parent[s]][s]) s = parent[s] # update residual capacities of the edges and reverse edges along the path v = sink while v != source: u = parent[v] rGraph[u][v] -= path_flow rGraph[v][u] += path_flow v = parent[v] max_flow += path_flow return max_flow"},{"question":"# Coding Assessment Question Problem Statement Write a function `generate_fibonacci(n: int) -> List[int]` that generates a list of the first `n` numbers in the Fibonacci sequence. The Fibonacci sequence is defined as follows: - The first two numbers are 0 and 1. - Each subsequent number is the sum of the previous two. Requirements 1. The function should use an iterative approach to generate the Fibonacci sequence. 2. The function should handle invalid inputs gracefully and return an empty list for the following cases: * Non-integer values. * Negative integers. * None. * Strings or any data types other than numbers. Input * An integer `n` (potentially negative). Output * Return a list of the first `n` Fibonacci numbers. Constraints * Time Complexity: O(n) * Space Complexity: O(n) Example ```python >>> generate_fibonacci(5) [0, 1, 1, 2, 3] >>> generate_fibonacci(10) [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] >>> generate_fibonacci(-1) [] >>> generate_fibonacci(0) [] >>> generate_fibonacci(1.5) [] >>> generate_fibonacci(None) [] >>> generate_fibonacci(\\"hello\\") [] ``` Additional Notes * Use an iterative strategy rather than a recursive one to avoid potential stack overflow issues with large `n`. * Handle edge cases for inputs like non-integer values, negative numbers, and other invalid types appropriately.","solution":"def generate_fibonacci(n): Generates the first n Fibonacci numbers. :param n: The number of Fibonacci numbers to generate. Should be a non-negative integer. :return: A list of the first n Fibonacci numbers. if not isinstance(n, int) or n < 0: return [] if n == 0: return [] fib_sequence = [0] if n == 1: return fib_sequence fib_sequence.append(1) for i in range(2, n): next_fib = fib_sequence[-1] + fib_sequence[-2] fib_sequence.append(next_fib) return fib_sequence"},{"question":"# Fibonacci Sequence Checker **Scenario:** You have been tasked with creating a function that checks whether a given number is part of the Fibonacci sequence. The Fibonacci sequence is a series of numbers where each number is the sum of the two preceding ones, usually starting with 0 and 1. The task is to determine if a given number is within this sequence. **Function Specification:** ```python def is_fibonacci_number(n: int) -> bool: Checks whether a given number is part of the Fibonacci sequence. Parameters: n (int): The number to be checked. Returns: bool: True if the number is a Fibonacci number, False otherwise. Raises: TypeError: If the input is not an integer. Example: >>> is_fibonacci_number(8) True >>> is_fibonacci_number(10) False >>> is_fibonacci_number(1) True >>> is_fibonacci_number(\'-3\') Traceback (most recent call last): ... TypeError: Input must be an integer def is_perfect_square(x: int) -> bool: Checks whether a number is a perfect square. Parameters: x (int): The number to be checked. Returns: bool: True if the number is a perfect square, False otherwise. s = int(x**0.5) return s*s == x if not isinstance(n, int): raise TypeError(\\"Input must be an integer\\") return is_perfect_square(5*n*n + 4) or is_perfect_square(5*n*n - 4) ``` **Requirements:** 1. The function should accept one parameter `n` which is expected to be an integer. 2. Raise a `TypeError` if the input is not an integer. 3. Use the fact that a number `n` is Fibonacci if and only if one (or both) of `(5*n*n + 4)` or `(5*n*n - 4)` is a perfect square. 4. Implement a helper function `is_perfect_square` that determines if a number is a perfect square. **Constraints:** - The input number will not exceed 10^18 in magnitude. # Examples: ```python assert is_fibonacci_number(8) == True assert is_fibonacci_number(10) == False assert is_fibonacci_number(1) == True assert is_fibonacci_number(144) == True assert is_fibonacci_number(233) == True assert is_fibonacci_number(987) == True assert is_fibonacci_number(1000) == False assert is_fibonacci_number(-8) == False # Fibonacci sequence does not include negative numbers assert is_fibonacci_number(\\"8\\") == False # Raises TypeError ```","solution":"def is_fibonacci_number(n: int) -> bool: Checks whether a given number is part of the Fibonacci sequence. Parameters: n (int): The number to be checked. Returns: bool: True if the number is a Fibonacci number, False otherwise. Raises: TypeError: If the input is not an integer. def is_perfect_square(x: int) -> bool: Checks whether a number is a perfect square. Parameters: x (int): The number to be checked. Returns: bool: True if the number is a perfect square, False otherwise. s = int(x**0.5) return s * s == x if not isinstance(n, int): raise TypeError(\\"Input must be an integer\\") if n < 0: return False return is_perfect_square(5 * n * n + 4) or is_perfect_square(5 * n * n - 4)"},{"question":"Task Question Creation for Coding Assessment # Sample Questions 1. # Problem Statement In the context of numerical simulations of laser beams within an elliptical mirror system (white cell), your task is to determine the number of times the laser beam hits the interior surface of the white cell before exiting. The white cell\'s boundary is defined by the ellipse equation: [ 4x^2 + y^2 = 100 ] # Task Implement a function `solution(first_x_coord: float, first_y_coord: float) -> int` to simulate the laser beam\'s trajectory and compute the number of reflections before the beam exits through a specific opening. * The laser beam starts just outside the ellipse at ((0.0, 10.1)). * The beam first impacts the mirror at a point ((first_x_coord, first_y_coord)). Input Format * `first_x_coord` - The x-coordinate of the first impact point of the beam on the elliptical surface. * `first_y_coord` - The y-coordinate of the first impact point of the beam on the elliptical surface. Output Format * The function should return an integer value representing the total number of times the laser beam hits the internal surface before it exits. # Constraints - Ensure that the calculations respect the geometric properties of the ellipse. - Handle floating-point computations with adequate precision. - Assume the input coordinates of the first impact will always lie within the bounds of the ellipse. # Example ```python def solution(first_x_coord: float, first_y_coord: float) -> int: # Your code here # Example Usage: print(solution(1.4, -9.6)) # Expected output: [number of reflections] ``` *Note*: Floating-point arithmetic and accurate geometric transformations are crucial in your implementation. Consider edge cases such as grazing angles close to the horizontal opening. --- # [New Question]: # Problem Statement In the study of the gravitational field in physics, consider a simulation of the trajectories of an object under the influence of multiple mass points fixed in space. Your task is to determine the successful terminus of an object within a bounded region after it releases from a certain initial position and velocity. The boundaries of the region are defined by the rectangle: [ 0 le x le 100 ] [ 0 le y le 200 ] # Task Implement a function `simulate_trajectory(initial_x: float, initial_y: float, initial_vx: float, initial_vy: float, masses: List[Tuple[float, float, float]]) -> Tuple[float, float]` to simulate the object\'s motion and compute its final position within the bounded region after one unit of time. * The object starts at the point ((initial_x, initial_y)). * The initial velocity of the object is given by ((initial_vx, initial_vy)). Input Format * `initial_x` - The initial x-coordinate of the object. * `initial_y` - The initial y-coordinate of the object. * `initial_vx` - The initial velocity component along the x-axis. * `initial_vy` - The initial velocity component along the y-axis. * `masses` - A list of tuples, each containing the x-coordinate, y-coordinate, and mass of the fixed mass points. Output Format * The function should return a tuple representing the final x and y coordinates of the object after one unit of time. # Constraints - Ensure calculations respect the gravitational forces exerted by all given mass points. - Handle floating-point computations with adequate precision. - Assume all coordinates and velocities are within the given bounds and constraints. # Example ```python def simulate_trajectory(initial_x: float, initial_y: float, initial_vx: float, initial_vy: float, masses: List[Tuple[float, float, float]]) -> Tuple[float, float]: # Your code here # Example Usage: print(simulate_trajectory(50, 100, 0, 0, [(25, 50, 100), (75, 150, 200)])) # Expected output: (final_x, final_y) ``` *Note*: Consider gravitational forces inversely proportional to the square of the distance between objects. Use numerical methods to integrate the equations of motion and compute the new trajectory at each small time step.","solution":"from typing import List, Tuple import math G = 6.67430e-11 # gravitational constant def simulate_trajectory(initial_x: float, initial_y: float, initial_vx: float, initial_vy: float, masses: List[Tuple[float, float, float]]) -> Tuple[float, float]: Simulates the trajectory of an object under the influence of multiple mass points :param initial_x: Initial x-coordinate of the object :param initial_y: Initial y-coordinate of the object :param initial_vx: Initial velocity along the x-axis :param initial_vy: Initial velocity along the y-axis :param masses: List of mass points (x, y, mass) :return: Final position (x, y) of the object after one unit of time time_step = 1e-2 # small time step total_time = 1.0 # total simulation time num_steps = int(total_time / time_step) x, y = initial_x, initial_y vx, vy = initial_vx, initial_vy for _ in range(num_steps): # Compute net forces due to all masses fx, fy = 0.0, 0.0 for mx, my, m in masses: dx, dy = mx - x, my - y distance_squared = dx * dx + dy * dy if distance_squared == 0: continue # Avoid division by zero distance = math.sqrt(distance_squared) force = G * m / distance_squared fx += force * (dx / distance) fy += force * (dy / distance) # Update velocities vx += fx * time_step vy += fy * time_step # Update positions x += vx * time_step y += vy * time_step # Ensure the object stays within the boundary if not (0 <= x <= 100) or not (0 <= y <= 200): x = min(max(x, 0), 100) y = min(max(y, 0), 200) break return x, y"},{"question":"# Scenario You have been hired to develop a project version tracking tool. This tool will read a list of project version strings and evaluate their order based on semantic versioning. Semantic versioning follows the pattern `MAJOR.MINOR.PATCH`, where each segment is a non-negative integer. A major update includes significant changes, a minor update includes backward-compatible changes, and a patch includes backward-compatible bug fixes. # Problem Statement Write a function `sort_versions(versions: List[str]) -> List[str]` that takes a list of version strings and returns a list sorted in ascending order based on semantic versioning rules. Input * `versions` (List of strings): A list of version strings. Each string is guaranteed to match the format `MAJOR.MINOR.PATCH`. Output * `sorted_versions` (List of strings): A list of version strings sorted according to semantic versioning. Function Signature ```python def sort_versions(versions: List[str]) -> List[str]: pass ``` Constraints * The input list will contain at least one version string. * Each version string will follow the pattern `MAJOR.MINOR.PATCH`, where `MAJOR`, `MINOR`, and `PATCH` are non-negative integers with no leading zeros. Example ```python versions = [ \\"1.0.0\\", \\"2.0.0\\", \\"1.2.3\\", \\"1.2.2\\", \\"1.1.5\\", \\"2.2.1\\", \\"0.1.9\\", \\"1.1.10\\" ] expected_output = [ \\"0.1.9\\", \\"1.0.0\\", \\"1.1.5\\", \\"1.1.10\\", \\"1.2.2\\", \\"1.2.3\\", \\"2.0.0\\", \\"2.2.1\\" ] result = sort_versions(versions) assert result == expected_output ``` Note Ensure your solution efficiently handles edge cases and large inputs. Document any assumptions made.","solution":"from typing import List def sort_versions(versions: List[str]) -> List[str]: Sort a list of version strings based on semantic versioning rules. Semantic versioning follows the pattern MAJOR.MINOR.PATCH where each part is a non-negative integer. Args: versions (List of strings): A list of version strings. Returns: List of strings: A list of version strings sorted in ascending order of version. return sorted(versions, key=lambda version: [int(part) for part in version.split(\'.\')])"},{"question":"# Problem Statement: You are tasked to implement a function `find_missing_number(arr: List[int]) -> int` that takes a list of unique integers sorted in ascending order and ranging from 0 to 99, where exactly one number is missing, and returns the missing number. # Input: * A list `arr` of integers where `0 <= arr[i] <= 99` (0 ≤ i < len(arr)). * The length of `arr` will be 99, representing numbers from 0 to 99 with exactly one missing. # Output: * An integer representing the missing number. # Constraints: * The function should efficiently handle the missing number computation. * Optimize for time complexity where possible. # Examples: ```python find_missing_number([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99]) -> 36 find_missing_number([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99]) -> 0 find_missing_number([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99]) -> 87 ``` # Directions: 1. Implement the function `find_missing_number(arr: List[int]) -> int` that follows the provided function signature. 2. Make sure the solution is optimized for any edge case, including the missing number being the first or the last in the range. 3. Ensure the implementation is efficient given the constraints.","solution":"from typing import List def find_missing_number(arr: List[int]) -> int: Finds the missing number in a list of integers ranging from 0 to 99. :param arr: List[int] - A list of integers from 0 to 99 with exactly one missing. :return: int - The missing integer in the range 0 to 99. # Calculate the expected sum of numbers from 0 to 99 expected_sum = sum(range(100)) # Calculate the actual sum of the numbers in the list actual_sum = sum(arr) # The difference between the expected sum and the actual sum is the missing number return expected_sum - actual_sum"},{"question":"# Prime Factorization Task **Objective:** Design a function that computes the prime factorization of a given integer. The function should return the prime factors along with their corresponding counts in the factorization. **Function Signature:** ```python def prime_factorization(n: int) -> List[Tuple[int, int]]: ``` The function should return a list of tuples, where each tuple consists of a prime factor and its multiplicity. **Input:** - `n`: An integer `n` where (2 leq n leq 10^6). **Output:** - A list of pairs `(prime, count)` where each `prime` is a prime factor of `n` and `count` is the number of times this prime factor divides `n`. **Example:** ```python print(prime_factorization(56)) # Output: [(2, 3), (7, 1)] ``` **Constraints:** - The input integer will be in the range (2) to (10^6). **Performance Requirements:** - The function should efficiently compute the prime factors even for the upper limit of the input range. **Notes:** - Focus on an efficient algorithm to handle large numbers, possibly employing techniques such as trial division up to the square root of `n` or generating primes using the Sieve of Eratosthenes. - Ensure that your function handles various edge cases, including very large prime numbers and numbers with multiple small prime factors. **Additional Guidance:** - Document any assumptions made and ensure that your solution is both time and space efficient. - Test your function thoroughly with different edge cases to ensure correctness.","solution":"from typing import List, Tuple def prime_factorization(n: int) -> List[Tuple[int, int]]: Computes the prime factorization of the given integer `n`. Returns a list of tuples where each tuple contains a prime factor and its count. factors = [] count = 0 # Step 1: Count the number of 2s that divide n while n % 2 == 0: n //= 2 count += 1 if count > 0: factors.append((2, count)) # Step 2: Investigate odd factors from 3 onwards factor = 3 while factor * factor <= n: count = 0 while n % factor == 0: n //= factor count += 1 if count > 0: factors.append((factor, count)) factor += 2 # If n becomes a prime number > 2 if n > 2: factors.append((n, 1)) return factors"},{"question":"# Question: Implement Enhanced Matrix Computations with Automatic Differentiation Context You are provided with a class `Matrix` that represents a 2D matrix with basic operations such as addition, subtraction, and matrix multiplication. Your task is to extend the functionality to support element-wise operations and optimize the differentiation computations for these operations. Task 1. **Implement New Element-Wise Operations**: Extend the `Matrix` class to support element-wise `multiplication`, `division`, and the `Hadamard` product. 2. **Graph Optimization**: Improve the performance of the computation graph when differentiating matrix operations, especially focusing on reducing redundant computations and memory usage. 3. **Numerical Stability**: Ensure that element-wise division handles edge cases involving zeros and near-zero denominators gracefully. Requirements 1. **New Element-Wise Operations**: * Element-wise `multiplication` and `division`. * Hadamard product (element-wise multiplication). * Implement gradient computation for each of these operations. 2. **Optimization**: * Apply techniques to optimize memory usage during matrix operations. * Optimize the differentiation computation graph for efficiency. 3. **Numerical Stability**: * Ensure that element-wise division handles edge cases appropriately. * Implement safeguards for operations that could lead to numerical instability. Input/Output Here is how the new operations should be used: ```python >>> m1 = Matrix([[1.0, 2.0], [3.0, 4.0]]) >>> m2 = Matrix([[5.0, 6.0], [7.0, 8.0]]) >>> with GradientTracker() as tracker: ... m3 = m1 * m2 # Element-wise multiplication >>> tracker.gradient(m3, m1) Matrix([ [5.0, 6.0], [7.0, 8.0] ]) >>> with GradientTracker() as tracker: ... m4 = m1 / m2 # Element-wise division >>> tracker.gradient(m4, m1) Matrix([ [0.2, 0.16666667], [0.14285714, 0.125] ]) >>> with GradientTracker() as tracker: ... m5 = m1.hadamard(m2) # Hadamard product >>> tracker.gradient(m5, m1) Matrix([ [5.0, 6.0], [7.0, 8.0] ]) ``` Constraints * Matrices are square and of the same dimension for operations involving two matrices. * Input values are valid floating-point numbers. * Carefully manage memory to avoid excessive usage during large matrix operations.","solution":"import numpy as np class Matrix: def __init__(self, data): self.data = np.array(data, dtype=np.float64) def __mul__(self, other): if isinstance(other, Matrix): return Matrix(self.data * other.data) # Element-wise Multiplication else: raise ValueError(\\"Unsupported multiplication operation\\") def __truediv__(self, other): if isinstance(other, Matrix): # Adding small constant to the denominator for numerical stability return Matrix(self.data / (other.data + 1e-10)) # Element-wise Division else: raise ValueError(\\"Unsupported division operation\\") def hadamard(self, other): return self * other # Reuse element-wise multiplication for Hadamard product class GradientTracker: def __enter__(self): self.gradients = {} return self def __exit__(self, exc_type, exc_value, traceback): pass def gradient(self, result, variable): if result.data.shape != variable.data.shape: raise ValueError(\\"Shape mismatch in gradient computation\\") return Matrix(np.ones_like(variable.data)) # Example usage m1 = Matrix([[1.0, 2.0], [3.0, 4.0]]) m2 = Matrix([[5.0, 6.0], [7.0, 8.0]]) with GradientTracker() as tracker: m3 = m1 * m2 # Element-wise multiplication print(tracker.gradient(m3, m1).data) with GradientTracker() as tracker: m4 = m1 / m2 # Element-wise division print(tracker.gradient(m4, m1).data) with GradientTracker() as tracker: m5 = m1.hadamard(m2) # Hadamard product print(tracker.gradient(m5, m1).data)"},{"question":"# Question: Efficient Interval Overlap Checker In this problem, you are tasked with implementing an algorithm to check whether any two intervals in a list overlap. Each interval is represented as a tuple of two integers, where the first integer is the start time, and the second integer is the end time of the interval. An overlap is defined as any case where one interval shares any point with another interval, inclusive of start and end points. Function Signature ```python def has_overlapping_intervals(intervals: list[tuple[int, int]]) -> bool: Determines if there are any overlapping intervals in the provided list. :param intervals: List of tuples, where each tuple contains two integers representing the start and end of an interval. :return: Boolean value indicating whether any pair of intervals overlap. pass ``` Input * `intervals` (list of tuples): A list of tuples, where each tuple contains two integers representing the start and end times of an interval. The list is not necessarily sorted and can contain any number of intervals, including zero. Output * Returns `True` if any pair of intervals overlap, and `False` otherwise. Constraints * 0 <= len(intervals) <= 10^5 * -10^6 <= start_i, end_i <= 10^6 for each interval (start_i, end_i) Performance Requirements - The solution should run in O(n log n) time complexity where n is the number of intervals. Example ```python # Check for overlapping intervals intervals1 = [(1, 5), (6, 10), (12, 15), (5, 6)] print(has_overlapping_intervals(intervals1)) # Output should be: False intervals2 = [(1, 5), (4, 9), (15, 20)] print(has_overlapping_intervals(intervals2)) # Output should be: True intervals3 = [(1, 3), (2, 6), (8, 10), (15, 18)] print(has_overlapping_intervals(intervals3)) # Output should be: True ``` Implement the `has_overlapping_intervals` function based on the above specifications, efficiently checking for any overlaps among the intervals provided.","solution":"def has_overlapping_intervals(intervals): Determines if there are any overlapping intervals in the provided list. :param intervals: List of tuples, where each tuple contains two integers representing the start and end of an interval. :return: Boolean value indicating whether any pair of intervals overlap. # Sort intervals by their start time intervals.sort() # Iterate through the sorted intervals and check for overlaps for i in range(1, len(intervals)): prev_start, prev_end = intervals[i - 1] curr_start, curr_end = intervals[i] # Check if the current interval overlaps with the previous one if curr_start <= prev_end: return True return False"},{"question":"# Context Strings can contain various characteristics, such as letters, numbers, and symbols. One common task in data processing is extracting and manipulating specific segments of a string based on certain criteria. In this task, your goal is to extract and return the longest numeric substring from a given input string. # Task Implement a function `longest_numeric_substring` that finds and returns the longest contiguous numeric substring in a given string. If there are multiple numeric substrings of the same maximum length, return the first one encountered in the string. # Function Signature ```python def longest_numeric_substring(input_string: str) -> str: pass ``` # Input * `input_string` (str): A string containing alphanumeric characters and possibly other symbols. # Output * A string representing the longest contiguous numeric substring in the input string. # Constraints * The input string can be up to 10^6 characters long. * Numeric substrings consist only of consecutive digits (\'0\'-\'9\'). # Examples ```python assert longest_numeric_substring(\\"abc1234xyz56789\\") == \\"56789\\" assert longest_numeric_substring(\\"abc123xyz45678\\") == \\"45678\\" assert longest_numeric_substring(\\"98765abc1234\\") == \\"98765\\" assert longest_numeric_substring(\\"abc12xyz34\\") == \\"12\\" assert longest_numeric_substring(\\"a1b2c3d000045678e\\") == \\"000045678\\" ```","solution":"def longest_numeric_substring(input_string: str) -> str: Finds and returns the longest contiguous numeric substring in the input string. If there are multiple substrings of the same length, returns the first one encountered. Args: input_string (str): The input string to process. Returns: str: The longest contiguous numeric substring. max_length = 0 max_substring = \\"\\" current_length = 0 current_substring = \\"\\" for char in input_string: if char.isdigit(): current_length += 1 current_substring += char if current_length > max_length: max_length = current_length max_substring = current_substring else: current_length = 0 current_substring = \\"\\" return max_substring"},{"question":"# Problem Description You are developing a feature for a ride-sharing application that predicts the fare for a given ride based on the distance of the trip, time of day, and type of car selected. Your task is to create a function that calculates the fare using a predefined formula. # Task Write a function `calculate_ride_fare` which: 1. Takes the distance of the trip in kilometers, the hour of the day, and the type of car as inputs. 2. Calculates the fare according to the given formula. 3. Returns the calculated fare as a floating-point number. # Function Signature ```python def calculate_ride_fare(distance: float, hour: int, car_type: str) -> float: # Your implementation here ``` # Input - `distance`: A floating-point number representing the distance of the trip in kilometers. - `hour`: An integer representing the hour of the day (0-23). - `car_type`: A string that can be either \\"economy\\", \\"standard\\", or \\"luxury\\". # Output - Returns a floating-point number representing the calculated fare. # Fare Calculation Formula Use the following formula to calculate the fare: [ text{base_fare} = 5 text{ (for economy)}, 10 text{ (for standard)}, 20 text{ (for luxury)} ] [ text{cost_per_km} = 1 text{ (for economy)}, 2 text{ (for standard)}, 3 text{ (for luxury)} ] [ text{time_of_day_multiplier} = 1.5 text{ (if 0 ≤ hour < 6 or 18 ≤ hour < 24)}, 1.0 text{ (otherwise)} ] [ text{fare} = (text{base_fare} + text{distance} times text{cost_per_km}) times text{time_of_day_multiplier} ] # Example Usage ```python # Calculate fare for a 10 km trip at 22:00 using a standard car fare = calculate_ride_fare(10, 22, \\"standard\\") print(fare) # Expected output: 45.0 # Calculate fare for a 5 km trip at 14:00 using an economy car fare = calculate_ride_fare(5, 14, \\"economy\\") print(fare) # Expected output: 10.0 ``` # Constraints 1. `distance` will be a floating-point number greater than 0 and less than 1000. 2. `hour` will be an integer between 0 and 23. 3. `car_type` will be one of the following strings: \\"economy\\", \\"standard\\", or \\"luxury\\". # Performance Requirements - Your implementation should be efficient enough to handle multiple fare calculations in a short period, as this function will be called frequently by the application. # Notes - Ensure the function handles edge cases, such as rides during the exact start or end of the high fare periods. - Make sure to test the function with different combinations of inputs to verify its accuracy.","solution":"def calculate_ride_fare(distance: float, hour: int, car_type: str) -> float: Calculates the ride fare based on distance, hour of the day, and car type. :param distance: Distance of the trip in kilometers. :param hour: Hour of the day (0-23). :param car_type: Type of the car - \\"economy\\", \\"standard\\", or \\"luxury\\". :return: The calculated fare as a floating-point number. base_fare = { \\"economy\\": 5, \\"standard\\": 10, \\"luxury\\": 20 } cost_per_km = { \\"economy\\": 1, \\"standard\\": 2, \\"luxury\\": 3 } time_of_day_multiplier = 1.5 if (0 <= hour < 6 or 18 <= hour < 24) else 1.0 fare = (base_fare[car_type] + distance * cost_per_km[car_type]) * time_of_day_multiplier return fare"},{"question":"# Check for Sorted List after Rotation **Context**: You are tasked with checking lists for a common software engineering function. Often lists are sorted in ascending order before being rotated. Your task is to verify if a list provided to you is originally sorted in ascending order and then rotated. For instance, if the list `[3, 4, 5, 1, 2]` is given, it is a rotated version of the sorted list `[1, 2, 3, 4, 5]`. # Task Implement a function `check_rotated_sorted` to determine if the given list is originally sorted in increasing order before being rotated. # Function Signature ```python def check_rotated_sorted(nums: List[int]) -> bool: # Your implementation here ``` # Input * `nums` (List[int]): A list of integers. # Output * Returns a boolean value, `True` if the list is originally sorted in increasing order before being rotated, otherwise `False`. # Constraints * 1 <= len(nums) <= 10^5 * -10^9 <= nums[i] <= 10^9 # Example ```python # Example 1 nums = [3, 4, 5, 1, 2] assert check_rotated_sorted(nums) == True # Example 2 nums = [1, 2, 3, 4, 5] assert check_rotated_sorted(nums) == True # Example 3 nums = [2, 1, 3, 4] assert check_rotated_sorted(nums) == False ``` # Notes * Ensure your solution is efficient with respect to time and space complexity. * Handle edge cases including single-element lists and cases where no rotations are present. * Consider scenarios where the rotation point is not uniquely defined due to repeated elements if appropriate.","solution":"from typing import List def check_rotated_sorted(nums: List[int]) -> bool: n = len(nums) if n == 1: return True rotation_point = -1 for i in range(1, n): if nums[i - 1] > nums[i]: if rotation_point == -1: rotation_point = i else: return False if rotation_point == -1: return True return nums[rotation_point:] + nums[:rotation_point] == sorted(nums)"},{"question":"# Problem Statement You are required to implement a **Queue** data structure using two stacks (standard Python lists). Additionally, you must ensure that the `__len__` function operates in O(1) time complexity. # Requirements 1. **Implementation Details**: - The queue should be implemented as a class `Queue` using two stacks. - Use two lists, for example, `in_stack` and `out_stack`, to manage the internal state of the queue. 2. **Functional Requirements**: Implement the following methods: - `enqueue(self, data: T) -> None`: Adds an element to the end of the queue. - `dequeue(self) -> T | None`: Removes and returns the element at the front of the queue. - `front(self) -> T | None`: Returns the element at the front of the queue without removing it. - `is_empty(self) -> bool`: Returns `True` if the queue is empty, `False` otherwise. - `__len__(self) -> int`: Returns the number of elements in the queue in O(1) time. # Input/Output Formats - The `enqueue` method should accept a data element of any type `T`. - The `dequeue`, `front` methods should return an element of type `T` or `None` if the queue is empty. - The `is_empty()` method should return a boolean value. - The `__len__` method should return an integer representing the number of elements in the queue. # Constraints - Your implementation should ensure that all operations are efficient. - Ensure that the `__len__` operation runs in O(1) time complexity. # Example Usage ```python queue = Queue() print(queue.is_empty()) # Output: True queue.enqueue(5) queue.enqueue(10) queue.enqueue(15) print(len(queue)) # Output: 3 print(queue.front()) # Output: 5 print(queue.dequeue()) # Output: 5 print(len(queue)) # Output: 2 print(queue.is_empty()) # Output: False ``` # Additional Notes - You may assume any necessary imports and class definitions are provided. - The `__init__` method should initialize the queue as empty. - Consider edge cases such as operations on an empty queue. - Optimize the `__len__` function to be O(1) using an auxiliary variable.","solution":"class Queue: def __init__(self): # Using two stacks (lists) for the queue operations self.in_stack = [] self.out_stack = [] self.size = 0 def enqueue(self, data): Adds an element to the end of the queue. self.in_stack.append(data) self.size += 1 def dequeue(self): Removes and returns the element at the front of the queue. Returns None if the queue is empty. if not self.out_stack: while self.in_stack: self.out_stack.append(self.in_stack.pop()) if self.out_stack: self.size -= 1 return self.out_stack.pop() return None def front(self): Returns the element at the front of the queue without removing it. Returns None if the queue is empty. if not self.out_stack: while self.in_stack: self.out_stack.append(self.in_stack.pop()) if self.out_stack: return self.out_stack[-1] return None def is_empty(self): Returns True if the queue is empty, False otherwise. return self.size == 0 def __len__(self): Returns the number of elements in the queue in O(1) time. return self.size"},{"question":"# Problem Context Sorting and searching are two foundational algorithms in computer science. One common task is to search for specific values in a sorted array. Binary search algorithm is a classic method to accomplish this efficiently. In this task, you will implement a function that utilizes binary search technique. # Problem Statement You need to write a function `binary_search(arr: List[int], target: int) -> int` that takes a sorted list of integers `arr` and an integer `target`. The function should return the index of `target` in `arr` if it is present, otherwise, it should return -1. # Function Signature ```python def binary_search(arr: List[int], target: int) -> int: # your code here ``` # Input - A list of integers `arr` which is sorted in ascending order. - A single integer `target` which you need to search for in `arr`. # Output - An integer representing the index of `target` in `arr` if it is present, otherwise -1. # Constraints - The list `arr` should have at least one element and at most 10^4 elements. - The values in `arr` and `target` can be any integer within the range of -10^9 to 10^9. # Examples ```python assert binary_search([1, 2, 3, 4, 5], 3) == 2 assert binary_search([1, 2, 3, 4, 5], 6) == -1 assert binary_search([-10, -5, 0, 3, 7, 10], 0) == 2 assert binary_search([4, 8, 15, 16, 23, 42], 42) == 5 assert binary_search([1], 1) == 0 assert binary_search([1], -1) == -1 ``` # Edge Cases to Consider 1. When the `arr` contains only one element, the function should handle both cases: when the target is present and when it is not. 2. When the `target` is not present in `arr`. 3. Be sure to return -1 if `target` is not present in the list.","solution":"from typing import List def binary_search(arr: List[int], target: int) -> int: Perform binary search to find the index of the target element in a sorted list. Parameters: arr (List[int]): A list of sorted integers. target (int): The integer to search for in the list. Returns: int: The index of the target if found in the list; otherwise, -1. left, right = 0, len(arr) - 1 while left <= right: mid = (left + right) // 2 if arr[mid] == target: return mid elif arr[mid] < target: left = mid + 1 else: right = mid - 1 return -1"},{"question":"# Question Create a function `find_missing_ranges(nums: List[int], lower: int, upper: int) -> List[str]` that finds the missing ranges in the interval `[lower, upper]` given an array of sorted unique integers `nums`. Input - `nums` (List[int]): A sorted list of unique integers representing the known values. - `lower` (int): The lower bound of the interval. - `upper` (int): The upper bound of the interval. Output - Returns a list of strings, where each string represents a missing range in the format of `\\"{start}->{end}\\"` or `\\"{start}\\"` if there\'s only one number missing in that range. Constraints - -10^9 ≤ lower ≤ upper ≤ 10^9 - 0 ≤ len(nums) ≤ 100 # Example ```python >>> find_missing_ranges([0, 1, 3, 50, 75], 0, 99) [\'2\', \'4->49\', \'51->74\', \'76->99\'] >>> find_missing_ranges([], 1, 1) [\'1\'] >>> find_missing_ranges([], -3, -1) [\'-3->-1\'] >>> find_missing_ranges([1, 3], 1, 3) [\'2\'] ``` Additional Notes - Pay attention to edge cases such as when `nums` is empty or contains all numbers within `[lower, upper]`. - Ensure your solution efficiently handles the given constraints without unnecessary complexity.","solution":"from typing import List def find_missing_ranges(nums: List[int], lower: int, upper: int) -> List[str]: Find the missing ranges in the interval [lower, upper] given a sorted list of unique integers nums. def format_range(low: int, high: int) -> str: if low == high: return f\\"{low}\\" else: return f\\"{low}->{high}\\" missing_ranges = [] prev = lower - 1 for i in range(len(nums) + 1): if i < len(nums): current = nums[i] else: current = upper + 1 if prev + 1 <= current - 1: missing_ranges.append(format_range(prev + 1, current - 1)) prev = current return missing_ranges"},{"question":"# Coding Challenge: Trie Implementation with wildcard search Context You have been provided with a basic implementation of a Trie (prefix tree), which supports the insertion and search of words. However, there is an additional operation involving wildcard characters that is frequently required in applications, but it has not been implemented yet. Task You need to extend the `Trie` class to support search operations with wildcard characters. The wildcard character `\'.\'` can match any single letter. Specifications **Operation: Search with Wildcard** - **Function Signature**: `def search_with_wildcard(self, word: str) -> bool` - **Input**: `word` - The word to be searched in the Trie, where `.` can match any single letter. - **Output**: Returns `True` if there is any possible word in the Trie that matches the wildcard pattern, `False` otherwise. Additional Requirements - Ensure that the wild card search operation is efficient. - Implement the search functionality within the Trie structure without the use of additional data structures. # Example Usage ```python # Initialize a Trie trie = Trie() # Insert words trie.insert(\\"bad\\") trie.insert(\\"dad\\") trie.insert(\\"mad\\") # Search for exact match print(trie.search(\\"pad\\")) # Should print False # Search with wildcard \'.\' print(trie.search_with_wildcard(\\"b..\\")) # Should print True because \\"bad\\" matches the pattern # Insert more words trie.insert(\\"bat\\") trie.insert(\\"mat\\") # Search with different wildcards print(trie.search_with_wildcard(\\".a.\\")) # Should print True because \\"bad\\", \\"dad\\", and \\"mad\\" all match the pattern print(trie.search_with_wildcard(\\"m.t\\")) # Should print True because \\"mat\\" matches the pattern print(trie.search_with_wildcard(\\"..d\\")) # Should print True because \\"bad\\", \\"dad\\", and \\"mad\\" all match the pattern ``` # Constraints - Do not use any additional data structures beyond what is required for the Trie operations. - Handle cases where the queried word does not match any word in the Trie gracefully. - Make sure the implementation is efficient in terms of both time and space complexity. **Nota Bene**: Modify the `Trie` and `TrieNode` classes as necessary to implement the new functionalities.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str) -> None: node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, word: str) -> bool: node = self.root for char in word: if char not in node.children: return False node = node.children[char] return node.is_end_of_word def search_with_wildcard(self, word: str) -> bool: return self._search_with_wildcard_recursive(word, 0, self.root) def _search_with_wildcard_recursive(self, word, index, node): if index == len(word): return node.is_end_of_word char = word[index] if char == \'.\': for child in node.children.values(): if self._search_with_wildcard_recursive(word, index + 1, child): return True elif char in node.children: return self._search_with_wildcard_recursive(word, index + 1, node.children[char]) return False"},{"question":"# Question: Implement a Real-Time Text Autocomplete System in Python Scenario You are developing a real-time text autocomplete system for a text editor that suggests possible completions based on an input prefix. The autocomplete feature should fetch suggestions from a predefined dictionary of words. As the user types, the system should update suggestions smoothly and efficiently. Task 1. Implement a class `AutocompleteSystem` that maintains a dictionary of words and provides autocomplete suggestions. The class should have the following methods: - `__init__(self, dictionary: List[str])`: Initialize the system with a list of words. - `input(self, prefix: str) -> List[str]`: Given a prefix, return a sorted list of all words in the dictionary that start with the prefix. 2. Write a function `initialize_autocomplete(dictionary: List[str]) -> AutocompleteSystem` that initializes and returns an instance of `AutocompleteSystem` using the provided dictionary. 3. Test the autocomplete system using a set of given input prefixes and verify that the system returns the correct suggestions. Input and Output Formats - **Input**: - A list of words `dictionary` (List[str]) containing the words to be used for autocompletion. - Multiple prefixes `prefixes` (List[str]) for which suggestions need to be generated. - **Output**: - The `initialize_autocomplete` function should return an instance of `AutocompleteSystem`. - Each call to the `input` method with a prefix should return a list of word suggestions. Constraints: - The `dictionary` should contain between 1 and 10,000 words. - Each word in the dictionary should be lowercase, contain only alphabetic characters, and have a length between 1 and 100 characters. - The `prefix` should be lowercase and contain only alphabetic characters with a length between 1 and 100 characters. Performance Requirements: - The autocomplete system should be able to provide suggestions in real-time, aiming for a time complexity better than O(n) for each input query, where n is the size of the dictionary. Implementation Hints: - Consider using data structures like tries (prefix trees) to efficiently store and search the dictionary. - Utilize sorting and searching techniques to optimize the performance of the autocomplete suggestions. Requirements: - Ensure your code includes sufficient error-checking and handles edge cases appropriately. - Add brief documentation and comments explaining your key decisions and logic. ```python class AutocompleteSystem: def __init__(self, dictionary): self.dictionary = dictionary self.dictionary.sort() # Ensure the dictionary is sorted def input(self, prefix): suggestions = [] for word in self.dictionary: if word.startswith(prefix): suggestions.append(word) elif word > prefix: # Optimization to stop early break return suggestions def initialize_autocomplete(dictionary): if not dictionary: raise ValueError(\\"Dictionary should not be empty\\") return AutocompleteSystem(dictionary) # Sample usage: # autocomplete = initialize_autocomplete([\\"apple\\", \\"app\\", \\"apricot\\", \\"banana\\", \\"berry\\"]) # print(autocomplete.input(\\"ap\\")) # Should return [\'apple\', \'apricot\', \'app\'] # print(autocomplete.input(\\"b\\")) # Should return [\'banana\', \'berry\'] ``` Example Initialize the autocomplete system with the dictionary: ```python dictionary = [\\"dog\\", \\"deer\\", \\"deal\\"] autocomplete_system = initialize_autocomplete(dictionary) ``` For the given prefixes, the results should be: ```python assert autocomplete_system.input(\\"de\\") == [\\"deal\\", \\"deer\\"] assert autocomplete_system.input(\\"do\\") == [\\"dog\\"] assert autocomplete_system.input(\\"d\\") == [\\"deal\\", \\"deer\\", \\"dog\\"] ```","solution":"class AutocompleteSystem: def __init__(self, dictionary): Initializes the autocomplete system with a sorted dictionary of words. self.dictionary = sorted(dictionary) def input(self, prefix): Given a prefix, returns a sorted list of all words in the dictionary that start with the prefix. suggestions = [] for word in self.dictionary: if word.startswith(prefix): suggestions.append(word) elif word > prefix: # Optimization to stop early in sorted list break return suggestions def initialize_autocomplete(dictionary): Initializes and returns an instance of AutocompleteSystem using the provided dictionary. if not dictionary: raise ValueError(\\"Dictionary should not be empty\\") return AutocompleteSystem(dictionary)"},{"question":"# Scenario A logistics company is developing a software tool to optimize delivery routes. One of the components of the tool needs to implement and test the Quick Sort algorithm, which is known for its efficiency in practical use cases involving large datasets. The tool will process lists of delivery locations identified by their coordinates. # Task Implement the Quick Sort algorithm and provide solutions both iteratively and recursively. The iterative version should use an explicit stack to simulate the recursive call stack. # Input - A list of tuples, where each tuple consists of x and y coordinates (integers) representing delivery locations. - Constraints: The list can have up to 2000 elements. # Output - A sorted list of tuples in ascending order based on their coordinates, first sorting by x-coordinate and then by y-coordinate if x-coordinates are equal. # Function Signature ```python from typing import List, Tuple def quick_sort_iter(collection: List[Tuple[int, int]]) -> List[Tuple[int, int]]: pass def quick_sort_recur(collection: List[Tuple[int, int]]) -> List[Tuple[int, int]]: pass ``` # Example ```python # Examples # Iterative version print(quick_sort_iter([(3, 2), (1, 4), (1, 2), (2, 5)])) # Output: [(1, 2), (1, 4), (2, 5), (3, 2)] print(quick_sort_iter([])) # Output: [] print(quick_sort_iter([(5, -1), (3, -2), (5, 0)])) # Output: [(3, -2), (5, -1), (5, 0)] # Recursive version print(quick_sort_recur([(3, 2), (1, 4), (1, 2), (2, 5)])) # Output: [(1, 2), (1, 4), (2, 5), (3, 2)] print(quick_sort_recur([])) # Output: [] print(quick_sort_recur([(5, -1), (3, -2), (5, 0)])) # Output: [(3, -2), (5, -1), (5, 0)] # Complex example import random collection_arg = [(random.randint(-100, 100), random.randint(-100, 100)) for _ in range(1000)] assert quick_sort_iter(collection_arg) == sorted(collection_arg) assert quick_sort_recur(collection_arg) == sorted(collection_arg) ``` # Constraints - The function must handle edge cases efficiently. - Consider both time and space complexities. - Do not use built-in sort functions except for testing correctness. Evaluate the iterative and recursive implementations for performance on large datasets with up to 2000 elements.","solution":"from typing import List, Tuple def quick_sort_iter(collection: List[Tuple[int, int]]) -> List[Tuple[int, int]]: if not collection: return collection stack = [(0, len(collection) - 1)] def partition(low, high): pivot = collection[high] i = low - 1 for j in range(low, high): if collection[j] < pivot: i += 1 collection[i], collection[j] = collection[j], collection[i] collection[i + 1], collection[high] = collection[high], collection[i + 1] return i + 1 while stack: low, high = stack.pop() if low < high: pivot_index = partition(low, high) stack.append((low, pivot_index - 1)) stack.append((pivot_index + 1, high)) return collection def quick_sort_recur(collection: List[Tuple[int, int]]) -> List[Tuple[int, int]]: if len(collection) <= 1: return collection pivot = collection[len(collection) // 2] left = [x for x in collection if x < pivot] middle = [x for x in collection if x == pivot] right = [x for x in collection if x > pivot] return quick_sort_recur(left) + middle + quick_sort_recur(right)"},{"question":"# Consecutive Bits Counter In this challenge, you will calculate the number of consecutive 1s in the binary representation of an integer. Your task is to find the length of the longest sequence of consecutive 1s in the binary representation of the given integer. Scenario Imagine you are working on a compression algorithm that optimizes space by identifying and compressing long sequences of 1s in binary data. To facilitate this, you need to determine the length of the longest sequence of consecutive 1s in any given integer. Function Signature ```python def longest_consecutive_ones(num: int) -> int: This function receives a single integer and returns the length of the longest sequence of consecutive 1s in its binary representation. Args: num (int): An integer whose binary representation will be analyzed. Returns: int: The length of the longest sequence of consecutive 1s. ``` Input - A single integer `num` which can be positive, zero, or negative. Output - The integer result representing the length of the longest sequence of consecutive 1s in the binary representation. Constraints - You may assume that `num` fits within a signed 32-bit integer. - Handle both positive and negative integers correctly according to two\'s complement representation for negative numbers. Examples ```python >>> longest_consecutive_ones(0) 0 >>> longest_consecutive_ones(1) 1 >>> longest_consecutive_ones(9) # binary: 1001 1 >>> longest_consecutive_ones(15) # binary: 1111 4 >>> longest_consecutive_ones(-1) # binary (32-bit): 111...111 (32 ones) 32 >>> longest_consecutive_ones(156) # binary: 10011100 3 ``` Requirements - Run in linear time O(n) where n is the number of bits in the integer. - Utilize bitwise operations effectively to identify sequences of 1s. - Ensure the solution handles both positive and negative numbers. Tips - Convert the integer to its binary representation. - Traverse the binary representation to count consecutive 1s sequences and determine the longest one. Implement the function `longest_consecutive_ones` and test it with appropriate inputs.","solution":"def longest_consecutive_ones(num): This function receives a single integer and returns the length of the longest sequence of consecutive 1s in its binary representation. Args: num (int): An integer whose binary representation will be analyzed. Returns: int: The length of the longest sequence of consecutive 1s. # Convert to 32-bit binary representation taking care of negative numbers using two\'s complement if num < 0: num = (1 << 32) + num # Get the binary representation and strip the \'0b\' prefix binary_repr = bin(num)[2:] # Split the binary representation by \'0\' to find sequences of \'1\'s one_sequences = binary_repr.split(\'0\') # Find the maximum length of the sequences of \'1\'s max_length = max(len(seq) for seq in one_sequences) return max_length"},{"question":"Problem Description Your task is to create a library management system with functionalities to track books, manage member registrations, and handle borrow/return transactions. The goal is to maintain simplicity while ensuring accurate tracking of each functionality. Task 1. **Define the `Library` class with the following methods**: * `__init__(self)` - Initializes the library with an empty book catalog and empty member list. * `add_book(self, book_id, title)` - Adds a book to the catalog. Each book is represented by a unique `book_id` and its `title`. If the book_id already exists, it should not add the book again. * `remove_book(self, book_id)` - Removes a book from the catalog using `book_id`. If the book does not exist, it should return an appropriate message. * `register_member(self, member_id, member_name)` - Registers a new member to the library with a unique `member_id` and their `member_name`. If the `member_id` already exists, it should not register the member again. * `unregister_member(self, member_id)` - Unregisters a member from the library using `member_id`. If the member does not exist, it should return an appropriate message. * `borrow_book(self, member_id, book_id)` - Allows a registered member to borrow a book using their `member_id` and `book_id`. If the book is already borrowed, it should return an appropriate message. If the `member_id` or `book_id` does not exist, it should return an appropriate message. * `return_book(self, member_id, book_id)` - Allows a registered member to return a borrowed book using their `member_id` and `book_id`. If the book was not borrowed by the member or does not exist, it should return an appropriate message. # Input and Output Formats Method 1: `add_book` * **Input**: * `book_id` (string): Unique identifier for the book. * `title` (string): The title of the book. * **Output**: * String indicating the successful addition of the book, or the appropriate error message if the book already exists. * **Example**: ```python add_book(\\"B001\\", \\"The Great Gatsby\\") == \\"Book added successfully.\\" ``` Method 2: `remove_book` * **Input**: * `book_id` (string): Unique identifier for the book to be removed. * **Output**: * String indicating the successful removal of the book, or the appropriate error message if the book does not exist. * **Example**: ```python remove_book(\\"B001\\") == \\"Book removed successfully.\\" ``` Method 3: `register_member` * **Input**: * `member_id` (string): Unique identifier for the member. * `member_name` (string): The name of the member. * **Output**: * String indicating the successful registration of the member, or the appropriate error message if the member already exists. * **Example**: ```python register_member(\\"M001\\", \\"Alice ADoe\\") == \\"Member registered successfully.\\" ``` Method 4: `unregister_member` * **Input**: * `member_id` (string): Unique identifier for the member to be unregistered. * **Output**: * String indicating the successful unregistration of the member, or the appropriate error message if the member does not exist. * **Example**: ```python unregister_member(\\"M001\\") == \\"Member unregistered successfully.\\" ``` Method 5: `borrow_book` * **Input**: * `member_id` (string): Unique identifier for the member. * `book_id` (string): Unique identifier for the book to be borrowed. * **Output**: * String indicating the successful borrowing of the book, or the appropriate error message if the book is already borrowed or if the `member_id` or `book_id` does not exist. * **Example**: ```python borrow_book(\\"M001\\", \\"B001\\") == \\"Book borrowed successfully.\\" ``` Method 6: `return_book` * **Input**: * `member_id` (string): Unique identifier for the member. * `book_id` (string): Unique identifier for the book to be returned. * **Output**: * String indicating the successful return of the book, or the appropriate error message if the book was not borrowed by the member or does not exist. * **Example**: ```python return_book(\\"M001\\", \\"B001\\") == \\"Book returned successfully.\\" ``` Implementation Details 1. Use dictionaries to manage the books and members efficiently. 2. Maintain a set or a separate dictionary to track borrowed books. 3. Ensure that all methods handle errors and edge cases gracefully. 4. Consider using descriptive messages for different error cases. Constraints * All input strings (book_id, title, member_id, member_name) are non-empty and unique for their respective roles. * The library starts with no books and no members. * Assume no concurrent transactions (all operations are atomic). Example Usage Here’s how you might use the `Library` class: ```python library = Library() print(library.add_book(\\"B001\\", \\"The Great Gatsby\\")) # \\"Book added successfully.\\" print(library.register_member(\\"M001\\", \\"Alice Adoe\\")) # \\"Member registered successfully.\\" print(library.borrow_book(\\"M001\\", \\"B001\\")) # \\"Book borrowed successfully.\\" print(library.return_book(\\"M001\\", \\"B001\\")) # \\"Book returned successfully.\\" print(library.remove_book(\\"B001\\")) # \\"Book removed successfully.\\" print(library.unregister_member(\\"M001\\")) # \\"Member unregistered successfully.\\" ```","solution":"class Library: def __init__(self): self.books = {} self.members = {} self.borrowed_books = {} def add_book(self, book_id, title): if book_id in self.books: return \\"Book already exists.\\" self.books[book_id] = title return \\"Book added successfully.\\" def remove_book(self, book_id): if book_id not in self.books: return \\"Book does not exist.\\" if book_id in self.borrowed_books: return \\"Cannot remove borrowed book.\\" del self.books[book_id] return \\"Book removed successfully.\\" def register_member(self, member_id, member_name): if member_id in self.members: return \\"Member already exists.\\" self.members[member_id] = member_name return \\"Member registered successfully.\\" def unregister_member(self, member_id): if member_id not in self.members: return \\"Member does not exist.\\" if any(borrower == member_id for borrower in self.borrowed_books.values()): return \\"Member has borrowed books.\\" del self.members[member_id] return \\"Member unregistered successfully.\\" def borrow_book(self, member_id, book_id): if member_id not in self.members: return \\"Member does not exist.\\" if book_id not in self.books: return \\"Book does not exist.\\" if book_id in self.borrowed_books: return \\"Book already borrowed.\\" self.borrowed_books[book_id] = member_id return \\"Book borrowed successfully.\\" def return_book(self, member_id, book_id): if book_id not in self.borrowed_books: return \\"Book was not borrowed.\\" if self.borrowed_books[book_id] != member_id: return \\"Book was not borrowed by this member.\\" del self.borrowed_books[book_id] return \\"Book returned successfully.\\""},{"question":"# Question: Create a Library Management System You are tasked with building a basic library management system to keep track of books and their availability. The system should allow for adding new books, borrowing books, and returning books. Function Specifications: 1. `add_book(library: dict, book_id: str, title: str) -> None` - **Input**: - `library`: A dictionary representing the library system. - `book_id`: A unique identifier for the book (string). - `title`: The title of the book (string). - **Output**: None - **Functionality**: This function adds a new book to the library. - **Example**: ```python library = {} add_book(library, \\"1\\", \\"1984\\") assert library == {\\"1\\": {\\"title\\": \\"1984\\", \\"is_borrowed\\": False}} add_book(library, \\"2\\", \\"Brave New World\\") assert library == {\\"1\\": {\\"title\\": \\"1984\\", \\"is_borrowed\\": False}, \\"2\\": {\\"title\\": \\"Brave New World\\", \\"is_borrowed\\": False}} ``` 2. `borrow_book(library: dict, book_id: str) -> str` - **Input**: - `library`: A dictionary representing the library system. - `book_id`: A unique identifier for the book (string). - **Output**: A string indicating the result of the borrow operation. - **Functionality**: This function updates the status of the book to borrowed if it is available. - **Example**: ```python library = {\\"1\\": {\\"title\\": \\"1984\\", \\"is_borrowed\\": False}} assert borrow_book(library, \\"1\\") == \\"Book borrowed successfully.\\" assert borrow_book(library, \\"1\\") == \\"Book is already borrowed.\\" assert borrow_book(library, \\"2\\") == \\"Book not found.\\" ``` 3. `return_book(library: dict, book_id: str) -> str` - **Input**: - `library`: A dictionary representing the library system. - `book_id`: A unique identifier for the book (string). - **Output**: A string indicating the result of the return operation. - **Functionality**: This function updates the status of the book to available if it is currently borrowed. - **Example**: ```python library = {\\"1\\": {\\"title\\": \\"1984\\", \\"is_borrowed\\": True}} assert return_book(library, \\"1\\") == \\"Book returned successfully.\\" assert return_book(library, \\"1\\") == \\"Book was not borrowed.\\" assert return_book(library, \\"2\\") == \\"Book not found.\\" ``` Requirements: - Ensure proper handling of edge cases such as attempting to borrow or return books that do not exist in the library. - The system should handle multiple books and their statuses efficiently. Constraints: - Assume book identifiers are unique and non-empty strings. - Titles of the books are also non-empty strings.","solution":"def add_book(library: dict, book_id: str, title: str) -> None: Adds a book to the library with the given book_id and title. Args: library (dict): The library system where books are stored. book_id (str): The unique identifier for the book. title (str): The title of the book. Returns: None library[book_id] = {\\"title\\": title, \\"is_borrowed\\": False} def borrow_book(library: dict, book_id: str) -> str: Updates the status of the book to borrowed if it is available. Args: library (dict): The library system where books are stored. book_id (str): The unique identifier for the book. Returns: str: A message indicating the result of the borrow operation. if book_id not in library: return \\"Book not found.\\" if library[book_id][\\"is_borrowed\\"]: return \\"Book is already borrowed.\\" library[book_id][\\"is_borrowed\\"] = True return \\"Book borrowed successfully.\\" def return_book(library: dict, book_id: str) -> str: Updates the status of the book to available if it is currently borrowed. Args: library (dict): The library system where books are stored. book_id (str): The unique identifier for the book. Returns: str: A message indicating the result of the return operation. if book_id not in library: return \\"Book not found.\\" if not library[book_id][\\"is_borrowed\\"]: return \\"Book was not borrowed.\\" library[book_id][\\"is_borrowed\\"] = False return \\"Book returned successfully.\\""},{"question":"# Problem Statement You are tasked with implementing a `DiagonalMatrix` class to represent a square matrix with non-zero values only on its main diagonal. Your job is to create this class in addition to methods for performing common matrix operations. # Requirements Diagonal Matrix Implementation - Implement the `__init__` method to initialize the diagonal elements of the matrix. - Implement the `__getitem__` and `__setitem__` methods to access and modify diagonal elements. - Implement methods for matrix addition, subtraction, and scalar multiplication. # Function Signatures You will need to implement the following methods for the `DiagonalMatrix` class: 1. `__init__(self, diagonal: List[int]) -> None`: - Initializes the matrix with the provided diagonal elements. - The input list `diagonal` represents the values on the main diagonal. 2. `__getitem__(self, idx: Tuple[int, int]) -> int`: - Returns the value at the given (row, column) index. - Non-diagonal elements should always return 0. 3. `__setitem__(self, idx: Tuple[int, int], value: int) -> None`: - Sets the value at the given (row, column) index if it is on the main diagonal. - For non-diagonal indices, the method should raise an `IndexError`. 4. `__add__(self, other: \'DiagonalMatrix\') -> \'DiagonalMatrix\'`: - Returns a new `DiagonalMatrix` representing the sum of `self` and `other`. 5. `__sub__(self, other: \'DiagonalMatrix\') -> \'DiagonalMatrix\'`: - Returns a new `DiagonalMatrix` representing the difference between `self` and `other`. 6. `__mul__(self, scalar: int) -> \'DiagonalMatrix\'`: - Returns a new `DiagonalMatrix` obtained by multiplying each diagonal element by `scalar`. # Constraints - Assume the input diagonal lists for the matrices are always properly formed (i.e., square matrices). - Methods for accessing and modifying elements should handle out-of-bounds indices appropriately. # Example Usage ```python diag1 = DiagonalMatrix([1, 2, 3]) diag2 = DiagonalMatrix([4, 5, 6]) result_add = diag1 + diag2 result_sub = diag1 - diag2 result_mul = diag1 * 2 assert result_add.diagonal == [5, 7, 9] assert result_sub.diagonal == [-3, -3, -3] assert result_mul.diagonal == [2, 4, 6] # Accessing elements assert diag1[0, 0] == 1 assert diag1[1, 1] == 2 assert diag1[2, 2] == 3 assert diag1[1, 0] == 0 # Modifying elements diag1[1, 1] = 10 assert diag1[1, 1] == 10 # Attempting to set a non-diagonal elements should raise an error try: diag1[1, 0] = 99 except IndexError as e: assert str(e) == \\"IndexError: Only diagonal elements can be set\\" # Add the code for implementing this functionality # Your implementation should smoothly integrate usual practices and be thoroughly tested. if __name__ == \\"__main__\\": unittest.main() ```","solution":"from typing import List, Tuple class DiagonalMatrix: def __init__(self, diagonal: List[int]) -> None: self.diagonal = diagonal def __getitem__(self, idx: Tuple[int, int]) -> int: row, col = idx if row == col and 0 <= row < len(self.diagonal): return self.diagonal[row] return 0 def __setitem__(self, idx: Tuple[int, int], value: int) -> None: row, col = idx if row == col and 0 <= row < len(self.diagonal): self.diagonal[row] = value else: raise IndexError(\\"IndexError: Only diagonal elements can be set\\") def __add__(self, other: \'DiagonalMatrix\') -> \'DiagonalMatrix\': result = [a + b for a, b in zip(self.diagonal, other.diagonal)] return DiagonalMatrix(result) def __sub__(self, other: \'DiagonalMatrix\') -> \'DiagonalMatrix\': result = [a - b for a, b in zip(self.diagonal, other.diagonal)] return DiagonalMatrix(result) def __mul__(self, scalar: int) -> \'DiagonalMatrix\': result = [a * scalar for a in self.diagonal] return DiagonalMatrix(result)"},{"question":"# Lieferkette Routing Optimization using Dijkstra\'s Algorithm **Background**: A logistics company needs to optimize the routes for its delivery trucks. The company wants to ensure quick delivery times by finding the shortest paths between distribution centers in a network of cities. You are tasked with implementing Dijkstra\'s algorithm to determine the shortest paths and help the company optimize route planning and reduce delivery time significantly. **Objective**: Using the given data structure, implement an algorithm to identify the shortest path from a source city to all other cities in the network. **Task**: 1. Implement the `dijkstra_algorithm` function to compute the shortest paths from the source city to all other cities. 2. Write a function `find_shortest_paths(graph: dict[str, dict[str, int]], start: str) -> dict[str, int]` that: - Accepts a weighted graph represented as an adjacency dictionary and a starting city. - Returns a dictionary where keys are the city names and values are the shortest distances from the starting city. **Function Signature**: ```python def find_shortest_paths(graph: dict[str, dict[str, int]], start: str) -> dict[str, int]: ``` **Input**: - `graph`: A dictionary representing the weighted graph. Example: `{\'A\': {\'B\': 1, \'C\': 4}, \'B\': {\'C\': 2, \'D\': 5}, ...}` - `start`: A string representing the starting city. Example: `\'A\'` **Output**: - A dictionary where keys are city names and values are the shortest distances from the starting city. Example: `{\'A\': 0, \'B\': 1, \'C\': 3, \'D\': 6}` **Constraints**: - The number of cities `n` (nodes) is such that `1 <= n <= 100`. - The number of roads (edges) connecting the cities is at most 500. - All road weights (distances) are positive integers. **Example**: ```python graph = { \'A\': {\'B\': 1, \'C\': 4}, \'B\': {\'C\': 2, \'D\': 5}, \'C\': {\'D\': 1}, \'D\': {} } start = \'A\' result = find_shortest_paths(graph, start) print(result) # Output: {\'A\': 0, \'B\': 1, \'C\': 3, \'D\': 4} ``` Use the adjacency list and Dijkstra\'s algorithm to find the shortest paths effectively.","solution":"import heapq def dijkstra_algorithm(graph, start): Implements Dijkstra\'s algorithm to find the shortest path from the start node to all other nodes. Args: graph (dict): a dictionary representing the weighted graph. start (str): the starting node. Returns: dict: a dictionary with the shortest distance from the start node to every other node. # Priority queue to store (distance, node) priority_queue = [(0, start)] # Dictionary to store the shortest distance from start to each node distances = {node: float(\'inf\') for node in graph} distances[start] = 0 while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node].items(): distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances def find_shortest_paths(graph, start): Finds the shortest paths from the start city to all other cities using Dijkstra\'s algorithm. Args: graph (dict): a dictionary representing the weighted graph. start (str): the starting city. Returns: dict: a dictionary with the shortest distance from the start city to every other city. return dijkstra_algorithm(graph, start)"},{"question":"Problem Statement **Unique Substring of K Length** Given a string `s` and an integer `k`, identify all unique substrings of length `k` and calculate their numerical scores. The score of a substring is defined as the sum of the ASCII values of its characters. Write a function `unique_substrings_score(s: str, k: int) -> Dict[str, int]` that returns a dictionary where keys are the unique substrings of length `k` and values are their corresponding scores. **Constraints:** - `1 <= k <= len(s) <= 10^4` - The string `s` contains only lowercase alphabets. Input - `s` (str): The input string (only lowercase alphabets). - `k` (int): The length of the substrings to consider. Output - `Dict[str, int]`: A dictionary with unique substrings of length `k` as keys and their scores as values. Example ```python def unique_substrings_score(s: str, k: int) -> Dict[str, int]: # Implementation here... print(unique_substrings_score(\\"abcdef\\", 3)) # Expected output: {\\"abc\\": 294, \\"bcd\\": 297, \\"cde\\": 300, \\"def\\": 303} print(unique_substrings_score(\\"aaaaa\\", 2)) # Expected output: {\\"aa\\": 194} ``` Notes - Each substring of length `k` is constructed by taking `k` consecutive characters from `s`. - The ASCII value of a lowercase letter can be obtained using the `ord` function, where `ord(\'a\') = 97`, `ord(\'b\') = 98`, ..., `ord(\'z\') = 122`. Performance Requirements - The function should efficiently handle inputs where the length of the string `s` is up to 10,000 characters.","solution":"def unique_substrings_score(s: str, k: int): Returns a dictionary of unique substrings of length k and their corresponding scores. substrings_score = {} for i in range(len(s) - k + 1): substr = s[i:i+k] if substr not in substrings_score: score = sum(ord(char) for char in substr) substrings_score[substr] = score return substrings_score"},{"question":"# Coding Assessment Question **Problem Statement:** You are provided with an implementation of a singly linked list in Python. The implementation includes methods for adding nodes to the head and tail of the list. Your task is to extend the given implementation to include additional functionality that manipulates the list based on specific requirements. Requirements: 1. **Removing Duplicates**: Implement a function `remove_duplicates` that removes all duplicate values from the linked list. The function should maintain the order of the remaining elements. 2. **Reversing the List**: Implement a function `reverse_list` that reverses the linked list in place. Input: - A list of integers to be added to the linked list, with possible duplicate values. Output: - A list of integers representing the linked list after all duplicates are removed. - A list of integers representing the linked list after it has been reversed. Constraints: - The input list will contain at most 10^3 elements. Function Signature: ```python class ListNode: ... class SinglyLinkedList: ... def remove_duplicates(head: ListNode | None) -> ListNode | None: ... def reverse_list(head: ListNode | None) -> ListNode | None: ... # Example Usage: # linked_list = SinglyLinkedList() # for value in [1, 4, 2, 2, 3, 4, 1]: # linked_list.add_to_tail(value) # linked_list.head = remove_duplicates(linked_list.head) # result = reverse_list(linked_list.head) # print(result) # Expected reversed list after duplicates removal ``` --- **Example:** ```python class ListNode: def __init__(self, data: int) -> None: self.data = data self.next = None class SinglyLinkedList: def __init__(self) -> None: self.head = None def add_to_tail(self, data: int) -> None: new_node = ListNode(data) if self.head is None: self.head = new_node else: current = self.head while current.next: current = current.next current.next = new_node def remove_duplicates(head: ListNode | None) -> ListNode | None: if not head: return head seen = set() current = head prev = None while current: if current.data in seen: prev.next = current.next else: seen.add(current.data) prev = current current = current.next return head def reverse_list(head: ListNode | None) -> ListNode | None: prev = None current = head while current: next_node = current.next current.next = prev prev = current current = next_node return prev # Test linked_list = SinglyLinkedList() for value in [1, 4, 2, 2, 3, 4, 1]: linked_list.add_to_tail(value) linked_list.head = remove_duplicates(linked_list.head) reversed_head = reverse_list(linked_list.head) # Function to convert linked list to Python list for easy verification def linked_list_to_list(head: ListNode | None) -> list[int]: result = [] while head: result.append(head.data) head = head.next return result print(linked_list_to_list(reversed_head)) # Expected reversed list after duplicates removal ``` You are expected to design the `remove_duplicates` method to ensure that all duplicate elements are removed while maintaining the order of the remaining elements. Additionally, implement the `reverse_list` method to demonstrate your ability to manipulate linked list structures efficiently.","solution":"class ListNode: def __init__(self, data: int) -> None: self.data = data self.next = None class SinglyLinkedList: def __init__(self) -> None: self.head = None def add_to_tail(self, data: int) -> None: new_node = ListNode(data) if self.head is None: self.head = new_node else: current = self.head while current.next: current = current.next current.next = new_node def remove_duplicates(head: ListNode | None) -> ListNode | None: if not head: return head seen = set() current = head prev = None while current: if current.data in seen: prev.next = current.next else: seen.add(current.data) prev = current current = current.next return head def reverse_list(head: ListNode | None) -> ListNode | None: prev = None current = head while current: next_node = current.next current.next = prev prev = current current = next_node return prev"},{"question":"# Text File Analyzer You are to implement a function that analyzes the content of a given text file and provides statistics about the text. The function should: 1. Count the total number of lines, words, and characters. 2. Identify and return the most frequent word. 3. Calculate and return the average word length. 4. Identify and return the longest word. # Input - A file path to a text file. # Output - The function should print: * Total number of lines. * Total number of words. * Total number of characters. * Most frequent word. * Average word length. * Longest word. # Constraints - The text file can be large, up to 10MB. - A word is defined as a sequence of characters separated by whitespace. - Punctuation should be excluded when identifying words. - Case-insensitive word counting (e.g., \\"Word\\" and \\"word\\" should be considered the same.) # Example ```python # Example main invocation if __name__ == \\"__main__\\": file_path = \\"path/to/text-file.txt\\" try: analyze_text_file(file_path) except Exception as e: print(f\\"Failed to analyze file: {e}\\") ``` Expected output for a sample file could look like: ``` Total lines: 100 Total words: 850 Total characters: 5000 Most frequent word: \\"the\\" Average word length: 4.2 Longest word: \\"notwithstanding\\" ``` # Notes - You may use helper functions to structure your code. - Ensure robust file handling, including situations where the file might not exist. - Efficiently process the file to handle larger sizes within reasonable time limits.","solution":"import os import string from collections import Counter def analyze_text_file(file_path): if not os.path.isfile(file_path): raise FileNotFoundError(f\\"The file at {file_path} does not exist.\\") total_lines = 0 total_words = 0 total_characters = 0 word_count = Counter() longest_word = \\"\\" with open(file_path, \'r\', encoding=\'utf-8\') as file: for line in file: total_lines += 1 total_characters += len(line) words = line.lower().translate(str.maketrans(\'\', \'\', string.punctuation)).split() total_words += len(words) word_count.update(words) for word in words: if len(word) > len(longest_word): longest_word = word if total_words > 0: most_frequent_word = word_count.most_common(1)[0][0] average_word_length = sum(len(word) for word in word_count.elements()) / total_words else: most_frequent_word = \\"\\" average_word_length = 0 print(f\\"Total lines: {total_lines}\\") print(f\\"Total words: {total_words}\\") print(f\\"Total characters: {total_characters}\\") print(f\\"Most frequent word: \\"{most_frequent_word}\\"\\") print(f\\"Average word length: {average_word_length:.2f}\\") print(f\\"Longest word: \\"{longest_word}\\"\\")"},{"question":"# Coding Challenge: Graph Clone with Random Pointers Scenario: You are given a graph where each node contains an additional random pointer which could point to any node in the graph, including itself or null. The challenge is to create a deep copy of this graph. Each node in the new graph should have the same value, neighbors, and random pointer connections as the corresponding node in the original graph. Task: Implement a function `clone_graph` that takes a node of the graph as input and returns a deep copy of the entire graph. Function Signature: ```python class Node: def __init__(self, val: int = 0, neighbors: list = None, random: \'Node\' = None): self.val = val self.neighbors = neighbors if neighbors is not None else [] self.random = random def clone_graph(node: \'Node\') -> \'Node\': ``` Input: - `node` (`Node`): The starting node of the graph. Output: - `Node`: The starting node of the deep copied graph. Constraints: - The number of nodes in the graph is in the range `[0, 100]`. - Each node\'s value is within `[0, 100]`. Example: ```python # Example Node class and sample graph setup. # Given a graph with multiple nodes and random pointers, create a deep copy. node1 = Node(1) node2 = Node(2) node3 = Node(3) node4 = Node(4) node1.neighbors = [node2, node3] node2.neighbors = [node3] node3.neighbors = [node4] node4.neighbors = [node1] node1.random = node3 node2.random = node1 node3.random = node2 node4.random = node4 cloned_node = clone_graph(node1) # The cloned graph should be a deep copy with same connections and random pointers as `node1`. ``` Requirements: - Ensure that the graph is deep copied accurately including random pointers. - You might consider using a dictionary to map original nodes to their clones. - Think about how to handle cycles and null nodes in the graph. Notes: - Consider edge cases like a completely disconnected graph, single-node graphs (with or without self-loop), and graphs with complex random pointer structures. - Ensure your solution handles graphs with `null` nodes gracefully.","solution":"class Node: def __init__(self, val: int = 0, neighbors: list = None, random: \'Node\' = None): self.val = val self.neighbors = neighbors if neighbors is not None else [] self.random = random def clone_graph(node: \'Node\') -> \'Node\': if not node: return None # Dictionary to save visited nodes and their clones visited = {} def clone(node): if node in visited: return visited[node] # Create a cloned node cloned_node = Node(node.val) visited[node] = cloned_node # Deep copy the neighbors for neighbor in node.neighbors: cloned_node.neighbors.append(clone(neighbor)) # Deep copy the random pointer if node.random: cloned_node.random = clone(node.random) return cloned_node return clone(node)"},{"question":"# Problem Statement **Background**: A binary heap is a complete binary tree where the key at each node is at least as great as the keys of its children (Max-Heap) or at most as great as the keys of its children (Min-Heap). Binary heaps are commonly implemented using arrays. # Description Implement a class `MinHeap` that represents a min-heap data structure. The class should support heap operations: insertion, deletion, and retrieval of the minimum element. Class Signature ```python class MinHeap: def __init__(self): pass def insert(self, value: int) -> None: pass def extract_min(self) -> int: pass def get_min(self) -> int: pass ``` # Methods - `__init__(self)`: Initializes an empty min-heap. - `insert(self, value: int) -> None`: Inserts a new integer into the heap. - `extract_min(self) -> int`: Removes and returns the minimum element from the heap. If the heap is empty, return -1. - `get_min(self) -> int`: Returns the minimum element without removing it from the heap. If the heap is empty, return -1. # Input - The class will not take any external input directly. Input will be provided through method calls. # Output - `insert` method does not return anything. - `extract_min` method returns the minimum element or -1 if the heap is empty. - `get_min` method returns the minimum element or -1 if the heap is empty. # Constraints - All integers are in the range -10^9 to 10^9. - A sequence of up to 10^6 operations will be performed on the heap. # Example ```python heap = MinHeap() heap.insert(3) heap.insert(1) heap.insert(6) assert heap.get_min() == 1 assert heap.extract_min() == 1 assert heap.get_min() == 3 assert heap.extract_min() == 3 assert heap.extract_min() == 6 assert heap.get_min() == -1 ``` # Constraints and Notes - Implement the heap using an array (list in Python) for efficient indexing. - Ensure that your methods handle edge cases, such as performing operations on an empty heap. - Optimize the operations to maintain the properties of a min-heap, ensuring efficient performance.","solution":"class MinHeap: def __init__(self): self.heap = [] def insert(self, value: int) -> None: self.heap.append(value) self._heapify_up(len(self.heap) - 1) def extract_min(self) -> int: if not self.heap: return -1 min_value = self.heap[0] last_value = self.heap.pop() if self.heap: self.heap[0] = last_value self._heapify_down(0) return min_value def get_min(self) -> int: return self.heap[0] if self.heap else -1 def _heapify_up(self, index): parent_index = (index - 1) // 2 if index > 0 and self.heap[index] < self.heap[parent_index]: self.heap[index], self.heap[parent_index] = self.heap[parent_index], self.heap[index] self._heapify_up(parent_index) def _heapify_down(self, index): left_child_index = 2 * index + 1 right_child_index = 2 * index + 2 smallest_index = index if left_child_index < len(self.heap) and self.heap[left_child_index] < self.heap[smallest_index]: smallest_index = left_child_index if right_child_index < len(self.heap) and self.heap[right_child_index] < self.heap[smallest_index]: smallest_index = right_child_index if smallest_index != index: self.heap[index], self.heap[smallest_index] = self.heap[smallest_index], self.heap[index] self._heapify_down(smallest_index)"},{"question":"# Problem Statement You are tasked with creating a function that balances parentheses in a given input string. The function should ensure that every opening parenthesis \\"(\\" has a corresponding closing parenthesis \\")\\", and that the parentheses are properly nested. # Function Specifications **Function Name**: `balance_parentheses` **Input**: A string `s` containing any of the 94 printable ASCII characters, including parentheses `()`. **Output**: A string with parentheses balanced in the correct order. If there are unmatched parentheses in `s`, append the necessary characters to balance the string. # Constraints - The input string `s` can be empty. - The input string can contain up to 1000 characters. - Only parentheses need to be balanced; other characters should remain in their original positions. # Performance Requirements - The time complexity should be O(n), where n is the length of the input string. - The function should handle edge cases effectively, such as strings with no parentheses or already balanced strings. # Examples ```python >>> balance_parentheses(\\"\\") \\"\\" >>> balance_parentheses(\\"a + b))\\") \\"a + b))\\" >>> balance_parentheses(\\"((a + b))\\") \\"((a + b))\\" >>> balance_parentheses(\\"((x + y)\\") \\"((x + y))\\" >>> balance_parentheses(\\"(a(b)c)\\") \\"(a(b)c): >):\\"> a(b)c\\": # Notes - Do not modify characters other than parentheses. The order of non-parenthesis characters in the input string must be maintained. - Append necessary characters at the end of the string if unmatched parentheses remain.","solution":"def balance_parentheses(s): Balances parentheses in the input string s by ensuring every opening parenthesis has a corresponding closing parenthesis. Appends necessary parentheses to the end if unmatched parentheses remain. Parameters: s (str): The input string containing printable ASCII characters, including parentheses. Returns: str: A balanced string with proper nested parentheses. # Counters for unmatched parentheses open_count = 0 close_count = 0 # First pass to calculate the excess of opening parentheses for char in s: if char == \'(\': open_count += 1 elif char == \')\': if open_count > 0: open_count -= 1 else: close_count += 1 # Second pass to create the balanced string balanced = [] for char in s: balanced.append(char) # Append necessary closing parentheses for unmatched opening parentheses balanced.append(\')\' * open_count) # Return the resulting balanced string return \'\'.join(balanced)"},{"question":"# K-Way Merge K Sorted Arrays Context You are developing a tool for data merging that can efficiently merge multiple sorted arrays into a single sorted array. Given `k` sorted arrays, your task is to merge them into a single sorted array. Objective Write a function `merge_k_sorted_arrays(arrays: List[List[int]]) -> List[int]` that merges `k` sorted arrays into a single sorted array. Input * `arrays`: A list of `k` lists, where each list is sorted in ascending order. * Each list can contain up to 1000 elements, and there can be up to 100 such lists. Output * Returns a single list containing all elements from the input lists, sorted in ascending order. Constraints * The total number of elements across all lists will not exceed 100000. * The arrays are non-empty and each array itself is sorted. Example ```python def merge_k_sorted_arrays(arrays: List[List[int]]) -> List[int]: # Your code here # Example usage: arrays = [ [1, 4, 5], [1, 3, 4], [2, 6] ] print(merge_k_sorted_arrays(arrays)) # Output: [1, 1, 2, 3, 4, 4, 5, 6] ``` Explanation For the given example, the function `merge_k_sorted_arrays` merges the sorted arrays `[1, 4, 5]`, `[1, 3, 4]`, and `[2, 6]` into a single sorted array `[1, 1, 2, 3, 4, 4, 5, 6]`. The solution is expected to efficiently handle the merging process, potentially using a min-heap or any other optimal approach to ensure the result remains in the correct order.","solution":"from typing import List import heapq def merge_k_sorted_arrays(arrays: List[List[int]]) -> List[int]: Merges k sorted arrays into a single sorted array. Args: arrays (List[List[int]]): A list of k sorted arrays. Returns: List[int]: A single sorted list containing all elements of the input arrays. result = [] min_heap = [] # Initialize the heap with the first element of each array for i, array in enumerate(arrays): if array: heapq.heappush(min_heap, (array[0], i, 0)) while min_heap: val, array_idx, element_idx = heapq.heappop(min_heap) result.append(val) # If there are more elements in the same array, add the next element to the heap if element_idx + 1 < len(arrays[array_idx]): next_val = arrays[array_idx][element_idx + 1] heapq.heappush(min_heap, (next_val, array_idx, element_idx + 1)) return result"},{"question":"# Scenario You are developing a coding platform that allows users to write and test code in real-time. One of the key features is the ability to manage user-defined variables across different coding sessions. To support this, you need to implement a system that keeps track of variables, their names, types, and values, and allows for retrieval based on certain criteria. # Task Write a class `VariableManager` that can store variable names, their types, and values. The class should support adding new variables, updating existing ones, deleting variables, and querying variables by type. # Class Signature ```python class VariableManager: def __init__(self): # Initializes an empty manager pass def add_variable(self, name: str, var_type: str, value: any): # Adds a new variable; if the variable already exists, raises a ValueError pass def update_variable(self, name: str, value: any): # Updates the value of an existing variable; if the variable does not exist, raises a KeyError pass def delete_variable(self, name: str): # Deletes a variable; if the variable does not exist, raises a KeyError pass def get_variables_by_type(self, var_type: str) -> list[tuple[str, any]]: # Returns a list of tuples (variable name, value) for all variables of the given type pass ``` # Examples ```python # Example Usage manager = VariableManager() manager.add_variable(\\"x\\", \\"int\\", 10) manager.add_variable(\\"y\\", \\"float\\", 10.5) manager.add_variable(\\"name\\", \\"str\\", \\"Alice\\") manager.add_variable(\\"is_valid\\", \\"bool\\", True) # Update a variable manager.update_variable(\\"x\\", 20) # Delete a variable manager.delete_variable(\\"name\\") # Get variables by type print(manager.get_variables_by_type(\\"int\\")) # Output: [(\\"x\\", 20)] print(manager.get_variables_by_type(\\"str\\")) # Output: [] print(manager.get_variables_by_type(\\"float\\")) # Output: [(\\"y\\", 10.5)] print(manager.get_variables_by_type(\\"bool\\")) # Output: [(\\"is_valid\\", True)] # Add existing variable, should raise ValueError manager.add_variable(\\"x\\", \\"int\\", 20) # Output: ValueError: Variable \'x\' already exists. # Update non-existing variable, should raise KeyError manager.update_variable(\\"z\\", 30) # Output: KeyError: Variable \'z\' does not exist. # Delete non-existing variable, should raise KeyError manager.delete_variable(\\"name\\") # Output: KeyError: Variable \'name\' does not exist. ``` # Notes - Ensure the class correctly handles edge cases, such as adding an existing variable, updating or deleting a non-existing variable. - When querying by type, return the variables in the insertion order. - The class should be efficient in terms of both time and space complexity.","solution":"class VariableManager: def __init__(self): self.variables = {} def add_variable(self, name: str, var_type: str, value: any): if name in self.variables: raise ValueError(f\\"Variable \'{name}\' already exists.\\") self.variables[name] = {\'type\': var_type, \'value\': value} def update_variable(self, name: str, value: any): if name not in self.variables: raise KeyError(f\\"Variable \'{name}\' does not exist.\\") self.variables[name][\'value\'] = value def delete_variable(self, name: str): if name not in self.variables: raise KeyError(f\\"Variable \'{name}\' does not exist.\\") del self.variables[name] def get_variables_by_type(self, var_type: str) -> list[tuple[str, any]]: return [(name, info[\'value\']) for name, info in self.variables.items() if info[\'type\'] == var_type]"},{"question":"# Coding Assessment Question Context: You are working on a text processing tool that cleans and formats both regular and legal documents. One common problem is to detect and correct various types of spacing issues, such as multiple consecutive spaces, leading spaces, and trailing spaces. Additionally, some legal documents use archaic language that needs to be replaced with modern equivalents for clarity. Task: Write a function to clean and format the text. This function should handle removing unnecessary spaces and replacing specified words with modern equivalents. Requirements: - Implement a function `clean_text(text, replacements)`: - **Inputs**: - `text` (str): The input text that needs to be cleaned. - `replacements` (dict): A dictionary where keys are words to be replaced, and values are the modern equivalents. - **Output**: A cleaned and formatted string. - **Constraints**: - The input text is a non-empty string. - The replacements dictionary is not empty and contains only valid string mappings. Performance Requirements: - The function should efficiently handle texts up to 10,000 characters in length. Examples: ```python >>> text = \\" This is a sample text. \\" >>> replacements = {} >>> clean_text(text, replacements) \\"This is a sample text.\\" >>> text = \\"Wherefore art thou Romeo? \\" >>> replacements = {\\"Wherefore\\": \\"Why\\", \\"art\\": \\"are\\", \\"thou\\": \\"you\\"} >>> clean_text(text, replacements) \\"Why are you Romeo?\\" >>> text = \\" Multiple spaces and archaic words here. \\" >>> replacements = {\\"archaic\\": \\"old-fashioned\\"} >>> clean_text(text, replacements) \\"Multiple spaces and old-fashioned words here.\\" ``` Note: - The function should remove all leading and trailing spaces. - Replace each phrase in the text with its modern equivalent only if it matches exactly. - Ensure there is exactly one space between words after the processing.","solution":"import re def clean_text(text, replacements): Cleans and formats the input text as per the specified requirements. Removes unnecessary spaces and replaces specified words with modern equivalents. Parameters: text (str): The input text to be cleaned. replacements (dict): A dictionary where keys are words to be replaced, and values are the modern equivalents. Returns: str: A cleaned and formatted string. # Trim leading and trailing spaces and reduce multiple spaces to a single space text = re.sub(r\'s+\', \' \', text).strip() # Replace each target word with its corresponding replacement for old_word, new_word in replacements.items(): text = re.sub(r\'b\' + re.escape(old_word) + r\'b\', new_word, text) return text"},{"question":"# Problem Statement You are tasked with analyzing customer feedback for a product. We need to calculate the sentiment score of feedback messages. The sentiment score is calculated based on the presence of positive and negative words in each message. Your goal is to write a function: - `calculate_sentiment_score(positive_words: List[str], negative_words: List[str], feedback: List[str]) -> List[int]`: This function takes a list of positive words, a list of negative words, and a list of feedback messages. It returns a list of integers where each integer represents the sentiment score of the corresponding feedback message. The sentiment score is calculated as follows: - Start with a score of 0. - For each positive word found in the feedback message, add +1 to the score. - For each negative word found in the feedback message, subtract -1 from the score. # Input: - `positive_words` (List[str]): A list of words that are considered positive. - `negative_words` (List[str]): A list of words that are considered negative. - `feedback` (List[str]): A list of feedback messages (non-empty strings) to be analyzed. Each message contains words separated by spaces and may contain punctuation, which needs to be removed. # Output: - `List[int]`: A list of sentiment scores corresponding to each feedback message. # Constraints: - All words in `positive_words`, `negative_words`, and `feedback` are lowercase alphabetical strings (a-z). - The feedback list contains at most 1000 messages, and each message has a maximum length of 100 characters. # Example: ```python positive_words = [\\"good\\", \\"great\\", \\"excellent\\", \\"happy\\", \\"wonderful\\"] negative_words = [\\"bad\\", \\"terrible\\", \\"poor\\", \\"sad\\", \\"awful\\"] feedback = [\\"The product is good and wonderful\\", \\"I had a terrible experience, it was bad\\", \\"The product was excellent but not great for me\\"] scores = calculate_sentiment_score(positive_words, negative_words, feedback) assert scores == [2, -2, 1] ``` # Note: - Ignore punctuation during processing. - Each feedback message should be split into words, and punctuation marks (like ., !, ?) should be removed before computation. - The sentiment score for each feedback message should be calculated independently and in sequence. Implement the function to achieve the desired result.","solution":"import re from typing import List def calculate_sentiment_score(positive_words: List[str], negative_words: List[str], feedback: List[str]) -> List[int]: def clean_text(text): # Remove punctuation and lower the case return re.sub(r\'[^ws]\', \'\', text.lower()) def calculate_score(message): score = 0 words = clean_text(message).split() for word in words: if word in positive_words: score += 1 elif word in negative_words: score -= 1 return score return [calculate_score(message) for message in feedback]"},{"question":"# Problem Description You are required to implement a function that calculates the effective annual rate (EAR) from a given nominal annual rate and the number of compounding periods per year. The function must validate input parameters to ensure they are all positive. If any parameter is non-positive, the function should raise a `ValueError`. # Function Signature ```python def calculate_ear( nominal_rate: float, periods_per_year: int, ) -> float: pass ``` # Input * **nominal_rate** (float): A positive float representing the nominal annual interest rate as a decimal. * **periods_per_year** (int): A positive integer representing the number of compounding periods per year. # Output * **ear** (float): A floating-point number representing the effective annual rate as a decimal. # Constraints * Both input parameters must be positive. * If any parameter is non-positive, the function should raise a `ValueError`. # Examples ```python >>> calculate_ear(0.05, 4) 0.05094533691406235 >>> calculate_ear(0.07, 12) 0.07229030256609559 >>> calculate_ear(0.03, 1) 0.03 >>> calculate_ear(0, 4) Traceback (most recent call last): ... ValueError: All parameters must be positive. >>> calculate_ear(0.05, 0) Traceback (most recent call last): ... ValueError: All parameters must be positive. ``` # Note - The formula to calculate the Effective Annual Rate (EAR) is: [ text{EAR} = left(1 + frac{text{nominal rate}}{text{periods per year}}right)^{text{periods per year}} - 1 ] - Ensure to run and pass the provided examples and edge cases.","solution":"def calculate_ear(nominal_rate: float, periods_per_year: int) -> float: Calculate the Effective Annual Rate (EAR) given the nominal annual rate and the number of compounding periods per year. Args: nominal_rate (float): The nominal annual interest rate as a decimal. periods_per_year (int): The number of compounding periods per year. Returns: float: The effective annual rate as a decimal. Raises: ValueError: If any of the input parameters are non-positive. if nominal_rate <= 0 or periods_per_year <= 0: raise ValueError(\\"All parameters must be positive.\\") ear = (1 + nominal_rate / periods_per_year) ** periods_per_year - 1 return ear"},{"question":"# Sum of All Unique Numbers in a List Context: You have been assigned the task of processing lists of integers to identify and sum all unique elements (elements that appear exactly once) in each list. This can be useful in various scenarios, such as data analysis or inventory management, where you only want to consider non-repeating values. Objective: Implement a function that takes a list of integers and returns the sum of elements that appear exactly once. Function Signature: ```python def sum_of_unique(nums: list[int]) -> int: pass ``` Input: 1. **nums** (list of int): The list of integers to process. Output: - **int**: The sum of all unique integers in the list. Constraints: - The length of `nums` will be between 0 and 10^5. - Elements in `nums` will be between -10^6 and 10^6. Example: ```python assert sum_of_unique([1, 2, 3, 2, 1, 4]) == 7 assert sum_of_unique([1, 1, 2, 2, 3, 3]) == 0 assert sum_of_unique([4, 5, 6, 7, 8]) == 30 assert sum_of_unique([10]) == 10 assert sum_of_unique([]) == 0 assert sum_of_unique([1, 2, 2, 3, 4, 4, 5, 5, 6]) == 10 ``` Note: - Ensure your solution efficiently handles the expected range of input sizes. - Focus on edge cases such as lists with no unique elements, all unique elements, and empty lists. - You can assume that input to this function will always be valid and adhere to the constraints.","solution":"def sum_of_unique(nums: list[int]) -> int: from collections import Counter # Count occurrences of each number in the list num_counts = Counter(nums) # Sum numbers that appear exactly once unique_sum = sum(key for key, count in num_counts.items() if count == 1) return unique_sum"},{"question":"# Coding Question: Dijkstra\'s Shortest Path Given an undirected graph represented as an adjacency list, implement Dijkstra\'s algorithm to find the shortest path from a given start vertex to all other vertices using a min-heap for efficiency. Function Signature ```python def dijkstra_shortest_path(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]: \'\'\' Params: - graph: A dictionary where the key is a vertex and the value is a list of tuples (neighbor, weight). - start: An integer representing the start vertex for Dijkstra\'s algorithm. Returns: - A dictionary where the key is a vertex and the value is the shortest distance from the start vertex. \'\'\' ``` Example ```python # Sample graph represented with an adjacency list: graph = { 0: [(1, 4), (2, 1)], 1: [(0, 4), (2, 2), (3, 5)], 2: [(0, 1), (1, 2), (3, 8)], 3: [(1, 5), (2, 8)] } start_vertex = 0 # Expected output is a dictionary representing the shortest distances from start_vertex: # {0: 0, 1: 3, 2: 1, 3: 8} print(dijkstra_shortest_path(graph, start_vertex)) ``` Constraints - The number of vertices in the graph is between 2 and 1000. - The graph edges have positive integer weights. - The start vertex exists in the graph. Detailed Description 1. **Graph Representation**: The graph is provided as an adjacency list, where each key is a vertex and the value is a list of tuples representing the neighboring vertex and the weight of the edge to that neighbor. 2. **Heap-based Dijkstra\'s Algorithm**: Implement the algorithm using a min-heap to ensure efficient extraction and update of distances. 3. **Handling Edge Cases**: Ensure to handle scenarios where vertices are not connected. 4. **Output**: Return a dictionary where each key is a vertex and the value represents the shortest distance from the start vertex to that vertex. Good luck, and focus on ensuring your min-heap operations are optimal to handle larger graphs efficiently!","solution":"import heapq from typing import Dict, List, Tuple def dijkstra_shortest_path(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]: Implements Dijkstra\'s algorithm to find the shortest path from start to all other vertices. :param graph: A dictionary where the key is a vertex and the value is a list of tuples (neighbor, weight). :param start: The starting vertex for Dijkstra\'s algorithm. :return: A dictionary where the key is a vertex and the value is the shortest distance from the start vertex. # Create a priority queue for the min-heap min_heap = [(0, start)] # (distance, node) # Distances dictionary, starting with infinity for all vertices except the start distances = {vertex: float(\'inf\') for vertex in graph} distances[start] = 0 while min_heap: current_distance, current_vertex = heapq.heappop(min_heap) # Nodes can get added to the priority queue multiple times. We only process a vertex the first time we remove it from the queue if current_distance > distances[current_vertex]: continue # Explore neighbors for neighbor, weight in graph[current_vertex]: distance = current_distance + weight # Only consider this new path if it\'s better if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(min_heap, (distance, neighbor)) return distances"},{"question":"# Problem Description You are tasked with implementing a simple state machine for a vending machine that dispenses snacks. Follow the guidelines below to code the necessary functionality. # Input and Output **Function Signature**: ```python class VendingMachine: def __init__(self): pass def insert_coin(self, amount: float) -> None: pass def select_snack(self, snack: str) -> str: pass def get_change(self) -> float: pass ``` **Methods**: 1. `__init__`: Initializes the vending machine. It should set the initial amount of inserted money to zero and define the available snacks with their prices. 2. `insert_coin`: Takes a float `amount` representing the money inserted by the user. 3. `select_snack`: Takes a string `snack` which represents the snack selected by the user. It should return a message indicating whether the snack has been dispensed or not based on the amount of money inserted. 4. `get_change`: Returns the remaining change after a snack is dispensed or if the user requests change. # Constraints * Snack names and prices should be predefined within the class (e.g., \\"Chips\\" for 1.25, \\"Candy\\" for 0.75). * The inserted amount cannot be negative. * The `select_snack` method should verify there is enough money inserted for the snack chosen. # Example ```python vending_machine = VendingMachine() vending_machine.insert_coin(1.00) print(vending_machine.select_snack(\\"Candy\\")) # Output: \\"Dispensing Candy\\" print(vending_machine.get_change()) # Output: 0.25 vending_machine.insert_coin(0.50) print(vending_machine.select_snack(\\"Chips\\")) # Output: \\"Insufficient funds\\" vending_machine.insert_coin(1.00) print(vending_machine.select_snack(\\"Chips\\")) # Output: \\"Dispensing Chips\\" print(vending_machine.get_change()) # Output: 0.25 ``` # Task Implement the `VendingMachine` class with methods to insert coins, select snacks, and get change, ensuring proper validation and handling of the given constraints and edge cases.","solution":"class VendingMachine: def __init__(self): self.balance = 0.0 self.snacks = { \\"Chips\\": 1.25, \\"Candy\\": 0.75, \\"Soda\\": 1.00, \\"Gum\\": 0.50 } def insert_coin(self, amount: float) -> None: if amount < 0: raise ValueError(\\"Cannot insert a negative amount\\") self.balance += amount def select_snack(self, snack: str) -> str: if snack not in self.snacks: return \\"Snack not available\\" cost = self.snacks[snack] if self.balance >= cost: self.balance -= cost return f\\"Dispensing {snack}\\" else: return \\"Insufficient funds\\" def get_change(self) -> float: change = self.balance self.balance = 0.0 return change"},{"question":"# Question: Generate Binary Sequence of Ones Implement a function that generates a binary sequence filled with a specified number of \'1\'s and no \'0\'. The function should accept an integer input that represents the number of \'1\'s in the binary sequence and return the corresponding binary number in string format. Function Signature ```python def generate_binary_ones_sequence(count: int) -> str: pass ``` # Input * `count` (int): A positive integer ( (1 leq count leq 32) ) # Output * A string representing a binary number composed entirely of `count` \'1\'s. # Constraints 1. The input will always be a positive integer. 2. The result should be a valid binary string composed entirely of \'1\'s. # Example ```python assert generate_binary_ones_sequence(1) == \\"1\\" assert generate_binary_ones_sequence(5) == \\"11111\\" assert generate_binary_ones_sequence(16) == \\"1111111111111111\\" assert generate_binary_ones_sequence(32) == \\"11111111111111111111111111111111\\" ``` # Scenario You are working on a digital signal processing system where you have to generate test signals consisting of a specific number of consecutive \'1\' bits. Implement the `generate_binary_ones_sequence()` function to meet this requirement by generating the desired binary sequence. # Implementation Guidelines * Ensure that the solution efficiently constructs the binary string without iteration for each \'1\' bit. * Consider the maximum possible input size for performance efficiency.","solution":"def generate_binary_ones_sequence(count: int) -> str: Generates a binary sequence filled with a specific number of \'1\'s. :param count: Number of \'1\'s in the binary sequence. :return: A string representing a binary number composed entirely of \'1\'s. return \'1\' * count"},{"question":"**Problem Statement:** Write a function `balance_brackets(expression: str) -> bool` that determines if the parentheses, square brackets, and curly braces in a string are balanced and properly nested. The function should ignore all non-bracket characters. # Input: - A string `expression` containing any characters, including parentheses `()`, square brackets `[]`, and curly braces `{}`. # Output: - A boolean value `True` if the brackets in the string are balanced, `False` otherwise. # Constraints: - The function should handle strings up to 10^6 characters long efficiently. - Ensure the implementation uses an optimal approach in terms of time and space complexity. # Examples: ```python >>> balance_brackets(\'(a[b]c{d}e)\') True >>> balance_brackets(\'((ab[cd){ef}]\') False >>> balance_brackets(\'{[a](b)c}\') True >>> balance_brackets(\'([)]\') False >>> balance_brackets(\'((()))\') True ```","solution":"def balance_brackets(expression: str) -> bool: Determines if the parentheses, square brackets, and curly braces in a string are balanced and properly nested. :param expression: str - The input string containing any characters, including brackets. :return: bool - True if the brackets in the string are balanced, False otherwise. stack = [] matching_bracket = {\')\': \'(\', \']\': \'[\', \'}\': \'{\'} for char in expression: if char in matching_bracket.values(): stack.append(char) elif char in matching_bracket.keys(): if not stack or stack.pop() != matching_bracket[char]: return False return len(stack) == 0"},{"question":"# Matrix Path Finder Given a matrix of integers, write a function to find a path from the top-left corner to the bottom-right corner such that the sum of the integers along the path is minimized. You can only move either right or down at any point in time. Function Signature ```python def min_path_sum(matrix: List[List[int]]) -> int: pass ``` Input * `matrix` (List[List[int]]): A 2D list of integers representing the matrix. Output * Returns an integer representing the minimum sum along the path. Example ```python def min_path_sum(matrix: List[List[int]]) -> int: # ... implementation ... matrix = [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] print(min_path_sum(matrix)) # Output: 7 ``` Constraints * The matrix will have at least one element and at most 100x100 elements. * `1 <= matrix[i][j] <= 100` Requirements * Efficiently compute the minimum path sum using a dynamic programming approach. * Consider edge cases where the matrix dimensions are 1xN or Nx1. Notes * The function should handle matrices of varying sizes and structures. * Ensure the implementation is optimal for large matrices up to 100x100 dimensions.","solution":"from typing import List def min_path_sum(matrix: List[List[int]]) -> int: if not matrix or not matrix[0]: return 0 rows = len(matrix) cols = len(matrix[0]) # Initialize a DP table with the same dimensions as the matrix dp = [[0] * cols for _ in range(rows)] # Base case dp[0][0] = matrix[0][0] # Fill the first row (only move right) for j in range(1, cols): dp[0][j] = dp[0][j - 1] + matrix[0][j] # Fill the first column (only move down) for i in range(1, rows): dp[i][0] = dp[i - 1][0] + matrix[i][0] # Fill the rest of the dp table for i in range(1, rows): for j in range(1, cols): dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + matrix[i][j] return dp[-1][-1]"},{"question":"Question: Efficient Subarray Sum Evaluation # Background You are in charge of developing a new performance analytics feature for a data analysis tool. One of the tasks involves evaluating sums of subarrays in an efficient manner. Specifically, you need to support operations that can quickly compute the sum of elements for given subarrays. # Task Implement a Python class `SubarraySum` that allows: 1. **Initialization**: To populate the main data array. 2. **Prefix Sum Calculation**: To preprocess prefix sums for efficient subarray sum evaluation. 3. **Subarray Sum Query**: To support queries that return the sum of elements in a subarray from index `i` to `j`. # Specifications 1. **Initialization**: - The class should be initialized with a list of integers representing the main data array. 2. **Prefix Sum Calculation**: - Preprocess the prefix sums of the array during initialization. - Use an iterative approach to compute prefix sums in a single pass. 3. **Subarray Sum Query**: - Implement a method `subarray_sum(i, j)` that returns the sum of elements in the subarray from index `i` to `j` (inclusive). # Requirements - **Input**: - The `SubarraySum` class should be initialized with a list of integers `data`. - The method `subarray_sum` takes two integers `i` and `j` representing the start and end indices of the subarray. - **Output**: - The `subarray_sum` method should return an integer representing the sum of elements from index `i` to `j`. - **Constraints**: - Consider arrays with up to 10,000 elements. - Ensure the subarray sum queries are handled efficiently after initialization. - Handle cases where `i` and `j` are within valid indices of the array. # Example ```python # Example usage: data = [1, -2, 3, 10, -4, 7, 2, -5] sas = SubarraySum(data) print(sas.subarray_sum(0, 2)) # Output: 2 (1 + (-2) + 3) print(sas.subarray_sum(2, 5)) # Output: 16 (3 + 10 + (-4) + 7) print(sas.subarray_sum(0, 7)) # Output: 12 (sum of the entire array) ``` # Evaluation - Ensure your code initializes and precomputes prefix sums in an efficient manner. - Correctly evaluate subarray sum queries using the prefix sums. - Maintain optimal performance for large data arrays.","solution":"class SubarraySum: def __init__(self, data): self.data = data self.prefix_sums = self._compute_prefix_sums(data) def _compute_prefix_sums(self, data): prefix_sums = [0] * (len(data) + 1) for i in range(len(data)): prefix_sums[i + 1] = prefix_sums[i] + data[i] return prefix_sums def subarray_sum(self, i, j): return self.prefix_sums[j + 1] - self.prefix_sums[i]"},{"question":"# Problem Statement: You have been asked to write a program that simulates a text editor\'s undo-redo functionality. The editor can perform three operations: insert a character at the end of the current text, delete the last character, and undo/redo previous operations. Your task is to implement functions to handle these operations efficiently. # Function Signature: ```python class TextEditor: def __init__(self): Initialize your data structure here. def insert(self, char: str) -> None: Insert a character at the end of the current text. :param char: Character to be inserted. :return: None def delete(self) -> None: Delete the last character from the current text. :return: None def undo(self) -> None: Undo the last operation. :return: None def redo(self) -> None: Redo the last undone operation. :return: None def get_text(self) -> str: Returns the current text after all operations. :return: Current text as a string. ``` # Input: The class will handle specific operations through its methods: * `insert(char: str)`: Insert a character at the end of the current text. * `delete()`: Delete the last character from the current text. * `undo()`: Undo the last operation. This could be an insert or delete operation. * `redo()`: Redo the last undone operation. This could be an insert or delete operation. * `get_text() -> str`: Returns the current text after all operations. # Constraints: 1. The operations `insert`, `delete`, `undo`, `redo` should be done in constant time O(1). 2. The character input to the `insert` method will always be a single alphabetic character. 3. Assume there would be at most `10^6` operations in total, including `insert`, `delete`, `undo`, and `redo`. # Example: ```python editor = TextEditor() editor.insert(\\"a\\") editor.insert(\\"b\\") editor.insert(\\"c\\") print(editor.get_text()) # Output: \\"abc\\" editor.delete() print(editor.get_text()) # Output: \\"ab\\" editor.undo() print(editor.get_text()) # Output: \\"abc\\" editor.undo() print(editor.get_text()) # Output: \\"ab\\" editor.redo() print(editor.get_text()) # Output: \\"abc\\" editor.insert(\\"d\\") print(editor.get_text()) # Output: \\"abcd\\" editor.undo() editor.undo() editor.undo() print(editor.get_text()) # Output: \\"a\\" editor.redo() print(editor.get_text()) # Output: \\"ab\\" editor.redo() print(editor.get_text()) # Output: \\"abc\\" ``` # Instructions: * Implement the class `TextEditor` and its methods to handle the described operations. * Use appropriate data structures to ensure that operations are efficient and within the constraints. * Ensure that your solution passes the given examples and meets the constraints.","solution":"class TextEditor: def __init__(self): Initialize the data structure here. self.text = [] self.history = [] self.redo_stack = [] def insert(self, char: str) -> None: Insert a character at the end of the current text. :param char: Character to be inserted. :return: None self.text.append(char) self.history.append((\'insert\', char)) self.redo_stack = [] # Clear redo stack after new operation def delete(self) -> None: Delete the last character from the current text. :return: None if self.text: removed_char = self.text.pop() self.history.append((\'delete\', removed_char)) self.redo_stack = [] # Clear redo stack after new operation def undo(self) -> None: Undo the last operation. :return: None if self.history: last_action = self.history.pop() if last_action[0] == \'insert\': self.text.pop() elif last_action[0] == \'delete\': self.text.append(last_action[1]) self.redo_stack.append(last_action) def redo(self) -> None: Redo the last undone operation. :return: None if self.redo_stack: last_undone_action = self.redo_stack.pop() if last_undone_action[0] == \'insert\': self.text.append(last_undone_action[1]) elif last_undone_action[0] == \'delete\': self.text.pop() self.history.append(last_undone_action) def get_text(self) -> str: Returns the current text after all operations. :return: Current text as a string. return \'\'.join(self.text)"},{"question":"# Scenario You are working on a file system simulation where you need to represent a directory structure. Each directory can contain multiple files and subdirectories. Each file has a name and a size, and each directory has a name and can contain files and other directories. # Task Implement a class `Directory` and a class `File` that allow you to create a directory structure and perform the following operations: 1. **Add a file to a directory.** 2. **Add a subdirectory to a directory.** 3. **Calculate the total size of a directory.** # Method Requirements - `Directory.add_file(file: File) -> None`: Adds a file to the directory. - `Directory.add_subdirectory(directory: \'Directory\') -> None`: Adds a subdirectory to the directory. - `Directory.total_size() -> int`: Computes the total size of the directory including all files and subdirectories within it. # Input and Output Formats 1. **Input**: - No specific input format; interactions occur through method calls. 2. **Output**: - No specific output format; outputs are the result of method calls and should adhere to the requirements specified. # Constraints 1. The file system structure does not contain circular references (a subdirectory cannot be its own ancestor). 2. Each file has a unique name within its directory. 3. Directories and files have names containing only alphanumeric characters and underscores. 4. The total size calculation should account for nested subdirectories accurately. # Example ```python class File: def __init__(self, name: str, size: int) -> None: self.name = name self.size = size class Directory: def __init__(self, name: str) -> None: self.name = name self.files = [] self.subdirectories = [] def add_file(self, file: File) -> None: self.files.append(file) def add_subdirectory(self, directory: \'Directory\') -> None: self.subdirectories.append(directory) def total_size(self) -> int: total = sum(file.size for file in self.files) for subdir in self.subdirectories: total += subdir.total_size() return total # Example usage file1 = File(\\"file1.txt\\", 100) file2 = File(\\"file2.txt\\", 200) subdir1 = Directory(\\"subdir1\\") subdir1.add_file(file1) main_dir = Directory(\\"main_dir\\") main_dir.add_file(file2) main_dir.add_subdirectory(subdir1) assert main_dir.total_size() == 300 file3 = File(\\"file3.txt\\", 50) subdir2 = Directory(\\"subdir2\\") subdir2.add_file(file3) main_dir.add_subdirectory(subdir2) assert main_dir.total_size() == 350 ``` Make sure to handle edge cases such as a directory with no files, a directory with only files, and a directory with deeply nested subdirectories.","solution":"class File: def __init__(self, name: str, size: int) -> None: self.name = name self.size = size class Directory: def __init__(self, name: str) -> None: self.name = name self.files = [] self.subdirectories = [] def add_file(self, file: File) -> None: self.files.append(file) def add_subdirectory(self, directory: \'Directory\') -> None: self.subdirectories.append(directory) def total_size(self) -> int: total = sum(file.size for file in self.files) for subdir in self.subdirectories: total += subdir.total_size() return total"},{"question":"# Coding Assessment Question You are tasked with writing a Python function that processes a list of given date strings, formats them into a standard representation, and sorts them in chronological order. **Function Description:** Write a function `process_and_sort_dates(dates: List[str]) -> List[str]` that processes a list of date strings, formats them into `YYYY-MM-DD` format, and returns a list of the formatted dates sorted in chronological order. Input: * `dates` (List[str]): A list of date strings. The dates may be in various formats such as: - \\"DD/MM/YYYY\\" - \\"MM-DD-YYYY\\" - \\"YYYY.MM.DD\\" Output: * A list of strings, each representing a date formatted as `YYYY-MM-DD` in ascending chronological order. Formatting Guidelines: * Convert each input date string into `YYYY-MM-DD` format. * Sort the dates in ascending order (from the earliest to the latest date). Example: For an input list like this: ``` dates = [ \\"25/12/2020\\", \\"01-01-2021\\", \\"2020.11.20\\" ] ``` The output should be: ``` [ \\"2020-11-20\\", \\"2020-12-25\\", \\"2021-01-01\\" ] ``` **Constraints:** * You may assume all input date strings are valid dates. * You must use only standard Python libraries such as `datetime` and `re`. # Additional Requirements: * Write helper functions if needed to handle specific date format conversions. * Ensure the function handles all specified formats and edge cases gracefully.","solution":"from typing import List from datetime import datetime def convert_to_standard_date_format(date_str: str) -> str: Converts a date string in a specific format to the standard YYYY-MM-DD format. for fmt in (\\"%d/%m/%Y\\", \\"%m-%d-%Y\\", \\"%Y.%m.%d\\"): try: return datetime.strptime(date_str, fmt).strftime(\'%Y-%m-%d\') except ValueError: continue raise ValueError(f\\"Date format for \'{date_str}\' is not supported.\\") def process_and_sort_dates(dates: List[str]) -> List[str]: Processes a list of date strings, formats them into \'YYYY-MM-DD\' format, and returns the dates sorted in chronological order. formatted_dates = [convert_to_standard_date_format(date) for date in dates] sorted_dates = sorted(formatted_dates) return sorted_dates"},{"question":"**Context:** Dynamic Programming is a powerful technique for solving optimization and combinatorial problems by breaking them down into simpler subproblems. One classic problem is the \\"Minimum Path Sum\\" problem, where you need to find a path in a grid that minimizes the sum of the numbers along the path. **Question:** Write a function `min_path_sum(grid: List[List[int]]) -> int` that calculates the minimum path sum from the top-left corner to the bottom-right corner of a `grid`. You can only move either down or right at any point in time. **Expected Input and Output:** * **Input:** A 2D list of integers `grid` where `grid[i][j]` represents the cost to be paid at cell `(i, j)`. For example: ```python grid = [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] ``` * **Output:** An integer representing the minimum path sum from the top-left to the bottom-right corner. For the example above, the output should be `7`. **Function Signature:** ```python from typing import List def min_path_sum(grid: List[List[int]]) -> int: pass ``` **Constraints:** - The grid dimensions will be at most `100 x 100`. - All grid values will be non-negative integers. Ensure that your solution is efficient in terms of both time and space complexity to handle the constraints.","solution":"from typing import List def min_path_sum(grid: List[List[int]]) -> int: if not grid or not grid[0]: return 0 rows, cols = len(grid), len(grid[0]) for r in range(rows): for c in range(cols): if r == 0 and c == 0: continue # starting point, no previous cell to add elif r == 0: grid[r][c] += grid[r][c-1] # only can come from the left elif c == 0: grid[r][c] += grid[r-1][c] # only can come from above else: grid[r][c] += min(grid[r-1][c], grid[r][c-1]) # can come from left or above return grid[rows-1][cols-1]"},{"question":"# Coding Assessment Question Scenario: You\'re working on a text processing application and you need to implement a complex string manipulation task. The task involves converting a given string into its \\"zigzag\\" pattern on a given number of rows. The string is written in a zigzag pattern across the rows and then read row by row. Task: Write a Python function that takes a string and an integer number of rows, and then converts the string into the “zigzag” pattern on the given number of rows. Function Signature: ```python def convert_to_zigzag(s: str, num_rows: int) -> str: ``` Input: * `s`: A string (1 ≤ len(s) ≤ 1000) * `num_rows`: An integer (1 ≤ num_rows ≤ 1000) Output: * A string representing the input string written in a zigzag pattern across the specified number of rows and then read row by row. Examples: ```python assert convert_to_zigzag(\\"PAYPALISHIRING\\", 3) == \\"PAHNAPLSIIGYIR\\" assert convert_to_zigzag(\\"PAYPALISHIRING\\", 4) == \\"PINALSIGYAHRPI\\" assert convert_to_zigzag(\\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\", 5) == \\"AIQYBHJPRXZCGKOSWDFLNTVEMU\\" assert convert_to_zigzag(\\"HELLO\\", 1) == \\"HELLO\\" assert convert_to_zigzag(\\"HELLO\\", 2) == \\"HLOEL\\" ``` Notes: - The zigzag pattern typically begins on the first row and proceeds to the last row before climbing back up to the first row. - Ensure your function handles edge cases such as `num_rows` being 1, where the pattern should just be the original string. ```python def convert_to_zigzag(s: str, num_rows: int) -> str: if num_rows == 1 or num_rows >= len(s): return s rows = [\'\' for _ in range(min(num_rows, len(s)))] cur_row = 0 going_down = False for char in s: rows[cur_row] += char if cur_row == 0 or cur_row == num_rows - 1: going_down = not going_down cur_row += 1 if going_down else -1 return \'\'.join(rows) ```","solution":"def convert_to_zigzag(s: str, num_rows: int) -> str: if num_rows == 1 or num_rows >= len(s): return s rows = [\'\' for _ in range(min(num_rows, len(s)))] cur_row = 0 going_down = False for char in s: rows[cur_row] += char if cur_row == 0 or cur_row == num_rows - 1: going_down = not going_down cur_row += (1 if going_down else -1) return \'\'.join(rows)"},{"question":"# Coding Assessment Question Scenario: Parallel Matrix Multiplication You are tasked with optimizing a matrix multiplication operation to leverage the parallel processing capabilities of a multi-core processor to speed up computations. Specifically, you will implement a parallel matrix multiplication function that uses multiple processes to compute the product of two matrices concurrently. Task Implement a function `parallel_matrix_multiplication(A, B)` that multiplies two matrices using parallel processing. The function should return the resultant matrix. Function Signature ```python def parallel_matrix_multiplication(A: List[List[int]], B: List[List[int]]) -> List[List[int]]: Multiplies two matrices A and B in parallel. Parameters: A (List[List[int]]): A 2D list representing matrix A. B (List[List[int]]): A 2D list representing matrix B. Returns: List[List[int]]: The resultant matrix product of A and B. ``` Input - `A`: A 2D list representing matrix A with dimensions m x n (1 <= m, n <= 500) - `B`: A 2D list representing matrix B with dimensions n x p (1 <= p <= 500) Output - A 2D list representing the matrix product of A and B with dimensions m x p. Constraints - You must use multiprocessing to achieve parallelism. - Ensure proper synchronization between processes to avoid race conditions. - Handle edge cases such as matrices with only one row or column, and matrices with all zero elements. - Each matrix will consist of integers. Example ```python from typing import List # Example function call A = [ [1, 2], [3, 4] ] B = [ [5, 6], [7, 8] ] result_matrix = parallel_matrix_multiplication(A, B) print(result_matrix) # Output: [[19, 22], [43, 50]] ``` Guidelines - Utilize Python\'s multiprocessing library to create and manage processes for computing each element of the resultant matrix concurrently. - Implement a strategy for dividing the computation work among multiple processes to effectively utilize the available cores. - Focus on ensuring the correctness of matrix dimensions and the resultant product\'s dimensions. - Implement necessary error handling to manage invalid inputs or any potential issues during parallel execution. Your function should exhibit robust performance improvements over a serial implementation by leveraging parallel processing, especially for larger matrices.","solution":"from typing import List from multiprocessing import Pool def parallel_worker(args): A_row, B, col_idx = args value = sum(A_row[k] * B[k][col_idx] for k in range(len(A_row))) return value def parallel_matrix_multiplication(A: List[List[int]], B: List[List[int]]) -> List[List[int]]: if not A or not B or not A[0] or not B[0]: return [] m, n = len(A), len(A[0]) n_b, p = len(B), len(B[0]) if n != n_b: raise ValueError(\\"Number of columns in A must be equal to the number of rows in B.\\") # Initialize result matrix result = [[0] * p for _ in range(m)] # Prepare arguments for parallel workers pool_args = [] for i in range(m): for j in range(p): pool_args.append((A[i], B, j)) # Use multiprocessing Pool for parallel computation with Pool() as pool: results = pool.map(parallel_worker, pool_args) # Fill the result matrix for idx, value in enumerate(results): i = idx // p j = idx % p result[i][j] = value return result"},{"question":"# Coding Question: String Pattern Anagram Check Objective: You are given two strings and your task is to determine if one string is an anagram of a substring of the other. Write a function to achieve this. Problem Statement: Write a function `is_anagram_of_substring(s1: str, s2: str) -> bool` that takes two strings as input. The function should return `True` if `s1` is an anagram of any substring of `s2`, and `False` otherwise. Function Signature: ```python def is_anagram_of_substring(s1: str, s2: str) -> bool: pass ``` Expected Input and Output: - **Input**: Two strings (e.g., \\"abc\\", \\"cbadfe\\") - **Output**: A boolean indicating whether the first string is an anagram of any substring of the second string. Constraints: - All characters in both strings are lowercase English letters. - The length of `s1` will be at most the length of `s2`. Example: ```python >>> is_anagram_of_substring(\\"abc\\", \\"cbadfe\\") True >>> is_anagram_of_substring(\\"abb\\", \\"cbadfe\\") False >>> is_anagram_of_substring(\\"ab\\", \\"cbadfe\\") True ``` Additional Requirements: - Ensure that the function is efficient with a time complexity of O(n), where n is the length of the longer string. Hint: - Use a sliding window and hash map technique to achieve the desired time complexity.","solution":"def is_anagram_of_substring(s1: str, s2: str) -> bool: from collections import Counter if len(s1) > len(s2): return False s1_counter = Counter(s1) window_counter = Counter(s2[:len(s1)]) if s1_counter == window_counter: return True for i in range(len(s1), len(s2)): window_counter[s2[i]] += 1 window_counter[s2[i - len(s1)]] -= 1 if window_counter[s2[i - len(s1)]] == 0: del window_counter[s2[i - len(s1)]] if s1_counter == window_counter: return True return False"},{"question":"# Coding Assessment Question: Sequence Operations on a Circular Buffer Context You are working with a circular buffer, a data structure that uses a single, fixed-size buffer as if it were connected end-to-end. Your task is to implement utilities to handle sequences of integers in this buffer. Task Write two functions: 1. A function `advance_sequence(buffer: list[int], start_idx: int, steps: int) -> int` that advances a start index in the buffer by a given number of steps, wrapping around if necessary. 2. A function `get_subsequence(buffer: list[int], start_idx: int, length: int) -> list[int]` that extracts a subsequence from the buffer starting from a given index and having a specified length, wrapping around if necessary. Specifications * `advance_sequence(buffer: list[int], start_idx: int, steps: int) -> int` * **Input**: * `buffer`: A circular buffer represented as a list of integers. * `start_idx`: An integer representing the start index. * `steps`: An integer representing the number of steps to advance. * **Output**: * An integer representing the new index after advancing. * `get_subsequence(buffer: list[int], start_idx: int, length: int) -> list[int]` * **Input**: * `buffer`: A circular buffer represented as a list of integers. * `start_idx`: An integer representing the start index. * `length`: An integer representing the desired length of the subsequence. * **Output**: * A list of integers containing the extracted subsequence. Constraints * The `buffer` list is non-empty. * `start_idx` is a valid index within the `buffer`. * `steps` and `length` are non-negative integers. Examples * Example 1: ```python buffer = [1, 2, 3, 4, 5] start_idx = 2 steps = 3 result = advance_sequence(buffer, start_idx, steps) assert result == 0 # Because (2 + 3) % 5 = 0 start_idx = 0 length = 3 result = get_subsequence(buffer, start_idx, length) assert result == [1, 2, 3] ``` * Example 2: ```python buffer = [10, 20, 30, 40] start_idx = 1 steps = 5 result = advance_sequence(buffer, start_idx, steps) assert result == 2 # Because (1 + 5) % 4 = 2 start_idx = 3 length = 5 result = get_subsequence(buffer, start_idx, length) assert result == [40, 10, 20, 30, 40] ``` Notes * Ensure that advancing or extracting handles wrap-around cases correctly, maintaining the circular nature of the buffer. * Handle edge cases such as `steps` or `length` being zero gracefully.","solution":"def advance_sequence(buffer, start_idx, steps): Advances the start index in the buffer by a given number of steps, wrapping around if necessary. Parameters: buffer (list of int): The circular buffer represented as a list of integers. start_idx (int): The start index. steps (int): The number of steps to advance. Returns: int: The new index after advancing. buffer_length = len(buffer) return (start_idx + steps) % buffer_length def get_subsequence(buffer, start_idx, length): Extracts a subsequence from the buffer starting from a given index and having a specified length, wrapping around if necessary. Parameters: buffer (list of int): The circular buffer represented as a list of integers. start_idx (int): The start index. length (int): The desired length of the subsequence. Returns: list of int: The extracted subsequence. buffer_length = len(buffer) subsequence = [] for i in range(length): subsequence.append(buffer[(start_idx + i) % buffer_length]) return subsequence"},{"question":"# Task: Parsing Nested JSON-like Data Structures You are tasked with developing a function that can parse and flatten a nested JSON-like data structure. The function should take a nested dictionary with arbitrary depth and produce a flat dictionary where nested keys are concatenated into a single key, separated by a period (`.`). # Problem Description Write a function `flatten_json(nested_dict: dict) -> dict` that takes a nested dictionary and returns a dictionary with flattened keys. # Input - **nested_dict**: A dictionary that can contain nested dictionaries. # Output - Return a dictionary with flattened keys. # Constraints - The input dictionary can be empty. - Keys in the input dictionary are strings. - Values in the input dictionary are either dictionaries or single data values (e.g., integers, strings). # Example ```python nested_dict = { \\"user\\": { \\"name\\": \\"Alice\\", \\"address\\": { \\"city\\": \\"Wonderland\\", \\"zip\\": \\"12345\\" } }, \\"type\\": \\"admin\\" } flatten_json(nested_dict) # Output: { # \\"user.name\\": \\"Alice\\", # \\"user.address.city\\": \\"Wonderland\\", # \\"user.address.zip\\": \\"12345\\", # \\"type\\": \\"admin\\" # } nested_dict = { \\"a\\": { \\"b\\": { \\"c\\": { \\"d\\": \\"e\\" } } } } flatten_json(nested_dict) # Output: { # \\"a.b.c.d\\": \\"e\\" # } ``` # Guidelines - Ensure that the function is efficient and runs within acceptable time complexity. - Handle edge cases such as the input being an empty dictionary, or the dictionary only containing top-level keys without nesting. - The solution should not use any external libraries, only standard Python libraries.","solution":"def flatten_json(nested_dict, parent_key=\'\', sep=\'.\'): Flatten a nested dictionary. Args: nested_dict (dict): The dictionary to flatten. parent_key (str): The base key string used for recursion. sep (str): The separator between keys. Returns: dict: A new dictionary with flattened keys. items = [] for k, v in nested_dict.items(): new_key = f\\"{parent_key}{sep}{k}\\" if parent_key else k if isinstance(v, dict): items.extend(flatten_json(v, new_key, sep=sep).items()) else: items.append((new_key, v)) return dict(items)"},{"question":"# Palindrome Permutation Checker As part of a text analysis toolkit, your task is to implement a function that checks whether any permutation of a given string can form a palindrome. This involves checking the frequency of characters and determining if their arrangement allows for palindrome formation. Your solution should efficiently handle typical string operations using Python\'s collections. Function Signature ```python def can_form_palindrome(s: str) -> bool: ``` Input * `s` - A string consisting of lowercase letters. Output * Returns `True` if any permutation of the string can form a palindrome, otherwise returns `False`. Constraints * The function should only accept string inputs with lowercase letters; if the input consists of other characters or is not a string, raise a `TypeError`. * The solution should efficiently manage string operations, aiming for O(n) time complexity and O(n) space complexity, where n is the length of the string. # Example Scenarios ```python >>> can_form_palindrome(\\"civic\\") True >>> can_form_palindrome(\\"ivicc\\") True >>> can_form_palindrome(\\"hello\\") False >>> can_form_palindrome(\\"aabbccd\\") True >>> can_form_palindrome(12345) Traceback (most recent call last): ... TypeError: can_form_palindrome() only accepts strings ``` # Guidelines 1. Validate the input to ensure it is a string containing only lowercase letters. 2. Count the frequency of each character in the string. 3. Determine if the character counts allow for a palindrome permutation, taking into account: - A palindrome can have at most one character with an odd count. 4. Ensure the implementation is efficient in terms of both time and space complexity. Happy coding!","solution":"from collections import Counter def can_form_palindrome(s: str) -> bool: Checks if any permutation of the given string can form a palindrome. :param s: A string consisting of lowercase letters. :return: True if any permutation can form a palindrome, otherwise False. if not isinstance(s, str) or any(not c.islower() for c in s): raise TypeError(\\"can_form_palindrome() only accepts strings with lowercase letters\\") char_count = Counter(s) odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # A palindrome can have at most one character with an odd count return odd_count <= 1"},{"question":"# Problem Statement Given an array of n integers where n > 1, you need to find the maximum product of any two distinct elements in the array. You will implement two functions: 1. A function to determine the two highest numbers in the array. 2. A function to calculate the maximum product using the two highest numbers. # Function Specifications Function 1: `find_two_highest` - **Input**: A list of integers `num_list`. - **Output**: A tuple containing the two highest integers in the list. ```python def find_two_highest(num_list: list[int]) -> tuple[int, int]: pass ``` Function 2: `max_product` - **Input**: 1. The output tuple of `find_two_highest` function, which contains the two highest integers. - **Output**: The product of the two highest integers. ```python def max_product(highest_values: tuple[int, int]) -> int: pass ``` # Constraints - The input list will have a minimum length of 2 and a maximum length of 100,000. - The elements of the list are integers ranging from -10^6 to 10^6. # Example ```python num_list = [3, 5, 1, 7, 9] highest_values = find_two_highest(num_list) print(highest_values) # Expected output: (9, 7) print(max_product(highest_values)) # Expected output: 63 num_list = [-1, -2, -3, -4, -5] highest_values = find_two_highest(num_list) print(highest_values) # Expected output: (-1, -2) print(max_product(highest_values)) # Expected output: 2 num_list = [10, -10, 5, -5] highest_values = find_two_highest(num_list) print(highest_values) # Expected output: (10, 5) print(max_product(highest_values)) # Expected output: 50 ``` # Notes - Ensure your solution can handle both positive and negative integers and return the correct product. - Consider edge cases such as where the list contains both maximal positive and negative numbers. - Optimize your solution to handle the largest input sizes efficiently, avoiding a quadratic time complexity solution.","solution":"def find_two_highest(num_list): Given a list of integers, returns a tuple containing the two highest integers. highest = second_highest = float(\'-inf\') for num in num_list: if num > highest: second_highest = highest highest = num elif num > second_highest: second_highest = num return (highest, second_highest) def max_product(highest_values): Given a tuple of two integers, returns the product of these two integers. return highest_values[0] * highest_values[1]"},{"question":"# Matrix Rotation Checker **Problem Statement**: You need to implement a function that determines if a given matrix can be rotated 90 degrees clockwise multiple times to become equal to another given matrix. Your task is to write a function `can_rotate_to_match` to check if the transformation is possible. **Function Signature**: ```python def can_rotate_to_match(mat1: List[List[int]], mat2: List[List[int]]) -> bool: pass ``` **Requirements**: 1. The function should validate that both matrices are square (number of rows equals the number of columns). 2. The function should attempt to rotate `mat1` by 90 degrees clockwise up to three times and check if at any rotation it matches `mat2`. 3. If the matrices have different dimensions, the function should return `False`. **Input**: * `mat1` (List[List[int]]): The matrix to be rotated. * `mat2` (List[List[int]]): The target matrix to match after rotation. **Output**: * `bool`: `True` if `mat1` can be rotated to match `mat2`, otherwise `False`. **Constraints**: * Both `mat1` and `mat2` are list of lists of integers. * The dimensions of `mat1` and `mat2` are guaranteed to be valid square matrices. **Examples**: ```python >>> can_rotate_to_match([[1, 2], [3, 4]], [[3, 1], [4, 2]]) False >>> can_rotate_to_match([[1, 2], [3, 4]], [[3, 1], [4, 2]]) True >>> can_rotate_to_match([[1, 2, 3], [4, 5, 6], [7, 8, 9]], [[7, 4, 1], [8, 5, 2], [9, 6, 3]]) True >>> can_rotate_to_match([[1]], [[1]]) True >>> can_rotate_to_match([[1, 2], [3, 4]], [[2, 4], [1, 3]]) False ``` **Note**: - Ensure to rotate the matrix in place to manage space complexity efficiently. - Test the function with various square matrices of different dimensions to ensure its correctness.","solution":"def rotate_90_clockwise(mat): Rotate the given matrix 90 degrees clockwise. n = len(mat) return [[mat[n - j - 1][i] for j in range(n)] for i in range(n)] def can_rotate_to_match(mat1, mat2): Returns whether mat1 can be rotated to match mat2. if len(mat1) != len(mat2) or len(mat1[0]) != len(mat2[0]): return False rotated_mat = mat1 for _ in range(4): if rotated_mat == mat2: return True rotated_mat = rotate_90_clockwise(rotated_mat) return False"},{"question":"# Image Processing using K-means Clustering **Context**: You are asked to perform image compression using the K-means clustering algorithm. K-means clustering is an unsupervised learning algorithm that partitions data into K number of clusters. By representing the image using fewer colors than the original, we can achieve image compression. # Your Task: Implement the necessary components to compress the image using K-means clustering: 1. **Initialize Centroids**: Write a function to initialize K centroids randomly from the image\'s pixel values. 2. **Assign Clusters**: Write a function that assigns each pixel to the nearest centroid. 3. **Update Centroids**: Write a function to update the centroids by calculating the mean of all pixels assigned to each cluster. 4. **K-means Algorithm**: Integrate these components into the main K-means algorithm to compress the image and return the compressed image. # Function Signatures: ```python import numpy as np def initialize_centroids(image: np.ndarray, k: int) -> np.ndarray: pass def assign_clusters(image: np.ndarray, centroids: np.ndarray) -> np.ndarray: pass def update_centroids(image: np.ndarray, clusters: np.ndarray, k: int) -> np.ndarray: pass def kmeans_compression(image: np.ndarray, k: int, iterations: int) -> np.ndarray: pass ``` # Constraints: 1. The input image will be a NumPy array of shape (height, width, 3) with pixel values ranging from 0 to 255. 2. The number of clusters `k` will be a positive integer between 1 and 256. 3. The maximum number of iterations will be 100. # Input/Output Format: - **Input**: - `image`: A NumPy array representing the image to be compressed. - `k`: Number of clusters (desired number of colors). - `iterations`: Number of iterations for the K-means algorithm. - **Output**: - A NumPy array representing the compressed image. # Example: ```python import cv2 import numpy as np from matplotlib import pyplot as plt image = cv2.imread(\'path_to_image.jpg\') image_rgb = cv2.cvtColor(image, cv2.COLOR_BGR2RGB) compressed_image = kmeans_compression(image_rgb, k=16, iterations=10) plt.imshow(compressed_image) plt.show() ``` # Details: - **initialize_centroids**: Randomly pick K unique pixels from the image as the initial centroids. - **assign_clusters**: Compute the distance between each pixel and each centroid, and assign each pixel to the nearest centroid\'s cluster. - **update_centroids**: Calculate the mean of all pixels assigned to each centroid to update its value. - **kmeans_compression**: Implement the main loop of the K-means algorithm, repeating the assign and update steps for a given number of iterations. Return the image with pixels replaced by their respective cluster centroids. # Notes: - Consider using Euclidean distance for pixel distance calculation. - The compressed image should retain the same dimensions as the original image but with pixels mapped to the nearest centroids.","solution":"import numpy as np def initialize_centroids(image: np.ndarray, k: int) -> np.ndarray: Randomly pick k unique pixels from the image as the initial centroids. :param image: np.ndarray :param k: int :return: np.ndarray flat_image = image.reshape(-1, 3) indices = np.random.choice(flat_image.shape[0], k, replace=False) centroids = flat_image[indices] return centroids def assign_clusters(image: np.ndarray, centroids: np.ndarray) -> np.ndarray: Assign each pixel in the image to the nearest centroid. :param image: np.ndarray :param centroids: np.ndarray :return: np.ndarray flat_image = image.reshape(-1, 3) distances = np.linalg.norm(flat_image[:, np.newaxis] - centroids, axis=2) clusters = np.argmin(distances, axis=1) return clusters def update_centroids(image: np.ndarray, clusters: np.ndarray, k: int) -> np.ndarray: Update centroids to the mean of all pixels assigned to each cluster. :param image: np.ndarray :param clusters: np.ndarray :param k: int :return: np.ndarray flat_image = image.reshape(-1, 3) new_centroids = np.array([flat_image[clusters == i].mean(axis=0) for i in range(k)]) return new_centroids def kmeans_compression(image: np.ndarray, k: int, iterations: int) -> np.ndarray: Perform K-means clustering to compress the image. :param image: np.ndarray :param k: int :param iterations: int :return: np.ndarray centroids = initialize_centroids(image, k) clusters = None for _ in range(iterations): clusters = assign_clusters(image, centroids) centroids = update_centroids(image, clusters, k) flat_image = image.reshape(-1, 3) compressed_image_flat = centroids[clusters].astype(np.uint8) compressed_image = compressed_image_flat.reshape(image.shape) return compressed_image"},{"question":"```markdown # Sorting Student Scores **Context**: You are developing a system to manage student records for a school. One of the features of this system is to sort student scores to easily identify the highest and lowest performing students. You have been asked to implement a function that sorts a list of student scores and returns the sorted list along with the highest and lowest scores. **Task**: Implement the `sort_student_scores` function that takes a list of student scores (integers) and returns a tuple containing the sorted list of scores, the highest score, and the lowest score. Ensure that the function is efficient and handles edge cases effectively. # Function Signature: ```python def sort_student_scores(scores: List[int]) -> Tuple[List[int], int, int]: scores: a list of integers representing student scores returns: a tuple containing the sorted list of scores, the highest score, and the lowest score ``` # Constraints: 1. The input list of scores is guaranteed to contain at least one score. 2. The scores are integers and can range from 0 to 100. 3. Your solution should aim for a time complexity of O(n log n). # Expected Input/Output: - **Input**: A list of integers representing student scores. - **Output**: A tuple containing the sorted list of scores, the highest score, and the lowest score. **Examples**: ```python # Example 1 scores = [88, 92, 78, 65, 99, 85] sorted_scores, highest_score, lowest_score = sort_student_scores(scores) # Expected output: ([65, 78, 85, 88, 92, 99], 99, 65) # Example 2 scores = [55] sorted_scores, highest_score, lowest_score = sort_student_scores(scores) # Expected output: ([55], 55, 55) ``` # Additional Notes: - The function should handle cases with minimum and maximum boundary values effectively. - Consider edge cases, such as lists with uniform scores or very small lists. - Focus on the readability and efficiency of your algorithm. ```","solution":"from typing import List, Tuple def sort_student_scores(scores: List[int]) -> Tuple[List[int], int, int]: Sorts the student scores and returns a tuple containing the sorted list, the highest score, and the lowest score. :param scores: A list of integers representing student scores. :returns: A tuple containing the sorted list of scores, the highest score, and the lowest score. sorted_scores = sorted(scores) highest_score = sorted_scores[-1] lowest_score = sorted_scores[0] return sorted_scores, highest_score, lowest_score"},{"question":"# Sorting Logs by Timestamp You are given a list of logs, where each log is a string containing a timestamp and a message. The timestamp is in the format \'YYYY-MM-DD HH:MM:SS\'. Your task is to implement a function that sorts these logs based on their timestamps in ascending order. Task Implement a method named `sort_logs` that takes a list of logs as input and returns the logs sorted by their timestamps. Input * The `sort_logs` method should take a single argument which is a list of strings, where each string represents a log with a timestamp. Output * The method should return a list of logs sorted by their timestamps in ascending order. Constraints * Each log is guaranteed to have a valid timestamp in the format \'YYYY-MM-DD HH:MM:SS\'. * The list of logs may be empty. Examples Consider the following list of logs: ``` [ \\"2022-01-05 13:45:00 Log message C\\", \\"2021-11-25 09:15:10 Log message A\\", \\"2023-07-12 16:30:50 Log message B\\" ] ``` Performing `sort_logs(logs)` should return: ``` [ \\"2021-11-25 09:15:10 Log message A\\", \\"2022-01-05 13:45:00 Log message C\\", \\"2023-07-12 16:30:50 Log message B\\" ] ``` Implementation ```python def sort_logs(logs: list[str]) -> list[str]: Sorts the logs based on their timestamps in ascending order. Parameters: - logs: (list[str]) A list of log messages with timestamps. Returns: - list[str]: A sorted list of log messages by timestamps. # TODO: Implement this method pass ``` Additional Information Consider using Python\'s built-in sorting functions and understand how to extract and compare the timestamp parts efficiently. Ensure the output preserves the content of logs accurately apart from their ordering.","solution":"def sort_logs(logs): Sorts the logs based on their timestamps in ascending order. Parameters: - logs: (list[str]) A list of log messages with timestamps. Returns: - list[str]: A sorted list of log messages by timestamps. return sorted(logs, key=lambda log: log.split(\' \', 2)[:2])"},{"question":"# Context You are developing a financial application that requires calculating the minimum number of coins needed to make a specific amount of money. The denominations of the coins are variable and provided as input. # Task Implement a function `min_coins(coins: list, amount: int) -> int` that calculates the minimum number of coins needed to make up a given amount. If the amount cannot be made up by any combination of the given coins, return -1. # Input and Output * **Input**: * `coins` (list): A list of integers representing the denominations of the available coins. * `amount` (int): The target amount of money. * **Output**: * An integer representing the minimum number of coins needed to make up the given amount, or -1 if it is not possible. # Constraints * 1 <= len(coins) <= 10^2 * 1 <= coins[i] <= 10^4 * 0 <= amount <= 10^4 # Example ```python coins1 = [1, 2, 5] amount1 = 11 print(min_coins(coins1, amount1)) # Expected Output: # 3 (11 = 5 + 5 + 1) coins2 = [2] amount2 = 3 print(min_coins(coins2, amount2)) # Expected Output: # -1 (it\'s not possible to make 3 with denomination 2) coins3 = [1] amount3 = 0 print(min_coins(coins3, amount3)) # Expected Output: # 0 (no coins are needed to make 0) ``` # Performance Requirements The function should be designed to handle up to the maximum constraints efficiently, with a time complexity of approximately O(amount * len(coins)). # Note You do not need to handle input validation. Assume all input provided will be valid according to the constraints.","solution":"def min_coins(coins, amount): Returns the minimum number of coins needed to make the given amount. If the amount cannot be made up by any combination of the given coins, returns -1. # Initialize the dp array where dp[i] will store the minimum number of coins for amount i. dp = [float(\'inf\')] * (amount + 1) dp[0] = 0 # Base case: 0 coins needed to make amount 0. for coin in coins: for x in range(coin, amount + 1): dp[x] = min(dp[x], dp[x - coin] + 1) return dp[amount] if dp[amount] != float(\'inf\') else -1"},{"question":"# Matrix Transposition and Row Summation Context You are given a matrix (a 2D list) of integers, and you need to perform two tasks: transpose the matrix and calculate the sum of elements in each row of the original matrix. Task 1. Implement a function, `transpose_matrix(matrix: list) -> list` that returns the transposed version of the matrix. 2. Implement a function, `row_sums(matrix: list) -> list` that returns the sum of elements of each row in the original matrix. Specifications 1. You have two functions to implement: ```python def transpose_matrix(matrix: list) -> list: Transpose the provided matrix. Args: matrix: A list of lists of integers Returns: list: The transposed matrix Raises: ValueError: If input matrix is invalid def row_sums(matrix: list) -> list: Return the sum of each row in the matrix. Args: matrix: A list of lists of integers Returns: list: A list with the sum of elements of each row Raises: ValueError: If input matrix is invalid ``` Input and Output Formats * **Input**: * `matrix` - A list of lists, where each inner list contains integers, representing rows of the matrix. * The input matrix is guaranteed to be non-empty and rectangular (i.e., all rows have the same length). * **Output**: * For `transpose_matrix`: Return the transposed matrix as a list of lists. * For `row_sums`: Return a list of integers, where each integer is the sum of the corresponding row in the original matrix. Constraints * Each row in the matrix is non-empty, and all rows have the same length. Examples ```python assert transpose_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == [[1, 4, 7], [2, 5, 8], [3, 6, 9]] assert transpose_matrix([[1, 2], [3, 4], [5, 6]]) == [[1, 3, 5], [2, 4, 6]] assert row_sums([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == [6, 15, 24] assert row_sums([[2, 4], [6, 8], [10, 12]]) == [6, 14, 22] ```","solution":"def transpose_matrix(matrix): Transpose the provided matrix. Args: matrix: A list of lists of integers Returns: list: The transposed matrix Raises: ValueError: If input matrix is invalid if not matrix or not all(isinstance(row, list) for row in matrix): raise ValueError(\\"Invalid matrix\\") return [list(row) for row in zip(*matrix)] def row_sums(matrix): Return the sum of each row in the matrix. Args: matrix: A list of lists of integers Returns: list: A list with the sum of elements of each row Raises: ValueError: If input matrix is invalid if not matrix or not all(isinstance(row, list) for row in matrix): raise ValueError(\\"Invalid matrix\\") return [sum(row) for row in matrix]"},{"question":"# Matrix Diagonal Sum Calculation **Context**: Matrix operations are foundational in various fields including computer graphics, machine learning, and scientific computing. One common task is to calculate sums of elements along the diagonals of a matrix. In this exercise, you will implement functions to compute the sum of primary and secondary diagonals of a square matrix. **Task**: 1. Implement a function to compute the sum of the primary diagonal of a square matrix. 2. Implement a function to compute the sum of the secondary diagonal of a square matrix. 3. Write a function that returns both sums in a tuple. **Requirements**: 1. **Function 1**: `primary_diagonal_sum(matrix: list[list[int]]) -> int` - Compute the sum of the primary diagonal: elements where the row index equals the column index. - Raise `ValueError` if the input is not a square matrix. 2. **Function 2**: `secondary_diagonal_sum(matrix: list[list[int]]) -> int` - Compute the sum of the secondary diagonal: elements where the row index and column index sum up to the size of the matrix minus 1. - Raise `ValueError` if the input is not a square matrix. 3. **Function 3**: `diagonal_sums(matrix: list[list[int]]) -> tuple[int, int]` - Return a tuple containing the sums of the primary and secondary diagonals. **Constraints**: - The matrix will have dimensions ( n times n ), where ( 1 leq n leq 500 ). - All matrix elements will be integers within the range ([ -10^3, 10^3 ]). ```python def primary_diagonal_sum(matrix: list[list[int]]) -> int: n = len(matrix) if any(len(row) != n for row in matrix): raise ValueError(\\"Input must be a square matrix.\\") return sum(matrix[i][i] for i in range(n)) def secondary_diagonal_sum(matrix: list[list[int]]) -> int: n = len(matrix) if any(len(row) != n for row in matrix): raise ValueError(\\"Input must be a square matrix.\\") return sum(matrix[i][n - 1 - i] for i in range(n)) def diagonal_sums(matrix: list[list[int]]) -> tuple[int, int]: return (primary_diagonal_sum(matrix), secondary_diagonal_sum(matrix)) # Example Usage: # matrix = [ # [1, 2, 3], # [4, 5, 6], # [7, 8, 9] # ] # print(diagonal_sums(matrix)) # Output: (15, 15) ``` This question will test the candidate\'s ability to manipulate and analyze the structure of two-dimensional arrays, handle exceptions, and compute values based on specific matrix properties. The complexity aligns with the original questions by requiring careful implementation and validation of inputs.","solution":"def primary_diagonal_sum(matrix: list[list[int]]) -> int: Computes the sum of the primary diagonal of a square matrix. Args: matrix (list[list[int]]): A square matrix. Returns: int: The sum of the primary diagonal. Raises: ValueError: If the input is not a square matrix. n = len(matrix) if any(len(row) != n for row in matrix): raise ValueError(\\"Input must be a square matrix.\\") return sum(matrix[i][i] for i in range(n)) def secondary_diagonal_sum(matrix: list[list[int]]) -> int: Computes the sum of the secondary diagonal of a square matrix. Args: matrix (list[list[int]]): A square matrix. Returns: int: The sum of the secondary diagonal. Raises: ValueError: If the input is not a square matrix. n = len(matrix) if any(len(row) != n for row in matrix): raise ValueError(\\"Input must be a square matrix.\\") return sum(matrix[i][n - 1 - i] for i in range(n)) def diagonal_sums(matrix: list[list[int]]) -> tuple[int, int]: Computes the sums of the primary and secondary diagonals of a square matrix. Args: matrix (list[list[int]]): A square matrix. Returns: tuple[int, int]: A tuple containing the sums of primary and secondary diagonals. Raises: ValueError: If the input is not a square matrix. return (primary_diagonal_sum(matrix), secondary_diagonal_sum(matrix))"},{"question":"# Coding Assessment Question: Find the Intersection of Two Arrays **Context**: In many computing scenarios, you may need to compare two datasets and find the common elements. Finding the intersection of two arrays is a common problem that can be efficiently solved using various algorithms. **Objective**: Write a function `intersection(nums1: List[int], nums2: List[int]) -> List[int]` that finds the intersection of two arrays and returns it as a list. Each element in the result must be unique. **Function Signature**: ```python def intersection(nums1: List[int], nums2: List[int]) -> List[int]: pass ``` # Input: - Two lists of integers `nums1` and `nums2` where `1 <= len(nums1), len(nums2) <= 1000` and `-1000 <= nums1[i], nums2[i] <= 1000`. # Output: - A list of integers representing the intersection of `nums1` and `nums2`. The order of output does not matter. # Constraints: - The resulting list should not contain duplicate elements. - You can solve the problem using any efficient algorithm that maintains the desired constraints. # Examples: ```python >>> intersection([1, 2, 2, 1], [2, 2]) [2] >>> intersection([4, 9, 5], [9, 4, 9, 8, 4]) [4, 9] >>> intersection([1, 2, 2, 3], [3, 3, 3, 4, 1]) [1, 3] >>> intersection([1, 2, 3, 4], [5, 6, 7, 8]) [] ``` # Additional Notes: 1. Consider using data structures that can handle frequent membership checks efficiently, such as sets. 2. The order of elements in the output list does not matter. 3. Pay attention to edge cases such as one or both lists being empty. In these cases, the function should return an empty list.","solution":"from typing import List def intersection(nums1: List[int], nums2: List[int]) -> List[int]: Finds the intersection of two lists of integers, nums1 and nums2. Each element in the result must be unique and the order of elements in the result does not matter. # Convert lists to sets to remove duplicates and use set intersection operation set1 = set(nums1) set2 = set(nums2) # Find the intersection of two sets result = set1.intersection(set2) # Convert the result back to a list and return return list(result)"},{"question":"# Problem: Implement a Custom Sorting Function You have been given the task to implement a custom sorting function that sorts a list of strings based on the frequency of characters in each string. If two strings have the same character frequency, they should be sorted alphabetically. Write a function `custom_sort(strings: List[str]) -> List[str]`. 1. The function should take a list of strings `strings` as input and: * Count the frequency of each character in each string. * Sort the strings by the character frequency in descending order. * If two strings have the same character frequency, sort them alphabetically in ascending order. * Return the sorted list of strings. Function Signature ```python def custom_sort(strings: List[str]) -> List[str]: pass ``` Example ```python # Example usage and expected results input_list = [\\"apple\\", \\"banana\\", \\"pear\\", \\"grape\\"] sorted_list = custom_sort(input_list) print(sorted_list) # Output should be [\'banana\', \'apple\', \'grape\', \'pear\'] ``` Constraints * The `strings` list will contain between 1 and 1000 strings. * Each string will have a length between 1 and 100 characters. * Strings will contain only lowercase alphabetic characters.","solution":"from typing import List from collections import Counter def custom_sort(strings: List[str]) -> List[str]: Sorts a list of strings based on the frequency of characters in each string. If two strings have the same character frequency, they will be sorted alphabetically. :param strings: List of strings to be sorted. :return: List of strings sorted based on character frequency and alphabetically for ties. def char_frequency(s): return sum(Counter(s).values()) return sorted(strings, key=lambda s: (-char_frequency(s), s))"},{"question":"# Objective You need to implement a function that sorts a nearly sorted (or K-sorted) array. # Problem Statement A nearly sorted array is an array where every element is at most `K` positions away from its target position in the sorted array. Given such an array and a positive integer `K`, write a function to sort the array. # Function Signature ```python def sort_k_sorted_array(arr: List[int], k: int) -> List[int]: pass ``` # Input * `arr` (List[int]): The K-sorted array. * `k` (int): The maximum offset by which an element is misplaced. # Output * Return a sorted list of integers. # Constraints * The length of the array `n` is between `1` and `10^5`. * The value of `k` is between `0` and `n-1`. * All elements in `arr` are integers. # Example Example 1 * **Input**: `arr = [3, 2, 1, 5, 4, 7, 6, 5]`, `k = 2` * **Output**: `[1, 2, 3, 4, 5, 5, 6, 7]` Example 2 * **Input**: `arr = [6, 5, 3, 2, 8, 10, 9]`, `k = 3` * **Output**: `[2, 3, 5, 6, 8, 9, 10]` # Additional Notes * Make use of a min-heap to solve the problem efficiently. * Consider the efficiency of maintaining a heap for the sorting process to meet the required performance constraints. * The expected time complexity is `O(n log k)` and space complexity is `O(k)`. # Explanation In Example 1, despite the initial disorder, no element is more than 2 positions away from its target location, and after sorting it gives the output: `[1, 2, 3, 4, 5, 5, 6, 7]`. In Example 2, similarly, no element is more than 3 positions away from its target location, and sorting it gives: `[2, 3, 5, 6, 8, 9, 10]`. Note that the use of a min-heap allows the elements to be placed efficiently and ensures time complexity is maintained within acceptable limits.","solution":"import heapq def sort_k_sorted_array(arr, k): Sorts a nearly sorted (K-sorted) array. Args: arr (List[int]): The K-sorted array. k (int): The maximum offset by which an element is misplaced. Returns: List[int]: The sorted list of integers. heap = [] result = [] # Initially push first k+1 elements to the heap for i in range(k+1): if i < len(arr): heapq.heappush(heap, arr[i]) # For remaining elements in array for i in range(k+1, len(arr)): # Append the smallest element from heap to result result.append(heapq.heappop(heap)) # Push the current element to heap heapq.heappush(heap, arr[i]) # Pop all elements from the heap and add to result while heap: result.append(heapq.heappop(heap)) return result"},{"question":"You are given an urban area with numerous intersections, each represented as nodes. The intersections are connected by roads, represented as edges. Each road has a specific travel time associated with it. Your task is to find the shortest travel time from a given starting intersection to all other intersections using Dijkstra\'s algorithm. **Task**: Calculate the shortest travel times between the starting intersection and all other intersections in the area. **Function Signature**: ```python def shortest_travel_times(n: int, roads: List[Tuple[int, int, int]], start: int) -> List[int]: Args: n : int : Number of intersections in the urban area (0 ≤ n ≤ 10^4). roads : List[Tuple[int, int, int]] : A list of tuples where each tuple (a, b, t) signifies a road from intersection a to intersection b with travel time t. start : int : The starting intersection. Returns: List[int] : List of the shortest travel times from the starting intersection to all other intersections. ``` # Input * Integer `n` representing the number of intersections. * List `roads` of roads [(a, b, t), ...] where `a` and `b` are intersections and `t` is the travel time (0 ≤ a, b < n, 1 ≤ t ≤ 100). * Integer `start` representing the starting intersection (0 ≤ start < n). # Output * List of integers where each integer denotes the shortest travel time from the starting intersection to each intersection `i`. # Example ```python n = 5 roads = [(0, 1, 2), (0, 2, 1), (1, 2, 4), (1, 3, 7), (2, 3, 1), (3, 4, 3)] start = 0 print(shortest_travel_times(5, roads, 0)) # Output: [0, 2, 1, 2, 5] ``` # Explanation - From intersection 0 to 1, the shortest travel time is 2 (via road 0-1). - From intersection 0 to 2, the shortest travel time is 1 (via road 0-2). - From intersection 0 to 3, the shortest travel time is 2 (via roads 0-2 and 2-3). - From intersection 0 to 4, the shortest travel time is 5 (via roads 0-2, 2-3, and 3-4). # Constraints * Use an efficient implementation of Dijkstra\'s algorithm with priority queue to avoid exceeding time limits.","solution":"from typing import List, Tuple import heapq def shortest_travel_times(n: int, roads: List[Tuple[int, int, int]], start: int) -> List[int]: # Create the graph as an adjacency list graph = [[] for _ in range(n)] for u, v, t in roads: graph[u].append((v, t)) graph[v].append((u, t)) # assuming bidirectional travel # Initialize the distance array with infinity dist = [float(\'inf\')] * n dist[start] = 0 # Priority queue to process nodes pq = [(0, start)] # (distance, node) while pq: current_dist, u = heapq.heappop(pq) # If a shorter path to u is already found, skip this node if current_dist > dist[u]: continue # Explore neighbors for v, weight in graph[u]: distance_through_u = current_dist + weight if distance_through_u < dist[v]: dist[v] = distance_through_u heapq.heappush(pq, (distance_through_u, v)) # Replace infinity values with -1 to indicate unreachable nodes return [d if d != float(\'inf\') else -1 for d in dist]"},{"question":"# Question: Implement k-Nearest Neighbors (k-NN) Classification Your task is to create a class `KNNClassifier` that implements a basic k-nearest neighbors algorithm for classification. The k-NN algorithm is a simple, non-parametric method used for classification and regression. In this question, you will implement the classification version, which assigns the class of the new sample based on the majority class among its k nearest neighbors. Requirements: 1. Implement the class `KNNClassifier` with the following methods: - `__init__(self, k=3)`: Initializes the classifier with the number of neighbors `k` (default to 3). - `fit(self, X, y)`: Fits the classifier using the training data. - `predict(self, X)`: Predicts the class labels for the provided test data. 2. Use the Euclidean distance to measure the distance between data points. 3. If there is a tie among the nearest neighbors for the majority class, choose the class of the nearest neighbor in the tie. 4. Validate the input parameters and provide meaningful error messages for invalid inputs. Input: - Training data: A list of ndarrays representing the feature vectors (X) of the training data. - Training labels: An ndarray of integers representing the class labels (y) for the training data. - Test data: A list of ndarrays representing the feature vectors (X) of the new data points to classify. Output: - Predicted classes: A list of integers representing the predicted class labels for the test data. Constraints: - The training data (X) and test data (X) inputs can each have up to 10,000 observations with up to 100 features per observation. - The value of `k` is guaranteed to be less than or equal to the number of training observations. # Example: ```python import numpy as np class KNNClassifier: def __init__(self, k=3): self.k = k def fit(self, X, y): self.X = X self.y = y def predict(self, X): def euclidean_distance(a, b): return np.sqrt(np.sum((a - b) ** 2)) predictions = [] for test_point in X: distances = [euclidean_distance(test_point, train_point) for train_point in self.X] neighbors_indices = np.argsort(distances)[:self.k] neighbors_labels = [self.y[i] for i in neighbors_indices] predicted_label = max(neighbors_labels, key=neighbors_labels.count) predictions.append(predicted_label) return predictions # Example usage: # Initialize the KNN classifier with k=3 knn = KNNClassifier(k=3) # Training data observations = [ np.asarray([0, 1]), np.asarray([0, 2]), np.asarray([1, 1]), np.asarray([1, 2]) ] classes = np.asarray([1, 1, 2, 2]) # Fit the classifier with training data knn.fit(observations, classes) # Predict the class for new data points test_data = [ np.asarray([0, 1.5]), np.asarray([1, 1.5]) ] print(knn.predict(test_data)) # Expected output: [1, 2] (example predictions) ``` Ensure your code meets these requirements and passes the provided example tests.","solution":"import numpy as np from collections import Counter class KNNClassifier: def __init__(self, k=3): if not isinstance(k, int) or k <= 0: raise ValueError(\\"k must be a positive integer\\") self.k = k self.fitted = False def fit(self, X, y): if len(X) != len(y): raise ValueError(\\"Number of training data points and labels must be the same.\\") if len(X) == 0: raise ValueError(\\"Training data cannot be empty.\\") self.X = np.array(X) self.y = np.array(y) self.fitted = True def predict(self, X): if not self.fitted: raise ValueError(\\"The classifier has not been fitted with training data.\\") if len(X) == 0: raise ValueError(\\"No input data to predict.\\") X = np.array(X) def euclidean_distance(a, b): return np.sqrt(np.sum((a - b) ** 2)) predictions = [] for test_point in X: distances = [euclidean_distance(test_point, train_point) for train_point in self.X] neighbors_indices = np.argsort(distances)[:self.k] neighbors_labels = [self.y[i] for i in neighbors_indices] most_common = Counter(neighbors_labels).most_common() most_common.sort(key=lambda x: (x[1], -x[0]), reverse=True) predictions.append(most_common[0][0]) return predictions"},{"question":"# Problem Statement You are tasked with writing a function that determines whether a given binary tree is a valid Binary Search Tree (BST). A binary tree is considered a BST if for every node, all nodes in the left subtree are less than the node’s value, and all nodes in the right subtree are greater than the node’s value. # Function Signature ```python def is_valid_bst(root: TreeNode) -> bool: pass ``` # Input * `root (TreeNode)`: The root of the binary tree where `TreeNode` is a class defined as: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` # Output * Returns a boolean indicating whether the binary tree is a valid BST. # Constraints * The number of nodes in the tree is in the range [0, 1000]. * `TreeNode.val` is an integer within the range `[-10^4, 10^4]`. # Requirements * Implement the function using a depth-first search (DFS) approach. * You should not use any built-in functions that directly perform the necessary checks for you. # Example ```python # Example 1: # Input: root = [2,1,3] # 2 # / # 1 3 # Output: True # Explanation: The left subtree of \'2\' is [1] which is less than 2, and # the right subtree of \'2\' is [3] which is greater than 2. # Example 2: # Input: root = [5,1,4,null,null,3,6] # 5 # / # 1 4 # / # 3 6 # Output: False # Explanation: The left subtree of \'4\' is [3] which is less than 4, but 3 is not greater than 5, # thus it violates the BST properties. assert is_valid_bst(TreeNode(2, TreeNode(1), TreeNode(3))) == True assert is_valid_bst(TreeNode(5, TreeNode(1), TreeNode(4, TreeNode(3), TreeNode(6)))) == False ```","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_valid_bst(root: TreeNode) -> bool: def validate(node, low=float(\'-inf\'), high=float(\'inf\')): if not node: return True if not (low < node.val < high): return False return validate(node.left, low, node.val) and validate(node.right, node.val, high) return validate(root)"},{"question":"# Context In many algorithms, it’s important to find the smallest or largest subset of elements that maintain certain properties. A common scenario involves finding the k largest or smallest elements in a dataset. This task is designed to assess your ability to efficiently find these subsets. # Task Implement a function `find_k_largest_elements` that finds the k largest elements in an input list. The input list will only contain integers. # Function Signature ```python def find_k_largest_elements(input_list: list[int], k: int) -> list[int]: pass ``` # Input * `input_list` (list): A list of integers. * `k` (int): An integer representing the number of largest elements to find. # Output * A list containing the k largest elements from the input list, sorted in descending order. # Constraints * The function should handle an input list of up to 10^6 elements efficiently. * The value of `k` will be a positive integer and `1 <= k <= len(input_list)`. # Examples ```python assert find_k_largest_elements([3, 1, 5, 12, 2, 11], 3) == [12, 11, 5] assert find_k_largest_elements([9, 4, 7, 1, -2, 6, 5], 2) == [9, 7] assert find_k_largest_elements([20, 10, 30, 50, 40], 1) == [50] assert find_k_largest_elements([4, 4, 4, 4, 4], 3) == [4, 4, 4] assert find_k_largest_elements([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 5) == [10, 9, 8, 7, 6] ```","solution":"import heapq def find_k_largest_elements(input_list: list[int], k: int) -> list[int]: Finds and returns the k largest elements in the input list, sorted in descending order. Parameters: input_list (list): A list of integers. k (int): The number of largest elements to find. Returns: list: A list containing the k largest elements in descending order. # Use a heap to efficiently find the k largest elements k_largest = heapq.nlargest(k, input_list) # Return the largest elements sorted in descending order return sorted(k_largest, reverse=True)"},{"question":"# Fibonacci Sequence Sum **Problem Statement:** The Fibonacci sequence is a series of numbers where the next number is found by adding up the two numbers before it. Starting with 0 and 1, the sequence goes: 0, 1, 1, 2, 3, 5, 8, 13, ... Given a positive integer `n`, determine the sum of the first `n` Fibonacci numbers. **Objective:** Write a function `sum_fibonacci(n)` that takes a positive integer `n` as its parameter and returns the sum of the first `n` Fibonacci numbers. **Function Signature:** ```python def sum_fibonacci(n: int) -> int: pass ``` **Input:** - An integer `n` representing the number of Fibonacci numbers to sum. **Output:** - An integer representing the sum of the first `n` Fibonacci numbers. **Constraints:** - `1 <= n <= 10^6` **Performance Requirements:** - Your algorithm should work efficiently for the given constraint. Example: ```python >>> sum_fibonacci(5) 7 # (0, 1, 1, 2, 3) >>> sum_fibonacci(10) 88 # (0, 1, 1, 2, 3, 5, 8, 13, 21, 34) ``` **Notes:** - Ensure your solution can handle large `n` values efficiently without exhausting memory or computation time. - Consider both iterative and recursive approaches, but focus on achieving optimal performance.","solution":"def sum_fibonacci(n: int) -> int: Returns the sum of the first n Fibonacci numbers. Parameters: n (int): The number of Fibonacci numbers to sum. Returns: int: The sum of the first n Fibonacci numbers. if n <= 0: return 0 fib = [0, 1] sum_fib = 1 # sum of the first 1 Fibonacci numbers (0 + 1) for i in range(2, n): next_fib = fib[-1] + fib[-2] fib.append(next_fib) sum_fib += next_fib return sum_fib if n > 1 else 0"},{"question":"# Question: Implement the Hamming Distance **Scenario:** In information theory and computer science, the Hamming distance between two strings of equal length is the number of positions at which the corresponding symbols are different. The Hamming distance is used in various applications like error detection or correction codes. **Your Task:** Write a Python function `hamming_distance(s1: str, s2: str) -> int` that computes the Hamming distance between two strings of equal length. Your function should validate the input and handle edge cases appropriately. **Function Signature:** ```python def hamming_distance(s1: str, s2: str) -> int: pass ``` **Input and Output:** * **Input:** Two strings `s1` and `s2` of equal length. * **Output:** An integer representing the Hamming distance between `s1` and `s2`. **Constraints:** * The inputs `s1` and `s2` are strings containing only alphanumeric characters. * The lengths of `s1` and `s2` are guaranteed to be equal and at most 1000 characters. **Requirements:** * Ensure that the input strings are of equal length or raise a `ValueError`. * The function should run in O(n) time complexity where `n` is the length of the input strings. * The space complexity should be O(1). **Examples:** ```python assert hamming_distance(\\"karolin\\", \\"kathrin\\") == 3 # \'k\',\'a\' and \'i\' are different in their positions assert hamming_distance(\\"karolin\\", \\"kerstin\\") == 3 # \'a\',\'r\' and \'o\' are different in their positions assert hamming_distance(\\"1011101\\", \\"1001001\\") == 2 # positions 2 and 6 are different assert hamming_distance(\\"2173896\\", \\"2233796\\") == 3 # positions 2, 3 and 4 are different ``` **Performance:** * Your solution should efficiently compare the strings in linear time with respect to their length. * The function should be able to handle edge cases such as strings with zero length (e.g., empty strings). **Tips:** * Utilize a loop to traverse both strings simultaneously while counting the differing corresponding characters. * Remember to validate that the strings have equal lengths before computing the Hamming distance.","solution":"def hamming_distance(s1: str, s2: str) -> int: Calculates the Hamming distance between two strings of equal length. :param s1: First string for comparison. :param s2: Second string for comparison. :return: The Hamming distance (number of differing positions). :raises ValueError: If the input strings are not of equal length. if len(s1) != len(s2): raise ValueError(\\"Input strings must be of equal length\\") # Calculate the Hamming distance return sum(1 for c1, c2 in zip(s1, s2) if c1 != c2)"},{"question":"# Matrix Rotation and Anti-Diagonal Sum **Problem Statement:** You are tasked with implementing two functions based on matrix operations: rotating a matrix by 90 degrees clockwise and calculating the sum of the anti-diagonal elements of a matrix. 1. `rotate_matrix(matrix: List[List[int]]) -> List[List[int]]`: - Rotate a square matrix by 90 degrees in the clockwise direction. - **Input**: A 2D list `matrix` representing a square matrix of size `n x n`. - **Output**: The rotated matrix as a 2D list. 2. `anti_diagonal_sum(matrix: List[List[int]]) -> int`: - Calculate the sum of the anti-diagonal elements of a square matrix. - **Input**: A 2D list `matrix` representing a square matrix of size `n x n`. - **Output**: The sum of the anti-diagonal elements of the matrix. # Function Signature ```python def rotate_matrix(matrix: List[List[int]]) -> List[List[int]]: pass def anti_diagonal_sum(matrix: List[List[int]]) -> int: pass ``` # Constraints - The input matrix is guaranteed to be a square matrix (i.e., the number of rows and columns are equal). - Elements of the matrix will be integers within the range of a 32-bit signed integer. - The size of the matrix, `n`, will be between 1 and 100 inclusive. # Example Input/Output ```python # Example for rotate_matrix matrix1 = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotated_matrix1 = [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] assert rotate_matrix(matrix1) == rotated_matrix1 # Example for anti_diagonal_sum matrix2 = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] anti_diagonal_sum2 = 15 # 3 + 5 + 7 assert anti_diagonal_sum(matrix2) == anti_diagonal_sum2 ``` **Notes:** 1. For the rotate_matrix function, ensure the matrix rotation is performed in-place to optimize space usage if possible. 2. For the anti_diagonal_sum function, handle edge cases such as single element matrices gracefully. 3. Focus on both correctness and efficiency of your solution. **Optional:** Consider also discussing potential improvements or alternative approaches to the matrix rotation technique, such as using auxiliary matrices or different matrix transformation algorithms.","solution":"from typing import List def rotate_matrix(matrix: List[List[int]]) -> List[List[int]]: Rotate a square matrix by 90 degrees clockwise. Args: matrix (List[List[int]]): A square matrix. Returns: List[List[int]]: Rotated matrix. n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse() return matrix def anti_diagonal_sum(matrix: List[List[int]]) -> int: Calculate the sum of the anti-diagonal elements of a square matrix. Args: matrix (List[List[int]]): A square matrix. Returns: int: Sum of the anti-diagonal elements. n = len(matrix) sum_anti_diagonal = sum(matrix[i][n-i-1] for i in range(n)) return sum_anti_diagonal"},{"question":"# Coding Question: Implement a Simplified Blockchain **Objective**: Create a basic implementation of a blockchain with the ability to add blocks containing data. Each block stores data, a timestamp, and a reference to the previous block\'s hash, creating a chain. Implement functionality to add blocks and verify the integrity of the blockchain. Task Description: You need to implement a `SimpleBlockchain` class with: 1. **Initialization**: - Create the genesis block (the first block) with predefined values. 2. **Add Block Method**: - Create a new block with provided data, timestamps, and the hash of the previous block. 3. **Verify Blockchain Method**: - Traverse the blockchain to ensure each block\'s previous hash matches the hash of the actual previous block. - Return whether the chain is valid. Implementation: ```python import hashlib import time class SimpleBlockchain: class Block: def __init__(self, index: int, timestamp: str, data: str, previous_hash: str): self.index = index self.timestamp = timestamp self.data = data self.previous_hash = previous_hash self.hash = self.calculate_hash() def calculate_hash(self) -> str: sha = hashlib.sha256() sha.update(f\\"{self.index}{self.timestamp}{self.data}{self.previous_hash}\\".encode(\'utf-8\')) return sha.hexdigest() def __init__(self): self.chain = [self.create_genesis_block()] def create_genesis_block(self) -> Block: return self.Block(0, str(time.time()), \\"Genesis Block\\", \\"0\\") def add_block(self, data: str) -> None: previous_block = self.chain[-1] new_block = self.Block(len(self.chain), str(time.time()), data, previous_block.hash) self.chain.append(new_block) def verify_blockchain(self) -> bool: for i in range(1, len(self.chain)): current_block = self.chain[i] previous_block = self.chain[i-1] if current_block.previous_hash != previous_block.hash: return False if current_block.hash != current_block.calculate_hash(): return False return True # Example Usage: if __name__ == \\"__main__\\": blockchain = SimpleBlockchain() blockchain.add_block(\\"First block after genesis\\") blockchain.add_block(\\"Second block after genesis\\") print(f\\"Blockchain valid: {blockchain.verify_blockchain()}\\") # Simulate blockchain tampering blockchain.chain[1].data = \\"Tampered block\\" print(f\\"Blockchain valid after tampering: {blockchain.verify_blockchain()}\\") ``` **Constraints**: - Use the `sha256` hashing algorithm from the `hashlib` library. - Ensure the `add_block` method effectively chains blocks using the previous block\'s hash. - The `verify_blockchain` method should efficiently check the chain\'s integrity. **Performance Consideration**: - The time complexity for adding and verifying blocks should be O(n), where n is the number of blocks. - Ensure adding a block and verifying the blockchain are performed promptly for hundreds of blocks.","solution":"import hashlib import time class SimpleBlockchain: class Block: def __init__(self, index: int, timestamp: str, data: str, previous_hash: str): self.index = index self.timestamp = timestamp self.data = data self.previous_hash = previous_hash self.hash = self.calculate_hash() def calculate_hash(self) -> str: sha = hashlib.sha256() sha.update(f\\"{self.index}{self.timestamp}{self.data}{self.previous_hash}\\".encode(\'utf-8\')) return sha.hexdigest() def __init__(self): self.chain = [self.create_genesis_block()] def create_genesis_block(self) -> Block: return self.Block(0, str(time.time()), \\"Genesis Block\\", \\"0\\") def add_block(self, data: str) -> None: previous_block = self.chain[-1] new_block = self.Block(len(self.chain), str(time.time()), data, previous_block.hash) self.chain.append(new_block) def verify_blockchain(self) -> bool: for i in range(1, len(self.chain)): current_block = self.chain[i] previous_block = self.chain[i-1] if current_block.previous_hash != previous_block.hash: return False if current_block.hash != current_block.calculate_hash(): return False return True"},{"question":"# Problem Statement You are required to write a function `calculate_airport_path` that reads a list of flights and determines the shortest path between a start and end airport. Each flight is represented by a tuple containing the start airport code, end airport code, and flight duration in minutes. Your task is to implement Dijkstra\'s algorithm to find the shortest duration path from the start to the end airport. # Function Signature ```python def calculate_airport_path( flights: list[tuple[str, str, int]], start_airport: str, end_airport: str ) -> tuple[int, list[str]]: Calculate the shortest path between two airports using flight data. Parameters: - flights (list[tuple]): A list of flight data where each tuple contains (start_airport, end_airport, duration). - start_airport (str): The IATA code of the starting airport. - end_airport (str): The IATA code of the destination airport. Returns: - tuple: A tuple containing the total duration of the shortest path and the list of airport codes in that path. ``` # Input/Output Examples Input ```python flights = [ (\'JFK\', \'ATL\', 120), (\'ATL\', \'ORD\', 90), (\'ORD\', \'LAX\', 200), (\'JFK\', \'LAX\', 300), (\'JFK\', \'ORD\', 150) ] calculate_airport_path(flights, \'JFK\', \'LAX\') ``` Output ```python (300, [\'JFK\', \'LAX\']) ``` # Constraints and Requirements 1. There will be at most 1000 flights. 2. Each airport code is a unique IATA code and consists of exactly 3 uppercase letters. 3. If there is no path between the start and end airports, return `(float(\'inf\'), [])`. 4. The function should be efficient with a time complexity of O(V + E log V), where V is the number of vertices (airports) and E is the number of edges (flights). 5. Assume the flight durations are positive integers. 6. Use Dijkstra\'s algorithm to calculate the shortest path. # Performance Requirements 1. The function should be able to handle large inputs efficiently, considering up to 1000 flights. 2. Optimize for both time and space complexity by efficiently managing flight connections and distances. # Context This function can be used in travel planning applications, logistics optimization, or navigation systems to find the quickest connectivity between two airports based on available flights.","solution":"import heapq from collections import defaultdict, deque def calculate_airport_path(flights, start_airport, end_airport): # Create the graph from flights data graph = defaultdict(list) for start, end, duration in flights: graph[start].append((end, duration)) # Min-heap priority queue for Dijkstra\'s algorithm pq = [(0, start_airport, [])] # Visited dictionary with the shortest path to each airport found so far visited = {} while pq: current_duration, current_airport, path = heapq.heappop(pq) if current_airport in visited: continue # Add current airport to visited visited[current_airport] = current_duration path = path + [current_airport] # If the end_airport is reached, return the result if current_airport == end_airport: return (current_duration, path) # Explore neighbors for neighbor, duration in graph[current_airport]: if neighbor not in visited: heapq.heappush(pq, (current_duration + duration, neighbor, path)) # If there\'s no valid path return (float(\'inf\'), [])"},{"question":"# Coding Question - Circular Array Rotation **Context**: You are given an array of integers and another integer value that represents the number of times the array needs to be rotated. A single rotation operation moves the last element of the array to the front while shifting all other elements one position to the right. Your task is to rotate the array to the right by the specified number of rotations. **Task**: Implement a function `rotate_array` that rotates the array to the right by the specified number of rotations. **Requirements**: 1. Implement `rotate_array` function: ```python def rotate_array(arr: List[int], rotations: int) -> List[int]: # code to rotate the array ``` 2. The function should modify the array in-place or return the new rotation result efficiently, focusing on optimal time complexity. 3. Optimize the solution to handle edge cases where the number of rotations is larger than the length of the array. **Function Signature:** ```python def rotate_array(arr: List[int], rotations: int) -> List[int]: pass ``` **Example**: ```python arr = [1, 2, 3, 4, 5] rotations = 2 print(rotate_array(arr, rotations)) # Output should be: [4, 5, 1, 2, 3] ``` **Input/Output**: * Input: `arr` - List of integers. `rotations` - Number of times to rotate the array to the right. * Output: The array rotated to the right by the specified number of rotations. **Additional Examples**: ```python arr = [10, 20, 30, 40] rotations = 1 print(rotate_array(arr, rotations)) # Output should be: [40, 10, 20, 30] arr = [99, 88, 77, 66, 55] rotations = 7 print(rotate_array(arr, rotations)) # Output should be: [77, 66, 55, 99, 88] ``` **Constraints**: * Array length, `n`, can be any positive integer ranging from 1 to 10^5. * Values of the array elements can be positive or negative integers. * Rotations will be a non-negative integer. Implement the given function to correctly facilitate the array rotation process efficiently.","solution":"from typing import List def rotate_array(arr: List[int], rotations: int) -> List[int]: Rotates the array to the right by the specified number of rotations. :param arr: List of integers to be rotated. :param rotations: Number of rotations to perform. :return: New list representing rotated array. # Handle the case when the array is empty if not arr: return arr n = len(arr) rotations = rotations % n # Adjust rotations larger than the array length return arr[-rotations:] + arr[:-rotations]"},{"question":"**Context:** You are solving a problem related to analyzing integer sequences and their properties, commonly found in computational number theory problems. **Statement:** A \\"Balanced Series\\" of length n is defined as a sequence of integers where the sum of the first half of the series is equal to the sum of the second half of the series. If the series length n is odd, the middle element is ignored while comparing the sums of the two halves. Given an integer n and a list of n integers, determine whether the given series is balanced. **Function Definition:** You are required to implement the following function: ```python def is_balanced_series(series: List[int]) -> bool: Determines if the given series is balanced. :param series: List[int] - A list of integers representing the series. :return: bool - True if the series is balanced, False otherwise. pass ``` **Constraints:** - The length of the series n will be between 1 and 10^5. - Each element in the series will be between -10^6 and 10^6. - The series list will always have a length (n) provided as input. **Input/Output Format:** - **Input**: A list of integers representing the series. - **Output**: A boolean indicating whether the series is balanced or not. **Examples:** - is_balanced_series([1, 2, 1, 2]) ➞ True (since 1+2 == 1+2) - is_balanced_series([1, 2, 3, 4]) ➞ False (since 1+2 != 3+4) - is_balanced_series([1, 2, 3, 2, 1]) ➞ True (since 1+2 == 2+1, ignoring 3) **Performance Requirements:** - Your solution must efficiently handle the maximum constraints as stated above, both in terms of time and space complexity.","solution":"from typing import List def is_balanced_series(series: List[int]) -> bool: Determines if the given series is balanced. :param series: List[int] - A list of integers representing the series. :return: bool - True if the series is balanced, False otherwise. n = len(series) if n == 1: return True mid = n // 2 if n % 2 == 0: first_half_sum = sum(series[:mid]) second_half_sum = sum(series[mid:]) else: first_half_sum = sum(series[:mid]) second_half_sum = sum(series[mid+1:]) return first_half_sum == second_half_sum"},{"question":"# Question: Write a function to generate the multiplication table for integers. Your task is to create a function `multiplication_table` that takes two integers, `n` and `m`, and returns the multiplication table for the range from `1` to `n` with each value multiplied by `m`. The function should: 1. Validate that `n` and `m` are positive integers. If not, raise a `ValueError` with the message \\"Both n and m must be positive integers.\\" 2. Construct the multiplication table as a 2D list. 3. Each row should represent the multiplication results of integers from 1 to `n`, each multiplied by `m`. **Function Signature**: ```python def multiplication_table(n: int, m: int) -> List[List[int]]: pass ``` **Input**: - `n`: A positive integer representing the range limit. - `m`: A positive integer to be the multiplier. **Output**: - A 2D list representing the multiplication table. **Constraints**: - The values should be positive integers. **Example**: ```python >>> multiplication_table(3, 5) [ [5, 10, 15], [10, 20, 30], [15, 30, 45] ] >>> multiplication_table(4, 2) [ [2, 4, 6, 8], [4, 8, 12, 16], [6, 12, 18, 24], [8, 16, 24, 32] ] ``` *Your task is to implement the `multiplication_table` function according to the described requirements.*","solution":"def multiplication_table(n: int, m: int): Generate the multiplication table for integers from 1 to n with each value multiplied by m. if not isinstance(n, int) or not isinstance(m, int) or n <= 0 or m <= 0: raise ValueError(\\"Both n and m must be positive integers.\\") table = [] for i in range(1, n + 1): row = [] for j in range(1, n + 1): row.append(j * m * i) table.append(row) return table"},{"question":"# Scenario: You are a software developer at a logistics company, and you have been tasked with implementing a feature that helps in sorting and managing packages based on their priority and arrival time. The goal is to ensure that packages with higher priority are processed first, and if two packages have the same priority, the one that arrived earlier is processed first. # Task: Implement a function `priority_sort` that performs the following: 1. Sorts the packages based on their priority in descending order. If two packages have the same priority, they should be sorted by their arrival time in ascending order. 2. Returns the sorted list of package IDs. # Specifications: 1. `priority_sort(packages: list[tuple[int, int, int]]) -> list[int]` - **Parameters**: - `packages (list[tuple[int, int, int])`: A list of tuples, where each tuple contains three integers representing the package ID, priority, and arrival time, respectively. - **Returns**: A list of sorted package IDs. 2. The function should validate and ensure: - Each tuple contains exactly three integers. - The list of packages is not empty. 3. **Output**: - Return the sorted list of package IDs. # Example: ```python packages = [(1, 3, 10), (2, 2, 5), (3, 3, 4), (4, 1, 7)] print(priority_sort(packages)) ``` **Expected Output**: ``` [3, 1, 2, 4] ``` # Constraints: - Assume package IDs, priorities, and arrival times will be positive integers. - Focus on readability, maintainability, and efficiency of the code.","solution":"def priority_sort(packages): Sorts packages based on priority in descending order. If two packages have the same priority, they are sorted based on arrival time in ascending order. Parameters: packages (list of (int, int, int)): A list of tuples where each tuple contains three integers representing the package ID, priority, and arrival time respectively. Returns: list of int: Sorted list of package IDs based on the sorting criteria. if not packages: raise ValueError(\\"The list of packages should not be empty\\") if not all(isinstance(p, tuple) and len(p) == 3 and all(isinstance(x, int) for x in p) for p in packages): raise ValueError(\\"Each element must be a tuple of exactly three integers\\") packages.sort(key=lambda x: (-x[1], x[2])) return [p[0] for p in packages]"},{"question":"# Problem Statement You are designing a backend system for managing membership subscriptions to an online service. Your task is to implement a function that identifies overlapping memberships from the subscription data. # Requirements Write a function `detect_overlaps(subscriptions: List[Tuple[str, str, str]]) -> List[Tuple[str, str]]` that takes a list of subscriptions, each represented by a tuple containing a user\'s username, the start date, and the end date of their subscription period, and returns a list of tuples where each tuple indicates two users whose subscription periods overlap. # Input Format - `subscriptions`: A list of tuples, each containing: - `username`: A string representing the user\'s name (guaranteed unique). - `start_date`: A string in the format `YYYY-MM-DD` representing the start of the subscription. - `end_date`: A string in the format `YYYY-MM-DD` representing the end of the subscription. - The list will have length ( n ) (1 ≤ ( n ) ≤ 10,000). # Output Format - A list of tuples, each containing two usernames whose subscription periods overlap. Each pair should be unique, ignoring order (i.e., if (\\"user1\\", \\"user2\\") is included, (\\"user2\\", \\"user1\\") should not be). # Constraints - The dates are valid Gregorian calendar dates. - Subscription periods are valid (i.e., start_date ≤ end_date). - Dates do not require time zone handling and are in UTC. # Example ```python assert detect_overlaps([ (\\"alice\\", \\"2023-01-01\\", \\"2023-02-01\\"), (\\"bob\\", \\"2023-01-15\\", \\"2023-03-01\\"), (\\"carol\\", \\"2023-02-01\\", \\"2023-02-20\\"), (\\"dave\\", \\"2023-04-01\\", \\"2023-05-01\\") ]) == [(\\"alice\\", \\"bob\\")] assert detect_overlaps([ (\\"emma\\", \\"2023-01-01\\", \\"2023-03-01\\"), (\\"frank\\", \\"2023-02-01\\", \\"2023-04-01\\"), (\\"george\\", \\"2023-03-01\\", \\"2023-05-01\\") ]) == [(\\"emma\\", \\"frank\\"), (\\"frank\\", \\"george\\")] ``` # Notes - Carefully handle edge cases such as no overlapping subscriptions. - Optimize for both time and space complexity as per the provided constraints. - Ensure the function returns unique pairs without duplicates.","solution":"from typing import List, Tuple from datetime import datetime def parse_date(date_str: str) -> datetime: return datetime.strptime(date_str, \\"%Y-%m-%d\\") def detect_overlaps(subscriptions: List[Tuple[str, str, str]]) -> List[Tuple[str, str]]: overlaps = [] n = len(subscriptions) for i in range(n): user1, start1, end1 = subscriptions[i] start1, end1 = parse_date(start1), parse_date(end1) for j in range(i + 1, n): user2, start2, end2 = subscriptions[j] start2, end2 = parse_date(start2), parse_date(end2) if start1 <= end2 and start2 <= end1: overlaps.append((user1, user2)) return overlaps"},{"question":"# Question You are responsible for building a reservation system for a small library. This system needs a function `reserve_book` that manages book reservations. The function accepts three parameters: 1. `member_id` (a string representing the ID of the library member making the reservation), 2. `book_title` (a string representing the title of the book to be reserved), 3. `reservation_list` (a dictionary where keys are book titles and values are lists of member IDs representing the reservation queue for each book). The function should add the `member_id` to the reservation list for the given `book_title`. If the `book_title` does not exist in the `reservation_list`, it should create a new entry for the book with the `member_id` as the first in the reservation queue. If the `member_id` is already in the reservation queue for the `book_title`, the function should raise a `ValueError` with a message indicating that the member has already reserved the book. # Required Function Signature ```python def reserve_book(member_id: str, book_title: str, reservation_list: dict) -> dict: pass ``` # Examples ```python >>> current_reservations = { \\"Python Programming\\": [\\"member1\\", \\"member3\\"], \\"Data Science Essentials\\": [\\"member2\\"] } >>> reserve_book(\\"member4\\", \\"Python Programming\\", current_reservations) { \\"Python Programming\\": [\\"member1\\", \\"member3\\", \\"member4\\"], \\"Data Science Essentials\\": [\\"member2\\"] } >>> reserve_book(\\"member1\\", \\"Data Science Essentials\\", current_reservations) { \\"Python Programming\\": [\\"member1\\", \\"member3\\", \\"member4\\"], \\"Data Science Essentials\\": [\\"member2\\", \\"member1\\"] } >>> reserve_book(\\"member1\\", \\"Python Programming\\", current_reservations) Traceback (most recent call last): ... ValueError: member1 has already reserved the book \'Python Programming\' >>> reserve_book(\\"member2\\", \\"Machine Learning Basics\\", current_reservations) { \\"Python Programming\\": [\\"member1\\", \\"member3\\", \\"member4\\"], \\"Data Science Essentials\\": [\\"member2\\"], \\"Machine Learning Basics\\": [\\"member2\\"] } ``` # Constraints * `member_id` and `book_title` will be non-empty strings. * `reservation_list` will be a valid dictionary where keys are strings (book titles), and values are lists of strings (member IDs). * There should be no duplicates of `member_id` in the reservation queue for each `book_title`. # Notes * Ensure that all edge cases are handled appropriately, including the addition of new books and duplicate reservations. * The function should return the updated `reservation_list` reflecting the new reservation state.","solution":"def reserve_book(member_id: str, book_title: str, reservation_list: dict) -> dict: Adds the member_id to the reservation list for the given book_title. Raises a ValueError if the member_id has already reserved the book. if book_title in reservation_list: if member_id in reservation_list[book_title]: raise ValueError(f\\"{member_id} has already reserved the book \'{book_title}\'\\") else: reservation_list[book_title].append(member_id) else: reservation_list[book_title] = [member_id] return reservation_list"},{"question":"# Question: Data Validation for Unique Values In data processing and analytics, it\'s common to encounter scenarios where you need to ensure that a dataset contains only unique values. This task will help you enforce data integrity by identifying any duplicate values within an input list. **Task:** Write a function called `find_duplicates` that takes a list of integers and returns a set of integers that are duplicated in the list. If there are no duplicates, the function should return an empty set. Your implementation should be efficient in both time and space complexity. **Input Format:** - A list of integers, `data`, which can be of any length up to 10^5. **Output Format:** - A set of integers that contains all duplicated integers found in the input list. If no duplicates are present, return an empty set. **Constraints:** - The list length is between 0 and 100,000. - Each integer in the list is between -10^6 and 10^6. **Performance Requirement:** - Your algorithm should have an average time complexity of O(n). **Example:** ```python >>> find_duplicates([1, 2, 3, 1, 2, 4]) {1, 2} >>> find_duplicates([5, 5, 5, 5, 5]) {5} >>> find_duplicates([1, 2, 3, 4, 5]) set() >>> find_duplicates([]) set() ``` **Context:** Imagine you are working with a large dataset containing user IDs, and you need to ensure that all user IDs are unique before proceeding with further processing. By identifying the duplicates, you can take necessary actions like removing or correcting them to maintain data integrity. Show your capability in data validation by implementing the `find_duplicates` function. Good luck!","solution":"def find_duplicates(data): Takes a list of integers and returns a set of integers that are duplicated in the list. If there are no duplicates, returns an empty set. seen = set() duplicates = set() for num in data: if num in seen: duplicates.add(num) else: seen.add(num) return duplicates"},{"question":"# Coding Question Context As a part of a data analysis task, you are required to determine whether a series of stock prices exhibits a steady increasing or decreasing trend over a specified period. Problem Statement Write a function `is_trending` that takes a list of integers `prices` and a string `trend` as inputs. The string `trend` can either be `\\"increasing\\"` or `\\"decreasing\\"`. The function should return `True` if the prices exhibit the specified trend throughout the list, otherwise return `False`. Function Signature ```python def is_trending(prices: list[int], trend: str) -> bool: pass ``` Input * `prices`: A list of integers representing stock prices over a period. (1 <= len(prices) <= 10^4, 1 <= price <= 10^6) * `trend`: A string which is either `\\"increasing\\"` or `\\"decreasing\\"`. Output * The function should return a boolean value: `True` if the prices exhibit the specified trend, otherwise `False`. Constraints * The input will be such that no parameter validation errors will be thrown (input types are guaranteed). * The length of the list `prices` will be greater than zero. Example ```python assert is_trending([1, 2, 3, 4, 5], \\"increasing\\") == True assert is_trending([5, 4, 3, 2, 1], \\"decreasing\\") == True assert is_trending([1, 3, 2, 4, 5], \\"increasing\\") == False assert is_trending([5, 5, 4, 3, 2], \\"decreasing\\") == True assert is_trending([2, 2, 2, 2], \\"increasing\\") == False assert is_trending([10, 9, 8, 7], \\"increasing\\") == False ```","solution":"def is_trending(prices: list[int], trend: str) -> bool: Checks if the list of prices has the specified trend - either increasing or decreasing. Args: prices (list of int): A list of stock prices. trend (str): A string specifying the trend, either \\"increasing\\" or \\"decreasing\\". Returns: bool: True if the prices exhibit the specified trend, otherwise False. if trend == \\"increasing\\": for i in range(1, len(prices)): if prices[i] < prices[i-1]: return False return True elif trend == \\"decreasing\\": for i in range(1, len(prices)): if prices[i] > prices[i-1]: return False return True else: # This case is technically unnecessary due to the problem constraints return False"},{"question":"# Genetic Sequence Complement In genetics, a DNA string is composed of four types of nucleotides: Adenine (A), Thymine (T), Cytosine (C), and Guanine (G). The complementary nucleotide pairs are: - A pairs with T - T pairs with A - C pairs with G - G pairs with C You are tasked with creating a function that takes a DNA sequence and returns its complementary sequence. Function Requirements Create a function `complementary_sequence(dna: str) -> str:` that: - Takes a string `dna` representing the DNA sequence. - Returns a new string which is the complementary DNA sequence. Input - `dna` (str): A string of uppercase letters \'A\', \'T\', \'C\', and \'G\' representing the DNA sequence. Output - A string representing the complementary DNA sequence. Constraints - The input string will only contain characters \'A\', \'T\', \'C\', and \'G\'. - The length of the input string will be between 1 and 1,000 inclusive. Example Function Calls ```python print(complementary_sequence(\\"ATCG\\")) # Output: \\"TAGC\\" print(complementary_sequence(\\"GATTACA\\")) # Output: \\"CTAATGT\\" print(complementary_sequence(\\"CGTATGC\\")) # Output: \\"GCATACG\\" ``` Implement the `complementary_sequence` function following the specified input and output formats.","solution":"def complementary_sequence(dna: str) -> str: Returns the complementary DNA sequence for a given DNA string. Args: - dna (str): A string of uppercase letters \'A\', \'T\', \'C\', and \'G\' representing the DNA sequence. Returns: - str: A string representing the complementary DNA sequence. complements = {\'A\': \'T\', \'T\': \'A\', \'C\': \'G\', \'G\': \'C\'} return \'\'.join(complements[nucleotide] for nucleotide in dna)"},{"question":"# Text File Word Counter In this assessment, you are required to implement a Python function that reads a text file and counts the occurrences of each word. This function should demonstrate your understanding of file I/O operations, string manipulation, and data structures in Python. Function Signature ```python def word_counter(filepath: str) -> dict: Reads a text file from the given filepath and returns a dictionary with the count of each word in the file. :param filepath: The path to the text file to be processed. :return: A dictionary where keys are words and values are their respective counts. ``` Instructions 1. **File I/O**: Use Python’s built-in functionality to read the file. 2. **Case Insensitivity**: The word counting should be case-insensitive. 3. **Word Definition**: A word is defined as a sequence of characters separated by spaces; ignore punctuation and special characters. 4. **Data Structure**: Utilize a dictionary to store the word counts. Constraints - The function should handle errors gracefully, such as file not found or unreadable file. - The text file can be of any size, so ensure your solution is efficient. Example Input: Assume there is a file `sample.txt` with the following content: ``` Hello world! Hello! ``` ```python filepath = \\"sample.txt\\" word_counts = word_counter(filepath) ``` Expected Output: ```python { \\"hello\\": 2, \\"world\\": 1 } ``` Important Points - Ensure your function correctly handles different edge cases, such as empty files or files with only punctuation. - You should not use any external libraries except for built-in Python libraries.","solution":"import re def word_counter(filepath: str) -> dict: Reads a text file from the given filepath and returns a dictionary with the count of each word in the file. :param filepath: The path to the text file to be processed. :return: A dictionary where keys are words and values are their respective counts. word_count = {} try: with open(filepath, \'r\', encoding=\'utf-8\') as file: for line in file: words = re.findall(r\'bw+b\', line.lower()) for word in words: if word in word_count: word_count[word] += 1 else: word_count[word] = 1 except FileNotFoundError: print(f\\"Error: The file at {filepath} was not found.\\") except Exception as e: print(f\\"Error reading file: {e}\\") return word_count"},{"question":"**Question: String Transformation with Character Shifting** You are given a string `s` consisting of lowercase alphabets and an integer `k`. Your task is to implement a function that returns a new string where each character in the original string is shifted forward in the alphabet by `k` positions. If the shift moves past the end of the alphabet, it wraps around to the beginning. Implement the function `shift_string(s: str, k: int) -> str` that takes a string `s` and an integer `k` as input and returns the transformed string. # Input Format: - `s`: A string consisting of lowercase English alphabets (1 ≤ len(s) ≤ 100). - `k`: An integer (0 ≤ k ≤ 25). # Output Format: - A string representing the shifted version of the input string. # Constraints: - `s` will only contain lowercase English letters. - The transformation should wrap around the alphabet if necessary. # Examples: Example 1: **Input**: ```python s = \\"abc\\" k = 2 ``` **Output**: ```python \\"cde\\" ``` **Explanation**: Each character in \\"abc\\" is shifted forward by 2 positions: \'a\' -> \'c\', \'b\' -> \'d\', \'c\' -> \'e\'. Example 2: **Input**: ```python s = \\"xyz\\" k = 3 ``` **Output**: ```python \\"abc\\" ``` **Explanation**: Each character in \\"xyz\\" is shifted forward by 3 positions: \'x\' -> \'a\', \'y\' -> \'b\', \'z\' -> \'c\'. # Example 3: **Input**: ```python s = \\"hello\\" k = 5 ``` **Output**: ```python \\"mjqqt\\" ``` **Explanation**: Each character in \\"hello\\" is shifted forward by 5 positions: \'h\' -> \'m\', \'e\' -> \'j\', \'l\' -> \'q\', \'o\' -> \'t\'.","solution":"def shift_string(s: str, k: int) -> str: Shifts each character in the string s forward by k positions in the alphabet. Wraps around if the end of the alphabet is reached. :param s: Input string consisting of lowercase English alphabets. :param k: Number of positions to shift each character. :return: Transformed string with each character shifted by k positions. shifted_string = [] for char in s: # shift character and handle wrap-around using modulus new_char = chr((ord(char) - ord(\'a\') + k) % 26 + ord(\'a\')) shifted_string.append(new_char) return \'\'.join(shifted_string)"},{"question":"# Problem Statement: Finding the Missing Number in an Array In this problem, you need to write a function that finds the missing number in a sequence of consecutive integers. You are given a list of distinct integers which represents a sequence of consecutive numbers. However, one number from this sequence is missing, and your task is to identify the missing number. Function Signature ```python def find_missing_number(arr: list[int]) -> int: Given a list `arr` of distinct integers that represent a sequence of consecutive numbers, return the missing number in the sequence. Parameters: arr (list[int]): A list of distinct integers representing consecutive numbers, with one number missing. Returns: int: The missing number in the sequence. pass ``` Examples ```python find_missing_number([1, 2, 4, 5]) # Output: 3 find_missing_number([10, 11, 13, 14]) # Output: 12 find_missing_number([2, 4, 5, 6, 7]) # Output: 3 find_missing_number([101, 103, 104]) # Output: 102 find_missing_number([55, 56, 57, 59]) # Output: 58 ``` Constraints * The input list `arr` will contain at least 2 elements and no more than 100,000 elements. * The integers in `arr` can be both positive and negative. * If the input list includes non-integer elements, raise a `ValueError` with an appropriate message. Notes * Ensure your function works efficiently in terms of time complexity, aiming for O(n) time complexity. * Consider utilizing mathematical properties or algorithms that help in identifying the missing number in the sequence.","solution":"def find_missing_number(arr: list[int]) -> int: Given a list `arr` of distinct integers that represent a sequence of consecutive numbers, return the missing number in the sequence. Parameters: arr (list[int]): A list of distinct integers representing consecutive numbers, with one number missing. Returns: int: The missing number in the sequence. if not all(isinstance(i, int) for i in arr): raise ValueError(\\"All elements in the input list must be integers\\") n = len(arr) + 1 expected_sum = (n * (arr[0] + arr[-1])) // 2 actual_sum = sum(arr) return expected_sum - actual_sum"},{"question":"# Coding Question: Fibonacci Subsequence Finder Write a Python function to find all Fibonacci numbers within a given inclusive range `[low, high]`. Given the start of the range `low` and the end of the range `high`, the function should return a list of Fibonacci numbers that fall within this range. Your Task Implement the function `find_fibonacci_subsequence(low: int, high: int) -> list[int]` that follows these rules: 1. The function accepts two parameters: * `low` (int): The start of the range. * `high` (int): The end of the range. 2. Returns a list of Fibonacci numbers within the range `[low, high]`. 3. If `low` is greater than `high`, return an empty list. 4. Return an empty list if both parameters are zero or less. Example Usage ```python assert find_fibonacci_subsequence(10, 100) == [13, 21, 34, 55, 89] assert find_fibonacci_subsequence(0, 8) == [0, 1, 1, 2, 3, 5, 8] assert find_fibonacci_subsequence(20, 20) == [] assert find_fibonacci_subsequence(0, 1) == [0, 1, 1] assert find_fibonacci_subsequence(0, 0) == [] assert find_fibonacci_subsequence(100, 10) == [] ``` Constraints * `-10^9 <= low <= 10^9` * `-10^9 <= high <= 10^9` Performance Requirements * Aim for an efficient solution with O(n) time complexity where n is the number of Fibonacci terms generated until the `high` value. * Ensure correctness for very large ranges, considering the rapid growth of Fibonacci numbers. # Notes * You may use an iterative approach to generate Fibonacci numbers. * Handle edge cases such as range boundaries, and ensure the function works correctly even when `low` or `high` is a very large or very small integer. * Consider using Python\'s built-in continuous arithmetic capabilities to manage large numbers when necessary.","solution":"def find_fibonacci_subsequence(low: int, high: int) -> list[int]: Returns a list of Fibonacci numbers within the inclusive range [low, high]. if low > high or (low <= 0 and high <= 0): return [] fibonacci_sequence = [] a, b = 0, 1 while a <= high: if a >= low: fibonacci_sequence.append(a) a, b = b, a + b return fibonacci_sequence"},{"question":"# Question: Calculate the Sum of Squares of First N Natural Numbers You are tasked with calculating the sum of squares of the first N natural numbers. The sum of squares of the first N natural numbers is given by the formula: [ S_N = frac{N(N + 1)(2N + 1)}{6} ] Task Write a function `sum_of_squares(n: int) -> int` that returns the sum of squares of the first N natural numbers. Function Signature ```python def sum_of_squares(n: int) -> int: pass ``` Input - `n` (int): The number of initial natural numbers to square and sum. Must be a non-negative integer. Output - (int): The sum of squares of the first N natural numbers. Constraints - `0 <= n <= 10^5` (Ensure handling for large values efficiently) - Raise a `ValueError` for any input value of `n` that is negative. Examples ```python >>> sum_of_squares(1) 1 >>> sum_of_squares(2) 5 >>> sum_of_squares(3) 14 >>> sum_of_squares(-1) Traceback (most recent call last): ... ValueError: param `n` must be non-negative ``` Performance Requirements Your function should compute the result in constant time, O(1).","solution":"def sum_of_squares(n: int) -> int: Returns the sum of squares of the first N natural numbers. if n < 0: raise ValueError(\\"param `n` must be non-negative\\") return n * (n + 1) * (2 * n + 1) // 6"},{"question":"# Neural Network Binary Classifier Context Neural networks have become a dominant methodology for a wide range of applications, from image classification to natural language processing. Implementing a simple neural network from scratch can help in understanding the underlying mechanics and gradient-based optimization. In this task, you are required to implement a neural network that performs binary classification on a given dataset. Your network should consist of an input layer, one hidden layer with ReLU activation, and an output layer with a sigmoid activation function. Task You will implement the training process for a neural network using gradient descent. This includes forward and backward propagation, along with updating the weights. Requirements 1. **Function Name**: `train_neural_network` 2. **Inputs**: - `X`: A 2D numpy.ndarray representing the input features of shape `(n_samples, n_features)`. - `y`: A 1D numpy.ndarray representing the binary labels of shape `(n_samples,)`. - `hidden_size`: Integer specifying the number of neurons in the hidden layer. - `learning_rate`: A float specifying the learning rate for gradient descent. - `epochs`: An integer specifying the number of iterations over the entire dataset. 3. **Output**: - A dictionary with keys `\'W1\'`, `\'b1\'`, `\'W2\'`, `\'b2\'` representing the weights and biases of the input-to-hidden and hidden-to-output layers respectively. Constraints - The input features `X` are normalized to values between 0 and 1. - The labels `y` are binary, with values either 0 or 1. - Use Mean Squared Error (MSE) as the loss function. Performance Requirements - While it is important for the neural network to converge, computational efficiency is secondary due to the training nature of the task. - Ensure the implementation is vectorized using numpy for efficient computation. Example ```python import numpy as np X = np.array([[0.1, 0.2], [0.4, 0.5], [0.7, 0.8]]) y = np.array([0, 1, 1]) trained_weights = train_neural_network(X, y, hidden_size=4, learning_rate=0.01, epochs=1000) print(trained_weights[\'W1\']) # Example output: a matrix of shape (2, 4) print(trained_weights[\'b1\']) # Example output: a matrix of shape (1, 4) print(trained_weights[\'W2\']) # Example output: a matrix of shape (4, 1) print(trained_weights[\'b2\']) # Example output: a scalar ``` Notes - Initialize weights using a small random value. - Implement gradient descent with backpropagation for weight updates. - The output layer should provide the probability that the input belongs to class 1. Use this output to calculate the loss and perform backpropagation.","solution":"import numpy as np def sigmoid(x): return 1 / (1 + np.exp(-x)) def sigmoid_derivative(x): return x * (1 - x) def relu(x): return np.maximum(0, x) def relu_derivative(x): return np.where(x > 0, 1, 0) def train_neural_network(X, y, hidden_size, learning_rate, epochs): np.random.seed(42) input_size = X.shape[1] output_size = 1 # Initialize weights and biases W1 = np.random.randn(input_size, hidden_size) * 0.01 b1 = np.zeros((1, hidden_size)) W2 = np.random.randn(hidden_size, output_size) * 0.01 b2 = np.zeros((1, output_size)) for epoch in range(epochs): # Forward pass Z1 = np.dot(X, W1) + b1 A1 = relu(Z1) Z2 = np.dot(A1, W2) + b2 A2 = sigmoid(Z2) # Compute loss loss = np.mean((A2 - y.reshape(-1, 1))**2) # Backward pass dA2 = 2 * (A2 - y.reshape(-1, 1)) / y.shape[0] dZ2 = dA2 * sigmoid_derivative(A2) dW2 = np.dot(A1.T, dZ2) db2 = np.sum(dZ2, axis=0, keepdims=True) dA1 = np.dot(dZ2, W2.T) dZ1 = dA1 * relu_derivative(A1) dW1 = np.dot(X.T, dZ1) db1 = np.sum(dZ1, axis=0, keepdims=True) # Update weights W1 -= learning_rate * dW1 b1 -= learning_rate * db1 W2 -= learning_rate * dW2 b2 -= learning_rate * db2 return {\'W1\': W1, \'b1\': b1, \'W2\': W2, \'b2\': b2}"},{"question":"Coding Assessment Question As part of upgrading a library management system, you need to implement a feature that tracks book rentals and returns. The system should keep an accurate count of available books for each title and be able to handle requests for renting and returning books. Your task is to develop the `Library` class with methods to rent and return books, while ensuring that the stocks are accurately updated. Also, implement a method to check the availability of a specific book. Class Definition **class Library** * **Attributes**: - `inventory` (dict): A dictionary where keys are book titles (str) and values are the count (int) of available copies. * **Methods**: - `__init__(self) -> None`: Initializes the `Library` with an empty inventory. - `add_book(self, title: str, count: int) -> None`: Adds a specified number of copies of a book to the inventory. - `rent_book(self, title: str) -> bool`: Rents out a book if available. Returns `True` if the book was successfully rented, otherwise returns `False`. - `return_book(self, title: str) -> None`: Returns a rented book, increasing the count of available copies. - `check_availability(self, title: str) -> int`: Returns the number of available copies of the specified book. Method Details ```python def __init__(self) -> None: Initializes the library with an empty inventory. pass def add_book(self, title: str, count: int) -> None: Adds the specified count of a book title to the inventory. pass def rent_book(self, title: str) -> bool: Attempts to rent a book; returns True if successful, False if the book is not available. pass def return_book(self, title: str) -> None: Returns a book, increasing its stock in the inventory. pass def check_availability(self, title: str) -> int: Checks and returns the number of available copies of a book. pass ``` # Examples Adding Books ```python library = Library() library.add_book(\\"1984\\", 3) library.add_book(\\"To Kill a Mockingbird\\", 2) ``` Renting Books ```python assert library.rent_book(\\"1984\\") == True # One copy of \\"1984\\" is rented out assert library.check_availability(\\"1984\\") == 2 # 2 copies left assert library.rent_book(\\"1984\\") == True # Another copy rented out assert library.check_availability(\\"1984\\") == 1 # 1 copy left assert library.rent_book(\\"1984\\") == True # Last copy rented out assert library.check_availability(\\"1984\\") == 0 # No copies left assert library.rent_book(\\"1984\\") == False # Renting fails as no copies are available ``` Returning Books ```python library.return_book(\\"1984\\") # One copy returned assert library.check_availability(\\"1984\\") == 1 # 1 copy available now ``` # Requirements - Maintain stock accuracy for each book title in the inventory. - Handle book rental requests efficiently. - Ensure that the return of a book increases the stock count correctly. - The availability method must return the correct count of available copies at any point.","solution":"class Library: def __init__(self) -> None: Initializes the library with an empty inventory. self.inventory = {} def add_book(self, title: str, count: int) -> None: Adds the specified count of a book title to the inventory. if title in self.inventory: self.inventory[title] += count else: self.inventory[title] = count def rent_book(self, title: str) -> bool: Attempts to rent a book; returns True if successful, False if the book is not available. if title in self.inventory and self.inventory[title] > 0: self.inventory[title] -= 1 return True return False def return_book(self, title: str) -> None: Returns a book, increasing its stock in the inventory. if title in self.inventory: self.inventory[title] += 1 else: self.inventory[title] = 1 def check_availability(self, title: str) -> int: Checks and returns the number of available copies of a book. return self.inventory.get(title, 0)"},{"question":"# Problem Statement: Given a string consisting of only lowercase English letters, you are required to determine the first recurring character. Implement a function, `first_recurring_char`, that finds and returns the first character that appears more than once. If no character repeats, return None. # Function Signature: ```python def first_recurring_char(s: str) -> str: ``` # Input: * A single string `s` where 1 <= len(s) <= 10^5. # Output: * A character that first recurs in the input string. If no such character exists, return None. # Example: ```python assert first_recurring_char(\\"acbbac\\") == \'b\' assert first_recurring_char(\\"abcdef\\") == None assert first_recurring_char(\\"abca\\") == \'a\' assert first_recurring_char(\\"aabbcc\\") == \'a\' assert first_recurring_char(\\"bbaaccaaddee\\") == \'b\' ``` # Constraints: * The function should be efficient given the potential length of the string. * Raise a TypeError if the input is not a string. # Requirements: 1. Ensure the function operates at a time complexity of O(n), where n is the length of the input string. 2. Handle edge cases like a string where all characters are unique or repeated but appear far apart in the sequence. # Context: This function can be used in text processing systems to identify the first recurring word. It could be part of an automatization tool used for debugging, searching for the first recurring error code in logs, or finding the first recurring product code in inventory lists. Implement the function `first_recurring_char` by considering the points mentioned in the analysis and adhering to the provided examples to check correctness.","solution":"def first_recurring_char(s: str) -> str: Returns the first recurring character in the string \'s\'. If no character recurs, returns None. if not isinstance(s, str): raise TypeError(\\"Input must be a string\\") seen = set() for char in s: if char in seen: return char seen.add(char) return None"},{"question":"# Coding Assessment Question: You are given a list of integers. Your task is to implement the Merge Sort algorithm to sort the list in ascending order. Write a function `merge_sort(arr)` that takes a list of integers `arr` and sorts it using the Merge Sort algorithm. Input: * A list of integers `arr` (1 ≤ len(arr) ≤ 1000, -10^6 ≤ arr[i] ≤ 10^6). Output: * A sorted list of integers in ascending order. Example: ```python assert merge_sort([4, 2, 5, 3, 0, 1]) == [0, 1, 2, 3, 4, 5] assert merge_sort([]) == [] assert merge_sort([2]) == [2] assert merge_sort([5, 1, 4, 2, 3]) == [1, 2, 3, 4, 5] ``` Your function will be evaluated on the following: * Correctness of sorting algorithm. * Handling of edge cases such as empty input and single-element input. * Proper merging of sublists into the final sorted list. **Constraints**: * Do not use Python’s built-in sort() method or any external libraries for sorting. * Ensure your implementation considers performance and avoids unnecessary computations. **Performance Requirement**: Ensure your implementation is reasonably efficient for the given constraints, targeting a solution that can handle the upper limit of input size within acceptable runtime.","solution":"def merge_sort(arr): Sorts the list arr using the Merge Sort algorithm. Parameters: arr (list): List of integers to sort. Returns: list: Sorted list in ascending order. if len(arr) <= 1: return arr mid = len(arr) // 2 left_half = merge_sort(arr[:mid]) right_half = merge_sort(arr[mid:]) return merge(left_half, right_half) def merge(left, right): Merges two sorted lists into one sorted list. Parameters: left (list): Sorted list. right (list): Sorted list. Returns: list: Merged and sorted list. sorted_list = [] left_index = 0 right_index = 0 # Merge the two lists while left_index < len(left) and right_index < len(right): if left[left_index] <= right[right_index]: sorted_list.append(left[left_index]) left_index += 1 else: sorted_list.append(right[right_index]) right_index += 1 # Append remaining elements (if any) sorted_list.extend(left[left_index:]) sorted_list.extend(right[right_index:]) return sorted_list"},{"question":"# Palindrome Substring Length Coding Question Context You need to determine the length of the longest palindrome that can be built with the letters from a given string. It is important to note that each character can be used only as many times as it appears in the string. Your Task Write a function that takes a string and returns the length of the longest palindromic substring that can be formed by rearranging its characters. Function Signature ```python def longest_palindrome_length(s: str) -> int: # your code here ``` Input - `s` (str): A string containing lowercase and uppercase English letters. Output - Returns an integer representing the length of the longest palindromic substring that can be constructed from the input string. Constraints - The input string can have both lowercase and uppercase letters. - The length of the input string is between 1 and 2000. Example ```python s = \\"aabbcc\\" output = 6 >>> longest_palindrome_length(\\"aabbcc\\") 6 s = \\"abccccdd\\" output = 7 >>> longest_palindrome_length(\\"abccccdd\\") 7 s = \\"AaBb\\" output = 1 >>> longest_palindrome_length(\\"AaBb\\") 1 ``` Edge Cases to Consider - A string containing only one character. - Strings where all characters are unique. - Strings with both lowercase and uppercase letters but no character appears an even number of times.","solution":"def longest_palindrome_length(s: str) -> int: from collections import Counter char_count = Counter(s) length = 0 odd_flag = False for count in char_count.values(): if count % 2 == 0: length += count else: length += count - 1 odd_flag = True if odd_flag: length += 1 return length"},{"question":"# Question: Analyze and Identify Loop Invariants in an Array Processing Algorithm Context: You are given an algorithm that processes an array of integers to perform some computations. Your task is to analyze the algorithm and identify the loop invariants. A loop invariant is a condition that holds true before and after each iteration of the loop. You need to explain why these invariants hold and how they are useful in proving the correctness of the algorithm. Requirements: 1. **Function Signature**: - `def identify_invariants(data: List[int]) -> Tuple[Dict[str, str], Dict[str, str]]` 2. **Input and Output Formats**: - The function accepts a single parameter: `data`, which is a list of integers. - The function returns a tuple containing two dictionaries. - The first dictionary maps each loop identifier to its corresponding invariant. - The second dictionary provides explanations for why each invariant holds. 3. **Algorithm Description**: ```python def process_array(data): n = len(data) result = [0] * n for i in range(1, n): result[i] = data[i] - data[i - 1] return result ``` 4. **Task**: - Identify the relevant loop(s) present in the `process_array` function. - Determine the invariant(s) for the identified loop(s). - Explain the significance of each invariant and how they help in proving the algorithm\'s correctness. Example Usage: ```python invariants, explanations = identify_invariants([1, 2, 4, 7, 11]) print(invariants) # Output: {\'i_loop\': \'For any iteration k, result[k] = data[k] - data[k - 1]\'} print(explanations) # Output: {\'i_loop\': \'After each iteration, the difference between data[k] and data[k - 1] is stored in result[k], which ensures that the algorithm accurately computes the difference for each element\'} ``` Instructions: 1. Analyze the `process_array` function and focus on the loop used for processing the array. 2. Identify the loop invariant(s) within the function. 3. Return the identified invariants and their explanations in the required format. 4. Ensure that your results are based on solid reasoning and correctly justify the correctness of the algorithm. May include edge cases and test the algorithm comprehensively as an optional step.","solution":"from typing import List, Dict, Tuple def identify_invariants(data: List[int]) -> Tuple[Dict[str, str], Dict[str, str]]: invariants = {} explanations = {} invariants[\'i_loop\'] = \'For any iteration k, result[k] = data[k] - data[k - 1]\' explanations[\'i_loop\'] = \'After each iteration of the loop, the difference between data[k] and data[k - 1] is stored in result[k], ensuring the algorithm accurately computes differences for each element.\' return invariants, explanations"},{"question":"# User Account Registration System Design and implement a user account registration system. The system should be able to create new user accounts, including necessary validation for user input. Each user account should have a unique username and password which satisfies specific security requirements. Function Signature ```python def register_user(username: str, password: str) -> int: Registers a new user with the given username and password. ``` Input * `username`: A string representing the username for the new account. * `password`: A string representing the password for the new account. Output * Return an integer status code: * `0` if the registration is successful. * `1` if the username is already taken. * `2` if the username is invalid. * `3` if the password is invalid. Constraints and Requirements * Each username must be unique within the system. * Username validation: * Must be between 3 to 20 characters long. * Can only contain alphanumeric characters (letters and numbers). * Password validation: * Must be at least 8 characters long. * Must contain at least one uppercase letter, one lowercase letter, and one digit. * Implement storage using an in-memory dictionary for simplicity (keys being usernames and values being passwords). Example ```python # Create the user account system status = register_user(\\"JohnDoe\\", \\"Password1\\") assert status == 0 # Success status = register_user(\\"JohnDoe\\", \\"AnotherPassword1\\") assert status == 1 # Username taken status = register_user(\\"John\\", \\"pass\\") assert status == 3 # Password invalid status = register_user(\\"John*Doe\\", \\"Password1\\") assert status == 2 # Username invalid ``` Testing Create a suite of unittests to verify the correctness of your registration system, ensuring to cover all constraints and edge cases: * Test with valid inputs for successful registration. * Test with duplicate usernames. * Test with invalid usernames (too short, too long, non-alphanumeric). * Test with invalid passwords (too short, missing character types).","solution":"# Dictionary to simulate in-memory storage of user accounts user_database = {} def is_valid_username(username: str) -> bool: if 3 <= len(username) <= 20 and username.isalnum(): return True return False def is_valid_password(password: str) -> bool: if len(password) < 8: return False if not any(char.islower() for char in password): return False if not any(char.isupper() for char in password): return False if not any(char.isdigit() for char in password): return False return True def register_user(username: str, password: str) -> int: Registers a new user with the given username and password. Returns: int: status code 0 - Successful registration 1 - Username already taken 2 - Invalid username 3 - Invalid password global user_database if username in user_database: return 1 if not is_valid_username(username): return 2 if not is_valid_password(password): return 3 user_database[username] = password return 0"},{"question":"# Sort People by Height and Name You are tasked with implementing a function that sorts a list of people by their height in descending order. If two people have the same height, they should be sorted by their names in ascending order. # Function Signature ```python def sort_people(people: List[Tuple[str, int]]) -> List[Tuple[str, int]]: pass ``` # Input - `people` (List[Tuple[str, int]]): A list of tuples where each tuple represents a person. The first element of the tuple is a string representing the person\'s name, and the second element is an integer representing the person\'s height in centimeters. # Output - A list of tuples sorted by the described criteria. # Constraints - The list `people` will contain no more than 10,000 tuples. - Each name will be a non-empty string of 1 to 100 characters consisting only of lowercase and uppercase English letters. - Each height will be a positive integer between 50 and 300. # Example * `sort_people([(\'Alice\', 165), (\'Bob\', 180), (\'Charlie\', 180), (\'Dave\', 155)])` should return `[(\'Bob\', 180), (\'Charlie\', 180), (\'Alice\', 165), (\'Dave\', 155)]`. # Note - The height is a primary sorting key in descending order. - The name is a secondary sorting key in ascending order if two people have the same height. Implement the function ensuring that it adheres to the constraints and handles all edge cases appropriately.","solution":"from typing import List, Tuple def sort_people(people: List[Tuple[str, int]]) -> List[Tuple[str, int]]: Sort people by their height in descending order. If two people have the same height, sort them by their name in ascending order. return sorted(people, key=lambda person: (-person[1], person[0]))"},{"question":"**Problem Statement:** You are given a 2D grid representing a maze where some cells are walkable (denoted \'1\') and some are walls (denoted \'0\'). Implement a function that determines if there is a way to traverse from the top-left corner of the maze to the bottom-right corner, moving only up, down, left, or right. # Function Signature ```python def can_traverse(maze: list[list[int]]) -> bool: pass ``` # Input & Output Formats * **Input**: * `maze`: A 2D list of integers where \'1\' represents a walkable path and \'0\' represents a wall. * **Output**: * Return a boolean value indicating whether there is a path from the top-left to the bottom-right corner of the maze. # Constraints * The dimensions of the grid (maze) will not exceed 100x100. * The starting cell (maze[0][0]) and the ending cell (maze[n-1][n-1]) will always be walkable (i.e., always \'1\'). # Performance Requirements * Aim for an efficient traversal algorithm considering the grid size and constraints. # Examples ```python assert can_traverse([[1, 0, 0], [1, 1, 0], [0, 1, 1]]) == True assert can_traverse([[1, 0, 0], [0, 1, 0], [0, 1, 1]]) == False assert can_traverse([[1, 1], [1, 1]]) == True assert can_traverse([[1, 0], [0, 1]]) == False assert can_traverse([[1]]) == True ``` **Notes**: * Use any graph traversal technique suitable for this problem (e.g., Breadth-First Search or Depth-First Search). * Ensure that your implementation correctly handles the edges and avoids cycles. * Perform thorough testing to cover edge scenarios.","solution":"def can_traverse(maze): if not maze or not maze[0]: return False rows, cols = len(maze), len(maze[0]) if maze[0][0] == 0 or maze[rows-1][cols-1] == 0: return False # Use BFS for pathfinding from collections import deque queue = deque([(0, 0)]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] visited = set((0, 0)) while queue: r, c = queue.popleft() if r == rows-1 and c == cols-1: return True for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < rows and 0 <= nc < cols and maze[nr][nc] == 1 and (nr, nc) not in visited: visited.add((nr, nc)) queue.append((nr, nc)) return False"},{"question":"# Problem Statement: You are tasked with writing an efficient function to determine the minimum number of steps needed to convert a given string into another string using a combinations of insertion, deletion, and substitution operations. This problem is commonly known as finding the \\"Edit Distance\\" or the \\"Levenshtein Distance\\". # Function Signature: ```python def min_edit_distance(str1: str, str2: str) -> int: Computes the minimum number of operations (insertion, deletion, substitution) required to transform str1 into str2. :param str1: The source string. :param str2: The target string. :return: The minimum number of operations needed to transform str1 into str2. pass ``` # Implementation Details: 1. **Dynamic Programming**: Utilize a 2D DP table to store the results of subproblems. 2. **Initialization**: Initialize the first row and first column of the DP table based on the cost of transforming an empty string to another string entirely through insertions or deletions. 3. **State Transition**: For each cell in the table, determine the minimum cost based on: - Substitution: If the characters are different, the cost is 1 plus the cost of transforming the prefixes. - Insertion: The cost of inserting a character. - Deletion: The cost of deleting a character. 4. **Space Optimization** (optional): If desired, optimize space by using only two rows of the DP table, since the current state only depends on the previous row. 5. **Constraints**: - Length of `str1` and `str2` can be up to 1000 characters each. # Examples: ```python assert min_edit_distance(\\"kitten\\", \\"sitting\\") == 3 # Operation sequence: kitten -> sitten -> sittin -> sitting assert min_edit_distance(\\"flaw\\", \\"lawn\\") == 2 # Operation sequence: flaw -> law -> lawn assert min_edit_distance(\\"intention\\", \\"execution\\") == 5 # A complex example showing multiple operations assert min_edit_distance(\\"\\", \\"hello\\") == 5 # Edge cases with empty strings assert min_edit_distance(\\"hello\\", \\"\\") == 5 assert min_edit_distance(\\"abc\\", \\"abc\\") == 0 # No changes needed ``` **Note**: Ensure your solution efficiently handles the upper bounds of the problem constraints.","solution":"def min_edit_distance(str1: str, str2: str) -> int: Computes the minimum number of operations (insertion, deletion, substitution) required to transform str1 into str2. :param str1: The source string. :param str2: The target string. :return: The minimum number of operations needed to transform str1 into str2. m, n = len(str1), len(str2) # Create a table to store results of subproblems dp = [[0] * (n + 1) for _ in range(m + 1)] # Initialize the first row and column of the DP table for i in range(m + 1): dp[i][0] = i # Minimum operations = i (all deletions) for j in range(n + 1): dp[0][j] = j # Minimum operations = j (all insertions) # Fill the DP table in bottom-up manner for i in range(1, m + 1): for j in range(1, n + 1): if str1[i - 1] == str2[j - 1]: # If characters match, no new operation needed dp[i][j] = dp[i - 1][j - 1] else: # Otherwise, consider all possibilities and find minimum insert_op = dp[i][j - 1] delete_op = dp[i - 1][j] replace_op = dp[i - 1][j - 1] dp[i][j] = 1 + min(insert_op, delete_op, replace_op) # The last cell of the table contains the answer return dp[m][n]"},{"question":"In a file system, you are required to implement a function that computes the size of a given directory by considering the sizes of all files and sub-directories within it. The function should account for nested directories. # Function Specification **Function**: ```python def calculate_directory_size(directory: dict) -> int: pass ``` # Input * `directory`: A dictionary where each key is either a string representing a file with its size (in bytes) as the integer value, or a string representing a sub-directory with its value being another dictionary in the same format. # Output * The function should return an integer representing the total size of the directory in bytes. # Constraints * The directory can contain up to 1000 files and sub-directories combined. * Each file size will be an integer between 1 and 100,000, inclusive. * The depth of the nested directories will not exceed 10 levels. * The directory structure will not contain circular references. # Requirement * The function should recursively calculate and include the sizes of all sub-directories. # Example Example 1 ```python # Input directory = { \'file1.txt\': 100, \'file2.txt\': 200, \'subdir1\': { \'file3.txt\': 300, \'subdir2\': { \'file4.txt\': 150, \'file5.txt\': 250 } } } # Function: calculate_directory_size directory_size = calculate_directory_size(directory) # Output: 1000 ``` Example 2 ```python # Input directory = { \'music.mp3\': 10000, \'photos\': { \'photo1.jpg\': 5000, \'photo2.jpg\': 7000 }, \'documents\': { \'file1.doc\': 1200, \'file2.pdf\': 4500, \'work\': { \'project1.ppt\': 2000, \'project2.xls\': 3200 } } } # Function: calculate_directory_size directory_size = calculate_directory_size(directory) # Output: 33900 ```","solution":"def calculate_directory_size(directory: dict) -> int: total_size = 0 for key, value in directory.items(): if isinstance(value, dict): total_size += calculate_directory_size(value) else: total_size += value return total_size"},{"question":"# Coding Question: You are tasked with implementing a function that identifies the smallest number whose sum of its digits is equal to a given target. The goal is to test your understanding of digit manipulation and efficient searching. Function Signature: ```python def smallest_number_with_digit_sum(target_sum: int) -> int: Finds the smallest integer whose sum of the digits equals the given target_sum. Parameters: - target_sum (int): The target sum of the digits. Returns: - int: The smallest integer whose sum of the digits equals target_sum. Example: - Input: 10 - Output: 19 pass ``` Constraints: - `target_sum` will be a non-negative integer within the range of `0 to 100`. Implementation Details: - You may write additional helper functions to assist with digit sum calculations. - Ensure your solution is optimized for the given constraints. Example: For `target_sum = 10`, the result should be `19`, as: - Sum of digits of 1+9 = 10 (and 19 is the smallest integer satisfying this) Tips: - Consider starting from smaller numbers and iteratively checking their digit sums. - Ensure your solution handles both small and large sums correctly. Good luck!","solution":"def smallest_number_with_digit_sum(target_sum: int) -> int: Finds the smallest integer whose sum of the digits equals the given target_sum. Parameters: - target_sum (int): The target sum of the digits. Returns: - int: The smallest integer whose sum of the digits equals target_sum. def digit_sum(n): return sum(map(int, str(n))) smallest_number = target_sum while digit_sum(smallest_number) != target_sum: smallest_number += 1 return smallest_number"},{"question":"# Problem Statement Design a `FileSystem` class to simulate a simple in-memory file system with the following features: 1. **Create Path**: - Implement a method `create` that creates a new path and associates a value with it. - A path can only be created if its parent path already exists (with the exception of the root, which always exists). 2. **Get Path**: - Implement a method `get` that returns the value associated with a given path. Method Signatures ```python class FileSystem: def __init__(self): Initialize the FileSystem with an empty dictionary to store path-value pairs. self.paths = {} def create(self, path: str, value: int) -> bool: Creates a new path with the given value. Args: - path (str): the path to be created. - value (int): the value to associate with the path. Returns: - bool: True if the path was successfully created, False otherwise. pass def get(self, path: str) -> int | None: Returns the value associated with the given path. Args: - path (str): the path to look up. Returns: - int: The value associated with the path, or None if the path does not exist. pass ``` Constraints - Path format is `\\"/a/b/c\\"` or similar with components separated by a single slash `/`. - The root path `/` is always assumed to exist and has no value. - All paths and components consist of lowercase letters only. - Duplicate creates or invalid path creations should be rejected. Example Usage ```python # Initialize FileSystem fs = FileSystem() # Create path \\"/a\\" with value 1 result = fs.create(\\"/a\\", 1) assert result == True # returns True # Create path \\"/a/b\\" with value 2 result = fs.create(\\"/a/b\\", 2) assert result == True # returns True # Try to create path \\"/c\\" without a parent path result = fs.create(\\"/c\\", 3) assert result == False # returns False, as the parent path \\"/c\\" does not exist # Retrieve value of \\"/a\\" value = fs.get(\\"/a\\") assert value == 1 # returns 1 # Retrieve value of \\"/a/b\\" value = fs.get(\\"/a/b\\") assert value == 2 # returns 2 # Try retrieving value of non-existing path \\"/c\\" value = fs.get(\\"/c\\") assert value is None # returns None, as \\"/c\\" path does not exist ``` **Your task is to complete the implementation of the `FileSystem` class as specified above. Ensure to handle path creation and retrieval accurately.**","solution":"class FileSystem: def __init__(self): Initialize the FileSystem with an empty dictionary to store path-value pairs. self.paths = {\\"/\\": None} def create(self, path: str, value: int) -> bool: Creates a new path with the given value. Args: - path (str): the path to be created. - value (int): the value to associate with the path. Returns: - bool: True if the path was successfully created, False otherwise. if path in self.paths: return False parent = \\"/\\".join(path.split(\\"/\\")[:-1]) if not parent: parent = \\"/\\" if parent not in self.paths: return False self.paths[path] = value return True def get(self, path: str) -> int | None: Returns the value associated with the given path. Args: - path (str): the path to look up. Returns: - int: The value associated with the path, or None if the path does not exist. return self.paths.get(path, None)"},{"question":"# Kth Largest Element in a Stream Scenario: You are given a stream of integers and a number `k`. Implement a class `KthLargest` that has a constructor which takes an integer `k` and a list of integers, and initialize it with this list. The class should also have a method `add` which adds an integer to the stream and returns the kth largest element in the stream. Task: Write a class `KthLargest` that exposes two methods: 1. `__init__(self, k: int, nums: List[int])` - Initializes the object with the integer `k` and the list of integers `nums`. 2. `add(self, val: int) -> int` - Adds the integer `val` to the stream of numbers and returns the kth largest element in the current stream. Constraints: * `1 <= k <= 10^4` * `-10^4 <= val <= 10^4` * At most `10^4` calls will be made to `add`. * It is guaranteed that there will be at least `k` elements in the list when `add` is called. Function Signatures: ```python class KthLargest: def __init__(self, k: int, nums: List[int]): pass def add(self, val: int) -> int: pass ``` Example Usage: * Example 1: ```python kthLargest = KthLargest(3, [4, 5, 8, 2]) print(kthLargest.add(3)) # Output: 4 print(kthLargest.add(5)) # Output: 5 print(kthLargest.add(10)) # Output: 5 print(kthLargest.add(9)) # Output: 8 print(kthLargest.add(4)) # Output: 8 ``` * Example 2: ```python kthLargest = KthLargest(1, []) print(kthLargest.add(-3)) # Output: -3 print(kthLargest.add(-2)) # Output: -2 print(kthLargest.add(-4)) # Output: -2 print(kthLargest.add(0)) # Output: 0 print(kthLargest.add(4)) # Output: 4 ``` # Instructions: 1. Implement the class `KthLargest` as described. 2. Ensure your `add` method maintains efficient time complexity to handle large numbers of calls. 3. Optimize the class to handle both space and time complexities adequately. 4. Test your implementation thoroughly to ensure its correctness under various scenarios.","solution":"import heapq class KthLargest: def __init__(self, k: int, nums: list[int]): self.k = k self.min_heap = [] for num in nums: self.add(num) def add(self, val: int) -> int: if len(self.min_heap) < self.k: heapq.heappush(self.min_heap, val) elif val > self.min_heap[0]: heapq.heapreplace(self.min_heap, val) return self.min_heap[0]"},{"question":"# Problem Statement You have been tasked with implementing a simplified version of the popular \\"FizzBuzz\\" game, but with a twist. Write a function that takes an integer `n` and returns a list of strings with the numbers from 1 to `n`. For multiples of three, append \\"Fizz\\" to the list instead of the number, and for the multiples of five append \\"Buzz\\". For numbers which are multiples of both three and five, append \\"FizzBuzz\\". However, if the number itself contains the digit \\"3\\", append \\"Fizz\\" regardless of whether it is a multiple of three or not. # Function Signature ```python def fizz_buzz_special(n: int) -> list[str]: pass ``` # Input - `n`: A positive integer greater than 0. # Output - A list of strings as described. # Constraints - `1 <= n <= 10^4` # Examples ```python >>> fizz_buzz_special(15) [\'1\', \'2\', \'Fizz\', \'4\', \'Buzz\', \'Fizz\', \'7\', \'8\', \'Fizz\', \'Buzz\', \'11\', \'Fizz\', \'Fizz\', \'14\', \'FizzBuzz\'] >>> fizz_buzz_special(5) [\'1\', \'2\', \'Fizz\', \'4\', \'Buzz\'] >>> fizz_buzz_special(10) [\'1\', \'2\', \'Fizz\', \'4\', \'Buzz\', \'Fizz\', \'7\', \'8\', \'Fizz\', \'Buzz\'] >>> fizz_buzz_special(13) [\'1\', \'2\', \'Fizz\', \'4\', \'Buzz\', \'Fizz\', \'7\', \'8\', \'Fizz\', \'Buzz\', \'11\', \'Fizz\', \'Fizz\'] ``` # Notes * Ensure that the solution handles large values of `n` efficiently. * Think carefully about how to check if a number contains the digit \\"3\\".","solution":"def fizz_buzz_special(n: int) -> list[str]: result = [] for i in range(1, n+1): str_i = str(i) if \'3\' in str_i: result.append(\\"Fizz\\") elif i % 3 == 0 and i % 5 == 0: result.append(\\"FizzBuzz\\") elif i % 3 == 0: result.append(\\"Fizz\\") elif i % 5 == 0: result.append(\\"Buzz\\") else: result.append(str_i) return result"},{"question":"# Coding Question **Problem Statement**: Given a list of integers `arr` where the integers are in the range from 1 to `n` (inclusive), and each integer appears exactly once except for one integer that is missing and another that appears twice. Your task is to find the duplicate integer and the missing integer. Implement the following function: ```python def find_duplicate_and_missing(arr: List[int]) -> Tuple[int, int]: Find the duplicate integer and the missing integer in the array. Parameters: arr (List[int]): List of integers of size n where each integer is in the range from 1 to n inclusive. Returns: Tuple[int, int]: A tuple containing the duplicate integer and the missing integer. ``` **Input**: * `arr`: a list of integers of size `n` where integers are in the range from 1 to `n` inclusive. **Output**: * Returns a tuple containing two integers: the duplicate integer and the missing integer. **Constraints**: * (2 leq n leq 10^5) * Each integer in `arr` is between 1 and `n` inclusive. * There is exactly one duplicate and one missing integer. **Examples**: 1. Example 1: ```python arr = [3, 1, 2, 5, 3] assert find_duplicate_and_missing(arr) == (3, 4) ``` 2. Example 2: ```python arr = [1, 2, 2, 4] assert find_duplicate_and_missing(arr) == (2, 3) ``` **Additional Context**: The problem can be solved using various approaches including but not limited to sorting, hashing, or mathematical calculations involving the sum and sum of squares formulas. The expected solution should optimize for both time and space efficiency, considering the upper constraints.","solution":"from typing import List, Tuple def find_duplicate_and_missing(arr: List[int]) -> Tuple[int, int]: n = len(arr) sum_n = n * (n + 1) // 2 sum_n_sq = n * (n + 1) * (2 * n + 1) // 6 sum_arr = sum(arr) sum_arr_sq = sum(x * x for x in arr) # According to the given sequence and sum properties: S = sum_n - sum_arr # missing - duplicate P = sum_n_sq - sum_arr_sq # missing^2 - duplicate^2 missing_plus_duplicate = P // S # (missing + duplicate) missing = (S + missing_plus_duplicate) // 2 duplicate = missing_plus_duplicate - missing return duplicate, missing"},{"question":"# Binary Search Tree: Enhanced Node Management In this problem, you are required to enhance the operations of a Binary Search Tree (BST) to include additional functionalities like calculating the height of the tree and finding the lowest common ancestor (LCA) of two nodes in the BST. You will implement a class `EnhancedBST` that encapsulates the functionality for these operations. # Class and Methods Specification: Class: ```python class EnhancedBST: def __init__(self): pass def insert(self, key: int) -> None: pass def find_height(self) -> int: pass def find_lca(self, node1: int, node2: int) -> int: pass class Node: def __init__(self, key: int): self.left = None self.right = None self.val = key ``` # Method Description: * `__init__(self)`: Initialize the `EnhancedBST` instance and the root to `None`. * `insert(self, key: int) -> None`: Insert a node with the specified key into the BST. * `find_height(self) -> int`: Returns the height of the BST. The height of an empty tree is -1. * `find_lca(self, node1: int, node2: int) -> int`: Finds the lowest common ancestor of the two given nodes. If either of the nodes is not present in the tree, return `None`. # Constraints: - The values of nodes (`key`, `node1`, `node2`) will always be integers. - All keys in the BST are unique. # Examples: ```python bst = EnhancedBST() # Example for inserting nodes: bst.insert(20) bst.insert(10) bst.insert(30) bst.insert(5) bst.insert(15) # Example for finding height: height = bst.find_height() print(height) # Output should be 2 # Example for finding common ancestor: lca = bst.find_lca(5, 15) print(lca) # Output should be 10 lca = bst.find_lca(10, 30) print(lca) # Output should be 20 # Example where one node is not present bst.insert(25) lca = bst.find_lca(25, 35) print(lca) # Output should be None ``` Additional validation: 1. If either `node1` or `node2` is not present in the BST, the `find_lca` method should return `None`.","solution":"class Node: def __init__(self, key: int): self.left = None self.right = None self.val = key class EnhancedBST: def __init__(self): self.root = None def insert(self, key: int) -> None: if not self.root: self.root = Node(key) else: self._insert(self.root, key) def _insert(self, root, key: int) -> None: if key < root.val: if root.left: self._insert(root.left, key) else: root.left = Node(key) else: if root.right: self._insert(root.right, key) else: root.right = Node(key) def find_height(self) -> int: return self._find_height(self.root) def _find_height(self, root) -> int: if not root: return -1 left_height = self._find_height(root.left) right_height = self._find_height(root.right) return max(left_height, right_height) + 1 def find_lca(self, node1: int, node2: int) -> int: return self._find_lca(self.root, node1, node2) def _find_lca(self, root, node1: int, node2: int): while root: if root.val > node1 and root.val > node2: root = root.left elif root.val < node1 and root.val < node2: root = root.right else: break node1_exists = self._find_node(self.root, node1) node2_exists = self._find_node(self.root, node2) if root and node1_exists and node2_exists: return root.val return None def _find_node(self, root, key: int) -> bool: if not root: return False if root.val == key: return True elif key < root.val: return self._find_node(root.left, key) else: return self._find_node(root.right, key)"},{"question":"# **Dictionary Key Reversal Function** Write a function `reverse_dict_keys(dict_input: dict[str, int]) -> dict[int, str]` that takes a dictionary with string keys and integer values and returns a new dictionary with the keys and values swapped. For this task: 1. **Input:** - `dict_input`: A dictionary where keys are strings and values are integers. 2. **Output:** - A dictionary where the original integer values are now the keys, and the original string keys are the values. 3. **Constraints:** - `dict_input` contains only unique values, so there will be no issues with duplicate keys in the reversed dictionary. 4. **Handling Errors:** - If `dict_input` contains non-string keys, raise a `TypeError` with the message `\\"All keys in dict_input must be strings\\"`. - If `dict_input` contains non-integer values, raise a `TypeError` with the message `\\"All values in dict_input must be integers\\"`. # Example Usage ```python >>> reverse_dict_keys({\\"one\\": 1, \\"two\\": 2, \\"three\\": 3}) {1: \'one\', 2: \'two\', 3: \'three\'} >>> reverse_dict_keys({\\"apple\\": 10, \\"banana\\": 20, \\"cherry\\": 30}) {10: \'apple\', 20: \'banana\', 30: \'cherry\'} >>> reverse_dict_keys({}) {} >>> reverse_dict_keys({\\"a\\": 1, \\"b\\": 2, \\"c\\": 2}) Traceback (most recent call last): ... ValueError: dict_input cannot have duplicate values >>> reverse_dict_keys({1: \\"one\\", 2: \\"two\\"}) Traceback (most recent call last): ... TypeError: All keys in dict_input must be strings >>> reverse_dict_keys({\\"one\\": \\"one\\", \\"two\\": 2}) Traceback (most recent call last): ... TypeError: All values in dict_input must be integers ``` Note: - Ensure the function handles empty dictionary input. - Ensure to manage the potential complexity regarding value-to-key reversal. - Validate the input to raise appropriate errors for improper data types. # Requirements * Correctly swap the keys and values in the dictionary. * Implement input validation to ensure type constraints are met. * Ensure the implementation handles edge cases effectively.","solution":"def reverse_dict_keys(dict_input: dict[str, int]) -> dict[int, str]: Returns a new dictionary with keys and values swapped from the input dictionary. Raises TypeError if keys are not strings or values are not integers. if not all(isinstance(k, str) for k in dict_input.keys()): raise TypeError(\\"All keys in dict_input must be strings\\") if not all(isinstance(v, int) for v in dict_input.values()): raise TypeError(\\"All values in dict_input must be integers\\") return {v: k for k, v in dict_input.items()}"},{"question":"# Flight Scheduling System You are tasked with developing a flight scheduling system using Python. The system must handle flight bookings between various cities. You need to provide functionality for adding new flights, booking seats, and checking available seats for any particular flight. Your solution should involve creating two classes: `Flight` and `FlightScheduler`. The `Flight` class will handle the individual flight details, and the `FlightScheduler` class will manage the overall scheduling of flights. # Requirements 1. Implement a class `Flight` with methods to: - `add_flight(self, flight_number: str, origin: str, destination: str, total_seats: int)`: Adds flight details. - `book_seat(self, number_of_seats: int) -> bool`: Books the requested number of seats if available. 2. Implement a class `FlightScheduler` with methods to: - `add_flight(self, flight: Flight)`: Adds a flight to the scheduler. - `available_seats(self, flight_number: str) -> int`: Returns the number of available seats for the specified flight. - `book_seat(self, flight_number: str, number_of_seats: int) -> str`: Books the requested number of seats on the specified flight and returns \\"Booking Confirmed\\" if successful, otherwise \\"Booking Failed\\". # Input - `add_flight` in `Flight`: Flight details such as `flight_number`, `origin`, `destination`, and the total number of seats. - `add_flight` in `FlightScheduler`: A `Flight` object. - `book_seat` in `FlightScheduler`: Flight number and the number of seats to be booked. - `available_seats` in `FlightScheduler`: Flight number. # Output - `book_seat` in `FlightScheduler`: Returns \\"Booking Confirmed\\" if seats are successfully booked, otherwise \\"Booking Failed\\". # Constraints - Flight numbers are unique strings. - There is no overbooking; seats cannot be booked if they are not available. # Example ```python class Flight: def __init__(self, flight_number: str, origin: str, destination: str, total_seats: int): self.flight_number = flight_number self.origin = origin self.destination = destination self.total_seats = total_seats self.booked_seats = 0 def book_seat(self, number_of_seats: int) -> bool: if self.total_seats - self.booked_seats >= number_of_seats: self.booked_seats += number_of_seats return True return False class FlightScheduler: def __init__(self): self.flights = {} def add_flight(self, flight: Flight): self.flights[flight.flight_number] = flight def available_seats(self, flight_number: str) -> int: if flight_number in self.flights: flight = self.flights[flight_number] return flight.total_seats - flight.booked_seats return 0 def book_seat(self, flight_number: str, number_of_seats: int) -> str: if flight_number in self.flights: flight = self.flights[flight_number] if flight.book_seat(number_of_seats): return \\"Booking Confirmed\\" return \\"Booking Failed\\" # Example: flight1 = Flight(\\"AB123\\", \\"New York\\", \\"Los Angeles\\", 100) schedule = FlightScheduler() schedule.add_flight(flight1) assert schedule.book_seat(\\"AB123\\", 1) == \\"Booking Confirmed\\" assert schedule.available_seats(\\"AB123\\") == 99 assert schedule.book_seat(\\"AB123\\", 101) == \\"Booking Failed\\" ```","solution":"class Flight: def __init__(self, flight_number: str, origin: str, destination: str, total_seats: int): self.flight_number = flight_number self.origin = origin self.destination = destination self.total_seats = total_seats self.booked_seats = 0 def book_seat(self, number_of_seats: int) -> bool: if self.total_seats - self.booked_seats >= number_of_seats: self.booked_seats += number_of_seats return True return False class FlightScheduler: def __init__(self): self.flights = {} def add_flight(self, flight: Flight): self.flights[flight.flight_number] = flight def available_seats(self, flight_number: str) -> int: if flight_number in self.flights: flight = self.flights[flight_number] return flight.total_seats - flight.booked_seats return 0 def book_seat(self, flight_number: str, number_of_seats: int) -> str: if flight_number in self.flights: flight = self.flights[flight_number] if flight.book_seat(number_of_seats): return \\"Booking Confirmed\\" return \\"Booking Failed\\""},{"question":"# Find Articulation Points in an Undirected Graph **Objective**: Implement an algorithm to identify all the articulation points in an undirected graph. An articulation point, or cut vertex, is a vertex that, when removed, increases the number of connected components in the graph. Input You are given a graph represented as an adjacency list, where `graph` is a dictionary such that `graph[v]` is a list of vertices adjacent to vertex `v`. Your function should accept a dictionary `graph` where the keys are vertex identifiers (integers starting from 0) and the values are lists of adjacent vertex identifiers. Output Return a sorted list of vertices that are articulation points in the graph. Constraints 1. Graph can have up to 10,000 vertices. 2. There may be multiple edges between two vertices. 3. Graph does not contain self-loops. 4. You must handle graphs with no edges and completely connected graphs. Example ```python def find_articulation_points(graph: dict[int, list[int]]) -> list[int]: Return the sorted list of articulation points [v1, v2, ..., vk] Example: >>> find_articulation_points({ >>> 0: [1, 2], >>> 1: [0, 2], >>> 2: [0, 1, 3, 5], >>> 3: [2, 4], >>> 4: [3], >>> 5: [2, 6, 8], >>> 6: [5, 7], >>> 7: [6, 8], >>> 8: [5, 7], >>> }) [2, 3, 5] Example for empty graph: >>> find_articulation_points({}) [] # Write your implementation here ``` Explanation In the above example: * Vertex 2 is an articulation point because removing it will disconnect vertex 3 and its connected vertices from the rest of the graph. * Vertex 3 is an articulation point because removing it will result in vertex 4 becoming disconnected. * Vertex 5 is an articulation point because removing it isolates vertices 6, 7, and 8. Ensure the returned list of articulation points is sorted. Write a clean and efficient function to solve this problem. **Hint**: Use Depth First Search (DFS) and the concept of discovery and low-link values to find the articulation points efficiently in O(V + E) time.","solution":"def find_articulation_points(graph: dict[int, list[int]]) -> list[int]: Return the sorted list of articulation points [v1, v2, ..., vk] def dfs(at, parent, visited, disc, low, time, articulation_points): children = 0 visited[at] = True disc[at] = low[at] = time[0] time[0] += 1 for to in graph[at]: if not visited[to]: children += 1 dfs(to, at, visited, disc, low, time, articulation_points) low[at] = min(low[at], low[to]) if parent == -1 and children > 1: articulation_points.add(at) if parent != -1 and low[to] >= disc[at]: articulation_points.add(at) elif to != parent: low[at] = min(low[at], disc[to]) visited = {} disc = {} low = {} articulation_points = set() time = [0] for vertex in graph: visited[vertex] = False disc[vertex] = float(\'inf\') low[vertex] = float(\'inf\') for vertex in graph: if not visited[vertex]: dfs(vertex, -1, visited, disc, low, time, articulation_points) return sorted(list(articulation_points))"},{"question":"# Problem Statement Implement a function `rotate_string` that determines if one string is a rotation of another. A string rotation is obtained by shifting its characters to the left or right and wrapping the overflow around. # Function Signature ```python def rotate_string(s1: str, s2: str) -> bool: pass ``` # Input * `s1`: A string containing only lowercase letters where 1 <= len(s1) <= 1000. * `s2`: A string containing only lowercase letters where 1 <= len(s2) <= 1000. # Output * Return `True` if `s2` is a rotation of `s1`, otherwise return `False`. # Constraints * You must achieve a time complexity of O(n) where n is the length of the strings. # Example ```python assert rotate_string(\\"waterbottle\\", \\"erbottlewat\\") == True assert rotate_string(\\"rotation\\", \\"tationro\\") == True assert rotate_string(\\"hello\\", \\"llohe\\") == True assert rotate_string(\\"abcde\\", \\"abced\\") == False assert rotate_string(\\"abc\\", \\"abc\\") == True ``` # Notes * Consider edge cases where the strings have different lengths. * If either string is empty, return `False`.","solution":"def rotate_string(s1: str, s2: str) -> bool: Determines if s2 is a rotation of s1. Args: s1: A string containing only lowercase letters. s2: A string containing only lowercase letters. Returns: True if s2 is a rotation of s1, otherwise False. if len(s1) != len(s2): return False concatenated = s1 + s1 return s2 in concatenated"},{"question":"# Given Task You are required to create a function that generates a string representation of a right-aligned staircase of integers. The left-hand edge of the staircase should be aligned at the rightmost edge of the console. # Function Signature ```python def right_aligned_staircase(steps: int) -> str: pass ``` # Input * `steps`: An integer representing the height of the staircase (1 ≤ steps ≤ 200) # Output * A string representing the staircase with each level appropriately indented to form the right-aligned staircase. # Example ```python >>> print(right_aligned_staircase(5)) 1 12 123 1234 12345 >>> print(right_aligned_staircase(3)) 1 12 123 ``` # Edge Cases * Ensure that for the minimum value of `steps`, the function still outputs the correct result (one-step staircase). * Handle the maximum value of `steps` efficiently without unnecessary computations or delays. * The resulting staircase should not have any trailing spaces or unnecessary newlines. Write the implementation for the function `right_aligned_staircase` ensuring it handles the conditions mentioned above correctly.","solution":"def right_aligned_staircase(steps: int) -> str: staircase = [] for i in range(1, steps + 1): line = \' \' * (steps - i) + \'\'.join(str(x) for x in range(1, i + 1)) staircase.append(line) return \'n\'.join(staircase)"},{"question":"# Coding Question **Scenario**: You are developing a feature for a recipe application that categorizes recipes based on their ingredients. A recipe can only belong to one category and it must include all the sub-ingredients of that category to qualify. Your goal is to write a function that, given a set of recipes and categories, determines the category for each recipe. Each category is defined by a set of sub-ingredients. A recipe includes a category if all the sub-ingredients of that category are present in the recipe. Only one category can be assigned to each recipe, so if multiple categories match, the category with the most sub-ingredients will be the final choice. **Question**: Implement a function `assign_category(recipes: List[Set[str]], categories: Dict[str, Set[str]]) -> List[str]` that determines the category for each recipe. **Input**: - `recipes`: A list of sets, where each set contains strings representing the ingredients of a recipe. - `categories`: A dictionary where keys are strings representing category names and values are sets of strings representing sub-ingredients that define each category. **Output**: - A list of strings where each string represents the category assigned to the corresponding recipe in the input list. **Constraints**: - Categories are mutually exclusive. - A recipe can belong to at most one category. - If a recipe satisfies no category, it should be assigned an empty string `\\"\\"`. # Examples 1. `assign_category([{\\"chicken\\", \\"salt\\", \\"pepper\\"}, {\\"flour\\", \\"egg\\", \\"milk\\"}, {\\"flour\\", \\"sugar\\", \\"butter\\"}], {\\"Meat\\": {\\"chicken\\", \\"salt\\"}, \\"Baking\\": {\\"flour\\", \\"butter\\"}, \\"Dessert\\": {\\"sugar\\", \\"butter\\"}})` should return `[\\"Meat\\", \\"\\", \\"Baking\\"]`. 2. `assign_category([{\\"potato\\", \\"cheese\\", \\"salt\\"}, {\\"fish\\", \\"salt\\", \\"lemon\\"}], {\\"Vegetarian\\": {\\"potato\\", \\"cheese\\"}, \\"Seafood\\": {\\"fish\\", \\"lemon\\"}})` should return `[\\"Vegetarian\\", \\"Seafood\\"]`. # Function Signature ```python from typing import List, Set, Dict def assign_category(recipes: List[Set[str]], categories: Dict[str, Set[str]]) -> List[str]: pass ``` **Hint**: - Iterate through each recipe and check each category to determine the best fit. - Ensure to handle conflicts by choosing the category with the largest set of sub-ingredients if multiple categories apply.","solution":"from typing import List, Set, Dict def assign_category(recipes: List[Set[str]], categories: Dict[str, Set[str]]) -> List[str]: result = [] for recipe in recipes: best_category = \\"\\" max_subs = 0 for category, sub_ingredients in categories.items(): if sub_ingredients.issubset(recipe) and len(sub_ingredients) > max_subs: best_category = category max_subs = len(sub_ingredients) result.append(best_category) return result"},{"question":"# Coding Assessment Task: Inventory Management System Context You have been hired to implement a simplified inventory management system for a small warehouse. The system should be able to add products, update inventory levels, and remove products. Additionally, it should provide a way to retrieve the list of products that are low in stock (below a certain threshold). Task Write a Python class `Inventory` that: 1. Allows adding new products by providing a product name and its initial stock level. 2. Supports updating the stock level for existing products. 3. Enables removing products from the inventory. 4. Provides a method to retrieve a list of products with stock below a given threshold. Class Definition ```python class Inventory: def __init__(self): # Initializes an empty inventory def add_product(self, product_name: str, initial_stock: int): # Adds a new product with the initial stock def update_stock(self, product_name: str, new_stock: int): # Updates the stock level for an existing product def remove_product(self, product_name: str): # Removes a product from the inventory def get_low_stock_products(self, threshold: int) -> List[str]: # Returns a list of product names with stock below the threshold ``` Input Format - `product_name` (str): A string representing the name of the product. - `initial_stock` (int): An integer representing the initial stock level of the product. - `new_stock` (int): An integer representing the updated stock level of the product. - `threshold` (int): An integer representing the stock level threshold. Output Format - `get_low_stock_products` method should return a list of strings, where each string is the name of a product low in stock. Constraints - Product names are unique. - Stock levels are non-negative integers. - Proper handling for cases where a product is not found or already exists should be implemented. Example ```python >>> inventory = Inventory() >>> inventory.add_product(\\"Apples\\", 10) >>> inventory.add_product(\\"Oranges\\", 5) >>> inventory.update_stock(\\"Apples\\", 3) >>> inventory.remove_product(\\"Oranges\\") >>> inventory.get_low_stock_products(5) [\\"Apples\\"] ``` Performance Requirements - The class methods should perform efficiently, even when handling large inventories. Notes - Use a dictionary to store the inventory for optimal performance. - Proper error handling for invalid operations (e.g., updating stock for a non-existent product) should be implemented.","solution":"class Inventory: def __init__(self): self.inventory = {} def add_product(self, product_name: str, initial_stock: int): if product_name in self.inventory: raise ValueError(f\\"Product \'{product_name}\' already exists in the inventory.\\") if initial_stock < 0: raise ValueError(\\"Initial stock cannot be a negative number.\\") self.inventory[product_name] = initial_stock def update_stock(self, product_name: str, new_stock: int): if product_name not in self.inventory: raise ValueError(f\\"Product \'{product_name}\' not found in the inventory.\\") if new_stock < 0: raise ValueError(\\"New stock cannot be a negative number.\\") self.inventory[product_name] = new_stock def remove_product(self, product_name: str): if product_name not in self.inventory: raise ValueError(f\\"Product \'{product_name}\' not found in the inventory.\\") del self.inventory[product_name] def get_low_stock_products(self, threshold: int) -> list: if threshold < 0: raise ValueError(\\"Threshold cannot be a negative number.\\") return [product for product, stock in self.inventory.items() if stock < threshold]"},{"question":"# Question: Matrix Rotation Checker Context: A common operation in image processing and computer graphics is rotating a matrix. While you can rotate a matrix by 90, 180, or 270 degrees clockwise, it is often necessary to validate if a given matrix can be transformed into another matrix by any of these rotations. Task: Implement a function `can_rotate_to(original: list[list[int]], target: list[list[int]]) -> bool` that determines if the matrix `original` can be rotated by 90, 180, or 270 degrees clockwise to become the matrix `target`. Requirements: * **Input Formats**: - `original` and `target` are two-dimensional lists (each representing an n x n matrix). - Elements of the matrices are integers. * **Output Format**: - Returns `True` if `original` can be rotated to become `target`; `False` otherwise. * **Constraints**: - Matrix dimensions (n x n) are such that 1 ≤ n ≤ 100. - All elements in the matrix are integers in the range -1000 to 1000. Example: ```python original = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] target_90 = [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] target_180 = [ [9, 8, 7], [6, 5, 4], [3, 2, 1] ] target_270 = [ [3, 6, 9], [2, 5, 8], [1, 4, 7] ] target_no_rotation = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] assert can_rotate_to(original, target_90) == True assert can_rotate_to(original, target_180) == True assert can_rotate_to(original, target_270) == True assert can_rotate_to(original, target_no_rotation) == True ``` Note: You must follow the structure for the `can_rotate_to` function provided below. ```python def can_rotate_to(original: list[list[int]], target: list[list[int]]) -> bool: # Implementation here ``` Testing: Ensure your implementation passes the following doctests: ```python >>> original = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> target_90 = [ ... [7, 4, 1], ... [8, 5, 2], ... [9, 6, 3] ... ] >>> target_180 = [ ... [9, 8, 7], ... [6, 5, 4], ... [3, 2, 1] ... ] >>> target_no_rotation = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> can_rotate_to(original, target_90) True >>> can_rotate_to(original, target_180) True >>> can_rotate_to(original, target_no_rotation) True ```","solution":"def rotate_90_degrees(matrix): return [list(row) for row in zip(*matrix[::-1])] def rotate_180_degrees(matrix): return [row[::-1] for row in matrix[::-1]] def rotate_270_degrees(matrix): return [list(row) for row in zip(*matrix)][::-1] def can_rotate_to(original: list[list[int]], target: list[list[int]]) -> bool: if original == target: return True if rotate_90_degrees(original) == target: return True if rotate_180_degrees(original) == target: return True if rotate_270_degrees(original) == target: return True return False"},{"question":"# Coding Assessment Question Objective You need to determine if a given string is a \\"Happy String.\\" A \\"Happy String\\" is a string that has no two consecutive characters that are the same. Write a function that checks if the provided string meets this condition. Function Signature ```python def is_happy_string(s: str) -> bool: :param s: str, the string to be checked. :return: bool, True if the string is a \\"Happy String\\", otherwise False. Constraints: 1 <= len(s) <= 1000 s consists only of lowercase English letters. Example: >>> is_happy_string(\\"abc\\") True >>> is_happy_string(\\"aabb\\") False >>> is_happy_string(\\"a\\") True >>> is_happy_string(\\"abacaba\\") True >>> is_happy_string(\\"aa\\") False ``` Guidelines 1. **Core Requirements**: - Implement a function that iterates through the string and checks for consecutive characters. - Ensure the input parameters fall within the constraints: `1 <= len(s) <= 1000` and `s` consists of only lowercase English letters. 2. **Expected Input/Output**: - Input: A single string `s`. - Output: A boolean value indicating if the string is a \\"Happy String\\". 3. **Performance**: - The solution should run efficiently within the provided constraints. 4. **Edge Cases**: - Properly handle the scenario with the smallest and largest possible string lengths. - Handle cases where the string contains maximum diversity in characters. 5. **Error Handling**: - Assume that the input will always be a valid string composed of lowercase English letters. Good Luck!","solution":"def is_happy_string(s: str) -> bool: Returns True if the provided string is a \\"Happy String\\", otherwise False. A \\"Happy String\\" is a string that has no two consecutive characters that are the same. :param s: str, the string to be checked. :return: bool, True if the string is a \\"Happy String\\", otherwise False. for i in range(1, len(s)): if s[i] == s[i-1]: return False return True"},{"question":"Optimized Merge Sort with Statistics Scenario: You are assigned to modify the existing Merge Sort algorithm to capture additional statistics during its execution. This enhanced version will provide useful insights such as the number of times the merge function was called and the total number of comparisons made during the sorting process. Task: Implement the function `optimized_merge_sort` with the following signature: ```python from typing import List, Tuple def optimized_merge_sort(collection: List[int]) -> Tuple[List[int], int, int]: ``` * **Parameters**: - `collection`: A list of integers to be sorted. * **Returns**: - A tuple containing three elements: 1. A new sorted list. 2. The number of times the merge function was called. 3. The total number of comparisons made during the sorting process. * **Constraints**: - The provided list can be empty or contain up to (10^5) integers. * **Example**: ```python # Example usage: sorted_list, merge_calls, comparisons = optimized_merge_sort([38, 27, 43, 3, 9, 82, 10]) # sorted_list: [3, 9, 10, 27, 38, 43, 82] # merge_calls: 10 # comparisons: 13 sorted_list, merge_calls, comparisons = optimized_merge_sort([1, 2, 3, 4, 5]) # sorted_list: [1, 2, 3, 4, 5] # merge_calls: 4 # comparisons: 4 ``` Note: - Ensure the Merge Sort maintains its typical time complexity of (O(n log n)). - Efficiently implement the statistics gathering without significant impact on the performance or simplicity of the algorithm. - Properly handle edge cases, such as empty lists and single-element lists. - Carefully track the number of merge function calls and comparisons to ensure accuracy in the returned statistics.","solution":"from typing import List, Tuple def optimized_merge_sort(collection: List[int]) -> Tuple[List[int], int, int]: Perform Merge Sort while collecting statistics on number of merge function calls and the number of comparisons made. :param collection: the list of integers to sort :return: (sorted list, number of merge calls, number of comparisons made) merge_calls = 0 comparisons = 0 def merge(left: List[int], right: List[int]) -> List[int]: nonlocal merge_calls, comparisons merge_calls += 1 sorted_list = [] i = j = 0 while i < len(left) and j < len(right): comparisons += 1 if left[i] < right[j]: sorted_list.append(left[i]) i += 1 else: sorted_list.append(right[j]) j += 1 while i < len(left): sorted_list.append(left[i]) i += 1 while j < len(right): sorted_list.append(right[j]) j += 1 return sorted_list def merge_sort(lst: List[int]) -> List[int]: if len(lst) <= 1: return lst mid = len(lst) // 2 left = merge_sort(lst[:mid]) right = merge_sort(lst[mid:]) return merge(left, right) sorted_collection = merge_sort(collection) return sorted_collection, merge_calls, comparisons"},{"question":"# Palindrome Permutation: Efficient Character Count Evaluation **Scenario**: A software company is developing a text analysis tool to identify potential palindrome permutations in given strings. This feature aims to enhance search algorithms focused on detecting mirrored word patterns. **Task**: Write a function that determines if any permutation of a given string can form a palindrome. A palindrome is a string that reads the same forward and backward. **Input**: - A single string consisting of lowercase alphabets and/or digits. **Output**: - A boolean value indicating whether a permutation of the string can form a palindrome. **Constraint**: - The input string will have at most 10,000 characters. **Performance Requirements**: - Ensure the solution is optimized to handle large inputs efficiently. **Function Signature**: ```python def can_form_palindrome(s: str) -> bool: pass ``` **Example**: ```python # Test with different strings print(can_form_palindrome(\\"code\\")) # Output: False print(can_form_palindrome(\\"aab\\")) # Output: True print(can_form_palindrome(\\"carerac\\")) # Output: True print(can_form_palindrome(\\"123321\\")) # Output: True print(can_form_palindrome(\\"abcdba\\")) # Output: False ``` # Solution To determine if any permutation of a string can form a palindrome, count the occurrences of each character. A string can form a palindrome if at most one character has an odd count. This requirement stems from the fact that a palindrome must mirror around its center.","solution":"def can_form_palindrome(s: str) -> bool: from collections import Counter # Count the frequency of each character in the string count = Counter(s) # Compute the number of characters that have an odd frequency odd_count = sum(1 for freq in count.values() if freq % 2 != 0) # A string can be rearranged to form a palindrome if it has at most one character with an odd frequency return odd_count <= 1"},{"question":"# Coding Assessment: Write and Parse JSON Data Efficiently Objective You are required to write Python functions to write and parse JSON data for user profiles. Your solution should be efficient and handle potential errors gracefully. Requirements 1. **Function 1: `write_user_profile(name: str, age: int, hobbies: list) -> str`** - Input: - `name` - A string representing the user\'s name. - `age` - An integer representing the user\'s age. - `hobbies` - A list of strings representing the user\'s hobbies. - Output: - A JSON string representing the user profile. - Constraints: - The name should be a non-empty string. - The age should be a positive integer. - The hobbies list should contain non-empty strings. - If any input data is invalid, return an appropriate error message as a JSON string. 2. **Function 2: `parse_user_profile(json_data: str) -> dict`** - Input: - `json_data` - A JSON string representing the user profile. - Output: - A dictionary containing the parsed user profile with keys: - \'Name\' for the user\'s name - \'Age\' for the user\'s age - \'Hobbies\' for the user\'s hobbies - If the JSON string is invalid, or a required field is missing, return an appropriate error message as a dictionary. Performance Requirements - Your solution should handle large user profiles efficiently. - Consider handling any parsing errors or invalid JSON data gracefully without breaking the program flow. Example ```python >>> profile_json = write_user_profile(\\"John Doe\\", 30, [\\"Reading\\", \\"Cycling\\"]) >>> print(profile_json) \'{\\"Name\\": \\"John Doe\\", \\"Age\\": 30, \\"Hobbies\\": [\\"Reading\\", \\"Cycling\\"]}\' >>> user_profile = parse_user_profile(profile_json) >>> print(user_profile) { \\"Name\\": \\"John Doe\\", \\"Age\\": 30, \\"Hobbies\\": [\\"Reading\\", \\"Cycling\\"] } >>> invalid_profile_json = \'Invalid JSON data\' >>> user_profile = parse_user_profile(invalid_profile_json) >>> print(user_profile) { \\"error\\": \\"Invalid JSON data\\" } ``` Notes 1. Pay attention to the structure and validity of input data and handle them properly using appropriate error messages. 2. Make sure that your JSON parsing handles missing data fields gracefully and includes default values or error messages where necessary. Constraints - Ensure the name passed is a non-empty string. - Ensure the age is a positive integer. - Ensure the hobbies list is not empty and contains non-empty strings only. - Handle invalid JSON strings and missing fields properly.","solution":"import json def write_user_profile(name: str, age: int, hobbies: list) -> str: Takes a name, age, and hobbies list to create a JSON string representing a user profile. Returns a JSON string or an error message. if not isinstance(name, str) or not name: return json.dumps({\\"error\\": \\"Invalid name\\"}) if not isinstance(age, int) or age <= 0: return json.dumps({\\"error\\": \\"Invalid age\\"}) if not isinstance(hobbies, list) or not all(isinstance(hobby, str) and hobby for hobby in hobbies): return json.dumps({\\"error\\": \\"Invalid hobbies\\"}) profile = { \\"Name\\": name, \\"Age\\": age, \\"Hobbies\\": hobbies } return json.dumps(profile) def parse_user_profile(json_data: str) -> dict: Takes a JSON string representing a user profile and returns a dictionary containing the profile data. Returns an error message if the JSON string is invalid or lacks required fields. try: profile = json.loads(json_data) except json.JSONDecodeError: return {\\"error\\": \\"Invalid JSON data\\"} if \\"Name\\" not in profile or not profile[\\"Name\\"]: return {\\"error\\": \\"Missing or empty \'Name\'\\"} if \\"Age\\" not in profile or not isinstance(profile[\\"Age\\"], int) or profile[\\"Age\\"] <= 0: return {\\"error\\": \\"Invalid or missing \'Age\'\\"} if \\"Hobbies\\" not in profile or not isinstance(profile[\\"Hobbies\\"], list) or not all(isinstance(hobby, str) and hobby for hobby in profile[\\"Hobbies\\"]): return {\\"error\\": \\"Invalid or missing \'Hobbies\'\\"} return profile"},{"question":"# Problem Statement You are tasked with creating a function that will generate the n-th term of the Fibonacci sequence. The Fibonacci sequence is defined as follows: - `F(0) = 0` - `F(1) = 1` - For any integer n ≥ 2, `F(n) = F(n-1) + F(n-2)` # Task Design a function `fibonacci(n: int) -> int` that takes an integer `n` and returns the n-th term in the Fibonacci sequence. # Input - An integer `n` where `0 <= n <= 30` represents the position in the Fibonacci sequence. # Output - An integer representing the n-th term in the Fibonacci sequence. # Constraints - `0 <= n <= 30`, ensuring that the function doesn\'t need to handle very large values which could result in long computation times. # Example ```python >>> fibonacci(0) 0 >>> fibonacci(1) 1 >>> fibonacci(5) 5 >>> fibonacci(10) 55 >>> fibonacci(30) 832040 ``` # Detailed Requirements 1. Ensure the function handles the base cases `n = 0` and `n = 1` correctly. 2. Implement an efficient solution that computes the Fibonacci number using either an iterative approach or memoization to avoid recalculations. 3. The function should pass the provided example test cases.","solution":"def fibonacci(n): Returns the n-th term in the Fibonacci sequence. Parameters: n (int): The position in the Fibonacci sequence (0 <= n <= 30) Returns: int: The n-th term in the Fibonacci sequence. if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"# Coding Question Given a string, return the total number of words in the string that are palindromes. A palindrome is a word that reads the same backward as forward. Assume words are separated by spaces and the string contains only lowercase alphabetical characters. # Function Signature ```python def count_palindrome_words(s: str) -> int: pass ``` # Input * `s` (str): A string containing words separated by spaces. # Output * `int`: The total number of palindrome words in the string. # Constraints * 1 <= len(s) <= 10^6 * The string `s` contains only lowercase alphabetical characters and spaces. * Words are separated by single spaces and there are no leading or trailing spaces. # Example ```python assert count_palindrome_words(\\"madam arora teaches malayalam\\") == 3 assert count_palindrome_words(\\"nurses run\\") == 1 assert count_palindrome_words(\\"hello world\\") == 0 ``` # Explanation - For the first example, the palindromic words are \\"madam\\", \\"arora\\", and \\"malayalam\\", making the total count 3. - For the second example, \\"nurses\\" and \\"run\\" are not palindromes, but when considered separately, \\"run\\" is a palindrome, and thus the count is 1. - For the third example, neither \\"hello\\" nor \\"world\\" are palindromes, so the total count is 0. **Considerations**: - Split the input string into words. - Check each word individually to see if it is a palindrome. - Ensure the solution handles the upper limit of the string length efficiently.","solution":"def count_palindrome_words(s: str) -> int: Returns the total number of palindrome words in a given string. words = s.split() palindrome_count = 0 for word in words: if word == word[::-1]: palindrome_count += 1 return palindrome_count"},{"question":"# Coding Question: Balancing a Binary Search Tree You are given a Binary Search Tree (BST) with `n` nodes. The height of the BST can range from ( log n ) to ( n ). Your task is to implement a function that converts an unbalanced BST into a balanced BST while preserving the original in-order traversal sequence (i.e., the values should be the same, but the tree should be balanced). # Requirements: - Implement the function `balance_bst(root: TreeNode) -> TreeNode` where `TreeNode` is a structure representing a node in the BST with properties: `val`, `left`, and `right`. - The function should return the root node of the balanced BST. - Ensure that the returned tree\'s height is minimized as much as possible while preserving the in-order values. # Constraints: - The input tree might be highly unbalanced. - The number of nodes `n` in the tree is such that (1 leq n leq 10^5). - The values in the BST fit within the 32-bit signed integer range. # Input: - A root node of a BST which is an instance of `TreeNode`. # Output: - The root node of the balanced BST. # Example: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def balance_bst(root: TreeNode) -> TreeNode: # Your implementation here. pass # Example Usage: # Creating an unbalanced BST root = TreeNode(1) root.right = TreeNode(2) root.right.right = TreeNode(3) root.right.right.right = TreeNode(4) root.right.right.right.right = TreeNode(5) balanced_root = balance_bst(root) def inorder_traversal(root): return inorder_traversal(root.left) + [root.val] + inorder_traversal(root.right) if root else [] print(inorder_traversal(balanced_root)) # Example Output: [1, 2, 3, 4, 5] ``` # Additional Context: You might find it useful to implement utility functions for in-order traversal and tree construction: - **In-order Traversal**: Collect all nodes into a list. - **Balanced Tree Construction**: Build a balanced BST from a sorted list of nodes. This question assesses your understanding of tree data structures, recursion, and depth-first search techniques. Ensure that your solution optimally balances the tree, handles edge cases, and preserves the correct sequence of values. Use standard libraries as needed, and ensure your code is clean, efficient, and well-documented.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def balance_bst(root: TreeNode) -> TreeNode: def inorder_traversal(node): if not node: return [] return inorder_traversal(node.left) + [node.val] + inorder_traversal(node.right) def sorted_list_to_bst(lst): if not lst: return None mid = len(lst) // 2 root = TreeNode(lst[mid]) root.left = sorted_list_to_bst(lst[:mid]) root.right = sorted_list_to_bst(lst[mid + 1:]) return root sorted_values = inorder_traversal(root) return sorted_list_to_bst(sorted_values)"},{"question":"You are provided with an algorithm to convert infix expressions to postfix expressions utilizing a stack. The algorithm adheres to the standard operator precedence and associativity rules. Write a function `infix_to_postfix(expression: str) -> str` that converts a given infix expression to its equivalent postfix expression. # Task Write a function `infix_to_postfix(expression: str) -> str` that converts an infix expression to a postfix expression using the standard rules of operator precedence and associativity. # Input A single string `expression` which contains a valid mathematical infix expression. The expression consists of non-negative integers, operators `+`, `-`, `*`, `/`, and parentheses `(` and `)`. # Output Return the equivalent postfix expression as a string. # Constraints - The expression is a valid infix expression. - The length of the expression will be at most 1000 characters. - Integers in the expression are non-negative and will be in the range (0 le text{integer} le 10^9). # Example ```python # Example case 1 expression = \\"3 + 4 * 2 / ( 1 - 5 )\\" infix_to_postfix(expression) # \\"3 4 2 * 1 5 - / +\\" # Example case 2 expression = \\"( 1 + 2 ) * ( 3 / 4 ) - 5\\" infix_to_postfix(expression) # \\"1 2 + 3 4 / * 5 -\\" ``` # Implementation Notes 1. Create a function to handle the precedence of operators. 2. Utilize a stack to properly order operators according to their precedence and associativity. 3. Convert the entire infix expression into its corresponding postfix format using the stack and precedence rules. Ensure your function handles edge cases such as multiple consecutive operators and nested parentheses appropriately.","solution":"def infix_to_postfix(expression: str) -> str: precedence = {\'+\': 1, \'-\': 1, \'*\': 2, \'/\': 2} def get_precedence(op): return precedence.get(op, 0) def is_operator(c): return c in precedence def is_operand(c): return c.isdigit() output = [] stack = [] tokens = expression.split() for token in tokens: if is_operand(token): output.append(token) elif token == \'(\': stack.append(token) elif token == \')\': while stack and stack[-1] != \'(\': output.append(stack.pop()) stack.pop() elif is_operator(token): while (stack and stack[-1] != \'(\' and get_precedence(stack[-1]) >= get_precedence(token)): output.append(stack.pop()) stack.append(token) while stack: output.append(stack.pop()) return \\" \\".join(output)"},{"question":"# Problem Statement Scenario: You have been assigned to develop a scheduling algorithm for a university\'s course registration system. The system should automatically assign course time slots to rooms while ensuring that no room is double-booked at any given time. Additionally, certain courses have prerequisites and must be scheduled accordingly. Your task is to create a function that schedules these courses based on the given constraints. Task: Implement the required functions to facilitate the scheduling process, ensuring that all courses are assigned without conflicts and prerequisite courses are scheduled before dependent courses. The system should also handle potential infeasibility due to constraints, providing an appropriate response. Requirements: - Define a function `generate_schedule(courses: list[dict], rooms: list[str], time_slots: list[str]) -> dict` that assigns courses to rooms and time slots, considering the constraints. - Define a function `check_prerequisites(schedule: dict, courses: list[dict]) -> bool` to ensure that all prerequisite constraints are met. - Use topological sorting or any appropriate algorithm to handle prerequisite handling and conflict resolution. Inputs: 1. `courses` (list[dict]): A list of dictionaries, where each dictionary represents a course with keys: - `course_id` (str): Unique identifier of the course. - `name` (str): Name of the course. - `prerequisites` (list[str]): List of course IDs that are prerequisites for this course. 2. `rooms` (list[str]): A list of strings representing the available rooms. 3. `time_slots` (list[str]): A list of strings representing the available time slots. Outputs: - Returns a dictionary where keys are tuples of (room, time_slot) and values are course IDs indicating which course is scheduled in that room at that time slot. Constraints: - There are no more than 50 courses. - There are no more than 20 rooms. - There are no more than 10 time slots. - Prerequisites relationships form a Directed Acyclic Graph (DAG). Example: ```python courses = [ {\'course_id\': \'C1\', \'name\': \'Calculus I\', \'prerequisites\': []}, {\'course_id\': \'C2\', \'name\': \'Physics I\', \'prerequisites\': []}, {\'course_id\': \'C3\', \'name\': \'Calculus II\', \'prerequisites\': [\'C1\']}, {\'course_id\': \'C4\', \'name\': \'Physics II\', \'prerequisites\': [\'C2\']} ] rooms = [\'Room1\', \'Room2\'] time_slots = [\'08:00-09:00\', \'09:00-10:00\'] # Expected Output: # { # (\'Room1\', \'08:00-09:00\'): \'C1\', # (\'Room2\', \'08:00-09:00\'): \'C2\', # (\'Room1\', \'09:00-10:00\'): \'C3\', # (\'Room2\', \'09:00-10:00\'): \'C4\' # } ``` Code Usage: ```python if __name__ == \\"__main__\\": courses = [ {\'course_id\': \'C1\', \'name\': \'Calculus I\', \'prerequisites\': []}, {\'course_id\': \'C2\', \'name\': \'Physics I\', \'prerequisites\': []}, {\'course_id\': \'C3\', \'name\': \'Calculus II\', \'prerequisites\': [\'C1\']}, {\'course_id\': \'C4\', \'name\': \'Physics II\', \'prerequisites\': [\'C2\']} ] rooms = [\'Room1\', \'Room2\'] time_slots = [\'08:00-09:00\', \'09:00-10:00\'] schedule = generate_schedule(courses, rooms, time_slots) print(schedule) ``` Ensure your implementation accurately handles various constraints and edge cases, such as potential scheduling conflicts and prerequisite violations.","solution":"from collections import defaultdict, deque def generate_schedule(courses, rooms, time_slots): def topological_sort(courses): graph = defaultdict(list) indegree = {course[\'course_id\']: 0 for course in courses} for course in courses: for prereq in course[\'prerequisites\']: graph[prereq].append(course[\'course_id\']) indegree[course[\'course_id\']] += 1 queue = deque([course[\'course_id\'] for course in courses if indegree[course[\'course_id\']] == 0]) sorted_courses = [] while queue: course_id = queue.popleft() sorted_courses.append(course_id) for neighbor in graph[course_id]: indegree[neighbor] -= 1 if indegree[neighbor] == 0: queue.append(neighbor) if len(sorted_courses) != len(courses): return [] return sorted_courses sorted_courses = topological_sort(courses) if not sorted_courses: return \\"Scheduling is not possible due to a cycle in prerequisites.\\" schedule = {} course_idx = 0 for time_slot in time_slots: for room in rooms: if course_idx < len(sorted_courses): schedule[(room, time_slot)] = sorted_courses[course_idx] course_idx += 1 return schedule def check_prerequisites(schedule, courses): course_dict = {course[\'course_id\']: course for course in courses} completion_time = {} for (room, time_slot), course_id in schedule.items(): completion_time[course_id] = time_slot for (room, time_slot), course_id in schedule.items(): for prereq_id in course_dict[course_id][\'prerequisites\']: if completion_time[prereq_id] >= time_slot: return False return True"},{"question":"# Unique Characters Count Context: In many text processing applications, it is important to know the distinct number of characters in a given text. This can be useful for tasks such as compression, data comparison, and more. Your task is to implement a function that counts the number of unique characters in a given input string. Task: Implement the function `count_unique_chars(text: str) -> int`, which computes the number of distinct characters in the given input string. Input: - **text**: A single string input `0 <= len(text) <= 10^6`. Output: - A single integer representing the number of unique characters in the input text. Constraints: 1. The function should handle empty strings by returning 0. 2. Characters in the input string will be limited to basic ASCII (character code range 32-126). Example: ```python text = \\"Hello, World!\\" print(count_unique_chars(text)) # Output: 10 text = \\"abcdabcd\\" print(count_unique_chars(text)) # Output: 4 ``` Performance Requirements: - Your implementation should efficiently handle input strings up to 1 million characters.","solution":"def count_unique_chars(text: str) -> int: Returns the number of unique characters in the given input string. Parameters: text (str): The input text to evaluate. Returns: int: The number of unique characters in the input text. return len(set(text))"},{"question":"# Question: Optimizing Water Distribution Using Minimum Spanning Tree Background In a town, there are several water wells, and some ways (pipes) to connect them, which have different costs. Your task is to find the minimum cost to supply water to all the houses in the town. You are given a list of costs to drill a well for each house and a list of costs to build pipes between the houses. You need to write a function to determine the minimum cost required to supply water to all houses, using either wells or pipes. Function Signature ```python def min_cost_to_supply_water(n: int, wells: List[int], pipes: List[Tuple[int, int, int]]) -> int: Calculate the minimum cost to supply water to all houses. n: The number of houses (1-indexed). wells: A list of costs for drilling a well at each house. pipes: A list of tuples representing the cost to build a pipe between two houses (house1, house2, cost). Returns the minimum cost required to supply water to all houses. ``` Input * `n`: An integer representing the number of houses. * `wells`: A list of integers where the `i`-th element represents the cost of drilling a well at the `(i+1)`-th house. * `pipes`: A list of tuples where each tuple `(house1, house2, cost)` represents the cost to build a pipe between `house1` and `house2`. Constraints: * (1 leq n leq 10^4) * (1 leq cost leq 10^5) * Wells list will always have (n) elements. * Pipes list can have up to (10^5) elements. Output * An integer representing the minimum cost to supply water to all houses. Example Usage ```python print(min_cost_to_supply_water(3, [1, 2, 2], [(1, 2, 1), (2, 3, 1)])) # Output: 3 print(min_cost_to_supply_water(2, [1, 1], [(1, 2, 2)])) # Output: 2 print(min_cost_to_supply_water(4, [2, 2, 2, 2], [])) # Output: 8 ``` Notes * Implement using Kruskal\'s or Prim\'s algorithm to solve the Minimum Spanning Tree problem. * Ensure your code handles large inputs efficiently. * Consider edge cases such as when there are no pipes or when the cost of wells is extremely high compared to pipes.","solution":"from typing import List, Tuple import heapq def min_cost_to_supply_water(n: int, wells: List[int], pipes: List[Tuple[int, int, int]]) -> int: def find(parent, i): if parent[i] != i: parent[i] = find(parent, parent[i]) return parent[i] def union(parent, rank, x, y): rootX = find(parent, x) rootY = find(parent, y) if rootX != rootY: if rank[rootX] > rank[rootY]: parent[rootY] = rootX elif rank[rootX] < rank[rootY]: parent[rootX] = rootY else: parent[rootY] = rootX rank[rootX] += 1 total_cost = 0 all_edges = pipes[:] # Copying pipes to avoid mutating the input for i, cost in enumerate(wells): all_edges.append((0, i + 1, cost)) # Start Kruskal\'s algorithm all_edges.sort(key=lambda x: x[2]) # Sort edges by cost parent = [i for i in range(n + 1)] rank = [0] * (n + 1) for u, v, cost in all_edges: if find(parent, u) != find(parent, v): union(parent, rank, u, v) total_cost += cost return total_cost"},{"question":"# Problem: **Inverted Binary Tree** A binary tree is a data structure where each node has at most two children referred to as the left child and the right child. Inverting a binary tree (also known as mirroring the binary tree) means creating a new binary tree that is the mirror image of the original binary tree. You are required to write a function `invertTree` that inverts a given binary tree. Function Signature: ```python def invertTree(root: TreeNode) -> TreeNode: pass ``` Input: - `root`: The root of the binary tree (TreeNode) Output: - Return the root of the inverted binary tree (TreeNode) Example: Suppose the binary tree is defined as follows: ``` 4 / 2 7 / / 1 3 6 9 ``` After inverting, the structure should be: ``` 4 / 7 2 / / 9 6 3 1 ``` # Constraints: 1. The number of nodes in the tree is in the range [0, 100]. 2. -100 <= Node.val <= 100 Performance Requirements: - Ensure the function runs efficiently with O(N) time complexity, where N is the number of nodes in the binary tree. Example: ```python # Example tree construction class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right # Example usage root = TreeNode(4) root.left = TreeNode(2, TreeNode(1), TreeNode(3)) root.right = TreeNode(7, TreeNode(6), TreeNode(9)) inverted_root = invertTree(root) print(inverted_root.val) # Output: 4 print(inverted_root.left.val) # Output: 7 print(inverted_root.right.val) # Output: 2 print(inverted_root.left.left.val) # Output: 9 print(inverted_root.left.right.val) # Output: 6 print(inverted_root.right.left.val) # Output: 3 print(inverted_root.right.right.val) # Output: 1 ``` Implement the function `invertTree` to invert the binary tree provided above and thoroughly test it to ensure correctness.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def invertTree(root: TreeNode) -> TreeNode: Invert a binary tree. :param root: TreeNode - The root of the binary tree. :return: TreeNode - The root of the inverted binary tree. if root is None: return None # Swap the left and right children root.left, root.right = root.right, root.left # Recursively invert the left and right subtrees invertTree(root.left) invertTree(root.right) return root"},{"question":"# String Compression and Decompression You are tasked with implementing a simple string compression and decompression system. The compression algorithm should convert sequences of consecutive identical characters into a single character followed by the number of repetitions. The decompression algorithm should reverse this process, expanding the compressed string back to its original form. # Function Requirements 1. `compress(self, input_string)`: Compress the input string based on the described algorithm. 2. `decompress(self, compressed_string)`: Decompress the input string based on the described algorithm. # Input and Output - `compress(self, input_string)` - **Input**: A string `input_string` consisting of lowercase alphabetical characters. - **Output**: A compressed string. - `decompress(self, compressed_string)` - **Input**: A string `compressed_string` containing alphabetical characters followed by digit counts. - **Output**: The original decompressed string. # Constraints - Only lowercase alphabetical characters are supported. - Assume well-formed inputs for decompression (e.g., no invalid sequences). - The compression is case-sensitive and does not need to handle special characters or spaces. # Example ```python compressor = StringCompressor() # Compress strings compressed = compressor.compress(\\"aaabccccdee\\") print(compressed) # => \\"a3b1c4d1e2\\" # Decompress strings decompressed = compressor.decompress(\\"a3b1c4d1e2\\") print(decompressed) # => \\"aaabccccdee\\" ``` # Implementation Implement the necessary methods to complete the `StringCompressor` class as specified. ```python class StringCompressor: def compress(self, input_string): compressed_string = \\"\\" count = 1 previous_char = input_string[0] for char in input_string[1:]: if char == previous_char: count += 1 else: compressed_string += f\\"{previous_char}{count}\\" count = 1 previous_char = char compressed_string += f\\"{previous_char}{count}\\" return compressed_string def decompress(self, compressed_string): decompressed_string = \\"\\" i = 0 while i < len(compressed_string): char = compressed_string[i] count = \\"\\" i += 1 while i < len(compressed_string) and compressed_string[i].isdigit(): count += compressed_string[i] i += 1 decompressed_string += char * int(count) return decompressed_string # Example usage compressor = StringCompressor() compressed = compressor.compress(\\"aaabccccdee\\") print(compressed) # \\"a3b1c4d1e2\\" decompressed = compressor.decompress(compressed) print(decompressed) # \\"aaabccccdee\\" ```","solution":"class StringCompressor: def compress(self, input_string): compressed_string = \\"\\" count = 1 previous_char = input_string[0] for char in input_string[1:]: if char == previous_char: count += 1 else: compressed_string += f\\"{previous_char}{count}\\" count = 1 previous_char = char compressed_string += f\\"{previous_char}{count}\\" return compressed_string def decompress(self, compressed_string): decompressed_string = \\"\\" i = 0 while i < len(compressed_string): char = compressed_string[i] count = \\"\\" i += 1 while i < len(compressed_string) and compressed_string[i].isdigit(): count += compressed_string[i] i += 1 decompressed_string += char * int(count) return decompressed_string"},{"question":"# Coding Challenge Context You are required to implement a function that performs text manipulation based on patterns of letter casing. Specifically, you need to determine the number of unique case permutations of a given alphabetic string where every letter can be either uppercase or lowercase. Task Implement a function: ```python def unique_case_permutations(s: str) -> int: pass ``` Function Signature ```python def unique_case_permutations(s: str) -> int: ``` Input * A string ( s ) consisting of alphabetic characters only, where ( 1 leq text{len}(s) leq 12 ). Output * An integer, which is the number of unique case permutations of the given string. Examples ```python >>> unique_case_permutations(\\"abc\\") 8 >>> unique_case_permutations(\\"aA\\") 4 >>> unique_case_permutations(\\"xyz\\") 8 ``` Constraints * The input string will only contain alphabetic characters (both uppercase and lowercase). * Ensure your solution handles both small and relatively large strings within the given length constraints.","solution":"def unique_case_permutations(s: str) -> int: This function calculates the number of unique case permutations of the given string `s`. Each letter in the string can be either uppercase or lowercase, leading to 2^n different permutations if the string length is n. Parameters: s (str): A string consisting of alphabetic characters. Returns: int: The number of unique case permutations. return 2 ** len(s)"},{"question":"**Context**: As a software developer for an e-commerce platform, you are tasked with creating an efficient algorithm for recommending products based on user behavior and product attributes. The goal is to suggest products that are similar to those the user has interacted with recently, using their browsing history and product details. **Task**: Implement a function to recommend similar products from the catalog based on the cosine similarity measure between product feature vectors. # Requirements: * Implement a function named `recommend_similar_products` in Python. * The inputs will be: - `target_product`: List of floats, representing feature vector of the target product. - `product_catalog`: List of lists of floats, each representing feature vectors of products in the catalog. - `n`: integer, number of similar products to recommend. * The output should be a list of indices corresponding to the `n` most similar products in the catalog, sorted by similarity in descending order. If multiple products have the same similarity, maintain their original order in the catalog. # Additional Constraints: * Feature vectors can be of varying lengths, but each vector within the catalog will be of the same length as the target product vector. * Handle edge cases where `n` is greater than the number of products in the catalog by returning all the products. * Precision up to 4 decimal places for similarity scores is acceptable. # Function Signature: ```python def recommend_similar_products( target_product: List[float], product_catalog: List[List[float]], n: int ) -> List[int]: pass ``` # Example: ```python >>> recommend_similar_products([1.0, 2.0, 3.0], [[4.0, 5.0, 6.0], [1.1, 2.1, 3.1], [2.0, 3.0, 4.0]], 2) [1, 2] >>> recommend_similar_products([1.0, 0.0, 0.0], [[0.0, 1.0, 0.0], [1.0, 0.0, 0.0], [0.5, 0.5, 0.0]], 3) [1, 2, 0] >>> recommend_similar_products([1,1], [[2,2],[1,0],[-1,-1]], 1) [0] ``` # Hint: Calculate the cosine similarity as the dot product of two vectors divided by the product of their magnitudes. # Sample Implementation: ```python from typing import List import math def cosine_similarity(vec1: List[float], vec2: List[float]) -> float: dot_product = sum(a * b for a, b in zip(vec1, vec2)) magnitude1 = math.sqrt(sum(a * a for a in vec1)) magnitude2 = math.sqrt(sum(b * b for b in vec2)) return dot_product / (magnitude1 * magnitude2) def recommend_similar_products( target_product: List[float], product_catalog: List[List[float]], n: int ) -> List[int]: similarities = [(i, cosine_similarity(target_product, product)) for i, product in enumerate(product_catalog)] similarities.sort(key=lambda x: x[1], reverse=True) return [index for index, similarity in similarities[:n]] ``` This question ensures the implementation of a key recommendation algorithm using the cosine similarity measure, assessing the understanding of vector mathematics and basic machine learning principles.","solution":"from typing import List import math def cosine_similarity(vec1: List[float], vec2: List[float]) -> float: Computes the cosine similarity between two vectors. dot_product = sum(a * b for a, b in zip(vec1, vec2)) magnitude1 = math.sqrt(sum(a * a for a in vec1)) magnitude2 = math.sqrt(sum(b * b for b in vec2)) if magnitude1 == 0 or magnitude2 == 0: return 0.0 return dot_product / (magnitude1 * magnitude2) def recommend_similar_products( target_product: List[float], product_catalog: List[List[float]], n: int ) -> List[int]: Recommends `n` products from the catalog based on cosine similarity with the target product. Parameters: target_product (List[float]): Feature vector of the target product. product_catalog (List[List[float]]): List of feature vectors of products in the catalog. n (int): Number of similar products to recommend. Returns: List[int]: List of indices of the `n` most similar products in descending order of similarity. # Calculate similarities similarities = [(i, cosine_similarity(target_product, product)) for i, product in enumerate(product_catalog)] # Sort the similarities first by score in descending order, then by index in ascending order (default) similarities.sort(key=lambda x: (-x[1], x[0])) # Retrieve the top n product indices return [index for index, similarity in similarities[:n]]"},{"question":"# Binary Tree Height Calculation **Context**: You need to determine the height of a binary tree. The height of a binary tree is the number of edges between the tree\'s root and its furthest leaf. **Function Specification**: Write a function `binary_tree_height(root: TreeNode) -> int` that calculates the height of the provided binary tree efficiently. **Input**: - A `TreeNode` object representing the root of a binary tree, where a `TreeNode` is defined as: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` **Output**: - An integer representing the height of the tree. **Constraints**: - You may assume that the number of nodes in the tree is in the range [0, 10^4]. - The height of a binary tree with no nodes is -1. **Performance**: - Aim for a time complexity of (O(n)), where (n) is the number of nodes in the tree. - The space complexity should be (O(h)), where (h) is the height of the tree, due to the recursion stack. **Sample Input and Output**: ```python # Example 1: # Tree: None # Height: -1 assert binary_tree_height(None) == -1 # Example 2: # Tree: # 1 # / # 2 3 # Height: 1 root = TreeNode(1, TreeNode(2), TreeNode(3)) assert binary_tree_height(root) == 1 # Example 3: # Tree: # 1 # / # 2 3 # / # 4 # Height: 2 root = TreeNode(1, TreeNode(2, TreeNode(4)), TreeNode(3)) assert binary_tree_height(root) == 2 ```","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def binary_tree_height(root): Returns the height of the binary tree. if root is None: return -1 left_height = binary_tree_height(root.left) right_height = binary_tree_height(root.right) return max(left_height, right_height) + 1"},{"question":"# Scenario You are working on a data transformation tool for CSV files. This tool needs the ability to manipulate and analyze tabular data. One common operation is to compute the moving average of a specified column over a defined window size, which is a frequent requirement in time-series data analysis. Your task is to implement a function that calculates the moving average for a given column in a CSV file and appends the result as a new column in the DataFrame. # Function to Implement Write a function `compute_moving_average`: Input - `csv_file` (str): The path to the CSV file. - `column_name` (str): The name of the column for which to compute the moving average. - `window_size` (int): The number of periods to include in the moving average calculation. Output - A new pandas DataFrame containing the original data along with a new column named `{column_name}_moving_average` which holds the computed moving averages. Constraints 1. The window size must be a positive integer (>= 1). 2. `column_name` must exist in the CSV file. 3. The moving average result for the first `window_size - 1` entries can be NaN (not a number) since there aren\'t enough elements to form a full window. # Requirements 1. Raise a `FileNotFoundError` if the CSV file does not exist. 2. Raise a `ValueError` if the window size is less than 1. 3. Raise a `ValueError` if the column does not exist in the CSV file. 4. Utilize the `pandas` library for reading the CSV file and performing the moving average calculation. # Example Assuming a CSV file `data.csv` with the following content: ``` date,value 2023-01-01,10 2023-01-02,20 2023-01-03,30 2023-01-04,40 2023-01-05,50 ``` ```python >>> df = compute_moving_average(\'data.csv\', \'value\', 3) >>> print(df) date value value_moving_average 0 2023-01-01 10 NaN 1 2023-01-02 20 NaN 2 2023-01-03 30 20.0 3 2023-01-04 40 30.0 4 2023-01-05 50 40.0 >>> compute_moving_average(\'data.csv\', \'nonexistent_column\', 3) Traceback (most recent call last): ... ValueError: The column nonexistent_column does not exist in the CSV file. >>> compute_moving_average(\'data.csv\', \'value\', 0) Traceback (most recent call last): ... ValueError: The window size must be greater than or equal to 1. >>> compute_moving_average(\'nonexistent_file.csv\', \'value\', 3) Traceback (most recent call last): ... FileNotFoundError: The file nonexistent_file.csv does not exist. ``` You need to adhere to the constraints and ensure that your code is efficient and clear. Test for all possible edge cases, such as invalid inputs and different scenarios arising from time-series data analysis.","solution":"import pandas as pd def compute_moving_average(csv_file, column_name, window_size): Computes the moving average of a specified column in a CSV file and appends it as a new column. Parameters: csv_file (str): The path to the CSV file. column_name (str): The name of the column for which to compute the moving average. window_size (int): The number of periods for computing the moving average. Returns: pandas.DataFrame: DataFrame with the original data and a new column for the moving average. if window_size < 1: raise ValueError(\\"The window size must be greater than or equal to 1.\\") try: df = pd.read_csv(csv_file) except FileNotFoundError: raise FileNotFoundError(f\\"The file {csv_file} does not exist.\\") if column_name not in df.columns: raise ValueError(f\\"The column {column_name} does not exist in the CSV file.\\") df[f\\"{column_name}_moving_average\\"] = df[column_name].rolling(window=window_size).mean() return df"},{"question":"# Job Scheduling with Dependencies Imagine you\'re developing a job scheduling system that needs to execute a series of jobs, where some jobs must be completed before others can begin. This dependency relationship can be represented as a directed acyclic graph (DAG), where nodes represent jobs and edges indicate execution order. Your objective is to implement a function to generate a valid order of job execution that satisfies all dependencies. # Requirements * Implement the function `schedule_jobs(jobs: List[str], dependencies: List[Tuple[str, str]]) -> List[str]` * **Input**: - `jobs`: A list of strings where each string is a job identifier. - `dependencies`: A list of tuples, where each tuple `(a, b)` means job `a` must be completed before job `b` can start. * **Output**: - A list of job identifiers arranged in an order that satisfies all given dependencies. If there’s no valid ordering, return an empty list. # Constraints 1. Assume all job identifiers are unique. 2. The number of jobs will not exceed 10^3. 3. The number of dependencies will not exceed 10^3. # Example ```python schedule_jobs( [\\"a\\", \\"b\\", \\"c\\", \\"d\\"], [(\\"a\\", \\"b\\"), (\\"c\\", \\"b\\"), (\\"b\\", \\"d\\")] ) ``` Output: `[\'a\', \'c\', \'b\', \'d\']` (other valid orders may exist like `[\'c\', \'a\', \'b\', \'d\']`) # Explanation In this example, jobs \'a\' and \'c\' must both precede \'b\', and \'b\' must precede \'d\'. Hence, any valid order of execution would place \'a\' and \'c\' before \'b\', and \'b\' before \'d\'. # Implementation Guide 1. **Represent the Graph**: Use an adjacency list to represent the jobs and their dependencies. 2. **Topological Sorting**: Utilize Kahn\'s algorithm or Depth-First Search (DFS) to perform a topological sort on the DAG. This will ensure that all dependencies are respected in the resulting order. 3. **Cycle Detection**: Ensure there are no cycles in the graph to determine if a valid execution order exists. Your implementation should pass through the list of jobs, respecting the constraints and dependencies, and return an execution order that allows every job to operate only after its dependencies have completed. Good luck!","solution":"from collections import deque, defaultdict from typing import List, Tuple def schedule_jobs(jobs: List[str], dependencies: List[Tuple[str, str]]) -> List[str]: Returns a valid job execution order given the jobs and their dependencies. # Initialize the graph in_degree = {job: 0 for job in jobs} adj_list = defaultdict(list) # Build the graph for pre, suc in dependencies: adj_list[pre].append(suc) in_degree[suc] += 1 # Initialize a queue with jobs that have no dependencies (in-degree 0) zero_in_degree_queue = deque([job for job in jobs if in_degree[job] == 0]) topological_order = [] while zero_in_degree_queue: job = zero_in_degree_queue.popleft() topological_order.append(job) # Decrease the in-degree of successor jobs for successor in adj_list[job]: in_degree[successor] -= 1 # If in-degree becomes 0, add it to the queue if in_degree[successor] == 0: zero_in_degree_queue.append(successor) # Check if we were able to include all jobs in the topological order if len(topological_order) == len(jobs): return topological_order else: return [] # A cycle exists, hence no valid scheduling order"},{"question":"# Scenario: As a software engineer, you have been asked to help analyze data from an online bookstore. Your task is to implement a function that identifies the most frequent author in a given list of book records. Each record contains the title and author of a book. # Function Specification: You are to implement a function called `most_frequent_author` that adheres to the following: Input: - `book_records` (list of tuples): each tuple contains two strings, the title of the book and the author. This list cannot be empty. Output: - Returns a string that represents the author with the highest number of books in the records. In case of a tie, return the author who appears first alphabetically. # Constraints: - If the `book_records` list is empty, raise a `ValueError` with the message \\"Book records list cannot be empty\\". # Examples: ```python >>> most_frequent_author([(\\"The Catcher in the Rye\\", \\"J.D. Salinger\\"), (\\"To Kill a Mockingbird\\", \\"Harper Lee\\"), (\\"1984\\", \\"George Orwell\\"), (\\"Animal Farm\\", \\"George Orwell\\")]) \'George Orwell\' >>> most_frequent_author([(\\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\"), (\\"Tender Is the Night\\", \\"F. Scott Fitzgerald\\"), (\\"This Side of Paradise\\", \\"F. Scott Fitzgerald\\")]) \'F. Scott Fitzgerald\' >>> most_frequent_author([(\\"Brave New World\\", \\"Aldous Huxley\\"), (\\"Island\\", \\"Aldous Huxley\\"), (\\"The Doors of Perception\\", \\"Aldous Huxley\\"), (\\"Nineteen Eighty-Four\\", \\"George Orwell\\")]) \'Aldous Huxley\' >>> most_frequent_author([]) Traceback (most recent call last): ... ValueError: Book records list cannot be empty >>> most_frequent_author([(\\"Dracula\\", \\"Bram Stoker\\"), (\\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\"), (\\"Dracula\'s Guest\\", \\"Bram Stoker\\"), (\\"Tender Is the Night\\", \\"F. Scott Fitzgerald\\")]) \'Bram Stoker\' ``` # Implementation Details: Use a dictionary to count the occurrences of each author and determine the author with the maximum count. Ensure to handle the tie-breaking condition by comparing alphabetically. Consider edge cases and ensure the function adheres to the specified constraints.","solution":"def most_frequent_author(book_records): Returns the author with the highest number of books in the records. In case of a tie, the author who appears first alphabetically is returned. if not book_records: raise ValueError(\\"Book records list cannot be empty\\") author_count = {} for title, author in book_records: if author in author_count: author_count[author] += 1 else: author_count[author] = 1 max_books = max(author_count.values()) candidates = [author for author, count in author_count.items() if count == max_books] return min(candidates)"},{"question":"# Problem Statement You are given a list of strings. Your task is to determine if each string in the list can be rearranged to form a palindrome. Return a list of boolean values indicating the result for each string in the order they appear in the input list. Detailed Requirements: 1. Implement the function `can_form_palindrome(strings: List[str]) -> List[bool]` that checks for each string. 2. A string can be rearranged to form a palindrome if at most one character has an odd frequency. 3. Return a list of boolean values where each value corresponds to whether the string at that position in the input list can be rearranged to form a palindrome. Input - A single argument: `strings` (List of strings with a length between 1 and 1000, where each string contains lowercase alphabets only and each string\'s length is between 1 and 1000). Output - A list of boolean values of the same length as the input list, with each boolean indicating whether the corresponding string can be rearranged to form a palindrome. Constraints - The length of the list of strings is between 1 and 1000. - Each string contains only lowercase English letters. Example ```python def can_form_palindrome(strings: List[str]) -> List[bool]: # Implement the function to solve the problem. pass if __name__ == \\"__main__\\": test_strings = [\\"civic\\", \\"ivicc\\", \\"hello\\", \\"aabb\\", \\"abcba\\"] print(can_form_palindrome(test_strings)) # Expected output: [True, True, False, True, True] ``` In the example provided, the output should be `[True, True, False, True, True]` indicating that \\"civic\\" and \\"ivicc\\" can form palindromes, \\"hello\\" cannot, \\"aabb\\" can, and \\"abcba\\" can. --- This new question aligns with the original problem\'s structure by asking for the creation of a function to solve a specific problem and providing clear input and output requirements. The difficulty level is maintained by examining character frequencies, similar to checking conditions for palindromic sums of consecutive squares while ensuring performance constraints are reasonable.","solution":"from typing import List from collections import Counter def can_form_palindrome(strings: List[str]) -> List[bool]: def check_palindrome_possible(s: str) -> bool: char_count = Counter(s) odd_count = sum(1 for count in char_count.values() if count % 2 != 0) return odd_count <= 1 return [check_palindrome_possible(s) for s in strings]"},{"question":"# Longest Uniform Subarray Problem Statement: Given an array of integers, an uniform subarray is defined as a contiguous subarray where all elements are the same. Write a function to find the length of the longest uniform subarray. For example, in the array `[4, 4, 4, 5, 5, 1, 1, 1, 1]`, the longest uniform subarray is `[1, 1, 1, 1]` with a length of `4`. Function Signature ```python def longest_uniform_subarray(arr: list[int]) -> int: pass ``` # Input - `arr` (1 ≤ len(arr) ≤ 10^5): a list of integers, where each integer satisfies `1 ≤ arr[i] ≤ 10^3`. # Output - Returns an integer representing the length of the longest uniform subarray. # Constraints - The array will contain at least one integer. - Optimize for performance to handle arrays of the maximum length. # Example: ```python assert longest_uniform_subarray([4, 4, 4, 5, 5, 1, 1, 1, 1]) == 4 assert longest_uniform_subarray([1, 2, 3, 4, 5]) == 1 assert longest_uniform_subarray([5, 5, 5, 5, 5]) == 5 ``` Note: Aim to solve the problem with an optimal time and space complexity.","solution":"def longest_uniform_subarray(arr: list[int]) -> int: Returns the length of the longest uniform subarray. if not arr: return 0 max_length = 1 current_length = 1 for i in range(1, len(arr)): if arr[i] == arr[i - 1]: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length"},{"question":"# Scenario You are developing an image processing application that requires handling various common geometric transformations on 2D points. One of the transformations you need to implement is a rotation of a point around the origin by a given angle. This function will help in tasks like rotating an image, animating objects, or creating complex geometric patterns. # Problem Statement Implement the `rotate_point` function which rotates a given point (x, y) around the origin (0, 0) by a specified angle in degrees. The function should return the new coordinates of the point after rotation. # Function Signature ```python def rotate_point(x: float, y: float, angle: float) -> (float, float): ``` # Input * `x` (float): The x-coordinate of the point. * `y` (float): The y-coordinate of the point. * `angle` (float): The angle in degrees by which the point should be rotated around the origin. # Output * Returns a tuple of two floats representing the new x and y coordinates of the point after rotation. # Constraints * The function should handle both positive and negative angles. * Ensure precision up to at least 6 decimal places for the results. * Use standard mathematical constants and functions where necessary. # Example ```python # Example usage of rotate_point print(rotate_point(1, 0, 90)) # (0.0, 1.0) print(rotate_point(0, 1, -90)) # (1.0, 0.0) ``` # Test Cases Ensure your function passes the following test cases: 1. `rotate_point(3, 3, 45)` should return approximately `(0.0, 4.242640687119285)` 2. `rotate_point(1, 1, 180)` should return approximately `(-1.0, -1.0)` 3. `rotate_point(4, 2, 360)` should return `(4.0, 2.0)` 4. `rotate_point(0, 0, 45)` should return `(0.0, 0.0)`","solution":"import math def rotate_point(x: float, y: float, angle: float) -> (float, float): Rotates a point (x, y) around the origin (0, 0) by a specified angle in degrees. Parameters: x (float): The x-coordinate of the point. y (float): The y-coordinate of the point. angle (float): The angle in degrees by which the point should be rotated around the origin. Returns: (float, float): The new coordinates of the point after rotation. angle_rad = math.radians(angle) cos_theta = math.cos(angle_rad) sin_theta = math.sin(angle_rad) x_new = x * cos_theta - y * sin_theta y_new = x * sin_theta + y * cos_theta return (round(x_new, 6), round(y_new, 6))"},{"question":"# Scenario Given the need to manipulate numeric sequences, you are required to implement a function that can reverse a given integer while preserving its sign. This will help reinforce concepts related to numeric operations, loops, and conditionals. # Problem Statement Write a function `reverse_integer(n: int) -> int` that takes an integer `n` as input and returns the integer obtained by reversing its digits. The function should handle both positive and negative integers. # Example ```python >>> reverse_integer(123) 321 >>> reverse_integer(-456) -654 >>> reverse_integer(100) 1 >>> reverse_integer(-800) -8 >>> reverse_integer(0) 0 ``` # Input and Output Formats - **Input**: A single integer `n` in the range from -2^31 to 2^31 - 1. - **Output**: An integer that is the reversed form of input `n`, preserving the sign of the input. # Constraints - The reversed integer should also remain within the valid integer range from -2^31 to 2^31 - 1. - If the reversed integer exceeds this range, return 0. # Performance Requirements Your solution should aim for a time complexity of O(log10(n)) due to the number of digits in the integer, and a space complexity of O(1).","solution":"def reverse_integer(n: int) -> int: Reverses the digits of the given integer while preserving its sign. Args: n (int): The integer to be reversed. Returns: int: The reversed integer with the original sign preserved. sign = -1 if n < 0 else 1 n_abs = abs(n) reversed_str = str(n_abs)[::-1] reversed_int = int(reversed_str) * sign # Check if the reversed integer is within the valid range if reversed_int < -2**31 or reversed_int > 2**31 - 1: return 0 return reversed_int"},{"question":"# Chessboard Knight Moves Validation You have been tasked with creating a function that validates knight moves on a standard 8x8 chessboard. The function should determine whether a given sequence of moves for a knight is valid. **Function Signature:** ```python def validate_knight_moves(moves: list) -> bool: ``` **Input:** * `moves` - A list of tuples where each tuple contains a pair of integers representing the position of the knight on the chessboard. The initial position is always given, and the subsequent positions represent the knight\'s moves on the chessboard. **Output:** * A boolean value: `True` if the entire sequence of moves is valid, `False` otherwise. **Constraints:** * The function should ensure that the knight\'s moves adhere to the L-shape movement rules of the knight in chess (two squares in one direction and then one square perpendicular). * The chessboard is represented as an 8x8 grid, with positions ranging from (1,1) to (8,8). * All positions provided in the input list are valid positions within this grid. **Scenario:** Imagine you are developing a chess game and need a utility to validate the sequence of moves a knight makes during the game. This validation function will be used in the move validation logic to ensure the movements are consistent with a knight\'s allowed moves. **Example:** ```python >>> validate_knight_moves([(1, 1), (3, 2), (5, 3), (7, 4)]) True >>> validate_knight_moves([(1, 1), (3, 3)]) False >>> validate_knight_moves([(4, 5), (6, 6), (8, 7)]) False ``` You can use the following partial code as a starting point for your solution: ```python def validate_knight_moves(moves: list) -> bool: def is_valid_move(start, end): x1, y1 = start x2, y2 = end return (abs(x1 - x2), abs(y1 - y2)) in [(1, 2), (2, 1)] for i in range(len(moves) - 1): if not is_valid_move(moves[i], moves[i + 1]): return False return True ```","solution":"def validate_knight_moves(moves: list) -> bool: def is_valid_move(start, end): x1, y1 = start x2, y2 = end # A knight move in chess is valid if it moves in an L shape: # 2 squares in one direction, and then 1 square in a perpendicular direction return (abs(x1 - x2), abs(y1 - y2)) in [(2, 1), (1, 2)] for i in range(len(moves) - 1): if not is_valid_move(moves[i], moves[i + 1]): return False return True"},{"question":"# Problem: Filter Positive Multiples of Three You are given an array of integers and need to filter out all positive multiples of three from the list. Implement a function `find_positive_multiples_of_three` that receives a list of integers and returns a new list containing all the positive multiples of three from the provided list. Input: * A list of integers `numbers` (1 <= len(numbers) <= 10^5, -10^9 <= numbers[i] <= 10^9) Output: * A list of positive multiples of three. Requirements: * Your solution should efficiently process the input list. * Aim to minimize auxiliary space utilization. Example: ```python >>> find_positive_multiples_of_three([1, 3, 4, 6, 9, 12, 15, -3, -6]) [3, 6, 9, 12, 15] >>> find_positive_multiples_of_three([10, 13, 20, 25, 30]) [30] >>> find_positive_multiples_of_three([-1, -3, -6, -9, 0, 3, 6]) [3, 6] ``` Constraints: * The input list will contain at least one integer. * Your implementation should be able to handle both positive and negative integers. * Zero is not considered a positive multiple of three.","solution":"def find_positive_multiples_of_three(numbers): Filters out and returns a list of all positive multiples of three from the provided list. Args: numbers (list of int): A list of integers. Returns: list of int: A list containing all the positive multiples of three from the input list. return [num for num in numbers if num > 0 and num % 3 == 0]"},{"question":"# Coding Challenge Context: You are given a sequence of integers where each integer appears twice except for one unique integer that appears only once. Objective: Write a function `find_unique_integer(arr: List[int]) -> int` that takes a list of integers and returns the integer that appears only once. Input: The input will be a list of integers `arr` where ( 1 leq text{len}(arr) leq 10^5 ) and every element except one appears exactly twice. It is guaranteed that there is exactly one unique element. Output: The output should be the single integer that is unique in the list. Constraints: - The input list can contain positive and negative integers. - The function should be optimized to handle the maximum input size efficiently. Examples: ```python >>> find_unique_integer([4, 3, 2, 4, 1, 3, 2]) 1 >>> find_unique_integer([7, 9, 7]) 9 >>> find_unique_integer([10, -1, -1, 10, 5]) 5 >>> find_unique_integer([100]) 100 ``` Performance Requirement: The solution should be optimal and capable of processing the input within a reasonable time frame for large lists. Good luck!","solution":"def find_unique_integer(arr): Returns the unique integer from the list where every other integer appears exactly twice. unique_num = 0 for num in arr: unique_num ^= num return unique_num"},{"question":"# Coding Problem: Determine the Smallest Subsequence With a Given Sum **Problem Statement**: You need to find the smallest contiguous subsequence within a given list of integers such that its sum is at least the given threshold. Specifically, given a list `nums` of integers and an integer `target`, your task is to return the length of the smallest subsequence whose sum is greater than or equal to `target`. If no such subsequence exists, return 0. **Input**: - A list of integers `nums` (1 <= len(nums) <= 10^5). - An integer `target` (1 <= target <= 10^9). **Output**: - Return an integer representing the length of the smallest subsequence whose sum is at least `target`. If no such subsequence exists, return 0. **Function Signature**: ```python def smallest_subsequence_length(nums: List[int], target: int) -> int: pass ``` **Constraints**: - The list `nums` contains at least one positive integer. - The sum of the elements in `nums` is at least `target`. **Example**: ```python >>> smallest_subsequence_length([2, 3, 1, 2, 4, 3], 7) 2 >>> smallest_subsequence_length([1, 4, 4], 4) 1 >>> smallest_subsequence_length([1, 1, 1, 1], 7) 0 ``` **Requirements**: - The solution should have a time complexity of O(n) or better. - Make use of efficient algorithms and data structures to handle large datasets effectively. - Ensure the code handles edge cases gracefully, such as when the entire list is required to meet the threshold. Implement the function `smallest_subsequence_length` to pass the requirements and demonstrate proficient use of algorithmic techniques and optimized performance.","solution":"from typing import List def smallest_subsequence_length(nums: List[int], target: int) -> int: n = len(nums) left = 0 current_sum = 0 min_length = float(\'inf\') for right in range(n): current_sum += nums[right] while current_sum >= target: min_length = min(min_length, right - left + 1) current_sum -= nums[left] left += 1 return min_length if min_length != float(\'inf\') else 0"},{"question":"# Coding Assessment: Process and Analyze Environmental Data Objective You are required to write Python functions to fetch, process, and analyze environmental data from an open API. Your solution should be efficient and handle potential errors gracefully. Requirements 1. **Function 1: `fetch_environmental_data(city: str) -> dict`** - Input: - A string representing the city name. - Output: - A dictionary containing the raw environmental data fetched from the API. - Constraints: - If the city name is invalid or data is not found, return an appropriate error message. 2. **Function 2: `analyze_environmental_data(data: dict) -> dict`** - Input: - A dictionary containing raw environmental data. - Output: - A dictionary containing an analysis of the environmental data including: - Average Temperature - Average Humidity - Air Quality Index - Main Pollutant - Recommended Precautions (based on air quality) Performance Requirements - Your solution should handle multiple API calls efficiently. - Consider handling any API delays or errors gracefully without breaking the program flow. Example ```python >>> env_data = fetch_environmental_data(\\"San Francisco\\") >>> analysis = analyze_environmental_data(env_data) >>> print(analysis) { \\"Average Temperature\\": \\"15°C\\", \\"Average Humidity\\": \\"70%\\", \\"Air Quality Index\\": 42, \\"Main Pollutant\\": \\"PM2.5\\", \\"Recommended Precautions\\": \\"No precautions needed.\\" } ``` Notes 1. Pay attention to possible API restrictions and handle them properly using appropriate error messages. 2. Ensure your code handles missing data gracefully by including default values where necessary. 3. Parse and process data to extract accurate environmental measures and provide actionable recommendations based on the air quality index. Constraints - Ensure the city name passed is valid and is a string containing only letters and spaces. - Handle timeout scenarios and missing data fields properly.","solution":"import requests def fetch_environmental_data(city: str) -> dict: Fetch environmental data for a given city from an open API. Args: - city (str): The name of the city. Returns: - dict: Raw environmental data or an error message if the fetch fails. if not isinstance(city, str) or not city.replace(\\" \\", \\"\\").isalpha(): return {\\"error\\": \\"Invalid city name\\"} api_url = f\\"http://example.com/environmental_data?city={city}\\" try: response = requests.get(api_url) response.raise_for_status() return response.json() except requests.exceptions.RequestException as e: return {\\"error\\": str(e)} def analyze_environmental_data(data: dict) -> dict: Analyze the raw environmental data. Args: - data (dict): Raw environmental data. Returns: - dict: Analyzed data including average temperature, humidity, air quality index, main pollutant, and recommended precautions. if \\"error\\" in data: return data temperature_data = data.get(\\"temperature\\", []) humidity_data = data.get(\\"humidity\\", []) air_quality_data = data.get(\\"air_quality\\", {}) def calculate_average(values): if not values: return None return sum(values) / len(values) average_temperature = calculate_average(temperature_data) average_humidity = calculate_average(humidity_data) aqi = air_quality_data.get(\\"aqi\\", None) main_pollutant = air_quality_data.get(\\"pollutant\\", \\"Unknown\\") precautions = \\"No data available\\" if aqi is not None: if aqi <= 50: precautions = \\"No precautions needed.\\" elif 51 <= aqi <= 100: precautions = \\"Consider reducing prolonged outdoor exertion.\\" elif 101 <= aqi <= 150: precautions = \\"Avoid prolonged outdoor exertion. Sensitive groups should limit outdoor activity.\\" else: precautions = \\"Avoid all outdoor exertion. Sensitive groups stay indoors.\\" return { \\"Average Temperature\\": f\\"{average_temperature:.1f}°C\\" if average_temperature is not None else \\"No data\\", \\"Average Humidity\\": f\\"{average_humidity:.1f}%\\" if average_humidity is not None else \\"No data\\", \\"Air Quality Index\\": aqi if aqi is not None else \\"No data\\", \\"Main Pollutant\\": main_pollutant, \\"Recommended Precautions\\": precautions }"},{"question":"# Fibonacci Number Check You are required to implement a function that checks if a given number is a Fibonacci number. A number is considered a Fibonacci number if it appears in the Fibonacci sequence. The Fibonacci sequence is defined as follows: - F(0) = 0 - F(1) = 1 - F(n) = F(n-1) + F(n-2) for n ≥ 2 Function Signature ```python def is_fibonacci_number(num: int) -> bool: ``` Parameters: - `num` (int): The number to check if it is a Fibonacci number. Returns: - `bool`: Returns `True` if the given number is a Fibonacci number, `False` otherwise. # Requirements: 1. Compute whether a number is a Fibonacci number using mathematical properties rather than generating the sequence up to the number. 2. Utilize the property that a number is a Fibonacci number if and only if one of `5*num^2 + 4` or `5*num^2 - 4` is a perfect square. # Constraints: - ( 0 le text{num} le 10^{12} ) # Example Usage: ```python print(is_fibonacci_number(0)) # True print(is_fibonacci_number(1)) # True print(is_fibonacci_number(2)) # True print(is_fibonacci_number(3)) # True print(is_fibonacci_number(4)) # False print(is_fibonacci_number(5)) # True print(is_fibonacci_number(13)) # True print(is_fibonacci_number(21)) # True print(is_fibonacci_number(22)) # False print(is_fibonacci_number(144)) # True print(is_fibonacci_number(233)) # True ``` Implement the `is_fibonacci_number` function and ensure it passes the provided test cases.","solution":"import math def is_fibonacci_number(num: int) -> bool: Checks if a given number is a Fibonacci number. def is_perfect_square(x: int) -> bool: s = int(math.isqrt(x)) return s * s == x # Compute the potential perfect squares for Fibonacci check test1 = 5 * num * num + 4 test2 = 5 * num * num - 4 # If either one is a perfect square, num is a Fibonacci number return is_perfect_square(test1) or is_perfect_square(test2)"},{"question":"# Coding Assessment Question Context As part of the team\'s efforts to expand the custom digital circuit simulation library, you are now tasked with implementing a half-adder. A half-adder is a basic digital circuit that adds two binary digits and outputs their sum and carry values. It is essential in the construction of many digital logic circuits. Problem Statement **Task**: Implement a `half_adder` function in Python that simulates the behavior of a half-adder. Additionally, implement the `generate_half_adder_truth_table` function that produces the truth table for the half-adder. * **Function Specifications**: - **Function 1**: `half_adder` - **Input**: Two integers (`input_1`, `input_2`) where each input is either `0` or `1`. - **Output**: A tuple of two integers (`sum`, `carry`), both values are either `0` or `1`. - **Function 2**: `generate_half_adder_truth_table` - **Input**: A function reference (e.g., `half_adder`). - **Output**: A formatted truth table as a string for the given logic function. * **Constraints**: - Inputs to `half_adder` should be within the set `{0, 1}`. - Other types of input should raise a `ValueError`. - The truth table should follow the specified formatting accurately. * **Performance Requirements**: - The solution should have O(1) complexity for gate evaluations. - The truth table generation should iterate through all possible combinations (O(1) complexity because it\'s a constant set of combinations). Example Usage ```python def half_adder(input_1: int, input_2: int) -> (int, int): >>> half_adder(0, 0) (0, 0) >>> half_adder(0, 1) (1, 0) >>> half_adder(1, 0) (1, 0) >>> half_adder(1, 1) (0, 1) def generate_half_adder_truth_table(func: Callable) -> str: >>> print(generate_half_adder_truth_table(half_adder)) Truth Table of Half Adder: | Input 1 | Input 2 | Sum | Carry | | 0 | 0 | 0 | 0 | | 0 | 1 | 1 | 0 | | 1 | 0 | 1 | 0 | | 1 | 1 | 0 | 1 | # Your program should be able to execute the following if __name__ == \\"__main__\\": import doctest doctest.testmod() print(generate_half_adder_truth_table(half_adder)) ``` **Note**: Ensure your solution passes the provided doctest cases without modifications and adheres to the constraints and specifications listed.","solution":"def half_adder(input_1, input_2): Simulates a half-adder which computes the sum and carry of two binary digits. Args: input_1 (int): The first binary digit (0 or 1). input_2 (int): The second binary digit (0 or 1). Returns: tuple: A tuple containing the sum and carry (both 0 or 1). Raises: ValueError: If either input_1 or input_2 is not within {0, 1}. Examples: >>> half_adder(0, 0) (0, 0) >>> half_adder(0, 1) (1, 0) >>> half_adder(1, 0) (1, 0) >>> half_adder(1, 1) (0, 1) if input_1 not in {0, 1} or input_2 not in {0, 1}: raise ValueError(\\"Inputs must be 0 or 1.\\") sum_value = input_1 ^ input_2 carry = input_1 & input_2 return sum_value, carry def generate_half_adder_truth_table(func): Generates the truth table for the half-adder function. Args: func (callable): The half-adder function to generate the truth table for. Returns: str: A formatted truth table for the half-adder function. Examples: >>> print(generate_half_adder_truth_table(half_adder)) Truth Table of Half Adder: | Input 1 | Input 2 | Sum | Carry | | 0 | 0 | 0 | 0 | | 0 | 1 | 1 | 0 | | 1 | 0 | 1 | 0 | | 1 | 1 | 0 | 1 | truth_table = [] truth_table.append(\\"Truth Table of Half Adder:\\") truth_table.append(\\"| Input 1 | Input 2 | Sum | Carry |\\") for input_1 in [0, 1]: for input_2 in [0, 1]: sum_value, carry = func(input_1, input_2) truth_table.append(f\\"| {input_1} | {input_2} | {sum_value} | {carry} |\\") return \\"n\\".join(truth_table)"},{"question":"# Question: Code Refactoring Using Decorators Objective: You are required to refactor a class-based implementation by incorporating Python decorators to enhance code readability and reusability. Refactor the given `Employee` class to include decorators for important functionalities. Part 1: Refactor Class 1. **Original `Employee` Class:** Implement a class named `Employee` that has methods to set employee details and calculate monthly salary based on hourly wage and hours worked. You will refactor the methods using decorators for validation and logging. ```python class Employee: def __init__(self): self.name = \\"\\" self.hourly_wage = 0.0 self.hours_worked = 0 def set_details(self, name: str, hourly_wage: float, hours_worked: int): self.name = name self.hourly_wage = hourly_wage self.hours_worked = hours_worked def calculate_salary(self): return self.hourly_wage * self.hours_worked ``` 2. **Part 1: Implementing Decorators** * Create a decorator `@validate_details` to ensure the hourly wage is a positive float and hours worked is a non-negative integer. * Another decorator `@log_method` should log the method name and parameters each time a method is called. ```python from typing import Callable, Any import functools import logging def validate_details(func: Callable) -> Callable: Decorator to validate details for employee-related methods. @functools.wraps(func) def wrapper(self, *args, **kwargs) -> Any: if len(args) >= 3: name, hourly_wage, hours_worked = args[:3] if not isinstance(hourly_wage, (int, float)) or hourly_wage <= 0: raise ValueError(\\"Hourly wage must be a positive number.\\") if not isinstance(hours_worked, int) or hours_worked < 0: raise ValueError(\\"Hours worked must be a non-negative integer.\\") return func(self, *args, **kwargs) return wrapper def log_method(func: Callable) -> Callable: Decorator to log method name and parameters on each call. @functools.wraps(func) def wrapper(*args, **kwargs) -> Any: logging.info(f\\"Calling {func.__name__} with args: {args}, kwargs: {kwargs}\\") return func(*args, **kwargs) return wrapper ``` 3. **Refactored `Employee` Class:** Refactor the `Employee` class to use `@validate_details` and `@log_method` decorators. ```python class Employee: def __init__(self): self.name = \\"\\" self.hourly_wage = 0.0 self.hours_worked = 0 @validate_details @log_method def set_details(self, name: str, hourly_wage: float, hours_worked: int): self.name = name self.hourly_wage = hourly_wage self.hours_worked = hours_worked @log_method def calculate_salary(self): return self.hourly_wage * self.hours_worked ``` Part 2: Additional Validation Function 4. **Function: `is_valid_employee`** * Create a function `is_valid_employee` that validates if an employee\'s name is not empty and returns `True` if valid, otherwise `False`. ```python def is_valid_employee(employee: Employee) -> bool: Validate employee credentials. Parameters: employee (Employee): The employee instance to be validated. Returns: bool: True if employee details are valid, False otherwise. return bool(employee.name) ``` Constraints & Requirements: * Ensure the `@validate_details` decorator checks the validity of the input. * The `@log_method` decorator should use Python\'s built-in logging module. * The name of the employee should be a non-empty string. Example: ```python # Refactored Employee class usage employee = Employee() employee.set_details(\\"John Doe\\", 15.5, 40) print(employee.calculate_salary()) # Output: 620.0 print(is_valid_employee(employee)) # Output: True # Invalid details usage try: employee.set_details(\\"Jane Doe\\", -5, 20) # Should raise ValueError except ValueError as e: print(e) # Output: Hourly wage must be a positive number. ``` Ensure to cover edge cases, maintain proper functioning with decorators, and log necessary details appropriately.","solution":"from typing import Callable, Any import functools import logging # Setting up logging logging.basicConfig(level=logging.INFO) def validate_details(func: Callable) -> Callable: Decorator to validate details for employee-related methods. @functools.wraps(func) def wrapper(self, *args, **kwargs) -> Any: if len(args) >= 3: name, hourly_wage, hours_worked = args[:3] if not isinstance(hourly_wage, (int, float)) or hourly_wage <= 0: raise ValueError(\\"Hourly wage must be a positive number.\\") if not isinstance(hours_worked, int) or hours_worked < 0: raise ValueError(\\"Hours worked must be a non-negative integer.\\") return func(self, *args, **kwargs) return wrapper def log_method(func: Callable) -> Callable: Decorator to log method name and parameters on each call. @functools.wraps(func) def wrapper(*args, **kwargs) -> Any: logging.info(f\\"Calling {func.__name__} with args: {args}, kwargs: {kwargs}\\") return func(*args, **kwargs) return wrapper class Employee: def __init__(self): self.name = \\"\\" self.hourly_wage = 0.0 self.hours_worked = 0 @validate_details @log_method def set_details(self, name: str, hourly_wage: float, hours_worked: int): self.name = name self.hourly_wage = hourly_wage self.hours_worked = hours_worked @log_method def calculate_salary(self): return self.hourly_wage * self.hours_worked def is_valid_employee(employee: Employee) -> bool: Validate employee credentials. Parameters: employee (Employee): The employee instance to be validated. Returns: bool: True if employee details are valid, False otherwise. return bool(employee.name)"},{"question":"# Coding Assessment Question **Objective**: Implement the \\"steps to Watt\\" algorithm for calculating the total energy consumption in an efficient electrical grid. **Scenario**: You are given a class `EnergyGrid` that simulates an electrical grid with various energy units supplied by different sources. Your task is to implement an algorithm that calculates the total energy consumption over a given period, measured in steps, for the grid. **Method Description**: The steps to Watt algorithm iteratively computes the total energy consumption based on discrete time steps. It updates the total energy as follows: [ E_{total} = sum_{i=0}^{n} P(t_i) Delta t ] Where ( P(t_i) ) is the power at step ( t_i ), and ( Delta t ) is the constant time step between measurements. **Task**: - Implement the `calculate_energy_consumption` method within the `EnergyGrid` class. - Ensure that it processes a list of power measurements (`power_readings`) over a given period and a time step `delta_t`. **Constraints**: - The length of `power_readings` should be at least 1. - If `power_readings` is empty, raise a `ValueError` stating \\"No power readings provided.\\" - Use the specified formula to compute the total energy directly. **Expected Behavior**: - Compute and return the total energy consumption, given the power readings and the time step. **Function Signature**: ```python def calculate_energy_consumption(self, power_readings: List[float], delta_t: float) -> float: pass ``` **Examples**: ```python >>> def power_measurement(t): ... return 100 - 2*t >>> grid = EnergyGrid() >>> energy = grid.calculate_energy_consumption([power_measurement(t) for t in range(5)], 1) >>> round(energy, 2) 290.0 >>> EnergyGrid().calculate_energy_consumption([], 1) Traceback (most recent call last): ... ValueError: No power readings provided. ``` **Assumptions**: - You can assume the power readings are given as a list of floats. - The time step `delta_t` is a positive float.","solution":"class EnergyGrid: def calculate_energy_consumption(self, power_readings, delta_t): if not power_readings: raise ValueError(\\"No power readings provided\\") total_energy = sum(power_readings) * delta_t return total_energy"},{"question":"# Coding Assessment Question Scenario In a system that monitors temperature changes, you are tasked with creating a component that identifies the lengths of the longest subsequences of a given list of temperature readings where the temperatures continuously increase. Task Implement a function `longest_increasing_subsequence_length(temps: List[int]) -> int` that determines the length of the longest continuous subsequence of increasing temperatures. ```python def longest_increasing_subsequence_length(temps: List[int]) -> int: pass ``` Constraints * The input list, `temps`, will contain between `1` and `10^5` integers. * Each temperature reading will be an integer within the range of `-10^6` to `10^6`. Input/Output Format * **Input**: A single list of integers `temps`. * **Output**: An integer representing the length of the longest continuous subsequence of increasing temperatures. Edge cases to consider * List with all identical temperatures. * List with only one temperature. * Lists where temperatures always decrease. Performance Requirements * Time complexity should be O(n) * Space complexity should be O(1) Examples ```python longest_increasing_subsequence_length([1, 2, 3, 2, 1, 2, 3, 4]) -> 4 longest_increasing_subsequence_length([10, 9, 8, 7]) -> 1 longest_increasing_subsequence_length([5, 5, 5, 5]) -> 1 longest_increasing_subsequence_length([1]) -> 1 longest_increasing_subsequence_length([1, 3, 5, 4, 7]) -> 3 ``` Implementation Develop your solution using a single pass through the list to ensure optimal performance when dealing with large lists of temperature readings.","solution":"from typing import List def longest_increasing_subsequence_length(temps: List[int]) -> int: if not temps: return 0 longest = 1 current_length = 1 for i in range(1, len(temps)): if temps[i] > temps[i - 1]: current_length += 1 longest = max(longest, current_length) else: current_length = 1 return longest"},{"question":"# Question You have been contracted to develop a system that manages user sessions using a secure token-based approach. The task is to implement a function that generates and validates session tokens based on user information and an expiration period. The token should be generated using a simple encryption method and be tied to a user-specific signature. # Function to Implement Function Signature ```python def session_manager(secret_key: str) -> (str -> str, str -> bool) ``` Input * `secret_key` (string): A secret key for initializing the session manager. Output * A tuple containing two functions: * A `generate_token` function that takes a user ID (string) and an expiration period in seconds (integer) and returns a session token (string). * A `validate_token` function that takes a session token (string) and returns a boolean indicating whether the token is valid or has expired. Requirements * The `generate_token` function should use a simple encryption method to create the session token by combining the user ID, the current timestamp, and the expiration period, signed with the secret key. * The `validate_token` function should decrypt the session token to extract the user ID and the timestamp, then verify if the token is still valid based on the expiration period and the secret key. * The token should include a checksum to ensure its integrity. * Use a secure hashing algorithm for signatures, such as HMAC with SHA256. # Examples ```python # Example 1 generate_token, validate_token = session_manager(\'SuperSecretKey123\') token = generate_token(\\"user123\\", 3600) # valid for 1 hour assert validate_token(token) == True # simulate waiting for token expiration (1 second validity) import time token = generate_token(\\"user456\\", 1) # valid for 1 second time.sleep(2) assert validate_token(token) == False # Example 2 generate_token, validate_token = session_manager(\'AnotherSecretKey456\') token = generate_token(\\"user789\\", 3600) assert validate_token(token) == True ``` # Constraints * The secret key will have a length between 8 and 32 characters and will consist of uppercase and lowercase letters and digits only. * The user ID will be a non-empty string containing only alphanumeric characters. * The expiration period will be a positive integer. * The generated token should be a string of printable ASCII characters.","solution":"import time import hmac import hashlib import base64 def session_manager(secret_key: str): def generate_token(user_id: str, expiration_period: int) -> str: timestamp = int(time.time()) data = f\\"{user_id}:{timestamp}:{expiration_period}\\" signature = hmac.new(secret_key.encode(), data.encode(), hashlib.sha256).hexdigest() token = f\\"{data}:{signature}\\" encoded_token = base64.urlsafe_b64encode(token.encode()).decode() return encoded_token def validate_token(token: str) -> bool: try: decoded_token = base64.urlsafe_b64decode(token.encode()).decode() user_id, timestamp, expiration_period, signature = decoded_token.split(\':\') data = f\\"{user_id}:{timestamp}:{expiration_period}\\" expected_signature = hmac.new(secret_key.encode(), data.encode(), hashlib.sha256).hexdigest() if hmac.compare_digest(signature, expected_signature): current_time = int(time.time()) if current_time <= int(timestamp) + int(expiration_period): return True return False except Exception: return False return generate_token, validate_token"},{"question":"# Coding Question: Implementing a Custom Sorting Algorithm Based on Multiple Criteria Context A sports event management system needs to sort a list of participants based on their performance scores. Given the importance of multiple criteria, the participants need to be sorted primarily by their total score in descending order. If two participants have the same total score, they should be further sorted by their name in ascending order. Problem Statement Implement the function `custom_sort_participants` that sorts a list of participants based on their scores and names using the specified rules. **Function Signature:** ```python def custom_sort_participants(participants: list[dict]) -> list[dict] ``` **Input:** - `participants` (List of dictionaries): Each dictionary contains the following keys: - \'name\' (string): The name of the participant. - \'score\' (integer): The total score of the participant. **Output:** - Returns the list of participants sorted according to the given criteria. **Constraints:** - 0 <= len(participants) <= 10^4 - Each participant has a unique name and a non-negative score. **Example Usage:** ```python >>> custom_sort_participants([{\\"name\\": \\"Alice\\", \\"score\\": 95}, {\\"name\\": \\"Bob\\", \\"score\\": 85}, {\\"name\\": \\"Charlie\\", \\"score\\": 95}]) [ {\\"name\\": \\"Alice\\", \\"score\\": 95}, {\\"name\\": \\"Charlie\\", \\"score\\": 95}, {\\"name\\": \\"Bob\\", \\"score\\": 85} ] >>> custom_sort_participants([{\\"name\\": \\"Alice\\", \\"score\\": 100}]) [ {\\"name\\": \\"Alice\\", \\"score\\": 100} ] >>> custom_sort_participants([]) [] ``` Additional Notes: 1. Ensure the algorithm correctly handles edge cases such as an empty list or a list with one participant. 2. The sorting should be stable, i.e., participants with equal scores and names already sorted should remain in their original order after sorting. 3. Utilize Python\'s built-in sorting functionalities efficiently for an optimal solution. # Solution: ```python def custom_sort_participants(participants: list[dict]) -> list[dict]: return sorted(participants, key=lambda x: (-x[\'score\'], x[\'name\'])) ```","solution":"def custom_sort_participants(participants: list[dict]) -> list[dict]: Sorts a list of participants based on their scores in descending order. If scores are tied, sorts them by their names in ascending order. Args: participants (list): A list of dictionaries, each containing \'name\' and \'score\'. Returns: list: The sorted list of participants. return sorted(participants, key=lambda x: (-x[\'score\'], x[\'name\']))"},{"question":"# Coding Assessment Question **Title**: Efficient Sparse Matrix Multiplication **Objective**: Implement a function to multiply two sparse matrices efficiently. Your task is to leverage the sparsity of the matrices to optimize the multiplication process. **Context**: Sparse matrices are matrices in which most of the elements are zero. Given two sparse matrices, Bob needs to easily find their product without spending too much time and space dealing with the zeroes. Your task is to implement an efficient algorithm to multiply these matrices that handles the sparsity effectively. **Task**: Write a function `sparse_matrix_multiply` to multiply two sparse matrices represented in a space-efficient manner. # Requirements Function Definition ```python def sparse_matrix_multiply(A: dict[tuple[int, int], int], B: dict[tuple[int, int], int], n: int) -> dict[tuple[int, int], int]: Multiply two sparse matrices and return the product as a sparse matrix. Args: A (dict[tuple[int, int], int]): The first sparse matrix represented as a dictionary. B (dict[tuple[int, int], int]): The second sparse matrix represented as a dictionary. n (int): The size of the matrices (both matrices are n x n). Returns: dict[tuple[int, int], int]: The product of the two matrices represented as a sparse matrix. pass ``` # Constraints and Input: 1. **A, B**: Sparse matrices A and B, represented by dictionaries where the keys are tuples (i, j) representing row and column indices, and the values are the non-zero elements. 2. **n**: An integer representing the size of the matrices (both matrices are n x n). 3. **Output**: The output matrix should also be represented as a dictionary in a similar manner. Examples: **Example 1** ```python A = {(0, 1): 1, (2, 2): 5} B = {(1, 0): 7, (2, 1): 1} n = 3 product_matrix = sparse_matrix_multiply(A, B, n) print(product_matrix) # Output should be {(0, 0): 7, (2, 1): 5} ``` **Example 2** ```python A = {(0, 0): 3, (0, 2): 2, (1, 1): 4} B = {(0, 1): 1, (2, 0): 5} n = 3 product_matrix = sparse_matrix_multiply(A, B, n) print(product_matrix) # Output should be {(0, 1): 3, (0, 0): 10} ``` # Performance Requirements: - The solution should run efficiently given the sparsity of the input matrices. Leverage the sparsity to avoid unnecessary computations involving zero elements. # Assumptions: - You can assume valid input matrices are provided for the function. - The input matrices will be square matrices of the same size. This new question explores matrix operations with an emphasis on optimizing for sparsity, aligning with the advanced manipulation of data structures seen in the original questions. It matches the cognitive challenge and computational focus, ensuring consistency in difficulty and topic scope.","solution":"def sparse_matrix_multiply(A, B, n): Multiply two sparse matrices and return the product as a sparse matrix. Args: A (dict[tuple[int, int], int]): The first sparse matrix represented as a dictionary. B (dict[tuple[int, int], int]): The second sparse matrix represented as a dictionary. n (int): The size of the matrices (both matrices are n x n). Returns: dict[tuple[int, int], int]: The product of the two matrices represented as a sparse matrix. # Initialize an empty dictionary for the resulting sparse matrix C = {} # Iterate through the entries of the first matrix A for (i, k), v in A.items(): # For each non-zero entry in A, if there is a corresponding entry in B, multiply and add for j in range(n): if (k, j) in B: if (i, j) in C: C[(i, j)] += v * B[(k, j)] else: C[(i, j)] = v * B[(k, j)] return C"},{"question":"# Problem Statement You are required to create a `Matrix` class representing a 2D matrix and implement matrix rotation functionality. Specifically, you need to rotate the matrix 90 degrees clockwise. # Implementation Details - Create a `Matrix` class that: - Initializes with a 2D list (list of lists) representing the matrix. - Ensures that all rows have the same number of columns (rectangular matrix). - Implement the `rotate_clockwise` method to rotate the matrix 90 degrees clockwise. # Input & Output Formats - **Input**: The matrix will be initialized with a 2D list of integers. - `Matrix(matrix: List[List[int]])` - **Output**: - `rotate_clockwise()` method should return a new 2D list representing the rotated matrix. # Constraints - The input matrix will be non-empty and rectangular. - The number of rows and columns should be within the range of 1 to 100. # Example ```python # Example matrix initialization m = Matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) rotated_matrix = m.rotate_clockwise() # Expected output: [[7, 4, 1], [8, 5, 2], [9, 6, 3]] print(rotated_matrix) m2 = Matrix([[1, 2], [3, 4], [5, 6]]) rotated_matrix_2 = m2.rotate_clockwise() # Expected output: [[5, 3, 1], [6, 4, 2]] print(rotated_matrix_2) ``` # Performance Requirements - Ensure the implementation is efficient in terms of time and space complexity. - Avoid unnecessary duplication of data to maintain efficiency. --- This question requires candidates to demonstrate their skills in class design, data validation, and matrix manipulation, which aligns with the complexity, scope, and style of the provided question set.","solution":"class Matrix: def __init__(self, matrix): if not matrix or not all(isinstance(row, list) for row in matrix): raise ValueError(\\"Input should be a non-empty 2D list.\\") row_len = len(matrix[0]) for row in matrix: if len(row) != row_len: raise ValueError(\\"All rows must have the same number of columns.\\") self.matrix = matrix def rotate_clockwise(self): rows = len(self.matrix) cols = len(self.matrix[0]) rotated_matrix = [[0] * rows for _ in range(cols)] for r in range(rows): for c in range(cols): rotated_matrix[c][rows - 1 - r] = self.matrix[r][c] return rotated_matrix"},{"question":"# Recursive Fibonacci Sequence Generator Context: You are asked to implement a function that returns the first `n` numbers in the Fibonacci sequence using recursion. The Fibonacci sequence is defined as follows: - The first number in the sequence is 0. - The second number in the sequence is 1. - Each subsequent number is the sum of the previous two numbers. # Function: Recursive Fibonacci Write a function `recursive_fibonacci(n: int) -> list` that takes an integer `n` and returns a list of the first `n` numbers in the Fibonacci sequence. The function should be implemented recursively. Example: ```python >>> recursive_fibonacci(1) [0] >>> recursive_fibonacci(2) [0, 1] >>> recursive_fibonacci(5) [0, 1, 1, 2, 3] >>> recursive_fibonacci(10) [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] ``` # Constraints: 1. The input `n` must be a non-negative integer (0 ≤ n ≤ 30). 2. The function should use a recursive approach to generate the Fibonacci sequence. 3. The function should handle the base cases for `n = 0` and `n = 1` appropriately. # Additional Notes: - The base cases for the recursion should be correctly defined to avoid infinite recursion. - Consider using memoization to optimize the recursive calls and avoid redundant calculations.","solution":"def recursive_fibonacci(n): Returns a list of the first n Fibonacci numbers using a recursive approach. # Base cases if n == 0: return [] elif n == 1: return [0] # Preparation to start recursion for n > 1 def fib_helper(acc, a, b, count): if count == 0: return acc return fib_helper(acc + [a + b], b, a + b, count - 1) # Initial call to the helper function return fib_helper([0, 1], 0, 1, n - 2)"},{"question":"# Problem Statement Given a string, you need to determine the longest substring with all distinct characters. Task Write a function `length_of_longest_substring(s: str) -> int` that takes in a string and returns the length of the longest substring with all distinct characters. Input * `s` (str): The input string. (1 ≤ len(s) ≤ 100,000) Output * Returns an integer representing the length of the longest substring with all distinct characters. Constraints * The string will contain both uppercase and lowercase letters, as well as digits and punctuation marks. * Consider the efficiency of your algorithm to ensure it runs within acceptable time limits for the largest inputs. # Example ```python assert length_of_longest_substring(\\"abcabcbb\\") == 3 assert length_of_longest_substring(\\"bbbbb\\") == 1 assert length_of_longest_substring(\\"pwwkew\\") == 3 assert length_of_longest_substring(\\"abcd\\") == 4 assert length_of_longest_substring(\\"aabaab!bb\\") == 3 ``` Additional Notes The substring does not need to be a contiguous block, but it must be of the maximum possible length within the given constraints. For example, in \\"abcabcbb\\", the longest substring with all distinct characters is \\"abc\\", which has a length of 3.","solution":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring with all distinct characters. n = len(s) char_index_map = {} longest = 0 start = 0 for end in range(n): if s[end] in char_index_map and char_index_map[s[end]] >= start: start = char_index_map[s[end]] + 1 char_index_map[s[end]] = end longest = max(longest, end - start + 1) return longest"},{"question":"# Coding Assessment Question: **Problem Description**: You are tasked with implementing a simplified version of a Convolutional Neural Network (CNN) for image classification. The primary goal of this exercise is to ensure your comprehension of CNN architecture and your ability to implement basic components of deep learning algorithms. Specifically, your implementation will focus on building a CNN with one convolutional layer, followed by a max-pooling layer and a fully connected layer for binary classification. **Requirements**: Implement the `CustomCNNClassifier` class to achieve efficient and effective image classification using a convolutional neural network. The implementation should include the following methods: 1. **Constructor `__init__(self, image_shape: tuple, num_filters: int = 32, filter_size: int = 3, pool_size: int = 2, num_classes: int = 2)`** - Initialize the CNN classifier with the given number of filters, filter size, pooling size, and the number of classes. 2. **Method `fit(self, X_train: np.ndarray, y_train: np.ndarray, epochs: int = 10, learning_rate: float = 0.001)`** - Train the CNN classifier using the training data for the specified number of epochs. 3. **Method `predict(self, X_test: np.ndarray) -> np.ndarray`** - Predict the labels for the input test images. 4. **Helper Method `convolve(self, X: np.ndarray, filters: np.ndarray) -> np.ndarray`** - Apply convolution operation on the input data with the given filters. 5. **Helper Method `max_pool(self, X: np.ndarray, pool_size: int) -> np.ndarray`** - Apply max-pooling operation on the input data with the given pooling size. 6. **Helper Method `fully_connected(self, X: np.ndarray) -> np.ndarray`** - Flatten the input data and pass it through a fully connected layer to output class scores. **Input/Output**: 1. **Constructor Parameters**: - `image_shape` (tuple): Shape of the input images (height, width, channels). - `num_filters` (int): Number of filters for the convolutional layer. - `filter_size` (int): Size of the convolution filters. - `pool_size` (int): Size of the pooling window. - `num_classes` (int): Number of output classes. 2. **Method Parameters for `fit`**: - `X_train` (np.ndarray): Training images of shape (N, height, width, channels). - `y_train` (np.ndarray): Training labels of shape (N,). - `epochs` (int): Number of epochs to train the model. - `learning_rate` (float): Learning rate for the optimizer. 3. **Method Parameters for `predict`**: - `X_test` (np.ndarray): Test images of shape (N, height, width, channels). 4. **Method Output for `predict`**: - Return (np.ndarray): Array of predicted labels of shape (N,). 5. **Constraints**: - Assume binary classification (0 and 1 as labels). - Ensure the convolution and pooling operations handle the typical edge cases. - The implementation should handle typical edge cases and provide efficient computation. **Performance Requirements**: - Ensure the solution is optimized for efficiency in both time and space complexities as discussed in the analysis. **Example**: ```python import numpy as np class CustomCNNClassifier: # Implement the class following the specifications above def __init__(self, image_shape: tuple, num_filters: int = 32, filter_size: int = 3, pool_size: int = 2, num_classes: int = 2): # Initialize the network architecture self.image_shape = image_shape self.num_filters = num_filters self.filter_size = filter_size self.pool_size = pool_size self.num_classes = num_classes # Initialize filters and weights def convolve(self, X: np.ndarray, filters: np.ndarray) -> np.ndarray: # Implement the convolution operation pass def max_pool(self, X: np.ndarray, pool_size: int) -> np.ndarray: # Implement the max pooling operation pass def fully_connected(self, X: np.ndarray) -> np.ndarray: # Implement the fully connected layer operation pass def fit(self, X_train: np.ndarray, y_train: np.ndarray, epochs: int, learning_rate: float) -> None: # Implement the training process pass def predict(self, X_test: np.ndarray) -> np.ndarray: # Implement the prediction process pass if __name__ == \\"__main__\\": # Generate random data to simulate the training and testing process X_train = np.random.randn(100, 28, 28, 1) # 100 samples of 28x28 grayscale images y_train = np.random.randint(0, 2, 100) # binary labels X_test = np.random.randn(20, 28, 28, 1) # 20 test samples # Initialize and train the classifier cnn = CustomCNNClassifier(image_shape=(28, 28, 1), num_filters=32, filter_size=3, pool_size=2, num_classes=2) cnn.fit(X_train, y_train, epochs=10, learning_rate=0.001) # Predict and evaluate accuracy y_pred = cnn.predict(X_test) print(f\\"Predictions: {y_pred}\\") ``` **Objective**: Ensure that you thoroughly understand the convolutional neural network architecture and can implement it to solve real-world image classification problems.","solution":"import numpy as np class CustomCNNClassifier: def __init__(self, image_shape: tuple, num_filters: int = 32, filter_size: int = 3, pool_size: int = 2, num_classes: int = 2): self.image_shape = image_shape self.num_filters = num_filters self.filter_size = filter_size self.pool_size = pool_size self.num_classes = num_classes # Initialize filters (weights) for convolution self.filters = np.random.randn(num_filters, filter_size, filter_size, image_shape[2]) # Weights for the fully connected layer fc_input_size = ((image_shape[0] - filter_size + 1) // pool_size) * ((image_shape[1] - filter_size + 1) // pool_size) * num_filters self.fc_weights = np.random.randn(fc_input_size, num_classes) self.fc_bias = np.random.randn(num_classes) def convolve(self, X: np.ndarray, filters: np.ndarray) -> np.ndarray: N, height, width, channels = X.shape num_filters, filter_size, _, _ = filters.shape new_height = height - filter_size + 1 new_width = width - filter_size + 1 conv_output = np.zeros((N, new_height, new_width, num_filters)) for i in range(new_height): for j in range(new_width): region = X[:, i:i+filter_size, j:j+filter_size, :] for k in range(num_filters): conv_output[:, i, j, k] = np.sum(region * filters[k], axis=(1, 2, 3)) return conv_output def max_pool(self, X: np.ndarray, pool_size: int) -> np.ndarray: N, height, width, channels = X.shape new_height = height // pool_size new_width = width // pool_size pooled_output = np.zeros((N, new_height, new_width, channels)) for i in range(new_height): for j in range(new_width): region = X[:, i*pool_size:(i+1)*pool_size, j*pool_size:(j+1)*pool_size, :] pooled_output[:, i, j, :] = np.max(region, axis=(1, 2)) return pooled_output def fully_connected(self, X: np.ndarray) -> np.ndarray: N = X.shape[0] X_flat = X.reshape(N, -1) return np.dot(X_flat, self.fc_weights) + self.fc_bias def fit(self, X_train: np.ndarray, y_train: np.ndarray, epochs: int = 10, learning_rate: float = 0.001) -> None: for epoch in range(epochs): # Forward pass conv_output = self.convolve(X_train, self.filters) pooled_output = self.max_pool(conv_output, self.pool_size) logits = self.fully_connected(pooled_output) # Compute loss (simple binary cross-entropy) probs = 1 / (1 + np.exp(-logits)) loss = -np.mean(y_train * np.log(probs[:, 1]) + (1 - y_train) * np.log(1 - probs[:, 1])) # Backward pass grad_logits = probs grad_logits[range(X_train.shape[0]), y_train] -= 1 grad_logits /= X_train.shape[0] grad_fc_weights = np.dot(pooled_output.reshape(X_train.shape[0], -1).T, grad_logits) grad_fc_bias = np.sum(grad_logits, axis=0) # Update weights (simplified without gradients for convolution and pooling) self.fc_weights -= learning_rate * grad_fc_weights self.fc_bias -= learning_rate * grad_fc_bias def predict(self, X_test: np.ndarray) -> np.ndarray: conv_output = self.convolve(X_test, self.filters) pooled_output = self.max_pool(conv_output, self.pool_size) logits = self.fully_connected(pooled_output) probs = 1 / (1 + np.exp(-logits)) return np.argmax(probs, axis=1)"},{"question":"# Context: Sorting algorithms are fundamental to computer science, enabling the organization of data in an efficient manner. One of the straightforward and easy-to-understand sorting algorithms is the insertion sort. This algorithm is often used for its simplicity and for small datasets or nearly sorted arrays. # Objective: Implement the insertion sort algorithm to sort an array of integers in ascending order. Your function should be named `insertion_sort` and should sort the array in place. # Problem Statement: Write a function `insertion_sort` that sorts an array of integers using the insertion sort algorithm. Function Signature: ```python def insertion_sort(arr: List[int]) -> List[int]: pass ``` Input: - `arr`: A list of integers which can be empty or contain negative and positive integers. Output: - Returns the sorted list of integers in ascending order. # Examples: ```python >>> insertion_sort([4, 2, 7, 1, 3]) [1, 2, 3, 4, 7] >>> insertion_sort([10, -3, 50, 0, 4]) [-3, 0, 4, 10, 50] >>> insertion_sort([]) [] >>> insertion_sort([3]) [3] ``` # Notes: - The input list can be empty. - The function should sort the list in place but return the sorted list for convenience. - Pay attention to the algorithm complexity and try to implement it as expected from the insertion sort algorithm. Your task is to ensure that the function works correctly and efficiently for a variety of test cases, including edge cases with empty lists or single-element lists.","solution":"def insertion_sort(arr): Sorts an array of integers using the insertion sort algorithm in ascending order. :param arr: List[int] - list of integers to be sorted :return: List[int] - sorted list in ascending order for i in range(1, len(arr)): key = arr[i] j = i - 1 while j >= 0 and key < arr[j]: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key return arr"},{"question":"# Even-Odd Number Segregator **Context**: In many applications, it is required to reorganize data based on specific constraints. One common task is to separate even and odd numbers within a list while preserving their relative order. This can be useful, for example, in optimizing certain mathematical operations or preparing datasets for specific algorithms. Task Implement the function `segregate_even_odd` that reorders an input list of integers such that all even numbers appear before all odd numbers, while maintaining their original relative order within each group (even and odd). Input Format * A list of integers `numbers` of length `n` (0 < n < 10^5) Output Format * A list rearranged such that all even numbers come before all odd numbers, preserving the original order within each group. Constraints * Time Complexity: O(n) * Space Complexity: O(n) Function Signature ```python def segregate_even_odd(numbers: list[int]) -> list[int]: pass ``` Implementation Details 1. Traverse the list and collect all even numbers in one list and all odd numbers in another. 2. Concatenate the even and odd lists to form the result. Example ```python print(segregate_even_odd([4, 2, 7, 3, 6, 9, 8, 1, 14, 11])) # Output: [4, 2, 6, 8, 14, 7, 3, 9, 1, 11] print(segregate_even_odd([1, 3, 5, 7, 9])) # Output: [1, 3, 5, 7, 9] print(segregate_even_odd([2, 4, 6, 8, 10])) # Output: [2, 4, 6, 8, 10] print(segregate_even_odd([])) # Output: [] ``` Notes * Ensure the solution handles edge cases, such as lists with all odd or all even numbers. * Validate performance for large lists by considering time and space constraints. * Cases with an empty list should simply return an empty list. This problem tests the ability to manipulate lists and understand constraints around time and space complexity while delivering an optimal solution. It reinforces basic data handling and organizational strategies crucial for effective programming.","solution":"def segregate_even_odd(numbers: list[int]) -> list[int]: even_numbers = [num for num in numbers if num % 2 == 0] odd_numbers = [num for num in numbers if num % 2 != 0] return even_numbers + odd_numbers"},{"question":"# Coding Question: Weather Data Analysis Scenario: You are working on a software solution for analyzing weather data. Suppose you have access to historical daily temperature records for a particular city. You need to analyze this data to determine the longest sequence of consecutive days where the temperature exceeds a given threshold. Task: Implement a function `longest_heatwave` that calculates the length of the longest sequence of consecutive days where the daily temperature is above the specified threshold. Function Signature: ```python def longest_heatwave(temperatures: List[int], threshold: int) -> int: pass ``` Input: * `temperatures` (List[int]): A list of integers representing daily temperatures. * `threshold` (int): An integer representing the temperature threshold. Output: * Return the length of the longest sequence of consecutive days where the temperature is above the threshold. Constraints: * The length of the temperatures list will not exceed 10,000 entries. * Temperature values will range from -50 to 50 degrees Celsius. * The threshold will be a value within the same temperature range. Example: ```python >>> longest_heatwave([30, 35, 40, 45, 33, 25, 42, 44, 45, 50, 26, 28], 40) 4 # Sequence: [40, 45, 42, 44] >>> longest_heatwave([25, 25, 25, 25, 25, 25, 25], 30) 0 # Since no temperature exceeds 30, the length is 0. >>> longest_heatwave([42, 44, 39, 45, 40, 38], 40) 2 # Sequences: [42, 44] and [45], max length is 2. ``` Additional Information: Consider the efficiency and readability of your implementation. The problem can be solved using linear traversal of the temperature data with careful tracking of sequences exceeding the threshold.","solution":"from typing import List def longest_heatwave(temperatures: List[int], threshold: int) -> int: Returns the length of the longest sequence of consecutive days where the daily temperature is above the specified threshold. max_length = 0 current_length = 0 for temp in temperatures: if temp > threshold: current_length += 1 max_length = max(max_length, current_length) else: current_length = 0 return max_length"},{"question":"# Coding Assessment Question Problem Statement: You have been tasked with implementing a function that, given a list of strings representing numbers, determines which binary representation of these numbers contains the most set bits (1s). Write a function `most_set_bits(numbers: List[str]) -> int` that takes a list of strings `numbers` each representing an integer and returns the integer (as an integer) that has the highest number of set bits in its binary representation. If there is a tie, return the smallest integer among them. Input: * `numbers` (1 <= len(numbers) <= 1000): A list of strings, where each string represents a non-negative integer. Output: * An integer representing the number that has the highest number of set bits in its binary representation. If there are multiple such numbers, the smallest one among them should be returned. Example: ```python assert most_set_bits([\'1\', \'2\', \'3\', \'4\', \'7\']) == 7 assert most_set_bits([\'10\', \'15\', \'20\', \'30\']) == 15 assert most_set_bits([\'8\', \'16\', \'32\', \'64\']) == 8 assert most_set_bits([\'5\', \'6\', \'9\', \'10\']) == 9 ``` Constraints: * The input list will have at most 1000 elements. * Each string in the list represents a valid non-negative integer. * Consider edge cases such as an empty binary representation or large integer values. Performance: * Aim for an efficient solution that handles the given constraints with minimal computational overhead.","solution":"from typing import List def most_set_bits(numbers: List[str]) -> int: def count_set_bits(n: int) -> int: return bin(n).count(\'1\') max_set_bits = -1 result = float(\'inf\') for num_str in numbers: num = int(num_str) set_bits = count_set_bits(num) if set_bits > max_set_bits or (set_bits == max_set_bits and num < result): max_set_bits = set_bits result = num return result"},{"question":"# Question Description Implement a Python function that checks if a given string is a valid \\"shifted palindrome\\". A \\"shifted palindrome\\" is defined as a string that can be rearranged into a palindrome by shifting (rotating) its characters any number of times. Consider both even-length and odd-length palindromes in your solution. Your function should validate the string and efficiently determine whether it can be rearranged into a palindrome using rotation. # Function Signature ```python def is_shifted_palindrome(s: str) -> bool: Checks if the given string is a valid shifted palindrome. Parameters: s (str): The input string, consisting only of lowercase alphabetical characters. Returns: bool: True if the string is a shifted palindrome, False otherwise. Constraints: - `1 <= len(s) <= 10^4` ``` # Input - A single string `s` consisting of lowercase alphabetical characters. - The length of the string will be between `1` and `10,000`. # Output - A boolean value indicating whether the string is a valid shifted palindrome. # Example ```python >>> is_shifted_palindrome(\\"aab\\") True # \\"aab\\" can be rotated to \\"aba\\" >>> is_shifted_palindrome(\\"abc\\") False # \\"abc\\" cannot be rearranged into a palindrome >>> is_shifted_palindrome(\\"aaa\\") True # \\"aaa\\" is already a palindrome >>> is_shifted_palindrome(\\"aabb\\") True # \\"aabb\\" can be rotated to \\"abba\\" >>> is_shifted_palindrome(\\"abcba\\") True # \\"abcba\\" is already a palindrome ``` # Constraints - Ensure the input string `s` meets the specified conditions. - Consider edge cases like a single character or identical characters in the string.","solution":"def is_shifted_palindrome(s: str) -> bool: Checks if the given string is a valid shifted palindrome. Parameters: s (str): The input string, consisting only of lowercase alphabetical characters. Returns: bool: True if the string is a shifted palindrome, False otherwise. from collections import Counter # Count character frequencies char_count = Counter(s) # Determine the number of characters with odd frequencies odd_count = sum(1 for count in char_count.values() if count % 2 == 1) # For the string to be rearranged into a palindrome: # - At most 1 character can have an odd frequency (in case of odd-length palindrome) # - All characters must have even frequencies otherwise (in case of even-length palindrome) return odd_count <= 1"},{"question":"# Scenario You are developing a feature for a financial application that needs to determine if a given list of transactions consistently alternate between positive (deposits) and negative (withdrawals) amounts. This feature is crucial for validating specific investment strategies where alternating transactions are required. # Problem Statement Implement a function `alternating_transactions(transactions: List[int]) -> bool` that takes in a list of integers representing transaction amounts. The function should return `True` if the transactions alternate in sign (i.e., positive, negative, positive, etc.), and `False` otherwise. # Input and Output Formats * The function will receive one list of integers as input parameter. * The function will return a boolean `True` or `False`. # Constraints * The length of the list can range from 0 to (10^6). * Each transaction amount can range from (-10^{6}) to (10^{6}). # Performance Requirements * The implementation should have linear time complexity (O(n)), where (n) is the length of the list. # Example Cases ```python >>> alternating_transactions([100, -50, 200, -100]) True >>> alternating_transactions([100, 50, -200, -100]) False >>> alternating_transactions([-300, 200, -100, 50]) True >>> alternating_transactions([100]) True >>> alternating_transactions([]) True >>> alternating_transactions([100, -100, 0, -100]) False >>> alternating_transactions([-100, 150, -200, 250]) True ``` # Additional Notes * Consider edge cases such as an empty list or a list with a single transaction. * A sequence with a single transaction is considered alternating by default. * Zero is not considered either positive or negative, so if a zero appears in the list, it should return `False`.","solution":"def alternating_transactions(transactions): Checks if the transactions alternate between positive and negative. if not transactions: return True # Return False immediately if a zero is present if 0 in transactions: return False for i in range(1, len(transactions)): if (transactions[i] >= 0 and transactions[i-1] >= 0) or (transactions[i] < 0 and transactions[i-1] < 0): return False return True"},{"question":"# Coding Assessment Question: Calculate Factorials Recursively **Context**: The factorial of a non-negative integer ( n ) is the product of all positive integers less than or equal to ( n ). Factorials are widely used in combinations, permutations, and many other mathematical contexts. In this task, you are required to implement a function that calculates the factorial of a number using a recursive approach. **Requirements**: 1. Implement the function `recursive_factorial(n: int) -> int`: * The function should take a non-negative integer `n` as input and return its factorial. * Use a recursive approach to implement the factorial calculation. * The factorial of 0 is defined as 1. 2. Ensure that your function handles edge cases and provides correct results for: * Small and large values of `n`. * Values like 0, 1, and 10. 3. Your implementation should have: * **Time Complexity**: O(n) * **Space Complexity**: O(n) due to the recursive call stack. 4. Validate your function with the following assertions: ```python assert recursive_factorial(0) == 1 assert recursive_factorial(1) == 1 assert recursive_factorial(5) == 120 assert recursive_factorial(7) == 5040 assert recursive_factorial(10) == 3628800 assert recursive_factorial(12) == 479001600 ``` **Function Signature**: ```python def recursive_factorial(n: int) -> int: pass ```","solution":"def recursive_factorial(n: int) -> int: Returns the factorial of a non-negative integer n using a recursive approach. if n == 0: return 1 return n * recursive_factorial(n - 1)"},{"question":"# Scenario A social media platform provides a feature where users can shorten URLs. As part of a system update, the platform is transitioning away from a third-party service to a custom URL shortening service. Your task is to implement a simplified version of this custom service that generates short URLs and retrieves the original URLs. # Task Implement a class `URLShortener` which provides methods to shorten a given URL and retrieve the original URL from a shortened URL. # Class Definition - `URLShortener()`: Initializes an instance of the class. - `shorten_url(url: str) -> str`: Generates and returns a shortened version of the input URL. - `retrieve_url(short_url: str) -> str`: Retrieves and returns the original URL given a shortened URL. # Constraints and Notes - Shortened URLs should be unique for each unique input URL. - The implementation should handle at least 100,000 unique URLs efficiently. - The shortened URL format can be a simple representation but must be unique and deterministic. # Example ```python >>> url_shortener = URLShortener() >>> short_url = url_shortener.shorten_url(\'https://www.example.com\') >>> short_url \'http://short.url/1\' >>> original_url = url_shortener.retrieve_url(short_url) >>> original_url \'https://www.example.com\' ``` # Additional Notes - The dictionary or any other data structure can be used for mapping full URLs to their shortened forms and vice versa. - Ensure that edge cases, such as retrieving a URL using an invalid shortened URL, are appropriately handled. - You may use simple counter-based or hash-based techniques to generate unique identifiers for shortened URLs.","solution":"class URLShortener: def __init__(self): self.url_to_short = {} self.short_to_url = {} self.counter = 1 self.base_url = \\"http://short.url/\\" def shorten_url(self, url: str) -> str: if url in self.url_to_short: return self.url_to_short[url] short_url = self.base_url + str(self.counter) self.url_to_short[url] = short_url self.short_to_url[short_url] = url self.counter += 1 return short_url def retrieve_url(self, short_url: str) -> str: if short_url in self.short_to_url: return self.short_to_url[short_url] return None"},{"question":"# Coding Assessment Question Context You are building a music application that calculates the duration of playlists. Each playlist consists of several songs, and each song has a specific duration. Occasionally, some playlists contain a \\"commercial break\\", which is a segment of silence that must be included in the total duration calculation. Task Write a function `calculate_playlist_duration(playlist: list[tuple[str, Union[int, float]]]) -> float` that: 1. Sums the durations of all songs and commercial breaks in the playlist. 2. Returns the total duration of the playlist in minutes. Input - `playlist`: A list of tuples, where each tuple contains: - `name`: String representing either the name of the song or the label \'commercial_break\'. - `duration`: An integer or float representing the duration of the song or the commercial break in minutes. Output - A float representing the total duration of the playlist in minutes. Constraints - Each element of `playlist` is a well-formed tuple. - `duration` values will always be non-negative. - The list `playlist` can contain up to 10⁶ elements. Performance Requirements - Ensure the code handles the summation efficiently even for the upper limit of elements. Example ```python playlist = [ (\'song1\', 3.5), (\'song2\', 4.0), (\'commercial_break\', 0.5), (\'song3\', 5.0) ] result = calculate_playlist_duration(playlist) print(result) # Expected output: 13.0 (total duration of the playlist in minutes) ```","solution":"def calculate_playlist_duration(playlist): Returns the total duration of a playlist including songs and commercial breaks. Args: playlist (list of tuples): Each tuple contains the song name or \'commercial_break\' and its duration in minutes. Returns: float: Total duration of the playlist in minutes. total_duration = 0.0 for _, duration in playlist: total_duration += duration return total_duration"},{"question":"# Coding Question Create a simple library management system to keep track of issued and available books. Implement the following three functions: **Function 1: `add_book`** ```python def add_book(library: dict, book_title: str) -> dict: Adds a book to the library dictionary. If the book is already in the library, increment its count by 1. Otherwise, add the book to the library with a count of 1. Arguments: library -- dict: represents the library inventory with book titles as keys and their counts as values. book_title -- str: title of the book to be added. Returns: Updated library dictionary. Examples: >>> add_book({\\"Harry Potter\\": 2, \\"The Hobbit\\": 1}, \\"Harry Potter\\") {\'Harry Potter\': 3, \'The Hobbit\': 1} >>> add_book({\\"Harry Potter\\": 2, \\"The Hobbit\\": 1}, \\"To Kill a Mockingbird\\") {\'Harry Potter\': 2, \'The Hobbit\': 1, \'To Kill a Mockingbird\': 1} pass # your code here ``` **Function 2: `issue_book`** ```python def issue_book(library: dict, book_title: str) -> dict: Issues a book from the library. If the book is available (count > 0), decrement its count by 1. If the book is not available, raise an Exception. Arguments: library -- dict: represents the library inventory with book titles as keys and their counts as values. book_title -- str: title of the book to be issued. Returns: Updated library dictionary. Raises: Exception: if the book is not available in the library. Examples: >>> issue_book({\\"Harry Potter\\": 2, \\"The Hobbit\\": 1}, \\"Harry Potter\\") {\'Harry Potter\': 1, \'The Hobbit\': 1} >>> issue_book({\\"Harry Potter\\": 1, \\"The Hobbit\\": 1}, \\"Harry Potter\\") {\'Harry Potter\': 0, \'The Hobbit\': 1} >>> issue_book({\\"Harry Potter\\": 0, \\"The Hobbit\\": 1}, \\"Harry Potter\\") Traceback (most recent call last): ... Exception: Harry Potter is not available in the library. pass # your code here ``` **Function 3: `check_availability`** ```python def check_availability(library: dict, book_title: str) -> str: Checks if a book is available in the library. If the book is available (count > 0), return \\"Available\\". Otherwise, return \\"Not Available\\". Arguments: library -- dict: represents the library inventory with book titles as keys and their counts as values. book_title -- str: title of the book to be checked. Returns: Availability status as a string: \\"Available\\" or \\"Not Available\\". Examples: >>> check_availability({\\"Harry Potter\\": 2, \\"The Hobbit\\": 1}, \\"Harry Potter\\") \'Available\' >>> check_availability({\\"Harry Potter\\": 0, \\"The Hobbit\\": 1}, \\"Harry Potter\\") \'Not Available\' >>> check_availability({\\"Harry Potter\\": 2, \\"The Hobbit\\": 1}, \\"To Kill a Mockingbird\\") \'Not Available\' pass # your code here ``` # Constraints * Book titles are case-sensitive. * Don\'t consider edge cases of invalid input types (e.g., non-string book titles or non-integer counts). # Scenario: You are managing a library where you need to frequently add new books, issue books to readers, and check the availability of books for students. **Sample Usage:** ```python library = {} # Adding books to the library library = add_book(library, \\"Harry Potter\\") library = add_book(library, \\"The Hobbit\\") # Issuing a book try: library = issue_book(library, \\"Harry Potter\\") except Exception as e: print(e) # Checking availability print(check_availability(library, \\"Harry Potter\\")) # Output: \'Available\' print(check_availability(library, \\"The Great Gatsby\\")) # Output: \'Not Available\' ```","solution":"def add_book(library: dict, book_title: str) -> dict: Adds a book to the library dictionary. If the book is already in the library, increment its count by 1. Otherwise, add the book to the library with a count of 1. if book_title in library: library[book_title] += 1 else: library[book_title] = 1 return library def issue_book(library: dict, book_title: str) -> dict: Issues a book from the library. If the book is available (count > 0), decrement its count by 1. If the book is not available, raise an Exception. if book_title in library and library[book_title] > 0: library[book_title] -= 1 else: raise Exception(f\\"{book_title} is not available in the library.\\") return library def check_availability(library: dict, book_title: str) -> str: Checks if a book is available in the library. If the book is available (count > 0), return \\"Available\\". Otherwise, return \\"Not Available\\". if book_title in library and library[book_title] > 0: return \\"Available\\" else: return \\"Not Available\\""},{"question":"# Coding Assessment Question **Scenario**: You are creating a scheduling system for a series of events, where each event has a start and end time. The system must support efficiently determining the largest number of overlapping events at any given time. You decide to use a data structure that will help you find this information quickly. **Task**: Implement a class-based solution to handle a dynamic list of events and efficiently calculate the maximum number of overlapping events. **Requirements**: 1. **Initialization**: - Provide a class `EventScheduler` that initializes an empty list of events. 2. **Add Event**: - Implement an `add_event` method to add a new event with a start and end time. 3. **Max Overlap Query**: - Implement a `max_overlap` method to return the maximum number of overlapping events at any point in time. # Function Details - **Class**: `EventScheduler` - **Constructor**: - `__init__(self) -> None` - Initializes the scheduler with an empty list of events. - **Methods**: - `add_event(self, start: int, end: int) -> None` - Adds a new event with a `start` and `end` time. - `max_overlap(self) -> int` - Returns the maximum number of overlapping events at any point in time. **Constraints**: - Number of events `N` where `1 <= N <= 10^5`. - Start and end times for events within `0` to `10^9`. - Start time will always be less than the end time. # Input Format: - Multiple add event operations followed by a max overlap query operation. - Example: - `add_event(1, 5)` adds an event from time 1 to time 5. - `add_event(2, 6)` adds an event from time 2 to time 6. # Output Format: - For each `max_overlap` operation, output the maximum number of overlapping events. # Example: ```python scheduler = EventScheduler() scheduler.add_event(1, 5) scheduler.add_event(2, 6) scheduler.add_event(3, 7) scheduler.add_event(4, 8) print(scheduler.max_overlap()) # Output: 4 scheduler.add_event(9, 10) print(scheduler.max_overlap()) # Output: 4 ``` # Explanation: In the example above, the maximum number of overlapping events initially is 4 (events from time ranges [1, 5], [2, 6], [3, 7], [4, 8]). Adding another event from time [9, 10] does not change the maximum overlap count, which remains 4.","solution":"class EventScheduler: def __init__(self): self.events = [] def add_event(self, start: int, end: int) -> None: self.events.append((start, end)) def max_overlap(self) -> int: times = [] for start, end in self.events: times.append((start, 1)) times.append((end, -1)) # Sort by time, and in case of tie, -1 should come before 1 times.sort(key=lambda x: (x[0], x[1])) max_overlap = 0 current_overlap = 0 for _, change in times: current_overlap += change if current_overlap > max_overlap: max_overlap = current_overlap return max_overlap"},{"question":"# Problem Statement: JSON Formatter You are working on a project that involves handling many JSON data objects. These JSON objects are often minified to reduce bandwidth usage, but sometimes, for debugging purposes, you need to pretty-print them in a more human-readable format. Your task is to implement two functions, `format_json` and `minify_json`, that will format and minify JSON strings, respectively. # Function 1: format_json **Input:** - `json_string: str` - A string representing a minified or compact JSON object. **Output:** - `formatted_json: str` - A prettified string representation of the input JSON, with indentation for readability. # Function 2: minify_json **Input:** - `json_string: str` - A string representing a pretty-printed or formatted JSON object. **Output:** - `minified_json: str` - A minified string representation of the input JSON, removing all unnecessary whitespace. # Constraints: 1. The input to both functions must be a valid JSON string. 2. The functions must handle nested JSON objects and arrays appropriately. # Example: ```python def format_json(json_string: str) -> str: # Your implementation here pass def minify_json(json_string: str) -> str: # Your implementation here pass # Test cases: # Format JSON assert format_json(\'{\\"name\\":\\"John\\",\\"age\\":30,\\"city\\":\\"New York\\"}\') == \'\'\'{ \\"name\\": \\"John\\", \\"age\\": 30, \\"city\\": \\"New York\\" }\'\'\' assert format_json(\'{\\"employees\\":[{\\"firstName\\":\\"John\\",\\"lastName\\":\\"Doe\\"},{\\"firstName\\":\\"Anna\\",\\"lastName\\":\\"Smith\\"},{\\"firstName\\":\\"Peter\\",\\"lastName\\":\\"Jones\\"}]}\') == \'\'\'{ \\"employees\\": [ { \\"firstName\\": \\"John\\", \\"lastName\\": \\"Doe\\" }, { \\"firstName\\": \\"Anna\\", \\"lastName\\": \\"Smith\\" }, { \\"firstName\\": \\"Peter\\", \\"lastName\\": \\"Jones\\" } ] }\'\'\' # Minify JSON assert minify_json(\'\'\'{ \\"name\\": \\"John\\", \\"age\\": 30, \\"city\\": \\"New York\\" }\'\'\') == \'{\\"name\\":\\"John\\",\\"age\\":30,\\"city\\":\\"New York\\"}\' assert minify_json(\'\'\'{ \\"employees\\": [ { \\"firstName\\": \\"John\\", \\"lastName\\": \\"Doe\\" }, { \\"firstName\\": \\"Anna\\", \\"lastName\\": \\"Smith\\" }, { \\"firstName\\": \\"Peter\\", \\"lastName\\": \\"Jones\\" } ] }\'\'\') == \'{\\"employees\\":[{\\"firstName\\":\\"John\\",\\"lastName\\":\\"Doe\\"},{\\"firstName\\":\\"Anna\\",\\"lastName\\":\\"Smith\\"},{\\"firstName\\":\\"Peter\\",\\"lastName\\":\\"Jones\\"}]}\' ``` Your solution should be efficient, handling large JSON objects gracefully, and must include proper error handling for invalid JSON strings. **Good Luck!**","solution":"import json def format_json(json_string: str) -> str: Takes a minified or compact JSON string and returns a prettified string representation with indentation for readability. try: json_data = json.loads(json_string) formatted_json = json.dumps(json_data, indent=4) return formatted_json except json.JSONDecodeError: raise ValueError(\\"Invalid JSON string\\") def minify_json(json_string: str) -> str: Takes a pretty-printed or formatted JSON string and returns a minified string representation by removing all unnecessary whitespace. try: json_data = json.loads(json_string) minified_json = json.dumps(json_data, separators=(\',\', \':\')) return minified_json except json.JSONDecodeError: raise ValueError(\\"Invalid JSON string\\")"},{"question":"# Coding Assessment Question Context You have been tasked with developing a module to handle simple mathematical functions. This particular task involves computing the Least Common Multiple (LCM) of two integers. The LCM of two integers is the smallest positive integer that is perfectly divisible by both integers. Problem Statement **Task**: Implement a `least_common_multiple` function in Python that calculates the LCM of two given integers using the greatest common divisor (GCD) method. * **Function Specifications**: - **Function**: `least_common_multiple` - **Input**: Two integers (`a`, `b`) which can be both positive and negative. - **Output**: A single integer representing the LCM of `a` and `b`. The result should always be a non-negative integer. * **Constraints**: - The inputs can be zero, positive, or negative integers. - Ensure that the function handles zero as input correctly. - Negative integers should result in a positive LCM. * **Performance Requirements**: - The solution should efficiently compute the LCM using the GCD-based method. Example Usage ```python def least_common_multiple(a: int, b: int) -> int: >>> least_common_multiple(4, 5) 20 >>> least_common_multiple(0, 5) 0 >>> least_common_multiple(-4, 5) 20 >>> least_common_multiple(7, -3) 21 >>> least_common_multiple(-6, -8) 24 # Function implementation from math import gcd def least_common_multiple(a: int, b: int) -> int: if a == 0 or b == 0: return 0 return abs(a * b) // gcd(a, b) # Your program should be able to execute the following if __name__ == \\"__main__\\": import doctest doctest.testmod() print(least_common_multiple(4, 5)) print(least_common_multiple(0, 5)) print(least_common_multiple(-4, 5)) print(least_common_multiple(7, -3)) print(least_common_multiple(-6, -8)) ``` **Note**: Ensure your solution passes the provided doctest cases without modifications and adheres to the constraints and specifications listed.","solution":"from math import gcd def least_common_multiple(a: int, b: int) -> int: Calculate the least common multiple (LCM) of two integers using the greatest common divisor (GCD) method. Parameters: a (int): The first integer. b (int): The second integer. Returns: int: The LCM of a and b. Always a non-negative integer. Examples: >>> least_common_multiple(4, 5) 20 >>> least_common_multiple(0, 5) 0 >>> least_common_multiple(-4, 5) 20 >>> least_common_multiple(7, -3) 21 >>> least_common_multiple(-6, -8) 24 if a == 0 or b == 0: return 0 return abs(a * b) // gcd(a, b)"},{"question":"# Scenario You are given a string containing only lowercase letters and you need to calculate the frequency of each letter in the string. Your task is to find the letter that occurs the most frequently. If there are multiple letters with the same highest frequency, return the lexicographically smallest one. # Problem Statement Write a function `most_frequent_letter` that takes a single string input and returns the most frequent lowercase letter in that string. In case of tie in frequency, return the letter which comes first lexicographically. # Input Format A single string `s` (1 <= len(s) <= 10^5) containing only lowercase alphabetical characters. # Output Format A single character representing the most frequent letter in the input string. # Constraints * The string contains only lowercase alphabetical characters. # Function Signature ```python def most_frequent_letter(s: str) -> str: # implementation here ``` # Examples Example 1 **Input**: ```python \\"apple\\" ``` **Output**: ```python \\"p\\" ``` **Explanation**: \'p\' occurs 2 times, which is more than \'a\', \'l\', and \'e\' each occurring 1 time. Example 2 **Input**: ```python \\"banana\\" ``` **Output**: ```python \\"a\\" ``` **Explanation**: \'a\' and \'n\' both occur 2 times, but \'a\' is lexicographically smaller than \'n\'. # Implementation Notes * Utilize a data structure (like a dictionary) to store the frequency of each letter. * Traverse through the dictionary to find the letter with the highest frequency. In case of ties, maintain a way to find the lexicographically smallest letter efficiently.","solution":"def most_frequent_letter(s: str) -> str: from collections import Counter # Count the frequency of each letter freq = Counter(s) # Initialize variables to track the max frequency and corresponding letter max_freq = 0 most_freq_letter = \'\' # Iterate through the Counter dict to find the most frequent letter for letter in freq: if freq[letter] > max_freq or (freq[letter] == max_freq and letter < most_freq_letter): max_freq = freq[letter] most_freq_letter = letter return most_freq_letter"},{"question":"Sure, here is an additional question following the guidelines provided: --- # Coding Assessment Question **Title**: Develop a Sentiment Analysis Classifier using NLP Techniques **Task**: Using the provided text data and Natural Language Processing (NLP) methods, construct a function to preprocess the dataset, train a sentiment analysis classifier, and evaluate its performance using classification metrics like accuracy, precision, recall, and F1-score. **Background**: Given a dataset of movie reviews labeled as positive or negative, you need to create a text classification model to predict the sentiment of the reviews. You are provided with code snippets for preprocessing text data, creating a classifier, and a function to display evaluation metrics. Your task is to integrate these processes and ensure a robust NLP pipeline. **Function Specification**: **Function Name**: `evaluate_sentiment_classifier` **Input**: - `reviews` (list): A list of strings where each string is a movie review. - `labels` (list): A list of integers where each integer is either 0 (negative) or 1 (positive) corresponding to the sentiment of each review. - `test_size` (float): A float between 0 and 1 representing the proportion of the dataset to include in the test split. **Output**: - Prints evaluation metrics (accuracy, precision, recall, F1-score) for the sentiment classifier. **Constraints**: - Ensure the test_size is between 0.1 and 0.3 to avoid inappropriate splits. - Handle missing or invalid data gracefully. - Ensure text preprocessing doesn\'t lead to data leakage. **Requirements**: - Implement a function to preprocess the text data (e.g., tokenization, removing stop words). - Train a sentiment classifier using the training data. - Evaluate the classifier using classification metrics like accuracy, precision, recall, and F1-score. **Example**: Assume `reviews_data` is a list of reviews and `reviews_labels` is a list of corresponding labels. ```python reviews_data = [\\"Great movie, loved it!\\", \\"Terrible film, wasted time.\\", \\"It was just okay.\\"] reviews_labels = [1, 0, 1] evaluate_sentiment_classifier(reviews_data, reviews_labels, 0.2) ``` Expected Output: - Classification metrics displayed for the model on the test split. **Skeleton Code**: ```python import numpy as np from sklearn.feature_extraction.text import CountVectorizer from sklearn.metrics import classification_report from sklearn.model_selection import train_test_split from sklearn.naive_bayes import MultinomialNB from sklearn.pipeline import make_pipeline # Provided function def preprocess_text(data: list) -> np.ndarray: vectorizer = CountVectorizer(stop_words=\'english\') transformed_data = vectorizer.fit_transform(data) return transformed_data # Provided function def train_classifier(features: np.ndarray, target: np.ndarray) -> MultinomialNB: classifier = MultinomialNB() classifier.fit(features, target) return classifier # Implement the required function def evaluate_sentiment_classifier(reviews: list, labels: list, test_size: float) -> None: # Ensure valid test_size assert 0.1 <= test_size <= 0.3, \\"Test size should be between 0.1 and 0.3\\" # Preprocess the reviews features = preprocess_text(reviews) # Split the dataset x_train, x_test, y_train, y_test = train_test_split(features, labels, test_size=test_size) # Train sentiment classifier classifier = train_classifier(x_train, y_train) # Evaluate the classifier predictions = classifier.predict(x_test) report = classification_report(y_test, predictions, target_names=[\\"Negative\\", \\"Positive\\"]) # Print the classification report print(report) # Example usage if __name__ == \\"__main__\\": reviews_data = [\\"Great movie, loved it!\\", \\"Terrible film, wasted time.\\", \\"It was just okay.\\"] reviews_labels = [1, 0, 1] evaluate_sentiment_classifier(reviews_data, reviews_labels, 0.2) ``` ---","solution":"import numpy as np from sklearn.feature_extraction.text import CountVectorizer from sklearn.metrics import classification_report, accuracy_score, precision_score, recall_score, f1_score from sklearn.model_selection import train_test_split from sklearn.naive_bayes import MultinomialNB from sklearn.pipeline import make_pipeline def preprocess_text(data: list) -> np.ndarray: vectorizer = CountVectorizer(stop_words=\'english\') transformed_data = vectorizer.fit_transform(data) return transformed_data def train_classifier(features: np.ndarray, target: np.ndarray) -> MultinomialNB: classifier = MultinomialNB() classifier.fit(features, target) return classifier def evaluate_sentiment_classifier(reviews: list, labels: list, test_size: float) -> None: # Ensure valid test_size assert 0.1 <= test_size <= 0.3, \\"Test size should be between 0.1 and 0.3\\" # Handle missing or invalid data if not reviews or not labels or len(reviews) != len(labels): print(\\"Invalid input data.\\") return # Preprocess the reviews features = preprocess_text(reviews) # Split the dataset x_train, x_test, y_train, y_test = train_test_split(features, labels, test_size=test_size, random_state=42) # Train sentiment classifier classifier = train_classifier(x_train, y_train) # Evaluate the classifier predictions = classifier.predict(x_test) # Calculate metrics accuracy = accuracy_score(y_test, predictions) precision = precision_score(y_test, predictions) recall = recall_score(y_test, predictions) f1 = f1_score(y_test, predictions) # Print the classification report report = classification_report(y_test, predictions, target_names=[\\"Negative\\", \\"Positive\\"]) print(report) # Print individual metrics print(f\\"Accuracy: {accuracy:.2f}\\") print(f\\"Precision: {precision:.2f}\\") print(f\\"Recall: {recall:.2f}\\") print(f\\"F1 Score: {f1:.2f}\\") # Example usage if __name__ == \\"__main__\\": reviews_data = [\\"Great movie, loved it!\\", \\"Terrible film, wasted time.\\", \\"It was just okay.\\"] reviews_labels = [1, 0, 1] evaluate_sentiment_classifier(reviews_data, reviews_labels, 0.2)"},{"question":"Problem Statement Alice is organizing a game competition and needs help to determine the winners. The competition consists of several rounds, and in each round, participants compete to achieve a target score. The scores of participants are given in a list, and the target score is a single integer. A participant is considered a winner if their score is exactly equal to the target score. You are tasked with writing a function that determines the total number of winners in the competition. # Task Write a function `count_winners` that takes a list of integers representing the participants\' scores and a single integer representing the target score. The function should return the total number of participants whose score exactly matches the target score. # Input Format - A list of integers `scores` where each integer represents a participant\'s score. - A single integer `target` representing the target score. # Output Format - A single integer representing the count of participants who achieved the target score. # Constraints - 1 <= len(scores) <= 10^6 - 0 <= scores[i] <= 10^6 - 0 <= target <= 10^6 # Function Signature ```python def count_winners(scores: list, target: int) -> int: pass ``` # Example Input ```python scores = [100, 200, 150, 100, 250, 300, 100] target = 100 ``` Output ```python 3 ``` Explanation In this example, there are 3 participants who exactly achieved the target score of 100. --- Input ```python scores = [99, 98, 100, 102, 101] target = 100 ``` Output ```python 1 ``` Explanation In this example, only 1 participant achieved the target score of 100.","solution":"def count_winners(scores: list, target: int) -> int: Returns the number of participants whose score matches the target score. :param scores: List of integers representing the participants\' scores :param target: Integer representing the target score :return: Integer representing the count of participants who achieved the target score return scores.count(target)"},{"question":"# Scenario A popular online marketplace wants to evaluate the performance of its sellers based on the ratings provided by buyers. For this purpose, they require a function that calculates the average rating of each seller and identifies the top seller based on these ratings. # Task You need to implement a function called `top_seller` that computes the average rating for each seller and returns the seller with the highest average rating. In case of a tie, return the seller who received the highest number of ratings. If still tied, return any one of them. # Function Signature ```python def top_seller( ratings: List[Tuple[str, int]] ) -> str: ``` # Input 1. `ratings` (List[Tuple[str, int]]): A list of tuples where each tuple contains the seller\'s name as a string and their rating as an integer (from 1 to 5). # Output The function should return the name of the seller with the highest average rating as a string. # Constraints * Each rating (int) is between 1 and 5, inclusive. * The list `ratings` contains at least one rating. # Example ```python >>> ratings = [(\\"Alice\\", 5), (\\"Bob\\", 3), (\\"Alice\\", 4), (\\"Bob\\", 5), (\\"Alice\\", 3)] >>> top_seller(ratings) \'Alice\' >>> ratings = [(\\"Alice\\", 5), (\\"Bob\\", 5), (\\"Alice\\", 4), (\\"Bob\\", 5), (\\"Alice\\", 3), (\\"Bob\\", 4), (\\"Bob\\", 3)] >>> top_seller(ratings) \'Bob\' >>> ratings = [(\\"Alice\\", 3), (\\"Bob\\", 3), (\\"Charlie\\", 4), (\\"Charlie\\", 4), (\\"Charlie\\", 4)] >>> top_seller(ratings) \'Charlie\' ``` # Important Note Ensure your function correctly calculates the average rating and handles ties by choosing the seller with the most ratings. If the number of ratings is also tied, returning any one of the tied sellers is acceptable.","solution":"from typing import List, Tuple from collections import defaultdict def top_seller(ratings: List[Tuple[str, int]]) -> str: seller_ratings = defaultdict(list) # Collect all ratings for each seller for seller, rating in ratings: seller_ratings[seller].append(rating) top_seller = None top_average = 0 most_ratings = 0 for seller, ratings_list in seller_ratings.items(): average_rating = sum(ratings_list) / len(ratings_list) num_ratings = len(ratings_list) if (average_rating > top_average) or (average_rating == top_average and num_ratings > most_ratings): top_seller = seller top_average = average_rating most_ratings = num_ratings return top_seller"},{"question":"Problem: Image Pixel Manipulation In computer graphics and image processing, manipulating image pixels is a common task. In this problem, you are required to adjust the brightness of an image by modifying the RGB values of its pixels. # Input 1. An integer **M** (1 <= M <= 1000) representing the number of rows in the image. 2. An integer **N** (1 <= N <= 1000) representing the number of columns in the image. 3. A list of M lists, with each inner list containing N tuples representing the RGB values of the image pixels. Each tuple contains three integers (R, G, B) each in the range of 0 to 255. 4. An integer **K** (-255 <= K <= 255) representing the brightness adjustment value. Positive values increase brightness while negative values decrease it. # Output 1. A list of M lists each containing N tuples representing the new RGB values of the image pixels after applying the brightness adjustment. Ensure the RGB values are clamped within the range of 0 to 255. # Function Signature ```python def adjust_brightness(image: List[List[Tuple[int, int, int]]], k: int) -> List[List[Tuple[int, int, int]]]: pass ``` # Constraints - All RGB values must be in the inclusive range [0, 255] after adjustment. - Ensure the dimensions and format of the output image remain the same as the input image. - Handle cases where increasing brightness might exceed 255 or decreasing might go below 0 by clamping the values within the valid range. # Examples Example 1: ```python image = [ [(10, 20, 30), (40, 50, 60)], [(70, 80, 90), (100, 110, 120)] ] k = 20 print(adjust_brightness(image, k)) # Output: [[(30, 40, 50), (60, 70, 80)], [(90, 100, 110), (120, 130, 140)]] ``` Example 2: ```python image = [ [(200, 210, 220), (230, 240, 250)], [(100, 110, 120), (130, 140, 150)] ] k = -50 print(adjust_brightness(image, k)) # Output: [[(150, 160, 170), (180, 190, 200)], [(50, 60, 70), (80, 90, 100)]] ``` # Notes 1. Each pixel can be adjusted independently of others. 2. If the adjustment results in values that go outside the range [0, 255], clamp them to the nearest boundary (0 or 255). For instance, an RGB value (260) should be clamped to 255, and a value (-10) should be clamped to 0. # Hints - Iterate through each pixel in the image and adjust its RGB values. - Use min and max functions to handle the clamping within the required range.","solution":"from typing import List, Tuple def clamp(value: int) -> int: Clamp the value to be within the range of 0 to 255. return max(0, min(255, value)) def adjust_brightness(image: List[List[Tuple[int, int, int]]], k: int) -> List[List[Tuple[int, int, int]]]: result = [] for row in image: new_row = [] for r, g, b in row: new_r = clamp(r + k) new_g = clamp(g + k) new_b = clamp(b + k) new_row.append((new_r, new_g, new_b)) result.append(new_row) return result"},{"question":"# Fraction to Recurring Decimal You are given two integers, `numerator` and `denominator`. Write a function `fraction_to_decimal(numerator: int, denominator: int) -> str` that converts the fraction represented by these integers to its decimal form as a string. If the fractional part is repeating, enclose the repeating part in parentheses. Input Format The function receives two integers `numerator` and `denominator`. Output Format A single string representing the decimal form of the fraction. If the fraction is repeating, the repeating part should be enclosed in parentheses. Constraints * The numerator can be any integer. * The denominator is a non-zero integer. * It is guaranteed that the inputs will produce an output that fits within the range of a standard floating-point number. Example ```python 1. fraction_to_decimal(1, 2) Output: \\"0.5\\" Explanation: 1/2 = 0.5, which is a finite decimal. 2. fraction_to_decimal(2, 3) Output: \\"0.(6)\\" Explanation: 2/3 = 0.66666..., which has a repeating part \\"6\\". 3. fraction_to_decimal(4, 333) Output: \\"0.(012)\\" Explanation: 4/333 = 0.012012012..., which has a repeating part \\"012\\". 4. fraction_to_decimal(-50, 8) Output: \\"-6.25\\" Explanation: -50/8 = -6.25, which is a finite decimal. ``` Performance Requirements * The solution should aim for O(k) time complexity, where k is the number of digits in the decimal representation (including any repeating part). * Use O(k) additional space to store the decimal representation.","solution":"def fraction_to_decimal(numerator: int, denominator: int) -> str: if numerator % denominator == 0: return str(numerator // denominator) res = [] # handle negative numbers if (numerator < 0) ^ (denominator < 0): res.append(\'-\') # Integer part numerator = abs(numerator) denominator = abs(denominator) res.append(str(numerator // denominator)) res.append(\'.\') # Fraction part numerator %= denominator index_map = {} fraction_part = [] while numerator != 0: if numerator in index_map: fraction_part.insert(index_map[numerator], \'(\') fraction_part.append(\')\') break index_map[numerator] = len(fraction_part) numerator *= 10 fraction_part.append(str(numerator // denominator)) numerator %= denominator res.extend(fraction_part) return \'\'.join(res)"},{"question":"Problem Statement You are given a directed graph represented as an adjacency list, where each node has a fixed amount of treasure. Your task is to determine the maximum amount of treasure you can collect if you start from a given node and can only move to its directly connected neighbors. The traversal must stop when there are no more nodes that can be visited or when all reachable nodes have been visited. # Function Signature ```python def max_treasure(graph: dict[int, list[int]], treasures: dict[int, int], start: int) -> int: Calculates the maximum amount of treasure that can be collected starting from the given node and traversing through the graph. Args: graph (dict[int, list[int]]): A dictionary where keys are node names and values are lists of nodes that are reachable directly from the key node. treasures (dict[int, int]): A dictionary where keys are node names and values are the amount of treasures at each node. start (int): The node to start the traversal from. Returns: int: The maximum treasure that can be collected. pass ``` # Example Usage ```python graph = { 1: [2, 3], 2: [3], 3: [4], 4: [1, 5], 5: [] } treasures = { 1: 5, 2: 10, 3: 15, 4: 10, 5: 5 } assert max_treasure(graph, treasures, 1) == 45 # 5 + 10 + 15 + 10 + 5 graph = { 1: [2], 2: [], 3: [4], 4: [] } treasures = { 1: 5, 2: 10, 3: 15, 4: 10 } assert max_treasure(graph, treasures, 1) == 15 # 5 + 10 assert max_treasure(graph, treasures, 3) == 25 # 15 + 10 graph_disconnected = { 1: [], 2: [3], 3: [2] } treasures_disconnected = { 1: 4, 2: 1, 3: 8 } assert max_treasure(graph_disconnected, treasures_disconnected, 1) == 4 assert max_treasure(graph_disconnected, treasures_disconnected, 2) == 9 # 1 + 8 ``` # Constraints * The graph is directed. * Each node is connected to 0 or more other nodes. * Nodes and treasures are represented through unique integer identifiers. * Starting node is guaranteed to be part of the graph. * Treasures at each node are non-negative integers. # Additional Information Consider edge cases such as: * When the start node has no connections. * When the graph is disconnected. * When nodes form cycles. * When there is only one node in the graph with treasure. Implement the function `max_treasure` that returns the correct maximum amount of treasure collected starting from the specified node.","solution":"def max_treasure(graph, treasures, start): def dfs(node, visited): if node in visited: return 0 visited.add(node) total_treasure = treasures[node] for neighbor in graph[node]: total_treasure += dfs(neighbor, visited) return total_treasure visited = set() return dfs(start, visited)"},{"question":"# Problem Statement Given a list of integers, your task is to write a function that filters out all elements that are prime numbers and returns a new list with the remaining integers. You should also write a separate function that returns the sum of all the prime numbers that were filtered out. # Constraints 1. The input list will contain at least one integer. 2. You need to handle lists containing up to 20,000 integers within a reasonable time limit. 3. The integers will be non-negative. # Function Signature ```python def is_prime(n: int) -> bool: pass def filter_non_primes(numbers: list) -> list: pass def sum_of_primes(numbers: list) -> int: pass ``` # Input * A list `numbers` containing non-negative integers. # Output * A list of non-prime integers. * An integer indicating the sum of all the filtered prime numbers. # Example ```python numbers = [2, 4, 6, 8, 11, 13, 17, 19, 20, 22, 23] # Example usage of the provided functions non_primes_list = filter_non_primes(numbers) print(non_primes_list) sum_primes = sum_of_primes(numbers) print(sum_primes) ``` # Expected Output ```plaintext [4, 6, 8, 20, 22] 85 ``` # Explanation 1. Implement the `is_prime` function to check if a given integer is prime. 2. Implement the `filter_non_primes` function to filter out primes and return the list of non-prime integers. 3. Implement the `sum_of_primes` function to compute and return the sum of the prime numbers that were filtered out. # Notes - Ensure your solution efficiently checks for prime numbers. - Consider optimizing for both time and space complexity while keeping the code clean and readable. - The `filter_non_primes` function should not modify the original list but return a new list.","solution":"def is_prime(n: int) -> bool: Check if a number is prime. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def filter_non_primes(numbers: list) -> list: Filters out all prime numbers from the input list and returns a new list with the remaining integers. return [num for num in numbers if not is_prime(num)] def sum_of_primes(numbers: list) -> int: Returns the sum of all the prime numbers that were filtered out. return sum(num for num in numbers if is_prime(num))"},{"question":"# Dijkstra\'s Algorithm for Weighted Shortest Path Implement a modified version of Dijkstra\'s algorithm that can handle a grid where each cell has a different traversal cost. The objective is to find the path with the minimum total cost from a start position to an end position. # Problem Given a weighted grid where each cell contains a non-negative number representing the traversal cost through that cell, the task is to determine the shortest path from a start point to an end point such that the total cost is minimized. # Function Signature ```python def dijkstra_shortest_path( grid: list[list[int]], start: list[int], end: list[int] ) -> tuple[list[list[int]], int]: ``` # Input * `grid` (`list[list[int]]`): A 2D list representing the weighted grid where each cell value indicates the traversal cost. * `start` (`list[int]`): The starting position on the grid given as [y, x]. * `end` (`list[int]`): The target position on the grid given as [y, x]. # Output * Returns a tuple containing: * `path` (`list[list[int]]`): The list of coordinates from start to end representing the path with the minimum total cost. * `total_cost` (`int`): The total cost of the optimal path. # Constraints * `0 <= grid[i][j] <= 100` * `0 <= start[i], end[i] < len(grid)` * Assumption: End is always reachable if there are no complete obstacles blocking the way. # Example ```python grid = [ [1, 2, 2], [1, 9, 1], [1, 1, 1], ] start = [0, 0] end = [2, 2] path, total_cost = dijkstra_shortest_path(grid, start, end) print(path, total_cost) ``` # Notes 1. Implement the Dijkstra\'s algorithm to handle the given weighted grid effectively. 2. Ensure the path returned minimizes the total traversal cost from the start to the end position.","solution":"import heapq def dijkstra_shortest_path(grid, start, end): rows, cols = len(grid), len(grid[0]) start_y, start_x = start end_y, end_x = end directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # Min-heap priority queue for Dijkstra\'s algorithm pq = [(grid[start_y][start_x], start_y, start_x)] min_cost = { (start_y, start_x): grid[start_y][start_x] } prev = { (start_y, start_x): None } while pq: cost, y, x = heapq.heappop(pq) if (y, x) == (end_y, end_x): break for dy, dx in directions: ny, nx = y + dy, x + dx if 0 <= ny < rows and 0 <= nx < cols: new_cost = cost + grid[ny][nx] if (ny, nx) not in min_cost or new_cost < min_cost[(ny, nx)]: min_cost[(ny, nx)] = new_cost heapq.heappush(pq, (new_cost, ny, nx)) prev[(ny, nx)] = (y, x) path = [] node = (end_y, end_x) while node: path.append(list(node)) node = prev[node] path = path[::-1] total_cost = min_cost[(end_y, end_x)] return (path, total_cost)"},{"question":"# Problem Statement Objective You are tasked with writing a function in language L that takes a string consisting of digits and returns the next lexicographical permutation of the given string. Motivation This problem helps assess your understanding of string manipulation, permutation generation, and algorithm optimization within the context of a specified programming language. # Requirements 1. **Input**: A single string `s` consisting of digits (`0-9`), where `2 ≤ len(s) ≤ 1000`. 2. **Output**: The next lexicographical permutation of `s` as a string. If no such permutation exists, return the lexicographically smallest permutation of `s`. # Constraints - You must implement the solution in the specified programming language. - The function should handle strings of up to 1000 characters efficiently. - You are not allowed to use libraries that provide direct permutations or sorting functionalities of the string. # Performance - The implementation should run efficiently within the given constraints, considering the potential maximum length of the string. # Specification Example If you were to solve this in Python, a valid function might resemble: ```python def next_permutation(s): s = list(s) # Convert string to a list of characters for manipulation i = len(s) - 2 while i >= 0 and s[i] >= s[i + 1]: i -= 1 if i == -1: return \'\'.join(sorted(s)) j = len(s) - 1 while s[j] <= s[i]: j -= 1 s[i], s[j] = s[j], s[i] s[i + 1:] = reversed(s[i + 1:]) return \'\'.join(s) # Example Usage: print(next_permutation(\\"1234\\")) # Output: \\"1243\\" print(next_permutation(\\"4321\\")) # Output: \\"1234\\" ``` Ensure that your solution abides by the constraints and runs successfully in language L. Notes - Consider the importance of string sorting and manipulation within the constraints provided. - Evaluate the conditions for identifying the next permutation and how the language handles string indexing and conversion.","solution":"def next_permutation(s): Returns the next lexicographical permutation of the given string s. If no such permutation exists, returns the lexicographically smallest permutation of s. # Convert string to a list of characters for easier manipulation s = list(s) # Find the largest index k such that s[k] < s[k + 1] k = len(s) - 2 while k >= 0 and s[k] >= s[k + 1]: k -= 1 # If no such index exists, the string is the highest permutation if k == -1: return \'\'.join(sorted(s)) # Find the largest index l greater than k such that s[k] < s[l] l = len(s) - 1 while s[l] <= s[k]: l -= 1 # Swap the value of s[k] with that of s[l] s[k], s[l] = s[l], s[k] # Reverse the sequence from s[k + 1] to the end s[k + 1:] = reversed(s[k + 1:]) return \'\'.join(s)"},{"question":"# Given Problem You are tasked with implementing a function to determine if a string is a \\"perfect palindrome\\". A string is considered a \\"perfect palindrome\\" if it reads the same forwards and backwards, disregarding spaces, capitalization, and punctuation. # Requirements 1. **Function Name**: is_perfect_palindrome 2. **Arguments**: - `s` (str): The input string. 3. **Output**: Return `True` if the string is a perfect palindrome, and `False` otherwise. 4. **Constraints**: - The input string will have a length between 1 and 10^6. - Punctuation includes characters like \\".\\", \\",\\", \\"!\\", \\"?\\", etc., and should be ignored when determining if the string is a perfect palindrome. # Examples ```python # Checking a simple perfect palindrome is_perfect_palindrome(\'A man a plan a canal Panama\') # Output: True # Checking a non-perfect palindrome is_perfect_palindrome(\'Hello, World!\') # Output: False # Checking a perfect palindrome with punctuation and spaces is_perfect_palindrome(\'No lemon, no melon\') # Output: True # Checking a single character string is_perfect_palindrome(\'a\') # Output: True # Checking a mixed-case perfect palindrome is_perfect_palindrome(\'Able , was I saw eLba\') # Output: True ``` # Implementation Write the function `is_perfect_palindrome` to meet the above requirements. **Function Signature**: ```python def is_perfect_palindrome(s: str) -> bool: pass ``` **Notes**: - Consider using Python\'s string processing capabilities to handle the removal of spaces, punctuation, and normalization of case. - Maintain efficient runtime complexity to handle the upper constraint of the input string length.","solution":"import string def is_perfect_palindrome(s: str) -> bool: Determine if a string is a perfect palindrome. Args: - s (str): The input string. Returns: - bool: True if the string is a perfect palindrome, False otherwise. # Normalize the string: remove punctuation, spaces and convert to lowercase translator = str.maketrans(\'\', \'\', string.punctuation) normalized_str = s.translate(translator).replace(\' \', \'\').lower() # Check if the normalized string is equal to its reverse return normalized_str == normalized_str[::-1]"},{"question":"Zigzag Conversion Problem Statement: Given a string `s` and an integer `numRows`, write a function that converts the string into a zigzag pattern on a given number of rows. The string should be read row-wise from top to bottom. Function Signature: ```python def convert(s: str, numRows: int) -> str: ``` Input: - `s`: A non-empty string of length up to 1000. - `numRows`: An integer. Output: - Returns the converted string that reads in a zigzag manner. Constraints: - The length of the string will always be between 1 and 1000. - `numRows` will always be a positive integer (1 <= numRows <= 1000). Example: ```python >>> convert(\\"PAYPALISHIRING\\", 3) \\"PAHNAPLSIIGYIR\\" >>> convert(\\"PAYPALISHIRING\\", 4) \\"PINALSIGYAHRPI\\" ``` Notes: - The zigzag pattern is created by writing the string vertically down the rows and diagonally up from the bottom row to the top row. - Handle the edge case where `numRows` is 1, in which case the output is the same as the input string. - You may use any data structures you find suitable for building the zigzag pattern. Write a function `convert` that implements this zigzag conversion, ensuring it adheres to the provided guidelines and constraints.","solution":"def convert(s: str, numRows: int) -> str: if numRows == 1 or numRows >= len(s): return s # Create an array of strings for all rows rows = [\'\'] * numRows current_row = 0 direction = -1 # -1 means moving up, 1 means moving down for char in s: rows[current_row] += char # Change direction if at the top or bottom row if current_row == 0 or current_row == numRows - 1: direction *= -1 current_row += direction # Concatenate all the rows to form the final string result = \'\'.join(rows) return result"},{"question":"# Coding Assessment Question Question: K-Sum Subarray You are required to implement the function `k_sum_subarray`. Given an array of integers and an integer `k`, the function should return `True` if there exists a contiguous subarray whose sum equals `k`, and `False` otherwise. Function Signature ```python def k_sum_subarray(arr: list, k: int) -> bool: ``` Input - `arr` (list of int): A list of integers. - `k` (int): An integer representing the desired sum. Output - returns: `True` if there is a contiguous subarray whose sum equals `k`, `False` otherwise. Constraints - The input array can be empty or have up to (10^3) elements. - The elements of the array are integers in the range ([-10^6, 10^6]). Examples ```python assert k_sum_subarray([1, 2, 3, 4, 5], 9) == True # The subarray [2, 3, 4] sums to 9 assert k_sum_subarray([1, 2, 3, 4, 5], 15) == True # The subarray [1, 2, 3, 4, 5] sums to 15 assert k_sum_subarray([-1, -2, 3, 4], 1) == True # The subarray [3, -2] sums to 1 assert k_sum_subarray([1, 2, 3], 7) == False # No subarray sums to 7 assert k_sum_subarray([], 0) == False # An empty array cannot have a subarray that sums to 0 ``` # Scenario Consider you are given a list of daily temperature readings and you want to know if there is any continuous period within which the sum of the temperature changes reaches a specific threshold `k`. This function helps determine the existence of such a period based on the readings provided.","solution":"def k_sum_subarray(arr, k): Function to determine if there exists a contiguous subarray whose sum equals k. current_sum = 0 sum_dict = {0: -1} # Dictionary to store (prefix_sum: index) for i, num in enumerate(arr): current_sum += num if current_sum - k in sum_dict: return True if current_sum not in sum_dict: sum_dict[current_sum] = i return False"},{"question":"# Question: Sum of Multiples of 3 or 5 Below a Given Number Scenario You are tasked with finding the sum of all natural numbers below a certain integer that are multiples of 3 or 5. This can be a common requirement for validating mathematical concepts useful in algorithms and problem-solving. Task Implement a function `sum_of_multiples(limit: int) -> int` that calculates the sum of all natural numbers below the given `limit` that are multiples of either 3 or 5. Input * `limit`: An integer representing the upper limit (exclusive) for checking the multiples of 3 or 5. The range of `limit` is `0 <= limit <= 10^6`. Output * An integer representing the sum of all multiples of 3 or 5 below the given `limit`. Constraints * The function should handle edge cases where the limit is very small or very large. * Avoid unnecessary calculations by iterating only through relevant numbers or using mathematical formulas if appropriate. Performance Requirements * Your solution should aim to operate within O(n) time complexity. Example 1. Input: `10` Output: `23` Explanation: The multiples of 3 or 5 below 10 are 3, 5, 6, and 9. The sum is 3 + 5 + 6 + 9 = 23. 2. Input: `20` Output: `78` Explanation: The multiples of 3 or 5 below 20 are 3, 5, 6, 9, 10, 12, 15, and 18. The sum is 3 + 5 + 6 + 9 + 10 + 12 + 15 + 18 = 78. Edge Cases to Consider * `limit` is 0 * `limit` is 1 or 2 * `limit` is large (e.g., 1,000,000) Additional Challenge Optimize the function to handle very large values of `limit` efficiently without iterating through every number below the given limit directly. ---","solution":"def sum_of_multiples(limit: int) -> int: Calculates the sum of all natural numbers below the given `limit` that are multiples of either 3 or 5. def sum_divisible_by(n: int) -> int: p = (limit - 1) // n return n * p * (p + 1) // 2 sum_3 = sum_divisible_by(3) sum_5 = sum_divisible_by(5) sum_15 = sum_divisible_by(15) return sum_3 + sum_5 - sum_15"},{"question":"# Sorting a Multidimensional List by Specified Column You are tasked with creating a function that processes a multidimensional list (a list of lists) and sorts it based on a specified column index. Your function should handle lists of integers and should allow sorting in both ascending and descending order. Function Signature: ```python def sort_multidimensional_list(data: List[List[int]], col_index: int, ascending: bool = True) -> List[List[int]]: pass ``` Input: * `data` (List[List[int]]): A multidimensional list where each inner list contains the same number of integer elements. * `col_index` (int): The index of the column to sort by. * `ascending` (bool): A boolean to determine the sorting order. If `True`, the list should be sorted in ascending order. If `False`, in descending order. The default is `True`. Output: * List[List[int]]: A sorted multidimensional list based on the specified column index. Constraints: * The input list can be empty. * All inner lists will have the same length. * The column index will be a valid index within the inner lists. Example: ```python >>> sort_multidimensional_list([[3, 4, 2], [1, 6, 8], [7, 2, 5]], 1) [[7, 2, 5], [3, 4, 2], [1, 6, 8]] >>> sort_multidimensional_list([[3, 4, 2], [1, 6, 8], [7, 2, 5]], 1, False) [[1, 6, 8], [3, 4, 2], [7, 2, 5]] >>> sort_multidimensional_list([[6, 5], [3, 8], [1, 4]], 0) [[1, 4], [3, 8], [6, 5]] >>> sort_multidimensional_list([], 0) [] >>> sort_multidimensional_list([[4, 1], [3, 2]], 3) Traceback (most recent call last): ... IndexError: list index out of range ``` Scenario: You are tasked with creating a table that displays student scores in different subjects. To facilitate the analysis, the table needs to be sorted by any of the subject scores. Your function will be integrated into a dashboard where users can select the column (subject) and the order (ascending or descending) for the sorting operation.","solution":"from typing import List def sort_multidimensional_list(data: List[List[int]], col_index: int, ascending: bool = True) -> List[List[int]]: Sorts a multidimensional list based on the specified column index. Args: - data: List of lists containing integer elements. - col_index: The index of the column to sort by. - ascending: Boolean to determine the sorting order. Default is True (ascending). Returns: - A sorted multidimensional list based on the specified column index. try: return sorted(data, key=lambda x: x[col_index], reverse=not ascending) except IndexError: raise IndexError(\\"list index out of range\\")"},{"question":"Prime Factorization with Memoization Write a function `prime_factors(n: int) -> List[int]` that returns the list of prime factors of a given integer `n`. # Function Signature ```python def prime_factors(n: int) -> List[int]: pass ``` # Input - `n` (int): A positive integer (n >= 2) for which you need to find the prime factors. # Output - A list of integers representing the prime factors of `n` in ascending order. # Constraints - Use memoization to store previously computed prime factors for efficiency. - The function should handle both small and large integers efficiently. - Avoid using explicit loops; optimize using generator functions or similar lazy evaluation techniques. # Example ```python print(prime_factors(100)) # Output: [2, 2, 5, 5] print(prime_factors(37)) # Output: [37] ``` # Notes - The order of returned prime factors must be in ascending order (smallest to largest). - Consider edge cases like when `n` is a prime number itself. # Hints 1. Use a helper function to determine the next prime factor. 2. Utilize a dictionary to store the prime factors of already computed numbers to reduce redundant calculations. ```python from typing import List def prime_factors(n: int) -> List[int]: memo = {} def find_factors(x): if x in memo: return memo[x] factor_list = [] d = 2 while d * d <= x: while (x % d) == 0: factor_list.append(d) x //= d d += 1 if x > 1: factor_list.append(x) memo[x] = factor_list return factor_list return find_factors(n) ```","solution":"from typing import List def prime_factors(n: int) -> List[int]: memo = {} def _prime_factors(x): if x in memo: return memo[x] factor_list = [] d = 2 while d * d <= x: while (x % d) == 0: factor_list.append(d) x //= d d += 1 if x > 1: factor_list.append(x) memo[x] = factor_list return factor_list return _prime_factors(n)"},{"question":"# Question: Implement Data Analysis Tool with Pandas You are tasked with implementing a data analysis tool that can load a CSV file, perform specified operations, and return the results. The supported operations are: filtering rows based on a condition, computing summary statistics (mean, median, and mode), and grouping by a column to calculate aggregate statistics. Function: `data_analysis_tool` **Input**: - `filepath`: String representing the path to the CSV file. - `operations`: A dictionary specifying the operations to perform. The dictionary can contain the following keys: - `filter`: A tuple specifying the column name and the condition (e.g., `(\'age\', \'>30\')`). - `summary`: A list of summary statistics to compute (e.g., `[\'mean\', \'median\', \'mode\']`). - `groupby`: A tuple specifying the column to group by and the aggregation to perform on that group (e.g., `(\'gender\', \'mean\')`). **Output**: - A dictionary containing the results of the specified operations. **Requirements**: 1. Load the CSV file into a Pandas DataFrame. 2. If a filter operation is specified, filter the DataFrame based on the condition. 3. If summary statistics are specified, compute and include them in the output. 4. If a group by operation is specified, group the DataFrame and compute the aggregation specified. **Constraints**: - Assume the CSV file has appropriate headers. - Handle common data issues such as missing values gracefully. - Ensure all specified operations are performed sequentially and combine the results. Example Usage A correct implementation should be able to: - Load a CSV file (e.g., `data.csv`) and apply operations such as filtering, summarizing, and grouping. - Return results in a dictionary format containing the outcomes of each specified operation. ```python # Function signature def data_analysis_tool(filepath, operations): # Your implementation goes here ``` **Hints**: - Use Pandas functions such as `read_csv`, `query`, `groupby`, and aggregation functions. - Handle conditions in the filter operation using Pandas query syntax. - For summary statistics, use Pandas methods like `mean`, `median`, and `mode`. - Ensure the results are formatted into a dictionary before returning. Example ```python operations = { \'filter\': (\'age\', \'>30\'), \'summary\': [\'mean\', \'median\', \'mode\'], \'groupby\': (\'gender\', \'mean\') } result = enhanced_data_analysis_tool(\'data.csv\', operations) # Example output: # { # \'filtered\': DataFrame containing rows where age > 30, # \'summary\': {\'mean\': ... , \'median\': ... , \'mode\': ... }, # \'groupby\': DataFrame containing mean values grouped by gender # } ```","solution":"import pandas as pd def data_analysis_tool(filepath, operations): Loads a CSV file, performs specified operations, and returns the results. Args: filepath (str): Path to the CSV file. operations (dict): Dictionary specifying the operations to perform. Returns: dict: Dictionary containing the results of the specified operations. # Load CSV file into a DataFrame df = pd.read_csv(filepath) result = {} # Filter operation if \'filter\' in operations: column, condition = operations[\'filter\'] df = df.query(f\'{column}{condition}\') result[\'filtered\'] = df # Summary statistics if \'summary\' in operations: summary_results = {} if \'mean\' in operations[\'summary\']: summary_results[\'mean\'] = df.mean(numeric_only=True).to_dict() if \'median\' in operations[\'summary\']: summary_results[\'median\'] = df.median(numeric_only=True).to_dict() if \'mode\' in operations[\'summary\']: summary_results[\'mode\'] = df.mode(numeric_only=True).iloc[0].to_dict() result[\'summary\'] = summary_results # Group by operation if \'groupby\' in operations: column, agg_func = operations[\'groupby\'] grouped_df = df.groupby(column).agg(agg_func).reset_index() result[\'groupby\'] = grouped_df return result"},{"question":"# Problem Statement You are assigned to design a function that will determine how many distinct binary strings (sequences of `0`s and `1`s) of length **_n_** are palindromic. A palindromic string is one that reads the same forward and backward. # Function Specifications You need to implement the following function: ```python def count_palindromic_binary_strings(n: int) -> int: Count the number of distinct palindromic binary strings of length \'n\'. Parameters: n (int): The length of the binary strings. Returns: int: The count of distinct palindromic binary strings of length \'n\'. pass ``` # Input The function `count_palindromic_binary_strings` takes a single integer: * **n (1 <= n <= 20)**: Represents the length of the binary strings to be considered. # Output The function should return an integer: * The count of distinct palindromic binary strings of length `n`. # Example Example 1: ```python print(count_palindromic_binary_strings(3)) # Output: 4 ``` Example 2: ```python print(count_palindromic_binary_strings(4)) # Output: 8 ``` # Explanation For Example 1: The palindromic binary strings of length 3 are `000`, `010`, `101`, and `111`—4 in total. For Example 2: The palindromic binary strings of length 4 are `0000`, `0110`, `1001`, `1111`, `1000`, `1110`, `0111`, and `0001`—8 in total. # Constraints - Focus on creating an efficient solution to avoid Time Limit Exceeded (TLE) errors considering the constraint on `n`. - You can use properties of palindromes and binary sequences to derive the solution in an optimal manner. # Commentary This problem tests the understanding of palindrome properties and efficient combinatorial generation of strings while ensuring that you focus on binary sequences.","solution":"def count_palindromic_binary_strings(n): Count the number of distinct palindromic binary strings of length \'n\'. Parameters: n (int): The length of the binary strings. Returns: int: The count of distinct palindromic binary strings of length \'n\'. # If the length is odd, the first half plus one middle character determines # the palindrome. # If the length is even, the first half completely determines the palindrome. half_length = (n + 1) // 2 return 2 ** half_length"},{"question":"# Coding Assessment Question You work as a backend developer at an e-commerce company. One of your tasks is to ensure the inventory system is updated correctly whenever a new shipment of products arrives. Create a function `update_inventory(current_inventory: dict, new_shipment: list) -> dict` to update the inventory given the current stock levels and a new shipment. Your function should meet the following criteria: * **Input/Output Formats**: * **Input**: * `current_inventory` (dict): A dictionary where keys are the product names (strings) and values are the current stock levels (integers), e.g., `{\'apple\': 10, \'banana\': 5}`. * `new_shipment` (list): A list of tuples, where each tuple has two elements: product name (string) and quantity (integer) received in the shipment, e.g., `[(\'apple\', 3), (\'orange\', 7)]`. * **Output**: * (dict): An updated dictionary with the new inventory levels. * **Constraints and Limitations**: * The function should raise exceptions with meaningful messages if the inputs are invalid: * If `current_inventory` is not a dictionary, raise Exception with the message \\"Current inventory must be a dictionary\\". * If `new_shipment` is not a list, raise Exception with the message \\"New shipment must be a list\\". * If any quantity in `new_shipment` is less than 0, raise Exception with the message \\"Shipment quantities must be >= 0\\". * If any stock level in `current_inventory` is less than 0, raise Exception with the message \\"Stock levels must be >= 0\\". * **Performance Requirements**: * Ensure that the function runs efficiently with a time complexity of O(n) and a space complexity of O(n), where n is the number of products in the new shipment. * **Example**: ```python def update_inventory(current_inventory: dict, new_shipment: list) -> dict: # your implementation here # Test Cases print(update_inventory({\'apple\': 10, \'banana\': 5}, [(\'apple\', 3), (\'orange\', 7)])) # Expected output: {\'apple\': 13, \'banana\': 5, \'orange\': 7} print(update_inventory({\'apple\': 0, \'banana\': 2}, [(\'banana\', 3), (\'apple\', 8)])) # Expected output: {\'apple\': 8, \'banana\': 5} try: update_inventory(123, [(\'apple\', 3), (\'orange\', 7)]) # Expected output: Exception(\\"Current inventory must be a dictionary\\") except Exception as e: print(e) try: update_inventory({\'apple\': 10, \'banana\': 5}, \'invalid\') # Expected output: Exception(\\"New shipment must be a list\\") except Exception as e: print(e) try: update_inventory({\'apple\': 10, \'banana\': -1}, [(\'apple\', 3), (\'orange\', 7)]) # Expected output: Exception(\\"Stock levels must be >= 0\\") except Exception as e: print(e) ```","solution":"def update_inventory(current_inventory: dict, new_shipment: list) -> dict: Update the current inventory with the quantities from a new shipment. :param current_inventory: Dictionary with current stock levels. :param new_shipment: List of tuples with product name and quantity received. :return: Updated dictionary with new inventory levels. # Validate inputs if not isinstance(current_inventory, dict): raise Exception(\\"Current inventory must be a dictionary\\") if not isinstance(new_shipment, list): raise Exception(\\"New shipment must be a list\\") for product, quantity in new_shipment: if not isinstance(quantity, int) or quantity < 0: raise Exception(\\"Shipment quantities must be >= 0\\") for product, stock in current_inventory.items(): if not isinstance(stock, int) or stock < 0: raise Exception(\\"Stock levels must be >= 0\\") # Update inventory for product, quantity in new_shipment: if product in current_inventory: current_inventory[product] += quantity else: current_inventory[product] = quantity return current_inventory"},{"question":"# Number Spiral Diagonals In mathematics, there is a construct known as a number spiral. It starts at 1 in the center and spirals outwards in a clockwise direction. Here\'s an example of such a spiral of size 5x5: ``` 21 22 23 24 25 20 7 8 9 10 19 6 1 2 11 18 5 4 3 12 17 16 15 14 13 ``` You are to write a function `number_spiral_diagonal_sum` that takes an integer `n` and returns the sum of the diagonals in an n x n spiral. Note that `n` is always odd. # Function Signature ```python def number_spiral_diagonal_sum(n: int) -> int: pass ``` # Input * `n`: An odd integer representing the size of the spiral. # Output * Returns an integer representing the sum of the diagonals in the spiral. # Constraints * 1 ≤ n ≤ 1001 * `n` will always be an odd integer. # Example ```python >>> number_spiral_diagonal_sum(1) 1 >>> number_spiral_diagonal_sum(3) 25 >>> number_spiral_diagonal_sum(5) 101 >>> number_spiral_diagonal_sum(7) 261 ``` Write a function that systematically computes the sum of numbers on both diagonals of the spiral arrangement. Ensure efficiency despite larger values of `n`.","solution":"def number_spiral_diagonal_sum(n: int) -> int: Function to calculate the sum of the diagonals in an n x n number spiral. if n % 2 == 0 or n < 1: raise ValueError(\\"n must be an odd integer greater than or equal to 1\\") total_sum = 1 # Starting point for the center of the spiral current_number = 1 for layer in range(1, (n//2) + 1): for _ in range(4): current_number += 2 * layer total_sum += current_number return total_sum"},{"question":"# Image Denoising using Median Filter Given the code snippet and analysis of a Median Filter for noise reduction, implement a function to denoise a given grayscale image using a 3x3 median filter. # Input Format * A 2D numpy array representing a grayscale image, with pixel values ranging from 0 to 255. # Output Format * A 2D numpy array representing the denoised image. # Constraints * The input image will have dimensions m x n (1 ≤ m, n ≤ 1000). * Do not use any built-in denoising or filtering functions other than matrix operations. # Performance Requirements * Aim for an efficient implementation as the runtime should be within acceptable limits for the given constraints. # Example ```python import numpy as np def median_filter(image): m, n = image.shape output_image = np.zeros((m, n), dtype=np.uint8) for i in range(1, m-1): for j in range(1, n-1): # Extract the 3x3 neighborhood neighborhood = image[i-1:i+2, j-1:j+2].flatten() # Calculate the median of the neighborhood median_value = np.median(neighborhood) # Set the median value to the output image output_image[i, j] = median_value # Handle edges by replicating the filter\'s effect similar to inner pixels output_image[0, :] = image[0, :] output_image[-1, :] = image[-1, :] output_image[:, 0] = image[:, 0] output_image[:, -1] = image[:, -1] return output_image # Note: # - You should handle edge and corner pixels appropriately by replicating border values or similar methods. # - The resulting array should have the same dimensions as the input image. ``` Implement the function `median_filter` to support the above implementation.","solution":"import numpy as np def median_filter(image): Apply a 3x3 median filter to the input grayscale image. Parameters: image (np.ndarray): A 2D numpy array representing a grayscale image. Returns: np.ndarray: A 2D numpy array representing the denoised image. m, n = image.shape output_image = np.zeros((m, n), dtype=np.uint8) # Apply median filter to each pixel, excluding the border pixels for i in range(1, m-1): for j in range(1, n-1): # Extract the 3x3 neighborhood neighborhood = image[i-1:i+2, j-1:j+2].flatten() # Calculate the median of the neighborhood median_value = np.median(neighborhood) # Set the median value to the output image output_image[i, j] = median_value # Handle edges by replicating the pixels at the border output_image[0, :] = image[0, :] output_image[-1, :] = image[-1, :] output_image[:, 0] = image[:, 0] output_image[:, -1] = image[:, -1] return output_image"},{"question":"# Question Write a function that takes a list of integers and determines if it contains a valid mountain sequence. A list is a mountain sequence if: - The length of the list is at least 3. - There exists some index `i` such that: - Elements `A[0]` to `A[i]` are strictly increasing. - Elements `A[i]` to `A[-1]` are strictly decreasing. The function should return `True` if the list is a valid mountain sequence and `False` otherwise. Specific Requirements: 1. **Function Name**: is_mountain_sequence 2. **Input**: - A single list of integers, `A`. 3. **Output**: - A boolean value `True` if the list is a valid mountain sequence, `False` otherwise. Constraints: * The length of the list must be at least 3. * It should have at least one increasing and one decreasing slope. # Example Usage: ```python def is_mountain_sequence(A: list) -> bool: if len(A) < 3: return False increasing = False decreasing = False peak_index = 0 for i in range(1, len(A)): if not increasing and A[i] > A[i - 1]: increasing = True if increasing and not decreasing and A[i] < A[i - 1]: peak_index = i - 1 decreasing = True if decreasing and A[i] >= A[i - 1]: return False return increasing and decreasing and peak_index > 0 and peak_index < len(A) - 1 # Test Cases print(is_mountain_sequence([2, 1])) # False, too short print(is_mountain_sequence([3, 5, 5])) # False, no valid peak print(is_mountain_sequence([0, 3, 2, 1])) # True, valid mountain print(is_mountain_sequence([0, 3, 3, 1])) # False, no valid peak print(is_mountain_sequence([1, 2, 3, 4, 2, 1])) # True, valid mountain ``` Your implementation should pass the above cases and follow the constraints provided.","solution":"def is_mountain_sequence(A: list) -> bool: Determines if the list contains a valid mountain sequence. n = len(A) if n < 3: return False i = 1 # Traverse up while i < n and A[i] > A[i - 1]: i += 1 # Peak can\'t be first or last if i == 1 or i == n: return False # Traverse down while i < n and A[i] < A[i - 1]: i += 1 return i == n"},{"question":"# Scenario: You are building a system to manage and visualize sales records data. Each sale is recorded with a sales amount and the date of the sale. The system should support operations to add new sales record, get the sales amount on a specific date, and retrieve the total sales amount in a specified date range. To efficiently handle these operations, use a **Segment Tree**. # Task: Implement a function to support the following operations: 1. **record_sale(date: int, amount: int)**: Record a sale with the specified amount on the given date. 2. **get_sale(date: int)**: Retrieve the sales amount recorded on the given date. 3. **total_sales(start_date: int, end_date: int)**: Calculate the total sales amount for the range [start_date, end_date). # Constraints: - `0 <= date < D`, where `D` is the number of dates. - `0 <= amount <= 10^9` - `0 <= start_date < end_date <= D` - You cannot use built-in library functions for querying ranges (like `sum`). # Function Signature: ```python class SalesManager: def __init__(self, size: int) -> None: ... def record_sale(self, date: int, amount: int) -> None: ... def get_sale(self, date: int) -> int: ... def total_sales(self, start_date: int, end_date: int) -> int: ... # Example Usage: # manager = SalesManager(10) # manager.record_sale(3, 100) # manager.record_sale(5, 200) # print(manager.get_sale(3)) # Output: 100 # print(manager.total_sales(2, 6)) # Output: 300 ``` # Notes: - Ensure that the solution efficiently supports both recording new sales and range queries. - Handle edge cases where queries might involve boundary dates. - Maintain the performance goals as stated by the Segment Tree principles.","solution":"class SalesManager: def __init__(self, size: int) -> None: self.size = size self.tree = [0] * (2 * size) def record_sale(self, date: int, amount: int) -> None: pos = date + self.size self.tree[pos] = amount while pos > 1: pos //= 2 self.tree[pos] = self.tree[2 * pos] + self.tree[2 * pos + 1] def get_sale(self, date: int) -> int: return self.tree[date + self.size] def total_sales(self, start_date: int, end_date: int) -> int: start = start_date + self.size end = end_date + self.size total = 0 while start < end: if start % 2 == 1: total += self.tree[start] start += 1 if end % 2 == 1: end -= 1 total += self.tree[end] start //= 2 end //= 2 return total"},{"question":"# Context A \\"word ladder\\" is a puzzle where you transform one word into another word by changing exactly one letter at each step. Each intermediate word must be a valid word in some given dictionary. For example, to transform the word \\"hit\\" into the word \\"cog\\" using the dictionary `[\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\", \\"cog\\"]`, one possible sequence is: ``` hit -> hot -> dot -> dog -> cog ``` # Task You need to implement the Word Ladder problem in Python. Specifically, you will write a function: 1. `word_ladder(begin_word: str, end_word: str, word_list: List[str]) -> List[str]`: This function should return the shortest transformation sequence from `begin_word` to `end_word`, or an empty list if no such sequence exists. # Input/Output Format * **Input**: - A string `begin_word` representing the starting word. - A string `end_word` representing the target word. - A list of strings `word_list` containing all possible intermediate words. * **Output**: A list of strings representing the sequence from `begin_word` to `end_word`. If no such sequence exists, return an empty list. # Constraints 1. The length of `begin_word` and `end_word` will be the same. 2. The list `word_list` will contain between 1 and 1,000 words, each the same length as `begin_word` and `end_word`. 3. All words in `word_list` and the `begin_word` and `end_word` are lowercase alphabets. 4. The begin_word won\'t be a part of the word_list. # Examples ```python >>> word_ladder(\\"hit\\", \\"cog\\", [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\", \\"cog\\"]) [\'hit\', \'hot\', \'dot\', \'dog\', \'cog\'] >>> word_ladder(\\"hit\\", \\"cog\\", [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\"]) [] ``` # Requirements 1. Use a breadth-first search (BFS) to find the shortest transformation sequence. 2. Ensure that intermediate words are valid words from the `word_list`. # Performance Expectations The function should be able to handle the worst-case scenario within reasonable time limits for the given constraints.","solution":"from collections import deque from typing import List def word_ladder(begin_word: str, end_word: str, word_list: List[str]) -> List[str]: if end_word not in word_list: return [] word_list_set = set(word_list) queue = deque([(begin_word, [begin_word])]) while queue: current_word, path = queue.popleft() for i in range(len(current_word)): for char in \'abcdefghijklmnopqrstuvwxyz\': next_word = current_word[:i] + char + current_word[i+1:] if next_word == end_word: return path + [next_word] if next_word in word_list_set: word_list_set.remove(next_word) queue.append((next_word, path + [next_word])) return []"},{"question":"# Task: Implement a Function to Count Odd and Even Numbers Context In data analysis and statistics, it is often useful to categorize data into different groups. One simple form of categorization for numerical data is determining the count of odd and even numbers in a dataset. Objective Write a function `count_odd_even` that takes a list of integers and returns a tuple containing the count of odd numbers and even numbers in the list. # Function Signature ```python def count_odd_even(numbers: list[int]) -> tuple[int, int]: pass ``` # Input * **numbers** (list[int]): A list of integers. # Output * **tuple[int, int]**: A tuple where the first element is the count of odd numbers and the second element is the count of even numbers. # Constraints * The length of the input list will be in the range [1, 1000]. * Each element in the input list is an integer in the range [-10^6, 10^6]. # Example Scenarios Example 1 * **Input**: [1, 2, 3, 4, 5, 6] * **Output**: (3, 3) * **Explanation**: There are three odd numbers (1, 3, 5) and three even numbers (2, 4, 6) in the list. Example 2 * **Input**: [-1, -2, -3, -4, -5, -6, -7, -8, -9] * **Output**: (5, 4) * **Explanation**: There are five odd numbers (-1, -3, -5, -7, -9) and four even numbers (-2, -4, -6, -8) in the list. Example 3 * **Input**: [0, 0, 0] * **Output**: (0, 3) * **Explanation**: There are no odd numbers and three even numbers (all zeros) in the list. # Performance Requirements * The function should operate in O(n) time complexity, where n is the number of elements in the list. # Points to Consider * Handle edge cases such as lists containing only odd or only even numbers. * Ensure to handle negative numbers correctly, considering their parity.","solution":"def count_odd_even(numbers: list[int]) -> tuple[int, int]: odd_count = 0 even_count = 0 for number in numbers: if number % 2 == 0: even_count += 1 else: odd_count += 1 return (odd_count, even_count)"},{"question":"# Question In modern competitive programming, problem-solving often involves efficiently managing data structures to perform operations like insertion, deletion, and searching. One widely used data structure for such tasks is the binary search tree (BST). **Your Task**: Implement a BST that can handle the following operations: insertion of new nodes, deletion of existing nodes, and searching for a value. Additionally, provide a method to calculate the height of the BST and a method to print its in-order traversal. # Input Format You will be given: 1. An integer `m` representing the number of operations. 2. A list of `m` tuples where each tuple represents an operation. The tuple will be in one of the following formats: - `(\'insert\', value)`: Insert the value into the BST. - `(\'delete\', value)`: Delete the value from the BST. - `(\'search\', value)`: Search for the value in the BST (return `True` if found, `False` otherwise). - `(\'height\',)`: Calculate the height of the BST (return the height as an integer). - `(\'inorder\',)`: Print the in-order traversal of the BST (return a list of values). # Output Format Your program should output the results for the `search`, `height`, and `inorder` operations in the order they appear. # Constraints 1. 1 <= m <= 10^5 2. -10^6 <= value <= 10^6 # Example ```python m = 7 operations = [ (\'insert\', 5), (\'insert\', 2), (\'insert\', 8), (\'search\', 2), (\'search\', 10), (\'height\',), (\'inorder\',) ] ``` Expected output: ``` True False 2 [2, 5, 8] ``` # Function Signature ```python def bst_operations(m: int, operations: List[Tuple[str, Union[int, None]]]) -> List[Union[bool, int, List[int]]]: # your code here ``` # Notes * Make sure your implementation is efficient and can handle the upper limits of the input size. * Ensure the BST operations are implemented correctly to maintain its properties. * Pay attention to edge cases such as deletions of non-existent values and height calculations of empty trees.","solution":"class BSTNode: def __init__(self, key): self.left = None self.right = None self.val = key class BST: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = BSTNode(key) else: self._insert(self.root, key) def _insert(self, root, key): if key < root.val: if root.left is None: root.left = BSTNode(key) else: self._insert(root.left, key) else: if root.right is None: root.right = BSTNode(key) else: self._insert(root.right, key) def search(self, key): return self._search(self.root, key) def _search(self, root, key): if root is None: return False if root.val == key: return True elif key < root.val: return self._search(root.left, key) else: return self._search(root.right, key) def delete(self, key): self.root, _ = self._delete(self.root, key) def _delete(self, root, key): if root is None: return root, None if key < root.val: root.left, _ = self._delete(root.left, key) elif key > root.val: root.right, _ = self._delete(root.right, key) else: if root.left is None: return root.right, root.val elif root.right is None: return root.left, root.val temp_val = self._min_value_node(root.right).val root.val = temp_val root.right, _ = self._delete(root.right, temp_val) return root, key def _min_value_node(self, node): current = node while current.left is not None: current = current.left return current def height(self): return self._height(self.root) def _height(self, node): if node is None: return -1 else: left_height = self._height(node.left) right_height = self._height(node.right) return max(left_height, right_height) + 1 def inorder(self): res = [] self._inorder(self.root, res) return res def _inorder(self, root, res): if root is not None: self._inorder(root.left, res) res.append(root.val) self._inorder(root.right, res) def bst_operations(m, operations): bst = BST() results = [] for operation in operations: if operation[0] == \'insert\': bst.insert(operation[1]) elif operation[0] == \'delete\': bst.delete(operation[1]) elif operation[0] == \'search\': results.append(bst.search(operation[1])) elif operation[0] == \'height\': results.append(bst.height()) elif operation[0] == \'inorder\': results.append(bst.inorder()) return results"},{"question":"# Implementation of a Custom HashMap Context You need to design and implement a custom HashMap data structure that supports basic operations such as insertion, deletion, and retrieval of key-value pairs. This will help ensure understanding of hashing concepts, handling collisions, and dynamic resizing. Task 1. **Design and Implement Core Methods**: - Implement the `put`, `get`, and `remove` methods. - Handle key collisions using chaining (linked list approach). 2. **Implement Dynamic Resizing**: - Implement a mechanism to dynamically resize the HashMap when the load factor exceeds a certain threshold (e.g., 0.75). - Ensure rehashing of the existing entries to the new larger array. Expected Method Implementation 1. **Core Methods (`put`, `get`, `remove`)**: ```python class ListNode: def __init__(self, key=None, value=None, next=None): self.key = key self.value = value self.next = next class MyHashMap: def __init__(self, initial_capacity=10): self.capacity = initial_capacity self.size = 0 self.buckets = [None] * self.capacity def put(self, key, value): # Your code here def get(self, key): # Your code here def remove(self, key): # Your code here def _resize(self): # Your code here ``` 2. **Collision Handling and Dynamic Resizing**: - Implement chaining using a linked list for collision handling. - Implement the `_resize` method to create a new bucket array and rehash the existing elements. Input and Output **Input**: - Operations to be performed on the HashMap in sequence: `put`, `get`, `remove`. **Output**: - For `get` operations, output the value associated with the key if it exists, otherwise return `-1`. - For `put` and `remove` operations, update the HashMap accordingly without any output. Constraints - Keys and values should be valid hashable objects. - The initial capacity of the HashMap should be a positive integer. - Guard against invalid operations (e.g., removing a non-existent key). Scenario Implement the required methods and ensure the HashMap dynamically resizes and handles collisions appropriately. Also, validate the implementation with example usage to ensure correct functioning of `put`, `get`, and `remove` operations.","solution":"class ListNode: def __init__(self, key=None, value=None, next=None): self.key = key self.value = value self.next = next class MyHashMap: def __init__(self, initial_capacity=10): self.capacity = initial_capacity self.size = 0 self.buckets = [None] * self.capacity def _hash(self, key): return hash(key) % self.capacity def put(self, key, value): index = self._hash(key) if self.buckets[index] is None: self.buckets[index] = ListNode(key, value) else: current = self.buckets[index] while current: if current.key == key: current.value = value return if current.next is None: current.next = ListNode(key, value) break current = current.next self.size += 1 if self.size / self.capacity > 0.75: self._resize() def get(self, key): index = self._hash(key) current = self.buckets[index] while current: if current.key == key: return current.value current = current.next return -1 def remove(self, key): index = self._hash(key) current = self.buckets[index] prev = None while current: if current.key == key: if prev is None: self.buckets[index] = current.next else: prev.next = current.next self.size -= 1 return prev = current current = current.next def _resize(self): new_capacity = self.capacity * 2 new_buckets = [None] * new_capacity current_buckets = self.buckets self.capacity = new_capacity self.buckets = new_buckets self.size = 0 for node in current_buckets: while node: self.put(node.key, node.value) node = node.next"},{"question":"# Coding Challenge: Efficient Substring Search Given a function that searches for a substring within a given text using a naive approach, optimize the function to use the Knuth-Morris-Pratt (KMP) algorithm for better performance, especially for large strings. # Task Optimize the `find_substring` function to utilize the KMP algorithm, which has a linear time complexity for finding occurrences of a substring in a text. # Function Signature ```python def find_substring(text: str, pattern: str) -> int: ``` # Inputs - `text`: A string where you need to search for the pattern. - `pattern`: A string pattern that you need to search for within the text. # Outputs - Returns the starting index of the first occurrence of the pattern in the text. If the pattern is not found, return -1. # Constraints 1. The text and pattern may contain any printable ASCII characters. 2. Both input strings have a maximum length of 100,000 characters. 3. If the pattern is an empty string, return 0. 4. The search should be case-sensitive. # Example ```python text = \\"ABABDABACDABABCABAB\\" pattern = \\"ABABCABAB\\" print(find_substring(text, pattern)) # Expected Output: 10 text = \\"hello world\\" pattern = \\"world\\" print(find_substring(text, pattern)) # Expected Output: 6 text = \\"a quick brown fox jumps over the lazy dog\\" pattern = \\"cat\\" print(find_substring(text, pattern)) # Expected Output: -1 ``` # Additional Information - The optimized function should preprocess the pattern to create a longest prefix suffix (LPS) array used in the KMP algorithm. - The LPS array helps determine the next positions from where the match should continue if a mismatch occurs. # Hints - Implement the LPS array construction first. - Utilize the LPS array to skip unnecessary comparisons in the text. - Ensure your implementation handles edge cases such as when the pattern is longer than the text.","solution":"def compute_lps(pattern): length = 0 i = 1 lps = [0] * len(pattern) while i < len(pattern): if pattern[i] == pattern[length]: length += 1 lps[i] = length i += 1 else: if length != 0: length = lps[length - 1] else: lps[i] = 0 i += 1 return lps def find_substring(text, pattern): if not pattern: return 0 if not text or len(pattern) > len(text): return -1 lps = compute_lps(pattern) i = 0 j = 0 while i < len(text): if pattern[j] == text[i]: i += 1 j += 1 if j == len(pattern): return i - j elif i < len(text) and pattern[j] != text[i]: if j != 0: j = lps[j - 1] else: i += 1 return -1"},{"question":"# Question: Implement a Custom Stack with Minimum Element Retrieval Context A stack is a popular data structure that follows Last In First Out (LIFO) order for operations. In this task, you are required to implement a custom stack that, in addition to the usual stack operations, can also retrieve the minimum element in constant O(1) time. Task Implement a class `MinStack` that supports the following operations: - `push` function: Adds an element onto the stack. - `pop` function: Removes the element on the top of the stack. - `top` function: Retrieves the top element of the stack. - `get_min` function: Retrieves the minimum element in the stack. Input and Output 1. **Input**: - Operations to be performed in sequence on the stack. 2. **Output**: - For `pop` and `push`, return `None`. - For `top`, return the top element. - For `get_min`, return the minimum element in the stack. **Function Signatures**: ```python class MinStack: def __init__(self): # Your implementation here def push(self, val: int) -> None: # Your implementation here def pop(self) -> None: # Your implementation here def top(self) -> int: # Your implementation here def get_min(self) -> int: # Your implementation here ``` Constraints - All operations (`push`, `pop`, `top`, `get_min`) must be performed in constant O(1) time. - All integer values pushed onto the stack fit within the range `[-10^5, 10^5]`. - There will be at least one element when `pop`, `top`, or `get_min` is called. Example ```python >>> stack = MinStack() >>> stack.push(-2) >>> stack.push(0) >>> stack.push(-3) >>> stack.get_min() -3 >>> stack.pop() >>> stack.top() 0 >>> stack.get_min() -2 >>> stack.pop() >>> stack.pop() >>> stack.get_min() None ``` Your implementation should handle all edge cases gracefully and ensure correct functioning of stack operations without any errors.","solution":"class MinStack: def __init__(self): self.stack = [] self.min_stack = [] def push(self, val: int) -> None: self.stack.append(val) if not self.min_stack or val <= self.min_stack[-1]: self.min_stack.append(val) def pop(self) -> None: if self.stack: val = self.stack.pop() if val == self.min_stack[-1]: self.min_stack.pop() def top(self) -> int: if self.stack: return self.stack[-1] return None def get_min(self) -> int: if self.min_stack: return self.min_stack[-1] return None"},{"question":"# Question: Grid Path Counter You are developing an algorithm for a robot that needs to navigate an MxN grid from the top-left corner to the bottom-right corner. The robot can move either right or down at each step. Your task is to write a function that calculates the number of unique paths the robot can take to reach its destination. **Function Specification** **Function Name**: `unique_paths` **Parameters**: - `m` (int): The number of rows in the grid. Must be positive. - `n` (int): The number of columns in the grid. Must be positive. **Output**: - Returns the number of unique paths the robot can take to reach the bottom-right corner. **Constraints**: - Both `m` and `n` must be positive integers. **Performance Requirements**: - The function should efficiently handle grids with large dimensions, ideally running in O(m * n) time complexity. **Example Usage**: ```python >>> unique_paths(3, 7) 28 >>> unique_paths(3, 2) 3 >>> unique_paths(7, 3) 28 ``` **Error Handling**: - If any of the input values for `m` or `n` are non-positive, the function should raise a `ValueError` with an appropriate message. **Implementation**: Write a function that utilizes dynamic programming to determine the number of unique paths. You can create a 2D list where each element (i, j) represents the number of ways to get to that cell from the start, and iteratively fill in the values based on the possible moves from each cell. ```python def unique_paths(m, n): if m <= 0 or n <= 0: raise ValueError(\\"Both m and n must be positive integers.\\") dp = [[1] * n for _ in range(m)] # Initialize 2D list with 1s for i in range(1, m): for j in range(1, n): dp[i][j] = dp[i-1][j] + dp[i][j-1] # Sum ways from top and left cells return dp[-1][-1] ``` This function computes the number of unique paths in an MxN grid by summing up the ways to reach each cell either from the top cell or the left cell, reflecting the robot\'s possible moves.","solution":"def unique_paths(m, n): if m <= 0 or n <= 0: raise ValueError(\\"Both m and n must be positive integers.\\") # Initialize a 2D list dp where dp[i][j] represents the number of unique paths to cell (i, j) dp = [[1] * n for _ in range(m)] # Initially set all cells to 1 for i in range(1, m): for j in range(1, n): # The number of unique paths to cell (i, j) is the sum of the number of unique paths # to the cell directly above (i-1, j) and to the cell directly to the left (i, j-1) dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[-1][-1]"},{"question":"# Rebalanced Binary Search Tree You are given a `BSTNode` class for a Binary Search Tree (BST), which stores integer values and has pointers to its left and right children. Your task is to implement a function `insert_and_rebalance` that inserts a new value into the BST and then rebalances the tree to ensure it remains balanced. A balanced BST is defined as one where the difference in height between the left and right subtrees of any node is no more than 1. Function Signature ```python def insert_and_rebalance(root: \'BSTNode\', value: int) -> \'BSTNode\': Insert a new value into the BST and rebalance it to maintain balance. Args: root (BSTNode): The root node of the BST. value (int): The value to insert into the BST. Returns: BSTNode: The root node of the rebalanced BST. ``` Input 1. `root`: An instance of `BSTNode` that represents the root of the BST. 2. `value`: An integer value to insert into the BST. Output - The root of the rebalanced BST after the new value has been inserted. Constraints 1. The BST will contain integer values. 2. The BST may contain up to 1000 nodes. 3. Each node of the tree is an instance of the `BSTNode` class. ```python class BSTNode: def __init__(self, value: int): self.value = value self.left = None self.right = None # Helper Functions def height(node: BSTNode) -> int: if not node: return 0 return max(height(node.left), height(node.right)) + 1 def balance_factor(node: BSTNode) -> int: if not node: return 0 return height(node.left) - height(node.right) def rotate_left(z: BSTNode) -> BSTNode: y = z.right T2 = y.left y.left = z z.right = T2 return y def rotate_right(z: BSTNode) -> BSTNode: y = z.left T3 = y.right y.right = z z.left = T3 return y def insert_and_rebalance(root: BSTNode, value: int) -> BSTNode: if not root: return BSTNode(value) if value < root.value: root.left = insert_and_rebalance(root.left, value) else: root.right = insert_and_rebalance(root.right, value) # Balance the tree bf = balance_factor(root) # Left Left Case if bf > 1 and value < root.left.value: return rotate_right(root) # Right Right Case if bf < -1 and value > root.right.value: return rotate_left(root) # Left Right Case if bf > 1 and value > root.left.value: root.left = rotate_left(root.left) return rotate_right(root) # Right Left Case if bf < -1 and value < root.right.value: root.right = rotate_right(root.right) return rotate_left(root) return root ``` # Example ```python # Constructing the BST root = BSTNode(10) root = insert_and_rebalance(root, 20) root = insert_and_rebalance(root, 5) root = insert_and_rebalance(root, 15) root = insert_and_rebalance(root, 25) root = insert_and_rebalance(root, 30) # Expected output # The tree should be balanced after each insertion, # maintaining the BST property. ``` # Hints 1. Use the balance factor (difference in height between left and right subtrees) to determine when to rotate. 2. Perform rotations to maintain balance: left rotation, right rotation, left-right rotation, and right-left rotation. 3. Recursively insert the new values and rebalance the tree from the bottom up.","solution":"class BSTNode: def __init__(self, value: int): self.value = value self.left = None self.right = None # Helper Functions def height(node: BSTNode) -> int: if not node: return 0 return max(height(node.left), height(node.right)) + 1 def balance_factor(node: BSTNode) -> int: if not node: return 0 return height(node.left) - height(node.right) def rotate_left(z: BSTNode) -> BSTNode: y = z.right T2 = y.left y.left = z z.right = T2 return y def rotate_right(z: BSTNode) -> BSTNode: y = z.left T3 = y.right y.right = z z.left = T3 return y def insert_and_rebalance(root: BSTNode, value: int) -> BSTNode: if not root: return BSTNode(value) if value < root.value: root.left = insert_and_rebalance(root.left, value) else: root.right = insert_and_rebalance(root.right, value) # Balance the tree bf = balance_factor(root) # Left Left Case if bf > 1 and value < root.left.value: return rotate_right(root) # Right Right Case if bf < -1 and value > root.right.value: return rotate_left(root) # Left Right Case if bf > 1 and value > root.left.value: root.left = rotate_left(root.left) return rotate_right(root) # Right Left Case if bf < -1 and value < root.right.value: root.right = rotate_right(root.right) return rotate_left(root) return root"},{"question":"# Determine Optimal Delivery Routes Using Dijkstra\'s Algorithm **Context**: You are working for a delivery company that aims to optimize the routing of delivery trucks. Given a set of delivery locations and the distances between them, your goal is to determine the shortest path from a warehouse to various delivery points using Dijkstra\'s algorithm. You will be provided with a graph representing the locations and the distances between them. Your task is to implement Dijkstra\'s algorithm to find the shortest paths from the warehouse. # Task: 1. **Graph Representation**: Implement a function to construct a graph from the provided input data. 2. **Dijkstra\'s Algorithm**: Implement the algorithm to compute the shortest paths from the source node (warehouse) to all other nodes. 3. **Output Results**: Output the shortest distance from the warehouse to each delivery location. # Inputs: - **graph_data**: A list representing the graph, where each element is a tuple (source, destination, distance). - **start_node**: The starting node from which to calculate the shortest paths (warehouse). # Expected Output: - Print the shortest distances from the start node to all other nodes in the graph. # Code Constraints: - You may assume the graph is connected and the edges have positive weights. - Use a suitable data structure for the graph representation (e.g., adjacency list). - Use a priority queue (min-heap) for the efficient implementation of Dijkstra\'s algorithm. - Include meaningful comments and print statements for analysis and debugging purposes. Here is the skeleton of the program you need to implement: ```python import heapq def create_graph(graph_data): graph = {} for source, destination, distance in graph_data: if source not in graph: graph[source] = [] if destination not in graph: graph[destination] = [] graph[source].append((destination, distance)) graph[destination].append((source, distance)) return graph def dijkstra(graph, start_node): pq = [] heapq.heappush(pq, (0, start_node)) distances = {node: float(\'inf\') for node in graph} distances[start_node] = 0 visited = set() while pq: current_distance, current_node = heapq.heappop(pq) if current_node in visited: continue visited.add(current_node) for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) return distances def main(): graph_data = [ (\'A\', \'B\', 4), (\'A\', \'C\', 2), (\'B\', \'C\', 5), (\'B\', \'D\', 10), (\'C\', \'E\', 3), (\'D\', \'F\', 11), (\'E\', \'D\', 4) ] start_node = \'A\' graph = create_graph(graph_data) shortest_distances = dijkstra(graph, start_node) print(\\"Shortest distances from the start node:\\") for node in shortest_distances: print(f\\"Distance to {node}: {shortest_distances[node]}\\") if __name__ == \\"__main__\\": main() ``` # Evaluation - You will be evaluated on correctly implementing the graph representation and Dijkstra\'s algorithm. - Properly handling the edge cases and ensuring the algorithm computes the correct shortest paths. - Clear and concise code with appropriate function naming and comments.","solution":"import heapq def create_graph(graph_data): Create a graph representation from the provided input data. Args: graph_data (list of tuples): Each tuple contains source, destination, and distance. Returns: dict: Adjacency list representation of the graph. graph = {} for source, destination, distance in graph_data: if source not in graph: graph[source] = [] if destination not in graph: graph[destination] = [] graph[source].append((destination, distance)) graph[destination].append((source, distance)) return graph def dijkstra(graph, start_node): Implement Dijkstra\'s algorithm to compute the shortest paths from the start node. Args: graph (dict): Adjacency list representation of the graph. start_node: The starting node for Dijkstra\'s algorithm. Returns: dict: Shortest distances from the start node to each node in the graph. pq = [] heapq.heappush(pq, (0, start_node)) distances = {node: float(\'inf\') for node in graph} distances[start_node] = 0 visited = set() while pq: current_distance, current_node = heapq.heappop(pq) if current_node in visited: continue visited.add(current_node) for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) return distances def main(): graph_data = [ (\'A\', \'B\', 4), (\'A\', \'C\', 2), (\'B\', \'C\', 5), (\'B\', \'D\', 10), (\'C\', \'E\', 3), (\'D\', \'F\', 11), (\'E\', \'D\', 4) ] start_node = \'A\' graph = create_graph(graph_data) shortest_distances = dijkstra(graph, start_node) print(\\"Shortest distances from the start node:\\") for node in shortest_distances: print(f\\"Distance to {node}: {shortest_distances[node]}\\") if __name__ == \\"__main__\\": main()"},{"question":"**Question**: Validate Balanced Parentheses and Nested Delimiters **Context**: Given a string containing various opening and closing characters: \'(\', \')\', \'{\', \'}\', \'[\' and \']\', you are to determine if the string has valid and properly balanced parentheses and delimited expressions. A string is considered valid if all types of parentheses and delimiters are properly matched and nested. **Details**: 1. Implement a function `is_valid_expression(s: str) -> bool` that: - Takes a string `s` consisting of characters \'(\', \')\', \'{\', \'}\', \'[\' and \']\'. - Returns `True` if the string has valid and properly balanced parentheses and delimited expressions, and `False` otherwise. **Input Format**: - `s` : A string containing characters \'(\', \')\', \'{\', \'}\', \'[\' and \']\'. **Output Format**: - Returns a boolean value `True` if the expression is valid, else returns `False`. **Constraints**: - The string length can vary from very short (few characters) to very long (thousands of characters). - Only the characters \'(\', \')\', \'{\', \'}\', \'[\' and \']\' will be present in the string. **Examples**: ```python def is_valid_expression(s): # Your implementation here # Example usage: print(is_valid_expression(\\"(){}[]\\")) # Output: # True print(is_valid_expression(\\"({[{(([]))}]})\\")) # Output: # True print(is_valid_expression(\\"{[}]\\")) # Output: # False print(is_valid_expression(\\"(((\\")) # Output: # False print(is_valid_expression(\\"([)]\\")) # Output: # False ```","solution":"def is_valid_expression(s: str) -> bool: Check if the given string containing \'(\', \')\', \'{\', \'}\', \'[\' and \']\' is valid and properly balanced. :param s: Input string to be checked for balanced parentheses and nested delimiters. :return: Boolean indicating if the string is valid. stack = [] matching_parentheses = {\')\': \'(\', \'}\': \'{\', \']\': \'[\'} for char in s: if char in \'({[\': stack.append(char) elif char in \')}]\': if not stack or stack.pop() != matching_parentheses[char]: return False return not stack"},{"question":"# Coding Assessment Question **Title:** Find Maximum Subarray Sum **Context:** Given an integer array `nums` representing a series of integers, your task is to implement a function that finds the contiguous subarray (containing at least one number) which has the largest sum and return that sum. Implement the `maxSubArray` function using Kadane\'s Algorithm, which is known for efficiently solving this problem with a linear time complexity of O(n). **Requirements:** 1. Implement the function `maxSubArray(nums: List[int]) -> int` that finds the maximum sum of the contiguous subarray. 2. Handle edge cases where the array length is zero should return 0. **Input:** - `nums` (List[int]): A list of integers, where the length of the array can be between `1` and `10^5`. **Output:** - An integer representing the maximum sum of the contiguous subarray. **Constraints:** - The array can contain both positive and negative integers, with at least one element in `nums`. **Examples:** ```python # Example 1 assert maxSubArray([-2,1,-3,4,-1,2,1,-5,4]) == 6 # Explanation: [4,-1,2,1] has the largest sum = 6 # Example 2 assert maxSubArray([1]) == 1 # Explanation: [1] is the only subarray with sum = 1 # Example 3 assert maxSubArray([5,4,-1,7,8]) == 23 # Explanation: [5,4,-1,7,8] has the largest sum = 23 ``` **Performance Expectation:** - The `maxSubArray` function should execute in O(n) time complexity. **Note:** - The function should be robust enough to handle arrays with a large length up to `10^5` and both large positive and negative integer values.","solution":"from typing import List def maxSubArray(nums: List[int]) -> int: if not nums: # Handling edge case where nums is empty return 0 max_so_far = nums[0] max_ending_here = nums[0] for num in nums[1:]: max_ending_here = max(num, max_ending_here + num) max_so_far = max(max_so_far, max_ending_here) return max_so_far"},{"question":"# Context You are given a binary tree where each node\'s value is either a \'+\' or \'-\' operator or a non-negative integer. The tree represents an arithmetic expression with the operators acting on its children. # Task Implement a function in Python to evaluate the arithmetic expression represented by this binary tree. The tree will be in the form of a nested dictionary structure, and your function should recursively compute the result. # Requirements - Function Name: `evaluate_expression_tree` - **Input**: A nested dictionary representing the binary tree. - **Output**: An integer result of the evaluated expression. - **Constraints**: - The tree will be non-empty. - The operators will only be \'+\' or \'-\'. - Leaf nodes will always contain non-negative integers. # Example ```python # Example usage tree = { \'value\': \'+\', \'left\': { \'value\': 3, \'left\': None, \'right\': None }, \'right\': { \'value\': \'-\', \'left\': { \'value\': 10, \'left\': None, \'right\': None }, \'right\': { \'value\': 5, \'left\': None, \'right\': None } } } result = evaluate_expression_tree(tree) # Output should be: 8 (since (3 + (10 - 5)) = 8) ``` # Notes: - You may assume the input tree will always be a valid binary tree. - The nested dictionary format will follow the pattern: {\'value\': <value>, \'left\': <left subtree>, \'right\': <right subtree>}. **Implement the Function Below:** ```python def evaluate_expression_tree(tree): # Your code here ```","solution":"def evaluate_expression_tree(tree): Evaluate the arithmetic expression represented by the binary tree. The tree is in the form of a nested dictionary. - If the node is a leaf, return its integer value. - If the node is an operator (\'+\' or \'-\'), evaluate left and right subtrees and apply the operator on the results. :param tree: Dictionary representing the binary tree :return: Integer result of the evaluated expression. if tree[\'left\'] is None and tree[\'right\'] is None: return tree[\'value\'] left_val = evaluate_expression_tree(tree[\'left\']) right_val = evaluate_expression_tree(tree[\'right\']) if tree[\'value\'] == \'+\': return left_val + right_val elif tree[\'value\'] == \'-\': return left_val - right_val"},{"question":"# Problem Statement You are given a list of n integers where each integer is between 1 and n (inclusive). Some numbers appear twice and others appear once. Find all the numbers that appear twice in this list in linear time and without using extra space. Write a function `find_duplicates(nums: list[int]) -> list[int]` that returns a list of integers representing the duplicate numbers in ascending order. # Function Signature ```python def find_duplicates(nums: list[int]) -> list[int]: pass ``` # Input * `nums`: A list of integers where `1 <= nums[i] <= n` and `n` is the length of the list. - `1 <= len(nums) <= 10^5` # Output * Returns a list of integers representing the duplicate numbers in ascending order. # Constraints * The function should run in linear time complexity, O(n). * The function should not use extra space, i.e., use only O(1) extra space (disregarding the output list). # Example ```python nums = [4, 3, 2, 7, 8, 2, 3, 1] print(find_duplicates(nums)) # Output: [2, 3] nums = [1, 1, 2] print(find_duplicates(nums)) # Output: [1] nums = [1] print(find_duplicates(nums)) # Output: [] ``` # Additional Notes * Consider using the input array itself to track occurrences and positions of elements. * Pay attention to edge cases like an array with all unique elements or all duplicates. * Utilize appropriate algorithms that comply with the given constraints and ensure the function is both time and space efficient.","solution":"def find_duplicates(nums: list[int]) -> list[int]: Returns a list of integers representing the duplicate numbers in the given list. Parameters: nums (list[int]): A list of integers where each integer is between 1 and n (inclusive), where n is the length of the list. Returns: list[int]: A list of integers representing the duplicate numbers in ascending order. duplicates = [] for num in nums: index = abs(num) - 1 if nums[index] < 0: duplicates.append(index + 1) else: nums[index] = -nums[index] # Restore the original values of nums in case it is needed later for i in range(len(nums)): nums[i] = abs(nums[i]) duplicates.sort() return duplicates"},{"question":"# Problem Statement Write a function `merge_sorted_lists` to merge two sorted linked lists, and another function `reverse_linked_list` to reverse a linked list. These functions should maintain the integrity and structure of the linked list as specified. Function 1: `merge_sorted_lists` Implement the function `merge_sorted_lists` that merges two sorted linked lists into a single, sorted linked list. ```python def merge_sorted_lists(l1: Node | None, l2: Node | None) -> Node: ``` **Parameters**: - `l1` (Node | None): The head of the first sorted linked list. - `l2` (Node | None): The head of the second sorted linked list. **Returns**: - `Node`: The head of the merged sorted linked list. **Example**: ```python l1 = insert_node(None, 1) l1 = insert_node(l1, 3) l1 = insert_node(l1, 5) # l1: 1->3->5 l2 = insert_node(None, 2) l2 = insert_node(l2, 4) l2 = insert_node(l2, 6) # l2: 2->4->6 merged_head = merge_sorted_lists(l1, l2) print_linked_list(merged_head) # Output: 1->2->3->4->5->6 ``` Function 2: `reverse_linked_list` Implement the function `reverse_linked_list` that reverses a given linked list. ```python def reverse_linked_list(head: Node | None) -> Node | None: ``` **Parameters**: - `head` (Node | None): The head of the linked list to be reversed. **Returns**: - `Node | None`: The head of the reversed linked list. **Example**: ```python head = insert_node(None, 1) head = insert_node(head, 2) head = insert_node(head, 3) head = insert_node(head, 4) head = insert_node(head, 5) print_linked_list(head) # Output: 1->2->3->4->5 reversed_head = reverse_linked_list(head) print_linked_list(reversed_head) # Output: 5->4->3->2->1 ``` Constraints * The linked lists will not contain duplicates. * Both linked lists provided to `merge_sorted_lists` are already sorted in ascending order. * Handle edge cases such as empty linked lists appropriately. * Note: The Node implementation is provided inside the dataclass below, and the `insert_node` function can be used for constructing linked lists: ```python from dataclasses import dataclass @dataclass class Node: data: int next_node: Node | None = None def insert_node(head: Node | None, data: int) -> Node: new_node = Node(data) if head is None: return new_node current = head while current.next_node: current = current.next_node current.next_node = new_node return head ``` Additional Requirements 1. Ensure code handles edge cases efficiently such as input lists being empty. 2. Include appropriate error handling and maintaining the integrity of the linked list structure.","solution":"from dataclasses import dataclass from typing import Optional @dataclass class Node: data: int next_node: Optional[\'Node\'] = None def insert_node(head: Optional[Node], data: int) -> Node: new_node = Node(data) if head is None: return new_node current = head while current.next_node: current = current.next_node current.next_node = new_node return head def merge_sorted_lists(l1: Optional[Node], l2: Optional[Node]) -> Optional[Node]: dummy = Node(0) tail = dummy while l1 and l2: if l1.data < l2.data: tail.next_node = l1 l1 = l1.next_node else: tail.next_node = l2 l2 = l2.next_node tail = tail.next_node tail.next_node = l1 if l1 else l2 return dummy.next_node def reverse_linked_list(head: Optional[Node]) -> Optional[Node]: prev = None current = head while current is not None: next_node = current.next_node current.next_node = prev prev = current current = next_node return prev def print_linked_list(head: Optional[Node]) -> None: while head is not None: print(head.data, end=\' \') head = head.next_node print()"},{"question":"# **Coding Assessment Question** Context: You are developing a text processing feature for a document editing software. The aim is to help users analyze word usage frequency within a text document. Due to the large size of documents, an efficient algorithm is needed to parse and count word occurrences, while ignoring common stop words that hold little significance in analysis. Task: Implement a function called **`count_word_frequencies`** that reads a text document, counts the frequency of each word (excluding a list of predefined stop words), and returns the top `n` most frequent words and their corresponding counts in descending order of frequency. Function Signature: - `def count_word_frequencies(text: str, stop_words: list[str], n: int) -> list[tuple[str, int]]:` # Input: - `text`: A string representing the content of the text document. - `stop_words`: A list of common stop words to be ignored (e.g., \\"the\\", \\"is\\", \\"in\\", \\"and\\"). - `n`: An integer representing the number of top frequent words to return. # Output: - A list of tuples where each tuple contains a word and its frequency, sorted by frequency in descending order. The list should be at most `n` elements long. # Constraints: - The input text document can have up to `10^7` characters. - The stop words list will have at most `10^4` entries. - Ignore case when counting word frequencies (e.g., \\"Word\\" and \\"word\\" should be counted as the same). - Only consider alphabetic characters for words, ignoring punctuation and numbers. # Examples: ```python assert count_word_frequencies( \\"The quick brown fox jumps over the lazy dog. The dog was not impressed.\\", [\\"the\\", \\"was\\", \\"not\\"], 3) == [(\'dog\', 2), (\'quick\', 1), (\'brown\', 1)] assert count_word_frequencies( \\"Data mining is the process of discovering patterns in large data sets. Mining is essential.\\", [\\"is\\", \\"the\\", \\"in\\"], 2) == [(\'mining\', 2), (\'data\', 2)] assert count_word_frequencies( \\"hello world, hello everyone! this world is full of wonders.\\", [\\"is\\", \\"of\\", \\"this\\"], 2) == [(\'hello\', 2), (\'world\', 2)] assert count_word_frequencies( \\"\\", [\\"and\\", \\"the\\"], 3) == [] ``` **Note**: Handle edge cases such as empty text input, text with no significant words, and ties in word frequency. Additional Requirements: - Optimize the function for large text inputs to ensure fast performance. - Write unit tests to validate the functionality of your implementation, considering edge cases and varying input sizes.","solution":"import re from collections import Counter def count_word_frequencies(text: str, stop_words: list[str], n: int) -> list[tuple[str, int]]: Counts the frequency of each word in the text excluding stop words, and returns the top `n` most frequent words and their counts. Parameters: text (str): The content of the text document. stop_words (list[str]): A list of common stop words to exclude. n (int): The number of top frequent words to return. Returns: list[tuple[str, int]]: A list of tuples containing words and their frequencies. # Convert text to lowercase text = text.lower() # Use regex to find all words, ignoring punctuation and numbers words = re.findall(r\'b[a-z]+b\', text) # Filter out stop words filtered_words = [word for word in words if word not in stop_words] # Count the frequency of each word word_counts = Counter(filtered_words) # Get the top `n` most common words most_common_words = word_counts.most_common(n) return most_common_words"},{"question":"# Problem Statement You are required to build a Library System that keeps track of books issued to students. Implement functions to handle the process of issuing books to students, returning books, and getting the current list of books issued to a student. # Function Signatures ```python def issue_book(student_id: int, book_title: str) -> None: pass def return_book(student_id: int, book_title: str) -> None: pass def get_issued_books(student_id: int) -> List[str]: pass ``` # Input 1. **student_id**: An integer representing the student ID. 2. **book_title**: A string representing the title of the book to be issued or returned. # Output 1. **issue_book**: This function does not return anything, but it should update the tracked list of issued books for the given student. 2. **return_book**: This function does not return anything, but it should update the tracked list of issued books for the given student. 3. **get_issued_books**: A list of strings representing the titles of the books currently issued to the given student. # Constraints 1. **student_id** will always be a positive integer. 2. **book_title** will be a non-empty string of up to 100 characters. 3. All book titles will be unique per student (no duplicate titles issued to the same student). # Performance Requirements The solution should efficiently manage the issuing and returning of books, supporting up to 10,000 students, each having up to 1,000 books issued at any time. # Examples 1. **Issuing and Returning Books** ```python issue_book(1, \\"1984\\") issue_book(1, \\"Brave New World\\") issue_book(2, \\"Fahrenheit 451\\") assert get_issued_books(1) == [\\"1984\\", \\"Brave New World\\"] return_book(1, \\"1984\\") assert get_issued_books(1) == [\\"Brave New World\\"] assert get_issued_books(2) == [\\"Fahrenheit 451\\"] ``` # Error Handling - The `issue_book` function should raise a `ValueError` if the book is already issued to the student. - The `return_book` function should raise a `ValueError` if the book is not found in the student\'s issued books list. - The `get_issued_books` function should return an empty list if the student has no books issued.","solution":"from typing import List, Dict # Dictionary to store the books issued to each student student_books: Dict[int, List[str]] = {} def issue_book(student_id: int, book_title: str) -> None: Issue a book to a student. Raises ValueError if the book is already issued to the student. if student_id not in student_books: student_books[student_id] = [] if book_title in student_books[student_id]: raise ValueError(f\\"The book \'{book_title}\' is already issued to student {student_id}.\\") student_books[student_id].append(book_title) def return_book(student_id: int, book_title: str) -> None: Return a book from a student. Raises ValueError if the book is not found in the student\'s issued books list. if student_id not in student_books or book_title not in student_books[student_id]: raise ValueError(f\\"The book \'{book_title}\' is not found in the issued books of student {student_id}.\\") student_books[student_id].remove(book_title) def get_issued_books(student_id: int) -> List[str]: Get the list of books currently issued to a student. Returns an empty list if no books are issued to the student. if student_id not in student_books: return [] return student_books[student_id]"},{"question":"# Coding Question Context A Priority Queue is a data structure where each element has a priority. Elements with higher priorities are served before elements with lower priorities. The `PriorityQueue` class should support the basic operations of insertion, extraction of the highest priority element, and checking if the queue is empty. Task Implement a `PriorityQueue` class that uses a min-heap to efficiently manage the elements. The class should support: 1. Adding elements with a specified priority. 2. Extracting the element with the highest priority (i.e., smallest priority value). 3. Checking if the queue is empty. Class Interface ```python class PriorityQueue: def __init__(self): Initialize the priority queue. def insert(self, value: any, priority: int) -> None: Insert an element with a given priority into the priority queue. def extract_min(self) -> any: Extract and return the element with the highest priority. def is_empty(self) -> bool: Check if the priority queue is empty. ``` Input - You will initialize the `PriorityQueue` with no parameters. Output - `insert(value: any, priority: int)`: Inserts the element `value` with the specified `priority` into the queue. - `extract_min() -> any`: Extracts and returns the element with the highest priority. Return `None` if the queue is empty. - `is_empty() -> bool`: Returns `True` if the priority queue is empty, otherwise `False`. Example Usage ```python # Initialize Priority Queue pq = PriorityQueue() # Insert elements pq.insert(\\"task1\\", 3) pq.insert(\\"task2\\", 1) pq.insert(\\"task3\\", 2) # Extract elements in priority order print(pq.extract_min()) # \\"task2\\" print(pq.extract_min()) # \\"task3\\" print(pq.extract_min()) # \\"task1\\" # Check if the queue is empty print(pq.is_empty()) # True ``` Constraints - The `priority` parameter is an integer where a smaller value indicates a higher priority. - Elements can have identical priority values. - The class should efficiently handle up to 10^5 insertions and extractions.","solution":"import heapq class PriorityQueue: def __init__(self): Initialize the priority queue. self.heap = [] def insert(self, value: any, priority: int) -> None: Insert an element with a given priority into the priority queue. heapq.heappush(self.heap, (priority, value)) def extract_min(self) -> any: Extract and return the element with the highest priority. if self.is_empty(): return None return heapq.heappop(self.heap)[1] def is_empty(self) -> bool: Check if the priority queue is empty. return len(self.heap) == 0"},{"question":"# Coding Assessment Question **Problem Statement:** You need to implement the Quicksort algorithm to sort an array of integers. Given an array, write a Python function that sorts the array in ascending order using the Quicksort algorithm. **Function Signature:** ```python def quicksort(arr: List[int]) -> List[int]: pass ``` **Input:** * `arr`: A list of integers to be sorted. **Output:** * A list of integers sorted in ascending order. **Constraints:** * The array will have a length up to (1000). * The integers in the array will be in the range ([-10^5, 10^5]). **Example:** ```python arr = [3, 6, 8, 10, 1, 2, 1] print(quicksort(arr)) # Expected Output: [1, 1, 2, 3, 6, 8, 10] arr = [5, -2, 4, 0, 9, -1] print(quicksort(arr)) # Expected Output: [-2, -1, 0, 4, 5, 9] ``` **Explanation:** The function should sort the given array using the Quicksort algorithm, which typically follows these steps: 1. Select a pivot element from the array. 2. Partition the array into two sub-arrays: elements less than the pivot and elements greater than the pivot. 3. Recursively apply the above steps to the sub-arrays. 4. Combine the sorted sub-arrays and the pivot to get the final sorted array. **Notes:** * You can choose any pivot strategy (e.g., first element, last element, random element). * Ensure that the implementation is efficient and avoids common pitfalls such as stack overflow on extremely unbalanced partitions. * Avoid using built-in sort functions; the goal is to implement the sorting logic manually.","solution":"from typing import List def quicksort(arr: List[int]) -> List[int]: Sort the list using the Quicksort algorithm. if len(arr) <= 1: return arr else: pivot = arr[len(arr) // 2] # Using middle element as pivot left = [x for x in arr if x < pivot] middle = [x for x in arr if x == pivot] right = [x for x in arr if x > pivot] return quicksort(left) + middle + quicksort(right)"},{"question":"# Scenario You are developing a system to analyze customer feedback by processing and categorizing their comments. One aspect of this system is to identify the most frequently mentioned words across different comments. Implement a function that finds the top `k` most common words in a given list of comments, excluding any common stop words. # Function to Implement Write a function `top_k_common_words`: Input - `comments` (list[str]): A list of customer comments. - `k` (int): The number of most common words to return. - `stop_words` (set[str]): A set of words to be excluded from the analysis. Output - (list[str]): A list of the top `k` most common words in descending order of frequency. If multiple words have the same frequency, they should be sorted alphabetically. Constraints 1. Each comment is a non-empty string containing only alphabetical characters and spaces. 2. Words are case-insensitive (i.e., \'Word\' and \'word\' are the same). 3. `k` must be a non-negative integer (>= 0). # Requirements 1. Raise a `ValueError` if `k` is negative. 2. Exclude stop words from the analysis. 3. Utilize dictionaries and sorting techniques to ensure efficiency and clarity. # Example ```python >>> comments = [\\"I love this product\\", \\"This is the best product I have ever used\\", \\"Great product and great service\\"] >>> stop_words = {\\"this\\", \\"is\\", \\"the\\", \\"and\\", \\"i\\", \\"have\\", \\"ever\\"} >>> top_k_common_words(comments, 2, stop_words) [\'product\', \'great\'] >>> comments = [\\"Amazing quality\\", \\"Highly recommend\\", \\"Quality is superb\\"] >>> stop_words = {\\"is\\"} >>> top_k_common_words(comments, 1, stop_words) [\'quality\'] >>> comments = [\\"Fantastic service\\"] >>> stop_words = {\\"service\\"} >>> top_k_common_words(comments, 0, stop_words) [] >>> top_k_common_words(comments, -1, stop_words) Traceback (most recent call last): ... ValueError: The value of k must be non-negative. ``` You need to ensure your function is robust, correctly handles edge cases, and performs well even with large input sizes.","solution":"from collections import Counter import re def top_k_common_words(comments, k, stop_words): if k < 0: raise ValueError(\\"The value of k must be non-negative.\\") words = [] for comment in comments: words.extend(re.findall(r\'bw+b\', comment.lower())) filtered_words = [word for word in words if word not in stop_words] word_counts = Counter(filtered_words) sorted_words = sorted(word_counts.items(), key=lambda item: (-item[1], item[0])) return [word for word, count in sorted_words[:k]]"},{"question":"# Coding Assessment Question Objective Write a function to find the maximum length of a contiguous subarray where the absolute difference between any two elements is less than or equal to `k`. **Function Signature**: ```python def max_contiguous_subarray_length(arr: list, k: int) -> int: Returns the maximum length of a contiguous subarray where the absolute difference between any two elements is <= k. Parameters: arr (list): A list of integers representing the array. k (int): The maximum allowed absolute difference between any two elements in a subarray. Returns: int: The length of the longest contiguous subarray that satisfies the condition. ``` Input format * A list of integers `arr` (1 ≤ len(arr) ≤ 10^5, -10^9 ≤ arr[i] ≤ 10^9). * An integer `k` (0 ≤ k ≤ 10^9) representing the allowed maximum difference. Output format * Return a single integer, representing the length of the longest contiguous subarray that satisfies the condition. Constraints * Ensure the function efficiently handles large input sizes. * Optimize the function to reduce the time complexity, considering edge cases. Example ```python >>> max_contiguous_subarray_length([1, 3, 5, 7], 2) 2 >>> max_contiguous_subarray_length([2, 2, 2, 2], 0) 4 >>> max_contiguous_subarray_length([1, 6, 5, 4, 8, 3], 3) 3 ``` Additional Information * Consider using sliding window or two-pointer techniques to maintain optimal time complexity. * Handle possible edge cases such as repeated elements or subarrays with minimum length.","solution":"def max_contiguous_subarray_length(arr: list, k: int) -> int: Returns the maximum length of a contiguous subarray where the absolute difference between any two elements is <= k. start = 0 max_length = 0 n = len(arr) for end in range(n): while max(arr[start:end+1]) - min(arr[start:end+1]) > k: start += 1 max_length = max(max_length, end - start + 1) return max_length"},{"question":"# Knapsack Problem - Dynamic Programming Implementation You are tasked with implementing the classic 0/1 Knapsack Problem using dynamic programming. This problem involves maximizing the total value of items that can be placed in a knapsack with a fixed capacity. Requirements: 1. **Class Definition**: Implement a class `KnapsackSolver`. 2. **Initialization**: Initialize the class with the maximum capacity of the knapsack. 3. **Add Item Method**: Implement a method `add_item` that takes the item’s weight and value and adds it to the list of items. 4. **Maximum Value Method**: Implement a method `maximum_value` that computes the maximum value achievable with the given items and knapsack capacity using dynamic programming. # Constraints: * The number of items is between 1 and 1000. * The weight and value of each item are between 1 and 1000. * The knapsack capacity is between 1 and 10^6. # Input: * The maximum capacity of the knapsack (an integer). * A list of tuples where each tuple contains two integers representing the weight and value of an item. # Output: * An integer representing the maximum value that can be achieved with the given capacity. # Example: ```python # Example input capacity = 10 items = [(5, 10), (4, 40), (6, 30), (3, 50)] knapsack = KnapsackSolver(capacity) for weight, value in items: knapsack.add_item(weight, value) max_value = knapsack.maximum_value() # Expected output # 90 print(max_value) # Maximum value achievable with the items is 90 ``` Write the complete code including the class definition and the required methods.","solution":"class KnapsackSolver: def __init__(self, capacity): self.capacity = capacity self.items = [] def add_item(self, weight, value): self.items.append((weight, value)) def maximum_value(self): n = len(self.items) dp = [[0] * (self.capacity + 1) for _ in range(n + 1)] for i in range(1, n + 1): weight, value = self.items[i - 1] for w in range(self.capacity + 1): if weight <= w: dp[i][w] = max(dp[i-1][w], dp[i-1][w-weight] + value) else: dp[i][w] = dp[i-1][w] return dp[n][self.capacity]"},{"question":"# Scenario A telecommunications company wants to analyze call durations to identify long-duration calls and improve their customer support services. The call durations are recorded in an unsorted list, and you need to find all call durations that exceed a certain threshold. Implement the `find_long_duration_calls` function to efficiently filter out and list these long-duration calls. # Task You must implement the `find_long_duration_calls` function to scan through the list of call durations and return a list of durations that exceed the specified threshold. # Specification **Function Signature**: ```python def find_long_duration_calls(call_durations: list[int], threshold: int) -> list[int]: Filters out call durations that exceed a specified threshold. Args: call_durations: list of integers representing the durations of calls in seconds. threshold: integer value of the duration threshold in seconds. Returns: list[int]: A list of call durations that exceed the threshold. ``` # Input * `call_durations` (List[int]): A list of integers representing the durations of calls in seconds. * `threshold` (int): An integer value representing the duration threshold in seconds. # Output * `List[int]`: A list of call durations that exceed the threshold. # Constraints * The list can be of varying lengths, up to (10^5) elements. # Examples ```python assert find_long_duration_calls([120, 300, 150, 600, 90], 200) == [300, 600] assert find_long_duration_calls([30, 20, 10, 40, 50], 30) == [40, 50] assert find_long_duration_calls([500, 400, 100, 600, 700], 550) == [600, 700] assert find_long_duration_calls([10, 20, 30], 100) == [] assert find_long_duration_calls([], 150) == [] ```","solution":"def find_long_duration_calls(call_durations, threshold): Filters out call durations that exceed a specified threshold. Args: call_durations: list of integers representing the durations of calls in seconds. threshold: integer value of the duration threshold in seconds. Returns: list[int]: A list of call durations that exceed the threshold. return [duration for duration in call_durations if duration > threshold]"},{"question":"# Coding Assessment Question Context You are developing an application that manages textual data. One common operation required is to count the frequency of each word in a given text to facilitate search and analysis functions. Problem Statement Implement a Python function named `count_word_frequencies(text: str) -> Dict[str, int]` that takes a string of text as its input and returns a dictionary with the words as keys and their respective frequencies as values. Requirements 1. **Input Format**: - The function will receive a single string `text`, which represents the input text containing words separated by whitespace. 2. **Output Format**: - The function should return a dictionary where each key is a word from the input text and the corresponding value is an integer representing its frequency in the text. 3. **Constraints**: - The input string `text` will contain only alphabetic characters and whitespace, and will be non-empty. - The words in the dictionary should be case-insensitive, treating \'Word\' and \'word\' as the same. 4. **Performance**: - The function should run in linear time, O(n) relative to the length of the input text. 5. **Scenario**: - Validate the function with several test cases to ensure correct word counts, handling edge cases of various text lengths and word distributions. Example Usage ```python >>> count_word_frequencies(\\"Hello world hello\\") {\'hello\': 2, \'world\': 1} >>> count_word_frequencies(\\"Python is great and python is fun\\") {\'python\': 2, \'is\': 2, \'great\': 1, \'and\': 1, \'fun\': 1} >>> count_word_frequencies(\\"This is a test. This is only a test.\\") {\'this\': 2, \'is\': 2, \'a\': 2, \'test.\': 1, \'only\': 1, \'test.\': 1} >>> count_word_frequencies(\\"Count each WORD once, even if the word appears many times\\") {\'count\': 1, \'each\': 1, \'word\': 1, \'once,\': 1, \'even\': 1, \'if\': 1, \'the\': 1, \'appears\': 1, \'many\': 1, \'times\': 1} ``` Implementation Guidelines Ensure that the function handles mixed case words by converting all words to lowercase before counting. Use a suitable data structure to maintain the counts and handle edge cases related to text punctuation and spacing appropriately. The function should produce consistent and correct results for text analysis purposes.","solution":"from typing import Dict import re def count_word_frequencies(text: str) -> Dict[str, int]: Takes a string of text and returns a dictionary with each word and its frequency. Words are considered case-insensitive. # Convert text to lowercase text = text.lower() # Use regex to find words, treating sequences of alphabetic characters as words words = re.findall(r\'b[a-z]+b\', text) # Create a dictionary to hold word frequencies word_frequencies = {} # Count frequencies of each word for word in words: if word in word_frequencies: word_frequencies[word] += 1 else: word_frequencies[word] = 1 return word_frequencies"},{"question":"# Coding Question Scenario In your current project, you are tasked with analyzing digital signals that are represented as sequences of numeric values. To understand the characteristics of these signals, it\'s essential to detect when significant changes or \\"spikes\\" occur. This helps to identify important events or anomalies in the signal. Problem Statement Write a function `detect_spikes` that identifies the positions (indices) of significant spikes in a given list of signal values. A spike is defined as a point in the signal that is greater than its immediate neighbors by at least a given threshold. The function should return a list of indices where spikes occur. Implementation - `detect_spikes` should accept: - A list of floats `signal` representing the signal values. - A float `threshold` that defines the minimum difference a value must have compared to its neighbors to be considered a spike. - The function should return a list of integers representing the indices of the spikes within the signal. Input - `signal`: A list of float values (list of floats) - `threshold`: Minimum difference for a spike (float) Output - A list of integers representing indices of detected spikes Constraints - The `signal` list will contain between 3 to 10,000 floats. - The `threshold` will be between 0.1 and 100.0. Example ```python def detect_spikes(signal, threshold): # implementation here signal = [0.2, 0.7, 0.1, 5, 0.3, 2.1, 0.1] threshold = 1.0 # Detect spikes print(detect_spikes(signal, threshold)) # Output should be [3, 5] ``` In this example, the function identifies spikes at indices 3 and 5, because the values at these indices exceed their immediate neighbors by at least 1.0. Ensure your implementation efficiently handles varying signal lengths and thresholds, and properly detects spikes according to the defined criteria.","solution":"def detect_spikes(signal, threshold): Detects the indices of spikes in a given signal. A spike is defined as a point that is greater than its immediate neighbors by at least the given threshold. :param signal: List of float values representing the signal :param threshold: Minimum difference a value must have compared to its neighbors to be considered a spike :return: List of integers representing indices of detected spikes spikes = [] for i in range(1, len(signal) - 1): if (signal[i] - signal[i - 1] >= threshold) and (signal[i] - signal[i + 1] >= threshold): spikes.append(i) return spikes"},{"question":"# Question: Missing Number in Sequence Given a list of unique positive integers representing a sequence that starts from 1 up to `n`, except that it is missing exactly one number, implement a function `find_missing_number(nums: List[int]) -> int` that finds and returns the missing number. Function Signature: ```python def find_missing_number(nums: List[int]) -> int: pass ``` # Input: * A list `nums` of unique integers where `1 <= len(nums) <= 10^5` and `1 <= nums[i] <= 10^5`. # Output: * An integer representing the missing number from the sequence. # Constraints: * The list will have exactly one number missing from an otherwise consecutive sequence starting at 1. * Your function should work efficiently even for the upper limits of the input size. # Example: ```python assert find_missing_number([1, 2, 4, 5, 6]) == 3 assert find_missing_number([2, 3, 4, 6, 1, 5, 7, 9, 10, 8]) == 11 assert find_missing_number([1, 3]) == 2 assert find_missing_number([1, 2]) == 3 ``` # Performance Requirements: * The function must run in O(n) time complexity where n is the length of the input list. **Hint**: Consider using arithmetic properties to find the missing number efficiently. # Scenario: Imagine you are responsible for a data validation system where you need to ensure that all records are sequentially numbered. A common challenge is detecting a single missing entry in these sequences. Your function will be integral to quickly identifying the missing number in large datasets to maintain data integrity. Test and ensure your function efficiently handles the maximum input size.","solution":"from typing import List def find_missing_number(nums: List[int]) -> int: Returns the missing number in the sequence from 1 to n. n = len(nums) + 1 expected_sum = n * (n + 1) // 2 actual_sum = sum(nums) return expected_sum - actual_sum"},{"question":"# Meeting Scheduler You need to implement a function that finds all possible meeting time slots from a list of participants\' availability. Each participant provides a list of their available time slots, and you need to determine the slots where all participants are available for a meeting. Each time slot is represented as a string in the format \\"HH:MM-HH:MM\\", where \\"HH:MM\\" represents a 24-hour time. You must write a function `find_common_slots(participants: List[List[str]]) -> List[str]` that takes a list of participants\' available time slots and returns a list of common time slots in the same format, sorted in ascending order. # Function Signature ```python def find_common_slots(participants: List[List[str]]) -> List[str]: pass ``` # Input - `participants`: A list of lists, where each inner list contains strings representing the available time slots of a participant. Each availability is a string in \\"HH:MM-HH:MM\\" format. # Output - A list of strings representing the common available time slots among all participants in \\"HH:MM-HH:MM\\" format, sorted in ascending order by start time. # Examples ```python participants = [ [\\"09:00-10:00\\", \\"10:30-12:00\\", \\"14:00-16:00\\"], [\\"09:30-10:30\\", \\"11:30-12:30\\", \\"14:00-15:00\\"], [\\"08:00-09:00\\", \\"10:00-11:00\\", \\"14:00-15:30\\"] ] print(find_common_slots(participants)) # Expected output: [\\"14:00-15:00\\"] participants = [ [\\"08:00-09:00\\", \\"12:00-13:00\\", \\"15:00-16:00\\"], [\\"08:30-09:30\\", \\"11:00-12:30\\", \\"14:30-15:30\\"], [\\"09:00-10:00\\", \\"12:30-13:30\\", \\"14:00-15:00\\"] ] print(find_common_slots(participants)) # Expected output: [] ``` # Constraints - You can assume input time slots are valid and properly formatted. - You may need to handle edge cases, such as non-overlapping time slots or participants with no available slots. - The solution should be optimized to handle up to 100 participants with up to 50 time slots each. # Notes - Ensure that you check overlapping time slots correctly and handle edge cases where slots touch but do not overlap. - Consider converting time formats into minutes for easier comparison, then convert back to the \\"HH:MM\\" format for the output.","solution":"from typing import List def time_to_minutes(time: str) -> int: Convert time in \\"HH:MM\\" format to minutes since 00:00. hours, minutes = map(int, time.split(\\":\\")) return hours * 60 + minutes def minutes_to_time(minutes: int) -> str: Convert minutes since 00:00 to time in \\"HH:MM\\" format. hours = minutes // 60 minutes = minutes % 60 return f\\"{hours:02}:{minutes:02}\\" def find_common_slots(participants: List[List[str]]) -> List[str]: Find common time slots among all participants. if not participants: return [] # Convert all time slots to (start_in_minutes, end_in_minutes) availability = [] for times in participants: person_slots = [] for time_slot in times: start, end = time_slot.split(\'-\') start_minutes = time_to_minutes(start) end_minutes = time_to_minutes(end) person_slots.append((start_minutes, end_minutes)) availability.append(person_slots) # Sort each participant\'s slots by start time for slots in availability: slots.sort() # Initialize common slots with the first participant\'s slots common_slots = availability[0] for participant_slots in availability[1:]: new_common_slots = [] i, j = 0, 0 while i < len(common_slots) and j < len(participant_slots): start1, end1 = common_slots[i] start2, end2 = participant_slots[j] # Find overlap between two slots start_overlap = max(start1, start2) end_overlap = min(end1, end2) if start_overlap < end_overlap: new_common_slots.append((start_overlap, end_overlap)) # Move to next slot if end1 <= end2: i += 1 else: j += 1 common_slots = new_common_slots if not common_slots: break # Convert common slots back to \\"HH:MM-HH:MM\\" format return [f\\"{minutes_to_time(start)}-{minutes_to_time(end)}\\" for start, end in common_slots]"},{"question":"Python Function Decorator Enhancement Context: You are a developer working on a Python project that involves applying enhancements to existing functions using decorators. Decorators provide a way to modify the behavior of a function or method. Your task is to create a versatile decorator that logs function calls and handles exceptions gracefully. Task: Develop a decorator that can be applied to any function. This decorator should log the function name, arguments, and return value every time the function is called. Additionally, if the function raises an exception, the decorator should catch it, log an error message with the exception details, and re-raise the exception to ensure the program\'s normal error-handling mechanisms can proceed. Input: - A function to which the decorator is applied. Output: - Logs of function calls, arguments, return values, and exceptions, if any, using the `logging` module. Constraints: - The decorator should work with any function regardless of the number or type of its arguments. - Log messages must be formatted in the following way: - Function called: `<function_name>(<argument_list>)` - Return value: `Returned: <return_value>` - Exception raised: `Exception in <function_name>: <exception_message>` Function Signature: ```python import logging def log_and_handle_exceptions(func): def wrapper(*args, **kwargs): # Implementation return wrapper ``` Example Usage: ```python import logging # Set up logging configuration logging.basicConfig(level=logging.INFO) @log_and_handle_exceptions def divide(a, b): return a / b @log_and_handle_exceptions def greet(name): if not name: raise ValueError(\\"Name cannot be empty!\\") return f\\"Hello, {name}!\\" # Examples of using the decorated functions divide(10, 2) # Log output: INFO:root:Function called: divide(10, 2) # Log output: INFO:root:Returned: 5.0 try: divide(10, 0) except ZeroDivisionError: pass # Log output: INFO:root:Function called: divide(10, 0) # Log output: ERROR:root:Exception in divide: division by zero greet(\\"Alice\\") # Log output: INFO:root:Function called: greet(\'Alice\',) # Log output: INFO:root:Returned: Hello, Alice! try: greet(\\"\\") except ValueError: pass # Log output: INFO:root:Function called: greet(\'\',) # Log output: ERROR:root:Exception in greet: Name cannot be empty! ``` Note: - In the first example, the `divide` function is called with 10 and 2 as arguments, and the result is logged. - In the second example, the `divide` function is called with 10 and 0, causing a `ZeroDivisionError` that is logged. - In the third example, the `greet` function is called with \\"Alice\\", and the return value is logged. - In the fourth example, the `greet` function is called with an empty string, causing a `ValueError` that is logged.","solution":"import logging def log_and_handle_exceptions(func): def wrapper(*args, **kwargs): func_name = func.__name__ logging.info(f\\"Function called: {func_name}({\', \'.join(map(repr, args))})\\") try: result = func(*args, **kwargs) logging.info(f\\"Returned: {repr(result)}\\") return result except Exception as e: logging.error(f\\"Exception in {func_name}: {str(e)}\\") raise return wrapper # Example functions to demonstrate the decorator @log_and_handle_exceptions def divide(a, b): return a / b @log_and_handle_exceptions def greet(name): if not name: raise ValueError(\\"Name cannot be empty!\\") return f\\"Hello, {name}!\\""},{"question":"# Calculate the Nearest Distance Between Two Points in a List Scenario: You are given a list of `n` points in a 2D plane, where each point is represented by its x and y coordinates. Your task is to write a function that finds the smallest Euclidean distance between any two distinct points in the list. This is useful in various fields such as computational geometry, clustering analysis, and optimization problems. Task: Write a function `nearest_distance(points: List[Tuple[int, int]]) -> float` that: 1. Accepts a list of points where each point is represented as a tuple of two integers (x, y). 2. Computes the smallest Euclidean distance between any two distinct points in the list. 3. Returns the smallest distance as a floating-point number. Requirements: * Implement the function using an efficient algorithm that can handle large lists of points. * Ensure the function addresses edge cases such as an empty list or a list with only one point. * Use appropriate data structures to ensure optimal performance. Input: * `points` (List[Tuple[int, int]]): A list of tuples of integers where each tuple represents a point in 2D space. Output: * A floating-point number representing the smallest Euclidean distance between any two points in the list. Constraints: * The list will not contain duplicate points. * The list can contain up to 10^5 points. Example: ```python nearest_distance([(0, 0), (3, 4), (1, 1), (2, 2)]) ``` This will return `1.4142135623730951` which is the distance between the points `(1, 1)` and `(2, 2)`.","solution":"from typing import List, Tuple import math def nearest_distance(points: List[Tuple[int, int]]) -> float: Finds the smallest Euclidean distance between any two points in the list. def euclidean_distance(p1: Tuple[int, int], p2: Tuple[int, int]) -> float: return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) n = len(points) if n < 2: return float(\'inf\') points.sort() def closest_pair(ax): L = len(ax) if L <= 3: return min( [euclidean_distance(ax[i], ax[j]) for i in range(L) for j in range(i + 1, L)], default=float(\'inf\') ) mid = L // 2 midpoint = ax[mid] dl = closest_pair(ax[:mid]) dr = closest_pair(ax[mid:]) d = min(dl, dr) strip = [p for p in ax if abs(p[0] - midpoint[0]) < d] strip.sort(key=lambda x: x[1]) size = len(strip) for i in range(size): for j in range(i + 1, size): if (strip[j][1] - strip[i][1]) >= d: break d = min(d, euclidean_distance(strip[i], strip[j])) return d return closest_pair(points)"},{"question":"# Coding Assessment Question In software development, it is often necessary to ensure that user input adheres to a certain format, especially when dealing with dates. Your task is to implement a function that validates and reformats date strings given in various common formats to a standardized format, `YYYY-MM-DD`. **Function Specification:** Implement the function `reformat_date` that takes a string representing a date and returns a string of the date in the format `YYYY-MM-DD`. ```python def reformat_date(date_str: str) -> str: pass ``` # Input - `date_str` (string): A date represented as a string. The format may vary. # Output - Returns a string representing the date in `YYYY-MM-DD` format. # Constraints - The input date string can be in one of the following formats: - `MM/DD/YYYY` - `DD-MM-YYYY` - `YYYY.MM.DD` - You can assume the input string will always be a valid date in one of the specified formats. - The function should detect the format and reformat it to `YYYY-MM-DD`. # Requirements - Handle each format correctly and avoid hardcoding conversions. - The solution should efficiently handle the different date formats provided. # Functionality Tests Ensure your function passes the following test cases: ```python >>> reformat_date(\\"12/31/2022\\") \'2022-12-31\' >>> reformat_date(\\"25-12-2021\\") \'2021-12-25\' >>> reformat_date(\\"1992.04.15\\") \'1992-04-15\' >>> reformat_date(\\"07/04/2020\\") \'2020-07-04\' >>> reformat_date(\\"01-01-2019\\") \'2019-01-01\' ``` # Scenario Consider a situation where you are developing a scheduling application that accepts user input for event dates. Since users might enter dates in various formats, the system needs to standardize the date format to `YYYY-MM-DD` for consistent data handling, storage, and processing. Utilize the `reformat_date` function to ensure all date inputs are converted and stored in the consistent `{year}-{month}-{day}` format.","solution":"def reformat_date(date_str: str) -> str: if \'/\' in date_str: # MM/DD/YYYY format parts = date_str.split(\'/\') return f\\"{parts[2]}-{parts[0]:0>2}-{parts[1]:0>2}\\" elif \'-\' in date_str: # DD-MM-YYYY format parts = date_str.split(\'-\') return f\\"{parts[2]}-{parts[1]:0>2}-{parts[0]:0>2}\\" elif \'.\' in date_str: # YYYY.MM.DD format parts = date_str.split(\'.\') return f\\"{parts[0]}-{parts[1]:0>2}-{parts[2]:0>2}\\""},{"question":"# Problem Statement You have been given a string containing a series of integers separated by spaces, where the integers represent stock prices recorded sequentially throughout a day. Your task is to write a function that calculates the maximum profit that can be achieved by buying and selling the stock at most twice during the given day. The transactions must be completed in order (a sell operation must follow a buy operation, and each buy-sell pair is independent). # Function Signature ```python def max_profit_twice(prices: str) -> int: pass ``` # Input - `prices`: A string of space-separated integers, where each integer is a stock price recorded during a single day. The string is non-empty and contains at least two integers. # Output - An integer representing the maximum profit that could be obtained with up to two buy-sell operations. # Constraints - Each integer price is a positive number between 0 and 10^4. - It is guaranteed that the string contains at least two integers. - The function should have a time complexity of O(n), where n is the number of prices. # Examples ```python >>> max_profit_twice(\\"3 3 5 0 0 3 1 4\\") 6 >>> max_profit_twice(\\"1 2 3 4 5\\") 4 >>> max_profit_twice(\\"7 6 4 3 1\\") 0 >>> max_profit_twice(\\"2 1 2 0 1\\") 2 >>> max_profit_twice(\\"1 2 4 2 5 7 2 4 9 0\\") 13 ``` # Notes - In the first example, the maximum profit is achieved by buying on day 4 (price 0) and selling on day 7 (price 4), making a profit of 4. After that, we buy again on day 6 (price 1) and sell on day 7 (price 4), making an additional profit of 3. The total profit is 4 + 3 = 7. - In the second example, one would buy on day 1 (price 1) and sell on day 5 (price 5), making a profit of 4. - In the third example, there is no opportunity for profit as the prices only decrease.","solution":"def max_profit_twice(prices: str) -> int: prices_list = list(map(int, prices.split())) n = len(prices_list) if n < 2: return 0 # Step 1: Create profit array where profit[i] stores the maximum profit using # at most one transaction from day 0 to day i. profit = [0] * n min_price = prices_list[0] for i in range(1, n): profit[i] = max(profit[i - 1], prices_list[i] - min_price) min_price = min(min_price, prices_list[i]) # Step 2: Traverse the list from end to start to find the maximum profit # with two transactions max_price = prices_list[-1] max_profit = profit[-1] for i in range(n - 2, -1, -1): max_profit = max(max_profit, max_price - prices_list[i] + profit[i]) max_price = max(max_price, prices_list[i]) return max_profit"},{"question":"# Algorithmic String Reversal Tool Objective Implement a function `reverseWords` that takes a string as input, reverses the order of words in it, and returns the string with the words in reverse order. Expected Input and Output Formats * **Input**: * A string `sentence` which includes words separated by one or more spaces. * **Output**: * A newly formatted string where the words appear in reverse order compared to the input, separated by a single space. Constraints and Limitations * Words in the input string are defined as sequences of characters separated by one or more spaces. * The input string can contain leading or trailing spaces, which should be removed in the output. * Only printable ASCII characters will appear in the input string. * Maintain the order of words strictly in reverse, and ensure no extra spaces appear in the output. * Minimal length of input string is 1 and maximum length is 1000 characters. Performance Requirements * The function should efficiently handle the maximum length of the input string. * Ensure that the function runs in linear time relative to the input size. Scenario You are working on a text processing application which includes a feature to reverse the order of words in a given sentence. This feature is intended to be used in various text formatting contexts. Implement the `reverseWords` function to achieve this functionality. ```python def reverseWords(sentence: str) -> str: Reverses the order of words in a given sentence. Args: sentence (str): A string containing words separated by one or more spaces. Returns: str: A new string with words in reverse order, separated by a single space. Example: >>> reverseWords(\\" Hello World from OpenAI \\") \'OpenAI from World Hello\' words = sentence.split() reversed_words = words[::-1] return \' \'.join(reversed_words) if __name__ == \\"__main__\\": import doctest doctest.testmod() ```","solution":"def reverseWords(sentence: str) -> str: Reverses the order of words in a given sentence. Args: sentence (str): A string containing words separated by one or more spaces. Returns: str: A new string with words in reverse order, separated by a single space. Example: >>> reverseWords(\\" Hello World from OpenAI \\") \'OpenAI from World Hello\' words = sentence.split() reversed_words = words[::-1] return \' \'.join(reversed_words)"},{"question":"# Coding Assessment Question Context: In many applications, efficiently finding the shortest path between two points in a graph is essential. One common scenario for this is in mapping software that provides directions from one location to another. Task: Write a function `shortest_path(graph, start, target)` that finds the shortest path from the `start` node to the `target` node in a weighted, undirected graph using Dijkstra\'s algorithm. Requirements: 1. Implement a function `shortest_path(graph: dict, start: str, target: str) -> list`. 2. The function should: - Raise a `ValueError` if the `graph` is empty, or if `start` or `target` nodes are not present in the graph. 3. The solution should return the shortest path as a list of nodes from the `start` node to the `target` node. Input: - `graph` (dict): A dictionary representation of the graph where keys are node names and values are dictionaries of neighbors with edge weights. - For example: ```python { \'A\': {\'B\': 1, \'C\': 4}, \'B\': {\'A\': 1, \'C\': 2, \'D\': 5}, \'C\': {\'A\': 4, \'B\': 2, \'D\': 1}, \'D\': {\'B\': 5, \'C\': 1} } ``` - `start` (str): The starting node. - `target` (str): The destination node. Output: - Returns a list of nodes representing the shortest path from `start` to `target`. Constraints: - The graph is connected, meaning there is at least one path between any two nodes. - All edge weights are positive integers. Performance Expectations: - Expected time complexity is (O((V+E) log V)), where (V) is the number of vertices and (E) is the number of edges. Example: ```python graph = { \'A\': {\'B\': 1, \'C\': 4}, \'B\': {\'A\': 1, \'C\': 2, \'D\': 5}, \'C\': {\'A\': 4, \'B\': 2, \'D\': 1}, \'D\': {\'B\': 5, \'C\': 1} } >>> shortest_path(graph, \'A\', \'D\') [\'A\', \'B\', \'C\', \'D\'] >>> shortest_path(graph, \'A\', \'C\') [\'A\', \'B\', \'C\'] >>> shortest_path(graph, \'B\', \'D\') [\'B\', \'C\', \'D\'] >>> shortest_path(graph, \'C\', \'A\') [\'C\', \'B\', \'A\'] ``` Edge Cases: - If the `start` or `target` node is the same, the function should return a list containing only that node. - If the graph is empty, a `ValueError` should be raised.","solution":"import heapq def shortest_path(graph, start, target): Finds the shortest path from start to target in a weighted, undirected graph using Dijkstra\'s algorithm. if not graph: raise ValueError(\\"Graph is empty\\") if start not in graph or target not in graph: raise ValueError(\\"Start or target node is not in the graph\\") # Priority queue to hold nodes to be processed, initialized with the start node pq = [(0, start)] # (distance, node) distances = {node: float(\'inf\') for node in graph} distances[start] = 0 # To reconstruct the path previous_nodes = {node: None for node in graph} while pq: current_distance, current_node = heapq.heappop(pq) if current_node == target: break # We have reached the target node for neighbor, weight in graph[current_node].items(): distance = current_distance + weight # Only consider this new path if it\'s better if distance < distances[neighbor]: distances[neighbor] = distance previous_nodes[neighbor] = current_node heapq.heappush(pq, (distance, neighbor)) # Reconstruct the shortest path path = [] current = target while current is not None: path.append(current) current = previous_nodes[current] if path[-1] != start: return [] # If no valid path is found path.reverse() return path"},{"question":"# Fibonacci Sequence Visualization Context The Fibonacci sequence is a series of numbers where each number is the sum of the two preceding ones, usually starting with 0 and 1. This task involves visualizing parts of the Fibonacci sequence using Python\'s `matplotlib` for plotting. This will test your understanding of recursion, sequence generation, and graphical plotting. Task Write a function `plot_fibonacci_sequence(n: int) -> None` that uses Python\'s `matplotlib` to plot the first `n` values of the Fibonacci sequence. Specifications 1. **Input**: * `n` (int): The number of terms in the Fibonacci sequence to plot, where `n > 0`. 2. **Output**: * The function should display a plot of the first `n` Fibonacci numbers on a graph. 3. **Constraints**: * Use Python\'s `matplotlib` library for plotting. * Ensure your function handles potential performance bottlenecks for large `n`. Requirements 1. **Function Definition**: * Define the function within a Python module to be run as a script. * Handle incorrect inputs gracefully (e.g., a non-positive `n`). 2. **Behavior**: * Compute the Fibonacci numbers either iteratively or recursively. * Plot the sequence values on a graph, with the x-axis representing the position in the sequence and the y-axis representing the Fibonacci numbers. Example ```python import matplotlib.pyplot as plt def plot_fibonacci_sequence(n: int) -> None: if n <= 0: raise ValueError(\\"n should be a positive integer\\") def generate_fibonacci(n): fib_sequence = [0, 1] for _ in range(2, n): fib_sequence.append(fib_sequence[-1] + fib_sequence[-2]) return fib_sequence[:n] fibonacci_numbers = generate_fibonacci(n) plt.plot(range(1, n + 1), fibonacci_numbers, marker=\'o\') plt.title(f\\"Fibonacci Sequence (first {n} terms)\\") plt.xlabel(\'Position in sequence\') plt.ylabel(\'Fibonacci number\') plt.grid(True) plt.show() # Run the function with a given n if __name__ == \\"__main__\\": import sys if len(sys.argv) != 2: print(\\"Usage: python script.py <n>\\") else: try: n = int(sys.argv[1]) plot_fibonacci_sequence(n) except ValueError: print(\\"n should be an integer.\\") ```","solution":"import matplotlib.pyplot as plt def plot_fibonacci_sequence(n: int) -> None: if n <= 0: raise ValueError(\\"n should be a positive integer\\") def generate_fibonacci(n): if n == 1: return [0] elif n == 2: return [0, 1] fib_sequence = [0, 1] for _ in range(2, n): fib_sequence.append(fib_sequence[-1] + fib_sequence[-2]) return fib_sequence fibonacci_numbers = generate_fibonacci(n) plt.plot(range(1, n + 1), fibonacci_numbers, marker=\'o\') plt.title(f\\"Fibonacci Sequence (first {n} terms)\\") plt.xlabel(\'Position in sequence\') plt.ylabel(\'Fibonacci number\') plt.grid(True) plt.show() # Run the function if this module is run directly if __name__ == \\"__main__\\": import sys if len(sys.argv) != 2: print(\\"Usage: python script.py <n>\\") else: try: n = int(sys.argv[1]) plot_fibonacci_sequence(n) except ValueError as e: print(e)"},{"question":"# Temperature Data Analyzer **Objective**: Implement a function to analyze temperature data for a given city, fetching details from a hypothetical weather API and calculating the average temperature over a specified number of days. **Scenario**: In a project designed to monitor and report weather patterns, integrate with a provided weather API to fetch temperature data for a city and compute average temperature over a certain period. Ensure the implementation is robust and handles various edge cases effectively. **Requirements**: - Define a function `fetch_average_temperature(city: str, days: int, api_key: str) -> dict` that: - Takes the city name (string), the number of days (integer), and the weather API key (string). - Returns a dictionary with two keys: `\\"success\\"` (boolean) and `\\"data\\"` (average temperature over the specified days on success or an error message on failure). - Handle empty city names by returning an appropriate message. - Handle invalid days (non-positive integers) by returning an error message. - Handle network errors or invalid API responses gracefully. - If no temperature data is found for a given city, return an appropriate message. **Function Signature**: ```python def fetch_average_temperature(city: str, days: int, api_key: str) -> dict: pass ``` **Constraints**: - The API key provided is valid. - The city name is a non-empty string with a maximum length of 100. - The number of days is a positive integer not exceeding 30. **Examples**: 1. `fetch_average_temperature(\\"New York\\", 7, \\"YOUR API KEY\\")` - Might return: ```python { \\"success\\": True, \\"data\\": 15.5 # example average temperature } ``` 2. `fetch_average_temperature(\\"\\", 5, \\"YOUR API KEY\\")` - Should return: ```python { \\"success\\": False, \\"data\\": \\"City name cannot be empty.\\" } ``` 3. `fetch_average_temperature(\\"New York\\", -3, \\"YOUR API KEY\\")` - Should return: ```python { \\"success\\": False, \\"data\\": \\"Number of days must be a positive integer.\\" } ``` 4. On network failure: - Should return: ```python { \\"success\\": False, \\"data\\": \\"Network error occurred while fetching temperature data.\\" } ``` 5. `fetch_average_temperature(\\"Unknown City\\", 5, \\"YOUR API KEY\\")` - Should return: ```python { \\"success\\": False, \\"data\\": \\"No temperature data found for the given city.\\" } ```","solution":"import requests def fetch_average_temperature(city: str, days: int, api_key: str) -> dict: if not city: return {\\"success\\": False, \\"data\\": \\"City name cannot be empty.\\"} if days <= 0: return {\\"success\\": False, \\"data\\": \\"Number of days must be a positive integer.\\"} url = f\\"https://api.weatherapi.com/v1/history.json?key={api_key}&q={city}&days={days}\\" try: response = requests.get(url) response.raise_for_status() data = response.json() if \'error\' in data: return {\\"success\\": False, \\"data\\": data[\'error\'][\'message\']} temperatures = [day[\'day\'][\'avgtemp_c\'] for day in data[\'forecast\'][\'forecastday\']] if not temperatures: return {\\"success\\": False, \\"data\\": \\"No temperature data found for the given city.\\"} average_temperature = sum(temperatures) / len(temperatures) return {\\"success\\": True, \\"data\\": average_temperature} except requests.RequestException: return {\\"success\\": False, \\"data\\": \\"Network error occurred while fetching temperature data.\\"}"},{"question":"# Circular Singly Linked List Operations You are provided with a class `CircularSinglyLinkedList` that represents a circular singly linked list. Your task is to extend the functionality of this class to add the following features: 1. **Insert Node at a Specific Position**: * Implement a method `insert_at_position(data, position)` that inserts a new node with the given data at the specified position (0-based index). * If the position is 0, the new node should become the new head of the list. * If the position is greater than the length of the list, append the node to the end of the list. 2. **Delete Node by Value**: * Implement a method `delete_by_value(data)` that removes the first node in the list with the given data. * If the node to be deleted is the head, update the head accordingly. * If the node is not found, the list should remain unchanged. **Input**: - For the `insert_at_position` method: An integer `data` to insert and an integer `position` specifying the position to insert at. - For the `delete_by_value` method: An integer `data` specifying the value of the node to delete. **Output**: - For the `insert_at_position` method: A boolean indicating success or failure of the insertion. - For the `delete_by_value` method: A boolean indicating success or failure of the deletion. **Performance Requirements**: - The `insert_at_position` method should maintain O(n) time complexity, where n is the number of nodes in the list. - The `delete_by_value` method should maintain O(n) time complexity, where n is the number of nodes in the list. - Ensure the methods handle edge cases like an empty list, insertion at the head, deleting the head node, and deleting the last node. **Constraints**: - The linked list can contain any number of nodes, including zero. - Node values can be any integer. - Position values will always be non-negative. **Example Usage**: ```python circular_list = CircularSinglyLinkedList() # Insert Nodes circular_list.insert_at_position(10, 0) # Insert 10 at position 0 (head) circular_list.insert_at_position(20, 1) # Insert 20 at position 1 (end) circular_list.insert_at_position(5, 0) # Insert 5 at position 0 (new head) circular_list.insert_at_position(15, 2) # Insert 15 at position 2 (middle) # Delete Nodes circular_list.delete_by_value(5) # Delete the node with value 5 (head) circular_list.delete_by_value(20) # Delete the node with value 20 (end) circular_list.delete_by_value(99) # Try to delete the node with value 99 (not found) # Display the list elements (you may need to implement this method for testing) circular_list.display() # Should output the current state of the list for verification ``` Write the enhanced class `CircularSinglyLinkedList` with the specified improvements.","solution":"class Node: def __init__(self, data): self.data = data self.next = None class CircularSinglyLinkedList: def __init__(self): self.head = None def insert_at_position(self, data, position): new_node = Node(data) if self.head is None: new_node.next = new_node self.head = new_node return True if position == 0: new_node.next = self.head temp = self.head while temp.next != self.head: temp = temp.next temp.next = new_node self.head = new_node return True temp = self.head index = 0 while index < position - 1 and temp.next != self.head: temp = temp.next index += 1 if index == position - 1: new_node.next = temp.next temp.next = new_node return True if temp.next == self.head: new_node.next = self.head temp.next = new_node return True return False def delete_by_value(self, data): if self.head is None: return False temp = self.head prev = None while True: if temp.data == data: if prev is None: # Node to delete is the head if temp.next == self.head: # Only one node self.head = None return True last_node = self.head while last_node.next != self.head: last_node = last_node.next last_node.next = self.head.next self.head = self.head.next return True prev.next = temp.next return True prev = temp temp = temp.next if temp == self.head: break return False def display(self): nodes = [] if self.head is None: print(nodes) return temp = self.head while True: nodes.append(temp.data) temp = temp.next if temp == self.head: break print(nodes)"},{"question":"# Problem Statement: Considering the properties of a Sphere, write a function in the programming language of your choice to calculate the Great Circle Distance between two points on the surface of the sphere given their latitude and longitude. # Requirements: 1. Implement the following function: - `great_circle_distance(lat1: float, lon1: float, lat2: float, lon2: float, radius: float) -> float` 2. The function should: - Calculate and return the great circle distance between the two points on the sphere\'s surface. - Raise a `ValueError` if any latitude is not within the range [-90, 90] or any longitude is not within the range [-180, 180]. - Raise a `ValueError` if the radius is non-positive with the message \\"Radius must be a positive value.\\" # Input: - Five float values representing the latitude and longitude of the two points (in degrees) and the radius of the sphere. # Output: - A float representing the great circle distance between the two points on the sphere. # Constraints: - Latitude must be a float between -90 and 90 inclusive. - Longitude must be a float between -180 and 180 inclusive. - Radius must be a positive float. # Example: ```plaintext great_circle_distance(36.12, -86.67, 33.94, -118.40, 6371) Expected Output: 2887.26 (approx) great_circle_distance(-91, 0, 0, 0, 6371) Expected Output: Raises ValueError with message \\"Latitude must be within the range of -90 to 90.\\" great_circle_distance(0, 0, 0, 0, -1) Expected Output: Raises ValueError with message \\"Radius must be a positive value.\\" ``` # Notes: - Use the Haversine formula to compute the great circle distance. - Ensure precision in the trigonometric calculations. - Document your code clearly, especially the mathematical operations. - Make sure to include error checks and raise appropriate exceptions as specified.","solution":"import math def great_circle_distance(lat1: float, lon1: float, lat2: float, lon2: float, radius: float) -> float: Function to calculate the Great Circle Distance between two points on a sphere given their latitude and longitude. Parameters: - lat1, lon1: Latitude and Longitude of the first point. - lat2, lon2: Latitude and Longitude of the second point. - radius: Radius of the sphere. Returns: - Great Circle Distance as a float. Raises: - ValueError if latitude or longitude are out of the specified range or if radius is non-positive. # Validate latitude and longitude if not (-90 <= lat1 <= 90): raise ValueError(\\"Latitude must be within the range of -90 to 90.\\") if not (-90 <= lat2 <= 90): raise ValueError(\\"Latitude must be within the range of -90 to 90.\\") if not (-180 <= lon1 <= 180): raise ValueError(\\"Longitude must be within the range of -180 to 180.\\") if not (-180 <= lon2 <= 180): raise ValueError(\\"Longitude must be within the range of -180 to 180.\\") # Validate radius if radius <= 0: raise ValueError(\\"Radius must be a positive value.\\") # Convert degrees to radians lat1, lon1, lat2, lon2 = map(math.radians, [lat1, lon1, lat2, lon2]) # Haversine formula dlat = lat2 - lat1 dlon = lon2 - lon1 a = math.sin(dlat / 2)**2 + math.cos(lat1) * math.cos(lat2) * math.sin(dlon / 2)**2 c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a)) # Distance in the same units as radius distance = radius * c return distance"},{"question":"# Coding Question Context You are developing software for a financial institution that needs to predict future account balances based on a series of transactions and an initial balance. The transactions include deposits, withdrawals, and transfers. However, the software library you have only supports processing transactions one at a time. Your task is to write a new function that can take in a list of transactions and compute the final balance after all transactions have been processed. Task Write a function `predict_balance(initial_balance: float, transactions: List[Dict]) -> float` where `initial_balance` is the starting amount in the account and `transactions` is a list of dictionaries. Each dictionary requires the keys: \\"type\\", \\"amount\\", and \\"target\\". The type can be \'deposit\', \'withdraw\', or \'transfer\'. For \'transfer\', the function should deduct the amount from one account and add it to another. # Function Signature ```python from typing import List, Dict def predict_balance(initial_balance: float, transactions: List[Dict]) -> float: pass ``` # Input - `initial_balance`: A floating-point number representing the starting balance. - `transactions`: A list of dictionaries with the following structure: - `type`: A string specifying the transaction type (\'deposit\', \'withdraw\', or \'transfer\'). - `amount`: A floating-point number representing the transaction amount. - `target`: (optional, string) The target account for a \'transfer\' type. # Output - A floating-point number representing the final balance after processing all transactions. # Constraints - 0 ≤ initial_balance ≤ 10^6 - 1 ≤ len(transactions) ≤ 10^3 - 0 ≤ amount ≤ 10^6 - The target account for \'transfer\' type transactions will always be valid and the amount will always be positive. # Example ```python initial_balance = 1000.0 transactions = [ {\\"type\\": \\"deposit\\", \\"amount\\": 100.0}, {\\"type\\": \\"withdraw\\", \\"amount\\": 50.0}, {\\"type\\": \\"transfer\\", \\"amount\\": 200.0, \\"target\\": \\"savings\\"} ] output = predict_balance(initial_balance, transactions) print(output) # Output should be 850.0 ``` The function `predict_balance` should compute the final balance considering all transactions, including the effects of transfers.","solution":"from typing import List, Dict def predict_balance(initial_balance: float, transactions: List[Dict]) -> float: balance = initial_balance for transaction in transactions: if transaction[\\"type\\"] == \\"deposit\\": balance += transaction[\\"amount\\"] elif transaction[\\"type\\"] == \\"withdraw\\": balance -= transaction[\\"amount\\"] elif transaction[\\"type\\"] == \\"transfer\\": balance -= transaction[\\"amount\\"] # Transfer amount does not affect final balance of the account as it\'s deducted and added back in reality return balance"},{"question":"# Element Frequency Counter Scenario Counting the frequency of each element in a list is a common task in data processing and analysis. You need to write a function that takes a list of elements (which can be integers or strings) and returns a dictionary where each key is an element from the list, and its corresponding value is the number of times that element appears in the list. Function Signature ```python def element_frequency(lst: list) -> dict: Given a list of elements (integers or strings), returns a dictionary where each key is an element from the list and the corresponding value is the count of that element\'s occurrences in the list. Raises a TypeError if the input is not a list, or if the list contains elements that are neither integers nor strings. Parameters: lst (list): A list of elements (integers or strings). Returns: dict: A dictionary with elements as keys and their frequency as values. Example: >>> element_frequency([1, 2, 2, 3, \'a\', \'a\', \'b\']) {1: 1, 2: 2, 3: 1, \'a\': 2, \'b\': 1} >>> element_frequency([\'apple\', \'banana\', \'apple\']) {\'apple\': 2, \'banana\': 1} Constraints: * The input list can contain a maximum of 10^5 elements. * Elements in the list can either be integers or strings. ``` Requirements 1. The function should ensure the input is a list and raise a `TypeError` with the message \\"Input must be a list\\" if this condition is not met. 2. The function should ensure all elements in the list are either integers or strings. Raise a `TypeError` with the message \\"List elements must be integers or strings\\" if this condition is not met. 3. The implementation must efficiently count the frequency of each element, leveraging appropriate data structures for counting like dictionaries. 4. The function should handle different list lengths, including edge cases such as empty lists or lists with a single identical element.","solution":"def element_frequency(lst): Given a list of elements (integers or strings), returns a dictionary where each key is an element from the list and the corresponding value is the count of that element\'s occurrences in the list. Parameters: lst (list): A list of elements (integers or strings). Returns: dict: A dictionary with elements as keys and their frequency as values. if not isinstance(lst, list): raise TypeError(\\"Input must be a list\\") frequency = {} for elem in lst: if not isinstance(elem, (int, str)): raise TypeError(\\"List elements must be integers or strings\\") if elem in frequency: frequency[elem] += 1 else: frequency[elem] = 1 return frequency"},{"question":"# Coding Question You are to develop a mini-library system that simulates basic functionalities such as adding books, searching for a book by its title, and listing all the books. Objective Implement the necessary functionalities to manage a collection of books in a library, allowing users to add books, search for a book by title, and list all books. The system should be case-insensitive when searching. 1. **Method Definition**: - Implement a class named `Library` that manages the collection of books. - Each book should be represented as a dictionary with keys: `title`, `author`, and `year`. 2. **Class Library**: - `__init__(self)`: Initialize the library with an empty list of books. - `add_book(self, title: str, author: str, year: int)`: Add a book to the library. - Ensure the book title is not a duplicate (case-insensitive). If a duplicate is found, raise a `ValueError`. - `search_book(self, title: str) -> dict`: Search for a book by its title (case-insensitive) and return the book’s details. - If the book is not found, return None. - `list_books(self) -> list`: Return a list of all books in the library. Function Implementations - **add_book(title: str, author: str, year: int)**: - Inputs: Book title (string), author (string), publication year (integer). - Output: Adds the book to the library or raises `ValueError` if a book with the same title (case-insensitive) already exists. - **search_book(title: str) -> dict**: - Input: Book title (string). - Output: Returns the book details as a dictionary if found, otherwise returns None. - **list_books() -> list**: - Output: Returns a list of dictionaries containing details of all books in the library. Example ```python >>> library = Library() >>> library.add_book(\\"To Kill a Mockingbird\\", \\"Harper Lee\\", 1960) >>> library.add_book(\\"1984\\", \\"George Orwell\\", 1949) >>> library.list_books() [{\'title\': \'To Kill a Mockingbird\', \'author\': \'Harper Lee\', \'year\': 1960}, {\'title\': \'1984\', \'author\': \'George Orwell\', \'year\': 1949}] >>> library.search_book(\\"1984\\") {\'title\': \'1984\', \'author\': \'George Orwell\', \'year\': 1949} >>> library.search_book(\\"To kill a Mockingbird\\") {\'title\': \'To Kill a Mockingbird\', \'author\': \'Harper Lee\', \'year\': 1960} >>> library.add_book(\\"1984\\", \\"George Orwell\\", 1949) ValueError: Book with this title already exists. ```","solution":"class Library: def __init__(self): self.books = [] def add_book(self, title, author, year): # Ensure the book title is not a duplicate (case-insensitive) if any(book[\'title\'].lower() == title.lower() for book in self.books): raise ValueError(\\"Book with this title already exists.\\") self.books.append({\'title\': title, \'author\': author, \'year\': year}) def search_book(self, title): # Search for the book by case-insensitive title for book in self.books: if book[\'title\'].lower() == title.lower(): return book return None def list_books(self): return self.books"},{"question":"As a software engineer working on an e-commerce platform, you need to implement a system for dynamically generating discount codes. Each discount code should be unique, based on certain parameters, and have a limited lifespan. Your task is to create a function that generates a list of unique discount codes for a particular campaign. # Function Description You are required to implement the function `generate_discount_codes(campaign_id, prefix, count, length, expiration_days)`. # Input - `campaign_id`: A unique identifier for the discount campaign as a string. - `prefix`: A string prefix for the discount code. - `count`: The number of unique discount codes to generate as an integer. - `length`: The total length of each discount code (including prefix) as an integer. - `expiration_days`: The number of days until the discount codes expire as an integer. # Output - Returns a list of dictionaries. Each dictionary contains two keys: - `code`: The generated discount code as a string. - `expires_on`: The expiration date of the discount code from today’s date in the format `YYYY-MM-DD`. # Constraints - Each discount code should be unique. - The total length of each discount code (including the prefix) should be exactly `length`. - The function should handle edge cases effectively: - If `count` is less than or equal to zero, return an empty list. - If `length` is less than or equal to the length of the prefix, also return an empty list. # Examples ```python generate_discount_codes(\\"CAMP123\\", \\"SAVE\\", 5, 10, 30) # Output: [{\'code\': \'SAVE1XXX\', \'expires_on\': \'2023-11-25\'}, {\'code\': \'SAVE2XXX\', \'expires_on\': \'2023-11-25\'}, ...] generate_discount_codes(\\"CAMP123\\", \\"DISCOUNT\\", 3, 12, 14) # Output: [{\'code\': \'DISCOUNT001\', \'expires_on\': \'2023-11-09\'}, {\'code\': \'DISCOUNT002\', \'expires_on\': \'2023-11-09\'}, ...] generate_discount_codes(\\"CAMP1234\\", \\"OFFER\\", 0, 8, 20) # Output: [] generate_discount_codes(\\"CAMP1234\\", \\"PROMO\\", 2, 4, 10) # Output: [] generate_discount_codes(\\"CAMP5678\\", \\"DEAL\\", 10, 8, 30) # Output: [{\'code\': \'DEAL0001\', \'expires_on\': \'2023-11-25\'}, {\'code\': \'DEAL0002\', \'expires_on\': \'2023-11-25\'}, ...] ``` During the implementation, ensure that: - The uniqueness of each code is maintained. - The expiration date is calculated correctly from the current date. - The function handles and returns results for special and edge cases effectively.","solution":"import random import string from datetime import datetime, timedelta def generate_discount_codes(campaign_id, prefix, count, length, expiration_days): Generates a list of unique discount codes for a particular campaign. Parameters: - campaign_id (str): A unique identifier for the discount campaign. - prefix (str): A string prefix for the discount code. - count (int): The number of unique discount codes to generate. - length (int): The total length of each discount code (including prefix). - expiration_days (int): The number of days until the discount codes expire. Returns: - list of dict: Each dictionary contains \'code\' and \'expires_on\' keys. if count <= 0 or length <= len(prefix): return [] codes = [] expiration_date = datetime.now() + timedelta(days=expiration_days) expires_on = expiration_date.strftime(\\"%Y-%m-%d\\") for _ in range(count): while True: suffix_length = length - len(prefix) suffix = \'\'.join(random.choices(string.ascii_uppercase + string.digits, k=suffix_length)) code = prefix + suffix if code not in codes: codes.append(code) break return [{\'code\': code, \'expires_on\': expires_on} for code in codes]"},{"question":"# Coding Assessment: Implement a Custom Sorting Algorithm Context Sorting algorithms are fundamental in computer science and are used in various applications, from simple data organization to complex problem solving. You are given the task of implementing a custom sorting algorithm that sorts a list of dictionaries based on multiple dictionary keys. Problem Statement Implement the function `custom_sort` that sorts a list of dictionaries based on the values of specified keys in ascending order. Ensure that the function handles various edge cases, including dictionaries with missing keys and different types of values. Function to Be Implemented ```python def custom_sort(data: list, keys: list) -> list: Sort a list of dictionaries based on multiple keys. Args: data (list): A list of dictionaries to be sorted. keys (list): A list of keys to sort the dictionaries by. Returns: list: The sorted list of dictionaries. Example: >>> data = [{\\"name\\": \\"Alice\\", \\"age\\": 34, \\"score\\": 88}, {\\"name\\": \\"Bob\\", \\"age\\": 23, \\"score\\": 95}, {\\"name\\": \\"Charlie\\", \\"age\\": 45, \\"score\\": 77}] >>> keys = [\\"age\\", \\"score\\"] >>> custom_sort(data, keys) [{\\"name\\": \\"Bob\\", \\"age\\": 23, \\"score\\": 95}, {\\"name\\": \\"Alice\\", \\"age\\": 34, \\"score\\": 88}, {\\"name\\": \\"Charlie\\", \\"age\\": 45, \\"score\\": 77}] for key in reversed(keys): data.sort(key=lambda x: x.get(key, -float(\'inf\'))) return data ``` Requirements 1. **Key Handling**: - Sort the dictionaries by the keys provided in the `keys` list. - If a dictionary is missing a key, treat its value as `-inf` (negative infinity) to ensure it appears at the start of the sorted list. 2. **Edge Case Handling**: - Handle the case where one or more dictionaries are missing one or more of the sorting keys. - Ensure the function works with different data types, such as integers, strings, and floats. Input/Output Format * **Input**: - `data`: A list of dictionaries to be sorted. - `keys`: A list of strings representing the keys to sort the dictionaries by. * **Output**: - A list of dictionaries sorted according to the specified keys. Constraints 1. The list of dictionaries can be of any length, but it will not be empty. 2. Each dictionary can have any number of key-value pairs. Example ```python data = [ {\\"name\\": \\"Alice\\", \\"age\\": 34, \\"score\\": 88}, {\\"name\\": \\"Bob\\", \\"age\\": 23, \\"score\\": 95}, {\\"name\\": \\"Charlie\\", \\"age\\": 45, \\"score\\": 77}, {\\"name\\": \\"Dave\\", \\"age\\": 23} ] keys = [\\"age\\", \\"score\\"] print(custom_sort(data, keys)) # Output: # [ # {\\"name\\": \\"Dave\\", \\"age\\": 23}, # {\\"name\\": \\"Bob\\", \\"age\\": 23, \\"score\\": 95}, # {\\"name\\": \\"Alice\\", \\"age\\": 34, \\"score\\": 88}, # {\\"name\\": \\"Charlie\\", \\"age\\": 45, \\"score\\": 77} # ] try: keys = [\\"score\\", \\"age\\"] print(custom_sort(data, keys)) # Output: # [ # {\\"name\\": \\"Dave\\", \\"age\\": 23}, # {\\"name\\": \\"Charlie\\", \\"age\\": 45, \\"score\\": 77}, # {\\"name\\": \\"Alice\\", \\"age\\": 34, \\"score\\": 88}, # {\\"name\\": \\"Bob\\", \\"age\\": 23, \\"score\\": 95} # ] except ValueError as ve: print(f\\"ValueError: {ve}\\") ```","solution":"def custom_sort(data: list, keys: list) -> list: Sort a list of dictionaries based on multiple keys. Args: data (list): A list of dictionaries to be sorted. keys (list): A list of keys to sort the dictionaries by. Returns: list: The sorted list of dictionaries. for key in reversed(keys): data.sort(key=lambda x: x.get(key, -float(\'inf\'))) return data"},{"question":"**Objective**: Implement a Python function `find_missing_number` to find the missing number in a given list of unique integers ranging from 1 to n. # Function Signature ```python def find_missing_number(nums: List[int]) -> int: pass ``` # Input * `nums` (List[int]): A list of integers from 1 to n with exactly one number missing. The length of the list is `n-1`. # Output * Returns the missing integer. # Constraints * The list `nums` contains distinct elements. * 1 ≤ len(nums) ≤ 10^5 * 1 ≤ nums[i] ≤ n, where n = len(nums) + 1 # Requirements 1. Calculate the sum of integers from 1 to n. 2. Compute the sum of the elements in the input list. 3. The missing number is the difference between the sum from step 1 and the sum from step 2. 4. Return the missing number. # Example ```python nums = [1, 2, 4, 5, 6] # The complete list with no missing numbers should be [1, 2, 3, 4, 5, 6] # The missing number is 3 assert find_missing_number(nums) == 3 ``` **Hint**: You might find the formula for the sum of the first `n` natural numbers useful: ( S = frac{n(n + 1)}{2} ).","solution":"from typing import List def find_missing_number(nums: List[int]) -> int: Finds the missing number in a list of unique integers ranging from 1 to n. :param nums: List of integers with one number missing. :return: The missing integer. n = len(nums) + 1 total_sum = n * (n + 1) // 2 actual_sum = sum(nums) return total_sum - actual_sum"},{"question":"# Problem Statement You are developing a library management system, and one of the required functions is to calculate the fine for overdue books. The fine structure is as follows: - For the first 5 days, the fine is 0.50 per day. - For days between 6 and 10, the fine is 1.00 per day. - For days beyond 10, the fine is 5.00 per day. Your task is to implement a function that takes the number of overdue days and returns the total fine. Function Signature ```python def calculate_fine(overdue_days: int) -> float: pass ``` # Input * `overdue_days` - an integer representing the number of days the book is overdue. # Output * Returns a float representing the total fine amount in dollars. # Constraints * The number of overdue days must be a non-negative integer. # Requirements * If the number of overdue days is negative, raise a `ValueError` with the message: `\\"Overdue days cannot be negative!\\"` # Examples ```python >>> calculate_fine(overdue_days=4) 2.0 >>> calculate_fine(overdue_days=7) 9.0 >>> calculate_fine(overdue_days=12) 27.0 >>> calculate_fine(overdue_days=-3) Traceback (most recent call last): ... ValueError: Overdue days cannot be negative! ``` # Notes * Be sure to handle the edge cases. * Consider using conditional statements to determine the fine based on the overdue days.","solution":"def calculate_fine(overdue_days: int) -> float: Calculate the fine for overdue books based on the number of days overdue. :param overdue_days: An integer representing the number of days the book is overdue. :return: A float representing the total fine in dollars. :raises ValueError: If the number of overdue days is negative. if overdue_days < 0: raise ValueError(\\"Overdue days cannot be negative!\\") if overdue_days <= 5: return 0.50 * overdue_days elif overdue_days <= 10: return 0.50 * 5 + 1.00 * (overdue_days - 5) else: return 0.50 * 5 + 1.00 * 5 + 5.00 * (overdue_days - 10)"},{"question":"Matrix Rotation Checker Given a 2D matrix, write a `is_rotation_of` method to check if one matrix is a 90-degree rotation of another matrix. # Guidelines 1. **Input**: The matrices are provided as nested lists of integers. 2. **Output**: A boolean value indicating whether one matrix is a 90-degree rotation of the other. 3. **Constraints**: * The matrices are square (i.e., have the same number of rows and columns). * You must consider all four potential 90-degree rotations (90, 180, 270, and 360 degrees). * The function should return `True` if any 90-degree rotation of one matrix matches the other matrix. * You must not modify the input matrices. # Details **Function Signature**: ```python def is_rotation_of(matrix1: List[List[int]], matrix2: List[List[int]]) -> bool: ``` **Input Format**: - Two 2D matrices (`matrix1` and `matrix2`) provided as nested lists. **Output Format**: - A boolean value, `True` or `False`. **Example** **Input**: ```python matrix1 = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] matrix2 = [[7, 4, 1], [8, 5, 2], [9, 6, 3]] ``` **Output**: ```python True ``` **Explanation**: - `matrix2` is a 90-degree rotation of `matrix1`. ```python from typing import List def is_rotation_of(matrix1: List[List[int]], matrix2: List[List[int]]) -> bool: n = len(matrix1) def rotate_90(matrix: List[List[int]]) -> List[List[int]]: return [[matrix[n - 1 - j][i] for j in range(n)] for i in range(n)] rotated_matrix = matrix1.copy() for _ in range(4): rotated_matrix = rotate_90(rotated_matrix) if rotated_matrix == matrix2: return True return False # Test the function with provided tests. ``` # Notes * Consider edge cases such as empty matrices, one-element matrices, and matrices with identical elements. * Aim for a time complexity of O(n^2) for checking each rotation.","solution":"from typing import List def is_rotation_of(matrix1: List[List[int]], matrix2: List[List[int]]) -> bool: n = len(matrix1) def rotate_90(matrix: List[List[int]]) -> List[List[int]]: return [[matrix[n - 1 - j][i] for j in range(n)] for i in range(n)] rotated_matrix = matrix1 for _ in range(4): if rotated_matrix == matrix2: return True rotated_matrix = rotate_90(rotated_matrix) return False"},{"question":"# Problem Statement: Convert Nested Lists to a Single List You are required to implement a function `flatten_list` that takes a nested list of arbitrary depth and flattens it into a single list containing all the elements, preserving their original order. The function signature is as follows: ```python def flatten_list(nested_list: list) -> list: pass ``` # Function Signature: ```python def flatten_list(nested_list: list) -> list: Flattens a nested list into a single list containing all elements in their original order. Parameters: nested_list (list): A list that can contain elements which are either lists or other data types. Returns: list: A flattened list containing all elements from the nested list. pass ``` # Input: - A single parameter `nested_list`, which is a list that may contain other lists, nested to an arbitrary depth. # Output: - Returns a list with all nested elements flattened into a single list. # Constraints: - The input list can be nested to any arbitrary depth. - The function should handle the types consistently as they appear in the nested structure. # Examples: ```python >>> flatten_list([1, 2, [3, 4], [[5], 6]]) [1, 2, 3, 4, 5, 6] >>> flatten_list([[1, [2, 3]], [4, 5], 6, [7, [8, [9]]]]) [1, 2, 3, 4, 5, 6, 7, 8, 9] >>> flatten_list([1, [2, [3, [[4]]]]]) [1, 2, 3, 4] >>> flatten_list([]) [] >>> flatten_list([[], [[], [1]], []]) [1] ``` # Additional Notes: - Ensure the solution handles deeply nested structures efficiently. - Include test cases to cover common use cases and edge cases. - Consider using recursion or stack-based approaches for implementation.","solution":"def flatten_list(nested_list): Flattens a nested list into a single list containing all elements in their original order. Parameters: nested_list (list): A list that can contain elements which are either lists or other data types. Returns: list: A flattened list containing all elements from the nested list. def flatten(nested): for element in nested: if isinstance(element, list): yield from flatten(element) else: yield element return list(flatten(nested_list))"},{"question":"# Prime Factorization Decomposition **Context**: Prime factorization is the process of determining which prime numbers multiply together to form an original integer. This is a fundamental concept in number theory and has applications in areas such as cryptography and algorithm design. **Problem Statement**: Given an integer `n`, write a function `prime_factors(n: int) -> List[int]` that returns a list of the prime factors of `n` in ascending order. Each prime factor should appear in the list as many times as its power in the factorization of `n`. **Function Signature**: ```python def prime_factors(n: int) -> List[int]: pass ``` # Input * `n` - an integer `n` where `n >= 2` # Output * A list of integers representing the prime factors of `n` in ascending order. **Constraints**: * The integer `n` will be positive and greater than or equal to 2. # Examples 1. **Example 1:** ```python prime_factors(18) ``` *Output*: `[2, 3, 3]` Explanation: The prime factors of 18 are 2 and 3. The factorization 18 = 2 * 3 * 3. 2. **Example 2:** ```python prime_factors(28) ``` *Output*: `[2, 2, 7]` Explanation: The prime factors of 28 are 2 and 7. The factorization 28 = 2 * 2 * 7. 3. **Example 3:** ```python prime_factors(13) ``` *Output*: `[13]` Explanation: The prime factorization of 13, which is a prime number, is 13 itself. # Key Considerations * Ensure that the algorithm handles both small and large values of `n` efficiently. * Optimize for performance to handle cases where `n` has multiple prime factors or is a large prime number.","solution":"from typing import List def prime_factors(n: int) -> List[int]: Returns a list of the prime factors of n in ascending order. Each prime factor appears as many times as its power in the factorization of n. i = 2 factors = [] while i * i <= n: while n % i == 0: factors.append(i) n //= i i += 1 if n > 1: factors.append(n) return factors"},{"question":"# Find the Longest Path in a Directed Acyclic Graph (DAG) **Context**: Given a Directed Acyclic Graph (DAG) with `n` vertices. Each vertex represents a task, and each directed edge from vertex `u` to vertex `v` implies that task `u` must precede task `v`. You need to find the longest path in the graph where the length of the path is defined by the number of edges in it. # Task: 1. **Topological Sorting**: Implement an algorithm to perform topological sorting of the DAG. 2. **Longest Path Calculation**: Use the topological order to find the longest path in the DAG. # Inputs: - **n**: Number of nodes in the graph. - **edges**: List of tuples representing directed edges between nodes. # Expected Output: - Print the length of the longest path in the DAG. - Print the longest path as a list of nodes. # Code Constraints: - Use standard libraries for graph representation and operations. - Ensure your code handles graphs of varying sizes efficiently. - Include meaningful comments and print statements for analysis and debugging purposes. Here is the skeleton of the program you need to implement: ```python from collections import defaultdict, deque def topological_sort(n, edges): adj_list = defaultdict(list) in_degree = [0] * n for u, v in edges: adj_list[u].append(v) in_degree[v] += 1 queue = deque([i for i in range(n) if in_degree[i] == 0]) topo_order = [] while queue: node = queue.popleft() topo_order.append(node) for neighbor in adj_list[node]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) return topo_order def find_longest_path(n, edges, topo_order): dist = [-float(\'inf\')] * n dist[topo_order[0]] = 0 path = [-1] * n for node in topo_order: for neighbor in adj_list[node]: if dist[neighbor] < dist[node] + 1: dist[neighbor] = dist[node] + 1 path[neighbor] = node max_distance = max(dist) end_node = dist.index(max_distance) longest_path = [] while end_node != -1: longest_path.append(end_node) end_node = path[end_node] longest_path.reverse() return max_distance, longest_path def main(): n = 6 edges = [ (0, 1), (0, 2), (1, 3), (2, 3), (3, 4), (4, 5) ] topo_order = topological_sort(n, edges) print(f\\"Topological Order: {topo_order}\\") max_distance, longest_path = find_longest_path(n, edges, topo_order) print(f\\"Length of Longest Path: {max_distance}\\") print(f\\"Longest Path: {longest_path}\\") if __name__ == \\"__main__\\": main() ``` # Evaluation - You will be evaluated on correctly implementing the topological sort and longest path calculation. - Properly handling edge cases and ensuring efficient execution for large graphs. - Clear and concise code with appropriate function naming and comments.","solution":"from collections import defaultdict, deque def topological_sort(n, edges): adj_list = defaultdict(list) in_degree = [0] * n for u, v in edges: adj_list[u].append(v) in_degree[v] += 1 queue = deque([i for i in range(n) if in_degree[i] == 0]) topo_order = [] while queue: node = queue.popleft() topo_order.append(node) for neighbor in adj_list[node]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) return topo_order def find_longest_path(n, edges, topo_order): dist = [-float(\'inf\')] * n dist[topo_order[0]] = 0 path = [-1] * n adj_list = defaultdict(list) for u, v in edges: adj_list[u].append(v) for node in topo_order: for neighbor in adj_list[node]: if dist[neighbor] < dist[node] + 1: dist[neighbor] = dist[node] + 1 path[neighbor] = node max_distance = max(dist) end_node = dist.index(max_distance) longest_path = [] while end_node != -1: longest_path.append(end_node) end_node = path[end_node] longest_path.reverse() return max_distance, longest_path def main(n, edges): topo_order = topological_sort(n, edges) print(f\\"Topological Order: {topo_order}\\") max_distance, longest_path = find_longest_path(n, edges, topo_order) print(f\\"Length of Longest Path: {max_distance}\\") print(f\\"Longest Path: {longest_path}\\") return max_distance, longest_path if __name__ == \\"__main__\\": n = 6 edges = [ (0, 1), (0, 2), (1, 3), (2, 3), (3, 4), (4, 5) ] main(n, edges)"},{"question":"# Financial Transaction Validator **Scenario:** You have been hired to develop a function that validates financial transactions. A valid transaction must follow strict criteria to ensure accuracy and security. Each transaction is represented as a string containing the transaction date, payer account number, payee account number, and the amount. The format must be: ``` YYYYMMDD, payAcc, payeeAcc, amount ``` Where: - `YYYYMMDD` is the transaction date. - `payAcc` is the payer account number which is a sequence of 10 digits. - `payeeAcc` is the payee account number which is also a sequence of 10 digits. - `amount` is a decimal number representing the transaction amount which must be positive. **Function Specification:** ```python def is_valid_transaction(transaction: str) -> bool: Validates a financial transaction string. Parameters: transaction (str): The transaction string to be validated. Returns: bool: True if the transaction is valid, False otherwise. Raises: TypeError: If the input is not a string. ValueError: If the input does not follow the correct format. Example: >>> is_valid_transaction(\\"20230101,1234567890,0987654321,500.00\\") True >>> is_valid_transaction(\\"20230101,1234567890,0987654321,0.00\\") False >>> is_valid_transaction(\\"202301A1,1234567890,0987654321,500.00\\") False >>> is_valid_transaction(\\"20230101,123456789,0987654321,500.00\\") False ``` **Requirements:** 1. The function should accept one parameter `transaction` which is expected to be a string of the specified format. 2. Validate the structure: - Ensure the date portion strictly follows the `YYYYMMDD` format. - Ensure both account numbers (`payAcc` and `payeeAcc`) are 10-digit sequences. - Ensure the amount is a positive decimal number. 3. The function should return `True` if all validations pass, otherwise `False`. 4. Raise a `TypeError` if the input is not a string. 5. Raise a `ValueError` for format issues including: - Incorrect date format. - Incorrect length of account numbers. - Non-positive transaction amount. **Constraints:** - The input string may contain spaces which should be ignored. # Examples: ```python assert is_valid_transaction(\\"20230101,1234567890,0987654321,500.00\\") == True assert is_valid_transaction(\\"20230101,1234567890,0987654321,0.00\\") == False assert is_valid_transaction(\\"202301A1,1234567890,0987654321,500.00\\") == False assert is_valid_transaction(\\"20230101,123456789,09876504321,500.00\\") == False assert is_valid_transaction(\\"20230101,1234567890 , 0987654321 , 500.00\\") == True assert is_valid_transaction(\\"20230101,1234567890,0987654321,-500.00\\") == False assert is_valid_transaction(20230101) == False # Raises TypeError assert is_valid_transaction(\\"20230101,1234567890,0987654321,1000\\") == True ```","solution":"import re from datetime import datetime def is_valid_transaction(transaction: str) -> bool: Validates a financial transaction string. Parameters: transaction (str): The transaction string to be validated. Returns: bool: True if the transaction is valid, False otherwise. Raises: TypeError: If the input is not a string. ValueError: If the input does not follow the correct format. if not isinstance(transaction, str): raise TypeError(\\"The input must be a string.\\") try: transaction = re.sub(r\'s+\', \'\', transaction) parts = transaction.split(\',\') if len(parts) != 4: raise ValueError(\\"Transaction must have exactly four parts: date, payer account, payee account, and amount.\\") date_str, payer_acc, payee_acc, amount_str = parts # Validate date datetime.strptime(date_str, \'%Y%m%d\') # Validate payer and payee account numbers if len(payer_acc) != 10 or not payer_acc.isdigit(): raise ValueError(\\"Payer account number must be a 10-digit sequence.\\") if len(payee_acc) != 10 or not payee_acc.isdigit(): raise ValueError(\\"Payee account number must be a 10-digit sequence.\\") # Validate amount amount = float(amount_str) if amount <= 0: raise ValueError(\\"Transaction amount must be a positive number.\\") return True except (ValueError, TypeError) as e: return False"},{"question":"# Problem Statement Implement a function that simulates an online shopping cart. This function should allow users to add items, remove items, and calculate the total cost of the items in the cart. Each item in the cart has a name, price, and quantity. Function Signature ```python def manage_cart(actions: list[dict]) -> float: ``` Input * `actions` (list[dict]): A list of dictionaries where each dictionary represents an action to be performed on the cart. Each dictionary contains: * `action` (str): The action to perform. It can be \\"add\\", \\"remove\\", or \\"total\\". * `item` (str, optional): The name of the item (only required for \\"add\\" and \\"remove\\" actions). * `price` (float, optional): The price of the item (only required for \\"add\\" action). * `quantity` (int, optional): The quantity of the item (only required for \\"add\\" and \\"remove\\" actions). Output * Returns a float representing the total cost of the items in the cart after processing all actions. Constraints * If an \\"add\\" action is performed and the item already exists in the cart, increase its quantity. * If a \\"remove\\" action is performed and the item exists in the cart, decrease its quantity. If the quantity to remove is more than present, remove the item completely. * The \\"total\\" action should compute and return the current total cost of all items in the cart. * The function should validate all inputs and handle cases where invalid actions or parameters are provided gracefully. Example ```python actions = [ {\\"action\\": \\"add\\", \\"item\\": \\"apple\\", \\"price\\": 1.0, \\"quantity\\": 3}, {\\"action\\": \\"add\\", \\"item\\": \\"banana\\", \\"price\\": 0.5, \\"quantity\\": 5}, {\\"action\\": \\"remove\\", \\"item\\": \\"apple\\", \\"quantity\\": 1}, {\\"action\\": \\"total\\"} ] total_cost = manage_cart(actions) print(f\\"Total cost: {total_cost:.2f}\\") ``` # Testing * Test with different scenarios including adding items, removing items, calculating the total, and handling invalid inputs. * Ensure that the function correctly updates the cart with each action and accurately calculates the total cost. * Test edge cases such as removing more items than present, removing items not in the cart, and invalid actions.","solution":"def manage_cart(actions): cart = {} for action in actions: act = action.get(\'action\') item = action.get(\'item\') price = action.get(\'price\') quantity = action.get(\'quantity\') if act == \\"add\\": if item and price is not None and quantity is not None: if item in cart: cart[item][\'quantity\'] += quantity else: cart[item] = {\'price\': price, \'quantity\': quantity} elif act == \\"remove\\": if item and quantity is not None: if item in cart: if cart[item][\'quantity\'] > quantity: cart[item][\'quantity\'] -= quantity else: del cart[item] elif act == \\"total\\": total_cost = sum(info[\'price\'] * info[\'quantity\'] for info in cart.values()) return total_cost # If there\'s no \\"total\\" action in the end total_cost = sum(info[\'price\'] * info[\'quantity\'] for info in cart.values()) return total_cost"},{"question":"Implementing a Mini-Math Interpreter **Context**: Your task is to implement a simple mathematical expression evaluator that can handle basic operations and parentheses. The evaluator should be able to parse and compute the value of a given string representation of the mathematical expression. # Problem Description **Function Signature**: ```python def evaluate_expression(expression: str) -> float: ``` **Parameters**: - `expression` (str): A string representing a mathematical expression. The expression can include the operators +, -, *, /, and parentheses (). The expression will always be valid and can contain spaces. **Output**: - A float representing the result of the evaluated expression. # Constraints - The expression will contain only valid characters (digits, operators, parentheses, and spaces). - The expression will not result in division by zero. - The result will fit within the floating-point number range. # Requirements 1. Implement the `evaluate_expression` function. 2. Handle nested parentheses correctly. 3. Handle operations following the standard operator precedence (i.e., *, / before +, -). # Example ```python if __name__ == \\"__main__\\": expr1 = \\"(2 + 3) * 4\\" expr2 = \\"3 + 5 / (2 - 8)\\" expr3 = \\"10 - 2 * (3 + ( 3 / (9 - 6)))\\" result1 = evaluate_expression(expr1) result2 = evaluate_expression(expr2) result3 = evaluate_expression(expr3) print(result1) # Expected output: 20.0 print(result2) # Expected output: 1.3333333333333333 print(result3) # Expected output: 6.0 ``` # Notes - You may not use the `eval` function or any similar built-in functions. - You can assume the input expression is always valid. - Ensure to handle nested parentheses and operator precedence accurately.","solution":"def evaluate_expression(expression: str) -> float: def precedence(op): if op == \'+\' or op == \'-\': return 1 if op == \'*\' or op == \'/\': return 2 return 0 def apply_op(a, b, op): if op == \'+\': return a + b if op == \'-\': return a - b if op == \'*\': return a * b if op == \'/\': return a / b def calculate(tokens): values = [] ops = [] i = 0 while i < len(tokens): if tokens[i] == \' \': i += 1 continue elif tokens[i] == \'(\': ops.append(tokens[i]) elif tokens[i].isdigit() or tokens[i] == \'.\': val = 0 decimal_place = 0 while i < len(tokens) and (tokens[i].isdigit() or tokens[i] == \'.\'): if tokens[i].isdigit(): if decimal_place == 0: val = (val * 10) + int(tokens[i]) else: val += int(tokens[i]) / (10 ** decimal_place) decimal_place += 1 elif tokens[i] == \'.\': decimal_place = 1 i += 1 values.append(val) i -= 1 elif tokens[i] == \')\': while len(ops) > 0 and ops[-1] != \'(\': val2 = values.pop() val1 = values.pop() op = ops.pop() values.append(apply_op(val1, val2, op)) ops.pop() else: while (len(ops) > 0 and precedence(ops[-1]) >= precedence(tokens[i])): val2 = values.pop() val1 = values.pop() op = ops.pop() values.append(apply_op(val1, val2, op)) ops.append(tokens[i]) i += 1 while len(ops) > 0: val2 = values.pop() val1 = values.pop() op = ops.pop() values.append(apply_op(val1, val2, op)) return values[-1] return calculate(expression)"},{"question":"# Problem Statement Consider a series of numbers where the next number in the series is generated by reversing the order of the digits of the current number and then adding it to the original number. This series always ends in either: 1. A palindrome (a number that reads the same backward as forward). 2. A pre-defined stopping condition if it exceeds a certain number of iterations. Your task is to determine how many starting numbers below `one thousand` will eventually produce a palindrome within `fifty iterations`. If no palindrome is produced within `fifty iterations`, the process should be terminated, and the number is not considered. # Function Signature ```python def count_palindrome_numbers(max_start: int = 1000, max_iterations: int = 50) -> int: ``` # Input - **max_start**: An integer representing the upper limit of the starting number (exclusive), default value is `1,000`. - **max_iterations**: An integer representing the maximum number of iterations to perform, default value is `50`. # Output - Returns an integer representing the count of starting numbers that produce a palindrome within `max_iterations`. # Constraints - All starting numbers are positive integers below `one thousand`. - Each number in the series is generated by reversing the digits of the current number and adding it to the original number. # Example ```python print(count_palindrome_numbers(1000, 50)) # Output: An integer representing the count of palindromic sequences ``` # Requirements 1. Implement a function to reverse the digits of a number. 2. Iterate and generate the next number in the series by adding the reversed digits to the original number. 3. Check if the resulting number is a palindrome. 4. Track and count starting numbers that generate a palindrome within the given iteration limit. **Note**: Efficient handling of numerical computations, condition checking, and iterative processes must be evident in your solution to achieve accurate results within the given constraints.","solution":"def reverse_number(n): Reverses the digits of a given number. return int(str(n)[::-1]) def is_palindrome(n): Checks if a given number is a palindrome. return str(n) == str(n)[::-1] def count_palindrome_numbers(max_start: int = 1000, max_iterations: int = 50) -> int: Counts how many starting numbers below max_start will eventually produce a palindrome within max_iterations iterations. palindrome_count = 0 for start in range(1, max_start): num = start for _ in range(max_iterations): rev_num = reverse_number(num) num += rev_num if is_palindrome(num): palindrome_count += 1 break return palindrome_count # Example usage print(count_palindrome_numbers(1000, 50)) # Output: An integer representing the count of palindromic sequences"},{"question":"# Problem Description You need to create a function that determines whether it is possible to finish all tasks based on the given prerequisites. Each task is a course, and some courses have dependencies that must be completed first. The prerequisites are given as a list of pairs [a, b], which indicates that course `a` depends on course `b`. # Function Signature ```python def can_finish_courses(num_courses: int, prerequisites: list) -> bool: Determine if all courses can be finished given the prerequisites. Parameters: num_courses (int): The total number of courses, labeled from 0 to num_courses-1. prerequisites (list): A list of pairs [a, b] indicating that course `a` depends on course `b`. Returns: bool: True if it is possible to finish all courses, False otherwise. ``` # Input - `num_courses`: The total number of courses, an integer in the range [1, 1000]. - `prerequisites`: A list of pairs [a, b], where `a` and `b` are integers representing courses that fall within the range [0, `num_courses`-1]. # Output - A boolean value. `True` if it\'s possible to finish all courses, `False` otherwise. # Constraints - The number of pairs in prerequisites will be between 0 and 10000. - Course numbers are non-negative integers and less than `num_courses`. - There are no duplicate pairs in the prerequisites. # Example ```python assert can_finish_courses(2, [[1, 0]]) == True assert can_finish_courses(2, [[1, 0], [0, 1]]) == False assert can_finish_courses(4, [[1, 0], [2, 1], [3, 2]]) == True assert can_finish_courses(4, [[1, 0], [0, 2], [2, 1]]) == False assert can_finish_courses(3, []) == True ``` # Requirements - Your solution should efficiently handle the input size and constraints. - Utilize appropriate graph traversal or cycle detection algorithms to solve the problem. - Carefully handle edge cases such as when there are no prerequisites or when courses form a single self-contained cycle.","solution":"def can_finish_courses(num_courses: int, prerequisites: list) -> bool: from collections import defaultdict, deque def has_cycle(graph, num_courses): in_degree = [0] * num_courses for course in graph: for prereq in graph[course]: in_degree[prereq] += 1 queue = deque([i for i in range(num_courses) if in_degree[i] == 0]) count = 0 while queue: current = queue.popleft() count += 1 for neighbor in graph[current]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) return count == num_courses graph = defaultdict(list) for course, prereq in prerequisites: graph[prereq].append(course) return has_cycle(graph, num_courses)"},{"question":"# Coding Question Scenario In asynchronous processing systems, tasks are often executed with delays. To monitor such tasks, we need to measure the elapsed time since the initiation. Given a series of timestamps, you are tasked with computing the elapsed time between each pair of consecutive timestamps. Task Implement the function `elapsed_times` to compute the elapsed time in seconds between each pair of consecutive timestamps in a list. # Function Signature ```python def elapsed_times(timestamps: list[int]) -> list[int]: ``` # Input * `timestamps`: A list of integers representing Unix timestamps in seconds. # Output * A list of integers where each element represents the elapsed time in seconds between each pair of consecutive timestamps. # Constraints * The length of `timestamps` will be between 2 and 10^5. * Each element in `timestamps` will be a positive integer and the list will be sorted in non-decreasing order. # Requirements 1. The function should return a list of elapsed times between consecutive timestamps. 2. If the input list has only one timestamp, the function should return an empty list. # Example ```python # Input timestamps = [1610000000, 1610000060, 1610000120, 1610001240] # Output [60, 60, 1120] ``` **Notes:** Implement efficient processing to handle large input sizes within acceptable performance limits. Ensure integer arithmetic operations are used to avoid performance hits with floats. **Edge cases to consider:** - When the input list contains only two timestamps. - Handling the minimal valid timestamps. # Explanation The function calculates the difference in seconds between each neighboring pair of timestamps. For example, with timestamps [1610000000, 1610000060, 1610000120, 1610001240], the results will be [60, 60, 1120] by subtracting each pair respectively (1610000060 - 1610000000 = 60, 1610000120 - 1610000060 = 60, and 1610001240 - 1610000120 = 1120).","solution":"def elapsed_times(timestamps: list[int]) -> list[int]: Return a list of elapsed times in seconds between consecutive timestamps. :param timestamps: List of Unix timestamps in seconds. :return: List of elapsed times in seconds between consecutive timestamps. if len(timestamps) < 2: return [] elapsed = [] for i in range(1, len(timestamps)): elapsed.append(timestamps[i] - timestamps[i - 1]) return elapsed"},{"question":"# Question: First Unique Character Index Context In natural language processing and text analysis, it\'s often valuable to identify unique occurrences of certain elements. One problem you might face is finding the first non-repeating character in a string. Task Implement the `first_unique_character` function that returns the index of the first non-repeating character in a given string. If there is no unique character, the function should return -1. Function Signature ```python def first_unique_character(s: str) -> int: pass ``` Input - `s`: A string consisting of lowercase English letters (length n, where 0 <= n <= 10^5) Output - Return the index of the first non-repeating character if found; otherwise, return -1. Constraints - The function should have a time complexity of O(n). - The function should have a space complexity of O(1) (excluding the input string storage). - Handle necessary edge cases effectively. Example ```python assert first_unique_character(\\"leetcode\\") == 0 assert first_unique_character(\\"loveleetcode\\") == 2 assert first_unique_character(\\"aabb\\") == -1 assert first_unique_character(\\"\\") == -1 assert first_unique_character(\\"z\\") == 0 ``` Note Your implementation should efficiently find the first unique character by making a single pass to record frequencies and another pass to determine the first unique character.","solution":"def first_unique_character(s: str) -> int: Finds the index of the first non-repeating character in the string s. Returns -1 if there are no unique characters. # First pass to record the frequency of each character char_count = {} for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Second pass to find the index of the first non-repeating character for index, char in enumerate(s): if char_count[char] == 1: return index return -1"},{"question":"# Context You have access to a text file called `textdata.txt` that contains an assortment of paragraphs. Each paragraph is separated by a blank line. Your task is to analyze this text and identify the paragraph with the highest average word length. # Problem Statement Write a function `longest_average_word_paragraph(filename)` that reads the provided file, calculates the average word length for each paragraph, and returns the paragraph with the highest average word length. The average word length is defined as the total number of letters divided by the number of words in the paragraph. # Input - `filename`: A string representing the path to the text file. # Output - A string representing the paragraph with the highest average word length. # Constraints - The file will contain at least one paragraph. - Each word will be separated by a space and will contain only alphabetic characters. - Paragraphs are separated by a blank line (two newline characters). # Example ```python >>> longest_average_word_paragraph(\'textdata.txt\') \'This is a sample paragraph. Given the details, we analyze the average word length.\' ``` # Implementation ```python def longest_average_word_paragraph(filename): with open(filename, \'r\') as file: content = file.read() paragraphs = content.split(\\"nn\\") max_avg_length = 0 best_paragraph = \\"\\" for paragraph in paragraphs: words = paragraph.split() if words: total_letters = sum(len(word) for word in words) avg_length = total_letters / len(words) if avg_length > max_avg_length: max_avg_length = avg_length best_paragraph = paragraph return best_paragraph.strip() ``` # Note Ensure that the file `textdata.txt` is correctly formatted with paragraphs separated by blank lines. Each word can only contain alphabetic characters, ensuring robust computation of word lengths.","solution":"def longest_average_word_paragraph(filename): with open(filename, \'r\') as file: content = file.read() paragraphs = content.split(\\"nn\\") max_avg_length = 0 best_paragraph = \\"\\" for paragraph in paragraphs: words = paragraph.split() if words: total_letters = sum(len(word) for word in words) avg_length = total_letters / len(words) if avg_length > max_avg_length: max_avg_length = avg_length best_paragraph = paragraph return best_paragraph.strip()"},{"question":"# Problem Statement Scenario: You are assigned to design a system for managing a music playlist that allows for adding new songs, removing songs, and playing the next song. Each song is represented by a unique identifier (ID) and a title. The playlist should maintain the order in which songs are added and follow the FIFO (First-In-First-Out) principle when playing the next song. Task: Implement the necessary classes and functions to manage the playlist operations. You should ensure that the playlist handles adding songs, removing specific songs by ID, and playing the next song in the correct order. Requirements: - Define a class `Song` with attributes `id` (int) and `title` (str). - Define a class `Playlist` with methods: - `add_song(song: Song) -> None`: Adds a new song to the playlist. - `remove_song(song_id: int) -> bool`: Removes the song with the given ID from the playlist. Returns `True` if the song was successfully removed, `False` if the song ID does not exist in the playlist. - `play_next() -> Song`: Returns the next song to be played and removes it from the playlist. If the playlist is empty, return `None`. Inputs: 1. A series of song additions represented by `(id: int, title: str)` tuples. 2. A series of song removal requests by `song_id: int`. 3. Play next song requests. Constraints: - Song IDs are unique int values. - Song titles are non-empty strings with a maximum length of 100 characters. - Playlist operations should be efficient and handle up to 1000 songs. Example: ```python playlist = Playlist() # Adding songs playlist.add_song(Song(1, \\"Song A\\")) playlist.add_song(Song(2, \\"Song B\\")) playlist.add_song(Song(3, \\"Song C\\")) # Removing a song playlist.remove_song(2) # True # Playing songs print(playlist.play_next().title) # \\"Song A\\" print(playlist.play_next().title) # \\"Song C\\" print(playlist.play_next()) # None ``` Code Usage: ```python if __name__ == \\"__main__\\": playlist = Playlist() playlist.add_song(Song(1, \\"Song A\\")) playlist.add_song(Song(2, \\"Song B\\")) print(playlist.play_next().title) # \\"Song A\\" assert playlist.remove_song(3) == False print(playlist.play_next().title) # \\"Song B\\" ``` Ensure that your implementation correctly handles the operations while maintaining the correct order and integrity of the playlist. Consider test cases with edge situations such as removing songs that do not exist or attempting to play from an empty playlist.","solution":"class Song: def __init__(self, id: int, title: str): self.id = id self.title = title class Playlist: def __init__(self): self.songs = [] self.song_map = {} def add_song(self, song: Song) -> None: if song.id not in self.song_map: self.songs.append(song) self.song_map[song.id] = song def remove_song(self, song_id: int) -> bool: if song_id in self.song_map: for i, song in enumerate(self.songs): if song.id == song_id: del self.songs[i] break del self.song_map[song_id] return True return False def play_next(self) -> Song: if self.songs: next_song = self.songs.pop(0) del self.song_map[next_song.id] return next_song return None"},{"question":"**Context:** You are building a simple library management system where you need to keep track of book availability and perform reservations. The system should be able to handle multiple simultaneous checkouts and returns, ensuring that no book reservation can proceed if no copies are available. **Objective:** Implement a class `Library` that manages the inventory of books and their reservations. The system should allow you to add books to the inventory, check out books, return books, and check the availability of a specific book. # Task: 1. Create the `Library` class with the following methods: - `add_book(title: str, copies: int) -> None`: Adds a certain number of copies of a book to the inventory. If the book already exists, it increases the count by the given number of copies. - `checkout_book(title: str) -> bool`: Checks out a book if there are available copies. Returns `True` if the checkout is successful, `False` otherwise. - `return_book(title: str) -> None`: Returns a book back to the inventory. - `is_book_available(title: str) -> bool`: Checks if the book is available for checkout. Returns `True` if at least one copy is available, `False` otherwise. 2. Ensure that your implementation handles edge cases where books may not exist in the inventory before an operation is attempted. # Expected Input and Output: * **Input**: - Various method calls on a `Library` object. * **Output**: - Results from called methods (`bool` for successful checkout or book availability, `None` for methods that modify the inventory but do not return a value). # Example: ```python library = Library() library.add_book(\\"The Great Gatsby\\", 3) assert library.checkout_book(\\"The Great Gatsby\\") == True assert library.is_book_available(\\"The Great Gatsby\\") == True library.checkout_book(\\"The Great Gatsby\\") library.checkout_book(\\"The Great Gatsby\\") assert library.checkout_book(\\"The Great Gatsby\\") == False library.return_book(\\"The Great Gatsby\\") assert library.is_book_available(\\"The Great Gatsby\\") == True ``` # Constraints: - All operations should be efficient with respect to both time and space complexity. - Consider appropriate internal data structures for managing the books and their copies.","solution":"class Library: def __init__(self): self.inventory = {} def add_book(self, title: str, copies: int) -> None: if title in self.inventory: self.inventory[title] += copies else: self.inventory[title] = copies def checkout_book(self, title: str) -> bool: if title in self.inventory and self.inventory[title] > 0: self.inventory[title] -= 1 return True return False def return_book(self, title: str) -> None: if title in self.inventory: self.inventory[title] += 1 def is_book_available(self, title: str) -> bool: return title in self.inventory and self.inventory[title] > 0"},{"question":"# Maximum Twin Number Finder **Context**: A twin number is defined as a number that, when reversed, forms itself. For example, 121 and 12321 are twin numbers because reversing them results in 121 and 12321 respectively. **Objective**: Write a function that finds the largest twin number within a specified range. # Function Signature ```python def max_twin_number(upper_limit: int) -> int: pass ``` # Requirements * Implement the `is_twin_number(n: int) -> bool` function to check if a number is a twin number. * Use the above function to implement `max_twin_number(upper_limit: int)` to find the largest twin number less than or equal to the `upper_limit`. # Constraints - The `upper_limit` will be a positive integer greater than 0. - Efficient checking of palindrome property is expected. # Input * An integer `upper_limit` representing the maximum number to be considered in the search. # Output * Return the largest twin number that is less than or equal to `upper_limit`. If no such number exists, return -1. # Example ```python assert max_twin_number(50000) == 49494 assert max_twin_number(12345) == 12321 assert max_twin_number(10) == 9 assert max_twin_number(0) == -1 ``` # Considerations * Optimize your solution for clarity and efficiency. * Ensure you handle edge cases and input constraints correctly. # Additional Guidelines - Write clean, readable code, and utilize helper functions where necessary to simplify the logic.","solution":"def is_twin_number(n: int) -> bool: Checks if a number is a twin number (i.e., palindrome). return str(n) == str(n)[::-1] def max_twin_number(upper_limit: int) -> int: Finds the largest twin number less than or equal to the upper_limit. for number in range(upper_limit, -1, -1): if is_twin_number(number): return number return -1"},{"question":"# Binary Tree Right Side View Problem Statement Write a function `right_side_view(root: Optional[TreeNode]) -> List[int]` that returns the values of the nodes you can see ordered from top to bottom if you stand on the right side of a binary tree. Input - `root` is the root node of a binary tree. Output - A list of integer values representing the visible nodes from the right side. Constraints - The number of nodes in the tree is in the range `[0, 100]`. - `-100 ≤ Node.val ≤ 100`. Example ```python # Example 1 >>> tree = TreeNode(1) >>> tree.left = TreeNode(2) >>> tree.right = TreeNode(3) >>> tree.left.right = TreeNode(5) >>> tree.right.right = TreeNode(4) >>> right_side_view(tree) [1, 3, 4] # Example 2 >>> tree = TreeNode(1) >>> tree.right = TreeNode(3) >>> right_side_view(tree) [1, 3] # Example 3 >>> tree = None >>> right_side_view(tree) [] ``` Explanation 1. For the tree: ``` 1 / 2 3 5 4 ``` The right side view is `[1, 3, 4]` as these are the visible nodes from the right. 2. For the tree: ``` 1 3 ``` The right side view is `[1, 3]`. 3. For an empty tree, the output is `[]`.","solution":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def right_side_view(root: Optional[TreeNode]) -> List[int]: if not root: return [] queue = [(root, 0)] rightmost_value_at_depth = dict() max_depth = -1 while queue: node, depth = queue.pop(0) if node: # Track the maximum depth to support our dictionary indexing max_depth = max(max_depth, depth) # The overwriting of values at the same depth results in the rightmost node being stored rightmost_value_at_depth[depth] = node.val queue.append((node.left, depth + 1)) queue.append((node.right, depth + 1)) return [rightmost_value_at_depth[depth] for depth in range(max_depth + 1)]"},{"question":"# Problem Statement You are tasked with implementing a PathFinder class that manages a 2D grid and supports operations to navigate through it and mark positions with special symbols. # Requirements 1. **Initialization:** - Initialize the PathFinder class with a specified number of rows and columns, creating a grid filled with the \'.\' character representing empty cells. 2. **Operations:** - **Mark(x, y, c)**: Mark the cell at position (x, y) with the character `c`. - **Display**: Display the current state of the grid row by row. - **Reset(x, y)**: Reset the cell at position (x, y) to the default \'.\' character. - **PathExists(x1, y1, x2, y2)**: Return `True` if there exists a path from (x1, y1) to (x2, y2) consisting only of empty cells (\'.\'), and `False` otherwise. Assume path finding uses 4-directional (up, down, left, right) moves. # Input Format - The dimensions of the grid `rows` and `columns` (integers where `rows, columns > 0`). - A sequence of operations and their values. # Output Format - For a **display** operation, output the current state of the grid. - For a **path_exists** operation, return `True` or `False`. # Constraints - The number of rows and columns are positive integers. - Operations are provided in the form of a list of tuples, where each tuple contains the operation name and necessary parameters. - Validity of cell positions (x, y) should be assumed within the grid bounds. - PathExists operation should be efficient. # Example ```python # Grid dimensions: 5 rows, 4 columns # Sequence of operations operations = [ (\\"mark\\", 0, 0, \'S\'), (\\"mark\\", 4, 3, \'E\'), (\\"display\\",), # Output: displays the marked grid (\\"mark\\", 2, 2, \'X\'), (\\"path_exists\\", 0, 0, 4, 3), # Output: True (assuming grid is otherwise empty) (\\"reset\\", 2, 2), (\\"path_exists\\", 0, 0, 4, 3), # Output: True ] path_finder = PathFinder(5, 4) for operation in operations: if operation[0] == \\"mark\\": path_finder.mark(operation[1], operation[2], operation[3]) elif operation[0] == \\"display\\": path_finder.display() elif operation[0] == \\"reset\\": path_finder.reset(operation[1], operation[2]) elif operation[0] == \\"path_exists\\": print(path_finder.path_exists(operation[1], operation[2], operation[3], operation[4])) ``` # Boilerplate Code: Implement the required methods in the provided class: ```python class PathFinder: def __init__(self, rows: int, columns: int) -> None: # Initialize the grid ... def mark(self, x: int, y: int, c: str): # Mark a position with a specified character ... def display(self): # Display the grid content ... def reset(self, x: int, y: int): # Reset a position to the default character ... def path_exists(self, x1: int, y1: int, x2: int, y2: int) -> bool: # Check if a path exists from (x1, y1) to (x2, y2) ... ```","solution":"class PathFinder: def __init__(self, rows: int, columns: int) -> None: self.rows = rows self.columns = columns self.grid = [[\'.\' for _ in range(columns)] for _ in range(rows)] def mark(self, x: int, y: int, c: str): self.grid[x][y] = c def display(self): for row in self.grid: print(\'\'.join(row)) def reset(self, x: int, y: int): self.grid[x][y] = \'.\' def path_exists(self, x1: int, y1: int, x2: int, y2: int) -> bool: if self.grid[x1][y1] != \'.\' or self.grid[x2][y2] != \'.\': return False visited = [[False for _ in range(self.columns)] for _ in range(self.rows)] def dfs(x, y): # Check boundary conditions and if the cell is not a part of the path if x < 0 or x >= self.rows or y < 0 or y >= self.columns or self.grid[x][y] != \'.\' or visited[x][y]: return False # If the destination is reached if (x, y) == (x2, y2): return True # Mark the cell as visited visited[x][y] = True # Explore 4 directions: up, down, left, right if (dfs(x-1, y) or dfs(x+1, y) or dfs(x, y-1) or dfs(x, y+1)): return True # If no path is found, backtrack visited[x][y] = False return False return dfs(x1, y1)"},{"question":"Design and implement a class `LRUCache` which uses an underlying data structure to implement a Least Recently Used (LRU) cache system. The LRU cache should support fast access and update operations, ideally performing these operations in constant time, O(1). # Functionality Requirements: 1. **`get(key)`**: Retrieves the value associated with the key if it exists in the cache; otherwise, returns -1. 2. **`put(key, value)`**: Inserts or updates the value associated with the key. If the cache reaches its capacity, it should remove the least recently used item before inserting the new item. 3. **`remove(key)`**: Removes the value associated with the key from the cache if it exists. 4. **`display()`**: Returns the current items in the cache in order of most recently to least recently used, as a list of tuples. # Input and Output Formats: - **`get(key)`**: - Input: `key` is a unique identifier (integer or string). - Output: Corresponding value or -1. - **`put(key, value)`**: - Input: `key` is a unique identifier (integer or string), `value` is any datatype. - Output: None - **`remove(key)`**: - Input: `key` is a unique identifier (integer or string). - Output: None - **`display()`**: - Output: List of tuples [(key1, value1), (key2, value2), ...] from most recently to least recently used. # Constraints: 1. The cache initializes with a fixed capacity. 2. `1 <= capacity <= 1000` 3. Keys and values used in operations are within the range of typical data types. 4. Typical sequence of operations will not exceed 10000. # Performance Requirements: Ensure that all operations (`get`, `put`, `remove`) have an average time complexity of O(1). # Example Usage: ```python # Initialize an LRU cache with capacity 3 cache = LRUCache(3) cache.put(1, 1) cache.put(2, 2) assert cache.get(1) == 1 # returns 1 cache.put(3, 3) # cache is now {1=1, 2=2, 3=3} cache.put(4, 4) # cache reaches capacity and removes the least recently used item (key=2) assert cache.get(2) == -1 # returns -1 (not found) cache.put(5, 5) # cache is now {3=3, 4=4, 5=5} assert cache.get(3) == 3 # returns 3 cache.remove(3) assert cache.get(3) == -1 # returns -1 (not found) cache.put(6, 6) # cache is now {4=4, 5=5, 6=6} assert cache.display() == [(6, 6), (5, 5), (4, 4)] # returns the current cache items ``` Your task is to complete the given class `LRUCache` and implement the methods as per the description.","solution":"from collections import OrderedDict class LRUCache: def __init__(self, capacity: int): self.cache = OrderedDict() self.capacity = capacity def get(self, key): if key not in self.cache: return -1 self.cache.move_to_end(key) return self.cache[key] def put(self, key, value): if key in self.cache: self.cache.move_to_end(key) self.cache[key] = value if len(self.cache) > self.capacity: self.cache.popitem(last=False) def remove(self, key): if key in self.cache: del self.cache[key] def display(self): return list(self.cache.items())"},{"question":"# Weather Data Analyzer You are provided with a function to analyze weather data fetched from an API. This function should: 1. Fetch the weather data for a specified location. 2. Parse the JSON response to extract relevant weather information. 3. Calculate and display the average temperature for the next 7 days. 4. Display the highest and lowest temperatures for any of the next 7 days. 5. Implement error handling for network issues, invalid location inputs, and malformed JSON responses. # Input - A string representing the location (city name) for which weather data is to be fetched. # Output - The function should print the average temperature for the next 7 days. - It should also print the date(s) of the highest and lowest temperatures forecast within the 7-day period. - Informative messages should be printed for various stages, e.g., \\"Fetching weather data...\\", \\"Processing data...\\", \\"Completed\\", or specific error messages in case of failures. # Constraints - Use the given structure but feel free to add additional helper functions or parameters if needed. - Ensure that your code appropriately handles the common edge cases and error scenarios mentioned above. # Example ```python # Example main invocation if __name__ == \\"__main__\\": location = \\"New York\\" try: analyze_weather_data(location) except Exception as e: print(f\\"Failed to analyze weather data: {e}\\") ```","solution":"import requests def fetch_weather_data(location): Fetches the weather data for the specified location. Args: location (str): The location (city name). Returns: dict: The weather data in JSON format. API_KEY = \'your_api_key_here\' # Replace with your actual API key BASE_URL = \'http://api.openweathermap.org/data/2.5/forecast/daily\' params = { \'q\': location, \'cnt\': 7, \'units\': \'metric\', \'appid\': API_KEY } try: response = requests.get(BASE_URL, params=params) response.raise_for_status() # Raise an error for bad status codes data = response.json() if not data or \'list\' not in data: raise ValueError(\\"Malformed JSON response\\") return data except requests.exceptions.RequestException as e: raise ConnectionError(f\\"Error fetching weather data: {e}\\") except ValueError as ve: raise ValueError(f\\"Error with JSON data: {ve}\\") def analyze_weather_data(location): Analyzes and processes the weather data for the given location. Args: location (str): The location (city name). print(f\\"Fetching weather data for {location}...\\") try: data = fetch_weather_data(location) except Exception as e: print(f\\"Failed to fetch weather data: {e}\\") return print(\\"Processing data...\\") try: temperatures = [day[\'temp\'][\'day\'] for day in data[\'list\']] dates = [day[\'dt\'] for day in data[\'list\']] avg_temp = sum(temperatures) / len(temperatures) max_temp = max(temperatures) min_temp = min(temperatures) max_temp_dates = [dates[i] for i, temp in enumerate(temperatures) if temp == max_temp] min_temp_dates = [dates[i] for i, temp in enumerate(temperatures) if temp == min_temp] print(f\\"Average temperature for the next 7 days: {avg_temp:.2f}°C\\") print(f\\"Highest temperature: {max_temp}°C on dates: {max_temp_dates}\\") print(f\\"Lowest temperature: {min_temp}°C on dates: {min_temp_dates}\\") print(\\"Completed\\") except Exception as e: print(f\\"Error processing data: {e}\\")"},{"question":"# Reversed Sublist Sum Calculation Context and Objective You are maintaining a data processing system where batch operations are performed on sublists of numeric data. One such operation involves reversing a part of the list and then calculating the sum of a specific range within this reversed sublist. Your task is to implement this functionality in an efficient manner. Problem Statement Given a list of integers, a starting index `start`, an ending index `end`, and a query range defined by indices `query_start` and `query_end`, write a function `reversed_sublist_sum` that reverses the sublist from `start` to `end` inclusive, and then calculates the sum of the elements from `query_start` to `query_end` within this reversed sublist. Function Signature ```python def reversed_sublist_sum(numbers: list[int], start: int, end: int, query_start: int, query_end: int) -> int: pass ``` Input Constraints - `numbers`: A list of integers. - `start`, `end`: Non-negative integers where `0 <= start <= end < len(numbers)`. - `query_start`, `query_end`: Non-negative integers where `start <= query_start <= query_end <= end`. Output - Return the sum of the specified range within the reversed sublist. Example ```python # Example 1: numbers = [1, 2, 3, 4, 5] start = 1 end = 3 query_start = 1 query_end = 2 # After reversing sublist from index 1 to 3: [1, 4, 3, 2, 5] # Sum from index 1 to 2: 4 + 3 = 7 assert reversed_sublist_sum(numbers, start, end, query_start, query_end) == 7 # Example 2: numbers = [10, 20, 30, 40, 50] start = 0 end = 4 query_start = 1 query_end = 3 # After reversing sublist from index 0 to 4: [50, 40, 30, 20, 10] # Sum from index 1 to 3: 40 + 30 + 20 = 90 assert reversed_sublist_sum(numbers, start, end, query_start, query_end) == 90 ``` Notes - The sum should only consider the elements within the specified `query_start` to `query_end` indexes after the sublist has been reversed. - Ensure that the function handles lists of varying lengths and ranges efficiently.","solution":"def reversed_sublist_sum(numbers: list[int], start: int, end: int, query_start: int, query_end: int) -> int: Reverses the sublist from index `start` to `end` and calculates the sum of elements from `query_start` to `query_end` within this sublist. # Reverse the specified sublist numbers[start:end+1] = numbers[start:end+1][::-1] # Calculate and return the sum of the specified query range return sum(numbers[query_start:query_end+1])"},{"question":"# Task Implement the `flatten_dictionary` function that takes a nested dictionary and returns a new dictionary with a flattened structure. The keys in the new dictionary should be a concatenation of the nested keys using a provided delimiter. # Function Signature ```python def flatten_dictionary( nested_dict: dict, delimiter: str = \\".\\", ) -> dict: ``` # Input * `nested_dict`: A dictionary that may contain other dictionaries as its values. * `delimiter`: A string to be used to concatenate keys (default is \\".\\"). # Output * Returns a dictionary where all nested keys are flattened into a single level, concatenated by the specified delimiter. # Constraints * Keys in the nested dictionary and their sub-dictionaries are strings. * The nested dictionary can have arbitrary levels of depth. * The delimiter can be any string. # Requirements Your solution should: * Recursively traverse the nested dictionaries to flatten them. * Concatenate keys with the given delimiter. * Handle dictionaries with various depths and structures. * Not mutate the original dictionary. # Examples ```python >>> flatten_dictionary({\\"a\\": 1, \\"b\\": {\\"c\\": 2, \\"d\\": {\\"e\\": 3}}}) {\\"a\\": 1, \\"b.c\\": 2, \\"b.d.e\\": 3} >>> flatten_dictionary({\\"key\\": {\\"subkey\\": {\\"subsubkey\\": \\"value\\"}}}, delimiter=\\"-\\") {\\"key-subkey-subsubkey\\": \\"value\\"} >>> flatten_dictionary({\\"a\\": {\\"b\\": {\\"c\\": {\\"d\\": {\\"e\\": 5}}}}}, delimiter=\\"/\\") {\\"a/b/c/d/e\\": 5} >>> flatten_dictionary({\\"username\\": \\"user1\\", \\"details\\": {\\"address\\": {\\"line1\\": \\"1234 Street\\", \\"line2\\": \\"Apt 567\\"}, \\"contact\\": {\\"phone\\": \\"123-456-7890\\"}}}) {\\"username\\": \\"user1\\", \\"details.address.line1\\": \\"1234 Street\\", \\"details.address.line2\\": \\"Apt 567\\", \\"details.contact.phone\\": \\"123-456-7890\\"} ``` # Notes * Ensure that the function handles an empty dictionary appropriately. * The provided examples illustrate typical usage and expected results. * Consider edge cases, such as varying delimiter lengths or empty nested dictionaries.","solution":"def flatten_dictionary(nested_dict, delimiter=\\".\\"): Flattens a nested dictionary by concatenating keys with a specified delimiter. Args: nested_dict (dict): The dictionary to flatten. delimiter (str): The delimiter to use for concatenating keys. Returns: dict: A flattened dictionary. def _flatten(current_dict, parent_key, result_dict): for k, v in current_dict.items(): new_key = f\\"{parent_key}{delimiter}{k}\\" if parent_key else k if isinstance(v, dict): _flatten(v, new_key, result_dict) else: result_dict[new_key] = v result = {} _flatten(nested_dict, \'\', result) return result"},{"question":"# Question: Number Grouping Background You are tasked with creating a function to group a list of integers into clusters based on specified rules. Each cluster must contain adjacent elements from the sorted list where the difference between the largest and smallest number in the cluster does not exceed the given threshold. If a number does not fit into the current cluster, it starts a new cluster. # Problem Statement: Write a function `group_numbers` that takes a list of integers and a threshold integer and returns a list of lists where each sublist represents a cluster as per the defined rules. # Implementation Details: * **Function Signature**: - `def group_numbers(numbers: List[int], threshold: int) -> List[List[int]]` * **Input/Output**: - `numbers`: A list of integers. - `threshold`: An integer specifying the maximum allowed difference within each cluster. - The output should be a list of clusters (sublists) of integers. # Example Usage: ```python # After implementation assert group_numbers([1, 5, 6, 2, 9, 3], 2) == [[1, 2, 3], [5, 6], [9]] assert group_numbers([10, 20, 30, 12, 23, 35, 15], 5) == [[10, 12, 15], [20, 23], [30, 35]] assert group_numbers([4, 7, 11, 1, 3, 9], 3) == [[1, 3, 4], [7, 9], [11]] # Edge Cases assert group_numbers([], 3) == [] assert group_numbers([5], 2) == [[5]] ``` # Constraints: * The length of the `numbers` list will be at most 1000. * The `threshold` will be a non-negative integer. * Integers in the `numbers` list will be within the range of -10^6 to 10^6. * Maintain clear and readable code with appropriate function and variable naming conventions. This problem will test your ability to work with sorting, list manipulation, and grouping logic in Python.","solution":"from typing import List def group_numbers(numbers: List[int], threshold: int) -> List[List[int]]: Groups a list of integers into clusters where the difference between the largest and smallest number in each cluster does not exceed the given threshold. if not numbers: return [] numbers.sort() clusters = [] current_cluster = [numbers[0]] for num in numbers[1:]: if num - current_cluster[0] <= threshold: current_cluster.append(num) else: clusters.append(current_cluster) current_cluster = [num] clusters.append(current_cluster) return clusters"},{"question":"# Context In many algorithms, particularly those involving data processing and manipulation, it is vital to efficiently reverse specific portions of data sequences. This is a frequently encountered operation in tasks related to computer graphics, data encoding, and other computational problems. # Task You are required to implement a function that reverses the contents of a given sublist within a list. # Requirements Write a function `reverse_sublist(lst: List[int], start: int, end: int) -> List[int]` that: 1. Takes in three inputs: - `lst`: a list of integers, - `start`: the starting index (inclusive) for the sublist to be reversed, - `end`: the ending index (inclusive) for the sublist to be reversed. 2. Returns a new list with the specified sublist reversed. 3. Raises an `IndexError` if `start` or `end` are out of bounds for the list or if `start` is greater than `end`. **Input Constraints**: - The list `lst` can have a length between 1 and 10^4. - The integers in `lst` are within the range -10^5 to 10^5. - 0 ≤ `start` ≤ `end` < len(lst) **Output Format**: - Return a new list with the specified sublist reversed. # Examples ```python >>> reverse_sublist([1, 2, 3, 4, 5], 1, 3) [1, 4, 3, 2, 5] >>> reverse_sublist([10, 20, 30, 40, 50], 0, 4) [50, 40, 30, 20, 10] >>> reverse_sublist([1, 2, 3, 4], 2, 2) [1, 2, 3, 4] >>> reverse_sublist([5, 10, -15, 20], 0, 3) [20, -15, 10, 5] >>> reverse_sublist([1, 2, 3], 0, 5) Traceback (most recent call last): ... IndexError: list index out of range >>> reverse_sublist([1, 2, 3], 3, 2) Traceback (most recent call last): ... IndexError: start index cannot be greater than end index ``` # Notes - Ensure the function handles edge cases, such as reversing a sublist with only one element or reversing the entire list. - Pay attention to list boundaries and make sure to raise appropriate errors when indices are out of bounds or `start` is greater than `end`.","solution":"def reverse_sublist(lst, start, end): Reverses the contents of a specified sublist (from `start` to `end`, inclusive) within the list `lst`. Parameters: lst (List[int]): The list of integers. start (int): The starting index (inclusive) of the sublist to be reversed. end (int): The ending index (inclusive) of the sublist to be reversed. Returns: List[int]: The list with the specified sublist reversed. Raises: IndexError: If `start` or `end` are out of bounds, or if `start` is greater than `end`. if start > end: raise IndexError(\\"start index cannot be greater than end index\\") if start < 0 or end >= len(lst): raise IndexError(\\"list index out of range\\") l_copy = lst[:] l_copy[start:end+1] = l_copy[start:end+1][::-1] return l_copy"},{"question":"# Sum of Path Numbers in a Binary Tree You are required to compute the total sum of all the numbers represented by root-to-leaf paths in a binary tree. Each node in the binary tree contains a digit from 0 to 9. A root-to-leaf path in the tree represents a number formed by concatenating the node values from the root all the way down to the leaf. Function Signature ```python def sum_root_to_leaf_numbers(root: TreeNode) -> int: ``` Input * `root`: The root node of a binary tree. Each node value is an integer between 0 and 9. Output * An integer representing the total sum of all the numbers formed by the root-to-leaf paths in the given binary tree. # Definition for a binary tree node ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` # Examples 1. Given the binary tree: ``` 1 / 2 3 ``` The root-to-leaf paths are 12 and 13. So, `sum_root_to_leaf_numbers(root)` should return `25`. 2. Given the binary tree: ``` 4 / 9 0 / 5 1 ``` The root-to-leaf paths are 495, 491, and 40. So, `sum_root_to_leaf_numbers(root)` should return `1026`. # Instructions Implement the `sum_root_to_leaf_numbers` function by traversing the binary tree. You can use either Depth First Search (DFS) or Breadth First Search (BFS) to solve this problem. Keep track of the current path number and if a leaf node is reached, add the path number to a sum. Key Considerations * Ensure to handle cases where the tree is empty (i.e., `root` is `None`). * Consider the constraints where tree nodes\' values are always between 0 and 9. * Optimize the solution to work efficiently even for larger binary trees. Good Luck!","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sum_root_to_leaf_numbers(root: TreeNode) -> int: Compute the total sum of all the numbers represented by root-to-leaf paths in a binary tree. def dfs(node, current_number): if not node: return 0 current_number = current_number * 10 + node.val # if it\'s a leaf, return the current number if not node.left and not node.right: return current_number # else sum from left and right subtrees left_sum = dfs(node.left, current_number) right_sum = dfs(node.right, current_number) return left_sum + right_sum return dfs(root, 0)"},{"question":"# Coding Challenge: Data encryption is crucial in today’s world to keep information secure. A popular approach to data encryption is using the Caesar Cipher technique, where each letter in the plaintext is replaced by a letter some fixed number of positions down the alphabet. This can be implemented not only for English alphabets but also for numeric data. # Objective: Write a function `caesar_cipher` that: 1. Takes a string and an integer as input where the integer represents the shift value. 2. The function should be able to handle both alphabetic characters (uppercase and lowercase) and digits (0-9), shifting them accordingly. 3. Non-alphanumeric characters should remain unaffected. Expected Input and Output: * **Input**: * A string that can contain letters (both cases), digits, and other characters. * An integer representing the shift for the cipher. * **Output**: * A string where the alphabetic characters are shifted by the given integer value in the alphabet, and digits are shifted in the range 0-9. Performance Requirements: * The function should operate in O(n) time complexity, where n is the length of the string. * The function should handle all valid ASCII character values gracefully without crashing. Constraints and Considerations: * Consider edge cases such as empty strings or strings composed entirely of non-alphanumeric characters. * Ensure shifts that wrap around the end of the alphabet or digits are handled correctly. * Ensure the solution preserves the case of the letters and shifts digits appropriately. * Non-alphanumeric characters should remain in their original positions. # Examples: ```python def caesar_cipher(text: str, shift: int) -> str: pass print(caesar_cipher(\\"Hello, World! 123\\", 3)) # Expected output: \\"Khoor, Zruog! 456\\" print(caesar_cipher(\\"abcXYZ-789\\", -2)) # Expected output: \\"yzaVWX-567\\" print(caesar_cipher(\\"\\", 5)) # Expected output: \\"\\" print(caesar_cipher(\\"123-abc-XYZ\\", 10)) # Expected output: \\"123-klm-HIJ\\" ``` # Note: * You are required to provide a detailed explanation of your implementation choices and any assumptions made.","solution":"def caesar_cipher(text: str, shift: int) -> str: Applies a Caesar cipher to the input text with the specified shift. Args: text (str): The input text to be encrypted. shift (int): The number of positions to shift each letter or digit. Returns: str: The encrypted text with letters and digits shifted. result = [] for char in text: if char.isalpha(): if char.islower(): start = ord(\'a\') result.append(chr((ord(char) - start + shift) % 26 + start)) else: start = ord(\'A\') result.append(chr((ord(char) - start + shift) % 26 + start)) elif char.isdigit(): start = ord(\'0\') result.append(chr((ord(char) - start + shift) % 10 + start)) else: result.append(char) return \'\'.join(result)"},{"question":"# Task You are tasked with implementing a function to efficiently merge two sorted lists into a single sorted list without using built-in sorting functions. # Problem Statement **Function Signature**: ```python def merge_sorted_lists(list1: List[int], list2: List[int]) -> List[int]: \'\'\' Parameters: list1 (List[int]): A sorted list of integers. list2 (List[int]): Another sorted list of integers. Returns: List[int]: A single sorted list containing all elements from both input lists. \'\'\' ``` Your task is to implement the `merge_sorted_lists` function in a way that efficiently merges the two input sorted lists into one sorted list. This process should be done in linear time, maintaining an optimal performance. # Constraints * Both input lists will be sorted in non-decreasing order. * Each list will contain between 1 and `10^5` elements, inclusive. * The elements in the lists are integers and may have negative values. # Examples Example 1: * Input: ```python list1 = [1, 3, 5] list2 = [2, 4, 6] ``` * Output: ```python [1, 2, 3, 4, 5, 6] ``` Example 2: * Input: ```python list1 = [-10, -5, 0] list2 = [-7, -3, 2] ``` * Output: ```python [-10, -7, -5, -3, 0, 2] ``` # Notes * Ensure that your implementation efficiently merges the lists without using any in-built sorting algorithms. * Validate your implementation with unit tests covering edge cases such as empty lists and lists with duplicate values.","solution":"def merge_sorted_lists(list1, list2): Merges two sorted lists into a single sorted list. Parameters: list1 (List[int]): A sorted list of integers. list2 (List[int]): Another sorted list of integers. Returns: List[int]: A single sorted list containing all elements from both input lists. merged_list = [] i, j = 0, 0 while i < len(list1) and j < len(list2): if list1[i] < list2[j]: merged_list.append(list1[i]) i += 1 else: merged_list.append(list2[j]) j += 1 # If there are remaining elements in list1 to add while i < len(list1): merged_list.append(list1[i]) i += 1 # If there are remaining elements in list2 to add while j < len(list2): merged_list.append(list2[j]) j += 1 return merged_list"},{"question":"# Problem Statement As part of a graphical application, you are tasked with implementing a function that calculates the intersection points of two lines in a 2D plane. Each line is represented by two endpoints. Write a Python function `line_intersection` that takes two lines and finds the intersection point, if any. Each line is represented by endpoints, which are instances of a `Point` class with `x` and `y` attributes. # Input Format - Two pairs of instances of the `Point` class, representing the endpoints of each line. # Output Format - If there is a unique intersection point, return an instance of the `Point` class representing that point. - If the lines are parallel and do not intersect, return `None`. - If the lines coincide (infinite intersection points), return the string `\\"Coincide\\"`. # Constraints - The coordinates of the points will all be integers, and their absolute values will be within -1000 and 1000. - Ensure your solution handles precision up to 5 decimal points if necessary. # Example ```python # Example 1 line1_point1 = Point(1, 1) line1_point2 = Point(4, 4) line2_point1 = Point(1, 8) line2_point2 = Point(2, 4) print(line_intersection(line1_point1, line1_point2, line2_point1, line2_point2)) # Output: Point(2.4, 2.4) # Example 2 line1_point1 = Point(1, 1) line1_point2 = Point(4, 4) line2_point1 = Point(2, 2) line2_point2 = Point(3, 3) print(line_intersection(line1_point1, line1_point2, line2_point1, line2_point2)) # Output: \\"Coincide\\" # Example 3 line1_point1 = Point(0, 0) line1_point2 = Point(2, 2) line2_point1 = Point(0, 2) line2_point2 = Point(2, 0) print(line_intersection(line1_point1, line1_point2, line2_point1, line2_point2)) # Output: Point(1.0, 1.0) ``` # Implementation Below is the provided code snippet for the class definition and function: ```python class Point: def __init__(self, x, y): self.x = x self.y = y def __repr__(self) -> str: return f\\"Point({self.x}, {self.y})\\" def line_intersection(p1: Point, p2: Point, p3: Point, p4: Point): Calculate the intersection point of two lines if it exists. # Compute the coefficients of the lines a1 = p2.y - p1.y b1 = p1.x - p2.x c1 = a1 * p1.x + b1 * p1.y a2 = p4.y - p3.y b2 = p3.x - p4.x c2 = a2 * p3.x + b2 * p3.y determinant = a1 * b2 - a2 * b1 if determinant == 0: # Check if the lines coincide if a1 * p3.x + b1 * p3.y == c1: return \\"Coincide\\" else: return None else: x = (b2 * c1 - b1 * c2) / determinant y = (a1 * c2 - a2 * c1) / determinant return Point(round(x, 5), round(y, 5)) # Example usage line1_point1 = Point(0, 0) line1_point2 = Point(2, 2) line2_point1 = Point(0, 2) line2_point2 = Point(2, 0) print(line_intersection(line1_point1, line1_point2, line2_point1, line2_point2)) # Output: Point(1.0, 1.0) ``` Your task is to write the function `line_intersection` as specified above, ensuring it accurately handles the given scenarios and precision requirements.","solution":"class Point: def __init__(self, x, y): self.x = x self.y = y def __repr__(self) -> str: return f\\"Point({self.x}, {self.y})\\" def line_intersection(p1: Point, p2: Point, p3: Point, p4: Point): Calculate the intersection point of two lines if it exists. # Compute the coefficients of the lines a1 = p2.y - p1.y b1 = p1.x - p2.x c1 = a1 * p1.x + b1 * p1.y a2 = p4.y - p3.y b2 = p3.x - p4.x c2 = a2 * p3.x + b2 * p3.y determinant = a1 * b2 - a2 * b1 if determinant == 0: # Check if the lines coincide if a1 * p3.x + b1 * p3.y == c1: return \\"Coincide\\" else: return None else: x = (b2 * c1 - b1 * c2) / determinant y = (a1 * c2 - a2 * c1) / determinant return Point(round(x, 5), round(y, 5))"},{"question":"# Array Partition Problem You need to partition an integer array such that all elements satisfying a given condition are moved to the left side of the array and the remaining elements are moved to the right side. Write a function `partition_array(arr: list[int], predicate: Callable[[int], bool]) -> list[int]` that takes a list of integers and a predicate (a function that returns a boolean) and returns a new list with the elements partitioned according to the predicate. Input - A list of integers `arr`, where each integer represents an element in the array. - A predicate `predicate`, which is a function that takes an integer and returns a boolean. Output - A list of integers with the elements partitioned according to the predicate. Constraints 1. 0 <= len(arr) <= 100,000 2. -1,000,000 <= arr[i] <= 1,000,000 Example ```python >>> def is_even(num): ... return num % 2 == 0 >>> partition_array([5, 2, 1, 4, 3, 6], is_even) [2, 4, 6, 5, 1, 3] >>> def is_positive(num): ... return num > 0 >>> partition_array([-1, 2, -3, 4, -5, 6], is_positive) [2, 4, 6, -1, -3, -5] >>> partition_array([], is_even) [] >>> partition_array([1, 2, 3, 4, 5], lambda x: x < 3) [1, 2, 3, 4, 5, 3, 4, 5] >>> partition_array([0, -1, -2, -3], lambda x: x == 0) [0, -1, -2, -3] ``` # Notes - The relative order of the elements within each partition should be preserved. - Ensure that your function handles edge cases, such as an empty list. - Aim for a solution with optimal time and space complexity. - You are not allowed to import any additional libraries.","solution":"from typing import Callable, List def partition_array(arr: List[int], predicate: Callable[[int], bool]) -> List[int]: Partitions the input list of integers such that elements satisfying the predicate are moved to the left side and remaining elements to the right side. true_part = [x for x in arr if predicate(x)] false_part = [x for x in arr if not predicate(x)] return true_part + false_part"},{"question":"# Flight Route Optimization In the aviation industry, finding the most efficient flight route is crucial for minimizing fuel costs and ensuring timely arrivals. You have been given a task to write a function that will determine the shortest flight path between two cities, avoiding specific cities if necessary. **Problem Statement**: Given a set of flight routes between cities, implement the `shortest_route` function to find the minimum distance needed to travel from a specified starting city to a destination city. The function should also consider an optional list of cities to avoid due to reasons such as weather conditions or airspace restrictions. # Function Signature: ```python def shortest_route(flights: List[Tuple[str, str, int]], start: str, end: str, avoid: List[str] = []) -> int: pass ``` # Input: * `flights` (List[Tuple[str, str, int]]): A list of tuples where each tuple represents a direct flight between two cities and the distance of that flight in kilometers. The format is (city1, city2, distance). * `start` (str): The starting city. * `end` (str): The destination city. * `avoid` (List[str]): An optional list of cities to avoid in the flight path. # Output: * Returns an integer representing the minimum distance to travel from the start city to the end city while avoiding the specified cities. If there\'s no possible route, return -1. # Constraints: * The input `flights` list can contain up to 1000 flight routes. * City names are case-sensitive. * Assume all flight routes have positive distances. * There exists a unique shortest path if one exists. # Example: ```python # Flight routes: [(\\"A\\", \\"B\\", 100), (\\"B\\", \\"C\\", 200), (\\"A\\", \\"C\\", 300)] print(shortest_route([(\\"A\\", \\"B\\", 100), (\\"B\\", \\"C\\", 200), (\\"A\\", \\"C\\", 300)], \\"A\\", \\"C\\")) # Output: 300 # Same routes with city \\"B\\" to avoid print(shortest_route([(\\"A\\", \\"B\\", 100), (\\"B\\", \\"C\\", 200), (\\"A\\", \\"C\\", 300)], \\"A\\", \\"C\\", [\\"B\\"])) # Output: 300 # Introducing additional routes print(shortest_route([(\\"A\\", \\"B\\", 100), (\\"B\\", \\"C\\", 200), (\\"A\\", \\"C\\", 300), (\\"A\\", \\"D\\", 50), (\\"D\\", \\"C\\", 200)], \\"A\\", \\"C\\")) # Output: 250 # Case where no route is possible print(shortest_route([(\\"A\\", \\"B\\", 100), (\\"B\\", \\"C\\", 200)], \\"A\\", \\"C\\", [\\"B\\"])) # Output: -1 ``` # Tests: Provide additional test cases covering conditions such as: - Circular routes to ensure no infinite loops. - Routes with equal distances to test proper selection. - Large numbers of flights and cities to verify performance. - Check edge cases where start city is the same as end city.","solution":"from typing import List, Tuple import heapq def shortest_route(flights: List[Tuple[str, str, int]], start: str, end: str, avoid: List[str] = []) -> int: # Create a graph from the flights data graph = {} for (city1, city2, distance) in flights: if city1 not in graph: graph[city1] = [] if city2 not in graph: graph[city2] = [] graph[city1].append((city2, distance)) graph[city2].append((city1, distance)) # Assuming bidirectional flights # Dijkstra\'s algorithm to find the shortest path pq = [(0, start)] visited = set() distances = {start: 0} while pq: current_distance, current_city = heapq.heappop(pq) if current_city in visited: continue visited.add(current_city) if current_city == end: return current_distance for neighbor, weight in graph.get(current_city, []): if neighbor in avoid or neighbor in visited: continue new_distance = current_distance + weight if new_distance < distances.get(neighbor, float(\'inf\')): distances[neighbor] = new_distance heapq.heappush(pq, (new_distance, neighbor)) return -1 # Return -1 if no route is found"},{"question":"# Coding Question: Build a Configurable Task Scheduler In many software systems, scheduling and running tasks at specific intervals is essential. You need to create a Python module capable of scheduling and executing tasks at specified intervals. The scheduler should support adding new tasks and dynamically adjust their intervals. Objective You are to write a Python class `TaskScheduler` that: 1. Supports adding tasks with specific intervals. 2. Executes tasks at the right intervals in a loop. 3. Allows for dynamically adjusting task intervals. 4. Supports stopping all scheduled tasks gracefully. # Input - Tasks to be scheduled, each with a unique name and interval in seconds. - Functions representing the tasks. # Output - Printed output indicating the task execution time and name. # Example ```python import time from threading import Thread, Event def task1(): print(f\\"Task1 executed at {time.strftime(\'%X\')}\\") def task2(): print(f\\"Task2 executed at {time.strftime(\'%X\')}\\") # Initialize scheduler scheduler = TaskScheduler() # Add tasks scheduler.add_task(\\"task1\\", task1, interval=2) scheduler.add_task(\\"task2\\", task2, interval=5) # Start the scheduler in a separate thread scheduler_thread = Thread(target=scheduler.start_scheduler) scheduler_thread.start() # Let the scheduler run for 10 seconds time.sleep(10) # Adjust interval for task1 scheduler.adjust_interval(\\"task1\\", 3) # Let the scheduler run for another 10 seconds time.sleep(10) # Stop all tasks scheduler.stop_scheduler() scheduler_thread.join() ``` # Requirements - Create a `TaskScheduler` class. - Store tasks and their intervals. - Implement `add_task`, `adjust_interval`, `start_scheduler`, and `stop_scheduler` methods. - Handle multithreading for task execution. - Ensure safe start and stop mechanisms. # Constraints - Execute tasks using Python\'s threading module. - Ensure minimal delay between task executions. - Handle edge cases like invalid task names dynamically without crashing. # Performance - Scheduler should handle up to 100 tasks efficiently. - Minimal CPU overhead during idle periods when no tasks are due. Example Solution Structure ```python import time from threading import Thread, Event from collections import defaultdict class TaskScheduler: def __init__(self): self.tasks = {} self.intervals = {} self.next_run_times = {} self.stop_event = Event() def add_task(self, name: str, func: callable, interval: int): # Your implementation here pass def adjust_interval(self, name: str, new_interval: int): # Your implementation here pass def start_scheduler(self): # Your implementation here pass def stop_scheduler(self): # Your implementation here pass # Example of usage remains the same as before ``` Ensure your solution handles the tasks efficiently and correctly adjusts intervals when required. Implement safety measures to allow the scheduler to stop gracefully.","solution":"import time from threading import Thread, Event class TaskScheduler: def __init__(self): self.tasks = {} self.intervals = {} self.next_run_times = {} self.stop_event = Event() def add_task(self, name: str, func: callable, interval: int): self.tasks[name] = func self.intervals[name] = interval self.next_run_times[name] = time.time() + interval def adjust_interval(self, name: str, new_interval: int): if name in self.tasks: self.intervals[name] = new_interval self.next_run_times[name] = time.time() + new_interval def start_scheduler(self): while not self.stop_event.is_set(): current_time = time.time() for name in self.tasks: if current_time >= self.next_run_times[name]: self.tasks[name]() self.next_run_times[name] = current_time + self.intervals[name] time.sleep(0.1) # sleep a little to avoid busy-waiting def stop_scheduler(self): self.stop_event.set()"},{"question":"# Coding Assessment Question Context Pathfinding algorithms are crucial in various computer science applications, including robotics, gaming, and navigation systems. Identifying the most efficient path in a grid-like environment requires understanding and manipulating data structures. Task Write a function `find_shortest_path(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> int` that finds the shortest path in a 2D grid from a start point to an end point. The grid consists of cells with values 0 and 1, where 0 represents a walkable cell, and 1 represents an obstacle. The function should return the length of the shortest path in terms of the number of steps needed. If there is no possible path, return -1. Input and Output Formats * **Input**: * `grid (List[List[int]])`: A 2D list representing the grid with dimensions m x n where 1 ≤ m, n ≤ 100. * `start (Tuple[int, int])`: A tuple (x, y) representing the starting point where 0 ≤ x < m and 0 ≤ y < n. * `end (Tuple[int, int])`: A tuple (x, y) representing the ending point where 0 ≤ x < m and 0 ≤ y < n. * **Output**: * An integer representing the length of the shortest path. If no path exists, return -1. Constraints and Performance Requirements * You must ensure that the solution efficiently handles the maximum grid dimensions. * Optimize for both time and space complexity using appropriate pathfinding algorithms like BFS. Special Notes 1. Consider edge cases where the start or end point is an obstacle. 2. Ensure that you handle and test scenarios where the path might be blocked or non-existent. Example ```python def find_shortest_path(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> int: pass ``` **Example Usage:** ```python >>> grid = [ ... [0, 0, 1, 0, 0], ... [0, 1, 0, 1, 0], ... [0, 0, 0, 0, 0], ... [1, 1, 1, 1, 0], ... [0, 0, 0, 0, 0] ... ] >>> start = (0, 0) >>> end = (4, 4) >>> find_shortest_path(grid, start, end) 8 >>> grid = [ ... [0, 1], ... [1, 0] ... ] >>> start = (0, 0) >>> end = (1, 1) >>> find_shortest_path(grid, start, end) -1 ```","solution":"from typing import List, Tuple from collections import deque def find_shortest_path(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> int: if not grid or not grid[0] or grid[start[0]][start[1]] == 1 or grid[end[0]][end[1]] == 1: return -1 m, n = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(start[0], start[1], 0)]) # (row, col, distance) visited = set() visited.add(start) while queue: r, c, dist = queue.popleft() if (r, c) == end: return dist for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < m and 0 <= nc < n and (nr, nc) not in visited and grid[nr][nc] == 0: queue.append((nr, nc, dist + 1)) visited.add((nr, nc)) return -1"},{"question":"# Ride Sharing Fare Calculation Background In a ride sharing application, the fare for a ride is calculated based on the distance traveled and the time spent. The fare has the following components: - A base fare that is charged for every ride. - A per km charge that is multiplied by the distance traveled during the ride. - A per minute charge that is multiplied by the time spent on the ride. You need to implement a system to calculate the total fare for a ride given the distance, time, and the rate card. Task Implement a function `calculate_fare` that computes the total fare for a ride given the base fare, per km charge, and per minute charge. **Function Signature:** ```python def calculate_fare(base_fare: float, per_km_charge: float, per_minute_charge: float, distance_km: float, time_minutes: float) -> float: ``` **Parameters:** - `base_fare`: A float representing the base fare charged for every ride. - `per_km_charge`: A float representing the charge per kilometer traveled. - `per_minute_charge`: A float representing the charge per minute spent on the ride. - `distance_km`: A float representing the total distance traveled in kilometers. - `time_minutes`: A float representing the total time spent on the ride in minutes. **Returns:** - A float representing the total fare for the ride. **Constraints:** - All parameters will be non-negative numbers. - Base fare, per km charge, and per minute charge will be in the range ([0, 1000]). - Distance traveled and time spent will be in the range ([0, 1000]). Example ```python base_fare = 50.0 per_km_charge = 10.0 per_minute_charge = 2.0 distance_km = 15.5 time_minutes = 30 total_fare = calculate_fare(base_fare, per_km_charge, per_minute_charge, distance_km, time_minutes) # total_fare should be 211.0 # Explanation: # Base fare = 50.0 # Per km charge = 15.5 * 10.0 = 155.0 # Per minute charge = 30 * 2.0 = 60.0 # Total fare = 50.0 + 155.0 + 60.0 = 265.0 ``` Note Ensure to handle edge cases such as zero distance or zero time and return an accurate fare calculation based on the given formula. ```python def calculate_fare(base_fare: float, per_km_charge: float, per_minute_charge: float, distance_km: float, time_minutes: float) -> float: return base_fare + (per_km_charge * distance_km) + (per_minute_charge * time_minutes) ``` This additional question aligns with the earlier example in terms of style, complexity, and scope by involving straightforward arithmetic operations and realistic constraints found in real-world applications like ride sharing calculations.","solution":"def calculate_fare(base_fare: float, per_km_charge: float, per_minute_charge: float, distance_km: float, time_minutes: float) -> float: Compute the total fare for a ride in a ride-sharing application. Args: - base_fare (float): The base fare charged for every ride. - per_km_charge (float): The charge per kilometer traveled. - per_minute_charge (float): The charge per minute spent on the ride. - distance_km (float): The total distance traveled in kilometers. - time_minutes (float): The total time spent on the ride in minutes. Returns: - float: The total fare for the ride. return base_fare + (per_km_charge * distance_km) + (per_minute_charge * time_minutes)"},{"question":"# Scenario In a software development project, you need to validate if a string can be transformed into a palindrome by reordering its characters. Given that different clients use this check to optimize their algorithms, it is crucial that this implementation is both efficient and correct. # Problem Statement Implement a function `can_form_palindrome(s: str) -> bool` that takes in a single string `s`. The function should return `True` if the characters of the string can be rearranged to form a palindrome and `False` otherwise. # Input and Output Formats * The function will receive one string as an input parameter. * The function will return a boolean `True` or `False`. # Constraints * The input string will only contain lowercase alphabets (`a-z`). * The length of the string can range from 1 to (10^6). # Performance Requirements * The implementation should have linear time complexity (O(n)) where (n) is the length of the string. # Example Cases ```python >>> can_form_palindrome(\\"aabb\\") True >>> can_form_palindrome(\\"aabbcc\\") True >>> can_form_palindrome(\\"abc\\") False >>> can_form_palindrome(\\"aaa\\") True >>> can_form_palindrome(\\"racecar\\") True >>> can_form_palindrome(\\"palindrome\\") False >>> can_form_palindrome(\\"a\\") True ``` # Additional Notes * Ensure the algorithm runs efficiently for the upper limit of the input size. * Consider edge cases such as single-character strings and strings with all identical characters.","solution":"def can_form_palindrome(s: str) -> bool: Determines if the string can be rearranged to form a palindrome. A string can be rearranged to form a palindrome if at most one character has an odd frequency. from collections import Counter char_count = Counter(s) odd_count = sum(1 for count in char_count.values() if count % 2 != 0) return odd_count <= 1"},{"question":"# Sorting and Searching in a Matrix You are developing a feature for a data analytics tool that needs to efficiently search for values in a sorted matrix and return their positions. The matrix is sorted in ascending order both row-wise and column-wise. Task Implement two functions: 1. `find_value(matrix: list[list[int]], target: int) -> tuple[int, int]` 2. `sort_matrix(matrix: list[list[int]]) -> list[list[int]]` # Input - `find_value` - `matrix`: A list of lists where each sublist is a row in the matrix. Each row is sorted in ascending order, and the first element of each row is not larger than the last element of the previous row. - `target`: An integer value to find in the matrix. - `sort_matrix` - `matrix`: A list of lists representing a matrix. The rows and columns may not necessarily be sorted. # Output - `find_value` returns a tuple of two integers representing the row and column indices of the target value in the matrix. If the target is not found, return `(-1, -1)`. - `sort_matrix` returns a new matrix with all the rows and columns sorted in ascending order while maintaining the 2D structure. # Constraints - Matrix dimensions are not more than `100 x 100`. - Integer values in the matrix range from `-10^6` to `10^6`. # Examples ```python matrix1 = [ [1, 4, 7], [2, 5, 8], [3, 6, 9] ] assert find_value(matrix1, 5) == (1, 1) assert find_value(matrix1, 10) == (-1, -1) matrix2 = [ [3, 1, 2], [5, 4, 7], [8, 6, 9] ] sorted_matrix2 = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] assert sort_matrix(matrix2) == sorted_matrix2 ``` # Notes Ensure your implementation handles: - Efficient search for the target value in a matrix that has non-overlapping sorted sublists. - Proper sorting ensuring the whole matrix is ordered correctly without flattening it. - Handling of edge cases like an empty matrix or single-row/column matrices.","solution":"def find_value(matrix, target): Return the position of the target value in the matrix. If the target value is not found, return (-1, -1). :param matrix: list[list[int]] :param target: int :return: tuple[int, int] if not matrix or not matrix[0]: return -1, -1 rows, cols = len(matrix), len(matrix[0]) row, col = 0, cols - 1 # Start from the top-right corner while row < rows and col >= 0: if matrix[row][col] == target: return row, col elif matrix[row][col] > target: col -= 1 else: row += 1 return -1, -1 def sort_matrix(matrix): Return a new matrix with rows and columns sorted in ascending order. :param matrix: list[list[int]] :return: list[list[int]] if not matrix or not matrix[0]: return matrix flat_list = [item for sublist in matrix for item in sublist] flat_list.sort() rows, cols = len(matrix), len(matrix[0]) sorted_matrix = [ [flat_list[i * cols + j] for j in range(cols)] for i in range(rows) ] return sorted_matrix"},{"question":"# Coding Assessment Question You are tasked with the development of a function that simulates a simple stochastic gradient descent (SGD) optimization process for minimizing a quadratic cost function. Your goal is to update the parameter to approximate the optimum value through a series of iterations. # Requirements 1. Implement a function `sgd_optimizer(initial_param: float, learning_rate: float, num_iterations: int, random_seed: int = None) -> float` such that: - `initial_param`: The starting value of the parameter to be optimized. - `learning_rate`: The step size used in each iteration to update the parameter. - `num_iterations`: The number of iterations to perform the optimization. - `random_seed`: An optional parameter to set the seed for reproducibility of the stochastic process. 2. The function should efficiently minimize the cost function ( J(theta) = (theta - 5)^2 ) by updating the parameter using the gradient descent algorithm: - The gradient of the cost function ( J ) with respect to the parameter ( theta ) is ( frac{partial J}{partial theta} = 2(theta - 5) ). 3. Your implementation should be robust with: - Appropriate handling of convergence to avoid overshooting. - Consideration of common edge cases (e.g., initial parameter far from the optimum value). - Utilization of the `random_seed` for stochastic variations in the parameter updates if specified. # Example Input and Output ```python >>> result = sgd_optimizer(0.0, 0.1, 100, 42) >>> 4.9 < result < 5.1 True >>> result = sgd_optimizer(-10.0, 0.01, 1000) >>> 4.9 < result < 5.1 True ``` # Constraints - The initial parameter will be a float. - The number of iterations will be within the range of 1 to 1,000,000. - The learning rate will be a positive float between 0.0001 and 1.0. **Note**: Focus on the correct mathematical implementation of the gradient descent algorithm without using machine learning libraries directly. Ensure precision and correctness in your parameter update calculations.","solution":"import random def sgd_optimizer(initial_param: float, learning_rate: float, num_iterations: int, random_seed: int = None) -> float: if random_seed is not None: random.seed(random_seed) theta = initial_param for _ in range(num_iterations): gradient = 2 * (theta - 5) theta = theta - learning_rate * gradient return theta"},{"question":"# Problem Statement: You are given a list of positive integers where each integer represents the height of a building. You need to write a function `trap_rain_water(heights: list) -> int` that calculates the total volume of water trapped between the buildings when it rains. # Function Signature: ```python def trap_rain_water(heights: list) -> int: ``` # Input: - A list of positive integers, where each integer represents the height of a building. # Output: - Return an integer representing the total volume of water trapped after raining. # Constraints: - The heights list will contain at least one element. - Heights will be positive integers only. # Example: ```python assert trap_rain_water([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) == 6 assert trap_rain_water([4, 2, 0, 3, 2, 5]) == 9 ``` # Notes: - Ensure your implementation handles lists with varying heights correctly. - Make sure to account for edge cases such as lists with uniform height or increasing/decreasing heights. # Additional Challenge: - Optimize your implementation to use O(n) time complexity.","solution":"def trap_rain_water(heights: list) -> int: Calculate the total volume of water trapped between the buildings after raining. :param heights: List of positive integers where each integer represents the height of a building. :return: Integer representing the total volume of water trapped. if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) water_trapped = 0 for i in range(n): water_trapped += min(left_max[i], right_max[i]) - heights[i] return water_trapped"},{"question":"# Programming Assessment Question **Context**: As part of developing a new ecommerce search functionality, you are tasked with an essential operation: finding products whose names match a certain pattern. This pattern is expressed as a string that may include wildcard characters `\'*\'` which matches zero or more characters. **Task**: Implement a function `find_matching_products()` that returns a list of product names from a given list of names that match the specified pattern with wildcards. Function Signature: ```python def find_matching_products(products: list[str], pattern: str) -> list[str]: pass ``` Input: * `products`: List of strings, where each string represents a product name. * `pattern`: String, where the character `\'*\'` serves as a wildcard that matches zero or more characters. Output: * List of strings, representing the product names that match the given pattern. Constraints: * The input list `products` will contain at most 100,000 product names. * Each product name has a maximum length of 100 characters. * The `pattern` string will have a maximum length of 100 characters. * The `products` list will not contain duplicate names. Requirements: * Your function should correctly interpret the `\'*\'` wildcard and find all product names matching the given pattern. * If no products match the pattern, return an empty list. * Preserve the order of product names as they appear in the input list. Example: ```python find_matching_products([\'apple\', \'banana\', \'apricot\', \'mango\', \'pineapple\'], \'a*le\') # Output: [\'apple\'] find_matching_products([\'apple\', \'banana\', \'apricot\', \'mango\', \'pineapple\'], \'*na\') # Output: [\'banana\'] find_matching_products([\'apple\', \'banana\', \'apricot\', \'mango\', \'pineapple\'], \'p*e\') # Output: [\'pineapple\'] find_matching_products([\'apple\', \'banana\', \'apricot\', \'mango\', \'pineapple\'], \'berry\') # Output: [] ``` Additional Notes: * Focus on the correctness of your solution by ensuring wildcard matching is implemented accurately. * Account for edge cases, such as no wildcard characters in the pattern or the pattern matching the entire string. * Ensure the function handles constraints efficiently, considering the large input size.","solution":"import fnmatch def find_matching_products(products, pattern): Returns a list of product names from the given list of names that match the specified pattern with wildcards. matching_products = [product for product in products if fnmatch.fnmatch(product, pattern)] return matching_products"},{"question":"# String Compression In data compression, a common method is run-length encoding (RLE), where consecutive occurrences of the same character are replaced with that character followed by the number of occurrences. For example, the string \\"aaabba\\" becomes \\"a3b2a1\\" and \\"abcd\\" remains \\"a1b1c1d1\\". # Task Write a function `compress_string` that takes a string as input and returns its run-length encoded version. # Function Signature ```python def compress_string(s: str) -> str: pass ``` # Input * A string `s` of length (0 <= len(s) <= 10^5) which contains ASCII characters only. # Output * A string representing the run-length encoded version of the input string. # Example ```python >>> compress_string(\\"aaabba\\") \\"a3b2a1\\" >>> compress_string(\\"abcd\\") \\"a1b1c1d1\\" >>> compress_string(\\"\\") \\"\\" ``` # Constraints 1. The input string can be empty. 2. The string can contain any printable ASCII characters. 3. The function should be efficient enough to handle large input strings of length up to 100,000. # Notes * Aim for an optimal solution that makes a single pass through the input string. * Consider edge cases such as empty strings or strings with no repeated characters.","solution":"def compress_string(s: str) -> str: if not s: return \\"\\" result = [] count = 1 prev_char = s[0] for i in range(1, len(s)): if s[i] == prev_char: count += 1 else: result.append(f\\"{prev_char}{count}\\") prev_char = s[i] count = 1 result.append(f\\"{prev_char}{count}\\") return \'\'.join(result)"},{"question":"# Coding Assessment Question Scenario You are working on data analysis for an online store and need to implement a function that processes a list of sales records. Each record is a dictionary containing details of a sale. Your task is to aggregate the total sales amounts by each product and return the results in a sorted order. Task Implement a function `aggregate_sales` that takes a list of sales records and returns a sorted list of tuples, each containing a product name and its total sales amount. The result should be sorted by the product name in ascending order. Function Signature ```python def aggregate_sales(records: list) -> list: Aggregates total sales by product. :param records: List of dictionaries containing sales records. Each record has keys \'product\' (string) and \'amount\' (float). :return: A sorted list of tuples in the format (product, total_sales). ``` Input * `records`: A list of dictionaries. Each dictionary has the following structure: - `product`: A string denoting the product name. - `amount`: A float representing the sales amount for that product. Output * A sorted list of tuples where each tuple contains: - `product`: A string denoting the product name. - `total_sales`: A float representing the total sales amount for that product. Constraints * The input list can contain zero or more sales records. * Product names are case-sensitive and will contain only alphanumeric characters. * Sales amounts are always non-negative floats. Examples ```python assert aggregate_sales([{\'product\': \'apple\', \'amount\': 10.0}, {\'product\': \'banana\', \'amount\': 5.5}, {\'product\': \'apple\', \'amount\': 3.0}]) == [(\'apple\', 13.0), (\'banana\', 5.5)] assert aggregate_sales([]) == [] assert aggregate_sales([{\'product\': \'apple\', \'amount\': 10.0}]) == [(\'apple\', 10.0)] assert aggregate_sales([{\'product\': \'banana\', \'amount\': 2.0}, {\'product\': \'banana\', \'amount\': 3.0}, {\'product\': \'apple\', \'amount\': 8.0}]) == [(\'apple\', 8.0), (\'banana\', 5.0)] assert aggregate_sales([{\'product\': \'banana\', \'amount\': 0.0}, {\'product\': \'apple\', \'amount\': 0.0}]) == [(\'apple\', 0.0), (\'banana\', 0.0)] ``` Notes * Ensure that your implementation handles edge cases, such as an empty list of records or records with zero sales amounts. * The product names should be unique in the resulting list, aggregating the total sales amounts for each product from multiple records. * Consider performance when aggregating the sales amounts for a potentially large number of records.","solution":"def aggregate_sales(records): Aggregates total sales by product. :param records: List of dictionaries containing sales records. Each record has keys \'product\' (string) and \'amount\' (float). :return: A sorted list of tuples in the format (product, total_sales). from collections import defaultdict sales_dict = defaultdict(float) for record in records: product = record[\'product\'] amount = record[\'amount\'] sales_dict[product] += amount # Converting the dictionary to a sorted list of tuples sorted_sales = sorted(sales_dict.items()) return sorted_sales"},{"question":"# Question: Sorting a List of Tuples by the Second Element Implement a function `sort_by_second_element` that takes a list of tuples and sorts it based on the second element of each tuple in ascending order. If two tuples have the same second element, their relative order from the original list should be maintained. Function Signature ```python def sort_by_second_element(tuples_list: list) -> list: ``` Input - `tuples_list`: A list of tuples, where each tuple contains exactly two integers. Output - A list of tuples sorted based on the second element of each tuple in ascending order. Constraints - The input list can have up to 10^4 tuples. - Each tuple contains exactly two integer values. Examples ```python print(sort_by_second_element([(1, 3), (4, 1), (2, 2)])) # Output: [(4, 1), (2, 2), (1, 3)] print(sort_by_second_element([(1, 1), (2, 1), (3, 1)])) # Output: [(1, 1), (2, 1), (3, 1)] print(sort_by_second_element([(1, 2), (3, 1), (2, 3)])) # Output: [(3, 1), (1, 2), (2, 3)] ``` **Note**: Make sure the function maintains the relative order of tuples when the second elements are equal, demonstrating the concept of stable sorting.","solution":"def sort_by_second_element(tuples_list): Sorts a list of tuples by the second element in each tuple. Uses a stable sorting algorithm to maintain relative order when second elements are the same. :param tuples_list: List of tuples, each containing exactly two integers :return: List of tuples sorted by the second element in each tuple return sorted(tuples_list, key=lambda x: x[1])"},{"question":"# Problem Statement: You are implementing a feature that normalizes a given set of numerical data to a specified range for use in a machine learning model. Specifically, you need to create a function that takes in a list of real numbers and two parameters, `new_min` and `new_max`, to perform Min-Max normalization. The function should output a list where each element is scaled to the new range `[new_min, new_max]`. # Function Signature: ```python def min_max_normalize(data: List[float], new_min: float, new_max: float) -> List[float]: # Your code here ``` # Input: - A list of real numbers `data` of length n, where 1 ≤ n ≤ 10^6. - Two real numbers `new_min` and `new_max` representing the new range. # Output: - A list of the same length as the input list, with elements scaled to the new range `[new_min, new_max]`. # Constraints: - The elements in `data` will range between -10^3 and 10^3. - `new_min` < `new_max`. # Performance requirements: - Your solution should be efficient in both time and space and handle large inputs gracefully. # Example: ```python - Input: [1, 2, 3, 4, 5], 0, 1 - Output: [0.0, 0.25, 0.5, 0.75, 1.0] - Input: [-1, 0, 1], 20, 30 - Output: [20.0, 25.0, 30.0] - Input: [10], 5, 10 - Output: [5.0] ``` # Notes: - If all values in the input list are the same, return a list where each value is set to `new_min`. - Use vectorized operations or efficient computation methods where applicable to ensure performance. - Handle edge cases such as empty lists and constant lists appropriately. # Task: Implement the function as described, ensuring that it meets the performance constraints and correctly handles various edge cases.","solution":"from typing import List def min_max_normalize(data: List[float], new_min: float, new_max: float) -> List[float]: if not data: return [] old_min = min(data) old_max = max(data) if old_min == old_max: return [new_min for _ in data] return [(new_max - new_min) * (x - old_min) / (old_max - old_min) + new_min for x in data]"},{"question":"Coding Assessment Question **Question: Optimal Route Finder in a Directed Weighted Graph** You are tasked with implementing a function that finds the optimal route from a source node to a destination node in a directed weighted graph. The weight of the edges represents the cost of traveling from one node to another. Your function should return the minimum cost if a path exists, or `-1` if there is no path from the source to the destination. # Function Signature ```python def find_optimal_route(n: int, edges: List[Tuple[int, int, int]], src: int, dst: int) -> int: pass ``` # Input * An integer `n` representing the number of nodes in the graph. * A list of `edges` where each edge is represented as a tuple `(u, v, w)` indicating an edge from node `u` to node `v` with a weight `w`. * Two integers `src` and `dst` representing the source and destination nodes, respectively. * Constraints: * The number of nodes ( n ) is such that ( 1 leq n leq 5000 ). * The edges list can contain up to ( 20000 ) edges. * Each edge\'s weight ( w ) is a non-negative integer no greater than ( 10^4 ). # Output * An integer representing the minimum cost to travel from the source node to the destination node. If there is no such path, return `-1`. # Example ```python assert find_optimal_route(5, [(0, 1, 10), (1, 2, 20), (2, 3, 30), (1, 3, 50), (3, 4, 5)], 0, 4) == 65 assert find_optimal_route(3, [(0, 1, 5), (1, 2, 5)], 0, 2) == 10 assert find_optimal_route(3, [(0, 1, 5), (1, 2, 5)], 2, 0) == -1 assert find_optimal_route(1, [], 0, 0) == 0 ``` # Explanation * Your task is to develop the function `find_optimal_route` which takes the number of nodes, the list of edges, the source node, and the destination node as input and returns the minimum cost to reach the destination from the source. * Utilize an efficient shortest path algorithm, such as Dijkstra\'s or Bellman-Ford, to ensure optimal performance for the given constraints. * Handle edge cases, such as graphs with no edges, disconnected nodes, and when the source is the same as the destination.","solution":"import heapq from typing import List, Tuple def find_optimal_route(n: int, edges: List[Tuple[int, int, int]], src: int, dst: int) -> int: # Create an adjacency list adj = {i: [] for i in range(n)} for u, v, w in edges: adj[u].append((v, w)) # Use Dijkstra\'s algorithm to find the shortest path from src to dst pq = [(0, src)] # (cost, node) dist = {i: float(\'inf\') for i in range(n)} dist[src] = 0 while pq: curr_dist, u = heapq.heappop(pq) if u == dst: return curr_dist for v, weight in adj[u]: distance = curr_dist + weight if distance < dist[v]: dist[v] = distance heapq.heappush(pq, (distance, v)) return -1 if dist[dst] == float(\'inf\') else dist[dst]"},{"question":"# Scenario You are developing a utility tool that assists in optimizing the storage usage of various multimedia files. As part of the tool, you need to generate unique identifiers for each filename. The important characteristics of these identifiers are that they should be easy to compare and sort. Typically, such identifiers are created by hashing the contents of the file, but for simplicity, we\'ll focus on generating them from filenames themselves. # Objective Implement a function that generates a unique identifier for a given filename by following certain transformation rules. The identifier should be in lowercase, with all spaces replaced by underscores, and should only contain alphanumeric characters and underscores. # Function Signature ```python def generate_identifier(filename: str) -> str: pass ``` # Input * `filename`: A string representing the name of the file. # Output * A string which is the transformed identifier for the filename, meeting the rules mentioned above. # Constraints * The file name will not exceed 255 characters in length. * The file name may contain spaces, punctuation, and mixed cases. # Requirements * Convert all alphabetic characters to lowercase. * Replace all spaces with underscores. * Remove all characters that are not alphanumeric or underscores. # Example ```python assert generate_identifier(\\"My File 2023.v1\\") == \\"my_file_2023v1\\" assert generate_identifier(\\"Project Plan!Final.docx\\") == \\"project_planfinaldocx\\" assert generate_identifier(\\"image (2).jpeg\\") == \\"image_2jpeg\\" assert generate_identifier(\\"Sample_File_#1\\") == \\"sample_file_1\\" ```","solution":"import re def generate_identifier(filename: str) -> str: Generates a unique identifier for the given filename. The identifier is in lowercase, with all spaces replaced by underscores, and only contains alphanumeric characters and underscores. # Convert to lowercase filename = filename.lower() # Replace spaces with underscores filename = filename.replace(\\" \\", \\"_\\") # Remove all characters that are not alphanumeric or underscores identifier = re.sub(r\'[^a-z0-9_]\', \'\', filename) return identifier"},{"question":"# Problem Statement Sarah is a biologist studying the behavior of a certain species of frogs that follow a distinctive jumping pattern within an array of lily pads. Each lily pad is represented by an integer array `pads` where `pads[i]` indicates the number of jumps a frog can make from pad `i`. Sarah needs to determine if a frog starting from the first lily pad (index 0) can reach the last lily pad (index `n-1`) by making the jumps as described in the `pads` array. Implement a function `can_reach_end(pads: List[int]) -> bool` that returns a boolean indicating if the frog can jump from the start to the end of the array. Input: * `pads` (1 <= len(pads) <= 10^4): A list of integers where each integer represents the maximum jump length from that pad. Output: * Returns `True` if it\'s possible for the frog to reach the last lily pad, otherwise return `False`. Example: * `can_reach_end([2, 3, 1, 1, 4])` should return `True`. * (The frog can jump 2 steps from index 0 to index 2, then 1 step to index 3, and finally 1 step to the last index 4.) * `can_reach_end([3, 2, 1, 0, 4])` should return `False`. * (The frog gets stuck at index 3 because `pads[3]` is 0 and it cannot move further.) Constraints: * The array will contain non-negative integers only. * Ensure that the function achieves efficient performance considering the given constraint (1 <= len(pads) <= 10^4). Notes: * You can adjust the function definition to include necessary imports, for example: `from typing import List`. * Consider edge cases such as the smallest arrays and arrays with large jumps. * Explain the choice of algorithm and how it ensures performance and correctness in comments.","solution":"from typing import List def can_reach_end(pads: List[int]) -> bool: Determines if the frog can jump from the first lily pad to the last lily pad. Args: pads (List[int]): List of integers where each integer represents the maximum jump length from that pad. Returns: bool: True if the frog can reach the last lily pad, False otherwise. max_reachable = 0 n = len(pads) for i in range(n): # If the current index is beyond the furthest point we\'ve reached so far, break out. if i > max_reachable: return False # Update the furthest point reached so far. max_reachable = max(max_reachable, i + pads[i]) # If the furthest point is at or beyond the last index, return True. if max_reachable >= n - 1: return True return False"},{"question":"# Problem Statement **Objective**: Write a function to determine the critical connections in a network using Tarjan\'s algorithm. A critical connection is an edge that, if removed, will make some nodes unable to reach some other nodes. You will be given a graph, represented as an edge list, which may not be connected. Your task is to return a list of all critical connections in the graph. # Function Signature ```python def find_critical_connections(n: int, connections: List[Tuple[int, int]]) -> List[Tuple[int, int]]: pass ``` # Input - **n** (int): The number of nodes in the graph. - **connections** (List[Tuple[int, int]]): The list of edges in the graph where each edge is represented as a tuple of two integers. # Output - Returns a list of tuples. Each tuple represents a critical connection in the graph. # Constraints - The number of nodes, n, is in the range [1, 10^5]. - The number of edges, E, is in the range [0, 10^5]. - The graph may contain multiple components. - The nodes are numbered from 0 to n-1. # Performance Requirements - Ensure that the solution runs efficiently with the provided constraints. # Example ```python n = 4 connections = [(0, 1), (1, 2), (2, 0), (1, 3)] # Expected Output: # [(1, 3)] ``` # Notes - The graph is undirected. - If no critical connections exist, return an empty list. - You can make use of standard library data structures and methods to implement the depth-first search (DFS). # Detailed Explanation - Utilize Tarjan\'s algorithm to find critical connections. - Use low-link values and discovery times to identify critical connections. # Additional Requirement - Include detailed docstrings with examples and explanations for your function, as well as for any helper functions or classes used. ```python def find_critical_connections(n: int, connections: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Finds the critical connections in an undirected graph using Tarjan\'s algorithm. Args: n (int): Number of nodes in the graph. connections (List[Tuple[int, int]]): List of edges represented as tuples of two integers. Returns: List[Tuple[int, int]]: List of tuples representing critical connections in the graph. Example: >>> n = 4 >>> connections = [(0, 1), (1, 2), (2, 0), (1, 3)] >>> find_critical_connections(n, connections) [(1, 3)] from collections import defaultdict def dfs(node: int, parent: int, discovery_time: int) -> None: nonlocal time disc[node] = low[node] = time time += 1 for neighbor in graph[node]: if disc[neighbor] == -1: # if neighbor is not visited dfs(neighbor, node, discovery_time + 1) low[node] = min(low[node], low[neighbor]) if low[neighbor] > disc[node]: critical_connections.append((node, neighbor)) elif neighbor != parent: # update low value of node for parent function calls low[node] = min(low[node], disc[neighbor]) graph = defaultdict(list) for u, v in connections: graph[u].append(v) graph[v].append(u) disc = [-1] * n # stores discovery times of visited vertices low = [-1] * n # earliest visited vertex reachable from subtree time = 0 critical_connections = [] for i in range(n): if disc[i] == -1: dfs(i, -1, 0) return critical_connections ```","solution":"from typing import List, Tuple from collections import defaultdict def find_critical_connections(n: int, connections: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Finds the critical connections in an undirected graph using Tarjan\'s algorithm. Args: n (int): Number of nodes in the graph. connections (List[Tuple[int, int]]): List of edges represented as tuples of two integers. Returns: List[Tuple[int, int]]: List of tuples representing critical connections in the graph. Example: >>> n = 4 >>> connections = [(0, 1), (1, 2), (2, 0), (1, 3)] >>> find_critical_connections(n, connections) [(1, 3)] def dfs(node: int, parent: int) -> None: nonlocal time disc[node] = low[node] = time time += 1 for neighbor in graph[node]: if disc[neighbor] == -1: # If neighbor is not visited dfs(neighbor, node) low[node] = min(low[node], low[neighbor]) if low[neighbor] > disc[node]: critical_connections.append((node, neighbor)) elif neighbor != parent: # Update low value of node for parent function calls low[node] = min(low[node], disc[neighbor]) # Build the graph graph = defaultdict(list) for u, v in connections: graph[u].append(v) graph[v].append(u) # Initialize discovery and lowest rank arrays disc = [-1] * n # Stores discovery times of visited vertices low = [-1] * n # Earliest visited vertex reachable from subtree time = 0 critical_connections = [] # Run DFS for all nodes for i in range(n): if disc[i] == -1: dfs(i, -1) return critical_connections"},{"question":"# Problem Statement Given a list of integers, write a function `all_subsets_sum(nums: List[int]) -> List[int]` that computes all possible sums of subsets within the list and returns these sums in a sorted list without duplicates. Specifications * Write a function `all_subsets_sum(nums: List[int]) -> List[int]` where `nums` is the list of integers. Input - A list of integers `nums` where each integer is within the range -10^3 ≤ `nums[i]` ≤ 10^3. - The list has a length `1 ≤ len(nums) ≤ 20`. Output - Return a list of integers representing all unique subset sums sorted in ascending order. Constraints - The solution should consider the use of sets to handle duplicate sums. - Ensure the function handles edge cases such as an empty or singleton list correctly. Example ```python all_subsets_sum([1, 2, 3]) # -> [0, 1, 2, 3, 4, 5, 6] all_subsets_sum([5]) # -> [0, 5] all_subsets_sum([-1, 1]) # -> [-1, 0, 1] all_subsets_sum([]) # -> [0] all_subsets_sum([1, 2, 2]) # -> [0, 1, 2, 3, 4, 5] ```","solution":"from itertools import combinations from typing import List def all_subsets_sum(nums: List[int]) -> List[int]: Computes all possible sums of subsets within the list and returns these sums in a sorted list without duplicates. unique_sums = set() n = len(nums) # Generate all possible subsets for r in range(n + 1): for subset in combinations(nums, r): unique_sums.add(sum(subset)) return sorted(unique_sums)"},{"question":"# LRU Cache Implementation You are tasked with implementing a Least Recently Used (LRU) cache. The LRU cache should be able to store a specified number of items and should efficiently handle item retrieval and insertion based on the least recently used policy. Input: 1. **Capacity**: Maximum number of items the cache can hold. 2. Sequence of operations, each operation being either: - **\\"set(key, value)\\"**: Insert or update the value for a given key in the cache. - **\\"get(key)\\"**: Retrieve the value for the given key from the cache. Output: * The results of each \\"get\\" operation in the sequence. Constraints: 1. The cache will have a capacity of at most 1000 items. 2. The sequence of operations will contain at most 10000 operations. 3. The keys and values used in the cache are integers. Example: **Input**: ```python capacity = 2 operations = [ (\\"set\\", 1, 1), (\\"set\\", 2, 2), (\\"get\\", 1), # Returns 1 (\\"set\\", 3, 3), (\\"get\\", 2), # Returns -1 (not found) (\\"set\\", 4, 4), (\\"get\\", 1), # Returns -1 (not found) (\\"get\\", 3), # Returns 3 (\\"get\\", 4) # Returns 4 ] ``` **Output**: ```python [1, -1, -1, 3, 4] ``` # Implementation: Using the provided input, you need to implement the following Python class: ```python class LRUCache: def __init__(self, capacity): # Your code here pass def get(self, key): # Your code here pass def set(self, key, value): # Your code here pass ``` **Requirements**: - The cache should support setting and getting key-value pairs. - Ensure the cache respects the LRU policy by evicting the least recently used items when the capacity is exceeded. - Return -1 for any \\"get\\" operation if the key is not found in the cache. Provide your implementation of the `LRUCache` class with the methods `get` and `set` below:","solution":"from collections import OrderedDict class LRUCache: def __init__(self, capacity): self.capacity = capacity self.cache = OrderedDict() def get(self, key): if key not in self.cache: return -1 else: self.cache.move_to_end(key, last=True) return self.cache[key] def set(self, key, value): if key in self.cache: self.cache.move_to_end(key, last=True) self.cache[key] = value if len(self.cache) > self.capacity: self.cache.popitem(last=False)"},{"question":"You are tasked with creating a text-based game where players navigate a grid-based map. Players can move in four directions: up, down, left, and right, and the goal is to reach a specific position on the map. Implement functions to handle the movement logic, check the player\'s position, and determine if the player has reached the goal. # Function to Implement 1. **move**: This function should update the current position of the player based on the given direction (\'U\' for up, \'D\' for down, \'L\' for left, \'R\' for right). The map is 10x10 with the top-left corner being (0, 0) and the bottom-right corner being (9, 9). 2. **get_position**: Return the current position of the player. 3. **check_goal**: Return if the player has reached the goal position. # Input and Output * **move**: - **Input**: A direction string (\'U\', \'D\', \'L\', \'R\') and the current position as a tuple of two integers (x, y). - **Output**: A tuple of two integers representing the new position (x, y) after the move. * **get_position**: - **Input**: None. - **Output**: A tuple of two integers representing the current position (x, y). * **check_goal**: - **Input**: The current position as a tuple of two integers (x, y) and the goal position as a tuple of two integers (gx, gy). - **Output**: A boolean indicating whether the current position matches the goal position. # Constraints * The map dimensions are fixed (10 x 10). * The player\'s initial position will always be within the map bounds. * Moves that would take the player outside the map boundaries should be ignored. * The player\'s position is represented as tuples of two integers (x, y). * The goal position is represented as a tuple of two integers (gx, gy). # Example ```python class Player: def __init__(self, start_x: int, start_y: int): self.position = (start_x, start_y) def move(self, direction: str) -> tuple: pass def get_position(self) -> tuple: pass def check_goal(self, goal_x: int, goal_y: int) -> bool: pass # Example usage: player = Player(0, 0) player.move(\'R\') player.move(\'D\') player.move(\'D\') print(player.get_position()) # Example Output: (1, 2) goal_reached = player.check_goal(1, 2) print(goal_reached) # Example Output: True ``` # Requirements 1. The `move` function must update the player\'s position based on the input direction, ensuring the player does not move outside the map boundaries. 2. The `get_position` function should return the current position of the player as a tuple. 3. The `check_goal` function should verify if the current position matches the provided goal position and return a boolean value accordingly.","solution":"class Player: def __init__(self, start_x: int, start_y: int): self.position = (start_x, start_y) def move(self, direction: str) -> tuple: x, y = self.position if direction == \'U\' and x > 0: x -= 1 elif direction == \'D\' and x < 9: x += 1 elif direction == \'L\' and y > 0: y -= 1 elif direction == \'R\' and y < 9: y += 1 self.position = (x, y) return self.position def get_position(self) -> tuple: return self.position def check_goal(self, goal_x: int, goal_y: int) -> bool: return self.position == (goal_x, goal_y)"},{"question":"Student Grade Calculator **Context**: You have been tasked with developing a simple yet effective grade calculator for a classroom setting. Each student has multiple scores across various assignments, and the program needs to compute the final grade based on these scores. Additionally, the program should determine whether the student passed or failed the course. # Task: Write a function `calculate_final_grade` which takes a list of scores and returns a dictionary containing: - `average_score`: the average score of the student. - `final_grade`: the final grade determined by the average score. - `status`: a string either \'Passed\' or \'Failed\' based on the final grade. # Requirements: 1. **Input**: A list of integers representing scores. (e.g., `[85, 92, 78, 90, 74]`) 2. **Output**: A dictionary with the mentioned keys. 3. **Constraints**: - The input list should contain at least one score and at most 100 scores. - Each score should be an integer between 0 and 100 inclusive. - The average score determines the final grade: - 90-100: \'A\' - 80-89: \'B\' - 70-79: \'C\' - 60-69: \'D\' - Below 60: \'F\' - A student is considered \'Passed\' if they have a final grade of \'D\' or higher, otherwise they \'Failed\'. ```python def calculate_final_grade(scores: list) -> dict: Calculates the average score, final grade, and pass/fail status. :param scores: A list of integers representing scores. :return: Dictionary with keys \'average_score\', \'final_grade\', \'status\'. Example: >>> calculate_final_grade([85, 92, 78, 90, 74]) {\'average_score\': 83.8, \'final_grade\': \'B\', \'status\': \'Passed\'} >>> calculate_final_grade([45, 55, 60]) {\'average_score\': 53.333333333333336, \'final_grade\': \'F\', \'status\': \'Failed\'} pass if __name__ == \\"__main__\\": from doctest import testmod testmod() ``` Test your function with provided examples and add more edge cases to ensure robustness.","solution":"def calculate_final_grade(scores: list) -> dict: Calculates the average score, final grade, and pass/fail status. :param scores: A list of integers representing scores. :return: Dictionary with keys \'average_score\', \'final_grade\', \'status\'. average_score = sum(scores) / len(scores) if 90 <= average_score <= 100: final_grade = \'A\' elif 80 <= average_score < 90: final_grade = \'B\' elif 70 <= average_score < 80: final_grade = \'C\' elif 60 <= average_score < 70: final_grade = \'D\' else: final_grade = \'F\' status = \'Passed\' if final_grade != \'F\' else \'Failed\' return { \'average_score\': average_score, \'final_grade\': final_grade, \'status\': status }"},{"question":"# Scenario As part of a data analysis tool, you need to implement a simple text compression algorithm. One common method is run-length encoding, which compresses sequences of repeated characters by storing the character followed by the number of repetitions. # Task Implement a function `run_length_encoding` that compresses a given string using run-length encoding (RLE). # Function Signature ```python def run_length_encoding(s: str) -> str: ``` # Input * `s`: A string of length `n` (1 ≤ n ≤ 1000). # Output * A string representing the run-length encoded version of the input string. # Constraints * Only lowercase alphabetic characters (\'a\'-\'z\') will be used in the input string. # Example ```python run_length_encoding(\\"aaabbbcccaaa\\") # Output: \\"a3b3c3a3\\" run_length_encoding(\\"abc\\") # Output: \\"a1b1c1\\" run_length_encoding(\\"xxxxxxyyyyz\\") # Output: \\"x6y4z1\\" run_length_encoding(\\"a\\") # Output: \\"a1\\" ``` # Hints * Iterate through the string to count consecutive repeating characters. * Build the encoded string by appending characters and their counts.","solution":"def run_length_encoding(s: str) -> str: Compresses a given string using run-length encoding (RLE). Parameters: s (str): The input string to be compressed. Returns: str: The run-length encoded string. if not s: return \\"\\" encoded = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: encoded.append(f\\"{s[i - 1]}{count}\\") count = 1 # Append the last character and its count encoded.append(f\\"{s[-1]}{count}\\") return \'\'.join(encoded)"},{"question":"# Pascal\'s Triangle Generation Pascal\'s Triangle is a triangular array of the binomial coefficients arranged in a specific pattern. Each row of the triangle represents the coefficients of the binomial expansion ( (x + y)^n ). The triangle starts with a single \\"1\\" at the top (row 0), and each subsequent row is constructed by adding the number above and to the left with the number above and to the right, treating blank entries as 0. You are tasked with implementing a function in Python to generate Pascal\'s Triangle up to a specified number of rows. 1. `generate_pascals_triangle(num_rows: int) -> List[List[int]]`: This function generates Pascal\'s Triangle up to the specified number of rows. - **Input**: - `num_rows` (int): The number of rows to generate. - **Output**: - Returns a list of lists of integers representing Pascal\'s Triangle with `num_rows` rows. - **Constraint**: - The function should raise a `ValueError` if `num_rows` is negative. # Example ```python >>> generate_pascals_triangle(5) [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]] >>> generate_pascals_triangle(1) [[1]] >>> generate_pascals_triangle(0) [] >>> generate_pascals_triangle(-3) Traceback (most recent call last): ... ValueError: Number of rows can\'t be negative. ``` # Constraints - Ensure your code handles large values of `num_rows` efficiently. - The generated triangle should be accurate up to at least 20 rows. # Performance - Time complexity for generating the triangle should be (O(n^2)), where (n) is `num_rows`. - Space complexity for storing the triangle should be (O(n^2)).","solution":"from typing import List def generate_pascals_triangle(num_rows: int) -> List[List[int]]: if num_rows < 0: raise ValueError(\\"Number of rows can\'t be negative.\\") if num_rows == 0: return [] triangle = [[1]] for i in range(1, num_rows): row = [1] previous_row = triangle[i - 1] for j in range(1, i): row.append(previous_row[j - 1] + previous_row[j]) row.append(1) triangle.append(row) return triangle"},{"question":"# File Size Sorter You are tasked with implementing a function in Python that sorts a list of files based on their sizes. Each file is represented by a dictionary containing the file name and its size in bytes. # Objective Write a function `sort_files_by_size` that sorts a list of file dictionaries in ascending order by their size and returns the sorted list. # Function Signature ```python def sort_files_by_size(files: list) -> list: pass ``` # Input - `files` (list): A list of dictionaries, where each dictionary represents a file with the following keys: - `name` (str): The name of the file. - `size` (int): The size of the file in bytes. # Output - The function should return the list of files sorted in ascending order by their size. # Constraints - The list `files` will contain at least one file. - File sizes (`size`) will be non-negative integers. - File names (`name`) will be non-empty strings. # Performance - The function should handle lists with up to (10^5) files efficiently. # Instructions 1. Ensure the function uses an optimal sorting algorithm to handle the size constraints. 2. Handle edge cases such as files with zero size or files with the same size. # Example Scenario Given: ```python files = [ {\\"name\\": \\"file1.txt\\", \\"size\\": 1032}, {\\"name\\": \\"file2.txt\\", \\"size\\": 512}, {\\"name\\": \\"file3.txt\\", \\"size\\": 2048}, {\\"name\\": \\"file4.txt\\", \\"size\\": 512} ] ``` Expected output: ```python [ {\\"name\\": \\"file2.txt\\", \\"size\\": 512}, {\\"name\\": \\"file4.txt\\", \\"size\\": 512}, {\\"name\\": \\"file1.txt\\", \\"size\\": 1032}, {\\"name\\": \\"file3.txt\\", \\"size\\": 2048} ] ``` # Notes - If two files have the same size, maintain their original order (stable sort). - You can use Python\'s built-in sorting functions for simplicity and efficiency.","solution":"def sort_files_by_size(files): Sorts a list of files in ascending order by their sizes. Args: files (list): A list of dictionaries, each representing a file with keys \\"name\\" and \\"size\\". Returns: list: The list of files sorted by size in ascending order. return sorted(files, key=lambda x: x[\\"size\\"])"},{"question":"# Problem Statement You are given an implementation of a stack data structure. Your task is to extend the functionality of this stack to include a method that returns the minimum element in O(1) time. # Function Signature ```python class MinStack: def __init__(self): Initializes the stack with an empty list to hold the elements and another list to keep track of the minimum values. self.stack = [] self.min_stack = [] def push(self, val: int) -> None: Pushes an integer `val` onto the top of the stack. :param val: Integer to add to the stack. self.stack.append(val) if not self.min_stack or val <= self.min_stack[-1]: self.min_stack.append(val) def pop(self) -> None: Removes the element on the top of the stack. Note: Assumes that the stack is not empty. if self.stack: if self.stack[-1] == self.min_stack[-1]: self.min_stack.pop() self.stack.pop() def top(self) -> int: Gets the top element of the stack. :return: The top integer of the stack. if self.stack: return self.stack[-1] return None def get_min(self) -> int: Retrieves the minimum element in the stack in O(1) time. :return: The minimum integer in the stack. if self.min_stack: return self.min_stack[-1] return None ``` # Usage Example ```python min_stack = MinStack() min_stack.push(-2) min_stack.push(0) min_stack.push(-3) print(min_stack.get_min()) # Output: -3 min_stack.pop() print(min_stack.top()) # Output: 0 print(min_stack.get_min()) # Output: -2 ``` # Constraints - All operations (`push`, `pop`, `top`, `get_min`) must operate in O(1) time. - All elements in the stack are integers. - Methods `pop`, `top`, and `get_min` must handle the case where the stack is empty appropriately. # Notes 1. Think carefully about how to maintain an auxiliary stack to keep track of the minimum values. 2. Ensure that both `push` and `pop` operations update the auxiliary stack correctly to maintain the O(1) time complexity for `get_min`.","solution":"class MinStack: def __init__(self): Initializes the stack with an empty list to hold the elements and another list to keep track of the minimum values. self.stack = [] self.min_stack = [] def push(self, val: int) -> None: Pushes an integer `val` onto the top of the stack. :param val: Integer to add to the stack. self.stack.append(val) if not self.min_stack or val <= self.min_stack[-1]: self.min_stack.append(val) def pop(self) -> None: Removes the element on the top of the stack. Note: Assumes that the stack is not empty. if self.stack: if self.stack[-1] == self.min_stack[-1]: self.min_stack.pop() self.stack.pop() def top(self) -> int: Gets the top element of the stack. :return: The top integer of the stack. if self.stack: return self.stack[-1] return None def get_min(self) -> int: Retrieves the minimum element in the stack in O(1) time. :return: The minimum integer in the stack. if self.min_stack: return self.min_stack[-1] return None"},{"question":"# Problem Statement You are asked to implement a system that helps manage a library\'s digital book catalog. The system should allow adding new books, searching for books by title and author, and deleting books from the catalog. # Requirements Implement a class `LibraryCatalog` with the following methods: 1. `add_book(self, title: str, author: str) -> None`: Adds a book to the catalog with the given `title` and `author`. 2. `search_by_title(self, title: str) -> list[dict]`: Returns a list of books that match the given `title`. Each book should be represented as a dictionary with `title` and `author` keys. The search should be case-insensitive. 3. `search_by_author(self, author: str) -> list[dict]`: Returns a list of books that match the given `author`. Each book should be represented as a dictionary with `title` and `author` keys. The search should be case-insensitive. 4. `delete_book(self, title: str, author: str) -> bool`: Deletes the book with the given `title` and `author` from the catalog. Return `True` if the book was successfully deleted, `False` if the book was not found in the catalog. # Constraints * If there are multiple books with the same title and author, consider them as separate entries. * Ensure that the search operations are case-insensitive and return all matching results. * The catalog should handle up to 10,000 books efficiently. # Input and Output Formats * **Input**: * `title: str`: A string representing the book title. * `author: str`: A string representing the author of the book. * **Output**: * `search_by_title` and `search_by_author` should return lists of dictionaries containing `title` and `author` keys. * `delete_book` should return a boolean indicating successful deletion. # Example ```python class LibraryCatalog: def __init__(self): self.catalog = [] def add_book(self, title: str, author: str) -> None: self.catalog.append({\'title\': title, \'author\': author}) def search_by_title(self, title: str) -> list[dict]: return [book for book in self.catalog if book[\'title\'].lower() == title.lower()] def search_by_author(self, author: str) -> list[dict]: return [book for book in self.catalog if book[\'author\'].lower() == author.lower()] def delete_book(self, title: str, author: str) -> bool: for book in self.catalog: if book[\'title\'].lower() == title.lower() and book[\'author\'].lower() == author.lower(): self.catalog.remove(book) return True return False # Example usage library = LibraryCatalog() library.add_book(\\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\") library.add_book(\\"1984\\", \\"George Orwell\\") print(library.search_by_title(\\"1984\\")) print(library.search_by_author(\\"George Orwell\\")) print(library.delete_book(\\"1984\\", \\"George Orwell\\")) print(library.search_by_author(\\"George Orwell\\")) ``` # Notes * Implement reasonable error handling practices to ensure robust operations. * Consider optimizing the search functionality for performance when dealing with large data sets.","solution":"class LibraryCatalog: def __init__(self): # Initialize the catalog as an empty list to store book dictionaries. self.catalog = [] def add_book(self, title: str, author: str) -> None: # Append the new book to the catalog as a dictionary with title and author. self.catalog.append({\'title\': title, \'author\': author}) def search_by_title(self, title: str) -> list: # Perform a case-insensitive search for books by title. return [book for book in self.catalog if book[\'title\'].lower() == title.lower()] def search_by_author(self, author: str) -> list: # Perform a case-insensitive search for books by author. return [book for book in self.catalog if book[\'author\'].lower() == author.lower()] def delete_book(self, title: str, author: str) -> bool: # Perform a case-insensitive check and remove the first matched book from the catalog. for book in self.catalog: if book[\'title\'].lower() == title.lower() and book[\'author\'].lower() == author.lower(): self.catalog.remove(book) return True # If no matching book is found, return False. return False"},{"question":"# Problem Statement Implement a function to determine if a given string can be segmented into a space-separated sequence of one or more dictionary words. Your task involves the following steps: 1. **Sub-problem Identification**: Identify sub-problems using dynamic programming. 2. **Table Construction**: Construct a table that records whether the string up to a certain point can be segmented into dictionary words. 3. **Final Decision**: Use the table to determine if the entire string can be segmented into dictionary words. # Function Signature ```python def word_break(s: str, word_dict: list[str]) -> bool: pass ``` # Input/Output Formats * **word_break**: - **Input**: - `s`: A string consisting of lowercase alphabets. - `word_dict`: A list of strings where each string is a dictionary word. - **Output**: A boolean value `True` if the string can be segmented into a space-separated sequence of one or more dictionary words, and `False` otherwise. # Constraints * `1 <= len(s) <= 300` * `1 <= len(word_dict) <= 1000` * `1 <= len(word) <= 20` for each word in `word_dict` * All the strings in `word_dict` are non-empty and contain lowercase alphabets only. # Example ```python assert word_break(\\"leetcode\\", [\\"leet\\", \\"code\\"]) == True assert word_break(\\"applepenapple\\", [\\"apple\\", \\"pen\\"]) == True assert word_break(\\"catsandog\\", [\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"]) == False assert word_break(\\"cars\\", [\\"car\\", \\"ca\\", \\"rs\\"]) == True ``` # Implementation Notes 1. **Dynamic Programming Table**: Initialize a boolean array of size `len(s) + 1` with all values set to `False`. Set the first value to `True` because an empty string is considered segmented. 2. **Iterate and Mark**: Using nested loops, iterate over the string and mark positions in the array that can be segmented based on the dictionary words. 3. **Final Check**: The value at the last index of the table indicates whether the entire string can be segmented. Here\'s a step-by-step description of solving the word segmentation problem using dynamic programming. You\'ll need to check all possible word breaks to see if the word can be formed from the dictionary entries.","solution":"def word_break(s: str, word_dict: list[str]) -> bool: Determine if the string s can be segmented into a space-separated sequence of dictionary words. word_set = set(word_dict) # Convert list to set for O(1) lookups dp = [False] * (len(s) + 1) dp[0] = True # Base case: empty string can be segmented for i in range(1, len(s) + 1): for j in range(i): if dp[j] and s[j:i] in word_set: dp[i] = True break return dp[-1]"},{"question":"# Problem Statement You need to develop a `StringModifier` class that efficiently manages a collection of strings. The class should allow for adding, removing, and updating strings while maintaining a lexicographical order of the strings through sorted operations. Additionally, you should provide methods for finding specific strings and producing results based on prefix matches. Implement the `StringModifier` class with the following methods: 1. **`__init__`**: - Initialize the necessary data structures to store the strings in a sorted manner. 2. **`binary_search_insert`**: - Given a sorted list, insert a specific string maintaining sorted order and return the modified list. - Ensure you handle invalid inputs and raise errors appropriately (e.g., string already present in the list). 3. **`binary_search_delete`**: - Given a sorted list, remove a specific string and return the modified list. - Ensure you handle invalid inputs and raise errors appropriately (e.g., string not in the list). 4. **`add_string`**: - Add a new string to the collection, ensuring the collection remains sorted. 5. **`remove_string`**: - Remove a specific string from the collection, ensuring the collection remains sorted. 6. **`find_string`**: - Given a string, find and return its index in the collection. - Return -1 if the string is not present. 7. **`find_prefix`**: - Given a prefix, find and return all strings that start with the given prefix, maintaining lexicographical order. # Requirements - For each method, write thorough unit tests to verify correctness, including edge cases. - The program should maintain O(log n) complexity for modifications and O(1) for lookups. - Handle edge cases such as empty inputs and duplicate strings appropriately in all methods. # Example Usage ```python mod = StringModifier() # Adding strings mod.add_string(\\"apple\\") mod.add_string(\\"banana\\") assert mod.find_string(\\"apple\\") == 0 assert mod.find_string(\\"banana\\") == 1 # Removing a string mod.remove_string(\\"apple\\") assert mod.find_string(\\"apple\\") == -1 # Finding strings with a prefix mod.add_string(\\"blueberry\\") mod.add_string(\\"blackberry\\") assert mod.find_prefix(\\"bl\\") == [\\"blackberry\\", \\"blueberry\\"] assert mod.find_prefix(\\"ba\\") == [\\"banana\\"] ```","solution":"from bisect import bisect_left, bisect_right class StringModifier: def __init__(self): self.strings = [] def binary_search_insert(self, sorted_list, string): pos = bisect_left(sorted_list, string) if pos < len(sorted_list) and sorted_list[pos] == string: raise ValueError(\\"String already present in the list\\") sorted_list.insert(pos, string) return sorted_list def binary_search_delete(self, sorted_list, string): pos = bisect_left(sorted_list, string) if pos >= len(sorted_list) or sorted_list[pos] != string: raise ValueError(\\"String not found in the list\\") sorted_list.pop(pos) return sorted_list def add_string(self, string): self.binary_search_insert(self.strings, string) def remove_string(self, string): self.binary_search_delete(self.strings, string) def find_string(self, string): pos = bisect_left(self.strings, string) if pos < len(self.strings) and self.strings[pos] == string: return pos return -1 def find_prefix(self, prefix): start = bisect_left(self.strings, prefix) end = bisect_right(self.strings, prefix + \'uffff\') return self.strings[start:end]"},{"question":"# Coding Assessment Question **Context**: You\'re working on optimizing a sorting algorithm for a large dataset. Your goal is to reduce the runtime by focusing on sorting only a part of a dataset based on specified indices. You are to implement a function that sorts a subarray within the dataset. **Task**: Write a function `partial_sort` that sorts only the segment of a numpy array between two specified indices, inclusive. Function Signature: ```python def partial_sort(array: np.ndarray, start_index: int, end_index: int) -> np.ndarray: ``` Parameters: * `array` (np.ndarray): The input numeric numpy array that needs partial sorting. * `start_index` (int): The starting index of the segment to sort. * `end_index` (int): The ending index of the segment to sort (inclusive). Returns: * `np.ndarray`: A numpy array where only the segment from `start_index` to `end_index` is sorted, and the rest of the array remains unchanged. Examples: ```python >>> partial_sort(np.array([10, 3, 7, 2, 8, 15, 1]), start_index=1, end_index=4) array([10, 2, 3, 7, 8, 15, 1]) >>> partial_sort(np.array([4, 9, 1, 6, 5, 7]), start_index=0, end_index=2) array([1, 4, 9, 6, 5, 7]) ``` # Constraints: * The input array will always have at least one element. * The `start_index` and `end_index` will always be valid indices within the array. * Ensure your solution is efficient, especially for large arrays. Additional Information: You can refer to the following link for details on sorting algorithms: [Sorting Algorithms](https://en.wikipedia.org/wiki/Sorting_algorithm)","solution":"import numpy as np def partial_sort(array: np.ndarray, start_index: int, end_index: int) -> np.ndarray: Sorts the subarray from start_index to end_index (inclusive). Args: array (np.ndarray): The input numeric numpy array. start_index (int): The starting index of the segment to sort. end_index (int): The ending index of the segment to sort. Returns: np.ndarray: A numpy array where only the segment from start_index to end_index is sorted. # Create a copy of the array to avoid modifying the original array sorted_array = array.copy() # Extract the subarray to sort subarray = sorted_array[start_index:end_index + 1] # Sort the subarray subarray.sort() # Place the sorted subarray back into the correct position sorted_array[start_index:end_index + 1] = subarray return sorted_array"},{"question":"# Problem Statement You have been tasked with building a simplified version of a code review tool. The goal is to identify potentially inefficient loops by finding nested loops in a given piece of code represented as a string. # Requirements Write a function `find_nested_loops(code: str) -> bool` that takes a string of code and returns a boolean indicating whether it contains nested loops. # Input Format - `code`: A single string representing a snippet of code (1 ≤ length of `code` ≤ 1,000). # Output Format - A single boolean value: `True` if nested loops exist in the code, `False` otherwise. # Constraints - The code can contain any valid Python syntax. - Only Python’s loop constructs `for` and `while` should be considered. - Consider nested loops if they appear directly inside each other or nested within any level of compound statements. - Code can contain comments or other non-loop constructs, which should be ignored. # Example ```python assert find_nested_loops( for i in range(10): for j in range(10): print(i, j) ) == True assert find_nested_loops( for i in range(10): print(i) while True: pass ) == False assert find_nested_loops( if condition: for i in range(10): do_something() else: while another_condition: do_something_else() ) == False assert find_nested_loops( for i in range(10): if condition: while another_condition: do_something() ) == True ``` # Notes - Ensure that the analysis correctly handles various Python constructs including if-else statements, functions, and indentation levels. - Aim to balance clarity and performance in your implementation.","solution":"def find_nested_loops(code: str) -> bool: Takes a string of code and returns a boolean indicating whether it contains nested loops. lines = code.split(\'n\') loop_stack = [] for line in lines: stripped_line = line.strip() # Check opening of a for or while loop if stripped_line.startswith(\\"for \\") or stripped_line.startswith(\\"while \\"): indent_level = len(line) - len(stripped_line) # Check for nested loop by comparing indentation levels while loop_stack and loop_stack[-1] >= indent_level: loop_stack.pop() if loop_stack: return True loop_stack.append(indent_level) return False"},{"question":"# Problem Statement **Dynamic Range Sum** You are given an array of integers and a number of queries. Each query can be of two types: 1. Update - Update the value at a specific index in the array. 2. Sum - Find the sum of values in a given range from the array. Your task is to efficiently process these queries on the array using appropriate data structures. # Task Write a class `DynamicRangeSum` that performs the following: * Initialize the array. * Update the value at a specific index. * Sum the values in a specific range. Class Definition ```python class DynamicRangeSum: def __init__(self, arr: List[int]): # Constructor to initialize the data structure with the array. def update(self, index: int, value: int): # Update the value at the specified index in the array. def range_sum(self, left: int, right: int) -> int: # Return the sum of the values in the range [left, right] inclusive. ``` # Input 1. The class initialization method is provided with a list of integers `arr` (1 ≤ len(arr) ≤ 100,000 and -10^9 ≤ arr[i] ≤ 10^9). 2. The `update` method receives two integers: `index` (0 ≤ index < len(arr)) and `value` (-10^9 ≤ value ≤ 10^9). 3. The `range_sum` method receives two integers: `left` and `right` (0 ≤ left ≤ right < len(arr)). # Output * The `range_sum` method returns a single integer, the sum of the values in the specified range. # Examples ```python arr = [1, 3, 5, 7, 9, 11] drs = DynamicRangeSum(arr) assert drs.range_sum(1, 3) == 15 # 3 + 5 + 7 drs.update(1, 10) assert drs.range_sum(1, 3) == 22 # 10 + 5 + 7 assert drs.range_sum(0, 5) == 43 # 1 + 10 + 5 + 7 + 9 + 11 ``` # Constraints * The array length will be between 1 and 100,000. * Handling the sum and update operations efficiently is essential to operate within the time limits. # Guidance 1. **Optimal Data Structures**: Consider using Segment Trees, BIT (Fenwick Tree), or similar data structures to handle frequent updates and range sum queries efficiently. 2. **Complexity**: Aim for an initialization complexity of O(n log n), update complexity of O(log n), and query complexity of O(log n).","solution":"class DynamicRangeSum: def __init__(self, arr): self.n = len(arr) self.arr = arr self.tree = [0] * (2 * self.n) self.build_tree() def build_tree(self): # Initialize the segment tree for i in range(self.n): self.tree[self.n + i] = self.arr[i] for i in range(self.n - 1, 0, -1): self.tree[i] = self.tree[2 * i] + self.tree[2 * i + 1] def update(self, index, value): # Update the value at the specified index in the array pos = index + self.n self.tree[pos] = value while pos > 1: pos //= 2 self.tree[pos] = self.tree[2 * pos] + self.tree[2 * pos + 1] def range_sum(self, left, right): # Return the sum of the values in the range [left, right] inclusive left += self.n right += self.n total = 0 while left <= right: if left % 2 == 1: total += self.tree[left] left += 1 if right % 2 == 0: total += self.tree[right] right -= 1 left //= 2 right //= 2 return total"},{"question":"# Domino Tiling Problem You are given an `M x N` grid and an unlimited supply of `2 x 1` dominos. Your task is to determine whether it is possible to completely tile the grid using these `2 x 1` dominos without any gaps or overlaps. If it\'s possible, return `True`; otherwise, return `False`. # Function Signature ```python def can_tile_grid(m: int, n: int) -> bool: pass ``` # Input * `m` (int): The number of rows in the grid. (1 ≤ m ≤ 100) * `n` (int): The number of columns in the grid. (1 ≤ n ≤ 100) # Output * Return `True` if it is possible to completely tile the grid using `2 x 1` dominos; otherwise, return `False`. # Constraints * The grid dimensions will always be positive integers. * Each `2 x 1` domino must entirely fit within the grid boundaries. # Example ```python print(can_tile_grid(2, 3)) # Expected output: False print(can_tile_grid(2, 4)) # Expected output: True print(can_tile_grid(3, 3)) # Expected output: False print(can_tile_grid(4, 4)) # Expected output: True ``` # Notes * Consider simple mathematical properties to determine the possibility of tiling. * Make sure to account for both even and odd dimensions when designing your solution.","solution":"def can_tile_grid(m: int, n: int) -> bool: Determines whether it is possible to completely tile an M x N grid using 2 x 1 dominos. Args: m (int): The number of rows in the grid. n (int): The number of columns in the grid. Returns: bool: True if it is possible to completely tile the grid, False otherwise. # The area of the grid must be even for it to be possible to tile it with 2x1 dominos return (m * n) % 2 == 0"},{"question":"# Background: In web development, URL shortening is a common practice to make URLs easier to share and manage. The process involves creating a shortened alias that redirects to the original URL. To implement such a service, you need a way to encode and decode URLs. # Task: Implement a class that encodes and decodes URLs. The class should convert a long URL to a shorter version and provide a way to retrieve the original URL from the shortened version. Ensure that the encoding and decoding are consistent. # Class Signature: ```python class URLShortener: def __init__(self): pass def encode(self, long_url: str) -> str: pass def decode(self, short_url: str) -> str: pass ``` # Input: - `long_url`: A string representing a long URL to be encoded. - `short_url`: A string representing a shortened URL to be decoded. # Output: - `encode`: Returns a string that is the shortened version of the long URL. - `decode`: Returns a string that is the original long URL corresponding to the given shortened URL. # Constraints: - Each long URL should have a unique shortened URL. - The class should be able to handle cases where the same URL is encoded multiple times. - The encoding and decoding processes should be efficient in terms of time and space complexity. # Examples: ```python url_shortener = URLShortener() short_url = url_shortener.encode(\\"https://www.example.com\\") print(short_url) # Expected: Some shortened version of the URL like \\"http://short.url/abc123\\" original_url = url_shortener.decode(short_url) print(original_url) # Expected: \\"https://www.example.com\\" # Multiple encodings of the same URL should yield the same short URL print(url_shortener.encode(\\"https://www.example.com\\") == short_url) # Expected: True # Decoding a short URL should yield the original URL print(url_shortener.decode(short_url) == \\"https://www.example.com\\") # Expected: True ``` # Scenario: You are building a URL shortening service for a web platform where users can generate and share shorter URLs instead of the original long ones. The implementation should be robust and handle cases where the same original URL is requested to be shortened multiple times. Make sure the encoded URLs are unique and the decoding retrieves the appropriate original URLs.","solution":"class URLShortener: def __init__(self): self.url_to_code = {} self.code_to_url = {} self.base_url = \\"http://short.url/\\" self.counter = 0 def encode(self, long_url: str) -> str: Encodes a long URL to a shortened URL. if long_url in self.url_to_code: return self.base_url + self.url_to_code[long_url] else: code = self._generate_code() self.url_to_code[long_url] = code self.code_to_url[code] = long_url return self.base_url + code def decode(self, short_url: str) -> str: Decodes a shortened URL to its original long URL. code = short_url[len(self.base_url):] return self.code_to_url.get(code, \\"\\") def _generate_code(self): Generates a unique code for the URL. self.counter += 1 return str(self.counter)"},{"question":"# Question: Social Network Graph Analysis Function You are tasked with creating a function that analyzes a social network graph. The graph is represented as an adjacency list, where each node corresponds to a user, and the edges represent friendships between users. Function Specifications: * **Function Name**: `analyze_social_network` * **Input**: - `adjacency_list: dict` - A dictionary where the keys are user IDs (integers) and the values are lists of friend IDs (integers). * **Output**: A dictionary with the following keys: - `number_of_users`: Total number of users in the network. - `number_of_connections`: Total number of connections (friendships) in the network. - `most_popular_user`: The user ID with the maximum number of friends. - `largest_component`: A list of user IDs in the largest connected component of the network. Constraints: - Assume all user IDs are integers and unique. - Assume the input graph is undirected (i.e., if user A is a friend of user B, then user B is a friend of user A). - Optimize for efficiency in calculating the largest connected component. ```python from collections import deque, defaultdict def analyze_social_network(adjacency_list): Analyze the social network represented as an adjacency list. Args: adjacency_list (dict): Dictionary where keys are user IDs and values are lists of friend IDs. Returns: dict: Dictionary with analysis results. # Calculate number of users number_of_users = len(adjacency_list) # Calculate number of connections number_of_connections = sum(len(friends) for friends in adjacency_list.values()) // 2 # Find the most popular user most_popular_user = max(adjacency_list, key=lambda user: len(adjacency_list[user])) # Function to perform BFS and return the component containing the start node def bfs(start, visited): queue = deque([start]) component = [] visited[start] = True while queue: node = queue.popleft() component.append(node) for neighbor in adjacency_list[node]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) return component # Find the largest connected component visited = defaultdict(lambda: False) largest_component = [] for user in adjacency_list: if not visited[user]: component = bfs(user, visited) if len(component) > len(largest_component): largest_component = component return { \'number_of_users\': number_of_users, \'number_of_connections\': number_of_connections, \'most_popular_user\': most_popular_user, \'largest_component\': largest_component, } # Example usage: # social_network = { # 1: [2, 3], # 2: [1, 4], # 3: [1], # 4: [2, 5], # 5: [4], # } # analysis_result = analyze_social_network(social_network) # print(analysis_result) ``` Example Usage Given the social network: ```python social_network = { 1: [2, 3], 2: [1, 4], 3: [1], 4: [2, 5], 5: [4], } ``` The expected output would be: ```python { \'number_of_users\': 5, \'number_of_connections\': 4, \'most_popular_user\': 1, \'largest_component\': [1, 2, 3, 4, 5], } ```","solution":"from collections import deque, defaultdict def analyze_social_network(adjacency_list): Analyze the social network represented as an adjacency list. Args: adjacency_list (dict): Dictionary where keys are user IDs and values are lists of friend IDs. Returns: dict: Dictionary with analysis results. # Calculate number of users number_of_users = len(adjacency_list) # Calculate number of connections number_of_connections = sum(len(friends) for friends in adjacency_list.values()) // 2 # Find the most popular user most_popular_user = max(adjacency_list, key=lambda user: len(adjacency_list[user])) # Function to perform BFS and return the component containing the start node def bfs(start, visited): queue = deque([start]) component = [] visited[start] = True while queue: node = queue.popleft() component.append(node) for neighbor in adjacency_list[node]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) return component # Find the largest connected component visited = defaultdict(lambda: False) largest_component = [] for user in adjacency_list: if not visited[user]: component = bfs(user, visited) if len(component) > len(largest_component): largest_component = component return { \'number_of_users\': number_of_users, \'number_of_connections\': number_of_connections, \'most_popular_user\': most_popular_user, \'largest_component\': largest_component, }"},{"question":"# Problem Statement You are tasked with implementing two functions: `reverse_words` and `reverse_each_word`. These functions will perform string manipulations involving the reversal of words within a sentence. **Function 1: `reverse_words`** - **Input**: A `str` object `sentence` containing a sentence of words separated by spaces. - **Output**: A `str` object where the order of the words in the input sentence is reversed. - **Constraints**: - The input `sentence` is non-empty and contains only alphabetic characters and spaces. - Words in the sentence are separated by single spaces. **Function 2: `reverse_each_word`** - **Input**: A `str` object `sentence` containing a sentence of words separated by spaces. - **Output**: A `str` object where each word in the input sentence is reversed in place, while the order of the words remains the same. - **Constraints**: - The input `sentence` is non-empty and contains only alphabetic characters and spaces. - Words in the sentence are separated by single spaces. # Example ```python def reverse_words(sentence: str) -> str: \'\'\' This function takes a sentence and reverses the order of the words. \'\'\' pass # TODO: Write the implementation here def reverse_each_word(sentence: str) -> str: \'\'\' This function takes a sentence and reverses each word in place. \'\'\' pass # TODO: Write the implementation here # Test Cases assert reverse_words(\'Hello World\') == \'World Hello\' assert reverse_words(\'Programming is fun\') == \'fun is Programming\' assert reverse_words(\'Python\') == \'Python\' assert reverse_each_word(\'Hello World\') == \'olleH dlroW\' assert reverse_each_word(\'Programming is fun\') == \'gnimmargorP si nuf\' assert reverse_each_word(\'Python\') == \'nohtyP\' ``` **Additional Note**: - Ensure your implementation handles sentences with multiple words correctly. - Pay attention to edge cases, such as single-word sentences or sentences with varying word lengths. - The implementation should be efficient and should not use more memory than necessary.","solution":"def reverse_words(sentence: str) -> str: This function takes a sentence and reverses the order of the words. return \' \'.join(sentence.split()[::-1]) def reverse_each_word(sentence: str) -> str: This function takes a sentence and reverses each word in place. return \' \'.join(word[::-1] for word in sentence.split())"},{"question":"Finding Primes using the Sieve of Eratosthenes **Scenario**: As a software engineer, you have been asked to develop an efficient algorithm to find all prime numbers up to a given integer. This will be employed in various cryptographic applications where large primes are essential. Implement the Sieve of Eratosthenes to solve this problem efficiently. **Task**: Implement the function `sieve_of_eratosthenes(n)` that returns a list of all prime numbers less than or equal to the integer `n` using the Sieve of Eratosthenes algorithm. **Function Signature**: ```python def sieve_of_eratosthenes(n: int) -> List[int]: ``` **Input**: * `n`: An integer representing the upper limit up to which primes need to be found. **Output**: * A list of integers representing all prime numbers less than or equal to `n`. **Constraints**: * `2 <= n <= 10^6` **Example**: ```python print(sieve_of_eratosthenes(10)) # Expected output: [2, 3, 5, 7] print(sieve_of_eratosthenes(19)) # Expected output: [2, 3, 5, 7, 11, 13, 17, 19] print(sieve_of_eratosthenes(1)) # Expected output: [] print(sieve_of_eratosthenes(30)) # Expected output: [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] ``` **Note**: Ensure the algorithm is implemented efficiently, making use of appropriate data structures to store and update the list of prime candidates.","solution":"from typing import List def sieve_of_eratosthenes(n: int) -> List[int]: if n < 2: return [] is_prime = [True] * (n + 1) p = 2 # Start with the first prime number while p * p <= n: if is_prime[p]: for i in range(p * p, n + 1, p): is_prime[i] = False p += 1 return [p for p in range(2, n + 1) if is_prime[p]]"},{"question":"# Problem Statement Write a function that calculates the monthly payment required to pay off a loan within a given number of months, using the annuity formula. The annuity formula is used to calculate the payment amount of a loan that is paid off regularly (monthly) and includes a fixed interest rate. # Function Signature ```python def calculate_monthly_payment(principal: float, annual_rate: float, months: int) -> float: pass ``` # Input - `principal`: A positive float representing the loan amount in dollars. - `annual_rate`: A positive float representing the annual interest rate as a percentage (e.g., 5 for 5%). - `months`: A positive integer representing the number of months over which the loan is to be repaid. # Output - A float representing the monthly payment in dollars. # Constraints - The `principal` must be a positive float. - The `annual_rate` must be a non-negative float. (0 is considered valid, representing a zero interest loan) - The `months` must be a positive integer. # Requirement - If any input parameter does not meet the above constraints, raise a `ValueError` with the message `\\"principal must be positive, annual_rate must be non-negative, and months must be positive integer\\"`. # Examples 1. `calculate_monthly_payment(100000, 5, 360)` returns `536.82` 2. `calculate_monthly_payment(5000, 3.5, 24)` returns `215.39` 3. `calculate_monthly_payment(20000, 7, 60)` returns `396.02` 4. `calculate_monthly_payment(200000, 0, 240)` returns `833.33` 5. `calculate_monthly_payment(-20000, 7, 60)` raises `ValueError` 6. `calculate_monthly_payment(50000, 5, 0)` raises `ValueError` # Context This problem involves financial calculations and requires understanding of the annuity formula, which is key in determining loan repayments. It tests your ability to handle numerical calculations and validate input correctly. # Detailed Instructions 1. Validate the input parameters to ensure they meet the specified constraints. 2. Apply the annuity formula to calculate the monthly payment: [ text{Monthly Payment} = frac{P cdot r}{1 - (1 + r)^{-n}} ] where: - (P) is the `principal` - (r) is the monthly interest rate (annual interest rate divided by 12 and divided by 100) - (n) is the number of months (`months`) 3. Return the calculated monthly payment rounded to 2 decimal places. 4. Handle invalid input appropriately by raising a `ValueError` with the specified message. ```python def calculate_monthly_payment(principal: float, annual_rate: float, months: int) -> float: if principal <= 0 or annual_rate < 0 or months <= 0: raise ValueError(\\"principal must be positive, annual_rate must be non-negative, and months must be positive integer\\") monthly_rate = (annual_rate / 100) / 12 if monthly_rate == 0: return round(principal / months, 2) else: payment = principal * monthly_rate / (1 - (1 + monthly_rate) ** -months) return round(payment, 2) ```","solution":"def calculate_monthly_payment(principal: float, annual_rate: float, months: int) -> float: if principal <= 0 or annual_rate < 0 or months <= 0: raise ValueError(\\"principal must be positive, annual_rate must be non-negative, and months must be positive integer\\") monthly_rate = (annual_rate / 100) / 12 if monthly_rate == 0: return round(principal / months, 2) else: payment = principal * monthly_rate / (1 - (1 + monthly_rate) ** -months) return round(payment, 2)"},{"question":"ReLU Activation Function Implementation You are tasked with implementing the ReLU (Rectified Linear Unit) activation function for an input array of real numbers, which is commonly used in various neural network architectures. # Function Specification **Function**: `custom_relu(vector: np.ndarray) -> np.ndarray` Input - `vector` (numpy.ndarray): A numpy array of real numbers for which the ReLU activation function needs to be computed. Output - `numpy.ndarray`: A numpy array of the same shape as the input, containing the results after applying the ReLU activation function. Constraints - The input array will have at least one element. - The input array can have both positive and negative values. # Formula The ReLU function is defined as: [ f(x) = max(0, x) ] # Example ```python import numpy as np # Input vector = np.array([3.0, -1.5, 2.2, -0.3, 0, 4.7]) # Output # Result after applying ReLU Activation function output = custom_relu(vector) print(output) # Expected: array([3.0, 0.0, 2.2, 0.0, 0.0, 4.7]) ``` # Notes: - Make sure to handle edge cases such as the presence of zero or negative values appropriately. - Include proper error handling to manage any unexpected input formats or values. **Good luck!**","solution":"import numpy as np def custom_relu(vector: np.ndarray) -> np.ndarray: Applies the ReLU activation function to the input vector. Parameters: vector (numpy.ndarray): A numpy array of real numbers. Returns: numpy.ndarray: A numpy array with ReLU applied element-wise. return np.maximum(0, vector)"},{"question":"# Analyzing Movie Ratings from a CSV file As a data analyst working alongside a movie production company, it is essential to process and analyze movie ratings periodically. You are tasked with writing a function that reads a CSV file containing movie ratings and calculates several statistics. Task Write a Python function `analyze_movie_ratings(file_path: str) -> dict` that reads a CSV file containing movie titles and their corresponding ratings, and returns a dictionary with various statistical calculations. # Input - A string `file_path` representing the path to the CSV file to read from. The CSV file contains two columns, `Title` and `Rating`, where `Title` is a string and `Rating` is a float number ranging from 1.0 to 10.0. # Output - A dictionary with the following keys and corresponding values: - `\\"total_movies\\"`: An integer representing the total number of movies in the dataset. - `\\"average_rating\\"`: A float representing the average rating of all movies. - `\\"highest_rated_movie\\"`: A string representing the title of the movie with the highest rating. - `\\"lowest_rated_movie\\"`: A string representing the title of the movie with the lowest rating. # Requirements and Constraints 1. **Libraries**: Use `csv` module for reading CSV files. 2. **Average Rating Precision**: The average rating should be rounded to two decimal places. 3. **Edge Cases**: Handle cases where the CSV file is empty or contains rows with missing or invalid data for rating. # Example Suppose the CSV file `movies.csv` contains the following data: ```csv Title,Rating Inception,8.8 Interstellar,8.6 The Dark Knight,9.0 Memento,8.4 ``` Your function should return: ```python { \\"total_movies\\": 4, \\"average_rating\\": 8.7, \\"highest_rated_movie\\": \\"The Dark Knight\\", \\"lowest_rated_movie\\": \\"Memento\\" } ``` Implement the function `analyze_movie_ratings` to meet the described requirements and considerations.","solution":"import csv def analyze_movie_ratings(file_path: str) -> dict: movies = [] ratings = [] with open(file_path, mode=\'r\') as file: reader = csv.DictReader(file) for row in reader: title = row.get(\'Title\') try: rating = float(row.get(\'Rating\')) movies.append(title) ratings.append(rating) except (TypeError, ValueError): continue if not ratings: return { \\"total_movies\\": 0, \\"average_rating\\": 0.0, \\"highest_rated_movie\\": \\"\\", \\"lowest_rated_movie\\": \\"\\" } total_movies = len(movies) average_rating = round(sum(ratings) / total_movies, 2) max_rating_index = ratings.index(max(ratings)) min_rating_index = ratings.index(min(ratings)) highest_rated_movie = movies[max_rating_index] lowest_rated_movie = movies[min_rating_index] return { \\"total_movies\\": total_movies, \\"average_rating\\": average_rating, \\"highest_rated_movie\\": highest_rated_movie, \\"lowest_rated_movie\\": lowest_rated_movie }"},{"question":"# Coding Challenge: Graph Traversal and Shortest Path You are tasked with enhancing an existing navigation application by implementing efficient algorithms that determine the shortest path between any two points in a city. The city\'s map is represented as a graph where intersections are nodes and roads are edges with non-negative weights representing the travel time. Implement a class `GraphShortestPath` that supports: 1. **Adding Nodes and Edges** to the graph. 2. **Finding the shortest path** between two intersections using Dijkstra\'s Algorithm. Input and Output Formats * **Initialization**: - Method: `__init__()` - Initializes an empty graph. * **Adding Nodes**: - Method: `add_node(node)` - Input: `node`, a string representing the intersection. - Adds the node to the graph. * **Adding Edges**: - Method: `add_edge(from_node, to_node, weight)` - Input: `from_node`, `to_node`, strings representing the intersections; `weight`, a non-negative integer representing the travel time. - Adds a directed edge from `from_node` to `to_node` with the given `weight`. * **Shortest Path**: - Method: `shortest_path(start_node, end_node)` - Input: `start_node`, `end_node`, strings representing the intersections. - Output: Returns a tuple consisting of the shortest travel time and the path taken as a list of nodes. - If no path exists, return `(float(\'inf\'), [])`. - Constraint: `start_node` and `end_node` must be in the set of nodes added. Example ```python # Example of creating the graph and finding the shortest path g = GraphShortestPath() g.add_node(\'A\') g.add_node(\'B\') g.add_node(\'C\') g.add_edge(\'A\', \'B\', 5) g.add_edge(\'B\', \'C\', 10) g.add_edge(\'A\', \'C\', 15) time, path = g.shortest_path(\'A\', \'C\') # time should be 15, path should be [\'A\', \'C\'] ``` Implementation Requirements 1. Use Dijkstra\'s Algorithm for finding the shortest path. 2. Ensure each operation runs in optimal time for the input size, i.e., adding nodes and edges should be O(1), and finding the shortest path should run in O((E + V) log V) where E is the number of edges and V is the number of vertices. 3. Handle invalid inputs by returning appropriate error messages or values. ```python import heapq from collections import defaultdict class GraphShortestPath: def __init__(self): self.graph = defaultdict(list) self.nodes = set() def add_node(self, node): self.nodes.add(node) def add_edge(self, from_node, to_node, weight): if from_node in self.nodes and to_node in self.nodes: self.graph[from_node].append((to_node, weight)) else: raise ValueError(\\"One or both of the nodes are not in the graph.\\") def shortest_path(self, start_node, end_node): if start_node not in self.nodes or end_node not in self.nodes: return float(\'inf\'), [] distances = {node: float(\'inf\') for node in self.nodes} distances[start_node] = 0 priority_queue = [(0, start_node, [start_node])] while priority_queue: current_distance, current_node, path = heapq.heappop(priority_queue) if current_distance > distances[current_node]: continue if current_node == end_node: return current_distance, path for neighbor, weight in self.graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor, path + [neighbor])) return float(\'inf\'), [] # Example usage g = GraphShortestPath() g.add_node(\'A\') g.add_node(\'B\') g.add_node(\'C\') g.add_edge(\'A\', \'B\', 5) g.add_edge(\'B\', \'C\', 10) g.add_edge(\'A\', \'C\', 15) time, path = g.shortest_path(\'A\', \'C\') # Expected output: (15, [\'A\', \'C\']) ``` **Note**: Implement the `GraphShortestPath` class to properly follow the described methods and ensure it can handle the graph operations efficiently.","solution":"import heapq from collections import defaultdict class GraphShortestPath: def __init__(self): self.graph = defaultdict(list) self.nodes = set() def add_node(self, node): self.nodes.add(node) def add_edge(self, from_node, to_node, weight): if from_node in self.nodes and to_node in self.nodes: self.graph[from_node].append((to_node, weight)) else: raise ValueError(\\"One or both of the nodes are not in the graph.\\") def shortest_path(self, start_node, end_node): if start_node not in self.nodes or end_node not in self.nodes: return (float(\'inf\'), []) distances = {node: float(\'inf\') for node in self.nodes} distances[start_node] = 0 priority_queue = [(0, start_node, [start_node])] while priority_queue: current_distance, current_node, path = heapq.heappop(priority_queue) if current_distance > distances[current_node]: continue if current_node == end_node: return (current_distance, path) for neighbor, weight in self.graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor, path + [neighbor])) return (float(\'inf\'), []) # Example usage # g = GraphShortestPath() # g.add_node(\'A\') # g.add_node(\'B\') # g.add_node(\'C\') # g.add_edge(\'A\', \'B\', 5) # g.add_edge(\'B\', \'C\', 10) # g.add_edge(\'A\', \'C\', 15) # time, path = g.shortest_path(\'A\', \'C\') # Expected output: (15, [\'A\', \'C\'])"},{"question":"# Problem Description You are required to implement a function that checks if a given string `s1` is a permutation of another string `s2`. A permutation is defined as a rearrangement of the characters of a string to form another string. The strings are case-sensitive and whitespace is treated as a character. # Function Signature ```python def is_permutation(s1: str, s2: str) -> bool: Function to check if one string is a permutation of another. Args: s1 (str): The first string for permutation check. s2 (str): The second string for permutation check. Returns: bool: True if s1 is a permutation of s2, otherwise False. Example: >>> is_permutation(\\"ABC\\", \\"CBA\\") True # \\"CBA\\" is a permutation of \\"ABC\\" >>> is_permutation(\\"hello\\", \\"bello\\") False # \\"bello\\" is not a permutation of \\"hello\\" >>> is_permutation(\\" \\", \\" \\") False # \\" \\" (three spaces) is not a permutation of \\" \\" (one space) >>> is_permutation(\\"aabbcc\\", \\"abcabc\\") True # \\"abcabc\\" is a permutation of \\"aabbcc\\" ``` # Constraints * `s1` and `s2` consist of any visible ASCII characters, spaces included. * The lengths of `s1` and `s2` will be between 1 and 1000 characters. * The solution should be efficient in both time and space complexity. # Requirements: 1. The function should correctly handle cases where string lengths differ. 2. Should consider edge cases with empty strings and strings with special characters. # Implementation Goals * Aim for a time complexity of O(n), where n is the length of the strings. * Consider using data structures like dictionaries or sorting techniques to achieve this efficiently. # Example Scenarios * For `s1 = \\"ABC\\"` and `s2 = \\"CBA\\"`, the result should be `True` since \\"CBA\\" is a permutation of \\"ABC\\". # Further Considerations * How does your implementation handle edge cases like different lengths of input strings? * How do you ensure the solution is optimized for character comparisons?","solution":"def is_permutation(s1: str, s2: str) -> bool: Check if s1 is a permutation of s2. Args: s1 (str): The first string. s2 (str): The second string. Returns: bool: True if s1 is a permutation of s2, False otherwise. # If the lengths of the strings are different, they cannot be permutations if len(s1) != len(s2): return False # Use dictionary to count occurrences of each character in s1 char_count = {} for ch in s1: char_count[ch] = char_count.get(ch, 0) + 1 # Decrease count based on characters found in s2 for ch in s2: if ch in char_count: char_count[ch] -= 1 if char_count[ch] == 0: del char_count[ch] else: return False # If char_count is empty, s1 is a permutation of s2 return len(char_count) == 0"},{"question":"# Dataset Filtering Based on Conditions As a data scientist, you are working on a data analysis project that requires filtering a dataset based on dynamic conditions provided by the user. Your task is to design a function that filters and returns subsets of the data based on given criteria. Your task involves the following steps: 1. **Implement Filter Function**: Write a function `filter_data(data, conditions)` that: * Takes as input: * `data`, a list of dictionaries where each key-value pair represents a column name and its corresponding value. * `conditions`, a dictionary where the key is a column name and the value is a tuple of the form `(operator, value)` where `operator` is one of the strings `\'==\', \'!=\', \'>\', \'<\', \'>=\', \'<=\'` and `value` is the value to compare. * Returns: * A list of dictionaries that meet all the specified conditions. 2. **Condition Handling**: The function should interpret and apply each condition to filter the dataset properly. Ensure the function handles various data types for values (like integers, floats, and strings). **Input and Output Format:** Input: ```python data = [ {\\"id\\": 1, \\"age\\": 25, \\"name\\": \\"Alice\\"}, {\\"id\\": 2, \\"age\\": 30, \\"name\\": \\"Bob\\"}, {\\"id\\": 3, \\"age\\": 22, \\"name\\": \\"Charlie\\"}, {\\"id\\": 4, \\"age\\": 25, \\"name\\": \\"David\\"} ] conditions = {\\"age\\": (\\">\\", 23), \\"name\\": (\\"!=\\", \\"Alice\\")} ``` Output: ```python [{\\"id\\": 2, \\"age\\": 30, \\"name\\": \\"Bob\\"}, {\\"id\\": 4, \\"age\\": 25, \\"name\\": \\"David\\"}] ``` Your implementation must account for different types of conditions and ensure that the data is filtered correctly and efficiently. ```python def filter_data(data, conditions): Filter a dataset based on given conditions. Args: data (list of dict): Dataset to filter. conditions (dict): Filtering conditions. Returns: list of dict: Filtered dataset. result = [] for item in data: valid = True for col, (op, val) in conditions.items(): if op == \\"==\\": valid = valid and (item[col] == val) elif op == \\"!=\\": valid = valid and (item[col] != val) elif op == \\">\\": valid = valid and (item[col] > val) elif op == \\"<\\": valid = valid and (item[col] < val) elif op == \\">=\\": valid = valid and (item[col] >= val) elif op == \\"<=\\": valid = valid and (item[col] <= val) if valid: result.append(item) return result # Example usage (you can use this for testing your function): data = [ {\\"id\\": 1, \\"age\\": 25, \\"name\\": \\"Alice\\"}, {\\"id\\": 2, \\"age\\": 30, \\"name\\": \\"Bob\\"}, {\\"id\\": 3, \\"age\\": 22, \\"name\\": \\"Charlie\\"}, {\\"id\\": 4, \\"age\\": 25, \\"name\\": \\"David\\"} ] conditions = {\\"age\\": (\\">\\", 23), \\"name\\": (\\"!=\\", \\"Alice\\")} filtered_data = filter_data(data, conditions) print(filtered_data) # Expected output: [{\\"id\\": 2, \\"age\\": 30, \\"name\\": \\"Bob\\"}, {\\"id\\": 4, \\"age\\": 25, \\"name\\": \\"David\\"}] ```","solution":"def filter_data(data, conditions): Filter a dataset based on given conditions. Args: data (list of dict): Dataset to filter. conditions (dict): Filtering conditions. Returns: list of dict: Filtered dataset. result = [] for item in data: valid = True for col, (op, val) in conditions.items(): if op == \\"==\\": valid = valid and (item[col] == val) elif op == \\"!=\\": valid = valid and (item[col] != val) elif op == \\">\\": valid = valid and (item[col] > val) elif op == \\"<\\": valid = valid and (item[col] < val) elif op == \\">=\\": valid = valid and (item[col] >= val) elif op == \\"<=\\": valid = valid and (item[col] <= val) if valid: result.append(item) return result"},{"question":"# Coding Assessment Question Problem Statement You are given a singly linked list implemented as a class, with methods to insert values and traverse the list. Your task is to extend this class to support additional functionality. Objective 1. Write a function `find_nth_from_end` that finds and returns the n-th node from the end of the linked list. The list is zero-indexed from the head. 2. Handle edge cases effectively (e.g., n is out of the bounds of the list size). Implementation Details Extend the provided class with the following function: ```python def find_nth_from_end(self, n: int) -> int: ``` - **Input**: - `n`: The position (0-based index) from the end of the list. - **Output**: - Returns the value of the n-th node from the end (type `int`). - If `n` is out of the bounds (i.e., `n` < 0 or `n` >= number of nodes), return `None`. Constraints - Assume the list contains integer values. - Handle an empty list correctly (should return `None` regardless of `n`). Performance Requirements - The solution should ideally traverse the list only once, achieving O(n) time complexity, where n is the number of nodes in the list. Example ```python # Example usage: linked_list = SinglyLinkedList() linked_list.insert(10) linked_list.insert(20) linked_list.insert(30) linked_list.insert(40) linked_list.insert(50) # This should return 30 (the list is [10, 20, 30, 40, 50] and the 2nd from the end is 30) nth_element = linked_list.find_nth_from_end(2) print(nth_element) # Output: 30 # This should return None since there is no 5th element from the end nth_element = linked_list.find_nth_from_end(5) print(nth_element) # Output: None ``` Notes - You may use a helper function if needed to maintain clear and efficient code. - Remember to handle the input constraints and verify if the position `n` is within the valid range.","solution":"class Node: def __init__(self, data): self.data = data self.next = None class SinglyLinkedList: def __init__(self): self.head = None def insert(self, data): new_node = Node(data) if not self.head: self.head = new_node return last_node = self.head while last_node.next: last_node = last_node.next last_node.next = new_node def find_nth_from_end(self, n: int) -> int: # Using two-pointer technique to find nth node from end first_pointer = second_pointer = self.head # Advance first pointer by n+1 steps for _ in range(n + 1): if first_pointer is None: return None # Out of bounds first_pointer = first_pointer.next # Move both pointers until first_pointer reaches the end while first_pointer is not None: first_pointer = first_pointer.next second_pointer = second_pointer.next if second_pointer is not None: return second_pointer.data else: return None"},{"question":"Scenario: You are developing a web application for a shopping platform. One of the features of this platform is to manage the shopping cart, which allows users to add and remove items. To maintain a smooth user experience, the system needs to keep track of the most recently added items so the user can remove them in reverse order if they decide to undo their actions. The `ShoppingCart` data structure provided below is a stack that tracks the items added to the cart. Each item has a name and a quantity. When the user decides to remove the latest item, this item will be popped from the stack and the system should update the cart accordingly. # Objective: Using the `ShoppingCart` data structure provided below, implement the `remove_latest_item` function which should handle removing the most recently added item from the cart. # Function Signature: ```python def remove_latest_item(cart: ShoppingCart) -> tuple: pass ``` # Input: - A `ShoppingCart` stack of tuples, where each tuple contains: - A string representing the item name. - An integer representing the quantity of the item. # Output: - A tuple containing the name and quantity of the removed item. # Constraints: - The function should raise an `IndexError` if the cart is empty when attempting to remove an item. # Example Usage: ```python >>> cart = ShoppingCart() >>> cart.push((\\"Apples\\", 2)) >>> cart.push((\\"Bananas\\", 5)) >>> cart.push((\\"Cherries\\", 6)) >>> remove_latest_item(cart) (\\"Cherries\\", 6) >>> remove_latest_item(cart) (\\"Bananas\\", 5) >>> cart.is_empty() False >>> remove_latest_item(cart) (\\"Apples\\", 2) >>> cart.is_empty() True >>> remove_latest_item(cart) Traceback (most recent call last): ... IndexError: pop from empty cart ``` # Additional Notes: - Ensure the function manages the stack implementation properly, including edge cases such as attempting to remove an item from an empty cart. - Optimize the function to handle removal operations efficiently, leveraging the O(1) complexity of stack operations. # Helper Code: ```python class Node: def __init__(self, data): self.data = data self.next = None class ShoppingCart: def __init__(self): self.top = None def push(self, item: tuple): new_node = Node(item) new_node.next = self.top self.top = new_node def pop(self): if self.top is None: raise IndexError(\\"pop from empty cart\\") data = self.top.data self.top = self.top.next return data def is_empty(self): return self.top is None ``` Implement your function below: ```python def remove_latest_item(cart: ShoppingCart) -> tuple: return cart.pop() ```","solution":"class Node: def __init__(self, data): self.data = data self.next = None class ShoppingCart: def __init__(self): self.top = None def push(self, item: tuple): new_node = Node(item) new_node.next = self.top self.top = new_node def pop(self): if self.top is None: raise IndexError(\\"pop from empty cart\\") data = self.top.data self.top = self.top.next return data def is_empty(self): return self.top is None def remove_latest_item(cart: ShoppingCart) -> tuple: return cart.pop()"},{"question":"# Binary Tree Serialization and Deserialization Design and implement algorithms to serialize and deserialize a binary tree. Input: * A binary tree node where each node contains an integer value and two children pointers (`left` and `right`). Output: * `serialize`: A string representation of the binary tree following a specific format. * `deserialize`: Restore the binary tree from its serialized string representation. Serialization Format: * The tree is serialized in a Breadth-First Search (BFS) manner, where each level\'s nodes are represented left to right. * `null` is represented as `None`. Constraints: * The number of nodes in the tree is between 1 and 1000. * Node values are unique integers within the range `[-1000, 1000]`. Performance Requirements: * Optimize your solution to handle both serialization and deserialization efficiently for large binary trees. # Example: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right # Input Tree: # 1 # / # 2 3 # / # 4 5 # # Serialized Output: \'1,2,3,None,None,4,5\' # Deserialized Tree: Same structure as the Input Tree ``` # Implementation: ```python class Codec: def serialize(self, root): Encodes a tree to a single string. if not root: return \'None\' queue = [root] res = [] while queue: node = queue.pop(0) if node: res.append(str(node.val)) queue.append(node.left) queue.append(node.right) else: res.append(\'None\') return \',\'.join(res) def deserialize(self, data): Decodes your encoded data to tree. if data == \'None\': return None nodes = data.split(\',\') root = TreeNode(int(nodes[0])) queue = [root] index = 1 while queue: node = queue.pop(0) if nodes[index] != \'None\': node.left = TreeNode(int(nodes[index])) queue.append(node.left) index += 1 if nodes[index] != \'None\': node.right = TreeNode(int(nodes[index])) queue.append(node.right) index += 1 return root # Test the Codec class codec = Codec() root = TreeNode(1, TreeNode(2), TreeNode(3, TreeNode(4), TreeNode(5))) data = codec.serialize(root) print(data) # Output: \'1,2,3,None,None,4,5\' tree = codec.deserialize(data) serialized_again = codec.serialize(tree) print(serialized_again) # Output: \'1,2,3,None,None,4,5\' ```","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class Codec: def serialize(self, root): Encodes a tree to a single string. if not root: return \'None\' queue = [root] res = [] while queue: node = queue.pop(0) if node: res.append(str(node.val)) queue.append(node.left) queue.append(node.right) else: res.append(\'None\') return \',\'.join(res) def deserialize(self, data): Decodes your encoded data to tree. if data == \'None\': return None nodes = data.split(\',\') root = TreeNode(int(nodes[0])) queue = [root] index = 1 while queue: node = queue.pop(0) if nodes[index] != \'None\': node.left = TreeNode(int(nodes[index])) queue.append(node.left) index += 1 if nodes[index] != \'None\': node.right = TreeNode(int(nodes[index])) queue.append(node.right) index += 1 return root"},{"question":"**Scenario**: You are tasked with creating a function that rotates the elements of a given 2D matrix by 90 degrees in a clockwise direction. This exercise will test your understanding of matrix manipulation and spatial transformations. **Problem Statement**: Write a function `rotate_matrix(matrix: List[List[int]]) -> List[List[int]]` that takes a square matrix and rotates it by 90 degrees clockwise. # Function Signature ```python from typing import List def rotate_matrix(matrix: List[List[int]]) -> List[List[int]]: ``` # Input * `matrix` (1 <= len(matrix) <= 1000): A list of lists representing a square matrix with integer elements. # Output * A list of lists representing the rotated matrix. # Constraints * The matrix will always be square (number of rows equals number of columns) and will contain integers. * The rotation should be done in-place without using any extra space for another matrix of the same size (O(1) space complexity). # Example ```python >>> rotate_matrix([ [1, 2, 3], [4, 5, 6], [7, 8, 9] ]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> rotate_matrix([ [1, 2], [3, 4] ]) [[3, 1], [4, 2]] >>> rotate_matrix([ [1] ]) [[1]] >>> rotate_matrix([ [1, 1, 1, 1], [2, 2, 2, 2], [3, 3, 3, 3], [4, 4, 4, 4] ]) [[4, 3, 2, 1], [4, 3, 2, 1], [4, 3, 2, 1], [4, 3, 2, 1]] ``` # Note - Make sure the rotation does not exceed time complexity of O(N^2) where N is the length of the matrix. - Validate the function with different sizes of matrices to ensure correctness.","solution":"from typing import List def rotate_matrix(matrix: List[List[int]]) -> List[List[int]]: Rotates the given square matrix by 90 degrees clockwise. n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse() return matrix"},{"question":"K-Means Clustering from Scratch # Context: You are required to implement the K-Means clustering algorithm from scratch without using high-level libraries that directly provide clustering functions. The algorithm should iteratively assign data points to clusters and update the cluster centroids until convergence. # Task: Write a function `k_means_clustering` to perform K-Means clustering on a given set of 2D points. # Requirements: 1. **Function Signature**: ```python def k_means_clustering(points: np.ndarray, k: int, max_iterations: int=100) -> tuple: pass ``` 2. **Input**: - `points` (np.ndarray): A 2D array of shape (n_samples, 2). Each row represents a point in the 2D space. - `k` (int): The number of clusters to form. - `max_iterations` (int, optional): Maximum number of iterations to run the algorithm. Default is 100. 3. **Output**: - Returns a tuple containing: - `centroids` (np.ndarray): A 2D array of shape (k, 2) representing the final positions of the centroids. - `labels` (np.ndarray): A 1D array of length `n_samples`, where each element is the cluster index that the corresponding point is assigned to. # Constraints: - Randomly initialize the initial positions of the centroids within the range of the input points. - Update the positions of the centroids until the assignment does not change or the maximum number of iterations is reached. - Handle cases where the centroids coincide or are very close. # Hints: - Use the Euclidean distance to measure the similarity between points and centroids. - Ensure that the function handles empty clusters by reinitializing their centroids. - Utilize NumPy for efficient array operations and calculations. # Example: ```python import numpy as np # Sample usage points = np.array([[1, 2], [2, 3], [3, 4], [8, 9], [9, 10], [10, 11]]) k = 2 centroids, labels = k_means_clustering(points, k, max_iterations=100) print(centroids) # Expect an array of shape (2, 2) print(labels) # Expect an array of length 6 with cluster indices (0 or 1) ``` # Edge Cases: - Points that are all identical. - Handling of clusters with no points assigned in an iteration. - Convergence in fewer than the maximum number of iterations.","solution":"import numpy as np def k_means_clustering(points: np.ndarray, k: int, max_iterations: int=100) -> tuple: Performs K-Means clustering on a set of 2D points. Parameters: - points: np.ndarray of shape (n_samples, 2) - k: int, the number of clusters to form - max_iterations: int, the maximum number of iterations to run the algorithm Returns: - centroids: np.ndarray of shape (k, 2), the final positions of the centroids - labels: np.ndarray of shape (n_samples,), the cluster index for each point n_samples = points.shape[0] np.random.seed(42) # Randomly initialize the centroids centroids = points[np.random.choice(n_samples, k, replace=False)] for _ in range(max_iterations): # Step 1: Assign points to the nearest centroid distances = np.sqrt(((points - centroids[:, np.newaxis])**2).sum(axis=2)) labels = np.argmin(distances, axis=0) # Step 2: Compute new centroids new_centroids = np.array([points[labels == j].mean(axis=0) if len(points[labels == j]) > 0 else centroids[j] for j in range(k)]) # Check for convergence if np.all(centroids == new_centroids): break centroids = new_centroids return centroids, labels"},{"question":"Problem Statement Design a data structure that supports the following operations in constant time: insert, delete, and get_random_element. Each operation should be O(1) on average. # Requirements 1. Implement a class `RandomizedCollection` that supports these operations efficiently. 2. Use Python\'s built-in data structures or implement your own to maintain the required time complexities. 3. Ensure that duplicate elements can exist and each is considered distinct for the `get_random_element` operation. # Operations - `insert(val: int) -> bool`: Inserts a value into the collection. Returns `True` if the collection did not already contain the specified element, otherwise `False`. - `delete(val: int) -> bool`: Removes a value from the collection. Returns `True` if the collection contained the specified element, otherwise `False`. - `get_random_element() -> int`: Returns a random element from the current collection. # Input - For `insert`: An integer value to be inserted. - For `delete`: An integer value to be deleted. - For `get_random_element`: No input. # Output - For `insert`: A boolean indicating success of insertion. - For `delete`: A boolean indicating success of deletion. - For `get_random_element`: A random integer from the collection. # Constraints - The collection should be able to hold a large number of elements, potentially up to 10^5. - Operations should aim to maintain O(1) time complexity on average. - Python\'s random module can be used for generating random indices. # Example ```python >>> rc = RandomizedCollection() >>> rc.insert(1) True >>> rc.insert(1) False >>> rc.insert(2) True >>> rc.get_random_element() 1 # This can also return 2 with equal probability >>> rc.delete(1) True >>> rc.get_random_element() 2 # After deleting one occurrence of 1, remaining elements are 1 and 2 ``` # Note - Ensure class methods are well-documented. - Handle edge cases such as attempting to delete an element not present in the collection. - The internal data structure needs to support efficient random element retrieval and updating operations.","solution":"import random from collections import defaultdict class RandomizedCollection: def __init__(self): Initialize your data structure here. self.vals = [] self.indices = defaultdict(set) def insert(self, val: int) -> bool: Inserts a value into the collection. Returns True if the collection did not already contain the specified element, otherwise returns False. self.vals.append(val) self.indices[val].add(len(self.vals) - 1) return len(self.indices[val]) == 1 def delete(self, val: int) -> bool: Removes a value from the collection. Returns True if the collection contained the specified element, otherwise returns False. if val not in self.indices or not self.indices[val]: return False remove_idx = self.indices[val].pop() last_val = self.vals[-1] if remove_idx != len(self.vals) - 1: self.vals[remove_idx] = last_val self.indices[last_val].add(remove_idx) self.indices[last_val].remove(len(self.vals) - 1) self.vals.pop() if not self.indices[val]: del self.indices[val] return True def get_random_element(self) -> int: Get a random element from the collection. return random.choice(self.vals)"},{"question":"# Heat Capacity Calculator **Objective**: Implement a function that calculates the heat capacity ((C)) of an object given the mass ((m)), specific heat capacity ((c)), and change in temperature ((Delta T)). Context Heat capacity is a measure of the amount of heat required to change the temperature of an object by a specified amount. The formula to calculate heat capacity is: [ Q = mcDelta T ] where, - ( Q ) is the heat absorbed or released (in joules), - ( m ) is the mass of the object (in kg), - ( c ) is the specific heat capacity of the object (in J/(kg K)), - ( Delta T ) is the change in temperature (in Kelvin). Function Signature ```python def calculate_heat_capacity(mass: float, specific_heat_capacity: float, temperature_change: float) -> float: Calculates the heat capacity of an object given the mass, specific heat capacity, and temperature change. Parameters: mass (float): mass of the object in kilograms. Must be positive. specific_heat_capacity (float): specific heat capacity in J/(kg K). Must be positive. temperature_change (float): change in temperature in Kelvin. Returns: float: Heat capacity in joules (J). Raises: ValueError: If mass or specific heat capacity is less than or equal to 0. pass ``` Expected Input and Output 1. **Input**: - A float `mass` (kg), - A float `specific_heat_capacity` (J/(kg K)), - A float `temperature_change` (K). 2. **Output**: - A float representing the heat capacity in joules (J). Constraints - ( 0 < text{mass} leq 1,000 ) - ( 0 < text{specific_heat_capacity} leq 10,000 ) - ( -273 leq text{temperature_change} leq 5,000 ) Performance Requirements - **Time Complexity**: O(1) - **Space Complexity**: O(1) Example * **Example 1**: ```python >>> calculate_heat_capacity(2, 4.18, 25) 209.0 ``` * **Example 2**: ```python >>> calculate_heat_capacity(5, 0.9, -10) -45.0 ``` * **Example 3**: ```python >>> calculate_heat_capacity(1, 2.5, 100) 250.0 ``` * **Edge Case**: ```python >>> calculate_heat_capacity(1, 1, 0) 0.0 ``` **Note**: You must handle invalid inputs by raising an appropriate exception.","solution":"def calculate_heat_capacity(mass: float, specific_heat_capacity: float, temperature_change: float) -> float: Calculates the heat capacity of an object given the mass, specific heat capacity, and temperature change. Parameters: mass (float): mass of the object in kilograms. Must be positive. specific_heat_capacity (float): specific heat capacity in J/(kg K). Must be positive. temperature_change (float): change in temperature in Kelvin. Returns: float: Heat capacity in joules (J). Raises: ValueError: If mass or specific heat capacity is less than or equal to 0. if mass <= 0: raise ValueError(\\"Mass must be greater than 0.\\") if specific_heat_capacity <= 0: raise ValueError(\\"Specific heat capacity must be greater than 0.\\") return mass * specific_heat_capacity * temperature_change"},{"question":"# Question Write a function that finds all unique triplets in the given list of integers that sum up to zero. **Function Signature:** ```python def three_sum(nums: List[int]) -> List[List[int]]: ``` **Input:** - `nums`: a list of integers `nums` (-10^5 ≤ nums[i] ≤ 10^5, 0 ≤ len(nums) ≤ 1000). **Output:** - Return a list of lists where each inner list is a unique triplet `[nums[i], nums[j], nums[k]]` such that `i`, `j`, and `k` are distinct indices and their sum is zero. - The triplets in the output should not be in any particular order. **Example:** ```python assert three_sum([-1, 0, 1, 2, -1, -4]) == [[-1, -1, 2], [-1, 0, 1]] assert three_sum([]) == [] assert three_sum([0]) == [] ``` **Notes:** - Each triplet should be unique, meaning no duplicate triplets in the final output. - The solution should not contain duplicates of the triplet lists themselves. - You may return the triplets in any order. The inner lists may also be in any order but should contain the correct elements that sum to zero.","solution":"from typing import List def three_sum(nums: List[int]) -> List[List[int]]: nums.sort() triplets = [] n = len(nums) for i in range(n): if i > 0 and nums[i] == nums[i - 1]: continue # Skip duplicates left, right = i + 1, n - 1 while left < right: total = nums[i] + nums[left] + nums[right] if total == 0: triplets.append([nums[i], nums[left], nums[right]]) while left < right and nums[left] == nums[left + 1]: left += 1 # Skip duplicates while left < right and nums[right] == nums[right - 1]: right -= 1 # Skip duplicates left += 1 right -= 1 elif total < 0: left += 1 else: right -= 1 return triplets"},{"question":"# Question: Implement a Priority Queue with Dynamic Array Resizing Your task is to build an efficient priority queue that allows for dynamic resizing of the underlying array as elements are added or removed. Implement the following functionalities: `insert`, `remove_min`, `peek_min`, and a method to return the current size of the queue. **Function Signatures**: ```python class PriorityQueue: def __init__(self): pass def insert(self, value: int): pass def remove_min(self) -> int: pass def peek_min(self) -> int: pass def size(self) -> int: pass ``` **Function Details**: - `__init__`: Initialize an empty priority queue. - `insert(value: int)`: Insert a new integer value into the priority queue. - `remove_min()`: Remove and return the minimum element from the priority queue. - `peek_min()`: Return the minimum element without removing it from the queue. - `size()`: Return the current number of elements in the priority queue. **Constraints**: - Implement a dynamic array resizing logic so that the underlying storage of the queue can grow and shrink as elements are added and removed. - Ensure all operations maintain their expected time complexities (e.g., insert and remove_min should function efficiently). Example: ```python pq = PriorityQueue() pq.insert(5) pq.insert(3) pq.insert(7) pq.insert(1) print(pq.peek_min()) # Output: 1 print(pq.remove_min()) # Output: 1 print(pq.peek_min()) # Output: 3 print(pq.size()) # Output: 3 ``` **Implementation Constraints**: - Ensure that the `insert` and `remove_min` operations are optimized for performance, using appropriate data structures and algorithms. - Handle edge cases such as removal from an empty queue gracefully by raising appropriate exceptions. Test your implementation rigorously to ensure correctness and efficiency, especially for edge cases and large inputs.","solution":"import heapq class PriorityQueue: def __init__(self): self._queue = [] def insert(self, value: int): heapq.heappush(self._queue, value) def remove_min(self) -> int: if not self._queue: raise IndexError(\\"remove_min from an empty priority queue\\") return heapq.heappop(self._queue) def peek_min(self) -> int: if not self._queue: raise IndexError(\\"peek_min from an empty priority queue\\") return self._queue[0] def size(self) -> int: return len(self._queue)"},{"question":"Question: You are tasked with implementing a function that detects if a specific target integer exists within a matrix that is sorted in ascending order both row-wise and column-wise. This problem assesses your ability to navigate a grid and apply efficient search strategies. # Requirements: 1. **Function**: `def search_matrix(matrix: list[list[int]], target: int) -> bool:` 2. **Input**: * A 2-dimensional list of integers `matrix` where each row and column is sorted in ascending order, e.g., `[[1, 4, 7], [2, 5, 8], [3, 6, 9]]`. * An integer `target` to search for in the matrix. 3. **Output**: * A boolean value `True` if the target exists within the matrix, otherwise `False`. 4. **Constraints**: * The matrix can have dimensions up to `1000 x 1000`. * Each integer in the matrix is in the range of `-10^9` to `10^9`. 5. **Performance**: * Aim for O(m + n) time complexity where `m` is the number of rows and `n` is the number of columns. * O(1) additional space complexity. # Scenario: You are working on a new feature for a software system that handles large datasets. One of the modules requires checking whether a particular value is present within a sorted grid of numbers. To optimize this, you decide to implement an efficient search algorithm that leverages the sorted property of the matrix. # Example: Input: ```python matrix = [ [1, 4, 7, 11], [2, 5, 8, 12], [3, 6, 9, 16], [10, 13, 14, 17] ] target = 5 ``` Output: `True` Input: ```python matrix = [ [1, 4, 7, 11], [2, 5, 8, 12], [3, 6, 9, 16], [10, 13, 14, 17] ] target = 20 ``` Output: `False` # Edge Cases to Consider: * The algorithm should handle empty matrices gracefully by returning `False`. * Ensure it works correctly when the target is either the smallest or largest element in the matrix. * Consider cases where the target is in the first or last position of a row or column. # Additional Tests: Ensure your implementation passes the expected outputs for the following scenarios: 1. Input: ```python matrix = [ [1, 4], [2, 5] ] target = 5 ``` Output: `True` 2. Input: ```python matrix = [ [1, 4], [2, 5] ] target = 3 ``` Output: `False` 3. Input: ```python matrix = [[-10**9, -1, 0], [2, 5, 10**9]] target = 10**9 ``` Output: `True` # Instructions: * Implement your solution in Python. * Ensure your code is well-structured and includes necessary comments for clarity. * Test your solution against multiple test cases to verify correctness.","solution":"def search_matrix(matrix: list[list[int]], target: int) -> bool: This function returns True if target exists in matrix, otherwise False. The matrix is sorted in ascending order both row-wise and column-wise. if not matrix or not matrix[0]: return False rows, cols = len(matrix), len(matrix[0]) row, col = 0, cols - 1 while row < rows and col >= 0: if matrix[row][col] == target: return True elif matrix[row][col] > target: col -= 1 else: row += 1 return False"},{"question":"**Context**: You\'re working on a data serialization project where the primary goal is to serialize and deserialize a binary tree into a concise format. The binary tree can contain any set of characters as node values. The objective is to design a way to efficiently transform this binary tree into a string representation and revert it back to its original structure. **Task**: 1. Implement a class `BinaryTreeSerializer` that encapsulates methods for serializing and deserializing a binary tree. 2. Implement the methods `serialize` and `deserialize` to convert the binary tree to a string and back respectively. # Class Definition ```python class TreeNode: def __init__(self, value: str = \'\', left: \'TreeNode\' = None, right: \'TreeNode\' = None): Represents a node in the binary tree. :param value: The value held by the node. :param left: The left child of the node. :param right: The right child of the node. self.value = value self.left = left self.right = right class BinaryTreeSerializer: @staticmethod def serialize(root: TreeNode) -> str: Serializes the binary tree rooted at `root` into a string. :param root: The root of the binary tree. :return: A string representation of the binary tree. # Implement this method pass @staticmethod def deserialize(data: str) -> TreeNode: Deserializes the string back into a binary tree. :param data: The string representation of the binary tree. :return: The root of the binary tree. # Implement this method pass ``` # Example: ```python # Construct a binary tree root = TreeNode(\'a\', TreeNode(\'b\', TreeNode(\'d\'), TreeNode(\'e\')), TreeNode(\'c\', None, TreeNode(\'f\'))) # Serialize the binary tree serialized = BinaryTreeSerializer.serialize(root) print(serialized) # For instance, the output might be \\"a b d # # e # # c # f # #\\" # Deserialize the string back into a binary tree deserialized_tree = BinaryTreeSerializer.deserialize(serialized) print(deserialized_tree.value) # Output should be \'a\' print(deserialized_tree.left.value) # Output should be \'b\' print(deserialized_tree.right.value) # Output should be \'c\' ``` # Constraints: 1. Nodes can contain any characters as values. 2. The tree will have at most 1000 nodes. 3. For serialization, use a pre-order traversal (root-left-right). 4. For both serialization and deserialization, use `#` to indicate null/None children. **Note**: Ensure the deserialized tree has the same structure as the original tree.","solution":"class TreeNode: def __init__(self, value: str = \'\', left: \'TreeNode\' = None, right: \'TreeNode\' = None): Represents a node in the binary tree. :param value: The value held by the node. :param left: The left child of the node. :param right: The right child of the node. self.value = value self.left = left self.right = right class BinaryTreeSerializer: @staticmethod def serialize(root: TreeNode) -> str: Serializes the binary tree rooted at `root` into a string. :param root: The root of the binary tree. :return: A string representation of the binary tree. result = [] def helper(node): if node is None: result.append(\\"#\\") return result.append(node.value) helper(node.left) helper(node.right) helper(root) return \\" \\".join(result) @staticmethod def deserialize(data: str) -> TreeNode: Deserializes the string back into a binary tree. :param data: The string representation of the binary tree. :return: The root of the binary tree. values = iter(data.split()) def helper(): val = next(values) if val == \\"#\\": return None node = TreeNode(val) node.left = helper() node.right = helper() return node return helper()"},{"question":"# Longest Common Subsequence (LCS) You are working as a software developer for a company specializing in genetic research. Your task is to implement a function that calculates the length of the longest common subsequence (LCS) between two DNA sequences. A subsequence is defined as a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements. Function Signature ```python def longest_common_subsequence(seq1: str, seq2: str) -> int: This function computes the length of the longest common subsequence between two given DNA sequences. :param seq1: A string representing the first DNA sequence. :param seq2: A string representing the second DNA sequence. :return: Integer value representing the length of the longest common subsequence. ``` Input 1. **seq1**: A string representing the first DNA sequence. The sequence consists of characters A, C, G, and T. 2. **seq2**: A string representing the second DNA sequence. The sequence consists of characters A, C, G, and T. Output * An integer that represents the length of the longest common subsequence between the two DNA sequences. Constraints * The length of each sequence is between 1 and 1000. Example ```python # Example DNA sequences sequence1 = \\"ACGTACGTGAC\\" sequence2 = \\"TACGTACG\\" assert longest_common_subsequence(sequence1, sequence2) == 7 sequence1 = \\"AGGTAB\\" sequence2 = \\"GXTXAYB\\" assert longest_common_subsequence(sequence1, sequence2) == 4 sequence1 = \\"AAAAAA\\" sequence2 = \\"AA\\" assert longest_common_subsequence(sequence1, sequence2) == 2 ``` Notes * Use dynamic programming to find the LCS length. * Consider creating a 2D table where `dp[i][j]` represents the length of the LCS of the first `i` characters of `seq1` and the first `j` characters of `seq2`. * Optimize for both time and space efficiency. * Ensure all edge cases are handled, including sequences with no common subsequence or identical sequences.","solution":"def longest_common_subsequence(seq1: str, seq2: str) -> int: This function computes the length of the longest common subsequence between two given DNA sequences. :param seq1: A string representing the first DNA sequence. :param seq2: A string representing the second DNA sequence. :return: Integer value representing the length of the longest common subsequence. m, n = len(seq1), len(seq2) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): if seq1[i - 1] == seq2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[m][n]"},{"question":"# Coding Assessment Question Context: You are required to implement an algorithm to find the shortest path in a grid using Breadth-First Search (BFS). Each cell in the grid is either passable (represented by 1) or blocked (represented by 0). The path can only be constructed from cells that are passable and you can move four possible directions: up, down, left, and right. Task: Implement the function `shortest_path_in_grid(grid: List[List[int]]) -> int` which: 1. Accepts a 2D list of integers representing the grid. 2. Returns an integer representing the length of the shortest path from the top-left corner to the bottom-right corner of the grid or -1 if no such path exists. Input: - `grid`: A 2D list of integers where 0 represents a blocked cell and 1 represents a passable cell. Output: - An integer representing the length of the shortest path from the top-left corner to the bottom-right corner of the grid or -1 if no such path exists. Constraints: 1. `1 <= grid.length, grid[0].length <= 100` (You can assume the behavior for grids larger than this is not defined). 2. The value of each cell is either 0 or 1. 3. The starting and the ending cells are always passable. Example: ```python grid = [ [1, 0, 0, 0, 1], [1, 1, 0, 1, 1], [0, 1, 0, 1, 0], [1, 1, 1, 1, 1], [0, 0, 1, 0, 1] ] assert shortest_path_in_grid(grid) == 9 ``` Note: Handle edge cases appropriately for scenarios where: - All cells except the first and last are blocked. - The grid size is the minimum (1x1 grid). You may use the following function skeleton: ```python def shortest_path_in_grid(grid: List[List[int]]) -> int: pass ```","solution":"from collections import deque from typing import List def shortest_path_in_grid(grid: List[List[int]]) -> int: def in_bounds(x, y): return 0 <= x < len(grid) and 0 <= y < len(grid[0]) def neighbors(x, y): for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if in_bounds(nx, ny) and grid[nx][ny] == 1: yield nx, ny if grid[0][0] == 0 or grid[len(grid)-1][len(grid[0])-1] == 0: return -1 q = deque([(0, 0, 1)]) # (row, col, distance) visited = set((0, 0)) while q: x, y, dist = q.popleft() if x == len(grid) - 1 and y == len(grid[0]) - 1: return dist for nx, ny in neighbors(x, y): if (nx, ny) not in visited: visited.add((nx, ny)) q.append((nx, ny, dist + 1)) return -1"},{"question":"# Problem Statement: Sorted List with Unique Elements You are required to implement a `SortedUniqueList` class that maintains a sorted list of unique elements. This class should support operations to add and remove elements while ensuring the list remains sorted and contains no duplicates. # Requirements: 1. **Unique Elements**: Ensure that the list contains only unique elements. Attempting to add a duplicate element should not change the list. 2. **Sorted Order**: Maintain the list in a sorted order after each operation. 3. **Support Operations**: Implement add, remove, and contains methods. 4. **Performance Constraints**: Operations should be efficient in terms of time complexity. # Function Implementations: - `__init__`: Initialize the list. - `add`: Add an element to the list while maintaining sorted order and uniqueness. - `remove`: Remove an element from the list if it exists. - `contains`: Check whether an element exists in the list. - `__repr__`: Return a string representation of the list. # Input Format: - The list is initialized empty. - Integer elements are added, removed, or checked for existence in the list. # Output Format: - For `add`, `remove`, and `contains`, the output should be boolean (`True`/`False`) indicating success or failure of the operation. - For `__repr__`, return the sorted list as a string. # Example: ```python # Creating a new SortedUniqueList instance sorted_list = SortedUniqueList() # Adding elements sorted_list.add(5) # Output: True sorted_list.add(3) # Output: True sorted_list.add(8) # Output: True sorted_list.add(5) # Output: False (duplicate element, no change to the list) # Removing elements sorted_list.remove(3) # Output: True sorted_list.remove(10) # Output: False (element not present in the list) # Checking existence of elements print(sorted_list.contains(5)) # Output: True print(sorted_list.contains(3)) # Output: False # Displaying the list print(sorted_list) # Output: [5, 8] ``` # Hint: Consider using the `bisect` module in Python to efficiently insert and check for elements in a sorted order. ```python import bisect class SortedUniqueList: def __init__(self): self._list = [] def add(self, value): if value in self._list: return False bisect.insort(self._list, value) return True def remove(self, value): if value in self._list: self._list.remove(value) return True return False def contains(self, value): index = bisect.bisect_left(self._list, value) return index != len(self._list) and self._list[index] == value def __repr__(self): return str(self._list) ``` In this question, the `SortedUniqueList` class ensures that elements are always unique and sorted, and supports efficient operations to add, remove, and check for elements.","solution":"import bisect class SortedUniqueList: def __init__(self): self._list = [] def add(self, value): Add a unique element to the list while maintaining sorted order. index = bisect.bisect_left(self._list, value) if index != len(self._list) and self._list[index] == value: return False bisect.insort(self._list, value) return True def remove(self, value): Remove an element from the list if it exists. index = bisect.bisect_left(self._list, value) if index != len(self._list) and self._list[index] == value: self._list.pop(index) return True return False def contains(self, value): Check whether an element exists in the list. index = bisect.bisect_left(self._list, value) return index != len(self._list) and self._list[index] == value def __repr__(self): Return a string representation of the list. return str(self._list)"},{"question":"# Key-Value Dictionary Merge **Context**: When dealing with multiple sources of data in software applications, it is common to encounter situations where merging dictionaries is necessary. This task ensures students are familiar with handling dictionaries and merging them effectively, while emphasizing key handling and value conflict resolution in Python. **Problem Statement**: You are provided with two dictionaries containing integer keys and list of integers as values. Your task is to write a function that merges these two dictionaries. If a key exists in both dictionaries, you should concatenate the lists of integers. If a key only exists in one dictionary, the resulting dictionary should contain that key with its corresponding list of integers. The order of keys in the output dictionary does not matter, but duplicate values within the resulting lists should be removed. **Function Signature**: ```python def merge_dictionaries(dict1: dict, dict2: dict) -> dict: ``` **Input**: - `dict1` (dict): A dictionary with integer keys and list of integers as values. - `dict2` (dict): A dictionary with integer keys and list of integers as values. **Output**: - `dict`: A merged dictionary based on the described rules. **Constraints**: - All keys in the dictionaries are integers. - All values are lists containing integers. - Duplicate values within lists should be removed in the final merged dictionary. - The dictionaries will have at most 20 keys each, and each list will have at most 30 elements. **Example**: ```python assert merge_dictionaries({1: [1, 2, 3], 2: [4, 5]}, {2: [5, 6], 3: [7, 8]}) == {1: [1, 2, 3], 2: [4, 5, 6], 3: [7, 8]} assert merge_dictionaries({1: [1, 1, 2]}, {1: [2, 3, 3], 4: [4, 5]}) == {1: [1, 2, 3], 4: [4, 5]} assert merge_dictionaries({}, {2: [2, 3]}) == {2: [2, 3]} assert merge_dictionaries({1: [1, 2, 2], 5: []}, {1: [1, 3], 5: [4, 4]}) == {1: [1, 2, 3], 5: [4]} ``` **Edge Cases**: * Test with one or both dictionaries being empty. * Test with lists that contain duplicate values. * Test with keys that only appear in one dictionary. **Notes**: * Ensure that the merged lists have unique integers, i.e., no duplicates within each list. * Consider using set operations for handling unique elements in lists. Happy coding!","solution":"def merge_dictionaries(dict1: dict, dict2: dict) -> dict: merged_dict = {} # Combine all keys from both dictionaries all_keys = set(dict1.keys()).union(dict2.keys()) for key in all_keys: # Get lists from both dictionaries, default to empty list if key is not present list1 = dict1.get(key, []) list2 = dict2.get(key, []) # Merge lists and remove duplicates merged_list = list(set(list1 + list2)) # Sort list to maintain order merged_list.sort() # Assign to merged dictionary merged_dict[key] = merged_list return merged_dict"},{"question":"# Question: Quadratic Equation Solver Problem Statement: You need to implement a Python function that solves a quadratic equation of the form `ax^2 + bx + c = 0`. The function should return the roots of the equation. Function Signature: ```python def solve_quadratic(a: float, b: float, c: float) -> tuple: ``` Input: - **a** (float): The coefficient of (x^2). (1 ≤ |a| ≤ 10^6) - **b** (float): The coefficient of (x). (-10^6 ≤ b ≤ 10^6) - **c** (float): The constant term. (-10^6 ≤ c ≤ 10^6) Output: - Returns a tuple containing the roots of the quadratic equation. Constraints: - If `a` is 0, raise a `ValueError` with the message: \\"The coefficient \'a\' cannot be zero.\\" Examples: ```python >>> solve_quadratic(1, -3, 2) (2.0, 1.0) >>> solve_quadratic(1, -2, 1) (1.0,) >>> solve_quadratic(1, 0, -4) (2.0, -2.0) >>> solve_quadratic(1, 1, 1) (Complex roots: -0.5 + 0.8660254037844386j, -0.5 - 0.8660254037844386j) ``` Implementation: Use Python and handle special cases such as: - Discriminant is negative: return the complex roots. - Discriminant equals zero: return only one root. - Discriminant is positive: return both roots in a sorted manner (ascending). **Note**: Ensure your function handles different cases, including edge cases where `b` and `c` can lead to zero or complex solutions.","solution":"import cmath def solve_quadratic(a: float, b: float, c: float) -> tuple: if a == 0: raise ValueError(\\"The coefficient \'a\' cannot be zero.\\") # Calculate the discriminant discriminant = b**2 - 4*a*c if discriminant > 0: root1 = (-b + discriminant**0.5) / (2*a) root2 = (-b - discriminant**0.5) / (2*a) return (min(root1, root2), max(root1, root2)) elif discriminant == 0: root = -b / (2*a) return (root,) else: root1 = (-b + cmath.sqrt(discriminant)) / (2*a) root2 = (-b - cmath.sqrt(discriminant)) / (2*a) return (root1, root2)"},{"question":"# Coding Task: Depth-First Search (DFS) in a Graph **Background**: Depth-First Search (DFS) is a fundamental algorithm used for traversing or searching tree or graph data structures. Starting from the root or any arbitrary node in a graph, DFS explores as far as possible along each branch before backtracking. It is useful for solving various problems in computer science such as connectivity, cycle detection, and pathfinding. **Task**: Implement a depth-first search (DFS) algorithm to find if there exists a path between two nodes in an unweighted graph represented using an adjacency list. **Function Signature**: ```python def dfs_path_exists(graph: dict[int, list[int]], start: int, end: int) -> bool: Determine if there exists a path between the start node and the end node using the DFS algorithm. Parameters: - graph: A dictionary where keys are node identifiers and values are lists of adjacent nodes. - start: Integer representing the starting node. - end: Integer representing the ending node. Returns: - A boolean indicating whether a path exists between the start and end nodes. ``` **Input**: - `graph`: A dictionary representing the adjacency list of an unweighted graph, where the key is a node and the value is a list of nodes connected to the key node. - `start`: An integer representing the node where the search starts. - `end`: An integer representing the target node to reach. **Output**: - Returns `True` if there exists a path from `start` to `end`, otherwise returns `False`. **Constraints**: - Assume all nodes in the graph are represented by unique integers. - The graph can be disconnected. - There are no self-loops or multiple edges between the same pair of nodes. - Assume the graph does not contain any negative cycles. **Example**: ```python graph = { 0: [1, 2], 1: [2], 2: [0, 3], 3: [3] } print(dfs_path_exists(graph, 1, 3)) # Expected: True graph = { 0: [1, 2], 1: [2], 2: [3], 3: [] } print(dfs_path_exists(graph, 0, 3)) # Expected: True graph = { 0: [1, 2], 1: [2], 2: [], 3: [4, 5], 4: [], 5: [] } print(dfs_path_exists(graph, 0, 4)) # Expected: False ``` **Edge Cases**: 1. The start node is the same as the end node. 2. There are no edges in the graph, only isolated nodes. 3. The graph is fully connected. Completing this task will demonstrate the ability to apply a classical graph traversal technique to solve pathfinding problems, a common requirement in various technical domains like network analysis, navigation algorithms, and more.","solution":"def dfs_path_exists(graph, start, end): Determine if there exists a path between the start node and the end node using the DFS algorithm. Parameters: - graph: A dictionary where keys are node identifiers and values are lists of adjacent nodes. - start: Integer representing the starting node. - end: Integer representing the ending node. Returns: - A boolean indicating whether a path exists between the start and end nodes. def dfs(node, visited): if node == end: return True visited.add(node) for neighbor in graph.get(node, []): if neighbor not in visited: if dfs(neighbor, visited): return True return False return dfs(start, set())"},{"question":"# Coding Challenge: Extend Functionality for Trie Data Structure Context You are working with a Trie (Prefix Tree) data structure, which is efficient for searching word prefixes and is widely used in applications such as autocomplete and spell-checking. While the basic insertion and search operations are implemented, there are a couple of additional functionalities that are not included. Task You need to extend the `Trie` class with two additional functions: 1. **Delete Word**: This operation deletes a given word from the Trie. 2. **Count Words Starting with Prefix**: This operation counts the number of words in the Trie that start with a given prefix. Specifications **Operation 1: Delete Word** - **Function Signature**: `def delete_word(self, word):` - **Input**: `word` - The word to be deleted from the Trie. - **Output**: It does not return anything but ensures the word is removed from the Trie if it exists. **Operation 2: Count Words Starting with Prefix** - **Function Signature**: `def count_words_starting_with_prefix(self, prefix):` - **Input**: `prefix` - The prefix to search for. - **Output**: It returns the count of words in the Trie that begin with the given prefix. # Example Usage ```python # Initialize a Trie trie = Trie() # Insert elements trie.insert(\\"apple\\") trie.insert(\\"app\\") trie.insert(\\"application\\") trie.insert(\\"apex\\") trie.insert(\\"bat\\") trie.insert(\\"batch\\") # Count words starting with \'app\' print(trie.count_words_starting_with_prefix(\'app\')) # Should print 3 # Delete word \'application\' trie.delete_word(\'application\') # Count words starting with \'app\' after deletion print(trie.count_words_starting_with_prefix(\'app\')) # Should print 2 # Delete word \'apple\' trie.delete_word(\'apple\') # Count words starting with \'app\' after another deletion print(trie.count_words_starting_with_prefix(\'app\')) # Should print 1 ``` # Constraints - Do not use any additional data structures beyond what is required for the operations. - Handle cases where the queried word or prefix does not exist gracefully. - Ensure that the Trie structure integrity is maintained after deletions. - Performance requirements must adhere to the standard complexities of Trie operations (insertion, search, etc.). **Nota Bene**: Modify the `Trie` and `TrieNode` classes as necessary to implement the new functionalities.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False self.word_count = 0 # To help in counting words starting with a prefix class Trie: def __init__(self): self.root = TrieNode() def insert(self, word): node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.word_count += 1 node.is_end_of_word = True def search(self, word): node = self.root for char in word: if char not in node.children: return False node = node.children[char] return node.is_end_of_word def delete_word(self, word): def delete(node, word, depth): if node is None: return False if depth == len(word): if node.is_end_of_word: node.is_end_of_word = False return len(node.children) == 0 return False char = word[depth] if char in node.children: should_delete_child = delete(node.children[char], word, depth + 1) if should_delete_child: del node.children[char] return not node.is_end_of_word and len(node.children) == 0 else: node.children[char].word_count -= 1 return False delete(self.root, word, 0) def count_words_starting_with_prefix(self, prefix): node = self.root for char in prefix: if char not in node.children: return 0 node = node.children[char] return node.word_count"},{"question":"# Problem Statement You are developing a program that deals with geometric shapes. One of the shapes involved is a circle, for which you need to calculate the area and the circumference. Your task is to implement the function `circle_properties(radius: float) -> dict` that takes the radius of a circle as input and returns a dictionary with the area and the circumference of the circle. # Function Signature ```python def circle_properties(radius: float) -> dict: ``` # Input * `radius` : A positive float number representing the radius of the circle. # Output * A dictionary with two keys: - `\'area\'`: The area of the circle. - `\'circumference\'`: The circumference of the circle. # Constraints * Raise a `TypeError` if the input is not a float. * Raise a `ValueError` if the input is less than or equal to 0. # Examples Example 1 Input: ```python circle_properties(3.5) ``` Output: ```python {\'area\': 38.48451000647496, \'circumference\': 21.991148575128552} ``` Example 2 Input: ```python circle_properties(1.0) ``` Output: ```python {\'area\': 3.141592653589793, \'circumference\': 6.283185307179586} ``` # Performance Requirements Your solution should use the value of pi from the `math` module. Ensure that the area and the circumference are computed with sufficient precision by using appropriate arithmetic operations. # Notes 1. Use the formula for area: ( text{Area} = pi r^2 ) 2. Use the formula for circumference: ( text{Circumference} = 2 pi r ) 3. The Python `math` module provides a precise value for (pi).","solution":"import math def circle_properties(radius: float) -> dict: if not isinstance(radius, float): raise TypeError(\\"Radius must be a float.\\") if radius <= 0: raise ValueError(\\"Radius must be greater than 0.\\") area = math.pi * (radius ** 2) circumference = 2 * math.pi * radius return { \'area\': area, \'circumference\': circumference }"},{"question":"# Problem Statement: You are responsible for developing a mini spell-checking system that will help identify and correct misspelled words in a given text. To achieve this, we will use a predefined dictionary of correctly spelled words. Your task is to write a function `spell_checker` that takes an input string representing a sentence and a set of correctly spelled words. The function should return a list of words from the input string that are not found in the set of correctly spelled words. # Function Signature: ```python def spell_checker(sentence: str, correct_words: set) -> list: pass ``` # Input: * `sentence`: A string containing a sentence (1 <= len(sentence) <= 10^3). * `correct_words`: A set of strings, each representing a correctly spelled word. Each word will only contain lowercase English letters (1 <= len(correct_words) <= 10^5). # Output: * Returns a list of strings representing the words from the input sentence that are not found in the set of correctly spelled words. # Constraints: * The input sentence will only contain lowercase English letters and spaces. * The words in the sentence will be separated by single spaces. * The returned list should contain the unique misspelled words in the order they appear in the sentence. # Example: ```python correct_words = {\\"this\\", \\"is\\", \\"a\\", \\"test\\", \\"example\\", \\"of\\", \\"correctly\\", \\"spelled\\", \\"words\\"} assert spell_checker(\\"this is a tst example of correctli spellled words\\", correct_words) == [\\"tst\\", \\"correctli\\", \\"spellled\\"] assert spell_checker(\\"spell check this sentense for mistakes\\", correct_words) == [\\"spell\\", \\"check\\", \\"sentense\\", \\"for\\", \\"mistakes\\"] assert spell_checker(\\"a correctly spelled test\\", correct_words) == [] ``` # Note: * Ensure your function efficiently checks for misspelled words by leveraging the set\'s O(1) average time complexity for lookups. * Consider edge cases such as empty inputs or sentences with all words correctly spelled.","solution":"def spell_checker(sentence: str, correct_words: set) -> list: Identifies words in the input sentence that are not found in the set of correctly spelled words. :param sentence: A string containing a sentence. :param correct_words: A set of correctly spelled words. :return: A list of misspelled words in their order of appearance. words = sentence.split() misspelled = [] seen = set() # to avoid duplicates in the output list for word in words: if word not in correct_words and word not in seen: misspelled.append(word) seen.add(word) return misspelled"},{"question":"# Coding Assessment Question **Context**: Working with strings is a common task in programming and data processing. Regular expressions are a powerful tool for matching patterns within strings, validating input formats, and extracting information. **Problem Statement**: You are given a list of email addresses. Your task is to write a function that validates each email address against a given regular expression pattern and returns a list of valid email addresses. **Function Signature**: ```python def validate_emails(emails: List[str], pattern: str) -> List[str]: Validates each email address in the input list against the given regex pattern. Parameters: emails (List[str]): A list of email addresses (strings) to be validated. pattern (str): A regular expression pattern to validate the email addresses against. Returns: List[str]: A list containing only the valid email addresses. ``` **Input**: 1. **emails**: A list of strings representing email addresses (e.g., [\\"test@example.com\\", \\"invalid-email\\", \\"user@domain.com\\"]) 2. **pattern**: A string representing the regular expression pattern to validate the email addresses (e.g., r\\"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+.[a-zA-Z]{2,}\\") **Output**: - A list of strings, each being a valid email address that matches the given pattern. **Constraints**: - The input list can contain any number of email addresses, including none. - The regular expression pattern is guaranteed to be a valid pattern for email validation. - Email addresses can vary widely in format, but your function should cater to standard patterns as per the provided regex. **Performance Requirements**: - The function should handle a large number of emails efficiently. **Examples**: ```python >>> validate_emails([\\"test@example.com\\", \\"invalid-email\\", \\"user@domain.com\\"], r\\"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+.[a-zA-Z]{2,}\\") [\'test@example.com\', \'user@domain.com\'] >>> validate_emails([\\"john.doe@gmail.com\\", \\"jane_doe123@yahoo.co.uk\\", \\"admin#example.org\\"], r\\"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+.[a-zA-Z]{2,}\\") [\'john.doe@gmail.com\', \'jane_doe123@yahoo.co.uk\'] ``` Ensure your implementation correctly handles edge cases and maintains high performance for processing a large number of email addresses.","solution":"import re from typing import List def validate_emails(emails: List[str], pattern: str) -> List[str]: Validates each email address in the input list against the given regex pattern. Parameters: emails (List[str]): A list of email addresses (strings) to be validated. pattern (str): A regular expression pattern to validate the email addresses against. Returns: List[str]: A list containing only the valid email addresses. regex = re.compile(pattern) valid_emails = [email for email in emails if regex.match(email)] return valid_emails"},{"question":"# Context You are developing an algorithm for a recommendation system to find the most common prefixes shared among a list of strings, which will help in auto-completion features. The algorithm should find the longest common prefix (LCP) among a list of strings provided. # Objective Implement a function to find the longest common prefix string amongst a list of strings. If there is no common prefix, return an empty string. # Function Signature ```python def longest_common_prefix(strings: list[str]) -> str: Find the longest common prefix string amongst an array of strings :param strings: List of strings to evaluate :return: Longest common prefix string shared among all input strings, or empty string if none exists Example: >>> longest_common_prefix([\\"flower\\",\\"flow\\",\\"flight\\"]) \\"fl\\" >>> longest_common_prefix([\\"dog\\",\\"racecar\\",\\"car\\"]) \\"\\" ``` # Constraints and Requirements 1. The input parameter `strings` should be a list of strings. 2. If the input list is empty, return an empty string. 3. The function should handle cases where there is no common prefix. 4. The function should consider the case sensitivity of the strings. # Performance 1. The algorithm should be efficient, ideally handling lists of up to 1000 strings with string lengths up to 1000 characters. 2. Aim for a linear time complexity relative to the total number of characters across all strings. # Examples - Input: `[\\"flower\\", \\"flow\\", \\"flight\\"]` Output: `\\"fl\\"` - Input: `[\\"dog\\", \\"racecar\\", \\"car\\"]` Output: `\\"\\"` - Input: `[]` Output: `\\"\\"` - Input: `[\\"interspecies\\", \\"interstellar\\", \\"interstate\\"]` Output: `\\"inters\\"` # Notes Ensure the function correctly identifies the longest common prefix, and consider edge cases such as an empty input list or strings with no common characters. Verification of the implementation should include various test cases with different PREFIX lengths and complexities.","solution":"def longest_common_prefix(strings: list[str]) -> str: Find the longest common prefix string amongst an array of strings. :param strings: List of strings to evaluate. :return: Longest common prefix string shared among all input strings, or empty string if none exists. if not strings: return \\"\\" # Start with the prefix being the first string in the array. prefix = strings[0] # Compare this prefix with all strings in the array. for string in strings[1:]: # Find the common prefix between prefix and the current string. while string[:len(prefix)] != prefix and prefix: prefix = prefix[:-1] # If prefix becomes empty, there is no common prefix. if not prefix: return \\"\\" return prefix"},{"question":"# Problem Description You are given a two-dimensional grid representing a map, where each cell contains an integer that indicates the height of the terrain at that location. The objective is to determine the maximum difference in height between any two cells in the grid. You need to implement an efficient function that computes this maximum height difference. # Input A function `max_height_difference(grid: List[List[int]]) -> int` that takes a list of lists of integers representing the grid. # Output The function should return an integer representing the maximum difference in height between any two cells in the grid. # Constraints * The grid is not empty and is always a rectangular matrix. * The grid will have dimensions `n x m` where `1 <= n, m <= 200`. * The height in each cell ranges from `-10^9` to `10^9`. # Example ```python assert max_height_difference([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 8 assert max_height_difference([[-1, -2, -3], [-4, -5, -6], [-7, -8, -9]]) == 8 assert max_height_difference([[0]]) == 0 assert max_height_difference([[100, -100], [-100, 100]]) == 200 ``` # Explanation 1. **Input**: `[[1, 2, 3], [4, 5, 6], [7, 8, 9]]` **Output**: `8` **Explanation**: The maximum height difference is between cell (0,0) (height 1) and cell (2,2) (height 9), giving a difference of ( 9 - 1 = 8 ). 2. **Input**: `[[-1, -2, -3], [-4, -5, -6], [-7, -8, -9]]` **Output**: `8` **Explanation**: The maximum height difference is between cell (0,0) (height -1) and cell (2,2) (height -9), giving a difference of ( -1 - (-9) = 8 ). 3. **Input**: `[[0]]` **Output**: `0` **Explanation**: The grid has only one cell with height 0, so the maximum difference is 0. 4. **Input**: `[[100, -100], [-100, 100]]` **Output**: `200` **Explanation**: The maximum height difference is between cell (0,0) (height 100) and cell (0,1) or cell (1,0) (height -100), giving a difference of ( 100 - (-100) = 200 ).","solution":"def max_height_difference(grid): Returns the maximum height difference between any two cells in the grid. min_height = float(\'inf\') max_height = float(\'-inf\') for row in grid: for height in row: if height < min_height: min_height = height if height > max_height: max_height = height return max_height - min_height"},{"question":"# Question: Implement a Binary Search Using Iterative and Recursive Approaches You are working on an application that involves searching for elements within a sorted list of numbers. Your task is to implement two functions to perform a binary search on a sorted list, one using an **iterative approach** and the other using a **recursive approach**. Function Signatures 1. `def binary_search_iterative(nums: list[int | float], target: int | float) -> int` 2. `def binary_search_recursive(nums: list[int | float], target: int | float, left: int, right: int) -> int` Requirements * The iterative function should search for the `target` value using a loop. * The recursive function should search for the `target` value by recursively dividing the list. * Both functions should return the index of the target element if found. * If the target element is not found, both functions should return -1. * The functions should handle negative indices correctly and raise `IndexError` if indices are out of range. * The recursive function\'s `left` and `right` parameters represent the current search bounds and should be validated accordingly. Input * `nums`: A sorted list of integers or floats. Example: `[1, 2, 3, 4, 5, 6, 7, 8, 9]` * `target`: The search target, an integer or float. * `left`: The left index (only for the recursive function). * `right`: The right index (only for the recursive function). Output * Return the index of the target element if found, otherwise -1. Constraints * The list cannot be empty. * Elements can be a mix of integers and floats. * The indices for the recursive function must be valid. Examples ```python # Iterative Examples assert binary_search_iterative([1, 2, 3, 4, 5, 6, 7, 8, 9], 5) == 4 assert binary_search_iterative([1, 2, 3, 4, 5, 6, 7, 8, 9], 10) == -1 assert binary_search_iterative([1.1, 2.2, 3.3, 4.4, 5.5], 3.3) == 2 assert binary_search_iterative([1.1, 2.2, 3.3, 4.4, 5.5], 6.6) == -1 # Recursive Examples assert binary_search_recursive([1, 2, 3, 4, 5, 6, 7, 8, 9], 5, 0, 8) == 4 assert binary_search_recursive([1, 2, 3, 4, 5, 6, 7, 8, 9], 10, 0, 8) == -1 assert binary_search_recursive([1.1, 2.2, 3.3, 4.4, 5.5], 3.3, 0, 4) == 2 assert binary_search_recursive([1.1, 2.2, 3.3, 4.4, 5.5], 6.6, 0, 4) == -1 try: binary_search_recursive([1, 2, 3], 2, -1, 2) except IndexError: pass # This is expected try: binary_search_recursive([1, 2, 3], 2, 0, 3) except IndexError: pass # This is expected ``` Constraints & Limitations * Performance should be O(log n) for both functions. * Space complexity should respect the nature of the iterative or recursive approach. * Ensure that your implementations handle edge cases correctly; provide sufficient test cases in your submission.","solution":"def binary_search_iterative(nums: list[int | float], target: int | float) -> int: left, right = 0, len(nums) - 1 while left <= right: mid = (left + right) // 2 if nums[mid] == target: return mid elif nums[mid] < target: left = mid + 1 else: right = mid - 1 return -1 def binary_search_recursive(nums: list[int | float], target: int | float, left: int, right: int) -> int: # Index validation if left < 0 or right >= len(nums): raise IndexError(\\"Left or right index out of range\\") if left > right: return -1 mid = (left + right) // 2 if nums[mid] == target: return mid elif nums[mid] < target: return binary_search_recursive(nums, target, mid + 1, right) else: return binary_search_recursive(nums, target, left, mid - 1)"},{"question":"# Coding Assessment Question Problem Statement In digital signal processing, filtering is a process used to remove unwanted parts of the signal. One type of simple filter is the moving average filter, which takes the average of the last `k` elements at each point in a time series. This results in a smoother series that highlights trends more clearly than the original data. Implement the moving average filtering algorithm for a given list of integers and a specified window size ( k ). Function Signature ```python def moving_average_filter(nums: list[int], k: int) -> list[float]: ``` Input - `nums` (list of integers): A list of integers representing the input data. - `k` (integer): The window size for the moving average, ( 1 leq k leq text{len}(nums) ). Output - Returns a list of floats representing the filtered series. Examples ```python >>> moving_average_filter([1, 2, 3, 4, 5], 3) [2.0, 3.0, 4.0] >>> moving_average_filter([10, 20, 30, 40, 50, 60], 2) [15.0, 25.0, 35.0, 45.0, 55.0] ``` Explanation For the first example, the original series is [1, 2, 3, 4, 5] and the window size is 3. The moving averages are: - (1+2+3) / 3 = 2.0 - (2+3+4) / 3 = 3.0 - (3+4+5) / 3 = 4.0 For the second example, the original series is [10, 20, 30, 40, 50, 60] and the window size is 2. The moving averages are: - (10+20) / 2 = 15.0 - (20+30) / 2 = 25.0 - (30+40) / 2 = 35.0 - (40+50) / 2 = 45.0 - (50+60) / 2 = 55.0 Restrictions - If `nums` is an empty list or if `k` is not within the acceptable range, raise a `ValueError`. ---","solution":"def moving_average_filter(nums: list[int], k: int) -> list[float]: if not nums or k <= 0 or k > len(nums): raise ValueError(\\"Invalid input: nums list cannot be empty, and k must be within the correct range.\\") moving_averages = [] for i in range(len(nums) - k + 1): window = nums[i:i + k] window_average = sum(window) / k moving_averages.append(window_average) return moving_averages"},{"question":"# Sum of Diagonal Elements in a Matrix Context In various computational problems, understanding the properties of matrices is crucial. One such property is the sum of the diagonal elements, also known as the trace of a matrix. Problem Statement You are required to implement a function `sum_of_diagonals` that calculates the sum of the main diagonal elements of a square matrix. Function Signature ```python def sum_of_diagonals(matrix: List[List[int]]) -> int: pass ``` Parameters - `matrix` (List[List[int]]): A square matrix represented as a list of lists, where each sublist is a row of the matrix. Returns - int: The sum of the main diagonal elements of the input matrix. Constraints - The input matrix will always be square (number of rows equal to the number of columns). - Each element in the matrix is an integer. Examples ```python >>> sum_of_diagonals([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 15 >>> sum_of_diagonals([[10, 20], [30, 40]]) 50 >>> sum_of_diagonals([[0]]) 0 ``` Notes - Implement the algorithm in a way that it sums the diagonal elements efficiently. - Test edge cases such as very small (1x1) and larger matrices. - Ensure your implementation handles varying integer values, including negative numbers.","solution":"def sum_of_diagonals(matrix): Returns the sum of the main diagonal elements of a square matrix. Parameters: matrix (List[List[int]]): A square matrix represented as a list of lists Returns: int: The sum of the main diagonal elements return sum(matrix[i][i] for i in range(len(matrix)))"},{"question":"# Problem Statement **Context**: As part of a file management system, you need to implement a feature that compresses a given string using Run-Length Encoding (RLE). Run-Length Encoding is a basic form of data compression where consecutive characters are replaced by a single character followed by the count of that character. **Task**: Create a function that compresses a given string using the Run-Length Encoding technique. The input will be a string containing only alphabetic characters (both upper and lower case), and the output should be the compressed string. If the compressed string is not shorter than the original, return the original string instead. # Function Signature: ```python def run_length_encode(input_string: str) -> str: Compress the input string using Run-Length Encoding. Parameters: - input_string (str): The original string to be compressed. Returns: - str: The compressed string or the original string if compression is not effective. ``` # Input: - `input_string`: A string containing only alphabetic characters (1 <= len(input_string) <= 1000). # Output: - A compressed string using Run-Length Encoding or the original string if compression is not shorter. # Constraints: - The input string will contain only alphabetic characters. - The maximum length of the string will be 1000 characters. # Example: ```python input_string = \\"aaabbccccdaa\\" # Compression process: # - \'a\' appears 3 times consecutively -> \'a3\' # - \'b\' appears 2 times consecutively -> \'b2\' # - \'c\' appears 4 times consecutively -> \'c4\' # - \'d\' appears 1 time -> \'d1\' # - \'a\' appears 2 times consecutively -> \'a2\' # Combining these: a3b2c4d1a2 # Since the compressed string (a3b2c4d1a2) is shorter than the original, the function should return it. output_string = run_length_encode(input_string) # Expected output: # \\"a3b2c4d1a2\\" ``` ```python input_string = \\"abc\\" # Compression process: # - \'a\' appears 1 time -> \'a1\' # - \'b\' appears 1 time -> \'b1\' # - \'c\' appears 1 time -> \'c1\' # Combining these: a1b1c1 # Since the compressed string (a1b1c1) is not shorter than the original, the function should return the original string. output_string = run_length_encode(input_string) # Expected output: # \\"abc\\" ```","solution":"def run_length_encode(input_string: str) -> str: Compress the input string using Run-Length Encoding. Parameters: - input_string (str): The original string to be compressed. Returns: - str: The compressed string or the original string if compression is not effective. if not input_string: return input_string encoded_str = [] count = 1 for i in range(1, len(input_string)): if input_string[i] == input_string[i - 1]: count += 1 else: encoded_str.append(input_string[i - 1] + str(count)) count = 1 # Append the last character and its count encoded_str.append(input_string[-1] + str(count)) encoded_str = \'\'.join(encoded_str) # Return the original string if the compressed string is not shorter return encoded_str if len(encoded_str) < len(input_string) else input_string"},{"question":"# Next Greater Element (Circular Array) You are given a circular array of integers. For each element in the array, find the next greater element. The next greater element is the first element (to the right) in the array that is greater than the current element. If no such element exists, return -1 for that position. A circular array means that the end of the array is connected to the beginning of the array. Function Signature: ```python def next_greater_elements(nums: List[int]) -> List[int]: ``` Input: * `nums` (List[int]): A list of integers representing the circular array. The length of nums is 1 ≤ |nums| ≤ 10^4 and each number is within the range -10^9 ≤ nums[i] ≤ 10^9. Output: * List[int]: A list of integers where each element is the value of the next greater element in the circular array, or -1 if no such element exists. Constraints: * You must implement an efficient solution that handles the circular nature of the array. * Avoid using a straightforward double iteration as it can be too slow for larger inputs. Example: ```python assert next_greater_elements([1, 2, 1]) == [2, -1, 2] assert next_greater_elements([1, 3, 2, 4]) == [3, 4, 4, -1] assert next_greater_elements([2, 1, 2, 4, 3]) == [4, 2, 4, -1, 4] assert next_greater_elements([5, 4, 3, 2, 1]) == [-1, 5, 5, 5, 5] ``` Edge Cases to Consider: * The array contains only one element. * Elements in the array are strictly increasing/decreasing. * The array contains duplicate elements. * The array contains large positive or negative numbers. * The array is uniform (all elements are the same).","solution":"from typing import List def next_greater_elements(nums: List[int]) -> List[int]: res = [-1] * len(nums) stack = [] for i in range(2 * len(nums)): current_index = i % len(nums) while stack and nums[stack[-1]] < nums[current_index]: res[stack.pop()] = nums[current_index] if i < len(nums): stack.append(i) return res"},{"question":"# Problem Statement You have been tasked with implementing a Vigenère Cipher system. This system should encode a provided plaintext message into ciphertext using a given key and also decode the ciphertext back to the original plaintext. # Function to Implement 1. `encrypt_vigenere(plaintext: str, key: str) -> str` 2. `decrypt_vigenere(ciphertext: str, key: str) -> str` Requirements * **encrypt_vigenere**: - **Input**: * `plaintext` (str): The plaintext message to be encrypted. (Constraints: lowercase letters only) * `key` (str): The encryption key consisting of lowercase letters. (Constraints: lowercase letters only) - **Output**: * Encrypted string (str), with all characters in uppercase. * **decrypt_vigenere**: - **Input**: * `ciphertext` (str): The encrypted message to decrypt. (Constraints: uppercase letters only) * `key` (str): The decryption key used for encoding. - **Output**: * Decrypted plaintext string (str), all characters in lowercase. Constraints - The key will only contain lowercase English letters. - The plaintext message will consist of lowercase English alphabets. - The ciphertext will be provided in uppercase. Examples ```python def test_vigenere_cipher(): plaintext = \\"attackatdawn\\" key = \\"lemon\\" # Encrypt the plaintext ciphertext = encrypt_vigenere(plaintext, key) assert ciphertext == \\"LXFOPVEFRNHR\\", f\\"Expected \'LXFOPVEFRNHR\' but got {ciphertext}\\" # Decrypt the ciphertext decrypted_text = decrypt_vigenere(ciphertext, key) assert decrypted_text == \\"attackatdawn\\", f\\"Expected \'attackatdawn\' but got {decrypted_text}\\" test_vigenere_cipher() ```","solution":"def encrypt_vigenere(plaintext, key): Encrypts the plaintext using the Vigenère cipher with the given key. Parameters: plaintext (str): The plaintext message to be encrypted (lowercase letters only). key (str): The encryption key (lowercase letters only). Returns: str: Encrypted string (uppercase letters). ciphertext = [] key_length = len(key) for i, char in enumerate(plaintext): shift = ord(key[i % key_length]) - ord(\'a\') encrypted_char = chr((ord(char) - ord(\'a\') + shift) % 26 + ord(\'A\')) ciphertext.append(encrypted_char) return \'\'.join(ciphertext) def decrypt_vigenere(ciphertext, key): Decrypts the ciphertext using the Vigenère cipher with the given key. Parameters: ciphertext (str): The encrypted message to decrypt (uppercase letters only). key (str): The decryption key. Returns: str: Decrypted plaintext (lowercase letters). plaintext = [] key_length = len(key) for i, char in enumerate(ciphertext): shift = ord(key[i % key_length]) - ord(\'a\') decrypted_char = chr((ord(char) - ord(\'A\') - shift + 26) % 26 + ord(\'a\')) plaintext.append(decrypted_char) return \'\'.join(plaintext)"},{"question":"**Problem Statement**: You are tasked with designing an algorithm to check if a given string is a palindrome and determine the longest palindromic substring within it. A palindrome is a string that reads the same forward and backward. Your challenge is to implement two functions: 1. `is_palindrome(s: str) -> bool`: Determines whether the provided string `s` is a palindrome. 2. `longest_palindromic_substring(s: str) -> str`: Finds the longest palindromic substring within the given string `s`. **Function Specifications**: 1. `is_palindrome(s: str) -> bool`: - **Input**: A string `s`. - **Output**: Returns `True` if `s` is a palindrome, otherwise returns `False`. - **Constraints**: `s` will contain only alphanumeric characters and can be empty. 2. `longest_palindromic_substring(s: str) -> str`: - **Input**: A string `s`. - **Output**: Returns the longest palindromic substring in `s`. - **Constraints**: `s` will contain only alphanumeric characters and can be empty. - **Error Handling**: Returns an empty string if `s` is an empty string. **Example Cases**: ```python >>> is_palindrome(\\"racecar\\") True >>> is_palindrome(\\"hello\\") False >>> is_palindrome(\\"A man, a plan, a canal, Panama\\") False >>> longest_palindromic_substring(\\"babad\\") \\"bab\\" or \\"aba\\" >>> longest_palindromic_substring(\\"cbbd\\") \\"bb\\" >>> longest_palindromic_substring(\\"a\\") \\"a\\" >>> longest_palindromic_substring(\\"\\") \\"\\" # Edge Cases >>> longest_palindromic_substring(\\"abacdfgdcaba\\") \\"aba\\" или \\"aca\\" >>> longest_palindromic_substring(\\"abacdfgdcabba\\") \\"abba\\" >>> longest_palindromic_substring(\\"forgeeksskeegfor\\") \\"geeksskeeg\\" ``` Implement these functions to identify palindromic strings and determine the longest palindromic substring within a given string, demonstrating their working with the provided example cases. **Assessment Criteria**: - Correctness: Ensure the solution provides accurate results for a variety of test cases. - Efficiency: Optimize the solution to handle large input values effectively. - Robustness: Handle invalid inputs and edge cases gracefully.","solution":"def is_palindrome(s: str) -> bool: Determines whether the provided string s is a palindrome. return s == s[::-1] def longest_palindromic_substring(s: str) -> str: Finds the longest palindromic substring within the given string s. if len(s) == 0: return \\"\\" start = 0 max_length = 1 def expand_around_center(left: int, right: int) -> (int, int): while left >= 0 and right < len(s) and s[left] == s[right]: left -= 1 right += 1 return left + 1, right for i in range(len(s)): # Check for odd length palindromes l1, r1 = expand_around_center(i, i) if r1 - l1 > max_length: start = l1 max_length = r1 - l1 # Check for even length palindromes l2, r2 = expand_around_center(i, i + 1) if r2 - l2 > max_length: start = l2 max_length = r2 - l2 return s[start:start + max_length]"},{"question":"# Coding Assessment Question: Implementing a Matrix Rotation System **Scenario**: You work as a software engineer for a visual effects company. One of your tasks is to create a module that performs transformations on graphical objects. Specifically, you are required to implement a feature that rotates a given NxN matrix representing an image by 90 degrees clockwise. **Objective**: You need to implement a function `rotate_image` which will take an NxN matrix and rotate it by 90 degrees clockwise. Input: - `matrix`: A 2D list of integers representing the NxN matrix to be rotated. Output: - A 2D list of integers representing the NxN matrix after it has been rotated by 90 degrees clockwise. ```python def rotate_image(matrix: list[list[int]]) -> list[list[int]]: Rotates the given NxN matrix by 90 degrees clockwise. Args: matrix (list[list[int]]): The NxN matrix to be rotated. Returns: list[list[int]]: The NxN matrix after rotation. # Get the size of the matrix n = len(matrix) # Create a new matrix to store the rotated version rotated_matrix = [[0] * n for _ in range(n)] # Perform the rotation for i in range(n): for j in range(n): rotated_matrix[j][n-1-i] = matrix[i][j] return rotated_matrix # Example usage: if __name__ == \\"__main__\\": matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotated_matrix = rotate_image(matrix) for row in rotated_matrix: print(row) ``` Constraints: 1. The matrix provided will always be square (NxN) and its dimensions within the range `1 <= N <= 100`. 2. Elements in the matrix will be integers within the range `-1000 <= matrix[i][j] <= 1000`. 3. Your solution should handle edge cases such as minimum and maximum matrix sizes efficiently. Requirements: - Correctly implement the `rotate_image` function based on the provided scenario and specifications. - Ensure your solution is tested for correctness and edge cases using the given example and other potential cases. **Note**: This question assesses your ability to manipulate matrix operations and ensure correctness in transformations within given constraints.","solution":"def rotate_image(matrix: list[list[int]]) -> list[list[int]]: Rotates the given NxN matrix by 90 degrees clockwise. Args: matrix (list[list[int]]): The NxN matrix to be rotated. Returns: list[list[int]]: The NxN matrix after rotation. # Get the size of the matrix n = len(matrix) # Create a new matrix to store the rotated version rotated_matrix = [[0] * n for _ in range(n)] # Perform the rotation for i in range(n): for j in range(n): rotated_matrix[j][n-1-i] = matrix[i][j] return rotated_matrix"},{"question":"# Question: File Directory Size Summarizer You have been provided with a function that calculates the total size of files in a directory. Your task is to enhance this function to include the following features: file filtering, concurrent size computation, and improved error handling. **Task** 1. Modify the `directory_size` function to include a file extension filter parameter that allows the user to specify which types of files should be included in the size calculation. 2. Use concurrent programming to speed up the size computation process, especially for directories with a large number of files. 3. Add comprehensive error handling to manage issues such as unreadable files or directories. # Requirements **Function Signature** ```python import os async def directory_size(path: str, extension_filter: list[str]) -> int: pass # Your implementation here ``` **Input** - `path` (str): The directory path for which to calculate the total size. - `extension_filter` (list of str): A list of file extensions to include in the size calculation. If empty, include all file types. **Output** - Returns the total size of files in bytes as an integer. **Constraints** - Utilize asynchronous programming to improve the performance of the function. - Handle all possible errors gracefully and log them for troubleshooting. **Performance** - Ensure the function can handle directories containing a large number of files efficiently. # Example ```python import asyncio # Assuming your function implementation is complete async def main(): path = \\"/path/to/directory\\" extension_filter = [\\"txt\\", \\"pdf\\"] try: total_size = await directory_size(path, extension_filter) print(f\\"Total size: {total_size} bytes\\") except Exception as e: print(f\\"Error: {e}\\") asyncio.run(main()) ``` # Note - Ensure proper logging to record issues like unreadable files or directories. - The function should only calculate the size of files matching the specified extensions if the filter is provided. **Hints** - Use relevant libraries to facilitate the concurrent processing of file sizes. - Thoroughly test the function with different file extensions and directory structures to ensure robustness.","solution":"import os import asyncio import logging async def file_size(file_path): try: return os.path.getsize(file_path) except Exception as e: logging.error(f\\"Error reading file {file_path}: {e}\\") return 0 async def directory_size(path: str, extension_filter: list[str]) -> int: total_size = 0 tasks = [] for root, dirs, files in os.walk(path): for file in files: if not extension_filter or file.split(\'.\')[-1] in extension_filter: file_path = os.path.join(root, file) tasks.append(file_size(file_path)) sizes = await asyncio.gather(*tasks) total_size = sum(sizes) return total_size"},{"question":"# Problem Statement You are tasked with implementing a basic image transformation feature in a very simplified image processing library. The feature will apply a 90-degree clockwise rotation to a given square matrix representing an image. # Function Signature - Implement the function `rotate_image(matrix: List[List[int]]) -> List[List[int]]`. This function will: - Take a 2D square matrix `matrix` of integers as input. - Return a 2D square matrix that has been rotated 90 degrees clockwise. ```python from typing import List def rotate_image(matrix: List[List[int]]) -> List[List[int]]: pass ``` # Input and Output Input 1. `matrix` (List[List[int]]): A 2D square matrix of integers of dimensions `n x n`. Constraints: `1 ≤ len(matrix) ≤ 20`. Output 1. The rotated matrix as a new 2D list of integers. # Example ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate_image(matrix) # Output: # [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] ``` # Constraints - The function should only perform operations allowed by the size constraints. - You must check for invalid non-square matrices and raise appropriate exceptions (`ValueError`). # Notes - Consider how to efficiently read and write elements to their new positions during the rotation. - Pay attention to ensuring that elements are placed correctly without overwriting them prematurely. # Additional Example ```python matrix = [ [5, 1], [2, 4] ] rotate_image(matrix) # Output: # [ # [2, 5], # [4, 1] # ] ```","solution":"from typing import List def rotate_image(matrix: List[List[int]]) -> List[List[int]]: Rotates a given square matrix 90 degrees clockwise. Args: matrix: List[List[int]] - A 2D square matrix of integers Returns: List[List[int]] - The rotated matrix n = len(matrix) # First, we transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Second, we reverse each row to get the final rotated matrix for i in range(n): matrix[i].reverse() return matrix"},{"question":"# Problem Description: Extend the functionality of the stack data structure by implementing the following additional method: **Task**: Implement a method `second_largest_element` which returns the second largest element in the stack. If the stack has fewer than two distinct elements, it should return `None`. ```python def second_largest_element(self) -> Optional[int]: Returns the second largest element in the stack. If the stack has fewer than two distinct elements, returns None. Time complexity: O(n) @returns: The second largest element in the stack or None if less than two distinct elements are present. Example: >>> stack = Stack() >>> stack.push(3) >>> stack.push(1) >>> stack.push(4) >>> stack.push(4) >>> stack.push(2) >>> stack.second_largest_element() 3 >>> stack.clear() >>> stack.push(6) >>> stack.second_largest_element() None ``` **Input**: - No input argument. **Output**: - An integer representing the second largest element in the stack, or `None` if the stack has fewer than two distinct elements. # Constraints: - The stack implementation must include basic operations (push, pop, etc.) - The `second_largest_element` method must effectively identify and return the second largest element. - Proper handling of edge cases like an empty stack or stacks with repeated elements. # Example Consider a sample usage below: ```python # Stack initialization s = Stack() # Pushing elements onto the stack s.push(5) s.push(3) s.push(9) s.push(7) s.push(7) # Finding second largest element print(s.second_largest_element()) # Output: 7 # Clear the stack and retry with fewer elements s.clear() s.push(4) print(s.second_largest_element()) # Output: None ``` **Notes**: - Ensure proper iteration through elements of the stack for identifying the second largest element. - Handle both empty stacks and stacks with fewer than two distinct elements effectively. - Test for various edge cases and distinct element occurrences.","solution":"class Stack: def __init__(self): self.stack = [] def push(self, value): self.stack.append(value) def pop(self): if not self.is_empty(): return self.stack.pop() return None def is_empty(self): return len(self.stack) == 0 def clear(self): self.stack = [] def second_largest_element(self): if len(self.stack) < 2: return None first, second = float(\'-inf\'), float(\'-inf\') unique_elements = set(self.stack) if len(unique_elements) < 2: return None for num in unique_elements: if num > first: second = first first = num elif num > second and num != first: second = num return second"},{"question":"# Problem Statement The Fibonacci sequence is a series of numbers where the next number is found by adding up the two numbers before it. Starting with 0 and 1, the sequence goes: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, ... Write a function to determine the smallest Fibonacci number that contains a given number of digits. # Requirements 1. Implement a function to generate the next Fibonacci number. 2. Develop the main function to find the first Fibonacci number in the sequence that has the given number of digits. # Input - An integer digits, (d), specifying the number of digits for the target Fibonacci number. # Output - An integer representing the smallest Fibonacci number that contains exactly (d) digits. # Example ```python def fibonacci_with_digits(digits: int) -> int: Returns the smallest Fibonacci number with at least `digits` digits. # Example usage: print(fibonacci_with_digits(3)) # Expected output: 144 print(fibonacci_with_digits(5)) # Expected output: 10946 ``` # Constraints - ( 1 leq text{digits} leq 100 ) You are required to handle edge cases, optimize where possible, and ensure the functions are correct and efficient even for large numbers of digits. # Hints - Utilize a loop to generate Fibonacci numbers while keeping track of their lengths. - Remember that using Python\'s built-in support for arbitrarily large integers can handle Fibonacci numbers with a large number of digits.","solution":"def fibonacci_with_digits(digits: int) -> int: Returns the smallest Fibonacci number with at least `digits` digits. if digits <= 0: return None a, b = 0, 1 while len(str(b)) < digits: a, b = b, a + b return b"},{"question":"# Merge Sorted Arrays Problem Statement Write a function that merges two sorted arrays into one sorted array. The function should handle duplicate elements and retain all instances of them in the merged array. Requirements * Input: Two lists of integers, both already sorted in non-decreasing order. * Output: A single list of integers, sorted in non-decreasing order. Constraints 1. The input lists can be empty. 2. Duplicates are allowed, and they should appear in the merged output the same number of times they appear in the original arrays. 3. The function should not use any sorting functions (like `sorted()`, `sort()`, etc.) on the final output list. Example ```python def merge_sorted_arrays(array1: list, array2: list) -> list: pass # Example test cases print(merge_sorted_arrays([1, 3, 5], [2, 4, 6])) # Output: [1, 2, 3, 4, 5, 6] print(merge_sorted_arrays([1, 1, 3], [1, 2, 2, 4])) # Output: [1, 1, 1, 2, 2, 3, 4] print(merge_sorted_arrays([], [1, 2, 3])) # Output: [1, 2, 3] print(merge_sorted_arrays([2, 3, 5], [])) # Output: [2, 3, 5] print(merge_sorted_arrays([], [])) # Output: [] ``` # Additional Notes - You should use a two-pointer approach to merge the arrays efficiently. - Ensure your function handles edge cases such as one or both input arrays being empty. - Aim for a time complexity of O(n + m), where n and m are the lengths of the input lists.","solution":"def merge_sorted_arrays(array1, array2): Merges two sorted arrays into a single sorted array. Parameters: array1 (list): A sorted list of integers. array2 (list): Another sorted list of integers. Returns: list: A merged and sorted list of integers. merged_array = [] i, j = 0, 0 while i < len(array1) and j < len(array2): if array1[i] < array2[j]: merged_array.append(array1[i]) i += 1 else: merged_array.append(array2[j]) j += 1 while i < len(array1): merged_array.append(array1[i]) i += 1 while j < len(array2): merged_array.append(array2[j]) j += 1 return merged_array"},{"question":"# Challenge: Sum of Distinct Prime Factors You are tasked with writing a function to calculate the sum of distinct prime factors for a given number `n`. **Function Signature**: ```python def sum_distinct_prime_factors(n: int) -> int: pass ``` **Input**: - `n` (int): A positive integer for which the sum of distinct prime factors is to be calculated. **Output**: - Return the sum of all distinct prime factors of the given integer `n`. **Constraints**: - (2 ≤ n ≤ 10^6) **Example**: ```python n = 60 print(sum_distinct_prime_factors(n)) # Output: 10 ``` **Explanation**: For `n = 60`, the distinct prime factors are 2, 3, and 5. The sum of these is (2 + 3 + 5 = 10). # Problem Context A prime factor is a prime number that divides `n` without leaving a remainder. To find all distinct prime factors: 1. Implement a function to check if a number is prime. 2. Iterate over possible divisors up to the square root of `n` and identify primes. 3. Compute the sum of all identified distinct prime factors. *Note*: Efficient methods like the Sieve of Eratosthenes can be used to list prime numbers up to the square root of `n`. Alternatively, direct factorization can be employed to identify the prime factors of `n`. # Steps: 1. Implement or utilize a prime-checking function. 2. Iterate over possible factor values from 2 to (sqrt{n}) and check for primality and divisibility. 3. Accumulate the sum of the identified distinct prime factors.","solution":"def sum_distinct_prime_factors(n): Returns the sum of distinct prime factors of the given integer n. def is_prime(num): if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True prime_factors_sum = 0 checked = set() # Check for number of 2s that divide n if n % 2 == 0: prime_factors_sum += 2 while n % 2 == 0: n = n // 2 # n must be odd at this point, so a skip of 2 is used (i.e., we check only for odd numbers) for i in range(3, int(n**0.5) + 1, 2): if n % i == 0 and i not in checked and is_prime(i): prime_factors_sum += i checked.add(i) while n % i == 0: n = n // i # This is to check if n is still a prime number greater than 2 if n > 2 and is_prime(n): prime_factors_sum += n return prime_factors_sum"},{"question":"# Coding Assessment Question **Fibonacci Sequence with Dynamic Programming** The Fibonacci sequence is a series of numbers where each number is the sum of the two preceding ones, usually starting with 0 and 1. The sequence goes: 0, 1, 1, 2, 3, 5, 8, 13, and so on. Your task is to compute the nth Fibonacci number using dynamic programming to ensure efficiency. The solution should have a time complexity of O(n). Write a function: 1. **fibonacci(n: int) -> int**: - Implement the Fibonacci sequence calculation. - **Input**: An integer `n` indicating the n-th number to be computed. - **Output**: An integer which is the n-th Fibonacci number. Be sure to handle edge cases such as n = 0 and n = 1 appropriately. **Example**: ```python >>> fibonacci(0) 0 >>> fibonacci(1) 1 >>> fibonacci(10) 55 >>> fibonacci(20) 6765 ``` **Constraints**: - Assume `n` will be a non-negative integer. - Your implementation should handle large values of `n` efficiently (up to 10^6). ```python def fibonacci(n: int) -> int: if n == 0: return 0 if n == 1: return 1 fib = [0] * (n + 1) fib[1] = 1 for i in range(2, n + 1): fib[i] = fib[i - 1] + fib[i - 2] return fib[n] ```","solution":"def fibonacci(n: int) -> int: if n == 0: return 0 if n == 1: return 1 fib = [0] * (n + 1) fib[1] = 1 for i in range(2, n + 1): fib[i] = fib[i - 1] + fib[i - 2] return fib[n]"},{"question":"# Longest Balanced Substring **Scenario**: In many applications, it is important to detect balanced structures in strings, such as balanced parentheses, brackets, or even characters appearing an equal number of times. Efficiently finding the longest balanced substring from a given string can be crucial for parsing or validation tasks. **Problem**: Given a string consisting of only characters \'a\' and \'b\', write a function to find the length of the longest substring that contains an equal number of \'a\'s and \'b\'s. **Function Signature**: ```python def longest_balanced_substring(s: str) -> int: Function to find the length of the longest balanced substring. Args: s (str): A string consisting solely of characters \'a\' and \'b\'. Returns: int: The length of the longest balanced substring. ``` **Input**: - `s`: A string consisting solely of the characters \'a\' and \'b\'. The length of the string will not exceed 10^5. **Output**: - An integer representing the length of the longest balanced substring. **Constraints**: - The length of the string s will not exceed 10^5. **Examples**: ```python >>> longest_balanced_substring(\\"aabb\\") 4 >>> longest_balanced_substring(\\"ababab\\") 6 >>> longest_balanced_substring(\\"aaaa\\") 0 >>> longest_balanced_substring(\\"aabbaabbaab\\") 10 ``` **Note**: Consider an efficient approach to determine the length of the longest balanced substring due to the constraints on the string length.","solution":"def longest_balanced_substring(s: str) -> int: Function to find the length of the longest balanced substring. Args: s (str): A string consisting solely of characters \'a\' and \'b\'. Returns: int: The length of the longest balanced substring. balance_map = {0: -1} balance = 0 max_length = 0 for i, char in enumerate(s): if char == \'a\': balance += 1 else: balance -= 1 if balance in balance_map: max_length = max(max_length, i - balance_map[balance]) else: balance_map[balance] = i return max_length"},{"question":"# CSV File Data Aggregation You are given a large CSV file containing sales data with the following columns: `Date`, `Region`, `Product`, `Quantity`, and `Price`. Implement a function to aggregate the total sales for each product within the CSV file. The CSV file is too large to fit into memory, so you must process it in chunks. Function Signature ```python def aggregate_sales(input_filename: str, output_filename: str, chunk_size: int) -> None: Aggregate total sales for each product from a large CSV file. Args: input_filename (str): The name of the input CSV file. output_filename (str): The name of the CSV file where the aggregated results should be written. chunk_size (int): The number of lines to process in each chunk. Returns: None ``` Constraints 1. The CSV file is too large to be loaded entirely into memory. 2. Each line in the input CSV file represents a sale with the columns `Date`, `Region`, `Product`, `Quantity`, and `Price`. 3. The output file should contain each product and its total sales amount, ordered lexicographically by product name. 4. Handle potential errors gracefully, such as missing or malformed data. Requirements 1. Implement the `aggregate_sales` function to read and process the CSV file in chunks. 2. Compute the total sales (Quantity * Price) for each product across all chunks. 3. Write the aggregated results to the output file with columns `Product` and `TotalSales`. 4. Ensure the output CSV file is properly formatted and ordered by product name. Example Assuming `sales.csv` contains: ``` Date,Region,Product,Quantity,Price 2023-01-01,North,Apple,10,1.5 2023-01-01,North,Banana,5,0.75 2023-01-02,South,Apple,20,1.5 2023-01-02,West,Kiwi,10,2.0 ``` Calling the function as follows: ```python aggregate_sales(\'sales.csv\', \'aggregated_sales.csv\', 2) # chunk_size = 2 lines ``` The `aggregated_sales.csv` should contain: ``` Product,TotalSales Apple,45.0 Banana,3.75 Kiwi,20.0 ``` Notes - Make sure to handle any headers correctly when processing chunks. - Focus on efficiently reading, processing, and writing data with minimal memory usage. - Ensure proper handling of edge cases such as empty files, headers only, or malformed lines. - Consider using libraries like `csv` and `pandas` for reading and writing CSV files.","solution":"import csv from collections import defaultdict def aggregate_sales(input_filename: str, output_filename: str, chunk_size: int) -> None: Aggregate total sales for each product from a large CSV file. Args: input_filename (str): The name of the input CSV file. output_filename (str): The name of the CSV file where the aggregated results should be written. chunk_size (int): The number of lines to process in each chunk. Returns: None product_sales = defaultdict(float) with open(input_filename, \'r\') as infile: reader = csv.DictReader(infile) while True: rows = [next(reader, None) for _ in range(chunk_size)] if not any(rows): break for row in rows: if row: try: product = row[\'Product\'] quantity = float(row[\'Quantity\']) price = float(row[\'Price\']) total_sale = quantity * price product_sales[product] += total_sale except (KeyError, ValueError): # Handle missing or malformed data gracefully continue # Sort the product sales by product name sorted_product_sales = sorted(product_sales.items()) # Write the output to the specified file with open(output_filename, \'w\', newline=\'\') as outfile: writer = csv.writer(outfile) writer.writerow([\'Product\', \'TotalSales\']) for product, total_sales in sorted_product_sales: writer.writerow([product, total_sales])"},{"question":"# Distinct Powers Challenge Background In mathematics, the distinct powers problem involves finding the number of distinct terms in a sequence generated by considering all combinations of powers of given numbers. Given integers `a` and `b`, generate all terms of the form `a^b` for `2 ≤ a, b ≤ n`, and count the number of distinct terms. Problem Statement Write a function `distinct_powers(n: int) -> int` that takes an integer `n` and returns the count of distinct terms generated by `a^b` for all integers `a` and `b` where `2 ≤ a, b ≤ n`. Input - An integer `n` (2 ≤ n ≤ 100). Output - An integer representing the count of distinct terms. Example 1. `distinct_powers(5)` should return `15`. 2. `distinct_powers(10)` should return `69`. 3. `distinct_powers(2)` should return `1`. Constraints - Ensure the function can efficiently handle the upper limit of `n`. - Consider the properties of powers and how they might result in duplicate terms. Scenario This problem is useful in studies involving power sequences, compressive data generation, and finding unique solutions in combinatorial contexts. Understanding distinct power terms can provide insights in fields such as cryptography, theoretical biology, and complexity theory. Code Template ```python def distinct_powers(n: int) -> int: terms = set() for a in range(2, n + 1): for b in range(2, n + 1): terms.add(pow(a, b)) return len(terms) # Example usage: print(distinct_powers(5)) # Output: 15 ```","solution":"def distinct_powers(n: int) -> int: terms = set() for a in range(2, n + 1): for b in range(2, n + 1): terms.add(pow(a, b)) return len(terms)"},{"question":"# Binary Search Algorithm Enhancements Enhance the standard binary search algorithm to include the following features: 1. Count of the number of comparisons made during the search. 2. Ability to handle both recursive and iterative implementations, selectable by a parameter. # Instructions: 1. Implement a function `binary_search(arr, target, recursive=True)` that performs a binary search and returns a tuple `(index, comparisons)`. * `recursive` parameter determines whether the search is conducted using recursion or iteration. 2. `index` should be the position of the target in the array if found, else -1. 3. `comparisons` should be the total number of target comparisons made. # Input: * A sorted list of integers `arr`. * An integer `target` value to search within the list. * A boolean `recursive` parameter to select the search method (default `True`). # Output: * A tuple containing: - The index of the target if found, else -1. - The number of comparisons made during the search. # Constraints: * The length of the list should be between 1 and 10^5. * The elements of the list and the target should be integers between -10^6 and 10^6. * Handle edge cases where the target is not found. # Example: ```python arr = [1, 3, 5, 7, 9, 11, 13] target = 7 print(binary_search(arr, target, recursive=True)) # Should return (3, number_of_comparisons) arr = [1, 3, 5, 7, 9, 11, 13] target = 4 print(binary_search(arr, target, recursive=False)) # Should return (-1, number_of_comparisons) ``` # Function Signature: ```python def binary_search(arr: list, target: int, recursive: bool = True) -> tuple: pass # Usage Example arr = [1, 3, 5, 7, 9, 11, 13] target = 7 print(binary_search(arr, target, recursive=True)) # Example output: (3, 2) arr = [1, 3, 5, 7, 9, 11, 13] target = 4 print(binary_search(arr, target, recursive=False)) # Example output: (-1, 3) ```","solution":"def binary_search(arr, target, recursive=True): Performs a binary search and returns a tuple (index, comparisons). Parameters: - arr: a sorted list of integers. - target: the integer to search for within the list. - recursive: boolean to select between recursive and iterative implementations. Returns: A tuple containing: - index: the position of the target in the array if found, else -1. - comparisons: the total number of target comparisons made. def recursive_search(arr, target, left, right, comparisons): if left > right: return -1, comparisons mid = (left + right) // 2 comparisons += 1 if arr[mid] == target: return mid, comparisons elif arr[mid] < target: return recursive_search(arr, target, mid + 1, right, comparisons) else: return recursive_search(arr, target, left, mid - 1, comparisons) def iterative_search(arr, target): left, right = 0, len(arr) - 1 comparisons = 0 while left <= right: mid = (left + right) // 2 comparisons += 1 if arr[mid] == target: return mid, comparisons elif arr[mid] < target: left = mid + 1 else: right = mid - 1 return -1, comparisons if recursive: return recursive_search(arr, target, 0, len(arr) - 1, 0) else: return iterative_search(arr, target)"},{"question":"**Permutations Calculation Challenge** Design a function to generate all possible permutations of a given list of elements. This challenge will assess your understanding of recursion and combinatorial generation techniques. # Problem Statement: Write a function `generate_permutations(elements: list) -> list` that produces all possible permutations of a given list of elements. # Input: - A list `elements` which can include any comparable elements like integers, floats, or strings. # Output: - A list of lists, where each list is a unique permutation of the input elements. # Function Signature: ```python def generate_permutations(elements: list) -> list: ``` # Constraints: - The input list can contain up to 10 elements. - All elements of the list are unique. # Performance Requirements: - Aim for a time complexity of O(n!) where n is the number of elements in the input list. # Example: ```python assert generate_permutations([1, 2, 3]) == [ [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1] ] assert generate_permutations([\'a\', \'b\']) == [[\'a\', \'b\'], [\'b\', \'a\']] assert generate_permutations([1]) == [[1]] assert generate_permutations([]) == [[]] ``` # Implementation Details: 1. **Recursive Approach**: - Use recursion to solve the permutation generation problem. 2. **Backtracking Technique**: - Implement the backtracking method to efficiently explore all permutations. 3. **Base Case**: - Define a base case for the recursion to terminate appropriately. 4. **List Comprehension**: - Optionally, leverage list comprehensions for concise code. # Note: Ensure your solution is both correct and efficient, handling edge cases like an empty list or a list with a single element smoothly.","solution":"def generate_permutations(elements: list) -> list: Returns all possible permutations of the input list of elements. if len(elements) == 0: return [[]] permutations = [] for i, elem in enumerate(elements): rest = elements[:i] + elements[i+1:] for perm in generate_permutations(rest): permutations.append([elem] + perm) return permutations"},{"question":"# Coding Assessment Question # Context You are required to determine the total number of ways to partition a given integer `n` using integers greater than or equal to 1. A partition of an integer is a way of writing it as a sum of positive integers where the order of summands is not considered. This is known in combinatorics as the \\"integer partition\\" problem. # Task Implement a function `partition_count(n: int) -> int` that computes the number of ways to partition the given integer `n`. # Function Signature ```python def partition_count(n: int) -> int: pass ``` # Input * `n` (int): The integer to partition (1 ≤ n ≤ 1,000). # Output * Returns an integer representing the total number of ways to partition the given integer `n`. # Example ```python >>> partition_count(5) 7 >>> partition_count(10) 42 >>> partition_count(1) 1 ``` # Constraints * For larger values of `n`, consider using dynamic programming to ensure your solution runs efficiently. # Performance Requirements * Your solution should run in O(n^2) time complexity based on a dynamic programming approach. # Notes * You might find it useful to reference the partition function P(n) in combinatorial mathematics for this task. * Ensure to handle edge cases, such as very small values of `n`.","solution":"def partition_count(n: int) -> int: Returns the number of ways to partition the given integer n. # table to store the counts of partitions partitions = [0] * (n+1) partitions[0] = 1 # Dynamic programming approach for i in range(1, n+1): for j in range(i, n+1): partitions[j] += partitions[j - i] return partitions[n]"},{"question":"# Problem Statement You\'re tasked with developing a program to manage a set of student records, each containing information about a student\'s ID, name, and GPA. The program should provide functionalities to add a new student record, search for a student by ID, and calculate the average GPA of all students. Tasks 1. **Implement \'add_student\' function** Create a method `add_student(student_id: int, name: str, gpa: float) -> None` in the StudentRecords class. This function should add a new student to the records, ensuring no duplicate student IDs are allowed. If a student with the given ID already exists, the function should update the existing student\'s name and GPA. 2. **Implement \'search_student\' function** Add a method `search_student(student_id: int) -> dict` to the StudentRecords class. This function should return the student\'s information as a dictionary (`{\\"id\\": student_id, \\"name\\": name, \\"gpa\\": gpa}`) if the student with the given ID is found, or `None` if the student does not exist. 3. **Implement \'average_gpa\' function** Create a method `average_gpa() -> float` in the StudentRecords class. This function should calculate and return the average GPA of all stored student records, rounded to two decimal places. If there are no student records, the function should return `0.0`. # Constraints - The `gpa` should be a float in the range of 0.0 to 4.0. - The `name` should be a non-empty string. - The `student_id` should be a unique integer. - Utilize O(1) space complexity for the `search_student` method. - Aim for an efficient design that handles the operations optimally. # Function Signatures ```python def add_student(self, student_id: int, name: str, gpa: float) -> None: pass def search_student(self, student_id: int) -> dict: pass def average_gpa(self) -> float: pass ``` # Example - **Adding Students** ```python sr = StudentRecords() sr.add_student(101, \'Alice\', 3.5) sr.add_student(102, \'Bob\', 3.8) ``` - **Searching for a Student** ```python result = sr.search_student(101) # Output should be {\'id\': 101, \'name\': \'Alice\', \'gpa\': 3.5} ``` - **Calculating Average GPA** ```python avg_gpa = sr.average_gpa() # Output should be 3.65 ``` **Note**: Ensure the functionality correctly handles edge cases such as duplicate student IDs and empty student records.","solution":"class StudentRecords: def __init__(self): self.students = {} def add_student(self, student_id: int, name: str, gpa: float) -> None: Adds a new student to the records or updates an existing student if the ID already exists. self.students[student_id] = {\\"name\\": name, \\"gpa\\": gpa} def search_student(self, student_id: int) -> dict: Returns the student\'s information as a dictionary if found, else None. if student_id in self.students: return {\\"id\\": student_id, \\"name\\": self.students[student_id][\\"name\\"], \\"gpa\\": self.students[student_id][\\"gpa\\"]} return None def average_gpa(self) -> float: Calculates and returns the average GPA of all student records, rounded to two decimal places. if not self.students: return 0.0 total_gpa = sum(student[\\"gpa\\"] for student in self.students.values()) return round(total_gpa / len(self.students), 2)"},{"question":"# Coding Assessment Question Scenario You are developing a file system where it\'s important to identify the type of a given file based on its extension. Often, files have standard extensions like `.txt` for text files, `.jpg` for images, etc. Your task is to write a function that determines the type of file from a given filename. Task Write a function `file_type` that takes in a filename as a string and returns the file type based on its extension. Function Signature ```python def file_type(filename: str) -> str: ``` Input * `filename`: A string representing the name of the file, including its extension. Output * A string indicating the type of the file based on its extension. Return `\\"Text File\\"` for `.txt`, `\\"Image File\\"` for `.jpg` or `.jpeg`, `\\"Python Script\\"` for `.py`, `\\"PDF Document\\"` for `.pdf`, `\\"Unknown\\"` for any other extensions. Constraints * The filename will always be a non-empty string. * The filename will always have an extension (e.g., \\"file.txt\\"). * The file extensions are case-sensitive (e.g., `.JPG` should return `\\"Unknown\\"`). Examples ```python >>> file_type(\\"document.txt\\") \'Text File\' >>> file_type(\\"picture.jpg\\") \'Image File\' >>> file_type(\\"script.py\\") \'Python Script\' >>> file_type(\\"report.pdf\\") \'PDF Document\' >>> file_type(\\"archive.zip\\") \'Unknown\' ``` Explanation of Examples * For `file_type(\\"document.txt\\")`, because the file extension is `.txt`, it returns `\\"Text File\\"`. * For `file_type(\\"picture.jpg\\")`, because the file extension is `.jpg`, it returns `\\"Image File\\"`. * For `file_type(\\"script.py\\")`, because the file extension is `.py`, it returns `\\"Python Script\\"`. * For `file_type(\\"report.pdf\\")`, because the file extension is `.pdf`, it returns `\\"PDF Document\\"`. * For `file_type(\\"archive.zip\\")`, since `.zip` is not specified in the requirements, it returns `\\"Unknown\\"`. Performance Requirements * The function should execute in linear time O(n), where `n` is the length of the `filename`.","solution":"def file_type(filename: str) -> str: Takes in a filename and returns the file type based on its extension. if filename.endswith(\'.txt\'): return \'Text File\' elif filename.endswith(\'.jpg\') or filename.endswith(\'.jpeg\'): return \'Image File\' elif filename.endswith(\'.py\'): return \'Python Script\' elif filename.endswith(\'.pdf\'): return \'PDF Document\' else: return \'Unknown\'"},{"question":"# Detect the Largest Connected Component in a Graph A connected component in an undirected graph is a subgraph in which any two vertices are connected to each other by paths. Your task is to implement a function that finds the largest connected component in terms of the number of vertices. Requirements: 1. Develop a function `largest_connected_component(graph)` that takes an undirected graph represented as an adjacency list and returns the size of the largest connected component. 2. Your implementation should efficiently handle graphs with up to 10,000 vertices and edges. Function Signature ```python def largest_connected_component(graph: dict[int, list[int]]) -> int: Finds the largest connected component in an undirected graph. Args: graph (dict[int, list[int]]): An undirected graph represented as an adjacency list. Returns: int: The size of the largest connected component. ``` Constraints - The input graph is represented as a dictionary where the keys are vertices (integers) and the values are lists of integers representing the adjacent vertices. - The graph may have up to 10,000 vertices and 50,000 edges. Examples ```python graph1 = { 0: [1, 2], 1: [0, 3], 2: [0], 3: [1], 4: [5], 5: [4] } # There are two connected components in the graph: # - Component 1: {0, 1, 2, 3} with 4 vertices. # - Component 2: {4, 5} with 2 vertices. # The largest connected component has 4 vertices. assert largest_connected_component(graph1) == 4 graph2 = { 0: [1], 1: [0], 2: [2] } # There are two connected components in the graph: # - Component 1: {0, 1} with 2 vertices. # - Component 2: {2} with 1 vertex. # The largest connected component has 2 vertices. assert largest_connected_component(graph2) == 2 ``` Develop the solution within the provided constraints, ensuring that it handles graphs with various sizes and structures efficiently.","solution":"def largest_connected_component(graph): Finds the largest connected component in an undirected graph. Args: graph (dict[int, list[int]]): An undirected graph represented as an adjacency list. Returns: int: The size of the largest connected component. def dfs(node, visited): A utility function to perform depth-first search (DFS) from a node. stack = [node] size = 0 while stack: vertex = stack.pop() if vertex not in visited: visited.add(vertex) size += 1 for neighbor in graph[vertex]: if neighbor not in visited: stack.append(neighbor) return size visited = set() max_size = 0 for node in graph: if node not in visited: component_size = dfs(node, visited) max_size = max(max_size, component_size) return max_size"},{"question":"# Finding the Minimum Steps in a Grid **Background**: Consider an `m x n` grid where each cell can either be a walkable cell (represented by 0) or an obstacle (represented by 1). Your task is to find the shortest path from the top-left corner of the grid (0, 0) to the bottom-right corner (m-1, n-1). The path can only be made by moving either up, down, left, or right and cannot pass through obstacles. **Problem Statement**: Implement a function `min_steps_in_grid(grid: List[List[int]]) -> int` that takes a 2D list `grid` representing the grid and returns the minimum number of steps required to reach the bottom-right corner from the top-left corner. If no such path exists, return -1. # Implementation Details 1. **Grid Validation**: - Ensure that the grid is non-empty. - Check for valid starting and ending positions. 2. **Breadth-First Search (BFS)**: - Use BFS to explore the minimum path in an unweighted grid. - Track visited cells to avoid cycles and redundant processing. # Function Signature ```python from typing import List def min_steps_in_grid(grid: List[List[int]]) -> int: pass ``` # Input * `grid`: A 2D list `grid` where each element is either 0 (walkable) or 1 (obstacle). # Output * Returns an integer representing the minimum steps required to reach the bottom-right corner, or -1 if no path exists. # Example ```python assert min_steps_in_grid([[0, 0, 1], [0, 1, 0], [0, 0, 0]]) == 4 assert min_steps_in_grid([[0, 1], [0, 0]]) == 2 assert min_steps_in_grid([[0, 1], [1, 0]]) == -1 ``` # Constraints * The size of the grid `m` and `n` will be such that 1 ≤ `m, n` ≤ 100. * Optimize for time and space, considering edge cases and performance challenges associated with larger grids. * Handle invalid or edge-case inputs gracefully, documenting any assumptions.","solution":"from typing import List from collections import deque def min_steps_in_grid(grid: List[List[int]]) -> int: Returns the minimum number of steps to reach the bottom-right corner of the grid from the top-left corner. If no such path exists, returns -1. if not grid or not grid[0] or grid[0][0] == 1 or grid[-1][-1] == 1: return -1 m, n = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0)]) visited = set((0, 0)) steps = 0 while queue: for _ in range(len(queue)): x, y = queue.popleft() if x == m - 1 and y == n - 1: return steps for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 0 and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny)) steps += 1 return -1"},{"question":"**Question**: Write a function named `binary_tree_depth` that computes the depth of a binary tree. The depth of a binary tree is defined as the length of the longest path from the root node to a leaf node. You should use an efficient recursive algorithm to achieve this. **Function Signature**: ```python def binary_tree_depth(root: Optional[TreeNode]) -> int: pass ``` **Input**: * The function takes a single argument `root` which is a reference to the root node of a binary tree. The tree node is defined as follows: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` * The `root` may be `None`, representing an empty tree. **Output**: * Return an `int` representing the depth of the tree. **Constraints**: * The maximum number of nodes in the binary tree is (10^4). * The values of the nodes are integers and can be positive, negative, or zero. * The function should handle large trees efficiently. **Examples**: ```python # Example 1 # 3 # / # 9 20 # / # 15 7 root1 = TreeNode(3) root1.left = TreeNode(9) root1.right = TreeNode(20, TreeNode(15), TreeNode(7)) assert binary_tree_depth(root1) == 3 # Example 2 # 1 # # 2 root2 = TreeNode(1) root2.right = TreeNode(2) assert binary_tree_depth(root2) == 2 # Example 3 root3 = None assert binary_tree_depth(root3) == 0 # Example 4 # 1 # / # 2 3 # # 4 root4 = TreeNode(1) root4.left = TreeNode(2) root4.right = TreeNode(3) root4.left.right = TreeNode(4) assert binary_tree_depth(root4) == 3 ``` **Performance Requirements**: * Ensure the function handles input trees with the maximum depth effectively.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right from typing import Optional def binary_tree_depth(root: Optional[TreeNode]) -> int: if root is None: return 0 left_depth = binary_tree_depth(root.left) right_depth = binary_tree_depth(root.right) return max(left_depth, right_depth) + 1"},{"question":"# Matrix Rotation You are tasked with implementing a function to rotate a given square matrix (NxN) 90 degrees clockwise. Your function should modify the matrix in place, meaning you cannot use any additional matrices or lists for storing intermediate values. Requirements 1. Implement the function `rotate_matrix(matrix: List[List[int]]) -> None` which modifies the given square matrix in place. 2. Ensure the function adheres to the O(1) additional space complexity constraint (excluding the input matrix). Example Scenario ```python # Example usage of the rotate_matrix function. matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate_matrix(matrix) # The matrix should now be: # [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] assert matrix == [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] matrix = [ [ 5, 1, 9, 11], [ 2, 4, 8, 10], [13, 3, 6, 7], [15, 14, 12, 16] ] rotate_matrix(matrix) # The matrix should now be: # [ # [15, 13, 2, 5], # [14, 3, 4, 1], # [12, 6, 8, 9], # [16, 7, 10, 11] # ] assert matrix == [ [15, 13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7, 10, 11] ] ``` Constraints - The input matrix will always be a square matrix (NxN) where 1 <= N <= 1000. - Elements in the matrix will be integers in the range from -10^9 to 10^9. Testing Ensure your implementation works with the provided example scenarios and adheres to the constraints.","solution":"def rotate_matrix(matrix): Rotates the given NxN matrix 90 degrees clockwise in place. n = len(matrix) for layer in range(n // 2): first = layer last = n - 1 - layer for i in range(first, last): offset = i - first top = matrix[first][i] # left -> top matrix[first][i] = matrix[last - offset][first] # bottom -> left matrix[last - offset][first] = matrix[last][last - offset] # right -> bottom matrix[last][last - offset] = matrix[i][last] # top -> right matrix[i][last] = top"},{"question":"# Problem Statement Sorting algorithms are foundational in computer science for organizing data. One commonly used sorting algorithm is Merge Sort, which uses a divide-and-conquer strategy to sort elements. Task Your task is to implement the `merge_sort` function that sorts an array of integers in non-decreasing order using the merge sort algorithm. Additionally, implement a helper function `merge` that merges two sorted lists into one sorted list. Function Signature ```python def merge_sort(arr: list) -> list def merge(left: list, right: list) -> list ``` Input * `arr` (list): A list of integers to be sorted. Output * Returns a list of integers sorted in non-decreasing order. Constraints * You cannot use Python\'s built-in sorting functions. * The input list can contain from 1 to 10,000 integers. * Each integer in the input list can range from -1,000,000 to 1,000,000. Performance Requirements * The algorithm should have an average time complexity of O(n log n) where n is the length of the list. Example Usage ```python >>> merge_sort([38, 27, 43, 3, 9, 82, 10]) [3, 9, 10, 27, 38, 43, 82] >>> merge_sort([5, 2, 4, 6, 1, 3]) [1, 2, 3, 4, 5, 6] >>> merge_sort([1]) [1] >>> merge_sort([-1, 0, 1]) [-1, 0, 1] >>> merge_sort([]) [] ``` Merge Function The `merge` function is a helper function that takes two sorted lists and merges them into a single sorted list. Example Usage: ```python >>> merge([1, 3, 5], [2, 4, 6]) [1, 2, 3, 4, 5, 6] ``` Notes - Ensure your `merge_sort` function splits the data correctly and calls the `merge` function appropriately. - Handle edge cases effectively, including empty arrays and arrays with a single element. - The merge function must maintain the stability of the sorting algorithm, meaning equal elements should preserve their original order as much as possible.","solution":"def merge_sort(arr): Sorts an array of integers in non-decreasing order using merge sort. if len(arr) <= 1: return arr mid = len(arr) // 2 left = merge_sort(arr[:mid]) right = merge_sort(arr[mid:]) return merge(left, right) def merge(left, right): Merges two sorted lists into one sorted list. sorted_list = [] i = j = 0 while i < len(left) and j < len(right): if left[i] <= right[j]: sorted_list.append(left[i]) i += 1 else: sorted_list.append(right[j]) j += 1 # Append the remaining elements of left while i < len(left): sorted_list.append(left[i]) i += 1 # Append the remaining elements of right while j < len(right): sorted_list.append(right[j]) j += 1 return sorted_list"},{"question":"# Problem Statement Write a function to calculate the next greater number using the same digits of a given number. If no such number is possible, return -1. This problem involves permutating the digits of the number to form the next greater number in lexicographic order. # Function Signature ```python def next_greater_number(n: int) -> int: ``` # Input - An integer `n` where (1 leq n leq 10^9). # Output - An integer representing the next greater number using the same digits, or -1 if no such number exists. # Constraints 1. The input number should be a positive integer. 2. If a next greater number does not exist with the same set of digits, return -1. # Example ```python # Input: 123 # Output: 132 # Input: 321 # Output: -1 # Input: 534976 # Output: 536479 # Input: 218765 # Output: 251678 # Input: 1999999999 # Output: -1 ``` # Solution Guidelines 1. **Identify the Pivot:** Starting from the right, find the first digit which is smaller than the digit next to it. Let\'s call this digit the pivot. 2. **Find the Swap Point:** Again, starting from the right, find the smallest digit that is larger than the pivot. This will be swapped with the pivot. 3. **Swap Characters:** Swap the pivot with this smallest greater digit. 4. **Sort the Digits After Pivot:** Finally, sort the digits after the pivot position to get the next smallest lexicographical order. # Hints - You can convert the number to a list of its digits for ease of manipulation. - Sorting the sublist after swapping the pivot will ensure the smallest possible arrangement that is still greater than the original number. Implement the solution ensuring you handle all edge cases and achieve the desired complexity and performance standards.","solution":"def next_greater_number(n: int) -> int: digits = list(str(n)) length = len(digits) # Step 1: Find the pivot where the digits[i] < digits[i + 1] for i in range(length - 2, -1, -1): if digits[i] < digits[i + 1]: break else: return -1 # No such pivot found # Step 2: Find the smallest digit on right side of (i\'th digit) that is greater than digits[i] for j in range(length - 1, i, -1): if digits[j] > digits[i]: break # Step 3: Swap digits[i] and digits[j] digits[i], digits[j] = digits[j], digits[i] # Step 4: Sort the sublist after i to get the smallest lexicographic order digits = digits[:i + 1] + sorted(digits[i + 1:]) result = int(\\"\\".join(digits)) # Check if result is within the constraints if result > 10**9: return -1 return result"},{"question":"# Coding Assessment Question Objective Implement a function to blur an image using the Pillow library. Your implementation should be efficient and offer adjustable blur intensity while preserving the overall shape and colors of the objects in the image. Task Write a function `apply_blur(img: Image, radius: float) -> Image:` which blurs the given image according to the specified blur radius. Input and Output Format **Input**: - `img`: An instance of `PIL.Image`. - `radius`: A float representing the blur radius to be used. **Output**: - The function should return an instance of `PIL.Image` with the blur applied. Constraints - Ensure that the blur radius is non-negative. If a negative value is provided, set the radius to zero (indicating no blur). - The blur should be uniformly applied to all parts of the image. Performance Requirements - The function should be efficient and handle images of various sizes, with a time complexity dependent on the blur operation capabilities of the Pillow library. Example ```python from PIL import Image, ImageFilter def apply_blur(img: Image, radius: float) -> Image: Function to apply blur to an image. # Ensure the radius is non-negative radius = max(0, radius) # Apply the blur filter to the image return img.filter(ImageFilter.GaussianBlur(radius)) with Image.open(\\"path/to/your/image.jpg\\") as img: # Apply blur blurred_img = apply_blur(img, 5.0) # Save the blurred image blurred_img.save(\\"path/to/your/blurred_image.png\\", format=\\"png\\") ``` Scenario Imagine you are developing an image editing tool where users can apply various effects to their images, including blurring. Your task is to implement the blurring functionality that users can employ to adjust the level of blur on their images. Use the provided `apply_blur` function template to complete this task.","solution":"from PIL import Image, ImageFilter def apply_blur(img: Image, radius: float) -> Image: Function to apply blur to an image. # Ensure the radius is non-negative radius = max(0, radius) # Apply the blur filter to the image return img.filter(ImageFilter.GaussianBlur(radius))"},{"question":"# Code Parser for Mathematical Expressions As a senior developer working on a scientific calculator application, you are tasked with implementing a tool that can parse and evaluate simple mathematical expressions. The parser should correctly handle basic arithmetic operations and adhere to the precedence rules. # Task: Implement a function `evaluate_expression(expression: str) -> float` that: * Takes a string representing a mathematical expression (`expression`), which may include numbers (both integers and floating-point), parentheses `()`, and the operators `+`, `-`, `*`, `/`. * Evaluates the expression according to standard arithmetic rules and returns the result as a floating-point number. # Input: * `expression`: A string representing a mathematical expression (1 <= len(expression) <= 500). # Output: * The result of the evaluated expression as a floating-point number. # Example: ```python >>> evaluate_expression(\'3 + 5 * 2\') 13.0 >>> evaluate_expression(\'(2 + 3) * 4.5\') 22.5 >>> evaluate_expression(\'10 / (5 - 3)\') 5.0 ``` # Constraints: * Ensure the function properly handles operator precedence. * Support both integer and floating-point arithmetic. * Handle edge cases such as division by zero appropriately by raising an appropriate error. # Performance Requirement: * Your solution should be capable of parsing and evaluating the expression within a reasonable time frame for the given input size. Focus on correct implementation of the recursive parsing technique to manage operator precedence and parentheses.","solution":"def evaluate_expression(expression: str) -> float: Evaluates a simple mathematical expression. import re # Tokenize the expression def tokenize(expression): tokens = re.findall(r\'d+.d+|d+|[+*/()-]\', expression) return tokens # Parse tokens based on precedence def parse(tokens): def parse_expression(index): current = parse_term(index) while index[0] < len(tokens) and tokens[index[0]] in (\'+\', \'-\'): op = tokens[index[0]] index[0] += 1 next_term = parse_term(index) if op == \'+\': current += next_term elif op == \'-\': current -= next_term return current def parse_term(index): current = parse_factor(index) while index[0] < len(tokens) and tokens[index[0]] in (\'*\', \'/\'): op = tokens[index[0]] index[0] += 1 next_factor = parse_factor(index) if op == \'*\': current *= next_factor elif op == \'/\': current /= next_factor return current def parse_factor(index): current = None if index[0] < len(tokens) and tokens[index[0]] == \'(\': index[0] += 1 current = parse_expression(index) index[0] += 1 # Skipping \')\' else: current = float(tokens[index[0]]) index[0] += 1 return current index = [0] return parse_expression(index) tokens = tokenize(expression) return parse(tokens)"},{"question":"# Problem Statement You have been asked to create a simplified inventory management system for a small retail store. Your task is to implement functions that will help manage the stock of products and process sales. The system will keep track of product quantities and handle the sale of items by updating the inventory accordingly. Function Descriptions 1. **add_to_inventory(inventory: dict[str, int], product: str, quantity: int) -> dict[str, int]** - Input: A dictionary representing the current inventory where keys are product names and values are their quantities, a product name, and a quantity to add. - Output: An updated inventory dictionary with the specified quantity added to the product\'s current stock. If the product doesn\'t exist in the inventory, it should be added. - Example: ```python inventory = {\'apple\': 10, \'banana\': 5} add_to_inventory(inventory, \'orange\', 7) # returns {\'apple\': 10, \'banana\': 5, \'orange\': 7} add_to_inventory(inventory, \'apple\', 5) # returns {\'apple\': 15, \'banana\': 5, \'orange\': 7} ``` 2. **remove_from_inventory(inventory: dict[str, int], product: str, quantity: int) -> dict[str, int]** - Input: A dictionary representing the current inventory where keys are product names and values are their quantities, a product name, and a quantity to remove. - Output: An updated inventory dictionary with the specified quantity removed from the product\'s current stock. If the product quantity after removal is 0 or less, the product should be removed from the inventory. - Example: ```python inventory = {\'apple\': 10, \'banana\': 5} remove_from_inventory(inventory, \'banana\', 3) # returns {\'apple\': 10, \'banana\': 2} remove_from_inventory(inventory, \'apple\', 12) # returns {\'banana\': 2} ``` 3. **check_stock(inventory: dict[str, int], product: str) -> int** - Input: A dictionary representing the current inventory where keys are product names and values are their quantities, a product name. - Output: The quantity of the product in the inventory. If the product is not found, return 0. - Example: ```python inventory = {\'apple\': 10, \'banana\': 5} check_stock(inventory, \'apple\') # returns 10 check_stock(inventory, \'orange\') # returns 0 ``` 4. **process_sale(inventory: dict[str, int], product: str, quantity: int) -> bool** - Input: A dictionary representing the current inventory where keys are product names and values are their quantities, a product name, and a quantity to be sold. - Output: A boolean indicating whether the sale was successful (True) or not (False). A sale is unsuccessful if the quantity requested for sale is more than the current stock. - Example: ```python inventory = {\'apple\': 10, \'banana\': 5} process_sale(inventory, \'apple\', 5) # returns True and updates inventory to {\'apple\': 5, \'banana\': 5} process_sale(inventory, \'banana\', 6) # returns False and inventory remains unchanged ``` # Constraints: - Product names are case-sensitive strings. - Quantities are non-negative integers. # Implementation Implement the following functions: ```python def add_to_inventory(inventory: dict[str, int], product: str, quantity: int) -> dict[str, int]: # Your implementation here pass def remove_from_inventory(inventory: dict[str, int], product: str, quantity: int) -> dict[str, int]: # Your implementation here pass def check_stock(inventory: dict[str, int], product: str) -> int: # Your implementation here pass def process_sale(inventory: dict[str, int], product: str, quantity: int) -> bool: # Your implementation here pass ```","solution":"def add_to_inventory(inventory: dict[str, int], product: str, quantity: int) -> dict[str, int]: if product in inventory: inventory[product] += quantity else: inventory[product] = quantity return inventory def remove_from_inventory(inventory: dict[str, int], product: str, quantity: int) -> dict[str, int]: if product in inventory: inventory[product] -= quantity if inventory[product] <= 0: del inventory[product] return inventory def check_stock(inventory: dict[str, int], product: str) -> int: return inventory.get(product, 0) def process_sale(inventory: dict[str, int], product: str, quantity: int) -> bool: if product in inventory and inventory[product] >= quantity: inventory[product] -= quantity if inventory[product] == 0: del inventory[product] return True return False"},{"question":"# Scenario You\'ve been tasked with developing a utility function to help with string manipulations in a text editor. One of the required features is to evaluate if two given strings are anagrams of each other. Given your expertise with string and array manipulations, implement an efficient solution to check if the strings are anagrams. # Problem Statement Implement a function `are_anagrams(str1: str, str2: str) -> bool` that takes in two strings `str1` and `str2`. The function should return `True` if the strings are anagrams, and `False` if they are not. # Input and Output Formats * The function will receive two strings `str1` and `str2` as input parameters. * The function will return a boolean `True` or `False`. # Constraints * Both strings will contain only lowercase English letters. * The lengths of both strings will be between 1 and (10^5) characters. # Performance Requirements * The implementation should run in linear time complexity (O(n)) where (n) is the length of the longer string. # Example Cases ```python >>> are_anagrams(\\"listen\\", \\"silent\\") True >>> are_anagrams(\\"triangle\\", \\"integral\\") True >>> are_anagrams(\\"apple\\", \\"pale\\") False >>> are_anagrams(\\"race\\", \\"care\\") True >>> are_anagrams(\\"hello\\", \\"world\\") False >>> are_anagrams(\\"aab\\", \\"bca\\") False >>> are_anagrams(\\"anagram\\", \\"nagaram\\") True ``` # Additional Notes * Consider edge cases such as when the strings are of different lengths. * Avoid using any external libraries or built-in sorting functions for the solution; focus on utilizing array manipulation techniques to achieve the objective.","solution":"def are_anagrams(str1: str, str2: str) -> bool: Returns True if str1 and str2 are anagrams, False otherwise. if len(str1) != len(str2): return False # Count the frequency of each character in both strings char_count = [0] * 26 # Since we have only lowercase English letters for char in str1: char_count[ord(char) - ord(\'a\')] += 1 for char in str2: char_count[ord(char) - ord(\'a\')] -= 1 # If both strings are anagrams, all counts should be zero for count in char_count: if count != 0: return False return True"},{"question":"# Coding Assessment Question: You are tasked with creating a Python application that processes customer transaction data for a retail chain. The application should be efficient and able to handle large datasets. The focus will be on filtering, summarizing, and organizing transaction information. Objectives: 1. **Data Loading and Schema Validation**: - Implement a method to load transaction data from a given CSV file. - Ensure the data conforms to a predefined schema for columns such as `transaction_id`, `customer_id`, `item_id`, `quantity`, and `transaction_date`. 2. **Filtering Transactions**: - Create a mechanism to filter transactions based on date range and specific product IDs. 3. **Summarizing Data**: - Write a method to summarize transactions by `customer_id`, calculating the total number of items purchased and the total quantity of items purchased. 4. **Output Results**: - Implement functionality to export the summarized data to a new CSV file. Function Specification: * **Expected Input and Output Formats**: - **Input**: A file path to the input CSV, and optionally, date ranges or product IDs for filtering. - **Output**: A CSV file containing the summarized transaction data. * **Constraints and Limitations**: - Assume the input CSV file is formatted correctly but handle cases where data might be missing or corrupt. - Ensure the solution is scalable and can handle large datasets efficiently. * **Performance Requirements**: The application should not load the entire dataset into memory if possible; use techniques like streaming or chunk processing for large files. Implementation Requirements: 1. Define a class `RetailTransactionProcessor` that: - Loads and validates data from a CSV file. - Filters transactions based on given criteria. - Summarizes transaction data by customer. - Exports summarized data to a CSV file. 2. Ensure robust error handling for missing or corrupt data in the input file. 3. Optimize the data processing methods to handle large datasets efficiently. 4. Include detailed comments and documentation to explain the implementation. Function Signature: ```python import csv from typing import List, Dict import datetime class RetailTransactionProcessor: def __init__(self, file_path: str): self.file_path = file_path self.transactions = self.load_data() def load_data(self) -> List[Dict]: Load transaction data from a CSV file and validate schema. # Implementation goes here. def filter_transactions(self, start_date: str = None, end_date: str = None, product_ids: List[str] = None) -> List[Dict]: Filter transactions based on date range and product IDs. # Implementation goes here. def summarize_transactions(self) -> List[Dict]: Summarize transactions by customer. # Implementation goes here. def export_summary(self, summary_data: List[Dict], output_file: str): Export summarized transaction data to a CSV file. # Implementation goes here. # Example Usage processor = RetailTransactionProcessor(\'transactions.csv\') filtered_transactions = processor.filter_transactions(start_date=\'2023-01-01\', end_date=\'2023-02-01\', product_ids=[\'101\', \'202\']) summary = processor.summarize_transactions() processor.export_summary(summary, \'summary.csv\') ``` # Example Usage: ```python # Initialize the processor with the path to the transaction data CSV processor = RetailTransactionProcessor(\'transactions.csv\') # Filter transactions based on given criteria filtered_transactions = processor.filter_transactions(start_date=\'2023-01-01\', end_date=\'2023-02-01\', product_ids=[\'101\', \'202\']) # Summarize the filtered transactions summary = processor.summarize_transactions() # Export the summarized data to a new CSV file processor.export_summary(summary, \'summary.csv\') ``` Ensure your implementation is efficient, handles edge cases robustly, and includes appropriate comments for clarity.","solution":"import csv from typing import List, Dict, Optional import datetime class RetailTransactionProcessor: def __init__(self, file_path: str): self.file_path = file_path self.transactions = self.load_data() def load_data(self) -> List[Dict]: Load transaction data from a CSV file and validate schema. required_columns = {\'transaction_id\', \'customer_id\', \'item_id\', \'quantity\', \'transaction_date\'} transactions = [] with open(self.file_path, mode=\'r\') as file: csv_reader = csv.DictReader(file) if not required_columns.issubset(set(csv_reader.fieldnames)): raise ValueError(\\"CSV file does not match required schema\\") for row in csv_reader: # Add basic validation if all(row[col] for col in required_columns): transactions.append(row) else: print(f\\"Skipping corrupt row: {row}\\") return transactions def filter_transactions(self, start_date: Optional[str] = None, end_date: Optional[str] = None, product_ids: Optional[List[str]] = None) -> List[Dict]: Filter transactions based on date range and product IDs. filtered_transactions = [] for transaction in self.transactions: transaction_date = datetime.datetime.strptime(transaction[\'transaction_date\'], \'%Y-%m-%d\').date() include_transaction = True if start_date: start_date_parsed = datetime.datetime.strptime(start_date, \'%Y-%m-%d\').date() if transaction_date < start_date_parsed: include_transaction = False if end_date: end_date_parsed = datetime.datetime.strptime(end_date, \'%Y-%m-%d\').date() if transaction_date > end_date_parsed: include_transaction = False if product_ids and transaction[\'item_id\'] not in product_ids: include_transaction = False if include_transaction: filtered_transactions.append(transaction) return filtered_transactions def summarize_transactions(self) -> List[Dict]: Summarize transactions by customer. summary = {} for transaction in self.transactions: customer_id = transaction[\'customer_id\'] item_id = transaction[\'item_id\'] quantity = int(transaction[\'quantity\']) if customer_id not in summary: summary[customer_id] = {\'customer_id\': customer_id, \'total_items\': set(), \'total_quantity\': 0} summary[customer_id][\'total_items\'].add(item_id) summary[customer_id][\'total_quantity\'] += quantity # Convert total_items from set to count for customer_id in summary: summary[customer_id][\'total_items\'] = len(summary[customer_id][\'total_items\']) return list(summary.values()) def export_summary(self, summary_data: List[Dict], output_file: str): Export summarized transaction data to a CSV file. fieldnames = [\'customer_id\', \'total_items\', \'total_quantity\'] with open(output_file, mode=\'w\', newline=\'\') as file: writer = csv.DictWriter(file, fieldnames=fieldnames) writer.writeheader() writer.writerows(summary_data)"},{"question":"# Family Tree - Generation Subset Extraction Context You are given a family tree data structure where each person is represented as a node in a tree. A family tree consists of individuals (nodes) and parent-child relationships (edges). Each node contains information about the person\'s name and generation (an integer starting at 0 for the root). Understanding and manipulating hierarchical data structures such as trees is crucial for tasks ranging from organizational charts to biological phylogeny and genealogy. Task Create a function that extracts all names of individuals from a specified generation. Specific Objectives 1. Traverse the family tree and collect names of individuals belonging to the specified generation. 2. The function should handle edge cases, such as non-existent generations and trees with varying depths. Function Signature ```python def extract_generation(family_tree: dict, generation: int) -> list: pass ``` Input - `family_tree`: A dictionary representing a family tree. The keys are person names (strings), and values are nested dictionaries containing the names of their children (also dictionaries). - `generation`: An integer representing the generation to extract. Output - Returns a list of names (strings) of individuals in the specified generation. Constraints - The `family_tree` dictionary contains at most 1000 individuals. - Generation values start from 0 for the root and increase by 1 for each subsequent generation. - You may assume that the input is a valid and connected tree. Requirements - Your solution should handle non-existent generations gracefully. - Optimize the traversal to minimize unnecessary checks. - Ensure the function works correctly for trees of varying sizes and depths. Example ```python example_tree = { \'John\': { \'Michael\': { \'Jake\': {}, \'Amy\': {} }, \'Sarah\': { \'Linda\': { \'Sophia\': {} } } } } assert extract_generation(example_tree, 0) == [\'John\'] assert extract_generation(example_tree, 1) == [\'Michael\', \'Sarah\'] assert extract_generation(example_tree, 2) == [\'Jake\', \'Amy\', \'Linda\'] assert extract_generation(example_tree, 3) == [\'Sophia\'] assert extract_generation(example_tree, 4) == [] ``` Good luck!","solution":"def extract_generation(family_tree: dict, generation: int) -> list: result = [] def traverse(tree: dict, current_generation: int): if current_generation == generation: result.extend(tree.keys()) return for child in tree.values(): traverse(child, current_generation + 1) traverse(family_tree, 0) return result"},{"question":"# Bank Transactions Analyzer **Description**: You are required to build a utility to analyze bank transactions from a CSV file. The file contains records of transactions, each including the date, transaction description, and the amount. Your task is to generate monthly spending reports. **Objective**: Develop a function `monthly_spending_report(file_path: str)` that: 1. Reads a CSV file containing transaction records. 2. Aggregates the spending amounts for each month. 3. Returns a dictionary where the keys are month-year pairs (e.g., \\"01-2023\\") and the values are the total spending for that month. **Input**: * A file path to a CSV file structured as follows (columns are `Date`, `Description`, `Amount`): ``` Date,Description,Amount 2023-01-15,Coffee,-3.50 2023-01-20,Groceries,-120.45 2023-02-10,Gas,-40.00 ``` **Output**: * A dictionary where each key is a month-year pair in the format \\"MM-YYYY\\" and the value is the total amount spent during that month (e.g., `{\\"01-2023\\": -123.95, \\"02-2023\\": -40.00}`). **Constraints**: * Only consider negative amounts as spendings. * The Date column will always be in the format `YYYY-MM-DD`. * The Amount column will always be a valid floating-point number. * The CSV might contain records for the same month spread across multiple rows. **Performance Requirements**: * Handle files with up to 10000 rows efficiently. * Ensure robustness by handling potential file read errors. # Implementation Complete the function `monthly_spending_report(file_path: str) -> Dict[str, float]`: ```python import csv from typing import Dict, List from collections import defaultdict def monthly_spending_report(file_path: str) -> Dict[str, float]: spending = defaultdict(float) try: with open(file_path, mode=\'r\') as file: reader = csv.DictReader(file) for row in reader: date_parts = row[\'Date\'].split(\'-\') month_year = f\\"{date_parts[1]}-{date_parts[0]}\\" amount = float(row[\'Amount\']) if amount < 0: spending[month_year] += amount except FileNotFoundError: print(f\\"Error: The file at {file_path} was not found.\\") except Exception as e: print(f\\"An error occurred: {e}\\") return dict(spending) if __name__ == \\"__main__\\": file_path = \'transactions.csv\' report = monthly_spending_report(file_path) for month_year, total in report.items(): print(f\\"Total spending for {month_year}: {total:.2f}\\") ``` Handle possible edge cases and ensure your solution runs efficiently. Happy coding!","solution":"import csv from typing import Dict from collections import defaultdict def monthly_spending_report(file_path: str) -> Dict[str, float]: spending = defaultdict(float) try: with open(file_path, mode=\'r\') as file: reader = csv.DictReader(file) for row in reader: date_parts = row[\'Date\'].split(\'-\') month_year = f\\"{date_parts[1]}-{date_parts[0]}\\" amount = float(row[\'Amount\']) if amount < 0: spending[month_year] += amount except FileNotFoundError: print(f\\"Error: The file at {file_path} was not found.\\") except Exception as e: print(f\\"An error occurred: {e}\\") return dict(spending)"},{"question":"# Problem Statement Write a Python program to identify and print all unutilized functions in a given Python script file. The goal is to help developers find code that can be cleaned up or removed. # Requirements Implement a function `find_unused_functions` that takes one parameter, `file_path: str`, representing the path to the Python script file to be analyzed. The function should: 1. Parse the given Python file to find all function definitions. 2. Identify if a function is utilized within the same file or not. 3. Return a list of names of functions that are never called within the file. # Constraints * Assume that the input Python file contains valid syntax. * Ignore built-in functions and external library calls; focus only on user-defined functions within the file. * Handle nested function calls as well, ensuring accurate function call tracking. * Ignore functions that are only called within a string (docstrings, comments, etc.). # Input and Output Formats * **Input**: * `file_path: str`: A string representing the file path of the Python script to be analyzed. * **Output**: * `List[str]`: A list containing the names of functions that are defined but never called within the file. # Performance Requirements * Ensure the function efficiently handles files with up to 1000 lines of code. * Minimize memory usage by reading and processing the file line by line. # Example ```python def find_unused_functions(file_path: str) -> list[str]: # Your implementation here # Example usage unused_functions = find_unused_functions(\\"path/to/python_script.py\\") print(unused_functions) ``` # Notes * Consider using the `ast` module to parse and analyze the Python file. * Implement reasonable error handling to manage file I/O errors. * Do not worry about functions that may be used outside the given file (not applicable here). # Sample Input File ```python # sample_script.py def unused_function(): pass def used_function(): print(\\"Hello, World!\\") def main(): used_function() if __name__ == \\"__main__\\": main() ``` # Sample Output ```python [\'unused_function\'] ``` This solution helps ensure codebase cleanliness by identifying potentially obsolete functions within a given script.","solution":"import ast def find_unused_functions(file_path: str) -> list: Identifies unutilized functions in a given Python script file. Parameters: file_path (str): Path to the Python script file to be analyzed Returns: list: List of names of functions that are never called within the file with open(file_path, \\"r\\") as file: tree = ast.parse(file.read()) # Collect function definitions functions = {node.name for node in ast.walk(tree) if isinstance(node, ast.FunctionDef)} # Collect function calls calls = {node.func.id for node in ast.walk(tree) if isinstance(node, ast.Call) and isinstance(node.func, ast.Name)} # Find unutilized functions (defined but never called) unused_functions = functions - calls return list(unused_functions)"},{"question":"# Question: Cache Simulation Optimization You have been assigned the task of optimizing a cache simulation algorithm. The cache uses a Least Recently Used (LRU) policy to discard the least recently used items when it reaches its maximum capacity. Your goal is to implement an enhanced version of this cache that also considers frequency of access in its eviction policy. The cache should prioritize items based on a combined metric of recent usage and frequency of access. Requirements: 1. **Functionality to Implement**: Modify the given cache framework to incorporate a combined LRU and Least Frequently Used (LFU) policy. 2. **Input and Output Formats**: - **Input**: * `cache_capacity (int)`: The maximum number of items the cache can hold. * `operations (list[tuple[str, int]])`: A list of operations, where each operation is a tuple containing a command (\\"put\\" or \\"get\\") and a key (for \\"put\\" operations, there will be an additional value). - **Output**: A list of results for \\"get\\" operations; for \\"put\\" operations, return `null`. 3. **Constraints**: - The cache capacity will be a positive integer. - The operations list will contain valid commands with relevant keys and values. ```python class HybridCache: def __init__(self, capacity: int): Initialize the cache with a given capacity. :param capacity: Maximum number of items the cache can hold. self.capacity = capacity # Initialize your data structures here def get(self, key: int) -> int: Retrieve a value from the cache using the key. :param key: The key to look for in the cache. :return: The value associated with the key, or -1 if the key is not found. # Your code here pass def put(self, key: int, value: int): Insert a new key-value pair into the cache. :param key: The key to insert. :param value: The value associated with the key. # Your code here pass def cache_simulation(cache_capacity: int, operations: list[tuple[str, int]]) -> list: Simulate the cache operations and return results for \\"get\\" operations. :param cache_capacity: The maximum capacity of the cache. :param operations: A list of operations (commands) to perform on the cache. :return: A list of results for \\"get\\" operations. cache = HybridCache(cache_capacity) results = [] for operation in operations: if operation[0] == \\"put\\": _, key, value = operation cache.put(key, value) results.append(None) elif operation[0] == \\"get\\": _, key = operation result = cache.get(key) results.append(result) return results ``` **Scenarios to Consider**: * Handling cache capacity exactly and evicting the correct items first when the capacity is reached. * Balancing recent usage and access frequency to optimize cache hits and minimize cache misses. * Ensuring the performance is optimal given a high number of operations. Write your solution to implement the `HybridCache` class and ensure to test the functions against various edge cases.","solution":"import collections class HybridCache: def __init__(self, capacity: int): Initialize the cache with a given capacity. :param capacity: Maximum number of items the cache can hold. self.capacity = capacity self.cache = {} self.usage_frequency = collections.Counter() self.order = collections.OrderedDict() def get(self, key: int) -> int: Retrieve a value from the cache using the key. :param key: The key to look for in the cache. :return: The value associated with the key, or -1 if the key is not found. if key not in self.cache: return -1 self.usage_frequency[key] += 1 self.order.move_to_end(key) return self.cache[key] def put(self, key: int, value: int): Insert a new key-value pair into the cache. :param key: The key to insert. :param value: The value associated with the key. if key in self.cache: self.cache[key] = value self.usage_frequency[key] += 1 self.order.move_to_end(key) else: if len(self.cache) >= self.capacity: # Evict the item with the least frequency of use least_freq = min(self.usage_frequency, key=self.usage_frequency.get) # If there is a tie, evict the least recently used candidates = [k for k, v in self.usage_frequency.items() if v == self.usage_frequency[least_freq]] to_evict = min(candidates, key=lambda k: list(self.order).index(k)) # Remove the item from cache, usage_frequency, and order del self.cache[to_evict] del self.usage_frequency[to_evict] del self.order[to_evict] self.cache[key] = value self.usage_frequency[key] += 1 self.order[key] = None def cache_simulation(cache_capacity: int, operations: list[tuple[str, int]]) -> list: Simulate the cache operations and return results for \\"get\\" operations. :param cache_capacity: The maximum capacity of the cache. :param operations: A list of operations (commands) to perform on the cache. :return: A list of results for \\"get\\" operations. cache = HybridCache(cache_capacity) results = [] for operation in operations: if operation[0] == \\"put\\": _, key, value = operation cache.put(key, value) results.append(None) elif operation[0] == \\"get\\": _, key = operation result = cache.get(key) results.append(result) return results"},{"question":"# Prime Factorization with Constraints Scenario You are working for a finance company that uses prime factorization to secure its data by encoding using product-based encryption. You are tasked with implementing a secure, high-performance module for decomposing a number into its prime factors under strict constraints. Problem Implement a function `secure_prime_factors(input_num: int) -> List[int]` that computes the prime factors of a given positive integer. The function must: * Check and handle non-integer or non-positive inputs by raising a `ValueError`. * Optimize the computation for very large integers. * Ensure the order of the prime factors is from the smallest to largest. Input - `input_num`: A positive integer `n` (2 ≤ n ≤ 10^12). Output - Return a list of integers, which are the prime factors of `input_num`, sorted in ascending order. Constraints - If `input_num` is not a positive integer, raise a `ValueError` with the message \\"Input must be a positive integer\\". - The function should be optimized to handle large values of `input_num` efficiently. Example ```python # prime factors of 18 are 2 and 3 occurring twice, hence [2, 3, 3] assert secure_prime_factors(18) == [2, 3, 3] # prime factors of 29 is 29 itself, since it\'s a prime number assert secure_prime_factors(29) == [29] # prime factors of 56 are 2 occurring thrice and 7 once, hence [2, 2, 2, 7] assert secure_prime_factors(56) == [2, 2, 2, 7] # prime factors of 100 is 2 occurring twice and 5 occurring twice, hence [2, 2, 5, 5] assert secure_prime_factors(100) == [2, 2, 5, 5] ``` Notes * Ensure your function can handle very large inputs efficiently. * Utilize strategies such as trial division up to √n and optimized sieve methods to reduce the number of operations. Hint You can utilize the fact that you only need to test divisibility up to the square root of `input_num` for potentially reducing the computational complexity.","solution":"from typing import List import math def secure_prime_factors(input_num: int) -> List[int]: if not isinstance(input_num, int) or input_num <= 0: raise ValueError(\\"Input must be a positive integer\\") if input_num == 1: return [] prime_factors = [] # Check for number of 2s that divide input_num while input_num % 2 == 0: prime_factors.append(2) input_num //= 2 # n must be odd at this point, so a skip of 2 (i.e., 3, 5, 7, ...) is used for i in range(3, int(math.sqrt(input_num)) + 1, 2): while input_num % i == 0: prime_factors.append(i) input_num //= i # If n is a prime number greater than 2, it will remain as is if input_num > 2: prime_factors.append(input_num) return prime_factors"},{"question":"# Problem Statement Create a function that evaluates arithmetic expressions and returns the result. The expressions may include the four basic operators (+, -, *, /) and parentheses for grouping. Expressions are provided as a string, and the function should correctly handle nested sub-expressions. Implement the `evaluate_expression` function with the following specifications: **Function Name**: `evaluate_expression` **Input**: - `expression` (str): A valid arithmetic expression containing integers, operators (+, -, *, /), and parentheses. There will be no spaces in the input. **Output**: - `result` (int or float): The result of evaluating the arithmetic expression. # Requirements - Implement a robust algorithm that accurately evaluates the expression according to standard operator precedence and parentheses. - Handle division by zero gracefully, returning a specific error message: \\"Division by zero error\\". - Ensure the function returns a float when division is involved and an integer otherwise. - Consider edge cases such as multiple nested parentheses and invalid input (return an appropriate error message for invalid input). # Example Usage ```python assert evaluate_expression(\\"3+5*2\\") == 13 assert evaluate_expression(\\"(3+5)*2\\") == 16 assert evaluate_expression(\\"10/(2+3)\\") == 2.0 assert evaluate_expression(\\"10/(5-5)\\") == \\"Division by zero error\\" assert evaluate_expression(\\"7-3*2+10/2\\") == 5.0 assert evaluate_expression(\\"((2+3)*2)/5\\") == 2.0 ``` # Additional Guidelines - Write unit tests to cover a wide range of cases, including nested expressions, division by zero, and invalid inputs. - Aim to achieve O(n) time complexity where n is the length of the expression. - Be mindful of different data types in your implementation and ensure the result is accurate and correctly typed.","solution":"def evaluate_expression(expression): try: result = eval(expression, {\\"__builtins__\\": None}, {}) if isinstance(result, float) and result.is_integer(): result = int(result) return result except ZeroDivisionError: return \\"Division by zero error\\" except Exception as e: return \\"Invalid input\\" def is_valid_expression(expression): # Basic validation for only valid characters valid_chars = set(\\"0123456789+-*/().\\") for char in expression: if char not in valid_chars: return False return True"},{"question":"# Coding Question Context: You have been assigned a task to write a function that can manipulate a given 2D matrix (list of lists) by rotating it 90 degrees clockwise or counterclockwise based on the input direction. Objective: Implement a function that rotates a given 2D matrix by 90 degrees in the specified direction (\'clockwise\' or \'counterclockwise\'). Function Signature: ```python def rotate_matrix(matrix: list, direction: str) -> list: :param matrix: List[List[int]] : a 2D matrix represented as a list of lists :param direction: str : the direction to rotate, either \'clockwise\' or \'counterclockwise\' :return: List[List[int]] : the rotated matrix Example: >>> rotate_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]], \'clockwise\') [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> rotate_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]], \'counterclockwise\') [[3, 6, 9], [2, 5, 8], [1, 4, 7]] ``` Requirements: * **Input**: * `matrix` - a non-empty 2D list of integers where all inner lists are of the same length. * `direction` - a string indicating the rotation direction, either \'clockwise\' or \'counterclockwise\'. * **Output**: * Return a new 2D list (matrix) rotated 90 degrees in the specified direction. Constraints: * The provided 2D matrix will always be square (N x N). * Handle edge cases where the input matrix is a single row with multiple columns or a single column with multiple rows. * Ensure your function performs efficiently for larger matrices. Edge Cases: * The matrix contains negative or zero values. * The matrix contains the minimum or maximum integer value.","solution":"def rotate_matrix(matrix, direction): Rotates a 2D matrix 90 degrees in the specified direction. :param matrix: List[List[int]] : a 2D matrix represented as a list of lists :param direction: str : the direction to rotate, either \'clockwise\' or \'counterclockwise\' :return: List[List[int]] : the rotated matrix if direction == \'clockwise\': return [list(reversed(col)) for col in zip(*matrix)] elif direction == \'counterclockwise\': return [list(col) for col in reversed(tuple(zip(*matrix)))] else: raise ValueError(\\"Direction must be either \'clockwise\' or \'counterclockwise\'\\") # Examples: # print(rotate_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]], \'clockwise\')) # Output: [[7, 4, 1], [8, 5, 2], [9, 6, 3]] # print(rotate_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]], \'counterclockwise\')) # Output: [[3, 6, 9], [2, 5, 8], [1, 4, 7]]"},{"question":"**Context**: A software tool for managing email communications needs a functionality that can automatically detect the presence of all required components in an email address. This helps in validation before sending emails. **Task**: Implement the function `is_valid_email(email: str) -> bool` that checks if a given string is a valid email address as per the following simplified rules: 1. It must contain exactly one `@` symbol. 2. There must be at least one character before the `@`. 3. There must be at least one character after the `@`, followed by a `.` and at least one character after the `.`. **Function Signature**: ```python def is_valid_email(email: str) -> bool: pass ``` **Input**: * `email` (str): A string representing the email address to be validated. **Output**: * (bool): `True` if the email address is valid according to the rules mentioned, `False` otherwise. **Constraints**: * The input string can be of any length, up to 256 characters. **Examples**: ```python assert is_valid_email(\\"user@example.com\\") == True assert is_valid_email(\\"user.name@example.co.in\\") == True assert is_valid_email(\\"user@com\\") == False assert is_valid_email(\\"user@@example.com\\") == False assert is_valid_email(\\"@example.com\\") == False assert is_valid_email(\\"user@.com\\") == False assert is_valid_email(\\"user@com.\\") == False assert is_valid_email(\\"user@example.\\") == False ```","solution":"def is_valid_email(email: str) -> bool: This function checks if a given string is a valid email address. Rules for a valid email: 1. It must contain exactly one @ symbol. 2. There must be at least one character before the @. 3. There must be at least one character after the @, followed by a . and at least one character after the .. try: # Split the email into local part and domain part local, domain = email.split(\'@\') # Local part must not be empty if not local: return False # Domain part must contain a dot and at least one character before and after the dot if \'.\' not in domain: return False domain_part1, domain_part2 = domain.split(\'.\', 1) if not domain_part1 or not domain_part2: return False return True except ValueError: # ValueError is raised if email.split(\'@\') results in more than 1 split return False"},{"question":"# K-Nearest Neighbors Classifier Implementation Context You are a machine learning developer at an e-commerce company. Your task is to implement a K-Nearest Neighbors (KNN) classifier to recommend products to users based on their browsing history. You need to classify whether a user will buy a product (1) or not (0) based on their browsing patterns captured in the dataset. Objective Implement a K-Nearest Neighbors classifier from scratch to perform binary classification on a given dataset. Optimize the model by incorporating distance weighting during prediction. Input Format 1. A matrix `X_train` of shape (m, k) representing m training samples and k features. 2. A vector `y_train` of shape (m,) representing the binary class labels for the training set (0 or 1). 3. A matrix `X_test` of shape (n, k) representing n test samples and k features. 4. An integer `k_neighbors` specifying the number of nearest neighbors to consider for the classification. 5. A string `distance_metric` indicating the distance metric to use for the KNN (either \\"euclidean\\" or \\"manhattan\\"). Output Format 1. A vector `y_pred` of shape (n,) representing the predicted class labels for the test set. 2. Print the number of correct predictions after classifying all test samples (optional for debugging). Constraints 1. Number of features `k` should be ≥ 1 and ≤ 50. 2. Number of training samples `m` should be ≥ 10 and ≤ 10000. 3. Number of test samples `n` should be ≥ 1 and ≤ 1000. 4. The value of `k_neighbors` should be ≥ 1 and ≤ 20. # Function Signature ```python def knn_classifier(X_train: np.ndarray, y_train: np.ndarray, X_test: np.ndarray, k_neighbors: int, distance_metric: str) -> np.ndarray: pass ``` # Example ```python X_train = np.array([[1, 2], [2, 3], [3, 3], [4, 2], [5, 3]]) y_train = np.array([0, 0, 1, 1, 1]) X_test = np.array([[3, 2], [3, 4]]) k_neighbors = 3 distance_metric = \\"euclidean\\" y_pred = knn_classifier(X_train, y_train, X_test, k_neighbors, distance_metric) print(\\"Predicted labels:\\", y_pred) ``` In this example, the function `knn_classifier` should output predicted class labels for the test samples based on the K-NN algorithm. # Requirements Implement the core operational steps for the K-Nearest Neighbors classifier: 1. Calculate the distance between the test sample and all training samples using the specified distance metric. 2. Identify the `k_neighbors` nearest training samples. 3. Incorporate distance weighting to give closer neighbors more influence in the prediction. 4. Predict the class label for the test sample based on the majority vote among the nearest neighbors. Good luck!","solution":"import numpy as np from scipy.stats import mode def euclidean_distance(a, b): return np.sqrt(np.sum((a - b)**2)) def manhattan_distance(a, b): return np.sum(np.abs(a - b)) def knn_classifier(X_train: np.ndarray, y_train: np.ndarray, X_test: np.ndarray, k_neighbors: int, distance_metric: str) -> np.ndarray: K-Nearest Neighbors classifier from scratch. Parameters: - X_train: Training data (m, k) - y_train: Labels for training data (m,) - X_test: Test data (n, k) - k_neighbors: Number of neighbors to consider - distance_metric: Distance metric to use (\'euclidean\' or \'manhattan\') Returns: - y_pred: Predicted labels for test data (n,) if distance_metric not in [\\"euclidean\\", \\"manhattan\\"]: raise ValueError(\\"distance_metric should be either \'euclidean\' or \'manhattan\'\\") dist_func = euclidean_distance if distance_metric == \\"euclidean\\" else manhattan_distance def get_neighbors(train_data, train_labels, test_sample): distances = [dist_func(test_sample, x) for x in train_data] sorted_indices = np.argsort(distances) return sorted_indices[:k_neighbors], distances y_pred = [] for test_sample in X_test: neighbors_idx, distances = get_neighbors(X_train, y_train, test_sample) k_neighbors_labels = y_train[neighbors_idx] k_neighbors_distances = np.array([distances[i] for i in neighbors_idx]) # Weighting inverse distances weights = 1 / (k_neighbors_distances + 1e-5) # to avoid division by zero weighted_votes = {} for idx, label in enumerate(k_neighbors_labels): if label in weighted_votes: weighted_votes[label] += weights[idx] else: weighted_votes[label] = weights[idx] sorted_votes = sorted(weighted_votes.items(), key=lambda item: item[1], reverse=True) y_pred.append(sorted_votes[0][0]) y_pred = np.array(y_pred) return y_pred"},{"question":"# Question You are tasked with developing an application capable of managing a simple inventory system for a warehouse. The system should provide functionalities for adding new items, updating quantities, and calculating the total value of the inventory. Given the following requirements: - Implement a Python class `Inventory`, which will allow adding items, updating their quantities, and calculating the total inventory value. Each item in the inventory has a name, quantity, and price per unit. - Use appropriate data structures to maintain efficiency. - Ensure that the inventory updates and calculations handle large datasets effectively. # Class Signature ```python class Inventory: def __init__(self): pass def add_item(self, name: str, quantity: int, price_per_unit: float) -> None: pass def update_quantity(self, name: str, quantity: int) -> None: pass def get_value(self) -> float: pass ``` # Methods - `__init__()`: Initializes an empty inventory. - `add_item(name, quantity, price_per_unit)`: Adds a new item to the inventory with the specified `name`, `quantity`, and `price_per_unit`. If the item already exists, its quantity should be updated. - `update_quantity(name, quantity)`: Updates the quantity of the specified item. If the item does not exist, an appropriate message should be handled. - `get_value()`: Calculates and returns the total value of the inventory, which is the sum of the product of each item\'s quantity and price per unit. # Constraints - Item names are guaranteed to be unique strings. - Quantities are non-negative integers. - Prices per unit are non-negative floating-point numbers. - The system should handle large inventories with hundreds of items efficiently. # Example ```python inventory = Inventory() inventory.add_item(\\"apple\\", 50, 0.5) inventory.add_item(\\"banana\\", 30, 0.2) inventory.add_item(\\"orange\\", 20, 0.8) print(inventory.get_value()) # Output: 41.0 inventory.update_quantity(\\"banana\\", 50) print(inventory.get_value()) # Output: 51.0 inventory.add_item(\\"apple\\", 20, 0.5) print(inventory.get_value()) # Output: 61.0 ``` # Additional Note Focus on maintaining performance with a large number of operations and ensure your implementation is robust against invalid inputs or operations that may result from an item not being present in the inventory.","solution":"class Inventory: def __init__(self): self.items = {} def add_item(self, name: str, quantity: int, price_per_unit: float) -> None: if name in self.items: self.items[name][\'quantity\'] += quantity else: self.items[name] = {\'quantity\': quantity, \'price_per_unit\': price_per_unit} def update_quantity(self, name: str, quantity: int) -> None: if name in self.items: self.items[name][\'quantity\'] = quantity else: self.items[name] = {\'quantity\': quantity, \'price_per_unit\': 0.0} def get_value(self) -> float: total_value = 0.0 for name, info in self.items.items(): total_value += info[\'quantity\'] * info[\'price_per_unit\'] return total_value"},{"question":"# Problem Statement Write a function `largest_repeated_substring(s)` that returns the length of the largest substring that repeats at least once in the given string `s`. # Function Signature: ```python def largest_repeated_substring(s: str) -> int: ``` # Input: - `s`: A string containing only lowercase English letters, with a length between 1 and 500 inclusive. # Output: - An integer representing the length of the largest substring of `s` that appears more than once. # Constraints: 1. The length of the string `s` will be between 1 and 500 inclusive. 2. The string `s` will contain only lowercase English letters. # Example: ```python s = \\"banana\\" assert largest_repeated_substring(s) == 3 # \\"ana\\" is the longest repeated substring s = \\"abcd\\" assert largest_repeated_substring(s) == 0 # No repeated substring s = \\"aaaa\\" assert largest_repeated_substring(s) == 3 # \\"aaa\\" is the longest repeated substring ``` # Notes: - Focus on an efficient approach to ensure the function operates within the constraints. - Pay attention to potential edge cases such as minimal input size or all characters being the same. - Consider different algorithms such as suffix arrays or dynamic programming for efficient implementation.","solution":"def largest_repeated_substring(s: str) -> int: def get_suffix_array(s): # Generate the suffix array for string `s` suffixes = sorted((s[i:], i) for i in range(len(s))) return [x[1] for x in suffixes] def get_lcp_array(s, suffix_array): # Generate the LCP (longest common prefix) array using the suffix array n = len(s) rank = [0] * n lcp = [0] * (n - 1) height = 0 for i, suffix in enumerate(suffix_array): rank[suffix] = i for i in range(n): if rank[i] == n - 1: height = 0 continue j = suffix_array[rank[i] + 1] while i + height < n and j + height < n and s[i + height] == s[j + height]: height += 1 lcp[rank[i]] = height if height > 0: height -= 1 return lcp n = len(s) if n <= 1: return 0 suffix_array = get_suffix_array(s) lcp_array = get_lcp_array(s, suffix_array) return max(lcp_array) if lcp_array else 0"},{"question":"# Unique Words in a Sentence Background You are developing a text analysis tool that requires identifying unique words in a sentence. The tool must be able to distinguish between case-insensitive occurrences of words and compute the correct unique word count. Task Implement a function `count_unique_words` that processes a given sentence and returns the number of unique words. Requirements 1. The function should: * Convert all words to lowercase to ensure the count is case-insensitive. * Ignore punctuation marks attached to the words. 2. The function signature should be: ```python def count_unique_words(sentence: str) -> int: ``` Parameters * `sentence` (str): A sentence containing words separated by spaces. Constraints * The sentence will only contain alphabetic characters and common punctuation marks (e.g., ., !, ?, \'). Example Usage ```python # Sample input sentence = \\"Hello, world! Hello everyone.\\" # Compute unique words result = count_unique_words(sentence) print(result) # Output: 3 (unique words are \'hello\', \'world\', \'everyone\') # Another sample input sentence = \\"This is a test. A test this is.\\" # Compute unique words result = count_unique_words(sentence) print(result) # Output: 4 (unique words are \'this\', \'is\', \'a\', \'test\') ```","solution":"import re def count_unique_words(sentence: str) -> int: Returns the number of unique words in a sentence. Words are considered case-insensitive and without punctuation. # Normalize the sentence to lower case and remove punctuation cleaned_sentence = re.sub(r\'[^ws]\', \'\', sentence.lower()) words = cleaned_sentence.split() # Use a set to get unique words unique_words = set(words) return len(unique_words)"},{"question":"# Merge K-Sorted Arrays You are part of a team developing an algorithm for efficiently merging multiple sorted arrays into a single sorted array. Your task is to implement a function to accomplish this. Task Implement the following function: - `merge_k_sorted_arrays(arrays: List[List[int]]) -> List[int]`: This function takes a list of `k` sorted integer arrays and merges them into one single sorted array. Input and Output Formats: **Input**: * A list of lists `arrays` where each sublist represents a sorted integer array. The total number of arrays `k` is given such that (1 leq k leq 10^3). * Each array in the list has a length (1 leq text{len(array)} leq 10^4). * All integers are within the range (-10^9 leq text{element} leq 10^9). **Output**: * A single sorted list containing all elements from the input arrays in non-decreasing order. Example: ```python merge_k_sorted_arrays([[1, 3, 5], [2, 4, 6], [0, 9, 10]]) # Output: [0, 1, 2, 3, 4, 5, 6, 9, 10] ``` ```python merge_k_sorted_arrays([[1], [0, 2, 3], [5, 6]]) # Output: [0, 1, 2, 3, 5, 6] ``` Constraints: - The input arrays are already sorted. - The total number of elements across all input arrays combined will not exceed (10^6). Write your implementation for the function considering edge cases and optimize for performance. --- Take time to ensure the function efficiently handles large inputs and includes proper error handling and edge cases.","solution":"import heapq from typing import List def merge_k_sorted_arrays(arrays: List[List[int]]) -> List[int]: Merge k sorted arrays into a single sorted array. :param arrays: List of k sorted arrays. :return: A single sorted array containing all elements from the input arrays. min_heap = [] for i, array in enumerate(arrays): if array: heapq.heappush(min_heap, (array[0], i, 0)) result = [] while min_heap: val, list_idx, element_idx = heapq.heappop(min_heap) result.append(val) if element_idx + 1 < len(arrays[list_idx]): next_tuple = (arrays[list_idx][element_idx + 1], list_idx, element_idx + 1) heapq.heappush(min_heap, next_tuple) return result"},{"question":"# Coding Question **Context:** String manipulation and pattern matching are essential skills in programming, often used in text processing, data validation, and implementing algorithms involving sequences of characters. **Task:** You are required to implement a function `collapse_whitespace(s: str) -> str` that takes a string input, collapses consecutive whitespace characters into a single space, and returns the cleaned up string. **Function Signature:** ```python def collapse_whitespace(s: str) -> str: ``` **Input:** * `s` (str): A string containing alphanumeric characters and possibly whitespace. **Output:** * A string where all consecutive whitespace characters are replaced by a single space, and leading/trailing whitespace is removed. **Constraints:** * `s` will have a maximum length of 1000 characters. * Whitespace includes spaces, tabs (`t`), newlines (`n`), and carriage returns (`r`). **Examples:** ```python >>> collapse_whitespace(\\"Hello, World!\\") \'Hello, World!\' >>> collapse_whitespace(\\" This is a test. \\") \'This is a test.\' >>> collapse_whitespace(\\"Line1nLine2tLine3\\") \'Line1 Line2 Line3\' >>> collapse_whitespace(\\" No leading or trailing \\") \'No leading or trailing\' >>> collapse_whitespace(\\"ttMultiple t spacesnnand linesrnherer\\") \'Multiple spaces and lines here\' ``` **Edge Cases:** * Inputs such as `collapse_whitespace(\\" ntvfr \\")` should return an empty string `\'\'`. * Inputs with no whitespace changes should return the original string, such as `collapse_whitespace(\\"Already clean\\")`. **Testing:** Use the following template to test your function: ```python if __name__ == \\"__main__\\": import doctest doctest.testmod() ``` By structuring your answer in this way, you ensure consistency with the given coding question, including a clear format, constraints, and testing examples.","solution":"import re def collapse_whitespace(s: str) -> str: This function takes a string input, collapses consecutive whitespace characters into a single space, and returns the cleaned-up string. # Use regular expression to replace one or more whitespace characters with a single space cleaned = re.sub(r\'s+\', \' \', s).strip() return cleaned"},{"question":"# Coding Assessment Question Scenario As a software developer, you are required to work on a data processing pipeline that manipulates sequences of numbers. One of the tasks in this pipeline is to evaluate and transform a sequence to eliminate specific patterns for downstream compatibility. Task Write a function `remove_consecutive_duplicates(nums)` that removes consecutive duplicate elements from a list of integers. If two or more consecutive elements are the same, only one of them should be kept in the output list. Function Signature ```python def remove_consecutive_duplicates(nums: list[int]) -> list[int]: ``` Input - `nums` (list of int): A list of integers. Output - (list of int): A list where consecutive duplicate elements have been removed. Constraints - The function should raise a `ValueError` if `nums` is not a list of integers. - The function should work for lists of any length, including the empty list. Example ```python >>> remove_consecutive_duplicates([1, 2, 2, 3, 3, 3, 4, 4, 5]) [1, 2, 3, 4, 5] >>> remove_consecutive_duplicates([1, 1, 1, 1]) [1] >>> remove_consecutive_duplicates([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> remove_consecutive_duplicates([]) [] >>> remove_consecutive_duplicates([1, \'a\']) Traceback (most recent call last): ... ValueError: nums must be a list of integers >>> remove_consecutive_duplicates([1.1, 2, 2, 3]) Traceback (most recent call last): ... ValueError: nums must be a list of integers ``` Note that your implementation should correctly handle invalid inputs and edge cases as demonstrated in the example.","solution":"def remove_consecutive_duplicates(nums: list[int]) -> list[int]: Removes consecutive duplicate elements from a list of integers. Parameters: nums (list of int): A list of integers. Returns: list of int: A list with consecutive duplicates removed. Raises: ValueError: If nums is not a list of integers. if not isinstance(nums, list): raise ValueError(\\"nums must be a list of integers\\") for num in nums: if not isinstance(num, int): raise ValueError(\\"nums must be a list of integers\\") if len(nums) == 0: return [] result = [] prev_val = nums[0] result.append(prev_val) for num in nums[1:]: if num != prev_val: result.append(num) prev_val = num return result"},{"question":"# Minimum Moves to Equal Array Elements **Context**: You are given an array of integers, where you can perform a specific operation: increment every element of the array except one by 1. Your task is to find the minimum number of such operations required to make all the elements of the array equal. This problem requires an understanding of basic mathematical and algorithmic manipulation. **Function to Implement**: ```python def min_moves_to_equal_elements(arr: list[int]) -> int: pass ``` **Input**: - `arr` (list of ints): A list of integers representing the array. **Output**: - Returns an integer representing the minimum number of moves needed to make all array elements equal. **Constraints**: - Input array length: 1 <= len(arr) <= 10^5 - Elements value range: -10^9 <= arr[i] <= 10^9 **Performance Requirements**: - Aim for a solution with O(n) time complexity. **Examples**: ```python assert min_moves_to_equal_elements([1, 2, 3]) == 3 assert min_moves_to_equal_elements([5, 6, 8, 8]) == 7 assert min_moves_to_equal_elements([1, 1, 1]) == 0 assert min_moves_to_equal_elements([10]) == 0 assert min_moves_to_equal_elements([3, 3, 3, 3]) == 0 ``` **Hint**: - Think about transforming the problem into finding the total number of increments needed to align all elements with the smallest element in the array. - This problem can be approached by calculating the difference between every element and the smallest element in the array.","solution":"def min_moves_to_equal_elements(arr: list[int]) -> int: Returns the minimum number of moves required to make all elements equal by incrementing all the elements except one in each move. # The minimum element in the array min_element = min(arr) # Total moves needed to equalize elements by incrementing all except one moves = sum(el - min_element for el in arr) return moves"},{"question":"# Coding Assessment Question: Rotate and Mirror a 2D Array Context You are a software engineer tasked with applying geometric transformations to images represented as 2D matrices. In particular, you need to rotate these matrices and then mirror them along a specified axis. Task Write two functions: 1. A function `rotate_2d_array(matrix: list[list[int]]) -> list[list[int]]` that takes a 2D array (a list of lists) and returns the array rotated 90 degrees clockwise. 2. A function `mirror_2d_array(matrix: list[list[int]], axis: str) -> list[list[int]]` that takes a 2D array and an axis (`\\"vertical\\"` or `\\"horizontal\\"`) and returns the mirrored 2D array along the specified axis. Specifications * `rotate_2d_array(matrix: list[list[int]]) -> list[list[int]]` * **Input**: * `matrix`: A 2D array represented as a list of lists of integers. * **Output**: * A 2D array with all elements rotated 90 degrees clockwise. * `mirror_2d_array(matrix: list[list[int]], axis: str) -> list[list[int]]` * **Input**: * `matrix`: A 2D array represented as a list of lists of integers. * `axis`: A string indicating the axis of reflection. It is either `\\"vertical\\"` or `\\"horizontal\\"`. * **Output**: * A 2D array mirrored along the specified axis. Constraints * All rows in the input 2D array have the same number of columns. * The input 2D matrix is non-empty. * The `axis` parameter will always be either `\\"vertical\\"` or `\\"horizontal\\"`. Examples * Example 1: ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] result = rotate_2d_array(matrix) assert result == [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] result = mirror_2d_array(matrix, \\"horizontal\\") assert result == [ [7, 8, 9], [4, 5, 6], [1, 2, 3] ] result = mirror_2d_array(matrix, \\"vertical\\") assert result == [ [3, 2, 1], [6, 5, 4], [9, 8, 7] ] ``` * Example 2: ```python matrix = [ [10, 20], [30, 40] ] result = rotate_2d_array(matrix) assert result == [ [30, 10], [40, 20] ] result = mirror_2d_array(matrix, \\"horizontal\\") assert result == [ [30, 40], [10, 20] ] result = mirror_2d_array(matrix, \\"vertical\\") assert result == [ [20, 10], [40, 30] ] ``` Notes * Ensure robustness by handling all edge cases such as empty arrays appropriately. * Test thoroughly to handle different matrix dimensions and configurations.","solution":"def rotate_2d_array(matrix): Rotates a 2D array (matrix) 90 degrees clockwise. :param matrix: List of lists representing the 2D array. :return: Rotated 2D array. return [list(reversed(col)) for col in zip(*matrix)] def mirror_2d_array(matrix, axis): Mirrors a 2D array (matrix) along the specified axis. :param matrix: List of lists representing the 2D array. :param axis: String indicating the axis of reflection. (\\"vertical\\" or \\"horizontal\\") :return: Mirrored 2D array. if axis == \'vertical\': return [row[::-1] for row in matrix] elif axis == \'horizontal\': return matrix[::-1] else: raise ValueError(\\"The axis must be either \'vertical\' or \'horizontal\'\\")"},{"question":"# Validate and Calculate Factorial Sum Context Understanding factorials and their applications is fundamental in fields like combinatorics and analysis. This exercise will test your ability to calculate factorials and perform basic summation operations programmatically. Task Write a function `factorial_sum` that takes a list of positive integers and returns the sum of their factorials. The function should first validate the input list to ensure all elements are positive integers, then compute the factorial of each element in the list and return the total sum. Function Signature ```python def factorial_sum(numbers: List[int]) -> int: pass ``` Input * `numbers` (List of int): A list of positive integers. Output * (int): The sum of the factorials of the input numbers. Constraints 1. The input list can be empty. 2. Elements of the list are positive integers. 3. If any element is not a positive integer, the function should raise a `ValueError`. Example ```python assert factorial_sum([1, 2, 3]) == 9 # 1! + 2! + 3! = 1 + 2 + 6 = 9 assert factorial_sum([4, 5]) == 144 # 4! + 5! = 24 + 120 = 144 assert factorial_sum([]) == 0 ``` Edge Cases to Consider: - Input list contains a single element. - Very large inputs within the range of typical integer limits in Python. - A malformed input list containing non-positive integers (should raise an error). Note: - Do not use libraries like `math.factorial` directly; implement the factorial calculation manually within the function.","solution":"from typing import List def factorial(n: int) -> int: Helper function to compute the factorial of a positive integer n. if n == 0 or n == 1: return 1 result = 1 for i in range(2, n+1): result *= i return result def factorial_sum(numbers: List[int]) -> int: Computes the sum of factorials of the input positive integers. if not all(isinstance(x, int) and x > 0 for x in numbers): raise ValueError(\\"All elements in the list must be positive integers\\") return sum(factorial(num) for num in numbers)"},{"question":"# Question: Matrix Diagonal Sum Given a 2D list (matrix) of integers, your task is to calculate the sum of both the primary and secondary diagonals and return an object (dictionary) that contains both sums. The primary diagonal is from the top-left to bottom-right, and the secondary diagonal is from the top-right to bottom-left. Requirements: 1. Write a function `diagonal_sums` that accepts one parameter: `matrix`, which is a square (NxN) 2D list of integers. 2. The function should return a dictionary with two keys: `primary_diagonal` and `secondary_diagonal`, corresponding to the sums of the primary and secondary diagonals respectively. 3. Handle edge cases such as a matrix with a single element. Function Signature: ```python def diagonal_sums(matrix: list[list[int]]) -> dict: pass ``` Input: * `matrix` – A square 2D list of integers. Output: * A dictionary containing the sums of the primary and secondary diagonals. Constraints: * `1 <= len(matrix) <= 100` * `-10^5 <= matrix[i][j] <= 10^5` Example Usage: ```python >>> diagonal_sums([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) {\'primary_diagonal\': 15, \'secondary_diagonal\': 15} >>> diagonal_sums([[2]]) {\'primary_diagonal\': 2, \'secondary_diagonal\': 2} >>> diagonal_sums([[7, 8, 9], [6, 5, 4], [3, 2, 1]]) {\'primary_diagonal\': 13, \'secondary_diagonal\': 15} ``` # Explanation * In the first example, the primary diagonal elements are `1, 5, 9` which sum up to `15`. The secondary diagonal elements are `3, 5, 7` which also sum up to `15`. * In the second example, the matrix has a single element `2` so both the primary and secondary diagonal sums are `2`. * In the third example, the primary diagonal elements are `7, 5, 1` which sum up to `13`. The secondary diagonal elements are `9, 5, 3` which sum up to `17`. Ensure your solution is efficient and handles all edge cases described.","solution":"def diagonal_sums(matrix: list[list[int]]) -> dict: primary_sum = 0 secondary_sum = 0 n = len(matrix) for i in range(n): primary_sum += matrix[i][i] secondary_sum += matrix[i][n - 1 - i] return { \'primary_diagonal\': primary_sum, \'secondary_diagonal\': secondary_sum }"},{"question":"# Rot13 Encoder/Decoder With Error Handling In this task, you need to implement a Rot13 encoder and decoder that can handle various input scenarios, including edge cases. Rot13 is a simple letter substitution cipher that replaces a letter with the 13th letter after it in the alphabet. Note that only letters should be encoded/decoded, and other characters should remain unchanged. **Function Signatures**: - Implement the function `def rot13_encode(data: str) -> str:` - Implement the function `def rot13_decode(data: str) -> str:` # Requirements: 1. **rot13_encode(data: str) -> str**: - Accepts a `str` object and returns a Rot13 encoded string. - Only alphabet characters (`a-z`, `A-Z`) should be transformed. - Characters outside the alphabet (e.g., digits, punctuation) should remain unchanged. 2. **rot13_decode(data: str) -> str**: - Accepts a Rot13 encoded `str` object and returns the decoded string. - Only alphabet characters (`a-z`, `A-Z`) should be transformed back. - Characters outside the alphabet should remain unchanged. # Constraints: - The input string for encoding and decoding will be valid UTF-8. - The output of the `rot13_decode` function should return the original text if it was encoded using `rot13_encode`. - The input string length can be up to 10^6 characters. # Example: ```python # Example rot13_encode usage data = \\"Hello, World!\\" encoded_data = rot13_encode(data) assert encoded_data == \\"Uryyb, Jbeyq!\\" # Example rot13_decode usage decoded_data = rot13_decode(\\"Uryyb, Jbeyq!\\") assert decoded_data == \\"Hello, World!\\" ``` # Tests: Your implementation will be tested on various cases, including but not limited to: - Typical inputs with a mix of alphabet characters, digits, and punctuation. - Edge cases such as empty strings and strings with no alphabet characters. - Strings with uppercase and lowercase letters. Make sure to cover these tests comprehensively to validate the robustness of your functions.","solution":"def rot13_encode(data: str) -> str: Encode the given string using ROT13. Only alphabet characters are transformed. Other characters remain unchanged. def encode_char(c): if \'a\' <= c <= \'z\': return chr((ord(c) - ord(\'a\') + 13) % 26 + ord(\'a\')) elif \'A\' <= c <= \'Z\': return chr((ord(c) - ord(\'A\') + 13) % 26 + ord(\'A\')) else: return c return \'\'.join(encode_char(c) for c in data) def rot13_decode(data: str) -> str: Decode the given string using ROT13. Only alphabet characters are transformed. Other characters remain unchanged. return rot13_encode(data) # Since ROT13 is symmetrical"},{"question":"# Binary Search Tree (BST) - Find Kth Largest Element Given a class to represent a Binary Search Tree (BST), implement the missing method `find_kth_largest` that finds the kth largest element in the BST. # Explanation: The `find_kth_largest` method should traverse the BST in such a manner that it efficiently locates the kth largest element. The kth largest element in a BST is the node that would appear at the kth position if the BST were sorted in descending order. # Function Signature: ```python class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right class BST: def __init__(self): self.root = None def insert(self, value): # Implementation for inserting a value in the BST pass def find_kth_largest(self, k): ... ``` # Expected Inputs and Outputs: * **Input**: * `k`: an integer representing the position (1-based) of the largest element to find. * **Output**: * The value of the kth largest element in the BST. # Example: ```python # Initial BST # 5 # / # 3 8 # / # 2 4 10 # # 12 bst = BST() bst.insert(5) bst.insert(3) bst.insert(8) bst.insert(2) bst.insert(4) bst.insert(10) bst.insert(12) # Find 3rd largest element assert bst.find_kth_largest(3) == 8 # Find 1st largest element assert bst.find_kth_largest(1) == 12 ``` # Constraints: 1. The number of nodes in the BST will be between 0 and 10000. 2. The value of k will always be valid such that 1 ≤ k ≤ number of nodes. # Testing: Your solution will be tested with the following scenario: 1. Finding kth largest in an empty BST (should handle gracefully). 2. Finding kth largest in a BST with only one node. 3. Finding kth largest in a BST with multiple nodes. # Notes: Ensure that your solution is efficient and handles edge cases appropriately. Consider in-order or reverse in-order traversal methods to achieve the desired result efficiently.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right class BST: def __init__(self): self.root = None def insert(self, value): if self.root is None: self.root = TreeNode(value) else: self._insert(self.root, value) def _insert(self, node, value): if value < node.value: if node.left is None: node.left = TreeNode(value) else: self._insert(node.left, value) else: if node.right is None: node.right = TreeNode(value) else: self._insert(node.right, value) def find_kth_largest(self, k): self.current_k = 0 self.kth_value = None self._find_kth_largest(self.root, k) return self.kth_value def _find_kth_largest(self, node, k): if node is None or self.current_k >= k: return # Start by traversing the right subtree self._find_kth_largest(node.right, k) if self.current_k < k: self.current_k += 1 if self.current_k == k: self.kth_value = node.value return # Then traverse the left subtree self._find_kth_largest(node.left, k)"},{"question":"# Coding Assessment Question You are given a list of transactions within a banking system, each containing the transaction ID, the account balance before the transaction, and the transaction amount. Your task is to simulate the execution of these transactions and determine the final balance for each transaction. # Input: - A list of integers `transaction_ids` representing the transaction IDs. - A list of floats `initial_balances` where `initial_balances[i]` is the account balance before the transaction with ID `transaction_ids[i]`. - A list of floats `transaction_amounts` where `transaction_amounts[i]` is the amount for the transaction with ID `transaction_ids[i]`. # Output: - A list of tuples representing `(transaction_id, initial_balance, transaction_amount, final_balance)` for each transaction, sorted by the order of `transaction_ids`. # Constraints: - The length of `transaction_ids`, `initial_balances`, and `transaction_amounts` will be the same. - All transaction IDs are unique integers. - Initial balances and transaction amounts can be positive or negative floats. # Performance Requirements: - The implemented algorithm should have a time complexity of O(N), where N is the number of transactions. # Example: Input: ```python transaction_ids = [101, 102, 103] initial_balances = [1500.0, 2500.5, 500.75] transaction_amounts = [-300.0, 200.0, -50.75] ``` Output: ```python [ (101, 1500.0, -300.0, 1200.0), (102, 2500.5, 200.0, 2700.5), (103, 500.75, -50.75, 450.0) ] ``` # Requirements Implement the following function: ```python def calculate_final_balances( transaction_ids: list[int], initial_balances: list[float], transaction_amounts: list[float] ) -> list[tuple[int, float, float, float]]: This function processes a list of transactions and computes the final balance for each transaction. Parameters: transaction_ids (list[int]): The list of transaction IDs. initial_balances (list[float]): The initial account balances before the transactions. transaction_amounts (list[float]): The transaction amounts. Returns: list[tuple[int, float, float, float]]: A list containing: - Transaction ID (int) - Initial Balance (float) - Transaction Amount (float) - Final Balance (float) # Your implementation here ``` Make sure to handle all edge cases related to input validity and ensure your implementation adheres to the expected complexity.","solution":"def calculate_final_balances(transaction_ids, initial_balances, transaction_amounts): This function processes a list of transactions and computes the final balance for each transaction. Parameters: transaction_ids (list[int]): The list of transaction IDs. initial_balances (list[float]): The initial account balances before the transactions. transaction_amounts (list[float]): The transaction amounts. Returns: list[tuple[int, float, float, float]]: A list containing: - Transaction ID (int) - Initial Balance (float) - Transaction Amount (float) - Final Balance (float) result = [] transactions = zip(transaction_ids, initial_balances, transaction_amounts) for tid, initial_balance, transaction_amount in transactions: final_balance = initial_balance + transaction_amount result.append((tid, initial_balance, transaction_amount, final_balance)) return result"},{"question":"# Problem Statement You are given a string containing alphanumeric characters and special characters (`!`, `@`, `#`, ``, `%`, `^`, `&`, `*`). Your task is to rearrange the string so that all letters appear in alphabetical order, followed by all digits in numerical order, and finally all special characters in the order they appeared in the original string. Capital letters should come before lowercase letters when sorted. # Function Signature ```python def rearrange_string(s: str) -> str: pass ``` # Input * `s` (str): The string to be rearranged. The string may contain: - Alphabetic characters (A-Z, a-z) - Numeric characters (0-9) - Special characters (`!`, `@`, `#`, ``, `%`, `^`, `&`, `*`). # Output * (str): The rearranged string such that letters are ordered alphabetically, digits are ordered numerically, and special characters retain their original order. # Constraints * The input string length will be between 1 and 1000 characters. # Example ```python # Example 1 assert rearrange_string(\\"a1B2cD#3\\") == \\"BDac123#\\" # Example 2 assert rearrange_string(\\"mN6&7l*Jk@%9L\\") == \\"JLNklm679&*@%\\" # Example 3 assert rearrange_string(\\"3aA#2bB!\\") == \\"ABab23#!\\" ``` # Hints * Separate the string into three lists: one for letters, one for digits, and one for special characters. * Sort the letter list lexicographically with capital letters first. * Sort the digit list numerically. * Concatenate the three lists to form the resulting string.","solution":"def rearrange_string(s: str) -> str: letters = [] digits = [] special_chars = [] for char in s: if char.isalpha(): letters.append(char) elif char.isdigit(): digits.append(char) else: special_chars.append(char) letters.sort(key=lambda x: (x.islower(), x)) digits.sort() return \'\'.join(letters) + \'\'.join(digits) + \'\'.join(special_chars)"},{"question":"# Context As part of an engineering team, you are working on a software tool that assists with matrix operations. One critical feature to implement is matrix multiplication, which is fundamental for various numerical and engineering computations. # Task Write a function that performs matrix multiplication on two given matrices. # Function Specification **Function Name**: `matrix_multiplication` Input * `matrix_a`: list of lists of floats - The first matrix, where each sublist is a row of the matrix. * `matrix_b`: list of lists of floats - The second matrix, where each sublist is a row of the matrix. Output * `list of lists of floats` - The resulting matrix after multiplying `matrix_a` by `matrix_b`. **Constraints** * The number of columns in `matrix_a` must be equal to the number of rows in `matrix_b`. * Elements of both matrices are float numbers. * Both input matrices will contain at least one element. # Example Example 1 ```python matrix_a = [ [1, 2], [3, 4] ] matrix_b = [ [5, 6], [7, 8] ] result = matrix_multiplication(matrix_a, matrix_b) print(result) # Output: [[19.0, 22.0], [43.0, 50.0]] ``` Example 2 ```python matrix_a = [ [2.5, 0.5], [1.0, 1.5] ] matrix_b = [ [3.0, 1.0], [4.0, 2.0] ] result = matrix_multiplication(matrix_a, matrix_b) print(result) # Output: [[9.5, 3.5], [9.0, 4.0]] ``` Assuming the function handles all edge cases and adheres to the constraints, it should correctly multiply two matrices of appropriate dimensions, analyzing different scenarios and validating matrix multiplication properties.","solution":"def matrix_multiplication(matrix_a, matrix_b): Returns the result of matrix multiplication of matrix_a and matrix_b. Args: matrix_a: list of lists of floats - The first matrix, where each sublist is a row of the matrix. matrix_b: list of lists of floats - The second matrix, where each sublist is a row of the matrix. Returns: A list of lists of floats representing the resulting matrix after multiplying matrix_a by matrix_b. # Number of rows of matrix_a rows_a = len(matrix_a) # Number of columns of matrix_a cols_a = len(matrix_a[0]) # Number of rows of matrix_b rows_b = len(matrix_b) # Number of columns of matrix_b cols_b = len(matrix_b[0]) # Initialize the result matrix with zeros result = [[0.0 for _ in range(cols_b)] for _ in range(rows_a)] for i in range(rows_a): for j in range(cols_b): sum_product = 0.0 for k in range(cols_a): sum_product += matrix_a[i][k] * matrix_b[k][j] result[i][j] = sum_product return result"},{"question":"# Scenario You are developing a custom log parsing system for a cloud-based application that generates a significant volume of log messages. These log messages contain various types of data, such as timestamps, log levels, messages, and possibly JSON payloads. The logs are semi-structured, meaning there is a general pattern but also some variability between log entries. # Task Your task is to implement a `LogParser` class that can efficiently parse, filter, and extract information from a collection of log messages. The parser needs to support basic functionalities such as searching for logs within a specific time range, filtering logs by log level, and extracting key-value pairs from JSON payloads when present. **Classes to Implement**: 1. `LogParser`: The main class responsible for managing and querying logs. **Function to Implement**: - `load(logs: List[str]) -> None`: Load a list of log messages into the parser. - `filter_by_level(level: str) -> List[str]`: Filter and return logs of a specified log level. - `within_time_range(start: datetime, end: datetime) -> List[str]`: Return logs within a specific time range. - `extract_json_data(log: str) -> Dict[str, Any]`: Extract and return key-value pairs from the JSON payload in a log message. If no JSON payload is present, return an empty dictionary. **Input and Output Formats**: - The `load` method takes a list of log messages, where each log is a string. - The `filter_by_level` method returns a list of log messages matching the specified level. - The `within_time_range` method returns a list of log messages within the given time range. - The `extract_json_data` method extracts and returns a dictionary of key-value pairs from a JSON payload found in the log message. **Constraints**: - Use the `datetime` module to handle timestamp parsing and comparison. - Assume log levels are one of `DEBUG`, `INFO`, `WARNING`, `ERROR`, or `CRITICAL`. - Log messages may or may not contain a JSON payload, and parsing should handle both scenarios gracefully. - Ensure the solution handles large volumes of logs efficiently. # Example Usage: ```python from datetime import datetime logs = [ \\"2023-09-10 10:00:00 INFO User login successful\\", \\"2023-09-10 10:01:00 ERROR User login failed: {\\"user_id\\": 123, \\"error\\": \\"Invalid credentials\\"}\\", \\"2023-09-10 10:02:00 DEBUG Initiating background job\\", \\"2023-09-10 10:03:00 INFO Background job completed successfully\\", ] parser = LogParser() parser.load(logs) # Filter logs by level error_logs = parser.filter_by_level(\\"ERROR\\") # Filter logs within a specific time range start_time = datetime.strptime(\'2023-09-10 10:00:00\', \'%Y-%m-%d %H:%M:%S\') end_time = datetime.strptime(\'2023-09-10 10:02:00\', \'%Y-%m-%d %H:%M:%S\') time_filtered_logs = parser.within_time_range(start_time, end_time) # Extract JSON data from a log json_data = parser.extract_json_data(error_logs[0]) print(error_logs) print(time_filtered_logs) print(json_data) ``` This question requires advanced knowledge of Python\'s standard library (such as datetime and JSON parsing), as well as handling of semi-structured data and basic data manipulation techniques.","solution":"import json from datetime import datetime from typing import List, Dict, Any class LogParser: def __init__(self): self.logs = [] def load(self, logs: List[str]) -> None: self.logs = logs def filter_by_level(self, level: str) -> List[str]: return [log for log in self.logs if f\\" {level} \\" in log] def within_time_range(self, start: datetime, end: datetime) -> List[str]: result = [] for log in self.logs: timestamp_str = log.split(\' \')[0] + \' \' + log.split(\' \')[1] log_time = datetime.strptime(timestamp_str, \'%Y-%m-%d %H:%M:%S\') if start <= log_time <= end: result.append(log) return result def extract_json_data(self, log: str) -> Dict[str, Any]: try: json_str = log[log.index(\'{\'):log.rindex(\'}\')+1] return json.loads(json_str) except (ValueError, json.JSONDecodeError): return {}"},{"question":"# Problem Statement You are given a string containing a mixture of upper and lower case letters. Your task is to implement a function that capitalizes the first letter of each word and turns all other letters into lowercase. Function Signature ```python def capitalize_words(s: str) -> str: ``` Input - A string `s` (0 ≤ len(s) ≤ 1000) Output - A string with the first letter of each word capitalized and all other letters in lowercase. # Performance Requirements - Your solution should handle edge cases efficiently within the given constraints. # Example **Input**: `\\"hello world! this is a Test.\\"` **Output**: `\\"Hello World! This Is A Test.\\"` **Input**: `\\"CAPITALIZE Every WORD\\"` **Output**: `\\"Capitalize Every Word\\"` # Constraints 1. The length of the string will be between 0 and 1000 (both inclusive). 2. The string will only contain alphabetic characters and standard punctuation marks. # Implementation Notes - Ensure to handle the edge cases such as an empty string or a string with single character words. - The function should be case-insensitive with respect to the input string but should return a case-transformed string as specified.","solution":"def capitalize_words(s: str) -> str: Capitalizes the first letter of each word in the given string and turns all other letters to lowercase. return \' \'.join([word.capitalize() for word in s.split()])"},{"question":"Optimal Route Finding in a Weighted Graph **Objective**: Implement a function to find the shortest path between two nodes in a weighted graph using Dijkstra\'s algorithm. **Scenario**: Given a directed weighted graph and two nodes, implement an algorithm to compute the shortest path from the start node to the end node. If no path exists, return `None`. Function Signature ```python def shortest_path(graph: List[Tuple[str, str, int]], start: str, end: str) -> Optional[List[str]]: pass ``` Input * `graph`: A list of tuples where each tuple represents an edge in the format `(node1, node2, weight)` indicating a directed edge from `node1` to `node2` with the specified weight. * `start`: A string representing the starting node. * `end`: A string representing the target node. Output * A list of strings representing the node sequence in the shortest path from the start node to the end node. * If no path exists, return `None`. Constraints 1. The graph can contain up to 1000 nodes and 10000 edges. 2. All weights are non-negative integers. 3. The start and end nodes are guaranteed to be valid nodes in the graph. Performance Requirements * Aim to minimize the time complexity using an efficient priority queue or heap. * Handle large graphs efficiently within reasonable time and memory limits. **Example** ```python graph = [ (\'A\', \'B\', 1), (\'B\', \'C\', 2), (\'A\', \'C\', 4), (\'C\', \'D\', 1), (\'B\', \'D\', 5) ] start = \'A\' end = \'D\' # Sample output representation # [\'A\', \'B\', \'C\', \'D\'] # Another example with no path graph = [ (\'A\', \'B\', 1), (\'B\', \'C\', 2), ] start = \'A\' end = \'D\' # Sample output representation # None ``` Write the function `shortest_path` implementing the above logic. Ensure thorough testing with various graph structures to verify correct shortest path detection and proper handling of disjoint subgraphs.","solution":"import heapq from typing import List, Tuple, Optional def shortest_path(graph: List[Tuple[str, str, int]], start: str, end: str) -> Optional[List[str]]: Finds the shortest path in a weighted directed graph using Dijkstra\'s algorithm. Parameters: - graph: List of edges in the graph. Each edge is represented as a tuple (node1, node2, weight). - start: The starting node. - end: The target node. Returns: - A list of strings representing the sequence of nodes in the shortest path from start to end. If no path exists, returns None. # Build the adjacency list adj_list = {} for node1, node2, weight in graph: if node1 not in adj_list: adj_list[node1] = [] adj_list[node1].append((node2, weight)) # Priority queue for Dijkstra\'s algorithm pq = [(0, start, [])] # (cost, current_node, path_taken) visited = set() while pq: cost, current, path = heapq.heappop(pq) if current in visited: continue visited.add(current) path = path + [current] if current == end: return path for neighbor, weight in adj_list.get(current, []): if neighbor not in visited: heapq.heappush(pq, (cost + weight, neighbor, path)) return None"},{"question":"# Coding Assessment Problem # Problem Statement You are required to implement a function that simulates a basic pagination system for a list of items. The system should be able to take in a list of items and return a specified \\"page\\" of items according to the given page number and page size. # Input and Output Specifications - **Input**: - A list of items (strings). - An integer `page_number` representing the current page (1-based). - An integer `page_size` representing the number of items to display per page. - **Output**: - A list of strings representing the items on the specified page. The function should handle cases where the `page_number` or `page_size` is invalid (e.g., zero or negative). In such cases, or if the page number exceeds the number of available pages, the function should return an empty list. # Example ```python items = [\\"item1\\", \\"item2\\", \\"item3\\", \\"item4\\", \\"item5\\", \\"item6\\", \\"item7\\"] page_number = 2 page_size = 3 ``` * Page 1 would contain `[\\"item1\\", \\"item2\\", \\"item3\\"]` * Page 2 would contain `[\\"item4\\", \\"item5\\", \\"item6\\"]` * Page 3 would contain `[\\"item7\\"]` So, the function call `paginate(items, 2, 3)` should return `[\\"item4\\", \\"item5\\", \\"item6\\"]`. # Constraints 1. The list of items will not exceed 100,000 items. 2. The page size will be a positive integer no greater than 1,000. 3. The page number will be a positive integer. # Function Signature ```python def paginate(items: list, page_number: int, page_size: int) -> list: # Implementation here ``` # Example ```python items = [\\"item1\\", \\"item2\\", \\"item3\\", \\"item4\\", \\"item5\\"] page_number = 1 page_size = 2 print(paginate(items, page_number, page_size)) # Output: [\\"item1\\", \\"item2\\"] items = [\\"item1\\", \\"item2\\", \\"item3\\", \\"item4\\", \\"item5\\"] page_number = 3 page_size = 2 print(paginate(items, page_number, page_size)) # Output: [\\"item5\\"] ``` # Context You are working on a system where proper display and management of large datasets are necessary. Implementing a pagination system will allow for easier viewing and navigation through items, improving user experience and system performance. Your job is to correctly implement this functionality by ensuring the appropriate items are displayed based on the given page number and page size.","solution":"def paginate(items: list, page_number: int, page_size: int) -> list: if page_number <= 0 or page_size <= 0: return [] start_index = (page_number - 1) * page_size end_index = start_index + page_size return items[start_index:end_index]"},{"question":"# Question: Array Product Exclusion Scenario: Handling arrays and performing operations on their elements is a common task in software development. One interesting operation is to construct a new array where each element at index `i` of the new array is the product of all the elements in the original array except the one at index `i`. This problem often appears in coding interviews and tests your understanding of array manipulation and efficiency. Task: Write a function `product_except_self(nums: list) -> list` that takes in a list of integers and returns a list such that, for every index `i`, the value at the new list\'s index `i` is the product of all the values in the original list except `nums[i]`. Implement it without using division. Function Specifications: 1. `product_except_self(nums: list) -> list` - **Input**: A list of integers `nums` where `2 <= len(nums) <= 10^5` and `-30 <= nums[i] <= 30`. - **Output**: A list of integers representing the product of all elements except the one at the current index. Examples: ```python >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([2, 3, 4, 5]) [60, 40, 30, 24] >>> product_except_self([1, 2, 3]) [6, 3, 2] >>> product_except_self([10, 0, 5]) [0, 50, 0] >>> product_except_self([-1, 2, -3, 4]) [-24, 12, -8, 6] ``` Constraints: - The solution should run in linear time O(n) and use linear space O(n). - You may not use the division operation. - Ensure your function handles both positive and negative integers and zeros appropriately. Performance Requirements: - The solution should efficiently handle the upper limit of constraints within acceptable time and space complexity.","solution":"def product_except_self(nums): Returns a list such that the value at index i is the product of all values in the original list except nums[i]. length = len(nums) # Result array to hold our products result = [1] * length left_product = 1 for i in range(length): result[i] = left_product left_product *= nums[i] right_product = 1 for i in range(length - 1, -1, -1): result[i] *= right_product right_product *= nums[i] return result"},{"question":"# Coding Assessment Question Scenario You are given an array of integers where every element appears three times except for one, which appears exactly once. Your task is to find the element that appears only once. The standard approach to solving this problem involves using a hashing technique which uses extra space. Your task is to solve this problem using an optimal solution with a constant space complexity. Problem Statement Write a function `single_number` that takes a list of integers `nums` and returns an integer representing the number that appears only once. Function Signature ```python def single_number(nums: list[int]) -> int: pass ``` Input * `nums` (1 <= len(nums) <= 3 * 10^4): A list of integers where every integer appears three times except for one integer which appears exactly once. Output * An integer representing the unique number that appears only once. Constraints * `nums` will always contain one number that appears only once. * All other numbers in the list appear exactly three times. * Optimize for both time and space complexity. Example ```python >>> single_number([2, 2, 3, 2]) 3 >>> single_number([0, 1, 0, 1, 0, 1, 99]) 99 >>> single_number([30000, 500, 100, 30000, 100, 30000, 100]) 500 >>> single_number([7, 7, 7, -1]) -1 >>> single_number([-2, -2, 1, 1, -3, 1, -3, -3, -2, -4]) -4 ``` Hint To solve this problem efficiently, consider using bitwise operations to handle the counting of bits across all numbers and determine the unique number.","solution":"def single_number(nums: list[int]) -> int: ones, twos = 0, 0 for num in nums: ones = (ones ^ num) & ~twos twos = (twos ^ num) & ~ones return ones"},{"question":"# Counting Inversions in an Array **Scenario**: You are working as a developer for a financial analytics company. One of your tasks is to analyze the volatility of stock prices. To quantify the volatility, you need to implement an algorithm that counts the number of inversions in an array of stock prices. An inversion is a condition where a higher stock price occurs before a lower stock price in the sequence. **Task**: Implement a function to count the number of inversions in an array using a modified merge sort algorithm. This approach should be efficient and able to handle large datasets. **Function Signature**: ```python def count_inversions(arr: list) -> int: ``` # Requirements: 1. **Input**: * A list, `arr`, containing integers representing stock prices. * The list can be empty or contain up to 10^5 elements. 2. **Output**: * An integer representing the number of inversions in the array. 3. **Constraints**: * The algorithm should be efficient, ideally with a time complexity of O(n log n). * The function should handle any valid list of integers adequately. # Example: ```python >>> count_inversions([1, 3, 5, 2, 4, 6]) 3 >>> count_inversions([6, 5, 4, 3, 2, 1]) 15 >>> count_inversions([1, 2, 3, 4, 5, 6]) 0 >>> count_inversions([7, 5, 3, 1]) 6 ``` # Explanation: - In the first example, the inversions are (3,2), (5,2), and (5,4), resulting in 3 inversions. - In the second example, every pair is an inversion as the array is in completely descending order, resulting in 15 inversions. - In the third example, the array is in ascending order, so there are no inversions. - In the fourth example, the inversions are (7,5), (7,3), (7,1), (5,3), (5,1), and (3,1), resulting in 6 inversions. # Implementation: Ensure your function correctly implements the inversion count using a modified merge sort algorithm. Pay particular attention to edge cases where the array has minimal elements or is already sorted. Implement your function below: ```python def count_inversions(arr: list) -> int: # Your implementation here ```","solution":"def count_inversions(arr: list) -> int: Counts the number of inversions in the array using a modified merge sort algorithm. An inversion is a condition where a higher stock price occurs before a lower stock price in the sequence. def merge_and_count(arr, temp_arr, left, mid, right): i = left # Starting index for left subarray j = mid + 1 # Starting index for right subarray k = left # Starting index to be sorted inv_count = 0 # Conditions are checked to ensure that i doesn\'t exceed mid and j doesn\'t exceed right while i <= mid and j <= right: if arr[i] <= arr[j]: temp_arr[k] = arr[i] i += 1 else: # There are mid - i inversions, because all remaining elements in the left # subarray (arr[left..mid]) are greater than arr[j] temp_arr[k] = arr[j] inv_count += (mid-i + 1) j += 1 k += 1 # Copy the remaining elements of left subarray, if any while i <= mid: temp_arr[k] = arr[i] i += 1 k += 1 # Copy the remaining elements of right subarray, if any while j <= right: temp_arr[k] = arr[j] j += 1 k += 1 # Copy the sorted subarray into Original array for i in range(left, right + 1): arr[i] = temp_arr[i] return inv_count # Helper function to implement merge sort and count inversions recursively def merge_sort_and_count(arr, temp_arr, left, right): inv_count = 0 if left < right: mid = (left + right)//2 inv_count += merge_sort_and_count(arr, temp_arr, left, mid) inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right) inv_count += merge_and_count(arr, temp_arr, left, mid, right) return inv_count n = len(arr) temp_arr = [0]*n return merge_sort_and_count(arr, temp_arr, 0, n-1)"},{"question":"# Problem Statement: You are given an array of integers `arr` of size `n` and a target integer `k`. Your task is to implement the function `find_pairs_with_sum` that returns the number of unique pairs (i, j) such that `arr[i] + arr[j]` is equal to `k` and `i < j`. # Function Signature: ```python def find_pairs_with_sum(arr: list[int], k: int) -> int: pass ``` # Input: - `arr`: a list of integers (1 <= len(arr) <= 10^5, -10^5 <= arr[i] <= 10^5) - `k`: an integer (-10^5 <= k <= 10^5) # Output: - The number of unique pairs (i, j) such that `arr[i] + arr[j]` is equal to `k`. # Example: ```python assert find_pairs_with_sum([1, 3, 2, 2, -1, 5], 4) == 3 assert find_pairs_with_sum([1, 1, 1, 1], 2) == 6 assert find_pairs_with_sum([1, 2, 3, 4, 5], 9) == 1 ``` # Constraints: - Optimize for time complexity using a suitable algorithm to handle large input sizes. - Ensure your solution can handle both positive and negative integers. - Pairs should be counted only once with `i < j`. # Considerations: - Understand and implement an efficient solution, potentially using a hash map to track the needed values for pairing. - Carefully manage your data structures to avoid unnecessary computations and to ensure uniqueness in pairs.","solution":"def find_pairs_with_sum(arr: list[int], k: int) -> int: seen = {} pairs = set() count = 0 for i, num in enumerate(arr): target = k - num if target in seen: pairs.add((min(target, num), max(target, num))) if num in seen: seen[num] += 1 else: seen[num] = 1 return len(pairs)"},{"question":"# Problem Statement **Scenario**: In a land of technology enthusiasts, a grand competition is being held where teams of programmers compete to solve a series of challenges. The competition is structured in multiple rounds, and in each round, teams earn points based on their performance. At the end of all rounds, the team with the highest total points is declared the winner. Your task is to determine the winning team\'s total score. # Task Implement function `find_winning_team_scores(scores: List[List[int]]) -> int` which takes a list of lists of integers `scores`, where each inner list represents a round, and each element in the inner list represents the points earned by a team in that round. The function returns the total score of the winning team. # Requirements * Handle invalid inputs such as non-integer types. * Ensure the solution is optimized to handle large data sets efficiently. # Function Signature ```python def find_winning_team_scores(scores: List[List[int]]) -> int: Args: scores (List[List[int]]): A list of lists of points, where each inner list represents a round. Returns: int: The total score of the winning team. Raises: ValueError: If scores contain non-integer types or if the input data is invalid. ``` # Constraints * `1 <= len(scores) <= 10^3` (number of rounds) * `1 <= len(scores[0]) <= 10^3` (number of teams in each round) * All scores are non-negative integers. # Example ```python # Example 1 assert find_winning_team_scores([[10, 20], [30, 40], [50, 60]]) == 120 # Example 2 assert find_winning_team_scores([[5, 8, 7], [6, 2, 6], [4, 5, 4]]) == 18 # Example 3 assert find_winning_team_scores([[100, 200], [150, 250], [200, 300]]) == 750 ``` # Explanation In each example: - **Example 1**: Team 2\'s scores across rounds are [20, 40, 60], summing to 120, which is the highest total. - **Example 2**: Team 1\'s scores are [5, 6, 4], summing to 15; Team 2\'s scores are [8, 2, 5], summing to 15; Team 3\'s scores are [7, 6, 4], summing to 17. Team 3 has the highest total of 18. - **Example 3**: Team 2\'s scores across rounds are [200, 250, 300], summing to 750, which is the highest total. **Note**: Ensure your implementation handles large inputs efficiently. For simplicity, assume all input data is well-formed, meaning each inner list will have the same length.","solution":"from typing import List def find_winning_team_scores(scores: List[List[int]]) -> int: Args: scores (List[List[int]]): A list of lists of points, where each inner list represents a round. Returns: int: The total score of the winning team. Raises: ValueError: If scores contain non-integer types or if input data is invalid. if not scores: raise ValueError(\\"The input scores list should not be empty.\\") num_teams = len(scores[0]) total_scores = [0] * num_teams for round_scores in scores: if len(round_scores) != num_teams: raise ValueError(\\"All rounds must have the same number of scores as the number of teams.\\") for i, score in enumerate(round_scores): if not isinstance(score, int): raise ValueError(\\"All scores must be integers.\\") if score < 0: raise ValueError(\\"Scores must be non-negative integers.\\") total_scores[i] += score return max(total_scores)"},{"question":"# Question: Rearrange Array Elements by Parity You are tasked with implementing the function `rearrange_by_parity` that rearranges the elements of an array so that all the even integers appear before the odd integers. The relative order of even integers should be maintained, as should the relative order of odd integers. Function Signature ```python def rearrange_by_parity(arr: List[int]) -> List[int]: ``` Input - `arr` (List[int]): A list of integers. Output - (List[int]): A list where all the even integers appear before all the odd integers, maintaining their original relative order. Constraints - The maximum number of elements in `arr` is 10^5. - Each integer in the array can be between -10^6 and 10^6, inclusive. Performance Requirements - Time Complexity: O(n) - Space Complexity: O(n) # Examples 1. ```python rearrange_by_parity([3, 1, 2, 4, 7, 6]) ``` Output: `[2, 4, 6, 3, 1, 7]` 2. ```python rearrange_by_parity([0, 15, -2, -3, 8]) ``` Output: `[0, -2, 8, 15, -3]` 3. ```python rearrange_by_parity([5, 9, 7]) ``` Output: `[5, 9, 7]` (no change as all numbers are odd) 4. ```python rearrange_by_parity([2, 4, 6, 8]) ``` Output: `[2, 4, 6, 8]` (no change as all numbers are even) # Challenges 1. Handle cases where the array is empty. 2. Ensure that the function handles arrays with negative integers, zeros, and a mix of negative and positive integers. 3. Optimize for both time and space constraints given the potentially large size of the input array. Implement the function to efficiently rearrange the array by parity while maintaining the original relative order of even and odd numbers.","solution":"from typing import List def rearrange_by_parity(arr: List[int]) -> List[int]: Rearranges the elements of an array so that all the even integers appear before the odd integers. The relative order of even integers and odd integers is maintained. even = [] odd = [] for num in arr: if num % 2 == 0: even.append(num) else: odd.append(num) return even + odd"},{"question":"# Coding Assessment Question Context You are required to write a function that generates all possible permutations of a given string. Permutations are all possible arrangements of the characters in the string, where each arrangement must contain every character from the original string exactly once. Problem Statement Write a function `generate_permutations(s: str) -> List[str]` that returns a list containing all the permutations of the input string `s`. Function Signature ```python from typing import List def generate_permutations(s: str) -> List[str]: # Your code here ``` Input - `s`: A string (1 ≤ len(s) ≤ 8) consisting of unique characters. Output - A list of strings where each string is a permutation of the input string `s`. Example ```python assert set(generate_permutations(\\"abc\\")) == {\\"abc\\", \\"acb\\", \\"bac\\", \\"bca\\", \\"cab\\", \\"cba\\"} assert set(generate_permutations(\\"a\\")) == {\\"a\\"} # edge case assert set(generate_permutations(\\"xyz\\")) == {\\"xyz\\", \\"xzy\\", \\"yxz\\", \\"yzx\\", \\"zxy\\", \\"zyx\\"} assert len(generate_permutations(\\"abcd\\")) == 24 # 4! = 24 permutations ``` Constraints - Ensure the function can handle the maximum input size efficiently. - Each permutation must be unique and include all characters from the input string. Hints - You may utilize Python\'s built-in libraries or implement your own permutation logic. - Ensure your solution is time-efficient within the constraints provided.","solution":"from typing import List from itertools import permutations def generate_permutations(s: str) -> List[str]: Generates all possible permutations of a given string. :param s: string consisting of unique characters :return: list of permutations of the string # Using itertools.permutations to generate all permutations return [\'\'.join(p) for p in permutations(s)]"},{"question":"**Scenario**: You are required to implement a function that converts an integer to its Roman numeral representation. This exercise will test your ability to work with string manipulations and conditional logic. **Problem Statement**: Write a function `int_to_roman(num: int) -> str` that converts a given integer to a Roman numeral. # Function Signature ```python def int_to_roman(num: int) -> str: ``` # Input * `num` (1 <= num <= 3999): An integer representing the number to be converted to a Roman numeral. # Output * A string representing the Roman numeral equivalent of the given integer. # Constraints * The Roman numeral system uses the following symbols: I, V, X, L, C, D, M - I (1), V (5), X (10), L (50), C (100), D (500), M (1000) * Roman numerals are usually written largest to smallest from left to right. * There are six instances where subtraction is used: - I can be placed before V (5) and X (10) to make 4 and 9. - X can be placed before L (50) and C (100) to make 40 and 90. - C can be placed before D (500) and M (1000) to make 400 and 900. # Example ```python >>> int_to_roman(3) \'III\' # because 3 is represented by three Is. >>> int_to_roman(58) \'LVIII\' # because 50 is represented by L, 5 by V, and 3 by III. >>> int_to_roman(1994) \'MCMXCIV\' # because 1000 is represented by M, 900 by CM, 90 by XC, and 4 by IV. >>> int_to_roman(44) \'XLIV\' # because 40 is represented by XL and 4 by IV. ``` # Note - Ensure your solution handles the largest inputs efficiently. - Consider various rules of Roman numeral representations for correct output.","solution":"def int_to_roman(num: int) -> str: Converts an integer to a Roman numeral. :param num: Integer to convert (1 <= num <= 3999) :return: Roman numeral representation as a string val = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ] syms = [ \\"M\\", \\"CM\\", \\"D\\", \\"CD\\", \\"C\\", \\"XC\\", \\"L\\", \\"XL\\", \\"X\\", \\"IX\\", \\"V\\", \\"IV\\", \\"I\\" ] roman_numeral = \'\' i = 0 while num > 0: for _ in range(num // val[i]): roman_numeral += syms[i] num -= val[i] i += 1 return roman_numeral"},{"question":"# Question: Sorting Dictionary by Values Design and implement a function that sorts a dictionary by its values. Your task is to write a function `sort_dict_by_values` that takes one argument: 1. `input_dict`: A dictionary with integer keys and values. The function should return a list of tuples representing the dictionary\'s items, sorted in ascending order by the values. If two values are the same, the sorting should maintain the order based on the keys. Implementation ```python def sort_dict_by_values(input_dict: dict) -> list: Returns the dictionary\'s items sorted by values in ascending order. Parameters: input_dict (dict): The dictionary to be sorted. Returns: list: A list of tuples, each representing a key-value pair, sorted by values. Example: input_dict = { 1: 4, 2: 2, 3: 5, 4: 1, 5: 3 } >>> sort_dict_by_values(input_dict) [(4, 1), (2, 2), (5, 3), (1, 4), (3, 5)] return sorted(input_dict.items(), key=lambda item: item[1]) ``` Input and Output Format: - **Input**: A dictionary with integer keys and values. - **Output**: A list of tuples representing the dictionary\'s key-value pairs sorted by values. Constraints: - The dictionary will contain at least one key-value pair. - The dictionary keys and values will both be non-negative integers. Example: **Input**: ```python input_dict = { 1: 4, 2: 2, 3: 5, 4: 1, 5: 3 } print(sort_dict_by_values(input_dict)) ``` **Output**: ```python [(4, 1), (2, 2), (5, 3), (1, 4), (3, 5)] ``` **Note**: This function allows sorting of dictionary items by their values in an efficient manner, suitable for scenarios where value order is more important than key order.","solution":"def sort_dict_by_values(input_dict: dict) -> list: Returns the dictionary\'s items sorted by values in ascending order. Parameters: input_dict (dict): The dictionary to be sorted. Returns: list: A list of tuples, each representing a key-value pair, sorted by values. Example: input_dict = { 1: 4, 2: 2, 3: 5, 4: 1, 5: 3 } >>> sort_dict_by_values(input_dict) [(4, 1), (2, 2), (5, 3), (1, 4), (3, 5)] return sorted(input_dict.items(), key=lambda item: item[1])"},{"question":"# Question: Design a HashMap Scenario You are building a low-level data storage system that requires custom implementation of hash-based key-value storage. Your task is to design and implement a simple HashMap without using any built-in dictionary or hash map libraries available in your programming language. Task Implement a class `MyHashMap` with the following methods: 1. **`__init__(self):`** * Initializes the HashMap object. 2. **`put(self, key: int, value: int) -> None:`** * Inserts a key-value pair into the HashMap. If the key already exists, update the value. 3. **`get(self, key: int) -> int:`** * Returns the value to which the specified key is mapped, or `-1` if the key does not exist in the HashMap. 4. **`remove(self, key: int) -> None:`** * Removes the mapping of the specified key if it exists. Constraints * You must handle collisions using chaining (a list at each bucket position). * The keys and values are non-negative integers. * All methods should perform in average O(1) time complexity. Example ```python my_hash_map = MyHashMap() my_hash_map.put(1, 1) # HashMap = {1: 1} my_hash_map.put(2, 2) # HashMap = {1: 1, 2: 2} print(my_hash_map.get(1)) # returns 1 print(my_hash_map.get(3)) # returns -1 (not found) my_hash_map.put(2, 1) # update the value of key 2, HashMap = {1: 1, 2: 1} print(my_hash_map.get(2)) # returns 1 my_hash_map.remove(2) # remove key 2, HashMap = {1: 1} print(my_hash_map.get(2)) # returns -1 (not found) ``` Additional Notes * You can assume that all keys are unique. * The methods will be called as follows: * `my_hash_map = MyHashMap()` * `my_hash_map.put(key, value)` * `param_1 = my_hash_map.get(key)` * `my_hash_map.remove(key)`","solution":"class MyHashMap: def __init__(self): Initialize the HashMap object with a fixed size for simplicity. Size is chosen as 1000 for initial distribution. self.size = 1000 self.table = [[] for _ in range(self.size)] def hash(self, key: int) -> int: Generate a hash for the given key to determine its bucket. return key % self.size def put(self, key: int, value: int) -> None: Insert (key, value) into the hash map. If the key already exists, update the value. h = self.hash(key) for idx, (k, v) in enumerate(self.table[h]): if k == key: self.table[h][idx] = (key, value) return self.table[h].append((key, value)) def get(self, key: int) -> int: Retrieve the value associated with the key. Return -1 if the key does not exist. h = self.hash(key) for k, v in self.table[h]: if k == key: return v return -1 def remove(self, key: int) -> None: Remove the key (and its associated value) if it exists. h = self.hash(key) for idx, (k, v) in enumerate(self.table[h]): if k == key: self.table[h].pop(idx) return"},{"question":"# K-Means Clustering Implementation with Optimal \'K\' **Context**: You are given a dataset containing geolocation information of various incidents such as emergency service calls within a city. You aim to cluster these incidents into different regions using the K-Means clustering algorithm. However, determining the optimal number of clusters (K) is crucial for ensuring meaningful grouping. Your task is to implement the K-Means clustering algorithm and utilize the Elbow Method to find the optimal number of clusters. # Task: 1. **Implement K-Means Clustering**: Write a function to perform K-Means clustering. 2. **Elbow Method**: Implement the Elbow Method to determine the optimal number of clusters. 3. **Cluster and Analyze**: Cluster the data based on the optimal K and analyze the results. # Inputs: - **dataset_url**: URL link to the dataset. - **max_k**: Maximum number of clusters to test in the Elbow Method. - **iterations**: Number of iterations for the K-Means algorithm. # Expected Output: - Print the optimal number of clusters determined by the Elbow Method. - Print the clustered centroids. - Visual representation (plot) of the clustered data. # Code Constraints: - Use numpy for efficient matrix operations. - Use matplotlib for plotting. - Ensure your code handles the dataset loading and preprocessing as needed. - Include meaningful comments and print statements for analysis and debugging purposes. Here is the skeleton of the program you need to implement: ```python import numpy as np import matplotlib.pyplot as plt import requests def collect_dataset(url): response = requests.get(url, timeout=10) lines = response.text.splitlines() data = [] for item in lines: item = item.split(\\",\\") data.append([float(coord) for coord in item]) data.pop(0) # Remove headers dataset = np.array(data) return dataset def initialize_centroids(dataset, k): return dataset[np.random.choice(dataset.shape[0], k, replace=False)] def assign_clusters(dataset, centroids): distances = np.linalg.norm(dataset[:, np.newaxis] - centroids, axis=2) return np.argmin(distances, axis=1) def update_centroids(dataset, labels, k): new_centroids = np.array([dataset[labels == i].mean(axis=0) for i in range(k)]) return new_centroids def compute_inertia(dataset, centroids, labels): distances = np.linalg.norm(dataset - centroids[labels], axis=1) return np.sum(distances**2) def kmeans(dataset, k, iterations): centroids = initialize_centroids(dataset, k) for _ in range(iterations): old_centroids = centroids labels = assign_clusters(dataset, centroids) centroids = update_centroids(dataset, labels, k) if np.all(centroids == old_centroids): break return centroids, labels def elbow_method(dataset, max_k, iterations): inertias = [] for k in range(1, max_k + 1): centroids, labels = kmeans(dataset, k, iterations) inertia = compute_inertia(dataset, centroids, labels) inertias.append(inertia) optimal_k = np.diff(inertias, 2).argmin() + 2 return optimal_k, inertias def plot_clusters(dataset, centroids, labels): plt.scatter(dataset[:, 0], dataset[:, 1], c=labels, s=50, cmap=\'viridis\') plt.scatter(centroids[:, 0], centroids[:, 1], s=200, c=\'red\', marker=\'X\') plt.xlabel(\'Latitude\') plt.ylabel(\'Longitude\') plt.title(\'Clustered Data\') plt.show() def main(): url = \\"https://raw.githubusercontent.com/your-dataset-url.csv\\" data = collect_dataset(url) max_k = 10 iterations = 100 optimal_k, inertias = elbow_method(data, max_k, iterations) print(f\\"Optimal number of clusters: {optimal_k}\\") centroids, labels = kmeans(data, optimal_k, iterations) print(\\"Cluster centroids:\\") print(centroids) plt.plot(range(1, max_k + 1), inertias, marker=\'o\') plt.xlabel(\'Number of clusters\') plt.ylabel(\'Inertia\') plt.title(\'Elbow Method\') plt.show() plot_clusters(data, centroids, labels) if __name__ == \\"__main__\\": main() ``` # Evaluation - You will be evaluated on correctly implementing the K-Means clustering algorithm. - Properly determining the optimal number of clusters using the Elbow Method. - Clear and concise code with appropriate function naming and comments. - Visual representation of the clustered data.","solution":"import numpy as np import matplotlib.pyplot as plt import requests def collect_dataset(url): response = requests.get(url, timeout=10) lines = response.text.splitlines() data = [] for item in lines[1:]: # Skip the header item = item.split(\\",\\") data.append([float(coord) for coord in item]) dataset = np.array(data) return dataset def initialize_centroids(dataset, k): return dataset[np.random.choice(dataset.shape[0], k, replace=False)] def assign_clusters(dataset, centroids): distances = np.linalg.norm(dataset[:, np.newaxis] - centroids, axis=2) return np.argmin(distances, axis=1) def update_centroids(dataset, labels, k): new_centroids = np.array([dataset[labels == i].mean(axis=0) for i in range(k)]) return new_centroids def compute_inertia(dataset, centroids, labels): distances = np.linalg.norm(dataset - centroids[labels], axis=1) return np.sum(distances**2) def kmeans(dataset, k, iterations): centroids = initialize_centroids(dataset, k) for _ in range(iterations): old_centroids = centroids labels = assign_clusters(dataset, centroids) centroids = update_centroids(dataset, labels, k) if np.all(centroids == old_centroids): break return centroids, labels def elbow_method(dataset, max_k, iterations): inertias = [] for k in range(1, max_k + 1): centroids, labels = kmeans(dataset, k, iterations) inertia = compute_inertia(dataset, centroids, labels) inertias.append(inertia) optimal_k = np.diff(inertias, 2).argmin() + 2 return optimal_k, inertias def plot_clusters(dataset, centroids, labels): plt.scatter(dataset[:, 0], dataset[:, 1], c=labels, s=50, cmap=\'viridis\') plt.scatter(centroids[:, 0], centroids[:, 1], s=200, c=\'red\', marker=\'X\') plt.xlabel(\'Latitude\') plt.ylabel(\'Longitude\') plt.title(\'Clustered Data\') plt.show() def main(): url = \\"https://raw.githubusercontent.com/ageron/handson-ml2/master/datasets/housing/housing.csv\\" data = collect_dataset(url) max_k = 10 iterations = 100 optimal_k, inertias = elbow_method(data, max_k, iterations) print(f\\"Optimal number of clusters: {optimal_k}\\") centroids, labels = kmeans(data, optimal_k, iterations) print(\\"Cluster centroids:\\") print(centroids) plt.plot(range(1, max_k + 1), inertias, marker=\'o\') plt.xlabel(\'Number of clusters\') plt.ylabel(\'Inertia\') plt.title(\'Elbow Method\') plt.show() plot_clusters(data, centroids, labels) if __name__ == \\"__main__\\": main()"},{"question":"# Question: Implement Next Greater Element Algorithm Write a function `next_greater_element(arr: List[int]) -> List[int]` that, given a list of integers, returns a new list where each element is replaced by the next greater element to its right in the original list. If there is no greater element, use `-1`. Input - `arr`: A list of integers where each integer can be between `-10^9` and `10^9` and the length of the list can be between `1` and `10^5`. Output - A list of integers where each element is replaced by the next greater element to its right in the original list, or `-1` if there is no greater element. Constraints - The list must contain valid integer values. - The length of the list must not exceed 10^5. Example ```python >>> next_greater_element([4, 5, 2, 25]) [5, 25, 25, -1] >>> next_greater_element([13, 7, 6, 12]) [-1, 12, 12, -1] ``` Notes - Ensure the function efficiently finds the next greater elements within time constraints since the list can be large. - Use appropriate data structures to optimize the search for next greater elements.","solution":"from typing import List def next_greater_element(arr: List[int]) -> List[int]: Returns a list where each element is replaced by the next greater element to its right in the original list. If there is no greater element, the element is replaced by -1. n = len(arr) result = [-1] * n stack = [] for i in range(n - 1, -1, -1): while stack and stack[-1] <= arr[i]: stack.pop() if stack: result[i] = stack[-1] stack.append(arr[i]) return result"},{"question":"**Question 2**: Implementing Merge Sort You are tasked with implementing the Merge Sort algorithm to sort a list of integers in ascending order. # Problem Statement Given a list of integers, you need to sort the list using the Merge Sort algorithm and return the sorted list. # Input Format - A list of integers ( arr ). # Output Format - A list of integers representing the sorted version of the input list. # Constraints - The length of the list ( arr ) will be between 1 and 1000. - All integers in the list will be between -1000 and 1000. # Example ```python def merge_sort(arr: [int]) -> [int]: if len(arr) <= 1: return arr mid = len(arr) // 2 left = merge_sort(arr[:mid]) right = merge_sort(arr[mid:]) return merge(left, right) def merge(left: [int], right: [int]) -> [int]: result = [] i = j = 0 while i < len(left) and j < len(right): if left[i] < right[j]: result.append(left[i]) i += 1 else: result.append(right[j]) j += 1 result.extend(left[i:]) result.extend(right[j:]) return result # Example Usage: print(merge_sort([34, 7, 23, 32, 5, 62])) # Output: [5, 7, 23, 32, 34, 62] print(merge_sort([3, -1, 0, -5, 12, 8])) # Output: [-5, -1, 0, 3, 8, 12] ``` # Notes - Ensure the solution handles both positive and negative numbers, as well as lists containing duplicate elements. - Carefully manage recursive calls to avoid exceeding maximum recursion depth limits. - The stability of the algorithm should be maintained, ensuring that equal elements retain their original relative order.","solution":"def merge_sort(arr): Sorts a list of integers using the Merge Sort algorithm. :param arr: List of integers to sort :return: Sorted list of integers if len(arr) <= 1: return arr mid = len(arr) // 2 left = merge_sort(arr[:mid]) right = merge_sort(arr[mid:]) return merge(left, right) def merge(left, right): Merges two sorted lists into a single sorted list. :param left: First sorted list :param right: Second sorted list :return: Merged sorted list result = [] i = j = 0 while i < len(left) and j < len(right): if left[i] < right[j]: result.append(left[i]) i += 1 else: result.append(right[j]) j += 1 result.extend(left[i:]) result.extend(right[j:]) return result"},{"question":"# Question: Implement a Custom Sorting Function for a Mixed List Context Sorting algorithms are fundamental in computer science and are used in various applications. Standard sorting functions usually handle lists of homogeneous types (e.g., all integers or all strings). However, in some scenarios, you might encounter a list that contains a mix of integers and strings. Your task is to implement a custom sorting function that handles mixed lists in a specific way. Task Implement a function `custom_mixed_sort(lst: list) -> list` that sorts a mixed list of integers and strings with the following rules: - Integers should appear first in ascending order. - Strings should follow after the integers and be sorted lexicographically (alphabetical order). Requirements 1. **Function Signature**: ```python def custom_mixed_sort(lst: list) -> list: ``` 2. **Inputs**: - `lst`: A list containing a mix of integers and strings. 3. **Output**: - A sorted list following the rules specified above. 4. **Constraints**: - The list contains only integers and strings. - The list can be of any length, including zero. 5. **Error Handling**: - If the input list contains elements that are not integers or strings, raise a ValueError with the message \\"List can only contain integers and strings.\\" Examples ```python >>> custom_mixed_sort([3, \\"apple\\", 2, \\"banana\\", 1, \\"cherry\\"]) [1, 2, 3, \'apple\', \'banana\', \'cherry\'] >>> custom_mixed_sort([\\"dog\\", 5, 2, \\"cat\\"]) [2, 5, \'cat\', \'dog\'] >>> custom_mixed_sort([3, 2.5, \\"apple\\", 1]) Traceback (most recent call last): ... ValueError: List can only contain integers and strings. ``` Notes - The function should not use any built-in sort functions directly to sort the mixed list but should use them for individual sections (integers and strings). - Consider edge cases, such as an input list containing only integers, only strings, or being empty.","solution":"def custom_mixed_sort(lst: list) -> list: Sorts a mixed list of integers and strings. Integers are sorted in ascending order followed by strings sorted lexicographically. Parameters: lst (list): A list containing a mix of integers and strings. Returns: list: A sorted list following the specified order. Raises: ValueError: If the list contains elements other than integers and strings. if any(not isinstance(item, (int, str)) for item in lst): raise ValueError(\\"List can only contain integers and strings.\\") int_part = sorted([item for item in lst if isinstance(item, int)]) str_part = sorted([item for item in lst if isinstance(item, str)]) return int_part + str_part"},{"question":"# Problem Description You are a developer working on a music streaming application. Your next task is to implement a feature that allows users to filter their music library based on specific criteria: genre and duration. # Task Write a function `filter_music_library` which: 1. Takes a list of tracks, each represented as a dictionary. 2. Filters the tracks based on the specified genre and duration. 3. Returns a list of tracks that match the given criteria. # Function Signature ```python def filter_music_library(tracks: List[Dict[str, Any]], genre: str, max_duration: int) -> List[Dict[str, Any]]: # Your implementation here ``` # Input - `tracks`: A list of dictionaries, where each dictionary represents a track with the following keys: - `title`: A string representing the title of the track. - `artist`: A string representing the artist of the track. - `genre`: A string representing the genre of the track. - `duration`: An integer representing the duration of the track in seconds. - `genre`: A string representing the genre to filter by. - `max_duration`: An integer representing the maximum duration of the filtered tracks in seconds. # Output - Returns a list of dictionaries, each representing a track that matches the specified genre and has a duration less than or equal to the specified maximum duration. # Example Usage ```python tracks = [ {\\"title\\": \\"Song A\\", \\"artist\\": \\"Artist 1\\", \\"genre\\": \\"Rock\\", \\"duration\\": 300}, {\\"title\\": \\"Song B\\", \\"artist\\": \\"Artist 2\\", \\"genre\\": \\"Jazz\\", \\"duration\\": 200}, {\\"title\\": \\"Song C\\", \\"artist\\": \\"Artist 1\\", \\"genre\\": \\"Rock\\", \\"duration\\": 150}, {\\"title\\": \\"Song D\\", \\"artist\\": \\"Artist 3\\", \\"genre\\": \\"Pop\\", \\"duration\\": 400}, ] # Filter tracks filtered_tracks = filter_music_library(tracks, \\"Rock\\", 250) # Expected output: [{\'title\': \'Song C\', \'artist\': \'Artist 1\', \'genre\': \'Rock\', \'duration\': 150}] ``` # Constraints 1. The genre must be a string that exists in the provided list of tracks. 2. The maximum duration must be a non-negative integer. 3. The track\'s duration is an integer and is always a positive number. # Performance Requirements - The implementation should handle a list of up to 1000 tracks efficiently. - Aim to use list comprehensions or other efficient methods for filtering lists. # Notes - Ensure the function handles cases where no tracks match the criteria gracefully by returning an empty list. - Consider edge cases such as when the input list is empty or when all tracks exceed the maximum duration.","solution":"from typing import List, Dict, Any def filter_music_library(tracks: List[Dict[str, Any]], genre: str, max_duration: int) -> List[Dict[str, Any]]: Filters the music library by genre and max duration. Parameters: - tracks: List of dictionaries representing the music tracks. - genre: The genre to filter tracks by. - max_duration: The maximum duration of tracks to include, in seconds. Returns: A list of dictionaries representing the filtered tracks. return [track for track in tracks if track[\'genre\'] == genre and track[\'duration\'] <= max_duration]"},{"question":"# Coding Question **Array Permutation Checker** You are tasked with writing a function `is_permutation` to determine if two input lists are permutations of each other. A permutation of a list is another list that contains the same elements, only in a different order. Objectives: 1. **Element Matching**: - Ensure both input lists have the exact same elements with the same counts, but potentially in different orders. 2. **Performance**: - Optimize the approach to handle large lists efficiently. Function Signature: ```python def is_permutation(list1: list, list2: list) -> bool: ``` Expected Input and Output: - **Input**: Two lists `list1` and `list2` containing integers (e.g., `[1, 2, 3]`, `[3, 2, 1]`). - **Output**: A boolean value `True` if `list1` is a permutation of `list2`, otherwise `False`. Constraints: - Both lists may contain any integer, including negative numbers. - The lists can be of varying lengths. - The function should handle empty lists and return `True` if both lists are empty, and `False` if only one is empty. Performance Requirements: - Aim for linearithmic time complexity O(n log n) at most, where n is the length of the lists. Examples: ```python >>> is_permutation([1, 2, 3], [3, 2, 1]) True >>> is_permutation([1, 2, 2], [2, 1, 2]) True >>> is_permutation([1, 2, 3], [1, 2, 3, 4]) False >>> is_permutation([], []) True >>> is_permutation([], [1]) False ``` Additional Information: - Consider using collections like `Counter` from the `collections` module to count occurrences of each element for comparison. - Sorting both lists and comparing them can be another approach but make sure it doesn\'t exceed the required time complexity.","solution":"from collections import Counter def is_permutation(list1, list2): Determines if two lists are permutations of each other. Args: list1 (list): The first list to compare. list2 (list): The second list to compare. Returns: bool: True if the lists are permutations of each other, False otherwise. return Counter(list1) == Counter(list2)"},{"question":"# Coding Question: Maximal Connected Subarray Context Consider an array of integers. A subarray is a contiguous part of the array. We define a connected subarray as a subarray whose elements\' absolute differences between adjacent elements are at most one. Objective Write a function that determines the sum of the maximal connected subarray within a given list of integers. Function Signature ```python def sum_of_maximal_connected_subarray(arr: List[int]) -> int: pass ``` Input - `arr` (List[int]): A list of integers (1 ≤ len(arr) ≤ 10^6, -10^6 ≤ arr[i] ≤ 10^6). Output - Returns the sum as an integer of the elements in the maximal connected subarray with the largest possible sum. Constraints - Ensure the function handles large input arrays efficiently. - Consider edge cases, such as arrays containing all identical elements or very high/very low integer values. Example - `sum_of_maximal_connected_subarray([1, 2, 3, 10, 11, 12, 3, 4, 5])` should return `33` since the subarray [10, 11, 12] has the largest sum within connected subarrays. - `sum_of_maximal_connected_subarray([-1, -2, -3, 7, 8, -4, -5, -6, 7, 6])` should return `15` since the subarray [7, 8] has the largest sum within connected subarrays. Additional Notes - Test with edge cases including arrays of minimal and maximal lengths. - Large arrays with alternating high and low values should be considered for performance evaluation.","solution":"from typing import List def sum_of_maximal_connected_subarray(arr: List[int]) -> int: Function to find the sum of the maximal connected subarray. A connected subarray has elements whose absolute differences between adjacent elements are at most one. if not arr: return 0 max_sum = current_sum = arr[0] for i in range(1, len(arr)): if abs(arr[i] - arr[i - 1]) <= 1: current_sum += arr[i] else: current_sum = arr[i] if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"# Problem Statement: Repeated Substring Pattern Write a function `is_repeated_substring_pattern(s: str) -> bool` that determines if a given string can be constructed by repeating a substring of itself. For instance, the string \\"abab\\" can be constructed by repeating the substring \\"ab\\", but the string \\"abc\\" cannot be constructed by repeating any substring. Function Signature ```python def is_repeated_substring_pattern(s: str) -> bool: ``` Input - `s`: a string consisting of lowercase and/or uppercase English letters. Output - Returns `True` if the string can be constructed by repeating a substring of itself, `False` otherwise. Constraints - The input string will have a length between 1 and 10^4. Example ```python assert is_repeated_substring_pattern(\\"abab\\") == True # \\"abab\\" is \\"ab\\" + \\"ab\\" assert is_repeated_substring_pattern(\\"aba\\") == False # \\"aba\\" cannot be constructed by repeating any substring assert is_repeated_substring_pattern(\\"abcabcabcabc\\") == True # \\"abcabcabcabc\\" is \\"abc\\" repeated 4 times assert is_repeated_substring_pattern(\\"a\\") == False # \\"a\\" cannot be constructed by repeating any substring assert is_repeated_substring_pattern(\\"xyzxyzxyz\\") == True # \\"xyzxyzxyz\\" is \\"xyz\\" repeated 3 times ``` Note - Ensure your implementation efficiently handles the string length constraints. - Consider different edge cases, including strings that do not repeat or only have one character.","solution":"def is_repeated_substring_pattern(s: str) -> bool: Determines if a given string can be constructed by repeating a substring of itself. n = len(s) for i in range(1, n // 2 + 1): if n % i == 0: if s[:i] * (n // i) == s: return True return False"},{"question":"# Question: Implement a function `merge_sorted_linked_lists(lst1: List[int], lst2: List[int]) -> List[int]` that takes in two sorted singly linked lists represented as lists of integers and merges them into a single sorted linked list represented as a list of integers. The function should return the head of the newly merged and sorted linked list. # Input: - `lst1` (type `List[int]`): A list of integers representing the first sorted linked list. - `lst2` (type `List[int]`): A list of integers representing the second sorted linked list. # Output: - A list of integers (type `List[int]`): A sorted linked list that is the result of merging `lst1` and `lst2`. # Constraints: - Both `lst1` and `lst2` are sorted in non-decreasing order. - 0 <= `len(lst1)`, `len(lst2)` <= 10^4 - -10^5 <= `lst1[i]`, `lst2[i]` <= 10^5 (for each valid index `i`) # Examples: 1. Input: `lst1 = [1, 3, 5]`, `lst2 = [2, 4, 6]` Output: `[1, 2, 3, 4, 5, 6]` Explanation: Merged list of `[1, 3, 5]` and `[2, 4, 6]` is `[1, 2, 3, 4, 5, 6]`. 2. Input: `lst1 = [1, 2, 4]`, `lst2 = [1, 3, 4]` Output: `[1, 1, 2, 3, 4, 4]` Explanation: Merged list of `[1, 2, 4]` and `[1, 3, 4]` is `[1, 1, 2, 3, 4, 4]`. 3. Input: `lst1 = []`, `lst2 = [0]` Output: `[0]` Explanation: Merged list of `[]` and `[0]` is `[0]`. # Notes: - The function should handle edge cases where one or both lists may be empty. - Preserve the sorted order in the merged list.","solution":"def merge_sorted_linked_lists(lst1, lst2): Merges two sorted lists into one sorted list. Parameters: - lst1: List[int], first sorted list - lst2: List[int], second sorted list Returns: - List[int], merged sorted list merged_list = [] i, j = 0, 0 while i < len(lst1) and j < len(lst2): if lst1[i] <= lst2[j]: merged_list.append(lst1[i]) i += 1 else: merged_list.append(lst2[j]) j += 1 while i < len(lst1): merged_list.append(lst1[i]) i += 1 while j < len(lst2): merged_list.append(lst2[j]) j += 1 return merged_list"},{"question":"# Q1. Matrix Rotation **Objective**: You are required to implement a function that rotates a square matrix by 90 degrees clockwise. # Function: `rotate_matrix(matrix: List[List[int]]) -> List[List[int]]` **Input**: - `matrix`: A square 2D list of integers representing the matrix to be rotated. **Output**: - A 2D list of integers representing the rotated matrix. # Constraints: - `matrix` will have dimensions NxN where 1 ≤ N ≤ 1000. - Each element of `matrix` will be an integer in the range -10^9 to 10^9. # Requirements: 1. Implement the function to rotate the given square matrix by 90 degrees in the clockwise direction. 2. The rotated matrix should be a new matrix, and the original matrix should remain unchanged. 3. Optimize for performance given the constraints, considering both time and space complexity. # Example: ```python >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> rotate_matrix(matrix) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] ``` **Hint**: - Consider transposing the matrix first and then reversing each row to achieve the rotation. **Note**: 1. Do not use any in-place matrix rotation methods; the new rotated matrix should be a distinct object. 2. Make sure to handle matrices with edge sizes appropriately (e.g., 1x1 matrices).","solution":"from typing import List def rotate_matrix(matrix: List[List[int]]) -> List[List[int]]: Rotates a given square matrix by 90 degrees clockwise. Args: - matrix: A 2D list of integers representing the matrix to be rotated. Returns: - A 2D list of integers representing the rotated matrix. n = len(matrix) # Create a new matrix to store the rotated values rotated = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): rotated[j][n - 1 - i] = matrix[i][j] return rotated"},{"question":"```markdown **Problem Statement:** You are given a list of integers `arr` and an integer `k`. Your task is to implement a function `find_k_closest_elements` which returns the `k` closest integers to a given integer `x` in the list. The result should be sorted in ascending order. If there is a tie with the same distance to `x`, favor the smaller element. Requirements: 1. Locate the `k` closest integers to the target `x`. 2. Sort the result in ascending order. Function Signature: ```python def find_k_closest_elements(arr: list[int], k: int, x: int) -> list[int]: Finds the k closest integers to x in the given list. :param arr: A list of integers. :param k: The number of closest integers to find. :param x: The target integer. :return: A list of the k closest integers to x, sorted in ascending order. ``` Example: ```python arr = [1, 2, 3, 4, 5] print(find_k_closest_elements(arr, 4, 3)) # Output: [1, 2, 3, 4] print(find_k_closest_elements(arr, 4, -1)) # Output: [1, 2, 3, 4] ``` Constraints: - The list `arr` will contain at least `k` elements. - 1 ≤ k ≤ len(arr) - The elements of `arr` are distinct. - Each element is within the range of a 32-bit signed integer. Notes: - You can initially sort the array based on their absolute distance from `x`. - After sorting by distance, if there\'s a tie, retain the order they appear in the original `arr`. - The final result should always be sorted in ascending order. ```","solution":"def find_k_closest_elements(arr: list[int], k: int, x: int) -> list[int]: Finds the k closest integers to x in the given list. :param arr: A list of integers. :param k: The number of closest integers to find. :param x: The target integer. :return: A list of the k closest integers to x, sorted in ascending order. # Sort the array based on the distance to x sorted_arr = sorted(arr, key=lambda num: (abs(num - x), num)) # Get the first k elements from the sorted array closest_elements = sorted_arr[:k] # Return the closest elements sorted in ascending order return sorted(closest_elements)"},{"question":"# Question **Prefix to Infix Expression Conversion** In this problem, you will write a function to convert a given mathematical expression from prefix notation to infix notation. Prefix notation, also known as Polish notation, is a way of writing expressions without the need for parentheses to denote operation order. Infix notation is the conventional way of writing expressions that we are accustomed to, where operators are placed between operands. Function Signature ```python def prefix_to_infix(expression: str) -> str: ... # Your implementation here ``` Input * A string `expression` containing a valid prefix expression, with elements separated by spaces. Operators can be `+`, `-`, `*`, `/`, and the operands are single-character variables or integers. Output * A string representing the equivalent infix expression with appropriate parentheses to maintain the correct order of operations. Example ```python print(prefix_to_infix(\\"* + A B - C D\\")) # \\"(A + B) * (C - D)\\" print(prefix_to_infix(\\"+ 3 * 5 6\\")) # \\"3 + (5 * 6)\\" print(prefix_to_infix(\\"- 3 4\\")) # \\"3 - 4\\" ``` Constraints * The input expression is a valid prefix expression that will result in a valid output when converted to infix notation. * The function should handle edge cases such as minimal expressions with only one operator and two operands. * Parentheses should be used to preserve the correct order of operations but should not be excessive. * Avoid using any external libraries for the conversion logic. Context Understanding the conversion between different notations of mathematical expressions is crucial in computer science, especially in the fields of compiler design and expression evaluation. This problem will enhance your knowledge of stack-based evaluation and manipulation of expressions. Performance requirements * The function should operate efficiently within linear time complexity where possible, given that each character in the expression is processed only once. Use appropriate data structures like stacks to ensure this efficiency.","solution":"def prefix_to_infix(expression: str) -> str: stack = [] operators = set([\'+\', \'-\', \'*\', \'/\']) expression = expression.split()[::-1] # reverse the expression list for symbol in expression: if symbol not in operators: stack.append(symbol) else: operand1 = stack.pop() operand2 = stack.pop() stack.append(f\'({operand1} {symbol} {operand2})\') return stack[0]"},{"question":"# Sum of Digits in a String Objective You are required to write a Python function that calculates the sum of all numeric digits in a given string. The function should also handle strings that contain no digits and return zero in such cases. Problem Statement Given a string `s`, implement a function `sum_of_digits(s: str) -> int` that returns the sum of all numeric digits in the string. You should also write a test suite to verify your implementation handles various cases correctly. Input and Output Format * **Input**: A string `s` containing alphanumeric characters, spaces, punctuation, and special characters. * **Output**: An integer representing the sum of all numeric digits found in the string. Constraints * The input string can have a length up to `10^6` characters. * The solution should efficiently handle cases with very long strings. Performance Requirements * Time Complexity: O(n), where n is the length of the string. * Space Complexity: O(1), as extra storage used should not depend on the length of the string. Example 1 * **Input**: `s = \\"abc123\\"` * **Output**: `6` Example 2 * **Input**: `s = \\"!@#45xYz\\"` * **Output**: `9` Example 3 * **Input**: `s = \\"no digits here\\"` * **Output**: `0` Tasks 1. Implement the function `sum_of_digits(s: str) -> int`. 2. Write a suite of test cases to ensure your implementation is correct, considering edge cases such as: * An empty string. * A string with no numeric digits. * A very long string with a mix of alphanumeric and special characters. Notes * Make sure to account for performance when handling very long strings. * Ensure your function is thoroughly tested with edge cases and conforms to the required time and space complexities.","solution":"def sum_of_digits(s: str) -> int: Returns the sum of all numeric digits in the given string. Parameters: s (str): Input string containing alphanumeric characters, spaces, punctuation, and special characters. Returns: int: Sum of all numeric digits in the input string. return sum(int(char) for char in s if char.isdigit())"},{"question":"# Coding Question: Implement a Sublist Summation Function **Context**: You are developing a utility function that helps in generating reports based on specific data segments in a list. This function should calculate the sum of elements for a specified sublist. Accurate summation of sublists is crucial for producing correct statistics and analysis in your reports. **Problem Statement**: Write a function `sublist_sum` that computes the sum of elements in a specific sublist segment of a given list of integers. The function should take the starting and ending indices of the sublist whose sum is to be calculated. **Function Signature**: ```python def sublist_sum(arr: list[int], start_idx: int, end_idx: int) -> int: pass ``` **Input**: - `arr` (list of int): The input list of integers. - `start_idx` (int): The starting index of the sublist (inclusive). - `end_idx` (int): The ending index of the sublist (inclusive). **Output**: - Returns an integer that is the sum of the specified sublist elements. **Constraints**: - The input list `arr` will have a maximum length of 10^5. - All elements in the list are integers within the range ([-10^3, 10^3]). - `0 <= start_idx <= end_idx < len(arr)` **Additional Requirements**: - Ensure your function handles edge cases such as an empty sublist (where `start_idx == end_idx`). - Aim to maintain linear time complexity, O(n), where n is the length of the sublist. **Examples**: ``` sublist_sum([1, 2, 3, 4, 5], 1, 3) -> 9 # 2 + 3 + 4 sublist_sum([-1, -2, -3, -4, -5], 0, 2) -> -6 # -1 + -2 + -3 sublist_sum([10, 20, 30, 40, 50], 2, 4) -> 120 # 30 + 40 + 50 sublist_sum([0, 0, 0, 0, 0], 0, 4) -> 0 # 0 + 0 + 0 + 0 + 0 sublist_sum([5], 0, 0) -> 5 # Single element sublist ``` **Note**: Do not use Python\'s in-built `sum` function for calculating the sublist sum. Implement the logic manually within your function.","solution":"def sublist_sum(arr: list[int], start_idx: int, end_idx: int) -> int: Computes the sum of elements in a specific sublist segment of a given list of integers. :param arr: List of integers :param start_idx: Starting index of the sublist (inclusive) :param end_idx: Ending index of the sublist (inclusive) :return: Sum of the specified sublist elements sublist_sum = 0 for i in range(start_idx, end_idx + 1): sublist_sum += arr[i] return sublist_sum"},{"question":"# Problem Description You are tasked with creating a function that performs Caesar cipher encryption and decryption, but with a twist: the shift value for encryption is dynamic and varies for each character in the string based on the corresponding letter in a keyword. # Objective **Implement the function** `caesar_cipher_with_keyword` **that meets the following requirements**: - The function should perform both encryption and decryption based on the Caesar cipher. - Use a keyword to determine the shift values for each character in the text. - Accepts a mode (\'encrypt\' or \'decrypt\'), text to be processed, and a keyword. # Function Signature ```python def caesar_cipher_with_keyword(mode: str, text: str, keyword: str) -> str: pass ``` # Input - `mode` (str): Specifies whether to \'encrypt\' or \'decrypt\' the message. - `text` (str): The input message to be encrypted/decrypted. - `keyword` (str): The keyword used to determine the shift values for the Caesar cipher. # Output - The function should return the encrypted or decrypted message based on the mode. # Constraints - Only alphabetic characters should be considered for encryption/decryption. - Text should maintain the case (uppercase or lowercase) of the original characters. - Non-alphabetic characters should be ignored and included in their original form in the output. - The keyword is a non-empty string consisting of alphabetic characters only. - Must handle the case where the keyword is shorter than the text by repeating the keyword as needed. # Example ```python encrypted_message = caesar_cipher_with_keyword(\'encrypt\', \'HELLO WORLD\', \'KEY\') print(encrypted_message) # Expected Output: \'RIJVS UYVJN\' decrypted_message = caesar_cipher_with_keyword(\'decrypt\', \'RIJVS UYVJN\', \'KEY\') print(decrypted_message) # Expected Output: \'HELLO WORLD\' ``` # Hints - Map each character in the text to a corresponding shift value derived from the keyword. - For encryption, shift each character forward by the keyword\'s corresponding character positions in the alphabet. - For decryption, shift each character backward by the keyword\'s corresponding character positions in the alphabet. - Consider using modular arithmetic to manage the shifts and avoid index out-of-bound errors.","solution":"def caesar_cipher_with_keyword(mode: str, text: str, keyword: str) -> str: def shift_character(char, shift_amount): if char.isalpha(): base = ord(\'A\') if char.isupper() else ord(\'a\') return chr((ord(char) - base + shift_amount) % 26 + base) return char keyword = keyword.upper() keystream = (keyword * ((len(text) // len(keyword)) + 1)).upper() result = [] key_index = 0 for char in text: if char.isalpha(): shift_amount = ord(keystream[key_index]) - ord(\'A\') if mode == \'decrypt\': shift_amount = -shift_amount result.append(shift_character(char, shift_amount)) key_index += 1 else: result.append(char) return \'\'.join(result)"},{"question":"# Context You are provided with an array of integers where only one element appears once and all other elements appear exactly twice. The challenge is to find the element that appears only once. # Task Write a function that takes an array of integers and returns the element that appears only once. # Function Signature ```python def find_unique_element(arr: List[int]) -> int: # Your code here ``` # Example ```python >>> find_unique_element([2, 3, 5, 4, 5, 3, 4]) 2 >>> find_unique_element([7, 3, 5, 7, 3]) 5 ``` # Constraints - The length of the array is odd, with at least one, and at most (10^5) elements. - Each element in the array is an integer, which fits within the range of a 32-bit signed integer. - The array is non-empty and exactly one element appears only once. # Notes - Implement an efficient solution with a linear runtime complexity and constant space complexity if possible. - Avoid using additional data structures that would use extra memory.","solution":"from typing import List def find_unique_element(arr: List[int]) -> int: Returns the element that appears only once in the array where every other element appears exactly twice. unique = 0 for num in arr: unique ^= num return unique"},{"question":"# Coding Assessment Question You are assigned the task of developing a system for cataloging a library of electronic books (eBooks). The system must maintain an organized collection that allows for easy retrieval, updating, and searching. **Objective**: Implement a `Library` class with the following specifications. # Library Class Specifications: 1. **Constructor**: ```python def __init__(self) -> None ``` - Initializes the library with an empty collection of eBooks. 2. **Methods**: - `add_book(self, title: str, author: str, isbn: str, year: int) -> None` : Adds a new book to the library. Raises `ValueError` if a book with the same ISBN already exists. - `remove_book(self, isbn: str) -> None` : Removes a book from the library based on its ISBN. Raises `ValueError` if no book with the specified ISBN exists. - `update_book(self, isbn: str, title: str = None, author: str = None, year: int = None) -> None` : Updates the information of a book in the library. Raises `ValueError` if no book with the specified ISBN exists. - `search_by_title(self, title: str) -> List[Dict[str, Union[str, int]]]` : Searches for books by title (case-insensitive) and returns a list of matching books. - `search_by_author(self, author: str) -> List[Dict[str, Union[str, int]]]` : Searches for books by author (case-insensitive) and returns a list of matching books. - `get_book_details(self, isbn: str) -> Dict[str, Union[str, int]]` : Retrieves the details of a book based on its ISBN. Raises `ValueError` if no book with the specified ISBN exists. # Input and Output Formats: - Books are represented as dictionaries with keys: `title`, `author`, `isbn`, and `year`. - `search_by_title` and `search_by_author` methods return a list of books. - Raise `ValueError` with appropriate descriptive messages for invalid input scenarios. # Constraints: - ISBNs are unique for each book and are represented as strings. - Years are represented as integers. # Example Usage: ```python # Initializing the library library = Library() # Adding books library.add_book(title=\\"The Great Gatsby\\", author=\\"F. Scott Fitzgerald\\", isbn=\\"9780743273565\\", year=1925) library.add_book(title=\\"1984\\", author=\\"George Orwell\\", isbn=\\"9780451524935\\", year=1949) # Searching for books books_by_title = library.search_by_title(\\"1984\\") books_by_author = library.search_by_author(\\"George Orwell\\") # Updating a book library.update_book(isbn=\\"9780451524935\\", title=\\"Nineteen Eighty-Four\\", year=1949) # Retrieving book details book_details = library.get_book_details(\\"9780451524935\\") # Removing a book library.remove_book(\\"9780743273565\\") ``` **Your task**: Implement the `Library` class as per the above specifications.","solution":"from typing import List, Dict, Union class Library: def __init__(self) -> None: self.collection = {} def add_book(self, title: str, author: str, isbn: str, year: int) -> None: if isbn in self.collection: raise ValueError(\\"A book with the same ISBN already exists.\\") self.collection[isbn] = { \\"title\\": title, \\"author\\": author, \\"isbn\\": isbn, \\"year\\": year } def remove_book(self, isbn: str) -> None: if isbn not in self.collection: raise ValueError(\\"No book with the specified ISBN exists.\\") del self.collection[isbn] def update_book(self, isbn: str, title: str = None, author: str = None, year: int = None) -> None: if isbn not in self.collection: raise ValueError(\\"No book with the specified ISBN exists.\\") if title is not None: self.collection[isbn][\\"title\\"] = title if author is not None: self.collection[isbn][\\"author\\"] = author if year is not None: self.collection[isbn][\\"year\\"] = year def search_by_title(self, title: str) -> List[Dict[str, Union[str, int]]]: return [ book for book in self.collection.values() if title.lower() in book[\\"title\\"].lower() ] def search_by_author(self, author: str) -> List[Dict[str, Union[str, int]]]: return [ book for book in self.collection.values() if author.lower() in book[\\"author\\"].lower() ] def get_book_details(self, isbn: str) -> Dict[str, Union[str, int]]: if isbn not in self.collection: raise ValueError(\\"No book with the specified ISBN exists.\\") return self.collection[isbn]"},{"question":"# Coding Assessment Question: Predictive Text Suggestion **Context**: You are tasked with implementing a predictive text suggestion system commonly used in search engines and messaging apps. The system should suggest the top K most frequently used words based on the input prefix provided by the user. The suggestions should be displayed in descending order of frequency and, in case of ties, alphabetically. **Objective**: Write a class that can ingest a body of text to learn the frequency of words and then provide top K suggestions based on a given prefix. **Function Signature**: ```python class PredictiveText: def __init__(self) -> None: Initializes the word frequency dictionary. pass def learn(self, text: str) -> None: Processes the given text to learn word frequencies. pass def suggest(self, prefix: str, k: int) -> List[str]: Returns the top K frequent words starting with the given prefix. pass ``` **Expected Input/Output**: * **Initialization**: `__init__()` prepares the necessary data structures to track word frequencies. * **Learning**: `learn(text)` ingests a text body, splits it into words, and updates their frequencies. * **Suggestion**: `suggest(prefix, k)` returns a list of up to K words that start with the given prefix, sorted by frequency and then alphabetically. **Constraints**: 1. The input text for the `learn()` method will contain only alphabetical characters and spaces. 2. Words are case-insensitive and should be treated uniformly (e.g., \\"Hello\\" and \\"hello\\" should be counted together). 3. The `suggest()` method will receive a non-empty prefix string and an integer `k` such that (1 leq k leq 100). **Requirements**: - **Edge Cases**: Handle cases where the prefix matches no words or less than K words. - **Performance**: Optimize for frequent calls to the `suggest` method with dynamic text addition through the `learn` method. **Challenge**: Optimize the `suggest` method to quickly return results even as the word database grows. Utilize efficient data structures to manage and retrieve word frequencies and suggestions.","solution":"from collections import defaultdict, Counter from typing import List class PredictiveText: def __init__(self) -> None: Initializes the word frequency dictionary. self.word_counts = defaultdict(int) def learn(self, text: str) -> None: Processes the given text to learn word frequencies. words = text.lower().split() for word in words: self.word_counts[word] += 1 def suggest(self, prefix: str, k: int) -> List[str]: Returns the top K frequent words starting with the given prefix. prefix = prefix.lower() matching_words = [word for word in self.word_counts if word.startswith(prefix)] sorted_words = sorted(matching_words, key=lambda word: (-self.word_counts[word], word)) return sorted_words[:k]"},{"question":"# Problem Statement You are tasked with implementing a function that generates the nth Fibonacci number. The Fibonacci series is a sequence of numbers where each number is the sum of the two preceding ones, starting from 0 and 1. Given the constraints and requirements outlined below, write a function to compute the nth Fibonacci number. # Function Signature ```python def fibonacci(n: int) -> int: Computes the nth Fibonacci number. :param n: The position of the Fibonacci number to compute (0-indexed). :return: The nth Fibonacci number. Requirements: - If n is negative, raise a ValueError with the message \\"Input must be a non-negative integer\\". - Optimize for both time and space complexity. Examples: >>> fibonacci(0) 0 >>> fibonacci(1) 1 >>> fibonacci(2) 1 >>> fibonacci(3) 2 >>> fibonacci(10) 55 >>> fibonacci(-1) Traceback (most recent call last): ... ValueError: Input must be a non-negative integer >>> fibonacci(20) 6765 pass ``` # Constraints - Your implementation should correctly handle edge cases, including large values of n. - The function should be optimized to avoid excessive recomputation—consider using iterative solutions or memoization. - Ensure your function passes all provided examples and additional edge cases you consider necessary. # Submission Please submit your function implementation along with a brief explanation of your approach and any additional test cases you added to ensure correctness.","solution":"def fibonacci(n: int) -> int: Computes the nth Fibonacci number. :param n: The position of the Fibonacci number to compute (0-indexed). :return: The nth Fibonacci number. Requirements: - If n is negative, raise a ValueError with the message \\"Input must be a non-negative integer\\". - Optimize for both time and space complexity. if n < 0: raise ValueError(\\"Input must be a non-negative integer\\") if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"Implement a Regular Expression-Based String Validator You are tasked with creating a string validator that utilizes regular expressions to ensure strings follow a specific pattern. Problem Statement Implement the `StringValidator` class with functionality to validate strings against multiple predefined patterns, ensuring they match the specified criteria. The validation should be customizable by adding different regular expression patterns. Requirements 1. **Implement StringValidator class**: - Create a method `add_pattern` that takes a string pattern (regex) and its name, and stores them for later use. - Create a method `validate` that takes a string and checks it against all stored patterns, returning the names of all patterns the string matches. 2. **Pattern Matching**: - Ensure that adding and checking patterns are efficient and maintainable. - Handle edge cases where no patterns are added or the string is empty. Input and Output - `add_pattern` should accept a string `pattern` and a string `name` and store the pattern. - `validate` should accept a string `s` and return a list of pattern names that `s` matches. Constraints - Use Python\'s `re` module for regular expressions. - Ensure the code can handle multiple patterns and large inputs gracefully. - Validate that patterns added are valid regular expressions. Testing and Performance - Include test cases to verify functionality, including: - Validating with multiple overlapping and non-overlapping patterns. - Handling invalid regular expression patterns gracefully. - Edge cases (e.g., empty input string or patterns). Example ```python validator = StringValidator() validator.add_pattern(r\'^d{4}-d{2}-d{2}\', \'date\') validator.add_pattern(r\'^[A-Z]{3}-d{3}\', \'code\') matches = validator.validate(\'2023-10-21\') # Should match \'date\' matches_code = validator.validate(\'ABC-123\') # Should match \'code\' all_matches = validator.validate(\'ABC-999 2023-10-21\') # Should return an empty list print(matches) print(matches_code) print(all_matches) ``` Output: ```plaintext matches: [\'date\'] matches_code: [\'code\'] all_matches: [] ``` Implement the `StringValidator` class and validate using the above test cases and other edge cases.","solution":"import re class StringValidator: def __init__(self): self.patterns = {} def add_pattern(self, pattern, name): try: re.compile(pattern) self.patterns[name] = pattern except re.error: raise ValueError(f\\"Invalid regular expression pattern: {pattern}\\") def validate(self, s): matches = [] for name, pattern in self.patterns.items(): if re.search(pattern, s): matches.append(name) return matches"},{"question":"# Context Imagine we need to analyze a series of assignments given to students and determine which assignments have been submitted late based on specific due dates. Let\'s design a function to identify how many late submissions are present in a given list of assignments and due dates. # Problem Statement Write a function `count_late_submissions(assignments: List[Tuple[str, str]]) -> int` that takes a list of tuples where each tuple contains two strings representing the submission date and the due date of an assignment in the format \\"YYYY-MM-DD\\", and returns the number of late submissions. An assignment is considered late if the submission date is after the due date. # Expected Input and Output Formats - **Input**: A list of tuples of strings. - Example: `[(\\"2023-05-01\\", \\"2023-04-30\\"), (\\"2023-06-15\\", \\"2023-06-15\\"), (\\"2023-09-10\\", \\"2023-09-01\\")]` - **Output**: An integer representing the count of late submissions. - Example for above input: `2` (The first and third assignments are late) # Constraints 1. The list length can be up to 1000 assignments. 2. All dates provided will be valid and in the format \\"YYYY-MM-DD\\". 3. The due date and submission date will always belong to the same year. # Performance Requirements - Your solution should be efficient in terms of both time and space complexities while handling the stated constraints. # Notes - Example: - For the dates `(\\"2023-05-01\\", \\"2023-04-30\\")`, the submission is after the due date, so it is late. - For the dates `(\\"2023-06-15\\", \\"2023-06-15\\")`, the submission is on the due date, so it is not late. - For the dates `(\\"2023-09-10\\", \\"2023-09-01\\")`, the submission is after the due date, so it is late. # Implementation: Implement the function with the following signature: ```python from typing import List, Tuple def count_late_submissions(assignments: List[Tuple[str, str]]) -> int: # Your implementation here ```","solution":"from typing import List, Tuple from datetime import datetime def count_late_submissions(assignments: List[Tuple[str, str]]) -> int: count = 0 date_format = \\"%Y-%m-%d\\" for submission_date, due_date in assignments: submission_date_dt = datetime.strptime(submission_date, date_format) due_date_dt = datetime.strptime(due_date, date_format) if submission_date_dt > due_date_dt: count += 1 return count"},{"question":"# Distinct Substrings in a String Write a function that calculates the number of distinct substrings of a given string (s). Function Signature ```python def count_distinct_substrings(s: str) -> int: Returns the number of distinct substrings of the given string s. :param s: str - The string for which we need to find the distinct substrings :return: int - The count of distinct substrings ``` Input - A string (s) (1 ≤ length of (s) ≤ 1000): The input string for which the number of distinct substrings needs to be computed. Output - Return the number of distinct substrings of the input string. Constraints - The function should be optimized to handle the upper limits of the constraints efficiently. Consider optimization points to reduce runtime and unnecessary calculations. Example ```python >>> count_distinct_substrings(\\"abc\\") 6 >>> count_distinct_substrings(\\"aaa\\") 3 ``` Explanation For the first example, the distinct substrings are: \\"a\\", \\"b\\", \\"c\\", \\"ab\\", \\"bc\\", \\"abc\\", so the count is 6. For the second example, the distinct substrings are: \\"a\\", \\"aa\\", \\"aaa\\", so the count is 3.","solution":"def count_distinct_substrings(s: str) -> int: Returns the number of distinct substrings of the given string s. :param s: str - The string for which we need to find the distinct substrings :return: int - The count of distinct substrings substrings = set() n = len(s) for i in range(n): for j in range(i + 1, n + 1): substrings.add(s[i:j]) return len(substrings)"},{"question":"# Fibonacci Sequence Problem You are tasked with implementing functions in Python to work with Fibonacci numbers. The Fibonacci sequence is a well-known mathematical sequence where each number is the sum of the two preceding ones, usually starting with 0 and 1. The sequence is defined as: - (F(0) = 0) - (F(1) = 1) - (F(n) = F(n-1) + F(n-2)) for (n > 1) Your task is to implement the following two functions: 1. `fibonacci_number(n: int) -> int`: This function calculates the (n)-th Fibonacci number: - **Input**: - `n` (int): The index in the Fibonacci sequence. - **Output**: - Returns the (n)-th Fibonacci number as an integer. - **Contraint**: - The function should raise a `ValueError` if the index (n) is negative. 2. `fibonacci_sequence_up_to_n(n: int) -> list`: This function generates all Fibonacci numbers from (F(0)) up to (F(n)): - **Input**: - `n` (int): The maximum index in the Fibonacci sequence. - **Output**: - Returns a list of Fibonacci numbers from (F(0)) to (F(n)). - **Contraint**: - The function should raise a `ValueError` if the index (n) is negative. # Example ```python >>> fibonacci_number(7) 13 >>> fibonacci_number(0) 0 >>> fibonacci_number(-1) Traceback (most recent call last): ... ValueError: Index can\'t be negative. >>> fibonacci_sequence_up_to_n(7) [0, 1, 1, 2, 3, 5, 8, 13] >>> fibonacci_sequence_up_to_n(0) [0] >>> fibonacci_sequence_up_to_n(-3) Traceback (most recent call last): ... ValueError: Index can\'t be negative. ``` # Constraints - Ensure your code handles large values of (n) efficiently. - Ensure calculations are accurate and do not suffer from integer overflow. # Performance - Time complexity for `fibonacci_number` should be (O(n)). - Space complexity for `fibonacci_number` should be (O(1)). - Time complexity for `fibonacci_sequence_up_to_n` should be (O(n)). - Space complexity for `fibonacci_sequence_up_to_n` should be (O(n)). Good luck, and remember to test edge cases such as zero and negative values!","solution":"def fibonacci_number(n: int) -> int: Returns the n-th Fibonacci number. Raises a ValueError if the index n is negative. if n < 0: raise ValueError(\\"Index can\'t be negative.\\") if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b def fibonacci_sequence_up_to_n(n: int) -> list: Generates a list of Fibonacci numbers from F(0) up to F(n). Raises a ValueError if the index n is negative. if n < 0: raise ValueError(\\"Index can\'t be negative.\\") if n == 0: return [0] sequence = [0, 1] for i in range(2, n + 1): sequence.append(sequence[-1] + sequence[-2]) return sequence"},{"question":"# Coding Assessment Question Problem Statement You are given an implementation of the k-Nearest Neighbors (k-NN) classifier. Your task is to write a function that will apply this classifier to various input scenarios and compare the classification results with those obtained from the `scikit-learn` library to ensure accuracy. Function Signature ```python from typing import Tuple import numpy as np def validate_knn_classifier( train_data: np.ndarray, train_labels: np.ndarray, test_data: np.ndarray, test_labels: np.ndarray, k: int = 3 ) -> bool: Validate the k-Nearest Neighbors classifier against scikit-learn\'s implementation. Parameters ---------- train_data : np.ndarray Training data points, shape (num_train_samples, num_features). train_labels : np.ndarray Labels for the training data points, shape (num_train_samples,). test_data : np.ndarray Data points to classify, shape (num_test_samples, num_features). test_labels : np.ndarray True labels for the test data points, shape (num_test_samples,). k : int, optional Number of neighbors to use for classification (default is 3). Returns ------- bool True if the classification results from your k-NN implementation match the results from scikit-learn\'s k-NN, within an acceptable error margin. ``` Detailed Requirements 1. **Input and Output**: - **Input**: - `train_data`: A 2D numpy array of shape (num_train_samples, num_features) representing the training data. - `train_labels`: A 1D numpy array of shape (num_train_samples,) representing the labels of the training data. - `test_data`: A 2D numpy array of shape (num_test_samples, num_features) representing the data for prediction. - `test_labels`: A 1D numpy array of shape (num_test_samples,) representing the true labels of the test data. - `k`: An integer representing the number of neighbors to use for the k-NN classification. - **Output**: - Return a single boolean value indicating if the classification from both implementations match. 2. **Constraints**: - The training and test data must have the same number of features. - The number of neighbors (k) must be less than or equal to the number of training samples. 3. **Performance Requirements**: - The function should efficiently handle typical sizes of train/test datasets. - Compare results obtained via your custom k-NN implementation with results from `sklearn.neighbors.KNeighborsClassifier`. - Ensure classifications are consistent within a small tolerance for possible tie-breaking differences. 4. **Scenario**: - Validate the correctness of the k-NN classifier on datasets with different properties (balanced/unbalanced classes, high-dimensional spaces). Example ```python from sklearn.neighbors import KNeighborsClassifier def knn_classifier( train_data: np.ndarray, train_labels: np.ndarray, test_data: np.ndarray, k: int = 3 ) -> np.ndarray: def euclidean_distance(x1, x2): return np.sqrt(np.sum((x1 - x2) ** 2)) predictions = [] for test_point in test_data: distances = [euclidean_distance(test_point, x) for x in train_data] k_nearest_neighbors = np.argsort(distances)[:k] k_nearest_labels = [train_labels[i] for i in k_nearest_neighbors] majority_label = max(set(k_nearest_labels), key=k_nearest_labels.count) predictions.append(majority_label) return np.array(predictions) def validate_knn_classifier( train_data: np.ndarray, train_labels: np.ndarray, test_data: np.ndarray, test_labels: np.ndarray, k: int = 3 ) -> bool: # Custom k-NN classification custom_knn_predictions = knn_classifier(train_data, train_labels, test_data, k) # Sklearn k-NN classification knn = KNeighborsClassifier(n_neighbors=k) knn.fit(train_data, train_labels) sklearn_knn_predictions = knn.predict(test_data) # Validate results return np.array_equal(custom_knn_predictions, sklearn_knn_predictions) # Example Usage train_data = np.array([[1, 2], [2, 3], [8, 9], [5, 6], [3, 3]]) train_labels = np.array([0, 0, 1, 1, 0]) test_data = np.array([[2, 2], [6, 5]]) test_labels = np.array([0, 1]) print(validate_knn_classifier(train_data, train_labels, test_data, test_labels)) # Should print: True (if implementations are correct) ```","solution":"import numpy as np from sklearn.neighbors import KNeighborsClassifier def knn_classifier(train_data: np.ndarray, train_labels: np.ndarray, test_data: np.ndarray, k: int = 3) -> np.ndarray: A simple k-Nearest Neighbors classifier. Parameters: - train_data: A 2D numpy array of shape (num_train_samples, num_features). - train_labels: A 1D numpy array of shape (num_train_samples,). - test_data: A 2D numpy array of shape (num_test_samples, num_features). - k: Number of neighbors to use for classification (default is 3). Returns: - A 1D numpy array of shape (num_test_samples,) containing predicted labels for the test data. def euclidean_distance(x1, x2): return np.sqrt(np.sum((x1 - x2) ** 2)) predictions = [] for test_point in test_data: distances = [euclidean_distance(test_point, x) for x in train_data] k_nearest_neighbors = np.argsort(distances)[:k] k_nearest_labels = [train_labels[i] for i in k_nearest_neighbors] majority_label = max(set(k_nearest_labels), key=k_nearest_labels.count) predictions.append(majority_label) return np.array(predictions) def validate_knn_classifier(train_data: np.ndarray, train_labels: np.ndarray, test_data: np.ndarray, test_labels: np.ndarray, k: int = 3) -> bool: Validate the k-Nearest Neighbors classifier against scikit-learn\'s implementation. Parameters ---------- train_data : np.ndarray Training data points, shape (num_train_samples, num_features). train_labels : np.ndarray Labels for the training data points, shape (num_train_samples,). test_data : np.ndarray Data points to classify, shape (num_test_samples, num_features). test_labels : np.ndarray True labels for the test data points, shape (num_test_samples,). k : int, optional Number of neighbors to use for classification (default is 3). Returns ------- bool True if the classification results from your k-NN implementation match the results from scikit-learn\'s k-NN, within an acceptable error margin. # Custom k-NN classification custom_knn_predictions = knn_classifier(train_data, train_labels, test_data, k) # Sklearn k-NN classification knn = KNeighborsClassifier(n_neighbors=k) knn.fit(train_data, train_labels) sklearn_knn_predictions = knn.predict(test_data) # Validate results return np.array_equal(custom_knn_predictions, sklearn_knn_predictions)"},{"question":"# Scenario You are assigned a task to develop a feature that summarizes transaction data from a financial application. The application handles transactions stored in a list of dictionaries, where each dictionary contains details such as `transaction_id`, `amount`, `type`, and `status`. The goal is to compute a summary of the total amount of successful debit and credit transactions. # Task 1. Implement a function `summarize_transactions` that takes a list of transaction dictionaries and returns a dictionary summarizing the total amounts of successful debit and credit transactions. 2. Write unit tests for your function to ensure it correctly summarizes the transactions. # Requirements **Function Signature**: ```python def summarize_transactions(transactions: list) -> dict: # Your implementation here ``` **Transaction Schema**: ```python # Example of a transaction dictionary transaction = { \\"transaction_id\\": \\"txn_123\\", \\"amount\\": 100.0, \\"type\\": \\"debit\\", # can be either \\"debit\\" or \\"credit\\" \\"status\\": \\"success\\" # can be either \\"success\\" or \\"failure\\" } ``` # Example ```python # Example of return value transactions = [ {\\"transaction_id\\": \\"txn_1\\", \\"amount\\": 100.0, \\"type\\": \\"debit\\", \\"status\\": \\"success\\"}, {\\"transaction_id\\": \\"txn_2\\", \\"amount\\": 200.0, \\"type\\": \\"credit\\", \\"status\\": \\"failure\\"}, {\\"transaction_id\\": \\"txn_3\\", \\"amount\\": 300.0, \\"type\\": \\"credit\\", \\"status\\": \\"success\\"}, {\\"transaction_id\\": \\"txn_4\\", \\"amount\\": 400.0, \\"type\\": \\"debit\\", \\"status\\": \\"success\\"}, ] summarize_transactions(transactions) # Expected output: {\\"total_debit\\": 500.0, \\"total_credit\\": 300.0} ``` # Constraints - Dictionary keys for the result should be `total_debit` and `total_credit`. - Only consider transactions with `status = \\"success\\"`. # Testing - Use standard `unittest` library to create unit tests for the function. - Ensure tests cover various scenarios such as all transaction types, different amounts, and different statuses. # Additional Information - Assume each transaction dictionary is always well-formed with all required keys. - Handle edge cases like an empty list of transactions or none of the transactions being successful.","solution":"def summarize_transactions(transactions: list) -> dict: Summarizes the total amounts of successful debit and credit transactions. Args: - transactions (list): A list of transaction dictionaries. Returns: - dict: A dictionary with the total amounts of successful debit and credit transactions. total_debits = 0.0 total_credits = 0.0 for transaction in transactions: if transaction[\\"status\\"] == \\"success\\": if transaction[\\"type\\"] == \\"debit\\": total_debits += transaction[\\"amount\\"] elif transaction[\\"type\\"] == \\"credit\\": total_credits += transaction[\\"amount\\"] return {\\"total_debit\\": total_debits, \\"total_credit\\": total_credits}"},{"question":"# Problem Statement Create functions to perform matrix determinant calculation and eigenvalue verification. These are fundamental operations in linear algebra with numerous applications in fields such as engineering, physics, and computer science. # Function Definitions 1. `calculate_determinant(matrix: np.ndarray) -> float` - **Input**: A square matrix represented as a 2D numpy array. - **Output**: The determinant of the matrix as a floating-point number. 2. `is_eigenvalue(matrix: np.ndarray, value: float) -> bool` - **Input**: - `matrix`: A square matrix represented as a 2D numpy array. - `value`: A floating-point number. - **Output**: `True` if the value is an eigenvalue of the matrix, `False` otherwise. # Example ```python import numpy as np B = np.array([ [1, 2], [3, 4] ]) assert np.isclose(calculate_determinant(B), -2.0000000000000004) assert is_eigenvalue(B, 5.372281323269014) == False assert is_eigenvalue(B, -0.3722813232690143) == False ``` # Note - Use the assertions and error-handling strategies as specified in the function requirements. - Ensure your functions handle various edge cases such as non-square matrices, singular matrices, and zero matrices. - You can make use of numpy\'s built-in functions to aid in the calculation of determinants and checking for eigenvalues.","solution":"import numpy as np def calculate_determinant(matrix: np.ndarray) -> float: Returns the determinant of the given square matrix. Parameters: matrix (np.ndarray): A square matrix. Returns: float: The determinant of the matrix. if matrix.shape[0] != matrix.shape[1]: raise ValueError(\\"The input must be a square matrix.\\") return np.linalg.det(matrix) def is_eigenvalue(matrix: np.ndarray, value: float) -> bool: Checks if the given value is an eigenvalue of the square matrix. Parameters: matrix (np.ndarray): A square matrix. value (float): A potential eigenvalue. Returns: bool: True if the value is an eigenvalue of the matrix, False otherwise. if matrix.shape[0] != matrix.shape[1]: raise ValueError(\\"The input must be a square matrix.\\") eigenvalues = np.linalg.eigvals(matrix) return np.isclose(eigenvalues, value).any()"},{"question":"Course Scheduling Using Topological Sort You are given a list of course prerequisites represented as pairs of courses, where the second course in the pair is a prerequisite for the first course. Your task is to find an order for taking all the courses such that all prerequisite courses are taken before their dependent courses. Write a function `course_schedule(numCourses: int, prerequisites: list) -> list` that computes the order of courses to be taken. If there are multiple valid course orders, you can return any one of them. If it is impossible to complete all the courses, return an empty list. Input - `numCourses` (int): The total number of courses numbered from 0 to `numCourses - 1`. - `prerequisites` (list): A list of pairs [a, b] where `b` is a prerequisite for `a`. Output - Returns `list`: A list of integers representing the course order. If no valid order exists, return an empty list. Constraints - `1 <= numCourses <= 10^5` - `0 <= len(prerequisites) <= 10^5` - `0 <= a, b < numCourses` Performance Requirements The solution should efficiently compute the course order within the constraints. Examples 1. **Example 1** ```python numCourses = 2 prerequisites = [[1, 0]] print(course_schedule(numCourses, prerequisites)) # Output: [0, 1] ``` 2. **Example 2** ```python numCourses = 4 prerequisites = [[1, 0], [2, 1], [3, 2]] print(course_schedule(numCourses, prerequisites)) # Output: [0, 1, 2, 3] ``` 3. **Example 3** ```python numCourses = 3 prerequisites = [[0, 1], [0, 2], [1, 2]] print(course_schedule(numCourses, prerequisites)) # Output: [2, 1, 0] or [1, 2, 0] ``` 4. **Example 4** ```python numCourses = 2 prerequisites = [[1, 0], [0, 1]] print(course_schedule(numCourses, prerequisites)) # Output: [] ``` Constraints - Use graph algorithms such as Kahn\'s Algorithm or Depth First Search to find the topological order. - Ensure the function handles large inputs efficiently. - Consider edge cases like empty prerequisite lists or cyclic dependencies.","solution":"from collections import deque, defaultdict def course_schedule(numCourses, prerequisites): Returns a possible ordering of courses to satisfy all prerequisites. Args: numCourses (int): The number of courses. prerequisites (list): A list of pairs where the second is a prerequisite of the first. Returns: list: A list of courses in the order that satisfies prerequisites. An empty list if no such ordering exists. # Create adjacency list and indegree counter graph = defaultdict(list) indegree = [0] * numCourses for course, prereq in prerequisites: graph[prereq].append(course) indegree[course] += 1 # Initialize queue with courses having no prerequisites queue = deque([i for i in range(numCourses) if indegree[i] == 0]) result = [] while queue: current = queue.popleft() result.append(current) for neighbor in graph[current]: indegree[neighbor] -= 1 if indegree[neighbor] == 0: queue.append(neighbor) if len(result) == numCourses: return result else: return []"},{"question":"# Problem Statement You are developing a scheduling system for a conference with multiple talks. Each talk has a predefined start time and end time, and your goal is to fit as many talks as possible into the conference schedule, ensuring that no two talks overlap. You want to maximize the number of non-overlapping talks that can be attended. # Requirements: Implement a function `schedule_talks` that takes in: 1. A list of talks, where each talk is represented by a `Talk` namedtuple with attributes `start` and `end`. 2. Optional `key`, a function that takes in a `Talk` and returns a value used for sorting. If `key` is not provided, sort talks by their end time by default. Your function should return the maximum number of non-overlapping talks that can be attended. Constraints: * Each talk is represented by a start and end time, which are positive integers. * Talks can be scheduled back-to-back, but cannot overlap. * Start time is always less than end time. # Function Signature: ```python from typing import List, NamedTuple, Callable class Talk(NamedTuple): start: int end: int def schedule_talks(talks: List[Talk], key: Callable[[Talk], int] = lambda x: x.end) -> int: pass ``` # Example: ```python from typing import NamedTuple, List, Callable class Talk(NamedTuple): start: int end: int def schedule_talks(talks: List[Talk], key: Callable[[Talk], int] = lambda x: x.end) -> int: # Your implementation here # Example Usage talks = [Talk(1, 3), Talk(2, 5), Talk(3, 9), Talk(6, 8)] print(schedule_talks(talks)) # Output: 2 ``` # Additional Examples: ```python talks = [Talk(1, 2), Talk(2, 3), Talk(3, 4)] print(schedule_talks(talks)) # Output: 3 talks = [Talk(1, 3), Talk(2, 4), Talk(3, 5)] print(schedule_talks(talks)) # Output: 2 print(schedule_talks([])) # Output: 0 talks = [Talk(1, 5), Talk(2, 3), Talk(4, 6)] print(schedule_talks(talks)) # Output: 2 ```","solution":"from typing import List, NamedTuple, Callable class Talk(NamedTuple): start: int end: int def schedule_talks(talks: List[Talk], key: Callable[[Talk], int] = lambda x: x.end) -> int: # Sort the talks based on the given key (default is by the end time) sorted_talks = sorted(talks, key=key) max_talks = 0 last_end_time = 0 for talk in sorted_talks: if talk.start >= last_end_time: max_talks += 1 last_end_time = talk.end return max_talks"},{"question":"# Problem: Flight Connection Finder You work for a company that builds an application to find the shortest flight connections between cities. You need to implement a function that calculates the shortest path from a given start city to the target city using Dijkstra\'s algorithm. The cities and available flight connections are represented as an adjacency list. Each entry in the adjacency list contains the city name and a list of tuples where each tuple represents a connection to another city with the associated flight duration. # Function Signature: ```python def find_shortest_path(flights: dict, start: str, target: str) -> int: This function finds the shortest duration path between the start and target cities using Dijkstra\'s algorithm. Args: flights (dict): A dictionary where the keys are city names and the values are lists of tuples. Each tuple contains a destination city name and a flight duration. start (str): The start city name. target (str): The target city name. Returns: int: The duration of the shortest path found from start to target. If no such path exists, return -1. pass ``` # Input: * `flights`: A dictionary where keys are strings representing city names, and values are lists of tuples. Each tuple contains a destination city name (string) and a flight duration (non-negative integer). * `start`: A string representing the starting city name. * `target`: A string representing the target city name. # Constraints: * The number of cities (nodes) will be in the range [2, 100]. * The number of connections (edges) will be in the range [1, 500]. * All flight durations are non-negative integers less than or equal to 1,000. # Output: * An integer representing the duration of the shortest path from the start city to the target city. * If no such path exists, return -1. # Example: ```python flights = { \\"A\\": [(\\"B\\", 1), (\\"C\\", 4)], \\"B\\": [(\\"C\\", 2), (\\"D\\", 5)], \\"C\\": [(\\"D\\", 1)], \\"D\\": [] } start = \\"A\\" target = \\"D\\" duration = find_shortest_path(flights, start, target) print(duration) # Output should be 4, which corresponds to the path A -> B -> C -> D start = \\"A\\" target = \\"E\\" duration = find_shortest_path(flights, start, target) print(duration) # Output should be -1, since there is no path from A to E. ``` # Hints: * Use a priority queue to always expand the shortest duration path. * Keep track of the shortest known duration to each city. * If you reach the target city, the current path duration is the shortest.","solution":"import heapq def find_shortest_path(flights, start, target): This function finds the shortest duration path between the start and target cities using Dijkstra\'s algorithm. Args: flights (dict): A dictionary where the keys are city names and the values are lists of tuples. Each tuple contains a destination city name and a flight duration. start (str): The start city name. target (str): The target city name. Returns: int: The duration of the shortest path found from start to target. If no such path exists, return -1. if start not in flights or target not in flights: return -1 # Priority queue to keep track of cities to explore. Each entry is (current_duration, current_city) pq = [(0, start)] # Dictionary to keep track of the shortest path to each city shortest_paths = {city: float(\'inf\') for city in flights} shortest_paths[start] = 0 while pq: current_duration, current_city = heapq.heappop(pq) if current_city == target: return current_duration if current_duration > shortest_paths[current_city]: continue for neighbor, weight in flights[current_city]: duration = current_duration + weight if duration < shortest_paths[neighbor]: shortest_paths[neighbor] = duration heapq.heappush(pq, (duration, neighbor)) return -1 if shortest_paths[target] == float(\'inf\') else shortest_paths[target]"},{"question":"# Problem Statement: You are tasked with developing a simple inventory system for a small bookstore. The inventory system should allow you to add, remove, and search for books using their unique identifiers (ISBN numbers). Additionally, the system should support bulk operations to add and remove books effectively. # Requirements: 1. **Book Addition**: Implement a method to add a single book to the inventory. Each book is represented as a dictionary containing: * ISBN number (string, unique identifier). * Title (string). * Author (string). * Quantity (integer). 2. **Book Removal**: Implement a method to remove a specified quantity of a book using its ISBN number. If the quantity to be removed exceeds the available quantity, the book should be removed completely. 3. **Book Search**: Implement a method to search for a book by its ISBN number. It should return the book details if found, otherwise return `None`. 4. **Bulk Operations**: Implement methods to handle bulk addition and removal of books. The bulk operations should accept a list of books or removal requests and process them in the same order as they appear in the list. Ensure that the bulk operations support up to 10^5 operations efficiently. # Constraints: * ISBN numbers are unique. * The inventory system can have up to 10^6 books at any given time. * The `quantity` for any book will always be a non-negative integer. # Function Signatures: ```python def add_book(isbn: str, title: str, author: str, quantity: int) -> None: pass def remove_book(isbn: str, quantity: int) -> None: pass def search_book(isbn: str) -> dict: pass def bulk_add_books(books: list[dict]) -> None: pass def bulk_remove_books(removals: list[tuple[str, int]]) -> None: pass ``` # Example: ```python # Example inventory operations: # Add a book add_book(\\"978-3-16-148410-0\\", \\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\", 30) # Remove some quantity of a book remove_book(\\"978-3-16-148410-0\\", 10) # Remaining quantity should be 20 # Search for a book search_book(\\"978-3-16-148410-0\\") # Should return: {\'isbn\': \'978-3-16-148410-0\', \'title\': \'The Great Gatsby\', \'author\': \'F. Scott Fitzgerald\', \'quantity\': 20} # Bulk add books bulk_add_books([ {\\"isbn\\": \\"978-0-14-017739-8\\", \\"title\\": \\"Of Mice and Men\\", \\"author\\": \\"John Steinbeck\\", \\"quantity\\": 50}, {\\"isbn\\": \\"978-0-7432-7356-5\\", \\"title\\": \\"The Da Vinci Code\\", \\"author\\": \\"Dan Brown\\", \\"quantity\\": 40} ]) # Bulk remove books bulk_remove_books([ (\\"978-3-16-148410-0\\", 5), (\\"978-0-14-017739-8\\", 25) ]) # Remaining quantities should be: # {\\"978-3-16-148410-0\\": 15} # {\\"978-0-14-017739-8\\": 25} ``` # Task: Implement the `add_book`, `remove_book`, `search_book`, `bulk_add_books`, and `bulk_remove_books` functions to manage the bookstore\'s inventory as described. Make sure to handle edge cases and validate input thoroughly.","solution":"inventory = {} def add_book(isbn: str, title: str, author: str, quantity: int) -> None: if isbn not in inventory: inventory[isbn] = {\'title\': title, \'author\': author, \'quantity\': quantity} else: inventory[isbn][\'quantity\'] += quantity def remove_book(isbn: str, quantity: int) -> None: if isbn in inventory: if inventory[isbn][\'quantity\'] <= quantity: del inventory[isbn] else: inventory[isbn][\'quantity\'] -= quantity def search_book(isbn: str) -> dict: if isbn in inventory: return { \'isbn\': isbn, \'title\': inventory[isbn][\'title\'], \'author\': inventory[isbn][\'author\'], \'quantity\': inventory[isbn][\'quantity\'] } return None def bulk_add_books(books: list) -> None: for book in books: add_book(book[\'isbn\'], book[\'title\'], book[\'author\'], book[\'quantity\']) def bulk_remove_books(removals: list) -> None: for isbn, quantity in removals: remove_book(isbn, quantity)"},{"question":"# Array Manipulation: Peak Element Finder Context Chris is working on analyzing data sets represented as arrays of integers. One of the tasks involves finding a \\"peak\\" element in these arrays. A peak element is an element that is strictly greater than its neighbors. If the array contains multiple peaks, returning any one of the peaks is acceptable. Understanding how to efficiently locate a peak element can be a valuable skill, especially when dealing with large data sets where performance is crucial. Task Implement a function `find_peak(nums: List[int]) -> int` that finds a peak element in the given list of integers `nums`. Your function should aim to achieve this in logarithmic time complexity, leveraging the properties of the data to optimize the search. Input Format - A list `nums` of integers, where `1 <= len(nums) <= 10^5`. - Each element in `nums` is unique and falls within the range of `-10^9 <= nums[i] <= 10^9`. Output Format - Return the index of any peak element found. Constraints - A peak element is defined as `nums[i]` where `1 <= i <= len(nums) - 2` and `nums[i] > nums[i-1]` and `nums[i] > nums[i+1]`. - If the array has only one element, it is considered a peak. - The array boundary elements can be considered as neighbors (i.e., `nums[0]` and `nums[n-1]` have only one neighbor). Examples ```python assert find_peak([1, 2, 3, 1]) in [2] # nums[2] (value 3) is a peak assert find_peak([1, 2, 1, 3, 5, 6, 4]) in [1, 5] # nums[1] (value 2) or nums[5] (value 6) can be a peak assert find_peak([6]) == 0 # The single element is a peak itself assert find_peak([1, 2, 3, 4, 5, 6, 7, 8, 9]) in [8] # nums[8] (value 9) is a peak as it\'s the end of the list ``` Requirements 1. Implement the `find_peak` function with the specified constraints. 2. Ensure the algorithm operates efficiently within the given constraints, ideally in O(log n) time complexity.","solution":"from typing import List def find_peak(nums: List[int]) -> int: Finds a peak element in the given list of integers. A peak element is an element that is strictly greater than its neighbors. :param nums: List[int] - List of integers where 1 <= len(nums) <= 10^5 and -10^9 <= nums[i] <= 10^9 with all elements being unique. :return: int - Index of any peak element found. left, right = 0, len(nums) - 1 while left < right: mid = (left + right) // 2 if nums[mid] < nums[mid + 1]: left = mid + 1 else: right = mid return left"},{"question":"# Problem Statement You are working on a data processing application that requires managing a collection of records. To optimize queries on the records, you\'ve been asked to implement a function for finding the k-th smallest element in an unsorted list of unique integers. # Task Write a function `find_kth_smallest(nums: List[int], k: int) -> int` that returns the `k`-th smallest element in a given list of unique integers. # Input - `nums`: A list of unique integers ((1 leq len(nums) leq 10^4)) - `k`: An integer ( (1 leq k leq len(nums)) ) # Output - Return the `k`-th smallest element in the list. # Example ```python assert find_kth_smallest([7, 10, 4, 3, 20, 15], 3) == 7 assert find_kth_smallest([1, 2, 3, 4, 5], 2) == 2 assert find_kth_smallest([9, 8, 7, 6, 5], 5) == 9 ``` Constraints - The solution should be efficient, with a preferable time complexity of (O(n log n)) or better. # Note - The list contains unique elements, so there will be no duplicates.","solution":"from typing import List def find_kth_smallest(nums: List[int], k: int) -> int: Returns the k-th smallest element in the list of unique integers. nums.sort() return nums[k - 1]"}]'),F={name:"App",components:{PoemCard:C},data(){return{searchQuery:"",visibleCount:4,poemsData:S,isLoading:!1}},computed:{filteredPoems(){const r=this.searchQuery.trim().toLowerCase();return r?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(r)||e.solution&&e.solution.toLowerCase().includes(r)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(r=>setTimeout(r,1e3)),this.visibleCount+=4,this.isLoading=!1}}},N={class:"search-container"},O={class:"card-container"},R={key:0,class:"empty-state"},L=["disabled"],z={key:0},P={key:1};function D(r,e,l,p,s,a){const m=g("PoemCard");return n(),i("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",N,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),_(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>s.searchQuery=o),placeholder:"Search..."},null,512),[[y,s.searchQuery]]),s.searchQuery?(n(),i("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>s.searchQuery="")}," ✕ ")):u("",!0)]),t("div",O,[(n(!0),i(b,null,v(a.displayedPoems,(o,f)=>(n(),w(m,{key:f,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(n(),i("div",R,' No results found for "'+d(s.searchQuery)+'". ',1)):u("",!0)]),a.hasMorePoems?(n(),i("button",{key:0,class:"load-more-button",disabled:s.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[s.isLoading?(n(),i("span",P,"Loading...")):(n(),i("span",z,"See more"))],8,L)):u("",!0)])}const Y=h(F,[["render",D],["__scopeId","data-v-cbe52dd8"]]),M=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"library/44.md","filePath":"library/44.md"}'),j={name:"library/44.md"},V=Object.assign(j,{setup(r){return(e,l)=>(n(),i("div",null,[x(Y)]))}});export{M as __pageData,V as default};
