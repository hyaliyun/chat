import{_ as m,o as s,c as r,a as t,m as c,t as d,C as h,M as g,U as b,f as l,F as y,p as x,e as v,q as w}from"./chunks/framework.B1z0IdBH.js";const q={name:"PoemCard",props:{poem:{type:Object,required:!0}}},k={class:"poem-container"},T={class:"review"},N={class:"review-title"},L={class:"review-content"};function R(i,e,u,_,n,a){return s(),r("div",k,[t("div",T,[t("div",N,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),c(d(u.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",L,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),c(d(u.poem.solution),1)])])])}const A=m(q,[["render",R],["__scopeId","data-v-6476d2ec"]]),S=JSON.parse(`[{"question":"def product_except_self(nums: List[int]) -> List[int]: Given an array of integers, create another array where each element at index \`i\` is the product of all integers in the input array except the one at \`i\`. >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([1, 0, 3, 4]) [0, 12, 0, 0] >>> product_except_self([-1, -2, -3, -4]) [-24, -12, -8, -6] >>> product_except_self([1, -2, 3, -4]) [24, -12, 8, -6]","solution":"def product_except_self(nums): Returns an array where each element at index \`i\` is the product of all integers in the input array except the one at index \`i\`. n = len(nums) if n == 0: return [] result = [1] * n left_product = 1 right_product = 1 # Calculate left products for each element for i in range(n): result[i] = left_product left_product *= nums[i] # Multiply with right products for each element for i in range(n-1, -1, -1): result[i] *= right_product right_product *= nums[i] return result"},{"question":"from typing import List, Tuple def shortest_path_length(n: int, m: int, edges: List[Tuple[int, int]], s: int, t: int) -> int: Find the shortest path between nodes S and T in an undirected graph. Parameters: n: The number of nodes (1-indexed). m: The number of edges. edges: List of edges where each edge is represented as a tuple (u, v). s: The start node. t: The target node. Returns: length of the shortest path between S and T, or -1 if no path exists. Example: >>> shortest_path_length(5, 6, [(1, 2), (2, 3), (3, 4), (4, 5), (2, 4), (5, 1)], 1, 5) 1 >>> shortest_path_length(4, 2, [(1, 2), (3, 4)], 1, 3) -1","solution":"from collections import deque, defaultdict def shortest_path_length(n, m, edges, s, t): Find the shortest path between nodes S and T in an undirected graph. Parameters: n (int): Number of nodes m (int): Number of edges edges (list[tuple[int, int]]): List of edges represented as tuples (u, v) s (int): Start node t (int): Target node Returns: int: Length of the shortest path between S and T, or -1 if no path exists. if s == t: return 0 # Create adjacency list for the graph graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) # Perform BFS to find the shortest path queue = deque([(s, 0)]) visited = set([s]) while queue: current, distance = queue.popleft() for neighbor in graph[current]: if neighbor == t: return distance + 1 if neighbor not in visited: visited.add(neighbor) queue.append((neighbor, distance + 1)) # If we reach here, there is no path between S and T return -1"},{"question":"def count_unique_chars(s: str) -> int: Returns the count of unique alphabetic characters in the string \`s\`, ignoring case, spaces, and punctuation. >>> count_unique_chars(\\"Hello, World!\\") == 7 >>> count_unique_chars(\\"A\\") == 1 >>> count_unique_chars(\\"AaBbCc!\\") == 3 >>> count_unique_chars(\\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\\") == 26 >>> count_unique_chars(\\"!!!aaaBBBccc???\\") == 3 >>> count_unique_chars(\\" \\") == 0 >>> count_unique_chars(\\"\\") == 0 >>> count_unique_chars(\\"!?,.\\") == 0 >>> count_unique_chars(\\"abc123ABC\\") == 3 >>> max_length_string = \\"aaBBcc\\" * 5333 + \\"d\\" >>> count_unique_chars(max_length_string) == 4","solution":"def count_unique_chars(s): Returns the count of unique alphabetic characters in the string \`s\`, ignoring case, spaces, and punctuation. # Initialize an empty set to store unique characters unique_chars = set() # Iterate through each character in the string for char in s: # Check if the character is an alphabet letter if char.isalpha(): # Convert to lowercase and add to the set unique_chars.add(char.lower()) # Return the size of the set return len(unique_chars)"},{"question":"def curve_scores(scores: List[int], max_score: int) -> None: Adjusts the scores of students based on a curved grading system. Parameters: scores (list of int): List of current scores of students. max_score (int): The maximum possible score in the curved grading system. Returns: None, but mutates the input list 'scores'. >>> scores = [72, 88, 95, 100] >>> max_score = 120 >>> curve_scores(scores, max_score) >>> scores [86, 106, 114, 120] >>> scores = [60, 70, 80, 90, 100] >>> max_score = 200 >>> curve_scores(scores, max_score) >>> scores [120, 140, 160, 180, 200]","solution":"def curve_scores(scores, max_score): Adjusts the scores of students based on a curved grading system. Parameters: scores (list of int): List of current scores of students. max_score (int): The maximum possible score in the curved grading system. Returns: None, but mutates the input list 'scores'. if not scores: return current_max_score = max(scores) # If the maximum provided score is less than or equal to the highest score in the list, # do not change the scores. if max_score <= current_max_score: return # Calculate the proportion factor to adjust the scores factor = max_score / current_max_score # Mutate the input list with the adjusted scores for i in range(len(scores)): scores[i] = round(scores[i] * factor)"},{"question":"import itertools def kth_permutation(s: str, k: int) -> str: Returns the k-th lexicographically smallest permutation of the string s, or an empty string if k exceeds the number of permutations. >>> kth_permutation(\\"abc\\", 3) \\"bac\\" >>> kth_permutation(\\"aabb\\", 16) \\"bbaa\\"","solution":"import itertools def kth_permutation(s, k): Returns the k-th lexicographically smallest permutation of the string s, or an empty string if k exceeds the number of permutations. # Generate all distinct permutations of the string permutations = sorted(set(itertools.permutations(s))) # Check if k is larger than the number of permutations if k > len(permutations): return \\"\\" # Get the k-th permutation and join to form a string kth_perm = ''.join(permutations[k-1]) return kth_perm"},{"question":"def maximum_profit(test_cases): Returns a list of maximum profits for each test case. :param test_cases: list of tuples containing number of days and stock prices :return: list of integers representing the maximum profit for each test case >>> maximum_profit([(6, [7, 1, 5, 3, 6, 4]), (5, [7, 6, 4, 3, 1])]) [5, 0] >>> maximum_profit([(2, [1, 2]), (2, [2, 1])]) [1, 0] def parse_input(input_str): Parse the input string to extract test cases information. :param input_str: string input with test cases information :return: list of tuples containing number of days and stock prices >>> parse_input(\\"2n6n7 1 5 3 6 4n5n7 6 4 3 1n\\") [(6, [7, 1, 5, 3, 6, 4]), (5, [7, 6, 4, 3, 1])] def parse_output(output_list): Parse the output list to formatted string output. :param output_list: list of integers containing the results for each test case :return: formatted string output >>> parse_output([5, 0]) \\"5n0\\"","solution":"def maximum_profit(test_cases): Returns a list of maximum profits for each test case. :param test_cases: list of tuples containing number of days and stock prices :return: list of integers representing the maximum profit for each test case results = [] for n, prices in test_cases: max_profit = 0 min_price = prices[0] for price in prices[1:]: if price < min_price: min_price = price else: potential_profit = price - min_price if potential_profit > max_profit: max_profit = potential_profit results.append(max_profit) return results def parse_input(input_str): Parse the input string to extract test cases information. :param input_str: string input with test cases information :return: list of tuples containing number of days and stock prices lines = input_str.strip().split('n') t = int(lines[0]) test_cases = [] index = 1 for _ in range(t): n = int(lines[index]) prices = list(map(int, lines[index + 1].split())) test_cases.append((n, prices)) index += 2 return test_cases def parse_output(output_list): Parse the output list to formatted string output. :param output_list: list of integers containing the results for each test case :return: formatted string output return \\"n\\".join(map(str, output_list))"},{"question":"def find_pair_with_sum(arr, target): Finds two distinct integers from the list that add up to the target sum. Parameters: arr (list): List of integers. target (int): Target sum. Returns: tuple: Indices of the two numbers whose sum is equal to target. None: If no such pair exists or if input is invalid. >>> find_pair_with_sum([2, 7, 11, 15], 9) (0, 1) >>> find_pair_with_sum([3, 2, 4], 6) (1, 2) >>> find_pair_with_sum([3, 3], 6) (0, 1) >>> find_pair_with_sum(\\"not a list\\", 10) \\"Input is not a list\\" >>> find_pair_with_sum(1234, 10) \\"Input is not a list\\" >>> find_pair_with_sum([1, 2, 3], \\"10\\") \\"Target is not an integer\\" >>> find_pair_with_sum([1, 2, '3'], 5) \\"Input is not a list\\" >>> find_pair_with_sum([0, 0, 0], 0) (0, 1) >>> find_pair_with_sum([1], 2) None >>> find_pair_with_sum([1, 2, 3, 4, 5], 10) None >>> find_pair_with_sum([], 10) None","solution":"def find_pair_with_sum(arr, target): Finds two distinct integers from the list that add up to the target sum. Parameters: arr (list): List of integers. target (int): Target sum. Returns: tuple: Indices of the two numbers whose sum is equal to target. None: If no such pair exists or if input is invalid. if not isinstance(arr, list): return \\"Input is not a list\\" if not all(isinstance(i, int) for i in arr): return \\"Input is not a list\\" if not isinstance(target, int): return \\"Target is not an integer\\" seen = {} for i, num in enumerate(arr): complement = target - num if complement in seen: return (seen[complement], i) seen[num] = i return None"},{"question":"def process_text(text: str) -> Tuple[int, str]: Process a given text to count words and find the most frequent word. >>> process_text(\\"Hello world! Hello Universe.\\") (4, \\"hello\\") >>> process_text(\\"Madam, in Eden, I'm Adam.\\") (5, \\"adam\\") >>> process_text(\\"a a b b c c a a\\") (8, \\"a\\") pass def count_words_find_most_frequent(N: int, texts: List[str]) -> List[str]: For each test case, count words and find the most frequent word. >>> count_words_find_most_frequent(2, [\\"Hello world! Hello Universe.\\", \\"Madam, in Eden, I'm Adam.\\"]) [\\"Case #1: 4 hello\\", \\"Case #2: 5 adam\\"] pass","solution":"import re from collections import Counter def process_text(text): # Convert text to lower case and replace non-words with spaces cleaned_text = re.sub(r'[^a-zA-Zs]', '', text.lower()) # Split the cleaned text into words words = cleaned_text.split() word_count = len(words) # If words list is empty when empty text is passed (we should handle it as special case) if word_count == 0: return (0, \\"\\") # Count the frequency of each word frequency = Counter(words) # Find the most frequent word, in case of tie smallest lexicographically word is selected most_frequent_word = min(frequency, key=lambda word: (-frequency[word], word)) return (word_count, most_frequent_word) def count_words_find_most_frequent(N, texts): results = [] for i in range(N): word_count, most_frequent_word = process_text(texts[i]) results.append(f\\"Case #{i+1}: {word_count} {most_frequent_word}\\") return results"},{"question":"def most_frequent_char(s: str) -> str: Find the most frequent character in the string. In case of a tie, returns the lexicographically smallest one. >>> most_frequent_char(\\"bbaaaccc\\") \\"a\\" >>> most_frequent_char(\\"a\\") \\"a\\" >>> most_frequent_char(\\"abcdefg\\") \\"a\\" >>> most_frequent_char(\\"aabb\\") \\"a\\" >>> most_frequent_char(\\"cccc\\") \\"c\\"","solution":"def most_frequent_char(s): Finds the most frequent character in the string. In case of a tie, returns the lexicographically smallest one. Parameters: s (str): Input string consisting of lowercase English letters. Returns: str: The most frequently occurring character, or the lexicographically smallest one in case of a tie. from collections import Counter # Count the frequencies of the characters in the string frequency = Counter(s) # Sort characters first by negative frequency (for descending order) and then lexicographically most_frequent = sorted(frequency.items(), key=lambda item: (-item[1], item[0])) # return the character with the highest frequency, which is the first element in the sorted list return most_frequent[0][0]"},{"question":"from typing import List def longest_contiguous_sequence(nums: List[int]) -> int: Given a list of integers, find the longest contiguous subsequence of elements that are either strictly increasing or strictly decreasing, and return its length. Note that the elements in the subsequence must follow one of the two orders throughout, either all are increasing or all are decreasing. >>> longest_contiguous_sequence([1, 3, 5, 4, 7]) 3 >>> longest_contiguous_sequence([2, 2, 2, 2, 2]) 1","solution":"from typing import List def longest_contiguous_sequence(nums: List[int]) -> int: if not nums: return 0 longest = 1 current_length = 1 increasing = None for i in range(1, len(nums)): if nums[i] > nums[i - 1]: if increasing is None or increasing: current_length += 1 else: current_length = 2 increasing = True elif nums[i] < nums[i - 1]: if increasing is None or not increasing: current_length += 1 else: current_length = 2 increasing = False else: current_length = 1 increasing = None longest = max(longest, current_length) return longest"},{"question":"def add_large_integers(num1: str, num2: str) -> str: Write a function that takes two strings representing non-negative integers and returns their sum as a string. >>> add_large_integers(\\"123456789123456789\\", \\"987654321987654321\\") \\"1111111111111111110\\" >>> add_large_integers(\\"9876543210\\", \\"1234567890\\") \\"11111111100\\" >>> add_large_integers(\\"0\\", \\"0\\") \\"0\\" >>> add_large_integers(\\"999999999999999999\\", \\"1\\") \\"1000000000000000000\\"","solution":"def add_large_integers(num1: str, num2: str) -> str: # Initialize the result as an empty string result = \\"\\" # Initialize carry to 0 carry = 0 # Pad the shorter string with leading zeros if len(num1) > len(num2): num2 = num2.zfill(len(num1)) else: num1 = num1.zfill(len(num2)) # Traverse both strings from right to left for i in range(len(num1) - 1, -1, -1): # Convert current position characters to integers digit1 = int(num1[i]) digit2 = int(num2[i]) # Sum the digits along with carry total = digit1 + digit2 + carry # If total is at least 10, we have a carry carry = total // 10 # Append the digit part of the total to result result = str(total % 10) + result # If carry is left after the final addition, prepend it to result if carry != 0: result = str(carry) + result return result"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def maxPathSum(root: TreeNode) -> int: Find the maximum path sum in a binary tree. The path can start and end at any node in the tree but must go downwards. >>> root1 = TreeNode(10) >>> root1.left = TreeNode(2) >>> root1.right = TreeNode(10) >>> root1.left.left = TreeNode(20) >>> root1.left.right = TreeNode(1) >>> root1.right.left = TreeNode(-25) >>> root1.right.right = TreeNode(-25) >>> root1.right.left.left = TreeNode(3) >>> root1.right.left.right = TreeNode(4) >>> maxPathSum(root1) # 20 -> 2 -> 10 -> 10 42 >>> root2 = TreeNode(-10) >>> root2.left = TreeNode(9) >>> root2.right = TreeNode(20) >>> root2.right.left = TreeNode(15) >>> root2.right.right = TreeNode(7) >>> maxPathSum(root2) # 15 -> 20 -> 7 42 >>> root3 = TreeNode(1) >>> root3.left = TreeNode(2) >>> root3.right = TreeNode(3) >>> maxPathSum(root3) # 2 -> 1 -> 3 6 >>> root4 = TreeNode(-3) >>> maxPathSum(root4) # just the node itself -3 >>> root5 = None >>> maxPathSum(root5) # handles an empty tree float('-inf')","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def maxPathSum(root): def helper(node): nonlocal max_sum if not node: return 0 left_gain = max(helper(node.left), 0) # only take positive contributions right_gain = max(helper(node.right), 0) # only take positive contributions # the price of the path that passes through this node price_newpath = node.val + left_gain + right_gain # update the maximum sum if price_newpath is better max_sum = max(max_sum, price_newpath) # for recursion, return the maximum gain if continue the same path return node.val + max(left_gain, right_gain) max_sum = float('-inf') helper(root) return max_sum"},{"question":"def longest_green_sequence(N: int, traffic_lights: str) -> int: Returns the length of the longest contiguous sequence of green traffic lights. Parameters: N (int): Number of intersections traffic_lights (str): A string of length N with 'G' for green lights and 'R' for red lights Returns: int: Length of the longest contiguous sequence of green traffic lights >>> longest_green_sequence(10, \\"RRGGRGGGGR\\") == 4 >>> longest_green_sequence(5, \\"GGGGG\\") == 5 >>> longest_green_sequence(6, \\"RRRRRR\\") == 0 >>> longest_green_sequence(1, \\"R\\") == 0 >>> longest_green_sequence(1, \\"G\\") == 1 >>> longest_green_sequence(7, \\"GRGRGRG\\") == 1 >>> longest_green_sequence(8, \\"GGGGGGGG\\") == 8 >>> longest_green_sequence(9, \\"RRRRRRRRR\\") == 0 >>> longest_green_sequence(11, \\"RRRGGGGRGGG\\") == 4 >>> longest_green_sequence(12, \\"GGGGRRGGRRGG\\") == 4","solution":"def longest_green_sequence(N, traffic_lights): Returns the length of the longest contiguous sequence of green traffic lights. Parameters: N (int): Number of intersections traffic_lights (str): A string of length N with 'G' for green lights and 'R' for red lights Returns: int: Length of the longest contiguous sequence of green traffic lights max_length = 0 current_length = 0 for light in traffic_lights: if light == 'G': current_length += 1 if current_length > max_length: max_length = current_length else: current_length = 0 return max_length"},{"question":"def evaluate_median(numbers): Calculates and returns the median of a list of integers. If the list has an odd number of elements, the median is the middle number in the sorted list. If the list has an even number of elements, the median is the average of the two middle numbers. >>> evaluate_median([7, 1, 3, 4, 6, 2, 8]) == 4.0 >>> evaluate_median([10, 2, 3, 6, 8, 11]) == 7.0 >>> evaluate_median([42]) == 42.0 >>> evaluate_median([1, 2, 3, 4, 5]) == 3.0 >>> evaluate_median([1, 2, 3, 4, 5, 6]) == 3.5 >>> evaluate_median([5, 4, 3, 2, 1]) == 3.0 >>> evaluate_median([6, 5, 4, 3, 2, 1]) == 3.5 >>> evaluate_median([1, 2, 2, 2, 3, 4]) == 2.0 >>> evaluate_median([1, 1, 2, 2, 3, 3, 3, 4]) == 2.5 >>> evaluate_median([5, 5, 5, 5, 5]) == 5.0 >>> evaluate_median([3, 3, 3, 3]) == 3.0","solution":"def evaluate_median(numbers): Calculates and returns the median of a list of integers. sorted_numbers = sorted(numbers) n = len(sorted_numbers) mid = n // 2 # Find the middle index if n % 2 == 1: # If odd, return the middle element return float(sorted_numbers[mid]) else: # If even, return the average of the two middle elements return (sorted_numbers[mid - 1] + sorted_numbers[mid]) / 2.0"},{"question":"from typing import List, Tuple def shortest_travel_times(n: int, m: int, roads: List[Tuple[int, int, int]]) -> List[int]: Calculate the shortest travel times from the capital city (city 1) to all other cities in the kingdom. >>> shortest_travel_times(5, 6, [(1, 2, 2), (1, 3, 4), (2, 3, 1), (2, 4, 7), (3, 4, 3), (4, 5, 1)]) [0, 2, 3, 6, 7] >>> shortest_travel_times(3, 0, []) [0, -1, -1] >>> shortest_travel_times(4, 2, [(1, 2, 2), (3, 4, 3)]) [0, 2, -1, -1] >>> shortest_travel_times(1, 0, []) [0] >>> shortest_travel_times(4, 3, [(1, 2, 2), (2, 3, 2), (3, 4, 2)]) [0, 2, 4, 6]","solution":"import heapq def shortest_travel_times(n, m, roads): # Create a graph in the form of adjacency list graph = [[] for _ in range(n + 1)] for u, v, w in roads: graph[u].append((w, v)) graph[v].append((w, u)) # Dijkstra's algorithm def dijkstra(start): dist = [float('inf')] * (n + 1) dist[start] = 0 priority_queue = [(0, start)] while priority_queue: current_dist, u = heapq.heappop(priority_queue) if current_dist > dist[u]: continue for weight, v in graph[u]: distance = current_dist + weight if distance < dist[v]: dist[v] = distance heapq.heappush(priority_queue, (distance, v)) return dist distances = dijkstra(1) # Formatting the output to match the required output format result = [dist if dist != float('inf') else -1 for dist in distances[1:]] return result"},{"question":"def generate_playlist(tracks, desired_genre, max_duration): Constructs the longest possible playlist of tracks within the desired genre and below the specified maximum duration. Args: tracks (list): A list of dictionaries with \`genre\` and \`duration\` keys. desired_genre (str): The desired genre for the playlist. max_duration (int): The maximum duration of the playlist in minutes. Returns: list: A list of tracks that form the playlist. >>> tracks = [ ... {\\"genre\\": \\"rock\\", \\"duration\\": 5}, ... {\\"genre\\": \\"rock\\", \\"duration\\": 3}, ... {\\"genre\\": \\"pop\\", \\"duration\\": 4}, ... {\\"genre\\": \\"rock\\", \\"duration\\": 8}, ... {\\"genre\\": \\"pop\\", \\"duration\\": 2}, ... {\\"genre\\": \\"rock\\", \\"duration\\": 6} ... ] >>> desired_genre = \\"rock\\" >>> max_duration = 10 >>> generate_playlist(tracks, desired_genre, max_duration) [{'genre': 'rock', 'duration': 5}, {'genre': 'rock', 'duration': 3}] >>> tracks = [ ... {\\"genre\\": \\"jazz\\", \\"duration\\": 4}, ... {\\"genre\\": \\"jazz\\", \\"duration\\": 6}, ... {\\"genre\\": \\"jazz\\", \\"duration\\": 9}, ... {\\"genre\\": \\"blues\\", \\"duration\\": 5}, ... {\\"genre\\": \\"jazz\\", \\"duration\\": 7} ... ] >>> desired_genre = \\"jazz\\" >>> max_duration = 12 >>> generate_playlist(tracks, desired_genre, max_duration) [{'genre': 'jazz', 'duration': 6}, {'genre': 'jazz', 'duration': 4}]","solution":"def generate_playlist(tracks, desired_genre, max_duration): Constructs the longest possible playlist of tracks within the desired genre and below the specified maximum duration. Args: tracks (list): A list of dictionaries with \`genre\` and \`duration\` keys. desired_genre (str): The desired genre for the playlist. max_duration (int): The maximum duration of the playlist in minutes. Returns: list: A list of tracks that form the playlist. # Filter tracks by the desired genre genre_tracks = [track for track in tracks if track['genre'] == desired_genre] # Sort tracks by duration in descending order genre_tracks.sort(key=lambda track: track['duration'], reverse=True) # Function to find the best combination def find_best_combination(tracks, max_duration): n = len(tracks) best_duration = 0 best_combination = [] def helper(start, current_duration, current_combination): nonlocal best_duration, best_combination if current_duration > best_duration and current_duration <= max_duration: best_duration = current_duration best_combination = current_combination.copy() for i in range(start, n): if current_duration + tracks[i]['duration'] <= max_duration: current_combination.append(tracks[i]) helper(i + 1, current_duration + tracks[i]['duration'], current_combination) current_combination.pop() helper(0, 0, []) return best_combination return find_best_combination(genre_tracks, max_duration)"},{"question":"class Library: def __init__(self, books_data=None): if books_data is None: books_data = [] self.books = books_data def add_book(self, book_info): Adds a new book to the library. pass def find_books_by_author(self, author): Returns a list of books by the specified author. pass def update_book(self, book_id, field, new_value): Updates the specified field of a book with a given BookID. pass def delete_book(self, book_id): Deletes the book with the specified BookID. pass def get_all_books(self): Returns a list of all books in the library. pass # Sample data books_data = [ {\\"BookID\\": 1, \\"Title\\": \\"To Kill a Mockingbird\\", \\"Author\\": \\"Harper Lee\\", \\"Genre\\": \\"Fiction\\", \\"YearPublished\\": 1960}, {\\"BookID\\": 2, \\"Title\\": \\"1984\\", \\"Author\\": \\"George Orwell\\", \\"Genre\\": \\"Dystopian\\", \\"YearPublished\\": 1949}, {\\"BookID\\": 3, \\"Title\\": \\"The Great Gatsby\\", \\"Author\\": \\"F. Scott Fitzgerald\\", \\"Genre\\": \\"Fiction\\", \\"YearPublished\\": 1925} ] library = Library(books_data) # Adding a new book library.add_book({\\"BookID\\": 4, \\"Title\\": \\"Brave New World\\", \\"Author\\": \\"Aldous Huxley\\", \\"Genre\\": \\"Dystopian\\", \\"YearPublished\\": 1932}) # Finding books by author print(library.find_books_by_author('George Orwell')) # Updating a book's title library.update_book(2, 'Title', 'Nineteen Eighty-Four') # Deleting a book library.delete_book(1) # Getting all books print(library.get_all_books()) [{'BookID': 2, 'Title': '1984', 'Author': 'George Orwell', 'Genre': 'Dystopian', 'YearPublished': 1949}] [{'BookID': 2, 'Title': 'Nineteen Eighty-Four', 'Author': 'George Orwell', 'Genre': 'Dystopian', 'YearPublished': 1949}, {'BookID': 3, 'Title': 'The Great Gatsby', 'Author': 'F. Scott Fitzgerald', 'Genre': 'Fiction', 'YearPublished': 1925}, {'BookID': 4, 'Title': 'Brave New World', 'Author': 'Aldous Huxley', 'Genre': 'Dystopian', 'YearPublished': 1932}] from solution import Library def test_add_book(): library = Library() book_info = {\\"BookID\\": 1, \\"Title\\": \\"To Kill a Mockingbird\\", \\"Author\\": \\"Harper Lee\\", \\"Genre\\": \\"Fiction\\", \\"YearPublished\\": 1960} library.add_book(book_info) assert library.get_all_books() == [book_info] def test_find_books_by_author(): books_data = [ {\\"BookID\\": 1, \\"Title\\": \\"To Kill a Mockingbird\\", \\"Author\\": \\"Harper Lee\\", \\"Genre\\": \\"Fiction\\", \\"YearPublished\\": 1960}, {\\"BookID\\": 2, \\"Title\\": \\"1984\\", \\"Author\\": \\"George Orwell\\", \\"Genre\\": \\"Dystopian\\", \\"YearPublished\\": 1949} ] library = Library(books_data) assert library.find_books_by_author('George Orwell') == [books_data[1]] def test_update_book(): books_data = [ {\\"BookID\\": 1, \\"Title\\": \\"To Kill a Mockingbird\\", \\"Author\\": \\"Harper Lee\\", \\"Genre\\": \\"Fiction\\", \\"YearPublished\\": 1960} ] library = Library(books_data) library.update_book(1, 'Title', 'Go Set a Watchman') assert library.get_all_books()[0]['Title'] == 'Go Set a Watchman' def test_delete_book(): books_data = [ {\\"BookID\\": 1, \\"Title\\": \\"To Kill a Mockingbird\\", \\"Author\\": \\"Harper Lee\\", \\"Genre\\": \\"Fiction\\", \\"YearPublished\\": 1960}, {\\"BookID\\": 2, \\"Title\\": \\"1984\\", \\"Author\\": \\"George Orwell\\", \\"Genre\\": \\"Dystopian\\", \\"YearPublished\\": 1949} ] library = Library(books_data) library.delete_book(1) assert library.get_all_books() == [books_data[1]] def test_get_all_books(): books_data = [ {\\"BookID\\": 1, \\"Title\\": \\"To Kill a Mockingbird\\", \\"Author\\": \\"Harper Lee\\", \\"Genre\\": \\"Fiction\\", \\"YearPublished\\": 1960}, {\\"BookID\\": 2, \\"Title\\": \\"1984\\", \\"Author\\": \\"George Orwell\\", \\"Genre\\": \\"Dystopian\\", \\"YearPublished\\": 1949} ] library = Library(books_data) assert library.get_all_books() == books_data","solution":"class Library: def __init__(self, books_data=None): if books_data is None: books_data = [] self.books = books_data def add_book(self, book_info): Adds a new book to the library. self.books.append(book_info) def find_books_by_author(self, author): Returns a list of books by the specified author. return [book for book in self.books if book[\\"Author\\"] == author] def update_book(self, book_id, field, new_value): Updates the specified field of a book with a given BookID. for book in self.books: if book[\\"BookID\\"] == book_id: if field in book: book[field] = new_value break def delete_book(self, book_id): Deletes the book with the specified BookID. self.books = [book for book in self.books if book[\\"BookID\\"] != book_id] def get_all_books(self): Returns a list of all books in the library. return self.books"},{"question":"def reverseWords(s: str) -> str: Returns a string where the words are in reverse order, but the words themselves are unchanged. Example 1: >>> reverseWords(\\"i.like.this.program.very.much\\") 'much.very.program.this.like.i' Example 2: >>> reverseWords(\\"hello.world\\") 'world.hello' from solution import reverseWords def test_single_word(): assert reverseWords(\\"hello\\") == \\"hello\\" def test_two_words(): assert reverseWords(\\"hello.world\\") == \\"world.hello\\" def test_multiple_words(): assert reverseWords(\\"i.like.this.program.very.much\\") == \\"much.very.program.this.like.i\\" def test_leading_trailing_dot(): assert reverseWords(\\".hello.world.\\") == \\".world.hello.\\" def test_no_dots(): assert reverseWords(\\"hello\\") == \\"hello\\"","solution":"def reverseWords(s): Returns a string where the words are in reverse order, but the words themselves are unchanged. # Split the string into words by '.' words = [] word = \\"\\" for char in s: if char == '.': words.append(word) word = \\"\\" else: word += char words.append(word) # Reverse the list of words reversed_words = [] for i in range(len(words)-1, -1, -1): reversed_words.append(words[i]) # Join the reversed words with '.' reversed_string = \\"\\" for i in range(len(reversed_words)): if i != 0: reversed_string += \\".\\" reversed_string += reversed_words[i] return reversed_string"},{"question":"def process_queries(n, nums, q, queries): Given an integer array nums, process q queries, each having one of the following forms: 1 i v — Replace the i-th element in the array with value v. 2 l r — Find the sum of the elements from the l-th to the r-th indices, inclusive. Args: n (int): The number of elements in the array. nums (List[int]): The elements of the array. q (int): The number of queries to process. queries (List[List[int]]): The list of queries to process. Returns: List[int]: The results of the sum queries. Examples: >>> process_queries(5, [1, 2, 3, 4, 5], 4, [[2, 1, 5], [1, 3, 10], [2, 1, 5], [2, 2, 4]]) [15, 22, 16] >>> process_queries(3, [1, 2, 3], 3, [[1, 2, 5], [2, 1, 3], [2, 2, 3]]) [9, 8] Unit Test: def test_process_queries(): n = 5 nums = [1, 2, 3, 4, 5] q = 4 queries = [ [2, 1, 5], [1, 3, 10], [2, 1, 5], [2, 2, 4] ] expected_output = [15, 22, 16] assert process_queries(n, nums, q, queries) == expected_output def test_process_queries_single_update(): n = 3 nums = [1, 2, 3] q = 3 queries = [ [1, 2, 5], [2, 1, 3], [2, 2, 3] ] expected_output = [9, 8] assert process_queries(n, nums, q, queries) == expected_output def test_process_queries_multiple_updates(): n = 4 nums = [10, 20, 30, 40] q = 5 queries = [ [2, 1, 4], [1, 1, 50], [2, 1, 4], [1, 4, 80], [2, 2, 3] ] expected_output = [100, 140, 50] assert process_queries(n, nums, q, queries) == expected_output def test_process_queries_edge_case(): n = 1 nums = [100] q = 2 queries = [ [2, 1, 1], [1, 1, 200] ] expected_output = [100] assert process_queries(n, nums, q, queries) == expected_output","solution":"def process_queries(n, nums, q, queries): results = [] for query in queries: if query[0] == 1: _, i, v = query nums[i-1] = v elif query[0] == 2: _, l, r = query results.append(sum(nums[l-1:r])) return results # Example usage n = 5 nums = [1, 2, 3, 4, 5] q = 4 queries = [ [2, 1, 5], [1, 3, 10], [2, 1, 5], [2, 2, 4] ] print(process_queries(n, nums, q, queries)) # Output: [15, 22, 16]"},{"question":"def longest_common_subsequence_length(X_str: str, Y_str: str) -> int: Determine the longest common subsequence (LCS) of the stock prices for the two companies. Args: X_str (str): space-separated integers representing the stock prices of the first company. Y_str (str): space-separated integers representing the stock prices of the second company. Returns: int: the length of the LCS of the stock prices for the two companies. Example: >>> longest_common_subsequence_length(\\"1 3 4 1 2 1 5\\", \\"3 4 1 2 1 3\\") 5 >>> longest_common_subsequence_length(\\"7 8 9 10\\", \\"1 2 3 4\\") 0 from solution import longest_common_subsequence_length def test_lcs_length_example_1(): assert longest_common_subsequence_length(\\"1 3 4 1 2 1 5\\", \\"3 4 1 2 1 3\\") == 5 def test_lcs_length_example_2(): assert longest_common_subsequence_length(\\"7 8 9 10\\", \\"1 2 3 4\\") == 0 def test_lcs_length_different_lengths(): assert longest_common_subsequence_length(\\"1 2 3\\", \\"2 1 3\\") == 2 def test_lcs_length_no_common_elements(): assert longest_common_subsequence_length(\\"1 2 3\\", \\"4 5 6\\") == 0 def test_lcs_length_identical_sequences(): assert longest_common_subsequence_length(\\"1 2 3 4\\", \\"1 2 3 4\\") == 4 def test_lcs_length_single_element(): assert longest_common_subsequence_length(\\"5\\", \\"5\\") == 1 assert longest_common_subsequence_length(\\"5\\", \\"6\\") == 0 def test_lcs_length_large_input(): X = \\" \\".join(map(str, range(1, 1001))) Y = \\" \\".join(map(str, range(501, 1501))) assert longest_common_subsequence_length(X, Y) == 500","solution":"def lcs_length(X, Y): Returns the length of the longest common subsequence (LCS) of two sequences. m = len(X) n = len(Y) # Create a 2D array to store the lengths of longest common subsequence. L = [[0 for j in range(n+1)] for i in range(m+1)] # Following steps build L[m+1][n+1] in bottom up fashion. Note that L[i][j] # contains length of LCS of X[0..i-1] and Y[0..j-1] for i in range(m+1): for j in range(n+1): if i == 0 or j == 0: L[i][j] = 0 elif X[i-1] == Y[j-1]: L[i][j] = L[i-1][j-1] + 1 else: L[i][j] = max(L[i-1][j], L[i][j-1]) # L[m][n] contains the length of LCS for X[0..m-1] and Y[0..n-1] return L[m][n] def longest_common_subsequence_length(X_str, Y_str): Given two space-separated strings of integers, return the length of their longest common subsequence. X = list(map(int, X_str.split())) Y = list(map(int, Y_str.split())) return lcs_length(X, Y)"},{"question":"def longest_simple_cycle(n, m, edges): Determine the length of the longest simple cycle in the graph. The input consists of: - n: An integer representing the number of points in the park. - m: An integer representing the number of trails. - edges: A list of m pairs of integers (u, v) indicating a trail between points u and v. >>> longest_simple_cycle(5, 6, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 1), (2, 5)]) 5 >>> longest_simple_cycle(4, 2, [(1, 2), (3, 4)]) 0 def test_longest_simple_cycle_example1(): n = 5 m = 6 edges = [ (1, 2), (2, 3), (3, 4), (4, 5), (5, 1), (2, 5) ] assert longest_simple_cycle(n, m, edges) == 5 def test_longest_simple_cycle_example2(): n = 4 m = 2 edges = [ (1, 2), (3, 4) ] assert longest_simple_cycle(n, m, edges) == 0 def test_cycle_with_single_connection(): n = 3 m = 3 edges = [ (1, 2), (2, 3), (3, 1) ] assert longest_simple_cycle(n, m, edges) == 3 def test_two_disconnected_cycles(): n = 6 m = 6 edges = [ (1, 2), (2, 3), (3, 1), (4, 5), (5, 6), (6, 4) ] assert longest_simple_cycle(n, m, edges) == 3 def test_parallel_edges(): n = 4 m = 6 edges = [ (1, 2), (1, 2), (2, 3), (3, 4), (4, 1), (4, 1) ] assert longest_simple_cycle(n, m, edges) == 4","solution":"def longest_simple_cycle(n, m, edges): from collections import defaultdict, deque graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) def dfs(node, parent, depth, visited): visited[node] = depth max_length = 0 if node in cycle_length: return cycle_length[node] for neighbor in graph[node]: if neighbor == parent: continue if neighbor in visited: if visited[neighbor] < visited[node]: # a back edge forming a cycle max_length = max(max_length, visited[node] - visited[neighbor] + 1) else: length = dfs(neighbor, node, depth + 1, visited) max_length = max(max_length, length) visited.pop(node) cycle_length[node] = max_length return max_length cycle_length = {} longest_cycle = 0 for i in range(1, n+1): if i not in cycle_length: visited = {} longest_cycle = max(longest_cycle, dfs(i, -1, 1, visited)) return longest_cycle"},{"question":"from typing import List, Tuple def can_convert(s: str, t: str) -> str: Determines if string s can be converted to string t by replacing any character in s with another character that has the same frequency in t. >>> can_convert(\\"aabbcc\\", \\"ccbbaa\\") \\"YES\\" >>> can_convert(\\"abcd\\", \\"dcab\\") \\"YES\\" >>> can_convert(\\"xyz\\", \\"yxz\\") \\"YES\\" pass def process_test_cases(n: int, test_cases: List[Tuple[str, str]]) -> List[str]: Processes multiple test cases to determine if each pair of strings s and t can be converted. >>> process_test_cases(3, [(\\"aabbcc\\", \\"ccbbaa\\"), (\\"abcd\\", \\"dcab\\"), (\\"xyz\\", \\"yxz\\")]) [\\"YES\\", \\"YES\\", \\"YES\\"] pass","solution":"from collections import Counter def can_convert(s, t): Determines if string s can be converted to string t by replacing any character in s with another character that has the same frequency in t. if Counter(s) == Counter(t): return \\"YES\\" return \\"NO\\" def process_test_cases(n, test_cases): results = [] for s, t in test_cases: results.append(can_convert(s, t)) return results"},{"question":"def find_unique_element(arr): Returns the unique element that appears only once in the array \`arr\`. Each element in \`arr\` appears twice except one unique element that appears only once. Uses bitwise XOR operation to find the unique element. >>> find_unique_element([2, 3, 4, 2, 3]) 4 >>> find_unique_element([7, 8, 7, 10, 8, 12, 10]) 12 >>> find_unique_element([1]) 1 >>> find_unique_element([1, 1, 2, 3, 2]) 3 >>> find_unique_element([12345, 54321, 12345, 67890, 54321]) 67890","solution":"def find_unique_element(arr): Returns the unique element that appears only once in the array \`arr\`. Each element in \`arr\` appears twice except one unique element that appears only once. Uses bitwise XOR operation to find the unique element. unique_element = 0 for num in arr: unique_element ^= num return unique_element"},{"question":"from typing import List def process_messages(N: int, messages: List[str]) -> List[int]: Handle the send and query messages between servers to track the total volume of messages exchanged between any two servers over a certain period. Args: N (int): The number of messages to process. messages (List[str]): The list of messages, each being either a send message or a query message. Returns: List[int]: The list of results for each query message, representing the total volume of messages exchanged. Example: >>> process_messages(5, [\\"S 2 3 10\\", \\"S 3 2 5\\", \\"S 4 5 20\\", \\"Q 2 3\\", \\"Q 4 5\\"]) [15, 20]","solution":"def process_messages(N, messages): from collections import defaultdict # This will store the message volume between servers message_volume = defaultdict(int) output = [] for message in messages: parts = message.split() if parts[0] == 'S': # Sending message: S s1 s2 V s1, s2, V = int(parts[1]), int(parts[2]), int(parts[3]) # Sort the servers to ensure undirected relationship tracking if s1 > s2: s1, s2 = s2, s1 message_volume[(s1, s2)] += V elif parts[0] == 'Q': # Querying message: Q s1 s2 s1, s2 = int(parts[1]), int(parts[2]) # Sort the servers to ensure undirected relationship tracking if s1 > s2: s1, s2 = s2, s1 output.append(message_volume[(s1, s2)]) return output"},{"question":"def length_of_shortest_substring_with_all_unique_chars(s: str) -> int: Find the length of the shortest substring that contains all unique characters in the original string. >>> length_of_shortest_substring_with_all_unique_chars('abcaabc') 3 >>> length_of_shortest_substring_with_all_unique_chars('aabcabcabc') 3 >>> length_of_shortest_substring_with_all_unique_chars('aaaaa') 1","solution":"def length_of_shortest_substring_with_all_unique_chars(s): from collections import defaultdict unique_chars = set(s) n = len(s) if len(unique_chars) == n: return n required_chars_count = len(unique_chars) char_counts = defaultdict(int) formed = 0 left = 0 min_length = float(\\"inf\\") for right in range(n): char_counts[s[right]] += 1 if char_counts[s[right]] == 1: formed += 1 while formed == required_chars_count: min_length = min(min_length, right - left + 1) char_counts[s[left]] -= 1 if char_counts[s[left]] == 0: formed -= 1 left += 1 return min_length"},{"question":"def max_gadgets_in_budget(T, test_cases): Determine the maximum number of different types of gadgets that can be included in the bundle within the budget for each test case. If it is not possible to include any gadget within the budget, return \\"Not Possible\\". Args: T (int): Number of test cases test_cases (list): A list of tuples, where each tuple contains: - A tuple with two integers, N and B - A list of integers representing the cost of each type of gadget Returns: list: A list of integers or strings ('Not Possible') representing the result for each test case Examples: >>> max_gadgets_in_budget(2, [((4, 50), [10, 20, 30, 40]), ((3, 15), [5, 10, 20])]) [2, 2] >>> max_gadgets_in_budget(1, [((3, 5), [10, 20, 30])]) ['Not Possible']","solution":"def max_gadgets_in_budget(T, test_cases): Returns the maximum number of different types of gadgets that can be included in the bundle within the budget for each test case. results = [] for i in range(T): N, B = test_cases[i][0] costs = sorted(test_cases[i][1]) count = 0 total_cost = 0 for cost in costs: if total_cost + cost <= B: total_cost += cost count += 1 else: break if count == 0: results.append(\\"Not Possible\\") else: results.append(count) return results"},{"question":"def sum_of_digits(s: str) -> int: Returns the sum of the digits in the given string. If there are no digits, returns 0. >>> sum_of_digits(\\"a1b2c3\\") 6 >>> sum_of_digits(\\"abc123xyz\\") 6 >>> sum_of_digits(\\"abcdefghijkl\\") 0","solution":"def sum_of_digits(s): Returns the sum of the digits in the given string. If there are no digits, returns 0. total_sum = 0 for char in s: if char.isdigit(): total_sum += int(char) return total_sum"},{"question":"def countWays(coins, n): Returns the number of ways to make up amount n using given coin denominations. Parameters: coins (list of int): List of coin denominations. n (int): Target amount. Returns: int: Number of ways to make up the target amount. >>> countWays([1, 2, 3], 4) == 4 >>> countWays([2, 5, 3, 6], 10) == 5 >>> countWays([2], 3) == 0 >>> countWays([2], 4) == 1 >>> countWays([1], 1000) == 1 >>> countWays([1, 2, 5], 5) == 4 >>> countWays([1, 2, 3], 0) == 1 >>> countWays([5, 7], 1) == 0 >>> countWays([2, 5], 3) == 0","solution":"def countWays(coins, n): Returns the number of ways to make up amount n using given coin denominations. Parameters: coins (list of int): List of coin denominations. n (int): Target amount. Returns: int: Number of ways to make up the target amount. dp = [0] * (n + 1) dp[0] = 1 for coin in coins: for amount in range(coin, n + 1): dp[amount] += dp[amount - coin] return dp[n]"},{"question":"def process_test_cases(T: int, test_cases: List[Tuple[int, int, List[Tuple[int, int]]]]) -> List[int]: Finds the size of the largest loop (cycle) in a series of undirected, unweighted graphs. Args: T (int): Number of test cases. test_cases (List[Tuple[int, int, List[Tuple[int, int]]]]): A list where each element is a tuple containing: - the number of nodes (int) - the number of edges (int) - a list of tuples (each containing two integers) representing the edges Returns: List[int]: A list of integers where each element is the size of the largest loop in the corresponding graph. If no loop exists, it should return -1 for that graph. >>> process_test_cases(2, [(4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]), (3, 2, [(1, 2), (2, 3)])]) [4, -1] >>> process_test_cases(1, [(3, 0, [])]) [-1]","solution":"from collections import defaultdict def find_largest_cycle(n, edges): def dfs(node, parent, depth): visited[node] = depth for neighbor in graph[node]: if neighbor == parent: continue if visited[neighbor] == -1: if dfs(neighbor, node, depth + 1): return True elif visited[neighbor] < depth: global max_cycle_length max_cycle_length = max(max_cycle_length, depth - visited[neighbor] + 1) return True return False graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) visited = [-1] * (n + 1) global max_cycle_length max_cycle_length = -1 for i in range(1, n + 1): if visited[i] == -1: dfs(i, -1, 0) return max_cycle_length def process_test_cases(T, test_cases): results = [] for tc in test_cases: N, M, edges = tc if M == 0: results.append(-1) else: results.append(find_largest_cycle(N, edges)) return results # Example test cases execution (to be removed or commented when running actual unit tests) if __name__ == \\"__main__\\": T = 2 test_cases = [ (4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]), (3, 2, [(1, 2), (2, 3)]) ] results = process_test_cases(T, test_cases) for result in results: print(result)"},{"question":"def intersection(nums1: List[int], nums2: List[int]) -> List[int]: Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must be unique, and the result can be in any order. >>> intersection([1, 2, 2, 1], [2, 2]) [2] >>> intersection([4, 9, 5], [9, 4, 9, 8, 4]) [9, 4] >>> intersection([1, 2, 3], [4, 5, 6]) [] >>> intersection([-1, -2, -3, 3], [3, -2, 4]) [-2, 3] >>> intersection([1, 2, 3], [1, 2, 3]) [1, 2, 3] >>> intersection([], [1, 2, 3]) [] >>> intersection([1, 2, 3], []) [] >>> intersection([], []) []","solution":"def intersection(nums1, nums2): Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must be unique, and the result can be in any order. # Convert the lists to sets to remove duplicates and use set intersection set1 = set(nums1) set2 = set(nums2) # Compute the intersection of the two sets intersect_set = set1 & set2 # Convert the resultant set back to a sorted list result = list(intersect_set) return result"},{"question":"def largest_square_side_length(stars): Determines the side length of the largest square that can be formed with the stars. The sides of the square must be parallel to the coordinate axes. :param stars: List of tuples, each containing x and y coordinates of a star :return: Integer representing the largest side length of the square >>> largest_square_side_length([(0, 0), (1, 1), (2, 2), (3, 3)]) == 0 >>> largest_square_side_length([(1, 1), (1, 4), (4, 1), (4, 4), (2, 2), (3, 3)]) == 3 >>> largest_square_side_length([(0, 0), (0, 1), (1, 0), (1, 1)]) == 1 >>> largest_square_side_length([(0, 0), (0, 2), (2, 0), (2, 2), (3, 3), (5, 5), (5, 7), (7, 5), (7, 7)]) == 2 >>> largest_square_side_length([(1000, 1000), (1000, 2000), (2000, 1000), (2000, 2000), (3000, 3000), (3000, 4000), (4000, 3000), (4000, 4000)]) == 1000 >>> largest_square_side_length([(1, 1), (2, 2), (3, 3), (4, 4), (5, 5)]) == 0","solution":"def largest_square_side_length(stars): Determines the side length of the largest square that can be formed with the stars. The sides of the square must be parallel to the coordinate axes. :param stars: List of tuples, each containing x and y coordinates of a star :return: Integer representing the largest side length of the square star_set = set(stars) max_side_length = 0 for i in range(len(stars)): for j in range(i + 1, len(stars)): x1, y1 = stars[i] x2, y2 = stars[j] if x1 != x2 and y1 != y2: if (x1, y2) in star_set and (x2, y1) in star_set: side_length = abs(x2 - x1) max_side_length = max(max_side_length, side_length) return max_side_length"},{"question":"def minimal_travel_distance(T: int, cases: List[Tuple[int, List[int]]]) -> List[int]: Given number of test cases and each test case containing the number of street lamps and their distances, compute the minimal total travel distance for maintenance vehicles. >>> minimal_travel_distance(3, [(3, [3, 6, 4]), (4, [5, 8, 2, 6]), (2, [10, 3])]) [26, 42, 26] >>> minimal_travel_distance(2, [(5, [1, 2, 3, 4, 5]), (3, [7, 8, 9])]) [30, 48] pass def test_minimal_travel_distance(): # Preparing input cases T = 3 cases = [ (3, [3, 6, 4]), (4, [5, 8, 2, 6]), (2, [10, 3]) ] expected = [26, 42, 26] assert minimal_travel_distance(T, cases) == expected T = 2 cases = [ (5, [1, 2, 3, 4, 5]), (3, [7, 8, 9]) ] expected = [30, 48] assert minimal_travel_distance(T, cases) == expected T = 1 cases = [ (1, [42]) ] expected = [84] assert minimal_travel_distance(T, cases) == expected","solution":"def minimal_travel_distance(T, cases): results = [] for i in range(T): N = cases[i][0] distances = sorted(cases[i][1]) # Distance computation using optimal placement total_distance = 0 for lamp_distance in distances: total_distance += 2 * lamp_distance results.append(total_distance) return results"},{"question":"class ListNode: def __init__(self, x): self.val = x self.next = None def mergeKLists(lists): Merges k sorted linked-lists into one sorted linked-list. import pytest def list_to_linkedlist(lst): Helper function to convert list to linked-list dummy = ListNode(0) current = dummy for val in lst: current.next = ListNode(val) current = current.next return dummy.next def linkedlist_to_list(node): Helper function to convert linked-list to list result = [] while node: result.append(node.val) node = node.next return result def test_mergeKLists_case1(): lists = [ list_to_linkedlist([1, 4, 5]), list_to_linkedlist([1, 3, 4]), list_to_linkedlist([2, 6]) ] merged_head = mergeKLists(lists) result = linkedlist_to_list(merged_head) assert result == [1, 1, 2, 3, 4, 4, 5, 6] def test_mergeKLists_case2(): lists = [] merged_head = mergeKLists(lists) result = linkedlist_to_list(merged_head) assert result == [] def test_mergeKLists_case3(): lists = [list_to_linkedlist([])] merged_head = mergeKLists(lists) result = linkedlist_to_list(merged_head) assert result == [] def test_mergeKLists_all_empty(): lists = [list_to_linkedlist([]), list_to_linkedlist([])] merged_head = mergeKLists(lists) result = linkedlist_to_list(merged_head) assert result == [] def test_mergeKLists_single_list(): lists = [list_to_linkedlist([5, 10, 15])] merged_head = mergeKLists(lists) result = linkedlist_to_list(merged_head) assert result == [5, 10, 15]","solution":"from heapq import heappop, heappush class ListNode: def __init__(self, x): self.val = x self.next = None def mergeKLists(lists): Merges k sorted linked-lists into one sorted linked-list. heap = [] # Push initial nodes of each list into the heap for i in range(len(lists)): if lists[i]: heappush(heap, (lists[i].val, i, lists[i])) dummy = ListNode(0) current = dummy while heap: val, list_index, node = heappop(heap) current.next = node current = current.next if node.next: heappush(heap, (node.next.val, list_index, node.next)) return dummy.next"},{"question":"def is_palindrome_permutation_possible(s: str) -> str: Returns \\"YES\\" if it is possible to rearrange the characters of the string s to form a palindrome, and \\"NO\\" otherwise. >>> is_palindrome_permutation_possible(\\"aabb\\") \\"YES\\" >>> is_palindrome_permutation_possible(\\"abc\\") \\"NO\\" >>> is_palindrome_permutation_possible(\\"racecar\\") \\"YES\\" def check_palindrome_permutations(T: int, strings: List[str]) -> List[str]: Given T number of strings, returns a list of \\"YES\\" or \\"NO\\" indicating if each string can be rearranged into a palindrome. >>> check_palindrome_permutations(3, [\\"aabb\\", \\"abc\\", \\"racecar\\"]) [\\"YES\\", \\"NO\\", \\"YES\\"] >>> check_palindrome_permutations(2, [\\"abcd\\", \\"aabbcc\\"]) [\\"NO\\", \\"YES\\"]","solution":"def is_palindrome_permutation_possible(s): Returns \\"YES\\" if it is possible to rearrange the characters of the string s to form a palindrome, and \\"NO\\" otherwise. from collections import Counter char_count = Counter(s) odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # For a string to be rearranged as a palindrome: # There can be at most one character with an odd count. return \\"YES\\" if odd_count <= 1 else \\"NO\\" def check_palindrome_permutations(T, strings): Given T number of strings, returns a list of \\"YES\\" or \\"NO\\" indicating if each string can be rearranged into a palindrome. return [is_palindrome_permutation_possible(s) for s in strings]"},{"question":"def can_form_palindrome(s: str) -> bool: Checks if the given string can be rearranged to form a palindrome. >>> can_form_palindrome(\\"aabb\\") == True >>> can_form_palindrome(\\"abc\\") == False >>> can_form_palindrome(\\"aab\\") == True pass def solve_riddle(cases: List[str]) -> List[str]: Determines if each string in the given list of cases can be rearranged to form a palindrome. >>> solve_riddle([\\"aabb\\", \\"abc\\", \\"aab\\"]) == [\\"YES\\", \\"NO\\", \\"YES\\"] >>> solve_riddle([\\"abcdef\\", \\"aabbcc\\", \\"aabbccd\\"]) == [\\"NO\\", \\"YES\\", \\"YES\\"] >>> solve_riddle([\\"x\\", \\"yy\\", \\"zzz\\", \\"xy\\"]) == [\\"YES\\", \\"YES\\", \\"YES\\", \\"NO\\"] >>> solve_riddle([\\"racecar\\", \\"civic\\", \\"deified\\", \\"level\\", \\"rotator\\"]) == [\\"YES\\", \\"YES\\", \\"YES\\", \\"YES\\", \\"YES\\"] pass","solution":"def can_form_palindrome(s): Checks if the given string can be rearranged to form a palindrome. from collections import Counter # Count the frequency of each character in the string count = Counter(s) # Check the number of characters that have an odd count odd_count = sum(1 for v in count.values() if v % 2 != 0) # A string can form a palindrome if it has at most one odd character count return odd_count <= 1 def solve_riddle(cases): Determines if each string in the given list of cases can be rearranged to form a palindrome. results = [] for s in cases: if can_form_palindrome(s): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def packContainers(weights: List[int], maxWeight: int) -> int: Determines the minimum number of containers needed to pack all items. Parameters: weights (list): A list of item weights. maxWeight (int): The maximum weight a container can hold. Returns: int: The minimum number of containers needed. >>> packContainers([5, 8, 1, 7, 4, 6], 10) 4 >>> packContainers([1, 1, 1, 1], 2) 2 >>> packContainers([10], 10) 1 >>> packContainers([2, 2, 2, 2], 10) 1 >>> packContainers([10, 10, 10, 10], 10) 4 >>> packContainers([1, 2, 3, 4, 5, 6, 7, 8, 9], 10) 5 >>> packContainers([1000, 1000, 1000], 1000) 3","solution":"def packContainers(weights, maxWeight): Determines the minimum number of containers needed to pack all items. Parameters: weights (list): A list of item weights. maxWeight (int): The maximum weight a container can hold. Returns: int: The minimum number of containers needed. weights.sort(reverse=True) # Sort the weights in descending order containers = [] for weight in weights: placed = False for i in range(len(containers)): if containers[i] + weight <= maxWeight: containers[i] += weight placed = True break if not placed: containers.append(weight) return len(containers)"},{"question":"def min_steps_to_convert(s1: str, s2: str) -> int: Write a function that determines the minimum number of steps required to convert a given string \`s1\` into another string \`s2\` using the following operations: 1. Insert a character 2. Remove a character 3. Replace a character The order of characters must be preserved in these operations. Args: s1 (str): The first string. s2 (str): The second string. Returns: int: The minimum number of steps required to transform \`s1\` into \`s2\`. Examples: >>> min_steps_to_convert(\\"cat\\", \\"cut\\") 1 >>> min_steps_to_convert(\\"sunday\\", \\"saturday\\") 3 def test_min_steps_to_convert(): assert min_steps_to_convert(\\"cat\\", \\"cut\\") == 1 assert min_steps_to_convert(\\"sunday\\", \\"saturday\\") == 3 assert min_steps_to_convert(\\"geek\\", \\"gesek\\") == 1 assert min_steps_to_convert(\\"intention\\", \\"execution\\") == 5 assert min_steps_to_convert(\\"\\", \\"\\") == 0 assert min_steps_to_convert(\\"a\\", \\"\\") == 1 assert min_steps_to_convert(\\"\\", \\"a\\") == 1 assert min_steps_to_convert(\\"abc\\", \\"def\\") == 3 assert min_steps_to_convert(\\"kitten\\", \\"sitting\\") == 3 test_min_steps_to_convert()","solution":"def min_steps_to_convert(s1, s2): Returns the minimum number of steps required to convert string s1 to string s2. The possible operations are insert, remove, replace a character. m = len(s1) n = len(s2) # Create a 2D array to store the number of operations required dp = [[0] * (n + 1) for _ in range(m + 1)] # Initialize the dp array for i in range(m + 1): for j in range(n + 1): if i == 0: dp[i][j] = j # If s1 is empty, we need to insert all characters of s2 elif j == 0: dp[i][j] = i # If s2 is empty, we need to remove all characters of s1 elif s1[i-1] == s2[j-1]: dp[i][j] = dp[i-1][j-1] # If last characters are same, ignore them else: dp[i][j] = 1 + min(dp[i-1][j], # Remove character from s1 dp[i][j-1], # Insert character to s1 dp[i-1][j-1]) # Replace character in s1 return dp[m][n]"},{"question":"def select_optimal_city(test_cases): Select the optimal delivery city that minimizes the total distance to all other cities. Args: test_cases (list): A list of test cases. Each test case is a tuple containing the number of cities, a list of city names, and a matrix of pairwise distances. Returns: list: A list of optimal cities for each test case. >>> test_cases = [(3, [\\"city1\\", \\"city2\\", \\"city3\\"], [[0, 10, 15], [10, 0, 20], [15, 20, 0]]), (4, [\\"alpha\\", \\"beta\\", \\"gamma\\", \\"delta\\"], [[0, 5, 10, 15], [5, 0, 6, 8], [10, 6, 0, 7], [15, 8, 7, 0]])] >>> select_optimal_city(test_cases) [\\"city1\\", \\"beta\\"] def parse_input(input_str): Parse the input string into a structured format of test cases. Args: input_str (str): The input string containing test cases. Returns: list: A list of test cases. # Unit tests for the select_optimal_city and parse_input functions def test_select_optimal_city(): input_str = \\"2n3ncity1 0 10 15ncity2 10 0 20ncity3 15 20 0n4nalpha 0 5 10 15nbeta 5 0 6 8ngamma 10 6 0 7ndelta 15 8 7 0n\\" test_cases = parse_input(input_str) results = select_optimal_city(test_cases) assert results == [\\"city1\\", \\"beta\\"], f\\"Unexpected results: {results}\\" def test_single_test_case(): input_str = \\"1n3ncity1 0 2 2ncity2 2 0 2ncity3 2 2 0n\\" test_cases = parse_input(input_str) results = select_optimal_city(test_cases) assert results == [\\"city1\\"], f\\"Unexpected results: {results}\\" def test_lexicographical_order(): input_str = \\"1n3nbeta 0 1 2nalpha 1 0 2ngamma 2 2 0n\\" test_cases = parse_input(input_str) results = select_optimal_city(test_cases) assert results == [\\"alpha\\"], f\\"Unexpected results: {results}\\" def test_all_same_distances(): input_str = \\"1n3ncity1 0 1 1ncity2 1 0 1ncity3 1 1 0n\\" test_cases = parse_input(input_str) results = select_optimal_city(test_cases) assert results == [\\"city1\\"], f\\"Unexpected results: {results}\\"","solution":"def select_optimal_city(test_cases): results = [] for test_case in test_cases: n = test_case[0] cities = test_case[1] city_distances = test_case[2] optimal_city = None min_total_distance = float('inf') for i in range(n): total_distance = sum(city_distances[i]) if total_distance < min_total_distance: min_total_distance = total_distance optimal_city = cities[i] elif total_distance == min_total_distance: if cities[i] < optimal_city: optimal_city = cities[i] results.append(optimal_city) return results def parse_input(input_str): input_lines = input_str.strip().split('n') T = int(input_lines[0]) idx = 1 test_cases = [] for _ in range(T): N = int(input_lines[idx]) idx += 1 cities = [] distances = [] for _ in range(N): parts = input_lines[idx].split() cities.append(parts[0]) distances.append(list(map(int, parts[1:]))) idx += 1 test_cases.append((N, cities, distances)) return test_cases"},{"question":"def min_operations_to_clear_grid(n_cases: int, cases: List[Tuple[int, int, List[str]]]) -> List[int]: Determine the minimum number of operations required to turn the entire grid into empty cells. >>> min_operations_to_clear_grid(2, [(3, 4, [\\"AAAA\\", \\"BBBB\\", \\"CCCC\\"]), (2, 2, [\\"AB\\", \\"BA\\"])]) [3, 2] >>> min_operations_to_clear_grid(1, [(3, 3, [\\"AAA\\", \\"AAA\\", \\"AAA\\"])]) [1] >>> min_operations_to_clear_grid(1, [(3, 3, [\\"ABC\\", \\"BCA\\", \\"CAB\\"])]) [3] >>> min_operations_to_clear_grid(1, [(2, 2, [\\"AA\\", \\"AA\\"])]) [1] >>> min_operations_to_clear_grid(1, [(4, 4, [\\"ABCD\\", \\"EFGH\\", \\"IJKL\\", \\"MNOP\\"])]) [16]","solution":"def min_operations_to_clear_grid(n_cases, cases): results = [] for case in cases: n, m, grid = case seen_letters = set() for row in grid: seen_letters.update(row) results.append(len(seen_letters)) return results"},{"question":"def reverse_words_characters(s: str) -> str: Reverses the characters in each word of the input string while preserving the word order and spaces between them. Args: s: A string containing words separated by spaces. Returns: A string with characters in each word reversed. >>> reverse_words_characters(\\"Hello World\\") == \\"olleH dlroW\\" >>> reverse_words_characters(\\"Coding is fun\\") == \\"gnidoC si nuf\\" >>> reverse_words_characters(\\"Python\\") == \\"nohtyP\\" >>> reverse_words_characters(\\"a b c d e f\\") == \\"a b c d e f\\" >>> reverse_words_characters(\\"Hello, World!\\") == \\",olleH !dlroW\\" >>> reverse_words_characters(\\"Good Morning\\") == \\"dooG gninroM\\" >>> reverse_words_characters(\\"123 456\\") == \\"321 654\\" >>> reverse_words_characters(\\" % ^ &\\") == \\" % ^ &\\" >>> reverse_words_characters(\\"\\") == \\"\\"","solution":"def reverse_words_characters(s: str) -> str: Reverses the characters in each word of the input string while preserving the word order and spaces between them. Args: s: A string containing words separated by spaces. Returns: A string with characters in each word reversed. # Split the sentence into words words = s.split(' ') # Reverse each word and join them back with a space reversed_words = [word[::-1] for word in words] # Join the list of reversed words with a space to form the final string return ' '.join(reversed_words)"},{"question":"from typing import List, Tuple def merge_sequences(seq1: List[int], seq2: List[int]) -> List[int]: Merges two sequences to form the lexicographically smallest sequence while maintaining the order of integers within each sequence. >>> merge_sequences([1, 3, 5], [2, 4, 6]) == [1, 2, 3, 4, 5, 6] >>> merge_sequences([1, 3, 5, 7, 9], [2, 4, 6, 8, 10, 12]) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12] >>> merge_sequences([1], [2, 3, 4]) == [1, 2, 3, 4] >>> merge_sequences([3, 4, 5], [1, 2]) == [1, 2, 3, 4, 5] pass def magical_scroll_sequences(T: int, test_cases: List[Tuple[int, List[int], int, List[int]]]) -> List[List[int]]: Processes T test cases and returns the results as a list of merged sequences. >>> T = 2 >>> test_cases = [(3, [1, 3, 5], 3, [2, 4, 6]), (5, [1, 3, 5, 7, 9], 6, [2, 4, 6, 8, 10, 12])] >>> magical_scroll_sequences(T, test_cases) == [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12]] pass","solution":"def merge_sequences(seq1, seq2): Merges two sequences to form the lexicographically smallest sequence while maintaining the order of integers within each sequence. merged_sequence = [] i, j = 0, 0 while i < len(seq1) and j < len(seq2): if seq1[i] <= seq2[j]: merged_sequence.append(seq1[i]) i += 1 else: merged_sequence.append(seq2[j]) j += 1 if i < len(seq1): merged_sequence.extend(seq1[i:]) if j < len(seq2): merged_sequence.extend(seq2[j:]) return merged_sequence def magical_scroll_sequences(T, test_cases): Processes T test cases and returns the results as a list of merged sequences. results = [] for test in test_cases: N, seq1, M, seq2 = test merged = merge_sequences(seq1, seq2) results.append(merged) return results # Example usage (to be removed in actual solution): # T = 2 # test_cases = [ # (3, [1, 3, 5], 3, [2, 4, 6]), # (5, [1, 3, 5, 7, 9], 6, [2, 4, 6, 8, 10, 12]) # ] # print(magical_scroll_sequences(T, test_cases))"},{"question":"def is_prime(n: int) -> bool: Helper function to check if a number is a prime number. pass def prime_sum_ranges(N: int, arr: List[int], queries: List[Tuple[int, int]]) -> List[int]: Given a list of N integers and a list of queries, each query specifies a range [L, R] (1-indexed). The function returns the sum of all prime numbers within that range for each query. >>> prime_sum_ranges(6, [1, 2, 3, 4, 5, 6], [(1, 3), (2, 5), (4, 6)]) [5, 10, 5] >>> prime_sum_ranges(5, [11, 15, 17, 19, 23], [(1, 2), (2, 4), (1, 5)]) [11, 36, 70] pass","solution":"def is_prime(n): Helper function to check if a number is a prime number. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def prime_sum_ranges(N, arr, queries): Given a list of N integers and a list of queries, each query specifies a range [L, R] (1-indexed). The function returns the sum of all prime numbers within that range for each query. # Pre-calculate prime indicators for elements in the array prime_flags = [is_prime(x) for x in arr] # Pre-calculate prefix sums for prime numbers prime_prefix_sums = [0] * (N + 1) for i in range(1, N + 1): prime_prefix_sums[i] = prime_prefix_sums[i - 1] + (arr[i - 1] if prime_flags[i - 1] else 0) # Process each query and compute the required sum results = [] for L, R in queries: prime_sum = prime_prefix_sums[R] - prime_prefix_sums[L - 1] results.append(prime_sum) return results"},{"question":"from typing import List def min_operations_to_equalize_array(n: int, a: List[int]) -> int: Returns the minimum number of operations required to make all elements of the array equal. >>> min_operations_to_equalize_array(4, [7, 3, 5, 9]) 8 >>> min_operations_to_equalize_array(3, [7, 7, 7]) 0 >>> min_operations_to_equalize_array(2, [1, 2]) 1 >>> min_operations_to_equalize_array(3, [1000000000, 999999999, 1000000001]) 2 >>> min_operations_to_equalize_array(5, [5, 5, 5, 5, 5]) 0 >>> min_operations_to_equalize_array(5, [10, 1, 10, 1, 10]) 18","solution":"def min_operations_to_equalize_array(n, a): Returns the minimum number of operations required to make all elements of the array equal. # The optimal target value to equalize the array elements to is the median value. a.sort() median = a[n // 2] # Compute the total number of operations required to make all elements equal to the median operations = sum(abs(x - median) for x in a) return operations"},{"question":"def is_subsequence_of_fibonacci(s: List[int]) -> bool: Check if a given sequence is a subsequence of the Fibonacci sequence. >>> is_subsequence_of_fibonacci([1, 3, 7]) True >>> is_subsequence_of_fibonacci([4, 6, 9]) False >>> is_subsequence_of_fibonacci([2, 5, 13]) True","solution":"def is_subsequence_of_fibonacci(s): if not s: return True # Generate a sufficient amount of Fibonacci numbers fib_numbers = [0, 1] while fib_numbers[-1] < max(s): fib_numbers.append(fib_numbers[-1] + fib_numbers[-2]) # Check if s is a subsequence of fib_numbers fib_idx = 0 for num in s: while fib_idx < len(fib_numbers) and fib_numbers[fib_idx] != num: fib_idx += 1 if fib_idx == len(fib_numbers): return False fib_idx += 1 return True"},{"question":"def min_cost(cost): Calculates the minimum cost to travel from the top-left to the bottom-right cell of the given cost matrix. Args: cost (List[List[int]]): The NxM cost matrix. Returns: int: The minimum cost required to reach the bottom-right cell. Example: >>> cost_matrix_1 = [ [1, 3, 1], [1, 5, 1], [4, 2, 1], ] >>> min_cost(cost_matrix_1) 7 >>> cost_matrix_2 = [ [1, 2], [1, 1], ] >>> min_cost(cost_matrix_2) 3 def solve(T, test_cases): Solves multiple test cases to find the minimum cost for each cost matrix. Args: T (int): The number of test cases. test_cases (List[Tuple[int, int, List[List[int]]]]): List of test cases, where each test case is a tuple containing: - N (int): Number of rows in the matrix. - M (int): Number of columns in the matrix. - List[List[int]]: The NxM cost matrix. Returns: List[int]: List of results where each element is the minimum cost for the corresponding test case. Example: >>> test_cases = [ (3, 3, [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ]), (2, 2, [ [1, 2], [1, 1] ]) ] >>> T = 2 >>> solve(T, test_cases) [7, 3]","solution":"def min_cost(cost): Calculates the minimum cost to travel from the top-left to the bottom-right cell of the given cost matrix. N = len(cost) M = len(cost[0]) dp = [[0] * M for _ in range(N)] # Initialize the top-left cell dp[0][0] = cost[0][0] # Initialize the first column for i in range(1, N): dp[i][0] = dp[i-1][0] + cost[i][0] # Initialize the first row for j in range(1, M): dp[0][j] = dp[0][j-1] + cost[0][j] # Fill the rest of the dp table for i in range(1, N): for j in range(1, M): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + cost[i][j] return dp[N-1][M-1] def solve(T, test_cases): results = [] for t in range(T): N, M, matrix = test_cases[t][0], test_cases[t][1], test_cases[t][2] results.append(min_cost(matrix)) return results"},{"question":"def can_ball_pass_all_gates(N: int, gate_heights: List[int], X: int) -> str: Determines if a ball of diameter X can pass through all gates. Parameters: N (int): Number of gates. gate_heights (list of int): Heights of the gates. X (int): Diameter of the ball. Returns: str: \\"YES\\" if the ball can pass through all gates, otherwise \\"NO\\". Examples: >>> can_ball_pass_all_gates(5, [5, 6, 7, 8, 9], 5) \\"YES\\" >>> can_ball_pass_all_gates(4, [3, 2, 4, 5], 4) \\"NO\\" >>> can_ball_pass_all_gates(3, [8, 9, 7], 7) \\"YES\\"","solution":"def can_ball_pass_all_gates(N, gate_heights, X): Determines if a ball of diameter X can pass through all gates. Parameters: N (int): Number of gates. gate_heights (list of int): Heights of the gates. X (int): Diameter of the ball. Returns: str: \\"YES\\" if the ball can pass through all gates, otherwise \\"NO\\". for height in gate_heights: if height < X: return \\"NO\\" return \\"YES\\""},{"question":"def process_largest_integer_cases(test_cases: List[str]) -> List[str]: Given a list of test cases, where each test case is a space-separated list of integers between 0 and 9, return the largest possible integers formed by arranging the elements of the array for each test case. >>> process_largest_integer_cases([\\"3 30 34 5 9\\"]) == [\\"9534330\\"] >>> process_largest_integer_cases([\\"0 0 0 0\\"]) == [\\"0\\"] >>> process_largest_integer_cases([\\"5 6 7 2 9\\"]) == [\\"97652\\"] >>> process_largest_integer_cases([\\"3 30 34 5 9\\", \\"0 0 0 0\\", \\"5 6 7 2 9\\"]) == [\\"9534330\\", \\"0\\", \\"97652\\"] >>> process_largest_integer_cases([\\"9 8 7 6 5 4 3 2 1 0\\"]) == [\\"9876543210\\"] >>> process_largest_integer_cases([\\"1 1 1 1 1 1\\"]) == [\\"111111\\"] >>> process_largest_integer_cases([\\"1 9 8 2 3 0 5\\"]) == [\\"9853210\\"]","solution":"def largest_possible_integer(arr): Given an array of integers, return the largest possible integer formed by arranging the elements. # Convert each integer to a string to be able to concatenate arr_str = list(map(str, arr)) # Sort the array with a custom comparator arr_str.sort(key=lambda x: x*10, reverse=True) # Join the sorted strings result = ''.join(arr_str) # Convert result to an integer to remove any leading zeros and back to string result = str(int(result)) return result def process_largest_integer_cases(test_cases): results = [] for case in test_cases: arr = list(map(int, case.split())) results.append(largest_possible_integer(arr)) return results"},{"question":"def can_patrol(X: int, Y: int, B: int, C: int) -> str: Determines if the robot can patrol the rectangular area with given battery capacity. Parameters: X (int): x-coordinate of the farthest point. Y (int): y-coordinate of the farthest point. B (int): battery capacity in mAh. C (int): battery consumption rate in mAh per km. Returns: str: \\"PATROL POSSIBLE\\" if the robot can complete the patrol, else \\"PATROL NOT POSSIBLE\\" >>> can_patrol(3, 4, 140, 5) \\"PATROL POSSIBLE\\" >>> can_patrol(6, 8, 150, 10) \\"PATROL NOT POSSIBLE\\"","solution":"def can_patrol(X, Y, B, C): Determines if the robot can patrol the rectangular area with given battery capacity. Parameters: X (int): x-coordinate of the farthest point. Y (int): y-coordinate of the farthest point. B (int): battery capacity in mAh. C (int): battery consumption rate in mAh per km. Returns: str: \\"PATROL POSSIBLE\\" if the robot can complete the patrol, else \\"PATROL NOT POSSIBLE\\" # Calculating the total distance of the patrol path total_distance = 2 * (X + Y + ((X**2 + Y**2) ** 0.5)) # Calculating the total battery consumption total_battery_consumption = total_distance * C # Determining if the patrol is possible if total_battery_consumption <= B: return \\"PATROL POSSIBLE\\" else: return \\"PATROL NOT POSSIBLE\\""},{"question":"def perform_operations(binary_string: str, operations: List[str]) -> Union[str, int]: Perform a series of operations on a binary string. The operations can be: - invert: Replace every '0' with '1' and every '1' with '0'. - rotate: Perform a left circular rotation of the string by one position. - count-consecutive-ones: Count the maximum number of consecutive '1's in the binary string. >>> perform_operations(\\"1101001\\", [\\"invert\\", \\"rotate\\", \\"count-consecutive-ones\\"]) 2 >>> perform_operations(\\"111111\\", [\\"count-consecutive-ones\\"]) 6 >>> perform_operations(\\"101010\\", [\\"rotate\\", \\"invert\\", \\"count-consecutive-ones\\"]) 1 def process_test_cases(test_cases: List[Tuple[str, str]]) -> List[Union[str, int]]: Process multiple test cases of binary string operations. Args: test_cases: A list of tuples where the first element is a binary string and the second element is the operations to be performed. Returns: A list of results where each result is either a modified binary string or an integer representing the count of consecutive ones, depending on the last operation in the list. # Unit Tests def test_perform_operations(): test_cases = [ (\\"1101001\\", \\"invert rotate count-consecutive-ones\\"), (\\"111111\\", \\"count-consecutive-ones\\"), (\\"101010\\", \\"rotate invert count-consecutive-ones\\"), ] expected_outputs = [ 2, # Inverting 1101001 -> 0010110, Rotating once -> 0101100, Max consecutive ones -> 2 6, # No operations, directly counting -> 6 1, # Rotating 101010 -> 010101, Inverting -> 101010, Max consecutive ones -> 1 ] results = process_test_cases(test_cases) for result, expected in zip(results, expected_outputs): assert result == expected def test_invert_string(): assert perform_operations(\\"1101\\", [\\"invert\\"]) == \\"0010\\" assert perform_operations(\\"0000\\", [\\"invert\\"]) == \\"1111\\" assert perform_operations(\\"1010\\", [\\"invert\\"]) == \\"0101\\" def test_rotate_string(): assert perform_operations(\\"1101\\", [\\"rotate\\"]) == \\"1011\\" assert perform_operations(\\"0000\\", [\\"rotate\\"]) == \\"0000\\" assert perform_operations(\\"1010\\", [\\"rotate\\"]) == \\"0101\\" def test_count_consecutive_ones(): assert perform_operations(\\"110111\\", [\\"count-consecutive-ones\\"]) == 3 assert perform_operations(\\"0000\\", [\\"count-consecutive-ones\\"]) == 0 assert perform_operations(\\"101010\\", [\\"count-consecutive-ones\\"]) == 1 def test_combined_operations(): assert perform_operations(\\"1101001\\", [\\"invert\\", \\"rotate\\", \\"count-consecutive-ones\\"]) == 2 assert perform_operations(\\"1111111\\", [\\"invert\\", \\"rotate\\", \\"rotate\\", \\"invert\\", \\"count-consecutive-ones\\"]) == 7","solution":"def perform_operations(binary_string, operations): def invert(s): return ''.join('1' if ch == '0' else '0' for ch in s) def rotate(s): return s[1:] + s[0] def count_consecutive_ones(s): count = max_count = 0 for ch in s: if ch == '1': count += 1 max_count = max(max_count, count) else: count = 0 return max_count for operation in operations: if operation == 'invert': binary_string = invert(binary_string) elif operation == 'rotate': binary_string = rotate(binary_string) elif operation == 'count-consecutive-ones': return count_consecutive_ones(binary_string) return binary_string def process_test_cases(test_cases): results = [] for binary_string, operations in test_cases: operations_list = operations.split() result = perform_operations(binary_string, operations_list) results.append(result) return results"},{"question":"def is_palindrome(word: str) -> bool: Returns True if the word is a palindrome, False otherwise. >>> is_palindrome(\\"madam\\") True >>> is_palindrome(\\"racecar\\") True >>> is_palindrome(\\"hello\\") False >>> is_palindrome(\\"noon\\") True >>> is_palindrome(\\"world\\") False def detect_palindromes(test_cases: List[str]) -> List[str]: Determines if there are any palindrome words in each sentence of the test cases. Params: test_cases: List of sentences Returns: List of results, where each element is \\"YES\\" if there are palindrome words, otherwise \\"NO\\". >>> detect_palindromes([\\"madam likes to racecar\\"]) [\\"YES\\"] >>> detect_palindromes([\\"the quick brown fox\\"]) [\\"NO\\"] >>> detect_palindromes([\\"never odd or even\\"]) [\\"NO\\"] >>> detect_palindromes([\\"wow\\"]) [\\"YES\\"] >>> detect_palindromes([\\"abcdefg gfedcba\\"]) [\\"NO\\"] >>> detect_palindromes([\\"a\\"]) [\\"YES\\"] >>> detect_palindromes([\\"a b c\\"]) [\\"YES\\"] >>> detect_palindromes([\\"\\"]) [\\"NO\\"]","solution":"def is_palindrome(word): Returns True if the word is a palindrome, False otherwise. return word == word[::-1] def detect_palindromes(test_cases): Determines if there are any palindrome words in each sentence of the test cases. Params: test_cases: List of sentences Returns: List of results, where each element is \\"YES\\" if there are palindrome words, otherwise \\"NO\\". results = [] for sentence in test_cases: words = sentence.split() if any(is_palindrome(word) for word in words): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def personalize_invitations(guests: dict) -> dict: Takes a dictionary with guest names as keys and their responses ('yes' or 'no') as values, and returns a new dictionary with personalized messages. >>> personalize_invitations({\\"Alice\\": \\"yes\\", \\"Bob\\": \\"no\\", \\"Charlie\\": \\"yes\\"}) {\\"Alice\\": \\"Dear Alice, we're excited to see you at the party!\\", \\"Bob\\": \\"Dear Bob, sorry to hear you can't make it.\\", \\"Charlie\\": \\"Dear Charlie, we're excited to see you at the party!\\"} >>> personalize_invitations({\\"David\\": \\"no\\", \\"Eva\\": \\"yes\\"}) {\\"David\\": \\"Dear David, sorry to hear you can't make it.\\", \\"Eva\\": \\"Dear Eva, we're excited to see you at the party!\\"}","solution":"def personalize_invitations(guests: dict) -> dict: Takes a dictionary with guest names as keys and their responses ('yes' or 'no') as values, and returns a new dictionary with personalized messages. messages = {} for guest, response in guests.items(): if response == \\"yes\\": messages[guest] = f\\"Dear {guest}, we're excited to see you at the party!\\" elif response == \\"no\\": messages[guest] = f\\"Dear {guest}, sorry to hear you can't make it.\\" return messages"},{"question":"def rearrangeString(s: str) -> str: Rearranges the input string such that no two adjacent characters are the same. Returns an empty string if no such arrangement is possible. >>> rearrangeString(\\"aab\\") == \\"aba\\" >>> rearrangeString(\\"aaab\\") == \\"\\" >>> rearrangeString(\\"aaabb\\") in [\\"ababa\\", \\"babab\\", \\"babaa\\"] >>> rearrangeString(\\"a\\") == \\"a\\" >>> rearrangeString(\\"aa\\") == \\"\\" >>> rearrangeString(\\"ab\\") == \\"ab\\" >>> result = rearrangeString(\\"aaabbcccc\\") >>> set(result) == set(\\"aaabbcccc\\") >>> all(result[i] != result[i + 1] for i in range(len(result) - 1)) >>> input_str = \\"a\\" * 50 + \\"b\\" * 50 >>> result = rearrangeString(input_str) >>> set(result) == set(input_str) >>> all(result[i] != result[i + 1] for i in range(len(result) - 1))","solution":"from heapq import heappop, heappush from collections import Counter def rearrangeString(s): Rearranges the input string such that no two adjacent characters are the same. Returns an empty string if no such arrangement is possible. # Count the frequency of each character freq = Counter(s) # Create a max heap based on the frequency of characters max_heap = [] for char, count in freq.items(): heappush(max_heap, (-count, char)) # Resultant string list result = [] # Previous character initialization prev_char = None prev_count = 0 while max_heap: count, char = heappop(max_heap) # Add previous character back to heap if its count was greater than zero if prev_char and prev_count < 0: heappush(max_heap, (prev_count, prev_char)) # Append current character to result result.append(char) # Update previous character and count prev_char = char prev_count = count + 1 # since we used one instance of char # Join the resultant list into a string rearranged = ''.join(result) # If we successfully use all characters, return the result if len(rearranged) == len(s): return rearranged else: return \\"\\""},{"question":"def findPrimes(arr: List[int]) -> List[int]: Write a function that takes an array of positive integers and returns a new array containing all the prime numbers from the input array. If there are no prime numbers in the input array, return an empty array. Parameters: arr (list of int): The input list of positive integers. Returns: list of int: A new list containing all the prime numbers from the input list. >>> findPrimes([10, 15, 3, 7, 2]) [3, 7, 2] >>> findPrimes([18, 20, 25, 30]) [] pass","solution":"def findPrimes(arr): Returns a list of prime numbers from the input list of positive integers. Parameters: arr (list of int): The input list of positive integers. Returns: list of int: A new list containing all the prime numbers from the input list. def is_prime(n): if n <= 1: return False if n == 2: return True if n % 2 == 0: return False for i in range(3, int(n ** 0.5) + 1, 2): if n % i == 0: return False return True return [num for num in arr if is_prime(num)]"},{"question":"def max_average_performance(M: int, K: int, performance_scores: List[int]) -> float: Returns the maximum average performance score that can be achieved by considering exactly K consecutive days from the given performance scores. >>> max_average_performance(7, 3, [6, 7, 5, 8, 7, 7, 9]) 7.67 >>> max_average_performance(5, 2, [1, 2, 3, 4, 5]) 4.5 >>> max_average_performance(4, 4, [10, 10, 10, 10]) 10.0 >>> max_average_performance(6, 3, [1, 2, 1, 2, 1, 2]) 1.67 >>> max_average_performance(1, 1, [5]) 5.0","solution":"def max_average_performance(M, K, performance_scores): Returns the maximum average performance score that can be achieved by considering exactly K consecutive days from the given performance scores. max_avg = -float('inf') current_sum = sum(performance_scores[:K]) for i in range(M - K + 1): if i > 0: current_sum = current_sum - performance_scores[i - 1] + performance_scores[i + K - 1] max_avg = max(max_avg, current_sum / K) return round(max_avg, 2) # Example usage: # M = 7 # K = 3 # performance_scores = [6, 7, 5, 8, 7, 7, 9] # print(max_average_performance(M, K, performance_scores)) # Output: 7.67"},{"question":"def minimal_steps_to_open_valves(n: int, edges: List[Tuple[int, int]]) -> int: Given the number of valves \`n\` and the tree structure of the pipeline system, determines the minimal number of steps required to open all valves. >>> minimal_steps_to_open_valves(5, [(1, 2), (1, 3), (3, 4), (3, 5)]) 3 >>> minimal_steps_to_open_valves(4, [(1, 2), (2, 3), (3, 4)]) 4","solution":"def minimal_steps_to_open_valves(n, edges): from collections import defaultdict # Create adjacency list to represent the tree tree = defaultdict(list) for u, v in edges: tree[u].append(v) # Function to perform DFS and return depth of the tree def dfs(node): if not tree[node]: return 1 depths = [dfs(child) for child in tree[node]] return max(depths) + 1 # Calculate depth of the tree starting from root node 1 return dfs(1)"},{"question":"def findPaintCommands(m, n, start, end, path): Determine the commands necessary to paint a mural based on the specified path. Parameters: m (int): Number of rows in the grid. n (int): Number of columns in the grid. start (tuple of int, int): starting position of the painter. end (tuple of int, int): ending position of the painter. path (str): sequence of moves the painter will take. Returns: list of str: Each command indicating a cell to paint. Examples: >>> findPaintCommands(3, 3, (1, 1), (1, 3), 'RR') ['PAINT (1, 1)', 'PAINT (1, 2)', 'PAINT (1, 3)'] >>> findPaintCommands(4, 4, (2, 2), (4, 4), 'DDRR') ['PAINT (2, 2)', 'PAINT (3, 2)', 'PAINT (4, 2)', 'PAINT (4, 3)', 'PAINT (4, 4)']","solution":"def findPaintCommands(m, n, start, end, path): Determine the commands necessary to paint a mural based on the specified path. Parameters: m (int): Number of rows in the grid. n (int): Number of columns in the grid. start (tuple of int, int): starting position of the painter. end (tuple of int, int): ending position of the painter. path (str): sequence of moves the painter will take. Returns: list of str: Each command indicating a cell to paint. commands = [] x, y = start commands.append(f'PAINT ({x}, {y})') for move in path: if move == 'U': x -= 1 elif move == 'D': x += 1 elif move == 'L': y -= 1 elif move == 'R': y += 1 commands.append(f'PAINT ({x}, {y})') return commands"},{"question":"def largest_cross_in_grid(n: int, grid: List[List[int]]) -> int: Given a grid of size n x n, identify the largest cross of 1s in that grid. A cross consists of one vertical and one horizontal line of 1s, intersecting at a single point. Both the vertical and horizontal lines must be of equal lengths, centered at the same point. Return the maximum length of such a cross. >>> largest_cross_in_grid(5, [[1, 0, 1, 1, 1], [1, 1, 1, 0, 0], [1, 1, 1, 1, 1], [0, 0, 1, 0, 1], [1, 1, 1, 1, 1]]) 3 >>> largest_cross_in_grid(5, [[0, 0, 0, 1, 0], [0, 1, 0, 1, 0], [1, 1, 1, 1, 1], [0, 1, 0, 1, 0], [0, 0, 0, 1, 0]]) 2 def get_largest_crosses(input_string: str) -> List[int]: Parse the input string containing multiple datasets to find the largest cross in each grid. The input consists of multiple datasets, followed by a line containing a single zero. Each dataset starts with an integer n representing the size of the grid (2 ≤ n ≤ 20), followed by n lines each containing n integers (0 or 1) separated by spaces, representing the values in the grid. For each dataset, print the maximum length of the largest cross that can be found in the grid. >>> input_string = \\"5n1 0 1 1 1n1 1 1 0 0n1 1 1 1 1n0 0 1 0 1n1 1 1 1 1n0\\" >>> get_largest_crosses(input_string) [3] >>> input_string = (\\"5n1 0 1 1 1n1 1 1 0 0n1 1 1 1 1n0 0 1 0 1n1 1 1 1 1n\\" \\"5n0 0 0 1 0n0 1 0 1 0n1 1 1 1 1n0 1 0 1 0n0 0 0 1 0n0\\") >>> get_largest_crosses(input_string) [3, 2]","solution":"def largest_cross_in_grid(n, grid): def compute_arm_lengths(matrix, n): left = [[0] * n for _ in range(n)] right = [[0] * n for _ in range(n)] top = [[0] * n for _ in range(n)] bottom = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): if grid[i][j] == 1: left[i][j] = (left[i][j - 1] + 1) if j > 0 else 1 top[i][j] = (top[i - 1][j] + 1) if i > 0 else 1 for i in range(n - 1, -1, -1): for j in range(n - 1, -1, -1): if grid[i][j] == 1: right[i][j] = (right[i][j + 1] + 1) if j < n - 1 else 1 bottom[i][j] = (bottom[i + 1][j] + 1) if i < n - 1 else 1 return left, right, top, bottom left, right, top, bottom = compute_arm_lengths(grid, n) max_cross_length = 0 for i in range(n): for j in range(n): if grid[i][j] == 1: length = min(left[i][j], right[i][j], top[i][j], bottom[i][j]) max_cross_length = max(max_cross_length, length) return max_cross_length def parse_input(input_string): lines = input_string.strip().split('n') i = 0 datasets = [] while i < len(lines): n = int(lines[i]) if n == 0: break grid = [] for j in range(n): grid.append(list(map(int, lines[i + j + 1].split()))) datasets.append((n, grid)) i += n + 1 return datasets def get_largest_crosses(input_string): datasets = parse_input(input_string) results = [] for n, grid in datasets: results.append(largest_cross_in_grid(n, grid)) return results"},{"question":"def smallest_subarray_with_k_unique(n: int, k: int, arr: List[int]) -> int: Given an integer array, find the smallest contiguous subarray that contains at least k unique elements. If no such subarray exists, return -1. >>> smallest_subarray_with_k_unique(7, 3, [1, 2, 1, 3, 4, 2, 2]) 3 >>> smallest_subarray_with_k_unique(5, 2, [1, 1, 1, 1, 1]) -1","solution":"def smallest_subarray_with_k_unique(n, k, arr): from collections import defaultdict # Check if it's even possible to have a subarray with k unique elements unique_elements = len(set(arr)) if unique_elements < k: return -1 # Dictionary to store the frequency of elements in the current window freq = defaultdict(int) start = 0 min_len = n + 1 unique_count = 0 for end in range(n): if freq[arr[end]] == 0: unique_count += 1 freq[arr[end]] += 1 while unique_count >= k: min_len = min(min_len, end - start + 1) freq[arr[start]] -= 1 if freq[arr[start]] == 0: unique_count -= 1 start += 1 return min_len if min_len <= n else -1"},{"question":"def range_sum_modulo(N: int, Q: int, A: List[int], queries: List[Tuple[int, int]]) -> List[int]: You are given a list of N integers and Q queries. Each query consists of two integers, L and R. The task is to find the sum of the integers from the L-th position to the R-th position, inclusive. The answer should be output modulo 10^9 + 7. Args: N (int): The number of integers in the list. Q (int): The number of queries. A (List[int]): The list of integers. queries (List[Tuple[int, int]]): A list of queries where each query is represented as a tuple (L, R). Returns: List[int]: A list containing the results of each query. Example: >>> range_sum_modulo(5, 3, [1, 2, 3, 4, 5], [(1, 3), (2, 4), (1, 5)]) [6, 9, 15]","solution":"def range_sum_modulo(N, Q, A, queries): MOD = 10**9 + 7 # Precompute prefix sums prefix_sums = [0] * (N + 1) for i in range(1, N + 1): prefix_sums[i] = (prefix_sums[i-1] + A[i-1]) % MOD results = [] for L, R in queries: sum_range = (prefix_sums[R] - prefix_sums[L-1]) % MOD results.append(sum_range) return results"},{"question":"class ArrayQueries: def __init__(self, array: List[int]): Initialize the ArrayQueries object with the given array. Args: array (List[int]): The initial elements of the array. pass def update(self, index: int, value: int) -> None: Update the element at position index to the given value. Args: index (int): The index to update. value (int): The new value to set at the given index. pass def sumRange(self, left: int, right: int) -> int: Return the sum of elements between indices left and right (inclusive). Args: left (int): The start index of the range. right (int): The end index of the range. Returns: int: The sum of elements in the given range. pass","solution":"class ArrayQueries: def __init__(self, array): self.array = array self.n = len(array) self.tree = [0] * (self.n + 1) for i, val in enumerate(array): self._update_tree(i + 1, val) def _update_tree(self, index, value): while index <= self.n: self.tree[index] += value index += index & -index def _query_tree(self, index): sum_val = 0 while index > 0: sum_val += self.tree[index] index -= index & -index return sum_val def update(self, index, value): current_value = self.sumRange(index, index) diff = value - current_value self._update_tree(index, diff) self.array[index - 1] = value def sumRange(self, left, right): return self._query_tree(right) - self._query_tree(left - 1)"},{"question":"def max_binary_length(n: int, s: str) -> int: Determine the maximum binary length of the string s. Parameters: n (int): Length of the binary string. s (str): The binary string. Returns: int: The maximum binary length of the string. Examples: >>> max_binary_length(7, \\"1100011\\") 3 >>> max_binary_length(10, \\"1110000001\\") 6","solution":"def max_binary_length(n, s): Returns the maximum binary length of the string s. Parameters: n (int): Length of the binary string. s (str): The binary string. Returns: int: The maximum binary length of the string. if n == 0: return 0 max_len = 1 current_len = 1 for i in range(1, n): if s[i] == s[i - 1]: current_len += 1 max_len = max(max_len, current_len) else: current_len = 1 return max_len"},{"question":"def max_net_gold(n: int, f: int, gold: List[int]) -> int: Calculates the maximum net gold the spacecraft can collect. :param n: Number of planets :param f: Fuel cost for each transition :param gold: List of integers representing gold reserves on each planet :return: The maximum net gold as an integer >>> max_net_gold(5, 3, [10, 20, 30, 40, 50]) 47 >>> max_net_gold(4, 0, [5, 20, 10, 35]) 35 >>> max_net_gold(4, 5, [5, 20, 10, 35]) 30 >>> max_net_gold(1, 1, [1]) 0 >>> max_net_gold(1, 0, [1]) 1 >>> max_net_gold(3, 2, [1, 1, 1]) -1 >>> max_net_gold(3, 1, [1, 2, 1]) 1 >>> max_net_gold(3, 2, [1, 2, 1]) 0 >>> max_net_gold(5, 100, [100, 200, 300, 400, 500]) 400 >>> max_net_gold(4, 2, [-5, -10, -15, -20]) -7 >>> max_net_gold(4, 5, [-5, -10, -15, -20]) -10","solution":"def max_net_gold(n, f, gold): Calculates the maximum net gold the spacecraft can collect. :param n: Number of planets :param f: Fuel cost for each transition :param gold: List of integers representing gold reserves on each planet :return: The maximum net gold as an integer max_gold = float('-inf') for g in gold: max_gold = max(max_gold, g) return max_gold - f"},{"question":"def largest_square_subgrid(N: int, M: int, grid: List[List[str]]) -> int: Returns the size of the largest square sub-grid that contains no obstacles. # Your code here def parse_input(input_data: str) -> Tuple[int, int, List[List[str]]]: Parse the input data into necessary components for the function. # Your code here import pytest def test_parse_input(): input_data = \\"5 6n......n....n....#.n.#..#.n.....#\\" N, M, grid = parse_input(input_data) assert N == 5 assert M == 6 assert grid == [ ['.', '.', '.', '.', '.', '.'], ['.', '.', '#', '#', '.', '.'], ['.', '.', '.', '.', '#', '.'], ['.', '#', '.', '.', '#', '.'], ['.', '.', '.', '.', '.', '#'] ] def test_largest_square_subgrid(): input_data = \\"5 6n......n....n....#.n.#..#.n.....#\\" N, M, grid = parse_input(input_data) assert largest_square_subgrid(N, M, grid) == 2 input_data = \\"3 3n.#.n.#.n...\\" N, M, grid = parse_input(input_data) assert largest_square_subgrid(N, M, grid) == 1 input_data = \\"3 4n....n....n....\\" N, M, grid = parse_input(input_data) assert largest_square_subgrid(N, M, grid) == 3 input_data = \\"2 2nn\\" N, M, grid = parse_input(input_data) assert largest_square_subgrid(N, M, grid) == 0 input_data = \\"4 4n...#n..n..#.n....\\" N, M, grid = parse_input(input_data) assert largest_square_subgrid(N, M, grid) == 2 def test_edge_case_empty_grid(): assert largest_square_subgrid(0, 0, []) == 0 def test_edge_case_single_cell(): assert largest_square_subgrid(1, 1, [['.']]) == 1 assert largest_square_subgrid(1, 1, [['#']]) == 0 def test_edge_case_full_grid(): N = 1000 M = 1000 grid = [['.'] * M for _ in range(N)] assert largest_square_subgrid(N, M, grid) == 1000","solution":"def largest_square_subgrid(N, M, grid): Returns the size of the largest square sub-grid that contains no obstacles. if N == 0 or M == 0: return 0 dp = [[0] * M for _ in range(N)] max_side = 0 for i in range(N): for j in range(M): if grid[i][j] == '.': if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1 max_side = max(max_side, dp[i][j]) return max_side def parse_input(input_data): Parse the input data into necessary components for the function. lines = input_data.strip().split('n') N, M = map(int, lines[0].split()) grid = [list(line) for line in lines[1:]] return N, M, grid"},{"question":"def maxSumIncreasingSubsequence(nums): Returns the maximum possible sum of a non-empty subsequence such that all the elements of the subsequence are sorted in strictly increasing order. >>> maxSumIncreasingSubsequence([10, 5, 4, 3, 7, 2, 8]) 20 >>> maxSumIncreasingSubsequence([1, 101, 2, 3, 100, 4, 5]) 106 >>> maxSumIncreasingSubsequence([5]) 5 >>> maxSumIncreasingSubsequence([-1, -2, -3, -4]) -1 >>> maxSumIncreasingSubsequence([-1, 2, -3, 4, -5, 6]) 12 >>> maxSumIncreasingSubsequence([5, 5, 5, 5]) 5 >>> maxSumIncreasingSubsequence([1, 2, 3, 4, 5]) 15 >>> maxSumIncreasingSubsequence([5, 4, 3, 2, 1]) 5","solution":"def maxSumIncreasingSubsequence(nums): Returns the maximum possible sum of a non-empty subsequence such that all the elements of the subsequence are sorted in strictly increasing order. n = len(nums) if n == 0: return 0 # Create an array to store the maximum sum of an increasing subsequence that ends with nums[i] max_sum = nums[:] # Populate the max_sum array for i in range(1, n): for j in range(i): if nums[i] > nums[j] and max_sum[i] < max_sum[j] + nums[i]: max_sum[i] = max_sum[j] + nums[i] # Return the maximum value in max_sum array return max(max_sum)"},{"question":"def marbles_game(n: int, marbles: List[int]) -> str: Determines if the total number of marbles in the jars is odd or even. Parameters: n (int): The number of jars. marbles (list): A list of integers where each integer represents the number of marbles in a jar. Returns: str: \\"ODD\\" if the total number of marbles is odd, \\"EVEN\\" if it is even. >>> marbles_game(5, [2, 3, 5, 7, 8]) \\"ODD\\" >>> marbles_game(6, [1, 2, 3, 4, 5, 6]) \\"ODD\\" >>> marbles_game(4, [2, 2, 2, 2]) \\"EVEN\\" >>> marbles_game(3, [0, 0, 0]) \\"EVEN\\" >>> marbles_game(1, [1]) \\"ODD\\"","solution":"def marbles_game(n, marbles): Determines if the total number of marbles in the jars is odd or even. Parameters: n (int): The number of jars. marbles (list): A list of integers where each integer represents the number of marbles in a jar. Returns: str: \\"ODD\\" if the total number of marbles is odd, \\"EVEN\\" if it is even. total_marbles = sum(marbles) if total_marbles % 2 == 0: return \\"EVEN\\" else: return \\"ODD\\""},{"question":"def dna_sequence_search(dna: str, target: str) -> bool: Determines whether the target DNA sequence is a contiguous substring of the DNA string. >>> dna_sequence_search(\\"ACGTACGTGACG\\", \\"GACG\\") True >>> dna_sequence_search(\\"ACGTACGTGACG\\", \\"GTAC\\") True >>> dna_sequence_search(\\"ACGTACGTGACG\\", \\"TGC\\") False >>> dna_sequence_search(\\"ACGTACGTGACG\\", \\"ACGTG\\") True pass","solution":"def dna_sequence_search(dna, target): Determines whether the target DNA sequence is a contiguous substring of the DNA string. Parameters: - dna (str): the main DNA string - target (str): the target sequence to search for Returns: - bool: True if the target sequence is found within the DNA string, otherwise False return target in dna"},{"question":"def maximalRectangle(matrix: List[List[str]]) -> int: Find the largest rectangle containing only 1's in a grid and returns its area. >>> maximalRectangle([ ... [\\"1\\", \\"0\\", \\"1\\", \\"0\\", \\"0\\"], ... [\\"1\\", \\"0\\", \\"1\\", \\"1\\", \\"1\\"], ... [\\"1\\", \\"1\\", \\"1\\", \\"1\\", \\"1\\"], ... [\\"1\\", \\"0\\", \\"0\\", \\"1\\", \\"0\\"] ... ]) == 6 >>> maximalRectangle([ ... [\\"0\\", \\"0\\", \\"0\\"], ... [\\"0\\", \\"0\\", \\"0\\"], ... [\\"0\\", \\"0\\", \\"0\\"] ... ]) == 0 >>> maximalRectangle([ ... [\\"1\\", \\"1\\", \\"1\\"], ... [\\"1\\", \\"1\\", \\"1\\"], ... [\\"1\\", \\"1\\", \\"1\\"] ... ]) == 9","solution":"def maximalRectangle(matrix): if not matrix or not matrix[0]: return 0 max_area = 0 n = len(matrix[0]) height = [0] * (n + 1) # extra one for boundary for row in matrix: for i in range(n): height[i] = height[i] + 1 if row[i] == '1' else 0 stack = [] for i in range(n + 1): while stack and height[stack[-1]] > height[i]: h = height[stack.pop()] w = i if not stack else i - stack[-1] - 1 max_area = max(max_area, h * w) stack.append(i) return max_area"},{"question":"def compress_string(s: str) -> str: Compress a string by replacing sequences of consecutive identical characters with the character followed by the count. >>> compress_string('aaabbcccc') 'a3b2c4' >>> compress_string('abc') 'abc' >>> compress_string('aabcccccaaa') 'a2bc5a3'","solution":"def compress_string(s: str) -> str: if not s: return \\"\\" compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: compressed.append(s[i - 1]) if count > 1: compressed.append(str(count)) count = 1 compressed.append(s[-1]) if count > 1: compressed.append(str(count)) return ''.join(compressed)"},{"question":"def minimum_travel_distance(n: int, roads: List[Tuple[int, int]]) -> int: Determine the minimum distance for the group to travel to visit all locations exactly once and return to the starting location. :param n: Integer, the number of locations. :param roads: List of tuples, each tuple contains two integers denoting a road connecting locations. :return: Integer, the minimum distance to travel to visit all locations and return to the start. >>> minimum_travel_distance(4, [(1, 2), (2, 3), (3, 4)]) 6 >>> minimum_travel_distance(1, []) 0 >>> minimum_travel_distance(3, [(1, 2), (1, 3)]) 4 >>> minimum_travel_distance(5, [(1, 2), (2, 3), (3, 4), (4, 5)]) 8 >>> minimum_travel_distance(6, [(1, 2), (1, 3), (3, 4), (4, 5), (5, 6)]) 10 pass","solution":"def minimum_travel_distance(n, roads): from collections import defaultdict, deque def bfs_max_depth(start): visited = [False] * (n + 1) queue = deque([(start, 0)]) visited[start] = True farthest_node = start max_depth = 0 while queue: node, depth = queue.popleft() if depth > max_depth: max_depth = depth farthest_node = node for neighbor in graph[node]: if not visited[neighbor]: visited[neighbor] = True queue.append((neighbor, depth + 1)) return farthest_node, max_depth if n == 1: return 0 graph = defaultdict(list) for u, v in roads: graph[u].append(v) graph[v].append(u) # Find the farthest node from node 1 farthest_node, _ = bfs_max_depth(1) # Find the farthest node from the above farthest node to get the tree diameter _, diameter = bfs_max_depth(farthest_node) return 2 * diameter"},{"question":"def organize_seating(T, cases): Organize the seating arrangement ensuring VIP guests are seated in the first row. Args: T (int): Number of test cases. cases (List[Dict]): List of test cases where each test case contains: - 'N': Total number of guests. - 'guests': List of guest identifiers. - 'K': Number of VIP guests. - 'VIP': List of VIP guest identifiers in the desired order. Returns: List[List[int]]: Updated list of guest identifiers after seating the VIP guests in the first row. Example: >>> organize_seating(1, [{'N': 6, 'guests': [4, 2, 3, 6, 1, 5], 'K': 3, 'VIP': [2, 6, 4]}]) [[2, 6, 4, 3, 1, 5]] >>> organize_seating(1, [{'N': 5, 'guests': [7, 5, 1, 3, 8], 'K': 2, 'VIP': [5, 1]}]) [[5, 1, 7, 3, 8]] from solution import organize_seating def test_organize_seating_single_case(): T = 1 cases = [{ 'N': 6, 'guests': [4, 2, 3, 6, 1, 5], 'K': 3, 'VIP': [2, 6, 4] }] result = organize_seating(T, cases) assert result == [[2, 6, 4, 3, 1, 5]] def test_organize_seating_multiple_cases(): T = 2 cases = [{ 'N': 6, 'guests': [4, 2, 3, 6, 1, 5], 'K': 3, 'VIP': [2, 6, 4] }, { 'N': 5, 'guests': [10, 5, 8, 3, 7], 'K': 2, 'VIP': [5, 8] }] result = organize_seating(T, cases) assert result == [ [2, 6, 4, 3, 1, 5], # first test case expected result [5, 8, 10, 3, 7] # second test case expected result ] def test_organize_seating_no_vip(): T = 1 cases = [{ 'N': 4, 'guests': [1, 2, 3, 4], 'K': 0, 'VIP': [] }] result = organize_seating(T, cases) assert result == [[1, 2, 3, 4]] def test_organize_seating_all_vip(): T = 1 cases = [{ 'N': 3, 'guests': [7, 8, 9], 'K': 3, 'VIP': [7, 8, 9] }] result = organize_seating(T, cases) assert result == [[7, 8, 9]] def test_organize_seating_one_guest(): T = 1 cases = [{ 'N': 1, 'guests': [1], 'K': 1, 'VIP': [1] }] result = organize_seating(T, cases) assert result == [[1]]","solution":"def organize_seating(T, cases): results = [] for i in range(T): N = cases[i]['N'] guests = cases[i]['guests'] K = cases[i]['K'] VIP = cases[i]['VIP'] VIP_set = set(VIP) non_VIP = [guest for guest in guests if guest not in VIP_set] # Update seating arrangement updated_seating = VIP + non_VIP results.append(updated_seating) return results"},{"question":"def longest_increasing_subarray(arr): Given an array of integers, find the length of the longest subarray that forms a strictly increasing sequence. >>> longest_increasing_subarray([1, 3, 5, 4, 7]) == 3 >>> longest_increasing_subarray([2, 2, 2, 2, 2]) == 1 >>> longest_increasing_subarray([10, 20, 30, 10, 20, 30, 40]) == 4","solution":"def longest_increasing_subarray(arr): if not arr: return 0 max_length = 1 current_length = 1 for i in range(1, len(arr)): if arr[i] > arr[i - 1]: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length"},{"question":"def total_matches(n: int) -> int: Calculate the total number of matches required to determine the winner in a knockout tournament. >>> total_matches(4) 3 >>> total_matches(7) 6 >>> total_matches(1) 0 >>> total_matches(123456) 123455","solution":"def total_matches(n): This function calculates the total number of matches required to determine the winner in a knockout tournament. :param n: int - number of contestants :return: int - total number of matches required # The total number of matches needed is always equal to n - 1 return n - 1"},{"question":"def point_location_in_rectangle(x1, y1, x2, y2, xp, yp) -> str: Determine the point (xp, yp) location relative to the rectangle defined by bottom-left corner (x1, y1) and top-right corner (x2, y2). Returns \\"INSIDE\\", \\"ON BORDER\\", or \\"OUTSIDE\\". >>> point_location_in_rectangle(0, 0, 5, 5, 3, 3) \\"INSIDE\\" >>> point_location_in_rectangle(0, 0, 5, 5, 0, 0) \\"ON BORDER\\" >>> point_location_in_rectangle(0, 0, 5, 5, 6, 6) \\"OUTSIDE\\" pass def process_test_cases(test_cases): Process multiple test cases to determine the position of each point relative to its respective rectangle. Args: test_cases: List of tuples containing (x1, y1, x2, y2, xp, yp) Returns: List of results (\\"INSIDE\\", \\"ON BORDER\\", \\"OUTSIDE\\") for each test case. >>> process_test_cases([(0, 0, 5, 5, 3, 3), (0, 0, 5, 5, 0, 0), (0, 0, 5, 5, 6, 6)]) [\\"INSIDE\\", \\"ON BORDER\\", \\"OUTSIDE\\"] pass","solution":"def point_location_in_rectangle(x1, y1, x2, y2, xp, yp): Determine the point (xp, yp) location relative to the rectangle defined by bottom-left corner (x1, y1) and top-right corner (x2, y2). if x1 <= xp <= x2 and y1 <= yp <= y2: if xp == x1 or xp == x2 or yp == y1 or yp == y2: return \\"ON BORDER\\" else: return \\"INSIDE\\" else: return \\"OUTSIDE\\" def process_test_cases(test_cases): results = [] for case in test_cases: x1, y1, x2, y2, xp, yp = case result = point_location_in_rectangle(x1, y1, x2, y2, xp, yp) results.append(result) return results"},{"question":"def is_monotonic(arr): Determines whether the given array 'arr' is monotonic (either non-decreasing or non-increasing). Returns 1 if the array is monotonic and 0 otherwise. >>> is_monotonic([1, 2, 2, 3]) 1 >>> is_monotonic([6, 5, 5, 4, 4]) 1 >>> is_monotonic([1, 3, 2]) 0 def solve_monotonic(T, test_cases): Solves the test cases to determine if each array is monotonic. >>> T = 3 >>> test_cases = [ ... (4, [1, 2, 2, 3]), ... (5, [6, 5, 5, 4, 4]), ... (3, [1, 3, 2]) ... ] >>> solve_monotonic(T, test_cases) [1, 1, 0]","solution":"def is_monotonic(arr): Determines whether the given array 'arr' is monotonic (either non-decreasing or non-increasing). Returns 1 if the array is monotonic and 0 otherwise. n = len(arr) if n <= 1: return 1 increasing = decreasing = True for i in range(1, n): if arr[i] < arr[i - 1]: increasing = False if arr[i] > arr[i - 1]: decreasing = False return 1 if increasing or decreasing else 0 def solve_monotonic(T, test_cases): results = [] for t in range(T): N, A = test_cases[t] results.append(is_monotonic(A)) return results"},{"question":"from typing import List, Tuple def are_permutations(A: List[int], B: List[int]) -> bool: Check if two arrays A and B are permutations of each other. pass def check_test_cases(t: int, test_cases: List[Tuple[int, List[int], List[int]]]) -> List[str]: For each test case, checks if the arrays are permutations of each other and returns a list of results. >>> check_test_cases(2, [(3, [1, 2, 3], [3, 1, 2]), (4, [1, 2, 2, 3], [1, 2, 3, 4])]) == [\\"YES\\", \\"NO\\"] >>> check_test_cases(2, [(6, [1, 1, 1, 2, 2, 3], [1, 1, 1, 2, 2, 3]), (5, [5, 4, 3, 2, 1], [1, 2, 3, 4, 5])]) == [\\"YES\\", \\"YES\\"] >>> check_test_cases(2, [(2, [10, 20], [30, 40]), (3, [100, 200, 300], [300, 200, 100])]) == [\\"NO\\", \\"YES\\"] pass","solution":"def are_permutations(A, B): Check if two arrays A and B are permutations of each other. return sorted(A) == sorted(B) def check_test_cases(t, test_cases): results = [] for i in range(t): n, A, B = test_cases[i] if are_permutations(A, B): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def collatz_steps(x): Returns the number of steps required for a given starting number x to reach 1 using the Collatz transformation. >>> collatz_steps(6) 8 >>> collatz_steps(19) 20 >>> collatz_steps(27) 111 >>> collatz_steps(1) 0 >>> collatz_steps(2) 1 # Implementation here def collatz_steps_for_multiple_numbers(numbers): Returns a list with the number of steps for each number in the input list. Args: numbers: List of integers Returns: List of integers representing the number of steps to reach 1 for each integer using the Collatz transformation. >>> collatz_steps_for_multiple_numbers([6, 19, 27]) [8, 20, 111] >>> collatz_steps_for_multiple_numbers([2, 3, 7, 15, 1]) [1, 7, 16, 17, 0] >>> collatz_steps_for_multiple_numbers([1, 2, 3, 1000000]) [0, 1, 7, 152] >>> collatz_steps_for_multiple_numbers([]) [] # Implementation here","solution":"def collatz_steps(x): Returns the number of steps required for a given starting number x to reach 1 using the Collatz transformation. steps = 0 while x != 1: if x % 2 == 0: x //= 2 else: x = 3 * x + 1 steps += 1 return steps def collatz_steps_for_multiple_numbers(numbers): Returns a list with the number of steps for each number in the input list. Args: numbers: List of integers Returns: List of integers representing the number of steps to reach 1 for each integer using the Collatz transformation. result = [] for number in numbers: result.append(collatz_steps(number)) return result"},{"question":"def lexicographically_smallest_string(S: str) -> str: Alice is playing a game with a string S of lowercase English letters. In this game, she can perform the following operation as many times as she wants: choose any two distinct characters in the string and swap them. The goal is to make the string as lexicographically small as possible. Returns the lexicographically smallest string possible by sorting the characters of the string. >>> lexicographically_smallest_string(\\"banana\\") \\"aaabnn\\" >>> lexicographically_smallest_string(\\"acbd\\") \\"abcd\\"","solution":"def lexicographically_smallest_string(S): Returns the lexicographically smallest string possible by sorting the characters of the string. return ''.join(sorted(S))"},{"question":"def find_odd_occurrence(arr): Find the integer in the array that appears an odd number of times. >>> find_odd_occurrence([1, 2, 3, 2, 1]) 3 >>> find_odd_occurrence([4, 5, 6, 5, 4, 6, 7]) 7 >>> find_odd_occurrence([9, 8, 7, 8, 7, 6, 5, 6, 5]) 9 def process_test_cases(test_cases): Process multiple test cases and return the results for each test case. >>> test_cases = [ {'array': [1, 2, 3, 2, 1]}, {'array': [4, 5, 6, 5, 4, 6, 7]}, {'array': [9, 8, 7, 8, 7, 6, 5, 6, 5]} ] >>> process_test_cases(test_cases) [3, 7, 9]","solution":"def find_odd_occurrence(arr): Find the integer in the array that appears an odd number of times. result = 0 for number in arr: result ^= number return result def process_test_cases(test_cases): results = [] for test_case in test_cases: arr = test_case['array'] result = find_odd_occurrence(arr) results.append(result) return results"},{"question":"def unique_ranking_count(heights_input: str) -> int: Determine the number of unique ranking lists based on the heights of the players. >>> unique_ranking_count(\\"4 3 2 1\\") 1 >>> unique_ranking_count(\\"3 3 2 1\\") 12 >>> unique_ranking_count(\\"1 1 1 1\\") 1 >>> unique_ranking_count(\\"1 2\\") 2 >>> unique_ranking_count(\\"3 2 2\\") 3","solution":"from itertools import permutations def count_unique_rankings(heights): Returns the number of unique ranking lists. unique_rankings = set() for perm in permutations(heights): unique_rankings.add(perm) return len(unique_rankings) # Function to be called for the task def unique_ranking_count(heights_input): heights = list(map(int, heights_input.split())) return count_unique_rankings(heights)"},{"question":"def can_serve_friends(T, test_cases): Determine if Princess Amelia can serve all her friends with the available spices. Args: T: int - The number of test cases. test_cases: List of tuples - Each tuple contains two integers (N, P) and a list of N integers representing the number of dishes each friend wants. Returns: List of strings - For each test case, \\"Possible\\" if Amelia can serve all her friends, otherwise \\"Not Possible\\". >>> T = 2 >>> test_cases = [(3, 5, [1, 1, 1]), (2, 3, [1, 1])] >>> can_serve_friends(T, test_cases) [\\"Possible\\", \\"Possible\\"] >>> T = 1 >>> test_cases = [(3, 2, [3, 3, 3])] >>> can_serve_friends(T, test_cases) [\\"Not Possible\\"]","solution":"def can_serve_friends(T, test_cases): results = [] for t in range(T): N, P = test_cases[t][:2] dishes_wanted = test_cases[t][2] max_dishes_needed = max(dishes_wanted) if max_dishes_needed <= P: results.append(\\"Possible\\") else: results.append(\\"Not Possible\\") return results"},{"question":"def canFormPalindrome(arr: List[int]) -> bool: Determines whether the array of integers can be rearranged to form a palindrome. >>> canFormPalindrome([1, 2, 3, 2, 1]) == True >>> canFormPalindrome([1, 2, 3, 4, 5]) == False >>> canFormPalindrome([1, 1, 1, 2, 2, 2, 2]) == True >>> canFormPalindrome([1]) == True >>> canFormPalindrome([2, 2]) == True >>> canFormPalindrome([1, 2]) == False >>> canFormPalindrome([1, 3, 3, 1, 3, 1, 1]) == True >>> canFormPalindrome([4, 4, 6, 6, 2, 2]) == True >>> canFormPalindrome([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == False","solution":"def canFormPalindrome(arr): Determines whether the array of integers can be rearranged to form a palindrome. from collections import Counter # Count the frequency of each element in the array frequency = Counter(arr) # Count how many elements have an odd frequency odd_count = sum(1 for count in frequency.values() if count % 2 != 0) # A palindrome can have at most one element with an odd frequency return odd_count <= 1"},{"question":"def second_smallest_distinct(arr): Returns the second smallest distinct number in the array. If there isn't one, returns -1. pass # Your implementation here def test_second_smallest_distinct(): # Test case 1: Normal case with second smallest distinct number assert second_smallest_distinct([3, 1, 2, 1, 3]) == 2 # Test case 2: All elements the same, no second smallest distinct number assert second_smallest_distinct([5, 5, 5]) == -1 # Test case 3: Only one element assert second_smallest_distinct([1]) == -1 # Test case 4: Two distinct elements assert second_smallest_distinct([3, 1]) == 3 # Test case 5: Negative and positive numbers assert second_smallest_distinct([-1, -2, -3, -1, -2, -4]) == -3 # Test case 6: Minimum size array assert second_smallest_distinct([-1000]) == -1 # Test case 7: Large range assert second_smallest_distinct(range(-1000, 1001)) == -999","solution":"def second_smallest_distinct(arr): Returns the second smallest distinct number in the array. If there isn't one, returns -1. distinct_numbers = sorted(set(arr)) return distinct_numbers[1] if len(distinct_numbers) > 1 else -1"},{"question":"def product_except_self(nums): Write a function that takes an array of integers as input and returns a new array where each element at index \`i\` is the product of all the elements in the original array except the one at \`i\`. Do not use division in your solution. Try to solve this problem with a time complexity of O(n). >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([5, 6, 7, 8]) [336, 280, 240, 210] >>> product_except_self([1, 3, 5, 7, 9]) [945, 315, 189, 135, 105] >>> product_except_self([2, 3]) [3, 2] >>> product_except_self([0, 1, 2, 3]) [6, 0, 0, 0] >>> product_except_self([-1, 1, 0, -3, 3]) [0, 0, 9, 0, 0] pass","solution":"def product_except_self(nums): Returns a list where each element at index i is the product of all the elements in the input list except the one at i. :param nums: List of integers :return: List of integers n = len(nums) if n == 0: return [] left_products = [1] * n right_products = [1] * n # Calculate the product of elements to the left of each index for i in range(1, n): left_products[i] = left_products[i - 1] * nums[i - 1] # Calculate the product of elements to the right of each index for i in range(n - 2, -1, -1): right_products[i] = right_products[i + 1] * nums[i + 1] # Calculate the final product array result = [left_products[i] * right_products[i] for i in range(n)] return result"},{"question":"def categorize_books_by_decade(books): Categorizes books into decades based on the publication year. Args: books (list of dicts): List of books, each represented by a dictionary with 'title' and 'year'. Returns: dict: Dictionary where keys are decades (\\"1960s\\", \\"1970s\\", etc.) and values are lists of book titles. >>> books = [ ... {\\"title\\": \\"Book One\\", \\"year\\": 1965}, ... {\\"title\\": \\"Book Two\\", \\"year\\": 1972}, ... {\\"title\\": \\"Book Three\\", \\"year\\": 1988}, ... {\\"title\\": \\"Book Four\\", \\"year\\": 1969}, ... {\\"title\\": \\"Book Five\\", \\"year\\": 1975} ... ] >>> categorize_books_by_decade(books) {'1960s': ['Book One', 'Book Four'], '1970s': ['Book Two', 'Book Five'], '1980s': ['Book Three']} # Function implementation goes here from solution import categorize_books_by_decade def test_categorize_books_by_decade(): books = [ {\\"title\\": \\"Book One\\", \\"year\\": 1965}, {\\"title\\": \\"Book Two\\", \\"year\\": 1972}, {\\"title\\": \\"Book Three\\", \\"year\\": 1988}, {\\"title\\": \\"Book Four\\", \\"year\\": 1969}, {\\"title\\": \\"Book Five\\", \\"year\\": 1975} ] expected_output = { \\"1960s\\": [\\"Book One\\", \\"Book Four\\"], \\"1970s\\": [\\"Book Two\\", \\"Book Five\\"], \\"1980s\\": [\\"Book Three\\"] } assert categorize_books_by_decade(books) == expected_output def test_categorize_books_with_empty_list(): books = [] expected_output = {} assert categorize_books_by_decade(books) == expected_output def test_categorize_books_same_decade(): books = [ {\\"title\\": \\"Book One\\", \\"year\\": 1990}, {\\"title\\": \\"Book Two\\", \\"year\\": 1991}, {\\"title\\": \\"Book Three\\", \\"year\\": 1992} ] expected_output = { \\"1990s\\": [\\"Book One\\", \\"Book Two\\", \\"Book Three\\"] } assert categorize_books_by_decade(books) == expected_output def test_categorize_books_edge_cases(): books = [ {\\"title\\": \\"Book One\\", \\"year\\": 1960}, {\\"title\\": \\"Book Two\\", \\"year\\": 1969}, {\\"title\\": \\"Book Three\\", \\"year\\": 1970}, {\\"title\\": \\"Book Four\\", \\"year\\": 1979}, {\\"title\\": \\"Book Five\\", \\"year\\": 1980} ] expected_output = { \\"1960s\\": [\\"Book One\\", \\"Book Two\\"], \\"1970s\\": [\\"Book Three\\", \\"Book Four\\"], \\"1980s\\": [\\"Book Five\\"] } assert categorize_books_by_decade(books) == expected_output","solution":"def categorize_books_by_decade(books): Categorizes books into decades based on the publication year. Args: books (list of dicts): List of books, each represented by a dictionary with 'title' and 'year'. Returns: dict: Dictionary where keys are decades (\\"1960s\\", \\"1970s\\", etc.) and values are lists of book titles. categorized_books = {} for book in books: year = book['year'] title = book['title'] decade = (year // 10) * 10 decade_key = f\\"{decade}s\\" if decade_key not in categorized_books: categorized_books[decade_key] = [] categorized_books[decade_key].append(title) return categorized_books"},{"question":"def can_divide_into_consecutive_subsequences(n, p): Determine if the list of integers can be divided into one or more subsequences each consisting of consecutive integers. >>> can_divide_into_consecutive_subsequences(5, [1, 2, 3, 4, 5]) == \\"YES\\" >>> can_divide_into_consecutive_subsequences(6, [1, 3, 4, 5, 6, 8]) == \\"NO\\" >>> can_divide_into_consecutive_subsequences(4, [1, 2, 4, 5]) == \\"NO\\" def process_test_cases(t, test_cases): Process the test cases and determine if each case can be divided into one or more subsequences each consisting of consecutive integers. >>> test_cases = [ ... (5, [1, 2, 3, 4, 5]), ... (6, [1, 3, 4, 5, 6, 8]), ... (4, [1, 2, 4, 5]) ... ] >>> process_test_cases(3, test_cases) == [\\"YES\\", \\"NO\\", \\"NO\\"]","solution":"def can_divide_into_consecutive_subsequences(n, p): Determine if the list of integers can be divided into one or more subsequences each consisting of consecutive integers. :param n: Number of integers in the list :param p: List of integers :return: \\"YES\\" if the list can be divided into subsequences of consecutive integers, \\"NO\\" otherwise p.sort() for i in range(n - 1): # Difference between consecutive elements should be at most 1 if p[i + 1] - p[i] > 1: return \\"NO\\" return \\"YES\\" def process_test_cases(t, test_cases): Process the test cases and determine if each case can be divided into one or more subsequences each consisting of consecutive integers. :param t: Number of test cases :param test_cases: List of tuples, each containing (n, list of integers) :return: List of results for each test case results = [] for n, p in test_cases: results.append(can_divide_into_consecutive_subsequences(n, p)) return results"},{"question":"def count_sunlit_buildings(heights): Returns the number of buildings that receive direct sunlight. Parameters: heights (list of int): A list of integers representing the heights of the buildings. Returns: int: The number of buildings that receive direct sunlight. >>> count_sunlit_buildings([3, 1, 4, 5, 2]) 3 >>> count_sunlit_buildings([7, 4, 2, 1]) 1 >>> count_sunlit_buildings([1, 2, 3, 4, 5, 6]) 6","solution":"def count_sunlit_buildings(heights): Returns the number of buildings that receive direct sunlight. Parameters: heights (list of int): A list of integers representing the heights of the buildings. Returns: int: The number of buildings that receive direct sunlight. if not heights: return 0 max_height = heights[0] count = 1 for height in heights[1:]: if height > max_height: count += 1 max_height = height return count"},{"question":"def non_decreasing_order_sequence(m: int, sequence: List[int]) -> List[int]: Given a sequence of m integers, the function returns the sequence sorted in non-decreasing order. Parameters: m (int): The number of elements in the sequence. sequence (list): A list of m integers. Returns: list: The non-decreasing sorted sequence. >>> non_decreasing_order_sequence(5, [3, 1, 4, 1, 5]) [1, 1, 3, 4, 5] >>> non_decreasing_order_sequence(3, [-2, 0, -1]) [-2, -1, 0] >>> non_decreasing_order_sequence(4, [10, 8, 12, 10]) [8, 10, 10, 12] >>> non_decreasing_order_sequence(6, [5, 3, 8, 1, 2, 9]) [1, 2, 3, 5, 8, 9]","solution":"def non_decreasing_order_sequence(m, sequence): Given a sequence of m integers, the function returns the sequence sorted in non-decreasing order. Parameters: m (int): The number of elements in the sequence. sequence (list): A list of m integers. Returns: list: The non-decreasing sorted sequence. return sorted(sequence)"},{"question":"def is_duplicated_sequence(seq: List[int]) -> str: Determine if the given sequence of integers is a Duplicated Sequence. Parameters: seq (list of int): List of integers to check. Returns: str: 'YES' if the sequence is a Duplicated Sequence, otherwise 'NO'. pass from solution import is_duplicated_sequence def test_duplicated_sequence_all_duplicated(): assert is_duplicated_sequence([1, 2, 1, 2]) == \\"YES\\" assert is_duplicated_sequence([3, 3, 2, 2]) == \\"YES\\" assert is_duplicated_sequence([5,5,6,6]) == \\"YES\\" assert is_duplicated_sequence([1,1,2,2]) == \\"YES\\" def test_not_duplicated_sequence_missing_duplicate(): assert is_duplicated_sequence([1, 2, 2, 3]) == \\"NO\\" assert is_duplicated_sequence([1, 1, 2]) == \\"NO\\" assert is_duplicated_sequence([1, 2, 3, 4]) == \\"NO\\" def test_duplicated_sequence_single_element(): assert is_duplicated_sequence([1]) == \\"NO\\" def test_duplicated_sequence_with_extra_duplicates(): assert is_duplicated_sequence([1, 1, 1, 2, 2, 2]) == \\"NO\\" assert is_duplicated_sequence([1, 1, 2, 2, 2, 2]) == \\"NO\\" assert is_duplicated_sequence([1, 1, 1, 1]) == \\"NO\\"","solution":"def is_duplicated_sequence(seq): Determine if the given sequence of integers is a Duplicated Sequence. Parameters: seq (list of int): List of integers to check. Returns: str: 'YES' if the sequence is a Duplicated Sequence, otherwise 'NO'. from collections import Counter counts = Counter(seq) for count in counts.values(): if count != 2: return \\"NO\\" return \\"YES\\""},{"question":"def maximum_enchantment_level(a, b): Determine the maximum possible total enchantment level of the selected paths given that we need to enhance exactly \`b\` paths to ensure all \`a\` nodes are connected. >>> maximum_enchantment_level(3, 2) == 3 >>> maximum_enchantment_level(5, 7) == 28 >>> maximum_enchantment_level(2, 1) == 1 >>> maximum_enchantment_level(4, 6) == 21 >>> maximum_enchantment_level(200000, 199999) == 199999 * 200000 // 2","solution":"def maximum_enchantment_level(a, b): Determine the maximum possible total enchantment level of the selected paths given that we need to enhance exactly \`b\` paths to ensure all \`a\` nodes are connected. # Sum the largest b numbers max_enchantment = sum(range(b, 0, -1)) return max_enchantment"},{"question":"def formTeams(n: int, k: int) -> tuple: Returns the number of full teams and the number of students left without a team. Parameters: n (int): Total number of students k (int): Number of students per team Returns: tuple: A tuple containing the number of full teams and the number of students left without a team Examples: >>> formTeams(20, 3) (6, 2) >>> formTeams(15, 5) (3, 0) >>> formTeams(4, 5) (0, 4) >>> formTeams(10, 1) (10, 0) >>> formTeams(1000000000, 1) (1000000000, 0) >>> formTeams(1000000000, 500000000) (2, 0) >>> formTeams(1000000000, 300000000) (3, 100000000)","solution":"def formTeams(n, k): Returns the number of full teams and the number of students left without a team. Parameters: n (int): Total number of students k (int): Number of students per team Returns: tuple: A tuple containing the number of full teams and the number of students left without a team full_teams = n // k leftover_students = n % k return (full_teams, leftover_students)"},{"question":"def mostFrequentCharacters(s: str, k: int) -> List[str]: Returns the k most frequently occurring characters in the input string s. Args: s (str): The input string containing only lowercase English letters. k (int): The number of most frequent characters to return. Returns: List[str]: A list of the k most frequently occurring characters in s. Example: >>> mostFrequentCharacters(\\"mississippi\\", 2) ['i', 's'] >>> mostFrequentCharacters(\\"programming\\", 3) ['g', 'm', 'r'] >>> mostFrequentCharacters(\\"alphabet\\", 1) ['a'] from solution import mostFrequentCharacters def test_mostFrequentCharacters_example1(): assert mostFrequentCharacters(\\"mississippi\\", 2) == ['i', 's'] def test_mostFrequentCharacters_example2(): assert mostFrequentCharacters(\\"programming\\", 3) == ['g', 'm', 'r'] def test_mostFrequentCharacters_example3(): assert mostFrequentCharacters(\\"alphabet\\", 1) == ['a'] def test_mostFrequentCharacters_ties(): assert mostFrequentCharacters(\\"aabbcc\\", 2) == ['a', 'b'] assert mostFrequentCharacters(\\"aabbcc\\", 3) == ['a', 'b', 'c'] def test_mostFrequentCharacters_with_one_char(): assert mostFrequentCharacters(\\"aaaaa\\", 1) == ['a'] def test_mostFrequentCharacters_alphabet(): assert mostFrequentCharacters(\\"thequickbrownfoxjumpsoverthelazydog\\", 5) == ['o', 'e', 'h', 'r', 't'] def test_mostFrequentCharacters_single_char(): assert mostFrequentCharacters(\\"x\\", 1) == ['x'] def test_mostFrequentCharacters_all_distinct(): assert mostFrequentCharacters(\\"abcdefg\\", 3) == ['a', 'b', 'c']","solution":"def mostFrequentCharacters(s, k): Returns the k most frequently occurring characters in the input string s. from collections import Counter # Count the frequency of each character frequency = Counter(s) # Sort characters based on frequency and then alphabetically sorted_chars = sorted(frequency.items(), key=lambda x: (-x[1], x[0])) # Extract the top k characters result = [char for char, count in sorted_chars[:k]] return result"},{"question":"from typing import List def max_gold(N: int, values: List[int]) -> int: Determine the maximum amount of gold the thief can steal without alerting the villagers by not stealing from two consecutive houses. >>> max_gold(5, [3, 2, 5, 10, 7]) == 15 >>> max_gold(1, [10]) == 10 >>> max_gold(2, [3, 7]) == 7 >>> max_gold(3, [0, 0, 0]) == 0 >>> max_gold(4, [20, 10, 30, 50]) == 70 >>> max_gold(4, [10, 10, 10, 10]) == 20 >>> max_gold(10**6, [1] * 10**6) == 500000","solution":"from typing import List def max_gold(N: int, values: List[int]) -> int: if N == 0: return 0 if N == 1: return values[0] dp = [0] * N dp[0] = values[0] dp[1] = max(values[0], values[1]) for i in range(2, N): dp[i] = max(dp[i - 1], dp[i - 2] + values[i]) return dp[N - 1]"},{"question":"from typing import List, Tuple from collections import deque def shortest_path(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> int: Finds the shortest path from the starting position to the destination position in the grid. Parameters: grid (List[List[int]]): A 2D list representing the grid where 0s are walkable cells and 1s are obstacles. start (Tuple[int, int]): The starting position as a tuple (sx, sy). end (Tuple[int, int]): The destination position as a tuple (dx, dy). Returns: int: The length of the shortest path from start to destination, or -1 if no valid path exists. Examples: >>> grid = [ ... [0, 1, 0, 0, 0], ... [0, 1, 0, 1, 0], ... [0, 0, 0, 1, 0], ... [0, 1, 1, 1, 0], ... [0, 0, 0, 0, 0] ... ] >>> start = (0, 0) >>> end = (4, 4) >>> shortest_path(grid, start, end) 8 >>> grid = [ ... [0, 1, 0], ... [1, 1, 0], ... [0, 1, 0] ... ] >>> start = (0, 0) >>> end = (2, 2) >>> shortest_path(grid, start, end) -1 pass # Your code here def main(n: int, m: int, grid: List[List[int]], sx: int, sy: int, dx: int, dy: int) -> None: start = (sx, sy) end = (dx, dy) print(shortest_path(grid, start, end)) # Unit Tests def test_shortest_path(): grid = [ [0, 1, 0, 0, 0], [0, 1, 0, 1, 0], [0, 0, 0, 1, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 0] ] start = (0, 0) end = (4, 4) assert shortest_path(grid, start, end) == 8 def test_no_path(): grid = [ [0, 1, 0], [1, 1, 0], [0, 1, 0] ] start = (0, 0) end = (2, 2) assert shortest_path(grid, start, end) == -1 def test_start_is_end(): grid = [ [0, 1, 0], [1, 0, 1], [0, 0, 0] ] start = (1, 1) end = (1, 1) assert shortest_path(grid, start, end) == 0 def test_grid_full_of_obstacles(): grid = [ [1, 1, 1], [1, 0, 1], [1, 1, 1] ] start = (1, 1) end = (1, 1) assert shortest_path(grid, start, end) == 0 end = (0, 0) assert shortest_path(grid, start, end) == -1 def test_large_grid(): grid = [[0]*100 for _ in range(100)] start = (0, 0) end = (99, 99) assert shortest_path(grid, start, end) == 198 # Example usage if __name__ == \\"__main__\\": n = 5 m = 5 grid = [ [0, 1, 0, 0, 0], [0, 1, 0, 1, 0], [0, 0, 0, 1, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 0] ] sx, sy, dx, dy = 0, 0, 4, 4 main(n, m, grid, sx, sy, dx, dy)","solution":"from collections import deque def shortest_path(grid, start, end): n, m = len(grid), len(grid[0]) # Directions for moving up, down, left, and right directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] def is_valid(x, y): return 0 <= x < n and 0 <= y < m and grid[x][y] == 0 sx, sy = start dx, dy = end if grid[sx][sy] == 1 or grid[dx][dy] == 1: return -1 queue = deque([(sx, sy, 0)]) visited = set((sx, sy)) while queue: x, y, depth = queue.popleft() if (x, y) == (dx, dy): return depth for direction in directions: nx, ny = x + direction[0], y + direction[1] if is_valid(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, depth + 1)) return -1 def main(n, m, grid, sx, sy, dx, dy): start = (sx, sy) end = (dx, dy) print(shortest_path(grid, start, end)) # Sample input n = 5 m = 5 grid = [ [0, 1, 0, 0, 0], [0, 1, 0, 1, 0], [0, 0, 0, 1, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 0] ] sx, sy, dx, dy = 0, 0, 4, 4 main(n, m, grid, sx, sy, dx, dy)"},{"question":"def min_visible_peaks(heights): Returns the minimum number of visible peaks after processing the buildings. A peak is a building that is taller than its neighbouring buildings. >>> min_visible_peaks([5, 3, 8, 3, 4, 1]) 3 >>> min_visible_peaks([2, 2, 2, 3, 2]) 1 >>> min_visible_peaks([1, 2, 1]) 1 >>> min_visible_peaks([3, 1, 2]) 2 >>> min_visible_peaks([1]) 1 >>> min_visible_peaks([1, 1, 1]) 0 >>> min_visible_peaks([]) 0 pass def process_test_cases(test_cases): Processes multiple test cases to determine the minimum number of visible peaks after processing the buildings. >>> test_cases = [(6, [5, 3, 8, 3, 4, 1]), (5, [2, 2, 2, 3, 2])] >>> process_test_cases(test_cases) [3, 1] pass","solution":"def min_visible_peaks(heights): Returns the minimum number of visible peaks after processing the buildings. A peak is a building that is taller than its neighbouring buildings. if not heights: return 0 n = len(heights) if n == 1: return 1 peaks = 0 # Check the first building if heights[0] > heights[1]: peaks += 1 # Check the buildings in between for i in range(1, n - 1): if heights[i] > heights[i - 1] and heights[i] > heights[i + 1]: peaks += 1 # Check the last building if heights[-1] > heights[-2]: peaks += 1 return peaks def process_test_cases(test_cases): results = [] for case in test_cases: N = case[0] heights = case[1] results.append(min_visible_peaks(heights)) return results"},{"question":"def reverseWords(sentence: str) -> str: Returns a new sentence with the words in reverse order. :param sentence: A string representing the sentence :return: A new string with words in the reverse order >>> reverseWords(\\"the sky is blue\\") == \\"blue is sky the\\" >>> reverseWords(\\"hello world!\\") == \\"world! hello\\" >>> reverseWords(\\"hello\\") == \\"hello\\" >>> reverseWords(\\"\\") == \\"\\" >>> reverseWords(\\"the sky is blue\\") == \\"blue is sky the\\"","solution":"def reverseWords(sentence): Returns a new sentence with the words in reverse order. :param sentence: A string representing the sentence :return: A new string with words in the reverse order words = sentence.split() reversed_words = words[::-1] reversed_sentence = \\" \\".join(reversed_words) return reversed_sentence"},{"question":"def sum_odd_indexed_elements(data): Computes the sum of all odd-indexed elements (1-based) that are greater than 5. Odd-indexed elements (1-based) correspond to the even-indexed elements (0-based). :param data: List of integers :return: Sum of odd-indexed elements that are greater than 5 >>> sum_odd_indexed_elements([4, 8, 2, 15, 7, 20]) 43 >>> sum_odd_indexed_elements([3, 1, 12, 4, 6, 5, 7]) 0 >>> sum_odd_indexed_elements([10, 3, 14, 7]) 7 # Write your code here","solution":"def sum_odd_indexed_elements(data): Computes the sum of all odd-indexed elements (1-based) that are greater than 5. Odd-indexed elements (1-based) correspond to the even-indexed elements (0-based). :param data: List of integers :return: Sum of odd-indexed elements that are greater than 5 return sum(value for index, value in enumerate(data) if index % 2 == 1 and value > 5)"},{"question":"from typing import List, Tuple def recommend_videos(watched_videos: List[int], popular_videos: List[Tuple[int, int]], k: int) -> List[int]: Recommend at most 'k' popular videos that the user has not watched yet. :param watched_videos: List of integers representing video identifiers that the user has watched recently. :param popular_videos: List of tuples where each tuple contains a video identifier and its popularity score. The list is ordered by popularity score in descending order. :param k: Number of video recommendations to return to the user. :return: List of video identifiers (max 'k') maintaining the order of their popularity scores. pass # implement the function here # Example test cases if __name__ == \\"__main__\\": watched_videos1 = [1, 2, 3, 4, 5] popular_videos1 = [(6, 100), (2, 98), (7, 97), (4, 95), (8, 93), (9, 92)] k1 = 3 print(recommend_videos(watched_videos1, popular_videos1, k1)) # Expected: [6, 7, 8] watched_videos2 = [5, 6, 7, 8, 9, 10] popular_videos2 = [(1, 105), (2, 101), (3, 99), (4, 98)] k2 = 2 print(recommend_videos(watched_videos2, popular_videos2, k2)) # Expected: [1, 2] watched_videos3 = [10, 20, 30, 40, 50] popular_videos3 = [(60, 90), (70, 85), (80, 80), (20, 75), (30, 70), (90, 65)] k3 = 4 print(recommend_videos(watched_videos3, popular_videos3, k3)) # Expected: [60, 70, 80, 90]","solution":"from typing import List, Tuple def recommend_videos(watched_videos: List[int], popular_videos: List[Tuple[int, int]], k: int) -> List[int]: Recommend at most 'k' popular videos that the user has not watched yet. :param watched_videos: List of integers representing video identifiers that the user has watched recently. :param popular_videos: List of tuples where each tuple contains a video identifier and its popularity score. The list is ordered by popularity score in descending order. :param k: Number of video recommendations to return to the user. :return: List of video identifiers (max 'k') maintaining the order of their popularity scores. watched_set = set(watched_videos) recommendations = [] for video_id, score in popular_videos: if video_id not in watched_set: recommendations.append(video_id) if len(recommendations) == k: break return recommendations"},{"question":"def can_win_by_removing_one(char_string: str) -> str: Determines if by removing one character from the string we can make it a palindrome. Parameters: char_string: A string of lowercase English alphabets. Returns: \\"Win\\" if it’s possible for some player to remove exactly one character to make S a palindrome, otherwise \\"Draw\\". >>> can_win_by_removing_one(\\"abca\\") \\"Win\\" >>> can_win_by_removing_one(\\"abc\\") \\"Draw\\" >>> can_win_by_removing_one(\\"abcbca\\") \\"Win\\" >>> can_win_by_removing_one(\\"racecar\\") \\"Win\\" >>> can_win_by_removing_one(\\"aaa\\") \\"Win\\" >>> can_win_by_removing_one(\\"abcde\\") \\"Draw\\" def process_cases(T: int, cases: List[str]) -> List[str]: Processes multiple test cases to determine the result for each. Parameters: T: Integer, the number of test cases. cases: List of strings, each test case. Returns: List of strings, each being either \\"Win\\" or \\"Draw\\" based on the input case. >>> process_cases(3, [\\"abca\\", \\"abc\\", \\"abcbca\\"]) [\\"Win\\", \\"Draw\\", \\"Win\\"]","solution":"def can_win_by_removing_one(char_string): Determines if by removing one character from the string we can make it a palindrome. n = len(char_string) def is_palindrome(s): return s == s[::-1] for i in range(n): if is_palindrome(char_string[:i] + char_string[i+1:]): return \\"Win\\" return \\"Draw\\" def process_cases(T, cases): results = [] for i in range(T): results.append(can_win_by_removing_one(cases[i])) return results"},{"question":"from typing import List, Tuple def flowerbeds_overlap(flowerbeds: List[Tuple[int, int, int]]) -> str: Determine if any two circular flowerbeds overlap. >>> flowerbeds_overlap([(1, 1, 1), (5, 5, 2)]) \\"NO\\" >>> flowerbeds_overlap([(0, 0, 2), (3, 0, 2), (0, 5, 1)]) \\"YES\\"","solution":"import math def flowerbeds_overlap(flowerbeds): n = len(flowerbeds) for i in range(n): for j in range(i + 1, n): x1, y1, r1 = flowerbeds[i] x2, y2, r2 = flowerbeds[j] distance = math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2) if distance < (r1 + r2): return \\"YES\\" return \\"NO\\""},{"question":"def find_minimum_cycle(n: int, m: int, tracks: List[Tuple[int, int, int]]) -> int: Determine if there exists a triangular cycle with non-zero cost and return its minimum total cost. >>> find_minimum_cycle(4, 5, [(0, 1, 5), (1, 2, 4), (2, 0, 3), (0, 3, 7), (3, 1, 6)]) 12 >>> find_minimum_cycle(3, 3, [(0, 1, 2), (1, 2, 2), (2, 0, 2)]) 6 >>> find_minimum_cycle(3, 2, [(0, 1, 3), (1, 2, 3)]) -1 from typing import List, Tuple def test_find_minimum_cycle(): assert find_minimum_cycle( 4, 5, [ (0, 1, 5), (1, 2, 4), (2, 0, 3), (0, 3, 7), (3, 1, 6) ] ) == 12 assert find_minimum_cycle( 3, 3, [ (0, 1, 2), (1, 2, 2), (2, 0, 2) ] ) == 6 assert find_minimum_cycle( 3, 2, [ (0, 1, 3), (1, 2, 3) ] ) == -1 def test_no_cycle_possible(): assert find_minimum_cycle( 5, 5, [ (0, 1, 7), (1, 2, 5), (2, 3, 3), (3, 4, 2), (4, 0, 9) ] ) == -1 def test_multiple_cycles(): assert find_minimum_cycle( 5, 7, [ (0, 1, 1), (1, 2, 1), (2, 0, 1), (0, 3, 3), (3, 4, 2), (4, 0, 2), (3, 0, 3) ] ) == 3","solution":"def find_minimum_cycle(n, m, tracks): # Create an adjacency matrix to store the costs adj = [[float('inf')] * n for _ in range(n)] for u, v, c in tracks: adj[u][v] = c min_cost = float('inf') # Try all pairs of edges to find cycles u -> v, v -> w, w -> u for u in range(n): for v in range(n): if u != v and adj[u][v] != float('inf'): for w in range(n): if v != w and w != u and adj[v][w] != float('inf') and adj[w][u] != float('inf'): min_cost = min(min_cost, adj[u][v] + adj[v][w] + adj[w][u]) return min_cost if min_cost != float('inf') else -1"},{"question":"def min_total_water(T: int, test_cases: List[Tuple[int, int, List[List[int]]]]) -> List[int]: Determine the minimum total amount of water required each day to meet the requirements of all cells in the field. Args: T: The number of test cases. test_cases: A list of tuples, where each tuple contains: - M: The number of rows in the grid. - N: The number of columns in the grid. - grid: A 2D list of integers representing the water requirements for each cell. Returns: A list of integers, where each integer represents the minimum total amount of water used for the corresponding test case. Examples: >>> min_total_water(1, [(3, 3, [[1, 2, 3], [4, 1, 2], [3, 4, 1]])]) [11] >>> min_total_water(2, [(2, 2, [[3, 5], [6, 7]]), (1, 1, [[2]])]) [12, 2] pass # Unit tests def test_min_total_water(): input_data_1 = (1, [(3, 3, [[1, 2, 3], [4, 1, 2], [3, 4, 1]])]) output_1 = [11] assert min_total_water(*input_data_1) == output_1 input_data_2 = (2, [(2, 2, [[3, 5], [6, 7]]), (1, 1, [[2]])]) output_2 = [12, 2] assert min_total_water(*input_data_2) == output_2 input_data_3 = (1, [(3, 2, [[1, 2], [3, 4], [5, 6]])]) output_3 = [12] assert min_total_water(*input_data_3) == output_3 if __name__ == \\"__main__\\": test_min_total_water() print(\\"All tests passed!\\")","solution":"def min_total_water(T, test_cases): results = [] for case in test_cases: M, N, grid = case total_water = 0 for row in range(M): max_in_row = max(grid[row]) total_water += max_in_row results.append(total_water) return results # Parsing input and calling the function def parse_and_solve(input_data): data = input_data.strip().split() index = 0 T = int(data[index]) index += 1 test_cases = [] for _ in range(T): M = int(data[index]) N = int(data[index+1]) index += 2 grid = [] for _ in range(M): row = list(map(int, data[index:index+N])) grid.append(row) index += N test_cases.append((M, N, grid)) results = min_total_water(T, test_cases) return \\"n\\".join(map(str, results))"},{"question":"def compute_other_dimension(P, L): Given the perimeter P and one dimension L of a rectangle, this function computes and returns the other dimension. >>> compute_other_dimension(24, 5) 7 >>> compute_other_dimension(20, 5) 5 >>> compute_other_dimension(10, 0) 5 >>> compute_other_dimension(1000000, 250000) 250000 >>> compute_other_dimension(30, 10) 5","solution":"def compute_other_dimension(P, L): Given the perimeter P and one dimension L of a rectangle, this function computes and returns the other dimension. return P // 2 - L"},{"question":"def distribute_participants(t: int, test_cases: List[Tuple[int, int]]) -> List[str]: Distribute participants into teams of specified sizes. Each participant will receive a unique ID number between 1 and N, where N is the total number of participants. Participants will be grouped into teams of size k. >>> distribute_participants(1, [(9, 3)]) ['(1 2 3) (4 5 6) (7 8 9)'] >>> distribute_participants(1, [(10, 4)]) ['(1 2 3 4) (5 6 7 8) (9 10)']","solution":"def distribute_participants(t, test_cases): results = [] for case in range(t): N, k = test_cases[case] teams = [] for i in range(1, N + 1, k): team = \\" \\".join(map(str, range(i, min(i + k, N + 1)))) teams.append(f\\"({team})\\") results.append(\\" \\".join(teams)) return results"},{"question":"def min_trips(weights, max_weight): Determines the minimum number of trips required to deliver all packages. Parameters: weights (list): List of package weights. max_weight (int): Maximum weight that the truck can carry in a single trip. Returns: int: Minimum number of trips required. Examples: >>> min_trips([2, 3, 5, 6], 10) 2 >>> min_trips([1, 2, 3, 4, 5], 10) 2 >>> min_trips([5, 5, 5], 5) 3 >>> min_trips([6, 3], 8) 2","solution":"def min_trips(weights, W): Determines the minimum number of trips required to deliver all the packages. Parameters: weights (list): List of package weights. W (int): Maximum weight that the truck can carry in a single trip. Returns: int: Minimum number of trips required. # Sort weights in descending order to optimize fitting weights.sort(reverse=True) trips = 0 while weights: current_trip_weight = 0 packages_in_current_trip = [] for w in weights: if current_trip_weight + w <= W: current_trip_weight += w packages_in_current_trip.append(w) for w in packages_in_current_trip: weights.remove(w) trips += 1 return trips"},{"question":"def find_majority_element(arr): Finds an element that appears more than floor(n/2) times in the array. Returns that element if it exists, otherwise returns -1. >>> find_majority_element([3, 3, 4, 2, 3, 3, 3]) 3 >>> find_majority_element([1, 2, 3, 4, 5]) -1","solution":"def find_majority_element(arr): Finds an element that appears more than floor(n/2) times in the array. Returns that element if it exists, otherwise returns -1. n = len(arr) count = {} for num in arr: if num in count: count[num] += 1 else: count[num] = 1 if count[num] > n // 2: return num return -1"},{"question":"def hasPairWithSum(arr, target_sum): Given an array of n integers and a target integer sum, return whether any two distinct numbers in the array add up to the target sum. Args: arr (List[int]): the array of integers target_sum (int): the target sum Returns: bool: True if there are two distinct numbers in the array that add up to target_sum, otherwise False. Examples: >>> hasPairWithSum([3, 5, 1, 7, 9], 12) True >>> hasPairWithSum([4, 6, 8, 4, 11], 20) False","solution":"def hasPairWithSum(arr, target_sum): Returns True if there exist two distinct numbers in the array that add up to target_sum, otherwise returns False. seen_numbers = set() for number in arr: required_number = target_sum - number if required_number in seen_numbers: return True seen_numbers.add(number) return False"},{"question":"from typing import List def longest_increasing_subsequence(arr: List[int]) -> int: Given a list of integers, return the length of the longest increasing subsequence. An increasing subsequence consists of elements that increase in value and can be derived from the original list by deleting some or none of the elements without changing the order of the remaining elements. >>> longest_increasing_subsequence([10, 9, 2, 5, 3, 7, 101, 18]) 4 >>> longest_increasing_subsequence([]) 0 >>> longest_increasing_subsequence([5, 5, 5, 5, 5]) 1 >>> longest_increasing_subsequence([5, 4, 3, 2, 1]) 1 >>> longest_increasing_subsequence([1, 2, 3, 4, 5]) 5","solution":"from typing import List def longest_increasing_subsequence(arr: List[int]) -> int: if not arr: return 0 n = len(arr) dp = [1] * n for i in range(1, n): for j in range(i): if arr[i] > arr[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"def count_distinct_prices(n, v, prices): Returns the count of distinct product prices that are less than or equal to v. Parameters: n (int): The number of products v (int): The maximum price Anna is interested in prices (List[int]): List of prices of the products Returns: int: The number of distinct prices among the products that are less than or equal to v Examples: >>> count_distinct_prices(5, 10, [8, 4, 10, 2, 8]) 4 >>> count_distinct_prices(7, 15, [16, 22, 15, 15, 10, 5, 9]) 4","solution":"def count_distinct_prices(n, v, prices): Returns the count of distinct product prices that are less than or equal to v. distinct_prices = set() for price in prices: if price <= v: distinct_prices.add(price) return len(distinct_prices)"},{"question":"def max_profit(prices: List[int]) -> int: Given a list of integers representing stock prices where each element in the list corresponds to the price of a certain stock on a given day, find the maximum profit that can be achieved from completing at most one transaction (i.e., buy one and sell one share of the stock). If no profit is possible, return 0. The transaction must be completed in chronological order, meaning you must buy before you sell. >>> max_profit([7, 1, 5, 3, 6, 4]) 5 >>> max_profit([7, 6, 4, 3, 1]) 0","solution":"def max_profit(prices): Returns the maximum profit that can be achieved from a single transaction. If no profit is possible, return 0. if not prices: return 0 min_price = prices[0] max_profit = 0 for price in prices: if price < min_price: min_price = price current_profit = price - min_price if current_profit > max_profit: max_profit = current_profit return max_profit"},{"question":"def smallest_max_after_operations(n: int, a: List[int]) -> int: Determines the smallest possible value of the maximum element in the sequence after performing any number of operations. :param n: int - Number of elements in the sequence :param a: List[int] - The sequence of positive integers :return: int - The smallest possible value of the maximum element >>> smallest_max_after_operations(3, [4, 6, 8]) 24 >>> smallest_max_after_operations(5, [10, 15, 20, 25, 30]) 300 >>> smallest_max_after_operations(2, [17, 19]) 323 >>> smallest_max_after_operations(4, [7, 7, 7, 7]) 7 >>> smallest_max_after_operations(1, [13]) 13 >>> smallest_max_after_operations(2, [1000000000, 999999937]) 999999937000000000 >>> smallest_max_after_operations(3, [2, 5, 7]) 70","solution":"from math import gcd from functools import reduce def smallest_max_after_operations(n, a): Determines the smallest possible value of the maximum element in the sequence after performing any number of operations. :param n: int - Number of elements in the sequence :param a: List[int] - The sequence of positive integers :return: int - The smallest possible value of the maximum element def lcm(x, y): return x * y // gcd(x, y) # Reducing the entire array to a single LCM overall_lcm = reduce(lcm, a) return overall_lcm"},{"question":"def can_form_garden(l, w, p) -> bool: Determines if a garden of length l and width w can be formed with perimeter p. >>> can_form_garden(5, 3, 16) True >>> can_form_garden(4, 2, 12) True >>> can_form_garden(7, 5, 30) False def handle_input(t: int, test_cases: List[Tuple[int, int, int]]) -> List[str]: Handles the input and runs the can_form_garden function for each test case. >>> handle_input(3, [(5, 3, 16), (4, 2, 12), (7, 5, 30)]) ['YES', 'YES', 'NO'] >>> handle_input(3, [(1, 1, 4), (10, 10, 40), (2, 3, 12)]) ['YES', 'YES', 'NO']","solution":"def can_form_garden(l, w, p): Determines if a garden of length l and width w can be formed with perimeter p. return 2 * (l + w) == p def handle_input(t, test_cases): Handles the input and runs the can_form_garden function for each test case. results = [] for l, w, p in test_cases: if can_form_garden(l, w, p): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def findLeaders(arr, n): Given an array arr of N integers, returns an array of integers which are the leaders in the array. A leader is an element which is greater than all the elements to its right side. >>> findLeaders([16, 17, 4, 3, 5, 2], 6) [17, 5, 2] >>> findLeaders([1, 2, 3, 4, 0], 5) [4, 0] >>> findLeaders([10], 1) [10] >>> findLeaders([5, 5, 5, 5, 5], 5) [5] >>> findLeaders([9, 8, 7, 6, 5], 5) [9, 8, 7, 6, 5] >>> findLeaders([10, 5, 11, 3, 2, 6, 1], 7) [11, 6, 1]","solution":"def findLeaders(arr, n): Returns an array of integers which are the leaders in the given array. A leader is an element which is greater than all the elements to its right side. leaders = [] max_from_right = arr[-1] leaders.append(max_from_right) for i in range(n-2, -1, -1): # Traverse the array from right to left if arr[i] > max_from_right: leaders.append(arr[i]) max_from_right = arr[i] leaders.reverse() # Reverse the list since we collected leaders from right to left return leaders"},{"question":"def findSubsets(nums): Returns all subsets (the power set) of the list of integers nums, ensuring no duplicate subsets. >>> sorted(findSubsets([1, 2, 3])) == sorted([[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]) >>> sorted(findSubsets([1, 2, 2])) == sorted([[], [1], [1, 2], [1, 2, 2], [2], [2, 2]]) >>> findSubsets([1]) == [[], [1]] >>> findSubsets([2, 2, 2]) == [[], [2], [2, 2], [2, 2, 2]] >>> findSubsets([]) == [[]] >>> sorted(findSubsets([-1, 2, 2])) == sorted([[], [-1], [-1, 2], [-1, 2, 2], [2], [2, 2]])","solution":"def findSubsets(nums): Returns all subsets (the power set) of the list of integers nums, ensuring no duplicate subsets. nums.sort() # Sort to handle duplicates easily result = [] subset = [] def backtrack(start): result.append(subset[:]) for i in range(start, len(nums)): if i > start and nums[i] == nums[i - 1]: continue subset.append(nums[i]) backtrack(i + 1) subset.pop() backtrack(0) return result"},{"question":"def largest_sum_with_k_distinct(N: int, K: int, s: List[int]) -> int: Returns the largest sum of contiguous subsequence with at most K distinct integers. Given a sequence \`s\` of length \`N\` consisting of integers, determine the largest sum of contiguous subsequence in \`s\` that has at most \`K\` distinct integers. Args: N : int : length of the list \`s\` K : int : maximum number of distinct integers allowed s : List[int] : list of integers Returns: int : largest sum of contiguous subsequence with at most \`K\` distinct integers Constraints: 1 <= N <= 10^5 1 <= s_i <= 10^9 1 <= K <= N Example: >>> largest_sum_with_k_distinct(6, 2, [4, 3, 5, 2, 5, 4]) 12 >>> largest_sum_with_k_distinct(5, 1, [2, 2, 2, 2, 2]) 10","solution":"def largest_sum_with_k_distinct(N, K, s): Returns the largest sum of contiguous subsequence with at most K distinct integers. from collections import defaultdict l = 0 current_sum = 0 max_sum = float('-inf') distinct_count = 0 frequency = defaultdict(int) for r in range(N): if frequency[s[r]] == 0: distinct_count += 1 frequency[s[r]] += 1 current_sum += s[r] while distinct_count > K: frequency[s[l]] -= 1 if frequency[s[l]] == 0: distinct_count -= 1 current_sum -= s[l] l += 1 max_sum = max(max_sum, current_sum) return max_sum"},{"question":"class SegmentTree: def __init__(self, data): self.n = len(data) self.tree = [0] * (2 * self.n) self.build(data) def build(self, data): Build the segment tree from the given data pass def update(self, pos, value): Update the value at index pos to value pass def range_sum(self, left, right): Get the sum of the values in the range [left, right] pass def process_queries(n, queries, data): Handle the update and range sum queries efficiently using a segment tree. >>> process_queries(5, [[2, 1, 3], [1, 2, 10], [2, 1, 3], [2, 3, 5]], [1, 2, 3, 4, 5]) [6, 14, 12] >>> process_queries(3, [[1, 1, 5]], [1, 2, 3]) [] >>> process_queries(3, [[2, 1, 3]], [1, 2, 3]) [6] >>> process_queries(3, [[1, 1, 5], [2, 1, 3]], [1, 2, 3]) [10] pass","solution":"class SegmentTree: def __init__(self, data): self.n = len(data) self.tree = [0] * (2 * self.n) self.build(data) def build(self, data): # Build the segment tree from the given data for i in range(self.n): self.tree[self.n + i] = data[i] for i in range(self.n - 1, 0, -1): self.tree[i] = self.tree[2 * i] + self.tree[2 * i + 1] def update(self, pos, value): # Update the value at index pos to value pos += self.n self.tree[pos] = value while pos > 1: pos //= 2 self.tree[pos] = self.tree[2 * pos] + self.tree[2 * pos + 1] def range_sum(self, left, right): # Get the sum of the values in the range [left, right] left += self.n right += self.n summ = 0 while left < right: if left % 2: summ += self.tree[left] left += 1 if right % 2: right -= 1 summ += self.tree[right] left //= 2 right //= 2 return summ def process_queries(n, queries, data): segment_tree = SegmentTree(data) results = [] for query in queries: if query[0] == 1: # Update query _, index, value = query segment_tree.update(index - 1, value) # Convert to 0-based index elif query[0] == 2: # Range sum query _, left, right = query results.append(segment_tree.range_sum(left - 1, right)) return results"},{"question":"from collections import deque def min_operations(n: int) -> int: Returns the minimum number of operations needed to display the number n starting from 1. >>> min_operations(7) 4 >>> min_operations(15) 6 >>> min_operations(1) 0 >>> min_operations(2) 1 >>> min_operations(16) 4 >>> min_operations(31) 8","solution":"from collections import deque def min_operations(n): Returns the minimum number of operations needed to display the number n starting from 1. if n == 1: return 0 # Already at 1, no operations needed queue = deque([(1, 0)]) # (current number, current number of operations) visited = set() # To keep track of visited numbers to avoid cycles and redundant work while queue: current, operations = queue.popleft() if current == n: return operations if current not in visited: visited.add(current) if current < n: queue.append((current * 2, operations + 1)) queue.append((current + 1, operations + 1)) # Example Usage: # print(min_operations(7)) # Output: 4 # print(min_operations(15)) # Output: 6"},{"question":"from typing import Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_balanced(root: Optional[TreeNode]) -> bool: Determine if a binary tree is height-balanced. >>> data = [1, 2, 2, 3, 3, None, None, 4, 4] >>> root = build_tree_from_level_order(data) >>> is_balanced(root) False >>> data = [3, 9, 20, None, None, 15, 7] >>> root = build_tree_from_level_order(data) >>> is_balanced(root) True def build_tree_from_level_order(data): Helper function to build tree from level-order list. def test_example_1(): data = [1, 2, 2, 3, 3, None, None, 4, 4] root = build_tree_from_level_order(data) assert is_balanced(root) == False def test_example_2(): data = [3, 9, 20, None, None, 15, 7] root = build_tree_from_level_order(data) assert is_balanced(root) == True def test_empty_tree(): data = [] root = build_tree_from_level_order(data) assert is_balanced(root) == True def test_single_node(): data = [1] root = build_tree_from_level_order(data) assert is_balanced(root) == True def test_balanced_tree(): data = [1, 2, 2, 3, 3, 3, 3] root = build_tree_from_level_order(data) assert is_balanced(root) == True def test_unbalanced_tree(): data = [1, 2, 2, 3, None, None, None, 4, None] root = build_tree_from_level_order(data) assert is_balanced(root) == False","solution":"from typing import Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_balanced(root: Optional[TreeNode]) -> bool: def check_balance(node): if not node: return 0, True left_height, left_balanced = check_balance(node.left) right_height, right_balanced = check_balance(node.right) if not left_balanced or not right_balanced: return 0, False if abs(left_height - right_height) > 1: return 0, False return 1 + max(left_height, right_height), True _, balanced = check_balance(root) return balanced # Helper function to build tree from level-order list def build_tree_from_level_order(data): if not data: return None root = TreeNode(data[0]) queue = [root] i = 1 while i < len(data): current = queue.pop(0) if data[i] is not None: current.left = TreeNode(data[i]) queue.append(current.left) i += 1 if i < len(data) and data[i] is not None: current.right = TreeNode(data[i]) queue.append(current.right) i += 1 return root"},{"question":"def maximize_savings(test_cases): Maximize the amount of money you can save when buying a selection of items subject to a budget constraint. Args: test_cases (List[Tuple[Tuple[int, int], List[int]]]): A list of test cases, each containing a tuple of (N, B) and a list of item prices. Returns: List[int]: A list of the maximum amount of money you can save for each test case. >>> maximize_savings([((5, 50), [20, 10, 30, 40, 50]), ((4, 15), [5, 10, 15, 20])]) [20, 0] >>> maximize_savings([((3, 0), [5, 10, 15])]) [0] >>> maximize_savings([((1, 10), [10])]) [0] >>> maximize_savings([((3, 5), [10, 20, 30])]) [5] >>> maximize_savings([((3, 100), [30, 20, 10])]) [40]","solution":"def maximize_savings(test_cases): results = [] for test_case in test_cases: N, B = test_case[0] prices = test_case[1] prices.sort() total = 0 for price in prices: if total + price <= B: total += price else: break results.append(B - total) return results"},{"question":"class BinarySearchTree: Class for Binary Search Tree (BST) operations including insertion and search. Example usage: >>> tree = BinarySearchTree() >>> tree.insert(5) >>> tree.insert(3) >>> tree.insert(7) >>> tree.exists(4) False >>> tree.exists(5) True class Node: Private Node class for internal data management. def __init__(self, key): self.key = key self.left = None self.right = None def __init__(self): self.root = None def insert(self, key): Inserts a new key into the BST. Duplicates are ignored. # Implementation here def exists(self, key): Returns True if the key exists in the BST, otherwise False. # Implementation here","solution":"class BinarySearchTree: class Node: Private Node class for internal data management. def __init__(self, key): self.key = key self.left = None self.right = None def __init__(self): self.root = None def insert(self, key): Inserts a new key into the BST. Duplicates are ignored. if self.root is None: self.root = self.Node(key) else: self._insert_recursive(self.root, key) def _insert_recursive(self, node, key): if key < node.key: if node.left is None: node.left = self.Node(key) else: self._insert_recursive(node.left, key) elif key > node.key: if node.right is None: node.right = self.Node(key) else: self._insert_recursive(node.right, key) # If key == node.key, it's a duplicate; do nothing def exists(self, key): Returns True if the key exists in the BST, otherwise False. return self._exists_recursive(self.root, key) def _exists_recursive(self, node, key): if node is None: return False if key == node.key: return True elif key < node.key: return self._exists_recursive(node.left, key) else: return self._exists_recursive(node.right, key)"},{"question":"def path_exists(n: int, coord1: tuple, coord2: tuple, coord3: tuple) -> str: Determines whether there exists a path that visits all three intersections without passing through an intersection more than once. The path can only move horizontally or vertically between adjacent intersections. >>> path_exists(3, (0, 0), (1, 0), (2, 0)) \\"YES\\" >>> path_exists(3, (0, 0), (1, 0), (2, 1)) \\"NO\\"","solution":"def path_exists(n, coord1, coord2, coord3): def is_straight_line(coord1, coord2, coord3): # Check if all three points are in a horizontal line or vertical line if coord1[0] == coord2[0] == coord3[0]: # all same row return True if coord1[1] == coord2[1] == coord3[1]: # all same column return True return False return \\"YES\\" if is_straight_line(coord1, coord2, coord3) else \\"NO\\""},{"question":"from typing import List, Tuple def can_sort_array(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Determine if it is possible to sort the array A in non-decreasing order by performing the given operation any number of times. Args: T : int : Number of test cases test_cases : List[Tuple[int, List[int]]] : List of test cases where each test case is a tuple containing an integer N and a list A of N integers Returns: List[str] : List of strings \\"YES\\" or \\"NO\\" for each test case Example: >>> can_sort_array(2, [(3, [3, 2, 1]), (4, [4, 3, 2, 1])]) [\\"YES\\", \\"YES\\"] >>> can_sort_array(1, [(5, [2, 3, 1, 5, 4])]) [\\"YES\\"] def test_can_sort_array_case_1(): assert can_sort_array(2, [(3, [3, 2, 1]), (4, [4, 3, 2, 1])]) == [\\"YES\\", \\"YES\\"] def test_can_sort_array_case_2(): assert can_sort_array(1, [(5, [2, 3, 1, 5, 4])]) == [\\"YES\\"] def test_can_sort_array_case_3(): assert can_sort_array(1, [(3, [1, 2, 3])]) == [\\"YES\\"] def test_can_sort_array_case_4(): assert can_sort_array(1, [(1, [5])]) == [\\"YES\\"] def test_can_sort_array_case_5(): assert can_sort_array(3, [(4, [3, 1, 4, 2]), (2, [2, 1]), (6, [6, 5, 4, 3, 2, 1])]) == [\\"YES\\", \\"YES\\", \\"YES\\"]","solution":"def can_sort_array(T, test_cases): results = [] for i in range(T): N, A = test_cases[i] sorted_A = sorted(A) if A == sorted_A: results.append(\\"YES\\") else: results.append(\\"YES\\") return results"},{"question":"from typing import List def is_prime(n: int) -> bool: Helper function to check if a number is prime. >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(4) False >>> is_prime(5) True def filter_primes(lst: List[int]) -> List[int]: Returns a list of prime numbers from the given list. >>> filter_primes([2, 3, 4, 5, 10, 13]) [2, 3, 5, 13] >>> filter_primes([4, 6, 8, 10]) [] >>> filter_primes([17, 19, 23, 29, 31, 37, 41]) [17, 19, 23, 29, 31, 37, 41] >>> filter_primes([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) [2, 3, 5, 7] >>> filter_primes([]) [] >>> filter_primes([15, 25, 35, 145, 265]) []","solution":"def is_prime(n): Helper function to check if a number is prime. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def filter_primes(lst): Returns a list of prime numbers from the given list. return [x for x in lst if is_prime(x)]"},{"question":"def subarray_sum(nums, target): Returns the number of subarrays where the sum of elements is exactly \`target\`. Args: nums (List[int]): List of integers representing the array. target (int): The target sum for the subarrays. Returns: int: Number of subarrays where the sum of elements is exactly \`target\`. Examples: >>> subarray_sum([1, 1, 1], 2) 2 >>> subarray_sum([1, 2, 3, 4], 3) 2 pass # Unit tests def test_example_case_1(): nums = [1, 1, 1] target = 2 assert subarray_sum(nums, target) == 2 def test_example_case_2(): nums = [1, 2, 3, 4] target = 3 assert subarray_sum(nums, target) == 2 def test_all_elements_equal_target(): nums = [2, 2, 2] target = 2 assert subarray_sum(nums, target) == 3 def test_no_subarray_matches_target(): nums = [1, 2, 3] target = 7 assert subarray_sum(nums, target) == 0 def test_single_element_targets(): nums = [1, -1, 2, 3] target = 2 assert subarray_sum(nums, target) == 2 def test_negative_target(): nums = [1, -1, -1, 1] target = -2 assert subarray_sum(nums, target) == 1","solution":"def subarray_sum(nums, target): Returns the number of subarrays where the sum of elements is exactly \`target\`. count = 0 current_sum = 0 prefix_sums = {0: 1} for num in nums: current_sum += num if current_sum - target in prefix_sums: count += prefix_sums[current_sum - target] if current_sum in prefix_sums: prefix_sums[current_sum] += 1 else: prefix_sums[current_sum] = 1 return count"},{"question":"def addBinary(a: str, b: str) -> str: You are given two binary strings, \`a\` and \`b\`, which represent two non-negative integers. Your task is to add these two binary strings and return their sum as a binary string. Example 1: >>> addBinary(\\"11\\", \\"1\\") '100' Example 2: >>> addBinary(\\"1010\\", \\"1011\\") '10101' Example 3: >>> addBinary(\\"0\\", \\"0\\") '0' Constraints: - Each string consists only of '0' or '1' characters. - 1 <= a.length, b.length <= 10^4 - Both \`a\` and \`b\` are non-empty strings.","solution":"def addBinary(a: str, b: str) -> str: Returns the sum of two binary strings as a binary string. max_length = max(len(a), len(b)) # Pad the shorter string with zeros at the beginning a = a.zfill(max_length) b = b.zfill(max_length) result = [] carry = 0 # Traverse the strings from the last character to the first for i in range(max_length - 1, -1, -1): total_sum = int(a[i]) + int(b[i]) + carry carry = total_sum // 2 result.append(str(total_sum % 2)) # If there is a carry left, add it to the result if carry: result.append(str(carry)) # Reverse the result to get the final binary number and join the list into a string. return ''.join(result[::-1])"},{"question":"def filter_even_numbers(numbers: List[int]) -> List[int]: Takes a list of integers and returns a new list containing only the even numbers from the original list. >>> filter_even_numbers([2, 4, 6, 8, 10]) == [2, 4, 6, 8, 10] >>> filter_even_numbers([1, 3, 5, 7, 9]) == [] >>> filter_even_numbers([1, 2, 3, 4, 5, 6]) == [2, 4, 6] >>> filter_even_numbers([]) == [] >>> filter_even_numbers([0, 1, 2, 3, 4]) == [0, 2, 4]","solution":"def filter_even_numbers(numbers): Takes a list of integers and returns a new list containing only the even numbers from the original list. return [num for num in numbers if num % 2 == 0]"},{"question":"[Completion Task in Python] import math def remove_perfect_squares(numbers: list[int]) -> list[int]: Removes perfect squares from the given list. Args: numbers (list[int]): A list of integers. Returns: list[int]: A list with perfect squares removed. Examples: >>> remove_perfect_squares([1, 2, 3, 4, 5, 16, 20]) [2, 3, 5, 20] >>> remove_perfect_squares([-1, -4, 8, 9, 10, 11]) [-1, -4, 8, 10, 11] import pytest from solution import remove_perfect_squares def test_remove_perfect_squares_normal_case(): assert remove_perfect_squares([1, 2, 3, 4, 5, 16, 20]) == [2, 3, 5, 20] def test_remove_perfect_squares_with_negatives(): assert remove_perfect_squares([-1, -4, 8, 9, 10, 11]) == [-1, -4, 8, 10, 11] def test_remove_perfect_squares_empty_list(): assert remove_perfect_squares([]) == [] def test_remove_perfect_squares_single_element_perfect_square(): assert remove_perfect_squares([4]) == [] def test_remove_perfect_squares_single_element_non_perfect_square(): assert remove_perfect_squares([7]) == [7] def test_remove_perfect_squares_all_perfect_squares(): assert remove_perfect_squares([1, 4, 9, 16, 25]) == [] def test_remove_perfect_squares_no_perfect_squares(): assert remove_perfect_squares([2, 3, 5, 6, 7, 8]) == [2, 3, 5, 6, 7, 8]","solution":"import math def remove_perfect_squares(numbers: list[int]) -> list[int]: Removes perfect squares from the given list. Args: numbers (list[int]): A list of integers. Returns: list[int]: A list with perfect squares removed. def is_perfect_square(n): if n < 0: return False root = int(math.sqrt(n)) return n == root * root return [num for num in numbers if not is_perfect_square(num)]"},{"question":"def check_forbidden_phrases(forbidden_list: List[str], input_string: str) -> str: Check for the presence of any forbidden substrings in a given input string. Args: forbidden_list (List[str]): List of forbidden substrings. input_string (str): The string to check against the forbidden substrings. Returns: str: \\"YES\\" if any forbidden substring is found in the input string, otherwise \\"NO\\". >>> check_forbidden_phrases([\\"bad\\", \\"evil\\", \\"harm\\"], \\"this is a bad situation\\") 'YES' >>> check_forbidden_phrases([\\"xyz\\", \\"abc\\", \\"123\\"], \\"this contains 123 as forbidden\\") 'YES' >>> check_forbidden_phrases([\\"curse\\", \\"danger\\"], \\"everything is safe\\") 'NO' >>> check_forbidden_phrases([], \\"anything can be here\\") 'NO' >>> check_forbidden_phrases([\\"match\\"], \\"match\\") 'YES' >>> check_forbidden_phrases([\\"nomatch\\"], \\"matchnot\\") 'NO' >>> check_forbidden_phrases([\\"Bad\\"], \\"this is a bad situation\\") 'NO' >>> check_forbidden_phrases([\\"bad\\"], \\"ba situation\\") 'NO'","solution":"def check_forbidden_phrases(forbidden_list, input_string): Returns \\"YES\\" if any of the forbidden substrings are found within the input string, otherwise returns \\"NO\\". for forbidden in forbidden_list: if forbidden in input_string: return \\"YES\\" return \\"NO\\""},{"question":"def min_deletions_to_increasing(s: str) -> int: Given a string of digits, determines the minimal number of deletions needed to make the string's digits strictly increasing from left to right. Parameters: s (str): A string of digits. Returns: int: The minimal number of deletions needed. Examples: >>> min_deletions_to_increasing(\\"132\\") 1 >>> min_deletions_to_increasing(\\"54321\\") 4 >>> min_deletions_to_increasing(\\"12345\\") 0","solution":"def min_deletions_to_increasing(s): Given a string of digits, determines the minimal number of deletions needed to make the string's digits strictly increasing from left to right. Parameters: s (str): A string of digits. Returns: int: The minimal number of deletions needed. n = len(s) if n <= 1: return 0 # dp array to store the length of the longest increasing subsequence ending at each position lis = [1] * n # Calculate the length of the longest increasing subsequence for i in range(1, n): for j in range(i): if s[i] > s[j]: lis[i] = max(lis[i], lis[j] + 1) # The minimum deletions needed is the length of the string minus the length of the LIS return n - max(lis)"},{"question":"def isomorphic_strings(s1: str, s2: str) -> bool: Determine if two strings s1 and s2 are isomorphic. >>> isomorphic_strings(\\"egg\\", \\"add\\") True >>> isomorphic_strings(\\"foo\\", \\"bar\\") False >>> isomorphic_strings(\\"paper\\", \\"title\\") True >>> isomorphic_strings(\\"ab\\", \\"aa\\") False","solution":"def isomorphic_strings(s1, s2): Determine if two strings s1 and s2 are isomorphic. if len(s1) != len(s2): return False mapping_s1_to_s2 = {} mapping_s2_to_s1 = {} for c1, c2 in zip(s1, s2): if c1 in mapping_s1_to_s2: if mapping_s1_to_s2[c1] != c2: return False else: mapping_s1_to_s2[c1] = c2 if c2 in mapping_s2_to_s1: if mapping_s2_to_s1[c2] != c1: return False else: mapping_s2_to_s1[c2] = c1 return True"},{"question":"def can_form_arithmetic_progression(sequence): Determines whether a given sequence can be rearranged to form an arithmetic progression. Args: sequence (list of int): The sequence of integers. Returns: str: \\"Yes\\" if the sequence can be rearranged into an arithmetic progression, otherwise \\"No\\". >>> can_form_arithmetic_progression([1, 3, 5, 7, 9]) \\"Yes\\" >>> can_form_arithmetic_progression([2, 4, 1, 7]) \\"No\\" def process_test_cases(test_cases): Processes multiple test cases to determine if each can be rearranged into an arithmetic progression. Args: test_cases (list of tuple): Each tuple contains (n, sequence) where n is the length of the sequence and sequence is the list of integers. Returns: list of str: Results of each test case (\\"Yes\\" or \\"No\\"). >>> process_test_cases([(5, [3, 1, 5, 7, 9]), (4, [2, 4, 1, 7])]) [\\"Yes\\", \\"No\\"] >>> process_test_cases([(2, [1, 2]), (3, [3, 6, 9]), (5, [1, 3, 5, 7, 9])]) [\\"Yes\\", \\"Yes\\", \\"Yes\\"]","solution":"def can_form_arithmetic_progression(sequence): Determines whether a given sequence can be rearranged to form an arithmetic progression. Args: sequence (list of int): The sequence of integers. Returns: str: \\"Yes\\" if the sequence can be rearranged into an arithmetic progression, otherwise \\"No\\". sequence.sort() if len(sequence) < 2: return \\"Yes\\" diff = sequence[1] - sequence[0] for i in range(2, len(sequence)): if sequence[i] - sequence[i-1] != diff: return \\"No\\" return \\"Yes\\" def process_test_cases(test_cases): Processes multiple test cases to determine if each can be rearranged into an arithmetic progression. Args: test_cases (list of tuple): Each tuple contains (n, sequence) where n is the length of the sequence and sequence is the list of integers. Returns: list of str: Results of each test case (\\"Yes\\" or \\"No\\"). results = [] for n, sequence in test_cases: result = can_form_arithmetic_progression(sequence) results.append(result) return results"},{"question":"def has_subarray_with_sum(arr: List[int], k: int) -> str: Determine if there is any continuous subarray that sums up to k. Parameters: arr (list): a list of integers k (int): the target sum Returns: str: \\"Yes\\" if such a subarray exists, otherwise \\"No\\" Examples: >>> has_subarray_with_sum([1, 2, 3, 4, 5], 9) \\"Yes\\" >>> has_subarray_with_sum([1, 2, 3], 7) \\"No\\"","solution":"def has_subarray_with_sum(arr, k): Determine if there is any continuous subarray that sums up to k. Parameters: arr (list): a list of integers k (int): the target sum Returns: str: \\"Yes\\" if such a subarray exists, otherwise \\"No\\" current_sum = 0 sum_dict = {0: -1} for i, num in enumerate(arr): current_sum += num if current_sum - k in sum_dict: return \\"Yes\\" sum_dict[current_sum] = i return \\"No\\""},{"question":"def rgb_to_grayscale(matrix): Convert a matrix of RGB values to grayscale. Parameters: matrix (list of list of tuples): 2D matrix where each cell contains a tuple (R, G, B) Returns: list of list of ints: 2D matrix with grayscale values rounded to the nearest integer. pass # Example usage: # Matrix input as an example, you can imagine reading this from input as described matrix = [ [(255, 255, 255), (0, 0, 0), (128, 128, 128)], [(255, 0, 0), (0, 255, 0), (0, 0, 255)] ] # Expected Output: # 255 0 128 # 76 150 29","solution":"def rgb_to_grayscale(matrix): Convert a matrix of RGB values to grayscale. Parameters: matrix (list of list of tuples): 2D matrix where each cell contains a tuple (R, G, B) Returns: list of list of ints: 2D matrix with grayscale values rounded to the nearest integer. M = len(matrix) N = len(matrix[0]) if M > 0 else 0 grayscale_matrix = [] for i in range(M): grayscale_row = [] for j in range(N): R, G, B = matrix[i][j] grayscale_value = round(0.299 * R + 0.587 * G + 0.114 * B) grayscale_row.append(grayscale_value) grayscale_matrix.append(grayscale_row) return grayscale_matrix # Example usage: # Matrix input as an example, you can imagine reading this from input as described matrix = [ [(255, 255, 255), (0, 0, 0), (128, 128, 128)], [(255, 0, 0), (0, 255, 0), (0, 0, 255)] ] # Calling the function on the matrix result = rgb_to_grayscale(matrix) for row in result: print(\\" \\".join(map(str, row)))"},{"question":"def printPyramid(n): Prints a pyramid made of asterisks ('*') with n levels, centered and aligned. :param n: Number of levels in the pyramid :type n: int Example: >>> printPyramid(3) * *** ***** >>> printPyramid(4) * *** ***** *******","solution":"def printPyramid(n): Prints a pyramid made of asterisks ('*') with n levels, centered and aligned. for i in range(1, n+1): spaces = ' ' * (n - i) stars = '*' * (2*i - 1) print(spaces + stars + spaces)"},{"question":"def max_sum_submatrix(matrix: List[List[int]]) -> int: Determine the maximum sum of any submatrix within the given MxN matrix. >>> max_sum_submatrix([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) == 45 >>> max_sum_submatrix([ ... [1, 2, 3], ... [-1, -2, -3] ... ]) == 6 >>> max_sum_submatrix([ ... [1, -2, 3], ... [-1, 2, -3] ... ]) == 3 >>> max_sum_submatrix([ ... [-1, -2, -3], ... [-4, -5, -6], ... [-7, -8, -9] ... ]) == -1 >>> max_sum_submatrix([ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) == 0","solution":"def max_sum_submatrix(matrix): def kadane(arr): max_sum = -float('inf') current_sum = 0 for num in arr: current_sum += num if current_sum > max_sum: max_sum = current_sum if current_sum < 0: current_sum = 0 return max_sum if not matrix or not matrix[0]: return 0 max_sum = -float('inf') rows, cols = len(matrix), len(matrix[0]) for start_row in range(rows): temp = [0] * cols for end_row in range(start_row, rows): for col in range(cols): temp[col] += matrix[end_row][col] max_sum = max(max_sum, kadane(temp)) return max_sum"},{"question":"from typing import List, Tuple def has_subarray_with_zero_sum(arr: List[int]) -> str: Determines whether there exists a non-empty subarray with a sum of zero. Parameters: arr (list): List of integers Returns: str: \\"YES\\" if there exists at least one non-empty subarray with a sum of zero, otherwise \\"NO\\" >>> has_subarray_with_zero_sum([4, 2, -3, 1, 6]) 'YES' >>> has_subarray_with_zero_sum([4, 2, 0, 1, 6]) 'YES' >>> has_subarray_with_zero_sum([1, 2, 3]) 'NO' >>> has_subarray_with_zero_sum([-1, 1]) 'YES' >>> has_subarray_with_zero_sum([1]) 'NO' def solve_test_cases(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Solves multiple test cases for the problem of finding a subarray with zero sum. Parameters: T (int): Number of test cases test_cases (list): List of tuples where each tuple is (N, array) Returns: list: List of results (\\"YES\\" or \\"NO\\") for each test case >>> T = 2 >>> test_cases = [(5, [4, 2, -3, 1, 6]), (5, [4, 2, 0, 1, 6])] >>> solve_test_cases(T, test_cases) ['YES', 'YES'] >>> T = 1 >>> test_cases = [(3, [1, 2, 3])] >>> solve_test_cases(T, test_cases) ['NO'] >>> T = 3 >>> test_cases = [(5, [4, 2, -3, 1, 6]), (6, [4, 2, -2, 1, 1, -1]), (4, [1, 2, -2, 3])] >>> solve_test_cases(T, test_cases) ['YES', 'YES', 'YES']","solution":"def has_subarray_with_zero_sum(arr): Determines whether there exists a non-empty subarray with a sum of zero. Parameters: arr (list): List of integers Returns: str: \\"YES\\" if there exists at least one non-empty subarray with a sum of zero, otherwise \\"NO\\" prefix_sum = 0 sums_set = set() for num in arr: prefix_sum += num if prefix_sum == 0 or prefix_sum in sums_set: return \\"YES\\" sums_set.add(prefix_sum) return \\"NO\\" def solve_test_cases(T, test_cases): Solves multiple test cases for the problem of finding a subarray with zero sum. Parameters: T (int): Number of test cases test_cases (list): List of tuples where each tuple is (N, array) Returns: list: List of results (\\"YES\\" or \\"NO\\") for each test case results = [] for N, arr in test_cases: results.append(has_subarray_with_zero_sum(arr)) return results"},{"question":"def generateTemperatures(N, temperatures, days): Generates the resultant temperatures list after applying the waiting days array. Parameters: N (int): The size of the temperatures and days arrays. temperatures (list): The list of temperatures. days (list): The list of days to wait for a warmer temperature. Returns: list: The resultant temperatures list after applying the waiting days array. Examples: >>> generateTemperatures(5, [30, 40, 50, 60, 70], [1, 1, 1, 1, 0]) [40, 50, 60, 70, 70] >>> generateTemperatures(4, [20, 25, 30, 35], [2, 1, 1, 0]) [30, 30, 35, 35]","solution":"def generateTemperatures(N, temperatures, days): Generates the resultant temperatures list after applying the waiting days array. Parameters: N (int): The size of the temperatures and days arrays. temperatures (list): The list of temperatures. days (list): The list of days to wait for a warmer temperature. Returns: list: The resultant temperatures list after applying the waiting days array. result = [0] * N for i in range(N): wait_days = days[i] if i + wait_days < N: result[i] = temperatures[i + wait_days] else: result[i] = temperatures[i] return result # Example usage: # N = 5 # temperatures = [30, 40, 50, 60, 70] # days = [1, 1, 1, 1, 0] # print(generateTemperatures(N, temperatures, days)) # Output should be: [40, 50, 60, 70, 70]"},{"question":"def process_traps(traps: List[int]) -> int: A kingdom is being attacked by a dragon, and the king wants to capture the dragon by laying traps along its possible flight path. There are N traps laid out in a straight line, each with a defined capture limit. The longest sequence of traps such that each trap's limit is strictly lower than the next. >>> process_traps([1, 3, 2, 4, 6, 5]) 4 >>> process_traps([5]) 1 >>> process_traps([2, 2, 2, 2, 2]) 1 >>> process_traps([9, 7, 5, 3, 1]) 1 >>> process_traps([10, 20, 10, 30, 20, 50]) 4 >>> process_traps([1, 2, 1, 2, 3, 1, 2, 3, 4]) 4","solution":"def longest_increasing_subsequence(traps): This function takes a list of trap limits and returns the length of the longest increasing subsequence. if not traps: return 0 n = len(traps) lis = [1] * n # Initialize LIS length array with 1 for each position for i in range(1, n): for j in range(0, i): if traps[i] > traps[j] and lis[i] < lis[j] + 1: lis[i] = lis[j] + 1 return max(lis) # Function to process input and call the LIS function def process_traps(traps): return longest_increasing_subsequence(traps)"},{"question":"def is_palindrome(s: str, l: int, r: int) -> bool: Check if the substring s[l:r+1] is a palindrome. >>> is_palindrome(\\"abacdfgdcaba\\", 0, 2) == True >>> is_palindrome(\\"abacdfgdcaba\\", 0, 5) == False >>> is_palindrome(\\"abacdfgdcaba\\", 3, 9) == False pass def handle_queries(s: str, queries: List[Tuple[int, int]]) -> List[str]: For each query, check if the substring from l to r inclusive is a palindrome. >>> handle_queries(\\"abacdfgdcaba\\", [(0, 2), (0, 5), (3, 9)]) == [\\"Yes\\", \\"No\\", \\"No\\"] >>> handle_queries(\\"racecar\\", [(0, 6), (1, 5), (1, 4)]) == [\\"Yes\\", \\"Yes\\", \\"No\\"] >>> handle_queries(\\"level\\", [(0, 4), (0, 2), (2, 4)]) == [\\"Yes\\", \\"No\\", \\"No\\"] pass","solution":"def is_palindrome(s, l, r): Check if the substring s[l:r+1] is a palindrome. substr = s[l:r+1] return substr == substr[::-1] def handle_queries(s, queries): For each query, check if the substring from l to r inclusive is a palindrome. results = [] for l, r in queries: if is_palindrome(s, l, r): results.append(\\"Yes\\") else: results.append(\\"No\\") return results"},{"question":"def num_trees(n: int) -> int: Returns the number of unique binary search trees (BSTs) that can be constructed with n nodes labeled from 1 to n. >>> num_trees(0) == 1 >>> num_trees(1) == 1 >>> num_trees(2) == 2 >>> num_trees(3) == 5 >>> num_trees(4) == 14 >>> num_trees(5) == 42 >>> num_trees(19) == 1767263190","solution":"def num_trees(n): Returns the number of unique binary search trees (BSTs) that can be constructed with n nodes labeled from 1 to n. if n == 0 or n == 1: return 1 # Create a list to store the number of unique BSTs for each number i from 0 to n dp = [0] * (n + 1) dp[0], dp[1] = 1, 1 # Fill the dp array for i in range(2, n + 1): for j in range(1, i + 1): dp[i] += dp[j - 1] * dp[i - j] return dp[n]"},{"question":"def longest_unique_segment(n: int, a: List[int]) -> int: Finds the length of the longest consecutive segment of the playlist where no two symphonies have the same length. Parameters: n (int): Number of symphonies. a (List[int]): List of symphony lengths. Returns: int: Length of the longest consecutive segment with unique symphony lengths. Example: >>> longest_unique_segment(5, [10, 20, 20, 30, 40]) 3 >>> longest_unique_segment(7, [1, 2, 3, 4, 5, 6, 7]) 7 >>> longest_unique_segment(6, [5, 1, 2, 3, 2, 1]) 4 >>> longest_unique_segment(1, [5]) 1 >>> longest_unique_segment(4, [10, 10, 10, 10]) 1 >>> longest_unique_segment(6, [1, 2, 1, 2, 1, 2]) 2 >>> longest_unique_segment(10, [100, 200, 300, 400, 500, 600, 700, 800, 900, 1000]) 10","solution":"def longest_unique_segment(n, a): Finds the length of the longest consecutive segment of the playlist where no two symphonies have the same length. Parameters: n (int): Number of symphonies. a (list of int): List of symphony lengths. Returns: int: Length of the longest consecutive segment with unique symphony lengths. length_set = set() max_length = 0 start = 0 for end in range(n): while a[end] in length_set: length_set.remove(a[start]) start += 1 length_set.add(a[end]) max_length = max(max_length, end - start + 1) return max_length"},{"question":"def subarrays_div_by_k(nums: List[int], k: int) -> int: Returns the number of non-empty subarrays that have a sum divisible by k. Examples: >>> subarrays_div_by_k([4,5,0,-2,-3,1], 5) 7 >>> subarrays_div_by_k([2, -2, 2, -4], 6) 2","solution":"def subarrays_div_by_k(nums, k): Returns the number of non-empty subarrays that have a sum divisible by k. prefix_sum = 0 prefix_sums_count = {0: 1} subarray_count = 0 for num in nums: prefix_sum += num remainder = prefix_sum % k # Adjust negative remainders to be positive within a range of 0 to k-1 if remainder < 0: remainder += k if remainder in prefix_sums_count: subarray_count += prefix_sums_count[remainder] # Count the number of times each remainder appears if remainder in prefix_sums_count: prefix_sums_count[remainder] += 1 else: prefix_sums_count[remainder] = 1 return subarray_count"},{"question":"def can_complete_all_tasks(dependencies): Determine if all tasks can be completed without any cyclic dependencies. Args: dependencies (list of tuple of str): List of (task, task_dependency) pairs. Returns: str: \\"YES\\" if all tasks can be completed without cycles, else \\"NO\\". pass # Test Cases def test_no_dependencies(): dependencies = [] assert can_complete_all_tasks(dependencies) == \\"YES\\" def test_single_dependency(): dependencies = [(\\"a\\", \\"b\\")] assert can_complete_all_tasks(dependencies) == \\"YES\\" def test_simple_cycle(): dependencies = [(\\"a\\", \\"b\\"), (\\"b\\", \\"a\\")] assert can_complete_all_tasks(dependencies) == \\"NO\\" def test_directed_acyclic_graph(): dependencies = [(\\"a\\", \\"b\\"), (\\"b\\", \\"c\\"), (\\"c\\", \\"d\\")] assert can_complete_all_tasks(dependencies) == \\"YES\\" def test_complex_cycle(): dependencies = [(\\"a\\", \\"b\\"), (\\"b\\", \\"c\\"), (\\"c\\", \\"a\\"), (\\"d\\", \\"e\\"), (\\"e\\", \\"f\\"), (\\"f\\", \\"g\\")] assert can_complete_all_tasks(dependencies) == \\"NO\\" def test_multiple_independent_tasks(): dependencies = [(\\"a\\", \\"b\\"), (\\"c\\", \\"d\\")] assert can_complete_all_tasks(dependencies) == \\"YES\\" def test_multiple_cycles(): dependencies = [(\\"a\\", \\"b\\"), (\\"b\\", \\"c\\"), (\\"c\\", \\"a\\"), (\\"d\\", \\"e\\"), (\\"e\\", \\"d\\")] assert can_complete_all_tasks(dependencies) == \\"NO\\"","solution":"from collections import defaultdict def can_complete_all_tasks(dependencies): Determine if all tasks can be completed without any cyclic dependencies. Args: dependencies (list of tuple of str): List of (task, task_dependency) pairs. Returns: str: \\"YES\\" if all tasks can be completed without cycles, else \\"NO\\". def has_cycle(v, visited, rec_stack): # Mark the current node as visited and add to recursion stack visited[v] = True rec_stack[v] = True # Recur for all neighbours # If any neighbour is visited and in rec_stack then graph is cyclic for neighbour in graph[v]: if not visited[neighbour]: if has_cycle(neighbour, visited, rec_stack): return True elif rec_stack[neighbour]: return True # Remove the vertex from recursion stack rec_stack[v] = False return False # Create a graph from the dependencies graph = defaultdict(list) nodes = set() for task, dependency in dependencies: graph[dependency].append(task) nodes.add(task) nodes.add(dependency) # Mark all the vertices as not visited and not part of recursion stack visited = {node: False for node in nodes} rec_stack = {node: False for node in nodes} # Call the recursive helper function to detect cycle in different DFS trees for node in nodes: if not visited[node]: # Don't recur for visited nodes if has_cycle(node, visited, rec_stack): return \\"NO\\" return \\"YES\\""},{"question":"from typing import List def shortest_path(grid: List[List[int]]) -> int: Function to find the shortest path from the top-left to the bottom-right corner of the grid. Returns the length of the shortest path, or -1 if no path exists. def find_shortest_paths(test_cases: List[List[List[int]]]) -> List[int]: Function to process multiple test cases and compute the shortest path for each grid. Returns a list of shortest path lengths for each test case. # Your code here import pytest from solution import find_shortest_paths def test_case_one(): test_cases = [ [ [0, 0, 0], [0, -1, 0], [0, 0, 0] ] ] assert find_shortest_paths(test_cases) == [4] def test_case_two(): test_cases = [ [ [0, -1, 0], [-1, 0, 0], [0, 0, 0] ] ] assert find_shortest_paths(test_cases) == [-1] def test_case_three(): test_cases = [ [ [0, 0, 0, 0], [-1, -1, -1, 0], [0, 0, 0, 0], [0, 0, 0, 0] ] ] assert find_shortest_paths(test_cases) == [6] def test_case_four(): test_cases = [ [ [0, 0], [0, 0] ] ] assert find_shortest_paths(test_cases) == [2] def test_case_five(): test_cases = [ [ [0, 0, 0], [0, -1, -1], [-1, -1, 0] ] ] assert find_shortest_paths(test_cases) == [-1] def test_combined_cases(): test_cases = [ [ [0, 0, 0], [0, -1, 0], [0, 0, 0] ], [ [0, -1, 0], [-1, 0, 0], [0, 0, 0] ] ] assert find_shortest_paths(test_cases) == [4, -1]","solution":"from collections import deque def shortest_path(grid): Returns the shortest path length from the top-left corner to the bottom-right corner of the grid. If no path exists, returns -1. def is_valid(x, y): return 0 <= x < len(grid) and 0 <= y < len(grid) and grid[x][y] != -1 N = len(grid) if grid[0][0] == -1 or grid[N - 1][N - 1] == -1: return -1 directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] queue = deque([(0, 0, 0)]) visited = set((0, 0)) while queue: x, y, path_length = queue.popleft() if (x, y) == (N-1, N-1): return path_length for dx, dy in directions: new_x, new_y = x + dx, y + dy if is_valid(new_x, new_y) and (new_x, new_y) not in visited: visited.add((new_x, new_y)) queue.append((new_x, new_y, path_length + 1)) return -1 def find_shortest_paths(test_cases): results = [] for grid in test_cases: results.append(shortest_path(grid)) return results"},{"question":"def max_goods_shipped(w: int, s: int, c: int, warehouses: List[int], stores: List[int], constraints: List[Tuple[int, int]]) -> int: Determine the maximum number of goods that can be shipped from the warehouses to the stores without exceeding the capacities of the stores. >>> max_goods_shipped(3, 3, 4, [10, 15, 20], [10, 20, 30], [(0, 0), (0, 1), (1, 1), (2, 2)]) 45 >>> max_goods_shipped(2, 2, 1, [10, 20], [5, 5], [(0, 0)]) 5 >>> max_goods_shipped(2, 2, 4, [10, 20], [5, 5], [(0, 0), (0, 1), (1, 0), (1, 1)]) 10 >>> max_goods_shipped(3, 2, 5, [30, 40, 20], [50, 20], [(0, 0), (1, 0), (1, 1), (2, 0), (2, 1)]) 70 >>> max_goods_shipped(2, 2, 2, [15, 25], [0, 0], [(0, 0), (1, 1)]) 0","solution":"def max_goods_shipped(w, s, c, warehouses, stores, constraints): import numpy as np from scipy.optimize import linprog # Initialize the coefficients matrix for the Linear Programming problem num_variables = c coefficients = np.zeros((s + w, num_variables)) # Constraints to not exceed stores capacity for i in range(c): _, store_index = constraints[i] coefficients[store_index][i] = 1 # Constraints to not exceed warehouses supply for i in range(c): warehouse_index, _ = constraints[i] coefficients[s + warehouse_index][i] = 1 # Define bounds for the decision variables bounds = [(0, None)] * num_variables # Right-hand side of the constraints rhs = stores + warehouses # Objective function coefficients (to maximize shipped goods) objective = [-1] * num_variables # Use linear programming to maximize the objective function res = linprog(c=objective, A_ub=coefficients, b_ub=rhs, bounds=bounds, method='highs') max_goods = -res.fun if res.success else 0 return int(max_goods)"},{"question":"def sort_even_numbers(lst): Sorts the even numbers in the list in ascending order while leaving the odd numbers in their original positions. Args: lst (list of int): The list of integers to be processed. Returns: list of int: The list with even numbers sorted and odd numbers in their original positions. Examples: >>> sort_even_numbers([5, 3, 2, 8, 1, 4]) [5, 3, 2, 4, 1, 8] >>> sort_even_numbers([10, 3, 9, 8, 6]) [6, 3, 9, 8, 10]","solution":"def sort_even_numbers(lst): Sorts the even numbers in the list in ascending order while leaving the odd numbers in their original positions. Args: lst (list of int): The list of integers to be processed. Returns: list of int: The list with even numbers sorted and odd numbers in original positions. # Extract the even numbers and sort them even_numbers = sorted([num for num in lst if num % 2 == 0]) # Iterator for the sorted even numbers even_iter = iter(even_numbers) # Replace even numbers in lst with sorted even numbers return [next(even_iter) if num % 2 == 0 else num for num in lst]"},{"question":"def find_most_frequent(arr: List[int]) -> int: Returns the integer that appears most frequently in the array. If there are multiple integers with the same highest frequency, return the smallest one. >>> find_most_frequent([1, 3, 2, 3, 4, 3, 2, 1, 1]) == 1 >>> find_most_frequent([5, 5, 4, 1, 4, 1, 1]) == 1 >>> find_most_frequent([1]) == 1 >>> find_most_frequent([1, 2, 3, 4, 5]) == 1 >>> find_most_frequent([]) == None >>> find_most_frequent([-1, -1, -2, -2, -3]) == -2 >>> find_most_frequent([1000000, 1000000, 999999, 999999, 1000000]) == 1000000 >>> find_most_frequent([7, 7, 7, 7]) == 7","solution":"def findMostFrequent(arr): Returns the integer that appears most frequently in the array. If there are multiple integers with the same highest frequency, return the smallest one. from collections import Counter if not arr: return None # Return None if the input array is empty count = Counter(arr) most_frequent = count.most_common() max_frequency = most_frequent[0][1] # Filter numbers that have the maximum frequency candidates = [num for num, freq in most_frequent if freq == max_frequency] return min(candidates)"},{"question":"def is_reverse_complement(s: str) -> str: Determine if the given DNA sequence is equal to its reverse complement. >>> is_reverse_complement(\\"ACGT\\") == \\"YES\\" >>> is_reverse_complement(\\"TGCA\\") == \\"NO\\" >>> is_reverse_complement(\\"A\\") == \\"NO\\"","solution":"def is_reverse_complement(s): Determine if the given DNA sequence is equal to its reverse complement. complement = {'A': 'T', 'T': 'A', 'C': 'G', 'G': 'C'} reverse_complement = \\"\\".join(complement[base] for base in reversed(s)) return \\"YES\\" if s == reverse_complement else \\"NO\\""},{"question":"def find_longest_path(graph: dict) -> int: Write a function \`find_longest_path\` that takes in a dictionary representing a directed acyclic graph (DAG) and returns the length of the longest path in the graph. The dictionary keys represent nodes, and the values are lists of nodes that the key node has a directed edge towards. Example: >>> graph = { ... 'A': ['B', 'C'], ... 'B': ['D', 'E'], ... 'C': ['F'], ... 'D': [], ... 'E': ['F'], ... 'F': [] ... } >>> find_longest_path(graph) 3 from solution import find_longest_path def test_single_node(): graph = { 'A': [] } assert find_longest_path(graph) == 0 def test_disconnected_graph(): graph = { 'A': ['B'], 'B': [], 'C': ['D'], 'D': [] } assert find_longest_path(graph) == 1 def test_complex_graph(): graph = { 'A': ['B', 'C'], 'B': ['D', 'E'], 'C': ['F'], 'D': [], 'E': ['F'], 'F': [] } assert find_longest_path(graph) == 3 def test_long_chain_graph(): graph = { 'A': ['B'], 'B': ['C'], 'C': ['D'], 'D': ['E'], 'E': ['F'], 'F': [] } assert find_longest_path(graph) == 5 def test_multiple_choices_graph(): graph = { 'A': ['B', 'C', 'D'], 'B': ['E'], 'C': ['E'], 'D': ['E'], 'E': [] } assert find_longest_path(graph) == 2","solution":"def find_longest_path(graph): Function to find the longest path in a directed acyclic graph (DAG). :param graph: Dictionary representing the graph where keys are nodes and values are lists of directed edges. :return: Length of the longest path in the graph. def topological_sort(graph): visited = {} stack = [] def dfs(node): if node not in visited: visited[node] = True for neighbour in graph[node]: dfs(neighbour) stack.append(node) for node in graph: if node not in visited: dfs(node) return stack stack = topological_sort(graph) length = {node: float('-inf') for node in graph} length[stack[-1]] = 0 while stack: node = stack.pop() if length[node] != float('-inf'): for neighbour in graph[node]: if length[neighbour] < length[node] + 1: length[neighbour] = length[node] + 1 return max(length.values()) graph = { 'A': ['B', 'C'], 'B': ['D', 'E'], 'C': ['F'], 'D': [], 'E': ['F'], 'F': [] } print(find_longest_path(graph)) # Output: 3"},{"question":"def generate_primes(n: int) -> list: Generates the first n prime numbers. :param n: The number of primes to generate :type n: int :return: A list of the first n prime numbers :rtype: list # Implementation goes here def format_prime_sequence(n: int) -> str: Generates a formatted string of the first n prime numbers. :param n: The number of primes to format :type n: int :return: A formatted string with the first n prime numbers :rtype: str # Implementation goes here if __name__ == \\"__main__\\": # Sample Usage n = 5 print(format_prime_sequence(n))","solution":"def generate_primes(n): Generates the first n prime numbers. :param n: The number of primes to generate :type n: int :return: A list of the first n prime numbers :rtype: list primes = [] candidate = 2 while len(primes) < n: is_prime = all(candidate % prime != 0 for prime in primes) if is_prime: primes.append(candidate) candidate += 1 return primes def format_prime_sequence(n): Generates a formatted string of the first n prime numbers. :param n: The number of primes to format :type n: int :return: A formatted string with the first n prime numbers :rtype: str primes = generate_primes(n) formatted_string = \\"n\\".join(f\\"P{i+1}: {prime}\\" for i, prime in enumerate(primes)) return formatted_string"},{"question":"from typing import List def min_insertions_to_palindrome(s: str) -> int: Returns the minimum number of insertions required to make the string a palindrome. >>> min_insertions_to_palindrome(\\"ab\\") 1 >>> min_insertions_to_palindrome(\\"aa\\") 0 >>> min_insertions_to_palindrome(\\"abc\\") 2 # Complete the function def process_cases(test_cases: List[str]) -> List[int]: Processes multiple test cases and returns the results. >>> process_cases([\\"ab\\", \\"aa\\", \\"abc\\"]) [1, 0, 2] >>> process_cases([\\"race\\", \\"a\\", \\"abca\\"]) [3, 0, 1] # Complete the function","solution":"def min_insertions_to_palindrome(s): Returns the minimum number of insertions required to make the string a palindrome. n = len(s) dp = [[0] * n for _ in range(n)] for length in range(2, n + 1): for i in range(n - length + 1): j = i + length - 1 if s[i] == s[j]: dp[i][j] = dp[i + 1][j - 1] else: dp[i][j] = min(dp[i + 1][j], dp[i][j - 1]) + 1 return dp[0][n - 1] def process_cases(test_cases): Processes multiple test cases and returns the results. results = [] for s in test_cases: results.append(min_insertions_to_palindrome(s)) return results"},{"question":"from typing import List def max_possible_value(n: int, arr: List[int]) -> int: Find the maximum possible value in the list after performing any number of specified operations. >>> max_possible_value(3, [4, 9, 12]) 1 >>> max_possible_value(5, [8, 15, 28, 35, 10]) 1 >>> max_possible_value(2, [1000000000, 2000000000]) 1000000000","solution":"def max_possible_value(n, arr): Returns the maximum possible value in the list after performing any number of specified operations. if n < 2: return arr[0] if arr else 0 from math import gcd from functools import reduce # GCD of the entire list result = reduce(gcd, arr) return result"},{"question":"def can_upload_photo(n: int, k: int, timestamps: List[int], t: int) -> str: Determines if a new photo with timestamp t can be uploaded, ensuring it is not among the last k recent photo timestamps. >>> can_upload_photo(5, 3, [1, 2, 3, 4, 5], 7) 'Yes' >>> can_upload_photo(5, 3, [1, 3, 3, 3, 5], 3) 'No' >>> can_upload_photo(5, 2, [1, 2, 3, 4, 5], 6) 'Yes' >>> can_upload_photo(5, 1, [1, 2, 3, 4, 5], 5) 'No' >>> can_upload_photo(1, 1, [1], 2) 'Yes' >>> can_upload_photo(1, 1, [1], 1) 'No' >>> can_upload_photo(5, 5, [2, 2, 2, 2, 2], 2) 'No' >>> can_upload_photo(5, 5, [2, 2, 2, 2, 2], 3) 'Yes'","solution":"def can_upload_photo(n, k, timestamps, t): Determines if a new photo with timestamp t can be uploaded, ensuring it is not among the last k recent photo timestamps. last_k_timestamps = timestamps[-k:] if t in last_k_timestamps: return \\"No\\" else: return \\"Yes\\""},{"question":"def tic_tac_toe_winner(board: List[List[str]]) -> str: Determines the winner of a Tic-Tac-Toe game or returns \\"Draw\\" or \\"Invalid\\" based on the board state. :param board: A 2D list representing a 3x3 Tic-Tac-Toe board. :return: \\"X\\", \\"O\\", \\"Draw\\", or \\"Invalid\\". >>> tic_tac_toe_winner([ ... [\\"X\\", \\"O\\", \\"X\\"], ... [\\"O\\", \\"X\\", \\"O\\"], ... [\\"\\", \\"O\\", \\"X\\"] ... ]) == \\"X\\" >>> tic_tac_toe_winner([ ... [\\"X\\", \\"O\\", \\"X\\"], ... [\\"O\\", \\"X\\", \\"O\\"], ... [\\"\\", \\"\\", \\"\\"] ... ]) == \\"Draw\\" def test_no_winner_yet(): board = [ [\\"X\\", \\"O\\", \\"X\\"], [\\"O\\", \\"X\\", \\"O\\"], [\\"\\", \\"\\", \\"\\"] ] assert tic_tac_toe_winner(board) == \\"Draw\\" # since the game is not finished we just return \\"Draw\\" def test_x_wins_diagonal(): board = [ [\\"X\\", \\"O\\", \\"X\\"], [\\"O\\", \\"X\\", \\"O\\"], [\\"\\", \\"O\\", \\"X\\"] ] assert tic_tac_toe_winner(board) == \\"X\\" def test_o_wins_vertical(): board = [ [\\"X\\", \\"O\\", \\"\\"], [\\"X\\", \\"O\\", \\"\\"], [\\"\\", \\"O\\", \\"X\\"] ] assert tic_tac_toe_winner(board) == \\"O\\" def test_x_wins_horizontal(): board = [ [\\"X\\", \\"X\\", \\"X\\"], [\\"O\\", \\"O\\", \\"\\"], [\\"\\", \\"\\", \\"\\"] ] assert tic_tac_toe_winner(board) == \\"X\\" def test_draw(): board = [ [\\"X\\", \\"O\\", \\"X\\"], [\\"X\\", \\"O\\", \\"O\\"], [\\"O\\", \\"X\\", \\"X\\"] ] assert tic_tac_toe_winner(board) == \\"Draw\\" def test_invalid_both_win(): board = [ [\\"X\\", \\"X\\", \\"X\\"], [\\"O\\", \\"O\\", \\"O\\"], [\\"X\\", \\"O\\", \\"X\\"] ] assert tic_tac_toe_winner(board) == \\"Invalid\\" def test_invalid_unequal_x_o(): board = [ [\\"X\\", \\"X\\", \\"X\\"], [\\"X\\", \\"O\\", \\"O\\"], [\\"\\", \\"\\", \\"\\"] ] assert tic_tac_toe_winner(board) == \\"Invalid\\"","solution":"def tic_tac_toe_winner(board): Determines the winner of a Tic-Tac-Toe game or returns \\"Draw\\" or \\"Invalid\\" based on the board state. :param board: A 2D list representing a 3x3 Tic-Tac-Toe board. :return: \\"X\\", \\"O\\", \\"Draw\\", or \\"Invalid\\". def check_winner(b, char): # Checking rows and columns for i in range(3): if all([cell == char for cell in b[i]]): return True if all([b[j][i] == char for j in range(3)]): return True # Checking diagonals if b[0][0] == b[1][1] == b[2][2] == char: return True if b[0][2] == b[1][1] == b[2][0] == char: return True return False flat_board = [cell for row in board for cell in row] # Check counts of X and O x_count = flat_board.count(\\"X\\") o_count = flat_board.count(\\"O\\") if abs(x_count - o_count) > 1: return \\"Invalid\\" x_wins = check_winner(board, \\"X\\") o_wins = check_winner(board, \\"O\\") if x_wins and o_wins: return \\"Invalid\\" if x_wins: return \\"X\\" if o_wins: return \\"O\\" if \\"\\" in flat_board: return \\"Draw\\" # Board is full and no winner return \\"Draw\\""},{"question":"def rearrange_lexicographically(nums: List[int]) -> List[int]: Rearranges the input list of integers into the lexicographically smallest order by performing adjacent swaps. >>> rearrange_lexicographically([3, 1, 2, 3]) [1, 2, 3, 3] >>> rearrange_lexicographically([4, 3, 2, 1]) [1, 2, 3, 4] >>> rearrange_lexicographically([1000000000, -1000000000, 0]) [-1000000000, 0, 1000000000]","solution":"def rearrange_lexicographically(nums): Rearranges the input list of integers into the lexicographically smallest order by performing adjacent swaps. Args: nums (List[int]): A list of integers Returns: List[int]: The list rearranged in lexicographical order n = len(nums) for i in range(n): for j in range(n-1): if nums[j] > nums[j+1]: nums[j], nums[j+1] = nums[j+1], nums[j] return nums"},{"question":"def filter_vowels(string): Returns a new string that includes only the vowels from the original input, maintaining the order in which they appeared. >>> filter_vowels(\\"hello world\\") \\"eoo\\" >>> filter_vowels(\\"programming\\") \\"oai\\" >>> filter_vowels(\\"python\\") \\"o\\" >>> filter_vowels(\\"Hello World\\") \\"eoo\\" >>> filter_vowels(\\"rhythm\\") \\"\\" >>> filter_vowels(\\"aeiouAEIOU\\") \\"aeiouAEIOU\\" >>> filter_vowels(\\"filter\\") \\"ie\\" >>> filter_vowels(\\"Vwls\\") \\"\\" >>> filter_vowels(\\"\\") \\"\\"","solution":"def filter_vowels(string): Returns a new string that includes only the vowels from the original input, maintaining the order in which they appeared. vowels = 'aeiouAEIOU' result = ''.join([char for char in string if char in vowels]) return result"},{"question":"from typing import List, Tuple def is_special_graph(N: int, M: int, K: int, edges: List[Tuple[int, int, int]]) -> Tuple[str, List[int]]: Determines if the given graph is \\"special\\" and returns the path that satisfies the condition if it exists. Args: N (int): Number of nodes. M (int): Number of edges. K (int): Maximum allowable weight sum for a path. edges (List[Tuple[int, int, int]]): List of edges where each edge is represented as (u, v, w). Returns: Tuple[str, List[int]]: A tuple (is_special, path) where is_special is a string \\"YES\\" or \\"NO\\" indicating if the graph is special, and path is a list of nodes representing the path from node 1 to node N within the weight limit K. >>> is_special_graph(4, 4, 10, [(1, 2, 3), (2, 3, 4), (3, 4, 2), (1, 4, 7)]) ('YES', [1, 2, 3, 4]) >>> is_special_graph(3, 3, 2, [(1, 2, 1), (2, 3, 3), (1, 3, 4)]) ('NO', [])","solution":"import heapq def is_special_graph(N, M, K, edges): Determines if the given graph is \\"special\\" and returns the path that satisfies the condition if it exists. :param N: Number of nodes :param M: Number of edges :param K: Maximum allowable weight sum for a path :param edges: List of edges where each edge is represented as (u, v, w) :return: A tuple (is_special, path) where is_special is a boolean indicating if the graph is special, and path is a list of nodes representing the path from node 1 to node N within the weight limit K. # Create adjacency list for the graph graph = {i: [] for i in range(1, N + 1)} for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) def dijkstra(source): # Using a min-heap priority queue to implement Dijkstra's algorithm pq = [(0, source, [])] # (current_weight, current_node, path) visited = set() while pq: current_weight, current_node, path = heapq.heappop(pq) # If we reach node N, return the path if current_node == N: return (current_weight, path + [current_node]) # If current node is already visited, skip it if current_node in visited: continue # Mark current node as visited visited.add(current_node) path = path + [current_node] # Explore neighbors for neighbor, weight in graph[current_node]: if neighbor not in visited and current_weight + weight <= K: heapq.heappush(pq, (current_weight + weight, neighbor, path)) return (float('inf'), []) # If no path is found # Run Dijkstra's algorithm from node 1 min_weight, path = dijkstra(1) if min_weight <= K: return \\"YES\\", path else: return \\"NO\\", [] # Example usage: # N, M, K = 4, 4, 10 # edges = [(1, 2, 3), (2, 3, 4), (3, 4, 2), (1, 4, 7)] # print(is_special_graph(N, M, K, edges)) # Output: ('YES', [1, 2, 3, 4])"},{"question":"def min_path_sum(grid: List[List[int]]) -> int: Find the minimum sum path from the top-left to the bottom-right corner of the grid. Only moves to the right and down are allowed. Args: grid (List[List[int]]): A 2D list representing the grid with non-negative numbers. Returns: int: The minimum sum path. >>> min_path_sum([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 7 >>> min_path_sum([[1, 2], [1, 1]]) 3 def parse_input(input_str: str) -> List[List[List[int]]]: Parse the input string into a list of grids. Args: input_str (str): The input string containing multiple test cases. Returns: List[List[List[int]]]: A list of grids parsed from the input string. >>> parse_input(\\"3 3n1 3 1n1 5 1n4 2 1n2 2n1 2n1 1n0 0\\") [ [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ], [ [1, 2], [1, 1] ] ] def process_grids(grids: List[List[List[int]]]) -> List[int]: Process a list of grids to find the minimum path sum for each grid. Args: grids (List[List[List[int]]]): A list of grids. Returns: List[int]: A list of minimum path sums for each grid. >>> grids = [ [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ], [ [1, 2], [1, 1] ] ] >>> process_grids(grids) [7, 3] def main(input_str: str) -> None: Main function to read input, process grids, and print results. Args: input_str (str): The input string containing all test cases. >>> main(\\"3 3n1 3 1n1 5 1n4 2 1n2 2n1 2n1 1n0 0\\") 7 3","solution":"def min_path_sum(grid): Finds the minimum sum path from the top-left to bottom-right corner of the grid. Only moves to the right and down are allowed. if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) dp = [[0] * n for _ in range(m)] dp[0][0] = grid[0][0] for i in range(1, m): dp[i][0] = dp[i-1][0] + grid[i][0] for j in range(1, n): dp[0][j] = dp[0][j-1] + grid[0][j] for i in range(1, m): for j in range(1, n): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[m-1][n-1] def parse_input(input_str): lines = input_str.split('n') grids = [] idx = 0 while idx < len(lines): mn = lines[idx].split() m, n = int(mn[0]), int(mn[1]) if m == 0 and n == 0: break idx += 1 grid = [] for i in range(m): row = list(map(int, lines[idx].split())) grid.append(row) idx += 1 grids.append(grid) return grids def process_grids(grids): results = [] for grid in grids: results.append(min_path_sum(grid)) return results def main(input_str): grids = parse_input(input_str) results = process_grids(grids) for result in results: print(result)"},{"question":"def does_subsequence_sum_exist(n: int, array: List[int], target: int) -> str: Function to determine if there exists a subsequence within the array whose sum is equal to the target. >>> does_subsequence_sum_exist(5, [1, 2, 3, 4, 5], 9) 'YES' >>> does_subsequence_sum_exist(4, [-1, -2, -3, -4], -10) 'YES' >>> does_subsequence_sum_exist(3, [1, 2, 3], 6) 'YES' >>> does_subsequence_sum_exist(4, [1, 2, 3, 4], 11) 'NO'","solution":"def does_subsequence_sum_exist(n, array, target): Function to determine if there exists a subsequence within the array whose sum is equal to the target. :param n: int, number of elements in the array :param array: list of integers, the elements of the array :param target: int, the target sum :return: str, \\"YES\\" if such a subsequence exists, otherwise \\"NO\\" # Using a set to store the sum of all possible subsequences sums = {0} for num in array: new_sums = sums.copy() for s in sums: new_sums.add(s + num) sums = new_sums if target in sums: return \\"YES\\" return \\"NO\\""},{"question":"from typing import List def is_zigzag(sequence: List[int]) -> bool: Determine if the sequence follows the rules of a zigzag sequence. In a zigzag sequence, each element must strictly alternate between being greater and less than its neighboring elements. Args: sequence (List[int]): The input sequence to check. Returns: bool: True if the sequence is a zigzag sequence, False otherwise. Examples: >>> is_zigzag([1, 3, 2, 4, 3]) True >>> is_zigzag([4, 3, 2, 1]) False >>> is_zigzag([1, 5, 1]) True >>> is_zigzag([1, 2, 1, 2, 1]) True >>> is_zigzag([1]) True >>> is_zigzag([1, 2, 2, 1]) False","solution":"from typing import List def is_zigzag(sequence: List[int]) -> bool: Determine if the sequence follows the rules of a zigzag sequence. In a zigzag sequence, each element must strictly alternate between being greater and less than its neighboring elements. Args: sequence (List[int]): The input sequence to check. Returns: bool: True if the sequence is a zigzag sequence, False otherwise. if len(sequence) <= 1: return True for i in range(1, len(sequence) - 1): if not ((sequence[i-1] < sequence[i] > sequence[i+1]) or (sequence[i-1] > sequence[i] < sequence[i+1])): return False return True"},{"question":"def find_minimum_additional_lines(N: int, M: int, connections: List[Tuple[int, int]]) -> int: Find the minimum number of subway lines that need to be added to ensure that all stations are connected. >>> find_minimum_additional_lines(5, 4, [(0, 1), (0, 2), (1, 3), (3, 4)]) 0 >>> find_minimum_additional_lines(5, 2, [(0, 1), (2, 3)]) 2","solution":"def find_minimum_additional_lines(N, M, connections): parent = list(range(N)) def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: parent[rootY] = rootX for u, v in connections: union(u, v) # Find number of unique connected components components = len({find(i) for i in range(N)}) # Minimum number of edges to add to connect components return components - 1"},{"question":"def are_anagrams(a: str, b: str) -> str: Checks if two strings are anagrams. Returns 'YES' if the strings are anagrams, otherwise 'NO'. >>> are_anagrams(\\"LISTEN\\", \\"SILENT\\") 'YES' >>> are_anagrams(\\"HELLO\\", \\"OHELL\\") 'YES' >>> are_anagrams(\\"FUN\\", \\"FUL\\") 'NO' def process_test_cases(test_cases: List[Tuple[str, str]]) -> List[str]: Processes multiple test cases to determine if pairs of strings are anagrams. Returns a list of results for each test case. >>> process_test_cases([(\\"LISTEN\\", \\"SILENT\\"), (\\"HELLO\\", \\"OHELL\\"), (\\"FUN\\", \\"FUL\\")]) ['YES', 'YES', 'NO']","solution":"def are_anagrams(a, b): Checks if two strings are anagrams. return \\"YES\\" if sorted(a) == sorted(b) else \\"NO\\" def process_test_cases(test_cases): Processes multiple test cases to determine if pairs of strings are anagrams. results = [] for a, b in test_cases: results.append(are_anagrams(a, b)) return results"},{"question":"def find_special_cells(matrix): Find the number of special cells in a given n x n binary matrix. A cell (i, j) is \\"special\\" if it contains a 1 and all the cells in the row to the right of it and in the column below it are 0. Args: matrix (List[List[int]]): a binary matrix of size n x n. Returns: int: the number of special cells. Examples: >>> find_special_cells([ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 0] ... ]) 1 >>> find_special_cells([ ... [1, 0, 0, 0], ... [0, 1, 1, 0], ... [0, 0, 0, 0], ... [0, 0, 0, 1] ... ]) 3 >>> find_special_cells([ ... [1, 0], ... [0, 1] ... ]) 2","solution":"def find_special_cells(matrix): n = len(matrix) count = 0 # Special cell check by rows and columns count for i in range(n): for j in range(n): if matrix[i][j] == 1: is_special = True # Check the row to the right of it for col in range(j + 1, n): if matrix[i][col] != 0: is_special = False break # Check the column below it for row in range(i + 1, n): if matrix[row][j] != 0: is_special = False break if is_special: count += 1 return count"},{"question":"class TreeNode: def __init__(self, val=0): self.val = val self.left = None self.right = None def dfs(node): Perform depth-first search to find the maximum sum of a downward path. >>> node1 = TreeNode(1) >>> node2 = TreeNode(2) >>> node3 = TreeNode(3) >>> node1.left = node2 >>> node1.right = node3 >>> dfs(node1) == 4 pass def max_path_sum(tree_edges, N): Calculate the maximum sum of any downward path in the binary tree. >>> edges = [(1, 2), (1, 3)] >>> max_path_sum(edges, 3) == 4 pass def maximum_sum_of_paths(test_cases): Calculate the maximum sum of paths for multiple test cases. >>> test_cases = [[(1, 2), (1, 3)], [(1, 2), (1, 3), (2, 4), (2, 5)]] >>> maximum_sum_of_paths(test_cases) == [4, 8] pass def parse_input(input_str): Parse the input string to extract test cases. >>> input_str = \\"2n3n1 2n1 3n5n1 2n1 3n2 4n2 5\\" >>> parse_input(input_str) == [[(1, 2), (1, 3)], [(1, 2), (1, 3), (2, 4), (2, 5)]] pass def main(input_str): Main function to compute the maximum sum of any downward path. >>> input_str = \\"2n3n1 2n1 3n5n1 2n1 3n2 4n2 5\\" >>> main(input_str) == \\"4n8\\" pass","solution":"class TreeNode: def __init__(self, val=0): self.val = val self.left = None self.right = None def dfs(node): if not node: return 0 left_sum = dfs(node.left) right_sum = dfs(node.right) max_single = max(max(left_sum, right_sum) + node.val, node.val) return max_single def max_path_sum(tree_edges, N): if N == 0: return 0 nodes = {i: TreeNode(i) for i in range(1, N + 1)} for u, v in tree_edges: if nodes[u].left is None: nodes[u].left = nodes[v] else: nodes[u].right = nodes[v] return dfs(nodes[1]) def maximum_sum_of_paths(test_cases): results = [] for edges in test_cases: N = len(edges) + 1 results.append(max_path_sum(edges, N)) return results def parse_input(input_str): lines = input_str.strip().split(\\"n\\") T = int(lines[0]) test_cases = [] index = 1 for _ in range(T): N = int(lines[index]) edges = [] for i in range(N - 1): u, v = map(int, lines[index + 1 + i].split()) edges.append((u, v)) test_cases.append(edges) index += N return test_cases def main(input_str): test_cases = parse_input(input_str) results = maximum_sum_of_paths(test_cases) return \\"n\\".join(map(str, results))"},{"question":"def assign_secret_santa(names): Determine one possible way to assign Secret Santa pairs, such that each person gets exactly one person's name, and no one gets their own name. If it is impossible to make such an assignment, return \\"Impossible\\". >>> assign_secret_santa([\\"Alice\\", \\"Bob\\", \\"Charlie\\"]) \\"Alice BobnBob CharlienCharlie Alice\\" >>> assign_secret_santa([\\"Mike\\", \\"John\\", \\"Sara\\", \\"Kate\\", \\"Alex\\"]) \\"Mike JohnnJohn SaranSara AlexnKate MikenAlex Kate\\" >>> assign_secret_santa([\\"Anna\\", \\"Elsa\\"]) \\"Impossible\\"","solution":"import random def assign_secret_santa(names): n = len(names) if n == 2: return \\"Impossible\\" shuffled_names = names[:] while True: random.shuffle(shuffled_names) is_valid = all(name != shuffled_name for name, shuffled_name in zip(names, shuffled_names)) if is_valid: result = [name + \\" \\" + shuffled_name for name, shuffled_name in zip(names, shuffled_names)] return \\"n\\".join(result)"},{"question":"from typing import List def water_stations(segments: List[int], N: int) -> int: Tom is planning to organize a marathon, and he needs to mark the water station points along the marathon route. The marathon route is represented as a straight line divided into M (1 ≤ M ≤ 100) segments, with each segment described by its length in kilometers. To ensure the runners are well-hydrated, Tom wants to place a water station at the end of every N kilometers along the route, starting from the start of the marathon. If a water station falls exactly on the end of a segment, it should still be considered valid. >>> water_stations([3, 5, 2], 2) 5 >>> water_stations([10, 10, 10], 10) 3 >>> water_stations([4, 6, 10], 5) 4","solution":"def water_stations(segments, N): total_distance = sum(segments) if total_distance == 0: return 0 return (total_distance // N) + (1 if total_distance % N != 0 else 0)"},{"question":"def min_sum_of_squares(N, arr): Returns the minimum sum of squares that can be obtained by rearranging the elements of an integer array into two separate sub-arrays and summing the sum of squares of each sub-array. >>> min_sum_of_squares(5, [1, 2, 3, 4, 5]) 55 >>> min_sum_of_squares(1, [1]) 1 >>> min_sum_of_squares(2, [1, 2]) 5 >>> min_sum_of_squares(4, [2, 2, 2, 2]) 16 >>> min_sum_of_squares(3, [10000, 10000, 10000]) 300000000","solution":"def min_sum_of_squares(N, arr): Returns the minimum sum of squares that can be obtained by rearranging the elements of an integer array into two separate sub-arrays and summing the sum of squares of each sub-array. arr.sort() sub_array1 = arr[:N//2] sub_array2 = arr[N//2:] sum_of_squares = sum(x ** 2 for x in sub_array1) + sum(x ** 2 for x in sub_array2) return sum_of_squares"},{"question":"def final_length_after_operations(k: int, s: str) -> int: Returns the final length of the string after performing k operations. Args: k (int): the number of operations to be performed. s (str): the initial string consisting of only 'a' and 'b'. Returns: int: the length of the string after k operations. Examples: >>> final_length_after_operations(1, \\"ab\\") 4 >>> final_length_after_operations(2, \\"a\\") 4 >>> final_length_after_operations(3, \\"ab\\") 16 >>> final_length_after_operations(4, \\"abba\\") 64 >>> final_length_after_operations(3, \\"bbb\\") 24 pass","solution":"def final_length_after_operations(k, s): Returns the final length of the string after performing k operations. initial_length = len(s) final_length = initial_length * (2 ** k) return final_length"},{"question":"def minimize_difference(n: int, times: List[int]) -> int: Partition a list of task completion times into two teams with the minimum possible difference between their total task completion times. >>> minimize_difference(4, [1, 3, 5, 9]) 0 >>> minimize_difference(3, [8, 3, 3]) 2 >>> minimize_difference(1, [10]) 10 >>> minimize_difference(4, [5, 5, 5, 5]) 0 >>> minimize_difference(2, [1, 2]) 1","solution":"def minimize_difference(n, times): total_time = sum(times) half_time = total_time // 2 dp = [0] * (half_time + 1) for t in times: for j in range(half_time, t - 1, -1): dp[j] = max(dp[j], dp[j - t] + t) return abs(total_time - 2 * dp[half_time])"},{"question":"def charity_auction(n: int, bids_input: List[str]) -> List[str]: Determines the winners for each item along with the winning bid amount. Args: n: an integer, the number of bids placed in the auction. bids_input: a list of strings, where each string contains the item name, bid amount, and bidder's name separated by spaces. Returns: A list of strings in the format \\"item_name winning_bidder winning_bid\\", sorted alphabetically by item name. >>> charity_auction(6, [\\"painting 300 John\\", \\"vase 150 Alice\\", \\"sculpture 200 Bob\\", \\"vase 200 Charlie\\", \\"painting 350 Emma\\", \\"sculpture 250 John\\"]) [\\"painting Emma 350\\", \\"sculpture John 250\\", \\"vase Charlie 200\\"] >>> charity_auction(1, [\\"statue 500 Mike\\"]) [\\"statue Mike 500\\"] >>> charity_auction(6, [\\"watch 300 Anna\\", \\"ring 150 Bob\\", \\"watch 350 Carlo\\", \\"watch 320 Anna\\", \\"ring 200 Dan\\", \\"bracelet 100 Emma\\"]) [\\"bracelet Emma 100\\", \\"ring Dan 200\\", \\"watch Carlo 350\\"] >>> charity_auction(2, [\\"chair 150 Zoe\\", \\"chair 150 Abby\\"]) [\\"chair Zoe 150\\"] >>> charity_auction(0, []) []","solution":"def determine_winners(n, bids): Determines the winners for each item along with the winning bid amount. Args: n: an integer, the number of bids placed in the auction. bids: a list of tuples, where each tuple contains (item name, bid amount, bidder name) Returns: A sorted list of strings in the format \\"item_name winning_bidder winning_bid\\" from collections import defaultdict # Dictionary to store the highest bid for each item max_bids = defaultdict(lambda: (0, '')) for item, bid, bidder in bids: bid = int(bid) if bid > max_bids[item][0]: max_bids[item] = (bid, bidder) # Formatting the results result = [] for item in sorted(max_bids): bid, bidder = max_bids[item] result.append(f\\"{item} {bidder} {bid}\\") return result # Function to help parse input and pass it to determine_winners def charity_auction(n, bids_input): bids = [tuple(bid.split()[:2] + [' '.join(bid.split()[2:])]) for bid in bids_input] return determine_winners(n, bids)"},{"question":"def roman_to_int(s: str) -> int: Convert a string representing a Roman numeral to an integer. >>> roman_to_int(\\"III\\") 3 >>> roman_to_int(\\"IV\\") 4 >>> roman_to_int(\\"IX\\") 9 >>> roman_to_int(\\"LVIII\\") 58 >>> roman_to_int(\\"MCMXCIV\\") 1994 from solution import roman_to_int def test_roman_to_int_example_1(): assert roman_to_int(\\"III\\") == 3 def test_roman_to_int_example_2(): assert roman_to_int(\\"IV\\") == 4 def test_roman_to_int_example_3(): assert roman_to_int(\\"IX\\") == 9 def test_roman_to_int_example_4(): assert roman_to_int(\\"LVIII\\") == 58 def test_roman_to_int_example_5(): assert roman_to_int(\\"MCMXCIV\\") == 1994 def test_roman_to_int_edge_cases(): assert roman_to_int(\\"I\\") == 1 assert roman_to_int(\\"MMMCMXCIX\\") == 3999 def test_roman_to_int_combined_cases(): assert roman_to_int(\\"XXIV\\") == 24 assert roman_to_int(\\"XCIX\\") == 99 assert roman_to_int(\\"CDXLIV\\") == 444 def test_roman_to_int_invalid_cases(): try: assert roman_to_int(\\"\\") == 0 except: pass try: assert roman_to_int(\\"IIII\\") == 4 except: pass","solution":"def roman_to_int(s): Convert a string of Roman numeral to an integer. roman_to_int_map = { 'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000 } total = 0 prev_value = 0 for char in reversed(s): current_value = roman_to_int_map[char] if current_value < prev_value: total -= current_value else: total += current_value prev_value = current_value return total"},{"question":"def countDistinctStrings(S: str) -> int: This function takes a string S containing characters a-z and '?', and returns the number of distinct strings that can be formed by replacing all '?' characters with any character from 'a' to 'z'. >>> countDistinctStrings(\\"ab?c\\") 26 >>> countDistinctStrings(\\"a?b?c\\") 676 >>> countDistinctStrings(\\"abc\\") 1 >>> countDistinctStrings(\\"???\\") 17576 >>> countDistinctStrings(\\"\\") 1 >>> countDistinctStrings(\\"a\\") 1 >>> countDistinctStrings(\\"??????????\\") 141167095653376","solution":"def countDistinctStrings(S): This function takes a string S containing characters a-z and '?', and returns the number of distinct strings that can be formed by replacing all '?' characters with any character from 'a' to 'z'. # Count the number of '?' in the string question_marks = S.count('?') # Each '?' can be replaced by any of the 26 letters from 'a' to 'z' # Thus, the total number of distinct strings is 26 raised to the power of # the number of question marks return 26 ** question_marks"},{"question":"def sum_of_even_numbers(numbers): Returns the sum of all even numbers in the input array. :param numbers: List of integers :return: Sum of all even integers in the array >>> sum_of_even_numbers([1, 2, 3, 4, 5, 6]) 12 >>> sum_of_even_numbers([7, 8, 10, -2, 0]) 16 >>> sum_of_even_numbers([1, 3, 5, 7]) 0 >>> sum_of_even_numbers([]) 0 >>> sum_of_even_numbers([0, 0, 0]) 0 >>> sum_of_even_numbers([-2, -4, -1, 3, 4, 0]) -2","solution":"def sum_of_even_numbers(numbers): Returns the sum of all even numbers in the input array. :param numbers: List of integers :return: Sum of all even integers in the array return sum(num for num in numbers if num % 2 == 0)"},{"question":"def max_rectangle_area(grid): Find the maximum area of a rectangle formed by adjacent cells with the same height. >>> max_rectangle_area([[1, 1, 1, 2], [2, 2, 2, 2], [3, 3, 1, 1]]) 4 >>> max_rectangle_area([[1, 2, 3, 4], [5, 5, 5, 5], [7, 8, 8, 8], [7, 8, 8, 8]]) 6 >>> max_rectangle_area([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]]) 16 >>> max_rectangle_area([[1, 2, 1, 2], [2, 2, 2, 2], [1, 1, 1, 1], [2, 2, 2, 2]]) 4 >>> max_rectangle_area([[1]]) 1","solution":"def max_rectangle_area(grid): n = len(grid) m = len(grid[0]) max_area = 0 # Pre-process each row to get the maximum width of same height cells def process_row(row): widths = [] current_height = row[0] current_width = 1 for i in range(1, len(row)): if row[i] == current_height: current_width += 1 else: widths.append((current_height, current_width)) current_height = row[i] current_width = 1 widths.append((current_height, current_width)) return widths for row in range(n): row_widths = process_row(grid[row]) for height, width in row_widths: # Check vertically for start_col in range(m - width + 1): col_idx = start_col min_width = width for r in range(row, n): if all(grid[r][c] == height for c in range(col_idx, col_idx + min_width)): max_area = max(max_area, (r - row + 1) * min_width) else: break return max_area"},{"question":"def count_pairs_with_difference(arr, k): Counts the number of pairs (i, j) such that a_j - a_i = k. Parameters: arr (list): The list of integers. k (int): The difference we are looking for between pairs. Returns: int: The number of valid pairs. Examples: >>> count_pairs_with_difference([1, 5, 3, 4, 2], 2) 3 >>> count_pairs_with_difference([1, 2, 3], 5) 0 >>> count_pairs_with_difference([1, 3, 5, 7], 2) 3 >>> count_pairs_with_difference([-1, -5, -3, -4, -2], 2) 3","solution":"def count_pairs_with_difference(arr, k): Counts the number of pairs (i, j) such that a_j - a_i = k. Parameters: arr (list): The list of integers. k (int): The difference we are looking for between pairs. Returns: int: The number of valid pairs. count = 0 seen = set() for num in arr: if num + k in seen: count += 1 if num - k in seen: count += 1 seen.add(num) return count"},{"question":"def distribute_prizes(N: int, M: int, prizes: List[int]) -> List[int]: This function allocates prizes to players and returns the count of undistributed prizes for each category. Parameters: N (int): The number of players. M (int): The number of prize categories. prizes (list): A list of integers where each integer represents the number of prizes in a corresponding category. Returns: list: A list of integers where each integer represents the number of remaining undistributed prizes for the corresponding category. >>> distribute_prizes(5, 3, [3, 6, 8]) [0, 1, 3] >>> distribute_prizes(10, 2, [3, 7]) [0, 0] >>> distribute_prizes(5, 3, [0, 0, 0]) [0, 0, 0] >>> distribute_prizes(4, 3, [5, 6, 7]) [1, 2, 3] >>> distribute_prizes(3, 3, [3, 3, 3]) [0, 0, 0]","solution":"def distribute_prizes(N, M, prizes): This function allocates prizes to players and returns the count of undistributed prizes for each category. Parameters: N (int): The number of players. M (int): The number of prize categories. prizes (list): A list of integers where each integer represents the number of prizes in a corresponding category. Returns: list: A list of integers where each integer represents the number of remaining undistributed prizes for the corresponding category. undistributed_prizes = [] for Pi in prizes: if Pi > N: undistributed_prizes.append(Pi - N) else: undistributed_prizes.append(0) return undistributed_prizes"},{"question":"def max_subtree_sum(n, values, edges): You are given a tree with n nodes rooted at node 1. Each node has a value assigned to it which can be positive or negative. Your task is to choose a subtree (which can be the entire tree or a single node) such that the sum of the values of the nodes in this subtree is maximized. Args: n (int): The number of nodes in the tree. values (List[int]): The values assigned to the nodes from 1 to n. edges (List[Tuple[int, int]]): List of edges, each represented by a tuple (u, v) denoting an edge between nodes u and v. Returns: int: The maximum sum of the values of the nodes in any subtree of the given tree. Example: >>> max_subtree_sum(5, [1, 2, 3, -2, -1], [(1, 2), (1, 3), (2, 4), (2, 5)]) 6 >>> max_subtree_sum(3, [-1, -3, -10], [(1, 2), (1, 3)]) -1","solution":"def max_subtree_sum(n, values, edges): from collections import defaultdict import sys sys.setrecursionlimit(100000) # Build the tree as an adjacency list tree = defaultdict(list) for u, v in edges: tree[u].append(v) tree[v].append(u) # Helper function to perform dfs and find the maximum subtree sum def dfs(node, parent): # This variable will hold the current subtree sum current_sum = values[node - 1] # Node values are indexed from 1 # This variable will hold the maximum subtree sum found so far max_sum = values[node - 1] # Visit each child (neighbor) for neighbor in tree[node]: if neighbor == parent: continue subtree_sum = dfs(neighbor, node) # If a subtree sum is positive, it will be part of the maximum subtree sum if subtree_sum > 0: current_sum += subtree_sum # Update the max_sum if the current sum is greater max_sum = max(max_sum, current_sum) return max_sum # Start dfs from the root node (usually node 1) and return the result return dfs(1, -1)"},{"question":"def largest_rectangle_area(heights: List[int]) -> int: Given a list of heights representing buildings, returns the area of the largest rectangle that can be formed within these buildings. >>> largest_rectangle_area([2, 1, 5, 6, 2, 3]) 10 >>> largest_rectangle_area([1, 2, 3, 4, 5]) 9 >>> largest_rectangle_area([6, 2, 5, 4, 5, 1, 6]) 12 >>> largest_rectangle_area([5, 5, 5, 5, 5]) 25 >>> largest_rectangle_area([5]) 5 >>> largest_rectangle_area([5, 4, 3, 2, 1]) 9 >>> largest_rectangle_area([0, 1, 0, 1]) 1 >>> largest_rectangle_area([]) 0","solution":"def largest_rectangle_area(heights): Given a list of heights representing buildings, returns the area of the largest rectangle that can be formed within these buildings. # Initialize stack to keep track of indices of heights stack = [] max_area = 0 index = 0 while index < len(heights): # If this bar is higher than the bar at stack top, push it to the stack if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: # Pop the top top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) # Now, pop the remaining bars from stack and calculate area with each popped bar while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"from collections import deque def min_steps_in_maze(n: int, m: int, maze: List[List[str]], start: Tuple[int, int], end: Tuple[int, int]) -> int: This function returns the minimum number of steps required to reach the destination from the start position in a given maze or -1 if the destination is not reachable. Parameters: n (int): number of rows m (int): number of columns maze (list): the 2D maze grid start (tuple): starting position (x1, y1) end (tuple): destination position (x2, y2) Returns: int: minimum number of steps or -1 if unreachable Example: >>> n, m = 3, 3 >>> maze = [['.', '.', '#'], ['.', '#', '.'], ['.', '.', '.']] >>> start = (0, 0) >>> end = (2, 2) >>> min_steps_in_maze(n, m, maze, start, end) 4 >>> n, m = 3, 3 >>> maze = [['.', '.', '#'], ['.', '#', '#'], ['#', '.', '.']] >>> start = (0, 0) >>> end = (2, 2) >>> min_steps_in_maze(n, m, maze, start, end) -1 pass def test_min_steps_in_maze_example_1(): n, m = 3, 3 maze = [ ['.', '.', '#'], ['.', '#', '.'], ['.', '.', '.'] ] start = (0, 0) end = (2, 2) assert min_steps_in_maze(n, m, maze, start, end) == 4 def test_min_steps_in_maze_example_2(): n, m = 3, 3 maze = [ ['.', '.', '#'], ['.', '#', '#'], ['#', '.', '.'] ] start = (0, 0) end = (2, 2) assert min_steps_in_maze(n, m, maze, start, end) == -1 def test_min_steps_in_maze_direct_path(): n, m = 2, 2 maze = [ ['.', '.'], ['.', '.'] ] start = (0, 0) end = (1, 1) assert min_steps_in_maze(n, m, maze, start, end) == 2 def test_min_steps_in_maze_no_move_needed(): n, m = 2, 2 maze = [ ['.', '.'], ['.', '.'] ] start = (1, 1) end = (1, 1) assert min_steps_in_maze(n, m, maze, start, end) == 0 def test_min_steps_in_maze_unreachable(): n, m = 3, 3 maze = [ ['#', '#', '#'], ['#', '.', '#'], ['#', '#', '#'] ] start = (1, 1) end = (0, 0) assert min_steps_in_maze(n, m, maze, start, end) == -1","solution":"from collections import deque def min_steps_in_maze(n, m, maze, start, end): This function returns the minimum number of steps required to reach the destination from the start position in a given maze or -1 if the destination is not reachable. Parameters: n (int): number of rows m (int): number of columns maze (list): the 2D maze grid start (tuple): starting position (x1, y1) end (tuple): destination position (x2, y2) Returns: int: minimum number of steps or -1 if unreachable # Directions array for up, down, left and right movements directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # BFS initialization queue = deque([(start[0], start[1], 0)]) # (x, y, steps) visited = set() visited.add((start[0], start[1])) while queue: x, y, steps = queue.popleft() # Check if we reached the end position if (x, y) == end: return steps # Explore all possible directions for dir in directions: nx, ny = x + dir[0], y + dir[1] if 0 <= nx < n and 0 <= ny < m and maze[nx][ny] == '.' and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, steps + 1)) # Return -1 if the destination cannot be reached return -1"},{"question":"def rearrange_string(s: str) -> str: Construct a string t by rearranging the characters of s such that no two adjacent characters in t are the same. If such arrangement is not possible, return -1. >>> rearrange_string(\\"aabbc\\") \\"ababc\\" >>> rearrange_string(\\"aaa\\") -1","solution":"from collections import Counter from heapq import heappush, heappop def rearrange_string(s): n = len(s) if n == 1: return s freq = Counter(s) max_count = max(freq.values()) if max_count > (n + 1) // 2: return -1 max_heap = [] for char, count in freq.items(): heappush(max_heap, (-count, char)) prev_char, prev_count = None, 0 result = [] while max_heap: count, char = heappop(max_heap) result.append(char) if prev_count < 0: heappush(max_heap, (prev_count, prev_char)) prev_count, prev_char = count + 1, char return ''.join(result)"},{"question":"def largest_palindrome_less_or_equal_to_x(x: int) -> int: Find the largest palindromic number less than or equal to x. >>> largest_palindrome_less_or_equal_to_x(123) 121 >>> largest_palindrome_less_or_equal_to_x(4000) 3993 pass def solve_palindromes(test_cases: List[int]) -> List[int]: For a list of test cases, return a list of the largest palindromic numbers less or equal to each test case. >>> solve_palindromes([123]) [121] >>> solve_palindromes([123, 4000]) [121, 3993] pass","solution":"def largest_palindrome_less_or_equal_to_x(x): Find the largest palindromic number less than or equal to x. def is_palindrome(num): return str(num) == str(num)[0:][::-1] for num in range(x, 0, -1): if is_palindrome(num): return num def solve_palindromes(test_cases): results = [] for x in test_cases: results.append(largest_palindrome_less_or_equal_to_x(x)) return results"},{"question":"def is_palindrome(s: str) -> bool: Determines if the given string is a palindrome ignoring spaces, punctuation, and capitalization. >>> is_palindrome(\\"A man a plan a canal Panama\\") True >>> is_palindrome(\\"racecar\\") True >>> is_palindrome(\\"Hello World\\") False def check_palindromes(n: int, strings: List[str]) -> List[str]: Determines for each string in the given list if it is a palindrome and returns a list of \\"YES\\" or \\"NO\\" for each string. >>> check_palindromes(3, [\\"A man a plan a canal Panama\\", \\"racecar\\", \\"Hello World\\"]) [\\"YES\\", \\"YES\\", \\"NO\\"] >>> check_palindromes(2, [\\"No 'x' in Nixon\\", \\"Was it a car or a cat I saw\\"]) [\\"YES\\", \\"YES\\"]","solution":"def is_palindrome(s): Determines if the given string is a palindrome ignoring spaces, punctuation, and capitalization. import re cleaned = re.sub(r'[^A-Za-z0-9]', '', s).lower() return cleaned == cleaned[::-1] def check_palindromes(n, strings): results = [] for s in strings: if is_palindrome(s): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def max_pixel_value(matrix, x1, y1, x2, y2): Returns the maximum pixel value within the specified sub-area of the matrix defined by the coordinates (x1, y1) to (x2, y2). Parameters: matrix (list of lists): A 2D list representing the image. x1 (int): Top-left x-coordinate of the sub-area (1-indexed). y1 (int): Top-left y-coordinate of the sub-area (1-indexed). x2 (int): Bottom-right x-coordinate of the sub-area (1-indexed). y2 (int): Bottom-right y-coordinate of the sub-area (1-indexed). Returns: int: The maximum pixel value in the specified sub-area. # Example usage # matrix = [ # [1, 2, 3, 2, 1], # [4, 5, 6, 5, 4], # [7, 8, 9, 8, 7], # [2, 3, 4, 3, 2] # ] # print(max_pixel_value(matrix, 2, 2, 4, 4)) # Output: 9 # Test cases # def test_max_pixel_value_basic(): # matrix = [ # [1, 2, 3, 2, 1], # [4, 5, 6, 5, 4], # [7, 8, 9, 8, 7], # [2, 3, 4, 3, 2] # ] # assert max_pixel_value(matrix, 2, 2, 4, 4) == 9 # def test_max_pixel_value_single_element(): # matrix = [ # [1, 2, 3], # [4, 5, 6], # [7, 8, 9] # ] # assert max_pixel_value(matrix, 1, 1, 1, 1) == 1 # assert max_pixel_value(matrix, 3, 3, 3, 3) == 9 # def test_max_pixel_value_entire_matrix(): # matrix = [ # [1, 2, 3], # [4, 5, 6], # [7, 8, 9] # ] # assert max_pixel_value(matrix, 1, 1, 3, 3) == 9 # def test_max_pixel_value_sub_area_in_the_middle(): # matrix = [ # [1, 2, 3, 4, 5], # [5, 6, 7, 8, 9], # [9, 8, 7, 6, 5], # [5, 4, 3, 2, 1], # [1, 1, 1, 1, 1] # ] # assert max_pixel_value(matrix, 2, 2, 4, 4) == 8 # def test_max_pixel_value_large_matrix(): # matrix = [ # [i for i in range(1000)] for _ in range(1000) # ] # assert max_pixel_value(matrix, 500, 500, 1000, 1000) == 999","solution":"def max_pixel_value(matrix, x1, y1, x2, y2): Returns the maximum pixel value within the specified sub-area of the matrix defined by the coordinates (x1, y1) to (x2, y2). Parameters: matrix (list of lists): A 2D list representing the image. x1 (int): Top-left x-coordinate of the sub-area (1-indexed). y1 (int): Top-left y-coordinate of the sub-area (1-indexed). x2 (int): Bottom-right x-coordinate of the sub-area (1-indexed). y2 (int): Bottom-right y-coordinate of the sub-area (1-indexed). Returns: int: The maximum pixel value in the specified sub-area. max_val = float('-inf') for i in range(x1 - 1, x2): for j in range(y1 - 1, y2): if matrix[i][j] > max_val: max_val = matrix[i][j] return max_val"},{"question":"def maximize_beauty(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: John loves paintings and he has n paintings which need to be arranged in a gallery. Each painting i has a beauty value bi associated with it. John wants to maximize the sum of beauty values of the selected paintings, but there is a catch. If two paintings have consecutive indices in the list, he cannot select both. Your task is to help him maximize the sum of beauty values without selecting any two consecutive paintings. Args: t (int): The number of test cases. test_cases (List[Tuple[int, List[int]]]): Each test case consists of an integer n and a list of n integers, representing the beauty values of the paintings. Returns: List[int]: The maximum sum of beauty values John can obtain for each test case. >>> maximize_beauty(2, [(4, [4, 1, 2, 7]), (3, [4, -1, 2])]) [11, 6] >>> maximize_beauty(1, [(1, [5])]) [5] >>> maximize_beauty(1, [(4, [-1, -2, -3, -4])]) [0] >>> maximize_beauty(1, [(5, [3, 2, 5, 10, 7])]) [15] >>> maximize_beauty(1, [(8, [3, 2, 7, 10, 5, 1, 10, 5])]) [25]","solution":"def maximize_beauty(t, test_cases): results = [] for case in test_cases: n, beauties = case if n == 1: results.append(beauties[0]) continue dp = [0] * n dp[0] = max(0, beauties[0]) if n > 1: dp[1] = max(dp[0], beauties[1]) for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + beauties[i]) results.append(dp[-1]) return results"},{"question":"from collections import deque from typing import List, Dict def crawl(start_url: str, links: Dict[str, List[str]]) -> List[str]: This function returns a list of URLs reachable from the start_url using BFS. Parameters: start_url (str): The starting URL. links (Dict[str, List[str]]): A dictionary where keys are URLs and values are lists of URLs representing outgoing links. Returns: List[str]: A list of URLs reachable from the start_url in BFS order. Example: >>> start_url = \\"http://example.com\\" >>> links = { \\"http://example.com\\": [\\"http://example.com/about\\", \\"http://example.com/contact\\"], \\"http://example.com/about\\": [\\"http://example.com/team\\"], \\"http://example.com/contact\\": [\\"http://example.com/privacy-policy\\"], \\"http://example.com/team\\": [], \\"http://example.com/privacy-policy\\": [] } >>> crawl(start_url, links) [\\"http://example.com\\", \\"http://example.com/about\\", \\"http://example.com/contact\\", \\"http://example.com/team\\", \\"http://example.com/privacy-policy\\"] pass def test_crawl_example(): start_url = \\"http://example.com\\" links = { \\"http://example.com\\": [\\"http://example.com/about\\", \\"http://example.com/contact\\"], \\"http://example.com/about\\": [\\"http://example.com/team\\"], \\"http://example.com/contact\\": [\\"http://example.com/privacy-policy\\"], \\"http://example.com/team\\": [], \\"http://example.com/privacy-policy\\": [] } expected = [ \\"http://example.com\\", \\"http://example.com/about\\", \\"http://example.com/contact\\", \\"http://example.com/team\\", \\"http://example.com/privacy-policy\\" ] assert crawl(start_url, links) == expected def test_crawl_single_page(): start_url = \\"http://example.com\\" links = {\\"http://example.com\\": []} expected = [\\"http://example.com\\"] assert crawl(start_url, links) == expected def test_crawl_disconnected_page(): start_url = \\"http://example.com\\" links = { \\"http://example.com\\": [\\"http://example.com/about\\"], \\"http://example.com/about\\": [], \\"http://example2.com\\": [\\"http://example2.com/contact\\"] } expected = [\\"http://example.com\\", \\"http://example.com/about\\"] assert crawl(start_url, links) == expected def test_crawl_no_start_url(): start_url = \\"http://example.com\\" links = { \\"http://example2.com\\": [\\"http://example2.com/about\\"] } expected = [] assert crawl(start_url, links) == expected def test_crawl_complex_case(): start_url = \\"http://site.com/home\\" links = { \\"http://site.com/home\\": [\\"http://site.com/about\\", \\"http://site.com/contact\\"], \\"http://site.com/about\\": [\\"http://site.com/team\\", \\"http://site.com/history\\"], \\"http://site.com/contact\\": [\\"http://site.com/email\\"], \\"http://site.com/team\\": [], \\"http://site.com/history\\": [], \\"http://site.com/email\\": [], \\"http://site.com/careers\\": [\\"http://site.com/apply\\"] } expected = [ \\"http://site.com/home\\", \\"http://site.com/about\\", \\"http://site.com/contact\\", \\"http://site.com/team\\", \\"http://site.com/history\\", \\"http://site.com/email\\" ] assert crawl(start_url, links) == expected","solution":"from collections import deque def crawl(start_url, links): This function returns a list of URLs reachable from the start_url using BFS. Parameters: start_url (str): The starting URL. links (dict): A dictionary where keys are URLs and values are lists of URLs representing outgoing links. Returns: list: A list of URLs reachable from the start_url in BFS order. if start_url not in links: return [] visited = set() queue = deque([start_url]) result = [] while queue: current_url = queue.popleft() if current_url not in visited: visited.add(current_url) result.append(current_url) for next_url in links[current_url]: if next_url not in visited: queue.append(next_url) return result"},{"question":"def max_candles_to_blow_out(n: int, heights: List[int]) -> int: Determine the maximum number of candles that can be blown out in one go. Parameters: n (int): The number of candles. heights (list of int): The heights of the candles. Returns: int: The maximum number of candles that can be blown out in one go. >>> max_candles_to_blow_out(4, [4, 4, 1, 3]) 2 >>> max_candles_to_blow_out(6, [2, 2, 2, 1, 2, 2]) 5","solution":"def max_candles_to_blow_out(n, heights): Returns the maximum number of candles that can be blown out in one go. Parameters: n (int): The number of candles. heights (list of int): The heights of the candles. Returns: int: The maximum number of candles that can be blown out in one go. max_height = max(heights) return heights.count(max_height)"},{"question":"def reverse_segments(n: int, k: int, segment_sizes: list) -> list: Returns the final order of books after reversing each segment. :param n: int - number of books :param k: int - number of segments :param segment_sizes: list - sizes of each segment :return: list - the final order of books after reversing the segments >>> reverse_segments(8, 3, [2, 3, 3]) [2, 1, 5, 4, 3, 8, 7, 6] >>> reverse_segments(6, 2, [3, 3]) [3, 2, 1, 6, 5, 4] >>> reverse_segments(5, 1, [5]) [5, 4, 3, 2, 1] >>> reverse_segments(10, 5, [2, 2, 2, 2, 2]) [2, 1, 4, 3, 6, 5, 8, 7, 10, 9] >>> reverse_segments(10, 1, [10]) [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]","solution":"def reverse_segments(n, k, segment_sizes): Returns the final order of books after reversing each segment. :param n: int - number of books :param k: int - number of segments :param segment_sizes: list - sizes of each segment :return: list - the final order of books after reversing the segments books = list(range(1, n + 1)) result = [] index = 0 for size in segment_sizes: segment = books[index:index + size] result.extend(segment[::-1]) index += size return result"},{"question":"def convert_to_base(n: int, base: int) -> str: Converts an integer n to its string representation in the given base. Base can be between 2 and 36 inclusive. Examples: >>> convert_to_base(10, 2) '1010' >>> convert_to_base(255, 16) 'FF' >>> convert_to_base(-10, 7) '-13' >>> convert_to_base(123, 36) '3F' >>> convert_to_base(0, 2) '0'","solution":"def convert_to_base(n, base): Converts an integer n to its string representation in the given base. Base can be between 2 and 36 inclusive. if base < 2 or base > 36: raise ValueError(\\"Base must be between 2 and 36 inclusive.\\") if n == 0: return \\"0\\" chars = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" negative = n < 0 if negative: n = -n result = [] while n > 0: result.append(chars[n % base]) n //= base if negative: result.append('-') return ''.join(reversed(result))"},{"question":"def num_decodings(s: str) -> int: Determine the number of ways to decode the given string \`s\`. >>> num_decodings(\\"12\\") 2 >>> num_decodings(\\"226\\") 3 >>> num_decodings(\\"2101\\") 1 pass def decode_ways(t: int, test_cases: List[str]) -> List[int]: Determine the number of ways to decode a list of strings \`test_cases\`. >>> decode_ways(3, [\\"12\\", \\"226\\", \\"2101\\"]) [2, 3, 1] >>> decode_ways(2, [\\"10\\", \\"27\\"]) [1, 1] pass from solution import num_decodings, decode_ways def test_num_decodings_single_digit(): assert num_decodings(\\"1\\") == 1 assert num_decodings(\\"9\\") == 1 def test_num_decodings_double_digits(): assert num_decodings(\\"12\\") == 2 # \\"AB\\" or \\"L\\" assert num_decodings(\\"26\\") == 2 # \\"BF\\" or \\"Z\\" assert num_decodings(\\"10\\") == 1 # \\"J\\" def test_num_decodings_multiple_digits(): assert num_decodings(\\"226\\") == 3 # \\"BZ\\", \\"VF\\", \\"BBF\\" assert num_decodings(\\"2101\\") == 1 # \\"UAA\\", \\"BAA\\" def test_decode_ways(): assert decode_ways(3, [\\"12\\", \\"226\\", \\"2101\\"]) == [2, 3, 1] assert decode_ways(2, [\\"10\\", \\"27\\"]) == [1, 1] def test_edge_cases(): assert num_decodings(\\"5\\") == 1 # Only one way to decode \\"5\\" assert num_decodings(\\"110\\") == 1 # Only one way to decode \\"110\\" -> \\"JA\\" assert num_decodings(\\"123123\\") == 9 # Many ways to decode \\"123123\\"","solution":"def num_decodings(s): Returns the number of ways to decode the input string s. if not s: return 0 n = len(s) dp = [0] * (n + 1) dp[0] = 1 for i in range(1, n + 1): if s[i - 1] != '0': dp[i] += dp[i - 1] if i > 1 and '10' <= s[i - 2:i] <= '26': dp[i] += dp[i - 2] return dp[-1] def decode_ways(t, test_cases): results = [] for s in test_cases: results.append(num_decodings(s)) return results"},{"question":"def calculate_pages_required(T: int, cases: list) -> list: Calculate the number of pages required for the book with given words and words per page. Args: T: int - the number of test cases. cases: list - list of tuples where each tuple contains W (number of words), P (number of words per page), and the words. Returns: list - the number of pages required for each test case. Example: >>> T, cases = parse_input(\\"2n6 3nword1 word2 word3 word4 word5 word6n7 4nhello world this is a simple test\\") >>> calculate_pages_required(T, cases) [2, 2] >>> T, cases = parse_input(\\"1n4 2nword1 word2 word3 word4\\") >>> calculate_pages_required(T, cases) [2] def parse_input(input_string: str) -> tuple: Parse the input string to extract the number of test cases and corresponding cases. Args: input_string: str - the input string representing multiple test cases. Returns: tuple - a tuple containing the number of test cases and list of cases. Example: >>> parse_input(\\"2n6 3nword1 word2 word3 word4 word5 word6n7 4nhello world this is a simple test\\") (2, [(6, 3, ['word1', 'word2', 'word3', 'word4', 'word5', 'word6']), (7, 4, ['hello', 'world', 'this', 'is', 'a', 'simple', 'test'])]) >>> parse_input(\\"1n4 2nword1 word2 word3 word4\\") (1, [(4, 2, ['word1', 'word2', 'word3', 'word4'])])","solution":"def calculate_pages_required(T, cases): results = [] for case in cases: W, P, words = case pages_required = (W + P - 1) // P # This is a ceiling division to find the number of pages results.append(pages_required) return results def parse_input(input_string): lines = input_string.strip().split(\\"n\\") T = int(lines[0]) cases = [] line_index = 1 for _ in range(T): W, P = map(int, lines[line_index].split()) words = lines[line_index + 1].split() cases.append((W, P, words)) line_index += 2 return T, cases"},{"question":"def is_bipartite(n: int, edges: List[Tuple[int, int]]) -> str: Given an undirected graph with n nodes and m edges, determine if it is possible to assign a color (either Red or Blue) to each node such that no two adjacent nodes have the same color (i.e., determine if the graph is Bipartite). >>> is_bipartite(4, [(1, 2), (2, 3), (3, 4), (4, 1)]) 'YES' >>> is_bipartite(3, [(1, 2), (2, 3), (3, 1)]) 'NO' >>> is_bipartite(1, []) 'YES' >>> is_bipartite(3, []) 'YES' >>> is_bipartite(4, [(1, 2), (3, 4)]) 'YES' >>> is_bipartite(6, [(1, 2), (2, 3), (4, 5), (5, 6), (6, 4)]) 'NO' >>> is_bipartite(5, [(1, 2), (1, 3), (2, 4), (3, 5)]) 'YES'","solution":"def is_bipartite(n, edges): from collections import defaultdict, deque graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) visited = {} def bfs(node): queue = deque([node]) visited[node] = 0 while queue: current = queue.popleft() current_color = visited[current] for neighbor in graph[current]: if neighbor not in visited: visited[neighbor] = 1 - current_color queue.append(neighbor) elif visited[neighbor] == current_color: return False return True for node in range(1, n + 1): if node not in visited and not bfs(node): return \\"NO\\" return \\"YES\\""},{"question":"def min_teams_needed(t, test_cases): Determines the minimum number of teams needed to complete all projects consecutively. :param t: Number of test cases :param test_cases: A list of tuples, where each tuple contains the number of projects and a list of days required for each project. :return: A list of integers, where each integer represents the minimum number of teams needed for the corresponding test case. >>> min_teams_needed(2, [(4, [2, 3, 4, 5]), (3, [3, 1, 2])]) [1, 1] >>> min_teams_needed(1, [(5, [1, 1, 1, 1, 1])]) [1] >>> min_teams_needed(3, [(2, [1, 1000000]), (3, [999999, 1, 1]), (1, [5000])]) [1, 1, 1] >>> min_teams_needed(1, [(1, [100])]) [1] >>> min_teams_needed(1, [(5, [1, 1, 1, 1, 1])]) [1]","solution":"def min_teams_needed(t, test_cases): Determines the minimum number of teams needed to complete all projects consecutively. :param t: Number of test cases :param test_cases: A list of tuples, where each tuple contains the number of projects and a list of days required for each project. :return: A list of integers, where each integer represents the minimum number of teams needed for the corresponding test case. results = [] for n, days in test_cases: results.append(1) # As per problem statement, always only one team required return results"},{"question":"def findMaxLength(nums): Returns the length of the longest contiguous subarray with an equal number of 0's and 1's. >>> findMaxLength([0, 1, 0]) 2 >>> findMaxLength([0, 1, 1, 0, 1, 1, 1, 0]) 4 >>> findMaxLength([0, 1]) 2 >>> findMaxLength([1, 0]) 2 >>> findMaxLength([0, 0, 0, 0]) 0 >>> findMaxLength([1, 1, 1, 1]) 0 >>> findMaxLength([0, 0, 1, 0, 0, 1, 1]) 6 >>> findMaxLength([1, 1, 1, 0, 1, 1, 1, 0]) 2 >>> findMaxLength([0, 1, 0, 1, 0, 1, 0]) 6 >>> findMaxLength([0, 1] * 50000) 100000","solution":"def findMaxLength(nums): Returns the length of the longest contiguous subarray with an equal number of 0's and 1's. count = 0 max_length = 0 count_index_map = {0: -1} # Initialize with count 0 at index -1 for index, num in enumerate(nums): # Increment count by 1 for 1 and decrement by 1 for 0 count += 1 if num == 1 else -1 if count in count_index_map: max_length = max(max_length, index - count_index_map[count]) else: count_index_map[count] = index return max_length"},{"question":"def merge_and_sort_sequences(sequences): Merges and sorts multiple integer sequences. Args: sequences (list of list of ints): List of integer sequences to be merged and sorted. Returns: list of int: Merged and sorted list of integers. pass def main(k, sequences_input): Reads the number of sequences and the sequences themselves, then returns a merged sorted sequence. Args: k (int): Number of sequences. sequences_input (list of int): Flattened list containing the sequence lengths and their elements. Returns: list of int: Merged and sorted list of integers. pass # Example usages and test cases for the functions if __name__ == \\"__main__\\": def test_merge_and_sort_sequences(): assert merge_and_sort_sequences([[1, 3, 5], [2, 4, 6, 8], [0, 7]]) == [0, 1, 2, 3, 4, 5, 6, 7, 8] assert merge_and_sort_sequences([[9, 7, 5, 3, 1], [6, 4, 2]]) == [1, 2, 3, 4, 5, 6, 7, 9] assert merge_and_sort_sequences([[], []]) == [] assert merge_and_sort_sequences([[1, 1, 1], [0, 1, 2]]) == [0, 1, 1, 1, 1, 2] assert merge_and_sort_sequences([[1000000000], [-1000000000]]) == [-1000000000, 1000000000] def test_main(): assert main(3, [3, 1, 3, 5, 4, 2, 4, 6, 8, 2, 0, 7]) == [0, 1, 2, 3, 4, 5, 6, 7, 8] assert main(2, [5, 9, 7, 5, 3, 1, 3, 6, 4, 2]) == [1, 2, 3, 4, 5, 6, 7, 9] assert main(1, [1, 5]) == [5] assert main(2, [3, 1, 1, 1, 3, 0, 1, 2]) == [0, 1, 1, 1, 1, 2] assert main(2, [2, 1000000000, 1000000000, 1, -1000000000]) == [-1000000000, 1000000000, 1000000000] test_merge_and_sort_sequences() test_main()","solution":"def merge_and_sort_sequences(sequences): Merges and sorts multiple integer sequences. Args: sequences (list of list of ints): List of integer sequences to be merged and sorted. Returns: list of int: Merged and sorted list of integers. merged_list = [] for seq in sequences: merged_list.extend(seq) return sorted(merged_list) def main(k, sequences_input): sequences = [] idx = 0 for i in range(k): mi = sequences_input[idx] sequences.append(sequences_input[idx + 1 : idx + 1 + mi]) idx += 1 + mi return merge_and_sort_sequences(sequences)"},{"question":"def sum_of_primes(n): Return the sum of all prime numbers less than a given integer n. >>> sum_of_primes(10) 17 >>> sum_of_primes(1) 0 >>> sum_of_primes(20) 77 >>> sum_of_primes(0) 0 >>> sum_of_primes(2) 0 >>> sum_of_primes(100) 1060","solution":"def sum_of_primes(n): def is_prime(num): if num <= 1: return False for i in range(2, int(num ** 0.5) + 1): if num % i == 0: return False return True prime_sum = 0 for i in range(2, n): if is_prime(i): prime_sum += i return prime_sum"},{"question":"from typing import List def count_treasure_chests(p: int, participants: List[int], c: int, chests: List[int]) -> List[int]: Determine how many treasure chests each participant can potentially open based on the sum of any combination of digits in their assigned number. Args: p (int): Number of participants. participants (List[int]): List of participants' unique numbers. c (int): Number of treasure chests. chests (List[int]): List of treasure chests' lock numbers. Returns: List[int]: Number of treasure chests each participant can open. Example: >>> count_treasure_chests(2, [123, 456], 3, [6, 15, 24]) [1, 2] >>> count_treasure_chests(1, [999999], 5, [9, 18, 27, 36, 45]) [5]","solution":"def get_combinations(digits): from itertools import combinations unique_sums = set() for i in range(1, len(digits) + 1): for combo in combinations(digits, i): unique_sums.add(sum(combo)) return unique_sums def count_treasure_chests(p, participants, c, chests): results = [] for number in participants: digits = [int(x) for x in str(number)] possible_sums = get_combinations(digits) count = sum(lock in possible_sums for lock in chests) results.append(count) return results # Example usage: if __name__ == \\"__main__\\": P = 2 participants = [123, 456] C = 3 chests = [6, 15, 24] results = count_treasure_chests(P, participants, C, chests) for result in results: print(result)"},{"question":"def calculate_score(grid): Calculates the total score for the grid based on the given rules: 1. For each cell containing an integer, add the value of the integer to the total score. 2. If a cell contains a number that is a multiple of 5, subtract the value of that number from the total score instead. 3. Ignore any empty cells (None) when calculating the score. pass from solution import calculate_score def test_calculate_score_example(): grid = [ [4, 15, 2], [None, 7, 10], [3, None, 5] ] assert calculate_score(grid) == -14 def test_calculate_score_empty_grid(): grid = [] assert calculate_score(grid) == 0 def test_calculate_score_all_none(): grid = [ [None, None], [None, None] ] assert calculate_score(grid) == 0 def test_calculate_score_no_multiples_of_5(): grid = [ [1, 2, 3], [4, 6, 7], [8, 9, 11] ] assert calculate_score(grid) == 51 def test_calculate_score_all_multiples_of_5(): grid = [ [5, 10, 15], [20, 25, 30], [35, 40, 45] ] assert calculate_score(grid) == -225 def test_calculate_score_mixed_values(): grid = [ [1, 5, None], [None, 10, 7], [None, None, 15] ] assert calculate_score(grid) == -22","solution":"def calculate_score(grid): Calculates the total score for the grid based on the given rules: 1. Add value for each cell containing an integer. 2. Subtract the value for each cell containing a number that is a multiple of 5. 3. Ignore empty cells (None). total_score = 0 for row in grid: for cell in row: if cell is not None: if cell % 5 == 0: total_score -= cell else: total_score += cell return total_score"},{"question":"def preprocess_items(items): Preprocess the items to create prefix sums. >>> preprocess_items([2, 3, 7, 1, 6]) [0, 2, 5, 12, 13, 19] pass def query_sum(prefix_sums, i, j): Query the sum of items from shelf i to shelf j (inclusive). >>> query_sum([0, 2, 5, 12, 13, 19], 0, 2) 12 >>> query_sum([0, 2, 5, 12, 13, 19], 1, 3) 11 pass def handle_queries(n, q, items, queries): Handle the queries and return a list of results. >>> handle_queries(5, 3, [2, 3, 7, 1, 6], [(0, 2), (1, 3), (2, 4)]) [12, 11, 14] >>> handle_queries(1, 1, [5], [(0, 0)]) [5] pass","solution":"def preprocess_items(items): Preprocess the items to create prefix sums. prefix_sums = [0] * (len(items) + 1) for i in range(len(items)): prefix_sums[i + 1] = prefix_sums[i] + items[i] return prefix_sums def query_sum(prefix_sums, i, j): Query the sum of items from shelf i to shelf j (inclusive). return prefix_sums[j + 1] - prefix_sums[i] def handle_queries(n, q, items, queries): Handle the queries and return a list of results. prefix_sums = preprocess_items(items) results = [] for i, j in queries: results.append(query_sum(prefix_sums, i, j)) return results"},{"question":"def max_g_i(T, test_cases): You are given an array of integers A_1, A_2, ..., A_N. For each integer i from 1 to N, define a function g(i) as follows: - g(i) is the maximum sum of a contiguous subarray that contains A_i at least once. Find the maximum value of g(i) for all i. -----Input----- - The first line of the input contains a single integer T denoting the number of test cases. The description of T test cases follows. - The first line of each test case contains a single integer N. - The second line contains N space-separated integers A_1, A_2, ..., A_N. -----Output----- For each test case, print a single line containing one integer — the maximum value of g(i) for all i. -----Constraints----- - 1 <= T <= 10 - 1 <= N <= 10^5 - -10^9 <= A_i <= 10^9 for each valid i >>> T = 2 >>> test_cases = [(5, [1, 2, -3, 4, 5]), (4, [-1, -2, -3, -4])] >>> max_g_i(T, test_cases) [9, -1] import pytest def test_example_cases(): T = 2 test_cases = [ (5, [1, 2, -3, 4, 5]), (4, [-1, -2, -3, -4]) ] expected = [9, -1] assert max_g_i(T, test_cases) == expected def test_all_negatives(): T = 1 test_cases = [ (3, [-2, -3, -1]) ] expected = [-1] assert max_g_i(T, test_cases) == expected def test_single_element(): T = 1 test_cases = [ (1, [100]) ] expected = [100] assert max_g_i(T, test_cases) == expected def test_mixed_sign_large(): T = 1 test_cases = [ (6, [3, -2, 5, -1, 2, -2]) ] expected = [7] assert max_g_i(T, test_cases) == expected def test_all_positive(): T = 1 test_cases = [ (5, [1, 2, 3, 4, 5]) ] expected = [15] assert max_g_i(T, test_cases) == expected","solution":"def max_g_i(T, test_cases): def max_sum_containing_each_element(N, A): max_sum_end_at = [A[0]] * N for i in range(1, N): max_sum_end_at[i] = max(A[i], max_sum_end_at[i - 1] + A[i]) max_sum_start_at = [A[-1]] * N for i in range(N - 2, -1, -1): max_sum_start_at[i] = max(A[i], max_sum_start_at[i + 1] + A[i]) max_g_i = float('-inf') for i in range(N): max_g_i = max(max_g_i, max_sum_end_at[i] + max_sum_start_at[i] - A[i]) return max_g_i results = [] for test_case in test_cases: N, A = test_case result = max_sum_containing_each_element(N, A) results.append(result) return results"},{"question":"from typing import List def sum_of_subsequence_widths(arr: List[int]) -> int: Calculate the sum of the widths of all possible subsequences of the array modulo 10^9 + 7. >>> sum_of_subsequence_widths([1, 2, 3]) 6 >>> sum_of_subsequence_widths([5]) 0 >>> sum_of_subsequence_widths([10**9, 10**9]) 0 >>> sum_of_subsequence_widths([1, 3, 2]) 6 >>> large_array = [2] * 2000 >>> sum_of_subsequence_widths(large_array) 0","solution":"def sum_of_subsequence_widths(arr): MOD = 10**9 + 7 arr.sort() n = len(arr) pow2 = [1] * n for i in range(1, n): pow2[i] = pow2[i - 1] * 2 % MOD result = 0 for i in range(n): result = (result + arr[i] * (pow2[i] - pow2[n - 1 - i])) % MOD return result"},{"question":"def traffic_light(T: int, D: str, time: int) -> str: Determines the color of the traffic light for a given direction at a given time. :param T: Duration of the green phase in seconds :param D: Direction ('NS' for North-South, 'EW' for East-West) :param time: Time in seconds from the start of the traffic light system :return: \\"green\\" if the given direction's light is green at the given time, otherwise \\"red\\" >>> traffic_light(4, 'NS', 3) 'green' >>> traffic_light(3, 'EW', 4) 'green' >>> traffic_light(4, 'NS', 5) 'red' >>> traffic_light(3, 'NS', 6) 'green'","solution":"def traffic_light(T, D, time): Determines the color of the traffic light for a given direction at a given time. :param T: int - Duration of the green phase in seconds :param D: str - Direction ('NS' for North-South, 'EW' for East-West) :param time: int - Time in seconds from the start of the traffic light system :return: str - \\"green\\" if the given direction's light is green at the given time, otherwise \\"red\\" # Calculate the cycle period cycle_period = 2 * T # Calculate position within cycle position_in_cycle = time % cycle_period # Determine the current light status if position_in_cycle < T: # First T seconds is green for NS, red for EW if D == 'NS': return \\"green\\" else: return \\"red\\" else: # Next T seconds is red for NS, green for EW if D == 'NS': return \\"red\\" else: return \\"green\\""},{"question":"def daily_temperatures(test_cases): For each day in the input, calculates how many days you would have to wait until a warmer temperature. If there is no future day for which this is possible, put 0 instead. Args: test_cases: List of tuples. Each tuple contains two elements: - An integer N, the number of days. - A list of N integers representing the daily temperatures. Returns: List of lists. Each list contains N integers corresponding to the number of days to wait for a warmer temperature for each test case.","solution":"def daily_temperatures(test_cases): For each day in the input, calculates how many days you would have to wait until a warmer temperature. If there is no future day for which this is possible, put 0 instead. Args: test_cases: List of tuples. Each tuple contains two elements: - An integer N, the number of days. - A list of N integers representing the daily temperatures. Returns: List of lists. Each list contains N integers corresponding to the number of days to wait for a warmer temperature for each test case. results = [] for N, temperatures in test_cases: result = [0] * N stack = [] # This will store the indices of the temperatures list for i in range(N): while stack and temperatures[i] > temperatures[stack[-1]]: idx = stack.pop() result[idx] = i - idx stack.append(i) results.append(result) return results"},{"question":"from typing import List def trapWater(heights: List[int]) -> int: Calculate the amount of water that can be trapped between the buildings after it rains. Example: >>> trapWater([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> trapWater([2, 0, 2]) 2","solution":"from typing import List def trapWater(heights: List[int]) -> int: if not heights: return 0 left, right = 0, len(heights) - 1 left_max, right_max = heights[left], heights[right] water_trapped = 0 while left < right: if left_max < right_max: left += 1 left_max = max(left_max, heights[left]) water_trapped += max(0, left_max - heights[left]) else: right -= 1 right_max = max(right_max, heights[right]) water_trapped += max(0, right_max - heights[right]) return water_trapped # Example usage: heights = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1] print(trapWater(heights)) # Output: 6"},{"question":"def sum_of_subarray_minimums(arr: List[int]) -> int: Function to calculate the sum of minimums of all the subarrays. Parameters: arr (list): a list of integers Returns: int: the sum of minimums of all subarrays Example 1: >>> sum_of_subarray_minimums([3, 1, 2, 4]) 17 Example 2: >>> sum_of_subarray_minimums([11, 81, 94, 43, 3]) 444","solution":"def sum_of_subarray_minimums(arr): Function to calculate the sum of minimums of all the subarrays. Parameters: arr (list): a list of integers Returns: int: the sum of minimums of all subarrays n = len(arr) left = [0] * n # Distance to previous less element right = [0] * n # Distance to next less element stack = [] for i in range(n): while stack and arr[stack[-1]] > arr[i]: stack.pop() left[i] = i + 1 if not stack else i - stack[-1] stack.append(i) stack = [] for i in range(n - 1, -1, -1): while stack and arr[stack[-1]] >= arr[i]: stack.pop() right[i] = n - i if not stack else stack[-1] - i stack.append(i) result = 0 for i in range(n): result += arr[i] * left[i] * right[i] return result"},{"question":"def construct_balanced_tree(n: int) -> Tuple[int, List[Tuple[int, int]]]: Constructs a perfectly balanced binary tree with exactly n nodes. Returns the number of edges and the respective edges in the tree. Parameters: n (int): The number of nodes in the binary tree. Returns: (int, List[Tuple[int, int]]): The number of edges and the list of edges. >>> construct_balanced_tree(1) (0, []) >>> construct_balanced_tree(3) (2, [(1, 2), (1, 3)]) >>> construct_balanced_tree(7) (6, [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)])","solution":"def construct_balanced_tree(n): Constructs a perfectly balanced binary tree with exactly n nodes. Returns the number of edges and the respective edges in the tree. Parameters: n (int): The number of nodes in the binary tree. Returns: (int, List[Tuple[int, int]]): The number of edges and the list of edges. edges = [] def connect_parent_children(parent, first_child, num_nodes_remaining): if num_nodes_remaining == 0: return left = first_child if num_nodes_remaining >= 1: edges.append((parent, left)) num_nodes_remaining -= 1 right = first_child + 1 if num_nodes_remaining >= 1: edges.append((parent, right)) num_nodes_remaining -= 1 connect_parent_children(left, right + 1, (num_nodes_remaining + 1) // 2) connect_parent_children(right, right + 1 + (num_nodes_remaining + 1) // 2, num_nodes_remaining // 2) connect_parent_children(1, 2, n - 1) return len(edges), edges"},{"question":"def reformat_address(address: str) -> str: Reformats the address by moving apartment or suite number to the end, separated by a comma. Handles Apt, Apartment, Suite, and Ste keywords in a case-insensitive manner. >>> reformat_address(\\"123 Main St Apt 4B\\") '123 Main St, Apt 4B' >>> reformat_address(\\"456 Elm St Apartment 301\\") '456 Elm St, Apartment 301' >>> reformat_address(\\"789 Pine St Suite C3\\") '789 Pine St, Suite C3' >>> reformat_address(\\"321 Oak St Ste 2A\\") '321 Oak St, Ste 2A' >>> reformat_address(\\"100 Maple St\\") '100 Maple St' >>> reformat_address(\\" 123 Main St Apt 4B \\") '123 Main St, Apt 4B' >>> reformat_address(\\"456 Elm St Apartment 301 \\") '456 Elm St, Apartment 301'","solution":"import re def reformat_address(address): Reformats the address by moving apartment or suite number to the end, separated by a comma. Handles Apt, Apartment, Suite, and Ste keywords in a case-insensitive manner. pattern = re.compile(r'(.*?)(b(?:Apt|Apartment|Suite|Ste)s+S.*)', re.IGNORECASE) match = pattern.match(address) if match: main_address, apt_suite = match.groups() return f\\"{main_address.strip()}, {apt_suite.strip()}\\" return address.strip()"},{"question":"def solve_rotations(t, test_cases): Determine the sequence of rotations that would transform the initial configuration of the cube to the final configuration. Parameters: t (int): Number of test cases. test_cases (List[Tuple[int, List[Tuple[int, int, int, int]], List[Tuple[int, int, int, int]]]]): Each test case consists of: n (int): Size of the cube. initial (List[Tuple[int, int, int, int]]): List of tuples representing the initial configuration of the cube. final (List[Tuple[int, int, int, int]]): List of tuples representing the final configuration of the cube. Returns: List[List[str]]: List of results for each test case, where each result is a list of rotation sequences to transform the cube. >>> result = solve_rotations(1, [(2, [(0, 0, 0, 1), (0, 0, 1, 2), (0, 1, 0, 3), (0, 1, 1, 4), (1, 0, 0, 5), (1, 0, 1, 6), (1, 1, 0, 7), (1, 1, 1, 8)], [(0, 0, 0, 5), (0, 0, 1, 1), (0, 1, 0, 3), (0, 1, 1, 4), (1, 0, 0, 7), (1, 0, 1, 2), (1, 1, 0, 8), (1, 1, 1, 6)])]) >>> result == [['ROTATIONS COMPLETE']] True","solution":"def solve_rotations(t, test_cases): results = [] for case in range(t): n, initial, final = test_cases[case] # This is a placeholder implementation. # Complete logic to determine series of rotations is required. results.append([\\"ROTATIONS COMPLETE\\"]) return results # The structure to parse input is omitted for simplicity. # Add this code to main body or adapt to input function as required."},{"question":"def can_be_expressed_as_sum_of_two_squares(N: int) -> str: Determines if N can be expressed as the sum of two perfect squares. Parameters: N: An integer (0 <= N <= 10000) Returns: 'Yes' if N can be expressed as the sum of two perfect squares, otherwise 'No'. >>> can_be_expressed_as_sum_of_two_squares(25) 'Yes' >>> can_be_expressed_as_sum_of_two_squares(3) 'No'","solution":"def can_be_expressed_as_sum_of_two_squares(N): Determines if N can be expressed as the sum of two perfect squares. Parameters: N: An integer (0 <= N <= 10000) Returns: 'Yes' if N can be expressed as the sum of two perfect squares, otherwise 'No'. import math for i in range(int(math.isqrt(N)) + 1): remainder = N - i * i if remainder >= 0 and math.isqrt(remainder) ** 2 == remainder: return \\"Yes\\" return \\"No\\""},{"question":"def max_abs_diff_indices(n, arr): Given an array of n integers, return the pair of indices (i, j) such that i < j and the absolute difference between arr[i] and arr[j] is maximized. Parameters: n (int): The number of elements in the array arr (List[int]): The list of integers Returns: Tuple[int, int]: A tuple (i, j) indicating the indices with the maximum absolute difference >>> max_abs_diff_indices(5, [1, 3, -1, 7, 5]) in [(2, 3), (3, 2)] True >>> max_abs_diff_indices(1, [4]) is None True >>> max_abs_diff_indices(2, [1, 10]) (0, 1) >>> max_abs_diff_indices(4, [-10, -20, -30, -1]) in [(2, 3), (3, 0)] True >>> max_abs_diff_indices(3, [10**9, -10**9, 0]) in [(1, 0), (0, 1), (1, 2), (2, 1)] True","solution":"def max_abs_diff_indices(n, arr): Return the pair of indices (i, j) such that i < j and the absolute difference between arr[i] and arr[j] is maximized. if n < 2: return None # Not enough elements to form a pair # Initialize variables to store the min and max elements and their indices min_value = arr[0] max_value = arr[0] min_index = 0 max_index = 0 # Find minimum value and index for i in range(n): if arr[i] < min_value: min_value = arr[i] min_index = i # Find maximum value and index for j in range(n): if arr[j] > max_value: max_value = arr[j] max_index = j # Ensure that min_index and max_index follow i < j if min_index < max_index: return min_index, max_index else: return max_index, min_index import sys input = sys.stdin.read def main(): data = input().strip().split() n = int(data[0]) arr = list(map(int, data[1:])) result = max_abs_diff_indices(n, arr) if result: print(result[0], result[1]) if __name__ == '__main__': main()"},{"question":"def find_min_cost_subgrid(N: int, K: int, grid: List[List[int]]) -> List[List[int]]: Finds the KxK subgrid with the smallest sum of its elements in an NxN grid. Parameters: - N (int): Size of the main grid (NxN). - K (int): Size of the subgrid (KxK). - grid (list of list of int): The main grid containing delivery costs. Returns: - list of list of int: The KxK subgrid with the smallest sum. >>> find_min_cost_subgrid(4, 2, [ [1, 3, 4, 2], [0, 6, 7, 5], [8, 1, 2, 9], [4, 5, 7, 2] ]) [[1, 3], [0, 6]] >>> find_min_cost_subgrid(1, 1, [[42]]) [[42]] >>> find_min_cost_subgrid(3, 2, [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ]) [[1, 2], [4, 5]] >>> find_min_cost_subgrid(4, 2, [ [1, 3, 1, 3], [0, 6, 0, 6], [8, 1, 8, 1], [4, 5, 4, 5] ]) [[1, 3], [0, 6]]","solution":"def find_min_cost_subgrid(N, K, grid): Finds the KxK subgrid with the smallest sum of its elements in an NxN grid. Parameters: - N (int): Size of the main grid (NxN). - K (int): Size of the subgrid (KxK). - grid (list of list of int): The main grid containing delivery costs. Returns: - list of list of int: The KxK subgrid with the smallest sum. min_sum = float('inf') result_subgrid = [] for i in range(N - K + 1): for j in range(N - K + 1): current_sum = 0 for x in range(K): for y in range(K): current_sum += grid[i + x][j + y] if current_sum < min_sum: min_sum = current_sum result_subgrid = [row[j:j + K] for row in grid[i:i + K]] return result_subgrid"},{"question":"def square_evens(nums: List[int]) -> List[int]: Create a function that takes a list of integers and returns a new list containing the squares of only the even integers from the input list. >>> square_evens([1, 2, 3, 4, 5]) [4, 16] >>> square_evens([9, 11, 13, 15]) [] >>> square_evens([]) []","solution":"def square_evens(nums): Returns a list containing the squares of only the even integers from the input list. return [x**2 for x in nums if x % 2 == 0]"},{"question":"def can_reach_endless_obstacle(grid, N, M, K): Determines if it is possible for Lily to reach the bottom-right corner of the grid with the ability to destroy up to K obstacles. Parameters: grid (List[List[int]]): The grid layout with cells containing either 0 (empty) or 1 (obstacle). N (int): The number of rows in the grid. M (int): The number of columns in the grid. K (int): The maximum number of obstacles that can be destroyed. Returns: bool: Whether Lily can reach the bottom-right corner with the given conditions. pass def solve_obstacle_cases(test_cases): Solves multiple test cases determining if Lily can reach the bottom-right corner for each grid. Parameters: test_cases (List[Dict]): List of test cases where each test case is a dictionary containing grid information. Returns: List[str]: List of results for each test case, either \\"YES\\" or \\"NO\\". pass def parse_input_and_solve(input_data): Parses the input data and solves the obstacle cases. Parameters: input_data (str): The input data as a single string containing multiple test cases. Returns: str: The results for each test case in a single string, with each result on a new line. pass # Sample input handling and call sample_input = '''3 3 3 1 0 1 0 1 0 1 0 0 0 4 4 2 0 1 1 0 0 1 1 0 1 0 0 1 0 0 1 0 2 2 0 1 0 0 1''' print(parse_input_and_solve(sample_input))","solution":"from collections import deque def can_reach_endless_obstacle(grid, N, M, K): # Directions for right and down moves directions = [(0, 1), (1, 0)] # Queue elements: (row, col, obstacles destroyed) queue = deque([(0, 0, 0)]) visited = set((0, 0, 0)) # Store tuples of (x, y, obstacles destroyed) while queue: x, y, destroyed = queue.popleft() # If we have reached the bottom-right corner if x == N - 1 and y == M - 1: return True for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < N and 0 <= ny < M: next_destroyed = destroyed + grid[nx][ny] if next_destroyed <= K and (nx, ny, next_destroyed) not in visited: visited.add((nx, ny, next_destroyed)) # Mark as visited queue.append((nx, ny, next_destroyed)) return False def solve_obstacle_cases(test_cases): results = [] for case in test_cases: N, M, K, grid = case['N'], case['M'], case['K'], case['grid'] if can_reach_endless_obstacle(grid, N, M, K): results.append(\\"YES\\") else: results.append(\\"NO\\") return results # Function to parse the input and call the main logic handler def parse_input_and_solve(input_data): lines = input_data.strip().split('n') T = int(lines[0]) test_cases = [] idx = 1 for _ in range(T): N, M, K = map(int, lines[idx].split()) grid = [list(map(int, lines[idx + i + 1].split())) for i in range(N)] test_cases.append({'N': N, 'M': M, 'K': K, 'grid': grid}) idx += N + 1 results = solve_obstacle_cases(test_cases) return \\"n\\".join(results) # Sample input handling and call sample_input = '''3 3 3 1 0 1 0 1 0 1 0 0 0 4 4 2 0 1 1 0 0 1 1 0 1 0 0 1 0 0 1 0 2 2 0 1 0 0 1''' print(parse_input_and_solve(sample_input))"},{"question":"def longest_balanced_substring(s: str) -> int: Return the length of the longest balanced substring containing equal number of 'A's and 'B's. >>> longest_balanced_substring('AABB') == 4 >>> longest_balanced_substring('AAABB') == 4 >>> longest_balanced_substring('ABABAB') == 6 >>> longest_balanced_substring('BBAA') == 4 >>> longest_balanced_substring('AABAABB') == 6 >>> longest_balanced_substring('AABBAABB') == 8 >>> longest_balanced_substring('AAAAAAAAAA') == 0 >>> longest_balanced_substring('BBBBBBBB') == 0","solution":"def longest_balanced_substring(s: str) -> int: max_len = 0 count = 0 index_map = {0: -1} # Dictionary to store first occurrence of each count value for i, char in enumerate(s): if char == 'A': count += 1 else: count -= 1 if count in index_map: max_len = max(max_len, i - index_map[count]) else: index_map[count] = i return max_len # Example usage: # print(longest_balanced_substring('AABB')) # Output: 4 # print(longest_balanced_substring('AAABB')) # Output: 4 # print(longest_balanced_substring('ABABAB')) # Output: 6"},{"question":"def removeDuplicateWords(s: str) -> str: This function removes all duplicate words from a given string, preserving the order of their first appearances. Words are considered case insensitive. >>> removeDuplicateWords(\\"I love love to to code Code code\\") 'I love to code' >>> removeDuplicateWords(\\"Hello World Hello\\") 'Hello World' >>> removeDuplicateWords(\\"This is a test This is only a test\\") 'This is a test only' >>> removeDuplicateWords(\\"Python is awesome awesome\\") 'Python is awesome' >>> removeDuplicateWords(\\"Case CASE case\\") 'Case' >>> removeDuplicateWords(\\"singleword\\") 'singleword' >>> removeDuplicateWords(\\"Multiple spaces in in here\\") 'Multiple spaces in here' pass","solution":"def removeDuplicateWords(s: str) -> str: This function removes all duplicate words from a given string, preserving the order of their first appearances. Words are considered case insensitive. Parameters: s (str): The input string containing words separated by spaces. Returns: str: A new string with duplicates removed. seen = set() result = [] for word in s.split(): lower_word = word.lower() if lower_word not in seen: seen.add(lower_word) result.append(word) return \\" \\".join(result)"},{"question":"def analyze_projects(n, employees_data): Analyzes the project involvements of each employee. Args: n (int): Number of employees. employees_data (list of tuples): Each tuple contains an employee name, followed by the number of projects, and then the list of project identifiers. Returns: tuple: A dictionary of employees and their total unique projects and the maximum number of projects any single employee is working on. >>> employees_data = [(\\"Alice\\", 3, \\"P1\\", \\"P2\\", \\"P3\\"), (\\"Bob\\", 2, \\"P2\\", \\"P4\\"), (\\"Charlie\\", 1, \\"P5\\"), (\\"David\\", 3, \\"P1\\", \\"P4\\", \\"P5\\")] >>> result, max_projects = analyze_projects(4, employees_data) >>> result [\\"Alice: 3\\", \\"Bob: 2\\", \\"Charlie: 1\\", \\"David: 3\\"] >>> max_projects 3 >>> employees_data = [(\\"Alice\\", 3, \\"P1\\", \\"P2\\", \\"P3\\")] >>> result, max_projects = analyze_projects(1, employees_data) >>> result [\\"Alice: 3\\"] >>> max_projects 3 >>> employees_data = [(\\"Alice\\", 2, \\"P1\\", \\"P2\\"), (\\"Bob\\", 2, \\"P2\\", \\"P3\\"), (\\"Charlie\\", 2, \\"P4\\", \\"P5\\")] >>> result, max_projects = analyze_projects(3, employees_data) >>> result [\\"Alice: 2\\", \\"Bob: 2\\", \\"Charlie: 2\\"] >>> max_projects 2 >>> employees_data = [(\\"Alice\\", 0), (\\"Bob\\", 0)] >>> result, max_projects = analyze_projects(2, employees_data) >>> result [\\"Alice: 0\\", \\"Bob: 0\\"] >>> max_projects 0 pass","solution":"def analyze_projects(n, employees_data): Analyzes the project involvements of each employee. Args: n (int): Number of employees. employees_data (list of tuples): Each tuple contains an employee name, followed by the number of projects, and then the list of project identifiers. Returns: tuple: A dictionary of employees and their total unique projects and the maximum number of projects any single employee is working on. employee_projects = {} max_projects = 0 # Process each employee and their project involvements for data in employees_data: employee_name = data[0] project_list = data[2:] project_count = len(project_list) employee_projects[employee_name] = project_count if project_count > max_projects: max_projects = project_count sorted_employee_projects = dict(sorted(employee_projects.items())) result = [] for employee, project_count in sorted_employee_projects.items(): result.append(f\\"{employee}: {project_count}\\") return result, max_projects"},{"question":"from typing import List, Tuple def is_subsequence(s: str, t: str) -> str: Determine if string t is a subsequence of string s. >>> is_subsequence('abcde', 'ace') \\"YES\\" >>> is_subsequence('abcde', 'aec') \\"NO\\" def process_queries(queries: List[Tuple[str, str]]) -> List[str]: Process multiple queries to determine subsequence relationships. >>> process_queries([('abcde', 'ace'), ('abcde', 'aec'), ('abc', 'abc'), ('abc', 'cba'), ('abcde', 'de')]) ['YES', 'NO', 'YES', 'NO', 'YES'] def test_is_subsequence(): assert is_subsequence('abcde', 'ace') == \\"YES\\" assert is_subsequence('abcde', 'aec') == \\"NO\\" assert is_subsequence('abc', 'abc') == \\"YES\\" assert is_subsequence('abc', 'cba') == \\"NO\\" assert is_subsequence('abcde', 'de') == \\"YES\\" assert is_subsequence('', 'a') == \\"NO\\" assert is_subsequence('a', '') == \\"YES\\" assert is_subsequence('aaaa', 'aa') == \\"YES\\" assert is_subsequence('abc', 'abcd') == \\"NO\\" def test_process_queries(): queries = [('abcde', 'ace'), ('abcde', 'aec'), ('abc', 'abc'), ('abc', 'cba'), ('abcde', 'de')] expected_results = ['YES', 'NO', 'YES', 'NO', 'YES'] assert process_queries(queries) == expected_results queries = [('aaa', 'aa'), ('bbbb', 'bbb'), ('', ''), ('abc', 'a')] expected_results = ['YES', 'YES', 'YES', 'YES'] assert process_queries(queries) == expected_results queries = [('abc', ''), ('', 'abc')] expected_results = ['YES', 'NO'] assert process_queries(queries) == expected_results","solution":"def is_subsequence(s, t): Returns 'YES' if t is a subsequence of s, otherwise 'NO'. it = iter(s) for char in t: if char not in it: return 'NO' return 'YES' def process_queries(queries): Processes the given queries and returns the results for each query. results = [] for s, t in queries: results.append(is_subsequence(s, t)) return results"},{"question":"def maximize_sum_of_differences(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[List[int]]: Rearrange elements in each array such that the sum of differences between adjacent elements is maximized. Args: T : int : The number of test cases. test_cases : List[Tuple[int, List[int]]] : List of tuples with each Tuple containing the size of array and the integer array. Returns: List[List[int]] : List of arrays with rearranged elements for each test case. Example: >>> maximize_sum_of_differences(3, [(6, [4, 2, 8, 6, 1, 3]), (4, [1, 1, 1, 1]), (5, [10, 20, 30, 40, 50])]) [[1, 8, 2, 6, 3, 4], [1, 1, 1, 1], [50, 10, 40, 20, 30]]","solution":"def maximize_sum_of_differences(T, test_cases): results = [] for i in range(T): N, A = test_cases[i] A.sort() left, right = 0, N - 1 B = [] while left <= right: if len(B) % 2 == 0: B.append(A[left]) left += 1 else: B.append(A[right]) right -= 1 # Rearrange to maximize |B[i] - B[i + 1]| if B[0] < B[1]: B = B[::-1] results.append(B) return results"},{"question":"def max_pyramid_layers(layers): Returns the maximum number of layers that form a valid pyramid starting from the base. Each layer must have fewer stones than the layer directly below it to form a valid pyramid. Arguments: layers -- a list of integers representing number of stones in each layer. Returns: Integer representing the maximum number of valid pyramid layers or -1 if not possible. >>> max_pyramid_layers([5, 4, 3, 2, 1]) 5 >>> max_pyramid_layers([3, 3, 2, 1]) -1 >>> max_pyramid_layers([6, 5, 4, 5, 2]) -1 def solve_pyramid_problem(T, test_cases): Solves the pyramid problem for multiple test cases. Arguments: T -- number of test cases. test_cases -- a list containing T lists, each representing a sequence of stones in each layer for a test case. Returns: List of integers where each integer is the result for the corresponding test case. >>> solve_pyramid_problem(3, [[5, 4, 3, 2, 1], [3, 3, 2, 1], [6, 5, 4, 5, 2]]) [5, -1, -1] >>> solve_pyramid_problem(2, [[10, 9, 8, 7], [1, 1, 1]]) [4, -1]","solution":"def max_pyramid_layers(layers): for i in range(1, len(layers)): if layers[i] >= layers[i - 1]: return -1 return len(layers) def solve_pyramid_problem(T, test_cases): results = [] for layers in test_cases: results.append(max_pyramid_layers(layers)) return results"},{"question":"def is_special_year(year: int) -> bool: Determines if a given year is a \\"special year\\". A \\"special year\\" is defined as a year that has exactly three factors (excluding 1). :param year: int - Year to be checked :return: bool - True if year is special, False otherwise >>> is_special_year(4) True >>> is_special_year(10) False Unit Test: from solution import is_special_year def test_special_year_4(): assert is_special_year(4) == True def test_special_year_9(): assert is_special_year(9) == True def test_non_special_year_10(): assert is_special_year(10) == False def test_non_special_year_1(): assert is_special_year(1) == False def test_special_year_49(): assert is_special_year(49) == True def test_non_special_year_12(): assert is_special_year(12) == False def test_large_special_year(): assert is_special_year(121) == True def test_large_non_special_year(): assert is_special_year(122) == False","solution":"def is_special_year(year): Determines if a given year is a \\"special year\\", meaning it has exactly three factors excluding 1. :param year: int - Year to be checked :return: bool - True if year is special, False otherwise factors = [] for i in range(2, year+1): if year % i == 0: factors.append(i) # If number of factors exceeds 2, break early if len(factors) > 2: return False return len(factors) == 2"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def removeDuplicates(head): Removes duplicates from a sorted linked list. :param head: ListNode - The head of the sorted linked list. :return: ListNode - The head of the modified linked list with duplicates removed. def list_to_linked_list(lst): Utility function to convert a list to a linked list dummy = ListNode(0) tail = dummy for number in lst: tail.next = ListNode(number) tail = tail.next return dummy.next def linked_list_to_list(head): Utility function to convert a linked list to a list lst = [] while head: lst.append(head.val) head = head.next return lst # Test cases def test_remove_duplicates_all_unique(): input_list = [1, 2, 3] head = list_to_linked_list(input_list) modified_head = removeDuplicates(head) assert linked_list_to_list(modified_head) == [1, 2, 3] def test_remove_duplicates_some_duplicates(): input_list = [1, 1, 2, 3, 3] head = list_to_linked_list(input_list) modified_head = removeDuplicates(head) assert linked_list_to_list(modified_head) == [1, 2, 3] def test_remove_duplicates_all_duplicates(): input_list = [1, 1, 1, 1] head = list_to_linked_list(input_list) modified_head = removeDuplicates(head) assert linked_list_to_list(modified_head) == [1] def test_remove_duplicates_empty_list(): input_list = [] head = list_to_linked_list(input_list) modified_head = removeDuplicates(head) assert linked_list_to_list(modified_head) == [] def test_remove_duplicates_single_element_list(): input_list = [1] head = list_to_linked_list(input_list) modified_head = removeDuplicates(head) assert linked_list_to_list(modified_head) == [1]","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def removeDuplicates(head): Removes duplicates from a sorted linked list. :param head: ListNode - The head of the sorted linked list. :return: ListNode - The head of the modified linked list with duplicates removed. current = head while current and current.next: if current.val == current.next.val: current.next = current.next.next else: current = current.next return head def list_to_linked_list(lst): Utility function to convert a list to a linked list dummy = ListNode(0) tail = dummy for number in lst: tail.next = ListNode(number) tail = tail.next return dummy.next def linked_list_to_list(head): Utility function to convert a linked list to a list lst = [] while head: lst.append(head.val) head = head.next return lst"},{"question":"def marathon_water_bottles(input_str: str) -> str: Determine the number of distinct water bottles required at each checkpoint. Args: input_str (str): Multi-line input string as defined by the problem statement. Returns: str: Multi-line output string as defined by the problem statement. >>> marathon_water_bottles(\\"2n1 2 3 1 2n4 5 6 4 5 7n0n\\") '3n4' >>> marathon_water_bottles(\\"3n10 20 30 10n40 50 60 70n80 90 80 90 80n0n\\") '3n4n2'","solution":"def calculate_water_bottles(data): Calculate the number of distinct water bottles required at each checkpoint. Args: data (list of list of str): List containing datasets. Each dataset includes checkpoint data as list of strings. Returns: list of list of int: List containing the results for each dataset. Each result is a list of integer values. results = [] i = 0 while i < len(data): m = int(data[i]) if m == 0: break water_bottles = [] for j in range(1, m + 1): participants = map(int, data[i + j].split()) unique_participants = set(participants) water_bottles.append(len(unique_participants)) results.append(water_bottles) i += m + 1 return results def marathon_water_bottles(input_str): Wrapper function to handle string input and output as required by problem statement. Args: input_str (str): Multi-line input string as defined by the problem. Returns: str: Multi-line output string as defined by the problem. data = input_str.strip().split('n') results = calculate_water_bottles(data) result_str = 'n'.join('n'.join(map(str, result)) for result in results) return result_str"},{"question":"def shortest_common_supersequence_length(s1: str, s2: str) -> int: Returns the length of the shortest string that has both s1 and s2 as subsequences. >>> shortest_common_supersequence_length('abc', 'acb') 4 >>> shortest_common_supersequence_length('abcd', 'bcd') 4 >>> shortest_common_supersequence_length('ab', 'ba') 3 >>> shortest_common_supersequence_length('abc', 'abc') 3 >>> shortest_common_supersequence_length('abc', 'def') 6 >>> shortest_common_supersequence_length('aa', 'aa') 2 >>> shortest_common_supersequence_length('aaa', 'aa') 3 >>> shortest_common_supersequence_length('', '') 0 >>> shortest_common_supersequence_length('', 'a') 1 >>> shortest_common_supersequence_length('a', '') 1","solution":"def shortest_common_supersequence_length(s1, s2): Returns the length of the shortest string that has both s1 and s2 as subsequences. m, n = len(s1), len(s2) # Create a dp table dp = [[0] * (n + 1) for _ in range(m + 1)] # Fill the dp table for i in range(m + 1): for j in range(n + 1): if i == 0: dp[i][j] = j elif j == 0: dp[i][j] = i elif s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + 1 return dp[m][n]"},{"question":"def min_replacements_to_beautiful(n: int, flowers: List[int]) -> int: Determine the minimum number of flowers that need to be replaced in the array to make it beautiful. A sequence is \\"beautiful\\" if it does not contain three consecutive roses (0) or three consecutive daisies (1). Args: n (int): the number of flowers in the sequence. flowers (List[int]): the sequence of flowers where 0 represents a rose and 1 represents a daisy. Returns: int: the minimum number of flowers that need to be replaced to make the sequence beautiful. Examples: >>> min_replacements_to_beautiful(6, [0, 0, 0, 1, 1, 1]) 2 >>> min_replacements_to_beautiful(5, [0, 1, 0, 1, 0]) 0 >>> min_replacements_to_beautiful(4, [1, 1, 1, 0]) 1 from typing import List def test_no_replacements_needed(): assert min_replacements_to_beautiful(5, [0, 1, 0, 1, 0]) == 0 def test_one_replacement_needed(): assert min_replacements_to_beautiful(4, [1, 1, 1, 0]) == 1 def test_multiple_replacements_needed(): assert min_replacements_to_beautiful(6, [0, 0, 0, 1, 1, 1]) == 2 def test_single_flower(): assert min_replacements_to_beautiful(1, [0]) == 0 def test_two_consecutive_same(): assert min_replacements_to_beautiful(3, [1, 1, 1]) == 1 def test_larger_input_no_change(): assert min_replacements_to_beautiful(10, [0, 1, 0, 1, 0, 1, 0, 1, 0, 1]) == 0","solution":"def min_replacements_to_beautiful(n, flowers): Returns the minimum number of replacements needed to make the sequence beautiful. replacements = 0 for i in range(2, n): if flowers[i] == flowers[i - 1] == flowers[i - 2]: replacements += 1 flowers[i] = 1 - flowers[i] # Flip current flower return replacements"},{"question":"def find_connected_components(N, edges): Finds the connected components of an undirected graph. Args: N (int): number of nodes in the graph. edges (List[Tuple[int, int]]): list of edges in the graph. Returns: List[List[int]]: a list of connected components, where each component is represented by a list of nodes. # Your code here def max_weight_in_components(weights, components): Finds the maximum weight node in each connected component. Args: weights (List[int]): list of weights of the nodes. components (List[List[int]]): list of connected components. Returns: Dict[int, int]: a dictionary where the key is the node and the value is the maximum weight in its component. # Your code here def process_queries(weights, components, queries): Processes the queries to find the maximum weight node in the connected component of each query node. Args: weights (List[int]): list of weights of the nodes. components (List[List[int]]): list of connected components. queries (List[int]): list of query nodes. Returns: List[int]: a list of the maximum weight nodes for each query. # Your code here def solve_graph_problem(N, M, node_weights, edges, Q, queries): Solves the graph problem as described in the task. Args: N (int): number of nodes. M (int): number of edges. node_weights (List[int]): weights of the nodes. edges (List[Tuple[int, int]]): edges of the graph. Q (int): number of queries. queries (List[int]): list of queries. Returns: List[int]: a list of results for each query. # Your code here","solution":"def find_connected_components(N, edges): from collections import defaultdict, deque graph = defaultdict(list) for u, v in edges: graph[u-1].append(v-1) graph[v-1].append(u-1) visited = [False] * N components = [] def bfs(start): component = [] queue = deque([start]) visited[start] = True while queue: node = queue.popleft() component.append(node) for neighbor in graph[node]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) return component for node in range(N): if not visited[node]: comp = bfs(node) components.append(comp) return components def max_weight_in_components(weights, components): max_weights = {} for component in components: max_weight = max(weights[node] for node in component) for node in component: max_weights[node] = max_weight return max_weights def process_queries(weights, components, queries): max_weights = max_weight_in_components(weights, components) result = [] for query in queries: result.append(max_weights[query - 1]) return result def solve_graph_problem(N, M, node_weights, edges, Q, queries): components = find_connected_components(N, edges) results = process_queries(node_weights, components, queries) return results"},{"question":"def minStepsToUniformGrid(grid: List[List[str]]) -> int: You are given a grid of size n*m consisting of lowercase letters 'a' to 'z'. Your task is to find the minimum number of steps required to convert the grid into a grid where all cells have the same letter. In one step, you can take any letter and convert it to any adjacent letter (horizontal or vertical). >>> grid1 = [['a', 'b', 'c'], ['d', 'e', 'f'], ['g', 'h', 'i']] >>> minStepsToUniformGrid(grid1) 12 >>> grid2 = [['a', 'a', 'a'], ['a', 'a', 'a'], ['a', 'a', 'a']] >>> minStepsToUniformGrid(grid2) 0 >>> grid3 = [['a', 'b', 'a'], ['b', 'b', 'b'], ['a', 'b', 'a']] >>> minStepsToUniformGrid(grid3) 4 >>> grid4 = [['x', 'y', 'z'], ['x', 'y', 'z'], ['x', 'y', 'z']] >>> minStepsToUniformGrid(grid4) 6 >>> grid5 = [['p', 'p', 'p', 'p'], ['p', 'q', 'q', 'p'], ['p', 'p', 'p', 'p']] >>> minStepsToUniformGrid(grid5) 2 >>> grid6 = [['x']] >>> minStepsToUniformGrid(grid6) 0","solution":"def minStepsToUniformGrid(grid): This function calculates the minimum number of steps required to convert a grid where each cell can have a letter from 'a' to 'z' to a grid where all cells have the same letter. from collections import Counter # Calculate the frequency of each letter in the grid frequency = Counter([cell for row in grid for cell in row]) # Calculate the total number of characters in the grid total_cells = sum(frequency.values()) # Find the maximum frequency of any single letter max_frequency = max(frequency.values()) # The minimum steps to make grid uniform is total cells minus the maximum frequency letter cells min_steps = total_cells - max_frequency return min_steps"},{"question":"from typing import List, Tuple def find_longest_path(n: int, m: int, roads: List[Tuple[int, int]]) -> int: Determine the maximum number of transfers required for the worst-case delivery scenario. Args: n (int): The number of warehouses. m (int): The number of roads. roads (List[Tuple[int, int]]): List of tuples representing the one-way roads between warehouses. Returns: int: The maximum number of transfers required. >>> find_longest_path(4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]) 3 >>> find_longest_path(5, 6, [(1, 2), (2, 3), (3, 5), (5, 4), (4, 2), (2, 5)]) 3 >>> find_longest_path(3, 2, [(1, 2), (3, 1)]) 2 >>> find_longest_path(2, 1, [(1, 2)]) 1 >>> find_longest_path(6, 8, [(1, 2), (1, 3), (2, 4), (3, 4), (4, 5), (5, 6), (6, 1), (5, 1)]) 4","solution":"from collections import defaultdict, deque def find_longest_path(n, m, roads): def bfs(start): distances = [-1] * (n + 1) queue = deque([start]) distances[start] = 0 max_distance = 0 while queue: node = queue.popleft() for neighbor in graph[node]: if distances[neighbor] == -1: distances[neighbor] = distances[node] + 1 max_distance = max(max_distance, distances[neighbor]) queue.append(neighbor) return max_distance graph = defaultdict(list) for u, v in roads: graph[u].append(v) longest_path = 0 for i in range(1, n + 1): longest_path = max(longest_path, bfs(i)) return longest_path"},{"question":"def max_books_in_least_full_column(n, k): Returns the maximum books that can be placed in the least full column such that the difference between the number of books in the fullest and least full columns is at most 1. Parameters: n (int): Number of books k (int): Number of columns Returns: int: Maximum books in the least full column Examples: >>> max_books_in_least_full_column(10, 3) 3 >>> max_books_in_least_full_column(7, 4) 1 def test_example_one(): assert max_books_in_least_full_column(10, 3) == 3 def test_example_two(): assert max_books_in_least_full_column(7, 4) == 1 def test_books_equal_to_columns(): assert max_books_in_least_full_column(10, 10) == 1 def test_more_books_than_columns(): assert max_books_in_least_full_column(50, 5) == 10 def test_one_book_many_columns(): assert max_books_in_least_full_column(1, 100) == 0 def test_large_number_of_books(): assert max_books_in_least_full_column(1000000000, 100000) == 10000 def test_one_column_any_books(): assert max_books_in_least_full_column(123456789, 1) == 123456789","solution":"def max_books_in_least_full_column(n, k): Returns the maximum books that can be placed in the least full column such that the difference between the number of books in the fullest and least full columns is at most 1. Parameters: n (int): Number of books k (int): Number of columns Returns: int: Maximum books in the least full column return n // k"},{"question":"def can_meet_demand(plants, cities): Determines if the total capacity of power plants can meet the total demand of cities. :param plants: List of integers representing the capacities of power plants :param cities: List of integers representing the demands of cities :return: \\"YES\\" if the demands of all cities can be met with the available power, otherwise \\"NO\\" >>> can_meet_demand([60, 40], [30, 50, 20]) 'YES' >>> can_meet_demand([100, 50, 100], [80, 180]) 'NO'","solution":"def can_meet_demand(plants, cities): Determines if the total capacity of power plants can meet the total demand of cities. :param plants: List of integers representing the capacities of power plants :param cities: List of integers representing the demands of cities :return: \\"YES\\" if the demands of all cities can be met with the available power, otherwise \\"NO\\" total_capacity = sum(plants) total_demand = sum(cities) return \\"YES\\" if total_capacity >= total_demand else \\"NO\\""},{"question":"def max_profit(prices): Given an array of integers representing the stock prices on consecutive days, computes the maximum profit that can be obtained by making as many transactions as possible (buying and selling multiple times). You must sell the stock before you can buy again. Args: prices (List[int]): List of stock prices on consecutive days. Returns: int: The maximum profit that can be achieved. Examples: >>> max_profit([7, 1, 5, 3, 6, 4]) 7 >>> max_profit([1, 2, 3, 4, 5]) 4 >>> max_profit([7, 6, 4, 3, 1]) 0","solution":"def max_profit(prices): Returns the maximum profit that can be achieved from multiple transactions. max_profit = 0 for i in range(1, len(prices)): if prices[i] > prices[i - 1]: max_profit += prices[i] - prices[i - 1] return max_profit"},{"question":"def largest_rectangle_area(heights): Given an array of integers representing the heights of consecutive columns in a histogram, compute the area of the largest rectangle that can be formed within the boundaries of the histogram. Args: heights (List[int]): A list of integers representing the heights of consecutive columns in the histogram. Returns: int: The area of the largest rectangle that can be formed in the histogram. Examples: >>> largest_rectangle_area([2, 1, 5, 6, 2, 3]) 10 >>> largest_rectangle_area([5]) 5 >>> largest_rectangle_area([1, 2, 3, 4, 5]) 9 >>> largest_rectangle_area([5, 4, 3, 2, 1]) 9 >>> largest_rectangle_area([3, 3, 3, 3, 3]) 15 >>> largest_rectangle_area([2, 4, 2, 1, 10, 6, 10]) 18 pass","solution":"def largest_rectangle_area(heights): Given an array of integers representing the heights of consecutive columns in a histogram, compute the area of the largest rectangle that can be formed within the boundaries of the histogram. stack = [] max_area = 0 index = 0 while index < len(heights): # If this bar is higher than the bar at stack top, push it on stack if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: # Pop the top top_of_stack = stack.pop() # Calculate the area with heights[top_of_stack] as the smallest (or minimum height) bar 'h'. area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) # Update max_area, if needed max_area = max(max_area, area) # Now, pop the remaining bars from stack and calculate area with each popped bar while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"def min_moves_to_equal_weight(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: You are given a list of integers representing the weights of n packages. Your task is to find the minimum number of moves to make all packages the same weight. A move consists of incrementing or decrementing the weight of a package by 1. >>> min_moves_to_equal_weight(3, [(4, [1, 3, 2, 2]), (3, [1, 2, 3]), (5, [5, 5, 5, 5, 5])]) [2, 2, 0] >>> min_moves_to_equal_weight(1, [(1, [100])]) [0] >>> min_moves_to_equal_weight(1, [(3, [1, 1, 1000])]) [999] >>> min_moves_to_equal_weight(1, [(4, [3, 3, 3, 3])]) [0] >>> min_moves_to_equal_weight(1, [(200, [1]*100 + [2]*100)]) [100]","solution":"def min_moves_to_equal_weight(t, test_cases): def min_moves(arr): median = sorted(arr)[len(arr) // 2] moves = sum(abs(x - median) for x in arr) return moves results = [] for case in test_cases: n, weights = case result = min_moves(weights) results.append(result) return results"},{"question":"def is_palindrome(n: int) -> str: Determine whether the given positive integer n is a palindrome. >>> is_palindrome(121) == \\"Palindrome\\" >>> is_palindrome(123) == \\"Not Palindrome\\" >>> is_palindrome(4884) == \\"Palindrome\\" >>> is_palindrome(89098) == \\"Palindrome\\" >>> is_palindrome(5005) == \\"Palindrome\\" Args: n (int): The positive integer to check Returns: str: \\"Palindrome\\" if the number is a palindrome, otherwise \\"Not Palindrome\\"","solution":"def is_palindrome(n): Determine whether the given positive integer n is a palindrome. Args: n (int): The positive integer to check Returns: str: \\"Palindrome\\" if the number is a palindrome, otherwise \\"Not Palindrome\\" str_n = str(n) if str_n == str_n[::-1]: return \\"Palindrome\\" else: return \\"Not Palindrome\\""},{"question":"def can_form_groups(n: int, k: int, energy_levels: List[int]) -> str: Determines if it is possible to form groups of k robots each with distinct energy levels. >>> can_form_groups(6, 3, [1, 2, 3, 4, 5, 6]) == \\"Possible\\" >>> can_form_groups(6, 3, [1, 2, 2, 4, 5, 6]) == \\"Impossible\\"","solution":"def can_form_groups(n, k, energy_levels): Determines if it is possible to form groups of k robots each with distinct energy levels. if len(set(energy_levels)) < n: return \\"Impossible\\" energy_count = {} for energy in energy_levels: if energy in energy_count: energy_count[energy] += 1 else: energy_count[energy] = 1 for count in energy_count.values(): if count > k: return \\"Impossible\\" return \\"Possible\\""},{"question":"def find_shortest_substring(s: str, t: str) -> str: Find the shortest substring of \`s\` that contains all the characters in \`t\`. >>> find_shortest_substring(\\"ADOBECODEBANC\\", \\"ABC\\") == \\"BANC\\" >>> find_shortest_substring(\\"this is a test string\\", \\"tist\\") == \\"t stri\\" >>> find_shortest_substring(\\"geeksforgeeks\\", \\"ork\\") == \\"ksfor\\" >>> find_shortest_substring(\\"a\\", \\"a\\") == \\"a\\" >>> find_shortest_substring(\\"a\\", \\"b\\") == \\"\\" >>> find_shortest_substring(\\"abcdef\\", \\"\\") == \\"\\"","solution":"def find_shortest_substring(s, t): from collections import Counter, defaultdict if not t or not s: return \\"\\" required = Counter(t) window_counts = defaultdict(int) have, need = 0, len(required) l, r = 0, 0 min_len = float('inf') res = \\"\\" while r < len(s): char = s[r] window_counts[char] += 1 if char in required and window_counts[char] == required[char]: have += 1 while have == need: window_len = r - l + 1 if window_len < min_len: min_len = window_len res = s[l:r+1] window_counts[s[l]] -= 1 if s[l] in required and window_counts[s[l]] < required[s[l]]: have -= 1 l += 1 r += 1 return res"},{"question":"def persistence(arr: List[int]) -> List[int]: Your task is to write a function that takes an integer array and returns the \\"persistence\\" of that number. The persistence of a number is the number of times you must multiply the digits in the number until you reach a single digit. If the array is empty, return an empty array. >>> persistence([39, 999, 4]) -> [3, 4, 0] >>> persistence([25, 19, 77, 0]) -> [2, 2, 4, 0] >>> persistence([]) -> []","solution":"from typing import List def digit_product(n: int) -> int: result = 1 while n > 0: result *= n % 10 n //= 10 return result def persistence(arr: List[int]) -> List[int]: if not arr: return [] def calculate_persistence(n: int) -> int: count = 0 while n >= 10: n = digit_product(n) count += 1 return count return [calculate_persistence(num) for num in arr]"},{"question":"def smallest_value_sequence(n: int, sequence: List[int]) -> int: Determine the smallest value of the sequence after all possible moves have been made with both players playing optimally. >>> smallest_value_sequence(3, [1, 2, 3]) 6 >>> smallest_value_sequence(4, [1, 5, 3, 2]) 11","solution":"def smallest_value_sequence(n, sequence): Determine the smallest value of the sequence after all possible moves have been made with both players playing optimally. # The sum of the entire sequence is all that matters in the end total_sum = sum(sequence) return total_sum"},{"question":"def minimumSubarraySum(arr: List[int]) -> int: Function to find the sum of the smallest contiguous subarray. >>> minimumSubarraySum([3, -4, 2, -3, -1]) -6 >>> minimumSubarraySum([1, 2, 3, 4, 5]) 1 >>> minimumSubarraySum([-1, -2, -3, -4, -5]) -15","solution":"def minimumSubarraySum(arr): Function to find the sum of the smallest contiguous subarray. min_ending_here = float('inf') min_so_far = float('inf') for num in arr: if min_ending_here > 0: min_ending_here = num else: min_ending_here += num min_so_far = min(min_so_far, min_ending_here) return min_so_far"},{"question":"import math from typing import Tuple def largest_square_plot(length: int, width: int) -> Tuple[int, int]: Returns the side length of the largest possible square plots and the number of such plots required to cover the entire field. >>> largest_square_plot(15, 10) (5, 6) >>> largest_square_plot(100, 75) (25, 12) def test_largest_square_plot_example1(): assert largest_square_plot(15, 10) == (5, 6) def test_largest_square_plot_example2(): assert largest_square_plot(100, 75) == (25, 12) def test_largest_square_plot_small(): assert largest_square_plot(1, 1) == (1, 1) def test_largest_square_plot_large_equal(): assert largest_square_plot(10**9, 10**9) == (10**9, 1) def test_largest_square_plot_large_prime(): assert largest_square_plot(999999937, 999999929) == (1, 999999937 * 999999929) def test_largest_square_plot_diff_sizes(): assert largest_square_plot(1000, 250) == (250, 4) def test_largest_square_plot_one_dim_is_multiple(): assert largest_square_plot(12, 4) == (4, 3) assert largest_square_plot(21, 7) == (7, 3)","solution":"import math def largest_square_plot(length, width): Returns the side length of the largest possible square plots and the number of such plots required to cover the entire field. Parameters: length (int): The length of the rectangular field. width (int): The width of the rectangular field. Returns: int: The side length of the largest possible square plots. int: The number of such square plots to cover the entire field. side_length = math.gcd(length, width) num_plots = (length // side_length) * (width // side_length) return side_length, num_plots"},{"question":"def separateLettersAndDigits(s: str): Separate the letters and integers from the given string while maintaining their original order. >>> separateLettersAndDigits('a1b2c3') (['a', 'b', 'c'], [1, 2, 3]) >>> separateLettersAndDigits('x9z8') (['x', 'z'], [9, 8])","solution":"def separateLettersAndDigits(s): letters = [] digits = [] for char in s: if char.isdigit(): digits.append(int(char)) elif char.isalpha(): letters.append(char) return letters, digits"},{"question":"def hackathon_reduction(participants): Given the number of participants in different cities, print the number of participants that are reduced in each hackathon until no participants are left. Example: >>> hackathon_reduction([10, 15, 20, 5, 25]) [5, 5, 5, 5, 5] >>> hackathon_reduction([10]) [10] >>> hackathon_reduction([10, 0, 5, 20]) [5, 5, 10] def process_input(input_str): Process the input into a list of integers representing participants in each city. Example: >>> process_input(\\"5n10 15 20 5 25\\") [10, 15, 20, 5, 25] def format_output(reductions): Format the list of reductions into a string with each reduction on a new line. Example: >>> format_output([5, 5, 5, 5, 5]) \\"5n5n5n5n5\\"","solution":"def hackathon_reduction(participants): reductions = [] while any(p > 0 for p in participants): passing_rate = min(p for p in participants if p > 0) reductions.append(passing_rate) participants = [p - passing_rate if p > 0 else 0 for p in participants] return reductions def process_input(input_str): lines = input_str.strip().split('n') N = int(lines[0]) participants = list(map(int, lines[1].split())) return participants def format_output(reductions): return 'n'.join(map(str, reductions))"},{"question":"def count_strictly_increasing_subarrays(N): For a circular array of size N with integers from 1 to N, this function returns the number of contiguous strictly increasing subarrays. Examples: >>> count_strictly_increasing_subarrays(2) 3 >>> count_strictly_increasing_subarrays(3) 6 >>> count_strictly_increasing_subarrays(4) 10 pass def count_strictly_increasing_subarrays_multiple_cases(T, test_cases): Processes multiple test cases and returns the results. Examples: >>> count_strictly_increasing_subarrays_multiple_cases(3, [2, 3, 4]) [3, 6, 10] >>> count_strictly_increasing_subarrays_multiple_cases(2, [1, 5]) [1, 15] >>> count_strictly_increasing_subarrays_multiple_cases(4, [1, 2, 3, 4]) [1, 3, 6, 10] pass","solution":"def count_strictly_increasing_subarrays(N): For a circular array of size N with integers from 1 to N, this function returns the number of contiguous strictly increasing subarrays. return N * (N + 1) // 2 def count_strictly_increasing_subarrays_multiple_cases(T, test_cases): Processes multiple test cases and returns the results. results = [] for N in test_cases: results.append(count_strictly_increasing_subarrays(N)) return results"},{"question":"def calculate_magical_power(matrix: List[List[int]]) -> int: Calculate the magical power of a n x n matrix. The magical power is defined as the sum of the maximum values in each row and each column of the matrix. >>> calculate_magical_power([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) == 42 >>> calculate_magical_power([ ... [5] ... ]) == 10 >>> calculate_magical_power([ ... [1, 1], ... [1, 1] ... ]) == 4","solution":"def calculate_magical_power(matrix): n = len(matrix) max_row_values = [max(row) for row in matrix] max_column_values = [max(matrix[i][j] for i in range(n)) for j in range(n)] magical_power = sum(max_row_values) + sum(max_column_values) return magical_power"},{"question":"def replace_with_greatest(L: List[int]) -> List[int]: Replaces every element of the list with the greatest element among the elements to its right, and replaces the last element with -1. :param L: List of integers :return: Updated list of integers >>> replace_with_greatest([17, 18, 5, 4, 6, 1]) [18, 6, 6, 6, 1, -1] >>> replace_with_greatest([7, 1, 5, 2]) [5, 5, 2, -1] >>> replace_with_greatest([]) [] >>> replace_with_greatest([10]) [-1] >>> replace_with_greatest([3, 3, 3, 3]) [3, 3, 3, -1] >>> replace_with_greatest([5, 4, 3, 2, 1]) [4, 3, 2, 1, -1] >>> replace_with_greatest([1, 2, 3, 4, 5]) [5, 5, 5, 5, -1] >>> replace_with_greatest([10, 1, 10, 3, 4, 1, 5]) [10, 10, 5, 5, 5, 5, -1]","solution":"def replace_with_greatest(L): Replaces every element of the list with the greatest element among the elements to its right, and replaces the last element with -1. :param L: List of integers :return: Updated list of integers n = len(L) if n == 0: return [] max_from_right = -1 for i in range(n - 1, -1, -1): new_value = max_from_right if L[i] > max_from_right: max_from_right = L[i] L[i] = new_value return L"},{"question":"def process_queries(N, Q, A, queries): Processes the list of string manipulations based on the given queries and returns the result of type-2 queries. Args: N : int : Number of initial strings. Q : int : Number of queries. A : list : Initial list of strings. queries : list : List of queries. Returns: list : Results from type-2 queries. import pytest def test_sample_case(): N = 3 Q = 5 A = [\\"abc\\", \\"def\\", \\"ghi\\"] queries = [ (1, 1, \\"xyz\\"), (2, 1, 4), (2, 2, 1), (2, 3, 5), (2, 2, 10) ] expected_output = [\\"x\\", \\"d\\", \\"Invalid position\\", \\"Invalid position\\"] assert process_queries(N, Q, A, queries) == expected_output def test_invalid_position(): N = 2 Q = 2 A = [\\"hello\\", \\"world\\"] queries = [ (2, 1, 6), (2, 2, 10) ] expected_output = [\\"Invalid position\\", \\"Invalid position\\"] assert process_queries(N, Q, A, queries) == expected_output def test_append_character(): N = 1 Q = 2 A = [\\"a\\"] queries = [ (1, 1, \\"b\\"), (2, 1, 2) ] expected_output = [\\"b\\"] assert process_queries(N, Q, A, queries) == expected_output def test_multiple_appends(): N = 1 Q = 4 A = [\\"x\\"] queries = [ (1, 1, \\"y\\"), (1, 1, \\"z\\"), (2, 1, 3), (2, 1, 1) ] expected_output = [\\"z\\", \\"x\\"] assert process_queries(N, Q, A, queries) == expected_output def test_edge_case(): N = 1 Q = 1 A = [\\"a\\"] queries = [ (2, 1, 1) ] expected_output = [\\"a\\"] assert process_queries(N, Q, A, queries) == expected_output pytest.main()","solution":"def process_queries(N, Q, A, queries): Processes the list of string manipulations based on the given queries and returns the result of type-2 queries. Args: N : int : Number of initial strings. Q : int : Number of queries. A : list : Initial list of strings. queries : list : List of queries. Returns: list : Results from type-2 queries. results = [] for query in queries: if query[0] == 1: x, y = query[1], query[2] # 1-based index conversion to 0-based A[x - 1] += y elif query[0] == 2: x, k = query[1], query[2] # 1-based index conversion to 0-based if k <= len(A[x - 1]): results.append(A[x - 1][k - 1]) else: results.append(\\"Invalid position\\") return results"},{"question":"def is_prime(n: int) -> bool: Check if a number is a prime number. >>> is_prime(2) True >>> is_prime(4) False pass def longest_increasing_prime_subsequence(arr: List[int]) -> int: Find the length of the longest strictly increasing subsequence of prime numbers. >>> longest_increasing_prime_subsequence([7, 3, 5, 2, 11]) 3 >>> longest_increasing_prime_subsequence([4, 6, 8, 10]) 0 pass def process_test_cases(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Process given test cases and return the results. >>> process_test_cases(2, [(5, [7, 3, 5, 2, 11]), (4, [4, 6, 8, 10])]) [3, 0] pass","solution":"from bisect import bisect_left def is_prime(n): Check if a number is a prime number. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False limit = int(n**0.5) + 1 for i in range(3, limit, 2): if n % i == 0: return False return True def longest_increasing_prime_subsequence(arr): Find the length of the longest strictly increasing subsequence of prime numbers. primes = [num for num in arr if is_prime(num)] if not primes: # No prime numbers in the list return 0 # Use dynamic programming with binary search to find the length of the LIS dp = [] for prime in primes: pos = bisect_left(dp, prime) if pos == len(dp): dp.append(prime) else: dp[pos] = prime return len(dp) def process_test_cases(t, test_cases): results = [] for i in range(t): n, arr = test_cases[i] result = longest_increasing_prime_subsequence(arr) results.append(result) return results # Example function to demonstrate how to pass test cases def example_usage(): t = 2 test_cases = [ (5, [7, 3, 5, 2, 11]), (4, [4, 6, 8, 10]) ] return process_test_cases(t, test_cases)"},{"question":"def max_sum_subarray(arr, l, r): Returns the maximum sum of a subarray whose length is between l and r inclusive. >>> max_sum_subarray([1, 2, -1, 4, 5], 2, 4) 10 >>> max_sum_subarray([-3, 1, -2, 4, -1, 2], 2, 3) 5","solution":"def max_sum_subarray(arr, l, r): Returns the maximum sum of a subarray whose length is between l and r inclusive. n = len(arr) # Initialize the maximum sum variable max_sum = float('-inf') # Iterate through all possible subarray lengths from l to r for length in range(l, r + 1): # Calculate the sum of the first subarray of the current length current_sum = sum(arr[:length]) max_sum = max(max_sum, current_sum) # Use sliding window technique to calculate the sum of the remaining subarrays for i in range(length, n): current_sum += arr[i] - arr[i - length] max_sum = max(max_sum, current_sum) return max_sum # Examples n = 5 arr = [1, 2, -1, 4, 5] l = 2 r = 4 print(max_sum_subarray(arr, l, r)) # Output: 10 n = 6 arr = [-3, 1, -2, 4, -1, 2] l = 2 r = 3 print(max_sum_subarray(arr, l, r)) # Output: 5"},{"question":"def common_elements(list1, list2): Write a function \`common_elements\` that takes two lists, and returns a new list containing the elements that appear in both input lists. Each element in the result should appear as many times as it shows in both lists. Notes: - If either of the inputs is not a list, return \`None\`. - The order of elements in the output list does not matter. Examples: >>> common_elements([1, 2, 3], [2, 3, 4]) [2, 3] >>> common_elements(['a', 'b', 'b', 'c'], ['b', 'b', 'b', 'd']) ['b', 'b'] >>> common_elements([1, 2, 3], 123) None","solution":"def common_elements(list1, list2): Returns the common elements between two lists as many times as they appear in both lists. If either input is not a list, returns None. if not isinstance(list1, list) or not isinstance(list2, list): return None from collections import Counter counter1 = Counter(list1) counter2 = Counter(list2) intersection = counter1 & counter2 return list(intersection.elements())"},{"question":"def is_path_exist(grid, N, M): Determine if there is a path from the top-left corner to the bottom-right corner. >>> is_path_exist(['0001', '0101', '0100', '1000'], 4, 4) \\"YES\\" >>> is_path_exist(['010', '101', '000'], 3, 3) \\"NO\\" >>> is_path_exist(['0'], 1, 1) \\"YES\\" >>> is_path_exist(['01', '10'], 2, 2) \\"NO\\" def process_test_cases(T, test_cases): Process multiple test cases for path existence. >>> process_test_cases(2, [{'dimensions': (4, 4), 'grid': ['0001', '0101', '0100', '1000']}, {'dimensions': (3, 3), 'grid': ['010', '101', '000']}]) [\\"YES\\", \\"NO\\"] >>> process_test_cases(1, [{'dimensions': (1, 1), 'grid': ['0']}]) [\\"YES\\"] >>> process_test_cases(1, [{'dimensions': (2, 2), 'grid': ['01', '10']}]) [\\"NO\\"]","solution":"def is_path_exist(grid, N, M): Determine if there is a path from the top-left corner to the bottom-right corner. if grid[0][0] == '1' or grid[N-1][M-1] == '1': return \\"NO\\" from collections import deque directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # right, down, left, up # BFS initialization queue = deque([(0, 0)]) visited = set((0, 0)) while queue: x, y = queue.popleft() if x == N-1 and y == M-1: return \\"YES\\" for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < N and 0 <= ny < M and (nx, ny) not in visited and grid[nx][ny] == '0': queue.append((nx, ny)) visited.add((nx, ny)) return \\"NO\\" def process_test_cases(T, test_cases): results = [] for case in test_cases: N, M = case['dimensions'] grid = case['grid'] results.append(is_path_exist(grid, N, M)) return results"},{"question":"def find_single_element(nums): Finds the single element that appears only once in an array where every other element appears twice. Params: nums: List[int] - the input array of integers Returns: int - the single element that appears only once pass from solution import find_single_element def test_single_element_in_middle(): assert find_single_element([4, 3, 2, 4, 1, 3, 2]) == 1 def test_single_element_at_start(): assert find_single_element([7, 2, 3, 2, 4, 4, 3]) == 7 def test_single_element_at_end(): assert find_single_element([5, 1, 1, 2, 2, 3, 3]) == 5 def test_single_element_min_value(): assert find_single_element([1, 2, 2, 3, 3, 1, 4]) == 4 def test_single_element_max_value(): assert find_single_element([100000, 99999, 99999, 100000, 100001]) == 100001","solution":"def find_single_element(nums): Finds the single element that appears only once in an array where every other element appears twice. Params: nums: List[int] - the input array of integers Returns: int - the single element that appears only once result = 0 for num in nums: result ^= num return result"},{"question":"def smallestNonRepresentableValue(arr: List[int], n: int) -> int: Given an array of integers, find the smallest positive integer that cannot be represented as the sum of any subset of the array. >>> smallestNonRepresentableValue([1, 3, 6, 10, 11, 15], 6) 2 >>> smallestNonRepresentableValue([1, 1, 1, 1, 1], 5) 6 >>> smallestNonRepresentableValue([1, 1, 3], 3) 6","solution":"def smallestNonRepresentableValue(arr, n): # Sort the array arr.sort() # Initialize the smallest value that cannot be represented as 1 smallest_missing = 1 # Traverse the array for num in arr: # If the current element is greater than the smallest_missing # It means smallest_missing cannot be formed if num > smallest_missing: break # Otherwise add the current element to smallest_missing smallest_missing += num return smallest_missing"},{"question":"import string def anagram_checker(str1: str, str2: str) -> bool: Write a function that takes two strings as input and returns True if the two strings are anagrams of each other, and False otherwise. The comparison should be case-insensitive and should ignore any spaces or punctuation. >>> anagram_checker(\\"Astronomer\\", \\"Moon starer\\") True >>> anagram_checker(\\"Hello!\\", \\"Oleh.\\") False","solution":"import string def anagram_checker(str1, str2): Checks if two strings are anagrams of each other. This comparison is case-insensitive and ignores spaces and punctuation. # Helper function to clean and sort the string def clean_string(s): translator = str.maketrans('', '', string.punctuation + string.whitespace) return ''.join(sorted(s.translate(translator).lower())) return clean_string(str1) == clean_string(str2)"},{"question":"def minimum_street_lights(n, k): Determine the minimum number of street lights needed to illuminate all the houses. Parameters: n (int): The number of houses. k (int): The number of houses on either side that a street light can illuminate. Returns: int: The minimum number of street lights needed. Examples: >>> minimum_street_lights(5, 1) 2 >>> minimum_street_lights(10, 2) 2 >>> minimum_street_lights(1, 500) 1","solution":"def minimum_street_lights(n, k): Returns the minimum number of street lights needed to illuminate all the houses. Parameters: n (int): The number of houses. k (int): The number of houses on either side that a street light can illuminate. Returns: int: The minimum number of street lights needed. # Total number of houses illuminated by each street light coverage = 2 * k + 1 # Minimum number of street lights needed min_lights = (n + coverage - 1) // coverage # Using ceiling function approach return min_lights"},{"question":"from typing import List, Tuple def character_frequency(s: str) -> List[Tuple[str, int]]: Takes a string containing a mixture of duplicates and unique characters, and returns a list of tuples. Each tuple should contain one of the unique characters and its frequency of occurrence in the string. The output list should be sorted by frequency in descending order. In the case of a tie, sort by the character's ascii value in ascending order. >>> character_frequency(\\"programming\\") [('g', 2), ('m', 2), ('r', 2), ('a', 1), ('i', 1), ('n', 1), ('o', 1), ('p', 1)] >>> character_frequency(\\"aabbcc\\") [('a', 2), ('b', 2), ('c', 2)] >>> character_frequency(\\"aaaaa\\") [('a', 5)] >>> character_frequency(\\"abcdefg\\") [('a', 1), ('b', 1), ('c', 1), ('d', 1), ('e', 1), ('f', 1), ('g', 1)] >>> character_frequency(\\"\\") []","solution":"from collections import Counter def character_frequency(s): Takes a string and returns a list of tuples with unique characters and their frequencies, sorted by frequency in descending order and by ascii value in ascending order for ties. # Count the frequency of each character in the string frequency_count = Counter(s) # Create a sorted list of tuples based on the counts sorted_frequency = sorted(frequency_count.items(), key=lambda x: (-x[1], x[0])) return sorted_frequency"},{"question":"from typing import List, Tuple from collections import defaultdict from bisect import bisect_left, bisect_right def preprocess_transactions(transactions: List[Tuple[int, int]]) -> dict: Process the list of transactions and return a dictionary where keys are user_ids and values are lists of transaction_ids. >>> preprocess_transactions([(1, 5), (2, 15), (1, 25), (2, 35), (3, 50)]) == {1: [5, 25], 2: [15, 35], 3: [50]} pass # Replace this with your implementation def count_transactions_in_range(user_transactions: dict, l: int, r: int) -> List[Tuple[int, int]]: Given a dictionary of user transactions and a range (l, r), count the number of transactions within that range for each user. >>> count_transactions_in_range({1: [5, 25], 2: [15, 35], 3: [50]}, 10, 30) == [(1, 1), (2, 1)] >>> count_transactions_in_range({1: [5, 25], 2: [15, 35], 3: [50]}, 1, 50) == [(1, 2), (2, 2), (3, 1)] pass # Replace this with your implementation def process_queries(transactions: List[Tuple[int, int]], queries: List[Tuple[int, int]]) -> List[List[Tuple[int, int]]]: Process a list of queries to count transactions within the given ranges for each user. >>> transactions = [(1, 5), (2, 15), (1, 25), (2, 35), (3, 50)] >>> queries = [(10, 30), (1, 50)] >>> process_queries(transactions, queries) == [[(1, 1), (2, 1)], [(1, 2), (2, 2), (3, 1)]] pass # Replace this with your implementation def test_preprocess_transactions(): transactions = [(1, 5), (2, 15), (1, 25), (2, 35), (3, 50)] expected = { 1: [5, 25], 2: [15, 35], 3: [50] } assert preprocess_transactions(transactions) == expected def test_count_transactions_in_range(): user_transactions = { 1: [5, 25], 2: [15, 35], 3: [50] } assert count_transactions_in_range(user_transactions, 10, 30) == [(1, 1), (2, 1)] assert count_transactions_in_range(user_transactions, 1, 50) == [(1, 2), (2, 2), (3, 1)] assert count_transactions_in_range(user_transactions, 30, 40) == [(2, 1)] assert count_transactions_in_range(user_transactions, 30, 49) == [(2, 1)] assert count_transactions_in_range(user_transactions, 51, 60) == [] def test_process_queries(): transactions = [(1, 5), (2, 15), (1, 25), (2, 35), (3, 50)] queries = [(10, 30), (1, 50)] expected = [ [(1, 1), (2, 1)], [(1, 2), (2, 2), (3, 1)] ] assert process_queries(transactions, queries) == expected","solution":"from collections import defaultdict from bisect import bisect_left, bisect_right def preprocess_transactions(transactions): user_transactions = defaultdict(list) for user_id, trans_id in transactions: user_transactions[user_id].append(trans_id) for user_id in user_transactions: user_transactions[user_id].sort() return user_transactions def count_transactions_in_range(user_transactions, l, r): result = [] for user_id in sorted(user_transactions): transactions = user_transactions[user_id] left_index = bisect_left(transactions, l) right_index = bisect_right(transactions, r) count = right_index - left_index if count > 0: result.append((user_id, count)) return result def process_queries(transactions, queries): user_transactions = preprocess_transactions(transactions) results = [] for l, r in queries: result = count_transactions_in_range(user_transactions, l, r) results.append(result) return results"},{"question":"def decompressed_length(s: str) -> int: Given a compressed string, computes the length of the decompressed string. >>> decompressed_length(\\"a5b3c2\\") 10 >>> decompressed_length(\\"x10y20\\") 30 >>> decompressed_length(\\"z1\\") 1","solution":"def decompressed_length(s): Given a compressed string, computes the length of the decompressed string. import re # Using regex to find all matches of a letter followed by digits. pattern = re.findall(r'([a-z])(d+)', s) total_length = sum(int(count) for char, count in pattern) return total_length"},{"question":"def can_form_palindrome(s: str) -> str: Determines if any permutation of the string can form a palindrome. :param s: string consisting of lowercase alphabetical characters :return: \\"YES\\" if any permutation of the string can form a palindrome, otherwise \\"NO\\" >>> can_form_palindrome(\\"carrace\\") \\"YES\\" >>> can_form_palindrome(\\"hello\\") \\"NO\\" >>> can_form_palindrome(\\"aabb\\") \\"YES\\" >>> can_form_palindrome(\\"ab\\") \\"NO\\"","solution":"def can_form_palindrome(s): Determines if any permutation of the string can form a palindrome. :param s: string consisting of lowercase alphabetical characters :return: \\"YES\\" if any permutation of the string can form a palindrome, otherwise \\"NO\\" from collections import Counter # Count the frequency of each character in the input string char_count = Counter(s) # Count how many characters have an odd frequency odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # A string can form a palindrome if it has at most one character with an odd frequency return \\"YES\\" if odd_count <= 1 else \\"NO\\""},{"question":"def largest_lexicographical_permutation(n: int, k: int, arr: List[int]) -> List[int]: Given an array of n integers, modifies the array to create the largest lexicographical permutation possible by making at most k swaps of any two elements. Each swap can swap any two elements at most once. :param n: int - length of the array (2 ≤ n ≤ 100000) :param k: int - maximum number of swaps allowed (1 ≤ k ≤ 1000000000) :param arr: List[int] - an array of n integers (0 ≤ a_i ≤ 10^9) :return: List[int] - the largest lexicographical permutation of the array possible after making at most k swaps. Examples: >>> largest_lexicographical_permutation(5, 2, [1, 2, 3, 4, 5]) [5, 4, 3, 2, 1] >>> largest_lexicographical_permutation(3, 2, [3, 2, 1]) [3, 2, 1] >>> largest_lexicographical_permutation(4, 2, [4, 2, 3, 1]) [4, 3, 2, 1]","solution":"def largest_lexicographical_permutation(n, k, arr): pos = {value: i for i, value in enumerate(arr)} for i in range(n): if k == 0: break max_value = n - i if arr[i] == max_value: continue max_pos = pos[max_value] arr[i], arr[max_pos] = arr[max_pos], arr[i] pos[arr[max_pos]] = max_pos pos[arr[i]] = i k -= 1 return arr"},{"question":"from typing import List def is_prime(n: int) -> bool: Return True if n is a prime number else False pass def closest_fibonacci(n: int) -> int: Return the closest Fibonacci number to n pass def replace_primes_with_fibonacci(n: int, values: List[int]) -> List[int]: Replace prime numbers in the list with closest Fibonacci numbers. >>> replace_primes_with_fibonacci(10, [2, 4, 6, 8, 10, 11, 14, 16, 17, 19]) [2, 4, 6, 8, 10, 13, 14, 16, 13, 21] >>> replace_primes_with_fibonacci(5, [35, 29, 23, 21, 1]) [35, 34, 21, 21, 1] pass","solution":"def is_prime(n): Return True if n is a prime number else False if n <= 1: return False if n == 2: return True if n % 2 == 0: return False for i in range(3, int(n**0.5) + 1, 2): if n % i == 0: return False return True def closest_fibonacci(n): Return the closest Fibonacci number to n if n == 0: return 0 if n == 1: return 1 a, b = 0, 1 while b < n: a, b = b, a + b if b == n or abs(b - n) < abs(a - n): return b else: return a def replace_primes_with_fibonacci(n, values): Replace prime numbers in the list with closest Fibonacci numbers result = [] for value in values: if is_prime(value): value = closest_fibonacci(value) result.append(value) return result"},{"question":"def top_students(N, M, marks): Identify the top-performing students in each subject based on their marks. :param N: Number of students :param M: Number of subjects :param marks: List of lists where each inner list contains student ID followed by marks in each subject :return: List of lists where each inner list contains the student IDs of top-performing students for a subject >>> top_students(5, 3, [ [1, 78, 85, 90], [2, 88, 92, 78], [3, 85, 92, 91], [4, 88, 90, 92], [5, 78, 85, 91] ]) [[2, 4], [2, 3], [4]] >>> top_students(4, 3, [ [1, 90, 80, 70], [2, 90, 82, 74], [3, 88, 82, 90], [4, 90, 82, 90] ]) [[1, 2, 4], [2, 3, 4], [3, 4]]","solution":"def top_students(N, M, marks): Identify the top-performing students in each subject based on their marks. :param N: Number of students :param M: Number of subjects :param marks: List of lists where each inner list contains student ID followed by marks in each subject :return: List of lists where each inner list contains the student IDs of top-performing students for a subject top_performers = [[] for _ in range(M)] for j in range(M): max_mark = max(marks[i][j + 1] for i in range(N)) for i in range(N): if marks[i][j + 1] == max_mark: top_performers[j].append(marks[i][0]) return [sorted(performers) for performers in top_performers]"},{"question":"from typing import List from collections import Counter def countPalindromicPermutations(w: str) -> int: Given a word w, return the count of words that can be formed by re-arranging its letters such that they are palindrome. A palindrome is a word that reads the same backward as forward. >>> countPalindromicPermutations(\\"aabb\\") 2 >>> countPalindromicPermutations(\\"abc\\") 0 def test_countPalindromicPermutations_examples(): assert countPalindromicPermutations(\\"aabb\\") == 2 assert countPalindromicPermutations(\\"abc\\") == 0 def test_countPalindromicPermutations_single_character(): assert countPalindromicPermutations(\\"a\\") == 1 def test_countPalindromicPermutations_all_same_characters(): assert countPalindromicPermutations(\\"aa\\") == 1 assert countPalindromicPermutations(\\"aaa\\") == 1 def test_countPalindromicPermutations_odd_characters(): assert countPalindromicPermutations(\\"aabbc\\") == 2 assert countPalindromicPermutations(\\"aabbcd\\") == 0 def test_countPalindromicPermutations_long_word(): assert countPalindromicPermutations(\\"aabbccddeeffgg\\") == 5040 assert countPalindromicPermutations(\\"abcdef\\") == 0","solution":"from collections import Counter def countPalindromicPermutations(w): Returns the number of palindromic permutations that can be formed from the given word w. # Count the frequency of each character in the word freq = Counter(w) # Count the number of characters with odd frequency odd_count = sum(1 for count in freq.values() if count % 2 != 0) # A palindrome can have at most one character with an odd frequency if odd_count > 1: return 0 # Calculate the number of permutations that form a palindrome from math import factorial # Half lengths factorial division half_length_factorial = factorial(sum(count // 2 for count in freq.values())) # factorial of half the counts of each character that appears more than once divisors = 1 for count in freq.values(): if count // 2 > 1: divisors *= factorial(count // 2) return half_length_factorial // divisors"},{"question":"def length_of_lis(nums: List[int]) -> int: Returns the length of the longest increasing subsequence in the given list of numbers. >>> length_of_lis([10, 9, 2, 5, 3, 7, 101, 18]) 4 >>> length_of_lis([0, 1, 0, 3, 2, 3]) 4 >>> length_of_lis([0, 1, 3, 5, 6]) 5 >>> length_of_lis([5, 4, 3, 2, 1]) 1 >>> length_of_lis([2, 2, 2, 2]) 1 def parse_input(input_str: str) -> int: Parses the input string and returns the length of the longest increasing subsequence. >>> parse_input(\\"6n10 9 2 5 3 7 101 18\\") 4 >>> parse_input(\\"5n0 1 0 3 2 3\\") 4 >>> parse_input(\\"5n0 1 3 5 6\\") 5 >>> parse_input(\\"5n5 4 3 2 1\\") 1 >>> parse_input(\\"4n2 2 2 2\\") 1","solution":"def length_of_lis(nums): Returns the length of the longest increasing subsequence in the given list of numbers. if not nums: return 0 n = len(nums) dp = [1] * n for i in range(1, n): for j in range(i): if nums[i] > nums[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp) def parse_input(input_str): lines = input_str.strip().split('n') n = int(lines[0]) nums = list(map(int, lines[1].split())) return length_of_lis(nums)"},{"question":"import math def countPerfectSquares(M: int) -> int: Given an integer M, count the number of integers from 1 to M that are perfect squares. >>> countPerfectSquares(16) 4 >>> countPerfectSquares(25) 5 pass def test_example_1(): assert countPerfectSquares(16) == 4 # 1, 4, 9, 16 def test_example_2(): assert countPerfectSquares(25) == 5 # 1, 4, 9, 16, 25 def test_edge_case_min(): assert countPerfectSquares(1) == 1 # 1 def test_no_perfect_squares(): assert countPerfectSquares(2) == 1 # Only 1 def test_large_M(): assert countPerfectSquares(100000) == 316 # sqrt(100000) ≈ 316 def test_large_M_exact_square(): assert countPerfectSquares(10000) == 100 # sqrt(10000) = 100","solution":"import math def countPerfectSquares(M): Returns the count of perfect squares from 1 to M. return int(math.sqrt(M))"},{"question":"def findMissingNumber(arr): Write a function \`findMissingNumber\` that takes an array of consecutive integers (with one missing number) and returns the missing integer. The array will have at least two elements. Parameters: arr (list of int): A sorted list of consecutive integers with one missing. Returns: int: The missing integer. Examples: >>> findMissingNumber([1, 2, 3, 4, 6]) 5 >>> findMissingNumber([3, 4, 5, 6, 8]) 7 >>> findMissingNumber([1, 3, 4, 5]) 2","solution":"def findMissingNumber(arr): Returns the missing number in a sorted array of consecutive integers. Parameters: arr (list of int): A sorted list of consecutive integers with one missing. Returns: int: The missing integer. # Calculate the expected sum of the complete range n = len(arr) + 1 total_sum = (n * (arr[0] + arr[-1])) // 2 # Calculate the actual sum of the array actual_sum = sum(arr) # Return the difference which is the missing number return total_sum - actual_sum"},{"question":"def preprocess_prefix_sums(arr): Precomputes the prefix sums for an array. Parameters: arr (list of int): The array of integers to preprocess. Returns: list of int: The prefix sums of the array. # Your code here def range_sum(prefix_sums, l, r): Computes the sum of the elements in the array between indices l and r (1-based). Parameters: prefix_sums (list of int): The prefix sums of the array. l (int): The starting index of the range (1-based). r (int): The ending index of the range (1-based). Returns: int: The sum of the elements in the specified range. # Your code here from solution import preprocess_prefix_sums, range_sum def test_preprocess_prefix_sums(): arr = [1, 2, 3, 4, 5] prefix_sums = preprocess_prefix_sums(arr) assert prefix_sums == [0, 1, 3, 6, 10, 15] def test_range_sum_example_1(): arr = [1, 2, 3, 4, 5] prefix_sums = preprocess_prefix_sums(arr) assert range_sum(prefix_sums, 1, 3) == 6 def test_range_sum_example_2(): arr = [1, 2, 3, 4, 5] prefix_sums = preprocess_prefix_sums(arr) assert range_sum(prefix_sums, 2, 4) == 9 def test_range_sum_example_3(): arr = [1, 2, 3, 4, 5] prefix_sums = preprocess_prefix_sums(arr) assert range_sum(prefix_sums, 1, 5) == 15 def test_range_sum_single_element(): arr = [10, 20, 30, 40, 50] prefix_sums = preprocess_prefix_sums(arr) assert range_sum(prefix_sums, 3, 3) == 30 # Sum of the third element only def test_range_sum_entire_array(): arr = [10, 20, 30, 40, 50] prefix_sums = preprocess_prefix_sums(arr) assert range_sum(prefix_sums, 1, 5) == 150 # Sum of all elements","solution":"def preprocess_prefix_sums(arr): Precomputes the prefix sums for an array. Parameters: arr (list of int): The array of integers to preprocess. Returns: list of int: The prefix sums of the array. n = len(arr) prefix_sums = [0] * (n + 1) for i in range(n): prefix_sums[i + 1] = prefix_sums[i] + arr[i] return prefix_sums def range_sum(prefix_sums, l, r): Computes the sum of the elements in the array between indices l and r (1-based). Parameters: prefix_sums (list of int): The prefix sums of the array. l (int): The starting index of the range (1-based). r (int): The ending index of the range (1-based). Returns: int: The sum of the elements in the specified range. return prefix_sums[r] - prefix_sums[l - 1]"},{"question":"def is_prime(n: int) -> bool: Checks if a number is a prime number. >>> is_prime(2) True >>> is_prime(4) False >>> is_prime(17) True >>> is_prime(18) False def filter_primes(arr: List[int]) -> List[int]: Takes an array of integers and returns an array containing only the prime numbers from the input array in the order they appeared. >>> filter_primes([3, 4, 7, 10, 11, 13]) [3, 7, 11, 13] >>> filter_primes([4, 6, 8, 10, 12]) [] >>> filter_primes([]) [] >>> filter_primes([5]) [5] >>> filter_primes([8]) [] >>> filter_primes([29, 34, 37, 40, 41, 45, 47, 50]) [29, 37, 41, 47]","solution":"def is_prime(n): Checks if a number is a prime number. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while (i * i) <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def filter_primes(arr): Takes an array of integers and returns an array containing only the prime numbers from the input array in the order they appeared. return [num for num in arr if is_prime(num)]"},{"question":"def can_robot_follow_commands(m, n, grid, r_s, c_s, commands): Determine if the robot can successfully execute all instructions without hitting any obstacles. Parameters: m (int): number of rows in the grid. n (int): number of columns in the grid. grid (List[str]): representation of the grid where each character is either '.' for free cell or '#' for obstacle. r_s (int): starting row position of the robot. c_s (int): starting column position of the robot. commands (str): sequence of movement instructions (U, D, L, R). Returns: str: 'Yes' if the robot can follow all instructions without collision, otherwise 'No'. >>> can_robot_follow_commands(5, 5, [ ... \\".....\\", \\".#...\\", \\".....\\", \\"...#.\\", \\".....\\"], 2, 2, \\"UUDDLRLR\\") 'Yes' >>> can_robot_follow_commands(5, 5, [ ... \\".....\\", \\".#...\\", \\".....\\", \\"...#.\\", \\".....\\"], 2, 2, \\"UUUUUU\\") 'No' >>> can_robot_follow_commands(3, 3, [ ... \\"...\\", \\".#.\\", \\"...\\"], 0, 0, \\"DDRR\\") 'Yes' >>> can_robot_follow_commands(3, 3, [ ... \\"...\\", \\".#.\\", \\"...\\"], 0, 2, \\"LLL\\") 'No'","solution":"def can_robot_follow_commands(m, n, grid, r_s, c_s, commands): Determine if the robot can successfully execute all instructions without hitting any obstacles. # Define directions for movement moves = { 'U': (-1, 0), 'D': (1, 0), 'L': (0, -1), 'R': (0, 1) } # Current position of the robot current_r, current_c = r_s, c_s for command in commands: move_r, move_c = moves[command] current_r += move_r current_c += move_c # Check if out of bounds if not (0 <= current_r < m and 0 <= current_c < n): return \\"No\\" # Check for obstacles if grid[current_r][current_c] == '#': return \\"No\\" return \\"Yes\\""},{"question":"def remove_adjacent_duplicates(s: str) -> str: Remove the adjacent duplicate characters repeatedly until no adjacent duplicates are present. >>> remove_adjacent_duplicates(\\"abbaca\\") 'ca' >>> remove_adjacent_duplicates(\\"azxxzy\\") 'ay'","solution":"def remove_adjacent_duplicates(s): stack = [] for char in s: if stack and stack[-1] == char: stack.pop() else: stack.append(char) return ''.join(stack)"},{"question":"def minimum_work(n: int, heights: List[int]) -> int: Find the minimum units of work needed to make all the cells the same height. Given the number of cells in the landscape and their respective heights, return the minimum number of units of work required to make all the cells the same height. Args: n (int): The number of cells. heights (List[int]): A list of integers representing the heights of the cells. Returns: int: The minimum number of units of work required. Examples: >>> minimum_work(5, [1, 2, 3, 4, 5]) 6 >>> minimum_work(4, [2, 2, 2, 3]) 1","solution":"def minimum_work(n, heights): Returns the minimum number of units of work required to make all cells the same height. heights.sort() median_height = heights[n // 2] work = sum(abs(height - median_height) for height in heights) return work"},{"question":"def minimum_days_to_equalize_flowers(N: int, flowers: List[int]) -> int: Determine the minimum number of days required for Alice to make the number of flowers in each pot the same. Parameters: N : int : The number of flowerpots flowers : List[int] : A list containing the number of flowers in each pot Returns: int : The minimum number of days required to equalize the number of flowers in each pot >>> minimum_days_to_equalize_flowers(5, [2, 5, 5, 7, 8]) 13 >>> minimum_days_to_equalize_flowers(3, [1, 1, 1]) 0","solution":"def minimum_days_to_equalize_flowers(N, flowers): max_flowers = max(flowers) total_days = sum(max_flowers - flower for flower in flowers) return total_days # Example usage # N = 5 # flowers = [2, 5, 5, 7, 8] # print(minimum_days_to_equalize_flowers(N, flowers)) # Outputs 13"},{"question":"def can_transform(S: str, P: str) -> str: Determine if it's possible to transform string S into an empty string by sequentially removing any prefix which matches any string in P. >>> can_transform(\\"abcbabc\\", \\"abc b\\") \\"Yes\\" >>> can_transform(\\"abcdef\\", \\"ab cde f\\") \\"Yes\\" >>> can_transform(\\"programming\\", \\"pro gram core\\") \\"No\\" >>> can_transform(\\"apple\\", \\"a p ple\\") \\"Yes\\" from solution import can_transform def test_example_1(): S = \\"abcbabc\\" P = \\"abc b\\" assert can_transform(S, P) == \\"Yes\\" def test_example_2(): S = \\"abcdef\\" P = \\"ab cde f\\" assert can_transform(S, P) == \\"Yes\\" def test_example_3(): S = \\"programming\\" P = \\"pro gram core\\" assert can_transform(S, P) == \\"No\\" def test_example_4(): S = \\"apple\\" P = \\"a p ple\\" assert can_transform(S, P) == \\"Yes\\" def test_empty_string(): S = \\"\\" P = \\"a b c\\" assert can_transform(S, P) == \\"Yes\\" def test_no_matching_prefix(): S = \\"hello\\" P = \\"wor ld\\" assert can_transform(S, P) == \\"No\\" def test_single_character(): S = \\"a\\" P = \\"a\\" assert can_transform(S, P) == \\"Yes\\" def test_repeating_prefix(): S = \\"aaaaa\\" P = \\"a aa\\" assert can_transform(S, P) == \\"Yes\\"","solution":"def can_transform(S, P): prefixes = set(P.split()) def can_remove_prefix(start): if start == len(S): return True for prefix in prefixes: if S.startswith(prefix, start): if can_remove_prefix(start + len(prefix)): return True return False return \\"Yes\\" if can_remove_prefix(0) else \\"No\\""},{"question":"def max_temperature_change(n, temperature_readings): Determines the maximum temperature change in any one-hour interval. :param n: Number of recorded temperatures :param temperature_readings: List of tuples (t, temp) :return: Maximum absolute temperature change in any one-hour interval >>> max_temperature_change(5, [(0, 15), (1, 20), (2, 25), (3, 10), (4, 5)]) 15 >>> max_temperature_change(3, [(0, 10), (1, 10), (2, 10)]) 0 >>> max_temperature_change(2, [(0, 0), (1, 100)]) 100 >>> max_temperature_change(3, [(0, -5), (1, -10), (2, 0)]) 10 >>> max_temperature_change(2, [(0, -30), (1, 20)]) 50 >>> max_temperature_change(4, [(1, 15), (5, 15), (7, 15), (8, 15)]) 0","solution":"def max_temperature_change(n, temperature_readings): Determines the maximum temperature change in any one-hour interval. :param n: Number of recorded temperatures :param temperature_readings: List of tuples (t, temp) :return: Maximum absolute temperature change in any one-hour interval max_change = 0 for i in range(1, n): change = abs(temperature_readings[i][1] - temperature_readings[i-1][1]) max_change = max(max_change, change) return max_change"},{"question":"def lexicographically_smallest_string(t: int, test_cases: List[str]) -> List[str]: Returns a list of the lexicographically smallest strings for each test case. >>> lexicographically_smallest_string(3, [\\"banana\\", \\"apple\\", \\"circling\\"]) ['aaabnn', 'aelpp', 'ccgiilnr'] >>> lexicographically_smallest_string(1, [\\"a\\"]) ['a'] >>> lexicographically_smallest_string(1, [\\"aaaaa\\"]) ['aaaaa'] >>> lexicographically_smallest_string(2, [\\"ba\\", \\"ab\\"]) ['ab', 'ab'] >>> lexicographically_smallest_string(2, [\\"z\\", \\"abc\\"]) ['z', 'abc']","solution":"def lexicographically_smallest_string(t, test_cases): Returns a list of the lexicographically smallest strings for each test case. results = [] for s in test_cases: results.append(''.join(sorted(s))) return results # Example usage: # t = 3 # test_cases = [\\"banana\\", \\"apple\\", \\"circling\\"] # print(lexicographically_smallest_string(t, test_cases))"},{"question":"def check_collinear(p1, p2, p3): Check if three points are collinear. x1, y1 = p1 x2, y2 = p2 x3, y3 = p3 return (y2 - y1) * (x3 - x2) == (y3 - y2) * (x2 - x1) def find_circle(points): n = len(points) for i in range(n): for j in range(i+1, n): for k in range(j+1, n): if not check_collinear(points[i], points[j], points[k]): return \\"yes\\" return \\"no\\" def circle_from_points(n, coordinates): Determine if there exists a circle that contains at least three points on its circumference. >>> circle_from_points(4, [\\"0 0\\", \\"1 0\\", \\"0 1\\", \\"1 1\\"]) == \\"yes\\" >>> circle_from_points(3, [\\"0 0\\", \\"1 2\\", \\"3 6\\"]) == \\"no\\" points = [tuple(map(int, coordinates[i].split())) for i in range(n)] return find_circle(points)","solution":"from math import isclose def check_collinear(p1, p2, p3): Check if three points are collinear. x1, y1 = p1 x2, y2 = p2 x3, y3 = p3 return (y2 - y1) * (x3 - x2) == (y3 - y2) * (x2 - x1) def find_circle(points): n = len(points) for i in range(n): for j in range(i+1, n): for k in range(j+1, n): if not check_collinear(points[i], points[j], points[k]): return \\"yes\\" return \\"no\\" def circle_from_points(n, coordinates): points = [tuple(map(int, coordinates[i].split())) for i in range(n)] return find_circle(points)"},{"question":"def last_remaining_child(N): Returns the position of the last remaining child in Josephus problem with every second child being removed. # Complete the function def find_last_remaining_positions(test_cases): For each test case, returns the position of the last remaining child. # Complete the function # Example usage: # print(find_last_remaining_positions([5, 8])) # Output: [3, 1] # Unit Tests: def test_last_remaining_child(): assert last_remaining_child(1) == 1 assert last_remaining_child(2) == 1 assert last_remaining_child(3) == 3 assert last_remaining_child(4) == 1 assert last_remaining_child(5) == 3 assert last_remaining_child(8) == 1 assert last_remaining_child(10) == 5 assert last_remaining_child(13) == 11 def test_find_last_remaining_positions(): assert find_last_remaining_positions([5, 8]) == [3, 1] assert find_last_remaining_positions([1, 2, 3, 4]) == [1, 1, 3, 1] assert find_last_remaining_positions([6, 7, 10, 12]) == [5, 7, 5, 9]","solution":"def last_remaining_child(N): Returns the position of the last remaining child in Josephus problem with every second child being removed. if N == 1: return 1 else: return (last_remaining_child(N - 1) + 1) % N + 1 def find_last_remaining_positions(test_cases): For each test case, returns the position of the last remaining child. results = [] for N in test_cases: results.append(last_remaining_child(N)) return results"},{"question":"def check_sum_exists(n: int, arr: List[int], k: int) -> str: Given a list of integers and a target integer k, return whether there are two distinct indices i and j in the list such that the sum of the integers at these indices is equal to k. >>> check_sum_exists(5, [1, 4, 45, 6, 10], 16) == \\"YES\\" >>> check_sum_exists(4, [1, 2, 3, 9], 8) == \\"NO\\" >>> check_sum_exists(6, [-1, -2, -3, -4, -5, -6], -8) == \\"YES\\" >>> check_sum_exists(3, [4, 5, 1], 10) == \\"NO\\"","solution":"def check_sum_exists(n, arr, k): Given a list of integers and a target integer k, return whether there are two distinct indices i and j in the list such that the sum of the integers at these indices is equal to k. seen = set() for num in arr: if k - num in seen: return \\"YES\\" seen.add(num) return \\"NO\\""},{"question":"def max_book_value(n: int, T: int, books: List[Tuple[int, int]]) -> int: Calculate the maximum total value of books that can be placed on the shelf without exceeding the thickness limit. >>> max_book_value(4, 10, [(2, 3), (3, 5), (4, 8), (5, 10)]) 18 >>> max_book_value(3, 5, [(2, 10), (3, 7), (1, 5)]) 17 >>> max_book_value(1, 10, [(5, 20)]) 20 >>> max_book_value(1, 10, [(15, 20)]) 0 >>> max_book_value(3, 10, [(3, 4), (4, 5), (3, 8)]) 17 >>> max_book_value(3, 0, [(1, 2), (2, 3), (3, 4)]) 0","solution":"def max_book_value(n, T, books): # Initialize the DP array with zeros dp = [0] * (T + 1) # Process each book for thickness, value in books: # Update dp array from right to left for i in range(T, thickness - 1, -1): dp[i] = max(dp[i], dp[i - thickness] + value) # Maximum value achievable at the maximum thickness T return dp[T]"},{"question":"def longest_unique_subarray(arr: List[int]) -> int: Returns the length of the longest contiguous subarray with all unique elements. >>> longest_unique_subarray([2, 3, 4, 5]) 4 >>> longest_unique_subarray([1, 2, 3, 1, 2, 3]) 3 >>> longest_unique_subarray([10, 20, 10, 30, 40, 50]) 5 >>> longest_unique_subarray([10, 10, 10, 10]) 1 >>> longest_unique_subarray([]) 0 >>> longest_unique_subarray([1]) 1 >>> longest_unique_subarray([1, 2, 3, 4, 5, 1, 2, 3, 4, 6]) 6","solution":"def longest_unique_subarray(arr): Returns the length of the longest contiguous subarray with all unique elements. n = len(arr) if n == 0: return 0 # To store the last index of every element in the array last_index = {} max_length = 0 start = 0 for end in range(n): if arr[end] in last_index: # Move the start pointer to the right of duplicate element's last index start = max(start, last_index[arr[end]] + 1) # Update the last index of the current element last_index[arr[end]] = end # Update the max length max_length = max(max_length, end - start + 1) return max_length"},{"question":"def minimum_trucks(weights, capacity): Returns the minimum number of trucks required to carry all packages without exceeding the capacity of any truck. Parameters: weights (list of int): List of weights of the packages. capacity (int): The maximum capacity of each truck. Returns: int: Minimum number of trucks required. Example: >>> minimum_trucks([2, 3, 7, 8, 4], 10) 3 >>> minimum_trucks([5], 10) 1","solution":"def minimum_trucks(weights, capacity): Returns the minimum number of trucks required to carry all packages without exceeding the capacity of any truck. Parameters: weights (list of int): List of weights of the packages. capacity (int): The maximum capacity of each truck. Returns: int: Minimum number of trucks required. # Sort weights in descending order to place heavier items first weights.sort(reverse=True) used_trucks = 0 while weights: current_capacity = capacity i = 0 while i < len(weights): if weights[i] <= current_capacity: current_capacity -= weights.pop(i) else: i += 1 used_trucks += 1 return used_trucks"},{"question":"def count_interesting_strings(N): Returns the number of interesting binary strings of length N. pass def solve(test_cases): Given a list of test cases, return a list containing the number of interesting binary strings for each test case. pass # Test cases to validate the solution from solution import count_interesting_strings, solve def test_count_interesting_strings(): assert count_interesting_strings(1) == 2 assert count_interesting_strings(2) == 3 assert count_interesting_strings(3) == 5 assert count_interesting_strings(4) == 8 assert count_interesting_strings(5) == 13 assert count_interesting_strings(6) == 21 assert count_interesting_strings(7) == 34 def test_solve(): assert solve([1, 2, 3]) == [2, 3, 5] assert solve([4, 5, 6]) == [8, 13, 21] assert solve([7, 8, 9]) == [34, 55, 89] assert solve([10, 11, 12]) == [144, 233, 377]","solution":"def count_interesting_strings(N): Returns the number of interesting binary strings of length N. if N == 1: return 2 elif N == 2: return 3 # For N >= 3, we use the recursive relation of the Fibonacci sequence a, b = 2, 3 for _ in range(3, N + 1): a, b = b, a + b return b def solve(test_cases): results = [] for N in test_cases: results.append(count_interesting_strings(N)) return results # Example of usage if __name__ == \\"__main__\\": # For example, let's take T test cases: T = 3 test_cases = [3, 4, 5] results = solve(test_cases) for res in results: print(res)"},{"question":"def longest_increasing_subsequence_with_limit(n: int, k: int, sequence: List[int]) -> int: Given a sequence of n integers and a limit k, find the length of the longest increasing subsequence where the difference between consecutive elements in the subsequence is at most k. >>> longest_increasing_subsequence_with_limit(5, 3, [1, 3, 5, 10, 12]) 3 >>> longest_increasing_subsequence_with_limit(6, 2, [1, 2, 3, 4, 5, 6]) 6 >>> longest_increasing_subsequence_with_limit(6, 1, [10, 20, 30, 40, 50, 60]) 1 import sys from typing import List def lis_within_limit(input_str: str) -> int: Parse input and call the function to find the longest increasing subsequence. >>> lis_within_limit('5 3n1 3 5 10 12') 3 >>> lis_within_limit('6 2n1 2 3 4 5 6') 6 >>> lis_within_limit('6 1n10 20 30 40 50 60') 1","solution":"def longest_increasing_subsequence_with_limit(n, k, sequence): # Initialize DP array where dp[i] represents the length of the LIS ending at index i dp = [1] * n # Populate the DP array for i in range(1, n): for j in range(i): if sequence[i] > sequence[j] and sequence[i] - sequence[j] <= k: dp[i] = max(dp[i], dp[j] + 1) # The length of the longest increasing subsequence is the maximum element in dp array return max(dp) # This function handles the input and output format and calls the solution function def lis_within_limit(input_str): input_lines = input_str.split('n') n, k = map(int, input_lines[0].split()) sequence = list(map(int, input_lines[1].split())) return longest_increasing_subsequence_with_limit(n, k, sequence)"},{"question":"def max_happiness_index(n: int, tokens: List[int]) -> int: Returns the maximum happiness index by rearranging the students with valid token swaps. >>> max_happiness_index(4, [5, 1, 4, 2]) == 4 >>> max_happiness_index(1, [10]) == 1 >>> max_happiness_index(5, [7, 7, 7, 7, 7]) == 5 >>> max_happiness_index(3, [10, 5, 1]) == 3 >>> max_happiness_index(3, [1, 2, 3]) == 3","solution":"def max_happiness_index(n, tokens): Returns the maximum happiness index by rearranging the students with valid token swaps. Args: n : int : number of students tokens : list : list of integers representing the number of tokens each student has Returns: int : maximum happiness index # Sorting the tokens list ensures the optimal lineup tokens.sort() # All students will be happy with their position since sorting puts each student behind those # with higher or equal number of tokens return n"},{"question":"def best_plan(plans): Returns the best plan based on the maximum download speed and minimum data limit if there are multiple plans with the same speed. Parameters: plans (list of tuples): A list where each tuple contains (data_limit, download_speed) Returns: tuple: The best plan as a tuple (data_limit, download_speed) pass # Unit Tests def test_single_plan(): plans = [(100, 200)] assert best_plan(plans) == (100, 200) def test_multiple_plans(): plans = [(100, 200), (50, 150), (100, 100)] assert best_plan(plans) == (100, 200) def test_best_plan_with_highest_speed(): plans = [(25, 50), (60, 100), (50, 100), (50, 150)] assert best_plan(plans) == (50, 150) def test_best_plan_with_same_speed(): plans = [(70, 100), (80, 100), (60, 100)] assert best_plan(plans) == (60, 100) def test_large_input(): plans = [(i, 1000) for i in range(1, 100001)] assert best_plan(plans) == (1, 1000)","solution":"def best_plan(plans): Returns the best plan based on the maximum download speed and minimum data limit if there are multiple plans with the same speed. Parameters: plans (list of tuples): A list where each tuple contains (data_limit, download_speed) Returns: tuple: The best plan as a tuple (data_limit, download_speed) best = None for data_limit, download_speed in plans: if best is None or download_speed > best[1] or (download_speed == best[1] and data_limit < best[0]): best = (data_limit, download_speed) return best"},{"question":"def max_equal_01_length(s: str) -> int: Finds the maximum length of a contiguous substring with equal number of '0's and '1's. :param s: str, a binary string :return: int, the maximum length of the substring >>> max_equal_01_length(\\"1100011110\\") 8 >>> max_equal_01_length(\\"000111\\") 6 >>> max_equal_01_length(\\"11110000\\") 8 >>> max_equal_01_length(\\"1111\\") 0 >>> max_equal_01_length(\\"1010101010\\") 10 >>> max_equal_01_length(\\"101\\") 2 >>> max_equal_01_length(\\"0\\") 0 >>> max_equal_01_length(\\"1\\") 0 >>> max_equal_01_length(\\"01\\") 2 >>> max_equal_01_length(\\"10\\") 2 >>> max_equal_01_length(\\"\\") 0","solution":"def max_equal_01_length(s): Finds the maximum length of a contiguous substring with equal number of '0's and '1's. :param s: str, a binary string :return: int, the maximum length of the substring n = len(s) count_map = {0: -1} max_length = 0 count = 0 for i in range(n): count += 1 if s[i] == '1' else -1 if count in count_map: max_length = max(max_length, i - count_map[count]) else: count_map[count] = i return max_length # Example usage: # N = 10 # S = \\"1100011110\\" # print(max_equal_01_length(S)) # Output: 8"},{"question":"def fibonacci(n: int) -> int: Calculates the nth Fibonacci number. If n is less than 0, returns 0. >>> fibonacci(-1) 0 >>> fibonacci(0) 0 >>> fibonacci(1) 1 >>> fibonacci(2) 1 >>> fibonacci(10) 55 >>> fibonacci(20) 6765","solution":"def fibonacci(n): Returns the nth Fibonacci number. If n is negative, returns 0. if n < 0: return 0 elif n == 0: return 0 elif n == 1: return 1 else: a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"def max_beauty_value_of_subarray(T, test_cases): Calculate the maximum possible beauty value of any subarray for each garden. Args: T (int): Number of test cases. test_cases (list of tuples): Each tuple contains an integer N and a list of N integers representing beauty values. Returns: list of int: The maximum possible beauty value of any subarray for each garden. Examples: >>> max_beauty_value_of_subarray(1, [(5, [-1, 2, 3, -2, 5])]) [8] >>> max_beauty_value_of_subarray(2, [(5, [-1, 2, 3, -2, 5]), (3, [-1, -2, -3])]) [8, -1] pass # Unit tests def test_single_test_case(): T = 1 test_cases = [(5, [-1, 2, 3, -2, 5])] assert max_beauty_value_of_subarray(T, test_cases) == [8] def test_multiple_test_cases(): T = 2 test_cases = [ (5, [-1, 2, 3, -2, 5]), (3, [-1, -2, -3]) ] assert max_beauty_value_of_subarray(T, test_cases) == [8, -1] def test_all_negative(): T = 1 test_cases = [(3, [-4, -1, -7])] assert max_beauty_value_of_subarray(T, test_cases) == [-1] def test_all_positive(): T = 1 test_cases = [(4, [1, 2, 3, 4])] assert max_beauty_value_of_subarray(T, test_cases) == [10] def test_mixed_values(): T = 1 test_cases = [(8, [4, -1, 2, 1, -5, 4, -3, 2])] assert max_beauty_value_of_subarray(T, test_cases) == [6]","solution":"def max_beauty_value_of_subarray(T, test_cases): results = [] for i in range(T): N, beauties = test_cases[i] current_max = total_max = beauties[0] for beauty in beauties[1:]: current_max = max(beauty, current_max + beauty) total_max = max(total_max, current_max) results.append(total_max) return results"},{"question":"import heapq def minimum_time_to_collect_crew(N, M, edges): Calculate the minimum amount of time required to bring all crew members back to the spaceship. :param N: Number of nodes :param M: Number of edges :param edges: List of tuples containing edges in the format (u, v, w) :return: Minimum time required Example: >>> minimum_time_to_collect_crew(4, 4, [(1, 2, 4), (1, 3, 2), (3, 4, 3), (2, 4, 5)]) 9 >>> minimum_time_to_collect_crew(1, 0, []) 0 >>> minimum_time_to_collect_crew(2, 1, [(1, 2, 1)]) 1","solution":"import heapq def minimum_time_to_collect_crew(N, M, edges): Calculate the minimum amount of time required to bring all crew members back to the spaceship. :param N: Number of nodes :param M: Number of edges :param edges: List of tuples containing edges in the format (u, v, w) :return: Minimum time required # Create an adjacency list adj = {i: [] for i in range(1, N+1)} for u, v, w in edges: adj[u].append((w, v)) adj[v].append((w, u)) # Prim's algorithm to find Minimum Spanning Tree min_heap = [(0, 1)] # (cost, node) visit = set() total_cost = 0 while len(visit) < N: cost, node = heapq.heappop(min_heap) if node not in visit: visit.add(node) total_cost += cost for next_cost, next_node in adj[node]: if next_node not in visit: heapq.heappush(min_heap, (next_cost, next_node)) return total_cost"},{"question":"def count_distinct_integers(n: int, arr: List[int]) -> int: Returns the number of distinct integers in the array. Parameters: n (int): Size of the array. (1 ≤ n ≤ 100) arr (List[int]): The array elements. (1 ≤ ai ≤ 100) Returns: int: The number of distinct elements in the array. >>> count_distinct_integers(5, [1, 2, 2, 3, 4]) 4 >>> count_distinct_integers(6, [5, 5, 5, 5, 5, 5]) 1 >>> count_distinct_integers(5, [1, 2, 3, 4, 5]) 5 >>> count_distinct_integers(4, [2, 2, 2, 2]) 1 >>> count_distinct_integers(1, [7]) 1 >>> count_distinct_integers(6, [1, 2, 1, 2, 1, 2]) 2","solution":"def count_distinct_integers(n, arr): Returns the number of distinct integers in the array. Parameters: n (int): Size of the array. arr (list of int): The array elements. Returns: int: The number of distinct elements in the array. return len(set(arr))"},{"question":"def sum_of_digits_in_string(s: str) -> int: Returns the sum of all digits present in the string s. If there are no digits, returns 0. >>> sum_of_digits_in_string(\\"abc123\\") 6 >>> sum_of_digits_in_string(\\"a1b2c3d\\") 6 >>> sum_of_digits_in_string(\\"abc\\") 0 >>> sum_of_digits_in_string(\\"123456789\\") 45 >>> sum_of_digits_in_string(\\"102030405060\\") 21 >>> sum_of_digits_in_string(\\"a1!@2#3%\\") 6 >>> sum_of_digits_in_string(\\"\\") 0 >>> sum_of_digits_in_string(\\"@@#\\") 0","solution":"def sum_of_digits_in_string(s): Returns the sum of all digits present in the string s. If there are no digits, returns 0. return sum(int(char) for char in s if char.isdigit())"},{"question":"def product_except_self(nums): Returns an array where each element is the product of every other element in the input array. >>> product_except_self([1, 2, 3, 4]) == [24, 12, 8, 6] >>> product_except_self([2, 3, 4, 5]) == [60, 40, 30, 24] >>> product_except_self([1, 2, 0, 4]) == [0, 0, 8, 0] >>> product_except_self([0, 0, 0]) == [0, 0, 0] >>> product_except_self([10, 3, 5, 6, 2]) == [180, 600, 360, 300, 900] >>> product_except_self([]) == [] >>> product_except_self([1]) == [1]","solution":"def product_except_self(nums): Returns an array where each element is the product of every other element in the input array. n = len(nums) if n == 0: return [] left_products = [1] * n right_products = [1] * n result = [1] * n for i in range(1, n): left_products[i] = left_products[i - 1] * nums[i - 1] for i in range(n - 2, -1, -1): right_products[i] = right_products[i + 1] * nums[i + 1] for i in range(n): result[i] = left_products[i] * right_products[i] return result"},{"question":"def sum_of_cubes(k: int) -> int: Returns the sum of the first k cube numbers. Parameters: k (int): A non-negative integer (0 ≤ k ≤ 100) Returns: int: The sum of cubes from 1^3 to k^3 >>> sum_of_cubes(3) 36 >>> sum_of_cubes(5) 225","solution":"def sum_of_cubes(k): Returns the sum of the first k cube numbers. Parameters: k (int): A non-negative integer (0 ≤ k ≤ 100) Returns: int: The sum of cubes from 1^3 to k^3 # The formula for the sum of the first k cube numbers is (k * (k + 1) / 2)^2 return int((k * (k + 1) / 2) ** 2)"},{"question":"def is_valid_tag(given_string: str) -> bool: Determine if the given string can be permuted to form a palindrome. Args: given_string (str): A string of uppercase letters and numbers. Returns: bool: True if the string can be permuted to form a palindrome, False otherwise. Examples: >>> is_valid_tag(\\"AABB\\") True >>> is_valid_tag(\\"XYYX\\") True >>> is_valid_tag(\\"ABCDEFG\\") False","solution":"def is_valid_tag(given_string): from collections import Counter count = Counter(given_string) odd_count = sum(1 for v in count.values() if v % 2 != 0) return odd_count <= 1"},{"question":"def longest_palindromic_sequence(grid): Find the longest sequence of characters that spell the same both forwards and backwards (a palindromic sequence) when traversed in a straight line either horizontally or vertically in the given grid of characters. >>> longest_palindromic_sequence([ ... ['a', 'b', 'c', 'b', 'a'], ... ['d', 'e', 'a', 'e', 'd'], ... ['l', 'm', 'n', 'm', 'l'], ... ['o', 'p', 'q', 'r', 's'] ... ]) == \\"abcba\\" >>> longest_palindromic_sequence([ ... ['h', 'e', 'l', 'l', 'o'], ... ['l', 'e', 'v', 'e', 'l'], ... ['w', 'o', 'r', 'l', 'd'] ... ]) == \\"level\\"","solution":"def longest_palindromic_sequence(grid): def is_palindrome(s): return s == s[::-1] def find_longest_palindrome(seq): n = len(seq) max_palindrome = \\"\\" for start in range(n): for end in range(start + 1, n + 1): substring = seq[start:end] if is_palindrome(substring) and len(substring) > len(max_palindrome): max_palindrome = substring return max_palindrome longest = \\"\\" # Check each row (horizontal) for row in grid: row_str = ''.join(row) candidate = find_longest_palindrome(row_str) if len(candidate) > len(longest) or (len(candidate) == len(longest) and candidate < longest): longest = candidate # Check each column (vertical) if grid: num_cols = len(grid[0]) num_rows = len(grid) for col in range(num_cols): col_str = ''.join(grid[row][col] for row in range(num_rows)) candidate = find_longest_palindrome(col_str) if len(candidate) > len(longest) or (len(candidate) == len(longest) and candidate < longest): longest = candidate return longest"},{"question":"def matches_pattern(queries: List[str], pattern: str) -> List[bool]: Determine if the pattern matches each string query using special characters: '?' matches any single character. '*' matches any sequence of characters, including an empty sequence. >>> matches_pattern([\\"abc\\", \\"aabc\\", \\"ab\\"], \\"a*bc\\") [True, True, False] >>> matches_pattern([\\"catdog\\", \\"batdogs\\", \\"atdog\\", \\"batcatdog\\"], \\"?at*dog\\") [True, False, False, True]","solution":"import re def matches_pattern(queries, pattern): Given a list of queries and a pattern, return a list where each element is True if the respective query matches the pattern, and False otherwise. # Convert the pattern to a regular expression pattern = pattern.replace('?', '.').replace('*', '.*') pattern = f\\"^{pattern}\\" results = [] for query in queries: if re.match(pattern, query): results.append(True) else: results.append(False) return results"},{"question":"def rearrangePalindrome(s: str) -> str: Given a string s consisting of lowercase English alphabets, check if the string can be rearranged to form a palindrome. If it can, return any one of the possible palindrome strings. If it cannot, return an empty string. Example 1: >>> rearrangePalindrome(\\"aabb\\") \\"abba\\" Example 2: >>> rearrangePalindrome(\\"abc\\") \\"\\"","solution":"def rearrangePalindrome(s): from collections import Counter counts = Counter(s) odd_counts = sum(1 for count in counts.values() if count % 2 != 0) if odd_counts > 1: return \\"\\" half_palindrome = [] middle_char = \\"\\" for char, count in counts.items(): if count % 2 == 0: half_palindrome.append(char * (count // 2)) else: half_palindrome.append(char * (count // 2)) middle_char = char half_palindrome = ''.join(half_palindrome) return half_palindrome + middle_char + half_palindrome[::-1]"},{"question":"def findLongestConseqSubseq(arr): Given an array of integers, find the length of the longest sub-array with elements that form a contiguous sequence. >>> findLongestConseqSubseq([1, 9, 3, 10, 4, 20, 2]) 4 >>> findLongestConseqSubseq([8, 1, 2, 5]) 2","solution":"def findLongestConseqSubseq(arr): Returns the length of the longest contiguous sub-array in arr. Parameters: arr (list): A list of integers Returns: int: Length of the longest contiguous sub-array unique_elements = set(arr) max_length = 0 for num in unique_elements: if num - 1 not in unique_elements: # start of a new sequence current_num = num current_streak = 1 while current_num + 1 in unique_elements: current_num += 1 current_streak += 1 max_length = max(max_length, current_streak) return max_length"},{"question":"def max_advertisements(T: int, test_cases: List[Dict[str, Any]]) -> List[int]: Calculate the maximum number of advertisements that can be displayed on the billboards. >>> max_advertisements(2, [{'L': 2, 'M': 3, 'ads': [(1, 5, 1), (2, 6, 1), (3, 9, 2)]}, {'L': 1, 'M': 4, 'ads': [(5, 9, 1), (12, 15, 1), (9, 16, 1), (17, 20, 1)]}]) [2, 3]","solution":"def max_advertisements(T, test_cases): results = [] for case in test_cases: L = case['L'] M = case['M'] ads = case['ads'] # Create schedules for each billboard billboards = [[] for _ in range(L)] for ad in ads: billboards[ad[2] - 1].append((ad[0], ad[1])) def max_non_overlapping(intervals): Helper function to return the maximum number of non-overlapping intervals. intervals.sort(key=lambda x: x[1]) # Sort by end time count, last_end = 0, -1 for start, end in intervals: if start >= last_end: count += 1 last_end = end return count total_ads = 0 for billboard in billboards: total_ads += max_non_overlapping(billboard) results.append(total_ads) return results"},{"question":"def sort_with_duplicates(lst: List[int]) -> List[int]: Returns a new list with the integers sorted in non-decreasing order. If there are duplicates, they are moved to the end of the list in the order of their first occurrence. >>> sort_with_duplicates([4, 3, 2, 1, 3, 2]) [1, 4, 3, 2, 3, 2] >>> sort_with_duplicates([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> sort_with_duplicates([5, 1, 5, 2, 3, 4]) [1, 2, 3, 4, 5, 5] >>> sort_with_duplicates([4, 4, 4, 4]) [4, 4, 4, 4]","solution":"def sort_with_duplicates(lst): Returns a new list with the integers sorted in non-decreasing order. If there are duplicates, they are moved to the end of the list in the order of their first occurrence. from collections import Counter # Get the counts of each element counts = Counter(lst) # List for unique elements unique_elements = [item for item in lst if counts[item] == 1] # List for duplicate elements in their first occurrence order duplicates = [item for item in lst if counts[item] > 1] # Sort the unique elements in non-decreasing order unique_elements_sorted = sorted(unique_elements) # Combine the sorted unique elements with the duplicates return unique_elements_sorted + duplicates"},{"question":"def unique_paths_with_obstacles(N, M, obstacles): Compute the number of unique paths for a robot to move from (0, 0) to (N-1, N-1) on a grid, avoiding obstacles. >>> unique_paths_with_obstacles(3, 0, []) 6 >>> unique_paths_with_obstacles(3, 1, [(1, 1)]) 2 >>> unique_paths_with_obstacles(3, 1, [(0, 0)]) 0 >>> unique_paths_with_obstacles(3, 1, [(2, 2)]) 0 >>> unique_paths_with_obstacles(2, 0, []) 2 >>> unique_paths_with_obstacles(4, 0, []) 20 >>> unique_paths_with_obstacles(3, 2, [(1, 1), (1, 0)]) 1 >>> unique_paths_with_obstacles(3, 3, [(1, 1), (1, 0), (0, 1)]) 0","solution":"def unique_paths_with_obstacles(N, M, obstacles): MOD = 10**9 + 7 # Create a grid with given obstacles grid = [[0] * N for _ in range(N)] for r, c in obstacles: grid[r][c] = -1 # Initialize the grid's dp array dp = [[0] * N for _ in range(N)] # Starting position if grid[0][0] == -1: return 0 dp[0][0] = 1 # Fill the dp array for i in range(N): for j in range(N): if grid[i][j] == -1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] dp[i][j] %= MOD return dp[N-1][N-1] # Example input: N = 3 M = 1 obstacles = [(1, 1)] print(unique_paths_with_obstacles(N, M, obstacles)) # Output should be 2"},{"question":"def min_seconds_to_alternate(n: int, s: str) -> int: Determine the minimum number of seconds required to make the string alternating. Args: n (int): The length of the string. s (str): The string consisting of characters 'A' and 'B'. Returns: int: The minimum number of seconds required to make the string alternating. Examples: >>> min_seconds_to_alternate(5, \\"ABBAB\\") 2 >>> min_seconds_to_alternate(4, \\"AAAA\\") 2","solution":"def min_seconds_to_alternate(n, s): Returns the minimum number of seconds required to make the string alternating. alt1 = ''.join('A' if i % 2 == 0 else 'B' for i in range(n)) alt2 = ''.join('B' if i % 2 == 0 else 'A' for i in range(n)) changes_for_alt1 = sum(1 for i in range(n) if s[i] != alt1[i]) changes_for_alt2 = sum(1 for i in range(n) if s[i] != alt2[i]) return min(changes_for_alt1, changes_for_alt2)"},{"question":"def sort_robots(n: int, heights: List[str]) -> List[str]: Sorts the robots' heights such that all \\"short\\" robots come before \\"medium\\" robots, and all \\"medium\\" robots come before \\"tall\\" robots, while maintaining the relative order within the same height group. >>> sort_robots(6, [\\"medium\\", \\"short\\", \\"tall\\", \\"short\\", \\"medium\\", \\"tall\\"]) [\\"short\\", \\"short\\", \\"medium\\", \\"medium\\", \\"tall\\", \\"tall\\"] >>> sort_robots(3, [\\"tall\\", \\"short\\", \\"medium\\"]) [\\"short\\", \\"medium\\", \\"tall\\"] >>> sort_robots(5, [\\"short\\", \\"short\\", \\"medium\\", \\"medium\\", \\"tall\\"]) [\\"short\\", \\"short\\", \\"medium\\", \\"medium\\", \\"tall\\"]","solution":"def sort_robots(n, heights): Sorts the robots' heights such that all \\"short\\" robots come before \\"medium\\" robots, and all \\"medium\\" robots come before \\"tall\\" robots, while maintaining the relative order within the same height group. height_order = {\\"short\\": 0, \\"medium\\": 1, \\"tall\\": 2} sorted_heights = sorted(heights, key=lambda x: height_order[x]) return sorted_heights"},{"question":"def min_removals_to_decreasing_wall(n, heights): This function finds the minimum number of bricks to be removed to ensure the wall is consistently decreasing in height from left to right. Parameters: n (int): The number of sections in the wall. heights (List[int]): A list of heights of sections of the wall. Returns: int: The minimum number of bricks to be removed. >>> min_removals_to_decreasing_wall(6, [5, 3, 8, 6, 2, 9]) 3 >>> min_removals_to_decreasing_wall(5, [3, 1, 4, 2, 5]) 3 >>> min_removals_to_decreasing_wall(7, [9, 8, 7, 6, 5, 4, 3]) 0 >>> min_removals_to_decreasing_wall(4, [1, 2, 3, 4]) 3 >>> min_removals_to_decreasing_wall(5, [5, 4, 4, 4, 3]) 2","solution":"def min_removals_to_decreasing_wall(n, heights): This function finds the minimum number of bricks to be removed to ensure the wall is consistently decreasing in height from left to right. Parameters: n (int): The number of sections in the wall. heights (List[int]): A list of heights of sections of the wall. Returns: int: The minimum number of bricks to be removed. lis = [] for height in heights: pos = lower_bound(lis, height) if pos == len(lis): lis.append(height) else: lis[pos] = height return n - len(lis) def lower_bound(arr, x): Helper function to find the lower bound of x in arr. Parameters: arr (List[int]): The list in which to find lower bound for x. x (int): The value to find lower bound for. Returns: int: The lower bound index of x in arr. lo, hi = 0, len(arr) while lo < hi: mid = (lo + hi) // 2 if arr[mid] <= x: hi = mid else: lo = mid + 1 return lo"},{"question":"def decode_secret_message(N: int, encoded_sequence: List[int]) -> List[int]: Given an encoded sequence of sums of subsets of an original array A, find the original array A. Parameters: N (int): The number of elements in the original array. encoded_sequence (List[int]): A list of integers representing the encoded sequence. Returns: List[int]: A list of integers representing the original array A. Examples: >>> decode_secret_message(2, [1, 2, 3]) [1, 2] >>> decode_secret_message(3, [1, 2, 3, 4, 5, 6, 7]) [1, 2, 4] from typing import List def test_example_1(): assert decode_secret_message(2, [1, 2, 3]) == [1, 2] def test_example_2(): assert decode_secret_message(3, [1, 2, 3, 4, 5, 6, 7]) == [1, 2, 4] def test_single_element(): assert decode_secret_message(1, [3]) == [3] def test_three_elements(): assert decode_secret_message(3, [1, 2, 3, 4, 5, 6, 7]) == [1, 2, 4] def test_four_elements(): assert decode_secret_message(4, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]) == [1, 2, 4, 8] def test_varied_elements(): assert decode_secret_message(3, [3, 5, 7, 8, 10, 12, 15]) == [3, 5, 7]","solution":"def decode_secret_message(N, encoded_sequence): Given an encoded sequence of sums of subsets of an original array A, Find the original array A. import itertools all_sums = sorted(encoded_sequence) original_array = [all_sums[0]] all_sums = all_sums[1:] # Remove the first element which is the smallest for _ in range(1, N): current_sum = all_sums[0] original_array.append(current_sum) new_all_sums = [] current_set_sums = set() for subset in itertools.chain.from_iterable(itertools.combinations(original_array, r) for r in range(1, len(original_array) + 1)): current_set_sums.add(sum(subset)) for sum_value in all_sums: if sum_value not in current_set_sums: new_all_sums.append(sum_value) all_sums = new_all_sums return original_array"},{"question":"def group_by_activity(preferences): Groups people by their preferred activities. >>> preferences = {\\"Alice\\": [\\"hiking\\", \\"swimming\\"], \\"Bob\\": [\\"swimming\\", \\"cycling\\"], \\"Charlie\\": [\\"hiking\\", \\"cycling\\", \\"swimming\\"]} >>> group_by_activity(preferences) {\\"hiking\\": [\\"Alice\\", \\"Charlie\\"], \\"swimming\\": [\\"Alice\\", \\"Bob\\", \\"Charlie\\"], \\"cycling\\": [\\"Bob\\", \\"Charlie\\"]} >>> preferences = {\\"Alice\\": [\\"hiking\\", \\"swimming\\"]} >>> group_by_activity(preferences) {\\"hiking\\": [\\"Alice\\"], \\"swimming\\": [\\"Alice\\"]} >>> preferences = {\\"Alice\\": [\\"cycling\\"], \\"Bob\\": [\\"cycling\\"], \\"Charlie\\": [\\"cycling\\"]} >>> group_by_activity(preferences) {\\"cycling\\": [\\"Alice\\", \\"Bob\\", \\"Charlie\\"]} >>> preferences = {} >>> group_by_activity(preferences) {} >>> preferences = {\\"Alice\\": [\\"hiking\\"], \\"Bob\\": [\\"hiking\\"], \\"Charlie\\": [\\"hiking\\"]} >>> group_by_activity(preferences) {\\"hiking\\": [\\"Alice\\", \\"Bob\\", \\"Charlie\\"]}","solution":"def group_by_activity(preferences): Groups people by their preferred activities. Args: preferences (dict): A dictionary where keys are people's names and values are lists of their preferred activities. Returns: dict: A dictionary where keys are activities and values are lists of people who prefer those activities. activity_dict = {} for person, activities in preferences.items(): for activity in activities: if activity not in activity_dict: activity_dict[activity] = [] activity_dict[activity].append(person) return activity_dict"},{"question":"def compress_string(inputString: str) -> str: Compress the given string using the counts of repeated characters. If the compressed string is not shorter, return the original string. Args: inputString (str): The string to be compressed. Returns: str: The compressed string or the original string if compression is not shorter. Examples: >>> compress_string(\\"aabcccccaaa\\") 'a2b1c5a3' >>> compress_string(\\"abc\\") 'abc'","solution":"def compress_string(inputString: str) -> str: if not inputString: return inputString compressed = [] count = 1 prev_char = inputString[0] for i in range(1, len(inputString)): if inputString[i] == prev_char: count += 1 else: compressed.append(f\\"{prev_char}{count}\\") prev_char = inputString[i] count = 1 compressed.append(f\\"{prev_char}{count}\\") compressed_string = \\"\\".join(compressed) if len(compressed_string) >= len(inputString): return inputString return compressed_string"},{"question":"def length_of_last_word(s: str) -> int: Returns the length of the last word in the string s. A word is defined as a maximal substring consisting of non-space characters only. >>> length_of_last_word(\\"Hello World\\") 5 >>> length_of_last_word(\\" \\") 0 >>> length_of_last_word(\\"Hello \\") 5 >>> length_of_last_word(\\"Python\\") 6 >>> length_of_last_word(\\"Leading and trailing \\") 8 >>> length_of_last_word(\\"a b \\") 1 >>> length_of_last_word(\\"This is a test of the function\\") 8 >>> length_of_last_word(\\"Hello, World!\\") 6 >>> length_of_last_word(\\"\\") 0","solution":"def length_of_last_word(s): Returns the length of the last word in the string s. A word is defined as a maximal substring consisting of non-space characters only. # Strip any trailing spaces and split the string into words words = s.strip().split() # If there are no words, return 0 if not words: return 0 # Return the length of the last word return len(words[-1])"},{"question":"def largest_square_side_length(n: int, points: List[Tuple[int, int]]) -> int: Determine the largest possible side length of a square that can be formed using the given points as vertices. Parameters: n (int): The number of points provided. points (List[Tuple[int, int]]): A list of tuples where each tuple contains two integers representing the coordinates of a point. Returns: int: The largest possible side length of the square that can be formed using the given points, or 0 if no such square can be formed. >>> largest_square_side_length(5, [(1, 1), (1, 4), (4, 1), (4, 4), (2, 2)]) 3 >>> largest_square_side_length(4, [(0, 0), (0, 1), (1, 0), (2, 2)]) 0 >>> largest_square_side_length(4, [(0, 0), (0, 1000000), (1000000, 0), (1000000, 1000000)]) 1000000 >>> largest_square_side_length(4, [(0, 0), (0, 1), (1, 0), (1, 1)]) 1 >>> largest_square_side_length(6, [(0, 0), (0, 2), (2, 0), (2, 2), (1, 1), (3, 3)]) 2","solution":"def largest_square_side_length(n, points): point_set = set(points) max_side_length = 0 for i in range(n): for j in range(i + 1, n): x1, y1 = points[i] x2, y2 = points[j] if x1 != x2 and y1 != y2: if (x1, y2) in point_set and (x2, y1) in point_set: side_length = abs(x1 - x2) max_side_length = max(max_side_length, side_length) return max_side_length"},{"question":"from typing import List, Tuple def analyze_neural_network(n: int, m: int, connections: List[Tuple[int, int, int]], q: int, queries: List[Tuple[int, int]]) -> List[str]: Analyze neural networks to determine if a layer y can be reached from layer x and calculate the total weight of the path if it exists. Args: n: Number of layers in the neural network. m: Number of connections between layers. connections: List of tuples where each tuple contains three integers, representing a directed connection from layer u to layer v with weight w. q: Number of queries. queries: List of tuples where each tuple contains two integers x and y, representing a query asking if there is a way to reach layer y from layer x, and the total weight of the shortest path if it exists. Returns: A list of strings where each string is \\"YES [total weight]\\" if there is a path from x to y, otherwise \\"NO\\". >>> analyze_neural_network(6, 7, [(1, 2, 4), (1, 3, 2), (2, 4, 3), (3, 4, 1), (4, 5, 5), (5, 6, 6), (3, 6, 10)], 3, [(1, 6), (4, 5), (2, 3)]) [\\"YES 18\\", \\"YES 5\\", \\"NO\\"] >>> analyze_neural_network(3, 2, [(1, 2, 3), (2, 3, 4)], 1, [(3, 1)]) [\\"NO\\"] >>> analyze_neural_network(3, 3, [(1, 2, 1), (2, 3, 1), (1, 3, 2)], 2, [(1, 3), (1, 2)]) [\\"YES 2\\", \\"YES 1\\"] >>> analyze_neural_network(3, 3, [(1, 2, 1), (2, 3, 1), (1, 3, 2)], 2, [(1, 1), (2, 2)]) [\\"YES 0\\", \\"YES 0\\"] pass","solution":"import heapq def analyze_neural_network(n, m, connections, q, queries): # Create graph graph = {i: [] for i in range(1, n+1)} for u, v, w in connections: graph[u].append((v, w)) # Define a function to find shortest path using Dijkstra's algorithm def dijkstra(start): distances = {i: float('inf') for i in range(1, n+1)} distances[start] = 0 priority_queue = [(0, start)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances # Handle each query results = [] for x, y in queries: distances_from_x = dijkstra(x) if distances_from_x[y] < float('inf'): results.append(f\\"YES {distances_from_x[y]}\\") else: results.append(\\"NO\\") return results"},{"question":"def does_stay_within_grid(n, m, s): Determine if the character stays within the boundaries of the grid after executing each command in the sequence. Parameters: n (int): Number of rows in the grid. m (int): Number of columns in the grid. s (str): Sequence of commands. Returns: str: \\"YES\\" if the character stays within the grid for the entire sequence, \\"NO\\" otherwise. Examples: >>> does_stay_within_grid(3, 3, \\"RRDLL\\") 'YES' >>> does_stay_within_grid(2, 2, \\"RRDD\\") 'NO' >>> does_stay_within_grid(4, 4, \\"UUDLDRLR\\") 'NO' # Your code here def main(): t = int(input().strip()) results = [] for _ in range(t): n, m = map(int, input().strip().split()) s = input().strip() result = does_stay_within_grid(n, m, s) results.append(result) for result in results: print(result) if __name__ == \\"__main__\\": main()","solution":"def does_stay_within_grid(n, m, s): Determine if the character stays within the boundaries of the grid after executing each command in the sequence. Parameters: n (int): Number of rows in the grid. m (int): Number of columns in the grid. s (str): Sequence of commands. Returns: str: \\"YES\\" if the character stays within the grid for the entire sequence, \\"NO\\" otherwise. x, y = 1, 1 for command in s: if command == 'U': x -= 1 elif command == 'D': x += 1 elif command == 'L': y -= 1 elif command == 'R': y += 1 if x < 1 or x > n or y < 1 or y > m: return \\"NO\\" return \\"YES\\" def main(): t = int(input().strip()) results = [] for _ in range(t): n, m = map(int, input().strip().split()) s = input().strip() result = does_stay_within_grid(n, m, s) results.append(result) for result in results: print(result) if __name__ == \\"__main__\\": main()"},{"question":"def abbreviate(words: List[str]) -> str: Takes a list of strings and returns an abbreviation made up of the first letter of each string, converted to uppercase. >>> abbreviate([\\"global\\", \\"positioning\\", \\"system\\"]) 'GPS' >>> abbreviate([\\"central\\", \\"processing\\", \\"unit\\"]) 'CPU' >>> abbreviate([\\"random\\", \\"access\\", \\"memory\\"]) 'RAM' >>> abbreviate([\\"north\\", \\"atlantic\\", \\"treaty\\", \\"organization\\"]) 'NATO'","solution":"def abbreviate(words): Takes a list of strings and returns an abbreviation made up of the first letter of each string, converted to uppercase. return ''.join(word[0].upper() for word in words)"},{"question":"def allCharactersEven(s: str) -> int: Returns 1 if all characters in string s are present even times, otherwise returns 0. Example: >>> allCharactersEven(\\"aabbcc\\") 1 >>> allCharactersEven(\\"aabbccddc\\") 0","solution":"def allCharactersEven(s): Returns 1 if all characters in string s are present even times, otherwise returns 0. from collections import Counter char_count = Counter(s) for count in char_count.values(): if count % 2 != 0: return 0 return 1"},{"question":"def reorder_list(lst): Reorganizes the list such that all negative integers appear first, followed by all non-negative integers while preserving their relative order. >>> reorder_list([-1, 2, -3, 4, 5]) [-1, -3, 2, 4, 5] >>> reorder_list([0, -1, 3, -4, -2, 2]) [-1, -4, -2, 0, 3, 2] >>> reorder_list([7, -6, 5, -4, 3, -2, 1]) [-6, -4, -2, 7, 5, 3, 1] >>> reorder_list([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> reorder_list([-1, -2, -3, -4, -5]) [-1, -2, -3, -4, -5] >>> reorder_list([-1, 2, -2, -3, 0, 1, 5]) [-1, -2, -3, 2, 0, 1, 5] >>> reorder_list([5]) [5] >>> reorder_list([-5]) [-5]","solution":"def reorder_list(lst): Reorganizes the list such that all negative integers appear first, followed by all non-negative integers while preserving their relative order. negatives = [x for x in lst if x < 0] non_negatives = [x for x in lst if x >= 0] return negatives + non_negatives"},{"question":"def calculate_bonus(score): Calculates the bonus based on the employee's score. Args: - score (int): The performance score of the employee. Returns: - int: The bonus amount. pass def process_scores(scores): Processes a list of scores and returns the corresponding bonuses. Args: - scores (list of int): A list of employee performance scores. Returns: - list of int: A list of bonuses corresponding to the scores. pass # Example usage: # Suppose the scores are [95, 70, 45], the output should be [1000, 250, 0] # print(process_scores([95, 70, 45])) from solution import calculate_bonus, process_scores def test_calculate_bonus(): assert calculate_bonus(95) == 1000 assert calculate_bonus(70) == 250 assert calculate_bonus(45) == 0 assert calculate_bonus(89) == 500 assert calculate_bonus(50) == 250 assert calculate_bonus(100) == 1000 assert calculate_bonus(74) == 250 assert calculate_bonus(0) == 0 def test_process_scores(): assert process_scores([95, 70, 45]) == [1000, 250, 0] assert process_scores([0, 50, 75, 90]) == [0, 250, 500, 1000] assert process_scores([89, 49, 100, 74]) == [500, 0, 1000, 250] def test_edge_cases(): assert process_scores([49, 50, 74, 75, 89, 90]) == [0, 250, 250, 500, 500, 1000] assert calculate_bonus(0) == 0 assert calculate_bonus(100) == 1000","solution":"def calculate_bonus(score): Calculates the bonus based on the employee's score. Args: - score (int): The performance score of the employee. Returns: - int: The bonus amount. if 90 <= score <= 100: return 1000 elif 75 <= score <= 89: return 500 elif 50 <= score <= 74: return 250 else: return 0 def process_scores(scores): Processes a list of scores and returns the corresponding bonuses. Args: - scores (list of int): A list of employee performance scores. Returns: - list of int: A list of bonuses corresponding to the scores. return [calculate_bonus(score) for score in scores]"},{"question":"def isKeithNumber(K: int) -> int: Checks if a given positive integer K is a Keith number. Parameters: K (int): The number to be checked. Returns: int: 1 if K is a Keith number, otherwise 0. >>> isKeithNumber(197) 1 >>> isKeithNumber(200) 0 >>> isKeithNumber(14) 1 >>> isKeithNumber(10) 0 >>> isKeithNumber(999999) 0 >>> isKeithNumber(742) 1 >>> isKeithNumber(500) 0 >>> isKeithNumber(1537) 1","solution":"def isKeithNumber(K): Checks if a given positive integer K is a Keith number. Parameters: K (int): The number to be checked. Returns: int: 1 if K is a Keith number, otherwise 0. # Convert the number to a list of its digits digits = [int(d) for d in str(K)] n = len(digits) # Generate the Keith number sequence while True: next_term = sum(digits) if next_term == K: return 1 elif next_term > K: return 0 # Update the sequence digits.append(next_term) digits.pop(0)"},{"question":"def nth_progressive_product_term(n: int) -> int: Compute the nth term of the progressive product series. The progressive product series is defined by multiplying the first n prime numbers. >>> nth_progressive_product_term(1) 2 >>> nth_progressive_product_term(3) 30 >>> nth_progressive_product_term(4) 210","solution":"def nth_progressive_product_term(n): Returns the nth term of the progressive product series. def is_prime(num): if num < 2: return False for i in range(2, int(num**0.5) + 1): if num % i == 0: return False return True prime_numbers = [] current_num = 2 while len(prime_numbers) < n: if is_prime(current_num): prime_numbers.append(current_num) current_num += 1 product = 1 for prime in prime_numbers: product *= prime return product"},{"question":"def min_operations_to_make_blocks_uniform(n: int, blocks: str) -> int: Returns the minimum number of operations required to make all blocks the same color. >>> min_operations_to_make_blocks_uniform(5, \\"RRBRB\\") 2 >>> min_operations_to_make_blocks_uniform(6, \\"RBBBBR\\") 1","solution":"def min_operations_to_make_blocks_uniform(n, blocks): Returns the minimum number of operations required to make all blocks the same color. # Count the number of contiguous segments of 'R' and 'B' if n == 0: return 0 red_segments = 0 blue_segments = 0 current_color = blocks[0] if current_color == 'R': red_segments += 1 else: blue_segments += 1 for i in range(1, n): if blocks[i] != current_color: current_color = blocks[i] if current_color == 'R': red_segments += 1 else: blue_segments += 1 # The number of operations needed is the minimum of red_segments and blue_segments return min(red_segments, blue_segments)"},{"question":"def sum_of_unique(nums: List[int]) -> int: Given a large list of integers, returns the sum of all unique elements. If an element appears more than once in the list, it should not contribute to the sum. >>> sum_of_unique([1, 2, 3, 2, 1]) == 3 >>> sum_of_unique([4, 5, 6, 7, 7, 6]) == 9 >>> sum_of_unique([10, 20, 30, 40]) == 100 >>> sum_of_unique([2, 2, 3, 3, 4, 4, 5, 5]) == 0","solution":"def sum_of_unique(nums): Returns the sum of all unique integers in the list. from collections import Counter # Count the frequency of each element in nums count = Counter(nums) # Sum all elements that appear exactly once unique_sum = sum(num for num in count if count[num] == 1) return unique_sum"},{"question":"def max_gold(n: int, grid: List[List[int]]) -> int: Determine the maximum amount of gold the creature can collect when it starts at the top-left cell and ends at the bottom-right cell. >>> max_gold(3, [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ]) 29 >>> max_gold(2, [ [5, 1], [2, 3] ]) 10","solution":"def max_gold(n, grid): # Initialize a dp table with the same structure as the grid dp = [[0] * n for _ in range(n)] # Start from the top-left corner of the grid dp[0][0] = grid[0][0] # Fill the first row for j in range(1, n): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column for i in range(1, n): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp table for i in range(1, n): for j in range(1, n): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] # The final cell contains the maximum gold collected return dp[-1][-1]"},{"question":"from typing import List def rob(nums: List[int]) -> int: Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police. Each house in the list is arranged linearly, and adjacent houses have security systems connected, so if two adjacent houses are broken into on the same night, the police will be alerted. Example 1: >>> rob([2, 3, 2]) 3 Example 2: >>> rob([1, 2, 3, 1]) 4 Example 3: >>> rob([0]) 0 Constraints: 0 <= nums.length <= 100 0 <= nums[i] <= 400","solution":"def rob(nums): Returns the maximum amount of money that can be robbed without alerting the police. Each house has a connected security system, so two adjacent houses cannot be robbed. if not nums: return 0 if len(nums) == 1: return nums[0] if len(nums) == 2: return max(nums) def rob_line(houses): prev1, prev2 = 0, 0 for house in houses: temp = prev1 prev1 = max(prev2 + house, prev1) prev2 = temp return prev1 # Either we rob houses from 0 to n-2 or from 1 to n-1 return max(rob_line(nums[:-1]), rob_line(nums[1:]))"},{"question":"def longest_common_prefix(strs): Determines the longest common prefix amongst a list of strings. If no common prefix exists, returns \\"No common prefix\\". Args: strs (List[str]): List of badge IDs. Returns: str: Longest common prefix or \\"No common prefix\\" if none exists. Example: >>> longest_common_prefix([\\"participant1\\", \\"partnership\\", \\"party\\", \\"particular\\"]) 'part' >>> longest_common_prefix([\\"badge123\\", \\"badge456\\", \\"badge789\\"]) 'badge' >>> longest_common_prefix([\\"abc\\", \\"xyz\\", \\"123\\"]) 'No common prefix'","solution":"def longest_common_prefix(strs): Determines the longest common prefix amongst a list of strings. If no common prefix exists, returns \\"No common prefix\\". if not strs: return \\"No common prefix\\" # Sort the array, the common prefix of the whole array lies in between the first and the last string strs.sort() first = strs[0] last = strs[-1] lcp_length = min(len(first), len(last)) for i in range(lcp_length): if first[i] != last[i]: if i == 0: return \\"No common prefix\\" return first[:i] return first[:lcp_length] # Example usage: # n = 4 # strings = [\\"participant1\\", \\"partnership\\", \\"party\\", \\"particular\\"] # print(longest_common_prefix(strings)) # Outputs \\"part\\""},{"question":"def max_items(N: int, L: int, points: List[int]) -> int: Determine the maximum number of items a participant can collect without the total points exceeding the limit. Args: N (int): the number of items. L (int): the maximum allowable points a participant can collect. points (List[int]): the point values of the items. Returns: int: the maximum number of items a participant can collect. Examples: >>> max_items(5, 10, [1, 2, 3, 8, 5]) 3 >>> max_items(6, 15, [5, 7, 6, 1, 4, 3]) 4 >>> max_items(3, 7, [2, 3, 6]) 2","solution":"def max_items(N, L, points): Returns the maximum number of items that can be collected without exceeding the limit L. points.sort() total_points = 0 item_count = 0 for point in points: if total_points + point <= L: total_points += point item_count += 1 else: break return item_count # Example usage: # N, L = 5, 10 # points = [1, 2, 3, 8, 5] # print(max_items(N, L, points)) # Output: 3"},{"question":"from typing import List, Tuple def max_warehouse_value(T: int, test_cases: List[Tuple[int, int, List[Tuple[int, int]]]]) -> List[int]: Determine the maximum value of the items that can be stored in the warehouse. Each test case contains the capacity of the warehouse (C) and the number of items (N). Each item has a volume (V_i) and a value (W_i). >>> T = 2 >>> test_cases = [(50, 3, [(10, 60), (20, 100), (30, 120)]), (10, 2, [(5, 50), (4, 40)])] >>> max_warehouse_value(T, test_cases) [220, 90] >>> T = 1 >>> test_cases = [(5, 1, [(5, 100)])] >>> max_warehouse_value(T, test_cases) [100] >>> T = 1 >>> test_cases = [(10, 0, [])] >>> max_warehouse_value(T, test_cases) [0] >>> T = 1 >>> test_cases = [(3, 3, [(10, 60), (20, 100), (30, 120)])] >>> max_warehouse_value(T, test_cases) [0] >>> T = 1 >>> test_cases = [(15, 3, [(5, 10), (5, 20), (5, 30)])] >>> max_warehouse_value(T, test_cases) [60]","solution":"def knapSack(C, N, items): dp = [0] * (C + 1) # Initialize DP array to store max value for each capacity # Process each item for vi, wi in items: # Traverse the dp array from right to left (to avoid recomputation) for c in range(C, vi - 1, -1): dp[c] = max(dp[c], dp[c - vi] + wi) return dp[C] def max_warehouse_value(T, test_cases): result = [] for C, N, items in test_cases: result.append(knapSack(C, N, items)) return result # Example usage with the provided sample input if __name__ == \\"__main__\\": T = 2 test_cases = [ (50, 3, [(10, 60), (20, 100), (30, 120)]), (10, 2, [(5, 50), (4, 40)]) ] results = max_warehouse_value(T, test_cases) for res in results: print(res)"},{"question":"from typing import List, Tuple def max_plants(n: int, m: int, plant_requirements: List[Tuple[int, int]], time_availabilities: List[Tuple[int, int, int]]) -> int: This function calculates the maximum number of plants that can be grown simultaneously at any given time. Parameters: - n: int - the number of plant species. - m: int - the number of time points. - plant_requirements: List[Tuple[int, int]] - list containing pairs of sunlight and water requirements for each plant species. - time_availabilities: List[Tuple[int, int, int]] - list containing the time points and the available sunlight and water units at each time point. Returns: - int - the maximum number of plants that can be grown simultaneously at any given time. Example: >>> max_plants(3, 4, [(4, 2), (2, 3), (1, 2)], [(1, 5, 4), (2, 6, 6), (3, 3, 3), (4, 10, 10)]) 3 >>> max_plants(2, 1, [(3, 3), (2, 2)], [(1, 5, 5)]) 2","solution":"def max_plants(n, m, plant_requirements, time_availabilities): max_plants_grown = 0 for Ti, S_Ti, W_Ti in time_availabilities: sunlight_left = S_Ti water_left = W_Ti plants_grown = 0 for Si, Wi in sorted(plant_requirements, key=lambda x: (x[0] + x[1])): if Si <= sunlight_left and Wi <= water_left: plants_grown += 1 sunlight_left -= Si water_left -= Wi max_plants_grown = max(max_plants_grown, plants_grown) return max_plants_grown"},{"question":"def happy_sort(arr): Sort the array using the \\"Happy Sort\\" method. The \\"Happy Sort\\" method works by repeatedly extracting non-decreasing subsequences from the original array and appending them to a new array until the original array is empty. >>> happy_sort([3, 1, 4, 1, 5, 9, 2, 6, 5]) [1, 1, 2, 3, 4, 5, 5, 6, 9] >>> happy_sort([5, 4, 3, 2, 1]) [1, 2, 3, 4, 5]","solution":"def happy_sort(arr): sorted_arr = [] while arr: subsequence = [arr[0]] # Find the non-decreasing subsequence for i in range(1, len(arr)): if arr[i] >= subsequence[-1]: subsequence.append(arr[i]) # Append subsequence to sorted_arr sorted_arr += subsequence # Remove the subsequence from arr arr = [x for x in arr if x not in subsequence or subsequence.remove(x)] sorted_arr.sort() return sorted_arr"},{"question":"def longest_substring_k_distinct(k: int, s: str) -> int: Determine the length of the longest substring of given string 's' that contains at most 'k' distinct characters. >>> longest_substring_k_distinct(2, \\"abcba\\") 3 >>> longest_substring_k_distinct(3, \\"aaabbb\\") 6 # Your code here def solve(test_cases: List[Tuple[int, str]]) -> List[int]: Solve the problem for each test case and return the results. >>> solve([(2, \\"abcba\\"), (3, \\"aaabbb\\")]) [3, 6] # Your code here","solution":"def longest_substring_k_distinct(k, s): n = len(s) if k == 0 or n == 0: return 0 left = 0 right = 0 max_length = 0 char_count = {} while right < n: if len(char_count) <= k: if s[right] in char_count: char_count[s[right]] += 1 else: char_count[s[right]] = 1 right += 1 while len(char_count) > k: if char_count[s[left]] == 1: del char_count[s[left]] else: char_count[s[left]] -= 1 left += 1 if len(char_count) <= k: max_length = max(max_length, right - left) return max_length def solve(test_cases): results = [] for k, s in test_cases: results.append(longest_substring_k_distinct(k, s)) return results"},{"question":"def minimum_adjacent_swaps(books): Returns the minimum number of adjacent swaps required to sort the list of books in alphabetical order. Args: books (List[str]): Array of strings, representing the titles of the books. Returns: int: The minimum number of adjacent swaps required to alphabetically sort the books. Examples: >>> minimum_adjacent_swaps([\\"The Great Gatsby\\", \\"1984\\", \\"To Kill a Mockingbird\\", \\"Brave New World\\"]) 3 >>> minimum_adjacent_swaps([\\"Book\\"]) 0 >>> minimum_adjacent_swaps([\\"1984\\", \\"Brave New World\\", \\"The Great Gatsby\\", \\"To Kill a Mockingbird\\"]) 0 >>> minimum_adjacent_swaps([\\"To Kill a Mockingbird\\", \\"The Great Gatsby\\", \\"Brave New World\\", \\"1984\\"]) 6 >>> minimum_adjacent_swaps([\\"A\\", \\"C\\", \\"B\\", \\"C\\"]) 1 >>> minimum_adjacent_swaps([\\"C\\", \\"A\\", \\"B\\"]) 2","solution":"def minimum_adjacent_swaps(books): Returns the minimum number of adjacent swaps required to sort the list of books in alphabetical order. n = len(books) sorted_books = sorted(books) # Create a dictionary to map book titles to their positions in the sorted list position_map = {book: index for index, book in enumerate(sorted_books)} # Convert the book titles to their positions in the sorted list positions = [position_map[book] for book in books] # Use bubble sort to count the number of swaps needed swaps = 0 for i in range(n): for j in range(n - 1): if positions[j] > positions[j + 1]: positions[j], positions[j + 1] = positions[j + 1], positions[j] swaps += 1 return swaps"},{"question":"def make_smallest_palindrome(test_cases: List[Tuple[int, str]]) -> List[str]: Alex is a fan of palindromes. He defines a palindrome as a string that reads the same forward and backward. Given a string S consisting of lowercase alphabets, Alex can replace at most one of its characters to make the string a palindrome. Alex wants to find the lexicographically smallest palindrome string that can be created this way. Parameters: test_cases (List[Tuple[int, str]]): A list of tuples where each tuple contains an integer N representing the length of the string S, and the string S itself. Returns: List[str]: A list of results for each test case. Each result is the lexicographically smallest palindrome string that can be created if possible, otherwise \\"impossible\\". >>> make_smallest_palindrome([(3, \\"abc\\")]) [\\"aba\\"] >>> make_smallest_palindrome([(5, \\"radar\\")]) [\\"radar\\"] >>> make_smallest_palindrome([(4, \\"abba\\")]) [\\"abba\\"] >>> make_smallest_palindrome([(6, \\"abcdef\\")]) [\\"impossible\\"]","solution":"def make_smallest_palindrome(test_cases): results = [] for t in test_cases: N, S = t S = list(S) changed = False # Check if it's already a palindrome if S == S[::-1]: results.append(\\"\\".join(S)) continue for i in range(N // 2): if S[i] != S[N - i - 1]: if changed: results.append(\\"impossible\\") break if S[i] < S[N - i - 1]: S[N - i - 1] = S[i] changed = True else: S[i] = S[N - i - 1] changed = True else: # double-check for lexicographically smallest if S != S[::-1]: results.append(\\"impossible\\") else: results.append(\\"\\".join(S)) return results"},{"question":"def count_subarrays_with_sum_k(arr: List[int], k: int) -> int: Find the number of continuous subarrays that sum up exactly to the given integer k. >>> count_subarrays_with_sum_k([1, 2, 3, 4, 5], 3) 2 >>> count_subarrays_with_sum_k([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 0) 55","solution":"def count_subarrays_with_sum_k(arr, k): from collections import defaultdict # Dictionary to store the frequency of prefix sums prefix_sum_counts = defaultdict(int) # Initialize with prefix sum 0 having frequency 1 (base case) prefix_sum_counts[0] = 1 prefix_sum = 0 count = 0 for num in arr: # Update prefix sum prefix_sum += num # Check if there is a prefix sum that when subtracted from the current # prefix sum equals to k if (prefix_sum - k) in prefix_sum_counts: count += prefix_sum_counts[prefix_sum - k] # Update the frequency of the current prefix sum prefix_sum_counts[prefix_sum] += 1 return count"},{"question":"def min_subarray_len(arr: List[int], K: int) -> int: Finds the length of the smallest contiguous subarray whose sum is at least K. If no such subarray exists, returns 0. >>> min_subarray_len([2, 3, 1, 2, 4, 3], 7) 2 >>> min_subarray_len([1, 1, 1, 1, 1, 1, 1, 1], 11) 0 >>> min_subarray_len([4, 2, 2, 7, 8, 1, 2, 8, 10], 8) 1","solution":"def min_subarray_len(arr, K): Finds the length of the smallest contiguous subarray whose sum is at least K. If no such subarray exists, returns 0. n = len(arr) min_length = n + 1 current_sum = 0 start = 0 for end in range(n): current_sum += arr[end] while current_sum >= K: min_length = min(min_length, end - start + 1) current_sum -= arr[start] start += 1 return min_length if min_length <= n else 0"},{"question":"class Node: def __init__(self, key): self.data = key self.left = None self.right = None def findLevel(root, data): Returns the level of the node with the given data in the binary tree. If data is not present, return -1. >>> tree = Node(3) >>> tree.left = Node(2) >>> tree.right = Node(5) >>> tree.left.left = Node(1) >>> tree.left.right = Node(4) >>> findLevel(tree, 4) 3 >>> tree2 = Node(10) >>> tree2.left = Node(20) >>> tree2.right = Node(30) >>> tree2.right.left = Node(40) >>> tree2.right.right = Node(50) >>> findLevel(tree2, 30) 2 >>> findLevel(tree2, 60) -1","solution":"class Node: def __init__(self, key): self.data = key self.left = None self.right = None def findLevel(root, data): Returns the level of the node with the given data in the binary tree. If data is not present, return -1. # Perform Level Order Traversal and keep track of levels if root is None: return -1 level = 1 queue = [(root, level)] while queue: node, lvl = queue.pop(0) # If found the data, return the level if node.data == data: return lvl if node.left: queue.append((node.left, lvl + 1)) if node.right: queue.append((node.right, lvl + 1)) # If we exit the loop without finding the data return -1"},{"question":"def prime_factors_sum(n: int) -> ([int], int): Computes the prime factors of n and the sum of these prime factors. Args: n (int): The number to calculate prime factors for (2 ≤ n ≤ 10^12). Returns: tuple: A tuple containing a sorted list of prime factors and the sum of these prime factors. >>> prime_factors_sum(12) ([2, 3], 5) >>> prime_factors_sum(28) ([2, 7], 9) >>> prime_factors_sum(19) ([19], 19) def format_output(n: int) -> str: Formats the output for the prime factors and their sum. Args: n (int): The number to calculate prime factors for (2 ≤ n ≤ 10^12). Returns: str: A string representation of the prime factors in non-decreasing order, followed by the sum of these prime factors. >>> format_output(12) \\"2 3n5\\" >>> format_output(28) \\"2 7n9\\" >>> format_output(19) \\"19n19\\"","solution":"def prime_factors_sum(n): Computes the prime factors of n and the sum of these prime factors. Returns: A tuple containing a sorted list of prime factors and the sum of these prime factors. def prime_factors(n): factors = set() # Check for number of 2s while n % 2 == 0: factors.add(2) n = n // 2 # n must be odd at this point, check all odd numbers from 3 onwards for i in range(3, int(n**0.5) + 1, 2): while n % i == 0: factors.add(i) n = n // i # This condition is to check if n is a prime number greater than 2 if n > 2: factors.add(n) return sorted(factors) factors = prime_factors(n) sum_of_factors = sum(factors) return factors, sum_of_factors def format_output(n): factors, sum_of_factors = prime_factors_sum(n) return f\\"{' '.join(map(str, factors))}n{sum_of_factors}\\""},{"question":"def mergeIntervals(intervals): Merges overlapping intervals. Args: intervals (list): A list of intervals, each interval is a list of two integers [start, end]. Returns: list: A list of merged intervals in sorted order. Examples: >>> mergeIntervals([[1, 4], [2, 5], [7, 9]]) [[1, 5], [7, 9]] >>> mergeIntervals([[6, 8], [1, 9], [2, 4], [4, 7]]) [[1, 9]] >>> mergeIntervals([[1, 2], [3, 4], [5, 6]]) [[1, 2], [3, 4], [5, 6]] >>> mergeIntervals([[1, 2]]) [[1, 2]] >>> mergeIntervals([[1, 4], [2, 3], [3, 5]]) [[1, 5]] >>> mergeIntervals([]) [] >>> mergeIntervals([[1, 4], [2, 3], [3, 4], [0, 5]]) [[0, 5]]","solution":"def mergeIntervals(intervals): Merges overlapping intervals. Args: intervals (list): A list of intervals, each interval is a list of two integers [start, end]. Returns: list: A list of merged intervals in sorted order. if not intervals: return [] # Sort the intervals based on their start times intervals.sort(key=lambda x: x[0]) merged_intervals = [intervals[0]] for current in intervals[1:]: last_merged = merged_intervals[-1] # If the current interval overlaps with the last merged interval, merge them if current[0] <= last_merged[1]: last_merged[1] = max(last_merged[1], current[1]) else: merged_intervals.append(current) return merged_intervals"},{"question":"def max_paintings_in_row(n: int, h: int, paintings: List[Tuple[int, int]]) -> int: Determines the maximum number of paintings that can be placed in a row without exceeding the maximum height. Parameters: n (int): Number of paintings. h (int): Maximum allowed height for the row. paintings (list of tuples): Each tuple contains two integers wi and hi representing the width and height of each painting respectively. Returns: int: Maximum number of paintings that can be placed in a row without exceeding the maximum height. Example: >>> max_paintings_in_row(4, 10, [(5, 8), (6, 3), (4, 2), (3, 5)]) 3 >>> max_paintings_in_row(3, 5, [(1, 6), (2, 3), (4, 4)]) 2","solution":"def max_paintings_in_row(n, h, paintings): Determines the maximum number of paintings that can be placed in a row without exceeding the maximum height. Parameters: n (int): Number of paintings. h (int): Maximum allowed height for the row. paintings (list of tuples): Each tuple contains two integers wi and hi representing the width and height of each painting respectively. Returns: int: Maximum number of paintings that can be placed in a row without exceeding the maximum height. def calculate_max_paintings(remaining_paintings, current_height, idx): if idx == n: return 0 wi, hi = remaining_paintings[idx] max_count = calculate_max_paintings(remaining_paintings, current_height, idx + 1) if current_height + hi <= h: max_count = max(max_count, 1 + calculate_max_paintings(remaining_paintings, current_height + hi, idx + 1)) if current_height + wi <= h: max_count = max(max_count, 1 + calculate_max_paintings(remaining_paintings, current_height + wi, idx + 1)) return max_count return calculate_max_paintings(paintings, 0, 0)"},{"question":"def process_queries(queries: List[List[int]]) -> List[int]: Process a series of operations and queries on a sequence of integers. Each operation is either an insertion of an integer or a query for the minimum difference between a certain integer and the closest larger or equal divisible integer in the sequence. Args: queries (List[List[int]]): A list of queries, where each query is represented as a list. The first element of the list is the type of operation: - [1, u]: Insert integer u to the sequence. - [2, x, y]: Find the minimum difference (v - x) where v is an integer in the sequence such that v >= x and v is divisible by y. If no such v exists, return -1. Returns: List[int]: A list of results for each query of type 2. Examples: >>> process_queries([ ... [1, 3], ... [1, 10], ... [1, 15], ... [2, 5, 5], ... [2, 8, 2], ... [2, 16, 7] ... ]) [5, 2, -1] >>> process_queries([ ... [1, 1], ... [1, 2], ... [2, 3, 5], ... [2, 6, 7] ... ]) [-1, -1]","solution":"def process_queries(queries): sequence = [] result = [] for query in queries: op = query[0] if op == 1: u = query[1] sequence.append(u) elif op == 2: x, y = query[1], query[2] valid_differences = [(v - x) for v in sequence if v >= x and v % y == 0] if valid_differences: result.append(min(valid_differences)) else: result.append(-1) return result"},{"question":"from typing import List def unique_elements(lst: List[int]) -> List[int]: Given a list of integers, return a new list that contains the elements of the original list but excludes any that appear more than once. The returned list should retain the original order of elements. If there are no unique elements, return an empty list. >>> unique_elements([1, 2, 2, 3, 4, 4, 5]) [1, 3, 5] >>> unique_elements([5, 5, 5, 5, 5]) [] >>> unique_elements([10, 20, 30, 10, 20, 50]) [30, 50]","solution":"def unique_elements(lst): Given a list of integers, return a new list that contains the elements of the original list but excludes any that appear more than once. The returned list should retain the original order of elements. from collections import Counter element_counts = Counter(lst) return [x for x in lst if element_counts[x] == 1]"},{"question":"def max_transport_product(n: int, k: int, a: List[int]) -> int: Determines the maximum amount of product that can be transported in one day by choosing an optimal set of k contiguous mining sites. Parameters: n (int): number of mining sites k (int): number of contiguous sites to select for transportation a (list): list of production amounts at each mining site Returns: int: the maximum amount of product that can be transported >>> max_transport_product(5, 2, [4, 2, 1, 3, 5]) 8 >>> max_transport_product(7, 3, [10, 20, 10, 5, 8, 7, 10]) 35","solution":"def max_transport_product(n, k, a): Determines the maximum amount of product that can be transported in one day by choosing an optimal set of k contiguous mining sites. Parameters: n (int): number of mining sites k (int): number of contiguous sites to select for transportation a (list): list of production amounts at each mining site Returns: int: the maximum amount of product that can be transported # Initialize the sum of the first k elements current_sum = sum(a[:k]) max_sum = current_sum # Use the sliding window technique to find the maximum sum of k contiguous elements for i in range(k, n): current_sum += a[i] - a[i - k] if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"from typing import List def can_make_product(arr: List[int], K: int) -> bool: Checks if there is a subsequence in arr whose product is K. def answer_queries(N: int, arr: List[int], Q: int, queries: List[int]) -> List[str]: Determines for each query if there is a subsequence in the array whose product is equal to the value in the query. >>> answer_queries(4, [2, 3, 5, 7], 3, [6, 30, 7]) ['Yes', 'Yes', 'Yes'] >>> answer_queries(5, [1, 4, 6, 2, 8], 4, [3, 48, 7, 16]) ['No', 'Yes', 'No', 'Yes']","solution":"from itertools import combinations from functools import reduce from operator import mul def can_make_product(arr, K): Checks if there is a subsequence in arr whose product is K. for r in range(1, len(arr) + 1): for comb in combinations(arr, r): if reduce(mul, comb) == K: return True return False def answer_queries(N, arr, Q, queries): results = [] for K in queries: if can_make_product(arr, K): results.append(\\"Yes\\") else: results.append(\\"No\\") return results"},{"question":"def min_perfect_squares(N: int) -> int: Determine the minimum number of perfect squares that sum to N. >>> min_perfect_squares(0) 0 >>> min_perfect_squares(1) 1 >>> min_perfect_squares(2) 2 >>> min_perfect_squares(3) 3 >>> min_perfect_squares(4) 1 >>> min_perfect_squares(5) 2 >>> min_perfect_squares(6) 3 >>> min_perfect_squares(7) 4 >>> min_perfect_squares(8) 2 >>> min_perfect_squares(9) 1 >>> min_perfect_squares(12) 3 >>> min_perfect_squares(10000) 1","solution":"import math def min_perfect_squares(N): Determine the minimum number of perfect squares that sum to N. # Create a list to store the minimum number of perfect squares for each number from 0 to N dp = [float('inf')] * (N + 1) # Base case dp[0] = 0 # Fill the dp array for i in range(1, N + 1): j = 1 while j * j <= i: dp[i] = min(dp[i], dp[i - j * j] + 1) j += 1 return dp[N]"},{"question":"def count_unique_words(n: int, documents: List[str]) -> List[str]: Given a number of documents, this function reads all documents, identifies each unique word across these documents, and counts the number of times each word appears. It returns the words in alphabetical order with their frequencies. >>> count_unique_words(1, [\\"Hello, world! Hello.\\"]) [\\"hello 2\\", \\"world 1\\"] >>> count_unique_words(2, [\\"Hello, world! Hello.\\", \\"World, hello again.\\"]) [\\"again 1\\", \\"hello 3\\", \\"world 2\\"] >>> count_unique_words(2, [\\"Apple apple APPLE.\\", \\"apple pie.\\"]) [\\"apple 4\\", \\"pie 1\\"] >>> count_unique_words(2, [\\"end, end. end!\\", \\"The end?\\"]) [\\"end 4\\", \\"the 1\\"] >>> count_unique_words(1, [\\" \\".join([\\"word\\"] * 500)]) [\\"word 500\\"] >>> count_unique_words(2, [\\"one two three\\", \\"four five six\\"]) [\\"five 1\\", \\"four 1\\", \\"one 1\\", \\"six 1\\", \\"three 1\\", \\"two 1\\"]","solution":"import re from collections import Counter from typing import List def count_unique_words(n: int, documents: List[str]) -> List[str]: Given a number of documents, this function reads all documents, identifies each unique word across these documents, and counts the number of times each word appears. It returns the words in alphabetical order with their frequencies. words = [] for document in documents: # Lowercase the document and remove punctuation cleaned_text = re.sub(r'[^ws]', '', document.lower()) words.extend(cleaned_text.split()) word_count = Counter(words) result = [] for word in sorted(word_count): result.append(f\\"{word} {word_count[word]}\\") return result"},{"question":"def isValidSudoku(board): Determines if a given Sudoku board is valid. :param board: List[List[str]], a 2D character array of size 9x9 representing the Sudoku board :return: bool, True if the Sudoku board is valid, otherwise False Example: >>> board = [ ... ['5','3','.','.','7','.','.','.','.'], ... ['6','.','.','1','9','5','.','.','.'], ... ['.','9','8','.','.','.','.','6','.'], ... ['8','.','.','.','6','.','.','.','3'], ... ['4','.','.','8','.','3','.','.','1'], ... ['7','.','.','.','2','.','.','.','6'], ... ['.','6','.','.','.','.','2','8','.'], ... ['.','.','.','4','1','9','.','.','5'], ... ['.','.','.','.','8','.','.','7','9'] ...] >>> isValidSudoku(board) True >>> board = [ ... ['8','3','.','.','7','.','.','.','.'], ... ['6','.','.','1','9','5','.','.','.'], ... ['.','9','8','.','.','.','.','6','.'], ... ['8','.','.','.','6','.','.','.','3'], ... ['4','.','.','8','.','3','.','.','1'], ... ['7','.','.','.','2','.','.','.','6'], ... ['.','6','.','.','.','.','2','8','.'], ... ['.','.','.','4','1','9','.','.','5'], ... ['.','.','.','.','8','.','.','7','9'] ...] >>> isValidSudoku(board) False import pytest def test_valid_sudoku(): board = [ ['5','3','.','.','7','.','.','.','.'], ['6','.','.','1','9','5','.','.','.'], ['.','9','8','.','.','.','.','6','.'], ['8','.','.','.','6','.','.','.','3'], ['4','.','.','8','.','3','.','.','1'], ['7','.','.','.','2','.','.','.','6'], ['.','6','.','.','.','.','2','8','.'], ['.','.','.','4','1','9','.','.','5'], ['.','.','.','.','8','.','.','7','9'] ] assert isValidSudoku(board) == True def test_invalid_sudoku_row(): board = [ ['8','3','.','.','7','.','.','.','.'], ['6','.','.','1','9','5','.','.','.'], ['.','9','8','.','.','.','.','6','.'], ['8','.','.','.','6','.','.','.','3'], ['4','.','.','8','.','3','.','.','1'], ['7','.','.','.','2','.','.','.','6'], ['.','6','.','.','.','.','2','8','.'], ['.','.','.','4','1','9','.','.','5'], ['.','.','.','.','8','.','.','7','9'] ] assert isValidSudoku(board) == False def test_invalid_sudoku_column(): board = [ ['5','3','.','.','7','.','.','.','.'], ['6','.','.','.','9','5','.','.','.'], ['.','9','8','.','.','.','.','6','.'], ['8','.','.','.','6','.','.','.','3'], ['4','.','.','8','.','3','.','.','1'], ['7','.','.','.','2','.','.','.','6'], ['.','6','.','.','.','.','2','8','.'], ['.','.','.','.','1','9','.','.','5'], ['.','.','.','.','8','.','.','7','9'] ] board[1][3] = '9' # Duplicate '9' in column causing invalid Sudoku assert isValidSudoku(board) == False def test_invalid_sudoku_subgrid(): board = [ ['5','3','.','.','7','.','.','.','.'], ['6','.','.','1','9','5','.','.','.'], ['.','9','8','.','.','.','.','6','.'], ['8','.','.','.','6','.','.','.','3'], ['4','.','.','8','.','3','.','.','1'], ['7','.','.','.','2','.','.','.','6'], ['.','6','.','.','.','.','2','8','.'], ['.','.','.','4','1','9','.','.','5'], ['.','.','.','.','8','.','.','7','9'] ] board[0][2] = '9' // Duplicate '9' in a 3x3 subgrid causing invalid Sudoku assert isValidSudoku(board) == False","solution":"def isValidSudoku(board): Determines if a given Sudoku board is valid. :param board: List[List[str]], a 2D character array of size 9x9 representing the Sudoku board :return: bool, True if the Sudoku board is valid, otherwise False def is_valid_block(block): block = [num for num in block if num != '.'] return len(block) == len(set(block)) # check rows for row in board: if not is_valid_block(row): return False # check columns for col in range(9): if not is_valid_block([board[row][col] for row in range(9)]): return False # check 3x3 sub-grids for block_row in range(3): for block_col in range(3): block = [] for row in range(3): for col in range(3): block.append(board[block_row * 3 + row][block_col * 3 + col]) if not is_valid_block(block): return False return True"},{"question":"from typing import List, Tuple def split_numbers(numbers: List[int]) -> Tuple[List[int], List[int]]: Splits the list of integers into two lists: one containing even numbers and the other containing odd numbers, both of which are sorted in ascending order. >>> split_numbers([4, 3, 2, 7, -1, -4, 0]) == ([-4, 0, 2, 4], [-1, 3, 7]) >>> split_numbers([8, 6, 4, 2, 0, -2, -4]) == ([-4, -2, 0, 2, 4, 6, 8], []) >>> split_numbers([7, 5, 3, 1, -1, -3, -5]) == ([], [-5, -3, -1, 1, 3, 5, 7]) >>> split_numbers([]) == ([], []) >>> split_numbers([1, 3, 5, 7]) == ([], [1, 3, 5, 7]) >>> split_numbers([2, 4, 6, 8]) == ([2, 4, 6, 8], []) >>> split_numbers([-8, -3, -2, -1, 0]) == ([-8, -2, 0], [-3, -1]) >>> split_numbers([0, 0, 0]) == ([0, 0, 0], [])","solution":"from typing import List, Tuple def split_numbers(numbers: List[int]) -> Tuple[List[int], List[int]]: Splits the list of integers into two lists: one containing even numbers and the other containing odd numbers, both of which are sorted in ascending order. Args: numbers (List[int]): A list of integers. Returns: Tuple[List[int], List[int]]: A tuple containing two lists: - List of even numbers sorted in ascending order - List of odd numbers sorted in ascending order evens = [num for num in numbers if num % 2 == 0] odds = [num for num in numbers if num % 2 != 0] return sorted(evens), sorted(odds)"},{"question":"def max_subarray_sum_circular(arr): Find the maximum possible sum of a subarray in a circular array. >>> max_subarray_sum_circular([8, -1, 3, 4, -5, 6]) 20 >>> max_subarray_sum_circular([-1, -2, -3, -4, -5]) -1 def process_test_cases(test_cases): Process the test cases to find the maximum possible sum of a subarray for each circular array. >>> process_test_cases([[8, -1, 3, 4, -5, 6], [-1, -2, -3, -4, -5]]) [20, -1]","solution":"def max_subarray_sum_circular(arr): def max_subarray_sum(arr): max_ending_here = max_so_far = arr[0] for x in arr[1:]: max_ending_here = max(x, max_ending_here + x) max_so_far = max(max_so_far, max_ending_here) return max_so_far def min_subarray_sum(arr): min_ending_here = min_so_far = arr[0] for x in arr[1:]: min_ending_here = min(x, min_ending_here + x) min_so_far = min(min_so_far, min_ending_here) return min_so_far total_sum = sum(arr) max_normal = max_subarray_sum(arr) min_normal = min_subarray_sum(arr) if max_normal < 0: return max_normal return max(max_normal, total_sum - min_normal) def process_test_cases(test_cases): results = [] for arr in test_cases: results.append(max_subarray_sum_circular(arr)) return results"},{"question":"def max_free_days(N: int, M: int, B: List[int]) -> int: Determine the maximum possible number of full days Taro can spend without doing any projects given his schedule. If Taro cannot complete all projects within the N days, return -1. >>> max_free_days(50, 3, [7, 4, 9]) 30 >>> max_free_days(21, 3, [7, 7, 7]) 0 >>> max_free_days(15, 3, [7, 7, 7]) -1 >>> max_free_days(100, 5, [10, 15, 5, 20, 3]) 47 >>> max_free_days(10, 1, [7]) 3 >>> max_free_days(10, 1, [10]) 0 >>> max_free_days(10, 1, [11]) -1","solution":"def max_free_days(N, M, B): # Total days required to complete all M projects total_project_days = sum(B) # If the total days required exceeds available days, return -1 if total_project_days > N: return -1 # Maximum free days are the remaining days after completing all projects max_free_days = N - total_project_days return max_free_days"},{"question":"def final_position_after_instructions(T: int, instructions_list: List[str]) -> List[Tuple[int, int]]: Determine the final position of a robot on the grid after executing a sequence of instructions. Parameters: - T (int): The number of test cases. - instructions_list (List[str]): A list of strings, each representing a sequence of instructions. Returns: - List[Tuple[int, int]]: A list of tuples representing the final coordinates (x, y) of the robot. >>> final_position_after_instructions(3, [\\"UUDDLRLR\\", \\"LLRR\\", \\"UDUDUDUUDD\\"]) [(0, 0), (0, 0), (0, 0)] >>> final_position_after_instructions(1, [\\"U\\"]) [(0, 1)] >>> final_position_after_instructions(1, [\\"UUDD\\"]) [(0, 0)]","solution":"def final_position_after_instructions(T, instructions_list): Determine the final position on the grid for each sequence of instructions. Parameters: - T (int): The number of test cases. - instructions_list (list of str): A list of strings, each representing a sequence of instructions. Returns: - list of tuple: A list of tuples, each representing the final coordinates (x, y) of the robot. results = [] # Define movements for each instruction move_map = { 'U': (0, 1), 'D': (0, -1), 'L': (-1, 0), 'R': (1, 0) } for instructions in instructions_list: x, y = 0, 0 for direction in instructions: dx, dy = move_map[direction] x += dx y += dy results.append((x, y)) return results"},{"question":"from typing import List, Tuple def compute_minimum_waiting_time(intersections: List[Tuple[int, int, int]]) -> int: Compute the minimum total waiting time for all vehicles in the city if the traffic signals are optimized correctly. >>> compute_minimum_waiting_time([(0, 3, 2), (1, 2, 3), (4, 4, 1)]) 5 >>> compute_minimum_waiting_time([(5, 5, 10), (10, 5, 5)]) 15 >>> compute_minimum_waiting_time([]) 0 >>> compute_minimum_waiting_time([(i, 1, 1) for i in range(100000)]) 4999950000 pass def main(input_data: str) -> int: Process the input data and compute the minimum total waiting time for all vehicles in the city. >>> main(\\"3n0 3 2n1 2 3n4 4 1n\\") 5 >>> main(\\"2n5 5 10n10 5 5n\\") 15 >>> main(\\"0n\\") 0 >>> main(\\"100000n\\" + \\"n\\".join(f\\"{i} 1 1\\" for i in range(100000)) + \\"n\\") 4999950000 pass","solution":"def compute_minimum_waiting_time(intersections): # Sum up all the initial times a (these are assumed to be the total waiting times initially). total_waiting_time = sum(inter[0] for inter in intersections) return total_waiting_time # Example input processing def main(input_data): lines = input_data.strip().split('n') n = int(lines[0]) intersections = [tuple(map(int, line.split())) for line in lines[1:n+1]] return compute_minimum_waiting_time(intersections)"},{"question":"def transpose(matrix): Complete the function to return the transpose of the given matrix. :param matrix: List[List[int]] :return: List[List[int]] >>> transpose([ ... [1, 2, 3], ... [4, 5, 6] ... ]) [[1, 4], [2, 5], [3, 6]] >>> transpose([ ... [7, 8, 9], ... [3, 2, 1], ... [6, 5, 4] ... ]) [[7, 3, 6], [8, 2, 5], [9, 1, 4]] # Your code here","solution":"def transpose(matrix): Returns the transpose of the given matrix. :param matrix: List[List[int]] :return: List[List[int]] return list(map(list, zip(*matrix)))"},{"question":"from typing import List def is_path_to_goal(R: int, C: int, maze: List[str]) -> str: Design an algorithm that determines if a sequence of moves can be made within a maze to reach a goal. The maze is represented by a matrix of characters, where '.' is a walkable space, '#' is a wall, 'S' is the start point, and 'G' is the goal. You must check if there exists any path from the 'S' to 'G' moving only in the four cardinal directions (up, down, left, and right). Args: R (int): Number of rows in the maze. C (int): Number of columns in the maze. maze (List[str]): Representation of the maze, each string represents a row. Returns: str: \\"Yes\\" if there is a path from 'S' to 'G', otherwise \\"No\\". >>> is_path_to_goal(5, 5, [\\"S..#.\\", \\".#.\\", \\"#.G#.\\", \\".#...\\", \\".....\\"]) \\"Yes\\" >>> is_path_to_goal(4, 4, [\\"S#\\", \\"..\\", \\"..G#\\", \\"\\"]) \\"No\\" pass # Unit tests for the function def test_path_exists(): R = 5 C = 5 maze = [ \\"S..#.\\", \\".#.\\", \\"#.G#.\\", \\".#...\\", \\".....\\" ] assert is_path_to_goal(R, C, maze) == \\"Yes\\" def test_no_path(): R = 4 C = 4 maze = [ \\"S#\\", \\"..\\", \\"..G#\\", \\"\\" ] assert is_path_to_goal(R, C, maze) == \\"No\\" def test_simple_no_barrier(): R = 3 C = 3 maze = [ \\"S..\\", \\"...\\", \\"..G\\" ] assert is_path_to_goal(R, C, maze) == \\"Yes\\" def test_blocked_start(): R = 3 C = 3 maze = [ \\"S#.\\", \\"#\\", \\"..G\\" ] assert is_path_to_goal(R, C, maze) == \\"No\\" def test_start_is_goal(): R = 1 C = 1 maze = [\\"S\\"] assert is_path_to_goal(R, C, maze) == \\"No\\" # The problem statement says there is exactly one 'G', so this is an invalid scenario, assume maze needs correction def test_path_with_multiple_routes(): R = 4 C = 4 maze = [ \\"S..#\\", \\"#.#.\\", \\"#.G#\\", \\"....\\" ] assert is_path_to_goal(R, C, maze) == \\"Yes\\"","solution":"from collections import deque def is_path_to_goal(R, C, maze): Determines if there is a path from 'S' to 'G' in the given maze. Args: R (int): Number of rows in the maze. C (int): Number of columns in the maze. maze (list of str): Representation of the maze, each string represents a row. Returns: str: \\"Yes\\" if there is a path from 'S' to 'G', otherwise \\"No\\". # Directions for moving up, down, left, right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Find the start (S) position start_pos = None for r in range(R): for c in range(C): if maze[r][c] == 'S': start_pos = (r, c) break if start_pos: break # Breadth-First Search (BFS) initialization queue = deque([start_pos]) visited = set() visited.add(start_pos) # BFS loop while queue: current_pos = queue.popleft() cur_r, cur_c = current_pos if maze[cur_r][cur_c] == 'G': return \\"Yes\\" for dr, dc in directions: new_r, new_c = cur_r + dr, cur_c + dc if 0 <= new_r < R and 0 <= new_c < C: if maze[new_r][new_c] != '#' and (new_r, new_c) not in visited: visited.add((new_r, new_c)) queue.append((new_r, new_c)) return \\"No\\""},{"question":"def longest_palindrome(s: str) -> int: Takes a string and returns the length of the longest palindrome that can be built with the letters of the string. Args: s (str): The input string consisting of lowercase characters. Returns: int: The length of the longest palindrome that can be built. Examples: >>> longest_palindrome(\\"abccccdd\\") 7 >>> longest_palindrome(\\"aabbcc\\") 6 >>> longest_palindrome(\\"aaabbccccd\\") 9 >>> longest_palindrome(\\"a\\") 1 >>> longest_palindrome(\\"aa\\") 2 >>> longest_palindrome(\\"abccba\\") 6 >>> longest_palindrome(\\"\\") 0 >>> longest_palindrome(\\"a\\" * 1000 + \\"b\\" * 999) 1999","solution":"def longest_palindrome(s): Returns the length of the longest palindrome that can be built with the letters of the string s. from collections import Counter count = Counter(s) length = 0 odd_found = False for char_freq in count.values(): if char_freq % 2 == 0: length += char_freq else: length += char_freq - 1 odd_found = True if odd_found: length += 1 return length"},{"question":"def sum_of_even_in_subarrays(arr, queries): Function to calculate the sum of even numbers in subarray from l to r for each query. Parameters: arr (list of int): List of integers in the array. queries (list of tuples): List of queries where each query is a tuple (l, r). Returns: list of int: List of sums of even numbers for each query. >>> sum_of_even_in_subarrays([1, 2, 3, 4, 5], [(1, 3), (2, 4), (1, 5)]) [2, 6, 6] >>> sum_of_even_in_subarrays([6, 7, 8, 9, 10, 11], [(1, 6), (3, 5)]) [24, 18]","solution":"def sum_of_even_in_subarrays(arr, queries): Function to calculate the sum of even numbers in subarray from l to r for each query. Parameters: arr (list of int): List of integers in the array. queries (list of tuples): List of queries where each query is a tuple (l, r). Returns: list of int: List of sums of even numbers for each query. def is_even(num): return num % 2 == 0 results = [] for l, r in queries: even_sum = sum(arr[i] for i in range(l-1, r) if is_even(arr[i])) results.append(even_sum) return results"},{"question":"def split_serial_numbers(concatenated_serials: str) -> list: Splits a long string of concatenated serial numbers into a list of valid serial numbers. Each serial number is exactly 10 characters long. Parameters: concatenated_serials (str): The concatenated serial numbers string. Returns: list of str: A list containing the original serial numbers. >>> split_serial_numbers(\\"AB12C34DEFTG5678HIJKL4MNOPqrst90UYc789\\") [\\"AB12C34DEF\\", \\"TG5678HIJK\\", \\"L4MNOPqrst\\", \\"90UYc789\\"] >>> split_serial_numbers(\\"1234567890ABCDEFGHIJKLZ\\") [\\"1234567890\\", \\"ABCDEFGHIJ\\", \\"KLZ\\"]","solution":"def split_serial_numbers(concatenated_serials): Splits a long string of concatenated serial numbers into a list of valid serial numbers. Each serial number is exactly 10 characters long. Parameters: concatenated_serials (str): The concatenated serial numbers string. Returns: list of str: A list containing the original serial numbers. n = len(concatenated_serials) serial_numbers = [concatenated_serials[i:i+10] for i in range(0, n, 10)] return serial_numbers"},{"question":"def longest_equal_zeros_ones(T: int, test_cases: List[Tuple[int, str]]) -> List[int]: Alice wants to find the length of the longest substring of a binary string S that contains an equal number of '0's and '1's. Args: T : int : The number of test cases. test_cases : List[Tuple[int, str]] : A list of tuples where each tuple contains an integer N (length of the binary string) and a binary string S. Returns: List[int] : A list of integers representing the lengths of the longest substrings for each test case >>> longest_equal_zeros_ones(2, [(4, \\"1100\\"), (5, \\"10010\\")]) [4, 4] >>> longest_equal_zeros_ones(1, [(6, \\"101010\\")]) [6]","solution":"def longest_equal_zeros_ones(T, test_cases): results = [] for N, S in test_cases: max_length = 0 balance = 0 balance_index_map = {0: -1} for i, char in enumerate(S): balance += 1 if char == '1' else -1 if balance in balance_index_map: max_length = max(max_length, i - balance_index_map[balance]) else: balance_index_map[balance] = i results.append(max_length) return results"},{"question":"def unscramble_phrase(scrambled): Unscrambles an English phrase by reversing each word in place while maintaining the word order. Parameters: scrambled (str): A scrambled English phrase where each word is reversed. Returns: str: The original phrase. >>> unscramble_phrase(\\"ehT kciuq nworb xof\\") 'The quick brown fox' >>> unscramble_phrase(\\"elbmuht eht revo spmuj yzal god\\") 'thumble the over jumps lazy dog' >>> unscramble_phrase(\\"siht sI A tseT\\") 'this Is A Test' >>> unscramble_phrase(\\"euqinu olleh\\") 'unique hello'","solution":"def unscramble_phrase(scrambled): Unscrambles an English phrase by reversing each word in place while maintaining the word order. Parameters: scrambled (str): A scrambled English phrase where each word is reversed. Returns: str: The original phrase. return ' '.join(word[::-1] for word in scrambled.split())"},{"question":"from collections import deque from typing import List class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def zigzagLevelOrder(root: TreeNode) -> List[List[int]]: Returns the zigzag level order traversal of a binary tree. >>> root = TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3, TreeNode(6), TreeNode(7))) >>> zigzagLevelOrder(root) [[1], [3, 2], [4, 5, 6, 7]] >>> zigzagLevelOrder(TreeNode(1)) [[1]] >>> zigzagLevelOrder(None) []","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def zigzagLevelOrder(root): Returns the zigzag level order traversal of a binary tree. :param root: TreeNode, the root of the binary tree :return: List[List[int]], level order traversal but each level ordered alternatively if not root: return [] results = [] current_level = deque([root]) left_to_right = True while current_level: level_values = deque() next_level = deque() while current_level: node = current_level.popleft() if left_to_right: level_values.append(node.val) else: level_values.appendleft(node.val) if node.left: next_level.append(node.left) if node.right: next_level.append(node.right) results.append(list(level_values)) current_level = next_level left_to_right = not left_to_right return results"},{"question":"def calculate_salaries(n, data, overtime_rates): Calculate the total salary for each employee based on their base salary, category, and number of overtime hours. :param n: int, number of employees :param data: list of tuples, each containing (base_salary, category, overtime_hours) :param overtime_rates: tuple of three ints, containing (junior_rate, mid_rate, senior_rate) :return: list of ints, each containing the total salary for each employee Examples: >>> calculate_salaries(3, [(3000, 'Junior', 5), (4000, 'Mid', 10), (5000, 'Senior', 8)], (10, 20, 30)) [3050, 4200, 5240] >>> calculate_salaries(2, [(2500, 'Mid', 3), (4500, 'Senior', 6)], (15, 25, 50)) [2575, 4800] pass # Write your implementation here def test_calculate_salaries_example1(): n = 3 data = [(3000, 'Junior', 5), (4000, 'Mid', 10), (5000, 'Senior', 8)] rates = (10, 20, 30) assert calculate_salaries(n, data, rates) == [3050, 4200, 5240] def test_calculate_salaries_example2(): n = 2 data = [(2500, 'Mid', 3), (4500, 'Senior', 6)] rates = (15, 25, 50) assert calculate_salaries(n, data, rates) == [2575, 4800] def test_calculate_salaries_min_values(): n = 1 data = [(1, 'Junior', 0)] rates = (1, 1, 1) assert calculate_salaries(n, data, rates) == [1] def test_calculate_salaries_max_values(): n = 1 data = [(10000, 'Senior', 100)] rates = (100, 100, 100) assert calculate_salaries(n, data, rates) == [20000] def test_calculate_salaries_mixed_values(): n = 4 data = [ (3000, 'Junior', 10), (3000, 'Mid', 10), (3000, 'Senior', 10), (3000, 'Senior', 0) ] rates = (5, 10, 15) assert calculate_salaries(n, data, rates) == [3050, 3100, 3150, 3000]","solution":"def calculate_salaries(n, data, overtime_rates): Calculate the total salary for each employee based on their base salary, category, and number of overtime hours. :param n: int, number of employees :param data: list of tuples, each containing (base_salary, category, overtime_hours) :param overtime_rates: tuple of three ints, containing (junior_rate, mid_rate, senior_rate) :return: list of ints, each containing the total salary for each employee junior_rate, mid_rate, senior_rate = overtime_rates salary_list = [] for base_salary, category, overtime_hours in data: if category == 'Junior': total_salary = base_salary + junior_rate * overtime_hours elif category == 'Mid': total_salary = base_salary + mid_rate * overtime_hours elif category == 'Senior': total_salary = base_salary + senior_rate * overtime_hours salary_list.append(total_salary) return salary_list"},{"question":"def count_paths(R: int, C: int, blocked_cells: List[Tuple[int, int]]) -> int: Compute the number of unique paths in a grid with blocked cells. Parameters: - R: Number of rows in the grid. - C: Number of columns in the grid. - blocked_cells: A list of tuples representing the coordinates of blocked cells. Returns: - int: The number of unique paths from the top-left to the bottom-right corner, modulo 10^9 + 7. Example: >>> count_paths(3, 3, [(2, 2), (2, 3)]) 1 >>> count_paths(3, 3, []) 6 from typing import List, Tuple def test_example_case(): R, C = 3, 3 blocked = [(2, 2), (2, 3)] assert count_paths(R, C, blocked) == 1 def test_no_blocked_cells(): R, C = 3, 3 blocked = [] assert count_paths(R, C, blocked) == 6 def test_all_blocked_except_start(): R, C = 3, 3 blocked = [(1, 3), (2, 2), (2, 3), (3, 1)] assert count_paths(R, C, blocked) == 0 def test_large_case_no_blockages(): R, C = 1000, 1000 blocked = [] # Hard to compute exact number, but it should be > 0 assert count_paths(R, C, blocked) > 0 def test_corner_blocked(): R, C = 3, 3 blocked = [(1, 1)] assert count_paths(R, C, blocked) == 0 def test_path_blocked_midway(): R, C = 3, 3 blocked = [(2, 2)] assert count_paths(R, C, blocked) == 2","solution":"def count_paths(R, C, blocked_cells): MOD = 10**9 + 7 # Create the dp table, initialized to zeroes dp = [[0] * C for _ in range(R)] # If the starting point is blocked, return 0 as no path is possible if (1, 1) in blocked_cells: return 0 # Initialize the starting point dp[0][0] = 1 # Convert blocked_cells to a set for O(1) lookups blocked_set = set((r-1, c-1) for r, c in blocked_cells) for r in range(R): for c in range(C): if (r, c) in blocked_set: dp[r][c] = 0 else: if r > 0: dp[r][c] = (dp[r][c] + dp[r-1][c]) % MOD if c > 0: dp[r][c] = (dp[r][c] + dp[r][c-1]) % MOD # The value at the bottom-right corner of the grid is our answer. return dp[R-1][C-1]"},{"question":"from typing import List def highest_improvement(sales_data: List[List[int]]) -> int: Find the salesperson who has made the maximum improvement in terms of sales compared to the previous month. Args: sales_data: List of Lists - a list of sub-arrays where each sub-array represents the sales data of a salesperson. Returns: int: The 0-based index of the salesperson with the highest improvement in sales between any two consecutive months. >>> highest_improvement([[5, 10, 15, 20], [3, 8, 12, 20], [6, 15, 9, 12]]) 2 >>> highest_improvement([[5, 8, 10, 12], [0, 0, 0, 0], [1, 2, 3, 1], [4, 9, 10, 11]]) 3","solution":"from typing import List def highest_improvement(sales_data: List[List[int]]) -> int: max_improvement = -1 best_salesperson_index = -1 for i, sales in enumerate(sales_data): for j in range(1, len(sales)): improvement = sales[j] - sales[j-1] if improvement > max_improvement: max_improvement = improvement best_salesperson_index = i return best_salesperson_index"},{"question":"def findTriplets(arr): Determines if there are three distinct elements in the array that sum to zero. Parameters: arr (List[int]): The input array of integers. Returns: str: \\"Yes\\" if there is a triplet in the array with sum zero, otherwise \\"No\\". pass def test_findTriplets(): assert findTriplets([-1, 0, 1, 2, -1, -4]) == \\"Yes\\" assert findTriplets([1, 2, 3]) == \\"No\\" assert findTriplets([0, -1, 2, -3, 1]) == \\"Yes\\" assert findTriplets([1, -2, 1, 0, 5]) == \\"Yes\\" assert findTriplets([]) == \\"No\\" assert findTriplets([0, 0, 0]) == \\"Yes\\" assert findTriplets([-1, -1, -1, 2]) == \\"Yes\\" assert findTriplets([10, 20, -10, -10, -30, 10]) == \\"Yes\\"","solution":"def findTriplets(arr): Determines if there are three distinct elements in the array that sum to zero. Parameters: arr (List[int]): The input array of integers. Returns: str: \\"Yes\\" if there is a triplet in the array with sum zero, otherwise \\"No\\". arr.sort() n = len(arr) for i in range(n-2): if i > 0 and arr[i] == arr[i-1]: continue left, right = i + 1, n - 1 while left < right: current_sum = arr[i] + arr[left] + arr[right] if current_sum == 0: return \\"Yes\\" elif current_sum < 0: left += 1 else: right -= 1 return \\"No\\""},{"question":"def can_be_non_decreasing(n: int, seq: List[int]) -> str: Determines if a sequence can be rearranged into non-decreasing order by reversing subarrays. Args: n : int : Length of the sequence. seq : List[int] : The sequence of integers. Returns: str : \\"YES\\" if the sequence can be rearranged into non-decreasing order, \\"NO\\" otherwise. Examples: >>> can_be_non_decreasing(3, [3, 1, 2]) 'YES' >>> can_be_non_decreasing(4, [4, 3, 2, 1]) 'YES' >>> can_be_non_decreasing(4, [1, 2, 4, 3]) 'YES'","solution":"def can_be_non_decreasing(n, seq): Determines if a sequence can be rearranged into non-decreasing order by reversing subarrays. Args: n : int : Length of the sequence. seq : List[int] : The sequence of integers. Returns: str : \\"YES\\" if the sequence can be rearranged into non-decreasing order, \\"NO\\" otherwise. # A sequence can be made non-decreasing if it is a permutation of a non-decreasing sequence return \\"YES\\" if seq == sorted(seq) else \\"YES\\""},{"question":"def count_unique_tokens(token_string): Determines the number of unique tokens in the list and counts their occurrences. Parameters: token_string (str): A string representing a list of tokens of size N separated by commas. Returns: list: A list of strings where the first element is the number of unique tokens and the rest are each unique token followed by a space and its count. Examples: >>> count_unique_tokens(\\"apple,banana,apple,orange,banana,apple\\") ['3', 'apple 3', 'banana 2', 'orange 1'] >>> count_unique_tokens(\\"apple\\") ['1', 'apple 1'] >>> count_unique_tokens(\\"apple,banana,orange\\") ['3', 'apple 1', 'banana 1', 'orange 1'] >>> count_unique_tokens(\\"apple,apple,apple\\") ['1', 'apple 3'] >>> count_unique_tokens(\\"apple,banana,apple,banana,orange,apple\\") ['3', 'apple 3', 'banana 2', 'orange 1'] pass","solution":"def count_unique_tokens(token_string): Returns the number of unique tokens and their counts in the order they first appeared. Params: token_string (str): A string representing a list of tokens separated by commas Returns: list: A list of strings where the first element is the number of unique tokens and the rest are formatted strings of each unique token followed by its count tokens = token_string.split(',') token_count = {} unique_tokens = [] for token in tokens: if token not in token_count: unique_tokens.append(token) token_count[token] = token_count.get(token, 0) + 1 result = [str(len(unique_tokens))] for token in unique_tokens: result.append(f\\"{token} {token_count[token]}\\") return result"},{"question":"def maxCoins_from_input(n: int, nums: List[int]) -> int: Maximize points by bursting balloons. Args: n (int): The number of balloons. nums (List[int]): List of integers representing the numbers on the balloons. Returns: int: The maximum points that can be collected by bursting the balloons in the best order. >>> maxCoins_from_input(4, [3, 1, 5, 8]) 167 >>> maxCoins_from_input(1, [3]) 3 >>> maxCoins_from_input(2, [3, 1]) 6 >>> maxCoins_from_input(4, [1, 1, 1, 1]) 4 >>> maxCoins_from_input(0, []) 0","solution":"def maxCoins(nums): Maximize points by bursting balloons. nums = [1] + nums + [1] n = len(nums) dp = [[0] * n for _ in range(n)] for length in range(2, n): for left in range(0, n - length): right = left + length for k in range(left + 1, right): dp[left][right] = max(dp[left][right], nums[left] * nums[k] * nums[right] + dp[left][k] + dp[k][right]) return dp[0][n - 1] def maxCoins_from_input(n, nums): return maxCoins(nums)"},{"question":"def count_dominant_elements(matrix): Counts the number of dominant elements in a given square matrix. A dominant element is defined as an element which is greater than or equal to all other elements in its row and column. >>> count_dominant_elements([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 1 >>> count_dominant_elements([[5, 1], [3, 4]]) 2 >>> count_dominant_elements([[10, 20, 30, 40], [50, 60, 70, 80], [90, 100, 110, 120], [130, 140, 150, 160]]) 1 >>> count_dominant_elements([[42]]) 1 >>> count_dominant_elements([[7, 7, 7], [7, 7, 7], [7, 7, 7]]) 9 >>> count_dominant_elements([[1, 2], [3, 4]]) 1","solution":"def count_dominant_elements(matrix): This function counts the number of dominant elements in a given square matrix. A dominant element is defined as an element which is greater than or equal to all other elements in its row and column. n = len(matrix) dominant_count = 0 for i in range(n): for j in range(n): row_max = max(matrix[i]) col_max = max(matrix[k][j] for k in range(n)) if matrix[i][j] == row_max and matrix[i][j] == col_max: dominant_count += 1 return dominant_count # Example to execute the function if __name__ == \\"__main__\\": n = int(input()) matrix = [list(map(int, input().split())) for _ in range(n)] print(count_dominant_elements(matrix))"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def rotateRight(head: ListNode, k: int) -> ListNode: Rotate the linked list to the right by k places. >>> head = ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5))))) >>> new_head = rotateRight(head, 2) >>> [new_head.val, new_head.next.val, new_head.next.next.val, new_head.next.next.next.val, new_head.next.next.next.next.val] [4, 5, 1, 2, 3] >>> head = ListNode(0, ListNode(1, ListNode(2))) >>> new_head = rotateRight(head, 4) >>> [new_head.val, new_head.next.val, new_head.next.next.val] [2, 0, 1]","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def rotateRight(head, k): if not head or not head.next or k == 0: return head # Compute the length of the list old_tail = head length = 1 while old_tail.next: old_tail = old_tail.next length += 1 # Connect the tail with the head to form a circular list old_tail.next = head # Find the new tail: (length - k % length - 1)th node # and the new head: (length - k % length)th node new_tail = head steps_to_new_head = length - k % length - 1 for i in range(steps_to_new_head): new_tail = new_tail.next new_head = new_tail.next # Break the circle new_tail.next = None return new_head"},{"question":"def distribute_feeds(bag_weight: int, duck_weights: List[int]) -> List[int]: Distributes the given bag_weight of bird feed among the ducks as evenly as possible. Parameters: - bag_weight: int, the total weight of the bird feed in grams. - duck_weights: List[int], the desired weight of feed in grams for each duck. Returns: - List[int], the actual amount of feed each duck will get. >>> distribute_feeds(100, [20, 30, 50]) [20, 30, 50] >>> distribute_feeds(100, [25, 35, 40]) [25, 35, 40] >>> distribute_feeds(80, [25, 25, 25]) [27, 27, 26] >>> distribute_feeds(0, [10, 20, 30]) [0, 0, 0] >>> distribute_feeds(50, [50]) [50] >>> distribute_feeds(10, [30, 30, 40]) [3, 3, 4] >>> distribute_feeds(50, [10, 10, 10, 10, 10]) [10, 10, 10, 10, 10] >>> distribute_feeds(100, [10, 20, 30, 40]) [10, 20, 30, 40] >>> distribute_feeds(99, [10, 20, 30, 40]) [10, 20, 30, 39] >>> distribute_feeds(101, [25, 25, 25, 25]) [26, 25, 25, 25]","solution":"def distribute_feeds(bag_weight, duck_weights): Distributes the given bag_weight of bird feed among the ducks as evenly as possible. Parameters: - bag_weight: int, the total weight of the bird feed in grams. - duck_weights: List[int], the desired weight of feed in grams for each duck. Returns: - List[int], the actual amount of feed each duck will get. n = len(duck_weights) if bag_weight == 0: return [0] * n total_desired = sum(duck_weights) feed_per_duck = [0] * n # Calculate the proportion of feed each duck should get for i in range(n): feed_per_duck[i] = (duck_weights[i] * bag_weight) // total_desired # Calculate the total feed distributed and the remaining feed distributed_feed_total = sum(feed_per_duck) remaining_feed = bag_weight - distributed_feed_total # Distribute the remaining feed starting from the beginning of the list i = 0 while remaining_feed > 0: feed_per_duck[i] += 1 remaining_feed -= 1 i = (i + 1) % n return feed_per_duck"},{"question":"def max_subarray(arr): Returns the sum of the largest subarray, and the start and end indices of that subarray. >>> max_subarray([-2, 1, -3, 4, -1, 2, 1, -5, 4]) (6, 3, 6) >>> max_subarray([5]) (5, 0, 0) >>> max_subarray([-5, -1, -8, -9]) (-1, 1, 1) >>> max_subarray([5, -2, 3, -1, 2]) (7, 0, 4) >>> max_subarray([0, 0, 0, 0]) (0, 0, 0) >>> max_subarray([-3, 4, -1, 2, 1, -5, 4]) (6, 1, 4)","solution":"def max_subarray(arr): Returns the sum of the largest subarray, and the start and end indices of that subarray. n = len(arr) max_sum = -float('inf') current_sum = 0 start = 0 end = 0 s = 0 for i in range(n): current_sum += arr[i] if current_sum > max_sum: max_sum = current_sum start = s end = i if current_sum < 0: current_sum = 0 s = i + 1 return max_sum, start, end # Example usage # arr = [-2, 1, -3, 4, -1, 2, 1, -5, 4] # print(max_subarray(arr)) # Output: (6, 3, 6)"},{"question":"def removeDuplicates(s: str) -> str: Given a string consisting of lowercase alphabets, removes all duplicate characters from the string and returns the resultant string with the relative order of characters preserved. >>> removeDuplicates(\\"geeksforgeeks\\") \\"geksfor\\" >>> removeDuplicates(\\"mississippi\\") \\"misp\\"","solution":"def removeDuplicates(s): Removes all duplicate characters from the string s while preserving the relative order of characters. Parameters: s (str): The input string consisting of lowercase alphabets. Returns: str: The resultant string with duplicates removed. seen = set() result = [] for char in s: if char not in seen: seen.add(char) result.append(char) return ''.join(result)"},{"question":"import numpy as np def transpose_and_flatten(N, M, array): Transpose and Flatten a given N x M integer array. Parameters: N (int): The number of rows in the array. M (int): The number of columns in the array. array (List[List[int]]): The N x M array to transpose and flatten. Returns: Tuple[np.ndarray, np.ndarray]: A tuple containing the transposed and flattened arrays. >>> N = 2 >>> M = 3 >>> array = [ >>> [1, 2, 3], >>> [4, 5, 6] >>> ] >>> transpose_and_flatten(N, M, array) (array([[1, 4], [2, 5], [3, 6]]), array([1, 2, 3, 4, 5, 6]))","solution":"import numpy as np def transpose_and_flatten(N, M, array): # Convert the list of lists into a NumPy array np_array = np.array(array) # Perform the transpose transposed = np_array.T # Perform the flatten operation flattened = np_array.flatten() return transposed, flattened"},{"question":"def min_remove_to_balance_parentheses(s): Remove the minimum number of parentheses to ensure every prefix has an equal number of '(' and ')'. >>> min_remove_to_balance_parentheses(\\"()()\\") \\"(()()\\" >>> min_remove_to_balance_parentheses(\\"(()))\\") \\"(())\\" pass def process_test_cases(T, test_cases): Process multiple test cases for minimum remove to balance parentheses. >>> process_test_cases(2, [\\"()()\\", \\"(()))\\"]) [\\"()()\\", \\"(())\\"] >>> process_test_cases(3, [\\"()()\\", \\"(()))\\", \\")))((\\"]) [\\"()()\\", \\"(())\\", \\"\\"] pass # Test cases def test_min_remove_to_balance_parentheses(): assert min_remove_to_balance_parentheses(\\"()()\\") == \\"()()\\" assert min_remove_to_balance_parentheses(\\"(()))\\") == \\"(())\\" assert min_remove_to_balance_parentheses(\\"((())())\\") == \\"((())())\\" assert min_remove_to_balance_parentheses(\\"(((())))\\") == \\"(((())))\\" assert min_remove_to_balance_parentheses(\\"))((\\") == \\"\\" def test_process_test_cases(): T = 2 test_cases = [\\"()()\\", \\"(()))\\"] expected = [\\"()()\\", \\"(())\\"] assert process_test_cases(T, test_cases) == expected T = 3 test_cases = [\\"()()\\", \\"(()))\\", \\")))((\\"] expected = [\\"()()\\", \\"(())\\", \\"\\"] assert process_test_cases(T, test_cases) == expected T = 1 test_cases = [\\"((()))\\"] expected = [\\"((()))\\"] assert process_test_cases(T, test_cases) == expected # Test with larger input T = 1 test_cases = [\\"(((())()((((()))))((())())))((())())\\"] expected = [\\"(((())()((((()))))((())())))((())())\\"] assert process_test_cases(T, test_cases) == expected","solution":"def min_remove_to_balance_parentheses(s): Remove the minimum number of parentheses to ensure every prefix has an equal number of '(' and ')'. :param s: String of balanced parentheses. :return: Resulting balanced parentheses string. left_count, right_count = 0, 0 result = [] # First pass: Remove excess ')' for char in s: if char == '(': left_count += 1 elif char == ')': if right_count < left_count: right_count += 1 else: continue result.append(char) left_count, right_count = 0, 0 final_result = [] # Second pass: Remove excess '(' from the right for char in reversed(result): if char == ')': right_count += 1 elif char == '(': if left_count < right_count: left_count += 1 else: continue final_result.append(char) return ''.join(reversed(final_result)) def process_test_cases(T, test_cases): results = [] for case in test_cases: results.append(min_remove_to_balance_parentheses(case)) return results"},{"question":"def min_operations_to_equal_distinct_characters(t, cases): Calculate the minimum number of operations to make the number of distinct characters in all strings the same. Args: t (int): The number of test cases. cases (List[Tuple[int, List[str]]]): A list of tuples where each tuple contains the number of strings and the list of strings. Returns: List[int]: A list of results for each test case, where each result is -1 if it is not possible to make the distinct characters equal, otherwise the minimum number of operations needed. >>> t = 2 >>> cases = [(3, [\\"abc\\", \\"bca\\", \\"cab\\"]), (2, [\\"abcd\\", \\"ef\\"])] >>> min_operations_to_equal_distinct_characters(t, cases) [0, -1] >>> t = 1 >>> cases = [(3, [\\"aaa\\", \\"aaa\\", \\"aaa\\"])] >>> min_operations_to_equal_distinct_characters(t, cases) [0] >>> t = 1 >>> cases = [(3, [\\"abc\\", \\"def\\", \\"ghi\\"])] >>> min_operations_to_equal_distinct_characters(t, cases) [-1] >>> t = 1 >>> cases = [(1, [\\"xyz\\"])] >>> min_operations_to_equal_distinct_characters(t, cases) [0] >>> t = 1 >>> cases = [(4, [\\"abcd\\", \\"efg\\", \\"hij\\", \\"klmn\\"])] >>> min_operations_to_equal_distinct_characters(t, cases) [-1]","solution":"def min_operations_to_equal_distinct_characters(t, cases): results = [] for i in range(t): n = cases[i][0] strings = cases[i][1] # Collect the count of each character for total validation from collections import Counter total_count = Counter() for s in strings: total_count.update(s) # Check if each character count is divisible by the number of strings for count in total_count.values(): if count % n != 0: results.append(-1) break else: results.append(0) return results"},{"question":"def assign_grades(students_scores: dict) -> dict: Assign grades based on the scores of students. >>> assign_grades({\\"John\\": 85, \\"Jane\\": 92, \\"Dave\\": 78, \\"Dana\\": 63, \\"Mike\\": 58}) {'John': 'B', 'Jane': 'A', 'Dave': 'C', 'Dana': 'D', 'Mike': 'F'} >>> assign_grades({\\"John\\": 90, \\"Doe\\": 80, \\"Jane\\": 70, \\"Dana\\": 60, \\"Mike\\": 59}) {'John': 'A', 'Doe': 'B', 'Jane': 'C', 'Dana': 'D', 'Mike': 'F'} >>> assign_grades({\\"John\\": 95, \\"Jane\\": 93, \\"Jake\\": 95, \\"Jill\\": 99, \\"Jack\\": 100}) {'John': 'A', 'Jane': 'A', 'Jake': 'A', 'Jill': 'A', 'Jack': 'A'} >>> assign_grades({\\"Failing\\": 0, \\"Low\\": 10, \\"Medium\\": 50, \\"Almost\\": 59, \\"Passed\\": 60}) {'Failing': 'F', 'Low': 'F', 'Medium': 'F', 'Almost': 'F', 'Passed': 'D'} >>> assign_grades({}) {} :param students_scores: Dictionary with student names as keys and their scores as values :return: Dictionary with student names as keys and their corresponding grades as values","solution":"def assign_grades(students_scores): Assigns grades based on the scores of students. :param students_scores: Dictionary with student names as keys and their scores as values :return: Dictionary with student names as keys and their corresponding grades as values grades = {} for student, score in students_scores.items(): if score >= 90: grades[student] = 'A' elif score >= 80: grades[student] = 'B' elif score >= 70: grades[student] = 'C' elif score >= 60: grades[student] = 'D' else: grades[student] = 'F' return grades"},{"question":"from typing import List, Tuple def can_create_invitation_list(n: int, m: int, friendships: List[Tuple[int, int]]) -> str: Determine if Limak can create a valid invitation list that satisfies the requirement that every invited friend knows at least one of the other friends on the list. >>> can_create_invitation_list(6, 4, [(1, 2), (2, 3), (4, 5), (5, 6)]) 'No' >>> can_create_invitation_list(5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)]) 'Yes' >>> can_create_invitation_list(1, 0, []) 'Yes' >>> can_create_invitation_list(3, 2, [(1, 2), (2, 3)]) 'Yes'","solution":"def can_create_invitation_list(n, m, friendships): from collections import defaultdict, deque if m == 0: return \\"Yes\\" if n <= 1 else \\"No\\" graph = defaultdict(list) for u, v in friendships: graph[u].append(v) graph[v].append(u) visited = set() components = 0 def bfs(node): queue = deque([node]) visited.add(node) while queue: current = queue.popleft() for neighbor in graph[current]: if neighbor not in visited: visited.add(neighbor) queue.append(neighbor) for person in range(1, n+1): if person not in visited: components += 1 bfs(person) if components > 1: return \\"No\\" return \\"Yes\\""},{"question":"def max_trains_at_station(t: int, test_cases: List[List[Tuple[int, int]]]) -> List[int]: Calculate the maximum number of trains at the station simultaneously for each test case. Args: t: the number of test cases. test_cases: A list that contains t elements, each being a list of tuples. Each tuple contains two integers representing the arrival and departure times of the trains. Returns: A list of integers, each representing the maximum number of trains at the station simultaneously for each test case. Example: >>> max_trains_at_station(2, [ ... [(100, 200), (150, 300), (200, 400)], ... [(900, 1000), (1000, 1100), (950, 1050), (1100, 1200)] ... ]) [2, 2] >>> max_trains_at_station(1, [ ... [(800, 900), (700, 800), (600, 700)] ... ]) [1]","solution":"def max_trains_at_station(t, test_cases): results = [] for trains in test_cases: events = [] for (arrival, departure) in trains: events.append((arrival, 1)) # Train arrives events.append((departure, -1)) # Train departs # Sort events. If two events occur at the same time, departures (-1) should come before arrivals (1). events.sort(key=lambda x: (x[0], x[1])) max_trains = 0 current_trains = 0 for event in events: current_trains += event[1] max_trains = max(max_trains, current_trains) results.append(max_trains) return results"},{"question":"def who_wins(N: int) -> str: Determines the winner of the game given an initial number of stones N. Bob starts first and both play optimally. Returns 'Bob' if Bob has a winning strategy, otherwise 'Alice'. >>> who_wins(1) 'Bob' >>> who_wins(2) 'Bob' >>> who_wins(3) 'Alice' >>> who_wins(4) 'Alice' >>> who_wins(5) 'Bob' >>> who_wins(6) 'Bob' >>> who_wins(7) 'Alice' >>> who_wins(8) 'Alice' >>> who_wins(1000000000) 'Alice' >>> who_wins(1000000001) 'Bob'","solution":"def who_wins(N): Determines the winner of the game given an initial number of stones N. Bob starts first and both play optimally. Returns 'Bob' if Bob has a winning strategy, otherwise 'Alice'. if N % 4 == 1 or N % 4 == 2: return \\"Bob\\" else: return \\"Alice\\""},{"question":"def can_split_with_higher_average(N: int, B: List[int]) -> str: Determine whether it is possible to split the array into two non-empty subarrays such that the average of elements in the first subarray is greater than the average of elements in the second subarray. Args: N : int : number of elements in the array B : List[int] : array of integers Returns: str : \\"YES\\" if it is possible to split the array as described, otherwise \\"NO\\" >>> can_split_with_higher_average(4, [1, 2, 3, 4]) \\"YES\\" >>> can_split_with_higher_average(3, [3, 3, 3]) \\"NO\\"","solution":"def can_split_with_higher_average(N, B): Returns \\"YES\\" if the array can be split into two subarrays such that the average of elements in the first subarray is greater than the average of elements in the second subarray. Otherwise, returns \\"NO\\". total_sum = sum(B) max_value = max(B) min_value = min(B) # Check if there is any element that can be a subarray of length 1 # and has a greater value compared to the average of the rest. if max_value > (total_sum - max_value) / (N - 1): return \\"YES\\" if min_value < (total_sum - min_value) / (N - 1): return \\"YES\\" return \\"NO\\""},{"question":"def unique_ways_to_serve(S: int, C: int, A: int) -> int: Returns the total number of unique ways to serve the coffee. Args: S (int): Number of different coffee sizes. C (int): Number of different cup types. A (int): Number of optional add-ons. Returns: int: Total number of unique ways to serve the coffee. def test_unique_ways_to_serve_sample_1(): assert unique_ways_to_serve(3, 4, 2) == 24 def test_unique_ways_to_serve_sample_2(): assert unique_ways_to_serve(1, 3, 3) == 9 def test_unique_ways_to_serve_no_add_ons(): assert unique_ways_to_serve(3, 4, 1) == 12 def test_unique_ways_to_serve_single_variant(): assert unique_ways_to_serve(1, 1, 1) == 1 def test_unique_ways_to_serve_more_complex_case(): assert unique_ways_to_serve(5, 6, 7) == 210 def test_unique_ways_to_serve_large_numbers(): assert unique_ways_to_serve(100, 200, 300) == 6000000","solution":"def unique_ways_to_serve(S, C, A): Returns the total number of unique ways to serve the coffee. Args: S (int): Number of different coffee sizes. C (int): Number of different cup types. A (int): Number of optional add-ons. Returns: int: Total number of unique ways to serve the coffee. return S * C * A"},{"question":"import random import string def generate_unique_id() -> str: Generates a random 10-character alphanumeric string that contains at least one uppercase letter, one lowercase letter, and one digit. >>> len(generate_unique_id()) == 10 True >>> any(c.isupper() for c in generate_unique_id()) True >>> any(c.islower() for c in generate_unique_id()) True >>> any(c.isdigit() for c in generate_unique_id()) True","solution":"import random import string def generate_unique_id(): Generates a random 10-character alphanumeric string that contains at least one uppercase letter, one lowercase letter, and one digit. # Generate one uppercase letter, one lowercase letter, and one digit upper_case = random.choice(string.ascii_uppercase) lower_case = random.choice(string.ascii_lowercase) digit = random.choice(string.digits) # Generate the rest of the 7 characters randomly from alphanumeric characters remaining_characters = [random.choice(string.ascii_letters + string.digits) for _ in range(7)] # Combine all characters and shuffle them to ensure randomness unique_id_list = [upper_case, lower_case, digit] + remaining_characters random.shuffle(unique_id_list) return ''.join(unique_id_list)"},{"question":"def is_path_exists(N: int, grid: List[List[int]]) -> str: Determines if there is a path for the robot to reach the bottom-right corner of the grid from the top-left corner. The robot can only move right (R) or down (D) and must avoid blocked cells. :param N: Size of the grid (NxN). :param grid: 2D list representing the grid where 0 is open and 1 is blocked. :return: 'Yes' if a path exists, 'No' otherwise. >>> is_path_exists(4, [[0, 0, 0, 0], [0, 1, 0, 1], [0, 0, 0, 1], [1, 1, 0, 0]]) == 'Yes' >>> is_path_exists(3, [[0, 1, 0], [1, 0, 0], [0, 0, 1]]) == 'No'","solution":"def is_path_exists(N, grid): Determines if there is a path from the top-left corner to the bottom-right corner of the grid, moving only right or down, and avoiding blocked cells. :param N: Size of the grid (NxN) :param grid: 2D list representing the grid where 0 is open and 1 is blocked :return: 'Yes' if a path exists, 'No' otherwise def dfs(x, y, visited): if x == N - 1 and y == N - 1: return True for dx, dy in [(1, 0), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < N and 0 <= ny < N and (nx, ny) not in visited and grid[nx][ny] == 0: visited.add((nx, ny)) if dfs(nx, ny, visited): return True visited.remove((nx, ny)) return False if grid[0][0] == 1 or grid[N-1][N-1] == 1: return 'No' visited = set() visited.add((0, 0)) return 'Yes' if dfs(0, 0, visited) else 'No'"},{"question":"def fibonacci(n): Generate a list of the first n Fibonacci numbers. Args: n (int): The number of Fibonacci numbers to generate (0 ≤ n ≤ 30). Returns: list: A list containing the first n Fibonacci numbers. # Your code here def test_fibonacci_zero_elements(): assert fibonacci(0) == [] def test_fibonacci_one_element(): assert fibonacci(1) == [0] def test_fibonacci_two_elements(): assert fibonacci(2) == [0, 1] def test_fibonacci_five_elements(): assert fibonacci(5) == [0, 1, 1, 2, 3] def test_fibonacci_ten_elements(): assert fibonacci(10) == [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] def test_fibonacci_max_elements(): assert fibonacci(30) == [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 17711, 28657, 46368, 75025, 121393, 196418, 317811, 514229]","solution":"def fibonacci(n): Generates a list of the first n Fibonacci numbers. Args: n (int): The number of Fibonacci numbers to generate (0 ≤ n ≤ 30). Returns: list: A list containing the first n Fibonacci numbers. if n == 0: return [] if n == 1: return [0] fib_sequence = [0, 1] for i in range(2, n): fib_sequence.append(fib_sequence[-1] + fib_sequence[-2]) return fib_sequence"},{"question":"def array_deduplicate(input_list): Returns a new list containing unique elements from the given list, maintaining the order of their first occurrence. >>> array_deduplicate([4, 5, 5, 4, 3, 2, 2, 7]) [4, 5, 3, 2, 7] >>> array_deduplicate(['a', 'b', 'a', 'c', 'a', 'b']) ['a', 'b', 'c'] >>> array_deduplicate([1, 'a', 1, 'b', 'a', 2]) [1, 'a', 'b', 2] >>> array_deduplicate([]) [] >>> array_deduplicate([1]) [1]","solution":"def array_deduplicate(input_list): Returns a new list containing unique elements from the given list, maintaining the order of their first occurrence. seen = set() unique_list = [] for item in input_list: if item not in seen: unique_list.append(item) seen.add(item) return unique_list"},{"question":"def visitOffices(n: int, m: int, employees: List[Tuple[int, int]], offices: List[Tuple[int, int]]) -> List[int]: Calculate the minimum distance each employee needs to travel to visit the nearest office. >>> visitOffices(3, 2, [(1, 2), (3, 4), (5, 6)], [(2, 3), (4, 5)]) [2, 2, 2] >>> visitOffices(1, 1, [(4, 4)], [(1, 1)]) [6] >>> visitOffices(2, 3, [(1, 1), (10, 10)], [(1, 2), (3, 3), (6, 6)]) [1, 8] >>> visitOffices(2, 2, [(1000000, 1000000), (500000, 500000)], [(0, 0), (1000000, 500000)]) [500000, 500000]","solution":"def visitOffices(n, m, employees, offices): min_distances = [] for e_x, e_y in employees: min_distance = float('inf') for o_x, o_y in offices: distance = abs(e_x - o_x) + abs(e_y - o_y) if distance < min_distance: min_distance = distance min_distances.append(min_distance) return min_distances"},{"question":"def min_modifications_to_k_alternating(n: int, k: int, arr: List[int]) -> int: Calculate the minimum modifications required to make an array a k-alternating sequence. Args: n (int): Length of the array. k (int): Maximum length of contiguous subsequence of the same element. arr (List[int]): The array of integers. Returns: int: The minimum number of modifications required. Examples: >>> min_modifications_to_k_alternating(6, 2, [1, 1, 3, 3, 3, 3]) 2 >>> min_modifications_to_k_alternating(5, 1, [2, 2, 2, 2, 2]) 4","solution":"def min_modifications_to_k_alternating(n, k, arr): if k == 1: return n - 1 modifications = 0 i = 0 while i < n: count = 1 # count the length of the current segment of the same elements while i + count < n and arr[i] == arr[i + count]: count += 1 # calculate necessary changes if count > k: modifications += count - k i += count return modifications"},{"question":"def lexicographically_smallest_strings(T, test_cases): Given the number of test cases T and a list of strings test_cases, returns the lexicographically smallest strings that can be formed by rearranging the characters of each input string. Parameters: T (int): Number of test cases. test_cases (List[str]): List of strings to be processed. Returns: List[str]: List of lexicographically smallest strings for each test case. >>> lexicographically_smallest_strings(3, [\\"bca\\", \\"zxy\\", \\"banana\\"]) ['abc', 'xyz', 'aaabnn'] >>> lexicographically_smallest_strings(1, [\\"hello\\"]) ['ehllo'] >>> lexicographically_smallest_strings(2, [\\"world\\", \\"python\\"]) ['dlorw', 'hnopty']","solution":"def lexicographically_smallest_strings(T, test_cases): Given the number of test cases T and a list of strings test_cases, returns the lexicographically smallest strings that can be formed by rearranging the characters of each input string. result = [] for S in test_cases: result.append(\\"\\".join(sorted(S))) return result"},{"question":"def is_path_exists(n: int, m: int, grid: List[List[str]]) -> str: Determine if a path exists from the top-left corner to the bottom-right corner in a given n x m grid of 'S' (safe) and 'B' (blocked) cells. >>> grid = [ ['S', 'S', 'S'], ['B', 'S', 'B'], ['S', 'S', 'S'] ] >>> is_path_exists(3, 3, grid) 'YES' >>> grid = [ ['S', 'B', 'S'], ['B', 'B', 'S'], ['S', 'S', 'S'] ] >>> is_path_exists(3, 3, grid) 'NO' def test_is_path_exists(): grid = [ ['S', 'S', 'S'], ['B', 'S', 'B'], ['S', 'S', 'S'] ] assert is_path_exists(3, 3, grid) == \\"YES\\" grid = [ ['S', 'B', 'S'], ['B', 'B', 'S'], ['S', 'S', 'S'] ] assert is_path_exists(3, 3, grid) == \\"NO\\" grid1 = [ ['B', 'S', 'S'], ['S', 'S', 'S'], ['S', 'S', 'S'] ] assert is_path_exists(3, 3, grid1) == \\"NO\\" grid2 = [ ['S', 'S', 'S'], ['S', 'S', 'S'], ['S', 'S', 'B'] ] assert is_path_exists(3, 3, grid2) == \\"NO\\" grid = [['S']] assert is_path_exists(1, 1, grid) == \\"YES\\" grid = [['B']] assert is_path_exists(1, 1, grid) == \\"NO\\" grid = [['S'] * 50 for _ in range(50)] grid[25][25] = 'B' assert is_path_exists(50, 50, grid) == \\"YES\\" grid = [['S' if i < 48 else 'B' for i in range(50)] for j in range(50)] assert is_path_exists(50, 50, grid) == \\"NO\\"","solution":"def is_path_exists(n, m, grid): if grid[0][0] == 'B' or grid[n-1][m-1] == 'B': return \\"NO\\" # Define a helper function to check if the move is within bounds and to a 'S' cell def is_safe(x, y): return 0 <= x < n and 0 <= y < m and grid[x][y] == 'S' # Use a queue for BFS from collections import deque queue = deque([(0, 0)]) visited = set() visited.add((0, 0)) while queue: x, y = queue.popleft() if (x, y) == (n-1, m-1): return \\"YES\\" # Move right if is_safe(x, y+1) and (x, y+1) not in visited: visited.add((x, y+1)) queue.append((x, y+1)) # Move down if is_safe(x+1, y) and (x+1, y) not in visited: visited.add((x+1, y)) queue.append((x+1, y)) return \\"NO\\""},{"question":"def calculate_pass_fail(grades: List[float]) -> str: Determines if a student passes or fails based on an average of five grades. Parameters: grades (list of float): The list containing five subject grades. Returns: str: \\"Pass\\" if the average grade is 5.0 or higher, otherwise \\"Fail\\". >>> calculate_pass_fail([4.5, 6.0, 5.5, 7.0, 8.0]) == \\"Pass\\" >>> calculate_pass_fail([4.5, 4.0, 3.5, 5.0, 6.0]) == \\"Fail\\" >>> calculate_pass_fail([5.0, 5.0, 5.0, 5.0, 5.0]) == \\"Pass\\" >>> calculate_pass_fail([10.0, 8.0, 9.5, 7.5, 9.0]) == \\"Pass\\" >>> calculate_pass_fail([0.0, 2.5, 4.0, 3.0, 4.5]) == \\"Fail\\" >>> calculate_pass_fail([5.0, 6.0, 7.0, 8.0, 9.0]) == \\"Pass\\" >>> calculate_pass_fail([1.0, 2.0, 3.0, 4.0, 5.0]) == \\"Fail\\" >>> calculate_pass_fail([10.0, 10.0, 10.0, 10.0, 10.0]) == \\"Pass\\" >>> calculate_pass_fail([5.0, 4.9, 5.1, 5.0, 5.0]) == \\"Pass\\" >>> calculate_pass_fail([4.9, 4.9, 4.9, 4.9, 4.9]) == \\"Fail\\" if __name__ == \\"__main__\\": grades = list(map(float, input().split())) print(calculate_pass_fail(grades))","solution":"def calculate_pass_fail(grades): Determines if a student passes or fails based on an average of five grades. Parameters: grades (list of float): The list containing five subject grades. Returns: str: \\"Pass\\" if the average grade is 5.0 or higher, otherwise \\"Fail\\". average_grade = sum(grades) / len(grades) if average_grade >= 5.0: return \\"Pass\\" else: return \\"Fail\\" # Read grades from input if __name__ == \\"__main__\\": grades = list(map(float, input().split())) print(calculate_pass_fail(grades))"},{"question":"def twinPrimes(n): Returns all twin primes up to n (inclusive). >>> twinPrimes(20) [(3, 5), (5, 7), (11, 13), (17, 19)] >>> twinPrimes(1) [] >>> twinPrimes(50) [(3, 5), (5, 7), (11, 13), (17, 19), (29, 31), (41, 43)]","solution":"def is_prime(num): Helper function to check if a number is a prime number. if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def twinPrimes(n): Returns all twin primes up to n (inclusive). if not isinstance(n, int) or n <= 1: return [] primes = [num for num in range(2, n + 1) if is_prime(num)] twin_prime_pairs = [(primes[i], primes[i + 1]) for i in range(len(primes) - 1) if primes[i + 1] - primes[i] == 2] return twin_prime_pairs"},{"question":"class FenwickTree: def __init__(self, size): self.size = size self.tree = [0] * (size + 1) def update(self, index, delta): Increment the value at index by delta in the Fenwick Tree. while index <= self.size: self.tree[index] += delta index += index & -index def query(self, index): Return the prefix sum from index 1 to index. sum = 0 while index > 0: sum += self.tree[index] index -= index & -index return sum def initialize_fenwick_tree(arr): Initialize the Fenwick Tree with the given array of integers. n = len(arr) fenwick_tree = FenwickTree(n) for i in range(n): fenwick_tree.update(i + 1, arr[i]) return fenwick_tree def process_queries(n, arr, queries): Process a series of queries on the given sequence of integers. Args: n (int): Number of integers in the sequence. arr (List[int]): The sequence of integers. queries (List[List[int]]): List of queries to process. Returns: List[int]: The results of the sum queries. fenwick_tree = initialize_fenwick_tree(arr) results = [] for query in queries: if query[0] == 1: _, i, x = query fenwick_tree.update(i, x) elif query[0] == 2: _, l, r = query sum_range = fenwick_tree.query(r) - fenwick_tree.query(l - 1) results.append(sum_range) return results def test_fenwick_tree(): arr = [3, 2, 1, 4, 5] queries = [ [2, 1, 3], # sum of elements from index 1 to 3 -> 3 + 2 + 1 = 6 [1, 2, 3], # increment element at index 2 by 3 -> [3, 5, 1, 4, 5] [2, 1, 3], # sum of elements from index 1 to 3 -> 3 + 5 + 1 = 9 [2, 1, 5] # sum of elements from index 1 to 5 -> 3 + 5 + 1 + 4 + 5 = 18 ] expected_output = [6, 9, 18] assert process_queries(5, arr, queries) == expected_output def test_fenwick_tree_single_element(): arr = [42] queries = [ [2, 1, 1], # sum of element at index 1 -> 42 [1, 1, 8], # increment element at index 1 by 8 -> [50] [2, 1, 1], # sum of element at index 1 -> 50 ] expected_output = [42, 50] assert process_queries(1, arr, queries) == expected_output def test_fenwick_tree_no_query(): arr = [10, 20, 30] queries = [] expected_output = [] assert process_queries(3, arr, queries) == expected_output def test_fenwick_tree_large_increment(): arr = [1, 2, 3, 4, 5] queries = [ [2, 1, 5], # sum of elements from index 1 to 5 -> 1 + 2 + 3 + 4 + 5 = 15 [1, 3, 1000000000], # increment element at index 3 by 1000000000 -> [1, 2, 1000000003, 4, 5] [2, 1, 5], # sum of elements from index 1 to 5 -> 1 + 2 + 1000000003 + 4 + 5 = 1000000015 ] expected_output = [15, 1000000015] assert process_queries(5, arr, queries) == expected_output","solution":"class FenwickTree: def __init__(self, size): self.size = size self.tree = [0] * (size + 1) def update(self, index, delta): while index <= self.size: self.tree[index] += delta index += index & -index def query(self, index): sum = 0 while index > 0: sum += self.tree[index] index -= index & -index return sum def initialize_fenwick_tree(arr): n = len(arr) fenwick_tree = FenwickTree(n) for i in range(n): fenwick_tree.update(i + 1, arr[i]) return fenwick_tree def process_queries(n, arr, queries): fenwick_tree = initialize_fenwick_tree(arr) results = [] for query in queries: if query[0] == 1: _, i, x = query fenwick_tree.update(i, x) elif query[0] == 2: _, l, r = query sum_range = fenwick_tree.query(r) - fenwick_tree.query(l - 1) results.append(sum_range) return results"},{"question":"def dispense_order(N, C): Determine the order of items dispensed from the vending machine. >>> dispense_order(3, 2) [1, 2, 3, 1, 2, 3] >>> dispense_order(4, 1) [1, 2, 3, 4] def vending_machine(T, cases): For each test case, determine the order of items dispensed from the vending machine. >>> vending_machine(2, [(3, 2), (4, 1)]) [[1, 2, 3, 1, 2, 3], [1, 2, 3, 4]]","solution":"def dispense_order(N, C): result = [] for i in range(C): for j in range(1, N+1): result.append(j) return result def vending_machine(T, cases): results = [] for case in cases: N, C = case results.append(dispense_order(N, C)) return results"},{"question":"def parking_lot_operations(N: int, initial_config: str, operations: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Simulate the operations on a parking lot and return the result after each query operation. Args: N: The number of positions in the parking lot. initial_config: A string representing the initial configuration of the parking lot. operations: A list of tuples where each tuple contains the type of operation and the position P. Returns: A list of tuples where each tuple contains the number of cars parked and the longest continuous empty space after a query operation (type 3). Examples: >>> N = 8 >>> initial_config = \\"CCEECCEE\\" >>> operations = [(3, 0), (1, 5), (3, 0), (2, 2), (3, 0)] >>> parking_lot_operations(N, initial_config, operations) [(4, 2), (4, 2), (3, 3)] pass","solution":"def parking_lot_operations(N, initial_config, operations): parking_lot = list(initial_config) operation_results = [] def count_cars_and_longest_empty_sequence(): cars = parking_lot.count('C') longest_empty = 0 current_empty = 0 for spot in parking_lot: if spot == 'E': current_empty += 1 if current_empty > longest_empty: longest_empty = current_empty else: current_empty = 0 return cars, longest_empty for operation, P in operations: if operation == 1: if parking_lot[P-1] == 'E': parking_lot[P-1] = 'C' elif operation == 2: if parking_lot[P-1] == 'C': parking_lot[P-1] = 'E' elif operation == 3: cars, longest_empty = count_cars_and_longest_empty_sequence() operation_results.append((cars, longest_empty)) return operation_results"},{"question":"def can_form_contiguous_panorama(n: int, segments: List[int]) -> str: Determines if the given segments can be arranged to form a contiguous panorama. Args: n : int : the number of photos segments : List[int] : the segments each photo captures Returns: str : \\"YES\\" if the segments can be arranged contiguously, otherwise \\"NO\\" >>> can_form_contiguous_panorama(4, [3, 1, 4, 2]) \\"YES\\" >>> can_form_contiguous_panorama(3, [1, 3, 5]) \\"NO\\" def test_can_form_contiguous_panorama(): assert can_form_contiguous_panorama(4, [3, 1, 4, 2]) == \\"YES\\" assert can_form_contiguous_panorama(3, [1, 3, 5]) == \\"NO\\" assert can_form_contiguous_panorama(5, [5, 4, 3, 2, 1]) == \\"YES\\" assert can_form_contiguous_panorama(2, [5, 7]) == \\"NO\\" assert can_form_contiguous_panorama(6, [8, 6, 7, 2, 5, 3]) == \\"NO\\" assert can_form_contiguous_panorama(3, [50, 49, 48]) == \\"YES\\" assert can_form_contiguous_panorama(7, [3, 5, 6, 7, 4, 2, 1]) == \\"YES\\" assert can_form_contiguous_panorama(3, [10, 12, 11]) == \\"YES\\" assert can_form_contiguous_panorama(4, [3, 2, 2, 4]) == \\"NO\\"","solution":"def can_form_contiguous_panorama(n, segments): Determines if the given segments can be arranged to form a contiguous panorama. Args: n : int : the number of photos segments : List[int] : the segments each photo captures Returns: str : \\"YES\\" if the segments can be arranged contiguously, otherwise \\"NO\\" # Sort the segments in ascending order segments.sort() # Check if each consecutive segment forms a contiguous range for i in range(1, n): if segments[i] != segments[i - 1] + 1: return \\"NO\\" return \\"YES\\""},{"question":"def max_consecutive_bookings(bookings, k): Find the maximum sum of room bookings for any k consecutive days. Parameters: bookings (list): List of integers representing the number of rooms booked on each day. k (int): Number of consecutive days. Returns: int: Maximum sum of bookings for any k consecutive days. Returns \\"error\\" if k is greater than the number of days or if k is less than 1. Examples: >>> max_consecutive_bookings([3, 2, 1, 5, 6, 3, 2], 3) 14 >>> max_consecutive_bookings([10, 20, 30, 40, 50], 2) 90 >>> max_consecutive_bookings([1, 2, 3, 4, 5], 1) 5 >>> max_consecutive_bookings([5, 1, 3, 2, 8, 2], 4) 15 >>> max_consecutive_bookings([3, 2, 1], 4) \\"error\\" >>> max_consecutive_bookings([3, 2, 1], 0) \\"error\\" >>> max_consecutive_bookings([], 1) \\"error\\" # Your code here","solution":"def max_consecutive_bookings(bookings, k): Find the maximum sum of room bookings for any k consecutive days. Parameters: bookings (list): List of integers representing number of rooms booked on each day. k (int): Number of consecutive days. Returns: int: Maximum sum of bookings for any k consecutive days. Returns \\"error\\" if k is greater than the number of days or if k is less than 1. if k > len(bookings) or k < 1: return \\"error\\" max_sum = 0 current_sum = sum(bookings[:k]) max_sum = current_sum for i in range(1, len(bookings) - k + 1): current_sum = current_sum - bookings[i - 1] + bookings[i + k - 1] if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"def can_reach(n: int, m: int, grid: List[str], sx: int, sy: int, tx: int, ty: int) -> str: Determine if you can reach the target position from the starting position on a grid. >>> can_reach(5, 5, [\\"FFFFF\\", \\"FBFFF\\", \\"FFFFB\\", \\"FFFFF\\", \\"FBFBF\\"], 0, 0, 4, 4) \\"yes\\" >>> can_reach(5, 5, [\\"FFFFF\\", \\"FBFFF\\", \\"FFFFB\\", \\"FFFFF\\", \\"BFBFB\\"], 0, 0, 4, 4) \\"no\\" >>> can_reach(2, 2, [\\"FF\\", \\"FB\\"], 0, 0, 1, 1) \\"no\\" >>> can_reach(3, 3, [\\"FFF\\", \\"FBF\\", \\"FFF\\"], 0, 0, 0, 0) \\"yes\\" >>> can_reach(5, 5, [\\"FFFFF\\", \\"BFFFB\\", \\"FBFFB\\", \\"BFFFF\\", \\"FFFFF\\"], 0, 0, 4, 4) \\"yes\\"","solution":"def can_reach(n, m, grid, sx, sy, tx, ty): if grid[sx][sy] == 'B' or grid[tx][ty] == 'B': return \\"no\\" def is_valid(x, y): return 0 <= x < n and 0 <= y < m and grid[x][y] == 'F' from collections import deque queue = deque([(sx, sy)]) visited = set() visited.add((sx, sy)) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] while queue: x, y = queue.popleft() if (x, y) == (tx, ty): return \\"yes\\" for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and (nx, ny) not in visited: queue.append((nx, ny)) visited.add((nx, ny)) return \\"no\\""},{"question":"def find_unique(nums): Find the number that appears only once in a list where every other number appears three times. The algorithm should have a linear runtime complexity and use constant extra space. >>> find_unique([2, 2, 3, 2]) 3 >>> find_unique([0, 1, 0, 1, 0, 1, 99]) 99 >>> find_unique([-2, -2, -3, -2, -3, -3, -1]) -1 >>> find_unique([5, 5, 5, 10, 10, 10, 6]) 6 >>> find_unique([7, 7, 7, 8]) 8 >>> find_unique([9]) 9 >>> find_unique([11, 11, 11, 8, 12, 12, 12]) 8 >>> find_unique([300000000, 300000000, 200000000, 300000000]) 200000000 >>> find_unique([2147483647, 2147483647, 2147483647, -2147483648]) -2147483648","solution":"def find_unique(nums): Find the number that appears only once in a list where every other number appears three times. This function uses bitwise operations for a linear runtime and constant space complexity. ones, twos = 0, 0 for num in nums: # \`twos\` is only set on bits that saw \`1\` two times so far. twos = twos | (ones & num) # \`ones\` is only set on bits that saw \`1\` one time. ones = ones ^ num # \`threes\` holds common bits of \`ones\` and \`twos\`. threes = ones & twos # Remove bits that appeared three times from \`ones\` and \`twos\`. ones = ones & ~threes twos = twos & ~threes return ones"},{"question":"def partition_labels(s: str) -> List[int]: Partitions the given string into as many parts as possible so that each letter appears in at most one part, and returns a list of integers representing the size of these parts. >>> partition_labels(\\"ababcbacadefegdehijhklij\\") [9, 7, 8] >>> partition_labels(\\"eccbbbbdec\\") [10] >>> partition_labels(\\"a\\") [1] >>> partition_labels(\\"abcde\\") [1, 1, 1, 1, 1] >>> partition_labels(\\"aaaaa\\") [5] >>> partition_labels(\\"aba\\") [3] >>> partition_labels(\\"caedbdedda\\") [1, 9]","solution":"def partition_labels(s: str): Partitions the given string into as many parts as possible so that each letter appears in at most one part, and returns a list of integers representing the size of these parts. Parameters: s (str): The input string Returns: List[int]: List representing sizes of the parts # Track the last occurrence of each character in the string last_occurrence = {char: idx for idx, char in enumerate(s)} partitions = [] start = end = 0 for i, char in enumerate(s): end = max(end, last_occurrence[char]) if i == end: partitions.append(end - start + 1) start = i + 1 return partitions"},{"question":"def sum_of_cubes_odd_numbers(N: int) -> int: Returns the sum of the cubes of the first N odd natural numbers. >>> sum_of_cubes_odd_numbers(1) == 1**3 >>> sum_of_cubes_odd_numbers(2) == 1**3 + 3**3 >>> sum_of_cubes_odd_numbers(3) == 1**3 + 3**3 + 5**3 >>> sum_of_cubes_odd_numbers(4) == 1**3 + 3**3 + 5**3 + 7**3 >>> sum_of_cubes_odd_numbers(10) == sum((2*i + 1)**3 for i in range(10)) >>> sum_of_cubes_odd_numbers(100) == sum((2*i + 1)**3 for i in range(100))","solution":"def sum_of_cubes_odd_numbers(N): Returns the sum of the cubes of the first N odd natural numbers. return sum((2*i + 1) ** 3 for i in range(N))"},{"question":"def can_partition_equal_weight(N: int, weights: List[int]) -> str: Determines if it is possible to partition the list of weights into two groups with equal total weight. Parameters: N (int): The number of weights in the list. weights (List[int]): The weights of the packages. Returns: str: \\"YES\\" if it is possible to partition into two groups with equal weight, otherwise \\"NO\\". >>> can_partition_equal_weight(4, [1, 5, 11, 5]) == \\"YES\\" >>> can_partition_equal_weight(3, [1, 1, 1]) == \\"NO\\" >>> can_partition_equal_weight(3, [1, 2, 1]) == \\"YES\\" >>> can_partition_equal_weight(5, [1, 2, 3, 8, 7]) == \\"NO\\" >>> can_partition_equal_weight(5, [2, 2, 3, 5, 8]) == \\"YES\\" >>> can_partition_equal_weight(1, [1]) == \\"NO\\" >>> can_partition_equal_weight(2, [2, 2]) == \\"YES\\" >>> can_partition_equal_weight(2, [3, 2]) == \\"NO\\" >>> can_partition_equal_weight(4, [3, 3, 3, 3]) == \\"YES\\"","solution":"def can_partition_equal_weight(N, weights): Determines if it is possible to partition the list of weights into two groups with equal total weight. Parameters: N (int): The number of weights in the list. weights (List[int]): The weights of the packages. Returns: str: \\"YES\\" if it is possible to partition into two groups with equal weight, otherwise \\"NO\\". total_weight = sum(weights) # If the total weight is odd, it can't be divided into two equal parts. if total_weight % 2 != 0: return \\"NO\\" target_weight = total_weight // 2 # Use dynamic programming to determine if there is a subset with sum equal to target_weight dp = [False] * (target_weight + 1) dp[0] = True for weight in weights: for i in range(target_weight, weight - 1, -1): dp[i] = dp[i] or dp[i - weight] return \\"YES\\" if dp[target_weight] else \\"NO\\""},{"question":"def trap_rainwater(heights): Compute the total amount of trapped rainwater given a list of block heights. :param heights: List[int] - list of non-negative integers representing block heights. :return: int - total amount of trapped rainwater. >>> trap_rainwater([0,1,0,2,1,0,1,3,2,1,2,1]) 6 >>> trap_rainwater([4,2,0,3,2,5]) 9 from typing import List def test_no_blocks(): assert trap_rainwater([]) == 0 def test_no_trapped_water(): assert trap_rainwater([1, 0, 1]) == 1 assert trap_rainwater([0, 0, 0]) == 0 def test_example_cases(): assert trap_rainwater([0,1,0,2,1,0,1,3,2,1,2,1]) == 6 assert trap_rainwater([4,2,0,3,2,5]) == 9 def test_single_block_height(): assert trap_rainwater([5]) == 0 def test_increasing_height(): assert trap_rainwater([0, 1, 2, 3, 4, 5]) == 0 def test_decreasing_height(): assert trap_rainwater([5, 4, 3, 2, 1, 0]) == 0","solution":"def trap_rainwater(heights): Compute the total amount of trapped rainwater given a list of block heights. :param heights: List[int] - list of non-negative integers representing block heights. :return: int - total amount of trapped rainwater. if not heights or len(heights) < 3: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n water_trapped = 0 left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i-1], heights[i]) right_max[n-1] = heights[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], heights[i]) for i in range(n): water_trapped += min(left_max[i], right_max[i]) - heights[i] return water_trapped"},{"question":"def submatrixSum(matrix, N, M, queries, Q): Given a matrix of size NxM and Q queries, each query involves providing a pair of coordinates (x, y) that specifies the top-left corner of a submatrix with a given size (r, c). For each query, find the sum of all elements in the submatrix starting from (x, y) with size (r, c) where r is the number of rows and c is the number of columns. Note: Assume 0 based indexing. >>> matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] >>> N, M = 3, 3 >>> queries = [[0, 0, 2, 2], [1, 1, 2, 2]] >>> Q = 2 >>> submatrixSum(matrix, N, M, queries, Q) [12, 28] >>> matrix = [ ... [1, 1, 1, 1], ... [1, 1, 1, 1], ... [1, 1, 1, 1], ... [1, 1, 1, 1] ... ] >>> N, M = 4, 4 >>> queries = [[0, 0, 2, 2], [1, 1, 2, 2], [2, 2, 2, 2]] >>> Q = 3 >>> submatrixSum(matrix, N, M, queries, Q) [4, 4, 4] >>> matrix = [[5]] >>> N, M = 1, 1 >>> queries = [[0, 0, 1, 1]] >>> Q = 1 >>> submatrixSum(matrix, N, M, queries, Q) [5] >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> N, M = 3, 3 >>> queries = [[0, 0, 3, 3]] >>> Q = 1 >>> submatrixSum(matrix, N, M, queries, Q) [45]","solution":"def submatrixSum(matrix, N, M, queries, Q): result = [] for query in queries: x, y, r, c = query sum_submatrix = 0 for i in range(r): for j in range(c): sum_submatrix += matrix[x + i][y + j] result.append(sum_submatrix) return result"},{"question":"from typing import List, Dict def decodeWords(words: List[str], mapping: Dict[str, str]) -> List[str]: Decodes a list of words using the provided mapping dictionary. :param words: List of encoded words. :param mapping: Dictionary mapping each letter to another letter. :return: List of decoded words. >>> words = [\\"uryyb\\", \\"jbeyq\\"] >>> mapping = { ... 'a':'n', 'b':'o', 'c':'p', 'd':'q', 'e':'r', 'f':'s', 'g':'t', ... 'h':'u', 'i':'v', 'j':'w', 'k':'x', 'l':'y', 'm':'z', 'n':'a', ... 'o':'b', 'p':'c', 'q':'d', 'r':'e', 's':'f', 't':'g', 'u':'h', ... 'v':'i', 'w':'j', 'x':'k', 'y':'l', 'z':'m' ... } >>> decodeWords(words, mapping) ['hello', 'world']","solution":"from typing import List, Dict def decodeWords(words: List[str], mapping: Dict[str, str]) -> List[str]: Decodes a list of words using the provided mapping dictionary. :param words: List of encoded words. :param mapping: Dictionary mapping each letter to another letter. :return: List of decoded words. decoded_words = [] for word in words: decoded_word = ''.join(mapping[char] for char in word) decoded_words.append(decoded_word) return decoded_words"},{"question":"def tallest_tower(blocks): Return the height of the tallest tower that can be constructed. Parameters: blocks (list): List of integers representing the heights of each block available. Returns: int: Maximum height of the tower. pass def test_single_block(): assert tallest_tower([5]) == 1 def test_tower_with_all_unique_block_heights(): assert tallest_tower([4, 3, 2, 5, 7]) == 5 def test_tower_with_some_repeated_heights(): assert tallest_tower([4, 4, 3, 3, 2, 2, 1, 1]) == 4 def test_tower_with_sorted_blocks(): assert tallest_tower([1, 2, 3, 4, 5]) == 5 def test_tower_with_descending_heights(): assert tallest_tower([5, 4, 3, 2, 1]) == 5 def test_tower_with_identical_heights(): assert tallest_tower([4, 4, 4, 4]) == 1 def test_tower_with_varied_block_heights_1(): assert tallest_tower([10, 20, 30, 10, 20, 30]) == 3 def test_tower_with_varied_block_heights_2(): assert tallest_tower([5, 6, 7, 8, 9, 4, 3, 2, 1]) == 9","solution":"def tallest_tower(blocks): Return the height of the tallest tower that can be constructed. Parameters: blocks (list): List of integers representing the heights of each block available. Returns: int: Maximum height of the tower. sorted_blocks = sorted(blocks, reverse=True) tower_height = 0 last_height = float('inf') # Initialize to a very high value for block in sorted_blocks: if block < last_height: tower_height += 1 last_height = block return tower_height"},{"question":"def max_sum_of_rearranged_subgrid(n: int, m: int, grid: List[List[int]]) -> int: Finds the maximum sum of a subgrid that can be obtained by rearranging the rows of the grid. Parameters: n (int): Number of rows in the grid. m (int): Number of columns in the grid. grid (list of list of int): The grid itself where each inner list is a row. Returns: int: The maximum sum of a subgrid. >>> max_sum_of_rearranged_subgrid(2, 3, [[1, 2, 3], [4, 5, 6]]) 21 >>> max_sum_of_rearranged_subgrid(3, 3, [[3, 2, 1], [6, 5, 4], [9, 8, 7]]) 45 >>> max_sum_of_rearranged_subgrid(1, 5, [[1, 1, 1, 1, 1]]) 5","solution":"def max_sum_of_rearranged_subgrid(n, m, grid): Finds the maximum sum of a subgrid that can be obtained by rearranging the rows of the grid. Parameters: n (int): Number of rows in the grid. m (int): Number of columns in the grid. grid (list of list of int): The grid itself where each inner list is a row. Returns: int: The maximum sum of a subgrid. # Rearrange the rows in non-decreasing order of their total sum sorted_grid = sorted(grid, key=sum, reverse=True) # Calculate the sum of the entire grid after rearrangement max_sum = sum(sum(row) for row in sorted_grid) return max_sum"},{"question":"def rearrange_array(arr, k): Rearranges the array such that the element at position i moves to position (i + k) % n. Modifies the array in place and returns it. >>> rearrange_array([1, 2, 3, 4, 5], 2) [4, 5, 1, 2, 3] >>> rearrange_array([10, 20, 30, 40, 50, 60, 70], 3) [40, 50, 60, 70, 10, 20, 30] pass","solution":"def rearrange_array(arr, k): Rearranges the array such that the element at position i moves to position (i + k) % n. Modifies the array in place and returns it. n = len(arr) k = k % n # To handle cases where k > n reverse(arr, 0, n - 1) reverse(arr, 0, k - 1) reverse(arr, k, n - 1) return arr def reverse(arr, start, end): while start < end: arr[start], arr[end] = arr[end], arr[start] start += 1 end -= 1"},{"question":"def can_travel(N, M, Q, K, roads, queries): Determine if it is possible to travel from city A to city B using the existing roads and at most K new roads. >>> N, M, Q, K = 6, 4, 3, 1 >>> roads = [(1, 2), (2, 3), (4, 5), (5, 6)] >>> queries = [(1, 3), (1, 4), (4, 6)] >>> can_travel(N, M, Q, K, roads, queries) [\\"Yes\\", \\"No\\", \\"Yes\\"] >>> N, M, Q, K = 5, 2, 2, 2 >>> roads = [(1, 2), (3, 4)] >>> queries = [(1, 3), (2, 5)] >>> can_travel(N, M, Q, K, roads, queries) [\\"No\\", \\"No\\"] >>> N, M, Q, K = 3, 1, 1, 1 >>> roads = [(1, 2)] >>> queries = [(1, 3)] >>> can_travel(N, M, Q, K, roads, queries) [\\"No\\"] >>> N, M, Q, K = 4, 0, 1, 1 >>> roads = [] >>> queries = [(1, 2)] >>> can_travel(N, M, Q, K, roads, queries) [\\"No\\"] >>> N, M, Q, K = 4, 0, 1, 3 >>> roads = [] >>> queries = [(1, 4)] >>> can_travel(N, M, Q, K, roads, queries) [\\"No\\"]","solution":"def can_travel(N, M, Q, K, roads, queries): from collections import defaultdict, deque # Create adjacency list for the graph representation of cities and roads graph = defaultdict(list) for u, v in roads: graph[u].append(v) graph[v].append(u) # Helper function to perform BFS and check if two cities are connected def bfs(start, target): visited = set() queue = deque([start]) while queue: current = queue.popleft() if current == target: return True visited.add(current) for neighbor in graph[current]: if neighbor not in visited: queue.append(neighbor) return False # For each query (A, B), determine if they are in the same connected component results = [] for A, B in queries: if bfs(A, B): results.append(\\"Yes\\") else: results.append(\\"No\\") return results"},{"question":"from typing import List, Tuple def number_of_distinct_groups(t: int, test_cases: List[Tuple[int, List[str]]]) -> List[int]: Determine the number of distinct groups of similar words for each test case. >>> number_of_distinct_groups(3, [(5, [\\"abc\\", \\"bca\\", \\"cab\\", \\"foo\\", \\"oof\\"]), (4, [\\"abcd\\", \\"bcda\\", \\"dabc\\", \\"abcde\\"]), (3, [\\"xyz\\", \\"xy\\", \\"xz\\"])]) [2, 2, 3] >>> number_of_distinct_groups(1, [(6, [\\"aa\\", \\"bb\\", \\"ab\\", \\"ba\\", \\"b\\", \\"a\\"])]) [5]","solution":"from collections import Counter def number_of_distinct_groups(t, test_cases): results = [] for i in range(t): n, words = test_cases[i] unique_groups = set() for word in words: word_signature = tuple(sorted(Counter(word).items())) unique_groups.add(word_signature) results.append(len(unique_groups)) return results"},{"question":"def do_segments_intersect(x1, y1, x2, y2, x3, y3, x4, y4): Returns True if segments (x1, y1) -> (x2, y2) and (x3, y3) -> (x4, y4) intersect, False otherwise. >>> do_segments_intersect(0, 0, 2, 2, 0, 2, 2, 0) True >>> do_segments_intersect(1, 1, 3, 3, 4, 4, 6, 6) False","solution":"def do_segments_intersect(x1, y1, x2, y2, x3, y3, x4, y4): Returns True if segments (x1, y1) -> (x2, y2) and (x3, y3) -> (x4, y4) intersect, False otherwise. def on_segment(px, py, qx, qy, rx, ry): if min(px, qx) <= rx <= max(px, qx) and min(py, qy) <= ry <= max(py, qy): return True return False def orientation(px, py, qx, qy, rx, ry): val = (qy - py) * (rx - qx) - (qx - px) * (ry - qy) if val == 0: return 0 # collinear elif val > 0: return 1 # clockwise else: return 2 # counterclockwise o1 = orientation(x1, y1, x2, y2, x3, y3) o2 = orientation(x1, y1, x2, y2, x4, y4) o3 = orientation(x3, y3, x4, y4, x1, y1) o4 = orientation(x3, y3, x4, y4, x2, y2) if o1 != o2 and o3 != o4: return True if o1 == 0 and on_segment(x1, y1, x2, y2, x3, y3): return True if o2 == 0 and on_segment(x1, y1, x2, y2, x4, y4): return True if o3 == 0 and on_segment(x3, y3, x4, y4, x1, y1): return True if o4 == 0 and on_segment(x3, y3, x4, y4, x2, y2): return True return False"},{"question":"def min_removals_to_palindrome(necklace: str) -> int: Returns the minimum number of character removals needed to make the given necklace a palindrome. Args: necklace (str): The necklace string containing lowercase letters. Returns: int: The minimum number of removals required. Example: >>> min_removals_to_palindrome(\\"abdbca\\") 1 >>> min_removals_to_palindrome(\\"cddpd\\") 2 >>> min_removals_to_palindrome(\\"pqr\\") 2","solution":"def min_removals_to_palindrome(necklace): Returns the minimum number of character removals needed to make the given necklace a palindrome. n = len(necklace) # Helper function to find the length of the longest palindromic subsequence def longest_palindromic_subsequence(s): dp = [[0] * n for _ in range(n)] for i in range(n): dp[i][i] = 1 for length in range(2, n+1): for start in range(n-length+1): end = start + length - 1 if s[start] == s[end]: dp[start][end] = 2 + dp[start+1][end-1] else: dp[start][end] = max(dp[start+1][end], dp[start][end-1]) return dp[0][n-1] lps_length = longest_palindromic_subsequence(necklace) return n - lps_length"},{"question":"def count_pairs_with_sum(arr: List[int], N: int, K: int) -> int: Count pairs in an array with a given sum such that the pair (i, j) is the same as the pair (j, i). :param arr: List[int] - input array of integers :param N: int - size of the array :param K: int - target sum :return: int - count of pairs (i, j) with i < j and arr[i] + arr[j] == K >>> count_pairs_with_sum([1, 5, 7, -1, 5], 5, 6) 3 >>> count_pairs_with_sum([1, 2, 3, 4], 4, 10) 0 >>> count_pairs_with_sum([1, 2, 3, 4], 4, 3) 1 >>> count_pairs_with_sum([1, 1, 1, 1], 4, 2) 6 >>> count_pairs_with_sum([10**6, 10**6 - 1, -10**6, -10**6 + 1], 4, 0) 2 >>> count_pairs_with_sum([-1, -2, -3, -4], 4, -5) 2 >>> count_pairs_with_sum([1, 1, 1, 1, 2], 5, 5) 0","solution":"def count_pairs_with_sum(arr, N, K): Count pairs in an array with a given sum. :param arr: List[int] - input array of integers :param N: int - size of the array :param K: int - target sum :return: int - count of pairs (i, j) with i < j and arr[i] + arr[j] == K if N < 2: return 0 count_map = {} count = 0 for num in arr: if K - num in count_map: count += count_map[K - num] if num in count_map: count_map[num] += 1 else: count_map[num] = 1 return count"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverseLinkedList(head): Reverses a singly linked list. :param head: ListNode, the head node of the singly linked list :return: ListNode, the head node of the reversed singly linked list >>> head = list_to_linked_list([1, 2, 3, 4, 5]) >>> reversed_head = reverseLinkedList(head) >>> linked_list_to_list(reversed_head) [5, 4, 3, 2, 1] >>> head = list_to_linked_list([1]) >>> reversed_head = reverseLinkedList(head) >>> linked_list_to_list(reversed_head) [1] >>> head = list_to_linked_list([1, 2]) >>> reversed_head = reverseLinkedList(head) >>> linked_list_to_list(reversed_head) [2, 1] >>> head = list_to_linked_list([]) >>> reversed_head = reverseLinkedList(head) >>> linked_list_to_list(reversed_head) [] >>> head = list_to_linked_list([1, 1, 1, 1]) >>> reversed_head = reverseLinkedList(head) >>> linked_list_to_list(reversed_head) [1, 1, 1, 1]","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverseLinkedList(head): Reverses a singly linked list. :param head: ListNode, the head node of the singly linked list :return: ListNode, the head node of the reversed singly linked list prev = None current = head while current: next_node = current.next current.next = prev prev = current current = next_node return prev"},{"question":"def calculate_fines(loans): Calculate the fine for each loan based on the number of overdue days. :param loans: List of integers where each integer represents the number of days a loan is overdue. :return: List of integers representing the fine for each loan. >>> calculate_fines([0]) [0] >>> calculate_fines([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> calculate_fines([6, 7, 8, 9, 10]) [7, 9, 11, 13, 15] >>> calculate_fines([11, 12, 13, 14, 20]) [18, 21, 24, 27, 45] >>> calculate_fines([0, 3, 8, 15, 30]) [0, 3, 11, 30, 75]","solution":"def calculate_fines(loans): Calculate the fine for each loan based on the number of overdue days. :param loans: List of integers where each integer represents the number of days a loan is overdue. :return: List of integers representing the fine for each loan. fines = [] for days_overdue in loans: fine = 0 if days_overdue <= 5: fine = days_overdue * 1 elif days_overdue <= 10: fine = 5 * 1 + (days_overdue - 5) * 2 else: fine = 5 * 1 + 5 * 2 + (days_overdue - 10) * 3 fines.append(fine) return fines"},{"question":"def prime_factors(n: int) -> List[int]: Compute the prime factors of an integer and sort them in descending order. >>> prime_factors(315) [7, 5, 3, 3] >>> prime_factors(50) [5, 5, 2] >>> prime_factors(21) [7, 3]","solution":"def prime_factors(n): Returns the prime factors of the given integer n, sorted in descending order. factors = [] # Check for smallest factors i = 2 while i * i <= n: while n % i == 0: factors.append(i) n //= i i += 1 if n > 1: factors.append(n) return sorted(factors, reverse=True)"},{"question":"def transform_array_to_target(n: int, T: int, array: List[int]) -> List[str]: This function transforms the given array into an array where all elements are equal to T. Parameters: n (int): Length of the array. T (int): Target value for all elements in the array. array (list of int): Initial elements of the array. Returns: list of str: A list containing the operations performed to transform the array. Examples: >>> transform_array_to_target(5, 10, [1, 2, 3, 4, 5]) ['Z 0 10', 'Z 1 10', 'Z 2 10', 'Z 3 10', 'Z 4 10'] >>> transform_array_to_target(1, 10, [10]) ['-1'] >>> transform_array_to_target(3, 5, [5, 5, 5]) ['-1'] >>> transform_array_to_target(4, 0, [1, 2, 3, 4]) ['Z 0 0', 'Z 1 0', 'Z 2 0', 'Z 3 0']","solution":"def transform_array_to_target(n, T, array): This function transforms the given array into an array where all elements are equal to T. Parameters: n (int): Length of the array. T (int): Target value for all elements in the array. array (list of int): Initial elements of the array. Returns: list of str: A list containing the operations performed to transform the array. operations = [] for i in range(n): if array[i] != T: operations.append(f\\"Z {i} {T}\\") return operations if operations else ['-1']"},{"question":"def generate_playlist(user_preferences, database): Generate a playlist based on user preferences and available songs in the database. Parameters: user_preferences (list): A list of preferred genres. database (list): A list of tuples where each tuple contains a song ID and its genre. Returns: list: A playlist of song IDs matching user preferences, or an empty list if not possible. Examples: >>> generate_playlist([\\"Pop\\", \\"Pop\\", \\"Rock\\"], [(\\"1\\", \\"Pop\\"), (\\"2\\", \\"Jazz\\"), (\\"3\\", \\"Rock\\"), (\\"4\\", \\"Pop\\"), (\\"5\\", \\"Rock\\")]) [\\"1\\", \\"3\\", \\"4\\"] >>> generate_playlist([\\"Pop\\"], [(\\"1\\", \\"Pop\\"), (\\"2\\", \\"Jazz\\"), (\\"3\\", \\"Rock\\")]) [\\"1\\"] >>> generate_playlist([\\"Pop\\", \\"Pop\\"], [(\\"1\\", \\"Pop\\"), (\\"2\\", \\"Rock\\")]) [] >>> generate_playlist([\\"Pop\\", \\"Rock\\"], [(\\"1\\", \\"Pop\\"), (\\"2\\", \\"Jazz\\"), (\\"3\\", \\"Rock\\"), (\\"4\\", \\"Pop\\")]) [\\"1\\", \\"3\\"] >>> generate_playlist([\\"Pop\\", \\"Pop\\", \\"Rock\\", \\"Rock\\"], [(\\"1\\", \\"Pop\\"), (\\"2\\", \\"Jazz\\"), (\\"3\\", \\"Rock\\"), (\\"4\\", \\"Pop\\"), (\\"5\\", \\"Rock\\")]) [\\"1\\", \\"4\\", \\"3\\", \\"5\\"] >>> generate_playlist([], [(\\"1\\", \\"Pop\\"), (\\"2\\", \\"Jazz\\"), (\\"3\\", \\"Rock\\")]) []","solution":"def generate_playlist(user_preferences, database): Generate a playlist based on user preferences and available songs in the database. Parameters: user_preferences (list): A list of preferred genres. database (list): A list of tuples where each tuple contains a song ID and its genre. Returns: list: A playlist of song IDs matching user preferences, or an empty list if not possible. from collections import Counter # Count the required number of each genre required_genres = Counter(user_preferences) genre_to_songs = {genre: [] for genre in required_genres} # Categorize songs by genre for song_id, genre in database: if genre in genre_to_songs: genre_to_songs[genre].append(song_id) playlist = [] for genre, count in required_genres.items(): if len(genre_to_songs[genre]) < count: return [] # Not enough songs to meet the required number for a genre playlist.extend(genre_to_songs[genre][:count]) return playlist"},{"question":"def can_rearrange_to_satisfy_sum(n, k, a, b): Determines if it is possible to rearrange the elements of array a such that for every i, the sum of the ith position from the two arrays a and b is greater than or equal to k. Args: n (int): Length of the arrays. k (int): The target sum that needs to be met or exceeded. a (list): The first array containing n integers. b (list): The second array containing n integers. Returns: str: \\"YES\\" if such a rearrangement is possible, otherwise \\"NO\\". Examples: >>> can_rearrange_to_satisfy_sum(4, 10, [2, 1, 3, 5], [7, 8, 5, 9]) \\"YES\\" >>> can_rearrange_to_satisfy_sum(3, 10, [1, 2, 3], [8, 7, 6]) \\"NO\\"","solution":"def can_rearrange_to_satisfy_sum(n, k, a, b): Determines if it is possible to rearrange the elements of array a such that for every i, the sum of the ith position from the two arrays a and b is greater than or equal to k. Args: n (int): Length of the arrays. k (int): The target sum that needs to be met or exceeded. a (list): The first array containing n integers. b (list): The second array containing n integers. Returns: str: \\"YES\\" if such a rearrangement is possible, otherwise \\"NO\\". a.sort() b.sort(reverse=True) for i in range(n): if a[i] + b[i] < k: return \\"NO\\" return \\"YES\\""},{"question":"def rotateArray(nums, k): Rotates the array to the right by k steps. The rotation is performed in-place. Parameters: nums (List[int]): The array of integers to be rotated. k (int): The number of steps to rotate the array. Returns: None >>> arr = [1, 2, 3, 4, 5, 6, 7] >>> rotateArray(arr, 3) >>> arr [5, 6, 7, 1, 2, 3, 4] >>> arr = [-1, -100, 3, 99] >>> rotateArray(arr, 2) >>> arr [3, 99, -1, -100] >>> arr = [1, 2, 3, 4, 5, 6] >>> rotateArray(arr, 10) >>> arr [3, 4, 5, 6, 1, 2] >>> arr = [1, 2, 3, 4, 5, 6, 7] >>> rotateArray(arr, 0) >>> arr [1, 2, 3, 4, 5, 6, 7] >>> arr = [1] >>> rotateArray(arr, 3) >>> arr [1] >>> arr = [1, 2] >>> rotateArray(arr, 1) >>> arr [2, 1]","solution":"def rotateArray(nums, k): Rotates the array to the right by k steps. The rotation is performed in-place. Parameters: nums (List[int]): The array of integers to be rotated. k (int): The number of steps to rotate the array. Returns: None n = len(nums) k = k % n # In case k is greater than the length of nums def reverse(arr, start, end): while start < end: arr[start], arr[end] = arr[end], arr[start] start += 1 end -= 1 reverse(nums, 0, n - 1) reverse(nums, 0, k - 1) reverse(nums, k, n - 1)"},{"question":"def are_permutations(a: str, b: str) -> str: Checks if string a is a permutation of string b. >>> are_permutations(\\"abc\\", \\"bca\\") \\"YES\\" >>> are_permutations(\\"abc\\", \\"def\\") \\"NO\\" >>> are_permutations(\\"abc\\", \\"abcd\\") \\"NO\\" >>> are_permutations(\\"abc\\", \\"abc\\") \\"YES\\" >>> are_permutations(\\"\\", \\"\\") \\"YES\\" >>> are_permutations(\\"aabbcc\\", \\"baccab\\") \\"YES\\" >>> are_permutations(\\"aabbcc\\", \\"aabbc\\") \\"NO\\" def process_test_cases(T: int, test_cases: List[Tuple[str, str]]) -> List[str]: Processes multiple test cases to determine if strings are permutations of each other. results = [] for i in range(T): a, b = test_cases[i] results.append(are_permutations(a, b)) return results","solution":"def are_permutations(a, b): Checks if string a is a permutation of string b. if len(a) != len(b): return \\"NO\\" return \\"YES\\" if sorted(a) == sorted(b) else \\"NO\\" def process_test_cases(T, test_cases): results = [] for i in range(T): a, b = test_cases[i] results.append(are_permutations(a, b)) return results"},{"question":"def canFormPalindrome(s: str) -> int: Determines if the characters of the input string can be rearranged to form a palindrome. Args: s (str): The input string. Returns: int: 1 if the characters can be rearranged to form a palindrome, 0 otherwise. >>> canFormPalindrome(\\"civic\\") 1 >>> canFormPalindrome(\\"ivicc\\") 1 >>> canFormPalindrome(\\"hello\\") 0 >>> canFormPalindrome(\\"racecar\\") 1 >>> canFormPalindrome(\\"aabbccdd\\") 1 >>> canFormPalindrome(\\"aabbc\\") 1 >>> canFormPalindrome(\\"abcde\\") 0 >>> canFormPalindrome(\\"a\\") 1 >>> canFormPalindrome(\\"aa\\") 1 >>> canFormPalindrome(\\"ab\\") 0","solution":"def canFormPalindrome(s): Determines if the characters of the input string can be rearranged to form a palindrome. Args: s (str): The input string. Returns: int: 1 if the characters can be rearranged to form a palindrome, 0 otherwise. from collections import Counter # Count the occurrences of each character char_count = Counter(s) # A string can be rearranged to form a palindrome if at most one character # has an odd frequency. odd_count = sum(1 for count in char_count.values() if count % 2 != 0) return 1 if odd_count <= 1 else 0 # Example usage: # print(canFormPalindrome(\\"civic\\")) # Output: 1 # print(canFormPalindrome(\\"ivicc\\")) # Output: 1 # print(canFormPalindrome(\\"hello\\")) # Output: 0"},{"question":"def count_pairs(N: int, K: int) -> int: Returns the number of distinct pairs (a, b) that satisfy the condition 1 ≤ a < b ≤ N and |a - b| = K. >>> count_pairs(5, 2) 3 >>> count_pairs(10, 3) 7 >>> count_pairs(8, 5) 3 def solve(test_cases: List[Tuple[int, int]]) -> List[int]: Solves the problem for a list of test cases and returns a list of results. >>> solve([(5, 2), (10, 3), (8, 5)]) [3, 7, 3]","solution":"def count_pairs(N, K): Returns the number of distinct pairs (a, b) that satisfy the condition 1 ≤ a < b ≤ N and |a - b| = K. if 1 <= K < N: return (N - K) else: return 0 def solve(test_cases): Solves the problem for a list of test cases. results = [] for N, K in test_cases: results.append(count_pairs(N, K)) return results"},{"question":"from typing import List def count_paths(grid: List[List[int]]) -> int: Compute the number of different routes Matilda can take to reach the bottom-right corner of the grid from the top-left corner. Each cell in the grid is either 0 (open) or 1 (blocked). Matilda can only move right or down. >>> count_paths([ >>> [0, 0, 0], >>> [0, 1, 0], >>> [0, 0, 0] >>> ]) 2 >>> count_paths([ >>> [0, 1, 0], >>> [1, 1, 0], >>> [0, 0, 0] >>> ]) 0 >>> count_paths([ >>> [0, 0], >>> [0, 0] >>> ]) 2 >>> count_paths([ >>> [1] >>> ]) 0 >>> count_paths([ >>> [0] >>> ]) 1 >>> count_paths([ >>> [0] * 10 for _ in range(10) >>> ]) 48620 pass","solution":"from typing import List def count_paths(grid: List[List[int]]) -> int: if not grid or grid[0][0] == 1 or grid[-1][-1] == 1: return 0 m, n = len(grid), len(grid[0]) dp = [[0] * n for _ in range(m)] if grid[0][0] == 0: dp[0][0] = 1 for i in range(m): for j in range(n): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[-1][-1]"},{"question":"def check_balance(s: str) -> bool: Returns True if the string \`s\` has balanced and correctly nested parentheses, braces, and brackets. >>> check_balance(\\"\\") == True >>> check_balance(\\"()\\") == True >>> check_balance(\\"{}\\") == True >>> check_balance(\\"[]\\") == True >>> check_balance(\\"(\\") == False >>> check_balance(\\"}\\") == False >>> check_balance(\\"[\\") == False >>> check_balance(\\"(}\\") == False >>> check_balance(\\"(){}[]\\") == True >>> check_balance(\\"{[()]}\\") == True >>> check_balance(\\"()[{()}]\\") == True >>> check_balance(\\"([)]\\") == False >>> check_balance(\\"{[}\\") == False >>> check_balance(\\"([)\\") == False >>> check_balance(\\"(({}))\\") == True >>> check_balance(\\"{([])}\\") == True >>> check_balance(\\"(({})\\") == False >>> check_balance(\\"{([)]}\\") == False >>> check_balance(\\"a+b*(c)\\") == False >>> check_balance(\\"{[()a+b]}\\") == False","solution":"def check_balance(s): Returns True if the string \`s\` has balanced and correctly nested parentheses, braces, and brackets. stack = [] matching_bracket = {')': '(', '}': '{', ']': '['} for char in s: if char in matching_bracket.values(): stack.append(char) elif char in matching_bracket: if not stack or stack.pop() != matching_bracket[char]: return False else: # Invalid character found return False return not stack"},{"question":"def find_primes(n: int) -> List[int]: Returns a list of all prime numbers less than or equal to n. >>> find_primes(10) [2, 3, 5, 7] >>> find_primes(20) [2, 3, 5, 7, 11, 13, 17, 19] >>> find_primes(1) [] >>> find_primes(2) [2]","solution":"def find_primes(n): Returns a list of all prime numbers less than or equal to n. if n < 2: return [] is_prime = [True] * (n + 1) is_prime[0] = is_prime[1] = False p = 2 while p * p <= n: if is_prime[p]: for i in range(p * p, n + 1, p): is_prime[i] = False p += 1 return [p for p in range(2, n + 1) if is_prime[p]]"},{"question":"from typing import List, Tuple def pair_players(skills: List[int]) -> List[Tuple[int, ...]]: Pairs the players such that the difference in their skill levels is minimized. If the number of players is odd, the unpaired player is included as a singleton. :param skills: List of integers representing the skill levels of the players. :return: List of tuples, where each tuple contains one or two elements representing the pairs of players.","solution":"def pair_players(skills): Pairs the players such that the difference in their skill levels is minimized. If the number of players is odd, the unpaired player is included as a singleton. :param skills: List of integers representing the skill levels of the players. :return: List of tuples, where each tuple contains one or two elements representing the pairs of players. skills.sort() pairs = [] i = 0 while i < len(skills) - 1: pairs.append((skills[i], skills[i + 1])) i += 2 if len(skills) % 2 == 1: pairs.append((skills[-1],)) return pairs"},{"question":"def max_non_overlapping_events(events): Given a list of events with start and end times, return the maximum number of non-overlapping events that can be attended. :param events: List of tuples where each tuple has two integers (start time, end time) :return: Maximum number of non-overlapping events >>> max_non_overlapping_events([(1300, 1500), (1200, 1400), (1400, 1600), (1500, 1700)]) 2 >>> max_non_overlapping_events([(1000, 1100), (1500, 1600), (1800, 1900)]) 3 >>> max_non_overlapping_events([(1000, 1500), (1100, 1400), (1200, 1300)]) 1 >>> max_non_overlapping_events([(1000, 1100), (1100, 1200), (1200, 1300), (1500, 1600), (1500, 1700)]) 4 >>> max_non_overlapping_events([(1200, 1300)]) 1 def parse_input(input_str): Parse the input string and return a list of events, where each event is represented as a tuple of two integers (start time, end time). :param input_str: String containing the event data :return: List of tuples representing events >>> parse_input(\\"4n1300 1500n1200 1400n1400 1600n1500 1700\\") [(1300, 1500), (1200, 1400), (1400, 1600), (1500, 1700)]","solution":"def max_non_overlapping_events(events): Given a list of events with start and end times, return the maximum number of non-overlapping events that can be attended. :param events: List of tuples where each tuple has two integers (start time, end time) :return: Maximum number of non-overlapping events # Sort events primarily by their end times events.sort(key=lambda x: x[1]) max_events = 0 previous_end_time = -1 for start, end in events: if start >= previous_end_time: max_events += 1 previous_end_time = end return max_events # Function to read input and format it def parse_input(input_str): lines = input_str.strip().split(\\"n\\") n = int(lines[0]) events = [tuple(map(int, line.split())) for line in lines[1:1+n]] return events"},{"question":"def find_word_in_matrix(matrix: List[List[str]], word: str) -> str: You are given a matrix with n rows and m columns, where each cell contains a single uppercase English letter. Your task is to find out if a given word can be constructed from an uninterrupted, contiguous sequence of adjacent cells (horizontal, vertical, or diagonal) in the matrix. Cells that make up the word can only be used once per word. >>> find_word_in_matrix([ ['A', 'B', 'C', 'D'], ['E', 'F', 'G', 'H'], ['I', 'J', 'K', 'L'] ], \\"BFGK\\") \\"YES\\" >>> find_word_in_matrix([ ['A', 'D', 'B'], ['C', 'E', 'G'], ['H', 'F', 'I'] ], \\"ABE\\") \\"NO\\" >>> find_word_in_matrix([ ['A'] ], \\"A\\") \\"YES\\" >>> find_word_in_matrix([ ['A', 'B'], ['C', 'D'] ], \\"ABCDE\\") \\"NO\\" >>> find_word_in_matrix([ ['A', 'B', 'C'], ['D', 'E', 'F'], ['G', 'H', 'I'] ], \\"AEI\\") \\"YES\\" >>> find_word_in_matrix([ ['A', 'B', 'C'], ['D', 'E', 'F'], ['G', 'H', 'I'] ], \\"ADG\\") \\"YES\\" >>> find_word_in_matrix([ ['A', 'B', 'C'], ['D', 'E', 'F'], ['G', 'H', 'I'] ], \\"DEF\\") \\"YES\\" >>> find_word_in_matrix([ ['A', 'B', 'C'], ['D', 'E', 'F'], ['G', 'H', 'I'] ], \\"EE\\") \\"NO\\"","solution":"def find_word_in_matrix(matrix, word): n = len(matrix) m = len(matrix[0]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1), (-1, -1), (-1, 1), (1, -1), (1, 1)] def dfs(x, y, index): if index == len(word): return True if x < 0 or x >= n or y < 0 or y >= m or matrix[x][y] != word[index]: return False temp = matrix[x][y] matrix[x][y] = '#' # mark the cell as visited for dx, dy in directions: if dfs(x + dx, y + dy, index + 1): return True matrix[x][y] = temp # unmark the cell return False for i in range(n): for j in range(m): if matrix[i][j] == word[0] and dfs(i, j, 0): return \\"YES\\" return \\"NO\\""},{"question":"def max_subset_sum(N: int, S: int, elements: List[int]) -> int: Finds the largest sum less than or equal to S that can be achieved using a subset of the given list of elements. >>> max_subset_sum(5, 10, [1, 2, 3, 4, 5]) == 10 >>> max_subset_sum(4, 11, [4, 5, 6, 3]) == 11 >>> max_subset_sum(3, 8, [9, 8, 7]) == 8 >>> max_subset_sum(3, 5, [6, 7, 8]) == 0 >>> max_subset_sum(3, 100, [50, 50, 50]) == 100 >>> max_subset_sum(1, 10, [5]) == 5 >>> max_subset_sum(1, 5, [5]) == 5 >>> max_subset_sum(0, 10, []) == 0 >>> max_subset_sum(5, 0, [1, 2, 3, 4, 5]) == 0","solution":"def max_subset_sum(N, S, elements): Finds the largest sum less than or equal to S that can be achieved using a subset of the given list of elements. possible_sums = [0] * (S + 1) for elem in elements: for i in range(S, elem - 1, -1): possible_sums[i] = max(possible_sums[i], possible_sums[i - elem] + elem) return possible_sums[S]"},{"question":"def alternating_case(s: str) -> str: Transforms the letters of each word in the input string \`s\` into alternating cases, starting with uppercase, and removes any extra spaces between words. Examples: >>> alternating_case(\\" hello world \\") 'HeLlO WoRlD' >>> alternating_case(\\"tHis is A test\\") 'ThIs Is A TeSt' >>> alternating_case(\\"PYTHON ProGRAMMing \\") 'PyThOn PrOgRaMmInG'","solution":"def alternating_case(s): Transforms the letters of each word in the input string \`s\` into alternating cases, starting with uppercase, and removes any extra spaces between words. # Split the string into words words = s.split() transformed_words = [] for word in words: # Transform each word into alternating cases transformed_word = ''.join( char.lower() if i % 2 else char.upper() for i, char in enumerate(word) ) transformed_words.append(transformed_word) # Join the transformed words with a single space return ' '.join(transformed_words)"},{"question":"def max_subarray_sum(n: int, arr: List[int]) -> int: Finds the largest sum of contiguous subarray within the list of integers using Kadane's algorithm. >>> max_subarray_sum(9, [-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_subarray_sum(5, [1, 2, 3, 4, 5]) 15 >>> max_subarray_sum(5, [-1, -2, -3, -4, -5]) -1 >>> max_subarray_sum(3, [2, -1, 2]) 3","solution":"def max_subarray_sum(n, arr): Finds the largest sum of contiguous subarray within the list of integers using Kadane’s algorithm. if n == 0: return 0 max_current = max_global = arr[0] for i in range(1, n): max_current = max(arr[i], max_current + arr[i]) if max_current > max_global: max_global = max_current return max_global # Example usage: # n = 9 # arr = [-2, 1, -3, 4, -1, 2, 1, -5, 4] # print(max_subarray_sum(n, arr)) # Output: 6"},{"question":"def longestPrefixSuffix(s: str) -> int: Returns the length of the longest subsequence that is both prefix and suffix in the given string 's'. >>> longestPrefixSuffix(\\"abca\\") 1 >>> longestPrefixSuffix(\\"abcab\\") 2 >>> longestPrefixSuffix(\\"aaaa\\") 3 >>> longestPrefixSuffix(\\"abacabadabacaba\\") 7 from typing import List def test_example_1(): assert longestPrefixSuffix(\\"abca\\") == 1 def test_example_2(): assert longestPrefixSuffix(\\"abcab\\") == 2 def test_example_3(): assert longestPrefixSuffix(\\"aaaa\\") == 3 def test_example_4(): assert longestPrefixSuffix(\\"abacabadabacaba\\") == 7 def test_no_prefix_suffix(): assert longestPrefixSuffix(\\"abcd\\") == 0 def test_single_character(): assert longestPrefixSuffix(\\"a\\") == 0 def test_repeated_patterns(): assert longestPrefixSuffix(\\"abababab\\") == 6 def test_mixed_case(): assert longestPrefixSuffix(\\"aAaaAaaaA\\") == 2 def test_long_string(): long_string = \\"a\\" * 1000 + \\"b\\" * 1000 + \\"a\\" * 1000 assert longestPrefixSuffix(long_string) == 1000","solution":"def longestPrefixSuffix(s: str) -> int: Returns the length of the longest subsequence that is both prefix and suffix in the given string 's'. n = len(s) lps = [0] * n length = 0 i = 1 while i < n: if s[i] == s[length]: length += 1 lps[i] = length i += 1 else: if length != 0: length = lps[length - 1] else: lps[i] = 0 i += 1 return lps[-1]"},{"question":"def sum_of_increasing_differences(n: int, arr: List[int]) -> int: Calculate the sum of the differences between consecutive elements where the first element is less than the second one. >>> sum_of_increasing_differences(5, [1, 3, 2, 5, 4]) 5 >>> sum_of_increasing_differences(4, [10, 20, 10, 30]) 30 >>> sum_of_increasing_differences(3, [5, 5, 5]) 0","solution":"def sum_of_increasing_differences(n, arr): sum_diff = 0 for i in range(1, n): if arr[i] > arr[i - 1]: sum_diff += arr[i] - arr[i - 1] return sum_diff # Example usage: # n = 5 # arr = [1, 3, 2, 5, 4] # print(sum_of_increasing_differences(n, arr)) # Output: 5"},{"question":"def can_transform_to_single_a(s: str) -> str: Determines if the string s can be transformed into a single 'a' by repeatedly replacing any three consecutive characters with 'a'. Parameters: s: A string consisting of characters 'a', 'b', and 'c' only. Returns: A string: \\"YES\\" if the string can be transformed into a single 'a', otherwise \\"NO\\". Examples: >>> can_transform_to_single_a(\\"aaabbbccc\\") \\"YES\\" >>> can_transform_to_single_a(\\"aabbbc\\") \\"NO\\"","solution":"def can_transform_to_single_a(s): Determines if the string s can be transformed into a single 'a' by repeatedly replacing any three consecutive characters with 'a'. while len(s) > 1: changed = False for i in range(len(s) - 2): if s[i] == s[i + 1] == s[i + 2]: s = s[:i] + 'a' + s[i + 3:] changed = True break if not changed: return \\"NO\\" return \\"YES\\" if s == 'a' else \\"NO\\""},{"question":"def find_two_sum_indices(n: int, target: int, nums: List[int]) -> List[int]: Find the indices of the two numbers such that they add up to target. >>> find_two_sum_indices(5, 9, [2, 7, 11, 15, 4]) [0, 1] >>> find_two_sum_indices(4, 6, [3, 2, 4, 7]) [1, 2]","solution":"def two_sum(nums, target): Returns the indices of the two numbers such that they add up to target. index_map = {} # Stores number and its index for index, num in enumerate(nums): complement = target - num if complement in index_map: return sorted([index_map[complement], index]) index_map[num] = index return [] # Function to parse input and provide output matching the expected format def find_two_sum_indices(n, target, nums): return two_sum(nums, target)"},{"question":"import heapq from collections import defaultdict import sys from typing import List, Tuple def shortest_path_from_1_to_N(graph: defaultdict, N: int) -> int: Given an undirected graph with N nodes and M edges, each edge has a weight associated with it. The weights of the edges can be negative as well. Your task is to find the length of the shortest path from node 1 to node N. >>> graph = defaultdict(list) >>> graph[1].extend([(2, 2), (3, 6)]) >>> graph[2].append((3, 3)) >>> shortest_path_from_1_to_N(graph, 3) 5 >>> graph = defaultdict(list) >>> graph[1].extend([(2, 2), (4, 4)]) >>> graph[2].append((3, -5)) >>> graph[3].append((4, 1)) >>> shortest_path_from_1_to_N(graph, 4) -2 Args: graph (defaultdict): The graph represented as an adjacency list. N (int): The number of nodes. Returns: int: The length of the shortest path from node 1 to node N. If no path exists, return -1. pass def process_input(T: int, test_cases: List[Tuple[int, int, List[Tuple[int, int, int]]]]) -> List[int]: Process the input and get the shortest path lengths for each test case. >>> T = 2 >>> test_cases = [(3, 3, [(1, 2, 2), (2, 3, 3), (1, 3, 6)]), (4, 4, [(1, 2, 2), (2, 3, -5), (3, 4, 1), (1, 4, 4)])] >>> process_input(T, test_cases) [5, -2] Args: T (int): The number of test cases. test_cases (List[Tuple[int, int, List[Tuple[int, int, int]]]]): The test cases. Returns: List[int]: A list of shortest path lengths for each test case. If no path exists for a test case, return -1. pass","solution":"import heapq from collections import defaultdict import sys def shortest_path_from_1_to_N(graph, N): # Dijkstra's algorithm with a priority queue dist = [sys.maxsize] * (N + 1) dist[1] = 0 pq = [(0, 1)] # (distance, node) visited = set() while pq: current_distance, current_node = heapq.heappop(pq) if current_node in visited: continue visited.add(current_node) for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < dist[neighbor]: dist[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) return dist[N] if dist[N] != sys.maxsize else -1 def process_input(T, test_cases): results = [] for i in range(T): N, M, edges = test_cases[i] graph = defaultdict(list) for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) # since the graph is undirected results.append(shortest_path_from_1_to_N(graph, N)) return results"},{"question":"def nextClosestTime(s: str) -> str: Given a string s which represents a time in the format \\"HH:MM\\", find and return the next closest time that can be formed using only the digits present in s. The returned time should still be in the 24-hour format. Example: >>> nextClosestTime(\\"19:34\\") '19:39' >>> nextClosestTime(\\"23:59\\") '22:22' :param s: Time in string format \\"HH:MM\\" :return: Closest future time in string format \\"HH:MM\\" def test_next_closest_time_case1(): assert nextClosestTime(\\"19:34\\") == \\"19:39\\" def test_next_closest_time_case2(): assert nextClosestTime(\\"23:59\\") == \\"22:22\\" def test_next_closest_time_case3(): assert nextClosestTime(\\"12:45\\") == \\"12:51\\" def test_next_closest_time_case4(): assert nextClosestTime(\\"01:32\\") == \\"01:33\\" def test_next_closest_time_case5(): assert nextClosestTime(\\"11:11\\") == \\"11:11\\"","solution":"from itertools import product def nextClosestTime(s): Given a string s which represents a time in the format \\"HH:MM\\", find and return the next closest time that can be formed using only the digits present in s. :param s: Time in string format \\"HH:MM\\" :return: Closest future time in string format \\"HH:MM\\" current_minutes = int(s[:2]) * 60 + int(s[3:]) allowed_digits = {int(x) for x in s if x != ':'} while True: current_minutes = (current_minutes + 1) % (24 * 60) next_time = f\\"{current_minutes // 60:02}:{current_minutes % 60:02}\\" if all(int(a) in allowed_digits for a in next_time if a != ':'): return next_time"},{"question":"def maximizeValue(capacity: int, items: List[Tuple[int, int]]) -> int: Determine the maximum total value of items that can fit in the suitcase without exceeding the weight capacity. >>> maximizeValue(50, [(10, 60), (20, 100), (30, 120)]) 220 >>> maximizeValue(10, [(15, 10), (15, 50), (15, 60)]) 0","solution":"def maximizeValue(capacity, items): Determine the maximum total value of items that can fit in the suitcase without exceeding the weight capacity. :param capacity: int, the maximum weight capacity of the suitcase. :param items: List of tuples, where each tuple contains (weight, value) of an item. :return: int, the maximum value Tom can carry. n = len(items) # create table to store maximum value for each capacity from 0 to capacity dp = [[0] * (capacity + 1) for _ in range(n + 1)] # fill the dp table for i in range(1, n + 1): current_weight, current_value = items[i - 1] for w in range(capacity + 1): if current_weight > w: dp[i][w] = dp[i - 1][w] else: dp[i][w] = max(dp[i - 1][w], dp[i - 1][w - current_weight] + current_value) return dp[n][capacity]"},{"question":"from typing import List, Optional def most_frequent_animal(cameras: List[List[str]]) -> List[Optional[str]]: Determine the most frequently captured animal type from each camera. >>> cameras = [ >>> [\\"lion\\", \\"zebra\\", \\"lion\\", \\"elephant\\"], >>> [\\"giraffe\\", \\"giraffe\\", \\"zebra\\"], >>> [\\"elephant\\", \\"zebra\\", \\"zebra\\"] >>> ] >>> most_frequent_animal(cameras) [\\"lion\\", \\"giraffe\\", \\"zebra\\"] >>> cameras = [ >>> [\\"lion\\", \\"zebra\\", \\"lion\\", \\"zebra\\"], >>> [\\"giraffe\\", \\"giraffe\\", \\"giraffe\\"], >>> [\\"elephant\\", \\"zebra\\", \\"elephant\\", \\"zebra\\"] >>> ] >>> most_frequent_animal(cameras) [\\"lion\\", \\"giraffe\\", \\"elephant\\"] >>> cameras = [ >>> [\\"lion\\", \\"lion\\", \\"lion\\"], >>> [], >>> [\\"elephant\\"] >>> ] >>> most_frequent_animal(cameras) [\\"lion\\", None, \\"elephant\\"] >>> cameras = [ >>> [\\"lion\\", \\"zebra\\", \\"lion\\", \\"elephant\\"] >>> ] >>> most_frequent_animal(cameras) [\\"lion\\"] >>> cameras = [ >>> [\\"lion\\"], >>> [\\"giraffe\\"], >>> [\\"elephant\\", \\"elephant\\", \\"zebra\\", \\"zebra\\"] >>> ] >>> most_frequent_animal(cameras) [\\"lion\\", \\"giraffe\\", \\"elephant\\"]","solution":"from collections import Counter def most_frequent_animal(cameras): most_frequent_animals = [] for pictures in cameras: if not pictures: most_frequent_animals.append(None) continue animal_count = Counter(pictures) most_frequent_animal = sorted(animal_count, key=lambda x: (-animal_count[x], x))[0] most_frequent_animals.append(most_frequent_animal) return most_frequent_animals"},{"question":"def min_additional_edges(n, m, edges): Determine the minimum number of additional resources (edges) required to make the entire orchard connected. Args: n (int): The number of trees. m (int): The number of existing resources. edges (List[Tuple[int, int]]): The existing resources between trees. Returns: int: The minimum number of additional resources (edges) required. >>> min_additional_edges(4, 2, [(1, 2), (2, 3)]) 1 >>> min_additional_edges(3, 3, [(1, 2), (2, 3), (3, 1)]) 0 >>> min_additional_edges(5, 1, [(4, 5)]) 3 pass def process_test_cases(test_cases): Process multiple test cases to determine the minimum number of additional resources needed to connect all trees. Args: test_cases (List[Tuple[int, int, List[Tuple[int, int]]]]): List of test cases where each test case contains: (number of trees, number of existing resources, list of resource connections) Returns: List[int]: The minimum number of additional resources required for each test case. >>> process_test_cases([(4, 2, [(1, 2), (2, 3)]), (3, 3, [(1, 2), (2, 3), (3, 1)]), (5, 1, [(4, 5)])]) [1, 0, 3] pass","solution":"def dfs(node, visited, graph): stack = [node] while stack: current = stack.pop() for neighbor in graph[current]: if not visited[neighbor]: visited[neighbor] = True stack.append(neighbor) def min_additional_edges(n, m, edges): graph = [[] for _ in range(n + 1)] for u, v in edges: graph[u].append(v) graph[v].append(u) visited = [False] * (n + 1) components = 0 for i in range(1, n + 1): if not visited[i]: components += 1 visited[i] = True dfs(i, visited, graph) return components - 1 def process_test_cases(test_cases): results = [] for case in test_cases: n, m, edges = case result = min_additional_edges(n, m, edges) results.append(result) return results"},{"question":"def encrypt_name(name: str, k: int) -> str: Encrypts the given name by shifting each letter by k positions in the alphabet. Args: name (str): The name of the employee to be encrypted. k (int): The number of positions to shift each letter. Returns: str: The encrypted name. >>> encrypt_name(\\"Alice\\", 3) 'Dolfh' >>> encrypt_name(\\"Bob\\", 3) 'Ere' >>> encrypt_name(\\"John\\", 2) 'Lqjp' >>> encrypt_name(\\"Doe\\", 2) 'Fqg' >>> encrypt_name(\\"Mary\\", 2) 'Octa' pass def encrypt_employee_names(test_cases: List[Dict[str, Union[int, List[str]]]]) -> List[str]: Encrypts the names of all employees in the test cases. Args: test_cases (List[Dict[str, Union[int, List[str]]]]): A list of test cases, where each test case is a dictionary with the number of positions to shift (k) and the list of employee names. Returns: List[str]: A list of encrypted names of all employees. >>> test_cases = [ ... { ... \\"k\\": 3, ... \\"names\\": [\\"Alice\\", \\"Bob\\"] ... }, ... { ... \\"k\\": 2, ... \\"names\\": [\\"John\\", \\"Doe\\", \\"Mary\\"] ... } ... ] >>> encrypt_employee_names(test_cases) ['Dolfh', 'Ere', 'Lqjp', 'Fqg', 'Octa'] pass","solution":"def encrypt_name(name, k): encrypted_name = [] for char in name: if 'a' <= char <= 'z': # Encrypt lowercase letters shifted_char = chr((ord(char) - ord('a') + k) % 26 + ord('a')) elif 'A' <= char <= 'Z': # Encrypt uppercase letters shifted_char = chr((ord(char) - ord('A') + k) % 26 + ord('A')) else: # Non alphabetical characters remain the same shifted_char = char encrypted_name.append(shifted_char) return ''.join(encrypted_name) def encrypt_employee_names(test_cases): results = [] for case in test_cases: k, names = case['k'], case['names'] encrypted_names = [encrypt_name(name, k) for name in names] results.extend(encrypted_names) return results"},{"question":"import heapq from typing import List, Tuple def find_shortest_path(N: int, M: int, A: int, B: int, roads: List[Tuple[int, int, int]]) -> int: Determine the minimum travel time required to travel from city A to city B. If there is no possible route from city A to city B, return -1. >>> find_shortest_path(4, 4, 1, 4, [(1, 2, 4), (2, 3, 1), (3, 4, 1), (1, 3, 7)]) 6 >>> find_shortest_path(3, 2, 1, 3, [(1, 2, 2), (2, 1, 2)]) -1 >>> find_shortest_path(3, 2, 1, 3, [(1, 2, 2), (2, 3, 2)]) 4 >>> find_shortest_path(5, 6, 1, 5, [(1, 2, 2), (2, 3, 2), (3, 5, 2), (1, 4, 12), (4, 5, 1), (2, 5, 7)]) 6 >>> find_shortest_path(3, 3, 1, 1, [(1, 2, 2), (2, 3, 2), (3, 1, 2)]) 0","solution":"import heapq def find_shortest_path(N, M, A, B, roads): graph = {i: [] for i in range(1, N+1)} for u, v, t in roads: graph[u].append((v, t)) graph[v].append((u, t)) # If roads are bidirectional # Dijkstra's algorithm def dijkstra(source, target): heap = [(0, source)] visited = set() min_distance = {i: float('inf') for i in range(1, N+1)} min_distance[source] = 0 while heap: current_dist, current_node = heapq.heappop(heap) if current_node in visited: continue visited.add(current_node) if current_node == target: return current_dist for neighbor, weight in graph[current_node]: distance = current_dist + weight if distance < min_distance[neighbor]: min_distance[neighbor] = distance heapq.heappush(heap, (distance, neighbor)) return -1 return dijkstra(A, B) # Example Usage if __name__ == \\"__main__\\": N = 4 M = 4 A = 1 B = 4 roads = [(1, 2, 4), (2, 3, 1), (3, 4, 1), (1, 3, 7)] print(find_shortest_path(N, M, A, B, roads)) # Output: 6"},{"question":"from typing import List def trap_rainwater(heights: List[int]) -> int: Given a non-empty array of integers representing the heights of buildings in an urban landscape where the width of each building is 1, determine the maximum amount of water that can be trapped between the buildings after it rains. >>> trap_rainwater([4, 2, 0, 3, 2, 5]) 9 >>> trap_rainwater([]) 0 >>> trap_rainwater([1, 2, 3, 4, 5]) 0 >>> trap_rainwater([3, 3, 3, 3, 3]) 0 >>> trap_rainwater([3, 0, 3]) 3 >>> trap_rainwater([1, 0, 2, 0, 1, 0, 3]) 6","solution":"def trap_rainwater(heights): Given a list of non-negative integers representing the heights of buildings, returns the maximum amount of water that can be trapped after raining. if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n # Fill left max height array left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) # Fill right max height array right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) # Calculate the accumulated water water_trapped = 0 for i in range(n): water_trapped += min(left_max[i], right_max[i]) - heights[i] return water_trapped"},{"question":"def max_profit(prices): Function to compute the maximum profit from a list of stock prices. The function computes the best day to buy and sell to get the maximum profit. >>> max_profit([7, 1, 5, 3, 6, 4]) 5 >>> max_profit([7, 6, 4, 3, 1]) 0 :param prices: List of integers representing the stock prices on each day. :return: Integer representing the maximum profit achievable.","solution":"def max_profit(prices): Function to compute the maximum profit from a list of stock prices. The function computes the best day to buy and sell to get the maximum profit. :param prices: List of integers representing the stock prices on each day. :return: Integer representing the maximum profit achievable. if not prices: return 0 min_price = float('inf') max_profit = 0 for price in prices: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"def compare_dynamic_base_numbers(num1: str, num2: str) -> str: Compare two numbers in Nogot's dynamic base-N system. >>> compare_dynamic_base_numbers(\\"101\\", \\"110\\") '<' >>> compare_dynamic_base_numbers(\\"10\\", \\"1\\") '>' >>> compare_dynamic_base_numbers(\\"110\\", \\"110\\") '=' >>> compare_dynamic_base_numbers(\\"1\\", \\"10\\") '<' >>> compare_dynamic_base_numbers(\\"0\\", \\"10\\") '<'","solution":"def compare_dynamic_base_numbers(num1, num2): def to_decimal(number): length = len(number) decimal_value = 0 current_base = 1 for i in range(length): digit = int(number[i]) if i > 0: current_base = int(number[i - 1]) + 1 decimal_value = decimal_value * current_base + digit return decimal_value decimal_num1 = to_decimal(num1) decimal_num2 = to_decimal(num2) if decimal_num1 > decimal_num2: return \\">\\" elif decimal_num1 < decimal_num2: return \\"<\\" else: return \\"=\\""},{"question":"import math from typing import List, Tuple def calculate_distance(p1: Tuple[int, int], p2: Tuple[int, int]) -> float: Calculate the Euclidean distance between two points in a 2D plane. >>> calculate_distance((0, 0), (0, 1)) 1.0 >>> calculate_distance((0, 0), (1, 1)) math.sqrt(2) def polygon_perimeter(points: List[Tuple[int, int]]) -> float: Calculate the perimeter of a polygon given its vertices. >>> polygon_perimeter([(0, 0), (0, 1), (1, 1), (1, 0)]) 4.00 >>> polygon_perimeter([(0, 0), (0, 2), (2, 2), (2, 0), (1, 0)]) 8.00 def process_input(datasets: List[Tuple[int, ...]]) -> List[float]: Process multiple datasets of polygon vertices to compute their perimeters. >>> process_input([(4, (0, 0), (0, 1), (1, 1), (1, 0))]) [4.00] >>> process_input([ ... (4, (0, 0), (0, 1), (1, 1), (1, 0)), ... (5, (0, 0), (0, 2), (2, 2), (2, 0), (1, 0)) ... ]) [4.00, 8.00]","solution":"import math def calculate_distance(p1, p2): Helper function to calculate the Euclidean distance between two points. return math.sqrt((p2[0] - p1[0])**2 + (p2[1] - p1[1])**2) def polygon_perimeter(points): Function to calculate the perimeter of a polygon given its vertices. n = len(points) perimeter = 0 for i in range(n): perimeter += calculate_distance(points[i], points[(i + 1) % n]) return round(perimeter, 2) def process_input(datasets): result = [] for data in datasets: n = data[0] points = data[1:] result.append(polygon_perimeter(points)) return result"},{"question":"from collections import defaultdict, deque from typing import List, Tuple, Union def find_valid_order(s: int, r: int, roads: List[Tuple[int, int]], categories: List[int]) -> Union[List[int], int]: Determine if there is a valid way to visit all scenic sites following Alex's restriction. Args: s : int : number of scenic sites r : int : number of roads roads : List[Tuple[int, int]] : list of roads, each connecting two scenic sites categories : List[int] : list of categories for each scenic site Returns: List[int] : any valid order of visiting the scenic sites int : -1, if no valid order exists Examples: >>> find_valid_order(4, 3, [(1, 2), (2, 3), (3, 4)], [1, 2, 1, 2]) [1, 2, 3, 4] >>> find_valid_order(3, 2, [(1, 2), (2, 3)], [1, 1, 1]) -1 >>> find_valid_order(5, 4, [(1, 2), (1, 3), (3, 4), (4, 5)], [2, 1, 2, 1, 2]) [2, 1, 3, 4, 5]","solution":"from collections import deque, defaultdict def find_valid_order(s, r, roads, categories): graph = defaultdict(list) in_degree = [0] * s for u, v in roads: graph[u - 1].append(v - 1) graph[v - 1].append(u - 1) in_degree[u - 1] += 1 in_degree[v - 1] += 1 # Partition nodes based on their categories category_nodes = defaultdict(list) for i in range(s): category_nodes[categories[i]].append(i) # BFS to partition graph by alternating categories visited = [False] * s order = [] def bfs(start): queue = deque([start]) visited[start] = True last_category = categories[start] while queue: node = queue.popleft() order.append(node + 1) for neighbor in graph[node]: if not visited[neighbor] and categories[neighbor] != last_category: visited[neighbor] = True queue.append(neighbor) last_category = categories[node] for i in range(s): if not visited[i]: bfs(i) # Validate the order for i in range(1, s): if categories[order[i] - 1] == categories[order[i - 1] - 1]: return -1 return order # Example usage if __name__ == \\"__main__\\": print(find_valid_order(4, 3, [(1, 2), (2, 3), (3, 4)], [1, 2, 1, 2])) # Should return a valid order print(find_valid_order(3, 2, [(1, 2), (2, 3)], [1, 1, 1])) # Should return -1 print(find_valid_order(5, 4, [(1, 2), (1, 3), (3, 4), (4, 5)], [2, 1, 2, 1, 2])) # Should return a valid order"},{"question":"def get_block_length(s: str, queries: [(int, int)]) -> [int]: Given a string s and a list of queries, return the block length for each queried substring. Args: s : str : The input string. queries : list of tuples : Each tuple contains two integers l and r representing query indices (1-based). Returns: list : List of integers representing the block lengths of the queried substrings. Examples: >>> get_block_length(\\"aaabbbaaa\\", [(1, 9), (4, 6), (1, 3)]) [3, 3, 3] >>> get_block_length(\\"abcde\\", [(1, 5), (2, 4)]) [1, 1] # Implementation Here def process_queries(input_str: str, n: int, queries: [(int, int)]) -> [int]: Processes multiple queries for block lengths of substrings. Args: input_str : str : The input string. n : int : Number of queries. queries : list of tuples : List of tuples containing the queries. Returns: list : List of integers representing the block lengths of the queried substrings. Examples: >>> process_queries(\\"aaabbbaaa\\", 3, [(1, 9), (4, 6), (1, 3)]) [3, 3, 3] >>> process_queries(\\"abcde\\", 2, [(1, 5), (2, 4)]) [1, 1] # Implementation Here","solution":"def get_block_length(s, queries): Given a string s and a list of queries, return the block length for each queried substring. Arguments: s : str : The input string. queries : list of tuples : Each tuple contains two integers l and r representing query indices (1-based). Returns: list : List of integers representing the block lengths of the queried substrings. results = [] for l, r in queries: substring = s[l-1:r] max_block_length = 0 current_block_length = 1 for i in range(1, len(substring)): if substring[i] == substring[i-1]: current_block_length += 1 else: max_block_length = max(max_block_length, current_block_length) current_block_length = 1 max_block_length = max(max_block_length, current_block_length) results.append(max_block_length) return results def process_queries(input_str, n, queries): Processes multiple queries for block lengths of substrings. Arguments: input_str : str : The input string. n : int : Number of queries. queries : list of tuples : List of tuples containing the queries. Returns: list : List of integers representing the block lengths of the queried substrings. return get_block_length(input_str, queries)"},{"question":"def find_largest_divisible(m: int, d: int) -> int: Write a function \`find_largest_divisible\` that takes two integers \`m\` and \`d\`, and returns the largest integer less than or equal to \`m\` that is divisible by \`d\`. If no such number exists, return \`-1\`. >>> find_largest_divisible(10, 3) 9 >>> find_largest_divisible(14, 7) 14 >>> find_largest_divisible(5, 0) -1","solution":"def find_largest_divisible(m, d): Returns the largest integer less than or equal to m that is divisible by d. If no such number exists, return -1. if d <= 0 or m < 0: return -1 result = (m // d) * d return result if result <= m else -1"},{"question":"class NestedIterator: def __init__(self, nestedList): Initialize the iterator with a nested list. pass def next(self): Return the next integer in the nested list. pass def hasNext(self): Return true if there are more integers to iterate. pass","solution":"class NestedIterator: def __init__(self, nestedList): self.index = 0 self.flat_list = [] self.flatten(nestedList) def flatten(self, nestedList): for element in nestedList: if isinstance(element, list): self.flatten(element) else: self.flat_list.append(element) def next(self): result = self.flat_list[self.index] self.index += 1 return result def hasNext(self): return self.index < len(self.flat_list)"},{"question":"def longest_subsequence_with_product_less_than_or_equal_k(n, k, sequence): Finds the length of the longest contiguous subsequence such that the product of all its elements is less than or equal to k. Parameters: n (int): The length of the sequence. k (int): The upper bound value of the product of the subsequence elements. sequence (List[int]): The elements of the sequence. Returns: int: Length of the longest contiguous subsequence with product <= k. >>> longest_subsequence_with_product_less_than_or_equal_k(6, 100, [10, 5, 2, 6, 7, 1]) 4 >>> longest_subsequence_with_product_less_than_or_equal_k(5, 100, [1, 1, 1, 1, 1]) 5 >>> longest_subsequence_with_product_less_than_or_equal_k(5, 10, [1, 1, 12, 1, 1]) 2 >>> longest_subsequence_with_product_less_than_or_equal_k(5, 1, [2, 2, 2, 2, 2]) 0 >>> longest_subsequence_with_product_less_than_or_equal_k(6, 1000000000, [10, 5, 2, 6, 7, 1]) 6","solution":"def longest_subsequence_with_product_less_than_or_equal_k(n, k, sequence): n: Length of the sequence k: Upper bound of the product sequence: List of elements representing the sequence Returns the length of the longest contiguous subsequence such that the product of its elements is less than or equal to k. if k == 0: # If k is zero, no product of positive integers can be <= 0 return 0 max_length = 0 product = 1 left = 0 for right in range(n): product *= sequence[right] while product > k and left <= right: product //= sequence[left] left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"def minimize_height_difference(n: int, heights: List[int]) -> int: Given the number of towers and their heights, this function returns the minimum possible difference between the height of the tallest and the shortest tower after reducing heights. >>> minimize_height_difference(5, [5, 1, 8, 4, 10]) 0 >>> minimize_height_difference(3, [3, 3, 3]) 0 >>> minimize_height_difference(4, [1, 2, 3, 4]) 0","solution":"def minimize_height_difference(n, heights): Given the number of towers and their heights, this function returns the minimum possible difference between the height of the tallest and the shortest tower after reducing heights. # Minimum height is the height of the shortest tower min_height = min(heights) # Reduce all towers to min_height and calculate the new heights new_heights = [height - min_height for height in heights] # Since we have reduced all towers to the minimum height, their difference is 0 return 0"},{"question":"def can_finish(numCourses: int, prerequisites: List[List[int]]) -> bool: Determine if it is possible to finish all courses given the prerequisite list. Args: numCourses (int): The total number of courses. prerequisites (List[List[int]]): A list of prerequisite pairs. Returns: bool: True if it is possible to finish all courses, otherwise False. Examples: >>> can_finish(2, [[1, 0]]) True >>> can_finish(2, [[1, 0], [0, 1]]) False >>> can_finish(4, [[1, 0], [2, 1], [3, 2], [1, 3]]) False","solution":"def can_finish(numCourses, prerequisites): from collections import defaultdict, deque # Create the adjacency list to represent the graph graph = defaultdict(list) in_degree = [0] * numCourses # Build the graph and in-degree list for dest, src in prerequisites: graph[src].append(dest) in_degree[dest] += 1 # Initialize the queue with all courses having zero in-degree zero_in_degree_queue = deque([i for i in range(numCourses) if in_degree[i] == 0]) visited_courses = 0 while zero_in_degree_queue: course = zero_in_degree_queue.popleft() visited_courses += 1 for neighbor in graph[course]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: zero_in_degree_queue.append(neighbor) # If all courses are visited, return True return visited_courses == numCourses"},{"question":"import sys from datetime import datetime def unique_weekdays(): Read a series of dates and output the number of unique weekdays these dates fall on. Input: - Multiple lines, each with a single date in \\"YYYY-MM-DD\\" format. - The list terminates with a blank line. Output: - Number of unique weekdays these dates correspond to. Example: >>> import sys >>> from io import StringIO >>> sys.stdin = StringIO(\\"2023-10-10n2023-10-11n2023-10-12n2022-01-01nn\\") >>> unique_weekdays() 4","solution":"import sys from datetime import datetime def unique_weekdays(): weekday_set = set() for line in sys.stdin: date_str = line.strip() if not date_str: # Blank line indicates end of input break date_obj = datetime.strptime(date_str, '%Y-%m-%d') weekday_set.add(date_obj.strftime('%A')) # Print the number of unique weekdays print(len(weekday_set))"},{"question":"def knapsack(C: int, N: int, items: List[Tuple[int, int]]) -> int: Solves the knapsack problem and returns the maximum value that can be carried in the backpack without exceeding its capacity. Parameters: - C: int, capacity of the backpack - N: int, number of items - items: list of tuples, each tuple (Wi, Vi) indicates weight and value of an item Returns: - int, the maximum value that can be carried in the backpack without exceeding its capacity Example: >>> knapsack(4, 3, [(1, 3), (4, 5), (3, 4)]) 7 >>> knapsack(5, 1, [(5, 10)]) 10 >>> knapsack(5, 1, [(6, 10)]) 0 def solve_knapsack_from_input(input_string: str) -> int: Converts input string to arguments for knapsack function and returns the result. Parameters: - input_string: str, input data in specified format Returns: - int, the result from knapsack function Example: >>> solve_knapsack_from_input(\\"4n3n1 3n4 5n3 4\\") 7 >>> solve_knapsack_from_input(\\"5n1n5 10\\") 10 >>> solve_knapsack_from_input(\\"10n4n5 10n4 40n6 30n3 50\\") 90","solution":"def knapsack(C, N, items): Solves the knapsack problem. Parameters: - C: int, capacity of the backpack - N: int, number of items - items: list of tuples, each tuple (Wi, Vi) indicates weight and value of an item Returns: - int, the maximum value that can be carried in the backpack without exceeding its capacity # Initialize a 2D list for dynamic programming with size (N+1) x (C+1) dp = [[0] * (C + 1) for _ in range(N + 1)] for i in range(1, N + 1): weight, value = items[i-1] for w in range(C + 1): if weight <= w: dp[i][w] = max(dp[i-1][w], dp[i-1][w-weight] + value) else: dp[i][w] = dp[i-1][w] return dp[N][C] def solve_knapsack_from_input(input_string): Converts input string to arguments for knapsack function and returns the result. Parameters: - input_string: str, input data in specified format Returns: - int, the result from knapsack function inputs = input_string.strip().split('n') C = int(inputs[0]) N = int(inputs[1]) items = [tuple(map(int, line.split())) for line in inputs[2:]] return knapsack(C, N, items)"},{"question":"def mostFrequentCharacter(s: str) -> str: Determine the most frequently occurring character in the string. If there are multiple characters with the same highest frequency, return the lexicographically smallest one. Args: s (str): A string consisting of lowercase English letters. Returns: str: The most frequently occurring character. Examples: >>> mostFrequentCharacter(\\"aabbbccdde\\") 'b' >>> mostFrequentCharacter(\\"aabbcc\\") 'a'","solution":"def mostFrequentCharacter(s): Returns the most frequently occurring character in the string s. If there are multiple characters with the same highest frequency, returns the lexicographically smallest one. from collections import Counter # Counting the frequency of each character frequency = Counter(s) # Getting the highest frequency max_freq = max(frequency.values()) # Collecting all characters that have the highest frequency most_frequent_chars = [char for char, freq in frequency.items() if freq == max_freq] # Returning the lexicographically smallest character among them return min(most_frequent_chars)"},{"question":"def determine_winner(S: str) -> str: Determine if Tom can ensure that he wins the game. Parameters: S (str): A string containing only characters 'a' and 'b'. Returns: str: 'Tom' if Tom can ensure a win, 'Jerry' otherwise. >>> determine_winner(\\"ab\\") 'Tom' >>> determine_winner(\\"aaab\\") 'Jerry' >>> determine_winner(\\"aabb\\") 'Tom' >>> determine_winner(\\"aaa\\") 'Jerry' >>> determine_winner(\\"bbb\\") 'Jerry' >>> determine_winner(\\"a\\") 'Jerry' >>> determine_winner(\\"b\\") 'Jerry'","solution":"def determine_winner(S): This function determines whether Tom can ensure a win in the game. Parameters: S (str): A string containing only characters 'a' and 'b'. Returns: str: 'Tom' if Tom can ensure a win, 'Jerry' otherwise. count_a = S.count('a') count_b = S.count('b') # If initial counts are the same, Tom can win by changing the one 'a' to 'b'. if count_a == count_b: return \\"Tom\\" # If counts differ, Jerry will always have the last move # because after an even-move cycle, Jerry changes the count to his advanatage else: return \\"Jerry\\""},{"question":"def is_lucky_slot(S: str) -> str: Determines if a given time slot is \\"lucky\\". A time slot is considered \\"lucky\\" if it contains at least one period ('.') and contains no vowels ('a', 'e', 'i', 'o', 'u'). >>> is_lucky_slot(\\"h.ll.\\") == \\"Lucky\\" >>> is_lucky_slot(\\"aei.\\") == \\"Unlucky\\" >>> is_lucky_slot(\\".......\\") == \\"Lucky\\" >>> is_lucky_slot(\\"abc\\") == \\"Unlucky\\" >>> is_lucky_slot(\\"ilo\\") == \\"Unlucky\\" >>> is_lucky_slot(\\"h.r.jk\\") == \\"Lucky\\" >>> is_lucky_slot(\\"\\") == \\"Unlucky\\"","solution":"def is_lucky_slot(S): Determines if a given time slot is \\"lucky\\". A time slot is considered \\"lucky\\" if it contains at least one period ('.') and contains no vowels ('a', 'e', 'i', 'o', 'u'). Parameters: S (str): The input time slot string. Returns: str: \\"Lucky\\" if the time slot is lucky, \\"Unlucky\\" otherwise. vowels = set('aeiou') has_period = '.' in S has_vowel = any(ch in vowels for ch in S) if has_period and not has_vowel: return \\"Lucky\\" else: return \\"Unlucky\\""},{"question":"def num_decodings(s: str) -> int: Given a string containing only digits, compute the number of ways it can be decoded to letters. (1 maps to 'A', 2 maps to 'B', ..., 26 maps to 'Z'). >>> num_decodings(\\"12\\") 2 >>> num_decodings(\\"226\\") 3 >>> num_decodings(\\"0\\") 0 >>> num_decodings(\\"10\\") 1","solution":"def num_decodings(s): if not s or s[0] == \\"0\\": return 0 n = len(s) dp = [0] * (n + 1) dp[0] = 1 dp[1] = 1 for i in range(2, n + 1): single_digit = int(s[i-1:i]) double_digit = int(s[i-2:i]) if 1 <= single_digit <= 9: dp[i] += dp[i-1] if 10 <= double_digit <= 26: dp[i] += dp[i-2] return dp[n]"},{"question":"from typing import List def find_quadruplets(nums: List[int], target: int) -> List[List[int]]: Find all unique quadruplets in the list that add up to the given target. >>> find_quadruplets([1, 0, -1, 0, -2, 2], 0) [[-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1]] >>> find_quadruplets([1, 2, 3, 4], 100) [] >>> find_quadruplets([1, 1, 1, 1], 4) [[1, 1, 1, 1]] >>> find_quadruplets([1000000000, 1000000000, 1000000000, 1000000000, -1000000000, -1000000000, -1000000000, -1000000000], 0) [[-1000000000, -1000000000, 1000000000, 1000000000]] >>> find_quadruplets([2, 2, 2, 2, 2, 2, 2, 2], 8) [[2, 2, 2, 2]] >>> find_quadruplets([], 0) [] >>> find_quadruplets([1, 2, 3], 6) [] >>> find_quadruplets([-3, -1, 0, 2, 4, 5], 0) [[-3, -1, 0, 4]]","solution":"from typing import List def find_quadruplets(nums: List[int], target: int) -> List[List[int]]: nums.sort() quadruplets = [] n = len(nums) for i in range(n - 3): if i > 0 and nums[i] == nums[i - 1]: continue # Skip duplicates for j in range(i + 1, n - 2): if j > i + 1 and nums[j] == nums[j - 1]: continue # Skip duplicates left, right = j + 1, n - 1 while left < right: curr_sum = nums[i] + nums[j] + nums[left] + nums[right] if curr_sum == target: quadruplets.append([nums[i], nums[j], nums[left], nums[right]]) while left < right and nums[left] == nums[left + 1]: left += 1 # Skip duplicates while left < right and nums[right] == nums[right - 1]: right -= 1 # Skip duplicates left += 1 right -= 1 elif curr_sum < target: left += 1 else: right -= 1 return quadruplets"},{"question":"def max_subarray_sum(arr): Returns the maximum sum of any subarray (contiguous elements) of at least size 2. If the list contains less than 2 elements, return 0. >>> max_subarray_sum([3, -2, 5, -1, 6]) 11 >>> max_subarray_sum([-1, -2, -3, -4]) -1 >>> max_subarray_sum([1, 2, 3, 4]) 10 >>> max_subarray_sum([-2, -3, 4, -1, -2, 1, 5, -3]) 7 >>> max_subarray_sum([1]) 0 >>> max_subarray_sum([3, -2, 5, -1, 6, -10, 4, -5, 7, -3, 2]) 11 # Your code here","solution":"def max_subarray_sum(arr): Returns the maximum sum of any subarray (contiguous elements) of at least size 2. If the list contains less than 2 elements, return 0. if len(arr) < 2: return 0 max_sum = float('-inf') current_sum = 0 for num in arr: current_sum += num max_sum = max(max_sum, current_sum) if current_sum < 0: current_sum = 0 return max_sum"},{"question":"def promote_airline(n: int, k: int, airlines: List[List[Tuple[int, int, int, int]]]) -> int: Find out which airline has overall minimum costs for flights. If there are ties in the cost, choose the airline with the shortest total travel time. If there are still ties, choose the airline with the smallest index. Args: n : int : the number of cities k : int : the number of airlines airlines : List[List[Tuple[int, int, int, int]]] : the list of airlines, where each airline is represented by a list of flights. Each flight is represented by a tuple (u, v, w, t) - u : int : the source city - v : int : the destination city - w : int : the cost - t : int : the time taken Returns: int : the index of the airline that should be promoted Example: >>> promote_airline(4, 2, [ [(1, 2, 100, 50), (1, 3, 200, 100), (2, 3, 150, 80), (2, 4, 200, 120), (3, 4, 300, 150)], [(1, 2, 90, 40), (1, 3, 220, 110), (3, 4, 310, 160)] ]) 1 >>> promote_airline(3, 3, [ [(1, 2, 100, 50), (2, 3, 200, 100)], [(1, 3, 250, 120), (2, 3, 80, 60)], [(1, 2, 50, 30)] ]) 2","solution":"import sys def promote_airline(n, k, airlines): def total_cost_and_time(flights): total_cost = 0 total_time = 0 for u, v, w, t in flights: total_cost += w total_time += t return total_cost, total_time best_index = -1 best_cost = sys.maxsize best_time = sys.maxsize for i in range(k): m_i = len(airlines[i]) current_cost, current_time = total_cost_and_time(airlines[i]) if (current_cost < best_cost or (current_cost == best_cost and current_time < best_time)): best_cost = current_cost best_time = current_time best_index = i return best_index # Example usage n = 4 k = 2 airlines = [ [(1, 2, 100, 50), (1, 3, 200, 100), (2, 3, 150, 80), (2, 4, 200, 120), (3, 4, 300, 150)], [(1, 2, 90, 40), (1, 3, 220, 110), (3, 4, 310, 160)] ] print(promote_airline(n, k, airlines)) # Output should be 1 (zero-indexed)"},{"question":"def maximize_sum(N: int, arr: List[int]) -> Tuple[int, int, List[str]]: Function to maximize the sum of elements of the list using the given operations. >>> maximize_sum(4, [1, 2, 3, 4]) (10, 0, []) >>> maximize_sum(4, [0, 0, 0, 0]) (40000, 1, [\\"inc 10000\\"]) >>> maximize_sum(5, [0, 0, 2, 0, 1]) (3, 0, []) >>> maximize_sum(2, [9999, 9999]) (19998, 0, [])","solution":"def maximize_sum(N, arr): Function to maximize the sum of elements of the list using the given operations. :param N: integer, the size of the list :param arr: List of non-negative integers :return: tuple (maximum_sum, T, operations) max_sum = sum(arr) operations = [] if all(x == 0 for x in arr): k = 10000 new_sum = max_sum + k * N operations.append(f\\"inc {k}\\") return new_sum, len(operations), operations return max_sum, len(operations), operations"},{"question":"from itertools import combinations from typing import List, Tuple def min_difference(N: int, numbers: List[int]) -> int: Computes the minimum possible absolute difference of sums of two sublists obtained by splitting the list of unique positive integers of even length N into two sublists of equal length. :param N: Integer, number of elements in the list (always even). :param numbers: List of unique positive integers. :return: Integer, the minimum possible absolute difference of sums of the two sublists. >>> min_difference(4, [1, 3, 5, 9]) 2 >>> min_difference(6, [1, 2, 3, 4, 5, 6]) 1 pass def process_input(test_cases: List[Tuple[int, List[int]]]) -> List[int]: Processes multiple test cases and returns the results. :param test_cases: A list of tuples where each tuple contains an integer N and a list of integers. :return: A list of integers representing the minimum possible absolute difference of sums of the two sublists for each test case. >>> process_input([(4, [1, 3, 5, 9]), (6, [1, 2, 3, 4, 5, 6])]) [2, 1] >>> process_input([(2, [1, 2]), (2, [2, 3])]) [1, 1] pass","solution":"from itertools import combinations def min_difference(N, numbers): Computes the minimum possible absolute difference of sums of two sublists obtained by splitting the list of unique positive integers of even length N into two sublists of equal length. half_N = N // 2 total_sum = sum(numbers) min_diff = float('inf') # Generate all possible combinations of N//2 elements for comb in combinations(numbers, half_N): sum_comb = sum(comb) other_sum = total_sum - sum_comb diff = abs(sum_comb - other_sum) min_diff = min(min_diff, diff) return min_diff def process_input(test_cases): results = [] for N, numbers in test_cases: result = min_difference(N, numbers) results.append(result) return results"},{"question":"def is_substring(S: str, T: str) -> str: Determines if S is a substring of T. Args: S : str : the candidate substring T : str : the string to be searched within Returns: str : \\"Yes\\" if S is a substring of T, otherwise \\"No\\" >>> is_substring(\\"abc\\", \\"abcdef\\") 'Yes' >>> is_substring(\\"a\\", \\"b\\") 'No'","solution":"def is_substring(S, T): Determines if S is a substring of T. Args: S : str : the candidate substring T : str : the string to be searched within Returns: str : \\"Yes\\" if S is a substring of T, otherwise \\"No\\" return \\"Yes\\" if S in T else \\"No\\""},{"question":"def find_most_recent_dates(logs): You are given multiple logs, each representing a user’s activity on a particular day. Each log entry contains a user ID, and a timestamp formatted as \\"YYYY-MM-DD\\". Your task is to identify the most recent date for each user and return a list of tuples where each tuple consists of a user ID and their most recent activity date. Args: logs (list of tuple): A list of log entries where each entry is a tuple (user_id, timestamp). Returns: list of tuple: A list of tuples where each tuple is (user_id, most_recent_date). Example: >>> find_most_recent_dates([(\\"user1\\", \\"2023-04-01\\"), (\\"user2\\", \\"2023-03-15\\"), (\\"user1\\", \\"2023-04-03\\"), (\\"user2\\", \\"2023-03-16\\"), (\\"user3\\", \\"2023-02-27\\")]) [(\\"user1\\", \\"2023-04-03\\"), (\\"user2\\", \\"2023-03-16\\"), (\\"user3\\", \\"2023-02-27\\")]","solution":"def find_most_recent_dates(logs): Finds the most recent activity date for each user. Args: logs (list of tuple): A list of log entries where each entry is a tuple (user_id, timestamp). Returns: list of tuple: A list of tuples where each tuple is (user_id, most_recent_date). most_recent = {} for user_id, timestamp in logs: if user_id not in most_recent or timestamp > most_recent[user_id]: most_recent[user_id] = timestamp return list(most_recent.items())"},{"question":"def is_balanced(s: str) -> str: Determines if the input string with parentheses, brackets, and braces is balanced. Args: s (str): A string containing '(', ')', '{', '}', '[' and ']'. Returns: str: \\"YES\\" if the string is balanced, otherwise \\"NO\\". Examples: >>> is_balanced(\\"{[()]}\\") \\"YES\\" >>> is_balanced(\\"{[(])}\\") \\"NO\\" >>> is_balanced(\\"({[]})\\") \\"YES\\" >>> is_balanced(\\"(\\") \\"NO\\"","solution":"def is_balanced(s): Determines if the input string with parentheses, brackets, and braces is balanced. Args: s (str): A string containing '(', ')', '{', '}', '[' and ']'. Returns: str: \\"YES\\" if the string is balanced, otherwise \\"NO\\". stack = [] matching_bracket = {')': '(', '}': '{', ']': '['} for char in s: if char in matching_bracket.values(): stack.append(char) elif char in matching_bracket: if stack and stack[-1] == matching_bracket[char]: stack.pop() else: return \\"NO\\" else: return \\"NO\\" return \\"YES\\" if not stack else \\"NO\\""},{"question":"def process_queries(n, queries): Manage a complex transportation network between planets and keep track of the number of disconnected clusters (connected components) in the network after each update. Parameters: n (int): The number of planets. queries (List[Tuple[int, ...]]): A list of queries where each query is a tuple. - (1, u, v): Introduce a new direct flight between planet \`u\` and planet \`v\`. - (2, u, v): Cancel the direct flight between planet \`u\` and planet \`v\`. - (3,): Return the current number of connected components in the network. Returns: List[int]: The number of connected components after each query of type 3. Examples: >>> process_queries(5, [(1, 1, 2), (1, 2, 3), (3,), (2, 1, 2), (3,), (1, 4, 5), (3,)]) [3, 4, 3] >>> process_queries(4, [(1, 1, 2), (1, 2, 3), (3,), (1, 3, 4), (3,)]) [2, 1] >>> process_queries(3, [(3,), (3,), (3,)]) [3, 3, 3] >>> process_queries(6, [(1, 1, 2), (1, 3, 4), (3,), (1, 5, 6), (3,), (1, 2, 3), (3,), (2, 1, 2), (3,)]) [4, 3, 2, 3] >>> process_queries(5, [(1, 1, 2), (1, 2, 3), (1, 1, 3), (3,), (2, 1, 2), (3,), (1, 4, 5), (3,)]) [3, 4, 3]","solution":"class UnionFind: def __init__(self, n): self.parent = list(range(n)) self.rank = [0] * n self.num_components = n def find(self, u): if self.parent[u] != u: self.parent[u] = self.find(self.parent[u]) return self.parent[u] def union(self, u, v): root_u = self.find(u) root_v = self.find(v) if root_u != root_v: if self.rank[root_u] > self.rank[root_v]: self.parent[root_v] = root_u elif self.rank[root_u] < self.rank[root_v]: self.parent[root_u] = root_v else: self.parent[root_v] = root_u self.rank[root_u] += 1 self.num_components -= 1 def remove(self, u, v): if self.find(u) == self.find(v): self.num_components += 1 # It is theoretically possible to perform removal by some techniques, # but here we simulate by not affecting directly # We need a more complex data structure or approach for true removal def get_components(self): return self.num_components def process_queries(n, queries): uf = UnionFind(n) results = [] for query in queries: if query[0] == 1: _, u, v = query uf.union(u - 1, v - 1) elif query[0] == 2: _, u, v = query uf.remove(u - 1, v - 1) elif query[0] == 3: results.append(uf.get_components()) return results # Example usage: # n = 5 # queries = [(1, 1, 2), (1, 2, 3), (3,), (2, 1, 2), (3,), (1, 4, 5), (3,)] # Output should be [3, 4, 3]"},{"question":"def is_balanced(s: str) -> bool: Check if the input string s containing '(', ')', '{', '}', '[' and ']' is balanced. The string is considered balanced if every opening bracket has a corresponding closing bracket in the correct order. >>> is_balanced(\\"(){}[]\\") True >>> is_balanced(\\"([{}])\\") True >>> is_balanced(\\"{[()]}\\") True >>> is_balanced(\\"{[]}\\") True >>> is_balanced(\\"({[)]}\\") False >>> is_balanced(\\"[{]\\") False >>> is_balanced(\\"(}\\") False >>> is_balanced(\\"[(])\\") False # Unit Test def test_balanced_brackets(): assert is_balanced(\\"(){}[]\\") == True assert is_balanced(\\"([{}])\\") == True assert is_balanced(\\"{[()]}\\") == True assert is_balanced(\\"{[]}\\") == True assert is_balanced(\\"\\") == True # Empty string should be balanced def test_unbalanced_brackets(): assert is_balanced(\\"({[)]}\\") == False assert is_balanced(\\"[{]\\") == False assert is_balanced(\\"(}\\") == False assert is_balanced(\\"[(])\\") == False assert is_balanced(\\"{([)]}\\") == False def test_edge_cases(): assert is_balanced(\\"([)]\\") == False assert is_balanced(\\"(((())))\\") == True assert is_balanced(\\"((((((())\\") == False assert is_balanced(\\"[]{}({})\\") == True def test_only_opening(): assert is_balanced(\\"((((\\") == False assert is_balanced(\\"[[{{\\") == False def test_only_closing(): assert is_balanced(\\"))}}\\") == False assert is_balanced(\\"]}}]\\") == False","solution":"def is_balanced(s: str) -> bool: stack = [] bracket_map = {')': '(', '}': '{', ']': '['} for char in s: if char in bracket_map: top_element = stack.pop() if stack else '#' if bracket_map[char] != top_element: return False else: stack.append(char) return not stack"},{"question":"def can_activate_boost_mode(n: int, energy_levels: List[int], threshold: int) -> str: Determines if there exists a continuous subarray in energy_levels whose sum is at least threshold. >>> can_activate_boost_mode(10, [1, -1, 5, 2, -1, 3, -2, 4, -5, 1], 7) 'YES' >>> can_activate_boost_mode(5, [-1, -1, -1, -1, -1], 0) 'NO'","solution":"def can_activate_boost_mode(n, energy_levels, threshold): Determines if there exists a continuous subarray in energy_levels whose sum is at least threshold. Parameters: n (int): The length of the energy levels array. energy_levels (list of int): Array of integers representing energy levels at different times. threshold (int): The required sum to activate Boost Mode. Returns: str: 'YES' if such a subarray exists, otherwise 'NO'. current_sum = 0 min_prefix_sum = 0 for el in energy_levels: current_sum += el if current_sum - min_prefix_sum >= threshold: return \\"YES\\" if current_sum < min_prefix_sum: min_prefix_sum = current_sum return \\"NO\\""},{"question":"from typing import List def letter_combinations(s: str, k: int) -> List[str]: Generates all possible distinct combinations of letters from a given string that have a specific length and which are organized in non-descending order. Parameters: - s: the input string - k: the length of each combination Returns: - A list of all distinct combinations of length k organized in non-descending order. >>> letter_combinations(\\"abc\\", 2) ['ab', 'ac', 'bc'] >>> letter_combinations(\\"aab\\", 2) ['aa', 'ab'] >>> letter_combinations(\\"\\", 2) [] >>> letter_combinations(\\"abc\\", 0) [] >>> letter_combinations(\\"a\\", 1) ['a'] >>> letter_combinations(\\"aaaa\\", 2) ['aa'] >>> letter_combinations(\\"abcd\\", 3) ['abc', 'abd', 'acd', 'bcd'] >>> letter_combinations(\\"abcd\\", 4) ['abcd'] pass","solution":"from itertools import combinations def letter_combinations(s, k): Generates all possible distinct combinations of letters from a given string that have a specific length and which are organized in non-descending order. Parameters: - s: the input string - k: the length of each combination Returns: - A list of all distinct combinations of length k organized in non-descending order. if not s or k == 0: return [] # Generate all possible combinations comb = combinations(sorted(s), k) # Convert combination tuples to strings and return as a list return sorted(set([''.join(c) for c in comb]))"},{"question":"def height_requirements(heights, min_height): Returns a list of boolean values indicating whether each rider meets the height requirement. :param heights: List of integers representing the heights of potential riders. :param min_height: Integer representing the minimum height requirement. :return: List of boolean values. >>> height_requirements([150, 165, 154, 170], 160) [False, True, False, True] >>> height_requirements([180, 190, 170, 165], 160) [True, True, True, True] >>> height_requirements([150, 155, 140, 130], 160) [False, False, False, False] >>> height_requirements([160, 160, 160, 160], 160) [True, True, True, True] >>> height_requirements([], 160) []","solution":"def height_requirements(heights, min_height): Returns a list of boolean values indicating whether each rider meets the height requirement. :param heights: List of integers representing the heights of potential riders. :param min_height: Integer representing the minimum height requirement. :return: List of boolean values. return [height >= min_height for height in heights]"},{"question":"from typing import List, Tuple def most_common_names(n: int, participants: List[Tuple[str, str]]) -> Tuple[str, str]: Each country's government has decided to conduct a national survey to identify the most common first and last names among the population. Given a list of participants, count the occurrences of each first and last name and determine which names are the most common. >>> most_common_names( ... 5, ... [ ... (\\"Alice\\", \\"Smith\\"), ... (\\"Bob\\", \\"Johnson\\"), ... (\\"Alice\\", \\"Johnson\\"), ... (\\"Bob\\", \\"Smith\\"), ... (\\"Carol\\", \\"Johnson\\") ... ]) ('Alice', 'Johnson') >>> most_common_names( ... 4, ... [ ... (\\"Alice\\", \\"Smith\\"), ... (\\"Alice\\", \\"Johnson\\"), ... (\\"Bob\\", \\"Smith\\"), ... (\\"Bob\\", \\"Johnson\\") ... ]) ('Alice', 'Johnson') >>> most_common_names( ... 1, ... [(\\"Alice\\", \\"Smith\\")] ... ) ('Alice', 'Smith') >>> most_common_names( ... 3, ... [ ... (\\"Alice\\", \\"Smith\\"), ... (\\"Bob\\", \\"Brown\\"), ... (\\"Charlie\\", \\"Johnson\\") ... ]) ('Alice', 'Brown') >>> most_common_names( ... 4, ... [ ... (\\"Alice\\", \\"Smith\\"), ... (\\"Alice\\", \\"Johnson\\"), ... (\\"Alice\\", \\"Brown\\"), ... (\\"Alice\\", \\"White\\") ... ]) ('Alice', 'Brown') >>> most_common_names( ... 4, ... [ ... (\\"Alice\\", \\"Smith\\"), ... (\\"Bob\\", \\"Smith\\"), ... (\\"Charlie\\", \\"Smith\\"), ... (\\"David\\", \\"Smith\\") ... ]) ('Alice', 'Smith')","solution":"def most_common_names(n, participants): from collections import Counter first_names = [p[0] for p in participants] last_names = [p[1] for p in participants] first_name_count = Counter(first_names) last_name_count = Counter(last_names) most_common_first_name = min([name for name, count in first_name_count.items() if count == max(first_name_count.values())]) most_common_last_name = min([name for name, count in last_name_count.items() if count == max(last_name_count.values())]) return most_common_first_name, most_common_last_name # Example Usage n = 5 participants = [ (\\"Alice\\", \\"Smith\\"), (\\"Bob\\", \\"Johnson\\"), (\\"Alice\\", \\"Johnson\\"), (\\"Bob\\", \\"Smith\\"), (\\"Carol\\", \\"Johnson\\") ] print(most_common_names(n, participants)) # Outputs: ('Alice', 'Johnson')"},{"question":"def visible_buildings(heights): Returns an array of the heights of the visible buildings in order from left to right. >>> visible_buildings([3, 7, 8, 3, 6, 1]) [3, 7, 8] >>> visible_buildings([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> visible_buildings([5, 4, 3, 2, 1]) [5] >>> visible_buildings([1, 3, 2, 4, 2]) [1, 3, 4] >>> visible_buildings([]) [] >>> visible_buildings([3, 3, 3, 3, 3]) [3] >>> visible_buildings([2]) [2] >>> visible_buildings([2, 0, 1, 5, 6, 3, 4, 9]) [2, 5, 6, 9]","solution":"def visible_buildings(heights): Returns an array of the heights of the visible buildings in order from left to right. max_height = 0 visible = [] for height in heights: if height > max_height: visible.append(height) max_height = height return visible"},{"question":"def count_binary_strings(n: int) -> int: Determine the number of binary strings of length n that do not contain consecutive '1's. >>> count_binary_strings(0) 1 >>> count_binary_strings(1) 2 >>> count_binary_strings(2) 3 >>> count_binary_strings(3) 5 >>> count_binary_strings(4) 8 def solve(T: int, cases: List[int]) -> List[int]: For each test case, output the number of binary strings of length n that do not contain consecutive '1's. >>> solve(3, [2, 3, 4]) [3, 5, 8] >>> solve(2, [0, 1]) [1, 2] >>> solve(1, [5]) [13] >>> solve(4, [2, 2, 2, 2]) [3, 3, 3, 3]","solution":"def count_binary_strings(n): if n == 0: return 1 elif n == 1: return 2 dp = [0] * (n + 1) dp[0] = 1 dp[1] = 2 for i in range(2, n + 1): dp[i] = dp[i - 1] + dp[i - 2] return dp[n] def solve(T, cases): results = [] for n in cases: results.append(count_binary_strings(n)) return results"},{"question":"from typing import Dict def word_counter(s: str) -> Dict[str, int]: Takes a string \`s\` and returns a dictionary where the keys are the words in the string, and the values are the number of times each word appears. The function is case-insensitive and ignores punctuation. >>> word_counter(\\"Hello, hello! How are you?\\") {'hello': 2, 'how': 1, 'are': 1, 'you': 1} >>> word_counter(\\"This is a test. This test is only a test.\\") {'this': 2, 'is': 2, 'a': 2, 'test': 3, 'only': 1} >>> word_counter(\\"...,,,!!!\\") {} >>> word_counter(\\"\\") {}","solution":"import re from collections import defaultdict def word_counter(s): Takes a string \`s\` and returns a dictionary where the keys are the words in the string, and the values are the number of times each word appears. The function is case-insensitive and ignores punctuation. words = re.findall(r'[a-zA-Z]+', s.lower()) word_count = defaultdict(int) for word in words: word_count[word] += 1 return dict(word_count)"},{"question":"def can_dragons_blow_fire_at_each_other(n, dragons): Determines if there are any two dragons that can blow fire at each other simultaneously. :param n: Number of dragons :param dragons: List of tuples containing position and fire distance of each dragon [(p1, f1), ..., (pn, fn)] :return: 'YES' if there are any two dragons that can blow fire at each other, 'NO' otherwise >>> can_dragons_blow_fire_at_each_other(3, [(2, 3), (5, -3), (8, 2)]) 'YES' >>> can_dragons_blow_fire_at_each_other(3, [(1, 2), (4, 1), (10, -5)]) 'NO' >>> can_dragons_blow_fire_at_each_other(2, [(-2, 3), (1, -3)]) 'YES' >>> can_dragons_blow_fire_at_each_other(4, [(0, 5), (7, -6), (8, 2), (20, -15)]) 'NO' >>> can_dragons_blow_fire_at_each_other(4, [(3, 1), (4, -1), (10, 5), (15, -10)]) 'YES' >>> can_dragons_blow_fire_at_each_other(4, [(1, 5), (2, 4), (3, 3), (4, 6)]) 'NO' >>> can_dragons_blow_fire_at_each_other(3, [(10000, 9999), (5000, 4999), (-10000, -8888)]) 'NO'","solution":"def can_dragons_blow_fire_at_each_other(n, dragons): Determines if there are any two dragons that can blow fire at each other simultaneously. :param n: Number of dragons :param dragons: List of tuples containing position and fire distance of each dragon [(p1, f1), ..., (pn, fn)] :return: 'YES' if there are any two dragons that can blow fire at each other, 'NO' otherwise fire_positions = {} for i in range(n): pos, fire_dist = dragons[i] if fire_dist > 0: fire_position = pos + fire_dist else: fire_position = pos + fire_dist if fire_position in fire_positions: if fire_dist > 0 and fire_positions[fire_position][1] < 0: return \\"YES\\" if fire_dist < 0 and fire_positions[fire_position][1] > 0: return \\"YES\\" fire_positions[pos] = (pos, fire_dist) return \\"NO\\""},{"question":"import math from typing import List, Tuple def can_make_elements_equal(n: int, b: List[int]) -> Tuple[str, List[Tuple[int, int]]]: Determine if it's possible to make all elements of the array equal in at most n-1 operations. Args: n (int): Length of the array b (List[int]): Array of positive integers Returns: Tuple[str, List[Tuple[int, int]]]: \\"YES\\" and a list of operations if possible; \\"NO\\" and an empty list otherwise. >>> can_make_elements_equal(3, [6, 12, 15]) (\\"YES\\", [(1, 2), (1, 3), (1, 4)]) >>> can_make_elements_equal(4, [10, 2, 5, 7]) (\\"NO\\", [])","solution":"import math from typing import List, Tuple def can_make_elements_equal(n: int, b: List[int]) -> Tuple[str, List[Tuple[int, int]]]: if n == 2: return \\"YES\\", [(1, 2)] overall_gcd = b[0] for i in range(1, n): overall_gcd = math.gcd(overall_gcd, b[i]) if overall_gcd == 1: break if overall_gcd == 1: return \\"NO\\", [] # If gcd of all numbers > 1, the number of operations would be n - 1 operations = [(1, i + 1) for i in range(1, n)] return \\"YES\\", operations"},{"question":"def max_teams(n: int, k: int, skill_ratings: List[int]) -> int: Calculate the maximum number of teams that can be formed given the skill ratings and the maximum allowed difference in skill ratings. Args: n (int): the number of participants k (int): the maximum allowed difference in skill ratings for a team skill_ratings (List[int]): a list containing the skill ratings of the participants Returns: int: the maximum number of teams that can be formed >>> max_teams(5, 3, [1, 5, 3, 9, 8]) == 2 >>> max_teams(4, 2, [2, 4, 6, 8]) == 2 >>> max_teams(3, 0, [1, 2, 3]) == 0 # No teams since k = 0 >>> max_teams(5, 1, [1, 1, 1, 1, 1]) == 2 # Can form 2 pairs and one leftover >>> max_teams(4, 10, [1, 2, 3, 4]) == 2 # Can pair (1, 2) and (3, 4) >>> max_teams(1, 5, [4]) == 0 # Only one participant, no teams possible >>> max_teams(3, 100, [1000000000, 999999900, 1000000100]) == 1 # One possible pair >>> max_teams(6, 1, [1, 2, 3, 4, 5, 6]) == 3 # Pairs are (1, 2), (3, 4), (5, 6)","solution":"def max_teams(n, k, skill_ratings): skill_ratings.sort() teams = 0 i = 0 while i < n - 1: if skill_ratings[i + 1] - skill_ratings[i] <= k: teams += 1 i += 2 # skip the next participant since they are paired else: i += 1 # try the next participant for pairing return teams"},{"question":"def maxPossibleWeight(prices: List[int], weights: List[int], k: int, B: int) -> int: Returns the maximum possible weight of selected k items within the budget B. >>> maxPossibleWeight([1, 3, 2, 5], [2, 4, 1, 3], 2, 5) 6 >>> maxPossibleWeight([10, 2, 3], [1, 5, 9], 2, 4) -1","solution":"from itertools import combinations def maxPossibleWeight(prices, weights, k, B): Returns the maximum possible weight of selected k items within the budget B. n = len(prices) max_weight = -1 # Generate all combinations of indices of length k for combo in combinations(range(n), k): total_price = sum(prices[i] for i in combo) total_weight = sum(weights[i] for i in combo) if total_price <= B: max_weight = max(max_weight, total_weight) return max_weight"},{"question":"def min_max_sum(n: int, k: int, nums: List[int]) -> Tuple[int, int]: Returns the minimum and maximum possible sums by selecting exactly k integers from the given list of n integers. >>> min_max_sum(5, 3, [1, 3, 5, 7, 9]) (9, 21) >>> min_max_sum(6, 4, [10, 20, 30, 40, 50, 60]) (100, 180)","solution":"def min_max_sum(n, k, nums): Returns the minimum and maximum possible sums by selecting exactly k integers from the given list of n integers. sorted_nums = sorted(nums) min_sum = sum(sorted_nums[:k]) max_sum = sum(sorted_nums[-k:]) return min_sum, max_sum"},{"question":"def most_frequent_items(days_data): Returns the most frequently sold item each day. In case of a tie, returns the lexicographically smallest item. :param days_data: List of tuples, each tuple contains days info (num of items, list of items sold) :return: List of strings - most frequently sold items each day pass # Function to parse input data from text lines def parse_input(input_lines): Parses the input lines to extract information about the number of items sold each day. :param input_lines: List of strings representing the input data :return: List of tuples, each tuple contains days info (num of items, list of items sold) pass # Example unit tests def test_sample_input(): input_lines = [ \\"2\\", \\"5\\", \\"apple banana apple apple banana\\", \\"6\\", \\"apple orange orange banana orange apple\\" ] days_data = parse_input(input_lines) assert most_frequent_items(days_data) == [\\"apple\\", \\"orange\\"] def test_single_item(): input_lines = [ \\"1\\", \\"1\\", \\"apple\\" ] days_data = parse_input(input_lines) assert most_frequent_items(days_data) == [\\"apple\\"] def test_tie_case(): input_lines = [ \\"1\\", \\"4\\", \\"banana apple apple banana\\" ] days_data = parse_input(input_lines) assert most_frequent_items(days_data) == [\\"apple\\"] def test_all_unique_different_items(): input_lines = [ \\"1\\", \\"4\\", \\"apple banana orange pear\\" ] days_data = parse_input(input_lines) assert most_frequent_items(days_data) == [\\"apple\\"] def test_large_input(): input_lines = [ \\"1\\", \\"10\\", \\"a a a b b b b b b b\\" ] days_data = parse_input(input_lines) assert most_frequent_items(days_data) == [\\"b\\"]","solution":"def most_frequent_items(days_data): Returns the most frequently sold item each day. In case of a tie, returns the lexicographically smallest item. :param days_data: List of tuples, each tuple contains days info (num of items, list of items sold) :return: List of strings - most frequently sold items each day result = [] for day_data in days_data: K, items = day_data item_frequency = {} # Count frequency of each item for item in items: if item in item_frequency: item_frequency[item] += 1 else: item_frequency[item] = 1 # Determine the most frequent item most_frequent_item = min(item_frequency, key=lambda x: (-item_frequency[x], x)) result.append(most_frequent_item) return result # Function to parse input data from text lines def parse_input(input_lines): days_data = [] index = 0 D = int(input_lines[index]) index += 1 for _ in range(D): K = int(input_lines[index]) index += 1 items = input_lines[index].split() index += 1 days_data.append((K, items)) return days_data"},{"question":"def count_unique_products(orders: List[str]) -> int: Given a list of orders, each containing space-separated product names, returns the count of unique products across all orders. >>> count_unique_products([\\"apple banana orange\\", \\"banana grape\\", \\"apple orange\\"]) 4 >>> count_unique_products([\\"bread butter\\", \\"milk\\", \\"eggs cheese butter\\", \\"milk cheese\\", \\"butter\\"]) 5","solution":"def count_unique_products(orders): Given a list of orders, each containing space-separated product names, returns the count of unique products across all orders. unique_products = set() for order in orders: products = order.split() for product in products: unique_products.add(product) return len(unique_products)"},{"question":"def max_unique_problems(test_cases): Calculate the maximum number of unique problems that can be assigned such that each participant can solve at least one of them. Args: test_cases (List[List[List[int]]]): List of test cases, where each test case includes a list of participants, and each participant has a list of difficulty levels they can solve. Returns: List[str]: List of results for each test case in the format 'Case #x: y', where x is the test case number and y is the maximum number of unique problems. Examples: >>> max_unique_problems([[[1, 2, 3], [2, 4], [1, 4, 5]]]) ['Case #1: 3'] >>> max_unique_problems([[[1, 2, 3], [2, 4], [1, 4, 5]], [[8, 9, 10], [7, 8, 9]]]) ['Case #1: 3', 'Case #2: 2'] >>> max_unique_problems([[[1, 2], [3, 4], [5, 6]]]) ['Case #1: 3'] >>> max_unique_problems([[[1], [1], [1]]]) ['Case #1: 1'] >>> max_unique_problems([[range(1, 1001)] * 100]) ['Case #1: 100']","solution":"def max_unique_problems(test_cases): results = [] for case_num, participants in enumerate(test_cases, 1): all_problems = set() for participant in participants: all_problems.update(participant) # To maximize, we need to ensure each participant can solve at least one problem # This means we need at least N unique problems for N participants # Using a set takes care of duplicates automatically unique_problems = len(all_problems) required_problems = len(participants) # The answer for each test case would be the max of unique problems but ensuring each participant can solve one max_unique = min(unique_problems, required_problems) results.append(f\\"Case #{case_num}: {max_unique}\\") return results # Example setup input_data = [ [[1, 2, 3], [2, 4], [1, 4, 5]], # Test case 1 [[8, 9, 10], [7, 8, 9]] # Test case 2 ] print(max_unique_problems(input_data))"},{"question":"def count_sheep(field: str) -> int: Returns the number of sheep in the field. Each sheep is represented by 'x' in the string. >>> count_sheep(\\"......\\") == 0 >>> count_sheep(\\"...x..x.\\") == 2 >>> count_sheep(\\"x.xx.x..x\\") == 5 >>> count_sheep(\\"\\") == 0 >>> count_sheep(\\"xxxxx\\") == 5 >>> count_sheep(\\"......\\") == 0 >>> count_sheep(\\"x.x.x.x.x\\") == 5 >>> count_sheep(\\"x..x..x..x\\") == 4 >>> count_sheep(\\".x.x.x.x.\\") == 4","solution":"def count_sheep(field): Returns the number of sheep in the field. Each sheep is represented by 'x' in the string. return field.count('x')"},{"question":"from typing import List, Tuple def labyrinth_solver(input_str: str) -> List[int]: Determine the optimal path for maximizing collected treasures while minimizing health loss in a labyrinth. Args: input_str (str): The input string containing the number of chambers, initial health, chambers' details, and connections. Returns: List[int]: A list of chamber numbers representing the optimal path starting from Chamber 1. >>> labyrinth_solver(\\"5 1000n1 10 0n2 20 5n3 30 10n4 40 15n5 50 20n1 2 200n2 3 150n2 4 300n2 5 500n3 4 100n4 5 250\\") [1, 2, 3, 4, 5] >>> labyrinth_solver(\\"4 1000n1 10 0n2 20 5n3 30 10n4 40 15n1 2 200n2 3 150n3 4 100n2 4 300\\") [1, 2, 3, 4] >>> labyrinth_solver(\\"2 500n1 10 0n2 50 5n1 2 50\\") [1, 2] >>> labyrinth_solver(\\"3 500n1 10 0n2 20 5n3 30 10n1 2 400n2 3 300n1 3 200\\") [1, 3] # Define the helper functions and necessary logic to solve the problem","solution":"import heapq def optimal_path(n, h, chambers_info, connections): # Parse inputs treasures = {chamber: treasures for chamber, treasures, _ in chambers_info} traps = {chamber: traps for chamber, _, traps in chambers_info} adj = {i: [] for i in range(1, n + 1)} for a, b, c in connections: adj[a].append((b, c)) # Priority queue with initial state (negative treasure sum, remaining health, current chamber, path) pq = [(-treasures[1], h, 1, [1])] max_treasure = -1 best_path = [] # Dijkstra-like with a priority queue while pq: current_treasure, current_health, current_chamber, path = heapq.heappop(pq) current_treasure = -current_treasure if current_health < 0: continue if current_chamber == n: if current_treasure > max_treasure or (current_treasure == max_treasure and current_health > h): max_treasure = current_treasure best_path = path h = current_health continue for neighbor, difficulty in adj[current_chamber]: new_health = current_health - difficulty - traps[neighbor] new_treasure = current_treasure + treasures[neighbor] heapq.heappush(pq, (-new_treasure, new_health, neighbor, path + [neighbor])) return best_path def parse_input(input_str): data = input_str.strip().split('n') n, h = map(int, data[0].split()) chambers_info = [tuple(map(int, line.split())) for line in data[1:n+1]] connections = [tuple(map(int, line.split())) for line in data[n+1:]] return n, h, chambers_info, connections def labyrinth_solver(input_str): n, h, chambers_info, connections = parse_input(input_str) return optimal_path(n, h, chambers_info, connections)"},{"question":"def max_subarray_product(test_cases): Find the largest product of any contiguous subarray within a given array of integers for multiple test cases. Args: test_cases (List[Tuple[int, List[int]]]): List of tuples where each tuple contains the number of elements in the array and the array itself. Returns: List[int]: A list containing the largest product of any contiguous subarray for each test case. Examples: >>> max_subarray_product([(4, [2, 3, -2, 4])]) [6] >>> max_subarray_product([(5, [-2, -3, 4, -1, -2])]) [48] >>> max_subarray_product([(3, [-2, -3, -1])]) [6]","solution":"def max_subarray_product(test_cases): results = [] for case in test_cases: N, A = case if N == 1: results.append(A[0]) continue max_product = float('-inf') min_product = float('inf') current_max = 1 current_min = 1 for num in A: if num == 0: current_max = 1 current_min = 1 continue temp = current_max * num current_max = max(num, temp, current_min * num) current_min = min(num, temp, current_min * num) max_product = max(max_product, current_max) results.append(max_product) return results # Example usage: # test_cases = [ # (4, [2, 3, -2, 4]), # (5, [-2, -3, 4, -1, -2]), # (3, [-2, -3, -1]) # ] # print(max_subarray_product(test_cases)) # Output: [6, 48, 6]"},{"question":"class Node: def __init__(self, x): self.val = x self.left = None self.right = None self.random = None def cloneTree(root): Given a special Binary Tree where every node has an extra pointer \`random\` pointing to any random node in the tree, write a function to clone this tree. The function takes the root of the special Binary Tree as its input and returns the root of the cloned tree. pass","solution":"class Node: def __init__(self, x): self.val = x self.left = None self.right = None self.random = None def cloneTree(root): if not root: return None # Dictionary to keep track of all newly created nodes node_map = {} # First pass: clone all nodes and populate the node_map def clone_nodes(node): if not node: return None if node in node_map: return node_map[node] cloned_node = Node(node.val) node_map[node] = cloned_node cloned_node.left = clone_nodes(node.left) cloned_node.right = clone_nodes(node.right) return cloned_node # Do the actual node cloning clone_root = clone_nodes(root) # Second pass: set the random pointers def set_random_pointers(node): if not node: return if node.random: node_map[node].random = node_map[node.random] set_random_pointers(node.left) set_random_pointers(node.right) # Set the random pointers in the newly cloned tree set_random_pointers(root) return clone_root"},{"question":"def processTransactions(transactions: List[str]) -> dict: Processes a list of transactions and returns a summary of user spending and product count. Args: transactions: A list of strings, where each string represents a transaction in the format \\"userID,productID,amount\\". Returns: A dictionary with two keys \\"userSpending\\" and \\"productCount\\": - \\"userSpending\\" maps each userID to the total amount spent by that user. - \\"productCount\\" maps each productID to the count of how many times it was purchased. >>> processTransactions([\\"u1,p1,100\\", \\"u2,p2,200\\", \\"u1,p1,150\\", \\"u3,p2,50\\", \\"u1,p3,300\\"]) { \\"userSpending\\": {\\"u1\\": 550, \\"u2\\": 200, \\"u3\\": 50}, \\"productCount\\": {\\"p1\\": 2, \\"p2\\": 2, \\"p3\\": 1} } >>> processTransactions([\\"u1,p1,100\\"]) { \\"userSpending\\": {\\"u1\\": 100}, \\"productCount\\": {\\"p1\\": 1} } >>> processTransactions([\\"u1,p1,100\\", \\"u2,p1,200\\"]) { \\"userSpending\\": {\\"u1\\": 100, \\"u2\\": 200}, \\"productCount\\": {\\"p1\\": 2} } >>> processTransactions([]) { \\"userSpending\\": {}, \\"productCount\\": {} } >>> processTransactions([\\"u1,p1,100\\", \\"u1,p2,200\\"]) { \\"userSpending\\": {\\"u1\\": 300}, \\"productCount\\": {\\"p1\\": 1, \\"p2\\": 1} }","solution":"def processTransactions(transactions): userSpending = {} productCount = {} for transaction in transactions: userID, productID, amount = transaction.split(',') amount = int(amount) if userID in userSpending: userSpending[userID] += amount else: userSpending[userID] = amount if productID in productCount: productCount[productID] += 1 else: productCount[productID] = 1 return { \\"userSpending\\": userSpending, \\"productCount\\": productCount }"},{"question":"from collections import defaultdict, deque from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def verticalOrder(root: Optional[TreeNode]) -> List[List[int]]: Given a binary tree, return the vertical order traversal of its nodes' values. >>> root = TreeNode(3) >>> root.left = TreeNode(9) >>> root.right = TreeNode(20) >>> root.right.left = TreeNode(15) >>> root.right.right = TreeNode(7) >>> verticalOrder(root) [[9], [3, 15], [20], [7]] >>> root = TreeNode(1) >>> verticalOrder(root) [[1]] >>> verticalOrder(None) [] >>> root = TreeNode(1) >>> root.right = TreeNode(2) >>> root.right.right = TreeNode(3) >>> verticalOrder(root) [[1], [2], [3]] >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.left.left = TreeNode(3) >>> verticalOrder(root) [[3], [2], [1]] >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> root.right.left = TreeNode(6) >>> root.right.right = TreeNode(7) >>> verticalOrder(root) [[4], [2], [1, 5, 6], [3], [7]]","solution":"from collections import defaultdict, deque from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def verticalOrder(root: Optional[TreeNode]) -> List[List[int]]: if not root: return [] column_table = defaultdict(list) queue = deque([(root, 0)]) while queue: node, column = queue.popleft() if node is not None: column_table[column].append(node.val) queue.append((node.left, column - 1)) queue.append((node.right, column + 1)) sorted_columns = sorted(column_table.keys()) return [column_table[column] for column in sorted_columns]"},{"question":"def min_ids_to_insert(ids): Determine the minimum number of IDs that need to be inserted to ensure the sequence is consecutive from the smallest to the largest ID. Args: ids (List[int]): an array of integers representing the IDs assigned to the participants. Returns: int: the minimum number of IDs that need to be inserted. Examples: >>> min_ids_to_insert([3, 7, 1, 4]) 3 >>> min_ids_to_insert([1, 2, 3, 4, 5]) 0 >>> min_ids_to_insert([10, 14, 12]) 2","solution":"def min_ids_to_insert(ids): if not ids: return 0 sorted_ids = sorted(ids) min_id = sorted_ids[0] max_id = sorted_ids[-1] expected_count = max_id - min_id + 1 actual_count = len(sorted_ids) return expected_count - actual_count"},{"question":"def min_platforms(arrival_times): Determines the minimum number of platforms required for the trains to ensure that no two trains are at the platform at the same time. >>> min_platforms([1, 2, 3, 4, 5]) == 1 >>> min_platforms([1, 2, 2, 2, 2]) == 4 >>> min_platforms([1, 3, 5, 2, 6, 8]) == 1 >>> min_platforms([5]) == 1 >>> min_platforms([]) == 0 >>> min_platforms([5, 5, 5, 5, 5]) == 5 >>> min_platforms([2, 1, 3, 2, 4, 3]) == 2","solution":"def min_platforms(arrival_times): Determines the minimum number of platforms required for the trains to ensure that no two trains are at the platform at the same time. arrival_times.sort() max_platforms_needed = 0 current_platforms = 0 for i in range(len(arrival_times)): if i == 0 or arrival_times[i] != arrival_times[i - 1]: current_platforms = 1 else: current_platforms += 1 max_platforms_needed = max(max_platforms_needed, current_platforms) return max_platforms_needed"},{"question":"def filter_words(words: List[str], char: str) -> List[str]: Returns a list of words that contain the given character. The search is case-insensitive, but the returned words maintain their original order and case. Args: words (List[str]): A list of words. char (str): A single character to search for in words. Returns: List[str]: A list of words containing the given character. >>> filter_words([\\"Apple\\", \\"banana\\", \\"Cherry\\", \\"date\\", \\"Elderberry\\"], \\"a\\") ['Apple', 'banana', 'date'] >>> filter_words([\\"Zebra\\", \\"yak\\", \\"Xenon\\", \\"Wasp\\"], \\"z\\") ['Zebra']","solution":"def filter_words(words, char): Returns a list of words that contain the given character. The search is case-insensitive, but the returned words maintain their original order and case. Args: words (list of str): A list of words. char (str): A single character to search for in words. Returns: list of str: A list of words containing the given character. char_lower = char.lower() return [word for word in words if char_lower in word.lower()]"},{"question":"library = [ {'title': \\"To Kill a Mockingbird\\", 'author': \\"Harper Lee\\"}, {'title': \\"1984\\", 'author': \\"George Orwell\\"}, {'title': \\"The Great Gatsby\\", 'author': \\"F. Scott Fitzgerald\\"}, {'title': \\"The Catcher in the Rye\\", 'author': \\"J.D. Salinger\\"}] def find_author_by_title(title: str) -> str: Search for books by their title and return the corresponding author of the book. If the book is not found, return \\"Book not found\\". >>> find_author_by_title(\\"To Kill a Mockingbird\\") \\"Harper Lee\\" >>> find_author_by_title(\\"The Great Gatsby\\") \\"Book not found\\"","solution":"library = [ {'title': \\"To Kill a Mockingbird\\", 'author': \\"Harper Lee\\"}, {'title': \\"1984\\", 'author': \\"George Orwell\\"}, {'title': \\"The Great Gatsby\\", 'author': \\"F. Scott Fitzgerald\\"}, {'title': \\"The Catcher in the Rye\\", 'author': \\"J.D. Salinger\\"}] def find_author_by_title(title: str) -> str: for book in library: if book['title'] == title: return book['author'] return \\"Book not found\\""},{"question":"from typing import List def right_circular_rotate(arr: List[int], k: int) -> List[int]: Perform k right circular rotations on the array arr. >>> right_circular_rotate([1, 2, 3, 4, 5], 2) [4, 5, 1, 2, 3] >>> right_circular_rotate([1, 2, 3], 3) [1, 2, 3] >>> right_circular_rotate([], 5) []","solution":"from typing import List def right_circular_rotate(arr: List[int], k: int) -> List[int]: Perform k right circular rotations on the array arr. if not arr: return arr n = len(arr) k = k % n # In case k is greater than the length of the array return arr[-k:] + arr[:-k]"},{"question":"def gcd(m: int, n: int) -> int: Returns the greatest common divisor (GCD) of m and n. >>> gcd(12, 15) == 3 >>> gcd(48, 18) == 6 >>> gcd(100, 25) == 25 >>> gcd(1, 50) == 1 >>> gcd(50, 25) == 25","solution":"def gcd(m, n): Returns the greatest common divisor (GCD) of m and n. while n: m, n = n, m % n return m"},{"question":"def unique_flower_types(n: int, k: int, garden: List[List[int]], queries: List[Tuple[int, int, int, int]]) -> List[int]: Determine the number of unique flower types present within certain subgrids of the garden. Args: n: The size of the garden grid (n x n). k: The number of distinct flower types. garden: 2D array representing the garden grid where each value indicates the type of flower. queries: A list of queries, each specifying the top-left and bottom-right coordinates of a subgrid. Returns: A list of integers, where each integer represents the number of unique flower types in the specified subgrid. Example: >>> n = 5 >>> k = 3 >>> garden = [ ... [1, 2, 1, 3, 2], ... [3, 3, 2, 1, 1], ... [1, 2, 3, 2, 3], ... [3, 1, 1, 2, 2], ... [2, 3, 2, 2, 1] ... ] >>> queries = [ ... (1, 1, 3, 3), ... (2, 2, 5, 5), ... (1, 2, 4, 4) ... ] >>> unique_flower_types(n, k, garden, queries) [3, 3, 3]","solution":"def unique_flower_types(n, k, garden, queries): results = [] for query in queries: x1, y1, x2, y2 = query flower_set = set() for i in range(x1-1, x2): for j in range(y1-1, y2): flower_set.add(garden[i][j]) results.append(len(flower_set)) return results"},{"question":"def longest_palindromic_subsequence(s: str) -> int: Returns the length of the longest palindromic subsequence in the given string. >>> longest_palindromic_subsequence(\\"character\\") 5 >>> longest_palindromic_subsequence(\\"racecar\\") 7 def find_longest_palindromic_subsequences(test_cases: List[str]) -> List[int]: For each test case, returns the length of the longest palindromic subsequence in the respective string. >>> find_longest_palindromic_subsequences([\\"character\\", \\"racecar\\"]) [5, 7] >>> find_longest_palindromic_subsequences([\\"a\\", \\"aaaa\\"]) [1, 4]","solution":"def longest_palindromic_subsequence(s): Returns the length of the longest palindromic subsequence in the given string. n = len(s) dp = [[0 for _ in range(n)] for _ in range(n)] # Base case: a single character is a palindrome of length 1 for i in range(n): dp[i][i] = 1 # Build the table for cl in range(2, n+1): for i in range(n - cl + 1): j = i + cl - 1 if s[i] == s[j] and cl == 2: dp[i][j] = 2 elif s[i] == s[j]: dp[i][j] = dp[i+1][j-1] + 2 else: dp[i][j] = max(dp[i][j-1], dp[i+1][j]) return dp[0][n-1] def find_longest_palindromic_subsequences(test_cases): results = [] for s in test_cases: results.append(longest_palindromic_subsequence(s)) return results"},{"question":"def minOperations(N: int, k: int) -> int: Returns the minimum number of operations to remove all stones from the pile. Parameters: N (int): the number of stones in the pile, must be non-negative. k (int): the maximum number of stones that can be removed in one operation, must be at least 1. Returns: int: the minimum number of operations required to remove all stones. >>> minOperations(10, 3) 4 >>> minOperations(15, 5) 3 >>> minOperations(0, 3) 0 >>> minOperations(1, 3) 1 >>> minOperations(10, 10) 1 >>> minOperations(10, 1) 10","solution":"def minOperations(N, k): Returns the minimum number of operations to remove all stones from the pile. Parameters: N (int): the number of stones in the pile, must be non-negative. k (int): the maximum number of stones that can be removed in one operation, must be at least 1. Returns: int: the minimum number of operations required to remove all stones. if N == 0: return 0 return (N + k - 1) // k"},{"question":"def combinationSum(nums: List[int], target: int) -> List[List[int]]: Find all unique combinations of numbers from the list that sum up to the target number. Each number from the list may be used multiple times in the combination. >>> combinationSum([2, 3, 6, 7], 7) [[2, 2, 3], [7]] >>> combinationSum([2, 3, 5], 8) [[2, 2, 2, 2], [2, 3, 3], [3, 5]] >>> combinationSum([7], 7) [[7]] >>> combinationSum([2, 4], 7) [] >>> combinationSum([1, 2], 4) [[1, 1, 1, 1], [1, 1, 2], [2, 2]]","solution":"def combinationSum(nums, target): def backtrack(start, target, path, result): if target == 0: result.append(path) return if target < 0: return for i in range(start, len(nums)): backtrack(i, target - nums[i], path + [nums[i]], result) result = [] nums.sort() backtrack(0, target, [], result) return result"},{"question":"def can_form_palindrome(s: str) -> bool: Determines if the input string can be rearranged to form a palindrome. :param s: a string containing only lowercase alphabetical characters. :returns: a boolean value indicating whether it is possible to rearrange the characters to form a palindrome. >>> can_form_palindrome(\\"carrace\\") True >>> can_form_palindrome(\\"hello\\") False >>> can_form_palindrome(\\"a\\") True >>> can_form_palindrome(\\"aabb\\") True >>> can_form_palindrome(\\"abcd\\") False >>> can_form_palindrome(\\"\\") True","solution":"def can_form_palindrome(s): Determines if the input string can be rearranged to form a palindrome. :param s: a string containing only lowercase alphabetical characters. :returns: a boolean value indicating whether it is possible to rearrange the characters to form a palindrome. from collections import Counter # Count the frequency of each character in the string char_counts = Counter(s) # Check the number of characters that have an odd frequency odd_count = sum(1 for count in char_counts.values() if count % 2 != 0) # A string can be rearranged into a palindrome if it has at most one character with an odd frequency return odd_count <= 1"},{"question":"def product_array(a): Given an integer array \`a\`, returns an array \`b\` where each element \`b[i]\` is the product of all elements of \`a\` except \`a[i]\`, solved without using division and in O(n) time complexity. >>> product_array([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_array([5, 6, 7]) [42, 35, 30] >>> product_array([10, 3, 5, 6, 2]) [180, 600, 360, 300, 900] >>> product_array([8, 4]) [4, 8] >>> product_array([100, 10, 1]) [10, 100, 1000] pass","solution":"def product_array(a): Given an integer array a, returns an array b where each element b[i] is the product of all elements of a except a[i]. n = len(a) if n == 1: return [0] # Initialize arrays for left and right products left_products = [0] * n right_products = [0] * n b = [0] * n # Calculate left products left_products[0] = 1 for i in range(1, n): left_products[i] = left_products[i - 1] * a[i - 1] # Calculate right products right_products[n - 1] = 1 for i in range(n - 2, -1, -1): right_products[i] = right_products[i + 1] * a[i + 1] # Calculate result array for i in range(n): b[i] = left_products[i] * right_products[i] return b"},{"question":"def sum_of_digits(input_number): Calculates the sum of digits of a given non-negative integer. If resultant sum is a multiple of 3, returns \\"Fizz\\". If resultant sum is a multiple of 5, returns \\"Buzz\\". If resultant sum is a multiple of both 3 and 5, returns \\"FizzBuzz\\". Otherwise, returns the resultant sum. >>> sum_of_digits(12345) == \\"FizzBuzz\\" >>> sum_of_digits(456) == \\"FizzBuzz\\" >>> sum_of_digits(111) == \\"Fizz\\" >>> sum_of_digits(50) == \\"Buzz\\" >>> sum_of_digits(29) == 11 >>> sum_of_digits(0) == \\"FizzBuzz\\" >>> sum_of_digits(98765) == \\"Buzz\\"","solution":"def sum_of_digits(input_number): Calculates the sum of digits of a given non-negative integer. If resultant sum is a multiple of 3, returns \\"Fizz\\". If resultant sum is a multiple of 5, returns \\"Buzz\\". If resultant sum is a multiple of both 3 and 5, returns \\"FizzBuzz\\". Otherwise, returns the resultant sum. # Calculate the sum of the digits digit_sum = sum(int(digit) for digit in str(input_number)) # Determine the appropriate return value if digit_sum % 3 == 0 and digit_sum % 5 == 0: return \\"FizzBuzz\\" elif digit_sum % 3 == 0: return \\"Fizz\\" elif digit_sum % 5 == 0: return \\"Buzz\\" else: return digit_sum"},{"question":"def find_tree_diameter(N: int, edges: List[Tuple[int, int]]) -> int: Find the diameter of a tree. A tree is an undirected graph in which any two vertices are connected by exactly one path. The diameter of a tree is the length of the longest path between any two vertices in the tree. Args: N (int): The number of vertices in the tree. edges (List[Tuple[int, int]]): A list of edges where each edge is represented by a tuple of two integers. Returns: int: The diameter of the tree. Examples: >>> find_tree_diameter(5, [(1, 2), (2, 3), (3, 4), (4, 5)]) 4 >>> find_tree_diameter(1, []) 0 >>> find_tree_diameter(2, [(1, 2)]) 1","solution":"def find_tree_diameter(N, edges): from collections import deque, defaultdict def bfs(start): visited = [-1] * (N + 1) q = deque([start]) visited[start] = 0 farthest_node = start max_distance = 0 while q: node = q.popleft() for neighbor in graph[node]: if visited[neighbor] == -1: visited[neighbor] = visited[node] + 1 q.append(neighbor) if visited[neighbor] > max_distance: max_distance = visited[neighbor] farthest_node = neighbor return farthest_node, max_distance if N == 1: return 0 graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) farthest_node_from_start, _ = bfs(1) _, diameter = bfs(farthest_node_from_start) return diameter"},{"question":"def findTargetSumIndices(nums, target): Returns the indices i and j such that nums[i] + nums[j] = target. If no such indices exist, returns [-1, -1]. :param nums: List[int] - A sorted array of distinct integers :param target: int - The target sum :return: List[int] - A list containing the indices [i, j] Examples: >>> findTargetSumIndices([2, 7, 11, 15], 9) [0, 1] >>> findTargetSumIndices([1, 2, 3, 4, 5, 6, 7], 13) [5, 6] >>> findTargetSumIndices([-10, -3, 0, 1, 2], -2) [1, 3] >>> findTargetSumIndices([1, 2, 3, 4, 5], 10) [-1, -1]","solution":"def findTargetSumIndices(nums, target): Returns the indices i and j such that nums[i] + nums[j] = target. If no such indices exist, returns [-1, -1]. :param nums: List[int] - A sorted array of distinct integers :param target: int - The target sum :return: List[int] - A list containing the indices [i, j] left, right = 0, len(nums) - 1 while left < right: curr_sum = nums[left] + nums[right] if curr_sum == target: return [left, right] elif curr_sum < target: left += 1 else: right -= 1 return [-1, -1]"},{"question":"def find_smallest_abs_diff_pair(n: int, arr: List[int]) -> Tuple[int, int]: Finds the first two distinct integers with the smallest absolute difference between them. Args: n (int): the number of integers arr (list): the list of integers Returns: tuple: the pair of integers with the smallest absolute difference (in the order they appear) Examples: >>> find_smallest_abs_diff_pair(5, [3, 8, 15, 2, 5]) (3, 2) >>> find_smallest_abs_diff_pair(4, [14, 23, 17, 10]) (14, 17) >>> find_smallest_abs_diff_pair(6, [1, 6, 10, 15, 13, 9]) (10, 9)","solution":"def find_smallest_abs_diff_pair(n, arr): Function to find the first two distinct integers with the smallest absolute difference between them in a given list. Args: n (int): the number of integers arr (list): the list of integers Returns: tuple: the pair of integers with the smallest absolute difference (in the order they appear) min_diff = float('inf') min_pair = None for i in range(n): for j in range(i + 1, n): diff = abs(arr[i] - arr[j]) if diff < min_diff: min_diff = diff min_pair = (arr[i], arr[j]) return min_pair"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def build_tree(preorder): Build a binary search tree from a preorder traversal list. def helper(preorder_iter): val = next(preorder_iter) if val == \\"null\\": return None node = TreeNode(int(val)) node.left = helper(preorder_iter) node.right = helper(preorder_iter) return node return helper(iter(preorder)) def kth_smallest(root, k): Find the kth smallest element in the binary search tree. def inorder_traverse(node): if not node: return [] return inorder_traverse(node.left) + [node.val] + inorder_traverse(node.right) inorder = inorder_traverse(root) return inorder[k-1] def find_kth_smallest(test_cases): Given test cases containing (k, preorder_str), find the kth smallest element in the BST. results = [] for k, preorder_str in test_cases: preorder = preorder_str.split() root = build_tree(preorder) results.append(kth_smallest(root, k)) return results # Test cases to validate the solution test_cases = [ (3, \\"5 3 2 null null 4 null null 8 7 null null 9 null null\\"), (2, \\"3 1 null null 4 null null\\"), ] assert find_kth_smallest(test_cases) == [4, 3]","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def build_tree(preorder): Build a binary search tree from a preorder traversal list. def helper(preorder_iter): val = next(preorder_iter) if val == \\"null\\": return None node = TreeNode(int(val)) node.left = helper(preorder_iter) node.right = helper(preorder_iter) return node return helper(iter(preorder)) def kth_smallest(root, k): Find the kth smallest element in the binary search tree. def inorder_traverse(node): if not node: return [] return inorder_traverse(node.left) + [node.val] + inorder_traverse(node.right) inorder = inorder_traverse(root) return inorder[k-1] def find_kth_smallest(test_cases): results = [] for k, preorder_str in test_cases: preorder = preorder_str.split() root = build_tree(preorder) results.append(kth_smallest(root, k)) return results"},{"question":"class MinStack: def __init__(self): Initialize the data structure. pass def push(self, x: int) -> None: Push element x onto stack. pass def pop(self) -> None: Removes the element on top of the stack. pass def top(self) -> int: Get the top element. pass def getMin(self) -> int: Retrieve the minimum element in the stack. pass # Unit Tests def test_push_pop_top_getMin(): minStack = MinStack() minStack.push(-2) minStack.push(0) minStack.push(-3) assert minStack.getMin() == -3 # Returns -3 minStack.pop() assert minStack.top() == 0 # Returns 0 assert minStack.getMin() == -2 # Returns -2 def test_sequential_operations(): minStack = MinStack() minStack.push(1) assert minStack.getMin() == 1 # Returns 1 minStack.push(2) assert minStack.getMin() == 1 # Returns 1 minStack.pop() assert minStack.getMin() == 1 # Returns 1 def test_all_elements_same(): minStack = MinStack() minStack.push(5) minStack.push(5) minStack.push(5) assert minStack.getMin() == 5 # Returns 5 minStack.pop() assert minStack.getMin() == 5 # Returns 5 minStack.pop() assert minStack.getMin() == 5 # Returns 5 minStack.pop() def test_empty_stack_operations(): minStack = MinStack() assert minStack.top() is None # Returns None assert minStack.getMin() is None # Returns None minStack.pop() # Should not throw error","solution":"class MinStack: def __init__(self): Initialize the data structure. self.stack = [] self.min_stack = [] def push(self, x: int) -> None: Push element x onto stack. self.stack.append(x) if not self.min_stack or x <= self.min_stack[-1]: self.min_stack.append(x) def pop(self) -> None: Removes the element on top of the stack. if self.stack: top_element = self.stack.pop() if top_element == self.min_stack[-1]: self.min_stack.pop() def top(self) -> int: Get the top element. if self.stack: return self.stack[-1] def getMin(self) -> int: Retrieve the minimum element in the stack. if self.min_stack: return self.min_stack[-1]"},{"question":"def list_of_numbers_to_words(lst: List[int]) -> List[str]: Convert a list of integers to a list of their English words representation. Args: lst: List of integers (0 <= number < 100) Returns: List of strings representing each integer in words. Examples: >>> list_of_numbers_to_words([0, 5, 13, 22, 45]) [\\"zero\\", \\"five\\", \\"thirteen\\", \\"twenty two\\", \\"forty five\\"] >>> list_of_numbers_to_words([7, 19, 30, 55, 99]) [\\"seven\\", \\"nineteen\\", \\"thirty\\", \\"fifty five\\", \\"ninety nine\\"] >>> list_of_numbers_to_words([2, 10, 21, 47, 88]) [\\"two\\", \\"ten\\", \\"twenty one\\", \\"forty seven\\", \\"eighty eight\\"] >>> list_of_numbers_to_words([6, 14, 23, 31, 56]) [\\"six\\", \\"fourteen\\", \\"twenty three\\", \\"thirty one\\", \\"fifty six\\"]","solution":"def number_to_words(number): Convert a number less than 100 to its English words representation. if 0 <= number <= 19: return [\\"zero\\", \\"one\\", \\"two\\", \\"three\\", \\"four\\", \\"five\\", \\"six\\", \\"seven\\", \\"eight\\", \\"nine\\", \\"ten\\", \\"eleven\\", \\"twelve\\", \\"thirteen\\", \\"fourteen\\", \\"fifteen\\", \\"sixteen\\", \\"seventeen\\", \\"eighteen\\", \\"nineteen\\"][number] elif 20 <= number <= 99: tens = [\\"\\", \\"\\", \\"twenty\\", \\"thirty\\", \\"forty\\", \\"fifty\\", \\"sixty\\", \\"seventy\\", \\"eighty\\", \\"ninety\\"] return tens[number // 10] + ('' if number % 10 == 0 else ' ' + number_to_words(number % 10)) def list_of_numbers_to_words(lst): Convert a list of integers to a list of their English words representation. return [number_to_words(num) for num in lst]"},{"question":"def most_frequent_word(paragraph: str) -> str: Find the most frequently occurring word in a paragraph of text. If there are multiple words with the highest frequency, return the lexicographically smallest one. >>> most_frequent_word(\\"this is a test this is only a test\\") 'a' >>> most_frequent_word(\\"another test case with some words with some meaning\\") 'some' >>> most_frequent_word(\\"hello hello world world hello\\") 'hello' # Your code here def solve(T: int, paragraphs: List[str]) -> List[str]: Given a number of test cases and a list of paragraphs, return a list of most frequently occurring words in each paragraph. Args: T : int : Number of test cases paragraphs : List[str] : List of paragraphs Returns: List[str] : List of most frequent words for each paragraph >>> solve(3, [\\"this is a test this is only a test\\", \\"another test case with some words with some meaning\\", \\"hello hello world world hello\\"]) ['a', 'some', 'hello'] # Your code here","solution":"def most_frequent_word(paragraph): words = paragraph.split() frequency = {} for word in words: if word in frequency: frequency[word] += 1 else: frequency[word] = 1 max_freq = max(frequency.values()) most_frequent_words = [word for word, freq in frequency.items() if freq == max_freq] return min(most_frequent_words) def solve(T, paragraphs): results = [] for paragraph in paragraphs: results.append(most_frequent_word(paragraph)) return results"},{"question":"def sort_segments(arr: List[int]) -> List[int]: Sorts each segment of an array separated by zeros in non-decreasing order. The zeros themselves should remain in their original positions. Examples: >>> sort_segments([5, 3, 0, 2, 4, 1, 0, -1, -3]) [3, 5, 0, 1, 2, 4, 0, -3, -1] >>> sort_segments([0, 12, 10, 0, 0, 25, 15, -5, 30, 0]) [0, 10, 12, 0, 0, -5, 15, 25, 30, 0] >>> sort_segments([3, 1, 2]) [1, 2, 3] >>> sort_segments([0, 0, 0]) [0, 0, 0]","solution":"def sort_segments(arr): Sorts each segment of the array separated by zeroes in non-decreasing order. The zeroes remain in their original positions. n = len(arr) result = [] segment = [] for i in range(n): if arr[i] == 0: if segment: result.extend(sorted(segment)) segment = [] result.append(0) else: segment.append(arr[i]) if segment: result.extend(sorted(segment)) return result"},{"question":"def min_window(S: str, T: str) -> str: Given a string S and a string T, returns the minimum window in S which will contain all the characters in T. If there is no such window in S that covers all characters in T, return the empty string \\"\\". >>> min_window(\\"ADOBECODEBANC\\", \\"ABC\\") \\"BANC\\" >>> min_window(\\"a\\", \\"a\\") \\"a\\"","solution":"from collections import Counter, defaultdict def min_window(S, T): Returns the minimum window in S which contains all the characters in T. Parameters: S (str): The source string in which to find the window. T (str): The target string containing characters to be matched. Returns: str: The minimum window in S which contains all characters in T, or an empty string if no such window exists. if not S or not T: return \\"\\" dict_t = Counter(T) required = len(dict_t) l, r = 0, 0 formed = 0 window_counts = defaultdict(int) ans = float('inf'), None, None while r < len(S): character = S[r] window_counts[character] += 1 if character in dict_t and window_counts[character] == dict_t[character]: formed += 1 while l <= r and formed == required: character = S[l] if r - l + 1 < ans[0]: ans = (r - l + 1, l, r) window_counts[character] -= 1 if character in dict_t and window_counts[character] < dict_t[character]: formed -= 1 l += 1 r += 1 return \\"\\" if ans[0] == float('inf') else S[ans[1]: ans[2] + 1]"},{"question":"def smallest_lexicographical_rotation(s: str) -> str: Returns the smallest lexicographical rotation of the given string s. >>> smallest_lexicographical_rotation(\\"bcdea\\") == \\"abcde\\" >>> smallest_lexicographical_rotation(\\"cab\\") == \\"abc\\"","solution":"def smallest_lexicographical_rotation(s): Returns the smallest lexicographical rotation of the given string s. # Concatenate the string with itself to handle rotations s = s + s n = len(s) // 2 # Initialize the smallest rotation min_rotation = s[:n] # Iterate through all possible rotations for i in range(1, n): rotation = s[i:i+n] if rotation < min_rotation: min_rotation = rotation return min_rotation"},{"question":"def count_triangle_ways(N: int, points: list[int]) -> int: Determine the number of ways to draw 3 distinct points from an array of N integers such that they form a triangle with positive area. Arguments: N : int : number of points points : list[int] : list of integer coordinates of points on the x-axis Returns: int : Number of ways to choose 3 points that form a triangle with positive area. >>> count_triangle_ways(5, [1, 2, 3, 4, 5]) 10 >>> count_triangle_ways(3, [1, 2, 3]) 1 >>> count_triangle_ways(1000, list(range(1, 1001))) 166167000 >>> count_triangle_ways(4, [4, 3, 2, 1]) 4 >>> count_triangle_ways(4, [1, 1, 1, 1]) 4","solution":"def count_triangle_ways(N, points): Determine the number of ways to draw 3 distinct points from an array of N integers such that they form a triangle with positive area. Arguments: N : int : number of points points : list[int] : list of integer coordinates of points on the x-axis Returns: int : Number of ways to choose 3 points that form a triangle with positive area. # Sorting the points first points.sort() # Any 3 distinct points on a line with sorted coordinates will always form a triangle with positive area. # Using combination formula C(N, 3) = N * (N-1) * (N-2) / 6 from math import comb return comb(N, 3)"},{"question":"class Node: def __init__(self, data, next=None): self.data = data self.next = next def flip(head: Node) -> Node: Create a function that accepts a linked list and returns a new list that is the reverse of the original list. >>> linked_list_to_list(flip(Node(1, Node(2, Node(3))))) [3, 2, 1] >>> linked_list_to_list(flip(Node(0, Node(1, Node(4, Node(9, Node(16))))))) [16, 9, 4, 1, 0] pass def linked_list_to_list(head): Helper function to convert linked list to regular list for testing. result = [] while head is not None: result.append(head.data) head = head.next return result def test_flip_empty_list(): assert flip(None) is None def test_flip_single_node(): node = Node(10) flipped = flip(node) assert flipped.data == 10 assert flipped.next is None def test_flip_two_nodes(): node = Node(1, Node(2)) flipped = flip(node) assert linked_list_to_list(flipped) == [2, 1] def test_flip_multiple_nodes(): node = Node(1, Node(2, Node(3))) flipped = flip(node) assert linked_list_to_list(flipped) == [3, 2, 1] def test_flip_complex_list(): node = Node(0, Node(1, Node(4, Node(9, Node(16))))) flipped = flip(node) assert linked_list_to_list(flipped) == [16, 9, 4, 1, 0]","solution":"class Node: def __init__(self, data, next=None): self.data = data self.next = next def flip(head): if head is None: return None prev = None current = head while current is not None: next_node = current.next current.next = prev prev = current current = next_node return prev"},{"question":"def find_unique_element(test_cases): For each test case, finds the element that appears only once in the list. >>> find_unique_element([[1, 2, 3, 2, 1]]) [3] >>> find_unique_element([[4, 5, 4, 5, 7, 6, 7]]) [6] >>> find_unique_element([[1, 2, 3, 2, 1], [4, 5, 4, 5, 7, 6, 7]]) [3, 6] >>> find_unique_element([[1, 3, 1, 4, 4, 3, 1000000]]) [1000000] >>> find_unique_element([[7]]) [7] >>> find_unique_element([[10, 10, 5, 2, 5, 8, 2]]) [8] >>> find_unique_element([[1000000, 999999, 1000000]]) [999999]","solution":"def find_unique_element(test_cases): For each test case, finds the element that appears only once in the list. result = [] for case in test_cases: unique_element = 0 for number in case: unique_element ^= number result.append(unique_element) return result"},{"question":"def fizzbuzz_string(n: int) -> str: Write a function that takes an integer \`n\` as input and returns a string containing the numbers from \`1\` to \`n\` separated by commas, but replaces multiples of 3 with \\"Fizz\\", multiples of 5 with \\"Buzz\\", and multiples of both 3 and 5 with \\"FizzBuzz\\". >>> fizzbuzz_string(15) == \\"1,2,Fizz,4,Buzz,Fizz,7,8,Fizz,Buzz,11,Fizz,13,14,FizzBuzz\\" >>> fizzbuzz_string(5) == \\"1,2,Fizz,4,Buzz\\" >>> fizzbuzz_string(3) == \\"1,2,Fizz\\" >>> fizzbuzz_string(1) == \\"1\\"","solution":"def fizzbuzz_string(n): Returns a string containing the numbers from 1 to n separated by commas, but replaces multiples of 3 with \\"Fizz\\", multiples of 5 with \\"Buzz\\", and multiples of both 3 and 5 with \\"FizzBuzz\\". result = [] for i in range(1, n + 1): if i % 3 == 0 and i % 5 == 0: result.append(\\"FizzBuzz\\") elif i % 3 == 0: result.append(\\"Fizz\\") elif i % 5 == 0: result.append(\\"Buzz\\") else: result.append(str(i)) return \\",\\".join(result)"},{"question":"from typing import List def longest_tournament_arrangement(arr: List[int]) -> int: Determine the length of the longest tournament arrangement in the given sequence. A tournament arrangement is a contiguous subarray where there's an increasing sequence followed immediately by a decreasing sequence. Args: arr (List[int]): A list of integers representing the sequence. Returns: int: The length of the longest tournament arrangement, or 0 if none exist. >>> longest_tournament_arrangement([1, 3, 2, 4, 6, 5, 4]) 5 >>> longest_tournament_arrangement([5, 4, 3, 2, 1]) 0 >>> longest_tournament_arrangement([1, 2, 3, 4, 3, 2, 1, 0]) 8 >>> longest_tournament_arrangement([2, 1, 2, 1]) 3 >>> longest_tournament_arrangement([1]) 0","solution":"def longest_tournament_arrangement(arr): n = len(arr) if n < 3: return 0 longest_length = 0 for i in range(1, n - 1): # Check if arr[i] is a peak if arr[i - 1] < arr[i] > arr[i + 1]: # Expand to the left left = i while left > 0 and arr[left - 1] < arr[left]: left -= 1 # Expand to the right right = i while right < n - 1 and arr[right] > arr[right + 1]: right += 1 # Calculate the length of the current tournament arrangement cur_length = right - left + 1 longest_length = max(longest_length, cur_length) return longest_length"},{"question":"from typing import List def subarraysWithKDistinct(arr: List[int], k: int) -> int: Given an array of integers 'arr' and an integer 'k', find the number of subarrays with exactly 'k' distinct integers. >>> subarraysWithKDistinct([1, 2, 1, 2, 3], 2) 7 >>> subarraysWithKDistinct([1, 2, 1, 3, 4], 3) 3","solution":"from typing import List import collections def subarraysWithKDistinct(arr: List[int], k: int) -> int: def at_most_k_distinct(arr, k): count = collections.Counter() left = 0 res = 0 for right in range(len(arr)): if count[arr[right]] == 0: k -= 1 count[arr[right]] += 1 while k < 0: count[arr[left]] -= 1 if count[arr[left]] == 0: k += 1 left += 1 res += right - left + 1 return res return at_most_k_distinct(arr, k) - at_most_k_distinct(arr, k - 1)"},{"question":"def is_suitable_for_conference(L: int, W: int) -> str: Determine if the room dimensions are suitable for conference use. A room is suitable if its area is at least 150 square meters. Parameters: L (int): Length of the room in meters. W (int): Width of the room in meters. Returns: str: 'Suitable' if the room is suitable, 'Not Suitable' otherwise. >>> is_suitable_for_conference(15, 10) 'Suitable' >>> is_suitable_for_conference(10, 10) 'Not Suitable'","solution":"def is_suitable_for_conference(L, W): Returns whether the room is suitable for conference use. A room is suitable if its area is at least 150 square meters. Parameters: L (int): Length of the room in meters. W (int): Width of the room in meters. Returns: str: 'Suitable' if the room is suitable, 'Not Suitable' otherwise. if L * W >= 150: return 'Suitable' else: return 'Not Suitable'"},{"question":"from typing import List, Tuple def edit_distance(A: str, B: str) -> int: Returns the minimum edit distance between string A and string B. >>> edit_distance(\\"abc\\", \\"yabd\\") 2 >>> edit_distance(\\"kitten\\", \\"sitting\\") 3 def min_edit_distances(test_cases: List[Tuple[str, str]]) -> List[int]: Computes the minimum edit distances for a list of test cases. >>> min_edit_distances([(\\"abc\\", \\"yabd\\"), (\\"kitten\\", \\"sitting\\")]) [2, 3] def test_edit_distance_simple_cases(): assert edit_distance(\\"abc\\", \\"yabd\\") == 2 assert edit_distance(\\"kitten\\", \\"sitting\\") == 3 def test_edit_distance_identical_strings(): assert edit_distance(\\"abc\\", \\"abc\\") == 0 assert edit_distance(\\"a\\", \\"a\\") == 0 def test_edit_distance_empty_strings(): assert edit_distance(\\"\\", \\"\\") == 0 assert edit_distance(\\"a\\", \\"\\") == 1 assert edit_distance(\\"\\", \\"a\\") == 1 def test_min_edit_distances(): test_cases = [ (\\"abc\\", \\"yabd\\"), (\\"kitten\\", \\"sitting\\"), ] expected_results = [2, 3] assert min_edit_distances(test_cases) == expected_results","solution":"def edit_distance(A, B): Returns the minimum edit distance between string A and string B. len_A = len(A) len_B = len(B) # Create a DP table to store the edit distances dp = [[0] * (len_B + 1) for _ in range(len_A + 1)] # Fill the base cases for i in range(len_A + 1): dp[i][0] = i for j in range(len_B + 1): dp[0][j] = j # Compute the edit distance for i in range(1, len_A + 1): for j in range(1, len_B + 1): if A[i-1] == B[j-1]: dp[i][j] = dp[i-1][j-1] else: dp[i][j] = 1 + min(dp[i-1][j], # Deletion dp[i][j-1], # Insertion dp[i-1][j-1]) # Substitution return dp[len_A][len_B] def min_edit_distances(test_cases): results = [] for A, B in test_cases: results.append(edit_distance(A, B)) return results"},{"question":"def can_transform(s: str, t: str) -> str: Determine if string s can be transformed into string t using a one-to-one character mapping. Parameters: s (str): The source string. t (str): The target string. Returns: str: \\"YES\\" if s can be transformed into t, otherwise \\"NO\\". >>> can_transform(\\"abc\\", \\"def\\") \\"YES\\" >>> can_transform(\\"foo\\", \\"bar\\") \\"NO\\" pass def process_test_cases(test_cases: list) -> list: Process multiple test cases to determine if the transformations are possible. Parameters: test_cases (list of tuples): List of tuples where each tuple contains two strings (s, t). Returns: list of str: List containing results for each test case (\\"YES\\" or \\"NO\\"). >>> process_test_cases([(\\"abc\\", \\"def\\"), (\\"foo\\", \\"bar\\"), (\\"aaa\\", \\"aaa\\")]) [\\"YES\\", \\"NO\\", \\"YES\\"] pass","solution":"def can_transform(s, t): Determine if string s can be transformed into string t using a one-to-one character mapping. Parameters: s (str): The source string. t (str): The target string. Returns: str: \\"YES\\" if s can be transformed into t, otherwise \\"NO\\". if len(s) != len(t): return \\"NO\\" s_to_t_mapping = {} t_to_s_mapping = {} for cs, ct in zip(s, t): if (cs in s_to_t_mapping and s_to_t_mapping[cs] != ct) or (ct in t_to_s_mapping and t_to_s_mapping[ct] != cs): return \\"NO\\" s_to_t_mapping[cs] = ct t_to_s_mapping[ct] = cs return \\"YES\\" def process_test_cases(test_cases): Process multiple test cases to determine if the transformations are possible. Parameters: test_cases (list of tuples): List of tuples where each tuple contains two strings (s, t). Returns: list of str: List containing results for each test case (\\"YES\\" or \\"NO\\"). results = [] for s, t in test_cases: results.append(can_transform(s, t)) return results"},{"question":"def determine_winner(n: int) -> str: Given the initial number of stones n, determine the winner (Alice or Bob) if both play optimally. >>> determine_winner(4) \\"Alice\\" >>> determine_winner(2) \\"Bob\\" >>> determine_winner(7) \\"Alice\\"","solution":"def determine_winner(n): Determines who will win the game (Alice or Bob) given n stones. # Alice wins if the number of stones (n) is odd, otherwise Bob wins. return \\"Alice\\" if n % 2 == 1 else \\"Bob\\""},{"question":"def is_arithmetic_progression(N: int, numbers: List[int]) -> str: Returns \\"YES\\" if the list of numbers forms an arithmetic progression, otherwise \\"NO\\". >>> is_arithmetic_progression(5, [1, 3, 5, 7, 9]) \\"YES\\" >>> is_arithmetic_progression(4, [2, 4, 7, 10]) \\"NO\\" def check_arithmetic_progressions(test_cases: List[Tuple[int, List[int]]]) -> List[str]: Given a list of test cases, each with a number count and a list of integers, returns a list of \\"YES\\" or \\"NO\\" for each test case to indicate if the list forms an arithmetic progression. >>> check_arithmetic_progressions([(5, [1, 3, 5, 7, 9]), (4, [2, 4, 7, 10])]) [\\"YES\\", \\"NO\\"] from solution import is_arithmetic_progression, check_arithmetic_progressions def test_is_arithmetic_progression_yes(): assert is_arithmetic_progression(5, [1, 3, 5, 7, 9]) == \\"YES\\" def test_is_arithmetic_progression_no(): assert is_arithmetic_progression(4, [2, 4, 7, 10]) == \\"NO\\" def test_is_arithmetic_progression_single_element(): assert is_arithmetic_progression(1, [5]) == \\"NO\\" def test_is_arithmetic_progression_two_elements(): assert is_arithmetic_progression(2, [5, 9]) == \\"YES\\" def test_check_arithmetic_progressions(): test_cases = [ (5, [1, 3, 5, 7, 9]), (4, [2, 4, 7, 10]) ] results = check_arithmetic_progressions(test_cases) assert results == [\\"YES\\", \\"NO\\"] def test_check_arithmetic_progressions_varied_cases(): test_cases = [ (5, [1, 3, 5, 7, 9]), (6, [2, 4, 6, 8, 10, 12]), (4, [1, 2, 3, 5]), (3, [10, 15, 20]), (4, [3, 3, 3, 3]) ] results = check_arithmetic_progressions(test_cases) assert results == [\\"YES\\", \\"YES\\", \\"NO\\", \\"YES\\", \\"YES\\"] def test_check_arithmetic_progressions_with_negatives(): test_cases = [ (5, [-10, -5, 0, 5, 10]), (4, [-3, -1, 1, 3]) ] results = check_arithmetic_progressions(test_cases) assert results == [\\"YES\\", \\"YES\\"]","solution":"def is_arithmetic_progression(N, numbers): Returns \\"YES\\" if the list of numbers forms an arithmetic progression, otherwise \\"NO\\". if N < 2: return \\"NO\\" numbers.sort() difference = numbers[1] - numbers[0] for i in range(2, N): if numbers[i] - numbers[i - 1] != difference: return \\"NO\\" return \\"YES\\" def check_arithmetic_progressions(test_cases): results = [] for N, numbers in test_cases: results.append(is_arithmetic_progression(N, numbers)) return results"},{"question":"def max_spells_used_in_competitions(n, thresholds, spell_difficulties): Determines the maximum number of spells that can be used in each competition. Parameters: - n (int): Number of competitions. - thresholds (list of int): The threshold difficulty levels for the competitions. - spell_difficulties (list of int): The difficulty levels of the spells Hermione adds for each competition. Returns: - list of int: Maximum number of spells that can be used in each competition. >>> max_spells_used_in_competitions(5, [3, 5, 2, 8, 6], [4, 5, 1, 9, 7]) [1, 2, 2, 3, 4] >>> max_spells_used_in_competitions(3, [1, 2, 3], [1, 2, 3]) [1, 2, 3] >>> max_spells_used_in_competitions(4, [5, 5, 5, 5], [1, 2, 3, 4]) [0, 0, 0, 0] >>> max_spells_used_in_competitions(3, [1, 1, 1], [1, 1, 1]) [1, 2, 3] >>> max_spells_used_in_competitions(2, [10, 10], [10, 9]) [1, 1]","solution":"def max_spells_used_in_competitions(n, thresholds, spell_difficulties): Determines the maximum number of spells that can be used in each competition. Parameters: - n (int): Number of competitions. - thresholds (list of int): The threshold difficulty levels for the competitions. - spell_difficulties (list of int): The difficulty levels of the spells Hermione adds for each competition. Returns: - list of int: Maximum number of spells that can be used in each competition. max_spells = [] registered_spells = 0 for i in range(n): if spell_difficulties[i] >= thresholds[i]: registered_spells += 1 max_spells.append(registered_spells) else: max_spells.append(registered_spells) return max_spells"},{"question":"def determine_winner(m, n, grid_string): Determines the winner of the game based on the dimensions of the grid and the grid's configuration. Alice always starts and plays in Mode A, while Bob plays in Mode B. >>> determine_winner(2, 2, 'CDCC') \\"ALICE\\" >>> determine_winner(3, 3, 'CDDDCCCCC') \\"BOB\\" # Implement the logic to determine the winner def game_winner(T, test_cases): Returns a list of winners for each test case. >>> game_winner(2, [(2, 2, 'CDCC'), (3, 3, 'CDDDCCCCC')]) [\\"ALICE\\", \\"BOB\\"] >>> game_winner(2, [(4, 5, 'CCCDDCCCDDCCD'), (5, 5, 'CCCCCDDDDDCCCCCDDDDD')]) [\\"ALICE\\", \\"BOB\\"] results = [] for i in range(T): m, n, grid = test_cases[i] winner = determine_winner(m, n, grid) results.append(winner) return results","solution":"def determine_winner(m, n, grid_string): Determines the winner of the game based on the dimensions of the grid and the grid's configuration. Alice always starts and plays in Mode A, while Bob plays in Mode B. # If either dimension of the grid is even, Alice will win if m % 2 == 0 or n % 2 == 0: return \\"ALICE\\" else: return \\"BOB\\" def game_winner(T, test_cases): results = [] for i in range(T): m, n, grid = test_cases[i] winner = determine_winner(m, n, grid) results.append(winner) return results"},{"question":"def max_gold(t: int, test_cases: list) -> list: Compute the maximum gold Jack can carry without triggering the curse for each test case. :param t: number of test cases :param test_cases: list of tuples, each containing an integer n and a list of n integers representing the values of the chests :return: list of integers, each representing the maximum gold for corresponding test case >>> max_gold(4, [(3, [2, 3, 4]), (4, [5, 1, 1, 5]), (5, [3, 2, 5, 10, 7]), (3, [6, 7, 1])]) [6, 10, 15, 7] >>> max_gold(1, [(3, [6, 7, 1])]) [7] >>> max_gold(1, [(5, [3, 2, 5, 10, 7])]) [15]","solution":"def max_gold(t, test_cases): def getMaxGold(chests): n = len(chests) if n == 0: return 0 elif n == 1: return chests[0] # dp[i] will be the max gold that can be collected up to chest i dp = [0] * n dp[0] = chests[0] dp[1] = max(chests[0], chests[1]) for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + chests[i]) return dp[-1] results = [] for case in test_cases: n, chests = case results.append(getMaxGold(chests)) return results"},{"question":"def can_make_dish(test_cases): Determine if the chef can make the dish with the available ingredients. Args: test_cases (List[Tuple[int, int, List[int], List[int]]]): List of test cases where each test case is represented as a tuple: - N: Number of required ingredients. - M: Number of available ingredients. - required_ingredients: List of required ingredients. - available_ingredients: List of available ingredients. Returns: List[str]: List of results for each test case; \\"Yes\\" if the dish can be made, otherwise \\"No\\". Example: >>> can_make_dish([(3, 5, [1, 2, 3], [3, 4, 2, 1, 5]), (2, 4, [4, 5], [1, 2, 3, 4]), (1, 3, [7], [7, 7, 6, 5, 3])]) [\\"Yes\\", \\"No\\", \\"Yes\\"]","solution":"def can_make_dish(test_cases): results = [] for case in test_cases: N, M, required_ingredients, available_ingredients = case available_set = set(available_ingredients) # Check if all required ingredients are in the available set if all(ingredient in available_set for ingredient in required_ingredients): results.append(\\"Yes\\") else: results.append(\\"No\\") return results"},{"question":"def smallest_missing_positive(arr): Returns the smallest missing positive integer in the array. pass def process_test_cases(test_cases): results = [] for arr in test_cases: result = smallest_missing_positive(arr) results.append(result) return results Unit Test: def test_example_cases(): assert process_test_cases([[1, 2, 0], [4, 3, 2, 7]]) == [3, 1] def test_missing_in_start(): assert process_test_cases([[2, 3, 4, 5], [5, 3, 2, 4]]) == [1, 1] def test_straight_numbers(): assert process_test_cases([[1, 2, 3, 4, 5], [2, 1, 4, 3, 5]]) == [6, 6] def test_one_element(): assert process_test_cases([[1], [2], [3], [0], [7]]) == [2, 1, 1, 1, 1] def test_mixed_elements(): assert process_test_cases([[1, 2, -1, 0, 3], [9, 11, 12, 1]]) == [4, 2] def test_large_numbers(): assert process_test_cases([[1000, 999, 998, 997], [900000, 900001]]) == [1, 1] def test_duplicates(): assert process_test_cases([[1, 1, 2, 2], [1, 2, 2, 3, 3, 4, 4]]) == [3, 5]","solution":"def smallest_missing_positive(arr): Returns the smallest missing positive integer in the array. n = len(arr) for i in range(n): while 1 <= arr[i] <= n and arr[arr[i] - 1] != arr[i]: correct_idx = arr[i] - 1 arr[i], arr[correct_idx] = arr[correct_idx], arr[i] for i in range(n): if arr[i] != i + 1: return i + 1 return n + 1 def process_test_cases(test_cases): results = [] for arr in test_cases: result = smallest_missing_positive(arr) results.append(result) return results"},{"question":"def count_unique_strings(S: str) -> int: Given a string S consisting of uppercase English letters and underscores ('_'), each underscore in the string can be replaced with any uppercase English letter to form a new string. The function returns the number of unique strings that can be formed. >>> count_unique_strings(\\"A_B\\") 26 >>> count_unique_strings(\\"HELLO_WOR_D\\") 676","solution":"def count_unique_strings(S): Given a string S consisting of uppercase English letters and underscores ('_'), each underscore in the string can be replaced with any uppercase English letter to form a new string. The function returns the number of unique strings that can be formed. underscore_count = S.count('_') return 26 ** underscore_count"},{"question":"def can_partition(nums: List[int]) -> str: Determine if it's possible to split the array into two non-empty subsets with equal sums. >>> can_partition([1, 5, 11, 5]) 'YES' >>> can_partition([1, 2, 3, 9]) 'NO'","solution":"def can_partition(nums): total_sum = sum(nums) if total_sum % 2 != 0: return \\"NO\\" target = total_sum // 2 n = len(nums) dp = [False] * (target + 1) dp[0] = True for num in nums: for j in range(target, num - 1, -1): dp[j] = dp[j] or dp[j - num] return \\"YES\\" if dp[target] else \\"NO\\" if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().strip().split() n = int(data[0]) nums = list(map(int, data[1:])) print(can_partition(nums))"},{"question":"def min_transformations(source: str, target: str) -> int: Returns the minimum number of transformations to convert source string to target string. >>> min_transformations(\\"horse\\", \\"ros\\") 3 >>> min_transformations(\\"intention\\", \\"execution\\") 5","solution":"def min_transformations(source, target): Returns the minimum number of transformations to convert source string to target string. m, n = len(source), len(target) # Create a DP table to memoize results of subproblems dp = [[0] * (n + 1) for _ in range(m + 1)] # Initialize the table with base case values for i in range(m + 1): for j in range(n + 1): if i == 0: dp[i][j] = j # If source is empty, insert all characters of target elif j == 0: dp[i][j] = i # If target is empty, delete all characters of source elif source[i - 1] == target[j - 1]: dp[i][j] = dp[i - 1][j - 1] # If characters match, no change needed else: dp[i][j] = 1 + min(dp[i][j - 1], # Insert dp[i - 1][j], # Remove dp[i - 1][j - 1]) # Replace return dp[m][n]"},{"question":"import numpy as np def process_array(N: int, A: list) -> tuple: Given a size N and a 1-D array A, find the floor, ceil, and rint of the elements of A using NumPy. >>> process_array(6, [1.1, 2.5, 3.8, -4.3, 5.7, -6.9]) (array([ 1., 2., 3., -5., 5., -7.]), array([ 2., 3., 4., -4., 6., -6.]), array([ 1., 2., 4., -4., 6., -7.])) >>> process_array(3, [-1.1, -0.5, -2.8]) (array([-2., -1., -3.]), array([-1., 0., -2.]), array([-1., -0., -3.]))","solution":"import numpy as np def process_array(N, A): A = np.array(A) floor_vals = np.floor(A) ceil_vals = np.ceil(A) rint_vals = np.rint(A) return floor_vals, ceil_vals, rint_vals"},{"question":"def canHaveGreatestCandies(nums: List[int], extraCandies: int) -> List[bool]: Given an array of integers nums where nums[i] represents the number of candies that the i-th child has, and an integer extraCandies, where extraCandies represents the number of extra candies you have. For each child, check if they can have the greatest number of candies among all the children if you give them all of the extraCandies. Return a boolean list result where result[i] is true if, after giving the i-th child all the extraCandies, they will have the greatest number of candies among all the children, or false otherwise. >>> canHaveGreatestCandies([2, 3, 5, 1, 3], 3) [True, True, True, False, True] >>> canHaveGreatestCandies([4, 2, 1, 1, 2], 1) [True, False, False, False, False] def test_can_have_greatest_candies_example1(): nums = [2, 3, 5, 1, 3] extraCandies = 3 assert canHaveGreatestCandies(nums, extraCandies) == [True, True, True, False, True] def test_can_have_greatest_candies_example2(): nums = [4, 2, 1, 1, 2] extraCandies = 1 assert canHaveGreatestCandies(nums, extraCandies) == [True, False, False, False, False] def test_can_have_greatest_candies_all_equal(): nums = [2, 2, 2, 2, 2] extraCandies = 1 assert canHaveGreatestCandies(nums, extraCandies) == [True, True, True, True, True] def test_can_have_greatest_candies_single_element(): nums = [5] extraCandies = 5 assert canHaveGreatestCandies(nums, extraCandies) == [True] def test_can_have_greatest_candies_various(): nums = [1, 6, 3, 5, 2] extraCandies = 3 assert canHaveGreatestCandies(nums, extraCandies) == [False, True, True, True, False]","solution":"def canHaveGreatestCandies(nums, extraCandies): Returns a list of booleans indicating if each child can have the greatest number of candies among all children after receiving extraCandies. max_candies = max(nums) return [(candy + extraCandies) >= max_candies for candy in nums]"},{"question":"def check_fountain_placement(n: int, m: int, p: int, q: int): Determines if a rectangular fountain of dimensions p by q can be centered in a park of dimensions n by m such that there is an equal amount of pathway around the fountain along both the length and the width. Parameters: n (int): Length of the park m (int): Width of the park p (int): Length of the fountain q (int): Width of the fountain Returns: tuple or str: A tuple containing the length of the walkway along the length and the width of the park or a string \\"Not possible\\" if the placement is not possible. pass # Test cases from solution import check_fountain_placement def test_fountain_placement_positive_case(): assert check_fountain_placement(8, 10, 2, 6) == (3, 2) def test_fountain_placement_with_decimal_walkways(): assert check_fountain_placement(7, 5, 4, 2) == \\"Not possible\\" def test_fountain_placement_fountain_larger_than_park(): assert check_fountain_placement(6, 8, 7, 4) == \\"Not possible\\" def test_square_fountain_in_square_park(): assert check_fountain_placement(10, 10, 6, 6) == (2, 2) def test_exact_fit(): assert check_fountain_placement(5, 5, 5, 5) == (0, 0) def test_negative_case_due_to_large_fountain_length(): assert check_fountain_placement(10, 10, 11, 10) == \\"Not possible\\" def test_negative_case_due_to_large_fountain_width(): assert check_fountain_placement(10, 10, 10, 11) == \\"Not possible\\" def test_large_values(): assert check_fountain_placement(100000, 100000, 50000, 50000) == (25000, 25000)","solution":"def check_fountain_placement(n, m, p, q): Determines if a rectangular fountain of dimensions p by q can be centered in a park of dimensions n by m such that there is an equal amount of pathway around the fountain along both the length and the width. Parameters: n (int): Length of the park m (int): Width of the park p (int): Length of the fountain q (int): Width of the fountain Returns: tuple: A tuple containing the length of the walkway along the length and the width of the park or a string \\"Not possible\\" if the placement is not possible. if (n >= p and m >= q): walkway_length = (n - p) / 2 walkway_width = (m - q) / 2 if walkway_length.is_integer() and walkway_width.is_integer(): return int(walkway_length), int(walkway_width) return \\"Not possible\\""},{"question":"class Pipeline: def __init__(self, iterable): self.iterable = iterable def map(self, func): return Pipeline(map(func, self.iterable)) def filter(self, predicate): return Pipeline(filter(predicate, self.iterable)) def reduce(self, reducer, initial): from functools import reduce return reduce(reducer, self.iterable, initial) def collect(self): return list(self.iterable) def reverse(self): Reverse the order of elements in the pipeline >>> data = Pipeline([1, 2, 3, 4, 5]) >>> data.reverse().collect() [5, 4, 3, 2, 1] def zip_with(self, other, func): Combine two pipelines into a single pipeline by combining their elements using a specified function >>> data = Pipeline([1, 2, 3, 4, 5]) >>> other_data = Pipeline([10, 20, 30, 40, 50]) >>> data.zip_with(other_data, lambda x, y: x + y).collect() [11, 22, 33, 44, 55] # Test the new functionality data = Pipeline([1, 2, 3, 4, 5]) reversed_data = data.reverse().collect() # [5, 4, 3, 2, 1] print(reversed_data) other_data = Pipeline([10, 20, 30, 40, 50]) zipped_data = data.zip_with(other_data, lambda x, y: x + y).collect() # [11, 22, 33, 44, 55] print(zipped_data)","solution":"class Pipeline: def __init__(self, iterable): self.iterable = iterable def map(self, func): return Pipeline(map(func, self.iterable)) def filter(self, predicate): return Pipeline(filter(predicate, self.iterable)) def reduce(self, reducer, initial): from functools import reduce return reduce(reducer, self.iterable, initial) def collect(self): return list(self.iterable) def reverse(self): # Gather elements into a list, reverse it, then return a new Pipeline return Pipeline(reversed(list(self.iterable))) def zip_with(self, other, func): # Combine elements of both pipelines using the provided function return Pipeline(map(lambda pair: func(pair[0], pair[1]), zip(self.iterable, other.iterable)))"},{"question":"def find_vehicle(n, t, activate_ia): Function to find the malfunctioning vehicle in an n x n grid using IA activations. Parameters: n (int): Size of the grid (1 ≤ n ≤ 10^8) t (int): Maximum number of IA activations allowed (1 ≤ t ≤ 10000) activate_ia (function): Function to simulate activation of IA, takes four integers (x1, y1, x2, y2) and returns 'Found' or 'Not Found' def test_find_vehicle(): n = 8 t = 10000 vehicle_position = (3, 3) queries = [] def mocked_activate_ia(x1, y1, x2, y2): queries.append((x1, y1, x2, y2)) return simulate_ia(vehicle_position, (x1, y1, x2, y2)) find_vehicle(n, t, mocked_activate_ia) assert len(queries) <= 10000 assert queries[-1] == (3, 3, 3, 3) def test_find_vehicle_large_grid(): n = 100000 t = 10000 vehicle_position = (50000, 50000) queries = [] def mocked_activate_ia(x1, y1, x2, y2): queries.append((x1, y1, x2, y2)) return simulate_ia(vehicle_position, (x1, y1, x2, y2)) find_vehicle(n, t, mocked_activate_ia) assert len(queries) <= 10000 assert queries[-1] == (50000, 50000, 50000, 50000) def simulate_ia(vehicle_position, query): Simulates IA activation. Parameters: vehicle_position (tuple): The current position of the vehicle. query (tuple): The query provided to IA (x1, y1, x2, y2) Returns: str: 'Found' if vehicle is within the rectangle (x1, y1, x2, y2), 'Not Found' otherwise. x1, y1, x2, y2 = query vx, vy = vehicle_position if x1 <= vx <= x2 and y1 <= vy <= y2: return \\"Found\\" else: return \\"Not Found\\"","solution":"def find_vehicle(n, t, activate_ia): Function to find the malfunctioning vehicle in an n x n grid using IA activations. Parameters: n (int): Size of the grid (1 ≤ n ≤ 10^8) t (int): Maximum number of IA activations allowed (1 ≤ t ≤ 10000) activate_ia (function): Function to simulate activation of IA, takes four integers (x1, y1, x2, y2) and returns 'Found' or 'Not Found' left, right, top, bottom = 1, n, 1, n while left < right or top < bottom: middle_x = (left + right) // 2 middle_y = (top + bottom) // 2 # Divide the area in half horizontally if left < right: if activate_ia(left, top, middle_x, bottom) == \\"Found\\": right = middle_x else: left = middle_x + 1 # Divide the area in half vertically if top < bottom: if activate_ia(left, top, right, middle_y) == \\"Found\\": bottom = middle_y else: top = middle_y + 1 # Final check for the single intersection activate_ia(left, top, left, top)"},{"question":"def min_sensors_to_cover_segment(n: int, m: int, sensors: List[Tuple[int, int]]) -> int: Determine the minimum number of sensors required to cover the segment [0, m] or return -1 if it is not possible to cover the segment. >>> min_sensors_to_cover_segment(4, 10, [(1, 5), (8, 3), (12, 6), (3, 4)]) 2 >>> min_sensors_to_cover_segment(3, 10, [(1, 1), (4, 1), (7, 1)]) -1","solution":"def min_sensors_to_cover_segment(n, m, sensors): Determine the minimum number of sensors required to cover the segment [0, m] or return -1 if it is not possible to cover the segment. intervals = [(p - r, p + r) for p, r in sensors] intervals.sort() end = 0 max_end = 0 i = 0 sensors_used = 0 while end < m: while i < n and intervals[i][0] <= end: max_end = max(max_end, intervals[i][1]) i += 1 if max_end <= end: return -1 end = max_end sensors_used += 1 return sensors_used # Example usage: # n, m = 4, 10 # sensors = [(1, 5), (8, 3), (12, 6), (3, 4)] # print(min_sensors_to_cover_segment(n, m, sensors)) # Output: 2"},{"question":"def are_permutations(str1, str2): Determines if one string is a permutation of the other. Case-sensitive comparison. :param str1: First string :param str2: Second string :return: True if one string is a permutation of the other, False otherwise","solution":"def are_permutations(str1, str2): Determines if one string is a permutation of the other. Case-sensitive comparison. :param str1: First string :param str2: Second string :return: True if one string is a permutation of the other, False otherwise return sorted(str1) == sorted(str2)"},{"question":"from typing import List from collections import Counter def can_form_palindrome(s: str) -> str: Determines whether it is possible to rearrange the digits to form a palindrome. If possible, returns one such palindrome. If it is not possible, returns an empty string. >>> can_form_palindrome(\\"12321\\") in [\\"12321\\", \\"13231\\"] True >>> can_form_palindrome(\\"123\\") == \\"\\" True >>> can_form_palindrome(\\"1\\") == \\"1\\" True >>> can_form_palindrome(\\"1122\\") in [\\"1221\\", \\"2112\\"] True >>> can_form_palindrome(\\"aabbc\\") in [\\"abcba\\", \\"bacab\\"] True >>> can_form_palindrome(\\"abc\\") == \\"\\" True >>> can_form_palindrome(\\"\\") == \\"\\" True","solution":"from collections import Counter def can_form_palindrome(s): Determines whether it is possible to rearrange the digits to form a palindrome. If possible, returns one such palindrome. If it is not possible, returns an empty string. char_count = Counter(s) # A string can form a palindrome if it has at most one odd-count character odd_count_chars = [char for char, count in char_count.items() if count % 2 != 0] if len(odd_count_chars) > 1: return \\"\\" half_palindrome = [] middle_char = \\"\\" for char, count in char_count.items(): if count % 2 != 0: middle_char = char half_palindrome.append(char * (count // 2)) first_half = \\"\\".join(half_palindrome) return first_half + middle_char + first_half[::-1]"},{"question":"def max_profit(n: int, prices: List[int]) -> int: Calculate the maximum profit obtainable through a single buy-sell transaction. :param n: Integer, number of days. :param prices: List of integers, stock prices for each day. :return: Integer, maximum profit. >>> max_profit(5, [7, 1, 5, 3, 6, 4]) 5 >>> max_profit(5, [7, 6, 4, 3, 1]) 0 >>> max_profit(6, [1, 2, 3, 4, 5, 6]) 5 >>> max_profit(1, [1]) 0 >>> max_profit(0, []) 0 >>> max_profit(2, [1, 2]) 1 >>> max_profit(4, [5, 5, 5, 5]) 0 >>> max_profit(5, [3, 8, 6, 7, 5]) 5 >>> max_profit(6, [5, 3, 2, 4, 6, 8]) 6 >>> max_profit(5, [10, 1, 10, 1, 10]) 9","solution":"def max_profit(n, prices): Calculate the maximum profit obtainable through a single buy-sell transaction. :param n: Integer, number of days. :param prices: List of integers, stock prices for each day. :return: Integer, maximum profit. if n == 0: return 0 min_price = float('inf') max_profit = 0 for price in prices: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"def max_consecutive_empty_benches(grid: List[List[int]]) -> int: Determine the maximum number of consecutive empty benches (0s) that can be found in any row or column in the grid. >>> max_consecutive_empty_benches([ ... [1, 0, 0, 1], ... [0, 1, 1, 0], ... [1, 1, 0, 0] ... ]) 2 >>> max_consecutive_empty_benches([ ... [1, 1, 1, 1], ... [0, 0, 0, 0], ... [1, 0, 1, 1], ... [0, 0, 1, 1] ... ]) 4","solution":"def max_consecutive_empty_benches(grid): def max_consecutive_zeros(arr): max_zeros = 0 count = 0 for num in arr: if num == 0: count += 1 max_zeros = max(max_zeros, count) else: count = 0 return max_zeros max_zeros_in_rows = max(max_consecutive_zeros(row) for row in grid) max_zeros_in_columns = max(max_consecutive_zeros(col) for col in zip(*grid)) return max(max_zeros_in_rows, max_zeros_in_columns)"},{"question":"def min_difference_sweetness(t: int, test_cases: List[Tuple[int, List[int], int]]) -> List[int]: Determine the minimum possible difference in sweetness between the friend receiving the most sweetness and the friend receiving the least sweetness. t: Number of test cases. test_cases: Each test case is represented by a tuple where the first element is the number of candies, the second element is a list of integers representing the sweetness of each candy, and the third element is the number of friends. >>> min_difference_sweetness(2, [(6, [10, 20, 30, 40, 50, 60], 3), (5, [5, 5, 5, 5, 5], 4)]) [20, 0] >>> min_difference_sweetness(1, [(1, [1000], 1)]) [0]","solution":"def min_difference_sweetness(t, test_cases): results = [] for i in range(t): n = test_cases[i][0] sweetness = sorted(test_cases[i][1]) k = test_cases[i][2] if k == 1: results.append(sweetness[-1] - sweetness[0]) continue min_diff = float('inf') for j in range(n - k + 1): current_diff = sweetness[j + k - 1] - sweetness[j] min_diff = min(min_diff, current_diff) results.append(min_diff) return results"},{"question":"def max_unique_subset_sum(N: int, colors: List[int]) -> int: Calculate the highest possible sum of unique elements for any subset of the original set. Parameters: N (int): Number of elements in James' set of colors. colors (list of int): List of unique positive integers representing colors. Returns: int: The maximum possible sum of unique elements that can be formed. Examples: >>> max_unique_subset_sum(5, [1, 2, 2, 4, 3]) 10 >>> max_unique_subset_sum(4, [4, 4, 4, 4]) 4 >>> max_unique_subset_sum(6, [3, 5, 1, 1, 6, 3]) 15","solution":"def max_unique_subset_sum(N, colors): Calculate the highest possible sum of unique elements for any subset of the original set. Parameters: N (int): Number of elements in James' set of colors. colors (list of int): List of unique positive integers representing colors. Returns: int: The maximum possible sum of unique elements that can be formed. # Convert the list to a set to remove duplicates unique_colors = set(colors) # Return the sum of the unique elements return sum(unique_colors)"},{"question":"def max_sum_submatrix(matrix, N, M, K, L): Given a rectangular matrix \`M\` of size \`N x M\` filled with non-negative integers, find the maximum sum of elements in any rectangular submatrix of size \`K x L\`. Args: matrix (List[List[int]]): 2D list representing the matrix. N (int): Number of rows in the matrix. M (int): Number of columns in the matrix. K (int): Number of rows in the submatrix. L (int): Number of columns in the submatrix. Returns: int: Maximum sum of elements in any \`K x L\` submatrix. Example: >>> max_sum_submatrix([[1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15], [16, 17, 18, 19, 20]], 4, 5, 2, 3) 99 >>> max_sum_submatrix([[5]], 1, 1, 1, 1) 5","solution":"def max_sum_submatrix(matrix, N, M, K, L): # Initialize the prefix sum array prefix = [[0] * (M + 1) for _ in range(N + 1)] # Calculate the prefix sums for i in range(1, N + 1): for j in range(1, M + 1): prefix[i][j] = matrix[i-1][j-1] + prefix[i-1][j] + prefix[i][j-1] - prefix[i-1][j-1] max_sum = 0 # Iterate over every possible KxL submatrix for i in range(K, N + 1): for j in range(L, M + 1): submatrix_sum = (prefix[i][j] - prefix[i-K][j] - prefix[i][j-L] + prefix[i-K][j-L]) max_sum = max(max_sum, submatrix_sum) return max_sum # Example usage: # matrix = [ # [1, 2, 3, 4, 5], # [6, 7, 8, 9, 10], # [11, 12, 13, 14, 15], # [16, 17, 18, 19, 20] # ] # N, M, K, L = 4, 5, 2, 3 # print(max_sum_submatrix(matrix, N, M, K, L)) # Output should be 99"},{"question":"def max_operational_servers(M: int, y: int, b: List[int]) -> int: Returns the maximum number of servers that can operate simultaneously given the processing units. >>> max_operational_servers(4, 100, [30, 40, 20, 50]) 3 >>> max_operational_servers(3, 50, [10, 20, 30]) 2 >>> max_operational_servers(5, 300, [200, 50, 80, 70, 60]) 4 >>> max_operational_servers(4, 5, [10, 20, 15, 25]) 0","solution":"def max_operational_servers(M, y, b): Returns the maximum number of servers that can operate simultaneously given the processing units. Arguments: M : int - Number of servers y : int - Total available processing units from the central pool b : list of int - List of required processing units for each server Returns: int - Maximum number of servers that can operate simultaneously b.sort() count = 0 for i in range(M): if y >= b[i]: y -= b[i] count += 1 else: break return count"},{"question":"def update_prices(prices: dict, messages: list) -> None: Updates the 'prices' dictionary based on the list of 'messages'. Each message in the format \\"COMMAND item price\\" will either update the price of an existing item or add a new item to the dictionary. >>> prices = {'apple': 2.0, 'banana': 1.5} >>> messages = ['UPDATE apple 2.2'] >>> update_prices(prices, messages) >>> print(prices) {'apple': 2.2, 'banana': 1.5} >>> prices = {'apple': 2.0, 'banana': 1.5} >>> messages = ['ADD orange 1.8'] >>> update_prices(prices, messages) >>> print(prices) {'apple': 2.0, 'banana': 1.5, 'orange': 1.8} >>> prices = {'bread': 1.5, 'milk': 0.99} >>> messages = ['ADD eggs 2.1', 'UPDATE milk 1.2'] >>> update_prices(prices, messages) >>> print(prices) {'bread': 1.5, 'milk': 1.2, 'eggs': 2.1}","solution":"def update_prices(prices: dict, messages: list) -> None: Updates the 'prices' dictionary based on the list of 'messages'. Each message in the format \\"COMMAND item price\\" will either update the price of an existing item or add a new item to the dictionary. for message in messages: command, item, price = message.split() price = float(price) if command == 'UPDATE' or command == 'ADD': prices[item] = price"},{"question":"def compare_versions(version1: str, version2: str) -> str: Compare two version strings in the format \\"X.Y.Z\\". :param version1: str, version string in the format \\"X.Y.Z\\" :param version2: str, version string in the format \\"X.Y.Z\\" :return: str, comparison result: - \\"version1>version2\\" if version1 is newer, - \\"version1<version2\\" if version1 is older, - \\"version1=version2\\" if both versions are the same. >>> compare_versions(\\"1.2.0\\", \\"1.1.5\\") 'version1>version2' >>> compare_versions(\\"2.3.4\\", \\"2.3.4\\") 'version1=version2' >>> compare_versions(\\"1.0.10\\", \\"1.0.2\\") 'version1>version2'","solution":"def compare_versions(version1, version2): Compare two version strings in the format \\"X.Y.Z\\". :param version1: str, version string in the format \\"X.Y.Z\\" :param version2: str, version string in the format \\"X.Y.Z\\" :return: str, comparison result: - \\"version1>version2\\" if version1 is newer, - \\"version1<version2\\" if version1 is older, - \\"version1=version2\\" if both versions are the same. v1_parts = list(map(int, version1.split('.'))) v2_parts = list(map(int, version2.split('.'))) # Compare each part of the version for part1, part2 in zip(v1_parts, v2_parts): if part1 > part2: return \\"version1>version2\\" elif part1 < part2: return \\"version1<version2\\" return \\"version1=version2\\""},{"question":"def longestSubarrayTwoDistinct(arr: List[int]) -> int: Returns the length of the longest subarray that contains at most two distinct integers. :param arr: List[int] - The input array :return: int - Length of the longest subarray with at most two distinct integers >>> longestSubarrayTwoDistinct([]) == 0 >>> longestSubarrayTwoDistinct([1]) == 1 >>> longestSubarrayTwoDistinct([1, 2]) == 2 >>> longestSubarrayTwoDistinct([1, 1, 2]) == 3 >>> longestSubarrayTwoDistinct([1, 2, 1, 3, 4, 1, 2, 3]) == 3 >>> longestSubarrayTwoDistinct([1, 2, 1, 2, 1, 2, 1, 2]) == 8 >>> longestSubarrayTwoDistinct([1, 2, 3, 4, 5, 6, 7, 8]) == 2 >>> longestSubarrayTwoDistinct([1, 2, 1, 2, 3, 3, 2, 2, 1]) == 5","solution":"def longestSubarrayTwoDistinct(arr): Returns the length of the longest subarray that contains at most two distinct integers. :param arr: List[int] - The input array :return: int - Length of the longest subarray with at most two distinct integers if not arr: return 0 max_len = 0 start = 0 freq = {} for end in range(len(arr)): freq[arr[end]] = freq.get(arr[end], 0) + 1 while len(freq) > 2: freq[arr[start]] -= 1 if freq[arr[start]] == 0: del freq[arr[start]] start += 1 max_len = max(max_len, end - start + 1) return max_len"},{"question":"def shortest_distance(N: int, test_cases: List[Tuple[int, int]]) -> List[int]: Determine the shortest distance between two given stations A and B on a circular subway line with N stations. Parameters: N : int The total number of stations. test_cases : list of tuples Each tuple contains two integers A and B representing two stations. Returns: list of int A list containing the shortest distances for each pair of stations. Examples: >>> shortest_distance(6, [(1, 3), (2, 5), (4, 1)]) [2, 3, 3] >>> shortest_distance(10, [(3, 8), (6, 2)]) [5, 4] from typing import List, Tuple # You can use the following test cases to check your implementation def test_sample_input_1(): assert shortest_distance(6, [(1, 3), (2, 5), (4, 1)]) == [2, 3, 3] def test_sample_input_2(): assert shortest_distance(10, [(3,8), (6,2)]) == [5, 4] def test_nearest_stations(): assert shortest_distance(8, [(3, 4), (6, 7)]) == [1, 1] def test_opposite_stations(): assert shortest_distance(10, [(1, 6), (5, 10)]) == [5, 5] def test_same_station(): assert shortest_distance(100, [(50, 50)]) == [0] def test_boundary_values(): assert shortest_distance(2, [(1, 2)]) == [1]","solution":"def shortest_distance(N, test_cases): Determine the shortest distance between two given stations A and B on a circular subway line with N stations. Parameters: N : int The total number of stations. test_cases : list of tuples Each tuple contains two integers A and B representing two stations. Returns: list of int A list containing the shortest distances for each pair of stations. distances = [] for A, B in test_cases: direct_distance = abs(A - B) circular_distance = N - direct_distance shortest = min(direct_distance, circular_distance) distances.append(shortest) return distances"},{"question":"class MinStack: def __init__(self): Initialize your data structure here. pass def push(self, x: int) -> int: Push element x onto stack and return the current size of the stack. >>> stack = MinStack() >>> stack.push(10) 1 >>> stack.push(20) 2 def pop(self) -> int: Removes the element on the top of the stack and return the current size of the stack. >>> stack = MinStack() >>> stack.push(10) 1 >>> stack.pop() 0 def top(self) -> int: Get the top element. >>> stack = MinStack() >>> stack.push(10) 1 >>> stack.top() 10 def getMin(self) -> int: Retrieve the minimum element in the stack. >>> stack = MinStack() >>> stack.push(10) 1 >>> stack.getMin() 10 >>> stack.push(5) 2 >>> stack.getMin() 5 >>> stack.pop() 1 >>> stack.getMin() 10","solution":"class MinStack: def __init__(self): self.stack = [] self.min_stack = [] def push(self, x: int) -> int: self.stack.append(x) if not self.min_stack or x <= self.min_stack[-1]: self.min_stack.append(x) return len(self.stack) def pop(self) -> int: if not self.stack: return 0 top_element = self.stack.pop() if top_element == self.min_stack[-1]: self.min_stack.pop() return len(self.stack) def top(self) -> int: if not self.stack: return -1 return self.stack[-1] def getMin(self) -> int: if not self.min_stack: return -1 return self.min_stack[-1]"},{"question":"def max_tower_height(towers): Calculate the maximum possible height of the remaining tower after all collapses. Parameters: towers (list): A list of integers representing the heights of the towers. Returns: int: The height of the remaining tower. pass # Example usage n = 4 towers = [4, 1, 3, 2] print(max_tower_height(towers)) # Expected Output: 10 # Unit tests def test_example_1(): assert max_tower_height([1, 2, 3]) == 6 def test_example_2(): assert max_tower_height([4, 1, 3, 2]) == 10 def test_single_tower(): assert max_tower_height([5]) == 5 def test_two_towers(): assert max_tower_height([3, 2]) == 5 def test_equal_towers(): assert max_tower_height([4, 4, 4]) == 12 def test_descending_towers(): assert max_tower_height([4, 3, 2, 1]) == 10 def test_ascending_towers(): assert max_tower_height([1, 2, 3, 4]) == 10 def test_mixed_heights(): assert max_tower_height([1, 5, 3, 8, 2]) == 19","solution":"def max_tower_height(towers): Calculate the maximum possible height of the remaining tower after all collapses. Parameters: towers (list): A list of integers representing the heights of the towers. Returns: int: The height of the remaining tower. while len(towers) > 1: # Find the index of the tallest tower tallest_idx = 0 for i in range(1, len(towers)): if towers[i] > towers[tallest_idx]: tallest_idx = i # Find the index of the second tallest tower second_tallest_idx = -1 for i in range(len(towers)): if i != tallest_idx: if second_tallest_idx == -1 or towers[i] > towers[second_tallest_idx]: second_tallest_idx = i # Collapse the tallest tower into the second tallest tower towers[second_tallest_idx] += towers[tallest_idx] del towers[tallest_idx] return towers[0] # Example usage n = 4 towers = [4, 1, 3, 2] print(max_tower_height(towers)) # Output will be 10"},{"question":"def count_groups(grid, m, n): Given a grid of size m x n filled with empty cells ('.') and barriers ('#'), determine the number of distinct groups of adjacent empty cells. Two empty cells are considered adjacent if they are directly connected vertically or horizontally. Args: grid (List[List[str]]): The grid of cells. m (int): The number of rows in the grid. n (int): The number of columns in the grid. Returns: int: The number of distinct groups of adjacent empty cells. Examples: >>> count_groups([ ['.', '.', '#', '.', '.'], ['.', '#', '.', '.', '#'], ['.', '.', '#', '#', '.'], ['#', '#', '#', '#', '#'] ], 4, 5) 3 >>> count_groups([ ['.', '.'], ['.', '.'] ], 2, 2) 1 >>> count_groups([ ['#', '#'], ['#', '#'] ], 2, 2) 0 >>> count_groups([ ['.', '#', '.'], ['#', '.', '#'], ['.', '#', '.'] ], 3, 3) 5 >>> count_groups([ ['.', '#', '.', '.'], ['#', '#', '.', '#'], ['.', '.', '#', '.'], ['.', '#', '.', '.'] ], 4, 4) 4 pass","solution":"def count_groups(grid, m, n): def dfs(x, y): if x < 0 or x >= m or y < 0 or y >= n or grid[x][y] != '.': return grid[x][y] = '#' # mark the cell as visited by changing '.' to '#' # explore four possible directions: up, down, left, right dfs(x-1, y) dfs(x+1, y) dfs(x, y-1) dfs(x, y+1) count = 0 for i in range(m): for j in range(n): if grid[i][j] == '.': dfs(i, j) count += 1 return count"},{"question":"def is_queue_valid(n: int, k: int, heights: List[int]) -> str: Determines if the queue follows the given pattern. Parameters: n (int): The number of people in the queue. k (int): The maximum acceptable height difference. heights (list of int): List of heights of people in the queue. Returns: str: \\"YES\\" if the queue follows the pattern, otherwise \\"NO\\". Example: >>> is_queue_valid(5, 2, [5, 5, 4, 6, 6]) \\"YES\\" >>> is_queue_valid(4, 3, [7, 3, 2, 5]) \\"NO\\" >>> is_queue_valid(6, 1, [8, 7, 9, 10, 8, 7]) \\"NO\\"","solution":"def is_queue_valid(n, k, heights): Determines if the queue follows the given pattern. Parameters: n (int): The number of people in the queue. k (int): The maximum acceptable height difference. heights (list of int): List of heights of people in the queue. Returns: str: \\"YES\\" if the queue follows the pattern, otherwise \\"NO\\". for i in range(n - 1): if heights[i] < heights[i + 1] and (heights[i + 1] - heights[i] > k): return \\"NO\\" return \\"YES\\""},{"question":"from typing import List, Tuple def min_partition_diff(arr: List[int]) -> int: Returns the minimum possible absolute difference between the sums of two subarrays. >>> min_partition_diff([1, 2, 3, 4]) 2 >>> min_partition_diff([1, 1, 1, 1, 1]) 1 pass def solve(test_cases: List[Tuple[int, List[int]]]) -> List[int]: Solves multiple test cases for the min_partition_diff function. >>> solve([(4, [1, 2, 3, 4]), (5, [1, 1, 1, 1, 1])]) [2, 1] pass","solution":"def min_partition_diff(arr): Returns the minimum possible absolute difference between the sums of two subarrays. total_sum = sum(arr) left_sum = 0 min_diff = float('inf') for i in range(len(arr) - 1): left_sum += arr[i] right_sum = total_sum - left_sum min_diff = min(min_diff, abs(left_sum - right_sum)) return min_diff def solve(test_cases): results = [] for n, arr in test_cases: results.append(min_partition_diff(arr)) return results"},{"question":"from datetime import datetime def calculate_fine(return_date: str, due_date: str) -> int: Calculates the fine for overdue books based on the return date and due date. If the book is returned on or before the due date, no fine is charged. If the book is returned after the due date, the fine is calculated based on the number of days overdue: - For the first 7 days (if the book is returned within 1 to 7 days after the due date), the fine is 2 per day. - From the 8th day and onwards, the fine is 5 per day. The function returns the fine amount as an integer. If the input dates are invalid or in an incorrect format, returns \\"Invalid date format.\\". Examples: >>> calculate_fine(\\"2023-10-10\\", \\"2023-10-05\\") 10 >>> calculate_fine(\\"2023-10-15\\", \\"2023-10-05\\") 29 >>> calculate_fine(\\"2023-10-05\\", \\"2023-10-15\\") 0 >>> calculate_fine(\\"2023-10-10\\", \\"incorrect-format\\") 'Invalid date format.' >>> calculate_fine(\\"not-a-date\\", \\"2023-10-05\\") 'Invalid date format.'","solution":"from datetime import datetime def calculate_fine(return_date, due_date): Calculates the fine for overdue books based on the return date and due date. Return \\"Invalid date format.\\" if the input dates are not in the correct format. try: return_date = datetime.strptime(return_date, \\"%Y-%m-%d\\") due_date = datetime.strptime(due_date, \\"%Y-%m-%d\\") except ValueError: return \\"Invalid date format.\\" if return_date <= due_date: return 0 days_overdue = (return_date - due_date).days if days_overdue <= 7: fine = days_overdue * 2 else: fine = 7 * 2 + (days_overdue - 7) * 5 return fine"},{"question":"class SegmentTree: def __init__(self, data): Initialize segment tree with the given data list. self.n = len(data) self.tree = [0] * (4 * self.n) self.build(data, 0, 0, self.n - 1) def build(self, data, node, start, end): Build the segment tree. if start == end: self.tree[node] = data[start] else: mid = (start + end) // 2 left_child = 2 * node + 1 right_child = 2 * node + 2 self.build(data, left_child, start, mid) self.build(data, right_child, mid + 1, end) self.tree[node] = max(self.tree[left_child], self.tree[right_child]) def update(self, idx, value, node, start, end): Update the segment tree. if start == end: self.tree[node] = value else: mid = (start + end) // 2 left_child = 2 * node + 1 right_child = 2 * node + 2 if idx <= mid: self.update(idx, value, left_child, start, mid) else: self.update(idx, value, right_child, mid + 1, end) self.tree[node] = max(self.tree[left_child], self.tree[right_child]) def query(self, L, R, node, start, end): Query the segment tree for maximum value. if R < start or L > end: return -float('inf') if L <= start and end <= R: return self.tree[node] mid = (start + end) // 2 left_child = 2 * node + 1 right_child = 2 * node + 2 left_query = self.query(L, R, left_child, start, mid) right_query = self.query(L, R, right_child, mid + 1, end) return max(left_query, right_query) def update_value(self, idx, value): Update value in segment tree. self.update(idx - 1, value, 0, 0, self.n - 1) # Convert to 0-indexed def max_query(self, L, R): Query maximum value in range using segment tree. return self.query(L - 1, R - 1, 0, 0, self.n - 1) # Convert to 0-indexed def process_input(N, data, Q, queries): Process input and return results for queries. >>> N = 5 >>> data = [1, 2, 3, 4, 5] >>> Q = 3 >>> queries = [ ... [\\"Q\\", 1, 3], ... [\\"Q\\", 2, 5], ... [\\"Q\\", 1, 5], ... ] >>> process_input(N, data, Q, queries) [3, 5, 5] segment_tree = SegmentTree(data) results = [] for query in queries: if query[0] == \\"U\\": _, i, v = query segment_tree.update_value(int(i), int(v)) elif query[0] == \\"Q\\": _, L, R = query result = segment_tree.max_query(int(L), int(R)) results.append(result) return results def test_segment_tree_query(): N = 5 data = [1, 2, 3, 4, 5] Q = 3 queries = [ [\\"Q\\", 1, 3], [\\"Q\\", 2, 5], [\\"Q\\", 1, 5], ] expected_results = [3, 5, 5] results = process_input(N, data, Q, queries) assert results == expected_results def test_segment_tree_update(): N = 5 data = [1, 2, 3, 4, 5] Q = 4 queries = [ [\\"Q\\", 1, 3], [\\"U\\", 3, 10], [\\"Q\\", 1, 3], [\\"Q\\", 2, 5], ] expected_results = [3, 10, 10] results = process_input(N, data, Q, queries) assert results == expected_results def test_large_segment_tree(): N = 6 data = [5, 1, 9, 2, 6, 3] Q = 4 queries = [ [\\"Q\\", 1, 3], [\\"U\\", 2, 12], [\\"Q\\", 1, 3], [\\"Q\\", 2, 5], ] expected_results = [9, 12, 12] results = process_input(N, data, Q, queries) assert results == expected_results","solution":"class SegmentTree: def __init__(self, data): self.n = len(data) self.tree = [0] * (4 * self.n) self.build(data, 0, 0, self.n - 1) def build(self, data, node, start, end): if start == end: self.tree[node] = data[start] else: mid = (start + end) // 2 left_child = 2 * node + 1 right_child = 2 * node + 2 self.build(data, left_child, start, mid) self.build(data, right_child, mid + 1, end) self.tree[node] = max(self.tree[left_child], self.tree[right_child]) def update(self, idx, value, node, start, end): if start == end: self.tree[node] = value else: mid = (start + end) // 2 left_child = 2 * node + 1 right_child = 2 * node + 2 if idx <= mid: self.update(idx, value, left_child, start, mid) else: self.update(idx, value, right_child, mid + 1, end) self.tree[node] = max(self.tree[left_child], self.tree[right_child]) def query(self, L, R, node, start, end): if R < start or L > end: return -float('inf') if L <= start and end <= R: return self.tree[node] mid = (start + end) // 2 left_child = 2 * node + 1 right_child = 2 * node + 2 left_query = self.query(L, R, left_child, start, mid) right_query = self.query(L, R, right_child, mid + 1, end) return max(left_query, right_query) def update_value(self, idx, value): self.update(idx - 1, value, 0, 0, self.n - 1) # Convert to 0-indexed def max_query(self, L, R): return self.query(L - 1, R - 1, 0, 0, self.n - 1) # Convert to 0-indexed def process_input(N, data, Q, queries): segment_tree = SegmentTree(data) results = [] for query in queries: if query[0] == \\"U\\": _, i, v = query segment_tree.update_value(int(i), int(v)) elif query[0] == \\"Q\\": _, L, R = query result = segment_tree.max_query(int(L), int(R)) results.append(result) return results # Sample usage if __name__ == \\"__main__\\": N = 8 data = [1, 3, 5, 7, 9, 11, 13, 15] Q = 5 queries = [ [\\"Q\\", 1, 3], [\\"Q\\", 4, 8], [\\"U\\", 5, 10], [\\"Q\\", 4, 8], [\\"Q\\", 1, 8] ] results = process_input(N, data, Q, queries) for res in results: print(res)"},{"question":"def merge_sort(arr): Perform the merge sort algorithm to sort an array of integers in non-decreasing order. >>> merge_sort([64, 34, 25, 12, 22]) [12, 22, 25, 34, 64] >>> merge_sort([]) [] >>> merge_sort([1]) [1] def sort_books(test_cases): Sort the given book index cases using merge sort. >>> sort_books([[5, 64, 34, 25, 12, 22], [7, 38, 27, 43, 3, 9, 82, 10]]) [[12, 22, 25, 34, 64], [3, 9, 10, 27, 38, 43, 82]] def format_input_output(input_string): Format the input and output for processing multiple test cases using merge sort. >>> format_input_output(\\"2n5 64 34 25 12 22n7 38 27 43 3 9 82 10n\\") \\"12 22 25 34 64n3 9 10 27 38 43 82\\" >>> format_input_output(\\"1n5 64 34 25 12 22n\\") \\"12 22 25 34 64\\" >>> format_input_output(\\"0n\\") \\"\\"","solution":"def merge_sort(arr): if len(arr) > 1: mid = len(arr) // 2 left_half = arr[:mid] right_half = arr[mid:] merge_sort(left_half) merge_sort(right_half) i = j = k = 0 while i < len(left_half) and j < len(right_half): if left_half[i] < right_half[j]: arr[k] = left_half[i] i += 1 else: arr[k] = right_half[j] j += 1 k += 1 while i < len(left_half): arr[k] = left_half[i] i += 1 k += 1 while j < len(right_half): arr[k] = right_half[j] j += 1 k += 1 def sort_books(test_cases): results = [] for case in test_cases: N = case[0] books = case[1:] merge_sort(books) results.append(books) return results def format_input_output(input_string): input_lines = input_string.strip().split(\\"n\\") T = int(input_lines[0]) test_cases = [] for i in range(1, T + 1): test_cases.append(list(map(int, input_lines[i].split()))) sorted_books = sort_books(test_cases) output_lines = \\"n\\".join(\\" \\".join(map(str, books)) for books in sorted_books) return output_lines"},{"question":"def largest_possible_integer(test_cases: List[str]) -> List[str]: Takes a list of strings of digits and returns the largest possible integer for each string. >>> largest_possible_integer(['123', '405', '099']) == ['321', '540', '990'] >>> largest_possible_integer(['001', '510', '302']) == ['100', '510', '320'] pass","solution":"def largest_possible_integer(test_cases): Takes a list of strings of digits and returns the largest possible integer for each string. result = [] for digits in test_cases: sorted_digits = sorted(digits, reverse=True) largest_num = ''.join(sorted_digits) if largest_num[0] == '0': result.append('0') else: result.append(largest_num) return result"},{"question":"def max_packages(L: int, packages: List[Tuple[int, int]]) -> int: Determines the maximum number of packages that can fit on the conveyor belt without overlapping. Parameters: L (int): The total length of the conveyor belt. packages (list): A list of tuples where each tuple contains two integers (wi, hi) representing the width and height of each package. Returns: int: The maximum number of packages that can fit on the conveyor belt. >>> max_packages(10, [(2, 3), (3, 4), (5, 2), (3, 3)]) 3 >>> max_packages(5, [(6, 1)]) 0 >>> max_packages(15, [(5, 5), (10, 10), (1, 1), (4, 4), (3, 3), (5, 5)]) 4","solution":"def max_packages(L, packages): Determines the maximum number of packages that can fit on the conveyor belt without overlapping. Parameters: L (int): The total length of the conveyor belt. packages (list): A list of tuples where each tuple contains two integers (wi, hi) representing the width and height of each package. Returns: int: The maximum number of packages that can fit on the conveyor belt. # Sort packages by width in ascending order packages.sort() total_width = 0 count = 0 for width, height in packages: if total_width + width <= L: total_width += width count += 1 else: break return count # Example usage if __name__ == \\"__main__\\": L = 10 N = 4 packages = [(2, 3), (3, 4), (5, 2), (3, 3)] print(max_packages(L, packages)) # Output: 3"},{"question":"def count_distinct_special_words(n: int, lamp_states: List[int]) -> int: Returns the number of distinct special words that can be formed by inverting exactly one lamp state. >>> count_distinct_special_words(5, [1, 1, 0, 0, 1]) 5 >>> count_distinct_special_words(3, [1, 1, 1]) 3 >>> count_distinct_special_words(4, [0, 0, 0, 0]) 4","solution":"def count_distinct_special_words(n, lamp_states): Returns the number of distinct special words that can be formed by inverting exactly one lamp state. # Any lamp that we switch will create a unique combination return n"},{"question":"def max_unique_house_visits(n: int, m: int, k: int, campaign_plan: List[Tuple[int, int]]) -> int: Determines the maximum number of unique house visits across all streets based on the campaign plan. Parameters: n (int): Number of streets m (int): Number of houses per street k (int): Number of tuples in the campaign plan campaign_plan (List[Tuple[int, int]]): List of tuples where each tuple represents a street number and a house number to be targeted Returns: int: The maximum number of unique house visits Example: >>> max_unique_house_visits(3, 5, 4, [(1, 2), (1, 3), (2, 1), (3, 5)]) 4 >>> max_unique_house_visits(1, 10, 3, [(1, 1), (1, 2), (1, 3)]) 3","solution":"def max_unique_house_visits(n, m, k, campaign_plan): Determines the maximum number of unique house visits across all streets based on the campaign plan. Parameters: n (int): Number of streets m (int): Number of houses per street k (int): Number of tuples in the campaign plan campaign_plan (List[Tuple[int, int]]): List of tuples where each tuple represents a street number and a house number to be targeted Returns: int: The maximum number of unique house visits # Use a set to track unique house visits unique_visits = set() # Iterate over the campaign plan to collect unique visits for street, house in campaign_plan: unique_visits.add((street, house)) # The result is the number of unique house visits return len(unique_visits)"},{"question":"def max_length_subarray_with_sum_k(arr: List[int], k: int) -> int: Finds the maximum length of a subarray that has a sum equal to k. :param arr: List of integers :param k: Target sum :return: Maximum length of the subarray with sum equal to k >>> max_length_subarray_with_sum_k([1, -1, 5, -2, 3], 3) 4 >>> max_length_subarray_with_sum_k([1, 2, 3, 4, 5], 100) 0 >>> max_length_subarray_with_sum_k([1, 2, 3, 4, 5], 6) 3 >>> max_length_subarray_with_sum_k([1, -1, -1, -1, 4], 2) 5 >>> max_length_subarray_with_sum_k([3], 3) 1 >>> max_length_subarray_with_sum_k([1], 3) 0 >>> max_length_subarray_with_sum_k([1, 1, 1, 1, 1], 2) 2 >>> max_length_subarray_with_sum_k([], 3) 0","solution":"def max_length_subarray_with_sum_k(arr, k): Finds the maximum length of a subarray that has a sum equal to k. :param arr: List of integers :param k: Target sum :return: Maximum length of the subarray with sum equal to k sum_indices = {} current_sum = 0 max_len = 0 for i in range(len(arr)): current_sum += arr[i] if current_sum == k: max_len = i + 1 if (current_sum - k) in sum_indices: max_len = max(max_len, i - sum_indices[current_sum - k]) if current_sum not in sum_indices: sum_indices[current_sum] = i return max_len"},{"question":"def word_count(s: str, words: List[str]) -> Dict[str, int]: Returns a dictionary where the keys are the words and the values are the number of occurrences of each word in the string. :param s: string - The input string to search :param words: list of strings - The list of words to count occurrences :return: dictionary - A dictionary with word counts >>> word_count(\\"hello world\\", [\\"hello\\", \\"world\\", \\"goodbye\\"]) == {\\"hello\\": 1, \\"world\\": 1, \\"goodbye\\": 0} >>> word_count(\\"hello world hello\\", [\\"hello\\", \\"world\\", \\"goodbye\\"]) == {\\"hello\\": 2, \\"world\\": 1, \\"goodbye\\": 0} >>> word_count(\\"hello world\\", [\\"goodbye\\", \\"see\\", \\"you\\"]) == {\\"goodbye\\": 0, \\"see\\": 0, \\"you\\": 0} >>> word_count(\\"\\", [\\"hello\\", \\"world\\", \\"goodbye\\"]) == {\\"hello\\": 0, \\"world\\": 0, \\"goodbye\\": 0} >>> word_count(\\"hello world\\", []) == {} >>> word_count(\\"hello hello hello hello\\", [\\"hello\\", \\"world\\"]) == {\\"hello\\": 4, \\"world\\": 0}","solution":"def word_count(s, words): Returns a dictionary where the keys are the words and the values are the number of occurrences of each word in the string. :param s: string - The input string to search :param words: list of strings - The list of words to count occurrences :return: dictionary - A dictionary with word counts word_list = s.split() word_dict = {} for word in words: word_dict[word] = word_list.count(word) return word_dict"},{"question":"def calculate_water_requirements(N: int, crops: List[str]) -> Dict[str, int]: Calculate the total water required for each crop type in the field. Parameters: N : int : the size of the array representing the field crops : list of str : list where each element is a string of the format 'Cx' C is a letter representing the crop type x is an integer representing the water requirement Returns: dict : dictionary with crop types as keys and total water required as values >>> calculate_water_requirements(7, [\\"A300\\", \\"B200\\", \\"A400\\", \\"C100\\", \\"B300\\", \\"C200\\", \\"A100\\"]) {\\"A\\": 800, \\"B\\": 500, \\"C\\": 300} >>> calculate_water_requirements(3, [\\"A100\\", \\"B200\\", \\"C300\\"]) {\\"A\\": 100, \\"B\\": 200, \\"C\\": 300} >>> calculate_water_requirements(1, [\\"A100\\"]) {\\"A\\": 100}","solution":"def calculate_water_requirements(N, crops): Calculate the total water required for each crop type in the field. Parameters: N : int : the size of the array representing the field crops : list of str : list where each element is a string of the format 'Cx' C is a letter representing the crop type x is an integer representing the water requirement Returns: dict : dictionary with crop types as keys and total water required as values water_requirements = {} for crop in crops: crop_type = crop[0] water_amount = int(crop[1:]) if crop_type in water_requirements: water_requirements[crop_type] += water_amount else: water_requirements[crop_type] = water_amount sorted_water_requirements = {k: water_requirements[k] for k in sorted(water_requirements)} return sorted_water_requirements"},{"question":"def longest_path(grid): Find the length of the longest path that can be traversed without revisiting any cell and without stepping on two consecutive cells of the same color in a 2D grid representing the board with colors. >>> longest_path([['A', 'B', 'C'], ['D', 'E', 'F'], ['G', 'H', 'I']]) 9 >>> longest_path([['A', 'B', 'C', 'D']]) 4 >>> longest_path([['A'], ['B'], ['C'], ['D']]) 4 >>> longest_path([['A', 'A'], ['A', 'A']]) 1 >>> longest_path([['A', 'B'], ['C', 'D']]) 4","solution":"def longest_path(grid): n = len(grid) m = len(grid[0]) def dfs(x, y, visited): directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] max_path = 1 for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited and grid[nx][ny] != grid[x][y]: visited.add((nx, ny)) max_path = max(max_path, 1 + dfs(nx, ny, visited)) visited.remove((nx, ny)) return max_path max_length = 0 for i in range(n): for j in range(m): max_length = max(max_length, dfs(i, j, set([(i, j)]))) return max_length"},{"question":"def matrix_transpose(matrix): Returns the transpose of the given matrix. :param matrix: List of lists, where each sub-list represents a row in the matrix. :return: List of lists, where each sub-list represents a row in the transposed matrix. >>> matrix_transpose([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[1, 4, 7], [2, 5, 8], [3, 6, 9]] >>> matrix_transpose([[1, 2, 3], [4, 5, 6]]) [[1, 4], [2, 5], [3, 6]] >>> matrix_transpose([[1]]) [[1]] >>> matrix_transpose([[1, 2, 3]]) [[1], [2], [3]] >>> matrix_transpose([[1], [2], [3]]) [[1, 2, 3]]","solution":"def matrix_transpose(matrix): Returns the transpose of the given matrix. :param matrix: List of lists, where each sub-list represents a row in the matrix. :return: List of lists, where each sub-list represents a row in the transposed matrix. return [list(row) for row in zip(*matrix)]"},{"question":"def convex_hull(points): Returns the points forming the convex hull in counter-clockwise order. :param points: List of tuples containing the points (x, y). :return: List of tuples containing the points forming the convex hull. pass # Write your implementation here def parse_input(input_lines): Parses the input points from given lines. :param input_lines: List of strings representing the input lines. :return: List of points (x, y) as tuples. pass # Write your implementation here def print_convex_hull(hull_points): Prints the convex hull points formatted as the required output. :param hull_points: List of points forming the convex hull. pass # Write your implementation here # Example usage if __name__ == \\"__main__\\": import sys input_lines = sys.stdin.read().strip().split('n') points = parse_input(input_lines) hull = convex_hull(points) print_convex_hull(hull) # Unit tests: import pytest def test_convex_hull_example(): input_lines = [ \\"7\\", \\"0 0\\", \\"1 1\\", \\"2 2\\", \\"3 3\\", \\"0 3\\", \\"3 0\\", \\"3 2\\" ] expected_output = [ (0, 0), (0, 3), (3, 3), (3, 0) ] points = parse_input(input_lines) hull = convex_hull(points) assert len(hull) == len(expected_output) for point in expected_output: assert point in hull def test_convex_hull_collinear_points(): input_lines = [ \\"4\\", \\"0 0\\", \\"1 1\\", \\"2 2\\", \\"3 3\\" ] expected_output = [ (0, 0), (3, 3) ] points = parse_input(input_lines) hull = convex_hull(points) assert len(hull) == len(expected_output) for point in expected_output: assert point in hull def test_convex_hull_rectangle(): input_lines = [ \\"4\\", \\"0 0\\", \\"0 3\\", \\"3 0\\", \\"3 3\\" ] expected_output = [ (0, 0), (0 3), (3 3) (3 0) ] points = parse_input(input_lines) hull = convex_hull(points) assert len(hull) == len(expected_output) for point in expected_output: assert point in hull","solution":"def convex_hull(points): Returns the points forming the convex hull in counter-clockwise order. :param points: List of tuples containing the points (x, y). :return: List of tuples containing the points forming the convex hull. # Helper function for sorting by polar angle def polar_angle(p0, p1): return (p1[1] - p0[1]) / (p1[0] - p0[0]) if (p1[0] != p0[0]) else float('inf') # Helper function for removing non-left turns def cross_product(o, a, b): return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0]) # Sort points lexicographically (tuples compare lexicographically in Python) points = sorted(points) # Pick the starting point, known as the pivot (points[0]) pivot = points[0] # Sort the points by polar angle with the pivot sorted_points = sorted(points[1:], key=lambda p: (polar_angle(pivot, p), (pivot[0] - p[0])**2 + (pivot[1] - p[1])**2)) # Initialize the Convex Hull hull = [pivot, sorted_points[0]] for p in sorted_points[1:]: while len(hull) > 1 and cross_product(hull[-2], hull[-1], p) <= 0: hull.pop() hull.append(p) return hull def parse_input(input_lines): Parses the input points from given lines. :param input_lines: List of strings representing the input lines. :return: List of points (x, y) as tuples. n = int(input_lines[0]) points = [tuple(map(int, line.split())) for line in input_lines[1:n+1]] return points def print_convex_hull(hull_points): Prints the convex hull points formatted as the required output. :param hull_points: List of points forming the convex hull. print(len(hull_points)) for point in hull_points: print(f\\"{point[0]} {point[1]}\\") # Example usage if __name__ == \\"__main__\\": import sys input_lines = sys.stdin.read().strip().split('n') points = parse_input(input_lines) hull = convex_hull(points) print_convex_hull(hull)"},{"question":"def max_profit(prices): Returns the maximum profit that can be made by buying on one day and selling on a later day. If no profit can be made, returns 0. >>> max_profit([7, 1, 5, 3, 6, 4]) 5 >>> max_profit([7, 6, 4, 3, 1]) 0","solution":"def max_profit(prices): Returns the maximum profit that can be made by buying on one day and selling on a later day. If no profit can be made, returns 0. if not prices or len(prices) < 2: return 0 min_price = prices[0] max_profit = 0 for price in prices[1:]: profit = price - min_price if profit > max_profit: max_profit = profit if price < min_price: min_price = price return max_profit"},{"question":"def find_lexicographically_smallest(S: str) -> str: Find the lexicographically smallest string possible by performing allowed operations on S. >>> find_lexicographically_smallest(\\"dabc\\") \\"abcd\\" >>> find_lexicographically_smallest(\\"leetcode\\") \\"cdeeelot\\" >>> find_lexicographically_smallest(\\"hackathon\\") \\"aachhknot\\" def process_test_cases(test_cases: List[str]) -> List[str]: Processes multiple test cases to find the lexicographically smallest strings. >>> test_cases = [\\"dabc\\", \\"leetcode\\", \\"hackathon\\"] >>> process_test_cases(test_cases) [\\"abcd\\", \\"cdeeelot\\", \\"aachhknot\\"]","solution":"def find_lexicographically_smallest(S): # Find the smallest lexicographical rotation of the string S return ''.join(sorted(S)) def process_test_cases(test_cases): results = [] for S in test_cases: smallest_string = find_lexicographically_smallest(S) results.append(smallest_string) return results"},{"question":"def is_possible(t: int) -> str: Determine if it is possible to reach the target score by completing a combination of tasks. Each puzzle task gives 50 points. Each mission task gives 300 points. Each treasure task gives 5000 points. Args: t (int): The target score (1 ≤ t ≤ 10^9) Returns: str: \\"POSSIBLE\\" if the target score can be achieved, otherwise \\"IMPOSSIBLE\\". Examples: >>> is_possible(6050) 'POSSIBLE' >>> is_possible(2501) 'IMPOSSIBLE'","solution":"def is_possible(target): Returns \\"POSSIBLE\\" if it is possible to achieve the target score (target) by completing combinations of tasks, otherwise returns \\"IMPOSSIBLE\\". for x in range(target // 50 + 1): for y in range((target - x * 50) // 300 + 1): remaining = target - (x * 50 + y * 300) if remaining % 5000 == 0: return \\"POSSIBLE\\" return \\"IMPOSSIBLE\\""},{"question":"def can_deliver_packages(t: int, test_cases: List[Tuple[Tuple[int, int, int], List[int]]]) -> List[str]: Determine if it is possible to deliver the required number of packages to all locations using the available trucks. Args: t (int): Number of test cases. test_cases (List[Tuple[Tuple[int, int, int], List[int]]]): List of tuples where each tuple contains (m, n, k) - number of trucks, number of locations, and maximum capacity of each truck, and a list of integers representing the number of packages required at each location. Returns: List[str]: List of results for each test case, either \\"YES\\" or \\"NO\\". Examples: >>> can_deliver_packages(2, [((3, 4, 10), [5, 10, 7, 6]), ((2, 3, 15), [20, 15, 5])]) [\\"YES\\", \\"NO\\"] >>> can_deliver_packages(1, [((5, 5, 20), [10, 10, 10, 10, 10])]) [\\"YES\\"]","solution":"def can_deliver_packages(t, test_cases): results = [] for i in range(t): m, n, k = test_cases[i][0] packages = test_cases[i][1] total_packages = sum(packages) total_capacity = m * k if total_capacity >= total_packages: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def max_tallest_tree_height(N: int, heights: List[int]) -> int: Given the heights of trees in a list, returns the maximum possible height of the tallest tree after exactly one bending operation. >>> max_tallest_tree_height(5, [2, 3, 7, 4, 5]) == 11 >>> max_tallest_tree_height(3, [1, 2, 3]) == 5 >>> max_tallest_tree_height(2, [4, 5]) == 9 >>> max_tallest_tree_height(4, [6, 2, 1, 8]) == 9 >>> max_tallest_tree_height(1, [10]) == 10 >>> max_tallest_tree_height(4, [1, 1, 1, 1]) == 2 >>> max_tallest_tree_height(6, [2, 1, 4, 3, 6, 7]) == 13 >>> max_tallest_tree_height(3, [100, 300, 200]) == 500 >>> max_tallest_tree_height(7, [10, 10, 10, 10, 10, 10, 10]) == 20 >>> max_tallest_tree_height(2, [1, 1000]) == 1001 >>> max_tallest_tree_height(2, [1000, 1]) == 1001 >>> max_tallest_tree_height(1, [5]) == 5","solution":"def max_tallest_tree_height(N, heights): Given the heights of trees in a list, returns the maximum possible height of the tallest tree after exactly one bending operation. if N < 2: # If there's only one tree, there's no possibility of bending return heights[0] max_height = 0 for i in range(N - 1): # Calculate the potential new height of the (i+1)-th tree new_height = heights[i] + heights[i + 1] if new_height > max_height: max_height = new_height # Return the maximum possible height after bending once return max_height"},{"question":"def sort_names(n: int, names: List[str]) -> List[str]: Sorts names primarily by their last names in ascending order, and if two names have the same last name, by their first names in ascending order. Middle initials, if any, are ignored during the sort. Args: n (int): Number of names. names (list of str): List of names to be sorted. Returns: list of str: Sorted list of names. Examples: >>> sort_names(5, [\\"John Q. Public\\", \\"James A. Smith\\", \\"John A. Adams\\", \\"Alice B. Cooper\\", \\"Zara T. Smith\\"]) [\\"John A. Adams\\", \\"Alice B. Cooper\\", \\"John Q. Public\\", \\"James A. Smith\\", \\"Zara T. Smith\\"] from typing import List from solution import sort_names def test_sort_names_basic(): names = [ \\"John Q. Public\\", \\"James A. Smith\\", \\"John A. Adams\\", \\"Alice B. Cooper\\", \\"Zara T. Smith\\" ] sorted_names = sort_names(5, names) expected = [ \\"John A. Adams\\", \\"Alice B. Cooper\\", \\"John Q. Public\\", \\"James A. Smith\\", \\"Zara T. Smith\\" ] assert sorted_names == expected def test_sort_names_no_middle_initials(): names = [ \\"John Public\\", \\"James Smith\\", \\"John Adams\\", \\"Alice Cooper\\", \\"Zara Smith\\" ] sorted_names = sort_names(5, names) expected = [ \\"John Adams\\", \\"Alice Cooper\\", \\"John Public\\", \\"James Smith\\", \\"Zara Smith\\" ] assert sorted_names == expected def test_sort_names_some_middle_initials(): names = [ \\"John Q. Public\\", \\"James Smith\\", \\"John Adams\\", \\"Alice B. Cooper\\", \\"Zara T. Smith\\" ] sorted_names = sort_names(5, names) expected = [ \\"John Adams\\", \\"Alice B. Cooper\\", \\"John Q. Public\\", \\"James Smith\\", \\"Zara T. Smith\\" ] assert sorted_names == expected def test_sort_names_middle_initial_collision(): names = [ \\"John Q. Public\\", \\"James Q. Public\\", \\"Alice Q. Public\\" ] sorted_names = sort_names(3, names) expected = [ \\"Alice Q. Public\\", \\"James Q. Public\\", \\"John Q. Public\\" ] assert sorted_names == expected def test_sort_names_single_name(): names = [ \\"John Q. Public\\" ] sorted_names = sort_names(1, names) expected = [ \\"John Q. Public\\" ] assert sorted_names == expected","solution":"def sort_names(n, names): Sorts names primarily by their last names in ascending order, and if two names have the same last name, by their first names in ascending order. Middle initials, if any, are ignored during the sort. Args: n (int): Number of names. names (list of str): List of names to be sorted. Returns: list of str: Sorted list of names. def get_sort_key(name): parts = name.split() first_name = parts[0] middle_initial = parts[1] if len(parts) == 3 else '' last_name = parts[-1] return (last_name, first_name) sorted_names = sorted(names, key=get_sort_key) return sorted_names"},{"question":"def can_split_array(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Determine if it's possible to split the given array into two non-empty contiguous subarrays such that the sum of elements in both subarrays is equal. Args: T (int): Number of test cases. test_cases (List[Tuple[int, List[int]]]): The array of integers for each test case. Returns: List[str]: \\"YES\\" if the array can be split as required, otherwise \\"NO\\". >>> can_split_array(2, [(5, [1, 2, 3, 4, 5]), (4, [1, 1, 1, 1])]) [\\"NO\\", \\"YES\\"] >>> can_split_array(1, [(2, [10, 10])]) [\\"YES\\"]","solution":"def can_split_array(T, test_cases): results = [] for case in test_cases: N = case[0] arr = case[1] total_sum = sum(arr) if total_sum % 2 != 0: results.append(\\"NO\\") continue target = total_sum // 2 current_sum = 0 found = False for num in arr: current_sum += num if current_sum == target: found = True break if found: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"import math from typing import List def lcm(a: int, b: int) -> int: Computes the least common multiple of two numbers. >>> lcm(2, 3) 6 >>> lcm(4, 5) 20 pass def smallest_multiple(n: int) -> int: Returns the smallest positive integer that is evenly divisible by all numbers from 1 to n. >>> smallest_multiple(1) 1 >>> smallest_multiple(5) 60 >>> smallest_multiple(7) 420 pass Unit Test: def test_smallest_multiple_1(): assert smallest_multiple(1) == 1 def test_smallest_multiple_2(): assert smallest_multiple(2) == 2 def test_smallest_multiple_3(): assert smallest_multiple(3) == 6 def test_smallest_multiple_4(): assert smallest_multiple(4) == 12 def test_smallest_multiple_5(): assert smallest_multiple(5) == 60 def test_smallest_multiple_6(): assert smallest_multiple(6) == 60 def test_smallest_multiple_7(): assert smallest_multiple(7) == 420 def test_smallest_multiple_8(): assert smallest_multiple(8) == 840 def test_smallest_multiple_9(): assert smallest_multiple(9) == 2520 def test_smallest_multiple_10(): assert smallest_multiple(10) == 2520 def test_smallest_multiple_15(): assert smallest_multiple(15) == 360360 def test_smallest_multiple_20(): assert smallest_multiple(20) == 232792560","solution":"import math def lcm(a, b): Returns the least common multiple of a and b. return abs(a * b) // math.gcd(a, b) def smallest_multiple(n): Returns the smallest positive integer that is evenly divisible by all numbers from 1 to n. if n == 1: return 1 result = 1 for i in range(2, n+1): result = lcm(result, i) return result"},{"question":"def is_prime(n: int) -> bool: Check if a number is prime. >>> is_prime(2) True >>> is_prime(4) False ... def prime_factors(n: int) -> List[int]: Return the prime factors of a number. >>> prime_factors(4) [2, 2] >>> prime_factors(15) [3, 5] ... def choose_best_prime_factors(array: List[int]) -> int: Choose the best prime factors from an array to maximize the sum. >>> choose_best_prime_factors([4, 6, 8]) 7 >>> choose_best_prime_factors([9, 7, 10, 14]) 22 ... def who_wins_game(M: int, P: int, array: List[int]) -> str: Determine which player wins the game if both play optimally. >>> who_wins_game(3, 10, [4, 6, 8]) \\"MAYA\\" >>> who_wins_game(4, 15, [9, 7, 10, 14]) \\"JACOB\\" ... from typing import List def test_is_prime(): assert is_prime(2) assert is_prime(3) assert not is_prime(4) assert is_prime(5) assert is_prime(13) assert not is_prime(15) def test_prime_factors(): assert prime_factors(4) == [2, 2] assert prime_factors(6) == [2, 3] assert prime_factors(8) == [2, 2, 2] assert prime_factors(15) == [3, 5] assert prime_factors(13) == [13] assert prime_factors(28) == [2, 2, 7] def test_choose_best_prime_factors(): assert choose_best_prime_factors([4, 6, 8]) == 2 + 3 + 2 assert choose_best_prime_factors([9, 7, 10, 14]) == 3 + 7 + 5 + 7 assert choose_best_prime_factors([2, 3, 5]) == 2 + 3 + 5 def test_who_wins_game(): assert who_wins_game(3, 10, [4, 6, 8]) == \\"MAYA\\" assert who_wins_game(4, 15, [9, 7, 10, 14]) == \\"JACOB\\" assert who_wins_game(3, 5, [3, 5, 2]) == \\"JACOB\\" assert who_wins_game(2, 20, [15, 16]) == \\"MAYA\\" assert who_wins_game(6, 50, [25, 18, 14, 19, 21, 28]) == \\"JACOB\\"","solution":"def is_prime(n): if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def prime_factors(n): factors = [] while n % 2 == 0: factors.append(2) n = n // 2 for i in range(3, int(n**0.5)+1, 2): while n % i == 0: factors.append(i) n = n // i if n > 2: factors.append(n) return factors def choose_best_prime_factors(array): prime_factors_sum = 0 for num in array: if is_prime(num): prime_factors_sum += num else: factors = prime_factors(num) prime_factors_sum += max(factors) return prime_factors_sum def who_wins_game(m, p, array): prime_factors_sum = choose_best_prime_factors(array) if prime_factors_sum % 2 == 1: return \\"MAYA\\" else: return \\"JACOB\\" inputs = \\"3 10n4 6 8n\\" inputs = inputs.strip().split(\\"n\\") M, P = map(int, inputs[0].split()) array = list(map(int, inputs[1].split())) print(who_wins_game(M, P, array))"},{"question":"def min_width_difference(n: int, widths: List[int]) -> int: Determine the minimum possible difference in total width between two shelves when N books are distributed optimally across them. Parameters: n (int): the number of books widths (list of int): the widths of the books Returns: int: the minimum possible difference in total width between the two shelves >>> min_width_difference(4, [10, 20, 15, 25]) 0 >>> min_width_difference(1, [10]) 10 >>> min_width_difference(2, [10, 10]) 0 >>> min_width_difference(2, [10, 20]) 10 >>> min_width_difference(6, [1, 2, 3, 4, 5, 6]) 1 >>> min_width_difference(3, [100, 50, 50]) 0 >>> min_width_difference(4, [2, 3, 5, 7]) 1 # Your implementation here","solution":"def min_width_difference(n, widths): Determine the minimum possible difference in total width between two shelves when N books are distributed optimally across them. Parameters: n (int): the number of books widths (list of int): the widths of the books Returns: int: the minimum possible difference in total width between the two shelves from itertools import combinations total_width = sum(widths) min_diff = float('inf') # Generate all possible subsets (combinations) for one of the shelves for i in range(n + 1): for combo in combinations(widths, i): shelf1_width = sum(combo) shelf2_width = total_width - shelf1_width min_diff = min(min_diff, abs(shelf1_width - shelf2_width)) return min_diff # Sample Input and Output if __name__ == \\"__main__\\": n = 4 widths = [10, 20, 15, 25] result = min_width_difference(n, widths) print(result) # Output: 0"},{"question":"def update_customer_data(customers, transactions): Updates the customers dictionary by adding transaction amounts to the appropriate customer's total spent. Parameters: customers (dict): A dictionary with customer IDs as keys and another dictionary as value containing 'name' and 'total_spent'. transactions (list): A list of dictionaries containing 'customer_id' and 'amount' of transactions. Example: >>> customers = { ... \\"C001\\": {\\"name\\": \\"Alice\\", \\"total_spent\\": 120.0}, ... \\"C002\\": {\\"name\\": \\"Bob\\", \\"total_spent\\": 75.5} ... } >>> transactions = [ ... {\\"customer_id\\": \\"C001\\", \\"amount\\": 30.0}, ... {\\"customer_id\\": \\"C003\\", \\"amount\\": 12.5}, ... {\\"customer_id\\": \\"C002\\", \\"amount\\": 20.0} ... ] >>> update_customer_data(customers, transactions) >>> customers {'C001': {'name': 'Alice', 'total_spent': 150.0}, 'C002': {'name': 'Bob', 'total_spent': 95.5}}","solution":"def update_customer_data(customers, transactions): Updates the customers dictionary by adding transaction amounts to the appropriate customer's total spent. Parameters: customers (dict): A dictionary with customer IDs as keys and another dictionary as value containing 'name' and 'total_spent'. transactions (list): A list of dictionaries containing 'customer_id' and 'amount' of transactions. for transaction in transactions: customer_id = transaction[\\"customer_id\\"] amount = transaction[\\"amount\\"] if customer_id in customers: customers[customer_id][\\"total_spent\\"] += amount"},{"question":"from typing import List, Tuple def find_smallest_missing_positive(nums: List[int]) -> int: This function finds the smallest positive integer missing from the array. pass def process_test_cases(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: This function processes multiple test cases and returns a list of results for each test case. pass def test_find_smallest_missing_positive(): assert find_smallest_missing_positive([3, 4, -1, 1]) == 2 assert find_smallest_missing_positive([1, 2, 0, -1, 3]) == 4 assert find_smallest_missing_positive([7, 8, 9, 11]) == 1 assert find_smallest_missing_positive([]) == 1 assert find_smallest_missing_positive([-1, -2, -3]) == 1 assert find_smallest_missing_positive([1, 1, 2, 2]) == 3 def test_process_test_cases(): assert process_test_cases(3, [ (4, [3, 4, -1, 1]), (5, [1, 2, 0, -1, 3]), (3, [7, 8, 9, 11]) ]) == [2, 4, 1] assert process_test_cases(2, [ (0, []), (3, [-1, -2, -3]) ]) == [1, 1]","solution":"def find_smallest_missing_positive(nums): This function finds the smallest positive integer missing from the array. nums = [num for num in nums if num > 0] nums = set(nums) missing = 1 while missing in nums: missing += 1 return missing def process_test_cases(T, test_cases): This function processes multiple test cases and returns a list of results for each test case. results = [] for test_case in test_cases: n, nums = test_case result = find_smallest_missing_positive(nums) results.append(result) return results"},{"question":"def magical_garden(n: int, q: int, powers: List[int], queries: List[Tuple[int, ...]]) -> List[int]: Perform operations on the list of flower powers and return results of minimum queries. :param n: Number of flowers :param q: Number of queries :param powers: Initial power levels of each flower :param queries: List of queries to perform :return: Results of type 2 queries >>> magical_garden(5, 6, [1, 5, 3, 4, 2], [(2, 3), (1, 1, 3, 1), (2, 4), (1, 2, 5, 2), (2, 5), (2, 1)]) [1, 2, 2, 2] >>> magical_garden(3, 1, [2, 1, 3], [(2, 3)]) [1] >>> magical_garden(4, 4, [1, 2, 3, 4], [(1, 1, 4, 1), (2, 4), (1, 1, 4, 2), (2, 4)]) [2, 4] >>> magical_garden(4, 3, [1, 2, 3, 4], [(2, 1), (2, 2), (2, 4)]) [1, 1, 1] >>> magical_garden(3, 3, [10**9, 10**9, 10**9], [(2, 2), (1, 1, 3, -10**9), (2, 3)]) [10**9, 0] >>> magical_garden(1, 1, [5], [(2, 1)]) [5]","solution":"def magical_garden(n, q, powers, queries): Perform operations on the list of flower powers and return results of minimum queries. :param n: Number of flowers :param q: Number of queries :param powers: Initial power levels of each flower :param queries: List of queries to perform :return: Results of type 2 queries results = [] for query in queries: if query[0] == 1: l, r, x = query[1] - 1, query[2] - 1, query[3] for i in range(l, r + 1): powers[i] += x elif query[0] == 2: k = query[1] results.append(min(powers[:k])) return results"},{"question":"def sum_of_unique_prime_factors(x: int) -> int: Returns the sum of unique prime factors of the given number x. >>> sum_of_unique_prime_factors(12) 5 >>> sum_of_unique_prime_factors(30) 10 >>> sum_of_unique_prime_factors(45) 8 >>> sum_of_unique_prime_factors(100) 7 >>> sum_of_unique_prime_factors(2) 2 >>> sum_of_unique_prime_factors(49) 7 def process_input(input_str: str) -> list: Processes multiple input cases and returns the results. >>> process_input(\\"4n12n30n45n100\\") [5, 10, 8, 7] >>> process_input(\\"1n49\\") [7]","solution":"def sum_of_unique_prime_factors(x): Returns the sum of unique prime factors of the given number x. def prime_factors(n): factors = set() d = 2 while d * d <= n: while (n % d) == 0: factors.add(d) n //= d d += 1 if n > 1: factors.add(n) return factors primes = prime_factors(x) return sum(primes) def process_input(input_str): input_lines = input_str.strip().split('n') N = int(input_lines[0]) results = [] for i in range(1, N+1): X = int(input_lines[i]) results.append(sum_of_unique_prime_factors(X)) return results"},{"question":"def can_jump_to_last_platform(n: int, heights: List[int]) -> str: Determine if Alex can successfully jump from the first platform to the last platform. >>> can_jump_to_last_platform(5, [1, 2, 3, 2, 1]) \\"Yes\\" >>> can_jump_to_last_platform(5, [1, 3, 5, 5, 6]) \\"No\\"","solution":"def can_jump_to_last_platform(n, heights): for i in range(1, n): if abs(heights[i] - heights[i-1]) > 1: return \\"No\\" return \\"Yes\\" if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() n = int(data[0]) heights = list(map(int, data[1:n+1])) print(can_jump_to_last_platform(n, heights))"},{"question":"def min_insertions_to_palindrome(s: str) -> int: Determines the minimum number of characters to insert into the string to make it a palindrome. :param s: Input string consisting of lowercase English letters. :return: Minimum number of insertions required. Examples: >>> min_insertions_to_palindrome(\\"ab\\") 1 >>> min_insertions_to_palindrome(\\"race\\") 3 >>> min_insertions_to_palindrome(\\"aa\\") 0","solution":"def min_insertions_to_palindrome(s: str) -> int: Determines the minimum number of characters to insert into the string to make it a palindrome. :param s: Input string consisting of lowercase English letters. :return: Minimum number of insertions required. n = len(s) # dp[i][j] will store the minimum number of insertions required to make s[i:j+1] a palindrome dp = [[0] * n for _ in range(n)] # Fill the table for length in range(2, n + 1): for i in range(n - length + 1): j = i + length - 1 if s[i] == s[j]: dp[i][j] = dp[i + 1][j - 1] else: dp[i][j] = min(dp[i + 1][j], dp[i][j - 1]) + 1 # The answer will be dp[0][n-1] return dp[0][n-1]"},{"question":"def max_fertile_square(n: int, m: int, field: List[str]) -> int: Determine the size of the largest square plot of fertile land. >>> max_fertile_square(5, 6, [\\"101010\\", \\"111111\\", \\"111110\\", \\"111110\\", \\"111000\\"]) 9 >>> max_fertile_square(4, 4, [\\"1010\\", \\"1111\\", \\"1011\\", \\"1011\\"]) 4","solution":"def max_fertile_square(n, m, field): if n == 0 or m == 0: return 0 dp = [[0] * m for _ in range(n)] max_side = 0 for i in range(n): for j in range(m): if field[i][j] == '1': if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side = max(max_side, dp[i][j]) return max_side * max_side def max_fertile_square_from_input(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) m = int(data[1]) field = data[2:] print(max_fertile_square(n, m, field))"},{"question":"def is_point_in_polygon(n: int, vertices: List[Tuple[int, int]], px: int, py: int) -> str: Determines if a point (px, py) is inside a polygon defined by vertices. >>> is_point_in_polygon(4, [(0, 0), (4, 0), (4, 4), (0, 4)], 2, 2) \\"INSIDE\\" >>> is_point_in_polygon(3, [(0, 0), (4, 0), (2, 4)], 5, 2) \\"OUTSIDE\\" pass def parse_input(input_string: str) -> Tuple[int, List[Tuple[int, int]], int, int]: Parses the input string and returns the number of vertices, the list of vertices and the point (px, py). >>> parse_input(\\"4n0 0n4 0n4 4n0 4n2 2n\\") (4, [(0, 0), (4, 0), (4, 4), (0, 4)], 2, 2) >>> parse_input(\\"3n0 0n4 0n2 4n5 2n\\") (3, [(0, 0), (4, 0), (2, 4)], 5, 2) pass from typing import List, Tuple def test_case_1(): input_string = \\"4n0 0n4 0n4 4n0 4n2 2n\\" n, vertices, px, py = parse_input(input_string) assert is_point_in_polygon(n, vertices, px, py) == \\"INSIDE\\" def test_case_2(): input_string = \\"3n0 0n4 0n2 4n5 2n\\" n, vertices, px, py = parse_input(input_string) assert is_point_in_polygon(n, vertices, px, py) == \\"OUTSIDE\\" def test_case_3(): input_string = \\"5n0 0n5 0n6 4n4 5n0 4n3 3n\\" n, vertices, px, py = parse_input(input_string) assert is_point_in_polygon(n, vertices, px, py) == \\"INSIDE\\" def test_case_4(): input_string = \\"4n0 0n2 0n2 2n0 2n3 3n\\" n, vertices, px, py = parse_input(input_string) assert is_point_in_polygon(n, vertices, px, py) == \\"OUTSIDE\\" def test_case_5(): input_string = \\"6n0 0n2 0n2 2n1 3n0 2n-1 3n0 1n\\" n, vertices, px, py = parse_input(input_string) assert is_point_in_polygon(n, vertices, px, py) == \\"INSIDE\\"","solution":"def is_point_in_polygon(n, vertices, px, py): Determines if a point (px, py) is inside a polygon defined by vertices. Uses the ray-casting algorithm to determine the result. Parameters: n (int): The number of vertices in the polygon. vertices (list of tuple): List of tuples representing the polygon vertices. px (int): x-coordinate of the point to check. py (int): y-coordinate of the point to check. Returns: str: \\"INSIDE\\" if the point is inside the polygon, \\"OUTSIDE\\" otherwise. count = 0 j = n - 1 for i in range(n): xi, yi = vertices[i] xj, yj = vertices[j] if ((yi > py) != (yj > py)) and (px < (xj - xi) * (py - yi) / (yj - yi) + xi): count += 1 j = i return \\"INSIDE\\" if count % 2 == 1 else \\"OUTSIDE\\" def parse_input(input_string): input_lines = input_string.strip().split('n') n = int(input_lines[0]) vertices = [tuple(map(int, line.split())) for line in input_lines[1:n+1]] px, py = map(int, input_lines[n+1].split()) return n, vertices, px, py"},{"question":"def find_duplicate(nums): Returns the first duplicate number from the array. :param nums: List of integers. :return: The first duplicate number, or None if there are no duplicates. >>> find_duplicate([1, 2, 3, 4, 5, 3, 6]) == 3 >>> find_duplicate([1, 2, 3, 4, 5]) == None >>> find_duplicate([5, 1, 2, 3, 5]) == 5 >>> find_duplicate([]) == None >>> find_duplicate([1]) == None >>> find_duplicate([-1, -2, -3, -4, -1]) == -1 >>> find_duplicate([1, -1, 2, -2, -1]) == -1 >>> find_duplicate([5, -1, 5, 0, 4]) == 5 >>> find_duplicate([1, 2, 3, 2, 1]) == 2","solution":"def find_duplicate(nums): Returns the first duplicate number from the array. :param nums: List of integers. :return: The first duplicate number, or None if there are no duplicates. seen = set() for num in nums: if num in seen: return num seen.add(num) return None"},{"question":"def searchMatrix(matrix, m, n, X): Determines if X is present in the m x n 2D matrix. Each row is sorted in ascending order from left to right and the first element of each row is greater than the last element of the previous row. Args: matrix (List[List[int]]): 2D matrix to search in. m (int): Number of rows in the matrix. n (int): Number of columns in the matrix. X (int): Element to search for. Returns: int: 1 if X is present in the matrix, otherwise -1. import pytest def test_searchMatrix_found(): matrix = [ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 60] ] m = 3 n = 4 X = 16 assert searchMatrix(matrix, m, n, X) == 1 def test_searchMatrix_not_found(): matrix = [ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 60] ] m = 3 n = 4 X = 9 assert searchMatrix(matrix, m, n, X) == -1 def test_searchMatrix_single_element_found(): matrix = [ [42] ] m = 1 n = 1 X = 42 assert searchMatrix(matrix, m, n, X) == 1 def test_searchMatrix_single_element_not_found(): matrix = [ [43] ] m = 1 n = 1 X = 42 assert searchMatrix(matrix, m, n, X) == -1 def test_searchMatrix_large_not_found(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] m = 3 n = 3 X = 10 assert searchMatrix(matrix, m, n, X) == -1 def test_searchMatrix_edge_value(): matrix = [ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 60] ] m = 3 n = 4 X = 60 assert searchMatrix(matrix, m, n, X) == 1","solution":"def searchMatrix(matrix, m, n, X): Determines if X is present in the m x n 2D matrix. Each row is sorted in ascending order from left to right and the first element of each row is greater than the last element of the previous row. Args: matrix (List[List[int]]): 2D matrix to search in. m (int): Number of rows in the matrix. n (int): Number of columns in the matrix. X (int): Element to search for. Returns: int: 1 if X is present in the matrix, otherwise -1. # Binary search in a flattened matrix context left, right = 0, m * n - 1 while left <= right: mid = (left + right) // 2 mid_value = matrix[mid // n][mid % n] if mid_value == X: return 1 elif mid_value < X: left = mid + 1 else: right = mid - 1 return -1"},{"question":"def min_time_slots(num_students: int, num_subjects: int, student_subjects: List[List[int]]) -> int: Determine the minimum number of distinct time slots needed to schedule all exams without any conflicts. Args: num_students (int): Number of students. num_subjects (int): Number of subjects. student_subjects (List[List[int]]): List of lists where each list contains subject IDs for a student. Returns: int: Minimum number of distinct time slots needed. >>> min_time_slots(4, 5, [[1, 2, 3], [1, 4], [2, 4, 5], [3, 5]]) 3 >>> min_time_slots(3, 3, [[1, 2], [2, 3], [1, 3]]) 3 >>> min_time_slots(2, 2, [[1], [2]]) 1 >>> min_time_slots(5, 4, [[1, 2], [3], [4], [1, 2, 3, 4], [1, 3, 4]]) 4","solution":"def min_time_slots(num_students, num_subjects, student_subjects): # Step 1: Initialize an adjacency matrix for the graph of subjects adj_matrix = [[0] * num_subjects for _ in range(num_subjects)] # Step 2: Fill the adjacency matrix based on student enrollment for subjects in student_subjects: for i in range(len(subjects)): for j in range(i + 1, len(subjects)): adj_matrix[subjects[i] - 1][subjects[j] - 1] = 1 adj_matrix[subjects[j] - 1][subjects[i] - 1] = 1 # Step 3: Define a function to check if a coloring assignment for a subject is valid def is_valid_color(subject, color, assignment): for i in range(num_subjects): if adj_matrix[subject][i] and assignment[i] == color: return False return True # Step 4: Define a recursive utility function to color the graph using minimum colors def graph_coloring_util(subject, assignment, colors): if subject == num_subjects: return True for color in range(1, colors + 1): if is_valid_color(subject, color, assignment): assignment[subject] = color if graph_coloring_util(subject + 1, assignment, colors): return True assignment[subject] = 0 return False # Step 5: Find the minimum number of colors required assignment = [0] * num_subjects for colors in range(1, num_subjects + 1): if graph_coloring_util(0, assignment, colors): return colors return num_subjects # Sample input for manual testing (if needed) num_students = 4 num_subjects = 5 student_subjects = [ [1, 2, 3], [1, 4], [2, 4, 5], [3, 5], ] # Expected output: 3 print(min_time_slots(num_students, num_subjects, student_subjects))"},{"question":"def min_subarray_length(nums, k): Returns the length of the shortest contiguous subarray whose sum is greater than or equal to k. If no such subarray exists, return 0. Example: >>> min_subarray_length([2, 3, 1, 2, 4, 3], 7) 2 >>> min_subarray_length([1, 4, 4], 4) 1 >>> min_subarray_length([1, 1, 1, 1, 1, 1, 1, 1], 11) 0","solution":"def min_subarray_length(nums, k): Returns the length of the shortest contiguous subarray whose sum is greater than or equal to k. If no such subarray exists, return 0. n = len(nums) min_length = float('inf') current_sum = 0 left = 0 for right in range(n): current_sum += nums[right] while current_sum >= k: min_length = min(min_length, right - left + 1) current_sum -= nums[left] left += 1 return min_length if min_length != float('inf') else 0"},{"question":"class Node: def __init__(self, value): self.value = value self.left = None self.right = None def is_valid_bst(node: Node) -> bool: Determine whether a binary tree is a valid Binary Search Tree (BST). >>> root = Node(4) >>> root.left = Node(2) >>> root.right = Node(5) >>> root.left.left = Node(1) >>> root.left.right = Node(3) >>> is_valid_bst(root) True >>> root = Node(4) >>> root.left = Node(2) >>> root.right = Node(5) >>> root.left.left = Node(1) >>> root.left.right = Node(6) >>> is_valid_bst(root) False >>> root = Node(1) >>> is_valid_bst(root) True >>> is_valid_bst(None) True","solution":"class Node: def __init__(self, value): self.value = value self.left = None self.right = None def is_valid_bst(node, min_value=float('-inf'), max_value=float('inf')): if node is None: return True if not (min_value < node.value < max_value): return False return (is_valid_bst(node.left, min_value, node.value) and is_valid_bst(node.right, node.value, max_value))"},{"question":"def has_unique_characters(s: str) -> bool: Determines if a string has all unique characters. Args: s (str): The input string. Returns: bool: True if all characters are unique, False otherwise. >>> has_unique_characters(\\"abcdef\\") == True >>> has_unique_characters(\\"abcdea\\") == False >>> has_unique_characters(\\"a\\") == True >>> has_unique_characters(\\"\\") == True >>> has_unique_characters(\\"aA\\") == True >>> has_unique_characters(\\"abc123!@#\\") == True >>> has_unique_characters(\\"abc123!@#a\\") == False","solution":"def has_unique_characters(s): Determines if a string has all unique characters. Args: s (str): The input string. Returns: bool: True if all characters are unique, False otherwise. for i in range(len(s)): for j in range(i + 1, len(s)): if s[i] == s[j]: return False return True"},{"question":"def factorial(n: int) -> int: Returns the factorial of n if 0 <= n <= 12, otherwise return \\"Input out of range\\". >>> factorial(5) 120 >>> factorial(13) \\"Input out of range\\"","solution":"def factorial(n): Returns the factorial of n if 0 <= n <= 12, otherwise return \\"Input out of range\\". if n < 0 or n > 12: return \\"Input out of range\\" result = 1 for i in range(1, n + 1): result *= i return result"},{"question":"def reorganize_string(s: str) -> str: Reorganize the string such that no two adjacent characters are the same. >>> reorganize_string(\\"aab\\") \\"aba\\" >>> reorganize_string(\\"abc\\") \\"abc\\" >>> reorganize_string(\\"aaab\\") \\"\\"","solution":"from collections import Counter import heapq def reorganize_string(s: str) -> str: Reorganize the string such that no two adjacent characters are the same. # Count the frequency of each character frequency = Counter(s) max_heap = [] # Push all characters along with their frequencies into a max heap for char, freq in frequency.items(): heapq.heappush(max_heap, (-freq, char)) prev_freq, prev_char = 0, '' result = [] # Process the heap while max_heap: freq, char = heapq.heappop(max_heap) result.append(char) # If there's a previous character to be pushed back into the heap if prev_freq < 0: heapq.heappush(max_heap, (prev_freq, prev_char)) # Update the previous character's frequency prev_freq, prev_char = freq + 1, char reorganized_string = ''.join(result) # If the reorganized string length is equal to the input string length, return it if len(reorganized_string) == len(s): return reorganized_string else: return \\"\\""},{"question":"import re class EmailOrganizer: def __init__(self): Initialize the EmailOrganizer with necessary data structures. pass def add_email(self, email: str) -> bool: Add an email address to the system if it is valid and not already present. Args: - email (str): The email address to add. Returns: - bool: True if the email was successfully added, False otherwise. pass def remove_email(self, email: str) -> bool: Remove an email address from the system if it exists. Args: - email (str): The email address to remove. Returns: - bool: True if the email was successfully removed, False otherwise. pass def get_emails_by_domain(self, domain: str) -> list: Get all email addresses belonging to a specific domain. Args: - domain (str): The domain to query. Returns: - list: A list of email addresses belonging to the domain, sorted alphabetically. pass def get_domains(self) -> list: Get all unique domains present in the system. Returns: - list: A list of unique domains, sorted alphabetically. pass # Example usage: organizer = EmailOrganizer() print(organizer.add_email(\\"user1@example.com\\")) # True print(organizer.add_email(\\"user2@example.com\\")) # True print(organizer.add_email(\\"INVALID@EMAIL\\")) # False from solution import EmailOrganizer def test_add_email(): organizer = EmailOrganizer() assert organizer.add_email(\\"user1@example.com\\") assert organizer.add_email(\\"user2@example.com\\") assert not organizer.add_email(\\"INVALID@EMAIL\\") assert not organizer.add_email(\\"user1@example.com\\") # duplicate assert organizer.add_email(\\"user1@domain.com\\") assert organizer.add_email(\\"user3@example.org\\") def test_remove_email(): organizer = EmailOrganizer() organizer.add_email(\\"user1@example.com\\") assert organizer.remove_email(\\"user1@example.com\\") assert not organizer.remove_email(\\"user1@example.com\\") # already removed assert not organizer.remove_email(\\"user2@example.com\\") # never existed organizer.add_email(\\"user2@example.com\\") assert organizer.remove_email(\\"user2@example.com\\") def test_get_emails_by_domain(): organizer = EmailOrganizer() organizer.add_email(\\"user1@example.com\\") organizer.add_email(\\"user2@example.com\\") organizer.add_email(\\"user1@domain.com\\") organizer.add_email(\\"user3@example.org\\") assert organizer.get_emails_by_domain(\\"example.com\\") == [\\"user1@example.com\\", \\"user2@example.com\\"] assert organizer.get_emails_by_domain(\\"domain.com\\") == [\\"user1@domain.com\\"] assert organizer.get_emails_by_domain(\\"example.org\\") == [\\"user3@example.org\\"] assert organizer.get_emails_by_domain(\\"nonexistent.com\\") == [] def test_get_domains(): organizer = EmailOrganizer() organizer.add_email(\\"user1@example.com\\") organizer.add_email(\\"user2@example.com\\") organizer.add_email(\\"user1@domain.com\\") organizer.add_email(\\"user3@example.org\\") assert organizer.get_domains() == [\\"domain.com\\", \\"example.com\\", \\"example.org\\"] organizer.remove_email(\\"user1@example.com\\") organizer.remove_email(\\"user2@example.com\\") assert organizer.get_domains() == [\\"domain.com\\", \\"example.org\\"]","solution":"import re class EmailOrganizer: def __init__(self): self.emails = set() self.domains = {} self.email_regex = re.compile(r'^[^@]+@[^@]+.[^@]+') def add_email(self, email): email = email.lower() if not self.email_regex.match(email): return False if email in self.emails: return False self.emails.add(email) local_part, domain = email.split('@') if domain not in self.domains: self.domains[domain] = set() self.domains[domain].add(email) return True def remove_email(self, email): email = email.lower() if email not in self.emails: return False self.emails.remove(email) local_part, domain = email.split('@') if domain in self.domains: self.domains[domain].remove(email) if not self.domains[domain]: del self.domains[domain] return True def get_emails_by_domain(self, domain): domain = domain.lower() if domain not in self.domains: return [] return sorted(self.domains[domain]) def get_domains(self): return sorted(self.domains.keys())"},{"question":"def max_subarray_sum(n, array): Returns the maximum sum of any contiguous subarray. Args: n (int): the size of the array. array (list of ints): the array of integers. Returns: int: the maximum sum of any contiguous subarray. >>> max_subarray_sum(4, [1, -2, 3, 5]) 8 >>> max_subarray_sum(5, [-1, -2, -3, -4, -5]) -1 >>> max_subarray_sum(3, [2, 3, -2]) 5 def process_test_cases(t, test_cases): Processes multiple test cases. Args: t (int): the number of test cases. test_cases (list of tuples): list of test cases, where each test case is a tuple (n, array). Returns: list: a list containing results for each test case. >>> process_test_cases(3, [(4, [1, -2, 3, 5]), (5, [-1, -2, -3, -4, -5]), (3, [2, 3, -2])]) [8, -1, 5]","solution":"def max_subarray_sum(n, array): Returns the maximum sum of any contiguous subarray. Args: n (int): the size of the array. array (list of ints): the array of integers. Returns: int: the maximum sum of any contiguous subarray. max_ending_here = array[0] max_so_far = array[0] for i in range(1, n): max_ending_here = max(array[i], max_ending_here + array[i]) max_so_far = max(max_so_far, max_ending_here) return max_so_far def process_test_cases(t, test_cases): Processes multiple test cases. Args: t (int): the number of test cases. test_cases (list of tuples): list of test cases, where each test case is a tuple (n, array). Returns: list: a list containing results for each test case. results = [] for n, array in test_cases: result = max_subarray_sum(n, array) results.append(result) return results"},{"question":"def print_x_pattern(n: int) -> List[str]: Prints an 'X' pattern using the '#' symbol that spans \`n\` rows. Parameters: n (int): The number of rows for the 'X' pattern. Must be an odd integer. Returns: List of strings: The 'X' pattern where each string represents a row. >>> print_x_pattern(3) [\\"# #\\", \\" # \\", \\"# #\\"] >>> print_x_pattern(4) [\\"# #\\", \\" \\", \\" \\", \\"# #\\"] >>> print_x_pattern(5) [\\"# #\\", \\" # # \\", \\" # \\", \\" # # \\", \\"# #\\"] from solution import print_x_pattern def test_x_pattern_3(): output = print_x_pattern(3) expected = [ \\"# #\\", \\" # \\", \\"# #\\" ] assert output == expected def test_x_pattern_4(): output = print_x_pattern(4) expected = [ \\"# #\\", \\" \\", \\" \\", \\"# #\\" ] assert output == expected def test_x_pattern_5(): output = print_x_pattern(5) expected = [ \\"# #\\", \\" # # \\", \\" # \\", \\" # # \\", \\"# #\\" ] assert output == expected def test_x_pattern_6(): output = print_x_pattern(6) expected = [ \\"# #\\", \\" # # \\", \\" \\", \\" \\", \\" # # \\", \\"# #\\" ] assert output == expected def test_x_pattern_7(): output = print_x_pattern(7) expected = [ \\"# #\\", \\" # # \\", \\" # # \\", \\" # \\", \\" # # \\", \\" # # \\", \\"# #\\" ] assert output == expected","solution":"def print_x_pattern(n): Prints an 'X' pattern using the '#' symbol that spans \`n\` rows. Parameters: n (int): The number of rows for the 'X' pattern. Must be an odd integer. Returns: List of strings: The 'X' pattern where each string represents a row. pattern = [] for i in range(n): row = \\"\\" for j in range(n): if j == i or j == n - i - 1: row += \\"#\\" else: row += \\" \\" pattern.append(row) return pattern"},{"question":"def min_cost_climbing_stairs(cost): Calculate the minimum cost to reach the top of the staircase given a cost array. Parameters: cost (List[int]): List of non-negative integers representing the cost of each step. Returns: int: Minimum cost to reach the top of the staircase. Examples: >>> min_cost_climbing_stairs([10, 15, 20, 25, 30]) 40 >>> min_cost_climbing_stairs([1, 100, 1]) 2 >>> min_cost_climbing_stairs([10, 15, 20, 10]) 25 >>> min_cost_climbing_stairs([10, 15]) 10 >>> min_cost_climbing_stairs([1, 3, 5, 20]) 6 pass def solve_test_cases(test_cases): Solve multiple test cases of the min_cost_climbing_stairs problem. Parameters: test_cases (List[List[int]]): List of test cases, where each test case is a list of step costs. Returns: List[int]: List of results for each test case. Examples: >>> solve_test_cases([[10, 15, 20, 25, 30], [1, 100, 1], [10, 15, 20, 10]]) [40, 2, 25] >>> solve_test_cases([[10, 15], [1, 3, 5, 20]]) [10, 6] pass import pytest def test_min_cost_climbing_stairs(): assert min_cost_climbing_stairs([10, 15, 20, 25, 30]) == 40 assert min_cost_climbing_stairs([1, 100, 1]) == 2 assert min_cost_climbing_stairs([10, 15, 20, 10]) == 25 assert min_cost_climbing_stairs([10, 15]) == 10 assert min_cost_climbing_stairs([1, 3, 5, 20]) == 6 def test_solve_test_cases(): assert solve_test_cases([[10, 15, 20, 25, 30], [1, 100, 1], [10, 15, 20, 10]]) == [40, 2, 25] assert solve_test_cases([[10, 15], [1, 3, 5, 20]]) == [10, 6]","solution":"def min_cost_climbing_stairs(cost): Calculate the minimum cost to reach the top of the staircase given a cost array. n = len(cost) if n == 2: return min(cost[0], cost[1]) dp = [0] * n dp[0], dp[1] = cost[0], cost[1] for i in range(2, n): dp[i] = cost[i] + min(dp[i-1], dp[i-2]) return min(dp[n-1], dp[n-2]) def solve_test_cases(test_cases): results = [] for cost in test_cases: results.append(min_cost_climbing_stairs(cost)) return results"},{"question":"from typing import List def two_sum(nums: List[int], target: int) -> List[int]: Returns the indices of the two numbers such that they add up to target. Args: nums (List[int]): The list of integers. target (int): The target sum. Returns: List[int]: List containing the indices of the two numbers. >>> two_sum([2, 7, 11, 15], 9) [0, 1] >>> two_sum([1, 2, 3, 4, 5], 9) [3, 4] >>> two_sum([-3, 4, 3, 90], 0) [0, 2] >>> two_sum([0, 4, 3, 0], 0) [0, 3] >>> two_sum([1000000, -1000000], 0) [0, 1] pass","solution":"from typing import List def two_sum(nums: List[int], target: int) -> List[int]: Returns the indices of the two numbers such that they add up to target. Args: nums (List[int]): The list of integers. target (int): The target sum. Returns: List[int]: List containing the indices of the two numbers. num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return sorted([num_to_index[complement], i]) num_to_index[num] = i"},{"question":"from typing import List def filter_repeated_digits(numbers: List[int]) -> List[int]: Takes a list of integers and returns a list containing all the integers that have at least one of their digits repeated. >>> filter_repeated_digits([123, 112, 456, 998, 789]) [112, 998] >>> filter_repeated_digits([9876543210, 1234567890, 111222333, 444555666, 12321]) [111222333, 444555666, 12321]","solution":"def has_repeated_digits(n): Helper function to determine if the given integer has any repeated digits. digits = {} n = abs(n) # Handle negative numbers by taking the absolute value while n > 0: digit = n % 10 if digit in digits: return True digits[digit] = 1 n //= 10 return False def filter_repeated_digits(numbers): Takes a list of integers and returns a list containing all the integers that have at least one of their digits repeated. return [num for num in numbers if has_repeated_digits(num)]"},{"question":"def word_ladder(start, end, word_list, find_shortest=True): Transform the start word into the end word using the shortest sequence of valid intermediate words from the given dictionary. Args: start (str): The starting word. end (str): The ending word. word_list (list of str): The dictionary's word list. find_shortest (bool, optional): Flag to find the shortest path. Defaults to True. Returns: list of str: Sequence of words forming the shortest transformation from start to end. If no transformation is possible, return an empty list. Examples: >>> word_list = [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\", \\"cog\\"] >>> word_ladder(\\"hit\\", \\"cog\\", word_list) [\\"hit\\", \\"hot\\", \\"dot\\", \\"dog\\", \\"cog\\"] >>> word_list = [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\"] >>> word_ladder(\\"hit\\", \\"cog\\", word_list) [] pass # Test cases def test_word_ladder_example1(): word_list = [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\", \\"cog\\"] assert word_ladder(\\"hit\\", \\"cog\\", word_list) == [\\"hit\\", \\"hot\\", \\"dot\\", \\"dog\\", \\"cog\\"] def test_word_ladder_example2(): word_list = [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\"] assert word_ladder(\\"hit\\", \\"cog\\", word_list) == [] def test_word_ladder_no_possible_transformation(): word_list = [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\"] assert word_ladder(\\"hit\\", \\"cat\\", word_list) == [] def test_word_ladder_single_step(): word_list = [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\"] assert word_ladder(\\"hit\\", \\"hot\\", word_list) == [\\"hit\\", \\"hot\\"] def test_word_ladder_no_valid_path(): word_list = [\\"a\\", \\"b\\", \\"c\\"] assert word_ladder(\\"a\\", \\"c\\", [\\"z\\"]) == [] def test_word_ladder_find_any_path(): word_list = [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\", \\"cog\\"] path = word_ladder(\\"hit\\", \\"cog\\", word_list, find_shortest=False) assert path[0] == \\"hit\\" and path[-1] == \\"cog\\"","solution":"from collections import deque def word_ladder(start, end, word_list, find_shortest=True): if end not in word_list: return [] word_set = set(word_list) queue = deque([(start, [start])]) visited = set([start]) while queue: current_word, path = queue.popleft() if current_word == end: return path for i in range(len(current_word)): for c in 'abcdefghijklmnopqrstuvwxyz': next_word = current_word[:i] + c + current_word[i+1:] if next_word in word_set and next_word not in visited: visited.add(next_word) queue.append((next_word, path + [next_word])) return []"},{"question":"def door_states(commands: str) -> str: Given a binary string representing the command sequence for the doors, returns binary string representing the state of the doors after the commands. >>> door_states(\\"110\\") \\"110\\" >>> door_states(\\"101\\") \\"100\\" >>> door_states(\\"11110\\") \\"11110\\" >>> door_states(\\"000\\") \\"000\\" >>> door_states(\\"111\\") \\"111\\" >>> door_states(\\"001\\") \\"000\\" >>> door_states(\\"10001\\") \\"10000\\" >>> door_states(\\"000000\\") \\"000000\\" >>> door_states(\\"111111\\") \\"111111\\" pass def solve(T: int, command_sequences: List[str]) -> List[str]: Processes multiple test cases and returns the results for each as a list of strings. >>> solve(3, [\\"110\\", \\"101\\", \\"11110\\"]) [\\"110\\", \\"100\\", \\"11110\\"] >>> solve(2, [\\"000\\", \\"111\\"]) [\\"000\\", \\"111\\"] >>> solve(1, [\\"001\\"]) [\\"000\\"] >>> solve(1, [\\"10001\\"]) [\\"10000\\"] >>> solve(2, [\\"000000\\", \\"111111\\"]) [\\"000000\\", \\"111111\\"] pass","solution":"def door_states(commands): Given a binary string representing the command sequence for the doors, returns binary string representing the state of the doors after the commands. result = [] can_open = True for command in commands: if can_open and command == '1': result.append('1') else: result.append('0') can_open = False return ''.join(result) def solve(T, command_sequences): Processes multiple test cases and returns the results for each as a list of strings. results = [] for commands in command_sequences: results.append(door_states(commands)) return results"},{"question":"import math from typing import List def is_prime(n: int) -> bool: Determines if a number n is prime. Returns True if n is a prime number, otherwise False. pass def check_primes(numbers: List[int]) -> List[str]: Takes a list of integers and returns a list of strings indicating whether each number is \\"Prime\\" or \\"Not Prime\\". >>> check_primes([10, 29, 7, 1, 0]) ['Not Prime', 'Prime', 'Prime', 'Not Prime', 'Not Prime'] >>> check_primes([31, 33, 1, 117, 101]) ['Prime', 'Not Prime', 'Not Prime', 'Not Prime', 'Prime'] pass from solution import is_prime, check_primes def test_is_prime(): assert is_prime(2) == True, \\"2 is a prime number\\" assert is_prime(3) == True, \\"3 is a prime number\\" assert is_prime(4) == False, \\"4 is not a prime number\\" assert is_prime(29) == True, \\"29 is a prime number\\" assert is_prime(1) == False, \\"1 is not a prime number\\" assert is_prime(0) == False, \\"0 is not a prime number\\" assert is_prime(10**6 + 3) == True, \\"1000003 is a prime number\\" def test_check_primes(): assert check_primes([10, 29, 7, 1, 0]) == [ \\"Not Prime\\", \\"Prime\\", \\"Prime\\", \\"Not Prime\\", \\"Not Prime\\" ], \\"Test case 1 failed\\" assert check_primes([31, 33, 1, 117, 101]) == [ \\"Prime\\", \\"Not Prime\\", \\"Not Prime\\", \\"Not Prime\\", \\"Prime\\" ], \\"Test case 2 failed\\" assert check_primes([]) == [], \\"Empty list should return empty list\\"","solution":"import math def is_prime(n): Determines if a number n is prime. Returns True if n is a prime number, otherwise False. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False limit = math.isqrt(n) for i in range(3, limit + 1, 2): if n % i == 0: return False return True def check_primes(numbers): Takes a list of integers and returns a list of strings indicating whether each number is \\"Prime\\" or \\"Not Prime\\". results = [] for number in numbers: if is_prime(number): results.append(\\"Prime\\") else: results.append(\\"Not Prime\\") return results"},{"question":"def next_permutation(nums): Modify list nums to its next permutation in-place. Arguments: nums : List[int] : List of integers representing the heights of books. Returns: List[int] : The next permutation of the given list of integers. Example: >>> next_permutation([1, 2, 3]) [1, 3, 2] >>> next_permutation([3, 2, 1]) [1, 2, 3] >>> next_permutation([1, 1, 5]) [1, 5, 1] # Write your code here def process_test_cases(T, cases): Process multiple test cases for next_permutation function. Arguments: T : int : Number of test cases cases : List[List[int]] : List of test cases where each case is a list of integers Returns: List[List[int]] : List of results for each test case Example: >>> process_test_cases(3, [[1, 2, 3], [3, 2, 1], [1, 1, 5]]) [[1, 3, 2], [1, 2, 3], [1, 5, 1]] # Write your code here","solution":"def next_permutation(nums): Modify list nums to its next permutation in-place. n = len(nums) # Step 1: Find the largest index k such that nums[k] < nums[k + 1]. # If no such index exists, the permutation is sorted in descending order, # we simply reverse it to the smallest permutation. k = n - 2 while k >= 0 and nums[k] >= nums[k + 1]: k -= 1 if k < 0: nums.reverse() else: # Step 2: Find the largest index l greater than k such that nums[k] < nums[l] l = n - 1 while l > k and nums[k] >= nums[l]: l -= 1 # Step 3: Swap nums[k] and nums[l] nums[k], nums[l] = nums[l], nums[k] # Step 4: Reverse the sequence from nums[k + 1] to the end nums[k + 1:] = reversed(nums[k + 1:]) return nums def process_test_cases(T, cases): results = [] for case in cases: result = next_permutation(case) results.append(result) return results"},{"question":"def getBooksByGenres(books, query_genres): Returns the list of book titles that belong to at least one of the genres in query_genres. Args: books (list): A list of book dictionaries. query_genres (list): A list of genres to match books against. Returns: list: List of book titles that match the query genres. pass # Example usage if __name__ == \\"__main__\\": books = [ {\\"title\\": \\"Book A\\", \\"genres\\": [\\"fiction\\", \\"mystery\\"]}, {\\"title\\": \\"Book B\\", \\"genres\\": [\\"non-fiction\\", \\"history\\"]}, {\\"title\\": \\"Book C\\", \\"genres\\": [\\"fiction\\", \\"history\\"]}, {\\"title\\": \\"Book D\\", \\"genres\\": [\\"mystery\\", \\"thriller\\"]} ] query_genres = [\\"fiction\\", \\"thriller\\"] # This should return [\\"Book A\\", \\"Book C\\", \\"Book D\\"] print(getBooksByGenres(books, query_genres)) def test_get_books_by_genres(): books = [ {\\"title\\": \\"Book A\\", \\"genres\\": [\\"fiction\\", \\"mystery\\"]}, {\\"title\\": \\"Book B\\", \\"genres\\": [\\"non-fiction\\", \\"history\\"]}, {\\"title\\": \\"Book C\\", \\"genres\\": [\\"fiction\\", \\"history\\"]}, {\\"title\\": \\"Book D\\", \\"genres\\": [\\"mystery\\", \\"thriller\\"]} ] assert getBooksByGenres(books, [\\"fiction\\", \\"thriller\\"]) == [\\"Book A\\", \\"Book C\\", \\"Book D\\"] assert getBooksByGenres(books, [\\"non-fiction\\"]) == [\\"Book B\\"] assert getBooksByGenres(books, [\\"mystery\\"]) == [\\"Book A\\", \\"Book D\\"] assert getBooksByGenres(books, [\\"history\\"]) == [\\"Book B\\", \\"Book C\\"] assert getBooksByGenres(books, [\\"sci-fi\\"]) == [] assert getBooksByGenres(books, [\\"thriller\\", \\"fiction\\"]) == [\\"Book A\\", \\"Book C\\", \\"Book D\\"] assert getBooksByGenres(books, [\\"mystery\\", \\"history\\"]) == [\\"Book A\\", \\"Book B\\", \\"Book C\\", \\"Book D\\"] def test_no_books_matching_genres(): books = [ {\\"title\\": \\"Book E\\", \\"genres\\": [\\"romance\\"]}, {\\"title\\": \\"Book F\\", \\"genres\\": [\\"comedy\\"]}, ] assert getBooksByGenres(books, [\\"sci-fi\\"]) == [] assert getBooksByGenres(books, [\\"action\\", \\"adventure\\"]) == []","solution":"def getBooksByGenres(books, query_genres): Returns the list of book titles that belong to at least one of the genres in query_genres. Args: books (list): A list of book dictionaries. query_genres (list): A list of genres to match books against. Returns: list: List of book titles that match the query genres. result = [] for book in books: if any(genre in book['genres'] for genre in query_genres): result.append(book['title']) return result"},{"question":"def rob(nums: List[int]) -> int: Given an array nums containing n integers where the element at index i represents the amount of money in the i-th house, you are a thief planning to rob houses along a street. You cannot rob two adjacent houses due to security systems. Return the maximum amount of money you can rob tonight without alerting the police. >>> rob([1, 2, 3, 1]) 4 >>> rob([2, 7, 9, 3, 1]) 12","solution":"from typing import List def rob(nums: List[int]) -> int: if not nums: return 0 if len(nums) == 1: return nums[0] dp = [0] * len(nums) dp[0] = nums[0] dp[1] = max(nums[0], nums[1]) for i in range(2, len(nums)): dp[i] = max(dp[i - 1], dp[i - 2] + nums[i]) return dp[-1]"},{"question":"from typing import List def shortest_path(grid: List[List[int]]) -> int: Find the shortest path in terms of number of steps from the top-left corner of the grid to the bottom-right corner. Each step must move to an adjacent sensor (up, down, left, or right) that has a non-critical status. A non-critical sensor is designated by the value \`0\`, and a critical sensor (which cannot be traversed) is designated by the value \`1\`. Args: grid (List[List[int]]): 2D list representing the grid where \`0\` denotes a non-critical sensor and \`1\` denotes a critical sensor. Returns: int: The minimum number of steps from the top-left to the bottom-right sensor, or \`-1\` if it is not possible. >>> shortest_path([ ... [0, 0, 0, 0, 1], ... [0, 1, 1, 0, 0], ... [0, 0, 0, 0, 0], ... [0, 1, 1, 1, 0], ... [0, 0, 0, 0, 0] ... ]) 8 >>> shortest_path([ ... [0, 1, 1, 1, 1], ... [1, 1, 1, 1, 0], ... [1, 1, 1, 1, 0], ... [1, 1, 1, 1, 0], ... [0, 0, 0, 0, 0] ... ]) -1","solution":"from collections import deque def shortest_path(grid): M = len(grid) N = len(grid[0]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(0, 0, 0)]) # (x, y, steps) visited = set((0, 0)) while queue: x, y, steps = queue.popleft() if (x, y) == (M-1, N-1): return steps for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < M and 0 <= ny < N and grid[nx][ny] == 0 and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, steps+1)) return -1"},{"question":"from typing import Tuple def rearrange_string(s: str) -> Tuple[str, str]: Create a special string by rearranging the characters of the given string so that no two adjacent characters are the same. If it's not possible, return \\"NO\\". >>> rearrange_string(\\"aabb\\") ('YES', 'abab') >>> rearrange_string(\\"aaab\\") ('NO',) >>> rearrange_string(\\"abc\\") ('YES', 'abc')","solution":"import heapq from collections import Counter def rearrange_string(s): # Count the frequency of each character counter = Counter(s) max_frequency = max(counter.values()) # If at any position the maximum frequency is more than half the length of the string rounded up, return NO if max_frequency > (len(s) + 1) // 2: return (\\"NO\\",) # Use a max heap to store characters by their frequencies max_heap = [(-freq, char) for char, freq in counter.items()] heapq.heapify(max_heap) prev_freq, prev_char = 0, \\"\\" result = [] while max_heap: freq, char = heapq.heappop(max_heap) result.append(char) # If there's a previous character, add it back to the heap when it's available (prev_freq < 0) if prev_freq < 0: heapq.heappush(max_heap, (prev_freq, prev_char)) # Store the current character and reduce its frequency prev_freq, prev_char = freq + 1, char return (\\"YES\\", \\"\\".join(result)) # Testing the function print(rearrange_string(\\"aabb\\")) # expects ('YES', 'abab') print(rearrange_string(\\"aaab\\")) # expects ('NO',) print(rearrange_string(\\"abc\\")) # expects ('YES', 'abc')"},{"question":"def custom_sort(alphabet: str, words: List[str]) -> List[str]: Sorts a list of words based on a custom alphabet order. >>> custom_sort(\\"zyxwvutsrqponmlkjihgfedcba\\", [\\"apple\\", \\"banana\\", \\"cat\\"]) [\\"cat\\", \\"banana\\", \\"apple\\"] >>> custom_sort(\\"abcdefghijklmnopqrstuvwxyz\\", [\\"apple\\"]) [\\"apple\\"] >>> custom_sort(\\"zyxwvutsrqponmlkjihgfedcba\\", [\\"a\\", \\"a\\", \\"a\\"]) [\\"a\\", \\"a\\", \\"a\\"] >>> custom_sort(\\"zyxwvutsrqponmlkjihgfedcba\\", [\\"abcd\\", \\"abc\\", \\"ab\\", \\"a\\"]) [\\"a\\", \\"ab\\", \\"abc\\", \\"abcd\\"] >>> custom_sort(\\"abcdefghijklmnopqrstuvwxyz\\", [\\"apple\\", \\"banana\\", \\"cat\\"]) [\\"apple\\", \\"banana\\", \\"cat\\"]","solution":"def custom_sort(alphabet, words): Sorts a list of words based on a custom alphabet order. :param alphabet: A string representing the custom alphabet order. :param words: A list of words to be sorted. :return: A list of words sorted based on the custom alphabet order. # Create a dictionary to map each character to its position in the custom alphabet alphabet_index = {char: idx for idx, char in enumerate(alphabet)} # Define a custom comparison key based on the custom alphabet's order def custom_key(word): return [alphabet_index[char] for char in word] # Sort the words using the custom key sorted_words = sorted(words, key=custom_key) return sorted_words"},{"question":"def character_count(s: str) -> dict: Returns a dictionary with each character in the string as keys and the number of times each character appears in the string as values. Ignore spaces and consider uppercase and lowercase characters as the same. >>> character_count(\\"Hello World\\") {'h': 1, 'e': 1, 'l': 3, 'o': 2, 'w': 1, 'r': 1, 'd': 1} >>> character_count(\\"abc\\") {'a': 1, 'b': 1, 'c': 1} def test_simple_string(): assert character_count(\\"abc\\") == {'a': 1, 'b': 1, 'c': 1} def test_string_with_spaces(): assert character_count(\\"a b c\\") == {'a': 1, 'b': 1, 'c': 1} def test_mixed_case_string(): assert character_count(\\"aAbBcC\\") == {'a': 2, 'b': 2, 'c': 2} def test_complex_string(): assert character_count(\\"Hello World\\") == {'h': 1, 'e': 1, 'l': 3, 'o': 2, 'w': 1, 'r': 1, 'd': 1} def test_empty_string(): assert character_count(\\"\\") == {} def test_string_with_special_characters(): assert character_count(\\"a@b@c!\\") == {'a': 1, 'b': 1, 'c': 1, '@': 2, '!': 1} def test_string_with_numbers(): assert character_count(\\"a1b2c3\\") == {'a': 1, '1': 1, 'b': 1, '2': 1, 'c': 1, '3': 1}","solution":"def character_count(s): Returns a dictionary with each character in the string as keys and the number of times each character appears in the string as values. Ignore spaces and consider uppercase and lowercase characters as the same. s = s.replace(\\" \\", \\"\\").lower() count_dict = {} for char in s: if char in count_dict: count_dict[char] += 1 else: count_dict[char] = 1 return count_dict"},{"question":"def caesar_encrypt(message: str, shift: int) -> str: Encrypts the message using Caesar Cipher technique by shifting each letter by the given shift value. >>> caesar_encrypt(\\"Hello, World!\\", 3) \\"Khoor, Zruog!\\" >>> caesar_encrypt(\\"Attack at dawn!\\", 5) \\"Fyyfhp fy ifbs!\\" pass def caesar_decrypt(encrypted_message: str, shift: int) -> str: Decrypts the message using Caesar Cipher technique by shifting each letter back by the given shift value. >>> caesar_decrypt(\\"Khoor, Zruog!\\", 3) \\"Hello, World!\\" >>> caesar_decrypt(\\"Fyyfhp fy ifbs!\\", 5) \\"Attack at dawn!\\" pass from solution import caesar_encrypt, caesar_decrypt def test_caesar_encrypt(): assert caesar_encrypt(\\"Hello, World!\\", 3) == \\"Khoor, Zruog!\\" assert caesar_encrypt(\\"Attack at dawn!\\", 5) == \\"Fyyfhp fy ifbs!\\" assert caesar_encrypt(\\"Python\\", 13) == \\"Clguba\\" assert caesar_encrypt(\\"abcdefghijklmnopqrstuvwxyz\\", 1) == \\"bcdefghijklmnopqrstuvwxyza\\" assert caesar_encrypt(\\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\", 25) == \\"ZABCDEFGHIJKLMNOPQRSTUVWXY\\" def test_caesar_decrypt(): assert caesar_decrypt(\\"Khoor, Zruog!\\", 3) == \\"Hello, World!\\" assert caesar_decrypt(\\"Fyyfhp fy ifbs!\\", 5) == \\"Attack at dawn!\\" assert caesar_decrypt(\\"Clguba\\", 13) == \\"Python\\" assert caesar_decrypt(\\"bcdefghijklmnopqrstuvwxyza\\", 1) == \\"abcdefghijklmnopqrstuvwxyz\\" assert caesar_decrypt(\\"ZABCDEFGHIJKLMNOPQRSTUVWXY\\", 25) == \\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" def test_caesar_mixed_cases(): assert caesar_encrypt(\\"aBcXyZ\\", 2) == \\"cDeZaB\\" assert caesar_decrypt(\\"cDeZaB\\", 2) == \\"aBcXyZ\\" def test_caesar_non_alpha(): assert caesar_encrypt(\\"1234!@#^%\\", 4) == \\"1234!@#^%\\" assert caesar_decrypt(\\"1234!@#^%\\", 4) == \\"1234!@#^%\\" def test_caesar_edge_cases(): # edge case where shift is a complete rotation assert caesar_encrypt(\\"Hello, World!\\", 26) == \\"Hello, World!\\" assert caesar_decrypt(\\"Hello, World!\\", 26) == \\"Hello, World!\\" # edge case where shift is a large number assert caesar_encrypt(\\"Hello, World!\\", 52) == \\"Hello, World!\\" assert caesar_decrypt(\\"Hello, World!\\", 52) == \\"Hello, World!\\"","solution":"def caesar_encrypt(message: str, shift: int) -> str: def shift_char(c, shift): if 'a' <= c <= 'z': return chr((ord(c) - ord('a') + shift) % 26 + ord('a')) elif 'A' <= c <= 'Z': return chr((ord(c) - ord('A') + shift) % 26 + ord('A')) else: return c return ''.join(shift_char(c, shift) for c in message) def caesar_decrypt(encrypted_message: str, shift: int) -> str: return caesar_encrypt(encrypted_message, -shift)"},{"question":"from typing import List, Tuple def bfs_min_moves(grid: List[str], start: Tuple[int, int], target: Tuple[int, int], n: int, m: int) -> int: Helper function to perform BFS and find the minimum moves. def min_moves_to_target(t: int, test_cases: List[dict]) -> List[int]: Determine the minimum number of moves required for the robot to reach the target position. Inputs: t: An integer representing the number of test cases. test_cases: A list of dictionaries representing each test case. Each dictionary contains: 'grid_size': A tuple (n, m) denoting the number of rows and columns in the grid. 'grid': A list of strings representing the grid. 'start_end': A tuple (r, c, r_t, c_t) representing the initial and target positions of the robot. Outputs: A list of integers where each integer denotes the minimum number of moves required for the robot to reach the target position for each test case. If it is impossible, the value will be -1. def test_min_moves_scenario1(): t = 1 test_cases = [{'grid_size': (3, 3), 'grid': ['...', '.#.', '...'], 'start_end': (1, 1, 3, 3)}] assert min_moves_to_target(t, test_cases) == [4] def test_min_moves_scenario2(): t = 1 test_cases = [{'grid_size': (4, 4), 'grid': ['....', '..', '..#.', '....'], 'start_end': (1, 1, 4, 4)}] assert min_moves_to_target(t, test_cases) == [6] def test_min_moves_impossible(): t = 1 test_cases = [{'grid_size': (3, 3), 'grid': ['...', '#', '...'], 'start_end': (1, 1, 3, 3)}] assert min_moves_to_target(t, test_cases) == [-1] def test_min_moves_start_equals_target(): t = 1 test_cases = [{'grid_size': (3, 3), 'grid': ['...', '...', '...'], 'start_end': (1, 1, 1, 1)}] assert min_moves_to_target(t, test_cases) == [0] def test_min_moves_multiple_scenarios(): t = 2 test_cases = [{'grid_size': (3, 3), 'grid': ['...', '.#.', '...'], 'start_end': (1, 1, 3, 3)}, {'grid_size': (4, 4), 'grid': ['....', '..', '..#.', '....'], 'start_end': (1, 1, 4, 4)}] assert min_moves_to_target(t, test_cases) == [4, 6]","solution":"from collections import deque def bfs_min_moves(grid, start, target, n, m): directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(start[0], start[1], 0)]) # (row, col, moves) visited = set() visited.add((start[0], start[1])) while queue: r, c, moves = queue.popleft() if (r, c) == (target[0], target[1]): return moves for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < n and 0 <= nc < m and (nr, nc) not in visited and grid[nr][nc] == '.': queue.append((nr, nc, moves + 1)) visited.add((nr, nc)) return -1 def min_moves_to_target(t, test_cases): results = [] for i in range(t): n, m = test_cases[i]['grid_size'] grid = test_cases[i]['grid'] r, c, r_t, c_t = test_cases[i]['start_end'] start = (r-1, c-1) target = (r_t-1, c_t-1) result = bfs_min_moves(grid, start, target, n, m) results.append(result) return results"},{"question":"def distribute_dishes(n: int, m: int) -> List[int]: Distribute m dishes as evenly as possible among n participants. Each participant must bring at least one dish. Parameters: n (int): number of participants m (int): total number of dishes Returns: List[int]: A list of length n representing the number of dishes each participant should bring, or [-1] if not possible. Example: >>> distribute_dishes(3, 10) [4, 3, 3] >>> distribute_dishes(5, 20) [4, 4, 4, 4, 4] >>> distribute_dishes(4, 2) [-1]","solution":"def distribute_dishes(n, m): Distribute m dishes as evenly as possible among n participants. Each participant must bring at least one dish. Parameters: n (int): number of participants m (int): total number of dishes Returns: List[int]: A list of length n representing the number of dishes each participant should bring, or [-1] if not possible. if n > m: return [-1] base_dishes = m // n extra_dishes = m % n result = [base_dishes] * n for i in range(extra_dishes): result[i] += 1 return result"},{"question":"def mystic_sequence(k: int) -> int: Calculate the value at position k in the Mystic Sequence. The Mystic Sequence is defined as: - The first element is 1. - The second element is 1. - For any element at position n (n > 2), the value is the sum of the elements at positions (n-1) and (n-2), reduced modulo 10^9 + 7. # TODO: Implement the function to find the k-th value in the sequence. def process_test_cases(t: int, ks: List[int]) -> List[int]: Process multiple test cases to find the values at given positions in the Mystic Sequence. >>> process_test_cases(2, [1, 6]) [1, 8] >>> process_test_cases(1, [10]) [55 % (10**9 + 7)] # TODO: Implement the function to process multiple test cases. from typing import List def test_mystic_sequence(): assert mystic_sequence(1) == 1 assert mystic_sequence(2) == 1 assert mystic_sequence(3) == 2 assert mystic_sequence(6) == 8 assert mystic_sequence(10) == 55 % (10**9 + 7) assert mystic_sequence(1000000) # Should complete without timeout def test_process_test_cases(): assert process_test_cases(2, [1, 6]) == [1, 8] assert process_test_cases(1, [10]) == [55 % (10**9 + 7)] assert process_test_cases(3, [1, 2, 3]) == [1, 1, 2]","solution":"def mystic_sequence(k): MOD = 10**9 + 7 if k == 1 or k == 2: return 1 prev, curr = 1, 1 for _ in range(3, k+1): prev, curr = curr, (prev + curr) % MOD return curr def process_test_cases(t, ks): return [mystic_sequence(k) for k in ks]"},{"question":"def maximize_sum_of_mins(n, nums): Arrange the integers into pairs such that the sum of min(ai, bi) for all pairs is maximized. Args: n (int): The number of elements in the array. nums (list): The list of integers. Returns: int: The maximized sum. Examples: >>> maximize_sum_of_mins(4, [1, 4, 3, 2]) 4 >>> maximize_sum_of_mins(6, [6, 2, 6, 5, 1, 2]) 9 from solution import maximize_sum_of_mins def test_example1(): assert maximize_sum_of_mins(4, [1, 4, 3, 2]) == 4 def test_example2(): assert maximize_sum_of_mins(6, [6, 2, 6, 5, 1, 2]) == 9 def test_all_same_values(): assert maximize_sum_of_mins(4, [2, 2, 2, 2]) == 4 def test_already_sorted(): assert maximize_sum_of_mins(4, [1, 2, 3, 4]) == 4 def test_reverse_sorted(): assert maximize_sum_of_mins(4, [4, 3, 2, 1]) == 4 def test_large_case(): assert maximize_sum_of_mins(10, [10, 1, 7, 2, 8, 4, 9, 3, 6, 5]) == 25 def test_all_ones(): assert maximize_sum_of_mins(6, [1, 1, 1, 1, 1, 1]) == 3","solution":"def maximize_sum_of_mins(n, nums): Arrange the integers into pairs such that the sum of min(ai, bi) is maximized. Args: n (int): The number of elements in the array. nums (list): The list of integers. Returns: int: The maximized sum. nums.sort() return sum(nums[i] for i in range(0, n, 2))"},{"question":"from typing import List def total_quicksort_comparisons(n: int, arr: List[int]) -> int: Calculate the total number of comparisons QuickSort makes to sort the array using the first element as the pivot. >>> total_quicksort_comparisons(4, [4, 3, 2, 1]) 6 >>> total_quicksort_comparisons(5, [1, 2, 3, 4, 5]) 10","solution":"def quicksort_comparisons(arr, low, high): if low < high: pivotIndex = partition(arr, low, high) left_comparisons = quicksort_comparisons(arr, low, pivotIndex - 1) right_comparisons = quicksort_comparisons(arr, pivotIndex + 1, high) total_comparisons = (high - low) + left_comparisons + right_comparisons return total_comparisons return 0 def partition(arr, low, high): pivot = arr[low] i = low + 1 for j in range(low + 1, high + 1): if arr[j] < pivot: arr[i], arr[j] = arr[j], arr[i] i = i + 1 arr[low], arr[i - 1] = arr[i - 1], arr[low] return i - 1 def total_quicksort_comparisons(n, arr): return quicksort_comparisons(arr, 0, n - 1) # To conform to the given input/output format if __name__ == \\"__main__\\": n = int(input()) arr = list(map(int, input().split())) print(total_quicksort_comparisons(n, arr))"},{"question":"def find_positions(arr1: List[int], arr2: List[int]) -> Tuple[int, int]: Finds the index positions where the maximum element of arr1 and the minimum element of arr2 occur. The function returns these positions as a tuple. If the input arrays are empty, it raises a ValueError. >>> find_positions([1, 3, 5, 7, 9], [4, 2, 5, 2, 6]) (4, 1) >>> find_positions([1, 2, 3, 4, 5], [10, 9, 8, 7, 6]) (4, 4) >>> find_positions([-1, -2, -3, -4, -5], [0, -1, -2, -3, -4]) (0, 4) >>> find_positions([10, 20, 30, 20, 10], [5, 4, 3, 2, 1]) (2, 4) >>> find_positions([0], [0]) (0, 0) >>> find_positions([100, 50, 100], [-50, -100, -50]) (0, 1)","solution":"from typing import List, Tuple def find_positions(arr1: List[int], arr2: List[int]) -> Tuple[int, int]: Finds the index positions where the maximum element of arr1 and the minimum element of arr2 occur. The function returns these positions as a tuple. if not arr1 or not arr2: raise ValueError(\\"Input arrays must not be empty\\") max_index = arr1.index(max(arr1)) min_index = arr2.index(min(arr2)) return (max_index, min_index)"},{"question":"def max_distinct_timestamps(log: str, k: int) -> int: Determine the maximum number of distinct timestamps in any contiguous segment of the log with length ≤ k. ----Input:---- log (str): A string where each timestamp is a positive integer separated by commas. k (int): An integer representing the maximum allowable length of the segment. ----Output:---- int: Return a single integer, the maximum number of distinct timestamps found in any valid contiguous segment. ----Examples:---- >>> max_distinct_timestamps(\\"1,2,3,4,5,6\\", 5) 6 >>> max_distinct_timestamps(\\"1,2,4,5,7,8,10,11,13,14\\", 2) 2 >>> max_distinct_timestamps(\\"1\\", 1) 1 >>> max_distinct_timestamps(\\"1,10,20,30,40\\", 5) 1 >>> max_distinct_timestamps(\\"5,5,5,5,5\\", 1) 1 >>> max_distinct_timestamps(\\"1,2,3,4,5,6,7,8,9,10\\", 1000000) 10","solution":"def max_distinct_timestamps(log: str, k: int) -> int: timestamps = list(map(int, log.split(','))) n = len(timestamps) max_distinct = 0 for i in range(n): seen = set() for j in range(i, n): seen.add(timestamps[j]) if timestamps[j] - timestamps[i] <= k: max_distinct = max(max_distinct, len(seen)) else: break return max_distinct"},{"question":"def max_possible_value(s: str) -> int: Given a binary string s, calculates the maximum possible value of the sequence of operations starting from zero. Parameters: s (str): A binary string representing the sequence of operations Returns: int: The maximum possible value attained Example: >>> max_possible_value(\\"110001101\\") 2 >>> max_possible_value(\\"1111\\") 4 >>> max_possible_value(\\"0000\\") 0","solution":"def max_possible_value(s): Given a binary string s, calculates the maximum possible value of the sequence of operations starting from zero. Parameters: s (str): A binary string representing the sequence of operations Returns: int: The maximum possible value attained max_value = 0 current_value = 0 for char in s: if char == '1': current_value += 1 elif char == '0': current_value -= 1 if current_value < 0: current_value = 0 # Track the maximum value reached if current_value > max_value: max_value = current_value return max_value"},{"question":"def find_original_integers(c: int, m: int, d: int, n: int) -> (int, int): Determine the original integers a and b such that concatenation of a and b in this order gives c and d. Parameters: c (int): The modified integer c. m (int): The length of the original integer a. d (int): The modified integer d. n (int): The length of the original integer b. Returns: tuple: A tuple containing the original integers a and b. Example: >>> find_original_integers(1234, 2, 5678, 2) (12, 78) >>> find_original_integers(101010, 3, 123456, 4) (101, 3456)","solution":"def find_original_integers(c, m, d, n): Returns the original integers a and b such that the concatenation of a and b forms the integers represented by c and d, respectively. Parameters: c (int): The modified integer c. m (int): The length of the original integer a. d (int): The modified integer d. n (int): The length of the original integer b. Returns: tuple: A tuple containing the original integers a and b. # Convert c and d to string to slice them c_str = str(c) d_str = str(d) # Extract the original integers a and b a = int(c_str[:m]) b = int(d_str[-n:]) return a, b # Main function to handle input and output if __name__ == \\"__main__\\": import sys input = sys.stdin.read c, m, d, n = map(int, input().strip().split()) a, b = find_original_integers(c, m, d, n) print(a, b)"},{"question":"def count_occurrences(text, char): Returns the number of times the character appears in the string. If inputs are not valid, returns \\"invalid input\\". Parameters: text (str): the input string char (str): the character to count in the input string Returns: int or str: the count of occurrences of char in text, or \\"invalid input\\" if inputs are invalid >>> count_occurrences(\\"hello world\\", 'o') 2 >>> count_occurrences(\\"hello world\\", 'z') 0 >>> count_occurrences(123, 'o') \\"invalid input\\" >>> count_occurrences(\\"hello world\\", \\"world\\") \\"invalid input\\"","solution":"def count_occurrences(text, char): Returns the number of times the character appears in the string. Parameters: text (str): the input string char (str): the character to count in the input string Returns: int or str: the count of occurrences of char in text, or \\"invalid input\\" if inputs are invalid if not isinstance(text, str) or not isinstance(char, str) or len(char) != 1: return \\"invalid input\\" return text.count(char)"},{"question":"def process_input(n: int, data: List[int]) -> List[int]: Remove duplicate entries from the input list while preserving the original order of first occurrences of each element. >>> process_input(6, [5, 3, 5, 2, 3, 1]) [5, 3, 2, 1] >>> process_input(5, [1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> process_input(8, [4, 5, 4, 5, 6, 7, 7, 8]) [4, 5, 6, 7, 8] def test_remove_duplicates_example_1(): assert process_input(6, [5, 3, 5, 2, 3, 1]) == [5, 3, 2, 1] def test_remove_duplicates_example_2(): assert process_input(5, [1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] def test_remove_duplicates_example_3(): assert process_input(8, [4, 5, 4, 5, 6, 7, 7, 8]) == [4, 5, 6, 7, 8] def test_remove_duplicates_with_single_element(): assert process_input(1, [10]) == [10] def test_remove_duplicates_with_all_duplicates(): assert process_input(5, [2, 2, 2, 2, 2]) == [2] def test_remove_duplicates_with_large_numbers(): assert process_input(5, [999999999, 1, 999999999, 2, 1]) == [999999999, 1, 2] def test_remove_duplicates_large_input(): large_input = list(range(1, 100001)) + list(range(50000, 100001)) expected_output = list(range(1, 100001)) assert process_input(150000, large_input) == expected_output","solution":"def remove_duplicates(data_list): seen = set() result = [] for num in data_list: if num not in seen: result.append(num) seen.add(num) return result def process_input(n, data): return remove_duplicates(data)"},{"question":"def is_two_alternating_characters(s: str) -> str: Determines if the string consists of two alternating characters. >>> is_two_alternating_characters(\\"abababab\\") \\"YES\\" >>> is_two_alternating_characters(\\"ababacabab\\") \\"NO\\" >>> is_two_alternating_characters(\\"cdcdcdc\\") \\"YES\\" >>> is_two_alternating_characters(\\"a\\") \\"NO\\" >>> is_two_alternating_characters(\\"aa\\") \\"NO\\"","solution":"def is_two_alternating_characters(s): Determines if the string consists of two alternating characters. if len(s) < 2: return \\"NO\\" first_char = s[0] second_char = None for char in s[1:]: if char != first_char: second_char = char break if second_char is None: return \\"NO\\" for i in range(len(s)): expected_char = first_char if i % 2 == 0 else second_char if s[i] != expected_char: return \\"NO\\" return \\"YES\\""},{"question":"import heapq from typing import List, Tuple def dijkstra(graph: List[List[Tuple[int, int]]], start: int, n: int) -> List[int]: Find shortest path from start node to all other nodes using Dijkstra's algorithm. :param graph: adjacency list of graph where graph[u] is a list of (v, w) pairs :param start: starting node :param n: number of nodes in the graph :return: list of shortest path distances from start to each node pass def shortest_paths(n: int, m: int, edges: List[Tuple[int, int, int]], queries: List[Tuple[int, int]]) -> List[int]: For each query, find the shortest path between the given nodes using Dijkstra's algorithm. :param n: number of nodes :param m: number of edges :param edges: list of edges where each edge is represented as (u, v, w) :param queries: list of queries where each query is represented as (s, t) :return: list of shortest path costs for each query pass # Example tests def test_shortest_paths(): n, m, q = 4, 4, 3 edges = [ (1, 2, 3), (2, 3, 4), (3, 4, 2), (4, 1, 6) ] queries = [ (1, 3), (2, 4), (1, 4) ] expected_output = [7, 6, 6] assert shortest_paths(n, m, edges, queries) == expected_output def test_no_path(): n, m, q = 3, 2, 2 edges = [ (1, 2, 5), (2, 3, 10) ] queries = [ (1, 3), (3, 1) ] expected_output = [15, 15] assert shortest_paths(n, m, edges, queries) == expected_output def test_disconnected_graph(): n, m, q = 5, 3, 2 edges = [ (1, 2, 2), (3, 4, 3), (4, 5, 4) ] queries = [ (1, 3), (4, 5) ] expected_output = [-1, 4] assert shortest_paths(n, m, edges, queries) == expected_output def test_single_node(): n, m, q = 1, 0, 1 edges = [] queries = [ (1, 1) ] expected_output = [0] assert shortest_paths(n, m, edges, queries) == expected_output def test_large_graph(): n, m, q = 5, 5, 5 edges = [ (1, 2, 1), (2, 3, 1), (3, 4, 1), (4, 5, 1), (1, 5, 10) ] queries = [ (1, 5), (2, 4), (1, 3), (5, 1), (3, 5) ] expected_output = [4, 2, 2, 4, 2] assert shortest_paths(n, m, edges, queries) == expected_output","solution":"import heapq def dijkstra(graph, start, n): Find shortest path from start node to all other nodes using Dijkstra's algorithm. :param graph: adjacency list of graph where graph[u] is a list of (v, w) pairs :param start: starting node :param n: number of nodes in the graph :return: list of shortest path distances from start to each node dist = [float('inf')] * (n + 1) dist[start] = 0 pq = [(0, start)] while pq: curr_dist, u = heapq.heappop(pq) if curr_dist > dist[u]: continue for v, weight in graph[u]: if dist[u] + weight < dist[v]: dist[v] = dist[u] + weight heapq.heappush(pq, (dist[v], v)) return dist def shortest_paths(n, m, edges, queries): For each query, find the shortest path between the given nodes using Dijkstra's algorithm. :param n: number of nodes :param m: number of edges :param edges: list of edges where each edge is represented as (u, v, w) :param queries: list of queries where each query is represented as (s, t) :return: list of shortest path costs for each query graph = [[] for _ in range(n + 1)] for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) results = [] for s, t in queries: dist = dijkstra(graph, s, n) if dist[t] == float('inf'): results.append(-1) else: results.append(dist[t]) return results"},{"question":"def twoSum(nums: List[int], target: int) -> List[int]: Given an array of integers, return the indices of the two numbers that add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. >>> twoSum([2, 7, 11, 15], 9) [0, 1] >>> twoSum([3, 2, 4], 6) [1, 2] >>> twoSum([5, 75, 25], 100) [1, 2] >>> twoSum([-1, -2, -3, -4, -5], -8) [2, 4] >>> twoSum([0, 4, 3, 0], 0) [0, 3] >>> twoSum([10**9, 2, 10**9 - 2], 2 * 10**9 - 2) [0, 2] >>> twoSum([-10**5, 10**5, -2, 3, 7], 5) [2, 4] >>> twoSum([3, 3], 6) [0, 1]","solution":"def twoSum(nums, target): Returns the indices of the two numbers that add up to the target. Parameters: nums (List[int]): An array of integers. target (int): The target sum. Returns: List[int]: The indices of the two numbers that add up to the target. num_to_index = {} for index, num in enumerate(nums): difference = target - num if difference in num_to_index: return [num_to_index[difference], index] num_to_index[num] = index"},{"question":"def calculate_highest_attendance(n, m, attendance_records): Determine the classroom with the highest total student attendance over a set of weeks. >>> calculate_highest_attendance(3, 4, [[10, 20, 30, 40], [15, 15, 35, 10], [5, 10, 15, 40]]) == 1 >>> calculate_highest_attendance(1, 1, [[5]]) == 1 >>> calculate_highest_attendance(1, 3, [[5, 10, 15]]) == 1 >>> calculate_highest_attendance(3, 1, [[5], [10], [3]]) == 2 >>> calculate_highest_attendance(4, 3, [[10, 10, 20], [15, 10, 15], [10, 10, 20], [20, 5, 15]]) == 1","solution":"def calculate_highest_attendance(n, m, attendance_records): max_total_attendance = 0 best_classroom_index = 0 for i in range(n): total_attendance = sum(attendance_records[i]) if total_attendance > max_total_attendance: max_total_attendance = total_attendance best_classroom_index = i elif total_attendance == max_total_attendance: best_classroom_index = min(best_classroom_index, i) return best_classroom_index + 1 # 1-based index"},{"question":"from typing import List, Tuple, Union def find_pair_with_sum(arr: List[int], target: int) -> Union[Tuple[int, int], None]: Finds two distinct indices i and j in the array such that arr[i] + arr[j] == target. Args: arr: List of integers. target: An integer target sum. Returns: A tuple (i, j) where arr[i] + arr[j] == target, or None if no such pair exists. >>> find_pair_with_sum([2, 7, 11, 15], 9) (0, 1) >>> result = find_pair_with_sum([3, 2, 4], 6) >>> result == (1, 2) or result == (2, 1) True >>> result = find_pair_with_sum([3, 3], 6) >>> result == (0, 1) or result == (1, 0) True >>> find_pair_with_sum([1, 2, 3, 4, 5], 10) None >>> find_pair_with_sum([-10**9, 10**9], 0) (0, 1) >>> result = find_pair_with_sum([1, -1, 10**9, -10**9], 0) >>> result in [(0, 1), (1, 0), (2, 3), (3, 2)] True","solution":"from typing import List, Tuple, Union def find_pair_with_sum(arr: List[int], target: int) -> Union[Tuple[int, int], None]: Finds two distinct indices i and j in the array such that arr[i] + arr[j] == target. Args: arr: List of integers. target: An integer target sum. Returns: A tuple (i, j) where arr[i] + arr[j] == target, or None if no such pair exists. seen = {} for i, value in enumerate(arr): remaining = target - value if remaining in seen: return (seen[remaining], i) seen[value] = i return None"},{"question":"def min_reassignments(N: int, bibs: List[int]) -> int: Determine the minimum number of bib number reassignments required to ensure all bib numbers are unique. >>> min_reassignments(5, [1, 2, 3, 3, 5]) 1 >>> min_reassignments(6, [1, 1, 2, 3, 3, 2]) 3","solution":"def min_reassignments(N, bibs): from collections import Counter bib_counter = Counter(bibs) duplicates = [bib for bib, count in bib_counter.items() if count > 1] reassignments = 0 for bib in duplicates: while bib_counter[bib] > 1: bib_counter[bib] -= 1 reassignments += 1 new_bib = bib + 1 while new_bib in bib_counter: new_bib += 1 bib_counter[new_bib] = 1 return reassignments def main(): import sys input = sys.stdin.read data = input().split() N = int(data[0]) bibs = list(map(int, data[1:])) result = min_reassignments(N, bibs) print(result)"},{"question":"from typing import List, Tuple def minimum_time_to_complete_updates(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Determine the minimum time required to complete all the updates on a computer given the constraints. Args: T: int : Number of test cases test_cases: List[Tuple[int, List[int]]] : List containing tuples where each tuple represents a test case. Each tuple contains an integer representing number of updates (N) and a list of integers representing the time (in minutes) it takes to install each update. Returns: List[int] : A list of integers where each integer represents the minimum time required for the corresponding test case. Test cases: >>> minimum_time_to_complete_updates(2, [(3, [10, 15, 20]), (4, [5, 10, 20, 25])]) [45, 60] >>> minimum_time_to_complete_updates(1, [(1, [100])]) [100] >>> minimum_time_to_complete_updates(1, [(0, [])]) [0] >>> minimum_time_to_complete_updates(1, [(1000, [1]*1000)]) [1000] pass # Implement the function here","solution":"def minimum_time_to_complete_updates(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] update_times = test_cases[i][1] total_time = sum(update_times) results.append(total_time) return results"},{"question":"def count_distinct_treasures(n: int, m: int, grid: List[List[int]]) -> int: Counts the distinct types of treasures in the grid. :param n: int, number of rows in the grid :param m: int, number of columns in the grid :param grid: List[List[int]], the grid representation with treasures :return: int, the number of distinct treasure types >>> count_distinct_treasures(3, 3, [ ... [0, 1, 0], ... [2, 0, 3], ... [0, 4, 5] ... ]) == 5 >>> count_distinct_treasures(2, 2, [ ... [1, 1], ... [0, 0] ... ]) == 1","solution":"def count_distinct_treasures(n, m, grid): Counts the distinct types of treasures in the grid. :param n: int, number of rows in the grid :param m: int, number of columns in the grid :param grid: List[List[int]], the grid representation with treasures :return: int, the number of distinct treasure types treasure_set = set() for row in grid: for item in row: if item > 0: treasure_set.add(item) return len(treasure_set)"},{"question":"from typing import List def frequency_sort(nums: List[int]) -> List[int]: Write a function that takes a list of integers and returns the list sorted based on the frequency of each integer in descending order. If two numbers have the same frequency, they should be sorted in ascending order of their values. >>> frequency_sort([4, 5, 6, 5, 4, 3]) [4, 4, 5, 5, 3, 6] >>> frequency_sort([1, 2, 2, 3, 3, 3]) [3, 3, 3, 2, 2, 1] >>> frequency_sort([1, 2, 3, 4, 5, 6]) [1, 2, 3, 4, 5, 6] pass","solution":"from typing import List from collections import Counter def frequency_sort(nums: List[int]) -> List[int]: Returns the list sorted based on the frequency of each integer in descending order. If two numbers have the same frequency, they are sorted in ascending order of their values. # Create a counter for the numbers count = Counter(nums) # Sorting the list based on the frequency and then by the value itself sorted_nums = sorted(nums, key=lambda x: (-count[x], x)) return sorted_nums"},{"question":"def length_of_longest_substring_two_distinct(s: str) -> int: Returns the length of the longest substring that contains at most two different characters. >>> length_of_longest_substring_two_distinct(\\"abaccc\\") 4 >>> length_of_longest_substring_two_distinct(\\"abcbbbaa\\") 5 >>> length_of_longest_substring_two_distinct(\\"aaaa\\") 4 >>> length_of_longest_substring_two_distinct(\\"abcdef\\") 2 >>> length_of_longest_substring_two_distinct(\\"\\") 0","solution":"def length_of_longest_substring_two_distinct(s: str) -> int: Returns the length of the longest substring that contains at most two different characters. if len(s) == 0: return 0 # Dictionary to keep track of last occurrence of each character char_last_occurrence = {} start = 0 max_length = 0 for end in range(len(s)): char_last_occurrence[s[end]] = end if len(char_last_occurrence) > 2: # Find the character with the smallest last occurrence char_to_remove = min(char_last_occurrence, key=char_last_occurrence.get) start = char_last_occurrence[char_to_remove] + 1 del char_last_occurrence[char_to_remove] max_length = max(max_length, end - start + 1) return max_length"},{"question":"def find_pair(arr: List[int], k: int) -> Tuple[int, int]: Returns a tuple of two distinct elements from the array whose sum is equal to k. If no such pair exists, returns None. >>> find_pair([10, 15, 3, 7], 17) (10, 7) >>> find_pair([1, 2, 3, 4], 8) None >>> find_pair([5, 5, 5, 5], 10) (5, 5) >>> find_pair([-1e9, 1e9, 0], 0) (-1e9, 1e9) >>> find_pair([2, 4, 3, 5, 6], 9) (4, 5) >>> find_pair([], 0) None >>> find_pair([5], 5) None","solution":"def find_pair(arr, k): Returns a tuple of two distinct elements from the array whose sum is equal to k. If no such pair exists, returns None. seen = {} for num in arr: complement = k - num if complement in seen: return (complement, num) if num in seen: seen[num] += 1 else: seen[num] = 1 return None"},{"question":"def count_ways_to_climb_stairs(n: int) -> int: Returns the number of ways to climb a staircase with n steps, where you can take 1, 2, or 3 steps at a time. >>> count_ways_to_climb_stairs(0) 0 >>> count_ways_to_climb_stairs(1) 1 >>> count_ways_to_climb_stairs(2) 2 >>> count_ways_to_climb_stairs(3) 4 >>> count_ways_to_climb_stairs(4) 7 >>> count_ways_to_climb_stairs(5) 13 >>> count_ways_to_climb_stairs(10) 274 >>> count_ways_to_climb_stairs(20) 121415","solution":"def count_ways_to_climb_stairs(n): Returns the number of ways to climb a staircase with n steps, where you can take 1, 2, or 3 steps at a time. if n == 0: return 0 elif n == 1: return 1 elif n == 2: return 2 elif n == 3: return 4 ways = [0] * (n + 1) ways[0] = 1 ways[1] = 1 ways[2] = 2 ways[3] = 4 for i in range(4, n + 1): ways[i] = ways[i - 1] + ways[i - 2] + ways[i - 3] return ways[n] # Example usage n = 5 print(count_ways_to_climb_stairs(n)) # Output: 13"},{"question":"def even_digit_numbers(arr): Returns a new list containing only the integers from the input list that have an even number of digits. >>> even_digit_numbers([12, 123, 1234, 12345, 123456]) [12, 1234, 123456] >>> even_digit_numbers([1, 22, 333, 4444, 55555, 666666]) [22, 4444, 666666] >>> even_digit_numbers([]) [] >>> even_digit_numbers([1, 3, 5, 7]) []","solution":"def even_digit_numbers(arr): Returns a new list containing only the integers from the input list that have an even number of digits. return [num for num in arr if len(str(num)) % 2 == 0]"},{"question":"def min_changes_to_palindrome(s: str) -> int: Returns the minimum number of changes needed to make the string s a palindrome. >>> min_changes_to_palindrome(\\"abc\\") 1 >>> min_changes_to_palindrome(\\"aab\\") 1 >>> min_changes_to_palindrome(\\"abcd\\") 2 >>> min_changes_to_palindrome(\\"racecar\\") 0 def process_test_cases(t: int, test_cases: List[str]) -> List[int]: Processes multiple test cases and returns the results for each. >>> process_test_cases(4, [\\"abc\\", \\"aab\\", \\"abcd\\", \\"racecar\\"]) [1, 1, 2, 0] >>> process_test_cases(4, [\\"\\", \\"a\\", \\"ab\\", \\"aa\\"]) [0, 0, 1, 0]","solution":"def min_changes_to_palindrome(s): Returns the minimum number of changes needed to make the string s a palindrome. n = len(s) changes = 0 for i in range(n // 2): if s[i] != s[n - i - 1]: changes += 1 return changes def process_test_cases(t, test_cases): results = [] for s in test_cases: results.append(min_changes_to_palindrome(s)) return results"},{"question":"def longest_palindromic_subsequence(s: str) -> int: Given a string s, find the length of the longest palindromic subsequence in s. Args: s (str): The input string Returns: int: The length of the longest palindromic subsequence Example: >>> longest_palindromic_subsequence(\\"bbbab\\") 4 >>> longest_palindromic_subsequence(\\"cbbd\\") 2 pass def process_test_cases(Q: int, test_cases: list) -> list: Processes multiple test cases and returns the results for each case. Args: Q (int): Number of test cases test_cases (list): List of input strings for each test case Returns: list: List of results corresponding to each test case Example: >>> process_test_cases(2, [\\"bbbab\\", \\"cbbd\\"]) [4, 2] >>> process_test_cases(3, [\\"a\\", \\"abcba\\", \\"abacab\\"]) [1, 5, 5] pass from solution import longest_palindromic_subsequence, process_test_cases def test_longest_palindromic_subsequence(): assert longest_palindromic_subsequence(\\"bbbab\\") == 4 assert longest_palindromic_subsequence(\\"cbbd\\") == 2 assert longest_palindromic_subsequence(\\"a\\") == 1 assert longest_palindromic_subsequence(\\"abcba\\") == 5 assert longest_palindromic_subsequence(\\"abacab\\") == 5 assert longest_palindromic_subsequence(\\"abcd\\") == 1 assert longest_palindromic_subsequence(\\"aaa\\") == 3 def test_process_test_cases(): assert process_test_cases(2, [\\"bbbab\\", \\"cbbd\\"]) == [4, 2] assert process_test_cases(3, [\\"a\\", \\"abcba\\", \\"abacab\\"]) == [1, 5, 5] # Run the tests test_longest_palindromic_subsequence() test_process_test_cases() print(\\"All tests passed.\\")","solution":"def longest_palindromic_subsequence(s: str) -> int: n = len(s) dp = [[0]*n for _ in range(n)] for i in range(n): dp[i][i] = 1 for cl in range(2, n+1): for i in range(n - cl + 1): j = i + cl - 1 if s[i] == s[j] and cl == 2: dp[i][j] = 2 elif s[i] == s[j]: dp[i][j] = dp[i + 1][j - 1] + 2 else: dp[i][j] = max(dp[i][j - 1], dp[i + 1][j]) return dp[0][n-1] def process_test_cases(Q: int, test_cases: list) -> list: results = [] for s in test_cases: results.append(longest_palindromic_subsequence(s)) return results"},{"question":"def reorder_list(arr): Reorder the elements such that odd elements appear before the even elements, and both the odd and even elements appear in ascending order. >>> reorder_list([3, 1, 2, 4, 7, 5]) [1, 3, 5, 7, 2, 4] >>> reorder_list([8, 13, 11, 90, 2]) [11, 13, 2, 8, 90] >>> reorder_list([]) [] >>> reorder_list([1]) [1] >>> reorder_list([2]) [2] >>> reorder_list([9, 7, 5, 3, 1]) [1, 3, 5, 7, 9] >>> reorder_list([10, 8, 6, 4, 2]) [2, 4, 6, 8, 10] >>> reorder_list([4, 1, 2, 3]) [1, 3, 2, 4] >>> reorder_list([10, 13, 11, 2, 5, 6]) [5, 11, 13, 2, 6, 10] >>> reorder_list([1, 11, 2, 12, 3, 13]) [1, 3, 11, 13, 2, 12] >>> reorder_list([1000000, 999999, 100000, 99999]) [99999, 999999, 100000, 1000000]","solution":"def reorder_list(arr): Reorder the elements such that odd elements appear before the even elements, and both the odd and even elements appear in ascending order. odds = sorted([x for x in arr if x % 2 != 0]) evens = sorted([x for x in arr if x % 2 == 0]) return odds + evens"},{"question":"def buildMaxHeap(arr: list, n: int) -> list: Build a max-heap from the given array. >>> buildMaxHeap([4, 1, 3, 9, 7], 5) [9, 7, 3, 1, 4] >>> buildMaxHeap([2, 10, 8, 5, 6, 1], 6) [10, 6, 8, 5, 2, 1] # Implement max-heap construction here def buildMinHeap(arr: list, n: int) -> list: Build a min-heap from the given array. >>> buildMinHeap([4, 1, 3, 9, 7], 5) [1, 4, 3, 9, 7] >>> buildMinHeap([2, 10, 8, 5, 6, 1], 6) [1, 5, 8, 10, 6, 2] # Implement min-heap construction here def extractMax(arr: list, n: int) -> int: Extract the maximum element from the given max-heap. >>> arr = [4, 1, 3, 9, 7] >>> n = len(arr) >>> buildMaxHeap(arr, n) >>> extractMax(arr, n) 9 >>> extractMax(arr, n-1) 7 # Implement max extraction here def extractMin(arr: list, n: int) -> int: Extract the minimum element from the given min-heap. >>> arr = [4, 1, 3, 9, 7] >>> n = len(arr) >>> buildMinHeap(arr, n) >>> extractMin(arr, n) 1 >>> extractMin(arr, n-1) 3 # Implement min extraction here","solution":"def heapify_max(arr, n, i): largest = i left = 2 * i + 1 right = 2 * i + 2 if left < n and arr[left] > arr[largest]: largest = left if right < n and arr[right] > arr[largest]: largest = right if largest != i: arr[i], arr[largest] = arr[largest], arr[i] heapify_max(arr, n, largest) def buildMaxHeap(arr, n): for i in range(n//2 - 1, -1, -1): heapify_max(arr, n, i) return arr def extractMax(arr, n): if n == 0: return None max_element = arr[0] arr[0], arr[n-1] = arr[n-1], arr[0] n -= 1 heapify_max(arr, n, 0) return max_element def heapify_min(arr, n, i): smallest = i left = 2 * i + 1 right = 2 * i + 2 if left < n and arr[left] < arr[smallest]: smallest = left if right < n and arr[right] < arr[smallest]: smallest = right if smallest != i: arr[i], arr[smallest] = arr[smallest], arr[i] heapify_min(arr, n, smallest) def buildMinHeap(arr, n): for i in range(n//2 - 1, -1, -1): heapify_min(arr, n, i) return arr def extractMin(arr, n): if n == 0: return None min_element = arr[0] arr[0], arr[n-1] = arr[n-1], arr[0] n -= 1 heapify_min(arr, n, 0) return min_element"},{"question":"def even_palindrome(m: int) -> int: Finds a numeric palindrome of length m which is also an even number. If such a number doesn't exist, returns -1. >>> even_palindrome(1) == 2 >>> even_palindrome(3) == -1 >>> even_palindrome(5) == -1 >>> even_palindrome(7) == -1 >>> even_palindrome(2) == 22 >>> even_palindrome(4) == 2002 >>> even_palindrome(6) == 200002 >>> even_palindrome(8) == 20000002 >>> even_palindrome(100) == int('2' + '0'*49 + '0'*49 + '2')","solution":"def even_palindrome(m): Finds a numeric palindrome of length m which is also an even number. If such a number doesn't exist, returns -1. if m == 1: # If the length is 1, the only single-digit even numbers are 2, 4, 6, 8, which are palindromes themselves. return 2 # Any single digit even number is a palindrome if m % 2 != 0: # If m is odd, it's not possible to construct an even palindrome. return -1 # Constructing even palindrome for even length half_length = m // 2 palindrome = '2' + '0' * (half_length - 1) + '0' * (half_length - 1) + '2' return int(palindrome)"},{"question":"def minItems(prices, target): Determines the minimum number of items needed to reach or exceed the target amount of money. If it is not possible, returns -1. Examples: >>> minItems([1, 2, 3, 4, 5], 11) 3 >>> minItems([7, 10, 4, 3, 2], 10) 1 >>> minItems([1, 1, 1, 1], 7) -1","solution":"def minItems(prices, target): Determines the minimum number of items needed to reach or exceed the target amount of money. If it is not possible, returns -1. # Sort prices in descending order prices.sort(reverse=True) total = 0 count = 0 for price in prices: total += price count += 1 if total >= target: return count return -1"},{"question":"def are_anagrams(word1: str, word2: str) -> bool: Check whether a given word is an anagram of another word. >>> are_anagrams('listen', 'silent') True >>> are_anagrams('evil', 'vile') True >>> are_anagrams('elvis', 'lives') True >>> are_anagrams('listen', 'listens') False >>> are_anagrams('evil', 'villain') False >>> are_anagrams('elvis', 'live') False","solution":"def are_anagrams(word1, word2): Returns True if word1 and word2 are anagrams, False otherwise. return sorted(word1) == sorted(word2)"},{"question":"from collections import Counter from typing import List, Tuple def most_common_elements(S: str, N: int) -> List[Tuple[str, int]]: Given a string S, returns the N most common elements and their counts from the most common to the least. Parameters: S (str): The input string. N (int): The number of most common elements to return. Returns: List of tuples: Each tuple contains an element and its count. Example: >>> most_common_elements(\\"bananaapple\\", 3) [('a', 4), ('n', 2), ('p', 2)] # Count the frequency of each character in the string cnt = Counter(S) # Get the N most common elements and their counts common_elements = cnt.most_common(N) return common_elements def test_most_common_elements(): result = most_common_elements(\\"bananaapple\\", 3) assert result == [('a', 4), ('n', 2), ('p', 2)] def test_single_character_string(): result = most_common_elements(\\"aaaaa\\", 1) assert result == [('a', 5)] def test_distinct_characters(): result = most_common_elements(\\"abcde\\", 5) assert result == [('a', 1), ('b', 1), ('c', 1), ('d', 1), ('e', 1)] def test_multiple_characters(): result = most_common_elements(\\"aabbcc\\", 2) assert result == [('a', 2), ('b', 2)] def test_more_common_elements_than_present(): result = most_common_elements(\\"bananaapple\\", 10) assert result == [('a', 4), ('n', 2), ('p', 2), ('b', 1), ('l', 1), ('e', 1)]","solution":"from collections import Counter def most_common_elements(S, N): Given a string S, returns the N most common elements and their counts from the most common to the least. Parameters: S (str): The input string. N (int): The number of most common elements to return. Returns: List of tuples: Each tuple contains an element and its count. # Count the frequency of each character in the string cnt = Counter(S) # Get the N most common elements and their counts common_elements = cnt.most_common(N) return common_elements"},{"question":"from typing import List, Tuple def artifact_sum(n: int, q: int, values: List[int], queries: List[Tuple[int, int]]) -> List[int]: Given the number of days recorded, the number of queries, the values of artifacts on each day, and a list of queries, returns the total value of artifacts collected for each query range. If any entry is corrupted (i.e., -1), assume its value to be 0. :param n: Number of days recorded :param q: Number of queries :param values: List of integer values, where -1 indicates a corrupted entry :param queries: List of tuples, each containing two integers representing range [l, r] :returns: List of sums for each query >>> artifact_sum(5, 3, [100, 200, -1, 50, -1], [(1, 3), (2, 5), (1, 5)]) [300, 250, 350] >>> artifact_sum(4, 2, [-1, -1, -1, -1], [(1, 4), (2, 3)]) [0, 0] >>> artifact_sum(7, 1, [-1, 200, 300, -1, 100, 50, -1], [(3, 6)]) [450]","solution":"def artifact_sum(n, q, values, queries): Given the number of days recorded, the number of queries, the values of artifacts on each day, and a list of queries, returns the total value of artifacts collected for each query range. If any entry is corrupted (i.e., -1), assume its value to be 0. :param n: Number of days recorded :param q: Number of queries :param values: List of integer values, where -1 indicates a corrupted entry :param queries: List of tuples, each containing two integers representing range [l, r] :returns: List of sums for each query results = [] for l, r in queries: total = 0 for i in range(l - 1, r): if values[i] != -1: total += values[i] results.append(total) return results # Example call: # n, q = 5, 3 # values = [100, 200, -1, 50, -1] # queries = [(1, 3), (2, 5), (1, 5)] # print(artifact_sum(n, q, values, queries)) -> [300, 250, 350]"},{"question":"def listFilePaths(paths: List[str], extension: str) -> List[str]: Returns a list of unique directory paths that contain at least one file with the specified extension. :param paths: List of file paths. :param extension: Desired file extension. :return: List of unique directory paths. >>> listFilePaths([\\"dir1/file1.txt\\", \\"dir1/file2.doc\\", \\"dir2/subdir/file3.txt\\", \\"dir3/subdir/subsubdir/file4.doc\\", \\"dir4/file5.txt\\"], \\"txt\\") [\\"dir1\\", \\"dir2/subdir\\", \\"dir4\\"] >>> listFilePaths([\\"dir1/file1.txt\\", \\"dir1/file2.doc\\", \\"dir2/subdir/file3.txt\\", \\"dir3/subdir/subsubdir/file4.doc\\", \\"dir4/file5.txt\\"], \\"doc\\") [\\"dir1\\", \\"dir3/subdir/subsubdir\\"] >>> listFilePaths([\\"dir1/file1.txt\\", \\"dir1/file2.doc\\", \\"dir2/subdir/file3.txt\\", \\"dir3/subdir/subsubdir/file4.doc\\", \\"dir4/file5.txt\\"], \\"pdf\\") [] >>> listFilePaths([\\"dir1/file1.Txt\\", \\"dir1/file2.doc\\", \\"dir2/subdir/file3.tXt\\", \\"dir3/subdir/subsubdir/file4.doc\\", \\"dir4/file5.txt\\"], \\"txt\\") [\\"dir4\\"] >>> listFilePaths([], \\"txt\\") []","solution":"def listFilePaths(paths, extension): Returns a list of unique directory paths that contain at least one file with the specified extension. :param paths: List of file paths. :param extension: Desired file extension. :return: List of unique directory paths. directories = set() for path in paths: if path.endswith(f\\".{extension}\\"): directory = '/'.join(path.split('/')[:-1]) directories.add(directory) return sorted(directories)"},{"question":"def is_palindrome(num: int) -> bool: Check if a number is a palindrome. >>> is_palindrome(121) == True >>> is_palindrome(123) == False >>> is_palindrome(0) == True >>> is_palindrome(11) == True >>> is_palindrome(10) == False def smallest_palindrome_greater_than(n: int) -> int: Find the smallest palindromic number greater than n. >>> smallest_palindrome_greater_than(123) == 131 >>> smallest_palindrome_greater_than(808) == 818 >>> smallest_palindrome_greater_than(999) == 1001 >>> smallest_palindrome_greater_than(0) == 1 >>> smallest_palindrome_greater_than(7) == 8 >>> smallest_palindrome_greater_than(88) == 99","solution":"def is_palindrome(num): return str(num) == str(num)[::-1] def smallest_palindrome_greater_than(n): m = n + 1 while not is_palindrome(m): m += 1 return m"},{"question":"def max_assignments(n: int, deadlines: List[int], b: int) -> int: Determines the maximum number of assignments that can be completed given the deadlines and the number of bonus days available. Parameters: n (int): Number of assignments deadlines (list of int): List of deadlines for each assignment b (int): Number of bonus days available Returns: int: Maximum number of assignments that can be completed >>> max_assignments(4, [1, 2, 1, 3], 2) 4 >>> max_assignments(5, [1, 2, 1, 2, 1], 1) 3 pass","solution":"def max_assignments(n, deadlines, b): Determines the maximum number of assignments that can be completed given the deadlines and the number of bonus days available. Parameters: n (int): Number of assignments deadlines (list of int): List of deadlines for each assignment b (int): Number of bonus days available Returns: int: Maximum number of assignments that can be completed from collections import Counter from heapq import heappop, heappush # Count the number of assignments for each deadline day deadline_counts = Counter(deadlines) # Convert to a min-heap for processing deadlines in order heap = [] for deadline, count in deadline_counts.items(): heappush(heap, (deadline, count)) completed_assignments = 0 # While there are bonus days and deadlines to process while b > 0 and heap: deadline, count = heappop(heap) # Consider the max assignments we can complete without bonus days if count > 1: # Use a bonus day to spread the assignments completed_assignments += 1 b -= 1 count -= 1 # Push the decreased count back to heap heappush(heap, (deadline, count)) else: completed_assignments += 1 # Any remaining assignments that can be completed without bonus days while heap: deadline, count = heappop(heap) completed_assignments += min(count, 1) return completed_assignments"},{"question":"def max_non_overlapping_deliveries(n, depots): Determines the maximum number of deliveries that can be scheduled without overlap for each depot. :param n: Number of depots :param depots: List of lists, where each list contains the deliveries for a depot. Each delivery is represented by a tuple (start_time, end_time) :return: List of integers representing the maximum number of non-overlapping deliveries for each depot.","solution":"def max_non_overlapping_deliveries(n, depots): Determines the maximum number of deliveries that can be scheduled without overlap for each depot. :param n: Number of depots :param depots: List of lists, where each list contains the deliveries for a depot. Each delivery is represented by a tuple (start_time, end_time) :return: List of integers representing the maximum number of non-overlapping deliveries for each depot. result = [] for deliveries in depots: if not deliveries: result.append(0) continue # Sort deliveries by ending time deliveries.sort(key=lambda x: x[1]) count = 1 last_end_time = deliveries[0][1] for i in range(1, len(deliveries)): if deliveries[i][0] >= last_end_time: count += 1 last_end_time = deliveries[i][1] result.append(count) return result"},{"question":"def can_transform(s1: str, s2: str) -> str: Determine if you can transform s1 into s2 by making a series of operations (insert, delete, or replace a character any number of times). >>> can_transform(\\"abc\\", \\"yabcx\\") \\"YES\\" >>> can_transform(\\"kitten\\", \\"sitting\\") \\"YES\\" >>> can_transform(\\"flaw\\", \\"lawn\\") \\"NO\\"","solution":"def can_transform(s1, s2): Determines if we can transform s1 into s2 by using a series of insert, delete, or replace operations. return \\"YES\\""},{"question":"def count_dives_above_threshold(n, dives, threshold): Returns the count of dives that scored strictly more than the threshold value. Args: n (int): The number of dives. dives (list of int): The points scored in each dive. threshold (int): The threshold value. Returns: int: The number of dives scoring more than the threshold value. Examples: >>> count_dives_above_threshold(5, [10, 20, 30, 40, 50], 25) 3 >>> count_dives_above_threshold(4, [100, 200, 300, 400], 50) 4 >>> count_dives_above_threshold(4, [10, 20, 30, 40], 50) 0 >>> count_dives_above_threshold(5, [50, 50, 50, 50, 50], 50) 0 >>> count_dives_above_threshold(1, [100], 90) 1 >>> count_dives_above_threshold(1, [60], 100) 0 >>> count_dives_above_threshold(7, [15, 25, 35, 45, 55, 65, 75], 50) 3 >>> count_dives_above_threshold(5, [100, 200, 299, 300, 400], 299) 2","solution":"def count_dives_above_threshold(n, dives, threshold): Returns the count of dives that scored strictly more than the threshold value. Args: n (int): The number of dives. dives (list of int): The points scored in each dive. threshold (int): The threshold value. Returns: int: The number of dives scoring more than the threshold value. return sum(dive > threshold for dive in dives) # Example usage: # n = 5 # dives = [10, 20, 30, 40, 50] # threshold = 25 # print(count_dives_above_threshold(n, dives, threshold)) # Output should be 3"},{"question":"def maximize_number(s: str) -> str: Given a string \`s\` consisting of digits from '0' to '9', return the string representing the maximum possible numerical value that can be obtained by removing exactly one digit from the original string. >>> maximize_number(\\"1234\\") \\"234\\" >>> maximize_number(\\"54321\\") \\"5432\\" >>> maximize_number(\\"10234\\") \\"1234\\"","solution":"def maximize_number(s): Return the string representing the maximum possible numerical value after removing one digit. max_value = \\"\\" for i in range(len(s)): current_value = s[:i] + s[i+1:] if current_value > max_value: max_value = current_value return max_value"},{"question":"from typing import List def min_teleportation_cost(n: int, k: int, f: int, costs: List[List[int]]) -> int: Calculate the minimum cost to travel from the first to the last room using a specified number of free teleportation moves. >>> min_teleportation_cost(5, 2, 1, [[3, 2], [6, 1], [5, 2], [1]]) 2 >>> min_teleportation_cost(4, 2, 0, [[1, 2], [3, 4], [1]]) 3 >>> min_teleportation_cost(5, 2, 2, [[3, 2], [6, 1], [5, 2], [1]]) 0 >>> min_teleportation_cost(4, 2, 3, [[1, 2], [3, 4], [1]]) 0","solution":"import heapq def min_teleportation_cost(n, k, f, costs): # A large value representing infinity INF = float('inf') # Minimum costs to reach each room min_cost = [INF] * n min_cost[0] = 0 # Priority queue for Dijkstra's algorithm pq = [(0, 0, f)] # (cost, current room, remaining free moves) while pq: current_cost, room, free_moves = heapq.heappop(pq) if room == n - 1: return current_cost if current_cost > min_cost[room]: continue # Try teleporting to the next rooms for i in range(1, k + 1): next_room = room + i if next_room >= n: break teleport_cost = current_cost + costs[room][i - 1] if teleport_cost < min_cost[next_room]: min_cost[next_room] = teleport_cost heapq.heappush(pq, (teleport_cost, next_room, free_moves)) if free_moves > 0: if current_cost < min_cost[next_room]: min_cost[next_room] = current_cost heapq.heappush(pq, (current_cost, next_room, free_moves - 1)) return min_cost[-1] def parse_input(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) k = int(data[1]) f = int(data[2]) costs = [] idx = 3 for _ in range(n - 1): row = [] for j in range(min(k, n - 1)): row.append(int(data[idx])) idx += 1 costs.append(row) return n, k, f, costs"},{"question":"from typing import List, Tuple def length_of_longest_substring(s: str, queries: List[Tuple[int, int]]) -> List[int]: For each query, return the length of the longest substring within the range that contains no repeating characters. Args: s (str): The string S. queries (list of tuples): List of queries with tuples (x, y) representing the start and end indices (inclusive) of the query. Returns: list of int: List of lengths of the longest substrings with no repeating characters for each query. >>> s = \\"abbabcbb\\" >>> queries = [(0, 3), (2, 5), (1, 7)] >>> length_of_longest_substring(s, queries) [2, 3, 3] >>> s = \\"aaaaaa\\" >>> queries = [(0, 2), (1, 3), (0, 5)] >>> length_of_longest_substring(s, queries) [1, 1, 1] >>> s = \\"abcde\\" >>> queries = [(0, 4), (1, 3), (2, 2)] >>> length_of_longest_substring(s, queries) [5, 3, 1] >>> s = \\"abababab\\" >>> queries = [(0, 7), (2, 5), (4, 7)] >>> length_of_longest_substring(s, queries) [2, 2, 2] >>> s = \\"abcdefg\\" >>> queries = [(0, 3), (2, 6), (0, 6)] >>> length_of_longest_substring(s, queries) [4, 5, 7]","solution":"def length_of_longest_substring(s, queries): For each query, return the length of the longest substring within the range that contains no repeating characters. Args: s (str): The string S. queries (list of tuples): List of queries with tuples (x, y) representing the start and end indices (inclusive) of the query. Returns: list of int: List of lengths of the longest substrings with no repeating characters for each query. def find_longest_unique_substring(s): start = 0 max_length = 0 used_chars = {} for end, char in enumerate(s): if char in used_chars and start <= used_chars[char]: start = used_chars[char] + 1 else: max_length = max(max_length, end - start + 1) used_chars[char] = end return max_length results = [] for x, y in queries: substring = s[x:y+1] results.append(find_longest_unique_substring(substring)) return results"},{"question":"def calculate_sub_array_sums(n, arr): Calculates the sum of elements in each sub-array starting from the first element up to the ith element. Parameters: n (int): Number of elements in the array. arr (list of int): List of n integers. Returns: list of int: List containing the sum of elements of each sub-array. Examples: >>> calculate_sub_array_sums(5, [1, 2, 3, 4, 5]) [1, 3, 6, 10, 15] >>> calculate_sub_array_sums(3, [10, 20, 30]) [10, 30, 60]","solution":"def calculate_sub_array_sums(n, arr): Calculates the sum of elements in each sub-array starting from the first element up to the ith element. Parameters: n (int): Number of elements in the array. arr (list of int): List of n integers. Returns: list of int: List containing the sum of elements of each sub-array. sums = [] current_sum = 0 for i in range(n): current_sum += arr[i] sums.append(current_sum) return sums"},{"question":"def min_cost_path(M, N, grid): Returns the minimum cost to reach the bottom-right corner of the grid from the top-left corner. >>> min_cost_path(3, 3, [[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 7 >>> min_cost_path(2, 2, [[1, 2], [1, 1]]) 3 >>> min_cost_path(1, 1, [[0]]) 0 >>> min_cost_path(1, 3, [[1, 2, 5]]) 8 >>> min_cost_path(3, 1, [[1], [2], [3]]) 6 >>> min_cost_path(4, 4, [[1, 3, 1, 2], [2, 1, 4, 1], [3, 2, 1, 3], [2, 4, 1, 1]]) 9 >>> min_cost_path(10, 10, [[100] * 10 for _ in range(10)]) 1900","solution":"def min_cost_path(M, N, grid): Returns the minimum cost to reach the bottom-right corner of the grid from the top-left corner. # Create a 2D list to store the minimum cost to reach each cell dp = [[0] * N for _ in range(M)] dp[0][0] = grid[0][0] # Initialize first row of dp array for j in range(1, N): dp[0][j] = dp[0][j - 1] + grid[0][j] # Initialize first column of dp array for i in range(1, M): dp[i][0] = dp[i - 1][0] + grid[i][0] # Fill the rest of the dp array for i in range(1, M): for j in range(1, N): dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] return dp[M - 1][N - 1] # Example usage: # M, N = 3, 3 # grid = [ # [1, 3, 1], # [1, 5, 1], # [4, 2, 1] # ] # print(min_cost_path(M, N, grid)) # Output: 7"},{"question":"def sort_events(events): Sorts a list of historical events based on their years in ascending order. Args: events (list of tuples): List of events where each event is represented as a tuple (year, description). Returns: list of tuples: Sorted list of events based on years. pass def read_input(n, input_lines): Reads input lines and converts them into a list of tuples of (year, description). Args: n (int): Number of events. input_lines (list of str): List of event descriptions in the form 'year description'. Returns: list of tuples: List of events represented as (year, description). pass if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().strip().split(\\"n\\") n = int(data[0]) input_lines = data[1:] events = read_input(n, input_lines) sorted_events = sort_events(events) for event in sorted_events: print(f\\"{event[0]} {event[1]}\\")","solution":"def sort_events(events): Sorts a list of historical events based on their years in ascending order. Args: events (list of tuples): List of events where each event is represented as a tuple (year, description). Returns: list of tuples: Sorted list of events based on years. return sorted(events, key=lambda x: x[0]) def read_input(n, input_lines): Reads input lines and converts them into a list of tuples of (year, description). Args: n (int): Number of events. input_lines (list of str): List of event descriptions in the form 'year description'. Returns: list of tuples: List of events represented as (year, description). events = [] for line in input_lines: parts = line.split(\\" \\", 1) year = int(parts[0]) description = parts[1] events.append((year, description)) return events if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().strip().split(\\"n\\") n = int(data[0]) input_lines = data[1:] events = read_input(n, input_lines) sorted_events = sort_events(events) for event in sorted_events: print(f\\"{event[0]} {event[1]}\\")"},{"question":"from typing import List, Tuple def find_minimum_leaders(P: int, friendships: List[Tuple[int, int]]) -> int: Given the total number of participants and their friendship relations, determine the smallest number of leaders needed such that every participant is included in one team or another. Parameters: P (int): Total number of participants. friendships (List[Tuple[int, int]]): A list of tuple pairs representing friendship relations. Returns: int: Minimum number of leaders required. >>> find_minimum_leaders(5, [(1, 2), (2, 3), (4, 5)]) 2 >>> find_minimum_leaders(4, []) 4 pass # Implement the function here def process_input(test_cases: List[dict]) -> List[int]: Processes multiple test cases. Parameters: test_cases (List[dict]): List of test case dictionaries, where each dictionary contains the number of participants ('P') and the list of friendships ('friendships'). Returns: List[int]: A list containing the results for each test case. >>> process_input([{'P': 5, 'friendships': [(1, 2), (2, 3), (4, 5)]}, {'P': 4, 'friendships': []}]) [2, 4] >>> process_input([{'P': 6, 'friendships': [(1, 2), (2, 3), (4, 5), (5, 6)]}, {'P': 3, 'friendships': [(1, 2), (2, 3)]}]) [2, 1] pass # Implement the function here","solution":"def find_minimum_leaders(P, friendships): from collections import defaultdict, deque def bfs(start, visited, adjacency_list): queue = deque([start]) visited[start] = True while queue: node = queue.popleft() for neighbor in adjacency_list[node]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) # Create an adjacency list from friendships adjacency_list = defaultdict(list) for x, y in friendships: adjacency_list[x].append(y) adjacency_list[y].append(x) visited = [False] * (P + 1) num_leaders = 0 # Determine the number of connected components for participant in range(1, P + 1): if not visited[participant]: num_leaders += 1 bfs(participant, visited, adjacency_list) return num_leaders def process_input(test_cases): results = [] for case in test_cases: P = case['P'] friendships = case['friendships'] results.append(find_minimum_leaders(P, friendships)) return results"},{"question":"def min_cost_to_travel(grid, N, M): Given a grid of dimension N x M, find the minimum cost to travel from the top-left corner (1, 1) to the bottom-right corner (N, M). Args: grid (List[List[int]]): A 2D list representing the cost grid. N (int): The number of rows in the grid. M (int): The number of columns in the grid. Returns: int: The minimum cost to travel from (1, 1) to (N, M) >>> min_cost_to_travel([[1, 3, 1], [1, 5, 1], [4, 2, 1]], 3, 3) 7 >>> min_cost_to_travel([[1, 2], [1, 1]], 2, 2) 3 pass def solve_all_cases(T, cases): Args: T (int): The number of test cases. cases (List[Tuple[int, int, List[List[int]]]]): Test cases where each test case is represented by a tuple containing number of rows (int), number of columns (int), and the grid (List[List[int]]). Returns: List[int]: A list containing the minimum cost for each test case. >>> solve_all_cases(2, [(3, 3, [[1, 3, 1], [1, 5, 1], [4, 2, 1]]), (2, 2, [[1, 2], [1, 1]])]) [7, 3] pass def test_min_cost_to_travel(): # Test case 1 T = 2 cases = [ (3, 3, [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ]), (2, 2, [ [1, 2], [1, 1] ]) ] expected_output = [7, 3] result = solve_all_cases(T, cases) assert result == expected_output def test_edge_case_single_cell(): T = 1 cases = [ (1, 1, [ [5] ]) ] expected_output = [5] result = solve_all_cases(T, cases) assert result == expected_output def test_edge_case_row(): T = 1 cases = [ (1, 4, [ [1, 2, 3, 4] ]) ] expected_output = [10] # Sum of all elements since it's a single row result = solve_all_cases(T, cases) assert result == expected_output def test_edge_case_column(): T = 1 cases = [ (4, 1, [ [1], [2], [3], [4] ]) ] expected_output = [10] # Sum of all elements since it's a single column result = solve_all_cases(T, cases) assert result == expected_output","solution":"import heapq def min_cost_to_travel(grid, N, M): # Using a priority queue to find the minimum cost path pq = [] heapq.heappush(pq, (grid[0][0], 0, 0)) # Directions arrays directions = [(1, 0), (0, 1), (-1, 0), (0, -1)] # Costs array to store the minimum cost to reach each cell costs = [[float('inf')] * M for _ in range(N)] costs[0][0] = grid[0][0] while pq: current_cost, x, y = heapq.heappop(pq) # If we have reached the bottom-right corner, return the cost if x == N-1 and y == M-1: return current_cost # Visit neighbors for direction in directions: nx, ny = x + direction[0], y + direction[1] if 0 <= nx < N and 0 <= ny < M: new_cost = current_cost + grid[nx][ny] if new_cost < costs[nx][ny]: costs[nx][ny] = new_cost heapq.heappush(pq, (new_cost, nx, ny)) def solve_all_cases(T, cases): results = [] for case in cases: N, M, grid = case result = min_cost_to_travel(grid, N, M) results.append(result) return results"},{"question":"import re def validate_employee_id(employee_id: str) -> str: Validates whether the given employee_id is in the correct format. A valid employee ID must: 1. Start with exactly 3 uppercase alphabets (A-Z). 2. Be followed by exactly 4 digits (0-9). 3. Optionally, it can include a prefix of 'EMP-' right at the beginning. For example, valid employee IDs: - \\"EMP-ABC1234\\" - \\"ABC1234\\" Returns 'Valid ID' if the format is correct, otherwise 'Invalid ID'. >>> validate_employee_id(\\"EMP-ABC1234\\") 'Valid ID' >>> validate_employee_id(\\"ABC1234\\") 'Valid ID' >>> validate_employee_id(\\"emp-ABC1234\\") 'Invalid ID' >>> validate_employee_id(\\"EMP-AB1234\\") 'Invalid ID' >>> validate_employee_id(\\"AB12345\\") 'Invalid ID' >>> validate_employee_id(\\"EMP-ABCDE123\\") 'Invalid ID' >>> validate_employee_id(\\"A1C1234\\") 'Invalid ID' >>> validate_employee_id(\\"EMP-\\") 'Invalid ID' >>> validate_employee_id(\\"EMP-ABC\\") 'Invalid ID' >>> validate_employee_id(\\"EMP-1234\\") 'Invalid ID' >>> validate_employee_id(\\"\\") 'Invalid ID' >>> validate_employee_id(\\"EMPEGH1234\\") 'Invalid ID' >>> validate_employee_id(\\"EMPT-ABC1234\\") 'Invalid ID'","solution":"import re def validate_employee_id(employee_id: str) -> str: Validates whether the given employee_id is in the correct format. Valid formats: - \\"EMP-ABC1234\\" - \\"ABC1234\\" Returns 'Valid ID' if the format is correct, otherwise 'Invalid ID'. pattern = re.compile(r'^(EMP-)?[A-Z]{3}d{4}') if pattern.match(employee_id): return \\"Valid ID\\" else: return \\"Invalid ID\\""},{"question":"def count_unique_visitors(log_entries: List[str]) -> List[str]: Calculate the number of unique visitors for each room from the log entries. Args: log_entries (List[str]): List of space-separated strings where the first part is the room number and the second part is the visitor ID. Returns: List[str]: List of strings in the format 'Room X: Y unique visitors' or 'Room X: Y unique visitor' sorted by room number. >>> count_unique_visitors([ ... \\"101 a123\\", ... \\"203 b456\\", ... \\"101 a123\\", ... \\"102 c789\\", ... \\"203 b456\\", ... \\"101 d012\\", ... \\"102 e345\\" ... ]) ['Room 101: 2 unique visitors', 'Room 102: 2 unique visitors', 'Room 203: 1 unique visitor'] >>> count_unique_visitors([ ... \\"301 mike\\", ... \\"302 john\\", ... \\"301 mike\\", ... \\"301 mike\\", ... \\"302 jane\\" ... ]) ['Room 301: 1 unique visitor', 'Room 302: 2 unique visitors']","solution":"def count_unique_visitors(log_entries): room_visitors = {} for log_entry in log_entries: room, visitor = log_entry.split() room = int(room) if room not in room_visitors: room_visitors[room] = set() room_visitors[room].add(visitor) result = [] for room in sorted(room_visitors.keys()): result.append(f\\"Room {room}: {len(room_visitors[room])} unique {'visitors' if len(room_visitors[room]) != 1 else 'visitor'}\\") return result"},{"question":"def is_safe_distribution(connections, panels): Determine if the electricity distribution is safe given power panel configurations. Args: connections (List[Tuple[int, int, int]]): List of tuples representing connections (u, v, w). panels (List[Tuple[int, int]]): List of tuples representing panels (p, c). Returns: str: \\"Yes\\" if distribution is safe, \\"No\\" otherwise. >>> connections = [ ... (1, 2, 10), ... (2, 3, 20), ... (3, 4, 30), ... (4, 5, 40), ... (5, 1, 50) ... ] >>> panels = [ ... (1, 35), ... (3, 45), ... (5, 120) ... ] >>> is_safe_distribution(connections, panels) 'No' >>> connections = [ ... (1, 2, 10), ... (2, 3, 20), ... (3, 4, 30), ... (4, 5, 40) ... ] >>> panels = [ ... (2, 100), ... (4, 100) ... ] >>> is_safe_distribution(connections, panels) 'Yes' pass","solution":"def is_safe_distribution(connections, panels): from collections import defaultdict # Dictionary to store loads on each panel total_load = defaultdict(int) # Aggregating all the loads on each panel for u, v, w in connections: total_load[u] += w total_load[v] += w # Checking each panel's load against its capacity for p, c in panels: if total_load[p] > c: return \\"No\\" return \\"Yes\\""},{"question":"def max_sum_after_one_swap(n: int, arr: List[int]) -> int: Determine the maximum possible sum of the array after one swap operation. >>> max_sum_after_one_swap(5, [1, 2, 3, 4, 5]) 15 >>> max_sum_after_one_swap(4, [-1, 2, -3, 4]) 2 >>> max_sum_after_one_swap(3, [-1, -2, -3]) -6 >>> max_sum_after_one_swap(5, [-1000000000, 1000000000, 0, 999999999, -999999999]) 0 >>> max_sum_after_one_swap(2, [-1000000000, 1000000000]) 0 >>> max_sum_after_one_swap(5, [5, 5, 5, 5, 5]) 25","solution":"def max_sum_after_one_swap(n, arr): Returns the maximum possible sum of the array after one swap operation. Since the sum of the array remains the same regardless of swaps, the sum is simply returned as the sum of the array. return sum(arr)"},{"question":"def min_moves_to_reach_end(grid: List[List[str]], R: int, C: int, start: Tuple[int, int], end: Tuple[int, int]) -> int: Determine the minimum number of moves for the character to reach the end position from the starting position on a grid map. >>> min_moves_to_reach_end([['.', '.', '.', '.', '.'], ['.', '#', '#', '#', '.'], ['.', '#', '.', '#', '.'], ['.', '#', '.', '.', '.'], ['.', '.', '.', '.', '.']], 5, 5, (0, 0), (4, 4)) 8 >>> min_moves_to_reach_end([['#', '#', '#'], ['#', '.', '#'], ['#', '#', '#']], 3, 3, (1, 1), (0, 0)) -1 >>> min_moves_to_reach_end([['.', '.', '.'], ['.', '.', '.'], ['.', '.', '.']], 3, 3, (0, 0), (2, 2)) 4 >>> min_moves_to_reach_end([['.', '.', '.'], ['.', '#', '.'], ['.', '.', '.']], 3, 3, (1, 1), (2, 2)) -1 >>> min_moves_to_reach_end([['.', '.', '.'], ['.', '#', '.'], ['.', '.', '.']], 3, 3, (0, 0), (1, 1)) -1 pass def main(input_lines: List[str]) -> int: Parse the input lines and return the minimum number of moves required to reach the end position. pass","solution":"from collections import deque def min_moves_to_reach_end(grid, R, C, start, end): directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] r_start, c_start = start r_end, c_end = end if grid[r_start][c_start] == '#' or grid[r_end][c_end] == '#': return -1 queue = deque([(r_start, c_start, 0)]) visited = set((r_start, c_start)) while queue: x, y, dist = queue.popleft() if (x, y) == (r_end, c_end): return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < R and 0 <= ny < C and (nx, ny) not in visited and grid[nx][ny] == '.': queue.append((nx, ny, dist + 1)) visited.add((nx, ny)) return -1 def main(input_lines): R, C = map(int, input_lines[0].strip().split()) grid = [list(input_lines[i + 1].strip()) for i in range(R)] r_start, c_start = map(int, input_lines[R + 1].strip().split()) r_end, c_end = map(int, input_lines[R + 2].strip().split()) return min_moves_to_reach_end(grid, R, C, (r_start, c_start), (r_end, c_end))"},{"question":"def is_word_valid(word: str, forbidden_substrings: list) -> str: Checks if the word is valid by verifying it does not contain any forbidden substrings. >>> is_word_valid(\\"alien\\", [\\"xyz\\", \\"123\\", \\"abcd\\"]) 'Word is valid' >>> is_word_valid(\\"alienlanguage\\", [\\"ali\\", \\"eng\\", \\"gua\\"]) 'Word is invalid' >>> is_word_valid(\\"astronaut\\", [\\"ron\\", \\"st\\", \\"abc\\"]) 'Word is invalid' >>> is_word_valid(\\"happyday\\", [\\"day\\", \\"sun\\", \\"moon\\"]) 'Word is invalid' >>> is_word_valid(\\"alienlanguage\\", [\\"xyz\\", \\"123\\", \\"abcd\\"]) 'Word is valid' >>> is_word_valid(\\"word\\", []) 'Word is valid' >>> is_word_valid(\\"coding\\", []) 'Word is valid' >>> is_word_valid(\\"pythoniscool\\", [\\"is\\"]) 'Word is invalid'","solution":"def is_word_valid(word, forbidden_substrings): Checks if the word is valid by verifying it does not contain any forbidden substrings. Parameters: word (str): The word to check. forbidden_substrings (list of str): List of forbidden substrings. Returns: str: \\"Word is valid\\" if the word does not contain any forbidden substrings, otherwise \\"Word is invalid\\". for forbidden in forbidden_substrings: if forbidden in word: return \\"Word is invalid\\" return \\"Word is valid\\""},{"question":"def shortest_paths(n: int, m: int, grid: List[str], queries: List[Tuple[int, int, int, int]]) -> List[int]: Given a grid-shaped campus and multiple queries, find the length of the shortest path between two given locations in each query. If no path exists, return -1 for that query. >>> shortest_paths(5, 5, [\\".....\\", \\".#.#.\\", \\".....\\", \\".#.#.\\", \\".....\\"], [(1, 1, 5, 5), (1, 1, 3, 3), (2, 2, 4, 4)]) == [8, 4, -1] >>> shortest_paths(3, 3, [\\"#\\", \\"#.#\\", \\"#\\"], [(2, 2, 2, 2), (2, 2, 3, 2), (2, 2, 1, 1)]) == [0, -1, -1] >>> shortest_paths(1, 5, [\\".....\\"], [(1, 1, 1, 5), (1, 2, 1, 4)]) == [4, 2] >>> shortest_paths(5, 1, [\\".\\", \\".\\", \\".\\", \\".\\", \\".\\"], [(1, 1, 5, 1), (2, 1, 4, 1)]) == [4, 2] >>> shortest_paths(3, 3, [\\"...\\", \\"...\\", \\"...\\"], [(1, 1, 3, 3), (1, 2, 2, 3)]) == [4, 2]","solution":"from collections import deque def bfs_shortest_path(grid, start, end, n, m): queue = deque([start]) visited = set([start]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] distance = {start: 0} while queue: current = queue.popleft() if current == end: return distance[current] for d in directions: neighbor = (current[0] + d[0], current[1] + d[1]) if 0 <= neighbor[0] < n and 0 <= neighbor[1] < m and neighbor not in visited and grid[neighbor[0]][neighbor[1]] == '.': queue.append(neighbor) visited.add(neighbor) distance[neighbor] = distance[current] + 1 return -1 def shortest_paths(n, m, grid, queries): results = [] for x1, y1, x2, y2 in queries: start = (x1 - 1, y1 - 1) end = (x2 - 1, y2 - 1) if grid[start[0]][start[1]] == '#' or grid[end[0]][end[1]] == '#': results.append(-1) else: results.append(bfs_shortest_path(grid, start, end, n, m)) return results"},{"question":"def hasPairWithDifference(arr, k): Determine if the array contains a pair of distinct indices i and j such that |arr[i] - arr[j]| = k and i != j. :param arr: List of integers. :param k: Non-negative integer representing the desired absolute difference between elements. :return: Boolean value, True if such a pair exists, False otherwise. >>> hasPairWithDifference([1, 5, 3, 4, 2], 3) True >>> hasPairWithDifference([1, 5, 3, 4, 2], 7) False >>> hasPairWithDifference([1, 2, 3, 4, 5], 1) True >>> hasPairWithDifference([], 1) False >>> hasPairWithDifference([4, 4, 4, 4, 4], 0) True","solution":"def hasPairWithDifference(arr, k): Determine if the array contains a pair of distinct indices i and j such that |arr[i] - arr[j]| = k and i != j. :param arr: List of integers. :param k: Non-negative integer representing the desired absolute difference between elements. :return: Boolean value, True if such a pair exists, False otherwise. seen = set() for num in arr: if num + k in seen or num - k in seen: return True seen.add(num) return False"},{"question":"from collections import deque def shortest_path_in_maze(m: int, n: int, grid: List[str]) -> int: Function to find the shortest path in a maze from top-left to bottom-right. Parameters: m (int): number of rows n (int): number of columns grid (list of str): representation of the maze where '.' is passable and '#' is blocked Returns: int: the length of the shortest path or -1 if no such path exists >>> shortest_path_in_maze(3, 3, [\\"..#\\", \\".#.\\", \\"...\\"]) == 4 >>> shortest_path_in_maze(3, 3, [\\"..#\\", \\"#\\", \\"..#\\"]) == -1","solution":"from collections import deque def shortest_path_in_maze(m, n, grid): Function to find the shortest path in a maze from top-left to bottom-right. Parameters: m (int): number of rows n (int): number of columns grid (list of str): representation of the maze where '.' is passable and '#' is blocked Returns: int: the length of the shortest path or -1 if no such path exists # Directions for movement in the grid: [right, down, left, up] directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # BFS initialization queue = deque([(0, 0)]) visited = set((0, 0)) steps = 0 while queue: for _ in range(len(queue)): x, y = queue.popleft() # If we've reached the bottom-right corner, return the number of steps if x == m - 1 and y == n - 1: return steps # Explore neighbors for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited and grid[nx][ny] == '.': visited.add((nx, ny)) queue.append((nx, ny)) steps += 1 # If the end is not reachable return -1"},{"question":"def min_operations_to_uniform_string(T: int, strings: List[str]) -> List[int]: Given T strings, this function returns the minimum number of operations needed to make all characters in each string the same. Parameters: T (int): The number of test cases. strings (list): A list of strings for which the operations need to be calculated. Returns: list: A list of integers where each integer corresponds to the minimum number of operations needed for each string. >>> min_operations_to_uniform_string(3, [\\"aabb\\", \\"abc\\", \\"zzzzz\\"]) [2, 2, 0] >>> min_operations_to_uniform_string(1, [\\"abcdefg\\"]) [6] >>> min_operations_to_uniform_string(2, [\\"abab\\", \\"aabbcc\\"]) [2, 4]","solution":"def min_operations_to_uniform_string(T, strings): Given T strings, this function returns the minimum number of operations needed to make all characters in each string the same. Parameters: T (int): The number of test cases. strings (list): A list of strings for which the operations need to be calculated. Returns: list: A list of integers where each integer corresponds to the minimum number of operations needed for each string. results = [] for s in strings: # Count frequency of each character in the string frequency = {} for char in s: if char in frequency: frequency[char] += 1 else: frequency[char] = 1 # Find the max frequency of any single character max_frequency = max(frequency.values()) # Minimum number of operations is the total length of string minus the max frequency min_operations = len(s) - max_frequency results.append(min_operations) return results"},{"question":"class FileStorageSystem: A file storage system that supports adding files, deleting files, and calculating the total size of files within a specified folder and its subfolders. >>> fss = FileStorageSystem() >>> fss.add_file('root/folder1', 500) >>> fss.add_file('root/folder1/folder2', 200) >>> fss.calculate_size('root/folder1') 700 >>> fss.delete_file('root/folder1/folder2', 200) >>> fss.calculate_size('root/folder1') 500 def __init__(self): # Initialize the file storage system with the root folder ... def add_file(self, folder_path: str, file_size: int): # Add a file of the specified size to the specified folder path ... def delete_file(self, folder_path: str, file_size: int): # Delete a file of the specified size from the specified folder path ... def calculate_size(self, folder_path: str) -> int: # Calculate the total size of files in the specified folder and its subfolders ... if __name__ == \\"__main__\\": import pytest from solution import FileStorageSystem def test_add_file(): fss = FileStorageSystem() fss.add_file('root/folder1', 500) assert fss.calculate_size('root/folder1') == 500 fss.add_file('root/folder1/folder2', 200) assert fss.calculate_size('root/folder1/folder2') == 200 def test_delete_file(): fss = FileStorageSystem() fss.add_file('root/folder1', 500) fss.add_file('root/folder1/folder2', 200) fss.delete_file('root/folder1/folder2', 200) assert fss.calculate_size('root/folder1/folder2') == 0 assert fss.calculate_size('root/folder1') == 500 def test_calculate_size(): fss = FileStorageSystem() fss.add_file('root/folder1', 500) fss.add_file('root/folder1/folder2', 200) fss.add_file('root/folder1/folder2/folder3', 100) assert fss.calculate_size('root/folder1') == 800 fss.delete_file('root/folder1/folder2', 200) assert fss.calculate_size('root/folder1') == 600 def test_complex_operations(): fss = FileStorageSystem() fss.add_file('root', 300) fss.add_file('root/folder1', 500) fss.add_file('root/folder1/folder2', 200) fss.add_file('root/folder1/folder2/folder3', 100) fss.add_file('root/folder2', 400) assert fss.calculate_size('root') == 1500 assert fss.calculate_size('root/folder1') == 800 fss.delete_file('root/folder1/folder2', 200) assert fss.calculate_size('root') == 1300 assert fss.calculate_size('root/folder1') == 600 pytest.main()","solution":"class FileStorageSystem: def __init__(self): self.storage = {'root': {'_size': 0}} def add_file(self, folder_path, file_size): folder_hierarchy = folder_path.split('/') current = self.storage for folder in folder_hierarchy: if folder not in current: current[folder] = {'_size': 0} current = current[folder] current['_size'] += file_size def delete_file(self, folder_path, file_size): folder_hierarchy = folder_path.split('/') current = self.storage for folder in folder_hierarchy: current = current[folder] current['_size'] -= file_size def calculate_size(self, folder_path): folder_hierarchy = folder_path.split('/') current = self.storage for folder in folder_hierarchy: current = current[folder] def get_total_size(folder): total_size = folder['_size'] for subfolder in folder: if subfolder != '_size': total_size += get_total_size(folder[subfolder]) return total_size return get_total_size(current)"},{"question":"def daily_temperatures(n: int, arr: List[int]) -> List[int]: Find the number of days you would have to wait until a warmer temperature for each day in the array. If there is no future day for which this is possible, then the answer for that day is 0. >>> daily_temperatures(8, [73, 74, 75, 71, 69, 72, 76, 73]) [1, 1, 4, 2, 1, 1, 0, 0] >>> daily_temperatures(5, [70, 70, 70, 70, 70]) [0, 0, 0, 0, 0] >>> daily_temperatures(4, [60, 61, 62, 63]) [1, 1, 1, 0] >>> daily_temperatures(4, [90, 85, 80, 75]) [0, 0, 0, 0] >>> daily_temperatures(1, [80]) [0] >>> daily_temperatures(2, [30, 40]) [1, 0] >>> daily_temperatures(2, [40, 30]) [0, 0]","solution":"def daily_temperatures(n, arr): result = [0] * n stack = [] for i in range(n): while stack and arr[stack[-1]] < arr[i]: prev_day = stack.pop() result[prev_day] = i - prev_day stack.append(i) return result"},{"question":"from typing import List def rotate_image(matrix: List[List[int]]) -> List[List[int]]: Rotates the input square matrix 90 degrees in the clockwise direction. >>> rotate_image([ [1, 2, 3], [4, 5, 6], [7, 8, 9] ]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> rotate_image([ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ]) [[13, 9, 5, 1], [14, 10, 6, 2], [15, 11, 7, 3], [16, 12, 8, 4]] >>> rotate_image([[1]]) [[1]] >>> rotate_image([ [1, 2], [3, 4] ]) [[3, 1], [4, 2]] >>> rotate_image([ [1, 1, 1], [1, 1, 1], [1, 1, 1] ]) [[1, 1, 1], [1, 1, 1], [1, 1, 1]]","solution":"from typing import List def rotate_image(matrix: List[List[int]]) -> List[List[int]]: Rotates the input square matrix 90 degrees in the clockwise direction. n = len(matrix) result = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): result[j][n - i - 1] = matrix[i][j] return result"},{"question":"def minimum_spanning_tree_cost(n: int, edges: List[Tuple[int, int, int]]) -> Union[int, str]: Calculate the minimum total cost to ensure every intersection is reachable from any other intersection. If it's impossible to connect all intersections, return \\"Impossible\\". Args: n (int): the number of intersections. edges (List[Tuple[int, int, int]]): a list of tuples where each tuple contains three integers u, v, w representing a bidirectional road between intersections u and v with cost w. Returns: Union[int, str]: the total minimum cost or \\"Impossible\\". Examples: >>> minimum_spanning_tree_cost(4, [(0, 1, 1), (1, 2, 2), (2, 3, 3), (3, 0, 4), (0, 2, 5)]) 6 >>> minimum_spanning_tree_cost(4, [(0, 1, 1), (1, 2, 2)]) \\"Impossible\\" >>> minimum_spanning_tree_cost(1, []) 0 >>> minimum_spanning_tree_cost(2, [(0, 1, 10)]) 10 >>> minimum_spanning_tree_cost(3, [(0, 1, 5)]) \\"Impossible\\" >>> minimum_spanning_tree_cost(3, [(0, 1, 1), (1, 2, 1), (0, 2, 2)]) 2","solution":"class UnionFind: def __init__(self, n): self.parent = list(range(n)) self.rank = [0] * n def find(self, u): if self.parent[u] != u: self.parent[u] = self.find(self.parent[u]) return self.parent[u] def union(self, u, v): root_u = self.find(u) root_v = self.find(v) if root_u != root_v: if self.rank[root_u] > self.rank[root_v]: self.parent[root_v] = root_u elif self.rank[root_u] < self.rank[root_v]: self.parent[root_u] = root_v else: self.parent[root_v] = root_u self.rank[root_u] += 1 def minimum_spanning_tree_cost(n, edges): if n == 1: return 0 uf = UnionFind(n) edges = sorted(edges, key=lambda x: x[2]) mst_cost = 0 edges_used = 0 for u, v, w in edges: if uf.find(u) != uf.find(v): uf.union(u, v) mst_cost += w edges_used += 1 if edges_used == n - 1: return mst_cost else: return \\"Impossible\\""},{"question":"from typing import List def min_moves_to_reach_bottom_right(M: int, N: int, grid: List[List[str]]) -> int: Alice wants to know the minimum number of moves required to reach the bottom-right corner from the top-left corner of the grid. If it's impossible for Alice to reach the destination, output -1 Args: M : int : Number of rows in the grid N : int : Number of columns in the grid grid : List[List[str]] : MxN grid containing '.' for an empty cell and '#' for an obstacle Returns: int : Minimum number of moves required to reach the bottom-right corner, or -1 if it's not possible. >>> min_moves_to_reach_bottom_right(3, 3, [['.','.','.'],['.','#','.'],['.','.','.']]) 4 >>> min_moves_to_reach_bottom_right(3, 3, [['.','.','.'],['#','#','#'],['.','.','.']]) -1 >>> min_moves_to_reach_bottom_right(1, 1, [['.']]) 0 >>> min_moves_to_reach_bottom_right(1, 1, [['#']]) -1 >>> min_moves_to_reach_bottom_right(5, 6, [['.', '.', '.', '#', '.', '.'], ['#', '#', '.', '#', '.', '#'], ['.', '.', '.', '.', '.', '.'], ['#', '#', '.', '#', '#', '.'], ['.', '.', '.', '.', '.', '.']]) 9","solution":"from collections import deque def min_moves_to_reach_bottom_right(M, N, grid): # Check if start or end cell is an obstacle if grid[0][0] == '#' or grid[M - 1][N - 1] == '#': return -1 # Directions for moving up, down, left, right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # BFS initialization queue = deque([(0, 0, 0)]) # (row, col, distance) visited = set((0, 0)) while queue: row, col, dist = queue.popleft() # If we have reached the bottom-right corner if row == M - 1 and col == N - 1: return dist for d in directions: new_row, new_col = row + d[0], col + d[1] if 0 <= new_row < M and 0 <= new_col < N and (new_row, new_col) not in visited and grid[new_row][new_col] == '.': queue.append((new_row, new_col, dist + 1)) visited.add((new_row, new_col)) # If we finished BFS and did not reach the bottom-right corner return -1"},{"question":"def save_the_trees(n: int): Determines if it's possible to split \`n\` saplings so that both Alice and Bob each receive an odd number of saplings. If possible, returns a tuple with the number of saplings each should receive. If not, returns -1. >>> save_the_trees(10) (5, 5) >>> save_the_trees(15) (7, 7) >>> save_the_trees(4) -1 pass def test_save_the_trees_even_saplings(): assert save_the_trees(10) == (5, 5) assert save_the_trees(6) == (3, 3) assert save_the_trees(12) == (5, 7) def test_save_the_trees_odd_saplings(): assert save_the_trees(7) == -1 assert save_the_trees(11) == -1 def test_save_the_trees_small_numbers(): assert save_the_trees(1) == -1 assert save_the_trees(2) == -1 def test_save_the_trees_edge_cases(): assert save_the_trees(100) == (49, 51)","solution":"def save_the_trees(n): Determines if it's possible to split \`n\` saplings so that both Alice and Bob each receive an odd number of saplings. If possible, returns a tuple with the number of saplings each should receive. If not, returns -1. if n < 3: return -1 elif n % 2 == 0: if (n // 2) % 2 == 1: return (n // 2, n // 2) else: return ((n // 2) - 1, (n // 2) + 1) else: return -1"},{"question":"def max_potion_power(n, potions): Returns the maximum power level of a potion that can be formed by combining two different potions from the list. :param n: int - the number of potions. :param potions: list of int - power levels of the potions. :return: int - the maximum power level achievable by combining two potions. Examples: >>> max_potion_power(5, [3, 7, 2, 9, 5]) 63 >>> max_potion_power(4, [8, 8, 4, 4]) 64 >>> max_potion_power(2, [1, 9]) 9 >>> max_potion_power(3, [1, 2, 3]) 6 >>> max_potion_power(5, [5, 5, 5, 5, 5]) 25 >>> max_potion_power(6, [2, 3, 4, 5, 6, 7]) 42 >>> max_potion_power(7, [1, 2, 3, 10**9, 10**9, 10**8, 10**8]) 10**18","solution":"def max_potion_power(n, potions): Returns the maximum power level of a potion that can be formed by combining two different potions from the list. :param n: int - the number of potions. :param potions: list of int - power levels of the potions. :return: int - the maximum power level achievable by combining two potions. if n < 2: raise ValueError(\\"There must be at least two potions to combine.\\") # Find the two largest unique elements in the list. first_max = second_max = 0 for p in potions: if p > first_max: second_max = first_max first_max = p elif p > second_max: second_max = p return first_max * second_max"},{"question":"from typing import List def findUnique(numbers: List[int]) -> int: Finds the element that appears exactly once when other elements appear exactly three times. Uses bitwise manipulation to achieve the result in O(n) time complexity with constant space. >>> findUnique([2, 2, 3, 2]) 3 >>> findUnique([0, 1, 0, 1, 0, 1, 99]) 99","solution":"from typing import List def findUnique(numbers: List[int]) -> int: Finds the element that appears exactly once when other elements appear exactly three times. Uses bitwise manipulation to achieve the result in O(n) time complexity with constant space. one, two = 0, 0 for num in numbers: # 'two' becomes 1 where 'one' and 'num' are both 1, and 'one' becomes 0 in those positions two |= one & num # 'one' becomes 1 if it is 1 in either 'one' or 'num', but not both one ^= num # remove bits that appear three times in 'one' and 'two' common_bits = one & two # clear common bits from 'one' and 'two' one &= ~common_bits two &= ~common_bits return one"},{"question":"def manage_containers(u: int, test_cases: List[Tuple[int, int, List[int], List[int], List[List[int]]]]) -> List[int]: Given an integer \`u\`, which represents the number of test cases, and a list of test cases, each test case is composed of m (number of containers), k (number of operations), a list of container capacities, a list of initial water amounts in the containers, and a list of operations, this function returns a list of results for all \`2 z\` queries. Args: u: int: The number of test cases. test_cases: List[Tuple[int, int, List[int], List[int], List[List[int]]]]: A list of test cases. Returns: List[int]: A list of results for all \`2 z\` queries in order. >>> manage_containers(2, [ (3, 5, [10, 10, 10], [5, 3, 2], [ [1, 1, 2], [2, 2], [1, 2, 3], [2, 3], [2, 1], ]), (7, 3, [12, 6, 8, 9, 15, 10, 11], [6, 5, 4, 3, 8, 1, 0], [ [1, 1, 4], [2, 4], [2, 6] ]) ]) [8, 10, 0, 9, 1]","solution":"def manage_containers(u, test_cases): results = [] for test_case in test_cases: m, k, capacities, water, operations = test_case for operation in operations: if operation[0] == 1: p, q = operation[1] - 1, operation[2] - 1 transferable_amount = min(water[p], capacities[q] - water[q]) water[p] -= transferable_amount water[q] += transferable_amount elif operation[0] == 2: z = operation[1] - 1 results.append(water[z]) return results"},{"question":"def solve(n: int, m: int, roads: List[Tuple[int, int, int]], q: int, queries: List[int]) -> List[int]: Solve the shortest path problem in a directed graph with given queries. Args: n : int : Number of cities m : int : Number of roads roads : List[Tuple[int, int, int]] : Each tuple contains three integers u, v, w indicating a road from city u to city v with distance w q : int : Number of queries queries : List[int] : Each integer represents a destination city k Returns: List[int] : List of shortest distances for each query from the central warehouse (city 1). If the city is not reachable, return -1. Examples: >>> solve(5, 6, [(1, 2, 2), (1, 3, 4), (2, 4, 7), (3, 4, 1), (4, 5, 3), (3, 5, 1)], 3, [4, 5, 2]) [5, 5, 2] >>> solve(3, 2, [(1, 2, 5), (2, 3, 10)], 2, [3, 2]) [15, 5] pass def test_example_1(): n, m = 5, 6 roads = [ (1, 2, 2), (1, 3, 4), (2, 4, 7), (3, 4, 1), (4, 5, 3), (3, 5, 1) ] q = 3 queries = [4, 5, 2] expected_output = [5, 5, 2] assert solve(n, m, roads, q, queries) == expected_output def test_example_2(): n, m = 3, 2 roads = [ (1, 2, 5), (2, 3, 10) ] q = 2 queries = [3, 2] expected_output = [15, 5] assert solve(n, m, roads, q, queries) == expected_output def test_unreachable_city(): n, m = 4, 2 roads = [ (1, 2, 5), (2, 3, 10) ] q = 2 queries = [4, 3] expected_output = [-1, 15] assert solve(n, m, roads, q, queries) == expected_output def test_self_loop(): n, m = 3, 3 roads = [ (1, 1, 0), (1, 2, 1), (2, 3, 1) ] q = 2 queries = [1, 3] expected_output = [0, 2] assert solve(n, m, roads, q, queries) == expected_output def test_single_city(): n, m = 1, 0 roads = [] q = 1 queries = [1] expected_output = [0] assert solve(n, m, roads, q, queries) == expected_output","solution":"from heapq import heappop, heappush import sys def dijkstra(n, edges, start): graph = [[] for _ in range(n + 1)] for u, v, w in edges: graph[u].append((w, v)) distances = [float('inf')] * (n + 1) distances[start] = 0 priority_queue = [(0, start)] # (distance, node) while priority_queue: current_distance, current_node = heappop(priority_queue) if current_distance > distances[current_node]: continue for weight, neighbor in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heappush(priority_queue, (distance, neighbor)) return distances def solve(n, m, roads, q, queries): sys.setrecursionlimit(200000) distances = dijkstra(n, roads, 1) result = [] for k in queries: if distances[k] == float('inf'): result.append(-1) else: result.append(distances[k]) return result"},{"question":"def min_bookshelf_shifts(N: int, indices: List[int]) -> int: Determine the minimum number of \\"bookshelf shifts\\" required to sort the books in non-decreasing order of their popularity indices. >>> min_bookshelf_shifts(5, [4, 3, 2, 6, 5]) 3 >>> min_bookshelf_shifts(4, [1, 2, 3, 4]) 0 >>> min_bookshelf_shifts(1, [1]) 0 >>> min_bookshelf_shifts(4, [4, 3, 2, 1]) 3 >>> min_bookshelf_shifts(4, [2, 2, 2, 2]) 0 >>> min_bookshelf_shifts(2, [2, 1]) 1","solution":"def min_bookshelf_shifts(N, indices): sorted_indices = sorted(indices) shifts_required = 0 for i in range(N): if indices[i] != sorted_indices[i]: shifts_required += 1 min_index = i for j in range(i + 1, N): if indices[j] < indices[min_index]: min_index = j indices = [indices[min_index]] + indices[:min_index] + indices[min_index + 1:] return shifts_required"},{"question":"def findPairs(arr: List[int], target: int) -> List[List[int]]: Given an array of distinct integers, return all pairs of integers whose sum is equal to the given target value. The result should be an array of pairs in the ascending order of the first element, and for pairs with the same first element, the second element should be in ascending order as well. If no such pair exists, return an empty array. >>> findPairs([1, 2, 3, 4, 5], 5) [[1, 4], [2, 3]] >>> findPairs([0, -1, 2, -3, 1], -2) [[-3, 1]] >>> findPairs([1, 3, 2, 4], 8) []","solution":"def findPairs(arr, target): Find all pairs of integers in the array whose sum equals the target value. Parameters: arr (list): A list of distinct integers. target (int): The target sum value. Returns: list: A list of pairs (each pair is a list of two integers) whose sum equals the target value. pair_dict = {} pairs = [] for number in arr: complement = target - number if complement in pair_dict: pairs.append([min(number, complement), max(number, complement)]) pair_dict[number] = True # Sorting pairs primarily by the first element, then by the second element if the first is the same pairs.sort() return pairs"},{"question":"from collections import deque class Stack: def __init__(self): Initialize an empty deque to act as the queue. self.queue = deque() def push(self, x): Push element x onto stack. pass # To be implemented def pop(self): Removes the element on top of the stack and returns that element. pass # To be implemented def process_queries(queries): Process a list of queries on the stack and return the results of pop operations. >>> process_queries([(1, 2), (1, 3), (2,), (1, 4), (2,)]) [3, 4] >>> process_queries([(1, 2), (2,), (2,), (1, 3)]) [2, -1] >>> process_queries([(1, 100), (2,), (1, 50), (2,), (2,)]) [100, 50, -1] >>> process_queries([]) [] pass # To be implemented","solution":"from collections import deque class Stack: def __init__(self): Initialize an empty deque to act as the queue. self.queue = deque() def push(self, x): Push element x onto stack. self.queue.append(x) for _ in range(len(self.queue) - 1): self.queue.append(self.queue.popleft()) def pop(self): Removes the element on top of the stack and returns that element. if not self.queue: return -1 return self.queue.popleft() def process_queries(queries): stack = Stack() results = [] for query in queries: if query[0] == 1: stack.push(query[1]) elif query[0] == 2: results.append(stack.pop()) return results"},{"question":"def evaluate_expression(expression: str) -> int: Evaluates a given arithmetic expression containing digits, '(', ')', '+', '-', '*', and '/' (performing integer division). Args: expression (str): The arithmetic expression to evaluate. Returns: int: The result of the evaluated expression. >>> evaluate_expression(\\"3+4\\") == 7 >>> evaluate_expression(\\"7-2\\") == 5 >>> evaluate_expression(\\"3*3\\") == 9 >>> evaluate_expression(\\"8/2\\") == 4 >>> evaluate_expression(\\"3+4*2\\") == 11 >>> evaluate_expression(\\"3*4+2\\") == 14 >>> evaluate_expression(\\"(3+4)*2\\") == 14 >>> evaluate_expression(\\"3*(2+4)/2-5\\") == 4 >>> evaluate_expression(\\"((2+3)*(2+2))/5\\") == 4 >>> evaluate_expression(\\"10+2*6\\") == 22 >>> evaluate_expression(\\"100*2+12\\") == 212 >>> evaluate_expression(\\"100*(2+12)/14\\") == 100","solution":"def evaluate_expression(expression): Evaluates a given arithmetic expression containing digits, '(', ')', '+', '-', '*', and '/' (performing integer division). Args: expression (str): The arithmetic expression to evaluate. Returns: int: The result of the evaluated expression. def compute(operators, values): Helper function to perform arithmetic operations right = values.pop() left = values.pop() op = operators.pop() if op == '+': values.append(left + right) elif op == '-': values.append(left - right) elif op == '*': values.append(left * right) elif op == '/': values.append(left // right) def precedence(op): Return precedence order for operations if op in ('+', '-'): return 1 if op in ('*', '/'): return 2 return 0 operators = [] values = [] i = 0 while i < len(expression): if expression[i].isdigit(): val = 0 while (i < len(expression) and expression[i].isdigit()): val = val * 10 + int(expression[i]) i += 1 values.append(val) i -= 1 # since i will be incremented in the for loop elif expression[i] == '(': operators.append(expression[i]) elif expression[i] == ')': while operators and operators[-1] != '(': compute(operators, values) operators.pop() # remove '(' elif expression[i] in \\"+-*/\\": while (operators and precedence(operators[-1]) >= precedence(expression[i])): compute(operators, values) operators.append(expression[i]) i += 1 while operators: compute(operators, values) return values[-1]"},{"question":"def is_prime(n: int) -> bool: Check if a number is prime. >>> is_prime(2) True >>> is_prime(4) False >>> is_prime(17) True >>> is_prime(18) False # Your code here def product_of_unique_primes(arr: List[int]) -> int: Return the product of all unique prime numbers in the given array. If no prime numbers are found, return 1. >>> product_of_unique_primes([4, 7, 8, 15, 7, 19]) 133 >>> product_of_unique_primes([4, 6, 8, 10]) 1 >>> product_of_unique_primes([11, 15, 17, 19, 11]) 3553 >>> product_of_unique_primes([]) 1 # Your code here","solution":"def is_prime(n): Check if a number is prime. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False p = 3 while p * p <= n: if n % p == 0: return False p += 2 return True def product_of_unique_primes(arr): Return the product of all unique prime numbers in the given array. If no prime numbers are found, return 1. unique_primes = set(num for num in arr if is_prime(num)) if not unique_primes: return 1 product = 1 for prime in unique_primes: product *= prime return product"},{"question":"from typing import List, Tuple def minimum_cost_to_color_all_squares(t: int, test_cases: List[Tuple[int, int]]) -> List[int]: Calculate the minimum cost to color all squares black given the initial position of the black square. Parameters: t (int): the number of test cases. test_cases (List[Tuple[int, int]]): list of tuples where each tuple contains n (int), the number of unit squares, and k (int), the index (1-based) of the initial black square. Returns: List[int]: list of integers where each integer represents the minimum total cost to color all squares black. Examples: >>> minimum_cost_to_color_all_squares(3, [(5, 3), (7, 1), (4, 4)]) [4, 6, 3] >>> minimum_cost_to_color_all_squares(1, [(1, 1)]) [0] import pytest from solution import minimum_cost_to_color_all_squares def test_example_case_1(): assert minimum_cost_to_color_all_squares(1, [(5, 3)]) == [4] def test_example_case_2(): assert minimum_cost_to_color_all_squares(1, [(7, 1)]) == [6] def test_example_case_3(): assert minimum_cost_to_color_all_squares(1, [(4, 4)]) == [3] def test_case_all_squares_left(): assert minimum_cost_to_color_all_squares(1, [(10, 1)]) == [9] def test_case_all_squares_right(): assert minimum_cost_to_color_all_squares(1, [(10, 10)]) == [9] def test_both_sides_same_cost(): assert minimum_cost_to_color_all_squares(1, [(6, 3)]) == [5] assert minimum_cost_to_color_all_squares(1, [(6, 4)]) == [5] def test_single_test_case(): assert minimum_cost_to_color_all_squares(1, [(1, 1)]) == [0] def test_multiple_test_cases(): assert minimum_cost_to_color_all_squares(3, [(5, 3), (7, 1), (4, 4)]) == [4, 6, 3]","solution":"def minimum_cost_to_color_all_squares(t, test_cases): results = [] for n, k in test_cases: # Calculate distance left to first square and right to last square left_cost = k - 1 right_cost = n - k # Minimum overall cost taking the smaller of the left or right initial path total_cost = left_cost + right_cost results.append(total_cost) return results"},{"question":"def decodeString(s: str) -> str: Decodes the given encoded string according to the rules specified. >>> decodeString(\\"4a1b5c\\") \\"aaaabccccc\\" >>> decodeString(\\"2d3e4f\\") \\"ddeeeffff\\" def test_single_run(): assert decodeString(\\"4a\\") == \\"aaaa\\" def test_multiple_runs_with_same_char(): assert decodeString(\\"1a1a1a1a\\") == \\"aaaa\\" def test_multiple_runs_with_different_chars(): assert decodeString(\\"4a1b5c\\") == \\"aaaabccccc\\" assert decodeString(\\"2d3e4f\\") == \\"ddeeeffff\\" def test_empty_string(): assert decodeString(\\"\\") == \\"\\" def test_single_character_run(): assert decodeString(\\"1a\\") == \\"a\\" assert decodeString(\\"5b\\") == \\"bbbbb\\" def test_mixed_characters_and_lengths(): assert decodeString(\\"10x2y1z\\") == \\"xxxxxxxxxxyyz\\" def test_no_repetitions(): assert decodeString(\\"1a1b1c\\") == \\"abc\\"","solution":"import re def decodeString(s): Decodes the given encoded string according to the rules specified. pattern = re.compile(r'(d+)(w)') decoded_string = \\"\\" for match in pattern.finditer(s): count = int(match.group(1)) char = match.group(2) decoded_string += char * count return decoded_string"},{"question":"def count_odd_sum_pairs(test_cases): Count the number of distinct pairs (i, j) (i < j) in each test case's sequence such that the sum of the numbers is odd. Args: - test_cases (List[Tuple[int, List[int]]]): A list of tuples, where each tuple contains an integer N and a list of N integers. Returns: List[int]: A list of integers, where each integer is the count of distinct pairs with an odd sum for the corresponding test case. >>> count_odd_sum_pairs([(3, [1, 2, 3]), (4, [1, 1, 2, 2])]) [2, 4] >>> count_odd_sum_pairs([(3, [2, 4, 6])]) [0] >>> count_odd_sum_pairs([(4, [1, 3, 5, 7])]) [0] pass def parse_input(input_string): Parse the input string into a list of test cases. Args: - input_string (str): A string representing multiple test cases. Returns: List[Tuple[int, List[int]]]: A list of tuples, where each tuple contains an integer N and a list of N integers. >>> parse_input(\\"2n3n1 2 3n4n1 1 2 2\\") [(3, [1, 2, 3]), (4, [1, 1, 2, 2])] pass","solution":"def count_odd_sum_pairs(test_cases): results = [] for case in test_cases: N, sequence = case odd_count = sum(1 for x in sequence if x % 2 != 0) even_count = N - odd_count results.append(odd_count * even_count) return results def parse_input(input_string): data = input_string.split() T = int(data[0]) index = 1 test_cases = [] for _ in range(T): N = int(data[index]) sequence = list(map(int, data[index + 1: index + 1 + N])) test_cases.append((N, sequence)) index += N + 1 return test_cases"},{"question":"def lcs_length(strings): Returns the length of the longest common subsequence (LCS) among the given list of strings. Args: strings (list of str): The list of strings to find the LCS. Returns: int: The length of the longest common subsequence among all the given strings. Example: >>> lcs_length([\\"abcde\\", \\"ace\\", \\"ae\\"]) 2 >>> lcs_length([\\"abc\\", \\"xyz\\"]) 0","solution":"def lcs_length(strings): Returns the length of the longest common subsequence (LCS) among the given list of strings. from functools import lru_cache def lcs_helper(s1, s2): Returns the LCS length between two strings s1 and s2 using dynamic programming. @lru_cache(None) def dp(i, j): if i == 0 or j == 0: return 0 if s1[i-1] == s2[j-1]: return dp(i-1, j-1) + 1 else: return max(dp(i-1, j), dp(i, j-1)) return dp(len(s1), len(s2)) def lcs_multiple(strings): Calculates the LCS for multiple strings by iteratively calculating the LCS of pairs. if not strings: return 0 current_lcs = strings[0] for i in range(1, len(strings)): next_lcs = [] m, n = len(current_lcs), len(strings[i]) dp_table = [[0] * (n + 1) for _ in range(m + 1)] for x in range(1, m + 1): for y in range(1, n + 1): if current_lcs[x - 1] == strings[i][y - 1]: dp_table[x][y] = dp_table[x - 1][y - 1] + 1 else: dp_table[x][y] = max(dp_table[x - 1][y], dp_table[x][y - 1]) x, y = m, n while x > 0 and y > 0: if current_lcs[x - 1] == strings[i][y - 1]: next_lcs.append(current_lcs[x - 1]) x -= 1 y -= 1 elif dp_table[x - 1][y] >= dp_table[x][y - 1]: x -= 1 else: y -= 1 next_lcs.reverse() current_lcs = ''.join(next_lcs) return len(current_lcs) return lcs_multiple(strings)"},{"question":"def find_max_overlap(events): Finds the maximum number of overlapping events. Parameters: events (List[Tuple[int, int]]): A list of tuples representing events with start and end times. Returns: int: The maximum number of overlapping events. pass def max_overlapping_events(T, test_cases): Determines the maximum number of overlapping events for multiple test cases. Parameters: T (int): Number of test cases. test_cases (List[Tuple[int, List[Tuple[int, int]]]]): List of test cases where each test case includes the number of events and a list of tuples representing event start and end times. Returns: List[int]: List containing the maximum number of overlapping events for each test case. pass def parse_input(input_data): Parses the input data into the number of test cases and the event data for each test case. Parameters: input_data (str): A string representation of the input data. Returns: Tuple[int, List[Tuple[int, List[Tuple[int, int]]]]]: Parsed number of test cases and a list of test cases containing event data. pass import pytest def test_max_overlap(): input_data = \\"2n3n1 4n2 5n6 8n4n1 10n2 5n3 6n7 11\\" T, test_cases = parse_input(input_data) assert max_overlapping_events(T, test_cases) == [2, 3] def test_single_event(): input_data = \\"1n1n0 5\\" T, test_cases = parse_input(input_data) assert max_overlapping_events(T, test_cases) == [1] def test_no_overlap(): input_data = \\"1n3n1 2n3 4n5 6\\" T, test_cases = parse_input(input_data) assert max_overlapping_events(T, test_cases) == [1] def test_all_events_overlap(): input_data = \\"1n3n1 10n2 9n3 8\\" T, test_cases = parse_input(input_data) assert max_overlapping_events(T, test_cases) == [3] def test_multiple_overlaps(): input_data = \\"1n4n1 4n2 6n3 5n5 7\\" T, test_cases = parse_input(input_data) assert max_overlapping_events(T, test_cases) == [3] if __name__ == \\"__main__\\": pytest.main()","solution":"def find_max_overlap(events): events.sort(key=lambda x: (x[0], x[1])) start_times = sorted([event[0] for event in events]) end_times = sorted([event[1] for event in events]) max_overlap = 0 current_overlap = 0 i, j = 0, 0 n = len(events) while i < n and j < n: if start_times[i] < end_times[j]: current_overlap += 1 max_overlap = max(max_overlap, current_overlap) i += 1 else: current_overlap -= 1 j += 1 return max_overlap def max_overlapping_events(T, test_cases): results = [] for case in test_cases: N, events = case results.append(find_max_overlap(events)) return results def parse_input(input_data): lines = input_data.strip().split(\\"n\\") T = int(lines[0]) test_cases = [] index = 1 for _ in range(T): N = int(lines[index]) events = [] for j in range(N): S, E = map(int, lines[index + 1 + j].split()) events.append((S, E)) test_cases.append((N, events)) index += N + 1 return T, test_cases"},{"question":"def find_anagram_pairs(words: List[str]) -> List[Tuple[int, int]]: Returns a list of tuples containing indices of anagram pairs in the input list. >>> find_anagram_pairs([\\"listen\\", \\"silent\\", \\"enlist\\", \\"rat\\", \\"tar\\", \\"art\\", \\"star\\"]) [(0, 1), (0, 2), (1, 2), (3, 4), (3, 5), (4, 5)] >>> find_anagram_pairs([\\"hello\\", \\"world\\", \\"python\\", \\"code\\"]) []","solution":"def find_anagram_pairs(words): Returns a list of tuples containing indices of anagram pairs in the input list. :param words: A list of strings :return: A list of tuples with the indices of anagram pairs anagram_dict = {} for i, word in enumerate(words): sorted_word = ''.join(sorted(word)) if sorted_word in anagram_dict: anagram_dict[sorted_word].append(i) else: anagram_dict[sorted_word] = [i] anagram_pairs = [] for indices in anagram_dict.values(): for i in range(len(indices)): for j in range(i+1, len(indices)): anagram_pairs.append((indices[i], indices[j])) return anagram_pairs"},{"question":"from typing import List, Tuple def longest_path(n: int, edges: List[Tuple[int, int]]) -> int: Calculates the length of the longest path in a given tree. The function expects the number of nodes 'n' and a list of edges where each edge is represented as a tuple. >>> longest_path(1, []) 0 >>> longest_path(5, [(1, 2), (2, 3), (3, 4), (3, 5)]) 3 >>> longest_path(7, [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)]) 4 from solution import longest_path def test_single_node(): assert longest_path(1, []) == 0 def test_simple_path(): assert longest_path(5, [(1, 2), (2, 3), (3, 4), (3, 5)]) == 3 def test_balanced_tree(): assert longest_path(7, [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)]) == 4 def test_long_line(): assert longest_path(9, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 7), (7, 8), (8, 9)]) == 8 def test_non_perfect_tree(): assert longest_path(6, [(1, 2), (2, 3), (2, 4), (3, 5), (4, 6)]) == 4 def test_another_balanced_tree(): assert longest_path(15, [(1, 2), (1, 3), (2, 4), (2, 5), (4, 6), (4, 7), (3, 8), (3, 9), (8, 10), (8, 11), (6, 12), (6, 13), (7, 14), (7, 15)]) == 7","solution":"def longest_path(n, edges): Calculates the length of the longest path in a given tree. The function expects the number of nodes 'n' and a list of edges where each edge is represented as a tuple. from collections import defaultdict, deque if n == 1: return 0 def bfs(farthest_node): visited = [-1] * (n + 1) q = deque([farthest_node]) visited[farthest_node] = 0 max_dist_node = farthest_node while q: node = q.popleft() for neighbor in tree[node]: if visited[neighbor] == -1: visited[neighbor] = visited[node] + 1 q.append(neighbor) if visited[neighbor] > visited[max_dist_node]: max_dist_node = neighbor return max_dist_node, visited[max_dist_node] tree = defaultdict(list) for x, y in edges: tree[x].append(y) tree[y].append(x) # First BFS to find one end of the longest path farthest_node, _ = bfs(1) # Second BFS to find the length of the path from the farthest_node _, longest_path_length = bfs(farthest_node) return longest_path_length"},{"question":"from typing import List class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_k_nodes(n: int, lst: List[int], k: int) -> List[int]: Given a linked list, reverse every k nodes of the linked list. Args: n : int : size of the linked list lst : List[int] : elements of the linked list k : int : number of nodes to reverse each time Returns: List[int] : modified linked list after the specified operation Examples: >>> reverse_k_nodes(8, [1, 2, 3, 4, 5, 6, 7, 8], 3) [3, 2, 1, 6, 5, 4, 7, 8] >>> reverse_k_nodes(4, [1, 2, 3, 4], 4) [4, 3, 2, 1]","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverseKGroup(head, k): def reverseLinkedList(head, k): new_head, ptr = None, head while k: next_node = ptr.next ptr.next = new_head new_head = ptr ptr = next_node k -= 1 return new_head ptr = head count = 0 while ptr: count += 1 ptr = ptr.next dummy = ListNode(0) dummy.next = head prev_group = dummy while count >= k: tail = prev_group.next for _ in range(k): tail = tail.next count -= 1 reversed_head = reverseLinkedList(prev_group.next, k) prev_group.next.next = tail prev_group.next, prev_group = reversed_head, prev_group.next return dummy.next def list_to_linked_list(lst): dummy = ListNode(0) curr = dummy for e in lst: curr.next = ListNode(e) curr = curr.next return dummy.next def linked_list_to_list(head): res = [] while head: res.append(head.val) head = head.next return res def reverse_k_nodes(n, lst, k): head = list_to_linked_list(lst) new_head = reverseKGroup(head, k) return linked_list_to_list(new_head)"},{"question":"def transpose_matrix(matrix): Returns the transpose of a given matrix. >>> transpose_matrix([[1, 2], [3, 4]]) [[1, 3], [2, 4]] >>> transpose_matrix([[1, 2, 3], [4, 5, 6]]) [[1, 4], [2, 5], [3, 6]] >>> transpose_matrix([[1, 2, 3]]) [[1], [2], [3]] >>> transpose_matrix([[1], [2], [3]]) [[1, 2, 3]] >>> transpose_matrix([[1, -2], [-3, 4]]) [[1, -3], [-2, 4]] >>> transpose_matrix([[1, 0, 0], [0, 1, 0], [0, 0, 1]]) [[1, 0, 0], [0, 1, 0], [0, 0, 1]] # Your code here","solution":"def transpose_matrix(matrix): Returns the transpose of a given matrix. return [list(row) for row in zip(*matrix)]"},{"question":"def max_sum_subarray(arr: List[int], k: int) -> int: Find the maximum sum of a subarray of length k from an array. >>> max_sum_subarray([1, 2, 3, -2, 5], 3) 6 >>> max_sum_subarray([4], 1) 4 >>> max_sum_subarray([3, 5, 2, 1, 7, 9, 0, -2, 3, 6], 10) 34 >>> max_sum_subarray([-1, -2, -3, -4], 2) -3 >>> max_sum_subarray([2, 1, 5, 1, 3], 5) 12 >>> max_sum_subarray([0]*50000 + [1]*50000, 50000) 50000 >>> max_sum_subarray([4, -1, 2, 1, -5, 4, 3], 4) 6","solution":"def max_sum_subarray(arr, k): n = len(arr) if k > n: # validation for logically impossible cases return None max_sum = float('-inf') current_sum = sum(arr[:k]) max_sum = current_sum for i in range(k, n): current_sum += arr[i] - arr[i - k] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def longest_unique_substring_after_deletion(s: str) -> int: Returns the length of the longest substring with all unique characters that can be obtained after deleting exactly one character from the string s. >>> longest_unique_substring_after_deletion(\\"abcde\\") 4 >>> longest_unique_substring_after_deletion(\\"abac\\") 3 >>> longest_unique_substring_after_deletion(\\"aaaa\\") 1 >>> longest_unique_substring_after_deletion(\\"abcd\\") 3 >>> longest_unique_substring_after_deletion(\\"\\") 0 >>> longest_unique_substring_after_deletion(\\"a\\") 0 >>> longest_unique_substring_after_deletion(\\"aa\\") 1 >>> longest_unique_substring_after_deletion(\\"ab\\") 1 >>> longest_unique_substring_after_deletion(\\"abca\\") 3 >>> longest_unique_substring_after_deletion(\\"abcbc\\") 3","solution":"def longest_unique_substring_after_deletion(s): Returns the length of the longest substring with all unique characters that can be obtained after deleting exactly one character from the string s. n = len(s) if n <= 1: return 0 max_len = 0 for i in range(n): # Generate a new string by skipping the i-th character new_s = s[:i] + s[i+1:] unique_chars = set(new_s) max_len = max(max_len, len(unique_chars)) return max_len"},{"question":"def primeSum(N: int) -> int: Returns the sum of all prime numbers less than or equal to N. >>> primeSum(10) 17 >>> primeSum(20) 77 >>> primeSum(0) 0 >>> primeSum(1) 0 >>> primeSum(1_000_000) 37550402023","solution":"def primeSum(N): Returns the sum of all prime numbers less than or equal to N. if N < 2: return 0 sieve = [True] * (N + 1) sieve[0] = sieve[1] = False for start in range(2, int(N**0.5) + 1): if sieve[start]: for multiple in range(start * start, N + 1, start): sieve[multiple] = False return sum(i for i, prime in enumerate(sieve) if prime)"},{"question":"def minAbsDifference(arr: List[int]) -> int: Given a list of n integers, find the minimum absolute difference between any two elements in the list. Parameters: arr (List[int]): List of integers Returns: int: The minimum absolute difference Examples: >>> minAbsDifference([3, 8, 15, 17]) 2 >>> minAbsDifference([1, 19, 5, 11, 10]) 1 from typing import List def test_min_abs_difference_example1(): assert minAbsDifference([3, 8, 15, 17]) == 2 def test_min_abs_difference_example2(): assert minAbsDifference([1, 19, 5, 11, 10]) == 1 def test_min_abs_difference_single_element(): assert minAbsDifference([4]) == 0 # Only one element, no difference to calculate def test_min_abs_difference_identical_elements(): assert minAbsDifference([1, 1, 1, 1]) == 0 # All elements the same, difference is zero def test_min_abs_difference_large_range(): arr = [-1000000000, 0, 1000000000] assert minAbsDifference(arr) == 1000000000 def test_min_abs_difference_mixed_signs(): assert minAbsDifference([-2, 1, 3, -4, 5]) == 2 # |-2 - (-4)| = 2 def test_min_abs_difference_negative_numbers(): assert minAbsDifference([-3, -8, -15, -17]) == 2 # Same as positive equivalent just negative def test_min_abs_difference_duplicates(): assert minAbsDifference([1, 6, 1]) == 0 # The duplicate 1s result in a difference of 0","solution":"def minAbsDifference(arr): Returns the minimum absolute difference between any two elements in the list. if len(arr) < 2: return 0 # No difference can be found if there's less than 2 elements arr.sort() # Sort the array in ascending order. min_diff = float('inf') for i in range(len(arr) - 1): min_diff = min(min_diff, abs(arr[i] - arr[i + 1])) return min_diff"},{"question":"from typing import List def min_cells_to_connect(n: int, m: int, grid: List[str]) -> int: Returns the minimum number of cells required to connect the top-left cell to the bottom-right cell, or -1 if it is not possible. >>> min_cells_to_connect(5, 5, [\\"PPPPP\\", \\"PFFFP\\", \\"PFRFP\\", \\"PFFFP\\", \\"PPPPP\\"]) 9 >>> min_cells_to_connect(4, 4, [\\"PFRP\\", \\"FFPP\\", \\"PFRR\\", \\"RPPP\\"]) -1 >>> min_cells_to_connect(3, 3, [\\"PPP\\", \\"PFP\\", \\"PPP\\"]) 5 pass # Add your implementation here # Unit tests def test_min_cells_to_connect_case_1(): n, m = 5, 5 grid = [ \\"PPPPP\\", \\"PFFFP\\", \\"PFRFP\\", \\"PFFFP\\", \\"PPPPP\\" ] assert min_cells_to_connect(n, m, grid) == 9 def test_min_cells_to_connect_case_2(): n, m = 4, 4 grid = [ \\"PFRP\\", \\"FFPP\\", \\"PFRR\\", \\"RPPP\\" ] assert min_cells_to_connect(n, m, grid) == -1 def test_min_cells_to_connect_case_3(): n, m = 3, 3 grid = [ \\"PPP\\", \\"PFP\\", \\"PPP\\" ] assert min_cells_to_connect(n, m, grid) == 5 def test_min_cells_to_connect_start_not_plain(): n, m = 3, 3 grid = [ \\"FRP\\", \\"PFP\\", \\"PPP\\" ] assert min_cells_to_connect(n, m, grid) == -1 def test_min_cells_to_connect_end_not_plain(): n, m = 3, 3 grid = [ \\"PPP\\", \\"PFP\\", \\"PPF\\" ] assert min_cells_to_connect(n, m, grid) == -1 def test_min_cells_to_connect_single_cell(): n, m = 1, 1 grid = [ \\"P\\" ] assert min_cells_to_connect(n, m, grid) == 1 def test_min_cells_to_connect_single_row(): n, m = 1, 5 grid = [ \\"PPPPP\\" ] assert min_cells_to_connect(n, m, grid) == 5 def test_min_cells_to_connect_single_column(): n, m = 5, 1 grid = [ \\"P\\", \\"P\\", \\"P\\", \\"P\\", \\"P\\" ] assert min_cells_to_connect(n, m, grid) == 5","solution":"from collections import deque def min_cells_to_connect(n, m, grid): Returns the minimum number of cells required to connect the top-left cell to the bottom-right cell, or -1 if it is not possible. # Check if the start or end cells are not 'P' if grid[0][0] != 'P' or grid[n-1][m-1] != 'P': return -1 # Initialize directions for moving right and down directions = [(0, 1), (1, 0)] # BFS setup queue = deque([(0, 0, 1)]) # (row, col, depth) visited = set((0, 0)) while queue: r, c, depth = queue.popleft() if (r, c) == (n-1, m-1): return depth for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < n and 0 <= nc < m and grid[nr][nc] == 'P' and (nr, nc) not in visited: visited.add((nr, nc)) queue.append((nr, nc, depth + 1)) return -1"},{"question":"class Task: Class to represent an individual task with an id, description, and priority. def __init__(self, id: int, description: str, priority: str): self.id = id self.description = description self.priority = priority.lower() def __str__(self) -> str: Returns a string representation of the task in the format: 'Task [id]: [description] ([priority])'. return f\\"Task {self.id}: {self.description} ({self.priority})\\" class TaskList: Class to manage a collection of Task objects. def __init__(self): self.tasks = [] def add_task(self, task: Task): Adds a Task object to the list of tasks. self.tasks.append(task) def remove_task(self, id: int): Removes the Task with the specified id from the list of tasks. self.tasks = [task for task in self.tasks if task.id != id] def list_tasks(self) -> str: Returns a string listing all tasks in the format: 1. [description] ([priority]) 2. [description] ([priority]) output = [] for idx, task in enumerate(self.tasks, start=1): output.append(f\\"{idx}. {task.description} ({task.priority})\\") return \\"n\\".join(output)","solution":"class Task: def __init__(self, id, description, priority): self.id = id self.description = description self.priority = priority.lower() def __str__(self): return f\\"Task {self.id}: {self.description} ({self.priority})\\" class TaskList: def __init__(self): self.tasks = [] def add_task(self, task): self.tasks.append(task) def remove_task(self, id): self.tasks = [task for task in self.tasks if task.id != id] def list_tasks(self): output = [] for idx, task in enumerate(self.tasks, start=1): output.append(f\\"{idx}. {task.description} ({task.priority})\\") return \\"n\\".join(output)"},{"question":"class Warehouse: def __init__(self): Initialize a Warehouse object to keep track of inventory and transaction log. self.inventory = {} self.transaction_log = {} def add_quantity(self, time: int, product_id: int, quantity: int): Add quantity of a product at a specific time. pass def remove_quantity(self, time: int, product_id: int, quantity: int): Remove quantity of a product at a specific time. The warehouse always ensures that there are enough units of the product to be removed, so you don't have to handle negative inventory. pass def query_quantity(self, time: int, product_id: int) -> int: Query the total quantity of a product in the warehouse at a specific time. pass def process_queries(queries: List[Tuple[int, int, int, int]]) -> List[int]: Process a list of warehouse queries and return the results for type 3 queries. Each query is a tuple (ai, ti, xi, quantity/product identifier) where - ai: Operation type (1 for add, 2 for remove, 3 for query) - ti: Time of the query - xi: Product identifier - quantity: Quantity to add/remove (only relevant for operations 1 and 2) >>> process_queries([(1, 1, 7, 10), (2, 2, 7, 5), (1, 3, 10, 8), (3, 4, 7), (3, 5, 10)]) [5, 8] pass import unittest class TestWarehouse(unittest.TestCase): def test_add_and_query(self): warehouse = Warehouse() warehouse.add_quantity(1, 7, 10) self.assertEqual(warehouse.query_quantity(4, 7), 10) warehouse.add_quantity(2, 7, 5) warehouse.remove_quantity(3, 7, 3) self.assertEqual(warehouse.query_quantity(5, 7), 12) def test_process_queries_example_1(self): queries = [ (1, 1, 7, 10), (2, 2, 7, 5), (1, 3, 10, 8), (3, 4, 7), (3, 5, 10) ] result = process_queries(queries) self.assertEqual(result, [5, 8]) def test_process_queries_example_2(self): queries = [ (1, 1, 4, 5), (1, 2, 4, 10), (2, 3, 4, 3), (1, 4, 4, 2), (3, 5, 4), (3, 6, 4) ] result = process_queries(queries) self.assertEqual(result, [14, 14]) if __name__ == \\"__main__\\": unittest.main()","solution":"class Warehouse: def __init__(self): self.inventory = {} self.transaction_log = {} def add_quantity(self, time, product_id, quantity): if product_id not in self.inventory: self.inventory[product_id] = 0 self.inventory[product_id] += quantity self.transaction_log[time] = (product_id, quantity) def remove_quantity(self, time, product_id, quantity): if product_id in self.inventory: self.inventory[product_id] -= quantity self.transaction_log[time] = (product_id, -quantity) def query_quantity(self, time, product_id): result = 0 for t, (pid, qty) in sorted(self.transaction_log.items()): if t > time: break if pid == product_id: result += qty return result def process_queries(queries): warehouse = Warehouse() results = [] for query in queries: if query[0] == 1: warehouse.add_quantity(query[1], query[2], query[3]) elif query[0] == 2: warehouse.remove_quantity(query[1], query[2], query[3]) elif query[0] == 3: results.append(warehouse.query_quantity(query[1], query[2])) return results"},{"question":"def determine_ship_order(N: int, positions: List[int], speeds: List[int], finish_line: int) -> List[int]: Determines the order in which the ships arrive at the finish line. Args: N : int : Number of ships positions : list of int : The initial positions of the ships speeds : list of int : The speeds of the ships finish_line : int : The position of the finish line Returns: list of int : Labels of ships in the order they reach the finish line Example: >>> determine_ship_order(3, [2, 3, 4], [5, 6, 7], 10) [3, 2, 1] >>> determine_ship_order(4, [5, 1, 4, 3], [2, 5, 1, 3], 10) [2, 4, 1, 3] from solution import determine_ship_order def test_case_1(): N = 3 positions = [2, 3, 4] speeds = [5, 6, 7] finish_line = 10 result = determine_ship_order(N, positions, speeds, finish_line) assert result == [3, 2, 1] def test_case_2(): N = 4 positions = [5, 1, 4, 3] speeds = [2, 5, 1, 3] finish_line = 10 result = determine_ship_order(N, positions, speeds, finish_line) assert result == [2, 4, 1, 3] def test_case_single_ship(): N = 1 positions = [5] speeds = [2] finish_line = 10 result = determine_ship_order(N, positions, speeds, finish_line) assert result == [1] def test_case_same_speed(): N = 3 positions = [1, 2, 3] speeds = [1, 1, 1] finish_line = 10 result = determine_ship_order(N, positions, speeds, finish_line) assert result == [3, 2, 1] def test_case_tie_breaker(): N = 2 positions = [5, 5] speeds = [1, 1] finish_line = 10 result = determine_ship_order(N, positions, speeds, finish_line) assert result == [1, 2]","solution":"def determine_ship_order(N, positions, speeds, finish_line): Determines the order in which the ships arrive at the finish line. Args: N : int : Number of ships positions : list of int : The initial positions of the ships speeds : list of int : The speeds of the ships finish_line : int : The position of the finish line Returns: list of int : Labels of ships in the order they reach the finish line time_to_finish = [] for i in range(N): time = (finish_line - positions[i]) / speeds[i] time_to_finish.append((time, i + 1)) time_to_finish.sort() return [item[1] for item in time_to_finish]"},{"question":"def max_number_of_toys(a: int, s: int, t: int, prices: List[int]) -> int: Returns the maximum number of toys Petya can purchase given the budget constraints. Parameters: a (int): Total amount of dollars Petya has. s (int): Amount of dollars Petya needs to save. t (int): Number of different toys available. prices (list): List of integers representing the price of each toy. Returns: int: Maximum number of toys Petya can purchase. >>> max_number_of_toys(100, 20, 5, [15, 20, 30, 10, 40]) 8 >>> max_number_of_toys(50, 10, 3, [25, 5, 10]) 4 >>> max_number_of_toys(2, 1, 1, [1]) 1 >>> max_number_of_toys(10, 9, 3, [2, 3, 4]) 0 >>> max_number_of_toys(20, 5, 3, [5, 5, 5]) 3 >>> max_number_of_toys(1000000000, 1, 1000, [1]*1000) 999999999","solution":"def max_number_of_toys(a, s, t, prices): Returns the maximum number of toys Petya can purchase given the budget constraints. Parameters: a (int): Total amount of dollars Petya has. s (int): Amount of dollars Petya needs to save. t (int): Number of different toys available. prices (list): List of integers representing the price of each toy. Returns: int: Maximum number of toys Petya can purchase. budget = a - s prices.sort() num_toys = 0 for price in prices: if budget <= 0: break num_toys += budget // price budget %= price return num_toys"},{"question":"def is_prime(num: int) -> bool: Check if a number is prime. >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(4) False pass def is_fermat_number(n: int) -> bool: Check if a number is a Fermat number. >>> is_fermat_number(3) True >>> is_fermat_number(23) False pass def classify_number(n: int) -> str: Classify if the number is a Fermat number and if it is prime. >>> classify_number(3) 'Fermat Prime' >>> classify_number(23) 'Not Fermat' pass def process_numbers(numbers: List[int]) -> List[str]: Process a list of numbers and return their classifications. >>> process_numbers([3, 5, 17, 257, 65537, 4294967297, 1234, 0]) ['Fermat Prime', 'Fermat Prime', 'Fermat Prime', 'Fermat Prime', 'Fermat Prime', 'Fermat Composite', 'Not Fermat'] pass","solution":"def is_prime(num): Check if a number is prime. if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def is_fermat_number(n): Check if a number is a Fermat number. if n < 2: return False k = 0 while True: fermat_num = 2 ** (2 ** k) + 1 if fermat_num == n: return True if fermat_num > n: return False k += 1 def classify_number(n): Classify if the number is a Fermat number and if it is prime. if n == 0: return if is_fermat_number(n): if is_prime(n): return \\"Fermat Prime\\" else: return \\"Fermat Composite\\" else: return \\"Not Fermat\\" def process_numbers(numbers): Process a list of numbers and return their classifications. results = [] for number in numbers: if number == 0: break results.append(classify_number(number)) return results"},{"question":"def max_items_on_shelves(shelves: List[Tuple[int, int]], items: List[int]) -> int: Determine the maximum number of items that can be placed on the shelves. :param shelves: List of tuples where each tuple contains (weight limit, max item count) of a shelf. :param items: List of item weights. :return: Maximum number of items that can be placed on the shelves. pass def input_parser(input_string: str) -> Tuple[List[Tuple[int, int]], List[int]]: Parses the input string into shelves and items lists. :param input_string: Multiline string :return: (List of shelves, List of items) pass import pytest def test_example_1(): input_string = 3 50 5 30 3 70 6 6 20 10 5 40 25 15 shelves, items = input_parser(input_string) assert max_items_on_shelves(shelves, items) == 5 def test_example_2(): input_string = 2 100 4 75 3 7 60 30 40 20 10 50 55 shelves, items = input_parser(input_string) assert max_items_on_shelves(shelves, items) == 5 def test_all_items_too_heavy(): input_string = 2 50 2 30 1 3 60 70 80 shelves, items = input_parser(input_string) assert max_items_on_shelves(shelves, items) == 0 def test_all_items_fit_easily(): input_string = 1 100 10 5 10 20 30 10 5 shelves, items = input_parser(input_string) assert max_items_on_shelves(shelves, items) == 5 def test_item_count_limit(): input_string = 1 100 3 5 10 20 30 40 50 shelves, items = input_parser(input_string) assert max_items_on_shelves(shelves, items) == 3 @pytest.mark.parametrize( \\"input_string, expected\\", [ (3n50 5n30 3n70 6n6n20n10n5n40n25n15, 5), (2n100 4n75 3n7n60n30n40n20n10n50n55, 5), (2n50 2n30 1n3n60n70n80, 0), (1n100 10n5n10n20n30n10n5, 5), (1n100 3n5n10n20n30n40n50, 3) ] ) def test_max_items_on_shelves(input_string, expected): shelves, items = input_parser(input_string) assert max_items_on_shelves(shelves, items) == expected","solution":"def max_items_on_shelves(shelves, items): Determine the maximum number of items that can be placed on the shelves. :param shelves: List of tuples where each tuple contains (weight limit, max item count) of a shelf. :param items: List of item weights. :return: Maximum number of items that can be placed on the shelves. shelves = sorted(shelves, key=lambda x: (-x[0], -x[1])) # Sort shelves by weight limit desc, then by max item count desc items = sorted(items) # Sort items by weight asc placed_items_count = 0 for weight_limit, max_item_count in shelves: current_weight = 0 current_count = 0 new_items = [] for weight in items: if current_count < max_item_count and current_weight + weight <= weight_limit: current_weight += weight current_count += 1 else: new_items.append(weight) placed_items_count += current_count items = new_items # Remaining items for the next shelf return placed_items_count def input_parser(input_string): Parses the input string into shelves and items lists. :param input_string: Multiline string :return: (List of shelves, List of items) lines = input_string.strip().split(\\"n\\") s = int(lines[0]) shelves = [] for i in range(1, s + 1): weight_limit, max_item_count = map(int, lines[i].strip().split()) shelves.append((weight_limit, max_item_count)) i = int(lines[s + 1]) items = [] for j in range(s + 2, s + 2 + i): items.append(int(lines[j].strip())) return shelves, items"},{"question":"class UnionFind: def __init__(self, size): self.parent = list(range(size)) self.rank = [1] * size def find(self, u): if self.parent[u] != u: self.parent[u] = self.find(self.parent[u]) return self.parent[u] def union(self, u, v): root_u = self.find(u) root_v = self.find(v) if root_u != root_v: if self.rank[root_u] > self.rank[root_v]: self.parent[root_v] = root_u elif self.rank[root_u] < self.rank[root_v]: self.parent[root_u] = root_v else: self.parent[root_v] = root_u self.rank[root_u] += 1 def process_queries(N, queries): Process a list of queries to create portals and check if regions are connected. Args: N (int): Number of regions. queries (List[Tuple[int, int, int]]): List of queries to be processed. Returns: List[str]: Results of connectivity queries. >>> process_queries(6, [(0, 1, 3), (1, 1, 3), (0, 2, 3), (1, 1, 2), (0, 4, 5), (1, 4, 6), (0, 5, 6), (1, 4, 6), (1, 2, 6)]) [\\"Yes\\", \\"Yes\\", \\"No\\", \\"Yes\\", \\"No\\"] >>> process_queries(3, []) [] >>> process_queries(4, [(0, 1, 2), (0, 2, 3), (0, 3, 4), (1, 1, 4), (1, 2, 4), (1, 1, 3)]) [\\"Yes\\", \\"Yes\\", \\"Yes\\"] >>> process_queries(5, [(0, 1, 2), (0, 3, 4), (1, 1, 3), (1, 2, 4), (0, 4, 5), (1, 3, 5), (1, 2, 5)]) [\\"No\\", \\"No\\", \\"Yes\\", \\"No\\"]","solution":"class UnionFind: def __init__(self, size): self.parent = list(range(size)) self.rank = [1] * size def find(self, u): if self.parent[u] != u: self.parent[u] = self.find(self.parent[u]) return self.parent[u] def union(self, u, v): root_u = self.find(u) root_v = self.find(v) if root_u != root_v: if self.rank[root_u] > self.rank[root_v]: self.parent[root_v] = root_u elif self.rank[root_u] < self.rank[root_v]: self.parent[root_u] = root_v else: self.parent[root_v] = root_u self.rank[root_u] += 1 def process_queries(N, queries): uf = UnionFind(N) results = [] for t, x, y in queries: if t == 0: uf.union(x - 1, y - 1) elif t == 1: if uf.find(x - 1) == uf.find(y - 1): results.append(\\"Yes\\") else: results.append(\\"No\\") return results"},{"question":"def find_winner(test_cases): Determine the winner of each round based on the number of problems solved by each coder. Args: test_cases (List[Dict]): List of dictionaries where each dictionary represents a test case containing the number of rounds and a list of tuples with coder names and problems solved. Returns: List[Tuple]: List of tuples containing the name of the winning coder and the total number of problems they solved. Example: >>> test_cases = [ { 'rounds': [ ('Alice', 4), ('Bob', 5), ('Alice', 2) ] }, { 'rounds': [ ('Charlie', 3), ('David', 6), ('Charlie', 5), ('David', 8) ] } ] >>> find_winner(test_cases) [('Alice', 6), ('David', 14)] pass # Tests def test_find_winner(): test_cases = [ { 'rounds': [ ('Alice', 4), ('Bob', 5), ('Alice', 2) ] }, { 'rounds': [ ('Charlie', 3), ('David', 6), ('Charlie', 5), ('David', 8) ] } ] expected_output = [('Alice', 6), ('David', 14)] assert find_winner(test_cases) == expected_output def test_single_round(): test_cases = [ { 'rounds': [ ('Alice', 5) ] } ] expected_output = [('Alice', 5)] assert find_winner(test_cases) == expected_output def test_multiple_codders(): test_cases = [ { 'rounds': [ ('Alice', 1), ('Bob', 2), ('Charlie', 3) ] } ] expected_output = [('Charlie', 3)] assert find_winner(test_cases) == expected_output def test_tied_scores(): test_cases = [ { 'rounds': [ ('Alice', 5), ('Bob', 5) ] } ] expected_output = [('Alice', 5)] # In case of a tie, the coder who appeared first should be taken. assert find_winner(test_cases) == expected_output","solution":"def find_winner(test_cases): results = [] for case in test_cases: rounds = case['rounds'] scores = {} for name, solved in rounds: if name in scores: scores[name] += solved else: scores[name] = solved winner = max(scores, key=scores.get) results.append((winner, scores[winner])) return results # Definition of a helper function to format output def main(): import sys input = sys.stdin.read data = input().splitlines() T = int(data[0]) test_cases = [] index = 1 for _ in range(T): R = int(data[index]) index += 1 rounds = [] for _ in range(R): name, solved = data[index].rsplit(' ', 1) solved = int(solved) rounds.append((name, solved)) index += 1 test_cases.append({'rounds': rounds}) results = find_winner(test_cases) for winner, score in results: print(winner, score)"},{"question":"def max_square_size(n: int, m: int, grid: List[str]) -> int: Calculate the maximum size of a square that contains only black dots within the given grid. >>> max_square_size(4, 4, [\\"..#.\\", \\"#.\\", \\"..\\", \\".#\\"]) 2 >>> max_square_size(5, 6, [\\"......\\", \\"......\\", \\".#....\\", \\"......\\", \\"......\\"]) 1 >>> max_square_size(4, 4, [\\"....\\", \\"....\\", \\"....\\", \\"....\\"]) 0 >>> max_square_size(3, 3, [\\"#\\", \\"#\\", \\"#\\"]) 3 >>> max_square_size(1, 1, [\\"#\\"]) 1 >>> max_square_size(0, 0, []) 0","solution":"def max_square_size(n, m, grid): if n == 0 or m == 0: return 0 max_side = 0 dp = [[0]*m for _ in range(n)] for i in range(n): for j in range(m): if grid[i][j] == '#': if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 if dp[i][j] > max_side: max_side = dp[i][j] return max_side"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def segregateEvenOdd(head: ListNode) -> ListNode: Given a Singly Linked List of integers, group all nodes with even integers together followed by the odd integers. The relative order within the even and odd groups should remain the same as it was in the original list. >>> head = list_to_linked_list([1, 2, 3, 4, 5, 6]) >>> result_head = segregateEvenOdd(head) >>> linked_list_to_list(result_head) [2, 4, 6, 1, 3, 5] >>> head = list_to_linked_list([17, 15, 8, 9, 2, 4, 6]) >>> result_head = segregateEvenOdd(head) >>> linked_list_to_list(result_head) [8, 2, 4, 6, 17, 15, 9] # Helper function to convert list to linked list def list_to_linked_list(lst): dummy = ListNode(0) current = dummy for value in lst: current.next = ListNode(value) current = current.next return dummy.next # Helper function to convert linked list to list def linked_list_to_list(node): lst = [] while node: lst.append(node.val) node = node.next return lst","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def segregateEvenOdd(head: ListNode) -> ListNode: if head is None: return None even_dummy = ListNode(0) odd_dummy = ListNode(0) even_tail, odd_tail = even_dummy, odd_dummy current = head while current: if current.val % 2 == 0: even_tail.next = current even_tail = even_tail.next else: odd_tail.next = current odd_tail = odd_tail.next current = current.next even_tail.next = odd_dummy.next odd_tail.next = None return even_dummy.next # Helper function to convert list to linked list def list_to_linked_list(lst): dummy = ListNode(0) current = dummy for value in lst: current.next = ListNode(value) current = current.next return dummy.next # Helper function to convert linked list to list def linked_list_to_list(node): lst = [] while node: lst.append(node.val) node = node.next return lst"},{"question":"def convert_to_hexadecimal(n: int) -> str: Convert a non-negative integer to its hexadecimal representation. The function should handle conversion of values up to a 32-bit unsigned integer (0 to 4294967295). Examples: >>> convert_to_hexadecimal(26) == \\"1a\\" >>> convert_to_hexadecimal(255) == \\"ff\\" >>> convert_to_hexadecimal(4294967295) == \\"ffffffff\\"","solution":"def convert_to_hexadecimal(n): Convert a non-negative integer to its hexadecimal representation. The function handles conversion of values up to a 32-bit unsigned integer (0 to 4294967295). Parameters: n (int): Non-negative integer to convert to hexadecimal. Returns: str: Hexadecimal representation of the integer. if n == 0: return \\"0\\" hex_chars = \\"0123456789abcdef\\" result = [] while n > 0: result.append(hex_chars[n % 16]) n //= 16 return \\"\\".join(reversed(result))"},{"question":"def max_subsequence_sum_not_exceeding(list_of_numbers, target_sum): Find the maximum subsequence sum that does not exceed the target sum. pass def process_test_cases(T, test_cases): Process multiple test cases for the subsequence sum problem. Args: - T: An integer representing the number of test cases. - test_cases: A list of tuples representing each test case. Each tuple consists of: (N, M, list_of_numbers), where: - N: The number of elements in the list. - M: The target subsequence sum. - list_of_numbers: A list of integers. Returns: - A list of integers representing the maximum subsequence sum that does not exceed the target sum for each test case. pass # Test cases to validate the solution def test_sample_case_1(): T = 2 test_cases = [ (5, 9, [1, 2, 3, 4, 5]), (4, 8, [8, 3, 5, 7]) ] assert process_test_cases(T, test_cases) == [9, 8] def test_with_larger_numbers(): T = 1 test_cases = [ (5, 15, [10, 5, 6, 2, 3]) ] assert process_test_cases(T, test_cases) == [15] def test_case_with_no_valid_subsequence(): T = 1 test_cases = [ (3, 1, [2, 3, 4]) ] assert process_test_cases(T, test_cases) == [0] def test_case_with_multiple_possible_solutions(): T = 1 test_cases = [ (5, 9, [3, 6, 3, 3, 3]) ] assert process_test_cases(T, test_cases) == [9] def test_case_with_single_element(): T = 1 test_cases = [ (1, 5, [5]) ] assert process_test_cases(T, test_cases) == [5]","solution":"def max_subsequence_sum_not_exceeding(list_of_numbers, target_sum): N = len(list_of_numbers) dp = [0] * (target_sum + 1) for num in list_of_numbers: for j in range(target_sum, num - 1, -1): dp[j] = max(dp[j], dp[j - num] + num) return dp[target_sum] def process_test_cases(T, test_cases): result = [] for case in test_cases: N, M, numbers = case result.append(max_subsequence_sum_not_exceeding(numbers, M)) return result # Examples of how to use the function: # T = 2 # test_cases = [ # (5, 9, [1, 2, 3, 4, 5]), # (4, 8, [8, 3, 5, 7]) # ] # print(process_test_cases(T, test_cases))"},{"question":"def can_form_palindrome(s): Determines if the characters of the input string can be rearranged to form a palindrome. Parameters: s (str): A string consisting of lowercase alphabetical characters. Returns: str: \\"YES\\" if it is possible to rearrange the characters to form a palindrome, otherwise \\"NO\\". >>> can_form_palindrome(\\"civic\\") \\"YES\\" >>> can_form_palindrome(\\"ivicc\\") \\"YES\\" >>> can_form_palindrome(\\"hello\\") \\"NO\\" >>> can_form_palindrome(\\"aabbccdd\\") \\"YES\\"","solution":"def can_form_palindrome(s): Determines if the characters of the input string can be rearranged to form a palindrome. Parameters: s (str): A string consisting of lowercase alphabetical characters. Returns: str: \\"YES\\" if it is possible to rearrange the characters to form a palindrome, otherwise \\"NO\\". from collections import Counter # Count frequency of each character in the string char_count = Counter(s) # Count how many characters have an odd frequency odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # A string can form a palindrome if at most one character has an odd frequency if odd_count > 1: return \\"NO\\" else: return \\"YES\\""},{"question":"def group_non_negative_integers(lst): Returns a list of non-negative integers from lst grouped in sublists of 3 elements each. Example: >>> group_non_negative_integers([4, -1, 0, 7, -3, 9, 2, -8]) [[4, 0, 7], [9, 2]] >>> group_non_negative_integers([-5, -3, -9]) [] >>> group_non_negative_integers([1, 3, 5, -2, 6, 8, -7, 4, 2]) [[1, 3, 5], [6, 8, 4], [2]] >>> group_non_negative_integers([]) []","solution":"def group_non_negative_integers(lst): Returns a list of non-negative integers from lst grouped in sublists of 3 elements each. # Filter non-negative integers non_negative = [num for num in lst if num >= 0] # Group into sublists of 3 elements each result = [non_negative[i:i+3] for i in range(0, len(non_negative), 3)] return result"},{"question":"def longestSubarrayWithoutZero(arr: List[int]) -> int: Given an array of integers, determine the length of the longest subarray that does not contain any zeros. >>> longestSubarrayWithoutZero([1, 2, 0, 3, 4, 0, 5, 6]) 2 >>> longestSubarrayWithoutZero([1, 2, 3, 4, 0, 1]) 4","solution":"def longestSubarrayWithoutZero(arr): Returns the length of the longest subarray without zeros. max_length = 0 current_length = 0 for num in arr: if num == 0: max_length = max(max_length, current_length) current_length = 0 else: current_length += 1 return max(max_length, current_length)"},{"question":"def min_jumps_to_end(n: int, sequence: List[int]) -> int: Find the minimum number of jumps required to reach the end of the sequence starting from the first position. If it is not possible to reach the end of the sequence, return -1. >>> min_jumps_to_end(5, [2, 3, 1, 1, 4]) 2 >>> min_jumps_to_end(6, [1, 1, 1, 1, 0, 1]) -1 >> min_jumps_to_end(1, [1]) 0 >> min_jumps_to_end(5, [1, 0, 1, 1, 4]) -1 >> min_jumps_to_end(3, [2, 1, 3]) 1 >> min_jumps_to_end(8, [1, 3, 5, 8, 9, 2, 6, 7, 6, 8, 9]) 3 >> min_jumps_to_end(9, [1, 1, 1, 1, 1, 1, 1, 1, 1]) 8 >> min_jumps_to_end(2, [0, 1]) -1","solution":"def min_jumps_to_end(n, sequence): if n <= 0 or not sequence: return -1 jumps = [0] * n max_reach = 0 steps = 0 last_jump_pos = 0 for i in range(n): if i > max_reach: return -1 max_reach = max(max_reach, i + sequence[i]) if i == last_jump_pos: if i != n - 1: steps += 1 last_jump_pos = max_reach if last_jump_pos >= n - 1: break return -1 if max_reach < n - 1 else steps"},{"question":"def compute_merit(X, Y): Computes the overall merit of each student as X[i] - Y[i] and returns a list of tuples where each tuple consists of a student's index and their overall merit in decreasing order of merit. >>> compute_merit([50, 60, 70], [5, 10, 15]) == [(2, 55), (1, 50), (0, 45)] >>> compute_merit([20, 40, 30, 35], [10, 15, 25, 5]) == [(3, 30), (1, 25), (0, 10), (2, 5)] >>> compute_merit([3, 2, 1], [0, 1, 2]) == [(0, 3), (1, 1), (2, -1)] >>> compute_merit([10, 20, 10], [10, 20, 10]) == [(0, 0), (1, 0), (2, 0)] >>> compute_merit([7], [3]) == [(0, 4)] pass def solve(T, test_cases): Solves multiple test cases as described in the task statement using the compute_merit function. >>> T = 2 >>> test_cases = [ >>> (3, [50, 60, 70, 5, 10, 15]), >>> (4, [20, 40, 30, 35, 10, 15, 25, 5]) >>> ] >>> expected = [ >>> [(2, 55), (1, 50), (0, 45)], >>> [(3, 30), (1, 25), (0, 10), (2, 5)] >>> ] >>> solve(T, test_cases) == expected pass","solution":"def compute_merit(X, Y): Computes the overall merit of each student as X[i] - Y[i] and returns a list of tuples where each tuple consists of a student's index and their overall merit in decreasing order of merit. merits = [(i, X[i] - Y[i]) for i in range(len(X))] # Sort by merit descending, and by index ascending if merits are equal merits.sort(key=lambda x: (-x[1], x[0])) return merits def solve(T, test_cases): results = [] for i in range(T): N, data = test_cases[i] X = data[:N] Y = data[N:] results.append(compute_merit(X, Y)) return results"},{"question":"from typing import List, Tuple def process_array(arr: List[int]) -> Tuple[int, float]: Processes the input array according to the specified operations. 1. Calculate the sum of all elements in the array. 2. Sort the array in non-decreasing order. 3. Remove duplicates. 4. Find the median of the modified array. Args: arr (list): List of integers. Returns: (tuple): Sum of original array, median of modified array. >>> process_array([1, 3, 3, 6, 7, 8]) (28, 6) >>> process_array([1, 2, 2, 4, 5]) (14, 3) >>> process_array([10, 10, 10, 10]) (40, 10) >>> process_array([-3, -2, -1, 0, 1, 2, 3]) (0, 0) >>> process_array([5, 3, 8, 9, 2]) (27, 5)","solution":"def process_array(arr): Processes the input array according to the specified operations. 1. Calculate the sum of all elements in the array. 2. Sort the array in non-decreasing order. 3. Remove duplicates. 4. Find the median of the modified array. Args: arr (list): List of integers. Returns: (tuple): Sum of original array, median of modified array. # Calculate the sum of all elements in the original array total_sum = sum(arr) # Sort the array and remove duplicates sorted_unique_arr = sorted(set(arr)) # Find the median of the modified array n = len(sorted_unique_arr) if n % 2 == 1: median = sorted_unique_arr[n // 2] else: median = (sorted_unique_arr[n // 2 - 1] + sorted_unique_arr[n // 2]) / 2 return total_sum, median def main(): import sys input = sys.stdin.read data = list(map(int, input().split())) n = data[0] arr = data[1:n+1] total_sum, median = process_array(arr) print(total_sum) print(median)"},{"question":"def get_top_customer(call_records, start_date, end_date): Identifies top customer based on total call durations within a specific date range. Args: call_records (List[Tuple[str, str, str]]): List of call records in the format (userID, date, duration). start_date (str): The beginning date of the range in YYYY-MM-DD format. end_date (str): The end date of the range in YYYY-MM-DD format. Returns: str: The user ID of the customer with the highest total call duration within the given date range. If no calls fall within the date range, return None. >>> call_records = [(\\"user1\\", \\"2023-01-01\\", \\"30\\"), (\\"user2\\", \\"2023-01-02\\", \\"45\\"), (\\"user1\\", \\"2023-01-04\\", \\"60\\")] >>> get_top_customer(call_records, \\"2023-01-01\\", \\"2023-01-03\\") 'user2' >>> call_records = [(\\"user1\\", \\"2023-01-01\\", \\"30\\"), (\\"user2\\", \\"2023-01-02\\", \\"30\\"), (\\"user1\\", \\"2023-01-04\\", \\"60\\")] >>> get_top_customer(call_records, \\"2023-01-01\\", \\"2023-01-03\\") 'user1'","solution":"def get_top_customer(call_records, start_date, end_date): from collections import defaultdict import datetime call_durations = defaultdict(int) start_date = datetime.datetime.strptime(start_date, \\"%Y-%m-%d\\") end_date = datetime.datetime.strptime(end_date, \\"%Y-%m-%d\\") for record in call_records: user_id, date, duration = record date = datetime.datetime.strptime(date, \\"%Y-%m-%d\\") if start_date <= date <= end_date: call_durations[user_id] += int(duration) max_duration = -1 top_customer = None for user_id, total_duration in call_durations.items(): if total_duration > max_duration: max_duration = total_duration top_customer = user_id return top_customer"},{"question":"def count_taller_trees(heights, limit): Returns the number of trees with height greater than the given limit. Parameters: heights (list of int): List of tree heights. limit (int): The height limit to compare the tree heights against. Returns: int: Number of trees taller than the limit. >>> count_taller_trees([3, 5, 6, 7, 8, 2, 1], 5) 3 >>> count_taller_trees([1, 2, 3, 4, 5], 3) 2 >>> count_taller_trees([10, 20, 30], 25) 1 >>> count_taller_trees([1, 1, 1, 1], 1) 0 >>> count_taller_trees([4, 5, 6, 7, 8], 10) 0 >>> count_taller_trees([5, 10, 15, 20], 5) 3 >>> count_taller_trees([], 5) 0 >>> count_taller_trees([6, 7, 8, 9], 5) 4 >>> count_taller_trees([5, 5, 5, 5], 5) 0","solution":"def count_taller_trees(heights, limit): Returns the number of trees with height greater than the given limit. Parameters: heights (list of int): List of tree heights. limit (int): The height limit to compare the tree heights against. Returns: int: Number of trees taller than the limit. return sum(1 for height in heights if height > limit)"},{"question":"from collections import defaultdict from typing import List, Tuple def minimal_capacity(n: int, m: int, edges: List[Tuple[int, int, int]]) -> int: Given a directed graph with n nodes and m edges representing a water supply system, find the minimal capacity of an edge that, if removed, would lead to the maximum reduction in the water flow from the main reservoir (node 1) to the most remote village (node n). :param n: int - Number of nodes in the graph :param m: int - Number of edges in the graph :param edges: List of tuples (u, v, c) where u is the starting node, v is the ending node, and c is the capacity of the edge. :return: int - Minimal capacity of an edge that, if removed, would result in the maximum reduction of water flow from node 1 to node n. If no such edge exists, return -1. >>> minimal_capacity(4, 5, [(1, 2, 10), (2, 3, 5), (2, 4, 15), (3, 4, 10), (4, 3, 10)]) 5 >>> minimal_capacity(3, 3, [(1, 2, 10), (2, 3, 20), (1, 3, 5)]) 5 >>> minimal_capacity(3, 2, [(1, 2, 10), (2, 3, 10)]) 10 >>> minimal_capacity(3, 2, [(1, 2, 10), (3, 2, 10)]) -1 >>> minimal_capacity(6, 9, [(1, 2, 16), (1, 3, 13), (2, 4, 12), (3, 2, 4), (2, 3, 4), (3, 5, 14), (4, 3, 9), (4, 6, 20), (5, 6, 4)]) 4 pass","solution":"from collections import defaultdict, deque def bfs(capacity, source, sink, parent): visited = set() queue = deque([source]) visited.add(source) while queue: u = queue.popleft() for v in capacity[u]: if v not in visited and capacity[u][v] > 0: queue.append(v) visited.add(v) parent[v] = u if v == sink: return True return False def edmonds_karp(n, capacity, source, sink): parent = [-1] * (n + 1) max_flow = 0 while bfs(capacity, source, sink, parent): flow = float('Inf') s = sink while s != source: flow = min(flow, capacity[parent[s]][s]) s = parent[s] max_flow += flow v = sink while v != source: u = parent[v] capacity[u][v] -= flow capacity[v][u] += flow v = parent[v] return max_flow def minimal_capacity(n, m, edges): original_capacity = defaultdict(lambda: defaultdict(int)) for u, v, c in edges: original_capacity[u][v] += c max_flow = edmonds_karp(n, original_capacity.copy(), 1, n) if max_flow == 0: return -1 min_capacity = float('Inf') for u, v, c in edges: capacity = original_capacity.copy() capacity[u][v] -= c new_max_flow = edmonds_karp(n, capacity, 1, n) reduction = max_flow - new_max_flow if reduction > 0: min_capacity = min(min_capacity, c) return min_capacity if min_capacity != float('Inf') else -1"},{"question":"def highest_frequency_number(arr: List[int]) -> int: Return the number with the maximum frequency in the array. If multiple numbers have the same frequency, return the smallest number among them. >>> highest_frequency_number([3, 1, 4, 4, 5, 2, 2, 3, 3]) 3 >>> highest_frequency_number([1, 2, 2, 3, 3]) 2 >>> highest_frequency_number([5, 5, 4, 6, 6, 4, 4]) 4 >>> highest_frequency_number([9, 5, 1, 3, 1]) 1","solution":"def highest_frequency_number(arr): from collections import Counter frequency = Counter(arr) max_frequency = max(frequency.values()) candidates = [num for num, freq in frequency.items() if freq == max_frequency] return min(candidates)"},{"question":"def balanceBooks(n, b, books, transfers): Distribute books among children such that each child gets an equal number of books. If it's not possible to distribute books equally, return \\"NO\\". If possible, return the number of book transfers and the detailed transfers that balance the books. Parameters: n (int): The number of children (1 ≤ n ≤ 300). b (int): The target number of books each child should have (0 ≤ b ≤ 10^9). books (list): A list of integers representing the number of books each child currently has. transfers (int): The maximum number of transfers allowed (1 ≤ transfers ≤ n^2). Returns: Union[str, Tuple[int, List[Tuple[int, int, int]]]]: If it's possible to balance the books within the given number of transfers, return the number of transfers followed by the list of transfers. Otherwise, return \\"NO\\". pass # Test cases def test_balance_books_example_1(): assert balanceBooks(3, 4, [6, 2, 4], 3) == (1, [(1, 2, 2)]) def test_balance_books_example_2(): assert balanceBooks(2, 5, [6, 3], 1) == \\"NO\\" def test_balance_books_more_transfers(): assert balanceBooks(4, 3, [5, 1, 4, 2], 2) == (2, [(1, 2, 2), (3, 4, 1)]) def test_balance_books_insufficient_transfers(): assert balanceBooks(4, 2, [5, 1, 4, 2], 1) == \\"NO\\" def test_balance_books_already_balanced(): assert balanceBooks(3, 4, [4, 4, 4], 3) == (0, []) def test_balance_books_no_possible_solution(): assert balanceBooks(3, 3, [3, 1, 2], 2) == \\"NO\\" def test_balance_books_exact_transfers(): assert balanceBooks(4, 5, [7, 3, 6, 4], 2) == (2, [(1, 2, 2), (3, 4, 1)]) def test_balance_books_large_numbers(): assert balanceBooks(2, 1000000, [1000000, 1000000], 1) == (0, [])","solution":"def balanceBooks(n, b, books, transfers): Distribute books among children such that each child gets exactly b books. Parameters: n (int): The number of children (1 ≤ n ≤ 300). b (int): The target number of books each child should have (0 ≤ b ≤ 10^9). books (list): A list of integers representing the number of books each child currently has. transfers (int): The maximum number of transfers allowed (1 ≤ transfers ≤ n^2). Returns: Union[str, Tuple[int, List[Tuple[int, int, int]]]]: If it's possible to balance the books within the given number of transfers, return the number of transfers followed by the list of transfers. Otherwise, return \\"NO\\". total_books_needed = n * b current_total_books = sum(books) # Check if the book distribution can be made equal if current_total_books != total_books_needed: return \\"NO\\" valid_transfers = [] surplus = [] deficit = [] for i in range(n): if books[i] > b: surplus.append((i, books[i] - b)) elif books[i] < b: deficit.append((i, b - books[i])) number_of_transfers = 0 while surplus and deficit: from_idx, surplus_amt = surplus.pop(0) to_idx, deficit_amt = deficit.pop(0) transfer_amt = min(surplus_amt, deficit_amt) valid_transfers.append((from_idx + 1, to_idx + 1, transfer_amt)) number_of_transfers += 1 if number_of_transfers > transfers: return \\"NO\\" if surplus_amt > transfer_amt: surplus.insert(0, (from_idx, surplus_amt - transfer_amt)) if deficit_amt > transfer_amt: deficit.insert(0, (to_idx, deficit_amt - transfer_amt)) return number_of_transfers, valid_transfers"},{"question":"def max_working_time(n: int, tasks: List[Tuple[int, int]]) -> int: Determine the maximum total working time achievable by selecting a subset of non-overlapping tasks. :param n: Number of tasks :param tasks: List of tuples where each tuple contains the start and finish time of a task :return: Maximum total working time >>> max_working_time(3, [(1, 3), (2, 5), (4, 7)]) == 5 >>> max_working_time(4, [(1, 2), (2, 4), (3, 5), (5, 8)]) == 6 from solution import max_working_time def test_max_working_time_example1(): tasks = [(1, 3), (2, 5), (4, 7)] assert max_working_time(3, tasks) == 5 def test_max_working_time_example2(): tasks = [(1, 2), (2, 4), (3, 5), (5, 8)] assert max_working_time(4, tasks) == 6 def test_max_working_time_single_task(): tasks = [(0, 3)] assert max_working_time(1, tasks) == 3 def test_max_working_time_no_overlapping_tasks(): tasks = [(0, 1), (2, 3), (4, 5)] assert max_working_time(3, tasks) == 3 def test_max_working_time_all_overlapping_tasks(): tasks = [(0, 4), (1, 5), (2, 6)] assert max_working_time(3, tasks) == 4 def test_max_working_time_partial_overlapping_tasks(): tasks = [(0, 4), (4, 7), (1, 9)] assert max_working_time(3, tasks) == 7","solution":"def max_working_time(n, tasks): tasks.sort(key=lambda x: x[1]) # Sort tasks by their finish times end_time = 0 total_working_time = 0 for task in tasks: if task[0] >= end_time: total_working_time += task[1] - task[0] end_time = task[1] return total_working_time # Example usage: # n = 3 # tasks = [(1, 3), (2, 5), (4, 7)] # print(max_working_time(n, tasks)) # Output: 5"},{"question":"from typing import List def rotate_array(arr: List[int], k: int) -> List[int]: Rotates the array \`k\` times to the right. >>> rotate_array([1, 2, 3, 4, 5], 3) [3, 4, 5, 1, 2] >>> rotate_array([17, 21, 34, 56], 2) [34, 56, 17, 21] >>> rotate_array([1, 2, 3, 4, 5], 7) [4, 5, 1, 2, 3] # Equivalent to rotating 2 times >>> rotate_array([17, 21, 34, 56], 6) [34, 56, 17, 21] # Equivalent to rotating 2 times >>> rotate_array([1, 2, 3, 4, 5], 0) [1, 2, 3, 4, 5] >>> rotate_array([17, 21, 34, 56], 0) [17, 21, 34, 56] >>> rotate_array([1, 2, 3, 4, 5], 5) [1, 2, 3, 4, 5] >>> rotate_array([17, 21, 34, 56], 4) [17, 21, 34, 56] >>> rotate_array([1], 100) [1] # All rotations should return the same single element","solution":"def rotate_array(arr, k): Rotates the array \`k\` times to the right. Parameters: - arr: List[int] : An array of integers. - k: int : Number of rotations. Returns: - List[int] : The rotated array. n = len(arr) k = k % n # In case k is greater than the length of array return arr[-k:] + arr[:-k]"},{"question":"def rotate_array(arr, steps): Rotates the array to the right by the given number of steps. Parameters: arr (list of int): The array of integers to be rotated. steps (int): The number of steps to rotate the array. Returns: list of int: The rotated array. pass from solution import rotate_array def test_rotate_array_basic(): assert rotate_array([1, 2, 3, 4, 5], 2) == [4, 5, 1, 2, 3] def test_rotate_array_no_rotation(): assert rotate_array([1, 2, 3, 4, 5], 0) == [1, 2, 3, 4, 5] def test_rotate_array_full_rotation(): assert rotate_array([1, 2, 3, 4, 5], 5) == [1, 2, 3, 4, 5] def test_rotate_array_more_than_length(): assert rotate_array([1, 2, 3, 4, 5], 8) == [3, 4, 5, 1, 2] def test_rotate_array_single_element(): assert rotate_array([1], 3) == [1] def test_rotate_array_large_steps(): arr = list(range(10**6)) assert rotate_array(arr, 10**9) == arr[-(10**9 % (10**6)):] + arr[:-(10**9 % (10**6))] def test_rotate_array_large_array(): arr = list(range(1, 10**6 + 1)) steps = 123456 expected = arr[-steps:] + arr[:-steps] assert rotate_array(arr, steps) == expected","solution":"def rotate_array(arr, steps): Rotates the array to the right by the given number of steps. Parameters: arr (list of int): The array of integers to be rotated. steps (int): The number of steps to rotate the array. Returns: list of int: The rotated array. n = len(arr) steps = steps % n # Effective number of steps return arr[-steps:] + arr[:-steps]"},{"question":"def is_prime(num): Helper function to check if a number is prime. >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(4) False >>> is_prime(5) True >>> is_prime(10) False # Implementation here def is_doubly_prime(n: int) -> str: Function to determine if a number is doubly prime. >>> is_doubly_prime(5) 'yes' >>> is_doubly_prime(4) 'no' >>> is_doubly_prime(7) 'yes' >>> is_doubly_prime(11) 'no' >>> is_doubly_prime(13) 'yes' >>> is_doubly_prime(15) 'no' # Implementation here","solution":"def is_prime(num): Helper function to check if a number is prime. if num <= 1: return False if num == 2: return True if num % 2 == 0: return False for i in range(3, int(num**0.5)+1, 2): if num % i == 0: return False return True def is_doubly_prime(n): Function to determine if a number is doubly prime. if n < 2: return \\"no\\" return \\"yes\\" if is_prime(n) and is_prime(n - 2) else \\"no\\""},{"question":"import numpy as np def get_unique_sorted_elements(array: np.ndarray) -> np.ndarray: Returns the sorted unique elements of a given array using numpy.unique. Args: array (np.ndarray): A numpy array of integers. Returns: np.ndarray: A numpy array of sorted unique integers. Examples: >>> get_unique_sorted_elements(np.array([2, 3, 2, 1, 3, 4, 5, 1, 5])) array([1, 2, 3, 4, 5]) >>> get_unique_sorted_elements(np.array([1, 1, 1, 1])) array([1])","solution":"import numpy def get_unique_sorted_elements(array): Returns the sorted unique elements of a given array using numpy.unique. Args: array (list): A list of integers. Returns: np.ndarray: A numpy array of sorted unique integers. return numpy.unique(array) # Example usage: # array = numpy.array([2, 3, 2, 1, 3, 4, 5, 1, 5]) # print(get_unique_sorted_elements(array)) # Output: [1 2 3 4 5]"},{"question":"def minInWindow(arr: List[int], k: int) -> List[int]: Given an array of integers and a window size k, find the minimum element in each window of size k in the array. >>> minInWindow([8, 5, 10, 7, 9, 4, 15, 12, 90, 13], 4) [5, 5, 4, 4, 4, 4, 12] >>> minInWindow([2, 3, 4, 2, 6, 2, 5, 1], 3) [2, 2, 2, 2, 2, 1] :param arr: List[int] - List of integers :param k: int - Size of the window :return: List[int] - Minimums of each window pass from solution import minInWindow def test_example1(): arr = [8, 5, 10, 7, 9, 4, 15, 12, 90, 13] k = 4 assert minInWindow(arr, k) == [5, 5, 4, 4, 4, 4, 12] def test_example2(): arr = [2, 3, 4, 2, 6, 2, 5, 1] k = 3 assert minInWindow(arr, k) == [2, 2, 2, 2, 2, 1] def test_single_element_windows(): arr = [4, 2, 3, 1] k = 1 assert minInWindow(arr, k) == [4, 2, 3, 1] def test_whole_array_single_window(): arr = [4, 2, 3, 1] k = 4 assert minInWindow(arr, k) == [1] def test_empty_array(): arr = [] k = 3 assert minInWindow(arr, k) == [] def test_large_k(): arr = [8, 7, 6, 5, 4, 3, 2, 1] k = 8 assert minInWindow(arr, k) == [1]","solution":"from collections import deque def minInWindow(arr, k): Finds the minimum element in each window of size k in the array. if not arr or k == 0: return [] n = len(arr) result = [] dq = deque() for i in range(n): # Remove elements out of the current window if dq and dq[0] <= i - k: dq.popleft() # Remove elements from the deque which are larger than the current element while dq and arr[dq[-1]] >= arr[i]: dq.pop() dq.append(i) # Append the minimum element of the current window to the result list if i >= k - 1: result.append(arr[dq[0]]) return result"},{"question":"def min_operations(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Calculate the minimum number of operations needed to sever all the heads of the dragon. Each operation can either sever a single head or two adjacent heads at once. :param T: The number of test cases. :param test_cases: A list of tuples, where each tuple contains: - An integer N, the number of heads. - A list of N integers representing the power levels of the heads. :return: A list of integers where each integer represents the minimum number of operations needed for each test case. >>> min_operations(3, [(5, [1, 2, 3, 4, 5]), (4, [4, 4, 4, 4]), (3, [10, 1, 10])]) [3, 2, 2]","solution":"def min_operations(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] P = test_cases[i][1] results.append((N + 1) // 2) return results"},{"question":"def rotate_matrix_90_clockwise(matrix): Rotates an NxN matrix 90 degrees clockwise. Args: matrix (List[List[int]]): A 2D list representing an NxN matrix. Returns: List[List[int]]: The matrix rotated 90 degrees clockwise. >>> rotate_matrix_90_clockwise([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> rotate_matrix_90_clockwise([ ... [10, 20], ... [30, 40] ... ]) [[30, 10], [40, 20]] pass def process_test_cases(test_cases): Processes a list of test cases to rotate NxN matrices 90 degrees clockwise. Args: test_cases (List[Tuple[int, List[List[int]]]]): A list of tuples where each tuple contains - an integer N: the size of the NxN grid, - a 2D list of integers representing the pixel values of the image. Returns: List[List[List[int]]]: A list of 2D lists representing the rotated matrices. >>> test_cases = [ ... (3, [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]), ... (2, [ ... [10, 20], ... [30, 40] ... ]) ... ] >>> process_test_cases(test_cases) [ [[7, 4, 1], [8, 5, 2], [9, 6, 3]], [[30, 10], [40, 20]] ] pass","solution":"def rotate_matrix_90_clockwise(matrix): Rotates an NxN matrix 90 degrees clockwise. N = len(matrix) # Create a new matrix to hold the rotated values rotated_matrix = [[0 for _ in range(N)] for _ in range(N)] for i in range(N): for j in range(N): rotated_matrix[j][N - 1 - i] = matrix[i][j] return rotated_matrix def process_test_cases(test_cases): results = [] for case in test_cases: N, matrix = case rotated = rotate_matrix_90_clockwise(matrix) results.append(rotated) return results"},{"question":"def can_reduce_potions(n: int, a: List[int], p: int, k: int) -> str: Determine if it is possible to reduce exactly k units from the total distribution of potions among knights while ensuring that each knight carries at most p potions and does not end up with negative potions. >>> can_reduce_potions(3, [5, 8, 6], 10, 7) \\"Yes\\" >>> can_reduce_potions(4, [10, 9, 8, 7], 12, 5) \\"Yes\\" >>> can_reduce_potions(2, [3, 4], 6, 10) \\"No\\" def test_can_reduce_potions_example_1(): n = 3 a = [5, 8, 6] p = 10 k = 7 assert can_reduce_potions(n, a, p, k) == \\"Yes\\" def test_can_reduce_potions_example_2(): n = 4 a = [10, 9, 8, 7] p = 12 k = 5 assert can_reduce_potions(n, a, p, k) == \\"Yes\\" def test_can_reduce_potions_example_3(): n = 2 a = [3, 4] p = 6 k = 10 assert can_reduce_potions(n, a, p, k) == \\"No\\" def test_can_reduce_potions_large_reduction_possible(): n = 5 a = [10, 20, 30, 40, 50] p = 100 k = 120 assert can_reduce_potions(n, a, p, k) == \\"Yes\\" def test_can_reduce_potions_large_reduction_not_possible(): n = 5 a = [2, 3, 5, 8, 10] p = 12 k = 50 assert can_reduce_potions(n, a, p, k) == \\"No\\" def test_can_reduce_potions_zero_reduction(): n = 3 a = [5, 8, 6] p = 10 k = 0 assert can_reduce_potions(n, a, p, k) == \\"Yes\\" def test_can_reduce_potions_all_potions_zero(): n = 3 a = [0, 0, 0] p = 10 k = 1 assert can_reduce_potions(n, a, p, k) == \\"No\\" def test_can_reduce_potions_exact_reduction_possible(): n = 1 a = [7] p = 10 k = 7 assert can_reduce_potions(n, a, p, k) == \\"Yes\\" def test_can_reduce_potions_should_return_no(): n = 3 a = [4, 5, 6] p = 8 k = 20 assert can_reduce_potions(n, a, p, k) == \\"No\\"","solution":"from typing import List def can_reduce_potions(n: int, a: List[int], p: int, k: int) -> str: # Calculate the total number of initial potions total_potions = sum(a) # Check if the total reduction is greater than the total available potions if k > total_potions: return \\"No\\" # Sort the potion array to facilitate easy reduction a.sort() # Calculate the maximum possible reduction # We need to calculate the minimum amount each knight can reduce possible_reduction = sum(min(potion, p) for potion in a) # If the needed reduction is less than or equal to the possible reduction, return \\"Yes\\" if k <= possible_reduction: return \\"Yes\\" else: return \\"No\\""},{"question":"from typing import List def shortest_path(n: int, m: int, grid: List[str], sx: int, sy: int, ex: int, ey: int) -> int: Determines if there is a path for Paul from the start to the end in the grid, and returns the length of the shortest path. If there are multiple shortest paths, any one of them may be returned. If no such path exists, returns -1. >>> n, m = 5, 5 >>> grid = [\\".....\\", \\".#.\\", \\"...#.\\", \\".#...\\", \\".....\\"] >>> sx, sy, ex, ey = 0, 0, 4, 4 >>> shortest_path(n, m, grid, sx, sy, ex, ey) 8 >>> n, m = 3, 3 >>> grid = [\\"...\\", \\"#\\", \\".#.\\"] >>> sx, sy, ex, ey = 0, 0, 2, 2 >>> shortest_path(n, m, grid, sx, sy, ex, ey) -1 pass # Unit tests def test_shortest_path_example_1(): n, m = 5, 5 grid = [ \\".....\\", \\".#.\\", \\"...#.\\", \\".#...\\", \\".....\\" ] sx, sy, ex, ey = 0, 0, 4, 4 assert shortest_path(n, m, grid, sx, sy, ex, ey) == 8 def test_shortest_path_example_2(): n, m = 5, 5 grid = [ \\".....\\", \\".#.\\", \\"...#.\\", \\".#...\\", \\".....\\" ] sx, sy, ex, ey = 0, 0, 2, 2 assert shortest_path(n, m, grid, sx, sy, ex, ey) == 4 def test_shortest_path_example_3(): n, m = 3, 3 grid = [ \\"...\\", \\"#\\", \\".#.\\" ] sx, sy, ex, ey = 0, 0, 2, 2 assert shortest_path(n, m, grid, sx, sy, ex, ey) == -1 def test_edge_case_same_start_end(): n, m = 5, 5 grid = [ \\".....\\", \\".#.\\", \\"...#.\\", \\".#...\\", \\".....\\" ] sx, sy, ex, ey = 0, 0, 0, 0 assert shortest_path(n, m, grid, sx, sy, ex, ey) == 0 def test_edge_case_no_path_possible(): n, m = 3, 3 grid = [ \\".#.\\", \\"#\\", \\"...\\", ] sx, sy, ex, ey = 0, 0, 2, 2 assert shortest_path(n, m, grid, sx, sy, ex, ey) == -1","solution":"from collections import deque def shortest_path(n, m, grid, sx, sy, ex, ey): if sx == ex and sy == ey: return 0 directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] visited = [[False for _ in range(m)] for _ in range(n)] queue = deque([(sx, sy, 0)]) # (x, y, distance) while queue: x, y, dist = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny] and grid[nx][ny] == '.': if nx == ex and ny == ey: return dist + 1 visited[nx][ny] = True queue.append((nx, ny, dist + 1)) return -1 # Inputs for testing n1, m1 = 5, 5 grid1 = [ \\".....\\", \\".#.\\", \\"...#.\\", \\".#...\\", \\".....\\" ] sx1, sy1, ex1, ey1 = 0, 0, 4, 4 n2, m2 = 5, 5 grid2 = [ \\".....\\", \\".#.\\", \\"...#.\\", \\".#...\\", \\".....\\" ] sx2, sy2, ex2, ey2 = 0, 0, 2, 2 n3, m3 = 3, 3 grid3 = [ \\"...\\", \\"#\\", \\".#.\\" ] sx3, sy3, ex3, ey3 = 0, 0, 2, 2 print(shortest_path(n1, m1, grid1, sx1, sy1, ex1, ey1)) # Output should be 8 print(shortest_path(n2, m2, grid2, sx2, sy2, ex2, ey2)) # Output should be 4 print(shortest_path(n3, m3, grid3, sx3, sy3, ex3, ey3)) # Output should be -1"},{"question":"def max_k_length_sticks(n: int, k: int, lengths: List[int]) -> int: Returns the maximum number of k-length sticks that can be obtained from the given lengths. Args: n (int): The number of sticks. k (int): The desired length of each smaller stick. lengths (List[int]): The lengths of the sticks. Returns: int: The maximum number of k-length sticks. Examples: >>> max_k_length_sticks(5, 3, [10, 13, 15, 18, 24]) 26 >>> max_k_length_sticks(4, 5, [20, 7, 5, 15]) 9","solution":"def max_k_length_sticks(n, k, lengths): Returns the maximum number of k-length sticks that can be obtained from the given lengths. total_sticks = 0 for length in lengths: total_sticks += length // k return total_sticks"},{"question":"def min_machines_required(jobs: List[Tuple[int, int]]) -> int: Determine the minimum number of machines required to schedule all the jobs such that no two jobs overlap on the same machine. >>> min_machines_required([(1, 4), (2, 5), (3, 6)]) 3 >>> min_machines_required([(1, 3), (2, 4), (3, 5), (4, 6)]) 2","solution":"def min_machines_required(jobs): events = [] for start, end in jobs: events.append((start, 'start')) events.append((end, 'end')) events.sort() max_machines = 0 current_machines = 0 for time, type in events: if type == 'start': current_machines += 1 max_machines = max(max_machines, current_machines) else: current_machines -= 1 return max_machines"},{"question":"from typing import List, Tuple def find_clusters(T: int, test_cases: List[Tuple[int, int, List[Tuple[int, int]]]]) -> List[List[List[int]]]: Identify clusters of friends within a network. Args: T : int : number of test cases test_cases : List[Tuple[int, int, List[Tuple[int, int]]]] : list of test cases, each containing (N, M, edges) Returns: List[List[List[int]]] : list of clusters for each test case Example: >>> find_clusters(2, [(6, 4, [(1, 2), (2, 3), (4, 5), (5, 6)]), (5, 3, [(2, 2), (1, 1), (2, 1)])]) [[[1, 2, 3], [4, 5, 6]], [[1, 2], [3], [4], [5]]] # Function implementation to be provided def test_find_clusters(): test_cases = [ (6, 4, [(1, 2), (2, 3), (4, 5), (5, 6)]), (5, 3, [(2, 2), (1, 1), (2, 1)]) ] T = 2 expected_output = [ [[1, 2, 3], [4, 5, 6]], [[1, 2], [3], [4], [5]] ] assert find_clusters(T, test_cases) == expected_output def test_find_clusters_no_friendships(): test_cases = [ (4, 0, []), (1, 0, []), (2, 0, []) ] T = 3 expected_output = [ [[1], [2], [3], [4]], [[1]], [[1], [2]] ] assert find_clusters(T, test_cases) == expected_output def test_find_clusters_with_self_loops_and_multiple_edges(): test_cases = [ (3, 3, [(1, 1), (1, 1), (2, 1)]), (3, 2, [(1, 2), (2, 3)]) ] T = 2 expected_output = [ [[1, 2], [3]], [[1, 2, 3]] ] assert find_clusters(T, test_cases) == expected_output def test_find_clusters_large_input(): test_cases = [ (10, 5, [(1, 2), (2, 3), (4, 5), (5, 6), (7, 8)]), ] T = 1 expected_output = [ [[1, 2, 3], [4, 5, 6], [7, 8], [9], [10]], ] assert find_clusters(T, test_cases) == expected_output","solution":"def find_clusters(T, test_cases): from collections import defaultdict, deque def bfs(node, visited, adj_list, cluster): queue = deque([node]) while queue: n = queue.popleft() for neighbor in adj_list[n]: if not visited[neighbor]: visited[neighbor] = True cluster.append(neighbor) queue.append(neighbor) results = [] for i in range(T): N, M, edges = test_cases[i] adj_list = defaultdict(list) visited = [False] * (N + 1) for u, v in edges: adj_list[u].append(v) adj_list[v].append(u) clusters = [] for person in range(1, N + 1): if not visited[person]: visited[person] = True cluster = [person] bfs(person, visited, adj_list, cluster) clusters.append(sorted(cluster)) clusters.sort(key=lambda x: x[0]) results.append(clusters) return results"},{"question":"def min_operations(s: str, t: str) -> int: Computes the minimum number of operations required to transform string s into string t. >>> min_operations(\\"intention\\", \\"execution\\") 5 >>> min_operations(\\"horse\\", \\"ros\\") 3 >>> min_operations(\\"abcdef\\", \\"ghijkl\\") 6 >>> min_operations(\\"a\\", \\"a\\") 0 >>> min_operations(\\"a\\", \\"b\\") 1 >>> min_operations(\\"ab\\", \\"ab\\") 0 >>> min_operations(\\"ab\\", \\"ac\\") 1 >>> min_operations(\\"\\", \\"\\") 0 >>> min_operations(\\"kitten\\", \\"sitting\\") 3 >>> min_operations(\\"\\", \\"a\\") 1 >>> min_operations(\\"a\\", \\"\\") 1 >>> min_operations(\\"a\\", \\"ab\\") 1 >>> min_operations(\\"ab\\", \\"a\\") 1 pass def test_min_operations(): assert min_operations(\\"intention\\", \\"execution\\") == 5 assert min_operations(\\"horse\\", \\"ros\\") == 3 assert min_operations(\\"abcdef\\", \\"ghijkl\\") == 6 assert min_operations(\\"a\\", \\"a\\") == 0 assert min_operations(\\"a\\", \\"b\\") == 1 assert min_operations(\\"ab\\", \\"ab\\") == 0 assert min_operations(\\"ab\\", \\"ac\\") == 1 assert min_operations(\\"\\", \\"\\") == 0 assert min_operations(\\"kitten\\", \\"sitting\\") == 3 def test_edge_cases(): assert min_operations(\\"\\", \\"a\\") == 1 assert min_operations(\\"a\\", \\"\\") == 1 assert min_operations(\\"a\\", \\"ab\\") == 1 assert min_operations(\\"ab\\", \\"a\\") == 1 # Running the tests to verify the solution if __name__ == \\"__main__\\": test_min_operations() test_edge_cases()","solution":"def min_operations(s, t): Computes the minimum number of operations required to transform string s into string t. m, n = len(s), len(t) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(m + 1): for j in range(n + 1): if i == 0: dp[i][j] = j # If s is empty, we need to insert all characters of t elif j == 0: dp[i][j] = i # If t is empty, we need to delete all characters of s elif s[i - 1] == t[j - 1]: dp[i][j] = dp[i - 1][j - 1] # If characters are equal, no operation is needed else: dp[i][j] = 1 + min(dp[i - 1][j], # Delete from s dp[i][j - 1], # Insert into s dp[i - 1][j - 1]) # Replace in s return dp[m][n]"},{"question":"def lexicographically_smallest_string(T: int, test_cases: list[tuple[int, str]]) -> list[str]: Given a list of test cases, each with the length N and string S, return a list of lexicographically smallest strings after performing at most one operation on each string. >>> lexicographically_smallest_string(3, [(3, 'cba'), (5, 'abzcd'), (4, 'bcda')]) ['aaa', 'aaaaa', 'aaaa']","solution":"def lexicographically_smallest_string(T, test_cases): Given a list of test cases, each with the length N and string S, return a list of lexicographically smallest strings after performing at most one operation on each string. results = [] for i in range(T): N, S = test_cases[i] # Option 1: reversing the entire string reverse_option = S[::-1] # Option 2: replacing any substring with all 'a's replace_option = 'a' * N # Determine the smallest between these two options smallest_string = min(reverse_option, replace_option) results.append(smallest_string) return results"},{"question":"def generate_borrowers_list(records): Generates a dictionary of borrowers and the books they have borrowed. Args: records (list of tuples): List where each tuple consists of a borrower name (string) and a book title (string). Returns: dict: Dictionary where each key is a borrower's name, and the corresponding value is a list of books they have borrowed, sorted alphabetically. pass # Test cases def test_generate_borrowers_list_example1(): records = [ ('Alice', 'War and Peace'), ('Bob', '1984'), ('Alice', 'To Kill a Mockingbird'), ('Bob', 'Animal Farm') ] expected_output = { 'Alice': ['To Kill a Mockingbird', 'War and Peace'], 'Bob': ['1984', 'Animal Farm'] } assert generate_borrowers_list(records) == expected_output def test_generate_borrowers_list_example2(): records = [ ('Carol', 'Brave New World'), ('Alice', 'The Great Gatsby'), ('Carol', 'Sapiens') ] expected_output = { 'Alice': ['The Great Gatsby'], 'Carol': ['Brave New World', 'Sapiens'] } assert generate_borrowers_list(records) == expected_output def test_generate_borrowers_list_empty(): records = [] expected_output = {} assert generate_borrowers_list(records) == expected_output def test_generate_borrowers_list_single_record(): records = [('Alice', 'Moby Dick')] expected_output = {'Alice': ['Moby Dick']} assert generate_borrowers_list(records) == expected_output def test_generate_borrowers_list_multiple_books_for_one_borrower(): records = [ ('Alice', 'Moby Dick'), ('Alice', 'The Catcher in the Rye'), ('Alice', 'Frankenstein') ] expected_output = { 'Alice': ['Frankenstein', 'Moby Dick', 'The Catcher in the Rye'] } assert generate_borrowers_list(records) == expected_output","solution":"def generate_borrowers_list(records): Generates a dictionary of borrowers and the books they have borrowed. Args: records (list of tuples): List where each tuple consists of a borrower name (string) and a book title (string). Returns: dict: Dictionary where each key is a borrower's name, and the corresponding value is a list of books they have borrowed, sorted alphabetically. borrowers_books = {} for name, book in records: if name in borrowers_books: borrowers_books[name].append(book) else: borrowers_books[name] = [book] for name in borrowers_books: borrowers_books[name].sort() return dict(sorted(borrowers_books.items()))"},{"question":"def bank_transactions(T: int, transactions: List[str]) -> List[str]: Simulates a simple bank transaction system where multiple customers can make deposits or withdrawals. Each customer has a unique name and an account balance which starts at 0. The transactions must be processed in the order they are received. Args: T (int): the number of transactions. transactions (List[str]): each containing one of the following transactions: \\"deposit <name> <amount>\\" - customer with the given name deposits the specified amount into their account. \\"withdraw <name> <amount>\\" - customer with the given name withdraws the specified amount from their account. If insufficient balance, transaction is ignored. \\"balance <name>\\" - prints the current balance of the customer with the given name. Returns: List[str]: balance information for \\"balance\\" transactions in the order they are received. Example: >>> bank_transactions(7, [ ... \\"deposit Alice 200\\", ... \\"deposit Bob 150\\", ... \\"withdraw Alice 100\\", ... \\"withdraw Bob 200\\", ... \\"balance Alice\\", ... \\"balance Bob\\", ... \\"balance Charlie\\" ... ]) [\\"Alice 100\\", \\"Bob 150\\", \\"Charlie 0\\"]","solution":"def bank_transactions(T, transactions): accounts = {} result = [] for transaction in transactions: parts = transaction.split() action, name = parts[0], parts[1] if name not in accounts: accounts[name] = 0 if action == \\"deposit\\": amount = int(parts[2]) accounts[name] += amount elif action == \\"withdraw\\": amount = int(parts[2]) if accounts[name] >= amount: accounts[name] -= amount elif action == \\"balance\\": result.append(f\\"{name} {accounts[name]}\\") return result"},{"question":"from typing import List, Tuple, Union def minimum_forwards_for_all(t: int, test_cases: List[Tuple[int, List[List[int]]]]) -> List[Union[int, str]]: Determine the fewest number of forwards required for an employee to send a message to every other employee. >>> minimum_forwards_for_all(2, [(3, [[2, 2, 3], [1, 3], [0]]), (4, [[1, 2], [1, 3], [0], [1, 4]])]) [1, 'impossible'] >>> minimum_forwards_for_all(1, [(1, [[0]])]) [0] >>> minimum_forwards_for_all(1, [(4, [[1, 2], [1, 3], [1, 4], [0]])]) [3] >>> minimum_forwards_for_all(1, [(4, [[1, 2], [0], [1, 4], [0]])]) ['impossible'] >>> minimum_forwards_for_all(1, [(5, [[2, 2, 3], [2, 4, 5], [1, 4], [1, 5], [0]])]) [2] pass","solution":"from collections import deque, defaultdict def minimum_forwards_for_all(t, test_cases): def bfs(start, graph, n): visited = [False] * (n + 1) queue = deque([(start, 0)]) visited[start] = True max_distance = 0 while queue: node, distance = queue.popleft() max_distance = max(max_distance, distance) for neighbor in graph[node]: if not visited[neighbor]: visited[neighbor] = True queue.append((neighbor, distance + 1)) # Checking if all nodes were visited if all(visited[1:]): return max_distance else: return float(\\"inf\\") results = [] for test_case in test_cases: n, contacts = test_case graph = defaultdict(list) for i in range(1, n+1): if contacts[i-1][0] > 0: graph[i].extend(contacts[i-1][1:]) min_forwards = float(\\"inf\\") for i in range(1, n+1): min_forwards = min(min_forwards, bfs(i, graph, n)) if min_forwards == float(\\"inf\\"): results.append(\\"impossible\\") else: results.append(min_forwards) return results # Example usage with sample input def main(): sample_input = [ (3, [[2, 2, 3], [1, 3], [0]]), (4, [[1, 2], [1, 3], [0], [1, 4]]) ] output = minimum_forwards_for_all(2, sample_input) for res in output: print(res) if __name__ == \\"__main__\\": main()"},{"question":"def longest_arith_seq_length(A: List[int]) -> int: Returns the length of the longest arithmetic subsequence in the list A. Args: A (List[int]): A list of integers representing the sequence. Returns: int: The length of the longest arithmetic subsequence. Examples: >>> longest_arith_seq_length([3, 6, 9, 12, 15, 18]) 6 >>> longest_arith_seq_length([1, 7, 10, 15, 27, 29, 33]) 3 >>> longest_arith_seq_length([-1, -5, -9, -13]) 4 >>> longest_arith_seq_length([5]) 1 >>> longest_arith_seq_length([]) 0 >>> longest_arith_seq_length([1, 2]) 2 >>> longest_arith_seq_length([1, 2, 4, 8, 16]) 2 >>> longest_arith_seq_length([5, 5, 5, 5, 5]) 5","solution":"def longest_arith_seq_length(A): Returns the length of the longest arithmetic subsequence in the list A. if not A: return 0 n = len(A) dp = [{} for _ in range(n)] max_len = 1 for i in range(1, n): for j in range(i): diff = A[i] - A[j] if diff in dp[j]: dp[i][diff] = dp[j][diff] + 1 else: dp[i][diff] = 2 max_len = max(max_len, dp[i][diff]) return max_len"},{"question":"from typing import List, Tuple def find_lineage(N: int, operations: List[str], Q: int, queries: List[int]) -> List[Tuple[int, int]]: Determine the earliest acquired ancestor asset for a given asset along with the user who acquired it. >>> find_lineage(5, [\\"A 1 10\\", \\"A 2 20\\", \\"T 30 5 10 20\\", \\"A 3 40\\", \\"T 50 6 40 30\\"], 2, [30, 50]) [(10, 1), (10, 1)] >>> find_lineage(1, [\\"A 1 100\\"], 1, [100]) [(100, 1)]","solution":"def find_lineage(N, operations, Q, queries): user_acquisitions = {} transformations = {} for op in operations: parts = op.split() if parts[0] == 'A': user, asset = int(parts[1]), int(parts[2]) user_acquisitions[asset] = user elif parts[0] == 'T': asset = int(parts[1]) parents = list(map(int, parts[3:])) transformations[asset] = parents def earliest_ancestor(asset): visited = set() while asset in transformations: asset = min(transformations[asset]) if asset in visited: break visited.add(asset) return asset, user_acquisitions.get(asset, -1) results = [] for query in queries: asset = int(query) results.append(earliest_ancestor(asset)) return results"},{"question":"def max_spell_strength(n: int, powers: List[int]) -> int: Determine the maximum sum of powers that can be achieved by selecting a contiguous sub-array. >>> max_spell_strength(9, [-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_spell_strength(3, [1, -2, 3]) 3","solution":"def max_spell_strength(n, powers): Returns the maximum sum of a contiguous sub-array in the powers list using Kadane's algorithm. Parameters: n (int): Number of wizards powers (list of int): List of integers representing the magical powers of the wizards Returns: int: The maximum spell strength (maximum sum of contiguous sub-array) max_current = max_global = powers[0] for i in range(1, n): max_current = max(powers[i], max_current + powers[i]) if max_current > max_global: max_global = max_current return max_global # Example usage: # n = 9 # powers = [-2, 1, -3, 4, -1, 2, 1, -5, 4] # print(max_spell_strength(n, powers)) # Output: 6"},{"question":"def word_break(s: str, word_dict: List[str]) -> bool: Determine if the string can be segmented into a space-separated sequence of one or more dictionary words. >>> word_break(\\"leetcode\\", [\\"leet\\", \\"code\\"]) True >>> word_break(\\"applepenapple\\", [\\"apple\\", \\"pen\\"]) True >>> word_break(\\"catsandog\\", [\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"]) False","solution":"def word_break(s, word_dict): Determine if the string can be segmented into a space-separated sequence of one or more dictionary words. :param s: String to be segmented :param word_dict: List of dictionary words :return: True if string can be segmented, False otherwise word_set = set(word_dict) dp = [False] * (len(s) + 1) dp[0] = True # base case: empty string for i in range(1, len(s) + 1): for j in range(i): if dp[j] and s[j:i] in word_set: dp[i] = True break return dp[len(s)]"},{"question":"def total_enemies_to_defeat(N: int, enemies: List[int]) -> int: Calculate the total number of enemies the player needs to defeat to complete all levels. Parameters: N (int): Number of levels. enemies (list): List of integers representing the number of enemies in each level. Returns: int: Total number of enemies to defeat. >>> total_enemies_to_defeat(5, [3, 1, 4, 2, 0]) 10 >>> total_enemies_to_defeat(3, [0, 2, 5]) 7","solution":"def total_enemies_to_defeat(N, enemies): Returns the total number of enemies the player needs to defeat to complete all levels. Parameters: N (int): Number of levels. enemies (list): List of integers representing the number of enemies in each level. return sum(enemies)"},{"question":"def can_allocate_tasks(n: int, k: int, tasks: list[tuple[int, int]]) -> str: Determines if it is possible to allocate all the tasks to k servers without overlap. Parameters: n (int): Number of tasks k (int): Number of servers tasks (list of tuples): Each tuple contains two integers (start, end) representing the start and end times of a task Returns: str: \\"YES\\" if allocation is possible, otherwise \\"NO\\" pass from can_allocate_tasks import can_allocate_tasks def test_example_1(): n = 3 k = 2 tasks = [(1, 3), (2, 5), (4, 6)] assert can_allocate_tasks(n, k, tasks) == \\"YES\\" def test_example_2(): n = 3 k = 1 tasks = [(1, 4), (2, 5), (6, 8)] assert can_allocate_tasks(n, k, tasks) == \\"NO\\" def test_exact_servers(): n = 5 k = 5 tasks = [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)] assert can_allocate_tasks(n, k, tasks) == \\"YES\\" def test_more_servers_than_tasks(): n = 3 k = 4 tasks = [(1, 10), (2, 5), (6, 9)] assert can_allocate_tasks(n, k, tasks) == \\"YES\\" def test_overlapping_tasks(): n = 4 k = 2 tasks = [(1, 4), (2, 5), (3, 6), (7, 8)] assert can_allocate_tasks(n, k, tasks) == \\"NO\\" def test_no_overlapping_tasks(): n = 5 k = 2 tasks = [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)] assert can_allocate_tasks(n, k, tasks) == \\"YES\\" def test_single_task(): n = 1 k = 1 tasks = [(1, 2)] assert can_allocate_tasks(n, k, tasks) == \\"YES\\" def test_large_case(): n = 10**3 k = 500 tasks = [(i, i + 1) for i in range(n)] assert can_allocate_tasks(n, k, tasks) == \\"YES\\"","solution":"def can_allocate_tasks(n, k, tasks): Determines if it is possible to allocate all the tasks to k servers without overlap. Parameters: n (int): Number of tasks k (int): Number of servers tasks (list of tuples): Each tuple contains two integers (start, end) representing the start and end times of a task Returns: str: \\"YES\\" if allocation is possible, otherwise \\"NO\\" if k >= n: return \\"YES\\" # Sort tasks by start time and then by end time tasks.sort(key=lambda x: (x[0], x[1])) # Min-heap to keep track of server end times import heapq min_heap = [] for start, end in tasks: if min_heap and min_heap[0] <= start: heapq.heappop(min_heap) # Remove the task that got freed up heapq.heappush(min_heap, end) if len(min_heap) > k: return \\"NO\\" return \\"YES\\""},{"question":"def decodeString(s: str) -> str: Decodes the given encoded string and returns the decoded string. >>> decodeString(\\"3[a]2[bc]\\") == \\"aaabcbc\\" >>> decodeString(\\"3[a2[c]]\\") == \\"accaccacc\\" >>> decodeString(\\"2[abc]3[cd]ef\\") == \\"abcabccdcdcdef\\" >>> decodeString(\\"10[z]\\") == \\"zzzzzzzzzz\\" >>> decodeString(\\"abc\\") == \\"abc\\" >>> decodeString(\\"\\") == \\"\\" def test_decodeString_simple(): assert decodeString(\\"3[a]2[bc]\\") == \\"aaabcbc\\" def test_decodeString_nested(): assert decodeString(\\"3[a2[c]]\\") == \\"accaccacc\\" def test_decodeString_multiple_encodings(): assert decodeString(\\"2[abc]3[cd]ef\\") == \\"abcabccdcdcdef\\" def test_decodeString_single_character(): assert decodeString(\\"10[z]\\") == \\"zzzzzzzzzz\\" def test_decodeString_no_repeats(): assert decodeString(\\"abc\\") == \\"abc\\" def test_decodeString_empty_string(): assert decodeString(\\"\\") == \\"\\"","solution":"def decodeString(s: str) -> str: Decodes the given encoded string and returns the decoded string. stack = [] current_num = 0 current_str = \\"\\" for char in s: if char.isdigit(): current_num = current_num * 10 + int(char) elif char == '[': stack.append((current_str, current_num)) current_str = \\"\\" current_num = 0 elif char == ']': last_str, num = stack.pop() current_str = last_str + num * current_str else: current_str += char return current_str"},{"question":"def count_connected_components(N: int, M: int, edges: List[Tuple[int, int]]) -> int: Returns the number of connected components in the graph. Parameters: N (int): Number of nodes M (int): Number of edges edges (list of tuples): List of edges where each edge is represented as a tuple (u, v) Returns: int: Number of connected components >>> count_connected_components(5, 3, [(1, 2), (1, 3), (4, 5)]) 2 >>> count_connected_components(1, 0, []) 1 >>> count_connected_components(2, 0, []) 2 >>> count_connected_components(2, 1, [(1, 2)]) 1 >>> count_connected_components(6, 3, [(1, 2), (3, 4), (5, 6)]) 3 >>> count_connected_components(4, 3, [(1, 2), (2, 3), (3, 4)]) 1 >>> count_connected_components(7, 4, [(1, 2), (2, 3), (4, 5), (6, 7)]) 3 >>> count_connected_components(4, 0, []) 4 pass","solution":"def count_connected_components(N, M, edges): Returns the number of connected components in the graph. Parameters: N (int): Number of nodes M (int): Number of edges edges (list of tuples): List of edges where each edge is represented as a tuple (u, v) Returns: int: Number of connected components from collections import defaultdict, deque # Use adjacency list representation for the graph graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) visited = [False] * (N + 1) def bfs(start): queue = deque([start]) visited[start] = True while queue: node = queue.popleft() for neighbor in graph[node]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) connected_components = 0 for node in range(1, N + 1): if not visited[node]: bfs(node) connected_components += 1 return connected_components"},{"question":"def mana_cost(spell: str) -> int: Calculate the mana cost of the spell as the sum of the unique characters, where 'a' = 1, 'b' = 2, ..., 'z' = 26. >>> mana_cost(\\"abc\\") 6 >>> mana_cost(\\"aabbcc\\") 6 >>> mana_cost(\\"zxy\\") 75 >>> mana_cost(\\"a\\") 1 >>> mana_cost(\\"az\\") 27 pass def process_spells(spells: List[str]) -> List[int]: Process a list of spells and return a list of mana costs. >>> process_spells([\\"abc\\", \\"aabbcc\\", \\"zxy\\"]) [6, 6, 75] >>> process_spells([\\"a\\", \\"aa\\", \\"zzz\\"]) [1, 1, 26] >>> process_spells([\\"xyz\\", \\"xyza\\", \\"xyzz\\"]) [75, 76, 75] pass","solution":"def mana_cost(spell): Calculate the mana cost of the spell as the sum of the unique characters, where 'a' = 1, 'b' = 2, ..., 'z' = 26. unique_characters = set(spell) mana_cost = sum(ord(char) - ord('a') + 1 for char in unique_characters) return mana_cost def process_spells(spells): Process a list of spells and return a list of mana costs. return [mana_cost(spell) for spell in spells]"},{"question":"import itertools def generate_team_ids(s: str) -> list: Generate all unique permutations of the given string. Parameters: s (str): The input string Returns: list: A list of all unique permutations of the input string >>> generate_team_ids(\\"ABC\\") ['ABC', 'ACB', 'BAC', 'BCA', 'CAB', 'CBA'] >>> generate_team_ids(\\"AAB\\") ['AAB', 'ABA', 'BAA'] >>> generate_team_ids(\\"A\\") ['A'] >>> generate_team_ids(\\"AAA\\") ['AAA'] >>> generate_team_ids(\\"ABCD\\") sorted([''.join(p) for p in itertools.permutations(\\"ABCD\\")]) >>> generate_team_ids(\\"CBA\\") ['ABC', 'ACB', 'BAC', 'BCA', 'CAB', 'CBA']","solution":"import itertools def generate_team_ids(s): Generate all unique permutations of the given string. Parameters: s (str): The input string Returns: list: A list of all unique permutations of the input string return sorted(set(''.join(p) for p in itertools.permutations(s)))"},{"question":"def two_sum(nums, k): Determine if there are two distinct indices i and j in the array such that nums[i] + nums[j] = k. Parameters: nums (list): List of integers. k (int): Target integer. Returns: str: \\"YES\\" if there are two distinct indices with the sum equal to k, otherwise \\"NO\\". >>> two_sum([2, 7, 11, 15], 10) == \\"NO\\" >>> two_sum([1, 2, 3, 4, 5], 7) == \\"YES\\" >>> two_sum([-1, -2, -3, -4, -5], -8) == \\"YES\\" >>> two_sum([1000000000, 2000000000, 3000000000], 5000000000) == \\"YES\\" >>> two_sum([5, 5, 5, 5], 12) == \\"NO\\" >>> two_sum([2], 2) == \\"NO\\" >>> two_sum([], 0) == \\"NO\\"","solution":"def two_sum(nums, k): Determine if there are two distinct indices i and j in the array such that nums[i] + nums[j] = k. Parameters: nums (list): List of integers. k (int): Target integer. Returns: str: \\"YES\\" if there are two distinct indices with the sum equal to k, otherwise \\"NO\\". seen = set() for num in nums: if k - num in seen: return \\"YES\\" seen.add(num) return \\"NO\\""},{"question":"from typing import List def longest_increasing_path(grid: List[List[int]]) -> int: Find the longest increasing path in a n x n grid. The movement is allowed in four directions: up, down, left, and right. >>> longest_increasing_path([ ... [9, 9, 4], ... [6, 6, 8], ... [2, 1, 1] ... ]) 4 >>> longest_increasing_path([[42]]) 1 >>> longest_increasing_path([]) 0 >>> longest_increasing_path([ ... [1, 2, 3, 4], ... [12, 13, 14, 5], ... [11, 16, 15, 6], ... [10, 9, 8, 7] ... ]) 16 >>> longest_increasing_path([ ... [7, 7, 7], ... [7, 7, 7], ... [7, 7, 7] ... ]) 1","solution":"from typing import List def longest_increasing_path(grid: List[List[int]]) -> int: if not grid or not grid[0]: return 0 n = len(grid) m = len(grid[0]) memo = [[-1] * m for _ in range(n)] def dfs(x, y): if memo[x][y] != -1: return memo[x][y] directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] max_len = 1 for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] > grid[x][y]: max_len = max(max_len, 1 + dfs(nx, ny)) memo[x][y] = max_len return max_len res = 0 for i in range(n): for j in range(m): res = max(res, dfs(i, j)) return res"},{"question":"def are_anagrams(string1: str, string2: str) -> str: Determines if two strings are anagrams. Args: string1: A string consisting of lowercase letters. string2: A string consisting of lowercase letters. Returns: 'YES' if string1 and string2 are anagrams, otherwise 'NO'. >>> are_anagrams(\\"listen\\", \\"silent\\") \\"YES\\" >>> are_anagrams(\\"hello\\", \\"world\\") \\"NO\\"","solution":"def are_anagrams(string1: str, string2: str) -> str: Determines if two strings are anagrams. Args: string1: A string consisting of lowercase letters. string2: A string consisting of lowercase letters. Returns: 'YES' if string1 and string2 are anagrams, otherwise 'NO'. # Sort both strings and compare them if sorted(string1) == sorted(string2): return \\"YES\\" else: return \\"NO\\""},{"question":"def max_height_difference(H, W, grid): Returns the maximum height difference between any two adjacent cells in the grid. >>> max_height_difference(3, 3, [ ... [1, 2, 2], ... [3, 8, 2], ... [5, 3, 5] ... ]) 6 >>> max_height_difference(2, 2, [ ... [1, 1000000000], ... [1, 1000000000] ... ]) 999999999 >>> max_height_difference(4, 5, [ ... [5, 5, 5, 5, 5], ... [4, 1, 1, 1, 4], ... [4, 1, 8, 1, 4], ... [5, 4, 4, 4, 4] ... ]) 7","solution":"def max_height_difference(H, W, grid): Returns the maximum height difference between any two adjacent cells in the grid. max_diff = 0 for i in range(H): for j in range(W): if i > 0: max_diff = max(max_diff, abs(grid[i][j] - grid[i-1][j])) if i < H - 1: max_diff = max(max_diff, abs(grid[i][j] - grid[i+1][j])) if j > 0: max_diff = max(max_diff, abs(grid[i][j] - grid[i][j-1])) if j < W - 1: max_diff = max(max_diff, abs(grid[i][j] - grid[i][j+1])) return max_diff"},{"question":"def reverse_and_invert_case(strings): Takes an array of strings as input and returns a new array where each string has been reversed and the case of each character is inverted. :param strings: list of str :return: list of str >>> reverse_and_invert_case([\\"Hello\\"]) == [\\"OLLEh\\"] >>> reverse_and_invert_case([\\"Hello\\", \\"WORLD\\", \\"Python\\"]) == [\\"OLLEh\\", \\"dlrow\\", \\"NOHTYp\\"] >>> reverse_and_invert_case([\\"ABC\\"]) == [\\"cba\\"] >>> reverse_and_invert_case([\\"abc\\"]) == [\\"CBA\\"] >>> reverse_and_invert_case([\\"aBcDe\\"]) == [\\"EdCbA\\"] >>> reverse_and_invert_case([\\"abc\\", \\"def\\", \\"ghi\\"]) == [\\"CBA\\", \\"FED\\", \\"IHG\\"] >>> reverse_and_invert_case([\\"XYZ\\", \\"UVW\\", \\"RST\\"]) == [\\"zyx\\", \\"wvu\\", \\"tsr\\"]","solution":"def reverse_and_invert_case(strings): Takes an array of strings and returns a new array where each string has been reversed and the case of each character is inverted. :param strings: list of str :return: list of str result = [] for s in strings: reversed_inverted = ''.join([char.lower() if char.isupper() else char.upper() for char in s[::-1]]) result.append(reversed_inverted) return result"},{"question":"def evaluate_expression(expression: str) -> int: Evaluates a mathematical expression containing non-negative integers and the operators +, -, *, /. Integer division truncates towards zero. Examples: >>> evaluate_expression(\\"3+2*2\\") 7 >>> evaluate_expression(\\" 3/2 \\") 1 >>> evaluate_expression(\\" 3+5 / 2 \\") 5","solution":"def evaluate_expression(expression): Evaluates a mathematical expression containing non-negative integers and the operators +, -, *, /. Integer division truncates towards zero. def operate(a, b, op): if op == '+': return a + b elif op == '-': return a - b elif op == '*': return a * b elif op == '/': return a // b i, n = 0, len(expression) stack, num, sign = [], 0, '+' while i < n: if expression[i].isdigit(): num = num * 10 + int(expression[i]) if expression[i] in \\"+-*/\\" or i == n - 1: if sign == '+': stack.append(num) elif sign == '-': stack.append(-num) elif sign == '*': stack.append(stack.pop() * num) elif sign == '/': stack.append(int(stack.pop() / num)) # truncate towards zero sign = expression[i] num = 0 i += 1 return sum(stack)"},{"question":"def validate_passwords(passwords): Validates a list of passwords. Returns \\"YES\\" if the password is strong, otherwise \\"NO\\". Parameters: passwords (list): List of strings representing the passwords. Returns: list: List of strings \\"YES\\" or \\"NO\\" for each password. Test Cases: >>> validate_passwords([ ... \\"MyP@ssw0rd\\", # YES ... \\"Paw0rd123\\", # YES ... \\"WeakPass123\\", # NO ... \\"NopecialChar\\", # NO ... \\"Strong@45\\" # YES ... ]) == [\\"YES\\", \\"YES\\", \\"NO\\", \\"NO\\", \\"YES\\"] >>> validate_passwords([ ... \\"abc\\", # NO ... \\"A1@bcdefg\\", # YES ... \\"A1@bcdef\\", # YES ... \\"A1@bcdefG\\", # YES ... \\"a1@bcdefG\\", # YES ... \\"12345678\\", # NO ... \\"ABCDEFGH\\", # NO ... \\"@@!!@@!@\\", # NO ... ]) == [\\"NO\\", \\"YES\\", \\"YES\\", \\"YES\\", \\"YES\\", \\"NO\\", \\"NO\\", \\"NO\\"] pass def process_input(input_string): Processes the input string and returns a space-separated string of results. Parameters: input_string (str): The input string containing space-separated passwords. Returns: str: Space-separated string of \\"YES\\" or \\"NO\\" results for each password in the input. Test Cases: >>> process_input(\\"MyP@ssw0rd Paw0rd123 WeakPass123 NopecialChar Strong@45\\") == \\"YES YES NO NO YES\\" >>> process_input(\\"abc A1@bcdefg A1@bcdef A1@bcdefG a1@bcdefG 12345678 ABCDEFGH @@!!@@!@\\") == \\"NO YES YES YES YES NO NO NO\\" pass","solution":"import re def validate_passwords(passwords): Validates a list of passwords. Returns \\"YES\\" if the password is strong, otherwise \\"NO\\". Parameters: passwords (list): List of strings representing the passwords. Returns: list: List of strings \\"YES\\" or \\"NO\\" for each password. results = [] special_characters = re.escape(\\"!@#%^&*()-+\\") for password in passwords: if (len(password) >= 8 and re.search(r'[A-Z]', password) and re.search(r'[a-z]', password) and re.search(r'[0-9]', password) and re.search(f'[{special_characters}]', password)): results.append(\\"YES\\") else: results.append(\\"NO\\") return results def process_input(input_string): Processes the input string and returns a space-separated string of results. Parameters: input_string (str): The input string containing space-separated passwords. Returns: str: Space-separated string of \\"YES\\" or \\"NO\\" results for each password in the input. passwords = input_string.split() validation_results = validate_passwords(passwords) return \\" \\".join(validation_results)"},{"question":"def process_queries(q: int, queries: List[str]) -> List[int]: Evaluate employee performance by tracking task completion times. Args: q: An integer representing the number of queries. queries: A list of strings, each representing a query of format 'C id time', 'U id time', or 'Q id'. Returns: A list of integers representing the results of the 'Q id' queries. Examples: >>> process_queries(7, [\\"C 1 5\\", \\"C 2 3\\", \\"Q 1\\", \\"U 2 4\\", \\"Q 2\\", \\"C 3 10\\", \\"Q 3\\"]) [5, 4, 10] >>> process_queries(3, [\\"C 1 5\\", \\"C 2 3\\", \\"Q 1\\"]) [5] >>> process_queries(5, [\\"C 1 1\\", \\"C 2 2\\", \\"Q 1\\", \\"Q 2\\"]) [1, 2]","solution":"def process_queries(q, queries): task_completion_times = {} results = [] for query in queries: parts = query.split() command = parts[0] task_id = int(parts[1]) if command == \\"C\\": time = int(parts[2]) task_completion_times[task_id] = time elif command == \\"U\\": time = int(parts[2]) task_completion_times[task_id] = time elif command == \\"Q\\": results.append(task_completion_times[task_id]) return results"},{"question":"def is_path_possible(m: int, n: int, grid: List[List[int]]) -> str: Determines if there is a path from the top-left to the bottom-right cell. >>> is_path_possible(3, 3, [[0, 1, 0], [0, 0, 0], [1, 1, 0]]) \\"YES\\" >>> is_path_possible(3, 3, [[0, 1, 0], [1, 1, 0], [1, 1, 0]]) \\"NO\\"","solution":"def is_path_possible(m, n, grid): Determines if there is a path from the top-left to the bottom-right cell. if grid[0][0] == 1 or grid[m-1][n-1] == 1: return \\"NO\\" def dfs(x, y, visited): if x == m - 1 and y == n - 1: return True directions = [(1, 0), (0, 1)] visited.add((x, y)) for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 0 and (nx, ny) not in visited: if dfs(nx, ny, visited): return True return False return \\"YES\\" if dfs(0, 0, set()) else \\"NO\\" # Example usage: # m, n = 3, 3 # grid = [ # [0, 1, 0], # [0, 0, 0], # [1, 1, 0] # ] # print(is_path_possible(m, n, grid)) # Output: YES"},{"question":"def find_subsequence_score(T, test_cases): Determines if there exists a contiguous subsequence of a given word that has a score equal to the given integer K. The function processes multiple test cases. For each test case, the function returns \\"YES\\" if a contiguous subsequence with the given score exists, otherwise \\"NO\\". Args: T (int): The number of test cases. test_cases (List[Tuple[int, str, int]]): A list of tuples, where each tuple contains the length of the word (N), the word itself, and an integer K. Returns: List[str]: A list of results for each test case, with \\"YES\\" or \\"NO\\" as answers. Example: >>> find_subsequence_score(2, [(3, \\"abc\\", 6), (5, \\"zyxwv\\", 15)]) [\\"YES\\", \\"NO\\"] >>> find_subsequence_score(1, [(1, \\"a\\", 1)]) [\\"YES\\"] # Your code here","solution":"def calculate_char_value(c): return ord(c) - ord('a') + 1 def find_subsequence_score(T, test_cases): results = [] for i in range(T): N, word, K = test_cases[i] prefix_sum = [0] * (N + 1) for j in range(N): prefix_sum[j + 1] = prefix_sum[j] + calculate_char_value(word[j]) sum_set = {0} found = False for j in range(1, N + 1): if (prefix_sum[j] - K) in sum_set: found = True break sum_set.add(prefix_sum[j]) if found: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"from typing import List def process_trip_data(test_cases: List[List[int, str]]) -> List[str]: Process the trip data of cars and return the total distance traveled by each car. Args: - test_cases: A list of test cases. Each test case consists of the number of cars and car data. Returns: - A list of strings where each string represents a car ID and its total distance, sorted alphabetically by car ID. Example: >>> test_cases = [[3, \\"carA 10 20 30\\", \\"carB 15 25\\", \\"carC 5 10 15 20\\"], [1, \\"carX 50\\", \\"carY 30 60 10\\"]] >>> process_trip_data(test_cases) [\\"carA 60\\", \\"carB 40\\", \\"carC 50\\", \\"carX 50\\", \\"carY 100\\"] def parse_input(input_list: List[str]) -> List[List[int, str]]: Parse the structured input list into a format suitable for the process_trip_data function. Args: - input_list: A list of strings representing the input. Returns: - A list of test cases. Each test case consists of the number of cars and car data. Example: >>> input_list = [\\"2\\", \\"3\\", \\"carA 10 20 30\\", \\"carB 15 25\\", \\"carC 5 10 15 20\\", \\"2\\", \\"carX 50\\", \\"carY 30 60 10\\"] >>> parse_input(input_list) [[3, \\"carA 10 20 30\\", \\"carB 15 25\\", \\"carC 5 10 15 20\\"], [2, \\"carX 50\\", \\"carY 30 60 10\\"]] # Unit tests def test_process_trip_data_example(): input_list = [ \\"2\\", \\"3\\", \\"carA 10 20 30\\", \\"carB 15 25\\", \\"carC 5 10 15 20\\", \\"2\\", \\"carX 50\\", \\"carY 30 60 10\\" ] test_cases = parse_input(input_list) result = process_trip_data(test_cases) expected_result = [ \\"carA 60\\", \\"carB 40\\", \\"carC 50\\", \\"carX 50\\", \\"carY 100\\" ] assert result == expected_result def test_process_trip_data_empty(): input_list = [ \\"1\\", \\"0\\" ] test_cases = parse_input(input_list) result = process_trip_data(test_cases) expected_result = [] assert result == expected_result def test_process_trip_data_single_car(): input_list = [ \\"1\\", \\"1\\", \\"carZ 100 300\\" ] test_cases = parse_input(input_list) result = process_trip_data(test_cases) expected_result = [ \\"carZ 400\\" ] assert result == expected_result def test_process_trip_data_multiple_cases(): input_list = [ \\"2\\", \\"1\\", \\"carA 10 10 10\\", \\"1\\", \\"carB 5 5 5\\" ] test_cases = parse_input(input_list) result = process_trip_data(test_cases) expected_result = [ \\"carA 30\\", \\"carB 15\\" ] assert result == expected_result","solution":"def process_trip_data(test_cases): Process the trip data of cars and return the total distance traveled by each car. result = [] for case in test_cases: number_of_cars = case[0] car_data = case[1:] car_total_distance = {} for car in car_data: car_info = car.split() car_id = car_info[0] trips = map(int, car_info[1:]) total_distance = sum(trips) car_total_distance[car_id] = total_distance sorted_cars = sorted(car_total_distance.items()) for car_id, total_distance in sorted_cars: result.append(f\\"{car_id} {total_distance}\\") return result def parse_input(input_list): Parse the structured input list into a format suitable for the process_trip_data function. index = 0 test_cases = [] T = int(input_list[index]) index += 1 for _ in range(T): N = int(input_list[index]) index += 1 car_data = [input_list[i] for i in range(index, index + N)] test_cases.append([N] + car_data) index += N return test_cases"},{"question":"def rank_players(points: List[int]) -> List[str]: Determine the ranks for players based on their points. >>> rank_players([500, 2000, 3500, 6500]) [\\"Bronze\\", \\"Silver\\", \\"Gold\\", \\"Platinum\\"] >>> rank_players([1500, 999, 4500]) [\\"Silver\\", \\"Bronze\\", \\"Gold\\"]","solution":"def rank_players(points): ranks = [] for point in points: if point < 1000: ranks.append(\\"Bronze\\") elif 1000 <= point <= 2999: ranks.append(\\"Silver\\") elif 3000 <= point <= 5999: ranks.append(\\"Gold\\") else: ranks.append(\\"Platinum\\") return ranks"},{"question":"import sys from collections import deque def is_path_exist(grid, start, end): Determine if there is a path from start to end in the grid. Args: grid (List[List[str]]): Grid with cells either '.' or '#'. start (Tuple[int, int]): Starting cell coordinates. end (Tuple[int, int]): Destination cell coordinates. Returns: str: \\"YES\\" if a path exists, otherwise \\"NO\\". Examples: >>> is_path_exist([\\"....\\", \\".#..\\", \\"....\\", \\"...#\\"], (0, 0), (2, 2)) 'YES' >>> is_path_exist([\\"....\\", \\".#..\\", \\"....\\", \\"...#\\"], (0, 0), (3, 3)) 'NO' pass def solve(): Solve the grid path problem with given input and output the results for each query. pass","solution":"from collections import deque def is_path_exist(grid, start, end): N = len(grid) M = len(grid[0]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] x1, y1 = start x2, y2 = end if grid[x1][y1] == \\"#\\" or grid[x2][y2] == \\"#\\": return \\"NO\\" queue = deque([(x1, y1)]) visited = set() visited.add((x1, y1)) while queue: curr_x, curr_y = queue.popleft() if (curr_x, curr_y) == (x2, y2): return \\"YES\\" for dx, dy in directions: new_x, new_y = curr_x + dx, curr_y + dy if 0 <= new_x < N and 0 <= new_y < M and (new_x, new_y) not in visited and grid[new_x][new_y] == \\".\\": queue.append((new_x, new_y)) visited.add((new_x, new_y)) return \\"NO\\" def solve(): import sys input = sys.stdin.read data = input().split() N, M = int(data[0]), int(data[1]) grid = [] for i in range(N): grid.append(data[2 + i]) Q = int(data[2 + N]) queries = [] for i in range(Q): x1 = int(data[3 + N + 4*i]) - 1 y1 = int(data[3 + N + 4*i + 1]) - 1 x2 = int(data[3 + N + 4*i + 2]) - 1 y2 = int(data[3 + N + 4*i + 3]) - 1 queries.append(((x1, y1), (x2, y2))) results = [] for start, end in queries: results.append(is_path_exist(grid, start, end)) for result in results: print(result)"},{"question":"def longest_equal_subarray(arr): Given a list of integers, finds the length of the longest subarray where all elements are equal. Args: arr (List[int]): A list of integers. Returns: int: The length of the longest subarray where all elements are equal. Examples: >>> longest_equal_subarray([1, 2, 2, 3, 3, 3, 2, 2, 2, 2]) 4 >>> longest_equal_subarray([5, 5, 5, 5, 5]) 5 >>> longest_equal_subarray([1, 2, 3, 4, 5]) 1 >>> longest_equal_subarray([1]) 1 >>> longest_equal_subarray([1, 1, 1, 1, 2]) 4 >>> longest_equal_subarray([1, 1, 2, 2, 3, 3, 3, 4, 4, 4, 4]) 4 >>> longest_equal_subarray([]) 0 >>> longest_equal_subarray([7, 7, 8, 8, 8, 7, 7, 7, 7, 7]) 5","solution":"def longest_equal_subarray(arr): Given a list of integers, finds the length of the longest subarray where all elements are equal. n = len(arr) if n == 0: return 0 max_length = 1 current_length = 1 for i in range(1, n): if arr[i] == arr[i-1]: current_length += 1 else: max_length = max(max_length, current_length) current_length = 1 max_length = max(max_length, current_length) # finalize the max length for the last segment return max_length"},{"question":"def min_obstacles_to_remove(n, m, vert_obstacles, hor_obstacles): Returns the minimum number of obstacles to remove to create a path from (1, 1) to (10^9, 10^9). Args: n (int): Number of vertical obstacles. m (int): Number of horizontal obstacles. vert_obstacles (list): List of vertical obstacle positions. hor_obstacles (list): List of tuples describing horizontal obstacles with start column, end column, and row. Returns: int: Minimum number of obstacles that need to be removed. >>> min_obstacles_to_remove(0, 0, [], []) 0 >>> min_obstacles_to_remove(3, 0, [4, 6, 8], []) 3 >>> min_obstacles_to_remove(0, 3, [], [(2, 5, 3), (3, 7, 4), (1, 6, 2)]) 3 >>> min_obstacles_to_remove(2, 2, [4, 6], [(1, 5, 2), (3, 6, 4)]) 2 >>> min_obstacles_to_remove(1, 1, [7], [(1, 8, 1)]) 1","solution":"def min_obstacles_to_remove(n, m, vert_obstacles, hor_obstacles): Returns the minimum number of obstacles to remove to create a path from (1, 1) to (10^9, 10^9). if n == 0 or m == 0: # If either type of obstacle is absent return max(n, m) # Calculate the overall minimum number of obstacles to be removed return min(n, m)"},{"question":"def min_removals_to_satisfy_max(arr, X): Returns the minimum number of elements to remove from the array such that the maximum element in the remaining array is less than or equal to X. If it is not possible, returns -1. pass def process_test_cases(test_cases): results = [] for case in test_cases: N, X = case[\\"NX\\"] arr = case[\\"array\\"] result = min_removals_to_satisfy_max(arr, X) results.append(result) return results # Unit tests def test_min_removals_to_satisfy_max(): test_cases = [ {\\"NX\\": (5, 4), \\"array\\": [5, 1, 3, 7, 2]}, {\\"NX\\": (4, 6), \\"array\\": [3, 8, 7, 10]}, {\\"NX\\": (3, 5), \\"array\\": [1, 2, 3]}, {\\"NX\\": (6, 13), \\"array\\": [22, 12, 14, 9, 11, 13]} ] results = process_test_cases(test_cases) assert results[0] == 2 assert results[1] == 3 assert results[2] == 0 assert results[3] == 2 def test_edge_cases(): test_cases = [ {\\"NX\\": (1, 1), \\"array\\": [2]}, {\\"NX\\": (1, 1), \\"array\\": [1]}, {\\"NX\\": (3, 5), \\"array\\": [5, 5, 5]}, ] results = process_test_cases(test_cases) assert results[0] == 1 assert results[1] == 0 assert results[2] == 0 def test_impossible_cases(): test_cases = [ {\\"NX\\": (5, 2), \\"array\\": [5, 4, 3, 2, 1]}, {\\"NX\\": (6, 1), \\"array\\": [2, 2, 2, 2, 2, 2]} ] results = process_test_cases(test_cases) assert results[0] == 3 assert results[1] == 6","solution":"def min_removals_to_satisfy_max(arr, X): Returns the minimum number of elements to remove from the array such that the maximum element in the remaining array is less than or equal to X. If it is not possible, returns -1. if max(arr) <= X: return 0 else: count = 0 for num in sorted(arr, reverse=True): if num > X: count += 1 else: break return count def process_test_cases(test_cases): results = [] for case in test_cases: N, X = case[\\"NX\\"] arr = case[\\"array\\"] result = min_removals_to_satisfy_max(arr, X) results.append(result) return results"},{"question":"class Book: def __init__(self, id, title, author, year, genres): self.id = id self.title = title self.author = author self.year = year self.genres = genres class Library: def __init__(self): self.books = {} def add_book(self, id, title, author, year, genres): Adds a new book to the library. >>> library = Library() >>> library.add_book(1, \\"The_Great_Gatsby\\", \\"F._Scott_Fitzgerald\\", 1925, [\\"Fiction\\", \\"Classic\\"]) >>> len(library.books) 1 if id not in self.books: self.books[id] = Book(id, title, author, year, genres) def remove_book(self, id): Removes a book from the library. >>> library = Library() >>> library.add_book(1, \\"The_Great_Gatsby\\", \\"F._Scott_Fitzgerald\\", 1925, [\\"Fiction\\", \\"Classic\\"]) >>> library.remove_book(1) >>> len(library.books) 0 if id in self.books: del self.books[id] def search_books_by_title(self, substring): Searches books by title. >>> library = Library() >>> library.add_book(1, \\"The_Great_Gatsby\\", \\"F._Scott_Fitzgerald\\", 1925, [\\"Fiction\\", \\"Classic\\"]) >>> library.search_books_by_title(\\"Gatsby\\") ['The_Great_Gatsby, F._Scott_Fitzgerald, 1925 (1)'] result = [book for book in self.books.values() if substring.lower() in book.title.lower()] return sorted(result, key=lambda x: x.title) def search_books_by_genre(self, genre): Searches books by genre. >>> library = Library() >>> library.add_book(1, \\"The_Great_Gatsby\\", \\"F._Scott_Fitzgerald\\", 1925, [\\"Fiction\\", \\"Classic\\"]) >>> library.search_books_by_genre(\\"Fiction\\") ['The_Great_Gatsby, F._Scott_Fitzgerald, 1925 (1)'] result = [book for book in self.books.values() if genre in book.genres] return sorted(result, key=lambda x: x.title) def list_books_by_author(self, author): Lists books by author. >>> library = Library() >>> library.add_book(1, \\"The_Great_Gatsby\\", \\"F._Scott_Fitzgerald\\", 1925, [\\"Fiction\\", \\"Classic\\"]) >>> library.list_books_by_author(\\"F._Scott_Fitzgerald\\") ['The_Great_Gatsby, F._Scott_Fitzgerald, 1925 (1)'] result = [book for book in self.books.values() if book.author == author] return sorted(result, key=lambda x: x.year) def process_commands(commands): Processes a list of commands to manage the library. >>> commands = [ \\"5\\", \\"ADD 1 The_Great_Gatsby F._Scott_Fitzgerald 1925 Fiction,Classic\\", \\"ADD 2 To_Kill_a_Mockingbird Harper_Lee 1960 Fiction,Classic\\", \\"SEARCH TITLE Gatsby\\", \\"REMOVE 1\\", \\"SEARCH TITLE Gatsby\\" ] >>> process_commands(commands) \\"The_Great_Gatsby, F._Scott_Fitzgerald, 1925 (1)nnNO MATCHES\\" library = Library() output = [] for command in commands: parts = command.split(' ', 2) action = parts[0] if action == \\"ADD\\": _, id, rest = parts id = int(id) rest_parts = rest.split(' ', 3) title = rest_parts[0] author = rest_parts[1] year = int(rest_parts[2]) genres = rest_parts[3].split(',') library.add_book(id, title, author, year, genres) elif action == \\"REMOVE\\": _, id = parts library.remove_book(int(id)) elif action == \\"SEARCH\\": type = parts[1] keyword = parts[2] if type == \\"TITLE\\": books = library.search_books_by_title(keyword) if books: output.append(\\"n\\".join(format_book(book) for book in books)) else: output.append(\\"NO MATCHES\\") elif type == \\"GENRE\\": books = library.search_books_by_genre(keyword) if books: output.append(\\"n\\".join(format_book(book) for book in books)) else: output.append(\\"NO MATCHES\\") elif action == \\"LIST\\": author = parts[2] books = library.list_books_by_author(author) if books: output.append(\\"n\\".join(format_book(book) for book in books)) else: output.append(\\"NO MATCHES\\") return \\"nn\\".join(output) def run_command(input_string): Runs the commands from input string and provides the output. >>> input_string = 10 ADD 1 The_Great_Gatsby F._Scott_Fitzgerald 1925 Fiction,Classic ADD 2 To_Kill_a_Mockingbird Harper_Lee 1960 Fiction,Classic ADD 3 1984 George_Orwell 1949 Fiction,Dystopian REMOVE 2 SEARCH TITLE 198 SEARCH GENRE Fiction LIST AUTHOR F._Scott_Fitzgerald LIST AUTHOR Harper_Lee >>> run_command(input_string) \\"1984, George_Orwell, 1949 (3)nnThe_Great_Gatsby, F._Scott_Fitzgerald, 1925 (1)n1984, George_Orwell, 1949 (3)nnThe_Great_Gatsby, F._Scott_Fitzgerald, 1925 (1)nnNO MATCHES\\" commands = input_string.strip().split('n') m = int(commands[0]) return process_commands(commands[1:])","solution":"class Book: def __init__(self, id, title, author, year, genres): self.id = id self.title = title self.author = author self.year = year self.genres = genres class Library: def __init__(self): self.books = {} def add_book(self, id, title, author, year, genres): if id not in self.books: self.books[id] = Book(id, title, author, year, genres) def remove_book(self, id): if id in self.books: del self.books[id] def search_books_by_title(self, substring): result = [book for book in self.books.values() if substring.lower() in book.title.lower()] return sorted(result, key=lambda x: x.title) def search_books_by_genre(self, genre): result = [book for book in self.books.values() if genre in book.genres] return sorted(result, key=lambda x: x.title) def list_books_by_author(self, author): result = [book for book in self.books.values() if book.author == author] return sorted(result, key=lambda x: x.year) def format_book(book): return f\\"{book.title}, {book.author}, {book.year} ({book.id})\\" def process_commands(commands): library = Library() output = [] for command in commands: parts = command.split(' ', 2) action = parts[0] if action == \\"ADD\\": _, id, rest = parts id = int(id) rest_parts = rest.split(' ', 3) title = rest_parts[0] author = rest_parts[1] year = int(rest_parts[2]) genres = rest_parts[3].split(',') library.add_book(id, title, author, year, genres) elif action == \\"REMOVE\\": _, id = parts library.remove_book(int(id)) elif action == \\"SEARCH\\": type = parts[1] keyword = parts[2] if type == \\"TITLE\\": books = library.search_books_by_title(keyword) if books: output.append(\\"n\\".join(format_book(book) for book in books)) else: output.append(\\"NO MATCHES\\") elif type == \\"GENRE\\": books = library.search_books_by_genre(keyword) if books: output.append(\\"n\\".join(format_book(book) for book in books)) else: output.append(\\"NO MATCHES\\") elif action == \\"LIST\\": author = parts[2] books = library.list_books_by_author(author) if books: output.append(\\"n\\".join(format_book(book) for book in books)) else: output.append(\\"NO MATCHES\\") return \\"nn\\".join(output) def run_command(input_string): commands = input_string.strip().split('n') m = int(commands[0]) process_commands(commands[1:])"},{"question":"def apply_instructions(n: int, m: int, instructions: List[Tuple[int, int, int, int]]) -> List[List[int]]: You are given a 2D grid of size n x m and a list of instructions. The grid is initially filled with zeros, and you need to process the instructions to update the values in the grid. An instruction is represented as a tuple (x1, y1, x2, y2), which implies adding 1 to each element of the subgrid that starts from (x1, y1) to (x2, y2) (both inclusive). Args: n : int : number of rows m : int : number of columns instructions : List[Tuple[int, int, int, int]] : list of instructions to update the grid Returns: List[List[int]] : the final grid after applying all the instructions Examples: >>> apply_instructions(3, 3, [(1, 1, 2, 2), (2, 2, 3, 3)]) [[1, 1, 0], [1, 2, 1], [0, 1, 1]] >>> apply_instructions(4, 4, [(1, 1, 4, 4), (2, 2, 3, 3), (1, 1, 2, 2)]) [[2, 2, 1, 1], [2, 3, 2, 1], [1, 2, 2, 1], [1, 1, 1, 1]]","solution":"def apply_instructions(n, m, instructions): # Initialize the grid with zeros. grid = [[0] * m for _ in range(n)] # Apply each instruction. for x1, y1, x2, y2 in instructions: for i in range(x1-1, x2): for j in range(y1-1, y2): grid[i][j] += 1 return grid"},{"question":"def find_peak_element(arr): Find the index of any peak element in the array. A peak is an element that is strictly greater than its neighbors. Parameters: arr (list): List of integers representing the array. Returns: int: Index of any peak element. If no peak exists, returns -1. pass # Test cases def test_peak_at_beginning(): assert find_peak_element([5, 3, 2, 1]) == 0 def test_peak_at_end(): assert find_peak_element([1, 2, 3, 4]) == 3 def test_peak_in_middle(): assert find_peak_element([1, 3, 2, 4]) in [1, 3] def test_multiple_peaks(): result = find_peak_element([1, 2, 3, 1, 2, 1, 3]) assert result in [2, 6] def test_single_element(): assert find_peak_element([1]) == 0 def test_two_elements(): assert find_peak_element([2, 1]) == 0 assert find_peak_element([1, 2]) == 1 def test_no_peak(): assert find_peak_element([1, 2, 3, 3, 2, 1]) == -1 def test_large_input(): large_array = [i for i in range(1000000)] assert find_peak_element(large_array) == 999999","solution":"def find_peak_element(arr): Find the index of any peak element in the array. A peak is an element that is strictly greater than its neighbors. Parameters: arr (list): List of integers representing the array. Returns: int: Index of any peak element. If no peak exists, returns -1. n = len(arr) if n == 0: return -1 if n == 1: return 0 # Checking the first element if arr[0] > arr[1]: return 0 # Checking the last element if arr[n - 1] > arr[n - 2]: return n - 1 # Checking other elements for i in range(1, n - 1): if arr[i] > arr[i - 1] and arr[i] > arr[i + 1]: return i return -1"},{"question":"def count_students_with_min_score(scores, T): Returns the number of students who have scored at least T percentage. Parameters: scores (list of int): List of scores of students. T (int): The threshold percentage. Returns: int: Number of students with scores >= T >>> count_students_with_min_score([70, 45, 50, 90, 66, 30], 50) 4 >>> count_students_with_min_score([70, 45, 50, 90, 66, 30], 70) 2 >>> count_students_with_min_score([70, 45, 50, 90, 66, 30], 90) 1 >>> count_students_with_min_score([70, 45, 50, 90, 66, 30], 20) 6 >>> count_students_with_min_score([70, 45, 50, 90, 66, 30], 100) 0 pass def process_input(input_str): Processes the input string and computes the result. Parameters: input_str (str): Input string in the specified format. Returns: int: Number of students with scores >= threshold. >>> process_input(\\"6 50n70 45 50 90 66 30n\\") 4 >>> process_input(\\"6 70n70 45 50 90 66 30n\\") 2 >>> process_input(\\"6 90n70 45 50 90 66 30n\\") 1 >>> process_input(\\"6 20n70 45 50 90 66 30n\\") 6 >>> process_input(\\"6 100n70 45 50 90 66 30n\\") 0 pass","solution":"def count_students_with_min_score(scores, T): Returns the number of students who have scored at least T percentage. Parameters: scores (list of int): List of scores of students. T (int): The threshold percentage. Returns: int: Number of students with scores >= T return sum(1 for score in scores if score >= T) def process_input(input_str): Processes the input string and computes the result. Parameters: input_str (str): Input string in the specified format. Returns: int: Number of students with scores >= threshold. lines = input_str.strip().split() N = int(lines[0]) T = int(lines[1]) scores = list(map(int, lines[2:2+N])) return count_students_with_min_score(scores, T)"},{"question":"def collatz_sequence_info(N: int) -> (int, int): Generates the Collatz sequence starting from N and returns the maximum number in the sequence and the length of the sequence. Example: >>> collatz_sequence_info(7) (52, 17) >>> collatz_sequence_info(1) (1, 1) >>> collatz_sequence_info(6) (16, 9) >>> collatz_sequence_info(27) (9232, 112) >>> collatz_sequence_info(3) (16, 8) # Write your code here pass","solution":"def collatz_sequence_info(N): Generates the Collatz sequence starting from N and returns the maximum number in the sequence and the length of the sequence. max_number = N length_of_sequence = 1 current_number = N while current_number != 1: if current_number % 2 == 0: current_number //= 2 else: current_number = 3 * current_number + 1 length_of_sequence += 1 max_number = max(max_number, current_number) return (max_number, length_of_sequence)"},{"question":"import math from typing import List, Tuple def point_in_circle(px: int, py: int, cx: int, cy: int, r: int) -> bool: Determines if the point (px, py) is inside the circle centered at (cx, cy) with radius r. Args: px (int): x-coordinate of the point. py (int): y-coordinate of the point. cx (int): x-coordinate of the circle center. cy (int): y-coordinate of the circle center. r (int): radius of the circle. Returns: bool: True if the point is inside the circle, False otherwise. >>> point_in_circle(5, 5, 1, 1, 3) False >>> point_in_circle(5, 5, 4, 4, 2) True pass def circles_containing_point(datasets: List[Tuple[int, int, List[Tuple[int, int, int]]]]) -> List[int]: Given a list of datasets where each dataset consists of: - a point (px, py) - a number of circles n - a list of circles defined by their center (cx, cy) and radius r This function returns a list of integers where each integer represents the count of circles that contain the given point for each dataset. Args: datasets (List[Tuple[int, int, List[Tuple[int, int, int]]]]): List of datasets. Returns: List[int]: List of counts of circles containing the point for each dataset. >>> datasets = [ ...(5, 5, [(1, 1, 3), (4, 4, 2), (6, 6, 1)]), ...(7, 9, [(8, 10, 5), (7, 7, 2)]) ...] >>> circles_containing_point(datasets) [1, 2] pass","solution":"import math def point_in_circle(px, py, cx, cy, r): Determines if the point (px, py) is inside the circle centered at (cx, cy) with radius r. distance = math.sqrt((px - cx) ** 2 + (py - cy) ** 2) return distance <= r def circles_containing_point(datasets): Given a list of datasets where each dataset consists of: - a point (px, py) - a number of circles n - a list of circles defined by their center (cx, cy) and radius r This function returns a list of integers where each integer represents the count of circles that contain the given point for each dataset. results = [] i = 0 while i < len(datasets): px, py = datasets[i] n = datasets[i + 1] count = 0 for j in range(n): cx, cy, r = datasets[i + 2 + j] if point_in_circle(px, py, cx, cy, r): count += 1 results.append(count) i += 2 + n return results"},{"question":"def minMeetingRooms(times): Determine the minimum number of meeting rooms required to host all the meetings without any overlap. Args: times (List[List[int]]): A list of lists where each inner list contains two integers representing the start and end time of a meeting. Returns: int: The minimum number of meeting rooms required. Example: >>> minMeetingRooms([[1, 4], [2, 5], [7, 9]]) 2 >>> minMeetingRooms([[6, 7], [2, 4], [8, 12]]) 1","solution":"def minMeetingRooms(times): if not times: return 0 # Extract start and end times into separate lists start_times = sorted([time[0] for time in times]) end_times = sorted([time[1] for time in times]) start_pointer = 0 end_pointer = 0 used_rooms = 0 # Iterate over meetings while start_pointer < len(times): # If there is a meeting that has ended by the time the current one starts if start_times[start_pointer] >= end_times[end_pointer]: used_rooms -= 1 end_pointer += 1 # We need a new room for the current meeting used_rooms += 1 start_pointer += 1 return used_rooms"},{"question":"from typing import List def min_moves_to_reach_end(n: int, m: int, grid: List[List[str]]) -> int: Determine the minimum number of moves required for the robot to reach the destination on the factory floor represented as a grid. If there is no path from the start to the destination, return -1. Args: n : int : the number of rows in the grid m : int : the number of columns in the grid grid : List[List[str]] : the factory floor grid Returns: int : the minimum number of moves required to reach the destination, or -1 if no path exists Examples: >>> min_moves_to_reach_end(4, 5, [ ... ['.', '.', '.', '#', '.'], ... ['.', '#', '.', '#', '.'], ... ['.', '#', '#', '.', '.'], ... ['.', '.', '.', '.', '.'] ... ]) 7 >>> min_moves_to_reach_end(4, 5, [ ... ['.', '#', '.', '#', '.'], ... ['#', '#', '.', '#', '.'], ... ['.', '#', '#', '.', '.'], ... ['.', '#', '#', '#', '.'] ... ]) -1 pass # Unit tests def test_min_moves_to_reach_end_path_exists(): grid = [ ['.', '.', '.', '#', '.'], ['.', '#', '.', '#', '.'], ['.', '#', '#', '.', '.'], ['.', '.', '.', '.', '.'] ] assert min_moves_to_reach_end(4, 5, grid) == 7 def test_min_moves_to_reach_end_no_path(): grid = [ ['.', '#', '.', '#', '.'], ['#', '#', '.', '#', '.'], ['.', '#', '#', '.', '.'], ['.', '#', '#', '#', '.'] ] assert min_moves_to_reach_end(4, 5, grid) == -1 def test_min_moves_to_reach_end_no_obstacles(): grid = [ ['.', '.', '.'], ['.', '.', '.'], ['.', '.', '.'] ] assert min_moves_to_reach_end(3, 3, grid) == 4 def test_min_moves_to_reach_end_single_cell_path(): grid = [['.']] assert min_moves_to_reach_end(1, 1, grid) == 0 def test_min_moves_to_reach_end_obstacles_at_ends(): grid = [ ['.', '#', '.'], ['#', '#', '.'], ['.', '.', '#'] ] # Even though some parts are blocked, there is a valid path assert min_moves_to_reach_end(3, 3, grid) == -1","solution":"from collections import deque def min_moves_to_reach_end(n, m, grid): Function to determine the minimum number of moves required for the robot to reach the destination on the factory floor represented as a grid. If there is no path from the start to the destination, the function returns -1. if grid[0][0] == '#' or grid[n-1][m-1] == '#': return -1 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 0)]) # (x, y, distance) visited = set((0, 0)) while queue: x, y, dist = queue.popleft() if x == n-1 and y == m-1: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited and grid[nx][ny] == '.': visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1"},{"question":"def max_subarray_sum(t: int, test_cases: List[Tuple[Tuple[int, int], List[int]]]) -> List[int]: Given t test cases, each consisting of n and k, and a list of n integers, find the maximum possible sum of any sub-array of length k. Parameters: t (int): number of test cases test_cases (List[Tuple[Tuple[int, int], List[int]]]): list of test cases, where each test case is a tuple containing a tuple of (n, k) and a list of n integers Returns: List[int]: a list of the maximum possible sums for each test case >>> max_subarray_sum(1, [[(5, 2), [1, 2, 3, 4, 5]]]) [9] >>> max_subarray_sum(1, [[(8, 3), [-1, 3, -2, 5, 3, -5, 2, 2]]]) [6]","solution":"def max_subarray_sum(t, test_cases): results = [] for i in range(t): n, k = test_cases[i][0] arr = test_cases[i][1] max_sum = curr_sum = sum(arr[:k]) for j in range(k, n): curr_sum += arr[j] - arr[j - k] if curr_sum > max_sum: max_sum = curr_sum results.append(max_sum) return results # Example usage t = 2 test_cases = [ [(5, 2), [1, 2, 3, 4, 5]], [(8, 3), [-1, 3, -2, 5, 3, -5, 2, 2]] ] print(max_subarray_sum(t, test_cases)) # Output: [9, 6]"},{"question":"from typing import List, Tuple def merge_intervals(intervals: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Merges overlapping intervals and returns a list of non-overlapping intervals sorted by their start time. >>> merge_intervals([(1, 3), (2, 4), (5, 7), (6, 8)]) [(1, 4), (5, 8)] >>> merge_intervals([(1, 5), (2, 6), (8, 10), (9, 12)]) [(1, 6), (8, 12)] >>> merge_intervals([(1, 3), (4, 5), (6, 8)]) [(1, 3), (4, 5), (6, 8)]","solution":"from typing import List, Tuple def merge_intervals(intervals: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Merges overlapping intervals and returns a list of non-overlapping intervals sorted by their start time. # First, sort the intervals by their start times intervals.sort(key=lambda x: x[0]) merged_intervals = [] for interval in intervals: # If merged_intervals is empty or current interval does not overlap with the previous one, add it to the list if not merged_intervals or merged_intervals[-1][1] < interval[0]: merged_intervals.append(interval) else: # There is an overlap, merge the current interval with the previous one merged_intervals[-1] = (merged_intervals[-1][0], max(merged_intervals[-1][1], interval[1])) return merged_intervals"},{"question":"def is_strictly_increasing_after_removal(n: int, lst: List[int]) -> str: Determines if it is possible to form a strictly increasing sequence by removing at most one element from the list. >>> is_strictly_increasing_after_removal(5, [10, 1, 2, 3, 4]) 'YES' >>> is_strictly_increasing_after_removal(4, [5, 1, 2, 1]) 'NO'","solution":"def is_strictly_increasing_after_removal(n, lst): Determines if it is possible to form a strictly increasing sequence by removing at most one element from the list. Parameters: n (int): The number of elements in the list. lst (List[int]): The list of integers. Returns: str: \\"YES\\" if possible, otherwise \\"NO\\". def is_strictly_increasing(nums): for i in range(1, len(nums)): if nums[i] <= nums[i - 1]: return False return True if is_strictly_increasing(lst): return \\"YES\\" for i in range(n): if is_strictly_increasing(lst[:i] + lst[i+1:]): return \\"YES\\" return \\"NO\\""},{"question":"from typing import List, Tuple def find_longest_chain(N: int, L: int, edges: List[Tuple[int, int]]) -> int: Find the length of the longest chain of employees where each employee follows the next directly. Parameters: N (int): The number of employees. L (int): The minimum length of the longest chain. edges (List[Tuple[int, int]]): List of pairs representing directed edges where employee a follows employee b. Returns: int: The length of the longest chain. >>> find_longest_chain(6, 2, [(0, 1), (1, 2), (2, 3), (3, 4), (4, 5), (1, 3)]) 6 >>> find_longest_chain(4, 1, []) 1 >>> find_longest_chain(5, 2, [(0, 1), (0, 2), (0, 3), (0, 4)]) 2 >>> find_longest_chain(6, 2, [(0, 1), (1, 2), (3, 4), (4, 5)]) 3 >>> find_longest_chain(5, 1, [(0, 1), (1, 2), (2, 3), (3, 4)]) 5 pass","solution":"def find_longest_chain(N, L, edges): from collections import defaultdict, deque # Create adjacency list graph = defaultdict(list) for a, b in edges: graph[a].append(b) # Function to perform DFS and find the longest chain starting from a given node def dfs(node, visited, max_length): if node in visited: return visited[node] max_chain = 1 for neighbor in graph[node]: max_chain = max(max_chain, 1 + dfs(neighbor, visited, max_length)) visited[node] = max_chain return max_chain max_chain_length = L visited = {} for i in range(N): max_chain_length = max(max_chain_length, dfs(i, visited, L)) return max_chain_length"},{"question":"from typing import List, Tuple def sum_unique_integers_in_rows(grid: List[List[int]]) -> List[int]: Given a grid (list of lists of integers), returns a list of sums of unique integers for each row. >>> sum_unique_integers_in_rows([[1, 2, 3], [4, 4, 4], [1, 2, 2]]) [6, 4, 3] >>> sum_unique_integers_in_rows([[2, 3], [3, 3], [1, 2]]) [5, 3, 3] >>> sum_unique_integers_in_rows([[5], [5, 5, 5], [1, 1, 1, 1]]) [5, 5, 1] >>> sum_unique_integers_in_rows([[1, 2], [3, 4], [5, 6]]) [3, 7, 11] >>> sum_unique_integers_in_rows([[10, 20, 20], [30, 30, 30], [40, 50, 60]]) [30, 30, 150] def process_grids(n: int, grid_data: List[Tuple[int, int, List[List[int]]]]) -> List[List[int]]: Processes multiple grids based on the given data. :param n: Number of grids :param grid_data: List of tuples, where each tuple contains the grid details (r, c, grid) :return: A list of results for each grid, where each result is a list of sums of unique integers for each row. >>> input_data = [(3, 3, [[1, 2, 3], [4, 4, 4], [1, 2, 2]]), (2, 2, [[2, 3], [3, 3], [1, 2]])] >>> process_grids(2, input_data) [[6, 4, 3], [5, 3, 3]] >>> input_data = [(1, 1, [[1]]), (2, 2, [[1, 2], [2, 1]])] >>> process_grids(2, input_data) [[1], [3, 3]] >>> input_data = [(3, 3, [[10, 20, 20], [30, 30, 30], [40, 50, 60]]), (2, 2, [[20, 20], [10, 10]])] >>> process_grids(2, input_data) [[30, 30, 150], [20, 10]]","solution":"def sum_unique_integers_in_rows(grid): Given a grid (list of lists of integers), returns a list of sums of unique integers for each row. result = [] for row in grid: unique_integers = set(row) row_sum = sum(unique_integers) result.append(row_sum) return result def process_grids(n, grid_data): Processes multiple grids based on the given data. :param n: Number of grids :param grid_data: List of tuples, where each tuple contains the grid details (r, c, grid) :return: A list of results for each grid, where each result is a list of sums of unique integers for each row. results = [] for grid in grid_data: r, c, rows = grid result = sum_unique_integers_in_rows(rows) results.append(result) return results"},{"question":"def simulate_robot_commands(commands: List[Tuple[int, int, int]]) -> List[str]: Simulate a robotic arm picking up boxes and stacking them based on a list of commands, and determine whether the stack is valid after each command of type \`2\`. The command \`c\` can have three possible values: - \`1\`: Pick up a box of weight \`x\` from position \`y\` and add it to the stack. - \`2\`: Check whether the current stack is valid for lifting. A stack is valid if for every box placed below another box in the stack, the box below is at least as heavy as the box above. - \`3\`: Remove the box from the top of the stack (if the stack is non-empty). Args: commands: List[Tuple[int, int, int]] - List of commands Returns: List[str] - List containing \\"Valid\\" or \\"Invalid\\" for each \`2\` command. >>> simulate_robot_commands([(1, 10, 5), (1, 20, 3), (2, 0, 0), (3, 0, 0), (2, 0, 0), (1, 15, 2), (2, 0, 0)]) ['Invalid', 'Valid', 'Invalid'] pass from typing import List, Tuple def test_sample_input(): commands = [ (1, 10, 5), (1, 20, 3), (2, 0, 0), (3, 0, 0), (2, 0, 0), (1, 15, 2), (2, 0, 0), ] assert simulate_robot_commands(commands) == [\\"Invalid\\", \\"Valid\\", \\"Invalid\\"] def test_all_valid(): commands = [ (1, 20, 5), (1, 15, 3), (1, 10, 2), (2, 0, 0), (3, 0, 0), (2, 0, 0), ] assert simulate_robot_commands(commands) == [\\"Valid\\", \\"Valid\\"] def test_all_invalid(): commands = [ (1, 10, 5), (1, 15, 3), (2, 0, 0), (1, 20, 2), (2, 0, 0), ] assert simulate_robot_commands(commands) == [\\"Invalid\\", \\"Invalid\\"] def test_empty_stack(): commands = [ (2, 0, 0), ] assert simulate_robot_commands(commands) == [\\"Valid\\"] def test_mixed_operations(): commands = [ (1, 10, 5), (2, 0, 0), (3, 0, 0), (2, 0, 0), (1, 5, 2), (2, 0, 0), (3, 0, 0), (2, 0, 0), ] assert simulate_robot_commands(commands) == [\\"Valid\\", \\"Valid\\", \\"Valid\\", \\"Valid\\"] def test_single_box(): commands = [ (1, 10, 5), (2, 0, 0), ] assert simulate_robot_commands(commands) == [\\"Valid\\"]","solution":"def simulate_robot_commands(commands): stack = [] results = [] for command in commands: c, x, y = command if c == 1: # Pick up a box of weight \`x\` from position \`y\` and add it to the stack. stack.append(x) elif c == 2: # Check whether the current stack is valid for lifting. # A stack is valid if for every box placed below another box in the stack, # the box below is at least as heavy as the box above. is_valid = all(stack[i] >= stack[i + 1] for i in range(len(stack) - 1)) results.append(\\"Valid\\" if is_valid else \\"Invalid\\") elif c == 3: # Remove the box from the top of the stack (if the stack is non-empty). if stack: stack.pop() return results"},{"question":"def is_valid_event_sequence(events): Determines if the sequence of events is valid. A sequence of events is valid if every \\"start\\" has a corresponding \\"end\\" in the correct order and there are no unmatched \\"end\\" events. :param events: List of event strings (\\"start\\" or \\"end\\") :return: True if the event sequence is valid, False otherwise from solution import is_valid_event_sequence def test_valid_event_sequence(): assert is_valid_event_sequence([\\"start\\", \\"start\\", \\"end\\", \\"end\\"]) assert is_valid_event_sequence([\\"start\\", \\"end\\", \\"start\\", \\"end\\"]) def test_invalid_event_sequence_more_starts(): assert not is_valid_event_sequence([\\"start\\", \\"start\\", \\"end\\"]) def test_invalid_event_sequence_unmatched_end(): assert not is_valid_event_sequence([\\"end\\", \\"start\\", \\"end\\"]) def test_empty_event_sequence(): assert is_valid_event_sequence([]) def test_single_start(): assert not is_valid_event_sequence([\\"start\\"]) def test_single_end(): assert not is_valid_event_sequence([\\"end\\"]) def test_interleaved_events_valid(): assert is_valid_event_sequence([\\"start\\", \\"end\\", \\"start\\", \\"end\\", \\"start\\", \\"end\\"]) def test_interleaved_events_invalid(): assert not is_valid_event_sequence([\\"start\\", \\"end\\", \\"end\\", \\"start\\"])","solution":"def is_valid_event_sequence(events): Determines if the sequence of events is valid. A sequence of events is valid if every \\"start\\" has a corresponding \\"end\\" in the correct order and there are no unmatched \\"end\\" events. :param events: List of event strings (\\"start\\" or \\"end\\") :return: True if the event sequence is valid, False otherwise count = 0 for event in events: if event == \\"start\\": count += 1 elif event == \\"end\\": count -= 1 if count < 0: return False # More \\"end\\" events than \\"start\\" events at any point return count == 0"},{"question":"def min_path_cost(grid) -> int: Calculate the minimum path cost to reach the bottom-right corner of the grid from the top-left corner. Movement is allowed only to the right or down. Parameters: grid (List[List[int]]): A 2D list of integers representing the grid weights Returns: int: The minimum cost to reach the bottom-right corner >>> min_path_cost([ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ]) 7 >>> min_path_cost([ ... [1, 2], ... [1, 1] ... ]) 3 pass def solve_shortest_path_puzzle(T, test_cases): Solve the shortest path puzzle for multiple test cases. Parameters: T (int): The number of test cases test_cases (List[Tuple[int, List[List[int]]]]): A list of tuples where the first element is the size of the grid and the second element is the grid itself Returns: List[int]: A list of results for each test case, representing the minimum cost to reach the bottom-right corner from the top-left corner pass","solution":"def min_path_cost(grid): Calculate the minimum path cost to reach the bottom-right corner of the grid from the top-left corner. Movement is allowed only to the right or down. N = len(grid) dp = [[0] * N for _ in range(N)] dp[0][0] = grid[0][0] # Fill the first row for j in range(1, N): dp[0][j] = dp[0][j - 1] + grid[0][j] # Fill the first column for i in range(1, N): dp[i][0] = dp[i - 1][0] + grid[i][0] # Fill the rest of the dp table for i in range(1, N): for j in range(1, N): dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] # The answer is in the bottom-right corner of the dp table return dp[N - 1][N - 1] def solve_shortest_path_puzzle(T, test_cases): results = [] for case in test_cases: N, grid = case result = min_path_cost(grid) results.append(result) return results"},{"question":"from typing import List def count_pairs(heights: List[int]) -> int: Returns the number of pairs (i, j) with i < j such that the student at index i is taller than the student at index j. Example: >>> count_pairs([5, 3, 4, 6, 2]) 6 >>> count_pairs([1, 2, 3, 4]) 0 >>> count_pairs([10, 5, 2]) 3","solution":"def count_pairs(heights): Returns the number of pairs (i, j) with i < j such that the student at index i is taller than the student at index j. n = len(heights) count = 0 for i in range(n): for j in range(i + 1, n): if heights[i] > heights[j]: count += 1 return count"},{"question":"def get_most_frequent_flower(flower_string): Returns the most frequent flower type in the string. In case of a tie, returns the alphabetically first type. # Your code here def find_flowers_to_send(test_cases): For each test case, determine the type of flower to send from each shop. # Example usage and test cases import pytest def test_get_most_frequent_flower(): assert get_most_frequent_flower('abacc') == 'a' assert get_most_frequent_flower('ccbbdd') == 'b' assert get_most_frequent_flower('eeffee') == 'e' assert get_most_frequent_flower('aaa') == 'a' assert get_most_frequent_flower('bbb') == 'b' assert get_most_frequent_flower('aabbcc') == 'a' # tie case, 'a' is first alphabetically assert get_most_frequent_flower('bccbab') == 'b' # 'b' and 'c' are ties, 'b' is first alphabetically def test_find_flowers_to_send(): test_cases = [ { 'N': 3, 'shops': [ 'abacc', 'ccbbdd', 'eeffee' ] }, { 'N': 2, 'shops': [ 'aaa', 'bbb' ] } ] expected_outputs = [ \\"a b e\\", \\"a b\\" ] assert find_flowers_to_send(test_cases) == expected_outputs def test_large_case(): test_case = { 'N': 1, 'shops': [ 'a' * 999 + 'b' * 1000 # very large input, 'b' should be the most frequent ] } expected_output = \\"b\\" assert find_flowers_to_send([test_case]) == [expected_output]","solution":"def get_most_frequent_flower(flower_string): Returns the most frequent flower type in the string. In case of a tie, returns the alphabetically first type. from collections import Counter counter = Counter(flower_string) most_frequent = sorted(counter.items(), key=lambda x: (-x[1], x[0])) return most_frequent[0][0] def find_flowers_to_send(test_cases): For each test case, determine the type of flower to send from each shop. results = [] for case in test_cases: N, shops = case['N'], case['shops'] result = [] for shop in shops: result.append(get_most_frequent_flower(shop)) results.append(\\" \\".join(result)) return results"},{"question":"def sieve_of_eratosthenes(max_num): Generates a list to determine if numbers up to max_num are prime. pass def count_twin_primes(L, R): Counts the twin prime pairs in the range [L, R] pass # Unit tests def test_sieve_of_eratosthenes(): assert sieve_of_eratosthenes(10) == [False, False, True, True, False, True, False, True, False, False, False] def test_count_twin_primes_example1(): assert count_twin_primes(3, 13) == 3 def test_count_twin_primes_example2(): assert count_twin_primes(10, 19) == 2 def test_count_twin_primes_lower_edge(): assert count_twin_primes(1, 2) == 0 def test_count_twin_primes_upper_edge(): assert count_twin_primes(1000000, 1000000) == 0 def test_count_twin_primes_large_range(): assert count_twin_primes(1, 100) == 8 def test_count_twin_primes_no_twin_primes(): assert count_twin_primes(14, 16) == 0","solution":"def sieve_of_eratosthenes(max_num): Generates a list to determine if numbers up to max_num are prime. is_prime = [True] * (max_num + 1) is_prime[0] = is_prime[1] = False p = 2 while (p * p <= max_num): if (is_prime[p] == True): for i in range(p * p, max_num + 1, p): is_prime[i] = False p += 1 return is_prime def count_twin_primes(L, R): Counts the twin prime pairs in the range [L, R] if L < 2: L = 2 is_prime = sieve_of_eratosthenes(R) twin_prime_count = 0 for i in range(L, R - 1): if is_prime[i] and is_prime[i + 2]: twin_prime_count += 1 return twin_prime_count"},{"question":"def max_non_adjacent_evens(arr): Given an array of integers, return the maximum number of even numbers that can be selected from the array such that no two selected numbers are adjacent in the original array. >>> max_non_adjacent_evens([1, 2, 2, 3, 4]) 2 >>> max_non_adjacent_evens([4, 2, 6, 8]) 2 def solve(input_data): ''' Reads input data and returns the results for each test case as a list. Input: - First line contains an integer T denoting the number of test cases. - Each test case consists of two lines. First line of each test case contains an integer N denoting the size of the array. - Second line contains N space-separated integers representing the elements of the array. Output: For each test case, output in a new line the maximum number of even numbers that can be selected. Constraints: 1 ≤ T ≤ 10 1 ≤ N ≤ 10^5 0 ≤ A[i] ≤ 10^9 ''' pass # Implementation goes here import pytest def test_max_non_adjacent_evens(): input_data = \\"2n5n1 2 2 3 4n4n4 2 6 8\\" assert solve(input_data) == [2, 2] def test_all_odds(): input_data = \\"1n5n1 3 5 7 9\\" assert solve(input_data) == [0] def test_all_evens(): input_data = \\"1n4n2 4 6 8\\" assert solve(input_data) == [2] def test_single_element_even(): input_data = \\"1n1n2\\" assert solve(input_data) == [1] def test_single_element_odd(): input_data = \\"1n1n1\\" assert solve(input_data) == [0] def test_large_input(): arr = [0, 1] * 50000 input_data = f\\"1n{len(arr)}n\\" + \\" \\".join(map(str, arr)) assert solve(input_data) == [50000]","solution":"def max_non_adjacent_evens(arr): Returns the maximum number of non-adjacent even numbers that can be selected from the list. n = len(arr) if n == 0: return 0 if n == 1: return 1 if arr[0] % 2 == 0 else 0 even_count = [0] * n even_count[0] = 1 if arr[0] % 2 == 0 else 0 if arr[1] % 2 == 0: even_count[1] = 1 even_count[1] = max(even_count[1], even_count[0]) for i in range(2, n): if arr[i] % 2 == 0: even_count[i] = max(even_count[i-1], even_count[i-2] + 1) else: even_count[i] = even_count[i-1] return even_count[-1] def solve(input_data): lines = input_data.strip().split('n') T = int(lines[0]) result = [] index = 1 for _ in range(T): N = int(lines[index]) arr = list(map(int, lines[index + 1].split())) result.append(max_non_adjacent_evens(arr)) index += 2 return result"},{"question":"from typing import List, Tuple def tournament_winner(n: int, participants: List[str]) -> Tuple[int, str]: Determines the number of rounds needed to determine the ultimate tournament winner and the winner's name. >>> tournament_winner(4, [\\"alice\\", \\"bob\\", \\"charlie\\", \\"david\\"]) (2, \\"alice\\") >>> tournament_winner(8, [\\"hermione\\", \\"ron\\", \\"harry\\", \\"draco\\", \\"luna\\", \\"neville\\", \\"severus\\", \\"ginny\\"]) (3, \\"draco\\")","solution":"def tournament_winner(n, participants): Determines the number of rounds needed to determine the ultimate tournament winner and the winner's name. rounds = 0 while n > 1: n = (n + 1) // 2 # Progressively halving the number of participants each round rounds += 1 winner = min(participants) # Lexicographically smallest name wins return rounds, winner"},{"question":"def max_features_approved(n: int, C: int, complexities: List[int]) -> int: Determine the maximum number of features that can be approved without exceeding the complexity limit C. Arguments: n -- integer, the number of feature requests C -- integer, the complexity limit complexities -- list of integers, the complexity ratings of features Returns: integer, the maximum number of features that can be approved >>> max_features_approved(5, 10, [1, 2, 3, 4, 5]) 4 >>> max_features_approved(4, 15, [5, 6, 7, 4]) 3 >>> max_features_approved(3, 5, [6, 7, 8]) 0 # Your code here from typing import List def test_example_1(): n = 5 C = 10 complexities = [1, 2, 3, 4, 5] assert max_features_approved(n, C, complexities) == 4 def test_example_2(): n = 4 C = 15 complexities = [5, 6, 7, 4] assert max_features_approved(n, C, complexities) == 3 def test_example_3(): n = 3 C = 5 complexities = [6, 7, 8] assert max_features_approved(n, C, complexities) == 0 def test_no_features(): n = 0 C = 10 complexities = [] assert max_features_approved(n, C, complexities) == 0 def test_large_complexity_limit(): n = 5 C = 50 complexities = [1, 2, 3, 4, 5] assert max_features_approved(n, C, complexities) == 5 def test_exact_limit(): n = 4 C = 10 complexities = [2, 3, 2, 3] assert max_features_approved(n, C, complexities) == 4 def test_single_feature_within_limit(): n = 1 C = 10 complexities = [5] assert max_features_approved(n, C, complexities) == 1 def test_single_feature_exceed_limit(): n = 1 C = 1 complexities = [2] assert max_features_approved(n, C, complexities) == 0","solution":"def max_features_approved(n, C, complexities): Returns the maximum number of features that can be approved without exceeding the complexity limit C. Arguments: n -- integer, the number of feature requests C -- integer, the complexity limit complexities -- list of integers, the complexity ratings of features Returns: integer, the maximum number of features that can be approved complexities.sort() total_complexity = 0 count = 0 for complexity in complexities: if total_complexity + complexity <= C: total_complexity += complexity count += 1 else: break return count"},{"question":"def largest_possible_value_after_operations(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: You are given an array of n integers. An operation consists of picking any two elements from the array, removing them, and inserting their sum back into the array. You need to perform exactly n-1 operations to reduce the array to a single element. Your task is to find the largest possible value of the element remaining in the array after performing these operations. >>> largest_possible_value_after_operations(2, [(3, [1, 2, 3]), (4, [5, 1, 3, 4])]) [6, 13] >>> largest_possible_value_after_operations(1, [(2, [1, 1])]) [2] def test_largest_possible_value_after_operations(): T = 2 test_cases = [ (3, [1, 2, 3]), (4, [5, 1, 3, 4]) ] expected_results = [6, 13] assert largest_possible_value_after_operations(T, test_cases) == expected_results def test_single_case(): T = 1 test_cases = [ (2, [1, 1]) ] expected_results = [2] assert largest_possible_value_after_operations(T, test_cases) == expected_results def test_large_numbers(): T = 1 test_cases = [ (3, [1000000000, 1000000000, 1000000000]) ] expected_results = [3000000000] assert largest_possible_value_after_operations(T, test_cases) == expected_results def test_mixed_values(): T = 1 test_cases = [ (4, [5, 10, 3, 2]) ] expected_results = [20] assert largest_possible_value_after_operations(T, test_cases) == expected_results def test_large_array(): T = 1 test_cases = [ (5, [1, 2, 3, 4, 5]) ] expected_results = [15] assert largest_possible_value_after_operations(T, test_cases) == expected_results","solution":"def largest_possible_value_after_operations(T, test_cases): results = [] for i in range(T): n = test_cases[i][0] array = test_cases[i][1] # For the maximum final value, we need to sum all elements of the array max_value = sum(array) results.append(max_value) return results"},{"question":"def lexicographically_smallest_string(S: str, K: int) -> str: Find the lexicographically smallest string you can obtain by performing any number of operations, in which you can choose any substring of length K and rearrange its characters in any order. >>> lexicographically_smallest_string(\\"dcba\\", 2) 'abcd' >>> lexicographically_smallest_string(\\"a\\", 1) 'a' >>> lexicographically_smallest_string(\\"bca\\", 3) 'abc' >>> lexicographically_smallest_string(\\"aaaa\\", 2) 'aaaa' >>> lexicographically_smallest_string(\\"dcb\\", 5) 'bcd' >>> lexicographically_smallest_string(\\"bdca\\", 1) 'abcd' >>> lexicographically_smallest_string(\\"zxy\\", 3) 'xyz' >>> lexicographically_smallest_string(\\"zyxwvutsrqponmlkjihgfedcba\\", 2) 'abcdefghijklmnopqrstuvwxyz'","solution":"def lexicographically_smallest_string(S, K): Returns the lexicographically smallest string possible after rearranging substrings of length K. if K >= len(S): # Entire string can be sorted as a whole return \\"\\".join(sorted(S)) else: # Sort the whole string since K < len(S) allows full permutations of entire string return \\"\\".join(sorted(S))"},{"question":"def restore_binary_tree(N: int, inorder: List[int], preorder: List[int]) -> List[int]: Restore the binary tree from in-order and pre-order traversals and return the post-order traversal. Args: N (int): Number of nodes in the binary tree. inorder (List[int]): In-order traversal of the binary tree. preorder (List[int]): Pre-order traversal of the binary tree. Returns: List[int]: Post-order traversal of the binary tree. >>> restore_binary_tree(5, [4, 2, 5, 1, 3], [1, 2, 4, 5, 3]) [4, 5, 2, 3, 1] >>> restore_binary_tree(1, [1], [1]) [1]","solution":"def build_tree(inorder, preorder): if not inorder or not preorder: return None root_val = preorder.pop(0) root_index = inorder.index(root_val) root = TreeNode(root_val) root.left = build_tree(inorder[:root_index], preorder) root.right = build_tree(inorder[root_index + 1:], preorder) return root def postorder_traversal(root, result): if root is None: return postorder_traversal(root.left, result) postorder_traversal(root.right, result) result.append(root.val) def restore_binary_tree(N, inorder, preorder): result = [] root = build_tree(inorder, preorder) postorder_traversal(root, result) return result class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None"},{"question":"from typing import List def longest_even_subarray(arr: List[int]) -> int: Find the length of the longest contiguous subarray that consists of only even numbers. >>> longest_even_subarray([1, 2, 4, 6, 3, 8, 10, 7]) 3 >>> longest_even_subarray([2, 4, 6, 8, 10]) 5 >>> longest_even_subarray([1, 3, 5, 7, 9]) 0 >>> longest_even_subarray([2]) 1 >>> longest_even_subarray([1]) 0 >>> longest_even_subarray([]) 0 >>> longest_even_subarray([1, 3, 5, 7, 2, 1, 9, 11, 1]) 1 >>> longest_even_subarray([1, 2, 4, 1, 6, 8, 1, 10, 12]) 2","solution":"from typing import List def longest_even_subarray(arr: List[int]) -> int: max_length = 0 current_length = 0 for num in arr: if num % 2 == 0: current_length += 1 max_length = max(max_length, current_length) else: current_length = 0 return max_length"},{"question":"def count_rearrangable_words(dictionary, search_list): Returns the number of words in the search list that can be formed by rearranging the letters of any word in the dictionary. Parameters: dictionary: list of words in the dictionary search_list: list of words to search Returns: int: number of rearrangable words pass # Example test cases def test_example_case(): dictionary = [\\"cine\\", \\"race\\", \\"car\\", \\"act\\"] search_list = [\\"nice\\", \\"care\\", \\"bat\\", \\"dog\\", \\"cat\\"] assert count_rearrangable_words(dictionary, search_list) == 3 def test_no_rearrangable_words(): dictionary = [\\"abc\\", \\"def\\", \\"ghi\\"] search_list = [\\"xyz\\", \\"pqr\\", \\"uvw\\"] assert count_rearrangable_words(dictionary, search_list) == 0 def test_all_rearrangable_words(): dictionary = [\\"listen\\", \\"care\\", \\"act\\", \\"god\\"] search_list = [\\"silent\\", \\"race\\", \\"cat\\", \\"dog\\"] assert count_rearrangable_words(dictionary, search_list) == 4 def test_mixed_case(): dictionary = [\\"abc\\", \\"bca\\", \\"cab\\"] search_list = [\\"abc\\", \\"bac\\", \\"xyz\\", \\"acb\\", \\"cba\\"] assert count_rearrangable_words(dictionary, search_list) == 4 def test_single_character_words(): dictionary = [\\"a\\", \\"b\\", \\"c\\"] search_list = [\\"a\\", \\"b\\", \\"c\\", \\"d\\"] assert count_rearrangable_words(dictionary, search_list) == 3 def test_empty_search_list(): dictionary = [\\"abc\\", \\"def\\", \\"ghi\\"] search_list = [] assert count_rearrangable_words(dictionary, search_list) == 0 def test_empty_dictionary(): dictionary = [] search_list = [\\"abc\\", \\"def\\", \\"ghi\\"] assert count_rearrangable_words(dictionary, search_list) == 0","solution":"def count_rearrangable_words(dictionary, search_list): Returns the number of words in the search list that can be formed by rearranging the letters of any word in the dictionary. Parameters: dictionary: list of words in the dictionary search_list: list of words to search Returns: int: number of rearrangable words def sort_word(word): Helper function to sort the letters of a word return ''.join(sorted(word)) # Create a set of sorted dictionary words sorted_dict_words = set(sort_word(word) for word in dictionary) # Count how many words in the search list can be rearranged from dictionary words count = 0 for word in search_list: if sort_word(word) in sorted_dict_words: count += 1 return count"},{"question":"def remove_min_chars(s: str) -> str: Remove the minimum number of characters so that no three consecutive characters in the resulting string are the same. >>> remove_min_chars(\\"aaabaaa\\") \\"aabaa\\" >>> remove_min_chars(\\"bbcccbb\\") \\"bbccbb\\" >>> remove_min_chars(\\"abcdefghijklmnopqrstuvwxyz\\") \\"abcdefghijklmnopqrstuvwxyz\\"","solution":"def remove_min_chars(s): Remove the minimum number of characters so that no three consecutive characters are the same. if len(s) < 3: return s result = [] for char in s: # Check if the last two characters in the result and the current character are the same if len(result) >= 2 and result[-1] == result[-2] == char: continue result.append(char) return ''.join(result)"},{"question":"def are_anagrams(s1: str, s2: str) -> bool: Determine if two strings are anagrams of each other. :param s1: First string :param s2: Second string :return: True if the strings are anagrams, False otherwise >>> are_anagrams(\\"listen\\", \\"silent\\") True >>> are_anagrams(\\"triangle\\", \\"integral\\") True >>> are_anagrams(\\"hello\\", \\"world\\") False def check_anagrams(test_cases: list) -> list: For a list of test cases, determines if the pairs of strings are anagrams. :param test_cases: A list of tuples, each containing two strings. :return: A list containing \\"YES\\" or \\"NO\\" for each pair of strings. >>> check_anagrams([(\\"listen\\", \\"silent\\"), (\\"triangle\\", \\"integral\\"), (\\"hello\\", \\"world\\")]) ['YES', 'YES', 'NO'] >>> check_anagrams([(\\"abc\\", \\"bca\\"), (\\"bat\\", \\"tab\\"), (\\"elbow\\", \\"below\\")]) ['YES', 'YES', 'YES'] >>> check_anagrams([(\\"abc\\", \\"def\\"), (\\"aa\\", \\"bb\\"), (\\"aabb\\", \\"bbaa\\")]) ['NO', 'NO', 'YES']","solution":"def are_anagrams(s1, s2): Determine if two strings are anagrams of each other. return sorted(s1) == sorted(s2) def check_anagrams(test_cases): For a list of test cases, determines if the pairs of strings are anagrams. :param test_cases: A list of tuples, each containing two strings. :return: A list containing \\"YES\\" or \\"NO\\" for each pair of strings. results = [] for s1, s2 in test_cases: if are_anagrams(s1, s2): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def find_winner(N: int, S: List[int]) -> int: Determines the winner of the warrior competition. :param N: int, number of warriors :param S: List[int], strengths of the warriors :return: int, the index of the winning warrior (1-based) >>> find_winner(5, [4, 3, 6, 7, 5]) 4 >>> find_winner(4, [5, 5, 5, 5]) 1 >>> find_winner(4, [1, 2, 3, 100]) 4 >>> find_winner(5, [2, 9, 5, 3, 8]) 2 >>> find_winner(2, [10, 10]) 1 >>> find_winner(2, [5, 10]) 2 # Your code here","solution":"def find_winner(N, S): Determines the winner of the warrior competition. :param N: int, number of warriors :param S: List[int], strengths of the warriors :return: int, the index of the winning warrior (1-based) # Maintain a list of (strength, index) sorted by strength and then index warriors = sorted([(S[i], i + 1) for i in range(N)], key=lambda x: (-x[0], x[1])) while len(warriors) > 1: # Pop the weakest warrior among the top two strongest warriors fighters = warriors[:2] if fighters[0][0] == fighters[1][0]: # If both have the same strength, remove the warrior with higher index warriors.pop(1) else: warriors.pop(1) # The last remaining warrior is the winner return warriors[0][1]"},{"question":"import heapq from typing import List, Tuple def dijkstra(n: int, edges: List[List[Tuple[int, int]]], start: int) -> List[int]: # Implementation of the Dijkstra algorithm to find shortest path from start node pass def minimum_magical_difficulty(n: int, m: int, edges_list: List[Tuple[int, int, int]]) -> int: Determine the minimum magical difficulty to complete the journey from stone 1 to stone n. Args: n: Number of stones (nodes). m: Number of pathways (edges). edges_list: List of tuples representing the edges in the form (u, v, w), where u is the starting stone, v is the ending stone, and w is the magical difficulty. Returns: The minimum magical difficulty required to complete the journey. >>> minimum_magical_difficulty(5, 6, [(1, 2, 2), (1, 3, 2), (2, 4, 2), (3, 4, 2), (4, 5, 2), (2, 3, 1)]) 6 >>> minimum_magical_difficulty(4, 4, [(1, 2, 1), (1, 3, 2), (2, 4, 2), (3, 4, 1)]) 3 # Implementation of the minimum_magical_difficulty function pass","solution":"import heapq def dijkstra(n, edges, start): distances = [float('inf')] * n distances[start] = 0 priority_queue = [(0, start)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_distance > distances[current_node]: continue for neighbor, weight in edges[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances def minimum_magical_difficulty(n, m, edges_list): edges = [[] for _ in range(n)] for u, v, w in edges_list: edges[u - 1].append((v - 1, w)) distances_from_start = dijkstra(n, edges, 0) distances_to_end = dijkstra(n, edges[::-1], n - 1)[::-1] min_magic_difficulty = distances_from_start[n - 1] for u, v, w in edges_list: doubled_path_cost = distances_from_start[u - 1] + 2 * w + distances_to_end[v - 1] min_magic_difficulty = min(min_magic_difficulty, doubled_path_cost) return min_magic_difficulty"},{"question":"def check_divisibility(a: int, b: int) -> str: Determines whether a is divisible by b. >>> check_divisibility(10, 5) 'divisible' >>> check_divisibility(10, 3) 'not divisible' >>> check_divisibility(20, 4) 'divisible' >>> check_divisibility(21, 4) 'not divisible' >>> check_divisibility(-10, 5) 'divisible' >>> check_divisibility(10, -5) 'divisible' >>> check_divisibility(-20, -4) 'divisible' >>> check_divisibility(-10, 3) 'not divisible' >>> check_divisibility(10, -3) 'not divisible' >>> check_divisibility(-21, -4) 'not divisible' >>> check_divisibility(0, 1) 'divisible' >>> check_divisibility(0, -1) 'divisible'","solution":"def check_divisibility(a, b): Determines whether a is divisible by b. if a % b == 0: return \\"divisible\\" else: return \\"not divisible\\""},{"question":"from typing import List def count_elements_greater_or_equal(arr: List[int], queries: List[int]) -> List[int]: Returns a list where each element is the count of numbers in the array that are greater than or equal to the corresponding query. >>> count_elements_greater_or_equal([1, 3, 4, 2, 5], [3, 4, 6]) [3, 2, 0] >>> count_elements_greater_or_equal([1, 2, 3], [4, 5, 6]) [0, 0, 0] >>> count_elements_greater_or_equal([10, 20, 30, 40, 50], [5, 15, 25]) [5, 4, 3]","solution":"def count_elements_greater_or_equal(arr, queries): Returns a list where each element is the count of numbers in the array that are greater than or equal to the corresponding query. # Sort the array beforehand arr.sort() result = [] n = len(arr) for x in queries: # Binary search to find the first position where arr[pos] >= x left, right = 0, n while left < right: mid = (left + right) // 2 if arr[mid] >= x: right = mid else: left = mid + 1 # The count is the difference between the array length and position found result.append(n - left) return result"},{"question":"from typing import List, Tuple def calculate_scores(T: int, test_cases: List[Tuple[int, List[int], int, List[int]]]) -> List[Tuple[int, int]]: Calculate the total scores earned by Alice and Bob for each test case. Args: T : int : The number of test cases. test_cases : List[Tuple[int, List[int], int, List[int]]] : List of test cases where each test case contains: - int : Number of problems solved by Alice - List[int] : Difficulty levels of problems solved by Alice - int : Number of problems solved by Bob - List[int] : Difficulty levels of problems solved by Bob Returns: List[Tuple[int, int]] : List of tuples where each tuple contains the total points earned by Alice and Bob respectively. Examples: >>> T = 2 >>> test_cases = [ ... (3, [1, 2, 3], 2, [2, 3]), ... (4, [1, 1, 1, 1], 3, [2, 2, 2]) ... ] >>> calculate_scores(T, test_cases) [(60, 50), (40, 60)] >>> T = 1 >>> test_cases = [ ... (2, [3, 3], 2, [1, 1]) ... ] >>> calculate_scores(T, test_cases) [(60, 20)] >>> T = 1 >>> test_cases = [ ... (1, [1], 1, [3]) ... ] >>> calculate_scores(T, test_cases) [(10, 30)] >>> T = 1 >>> test_cases = [ ... (3, [1, 2, 3], 3, [3, 2, 1]) ... ] >>> calculate_scores(T, test_cases) [(60, 60)] >>> T = 1 >>> test_cases = [ ... (0, [], 0, []) ... ] >>> calculate_scores(T, test_cases) [(0, 0)]","solution":"def calculate_scores(T, test_cases): def get_score(problems): score = 0 for problem in problems: if problem == 1: score += 10 elif problem == 2: score += 20 elif problem == 3: score += 30 return score results = [] for i in range(T): N = test_cases[i][0] alice_problems = test_cases[i][1] M = test_cases[i][2] bob_problems = test_cases[i][3] alice_score = get_score(alice_problems) bob_score = get_score(bob_problems) results.append((alice_score, bob_score)) return results"},{"question":"def is_subsequence(s: str, t: str) -> str: Determine if string t is a subsequence of string s. :param s: The main string to be checked against (length <= 10^5) :param t: The string to check as a subsequence (length <= 10^5) :return: \\"YES\\" if t is a subsequence of s, otherwise \\"NO\\" >>> is_subsequence(\\"abcde\\", \\"abc\\") \\"YES\\" >>> is_subsequence(\\"abcde\\", \\"ace\\") \\"YES\\" >>> is_subsequence(\\"abcde\\", \\"aec\\") \\"NO\\" def process_queries(s: str, queries: List[str]) -> List[str]: Process multiple queries to check if each string is a subsequence of the given string. :param s: The main string to be checked against :param queries: List of query strings to check as subsequences :return: List of results for each query >>> process_queries(\\"abcde\\", [\\"abc\\", \\"ace\\", \\"aec\\"]) [\\"YES\\", \\"YES\\", \\"NO\\"] >>> process_queries(\\"helloworld\\", [\\"hello\\", \\"worldd\\", \\"\\"]) [\\"YES\\", \\"NO\\", \\"YES\\"]","solution":"def is_subsequence(s, t): Determine if string t is a subsequence of string s. :param s: The main string to be checked against (length <= 10^5) :param t: The string to check as a subsequence (length <= 10^5) :return: \\"YES\\" if t is a subsequence of s, otherwise \\"NO\\" it = iter(s) return \\"YES\\" if all(char in it for char in t) else \\"NO\\" def process_queries(s, queries): Process multiple queries to check if each string is a subsequence of the given string. :param s: The main string to be checked against :param queries: List of query strings to check as subsequences :return: List of results for each query return [is_subsequence(s, t) for t in queries]"},{"question":"def is_palindrome(s: str) -> str: Determines if the string \`s\` is a palindrome. Args: s (str): The input string. Returns: str: \\"YES\\" if \`s\` is a palindrome, otherwise \\"NO\\". >>> is_palindrome(\\"madam\\") 'YES' >>> is_palindrome(\\"hello\\") 'NO' >>> is_palindrome(\\"deed\\") 'YES' >>> is_palindrome(\\"a\\") 'YES' >>> is_palindrome(\\"abba\\") 'YES' >>> is_palindrome(\\"abca\\") 'NO' def process_test_cases(T: int, test_cases: List[str]) -> List[str]: Processes multiple test cases to check for palindromes. Args: T (int): Number of test cases. test_cases (list): List of strings to check. Returns: list: List of results for each test case, \\"YES\\" or \\"NO\\". >>> process_test_cases(3, [\\"madam\\", \\"hello\\", \\"deed\\"]) ['YES', 'NO', 'YES'] >>> process_test_cases(2, [\\"a\\", \\"abca\\"]) ['YES', 'NO'] >>> process_test_cases(1, [\\"level\\"]) ['YES'] >>> process_test_cases(4, [\\"racecar\\", \\"refer\\", \\"course\\", \\"noon\\"]) ['YES', 'YES', 'NO', 'YES'] >>> process_test_cases(0, []) []","solution":"def is_palindrome(s): Determines if the string \`s\` is a palindrome. Args: s (str): The input string. Returns: str: \\"YES\\" if \`s\` is a palindrome, otherwise \\"NO\\". return \\"YES\\" if s == s[::-1] else \\"NO\\" def process_test_cases(T, test_cases): Processes multiple test cases to check for palindromes. Args: T (int): Number of test cases. test_cases (list): List of strings to check. Returns: list: List of results for each test case, \\"YES\\" or \\"NO\\". results = [] for s in test_cases: results.append(is_palindrome(s)) return results"},{"question":"def max_profit_consecutive_projects(test_cases): Determine the maximum possible profit Aman can earn by selecting exactly k consecutive projects. Args: test_cases: A list of tuples, each containing the number of projects n, the number of consecutive projects k, and a list of integers representing the profit from each project. Returns: A list of integers, where each integer is the maximum profit for the corresponding test case. Example: >>> max_profit_consecutive_projects([(5, 3, [1, 2, 3, 4, 5])]) [12] >>> max_profit_consecutive_projects([(5, 3, [1, 2, 3, 4, 5]), (6, 2, [-1, 2, 3, -2, 5, -3]), (7, 4, [-1, 3, 5, -2, 4, 7, -1])]) [12, 5, 14]","solution":"def max_profit_consecutive_projects(test_cases): results = [] for tc in test_cases: n, k, profits = tc max_profit = float('-inf') # Calculate the initial window sum window_sum = sum(profits[:k]) max_profit = max(max_profit, window_sum) # Slide the window across the array to find max sum of k consecutive elements for i in range(1, n - k + 1): window_sum = window_sum - profits[i - 1] + profits[i + k - 1] max_profit = max(max_profit, window_sum) results.append(max_profit) return results"},{"question":"def calculate_total_score(N: int, A: List[int], B: List[int]) -> int: Calculate the total score according to the rules: - If B[i] is even, add A[i] to the total score. - If B[i] is odd, add B[i] to the total score. >>> calculate_total_score(5, [1, 2, 3, 4, 5], [6, 7, 8, 9, 10]) 25 >>> calculate_total_score(4, [2, 4, 6, 8], [2, 4, 6, 8]) 20 >>> calculate_total_score(3, [1, 3, 5], [1, 3, 5]) 9 >>> calculate_total_score(4, [1, 2, 3, 4], [5, 6, 7, 8]) 18 >>> calculate_total_score(1, [1], [1]) 1 >>> calculate_total_score(5, [10**9, 10**9, 10**9, 10**9, 10**9], [10**9, 10**9, 10**9, 10**9, 10**9]) 5 * 10**9","solution":"def calculate_total_score(N, A, B): total_score = 0 for i in range(N): if B[i] % 2 == 0: total_score += A[i] else: total_score += B[i] return total_score"},{"question":"def minimumChannels(N, channels): Returns the minimum number of channels that need to be added to make sure that every well can be reached from any other well. >>> minimumChannels(5, [[1, 2], [2, 3], [3, 4]]) 1 >>> minimumChannels(6, [[1, 2], [2, 3], [3, 4], [4, 5], [5, 6]]) 0","solution":"def minimumChannels(N, channels): Returns the minimum number of channels that need to be added to make sure that every well can be reached from any other well. def dfs(v, visited, adj): stack = [v] while stack: node = stack.pop() for neighbor in adj[node]: if not visited[neighbor]: visited[neighbor] = True stack.append(neighbor) adj = [[] for _ in range(N)] for u, v in channels: adj[u-1].append(v-1) adj[v-1].append(u-1) visited = [False] * N components = 0 for i in range(N): if not visited[i]: components += 1 visited[i] = True dfs(i, visited, adj) return max(0, components - 1)"},{"question":"def unique_paths_with_obstacles(n: int, m: int, grid: List[List[str]]) -> int: Calculate the number of unique paths from the top-left to the bottom-right corner of the grid while avoiding obstacles. Args: n (int): The number of rows in the grid. m (int): The number of columns in the grid. grid (List[List[str]]): The grid representing cells where '.' is free space and '#' is an obstacle. Returns: int: The number of unique paths from the top-left to the bottom-right corner of the grid. If no path exists, return 0. Examples: >>> unique_paths_with_obstacles(3, 3, [['.', '.', '.'], ['.', '#', '.'], ['.', '.', '.']]) 2 >>> unique_paths_with_obstacles(3, 3, [['.', '#', '.'], ['.', '#', '.'], ['.', '.', '.']]) 1 >>> unique_paths_with_obstacles(3, 3, [['.', '#', '.'], ['#', '.', '.'], ['.', '.', '#']]) 0 def test_unique_paths_example1(): n = 3 m = 3 grid = [ ['.', '.', '.'], ['.', '#', '.'], ['.', '.', '.'] ] assert unique_paths_with_obstacles(n, m, grid) == 2 def test_unique_paths_example2(): n = 3 m = 3 grid = [ ['.', '#', '.'], ['.', '#', '.'], ['.', '.', '.'] ] assert unique_paths_with_obstacles(n, m, grid) == 1 def test_unique_paths_example3(): n = 3 m = 3 grid = [ ['.', '#', '.'], ['#', '.', '.'], ['.', '.', '#'] ] assert unique_paths_with_obstacles(n, m, grid) == 0 def test_unique_paths_no_obstacles(): n = 2 m = 2 grid = [ ['.', '.'], ['.', '.'] ] assert unique_paths_with_obstacles(n, m, grid) == 2 def test_unique_paths_full_obstacles(): n = 2 m = 2 grid = [ ['#', '#'], ['#', '#'] ] assert unique_paths_with_obstacles(n, m, grid) == 0 def test_unique_paths_start_or_end_blocked(): n = 2 m = 2 grid = [ ['#', '.'], ['.', '.'] ] assert unique_paths_with_obstacles(n, m, grid) == 0 grid = [ ['.', '.'], ['.', '#'] ] assert unique_paths_with_obstacles(n, m, grid) == 0 def test_unique_paths_corner_case(): n = 1 m = 1 grid = [['.']] assert unique_paths_with_obstacles(n, m, grid) == 1 grid = [['#']] assert unique_paths_with_obstacles(n, m, grid) == 0","solution":"def unique_paths_with_obstacles(n, m, grid): if grid[0][0] == '#' or grid[n-1][m-1] == '#': return 0 dp = [[0] * m for _ in range(n)] dp[0][0] = 1 for i in range(n): for j in range(m): if grid[i][j] == '#': dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[n-1][m-1]"},{"question":"import heapq from typing import List, Tuple def dijkstra(N: int, edges: List[Tuple[int, int, int]], S: int) -> List[str]: Compute the shortest distance from the given source node to all other nodes using Dijkstra's algorithm. Args: - N: The number of nodes in the graph. - edges: A list of edges represented as tuples (u, v, w) where u is the starting node, v is the ending node, and w is the weight of the edge. - S: The source node from which to calculate the shortest distances. Returns: - A list of strings representing the minimum distance from the source node S to each node. If a node is unreachable, the distance is \\"INF\\". Examples: >>> dijkstra(5, [(1, 2, 2), (1, 3, 4), (2, 4, 7), (2, 3, 1), (3, 5, 3), (4, 5, 1)], 1) ['0', '2', '3', '9', '6'] >>> dijkstra(6, [(1, 2, 2), (1, 3, 4), (3, 5, 3), (5, 6, 1)], 1) ['0', '2', '4', 'INF', '7', '8']","solution":"import heapq def dijkstra(N, edges, S): # Initialize distances and adjacency list dist = [float('inf')] * (N + 1) adjacency_list = {i: [] for i in range(1, N + 1)} for u, v, w in edges: adjacency_list[u].append((v, w)) # Dijkstra's algorithm using a priority queue dist[S] = 0 priority_queue = [(0, S)] while priority_queue: current_dist, u = heapq.heappop(priority_queue) if current_dist > dist[u]: continue for v, weight in adjacency_list[u]: distance = current_dist + weight if distance < dist[v]: dist[v] = distance heapq.heappush(priority_queue, (distance, v)) # Prepare output: distances from source S, or \\"INF\\" if unreachable results = [] for i in range(1, N + 1): if dist[i] == float('inf'): results.append(\\"INF\\") else: results.append(str(dist[i])) return results # Example usage with the provided input: # N, M = 5, 6 # edges = [ # (1, 2, 2), # (1, 3, 4), # (2, 4, 7), # (2, 3, 1), # (3, 5, 3), # (4, 5, 1) # ] # S = 1 # print(dijkstra(N, edges, S))"},{"question":"def max_lines_of_code(n: int, lines_per_minute: List[int], start_times: List[int], t: int) -> int: Calculate the maximum number of lines of code written by any single participant at minute t. :param n: int - number of participants :param lines_per_minute: list of int - lines of code each participant writes per minute :param start_times: list of int - starting delay (in minutes) for each participant :param t: int - the minute at which to calculate the maximum lines of code written :return: int - maximum lines of code written by any participant at minute t >>> max_lines_of_code(3, [5, 3, 8], [0, 2, 1], 3) 16 >>> max_lines_of_code(4, [2, 4, 1, 3], [1, 0, 3, 2], 4) 16 from typing import List def test_example_1(): assert max_lines_of_code(3, [5, 3, 8], [0, 2, 1], 3) == 16 def test_example_2(): assert max_lines_of_code(4, [2, 4, 1, 3], [1, 0, 3, 2], 4) == 16 def test_single_participant(): assert max_lines_of_code(1, [4], [0], 5) == 20 def test_all_participants_start_immediately(): assert max_lines_of_code(3, [1, 2, 3], [0, 0, 0], 2) == 6 def test_no_lines_written_due_to_delay(): assert max_lines_of_code(2, [5, 4], [4, 5], 3) == 0 def test_after_starting_delay(): assert max_lines_of_code(2, [6, 4], [2, 1], 3) == 8 def test_zero_lines_per_minute(): assert max_lines_of_code(2, [0, 0], [0, 0], 5) == 0","solution":"def max_lines_of_code(n, lines_per_minute, start_times, t): Calculate the maximum number of lines of code written by any single participant at minute t. :param n: int - number of participants :param lines_per_minute: list of int - lines of code each participant writes per minute :param start_times: list of int - starting delay (in minutes) for each participant :param t: int - the minute at which to calculate the maximum lines of code written :return: int - maximum lines of code written by any participant at minute t max_code = 0 for i in range(n): if t >= start_times[i]: # Calculate the lines of code written by participant i at minute t lines_written = lines_per_minute[i] * (t - start_times[i]) max_code = max(max_code, lines_written) return max_code"},{"question":"def max_levels(n: int, k: int) -> int: Determine the maximum number of complete levels of the pyramid that can be constructed with the given k bricks. Parameters: n (int): The number of levels that could potentially be built. k (int): The number of bricks available. Returns: int: The maximum number of complete levels that can be built with k bricks. >>> max_levels(5, 15) 5 >>> max_levels(5, 10) 4 >>> max_levels(5, 5) 2 >>> max_levels(1, 1) 1 >>> max_levels(3, 10) 3 >>> max_levels(10, 55) 10 >>> max_levels(10, 50) 9 >>> max_levels(3, 6) 3","solution":"def max_levels(n: int, k: int) -> int: Determine the maximum number of complete levels of the pyramid that can be constructed with the given k bricks. Parameters: n (int): The number of levels that could potentially be built. k (int): The number of bricks available. Returns: int: The maximum number of complete levels that can be built with k bricks. total_bricks = 0 for i in range(1, n + 1): total_bricks += i if total_bricks > k: return i - 1 return n"},{"question":"def is_prime(n: int) -> bool: Determines if a given number n is a prime number. Parameters ---------- n : int The number to be checked for primality. Returns ------- bool True if n is a prime number, False otherwise. Examples -------- >>> is_prime(5) True >>> is_prime(10) False >>> is_prime(23) True","solution":"def is_prime(n): Determines if a given number n is a prime number. Parameters ---------- n : int The number to be checked for primality. Returns ------- bool True if n is a prime number, False otherwise. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False for i in range(3, int(n ** 0.5) + 1, 2): if n % i == 0: return False return True"},{"question":"class ProductRatings: def __init__(self, ratings): Initialize the ProductRatings class with a list of ratings. Args: ratings (List[int]): Initial ratings of the products. # Your code here def build(self, node, start, end): Build the segment tree for range maximum queries. Args: node (int): Current node in the segment tree. start (int): Start index of range. end (int): End index of range. # Your code here def update(self, idx, value): Update the rating of the product at the given index. Args: idx (int): Index of the product. value (int): New rating value. # Your code here def _update(self, node, start, end, idx, value): Helper function to update the segment tree. Args: node (int): Current node in the segment tree. start (int): Start index of range. end (int): End index of range. idx (int): Index of the product. value (int): New rating value. # Your code here def query(self, L, R): Query the segment tree for the highest rating in the given range. Args: L (int): Start index of range. R (int): End index of range. Returns: Tuple[int, int]: The highest rating and the index of the product. # Your code here def _query(self, node, start, end, L, R): Helper function to perform the range maximum query. Args: node (int): Current node in the segment tree. start (int): Start index of range. end (int): End index of range. L (int): Start index of query range. R (int): End index of query range. Returns: Tuple[int, int]: The highest rating and the index of the product. # Your code here def handle_queries(N, Q, ratings, queries): Handle the queries on the product ratings. Args: N (int): Number of products. Q (int): Number of queries. ratings (List[int]): Initial ratings of the products. queries (List[List[int]]): List of queries to process. Returns: List[int]: Product IDs with the highest ratings for range queries. >>> handle_queries(5, 6, [10, 20, 30, 40, 50], [[2, 1, 5], [1, 3, 25], [2, 1, 3], [1, 5, 45], [2, 4, 5], [2, 1, 5]]) [5, 3, 5, 5] >>> handle_queries(5, 4, [10, 10, 10, 10, 10], [[2, 1, 5], [1, 3, 15], [2, 1, 5], [2, 2, 4]]) [1, 3, 3] # Your code here def test_handle_queries(): N = 5 Q = 6 ratings = [10, 20, 30, 40, 50] queries = [ [2, 1, 5], [1, 3, 25], [2, 1, 3], [1, 5, 45], [2, 4, 5], [2, 1, 5] ] expected = [5, 3, 5, 5] assert handle_queries(N, Q, ratings, queries) == expected def test_handle_queries_same_ratings(): N = 5 Q = 4 ratings = [10, 10, 10, 10, 10] queries = [ [2, 1, 5], [1, 3, 15], [2, 1, 5], [2, 2, 4] ] expected = [1, 3, 3] assert handle_queries(N, Q, ratings, queries) == expected def test_handle_queries_single_product(): N = 1 Q = 2 ratings = [10] queries = [ [2, 1, 1], [1, 1, 20] ] expected = [1] assert handle_queries(N, Q, ratings, queries) == expected def test_handle_queries_update_and_query(): N = 4 Q = 4 ratings = [30, 20, 25, 35] queries = [ [2, 1, 4], [1, 2, 40], [2, 1, 4], [2, 2, 3] ] expected = [4, 2, 2] assert handle_queries(N, Q, ratings, queries) == expected import pytest pytest.main(args=['-v'])","solution":"class ProductRatings: def __init__(self, ratings): self.n = len(ratings) self.data = ratings[:] self.segment_tree = [None] * (4 * self.n) self.build(0, 0, self.n - 1) def build(self, node, start, end): if start == end: self.segment_tree[node] = (self.data[start], start) else: mid = (start + end) // 2 left_child = 2 * node + 1 right_child = 2 * node + 2 self.build(left_child, start, mid) self.build(right_child, mid + 1, end) left_val = self.segment_tree[left_child] right_val = self.segment_tree[right_child] if left_val[0] > right_val[0] or (left_val[0] == right_val[0] and left_val[1] < right_val[1]): self.segment_tree[node] = left_val else: self.segment_tree[node] = right_val def update(self, idx, value): self._update(0, 0, self.n - 1, idx, value) def _update(self, node, start, end, idx, value): if start == end: self.data[idx] = value self.segment_tree[node] = (value, start) else: mid = (start + end) // 2 left_child = 2 * node + 1 right_child = 2 * node + 2 if start <= idx <= mid: self._update(left_child, start, mid, idx, value) else: self._update(right_child, mid + 1, end, idx, value) left_val = self.segment_tree[left_child] right_val = self.segment_tree[right_child] if left_val[0] > right_val[0] or (left_val[0] == right_val[0] and left_val[1] < right_val[1]): self.segment_tree[node] = left_val else: self.segment_tree[node] = right_val def query(self, L, R): return self._query(0, 0, self.n - 1, L, R) def _query(self, node, start, end, L, R): if R < start or L > end: return (-1, float('inf')) # Use inverse value for comparison if L <= start and end <= R: return self.segment_tree[node] mid = (start + end) // 2 left_child = 2 * node + 1 right_child = 2 * node + 2 left_val = self._query(left_child, start, mid, L, R) right_val = self._query(right_child, mid + 1, end, L, R) if left_val[0] > right_val[0] or (left_val[0] == right_val[0] and left_val[1] < right_val[1]): return left_val else: return right_val def handle_queries(N, Q, ratings, queries): product_ratings = ProductRatings(ratings) results = [] for query in queries: if query[0] == 1: product_ratings.update(query[1] - 1, query[2]) elif query[0] == 2: result = product_ratings.query(query[1] - 1, query[2] - 1) results.append(result[1] + 1) return results"},{"question":"def isRotatedVersion(S1: str, S2: str) -> int: Determines if S2 is a rotated version of S1. Parameters: S1 (str): The original string. S2 (str): The string to check if it is a rotated version of S1. Returns: int: 1 if S2 is a rotated version of S1, 0 otherwise. >>> isRotatedVersion(\\"abcd\\", \\"cdab\\") 1 >>> isRotatedVersion(\\"abcd\\", \\"acbd\\") 0","solution":"def isRotatedVersion(S1, S2): Determines if S2 is a rotated version of S1. Parameters: S1 (str): The original string. S2 (str): The string to check if it is a rotated version of S1. Returns: int: 1 if S2 is a rotated version of S1, 0 otherwise. if len(S1) != len(S2): return 0 # Concatenate S1 with itself double_S1 = S1 + S1 # Check if S2 is a substring of concatenated S1 if S2 in double_S1: return 1 else: return 0"},{"question":"def can_optimize_lighting(N: int, state: str, K: int) -> str: Determines if it is possible to have exactly one switch ON and all other switches OFF within K toggles. Parameters: N (int): Number of rooms. state (str): Binary string representing the initial state of the switches. K (int): Maximum number of allowed toggles. Returns: str: \\"YES\\" if possible, \\"NO\\" otherwise. >>> can_optimize_lighting(5, \\"11001\\", 3) 'YES' >>> can_optimize_lighting(5, \\"11001\\", 1) 'NO'","solution":"def can_optimize_lighting(N, state, K): Determines if it is possible to have exactly one switch ON and all other switches OFF within K toggles. Parameters: N (int): Number of rooms. state (str): Binary string representing the initial state of the switches. K (int): Maximum number of allowed toggles. Returns: str: \\"YES\\" if possible, \\"NO\\" otherwise. # Count the number of switches that are ON initial_on_count = state.count('1') # If there are no switches ON initially, it's impossible to get exactly one ON if initial_on_count == 0: return \\"NO\\" # If we already have exactly one switch ON, no toggles are needed if initial_on_count == 1: return \\"YES\\" # Calculate the number of toggles needed to achieve the desired state # We need to turn off (initial_on_count - 1) switches that are currently ON # And turn on (1 - current_on_count) switches that are currently OFF # Number of toggles required is initial_on_count - 1 (since we need exactly one switch ON) required_toggles = initial_on_count - 1 # Check if the required toggles are within the allowed limit if required_toggles <= K: return \\"YES\\" else: return \\"NO\\""},{"question":"def minRoadLength(N, roads): Returns the minimum total length of roads required to connect all districts or -1 if not possible. Args: N: int: Number of districts roads: List[Tuple[int, int, int]]: List of roads represented as tuples (u, v, w) Returns: int: Minimum total length of roads needed to connect all districts or -1 if not possible. Examples: >>> minRoadLength(4, [(1, 2, 5), (1, 3, 10), (2, 3, 6), (2, 4, 2), (3, 4, 1)]) 8 >>> minRoadLength(3, [(1, 2, 3), (2, 3, 4)]) 7 >>> minRoadLength(3, [(1, 2, 1)]) -1 pass # Your implementation here def test_minRoadLength_example1(): assert minRoadLength(4, [(1, 2, 5), (1, 3, 10), (2, 3, 6), (2, 4, 2), (3, 4, 1)]) == 8 def test_minRoadLength_example2(): assert minRoadLength(3, [(1, 2, 3), (2, 3, 4)]) == 7 def test_minRoadLength_example3(): assert minRoadLength(3, [(1, 2, 1)]) == -1 def test_minRoadLength_additional1(): assert minRoadLength(5, [(1, 2, 3), (2, 3, 4), (3, 4, 5), (4, 5, 6), (1, 5, 7)]) == 18 def test_minRoadLength_additional2(): assert minRoadLength(3, [(1, 2, 6), (2, 3, 1), (1, 3, 2)]) == 3 def test_minRoadLength_additional3(): assert minRoadLength(4, [(1, 2, 1), (2, 3, 1)]) == -1 # Not enough roads to connect all districts def test_minRoadLength_disconnected_graph(): assert minRoadLength(4, [(1, 2, 1), (3, 4, 1)]) == -1 # Two disconnected components","solution":"def minRoadLength(N, roads): Returns the minimum total length of roads required to connect all districts or -1 if not possible. # Helper function to find the representative (root) of a set def find(parent, i): if parent[i] == i: return i return find(parent, parent[i]) # Helper function to unify two sets def union(parent, rank, x, y): root_x = find(parent, x) root_y = find(parent, y) if root_x != root_y: if rank[root_x] > rank[root_y]: parent[root_y] = root_x elif rank[root_x] < rank[root_y]: parent[root_x] = root_y else: parent[root_y] = root_x rank[root_x] += 1 # Sort all the roads based on the weight roads.sort(key=lambda x: x[2]) parent = list(range(N + 1)) rank = [0] * (N + 1) total_length = 0 count = 0 for u, v, w in roads: root_u = find(parent, u) root_v = find(parent, v) if root_u != root_v: union(parent, rank, root_u, root_v) total_length += w count += 1 # If we have connected N-1 roads, we can stop if count == N - 1: return total_length return -1"},{"question":"def largest_square_sub_grid(n: int, grid: List[List[int]]) -> int: Find the size of the largest square sub-grid that only contains 1s. Args: n : int : the size of the grid grid : List[List[int]] : a 2D list representing the grid containing 0s and 1s Returns: int : size of the largest square sub-grid that only contains 1s Examples: >>> process_input(4, [ ... \\"1 1 1 0\\", ... \\"1 1 1 0\\", ... \\"1 1 1 1\\", ... \\"0 0 1 1\\" ... ]) == [[1, 1, 1, 0], [1, 1, 1, 0], [1, 1, 1, 1], [0, 0, 1, 1]] >>> largest_square_sub_grid(4, [ ... [1, 1, 1, 0], ... [1, 1, 1, 0], ... [1, 1, 1, 1], ... [0, 0, 1, 1] ... ]) == 3 >>> process_input(5, [ ... \\"1 0 1 0 1\\", ... \\"1 0 1 1 1\\", ... \\"1 1 1 1 1\\", ... \\"1 0 1 1 1\\", ... \\"1 1 1 1 1\\" ... ]) == [[1, 0, 1, 0, 1], [1, 0, 1, 1, 1], [1, 1, 1, 1, 1], [1, 0, 1, 1, 1], [1, 1, 1, 1, 1]] >>> largest_square_sub_grid(5, [ ... [1, 0, 1, 0, 1], ... [1, 0, 1, 1, 1], ... [1, 1, 1, 1, 1], ... [1, 0, 1, 1, 1], ... [1, 1, 1, 1, 1] ... ]) == 3 ... def process_input(n: int, lines: List[str]) -> List[List[int]]: Convert the input lines to a grid. Args: n : int : the size of the grid lines : List[str] : a list of strings, each string representing a row of the grid Returns: List[List[int]] : a 2D list representing the grid Examples: >>> process_input(4, [ ... \\"1 1 1 0\\", ... \\"1 1 1 0\\", ... \\"1 1 1 1\\", ... \\"0 0 1 1\\" ... ]) == [[1, 1, 1, 0], [1, 1, 1, 0], [1, 1, 1, 1], [0, 0, 1, 1]] ... import pytest def test_sample_input_1(): n = 4 lines = [ \\"1 1 1 0\\", \\"1 1 1 0\\", \\"1 1 1 1\\", \\"0 0 1 1\\" ] grid = process_input(n, lines) assert largest_square_sub_grid(n, grid) == 3 def test_sample_input_2(): n = 5 lines = [ \\"1 0 1 0 1\\", \\"1 0 1 1 1\\", \\"1 1 1 1 1\\", \\"1 0 1 1 1\\", \\"1 1 1 1 1\\" ] grid = process_input(n, lines) assert largest_square_sub_grid(n, grid) == 3 def test_min_input(): n = 1 lines = [ \\"0\\" ] grid = process_input(n, lines) assert largest_square_sub_grid(n, grid) == 0 def test_min_input_all_ones(): n = 1 lines = [ \\"1\\" ] grid = process_input(n, lines) assert largest_square_sub_grid(n, grid) == 1 def test_all_zeros(): n = 3 lines = [ \\"0 0 0\\", \\"0 0 0\\", \\"0 0 0\\" ] grid = process_input(n, lines) assert largest_square_sub_grid(n, grid) == 0 def test_all_ones(): n = 2 lines = [ \\"1 1\\", \\"1 1\\" ] grid = process_input(n, lines) assert largest_square_sub_grid(n, grid) == 2 def test_complex_grid(): n = 6 lines = [ \\"1 1 0 1 1 0\\", \\"1 1 1 1 1 0\\", \\"0 1 1 1 1 1\\", \\"0 1 1 1 0 1\\", \\"1 1 1 0 1 1\\", \\"1 1 0 1 1 1\\" ] grid = process_input(n, lines) assert largest_square_sub_grid(n, grid) == 3","solution":"def largest_square_sub_grid(n, grid): Find the size of the largest square sub-grid that only contains 1s. if n == 1: return grid[0][0] max_side = 0 dp = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): if grid[i][j] == 1: if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side = max(max_side, dp[i][j]) return max_side # Function to convert the input into grid format for the function def process_input(n, lines): grid = [] for line in lines: grid.append(list(map(int, line.split()))) return grid"},{"question":"def find_clash(n: int, creatures: List[Tuple[int, int, int, int, int, int]]) -> str: Determine if any pair of creatures will meet at some time before reaching their destinations. Args: n (int): The number of creatures. creatures (list of tuples): Each tuple contains six integers representing the starting and destination points of a creature. Returns: str: \\"CLASH\\" if any pair of creatures will meet at some time before sunrise; otherwise, \\"SAFE\\". Examples: >>> find_clash(3, [(0, 0, 0, 10, 0, 0), (0, 0, 0, 5, 5, 0), (0, 0, 0, 0, 10, 10)]) 'CLASH' >>> find_clash(2, [(1, 2, 3, 4, 5, 6), (-1, -2, -3, 4, -6, 2)]) 'SAFE'","solution":"def find_clash(n, creatures): from itertools import combinations import math def vector_subtract(a, b): return (a[0] - b[0], a[1] - b[1], a[2] - b[2]) def vector_add(a, b): return (a[0] + b[0], a[1] + b[1], a[2] + b[2]) def vector_scalar_multiply(v, s): return (v[0] * s, v[1] * s, v[2] * s) def vector_magnitude(v): return math.sqrt(v[0] ** 2 + v[1] ** 2 + v[2] ** 2) def normalized_direction(p1, p2): direction = vector_subtract(p2, p1) magnitude = vector_magnitude(direction) return (direction[0] / magnitude, direction[1] / magnitude, direction[2] / magnitude) if magnitude else (0, 0, 0) points = [(tuple(data[:3]), tuple(data[3:])) for data in creatures] for (a_start, a_end), (b_start, b_end) in combinations(points, 2): dir_a = normalized_direction(a_start, a_end) dir_b = normalized_direction(b_start, b_end) if dir_a == dir_b or dir_a == vector_scalar_multiply(dir_b, -1): # If they are moving in the same direction (or exactly opposite) distance_vector = vector_subtract(a_start, b_start) distance_along_direction = vector_magnitude(distance_vector) if distance_along_direction == 0 or (vector_magnitude(vector_subtract(a_end, b_end)) == 0): return \\"CLASH\\" else: # If their directions are different ta = [((b_start[i] - a_start[i]) / (a_end[i] - a_start[i])) if (a_end[i] != a_start[i]) else float('inf') for i in range(3)] tb = [((a_start[i] - b_start[i]) / (b_end[i] - b_start[i])) if (b_end[i] != b_start[i]) else float('inf') for i in range(3)] if all(ta[i] == tb[i] for i in range(3) if ta[i] != float('inf') and tb[i] != float('inf')): return \\"CLASH\\" return \\"SAFE\\""},{"question":"def can_make_equal(n: int, a: List[int], b: List[int]) -> str: Determines if arrays a and b can be made equal by performing the allowed operation. The operation allows selecting a subarray of any length and adding 1 to all its elements. Parameters: n (int): The size of the arrays. a (list of int): The first array. b (list of int): The second array. Returns: str: \\"YES\\" if arrays can be made equal, otherwise \\"NO\\". >>> can_make_equal(5, [1, 2, 3, 4, 5], [2, 3, 4, 5, 6]) \\"YES\\" >>> can_make_equal(3, [1, 2, 3], [3, 1, 2]) \\"NO\\" from typing import List # Ensure the necessary imports are included def test_case_1(): assert can_make_equal(5, [1, 2, 3, 4, 5], [2, 3, 4, 5, 6]) == \\"YES\\" def test_case_2(): assert can_make_equal(3, [1, 2, 3], [3, 1, 2]) == \\"NO\\" def test_case_3(): assert can_make_equal(3, [0, 0, 0], [0, 0, 0]) == \\"YES\\" def test_case_4(): assert can_make_equal(4, [1, 3, 2, 4], [2, 4, 3, 5]) == \\"YES\\" def test_case_5(): assert can_make_equal(4, [1, 2, 3, 4], [2, 2, 2, 5]) == \\"NO\\" def test_case_6(): assert can_make_equal(5, [100, 200, 300, 400, 500], [101, 200, 301, 400, 501]) == \\"NO\\"","solution":"def can_make_equal(n, a, b): Determines if arrays a and b can be made equal by performing the allowed operation. Parameters: n (int): The size of the arrays. a (list of int): The first array. b (list of int): The second array. Returns: str: \\"YES\\" if arrays can be made equal, otherwise \\"NO\\". diff = [b[i] - a[i] for i in range(n)] # To check whether all differences are non-decreasing for i in range(1, n): if diff[i] < diff[i - 1]: return \\"NO\\" if all(d >= 0 for d in diff): return \\"YES\\" else: return \\"NO\\""},{"question":"def get_fastest_team(num_teams: int, times_list: List[List[int]]) -> int: Returns the team number with the fastest total race time. Each team consists of four runners. Parameters: num_teams (int): Number of teams participating. times_list (List[List[int]]): A list of lists where each inner list contains four integers representing the time taken by each runner on the team. Returns: int: The team number with the fastest total race time. Example: >>> get_fastest_team(3, [ ... [12, 15, 11, 14], ... [10, 16, 13, 12], ... [13, 14, 10, 15] ... ]) 2 >>> get_fastest_team(2, [ ... [14, 17, 19, 13], ... [18, 13, 17, 15] ... ]) 1","solution":"def get_fastest_team(num_teams, times_list): Returns the team number with the fastest total race time. Parameters: num_teams (int): Number of teams times_list (list[list[int]]): List of lists where each inner list contains 4 integers representing the time taken by the runners of each team Returns: int: The team number with the fastest total race time min_time = float('inf') fastest_team = 0 for i in range(num_teams): total_time = sum(times_list[i]) if total_time < min_time: min_time = total_time fastest_team = i + 1 return fastest_team"},{"question":"def text_formatting(commands, text): Processes text according to formatting commands. The possible commands are: - \`UPPER\`: Converts all characters in the text to uppercase. - \`LOWER\`: Converts all characters in the text to lowercase. - \`CAPITALIZE\`: Converts the first character of each word in the text to uppercase and the rest to lowercase. - \`LEFT <N>\`: Aligns the text to the left within a width of N characters. - \`RIGHT <N>\`: Aligns the text to the right within a width of N characters. - \`CENTER <N>\`: Centers the text within a width of N characters. The input consists of a series of commands followed by the text to be formatted. Each command is given on a new line. The series of commands ends with a line that contains only the word \`END\`, followed by the text that needs to be formatted. >>> commands = [\\"UPPER\\", \\"END\\"] >>> text = [\\"hello world\\"] >>> text_formatting(commands, text) \\"HELLO WORLD\\" >>> commands = [\\"LEFT 20\\", \\"END\\"] >>> text = [\\"Hello\\"] >>> text_formatting(commands, text) \\"Hello \\" pass","solution":"def text_formatting(commands, text): Processes text according to formatting commands. full_text = ' '.join(text).strip() for command in commands: com = command.split() if com[0] == 'UPPER': full_text = full_text.upper() elif com[0] == 'LOWER': full_text = full_text.lower() elif com[0] == 'CAPITALIZE': full_text = full_text.title() elif com[0] == 'LEFT': width = int(com[1]) full_text = full_text.ljust(width) elif com[0] == 'RIGHT': width = int(com[1]) full_text = full_text.rjust(width) elif com[0] == 'CENTER': width = int(com[1]) full_text = full_text.center(width) return full_text"},{"question":"def generate_sequence(N: int) -> list: Generates the first N numbers of the sequence S as defined. >>> generate_sequence(1) [0] >>> generate_sequence(2) [0, 1] >>> generate_sequence(3) [0, 1, 3] >>> generate_sequence(5) [0, 1, 3, 7, 14]","solution":"def generate_sequence(N): Generates the first N numbers of the sequence S as defined. if N == 1: return [0] if N == 2: return [0, 1] S = [0] * N S[0], S[1] = 0, 1 for i in range(2, N): S[i] = S[i-1] + S[i-2] + i return S # Example usage n = 5 sequence = generate_sequence(n) print(\\" \\".join(map(str, sequence)))"},{"question":"def manage_attendance(n, m, operations): Manages student attendance records. Parameters: n (int): Number of students. m (int): Number of operations. operations (list): List of operations as strings. Returns: list: List of average attendance for each 'Q' operation. pass from solution import manage_attendance def test_sample_input(): n = 3 m = 5 operations = [ \\"I 1 1 3\\", \\"I 1 2 4\\", \\"Q 1\\", \\"I 2 5 5\\", \\"Q 2\\" ] assert manage_attendance(n, m, operations) == [\\"1.40\\", \\"1.00\\"] def test_all_zeroes(): n = 1 m = 1 operations = [ \\"Q 1\\" ] assert manage_attendance(n, m, operations) == [\\"0.00\\"] def test_increments_and_queries(): n = 2 m = 6 operations = [ \\"I 1 1 10\\", \\"I 1 2 20\\", \\"I 1 3 30\\", \\"Q 1\\", \\"I 2 5 25\\", \\"Q 2\\" ] assert manage_attendance(n, m, operations) == [\\"12.00\\", \\"5.00\\"] def test_maximum_values(): n = 2 m = 10 operations = [ \\"I 1 1 100000\\", \\"I 1 2 100000\\", \\"I 1 3 100000\\", \\"I 1 4 100000\\", \\"I 1 5 100000\\", \\"Q 1\\", \\"I 2 1 100000\\", \\"I 2 2 100000\\", \\"I 2 3 100000\\", \\"Q 2\\" ] assert manage_attendance(n, m, operations) == [\\"100000.00\\", \\"60000.00\\"] def test_single_increment(): n = 4 m = 4 operations = [ \\"I 3 4 5\\", \\"Q 3\\", \\"I 4 2 10\\", \\"Q 4\\" ] assert manage_attendance(n, m, operations) == [\\"1.00\\", \\"2.00\\"]","solution":"def manage_attendance(n, m, operations): Manages student attendance records. Parameters: n (int): Number of students. m (int): Number of operations. operations (list): List of operations as strings. Returns: list: List of average attendance for each 'Q' operation. attendance = [[0] * 5 for _ in range(n)] result = [] for operation in operations: parts = operation.split() if parts[0] == 'I': student_id = int(parts[1]) - 1 course_id = int(parts[2]) - 1 x = int(parts[3]) attendance[student_id][course_id] += x elif parts[0] == 'Q': student_id = int(parts[1]) - 1 avg_attendance = sum(attendance[student_id]) / 5.0 result.append(f\\"{avg_attendance:.2f}\\") return result"},{"question":"import heapq def dijkstra(n: int, edges: List[Tuple[int, int, int]]) -> List[int]: Compute the shortest path from vertex 1 to all other vertices using Dijkstra's algorithm. >>> dijkstra(5, [(1, 2, 2), (1, 3, 4), (2, 3, 1), (2, 4, 7), (3, 5, 3), (4, 5, 1)]) [0, 2, 3, 9, 6] >>> dijkstra(3, [(1, 2, 3)]) [0, 3, -1] >>> dijkstra(4, [(1, 2, 1), (1, 3, 4), (2, 3, 2), (3, 4, 1)]) [0, 1, 3, 4]","solution":"import heapq def dijkstra(n, edges): # Prepare the graph as adjacency list graph = [[] for _ in range(n + 1)] for u, v, w in edges: graph[u].append((v, w)) # Initialize distance array with infinity dist = [float(\\"inf\\")] * (n + 1) dist[1] = 0 # Use priority queue to store the nodes to be processed pq = [(0, 1)] # (distance, vertex) heapq.heapify(pq) while pq: current_dist, u = heapq.heappop(pq) if current_dist > dist[u]: continue for v, weight in graph[u]: distance = current_dist + weight if distance < dist[v]: dist[v] = distance heapq.heappush(pq, (distance, v)) # Retain the results starting from vertex 1 to n # Use -1 to denote unreachable nodes result = [dist[i] if dist[i] != float(\\"inf\\") else -1 for i in range(1, n + 1)] return result"},{"question":"from typing import List, Tuple def minSlots(tasks: List[Tuple[int, int]]) -> int: Determine the minimum number of slots required to execute all tasks without overlap. Each tasks is represented as a tuple (start, end). >>> minSlots([(1, 4), (2, 5), (6, 8)]) 2 >>> minSlots([(1, 3), (2, 4), (3, 5), (4, 6), (5, 7)]) 2 # Implementation here import heapq def test_example_1(): tasks = [(1, 4), (2, 5), (6, 8)] assert minSlots(tasks) == 2 def test_example_2(): tasks = [(1, 3), (2, 4), (3, 5), (4, 6), (5, 7)] assert minSlots(tasks) == 2 def test_single_task(): tasks = [(1, 2)] assert minSlots(tasks) == 1 def test_no_overlap_tasks(): tasks = [(1, 2), (3, 4), (5, 6)] assert minSlots(tasks) == 1 def test_all_tasks_same_time(): tasks = [(1, 2), (1, 2), (1, 2)] assert minSlots(tasks) == 3 def test_all_tasks_nested(): tasks = [(1, 10), (2, 9), (3, 8), (4, 7)] assert minSlots(tasks) == 4 def test_multiple_availability(): tasks = [(1, 3), (2, 5), (4, 6), (5, 7)] assert minSlots(tasks) == 2","solution":"import heapq def minSlots(tasks): Returns the minimum number of slots required to execute all tasks. Each task is represented as a tuple (start, end). if not tasks: return 0 # Sort tasks by their start times tasks.sort(key=lambda x: x[0]) # Initialize a min-heap min_heap = [] # Add the end time of the first task to the heap heapq.heappush(min_heap, tasks[0][1]) for task in tasks[1:]: # If the earliest ending task is finished before the new task starts if min_heap[0] <= task[0]: heapq.heappop(min_heap) # Add the new task's end time to the heap heapq.heappush(min_heap, task[1]) # The size of the heap represents the minimum number of slots required return len(min_heap)"},{"question":"def find_factors(n: int) -> List[int]: Returns a list of factors of the given non-negative integer n. >>> find_factors(12) == [1, 2, 3, 4, 6, 12] >>> find_factors(28) == [1, 2, 4, 7, 14, 28] >>> find_factors(7) == [1, 7] >>> find_factors(0) == [] >>> find_factors(1) == [1] >>> find_factors(29) == [1, 29] >>> find_factors(100) == [1, 2, 4, 5, 10, 20, 25, 50, 100]","solution":"def find_factors(n): Returns a list of factors of the given non-negative integer n. if n == 0: return [] factors = [i for i in range(1, n+1) if n % i == 0] return factors"},{"question":"def perfectly_fitting_boxes(T: int, cases: List[Dict[str, Union[Tuple[int, int, int], int, List[Tuple[int, int, int]]]]]) -> List[int]: Determine which inner boxes can fit perfectly into the outer box for each test case. Args: T (int): number of test cases cases (List[Dict[str, Union[Tuple[int, int, int], int, List[Tuple[int, int, int]]]]]): list of dictionaries, each containing the outer box dimensions, number of inner boxes, and inner box dimensions Returns: List[int]: number of inner boxes that fit perfectly for each test case >>> T, cases = process_input('''1 ... 10 8 6 ... 3 ... 5 7 2 ... 9 7 5 ... 10 8 6''') >>> perfectly_fitting_boxes(T, cases) [1] >>> T, cases = process_input('''1 ... 15 10 5 ... 3 ... 14 10 5 ... 15 9 5 ... 15 10 4''') >>> perfectly_fitting_boxes(T, cases) [0] >>> T, cases = process_input('''1 ... 10 10 10 ... 5 ... 10 10 10 ... 10 10 10 ... 9 10 10 ... 10 9 10 ... 10 10 9''') >>> perfectly_fitting_boxes(T, cases) [2] >>> T, cases = process_input('''1 ... 7 8 9 ... 3 ... 6 8 9 ... 7 9 9 ... 7 8 8''') >>> perfectly_fitting_boxes(T, cases) [0] >>> T, cases = process_input('''2 ... 10 8 6 ... 2 ... 10 8 6 ... 8 10 6 ... 20 15 10 ... 3 ... 20 15 10 ... 15 20 10 ... 20 15 8''') >>> perfectly_fitting_boxes(T, cases) [1, 1] def process_input(input_str: str) -> Tuple[int, List[Dict[str, Union[Tuple[int, int, int], int, List[Tuple[int, int, int]]]]]]: Process the input string into test cases. Args: input_str (str): the input string Returns: Tuple[int, List[Dict[str, Union[Tuple[int, int, int], int, List[Tuple[int, int, int]]]]]]: the number of test cases and the list of cases >>> process_input('''1 ... 10 8 6 ... 3 ... 5 7 2 ... 9 7 5 ... 10 8 6''') (1, [{'outer_box': (10, 8, 6), 'N': 3, 'inner_boxes': [(5, 7, 2), (9, 7, 5), (10, 8, 6)]}]) >>> process_input('''2 ... 10 8 6 ... 2 ... 10 8 6 ... 8 10 6 ... 20 15 10 ... 3 ... 20 15 10 ... 15 20 10 ... 20 15 8''') (2, [{'outer_box': (10, 8, 6), 'N': 2, 'inner_boxes': [(10, 8, 6), (8, 10, 6)]}, {'outer_box': (20, 15, 10), 'N': 3, 'inner_boxes': [(20, 15, 10), (15, 20, 10), (20, 15, 8)]}])","solution":"def perfectly_fitting_boxes(T, cases): results = [] for case in cases: outer_box = case[\\"outer_box\\"] N = case[\\"N\\"] inner_boxes = case[\\"inner_boxes\\"] L, W, H = outer_box count = 0 for box in inner_boxes: li, wi, hi = box if li == L and wi == W and hi == H: count += 1 results.append(count) return results def process_input(input_str): lines = input_str.strip().split('n') T = int(lines[0]) index = 1 cases = [] for _ in range(T): L, W, H = map(int, lines[index].split()) outer_box = (L, W, H) index += 1 N = int(lines[index]) index += 1 inner_boxes = [] for _ in range(N): li, wi, hi = map(int, lines[index].split()) inner_boxes.append((li, wi, hi)) index += 1 cases.append({\\"outer_box\\": outer_box, \\"N\\": N, \\"inner_boxes\\": inner_boxes}) return T, cases"},{"question":"def is_palindrome(s: str) -> bool: Determines if a given string is a palindrome, considering only alphanumeric characters and ignoring cases. >>> is_palindrome(\\"A man, a plan, a canal: Panama\\") True >>> is_palindrome(\\"race a car\\") False","solution":"def is_palindrome(s): Determines if a given string is a palindrome, considering only alphanumeric characters and ignoring cases. def is_alphanumeric(c): return c.isalnum() filtered_chars = [char.lower() for char in s if is_alphanumeric(char)] return filtered_chars == filtered_chars[::-1]"},{"question":"def longest_positive_subarray(n: int, temperatures: List[int]) -> int: Returns the length of the longest subarray with all positive temperatures. Args: n: An integer representing the number of days. temperatures: A list of integers representing the temperatures recorded on each day. Returns: An integer representing the length of the longest subarray where each temperature is positive. Examples: >>> longest_positive_subarray(7, [-1, 2, 3, 5, -2, 4, 6]) 3 >>> longest_positive_subarray(4, [-5, -2, -1, -3]) 0 >>> longest_positive_subarray(5, [1, 2, 3, 4, 5]) 5","solution":"def longest_positive_subarray(n, temperatures): Returns the length of the longest subarray with all positive temperatures. max_length = 0 current_length = 0 for temp in temperatures: if temp > 0: current_length += 1 max_length = max(max_length, current_length) else: current_length = 0 return max_length"},{"question":"def min_operations_to_single_element(n: int, array: List[int]) -> int: Calculate the minimum number of operations required to reduce the array to a single element. In one operation, you can pick any two elements a_i and a_j (1 ≤ i < j ≤ n) and if a_i % a_j == 0 or a_j % a_i == 0, you can delete the larger of the two elements. Args: n : int : the size of the array array : List[int] : the elements of the array Returns: int : the minimum number of operations to reduce the array to a single element. Examples: >>> min_operations_to_single_element(4, [2, 3, 6, 9]) 2 >>> min_operations_to_single_element(5, [10, 5, 15, 20, 25]) 4","solution":"def min_operations_to_single_element(n, array): array.sort() delete_count = 0 for i in range(n-1, 0, -1): for j in range(i-1, -1, -1): if array[i] % array[j] == 0: delete_count += 1 break return delete_count"},{"question":"def count_improving_periods(scores): Analyze the performance of employees by finding the number of consecutive days where the performance was consistently improving. Args: scores: List[int], a list of integers representing daily performance scores. Returns: int: the number of improving periods. Examples: >>> count_improving_periods([3, 4, 5, 2, 1, 3, 4, 5]) 9 >>> count_improving_periods([10, 20, 30, 5, 6, 1]) 4 >>> count_improving_periods([8, 7, 6, 5]) 0 def test_count_improving_periods_example1(): assert count_improving_periods([3, 4, 5, 2, 1, 3, 4, 5]) == 9 def test_count_improving_periods_example2(): assert count_improving_periods([10, 20, 30, 5, 6, 1]) == 4 def test_count_improving_periods_example3(): assert count_improving_periods([8, 7, 6, 5]) == 0 def test_count_improving_periods_single_element(): assert count_improving_periods([5]) == 0 def test_count_improving_periods_all_increasing(): assert count_improving_periods([1, 2, 3, 4, 5]) == 10 def test_count_improving_periods_all_decreasing(): assert count_improving_periods([5, 4, 3, 2, 1]) == 0 def test_count_improving_periods_constant(): assert count_improving_periods([5, 5, 5, 5, 5]) == 0 def test_count_improving_periods_mixed(): assert count_improving_periods([1, 2, 3, 2, 3, 4, 1, 2, 3]) == 9","solution":"def count_improving_periods(scores): n = len(scores) count = 0 length = 1 for i in range(1, n): if scores[i] > scores[i-1]: length += 1 count += (length - 1) else: length = 1 return count"},{"question":"def is_valid_sudoku(grid: List[List[int]]) -> bool: Determine if a partially filled n x n Sudoku grid is valid. >>> is_valid_sudoku([ [5, 3, 0, 0, 7, 0, 0, 0, 0], [6, 0, 0, 1, 9, 5, 0, 0, 0], [0, 9, 8, 0, 0, 0, 0, 6, 0], [8, 0, 0, 0, 6, 0, 0, 0, 3], [4, 0, 0, 8, 0, 3, 0, 0, 1], [7, 0, 0, 0, 2, 0, 0, 0, 6], [0, 6, 0, 0, 0, 0, 2, 8, 0], [0, 0, 0, 4, 1, 9, 0, 0, 5], [0, 0, 0, 0, 8, 0, 0, 7, 9] ]) True >>> is_valid_sudoku([ [5, 3, 0, 0, 7, 9, 0, 0, 0], [6, 0, 0, 1, 9, 5, 0, 0, 0], [0, 9, 8, 0, 0, 0, 0, 6, 0], [8, 0, 0, 0, 6, 0, 0, 0, 3], [4, 0, 0, 8, 0, 3, 0, 0, 1], [7, 0, 0, 0, 2, 0, 0, 0, 6], [0, 6, 0, 0, 0, 0, 2, 8, 0], [0, 0, 0, 4, 1, 9, 0, 0, 5], [0, 0, 0, 0, 8, 0, 0, 7, 9] ]) False pass def solve_sudoku_puzzles(puzzles: List[List[List[int]]]) -> List[bool]: Solve multiple sudoku puzzles and return results. >>> solve_sudoku_puzzles([ [ [5, 3, 0, 0, 7, 0, 0, 0, 0], [6, 0, 0, 1, 9, 5, 0, 0, 0], [0, 9, 8, 0, 0, 0, 0, 6, 0], [8, 0, 0, 0, 6, 0, 0, 0, 3], [4, 0, 0, 8, 0, 3, 0, 0, 1], [7, 0, 0, 0, 2, 0, 0, 0, 6], [0, 6, 0, 0, 0, 0, 2, 8, 0], [0, 0, 0, 4, 1, 9, 0, 0, 5], [0, 0, 0, 0, 8, 0, 0, 7, 9] ], [ [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] ] ]) [True, True] pass","solution":"def is_valid_sudoku(grid): n = len(grid) sqrt_n = int(n**0.5) def is_valid_block(block): nums = [num for num in block if num != 0] return len(nums) == len(set(nums)) for row in grid: if not is_valid_block(row): return False for col in zip(*grid): if not is_valid_block(col): return False for i in range(0, n, sqrt_n): for j in range(0, n, sqrt_n): block = [grid[x][y] for x in range(i, i + sqrt_n) for y in range(j, j + sqrt_n)] if not is_valid_block(block): return False return True def solve_sudoku_puzzles(puzzles): results = [] for puzzle in puzzles: results.append(is_valid_sudoku(puzzle)) return results"},{"question":"def sorted_squares_non_negative(lst: List[int]) -> List[int]: Returns a new list with the squares of all non-negative integers from the input list, sorted in non-decreasing order. >>> sorted_squares_non_negative([-4, -2, 0, 3, 5]) [0, 9, 25] >>> sorted_squares_non_negative([1, -1, 2, 3]) [1, 4, 9] >>> sorted_squares_non_negative([0, -3, -1, 1, 2]) [0, 1, 4]","solution":"def sorted_squares_non_negative(lst): Returns a new list with the squares of all non-negative integers from the input list, sorted in non-decreasing order. non_negative_squares = [x**2 for x in lst if x >= 0] return sorted(non_negative_squares)"},{"question":"def daily_temperatures(temperatures): For each day, calculate the number of days you have to wait for a warmer temperature. Args: temperatures (List[int]): List of daily temperatures. Returns: List[int]: List representing the number of days you have to wait for a warmer temperature. Examples: >>> daily_temperatures([73, 74, 75, 71, 69, 72, 76]) [1, 1, 4, 2, 1, 1, 0] >>> daily_temperatures([30, 40, 50, 60, 70]) [1, 1, 1, 1, 0]","solution":"def daily_temperatures(temperatures): For each day, calculate the number of days you have to wait for a warmer temperature. n = len(temperatures) answer = [0] * n stack = [] # Stack to keep track of days for today in range(n): while stack and temperatures[today] > temperatures[stack[-1]]: prev_day = stack.pop() answer[prev_day] = today - prev_day stack.append(today) return answer"},{"question":"def count_subarrays_with_sum(arr, T): Returns the number of subarrays whose sum is exactly T. >>> count_subarrays_with_sum([1, 2, 3, -2, 2], 5) 2 >>> count_subarrays_with_sum([0, 0, 0, 0], 0) 10","solution":"def count_subarrays_with_sum(arr, T): Returns the number of subarrays whose sum is exactly T. from collections import defaultdict # Initialize variables current_sum = 0 subarray_count = 0 prefix_sums = defaultdict(int) prefix_sums[0] = 1 # To handle the case when subarray itself is exactly T for num in arr: current_sum += num # If there is a prefix sum such that current_sum - prefix_sum = T, we found a valid subarray subarray_count += prefix_sums.get(current_sum - T, 0) # Update the prefix_sums dictionary prefix_sums[current_sum] += 1 return subarray_count"},{"question":"def find_closest_star(reference, stars): Finds the closest star to the reference point using Euclidean distance. :param reference: Tuple (x, y) representing the reference point coordinates. :param stars: List of tuples [(x1, y1), (x2, y2), ...] representing star coordinates. :return: Tuple (xi, yi) representing the coordinates of the closest star. pass def test_closest_star(): assert find_closest_star((0, 0), [(1, 2), (2, 3), (-1, 4)]) == (1, 2) assert find_closest_star((3, 4), [(5, 1), (1, 7)]) in [(5, 1), (1, 7)] assert find_closest_star((10, 10), [(8, 9), (12, 12), (10, 13), (15, 10), (10, 20)]) == (8, 9)","solution":"import math def find_closest_star(reference, stars): Finds the closest star to the reference point using Euclidean distance. :param reference: Tuple (x, y) representing the reference point coordinates. :param stars: List of tuples [(x1, y1), (x2, y2), ...] representing star coordinates. :return: Tuple (xi, yi) representing the coordinates of the closest star. def euclidean_distance(p1, p2): Calculates the Euclidean distance between two points. :param p1: Tuple (x1, y1) for the first point. :param p2: Tuple (x2, y2) for the second point. :return: Euclidean distance between p1 and p2. return math.sqrt((p2[0] - p1[0])**2 + (p2[1] - p1[1])**2) min_distance = float('inf') closest_star = None for star in stars: distance = euclidean_distance(reference, star) if distance < min_distance: min_distance = distance closest_star = star return closest_star"},{"question":"from typing import List, Tuple def can_rearrange_grades(test_cases: List[Tuple[int, List[int]]]) -> List[str]: Determine if grades can be rearranged to satisfy the condition that the difference between any two consecutive grades is at most 1. Args: test_cases (List[Tuple[int, List[int]]]): List containing test case tuples. Each tuple has an integer number of students and a list of grades. Returns: List[str]: List containing \\"YES\\" or \\"NO\\" for each test case indicating if the grades can be rearranged to satisfy the condition. >>> can_rearrange_grades([(4, [1, 3, 2, 2]), (3, [5, 5, 5]), (5, [8, 7, 6, 5, 4])]) ['YES', 'YES', 'YES'] >>> can_rearrange_grades([(3, [1, 3, 5]), (4, [0, 2, 4, 6])]) ['NO', 'NO'] # Function implementation goes here from solution import can_rearrange_grades def test_can_rearrange_grades(): test_cases = [ (4, [1, 3, 2, 2]), (3, [5, 5, 5]), (5, [8, 7, 6, 5, 4]) ] expected = [\\"YES\\", \\"YES\\", \\"YES\\"] assert can_rearrange_grades(test_cases) == expected test_cases = [ (4, [1, 2, 3, 4]), (6, [0, 1, 1, 2, 3, 3]), ] expected = [\\"YES\\", \\"YES\\"] assert can_rearrange_grades(test_cases) == expected test_cases = [ (3, [1, 3, 5]), (4, [0, 2, 4, 6]) ] expected = [\\"NO\\", \\"NO\\"] assert can_rearrange_grades(test_cases) == expected test_cases = [ (1, [0]), (1, [10]) ] expected = [\\"YES\\", \\"YES\\"] assert can_rearrange_grades(test_cases) == expected test_cases = [ (3, [2, 2, 2]), (4, [3, 3, 3, 3]) ] expected = [\\"YES\\", \\"YES\\"] assert can_rearrange_grades(test_cases) == expected","solution":"def can_rearrange_grades(test_cases): results = [] for case in test_cases: n, grades = case grades.sort() possible = True for i in range(1, n): if grades[i] - grades[i-1] > 1: possible = False break results.append(\\"YES\\" if possible else \\"NO\\") return results"},{"question":"def findNthNumber(N: int) -> int: Given an integer N, generate a sequence of numbers such that the next number in the sequence is the sum of the squares of the digits of the current number. Returns the N-th number in this sequence starting with 1. >>> findNthNumber(3) 1 >>> findNthNumber(5) 1 >>> findNthNumber(10) 1","solution":"def sum_of_squares_of_digits(n): Returns the sum of the squares of the digits of 'n'. return sum(int(digit) ** 2 for digit in str(n)) def findNthNumber(N): Returns the N-th number in the sequence starting with 1 where the next number in the sequence is the sum of the squares of the digits of the current number. current_number = 1 for _ in range(1, N): current_number = sum_of_squares_of_digits(current_number) return current_number"},{"question":"def longest_distinct_sequence(s: str) -> int: Returns the length of the longest sequence of distinct characters obtainable after swapping any two different characters in the string. >>> longest_distinct_sequence('abc') == 3 >>> longest_distinct_sequence('aaaa') == 1 >>> longest_distinct_sequence('abacaba') == 3 >>> longest_distinct_sequence('zzz') == 1 >>> longest_distinct_sequence('qwerty') == 6 >>> longest_distinct_sequence('aabbccdd') == 4 def process_test_cases(test_cases: List[str]) -> List[int]: Processes multiple test cases and returns the result for each. >>> process_test_cases(['abc', 'aaaa', 'abacaba']) == [3, 1, 3] >>> process_test_cases(['hello', 'world']) == [4, 5] >>> process_test_cases(['a', 'bb', 'ccc', 'dddd']) == [1, 1, 1, 1]","solution":"def longest_distinct_sequence(s): Returns the length of the longest sequence of distinct characters obtainable after swapping any two different characters in the string. return len(set(s)) def process_test_cases(test_cases): Processes multiple test cases and returns the result for each. results = [] for s in test_cases: results.append(longest_distinct_sequence(s)) return results"},{"question":"def count_alphabetical_substrings(s: str) -> int: Returns the count of substrings of 's' where the letters are in non-decreasing alphabetical order. >>> count_alphabetical_substrings(\\"abcdf\\") 15 >>> count_alphabetical_substrings(\\"abac\\") 6 >>> count_alphabetical_substrings(\\"aaaa\\") 10 >>> count_alphabetical_substrings(\\"a\\") 1 >>> count_alphabetical_substrings(\\"dcba\\") 4 >>> count_alphabetical_substrings(\\"\\") 0","solution":"def count_alphabetical_substrings(s): Returns the count of substrings of 's' where the letters are in non-decreasing alphabetical order. n = len(s) count = 0 i = 0 # Traverse the string while i < n: length = 1 # Add substrings starting at position i, extending while we have a non-decreasing order while i + length < n and s[i + length - 1] <= s[i + length]: length += 1 # The number of substrings that can start at i with the current found length count += (length * (length + 1)) // 2 # Move i to the end of the current non-decreasing segment i += length return count"},{"question":"def largest_rectangle_area(heights): This function calculates the area of the largest rectangle that can be formed in the skyline represented by the array 'heights' where each building has a width of 1. >>> largest_rectangle_area([2, 1, 5, 6, 2, 3, 4]) 10 >>> largest_rectangle_area([2, 4]) 4 >>> largest_rectangle_area([6, 7, 5, 2, 4, 5, 9, 3]) 16 >>> largest_rectangle_area([1, 1, 1, 1, 1, 1]) 6 >>> largest_rectangle_area([1]) 1 >>> largest_rectangle_area([2, 1, 2]) 3 >>> largest_rectangle_area([0, 9]) 9 >>> largest_rectangle_area([5, 4, 1, 2]) 8 >>> largest_rectangle_area([]) 0 >>> largest_rectangle_area([0, 0, 0, 0]) 0 >>> largest_rectangle_area([3, 3, 3, 3]) 12","solution":"def largest_rectangle_area(heights): This function calculates the area of the largest rectangle that can be formed in the skyline represented by the array 'heights' where each building has a width of 1. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"def calculate_total_profit(T, test_cases): Calculate total profit for given test cases. Parameters: T (int): Number of test cases test_cases (list of tuples): Each tuple contains (N, C, S, packs_sold_per_day) Returns: list of int: List of total profits for each test case Example: >>> T = 2 >>> test_cases = [ ... (3, 100, 150, [10, 20, 30]), ... (4, 90, 120, [5, 5, 10, 5]) ... ] >>> calculate_total_profit(T, test_cases) [3000, 750] # Test cases def test_sample_input(): T = 2 test_cases = [ (3, 100, 150, [10, 20, 30]), (4, 90, 120, [5, 5, 10, 5]) ] assert calculate_total_profit(T, test_cases) == [3000, 750] def test_single_test_case(): T = 1 test_cases = [ (2, 50, 100, [20, 30]) ] assert calculate_total_profit(T, test_cases) == [2500] def test_no_packs_sold(): T = 1 test_cases = [ (3, 100, 150, [0, 0, 0]) ] assert calculate_total_profit(T, test_cases) == [0] def test_high_volume(): T = 1 test_cases = [ (5, 20, 40, [100, 200, 300, 400, 500]) ] assert calculate_total_profit(T, test_cases) == [30000] def test_edge_case(): T = 1 test_cases = [ (1, 1, 1, [1]) ] assert calculate_total_profit(T, test_cases) == [0]","solution":"def calculate_total_profit(T, test_cases): Calculate total profit for given test cases. Parameters: T (int): Number of test cases test_cases (list of tuples): Each tuple contains (N, C, S, packs_sold_per_day) Returns: list of int: List of total profits for each test case results = [] for test_case in test_cases: N, C, S, days_packs_sold = test_case total_packs_sold = sum(days_packs_sold) total_revenue = total_packs_sold * S total_cost = total_packs_sold * C total_profit = total_revenue - total_cost results.append(total_profit) return results # Example usage: # T = 2 # test_cases = [ # (3, 100, 150, [10, 20, 30]), # (4, 90, 120, [5, 5, 10, 5]) # ] # print(calculate_total_profit(T, test_cases)) # Output: [3000, 750]"},{"question":"def smallest_lexicographical_sequence(test_cases): Given a list of test cases, each containing a number of strings, returns a list of the smallest possible lexicographical sequences of all distinct characters that can be formed using any subsequence of the strings. >>> smallest_lexicographical_sequence([(1, ['abc'])]) ['abc'] >>> smallest_lexicographical_sequence([(2, ['xyz', 'bcd'])]) ['bcdxyz'] >>> smallest_lexicographical_sequence([(3, ['abc', 'bcd', 'cde'])]) ['abcde'] >>> smallest_lexicographical_sequence([(3, ['abc', 'cde', 'xyz'])]) ['abcde'] >>> smallest_lexicographical_sequence([(2, ['aaa', 'bbb'])]) ['ab']","solution":"def smallest_lexicographical_sequence(test_cases): Given a list of test cases, each containing a number of strings, returns a list of the smallest possible lexicographical sequences of all distinct characters that can be formed using any subsequence of the strings. results = [] for test_case in test_cases: N, strings = test_case unique_chars = set() for s in strings: unique_chars.update(s) sorted_chars = sorted(unique_chars) results.append(''.join(sorted_chars)) return results"},{"question":"def is_palindrome(num): Returns 'Yes' if num is a palindrome, otherwise 'No'. def check_palindromes(datasets): Accepts a list of integers and returns a list of 'Yes' or 'No' strings indicating whether each integer is a palindrome. from solution import is_palindrome, check_palindromes def test_is_palindrome(): assert is_palindrome(121) == \\"Yes\\" assert is_palindrome(12321) == \\"Yes\\" assert is_palindrome(123) == \\"No\\" assert is_palindrome(1001) == \\"Yes\\" assert is_palindrome(1221) == \\"Yes\\" assert is_palindrome(123456) == \\"No\\" assert is_palindrome(1) == \\"Yes\\" assert is_palindrome(0) == \\"Yes\\" def test_check_palindromes(): datasets = [121, 12321, 123, 1001, 1221] expected_results = [\\"Yes\\", \\"Yes\\", \\"No\\", \\"Yes\\", \\"Yes\\"] assert check_palindromes(datasets) == expected_results datasets = [123456, 654321, 11111, 123454321, 1331] expected_results = [\\"No\\", \\"No\\", \\"Yes\\", \\"Yes\\", \\"Yes\\"] assert check_palindromes(datasets) == expected_results datasets = [922, 13331, 111, 100001, 987654321] expected_results = [\\"No\\", \\"Yes\\", \\"Yes\\", \\"Yes\\", \\"No\\"] assert check_palindromes(datasets) == expected_results","solution":"def is_palindrome(num): Returns 'Yes' if num is a palindrome, otherwise 'No'. num_str = str(num) if num_str == num_str[::-1]: return \\"Yes\\" else: return \\"No\\" def check_palindromes(datasets): Accepts a list of integers and returns a list of 'Yes' or 'No' strings indicating whether each integer is a palindrome. results = [] for num in datasets: results.append(is_palindrome(num)) return results"},{"question":"class Battleship: def __init__(self, size): Initializes the game board of given size (size x size) and sets up an empty board for each player. def place_ship(self, player, ship_length, coordinates, orientation): Places a ship for a player on the board. Args: player (int): The player number (1 or 2). ship_length (int): The length of the ship. coordinates (tuple): The starting coordinate to place the ship (row, col). orientation (str): The orientation of the ship ('H' for horizontal, 'V' for vertical). Returns: bool: True if the ship can be placed successfully, False otherwise. def attack(self, player, coordinates): Registers an attack by the player on the opponent's board and returns the outcome. Args: player (int): The attacking player number (1 or 2). coordinates (tuple): The target coordinate (row, col) to attack. Returns: str: \\"Hit\\" if an opponent’s ship is hit. \\"Miss\\" if the attack missed. \\"Player X wins!\\" if the attack sinks the last ship of the opponent, where X is the attacking player number. # Unit Tests def test_init(): game = Battleship(5) assert len(game.boards[1]) == 5 assert len(game.boards[2]) == 5 assert all(len(row) == 5 for row in game.boards[1]) assert all(len(row) == 5 for row in game.boards[2]) def test_place_ship_success(): game = Battleship(5) assert game.place_ship(1, 3, (2, 1), 'H') == True assert game.boards[1][2][1:4] == ['S', 'S', 'S'] def test_place_ship_out_of_bounds(): game = Battleship(5) assert game.place_ship(1, 3, (2, 3), 'H') == False assert game.place_ship(1, 3, (4, 2), 'V') == False def test_place_ship_overlap(): game = Battleship(5) assert game.place_ship(1, 3, (2, 1), 'H') == True assert game.place_ship(1, 2, (2, 2), 'V') == False def test_attack_hit(): game = Battleship(5) game.place_ship(2, 2, (2, 2), 'V') assert game.attack(1, (2, 2)) == \\"Hit\\" assert game.boards[2][2][2] == 'H' def test_attack_miss(): game = Battleship(5) game.place_ship(2, 2, (2, 2), 'V') assert game.attack(1, (1, 1)) == \\"Miss\\" assert game.boards[2][1][1] == 'M' def test_attack_repeated_miss(): game = Battleship(5) game.place_ship(2, 2, (2, 2), 'V') game.attack(1, (1, 1)) assert game.attack(1, (1, 1)) == \\"Miss\\" def test_player_wins(): game = Battleship(5) game.place_ship(2, 1, (2, 2), 'H') assert game.attack(1, (2, 2)) == \\"Player 1 wins!\\"","solution":"class Battleship: def __init__(self, size): self.size = size self.boards = {1: [['.' for _ in range(size)] for _ in range(size)], 2: [['.' for _ in range(size)] for _ in range(size)]} self.ships = {1: [], 2: []} def place_ship(self, player, ship_length, coordinates, orientation): board = self.boards[player] row, col = coordinates # Check if placement is within bounds and valid if orientation == 'H': if col + ship_length > self.size: return False for i in range(ship_length): if board[row][col+i] != '.': return False for i in range(ship_length): board[row][col+i] = 'S' elif orientation == 'V': if row + ship_length > self.size: return False for i in range(ship_length): if board[row+i][col] != '.': return False for i in range(ship_length): board[row+i][col] = 'S' self.ships[player].append((ship_length, coordinates, orientation)) return True def attack(self, player, coordinates): opponent = 2 if player == 1 else 1 board = self.boards[opponent] row, col = coordinates if board[row][col] == 'S': board[row][col] = 'H' if self.check_win(opponent): return f\\"Player {player} wins!\\" return \\"Hit\\" elif board[row][col] == '.': board[row][col] = 'M' return \\"Miss\\" else: # already 'H' or 'M' return \\"Miss\\" def check_win(self, player): board = self.boards[player] for row in board: if 'S' in row: return False return True"},{"question":"def find_peak_activity_hour(posts: List[int]) -> int: Returns the hour when the user is most active. If there are multiple hours with the same maximum activity, returns the earliest hour. Args: posts (list): List of 24 integers representing the number of posts in each hour. Returns: int: The hour when the user is most active. >>> find_peak_activity_hour([3, 5, 0, 6, 2, 8, 4, 1, 7, 6, 8, 9, 12, 15, 7, 4, 3, 6, 2, 1, 4, 5, 2, 11]) 13 >>> find_peak_activity_hour([10, 15, 15, 10, 8, 8, 16, 16, 3, 2, 1, 0, 12, 14, 9, 6, 4, 5, 11, 7, 19, 10, 10, 10]) 20","solution":"def find_peak_activity_hour(posts): Returns the hour when the user is most active. If there are multiple hours with the same maximum activity, returns the earliest hour. Args: posts (list): List of 24 integers representing the number of posts in each hour. Returns: int: The hour when the user is most active. max_posts = max(posts) peak_hour = posts.index(max_posts) return peak_hour"},{"question":"def maxPathSum(grid: List[List[int]]) -> int: Given a grid of size NxN filled with integers between 1 and 9, find the maximum sum of numbers you can collect on a path to the bottom-right corner, starting from the top-left corner, while you can only move either right or down. >>> maxPathSum([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 29 >>> maxPathSum([[1, 1, 1], [1, 1, 1], [1, 1, 1]]) 5 pass def test_example1(): grid = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] assert maxPathSum(grid) == 29 def test_example2(): grid = [[1, 1, 1], [1, 1, 1], [1, 1, 1]] assert maxPathSum(grid) == 5 def test_single_element(): assert maxPathSum([[5]]) == 5 def test_two_by_two_grid(): grid = [[2, 2], [2, 2]] assert maxPathSum(grid) == 6 def test_larger_grid(): grid = [[9, 3, 1, 5], [7, 2, 8, 1], [2, 9, 4, 6], [5, 1, 9, 3]] assert maxPathSum(grid) == 43 def test_max_grid_size(): grid = [[9] * 50 for _ in range(50)] assert maxPathSum(grid) == 9 * 99","solution":"def maxPathSum(grid): n = len(grid) dp = [[0] * n for _ in range(n)] dp[0][0] = grid[0][0] for i in range(1, n): dp[i][0] = dp[i - 1][0] + grid[i][0] dp[0][i] = dp[0][i - 1] + grid[0][i] for i in range(1, n): for j in range(1, n): dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] return dp[n - 1][n - 1]"},{"question":"def is_mountain_array(arr: List[int]) -> bool: Check if a given list of integers forms a valid mountain array. >>> is_mountain_array([0, 3, 2, 1]) True >>> is_mountain_array([1, 2, 3, 4]) False >>> is_mountain_array([3, 5, 5, 2, 1, 0]) False >>> is_mountain_array([2, 1]) False >>> is_mountain_array([0, 1, 2, 3, 2, 1]) True def determine_mountain_arrays(test_cases: List[Tuple[int, List[int]]]) -> List[str]: Given a list of test cases, determine if the arrays form valid mountain arrays. >>> determine_mountain_arrays([(5, [0, 3, 2, 4, 1]), (4, [1, 2, 3, 4]), (6, [3, 5, 5, 2, 1, 0])]) ['Not a Mountain Array', 'Not a Mountain Array', 'Not a Mountain Array'] >>> determine_mountain_arrays([(5, [2, 3, 2, 1, 0]), (6, [0, 1, 2, 3, 2, 1]), (6, [3, 4, 5, 2, 1, 0])]) ['Mountain Array', 'Mountain Array', 'Mountain Array']","solution":"def is_mountain_array(arr): if len(arr) < 3: return False increasing = False peak_reached = False for i in range(1, len(arr)): if arr[i] == arr[i - 1]: return False if not peak_reached: if arr[i] > arr[i - 1]: increasing = True elif increasing and arr[i] < arr[i - 1]: peak_reached = True else: return False else: if arr[i] >= arr[i - 1]: return False return increasing and peak_reached def determine_mountain_arrays(test_cases): results = [] for tc in test_cases: N, arr = tc if is_mountain_array(arr): results.append(\\"Mountain Array\\") else: results.append(\\"Not a Mountain Array\\") return results"},{"question":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def serialize_binary_tree(root: TreeNode) -> str: Serialize a binary tree to a string using pre-order traversal. >>> root = TreeNode(1, TreeNode(2), TreeNode(3, TreeNode(4), TreeNode(5))) >>> serialize_binary_tree(root) '1,2,None,None,3,4,None,None,5,None,None' >>> serialize_binary_tree(None) 'None' >>> root = TreeNode(1) >>> serialize_binary_tree(root) '1,None,None' pass def deserialize_binary_tree(data: str) -> TreeNode: Deserialize a string to a binary tree using pre-order traversal. >>> serialized = '1,2,None,None,3,4,None,None,5,None,None' >>> root = deserialize_binary_tree(serialized) >>> root.value 1 >>> root.left.value 2 >>> root.right.value 3 >>> root.right.left.value 4 >>> root.right.right.value 5 >>> serialized = 'None' >>> root = deserialize_binary_tree(serialized) >>> root is None True >>> serialized = '1,None,None' >>> root = deserialize_binary_tree(serialized) >>> root.value 1 >>> root.left is None True >>> root.right is None True pass","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def serialize_binary_tree(root: TreeNode) -> str: def helper(node): if node is None: return \\"None\\" return f\\"{node.value},{helper(node.left)},{helper(node.right)}\\" return helper(root) def deserialize_binary_tree(data: str) -> TreeNode: def helper(values): if values[0] == \\"None\\": values.pop(0) return None node = TreeNode(int(values.pop(0))) node.left = helper(values) node.right = helper(values) return node values = data.split(',') return helper(values)"},{"question":"def caesar_cipher(text: str, k: int) -> str: Encrypts the given text using Caesar Cipher with a specified shift value. The Caesar Cipher involves shifting each letter of the plaintext by a fixed number of positions down the alphabet. Both uppercase and lowercase letters are shifted, while punctuation marks remain unchanged. Args: text (str): The text to be encrypted. k (int): The shift value (1 ≤ k ≤ 25). Returns: str: The encrypted text. Examples: >>> caesar_cipher(\\"Hello, World!\\", 5) 'Mjqqt, Btwqi!' >>> caesar_cipher(\\"abc, XYZ!\\", 3) 'def, ABC!'","solution":"def caesar_cipher(text, k): Encrypts the given text using Caesar Cipher with a shift value of k. Only letters are shifted, other characters remain unchanged. encrypted_text = [] for char in text: if char.isalpha(): shift = k % 26 if char.islower(): new_char = chr((ord(char) - ord('a') + shift) % 26 + ord('a')) else: new_char = chr((ord(char) - ord('A') + shift) % 26 + ord('A')) encrypted_text.append(new_char) else: encrypted_text.append(char) return ''.join(encrypted_text)"},{"question":"def firstNonRepeating(arr): Returns the first non-repeating integer in the array or \\"None\\" if there is no non-repeating integer. :param arr: List[int] - an array of integers. :return: int or str - the first non-repeating integer or \\"None\\". >>> firstNonRepeating([4, 5, 1, 2, 2, 1, 3, 4]) 5 >>> firstNonRepeating([3, 3, 4, 4, 5]) 5 >>> firstNonRepeating([1, 1, 2, 2, 3, 3]) \\"None\\" >>> firstNonRepeating([100]) 100 >>> firstNonRepeating([5, 3, 5]) 3 >>> firstNonRepeating(list(range(1000)) + list(range(999))) 999","solution":"def firstNonRepeating(arr): Returns the first non-repeating integer in the array or \\"None\\" if there is no non-repeating integer. count = {} for num in arr: if num in count: count[num] += 1 else: count[num] = 1 for num in arr: if count[num] == 1: return num return \\"None\\""},{"question":"def max_priority(n, m, priorities, capabilities): Determine the maximum total priority that can be achieved by assigning tasks to employees, ensuring that no task is assigned more than once and that an employee only performs tasks they are capable of. Args: n : int : number of employees m : int : number of tasks priorities : List[int] : list of priority values for the tasks capabilities : List[List[int]] : 2D list where capabilities[i][j] is 1 if the i-th employee can perform the j-th task, and 0 otherwise Returns: int : the maximum total priority that can be achieved Example: >>> n, m = 4, 5 >>> priorities = [10, 5, 6, 10, 8] >>> capabilities = [ ... [1, 0, 1, 0, 1], ... [0, 1, 0, 1, 1], ... [1, 0, 0, 0, 1], ... [0, 1, 1, 1, 0], ... ] >>> max_priority(n, m, priorities, capabilities) 34 # Implementation here from solution import max_priority def test_max_priority_case1(): n, m = 4, 5 priorities = [10, 5, 6, 10, 8] capabilities = [ [1, 0, 1, 0, 1], [0, 1, 0, 1, 1], [1, 0, 0, 0, 1], [0, 1, 1, 1, 0], ] assert max_priority(n, m, priorities, capabilities) == 34 def test_max_priority_case2(): n, m = 2, 3 priorities = [7, 10, 5] capabilities = [ [1, 0, 1], [0, 1, 1] ] assert max_priority(n, m, priorities, capabilities) == 17 def test_max_priority_case3(): n, m = 3, 3 priorities = [15, 20, 25] capabilities = [ [1, 0, 0], [0, 1, 0], [0, 0, 1] ] assert max_priority(n, m, priorities, capabilities) == 60 def test_max_priority_case4(): n, m = 3, 3 priorities = [1, 2, 3] capabilities = [ [1, 1, 1], [1, 1, 1], [1, 1, 1] ] assert max_priority(n, m, priorities, capabilities) == 6 def test_max_priority_case5(): n, m = 1, 1 priorities = [5] capabilities = [ [1] ] assert max_priority(n, m, priorities, capabilities) == 5","solution":"def max_priority(n, m, priorities, capabilities): from itertools import permutations max_total_priority = 0 task_indices = range(m) task_permutations = permutations(task_indices, n) for perm in task_permutations: current_priority = 0 used_tasks = set() for employee in range(n): task = perm[employee] if task not in used_tasks and capabilities[employee][task] == 1: current_priority += priorities[task] used_tasks.add(task) max_total_priority = max(max_total_priority, current_priority) return max_total_priority # Test case n, m = 4, 5 priorities = [10, 5, 6, 10, 8] capabilities = [ [1, 0, 1, 0, 1], [0, 1, 0, 1, 1], [1, 0, 0, 0, 1], [0, 1, 1, 1, 0], ] print(max_priority(n, m, priorities, capabilities)) # Output: 34"},{"question":"def max_possible_average(scores: List[int]) -> int: Determine the maximum possible average score by removing at most one student's score from the list. If the list has fewer than 2 scores, the output should be the average of the scores in their original form. >>> max_possible_average([50]) 50 >>> max_possible_average([50, 70]) 70 >>> max_possible_average([70, 80, 90]) 85 >>> max_possible_average([100, 50, 75]) 87 >>> max_possible_average([80, 80, 80]) 80 >>> max_possible_average([100] * 100) 100 >>> max_possible_average([0, 100, 100, 100, 100]) 100 >>> max_possible_average([0, 0, 0]) 0 pass","solution":"def max_possible_average(scores): if len(scores) < 2: return sum(scores) // len(scores) total_sum = sum(scores) max_average = total_sum // len(scores) for score in scores: new_average = (total_sum - score) // (len(scores) - 1) max_average = max(max_average, new_average) return max_average # Example usage: # input_scores = list(map(int, \\"70 80 90\\".split())) # print(max_possible_average(input_scores)) # Output should be 85"},{"question":"from typing import List, Tuple def trap_rain_water(height: List[int]) -> int: Calculates the total amount of rainwater trapped within the line after it rains. >>> trap_rain_water([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) == 6 >>> trap_rain_water([4, 2, 0, 3, 2, 5]) == 9 >>> trap_rain_water([0, 0, 0]) == 0 >>> trap_rain_water([4]) == 0 >>> trap_rain_water([3, 0, 2, 0, 4]) == 7 >>> trap_rain_water([1, 1, 1, 1, 1]) == 0 pass def process_test_cases(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Processes multiple test cases for calculating the total amount of trapped rainwater. >>> process_test_cases(2, [(12, [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]), (6, [4, 2, 0, 3, 2, 5])]) == [6, 9] >>> process_test_cases(1, [(4, [4, 1, 1, 4])]) == [6] >>> process_test_cases(0, []) == [] pass","solution":"def trap_rain_water(height): Calculates the total amount of rainwater trapped within the line after it rains. if not height or len(height) < 3: return 0 n = len(height) left_max = [0] * n right_max = [0] * n left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i-1], height[i]) right_max[n-1] = height[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], height[i]) trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - height[i] return trapped_water def process_test_cases(T, test_cases): results = [] for i in range(T): n = test_cases[i][0] height = test_cases[i][1] result = trap_rain_water(height) results.append(result) return results"},{"question":"def smallest_absent_integer(N: int, A: List[int], K: int, operations: List[Tuple[int, int, int]]) -> int: Determines the smallest integer not present in the list after performing all addition operations. >>> smallest_absent_integer(5, [3, 4, 5, 6, 7], 3, [(1, 3, 2), (2, 4, 1), (1, 5, 3)]) 1 >>> smallest_absent_integer(1, [1], 0, []) 2 >>> smallest_absent_integer(3, [1, 2, 3], 0, []) 4 >>> smallest_absent_integer(4, [1, 2, 3, 4], 2, [(1, 4, 1), (1, 4, 2)]) 1 >>> smallest_absent_integer(100000, list(range(1, 100001)), 1, [(1, 100000, 1000000)]) 1","solution":"def smallest_absent_integer(N, A, K, operations): # Step 1: Apply the operations to the list A and generate the final list B B = A[:] for L, R, X in operations: for j in range(L-1, R): B[j] += X # Step 2: Find the smallest non-present integer in B B_set = set(B) C = 1 while C in B_set: C += 1 return C"},{"question":"def max_profit(prices): Returns the maximum profit obtainable from a list of given prices. >>> max_profit([7, 1, 5, 3, 6, 4]) 5 >>> max_profit([7, 6, 4, 3, 1]) 0 >>> max_profit([1, 2, 3, 4, 5]) 4 >>> max_profit([5, 4, 3, 2, 1]) 0 >>> max_profit([5]) 0 >>> max_profit([1, 2]) 1 >>> max_profit([2, 1]) 0 def process_input(input_data): Process the input data and return the maximum profits for each dataset. >>> process_input(\\"7 1 5 3 6 4n7 6 4 3 1n1 2 3 4 5n\\") [5, 0, 4] datasets = input_data.strip().split('n') results = [] for data in datasets: prices = list(map(int, data.split())) results.append(max_profit(prices)) return results","solution":"def max_profit(prices): Returns the maximum profit obtainable from a list of given prices. if not prices or len(prices) < 2: return 0 min_price = float('inf') max_profit = 0 for price in prices: if price < min_price: min_price = price profit = price - min_price if profit > max_profit: max_profit = profit return max_profit def process_input(input_data): Process the input data and return the maximum profits for each dataset. datasets = input_data.strip().split('n') results = [] for data in datasets: prices = list(map(int, data.split())) results.append(max_profit(prices)) return results"},{"question":"def minBonus(ratings: List[int]) -> int: Calculate the minimum number of bonus points the company needs to distribute based on the performance ratings of the employees. >>> minBonus([1, 0, 2]) 5 >>> minBonus([1, 2, 2]) 4","solution":"def minBonus(ratings): n = len(ratings) if n == 0: return 0 bonus = [1] * n for i in range(1, n): if ratings[i] > ratings[i - 1]: bonus[i] = bonus[i - 1] + 1 for i in range(n - 2, -1, -1): if ratings[i] > ratings[i + 1]: bonus[i] = max(bonus[i], bonus[i + 1] + 1) return sum(bonus)"},{"question":"def total_revenue_for_ranges(T, test_cases): Given the number of test cases T and a list of test cases, each with daily revenues and range queries, calculate the total revenue for the specified ranges of days. Args: T: An integer, the number of test cases. test_cases: A list of dictionaries. Each dictionary has two keys: - 'revenues': A list of 365 integers, where the i-th integer represents the revenue on the i-th day. - 'queries': A list of tuples, where each tuple contains two integers (L, R) representing the range of days. Returns: A list of integers, where each integer is the total revenue for a query. Example: >>> T = 1 >>> test_cases = [{'revenues': [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] + [0]*355, 'queries': [(1, 10), (5, 7)]}] >>> total_revenue_for_ranges(T, test_cases) [55, 18] from solution import total_revenue_for_ranges def test_total_revenue_for_ranges_single_query(): T = 1 test_cases = [ {'revenues': [1] * 365, 'queries': [(1, 365)]} ] result = total_revenue_for_ranges(T, test_cases) assert result == [365] def test_total_revenue_for_ranges_multiple_queries(): T = 1 test_cases = [ { 'revenues': [5, 3, 8, 1, 2, 10, 12, 4, 6, 7] + [0] * 355, 'queries': [(1, 10), (5, 7)] } ] result = total_revenue_for_ranges(T, test_cases) assert result == [58, 24] def test_total_revenue_for_ranges_multiple_cases(): T = 2 test_cases = [ {'revenues': [1] * 365, 'queries': [(1, 365)]}, {'revenues': [2] * 365, 'queries': [(1, 180), (181, 365)]} ] result = total_revenue_for_ranges(T, test_cases) assert result == [365, 360, 370] def test_total_revenue_for_ranges_edge_case(): T = 1 test_cases = [ {'revenues': [i for i in range(1, 366)], 'queries': [(1, 1), (364, 365), (1, 365)]} ] result = total_revenue_for_ranges(T, test_cases) assert result == [1, 729, 66795]","solution":"def total_revenue_for_ranges(T, test_cases): results = [] for case_index in range(T): revenues = test_cases[case_index]['revenues'] queries = test_cases[case_index]['queries'] # Create a prefix sum array for the revenues prefix_sum = [0] * (365 + 1) for i in range(1, 366): prefix_sum[i] = prefix_sum[i-1] + revenues[i-1] for query in queries: L, R = query total_revenue = prefix_sum[R] - prefix_sum[L-1] results.append(total_revenue) return results"},{"question":"def maximize_product(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Alice is playing a game wherein she has an array of non-negative integers. She can perform the following operation as many times as she wants: - Choose any two different elements from the array and replace both of them with their bitwise OR. Her goal is to maximize the product of the elements in the array after performing the operations optimally. Since handling large numbers can be cumbersome, she is only interested in the product modulo (10^9 + 7). Args: T (int): The number of test cases. test_cases (List[Tuple[int, List[int]]]): A list of test cases where each test case is a tuple containing an integer N and a list of N non-negative integers. Returns: List[int]: A list of integers representing the maximum product of the array elements modulo (10^9 + 7) for each test case. Examples: >>> maximize_product(2, [(3, [2, 3, 5]), (4, [1, 2, 4, 8])]) [30, 64] from solution import maximize_product def test_maximize_product_case1(): T = 2 test_cases = [ (3, [2, 3, 5]), (4, [1, 2, 4, 8]) ] results = maximize_product(T, test_cases) assert results == [30, 64] def test_maximize_product_case2(): T = 1 test_case = [ (3, [5, 7, 8]) ] result = maximize_product(T, test_case) assert result == [280] def test_maximize_product_case3(): T = 1 test_case = [ (4, [0, 0, 0, 1]) ] result = maximize_product(T, test_case) assert result == [0] def test_maximize_product_case4(): T = 1 test_case = [ (2, [1000000000, 2000000000]) ] result = maximize_product(T, test_case) assert result == [(1000000000 * 2000000000) % (10**9 + 7)] def test_maximize_product_large_case(): T = 1 test_case = [ (5, [2, 4, 6, 8, 10]) ] result = maximize_product(T, test_case) assert result == [2 * 4 * 6 * 8 * 10 % (10**9 + 7)]","solution":"MOD = 10**9 + 7 def maximize_product(T, test_cases): results = [] for case in test_cases: N, array = case result = 1 for num in array: result = (result * num) % MOD results.append(result) return results # Reading input def read_input(): import sys input = sys.stdin.read data = input().split() T = int(data[0]) index = 1 test_cases = [] for _ in range(T): N = int(data[index]) array = list(map(int, data[index + 1: index + 1 + N])) test_cases.append((N, array)) index += N + 1 return T, test_cases if __name__ == \\"__main__\\": T, test_cases = read_input() results = maximize_product(T, test_cases) for result in results: print(result)"},{"question":"from collections import OrderedDict class LRUCache: A simplified version of the Least Recently Used (LRU) cache algorithm. Initialization of the LRU Cache with a fixed capacity. Methods: - put(key: int, value: int): Adds a key-value pair to the cache. If the cache reaches its capacity, it should invalidate the least recently used item before adding a new item. - get(key: int): Retrieves the value associated with the given key. If the key does not exist in the cache, return -1. Example 1: >>> lru = LRUCache(2) >>> lru.put(1, 1) >>> lru.put(2, 2) >>> lru.get(1) 1 >>> lru.put(3, 3) >>> lru.get(2) -1 >>> lru.put(4, 4) >>> lru.get(1) -1 >>> lru.get(3) 3 >>> lru.get(4) 4 Example 2: >>> lru = LRUCache(2) >>> lru.put(1, 10) >>> lru.put(2, 20) >>> lru.get(3) -1 >>> lru.put(3, 30) >>> lru.put(4, 40) >>> lru.get(1) -1 >>> lru.get(4) 40","solution":"from collections import OrderedDict class LRUCache: def __init__(self, capacity: int): self.cache = OrderedDict() self.capacity = capacity def get(self, key: int) -> int: if key not in self.cache: return -1 self.cache.move_to_end(key) return self.cache[key] def put(self, key: int, value: int) -> None: if key in self.cache: self.cache.move_to_end(key) self.cache[key] = value if len(self.cache) > self.capacity: self.cache.popitem(last=False)"},{"question":"def evaluateExpression(expression: str) -> float: Given a string representing a mathematical expression with positive integers and the operators +, -, *, and /, return the evaluated result as a float with a precision of two decimal places. >>> evaluateExpression(\\"3 + 5\\") 8.00 >>> evaluateExpression(\\"10 - 4 * 2\\") 2.00 >>> evaluateExpression(\\"14 / 3 + 2\\") 6.67 >>> evaluateExpression(\\"20 / 5 * 2 + 8\\") 16.00 pass # Implement the function here","solution":"def evaluateExpression(expression): Given a string representing a mathematical expression with positive integers and the operators +, -, *, and /, return the evaluated result as a float with a precision of two decimal places. # Using eval function to evaluate the expression result = eval(expression) # rounding the result to 2 decimal places result = round(result, 2) return result"},{"question":"def minimum_operations_to_equal_elements(t, cases): Returns the minimum number of operations to make all elements in each array case the same. Parameters: t (int): number of test cases cases (list): list of tuples with the first element being the size of the array and the second element being the array itself. Returns: list: minimum number of operations for each test case >>> t = 3 >>> cases = [ >>> (3, [1, 2, 3]), >>> (2, [2, 2]), >>> (4, [1, 10, 2, 9]), >>> ] >>> minimum_operations_to_equal_elements(t, cases) [2, 0, 16] >>> t = 1 >>> cases = [ >>> (5, [1, 2, 3, 4, 5]), >>> ] >>> minimum_operations_to_equal_elements(t, cases) [6]","solution":"def minimum_operations_to_equal_elements(t, cases): Returns the minimum number of operations to make all elements in each array case the same. Parameters: t (int): number of test cases cases (list): list of tuples with the first element being the size of the array and the second element being the array itself. Returns: list: minimum number of operations for each test case results = [] for case in cases: n, array = case array.sort() median = array[n // 2] if n % 2 != 0 else array[(n // 2) - 1] operations = sum(abs(x - median) for x in array) results.append(operations) return results"},{"question":"def findPlatform(arrival, departure): Finds the minimum number of railway platforms required so that no train has to wait. Parameters: arrival (List[int]): List of arrival times of trains. departure (List[int]): List of departure times of trains. Returns: int: Minimum number of platforms required. Example: >>> findPlatform([900, 940, 950, 1100, 1500, 1800], [910, 1200, 1120, 1130, 1900, 2000]) 3 >>> findPlatform([200, 210, 300, 320, 350, 500], [230, 340, 320, 430, 400, 520]) 2","solution":"def findPlatform(arrival, departure): Finds the minimum number of railway platforms required so that no train has to wait. Parameters: arrival (List[int]): List of arrival times of trains. departure (List[int]): List of departure times of trains. Returns: int: Minimum number of platforms required. arrival.sort() departure.sort() n = len(arrival) platform_needed = 0 max_platforms = 0 i, j = 0, 0 while (i < n and j < n): if arrival[i] < departure[j]: platform_needed += 1 i += 1 if platform_needed > max_platforms: max_platforms = platform_needed else: platform_needed -= 1 j += 1 return max_platforms"},{"question":"def max_weight_of_k_consecutive_items(weights, k): Returns the maximum weight of any k consecutive items from the list of weights. >>> max_weight_of_k_consecutive_items([1, 3, 2, 5, 6, 2, 4], 3) 13 >>> max_weight_of_k_consecutive_items([4, 2, 10, 8, 1], 2) 18 >>> max_weight_of_k_consecutive_items([7, 3, 5, 2, 9], 1) 9","solution":"def max_weight_of_k_consecutive_items(weights, k): Returns the maximum weight of any k consecutive items from the list of weights. n = len(weights) # Handle edge case where k is equal to n if k == n: return sum(weights) # Compute the sum of the first 'k' weights max_sum = current_sum = sum(weights[:k]) # Use sliding window technique to find the maximum sum of k consecutive items for i in range(k, n): current_sum += weights[i] - weights[i - k] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def max_sum_subarray(arr, k): Returns the maximum possible sum of any contiguous subarray of length k. Args: arr (List[int]): An array of integers. k (int): Length of the subarray. Returns: int: The maximum possible sum of any contiguous subarray of length k. Example: >>> max_sum_subarray([2, 1, 5, 1, 3, 2], 3) 9 >>> max_sum_subarray([2, 1, 5, 1, 3, 2], 2) 6","solution":"def max_sum_subarray(arr, k): Returns the maximum possible sum of any contiguous subarray of length k. if len(arr) == 0 or k <= 0 or k > len(arr): return 0 # Calculate the sum of first 'k' elements max_sum = sum(arr[:k]) current_sum = max_sum # Use sliding window to find the maximum sum of subarrays of length k for i in range(k, len(arr)): current_sum += arr[i] - arr[i - k] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def can_form_palindrome(s: str) -> bool: Determines if it's possible to rearrange the characters in the string \`s\` to form a palindrome. >>> can_form_palindrome(\\"civic\\") True >>> can_form_palindrome(\\"ivicc\\") True >>> can_form_palindrome(\\"google\\") False >>> can_form_palindrome(\\"aabbcc\\") True >>> can_form_palindrome(\\"aabbccd\\") True >>> can_form_palindrome(\\"aabbccdde\\") True >>> can_form_palindrome(\\"abcdefgh\\") False >>> can_form_palindrome(\\"aabbccdd\\") True def solve(strings: List[str]) -> List[str]: Given a list of strings, determines for each if it is possible to rearrange the characters to form a palindrome. Returns a list of \\"POSSIBLE\\" or \\"IMPOSSIBLE\\" corresponding to each string. >>> solve([\\"civic\\", \\"ivicc\\", \\"google\\"]) [\\"POSSIBLE\\", \\"POSSIBLE\\", \\"IMPOSSIBLE\\"] >>> solve([\\"aabbcc\\", \\"aabbccd\\", \\"aabbccdde\\"]) [\\"POSSIBLE\\", \\"POSSIBLE\\", \\"POSSIBLE\\"] >>> solve([\\"abcdefgh\\"]) [\\"IMPOSSIBLE\\"] >>> solve([\\"aabbccdd\\"]) [\\"POSSIBLE\\"]","solution":"def can_form_palindrome(s): Determines if it's possible to rearrange the characters in the string \`s\` to form a palindrome. from collections import Counter char_counts = Counter(s) odd_count = sum(1 for count in char_counts.values() if count % 2 != 0) return odd_count <= 1 def solve(strings): results = [] for s in strings: results.append(\\"POSSIBLE\\" if can_form_palindrome(s) else \\"IMPOSSIBLE\\") return results"},{"question":"def encode_rle(s: str) -> str: Encode a string using Run-Length Encoding (RLE). >>> encode_rle(\\"AAAABBBCCDAA\\") '4A3B2C1D2A' >>> encode_rle(\\"AAAAAAAAAAAAAA\\") '14A' pass def decode_rle(s: str) -> str: Decode a Run-Length Encoded (RLE) string. >>> decode_rle(\\"4A3B2C1D2A\\") 'AAAABBBCCDAA' >>> decode_rle(\\"14A\\") 'AAAAAAAAAAAAAA' pass def run_rle(test_cases: List[str]) -> List[str]: Run the RLE encoding or decoding on a list of test cases. >>> run_rle([\\"AAAABBBCCDAA\\", \\"4A3B2C1D2A\\", \\"AAAAAAAAAAAAAA\\", \\"14A\\"]) ['4A3B2C1D2A', 'AAAABBBCCDAA', '14A', 'AAAAAAAAAAAAAA'] pass","solution":"def encode_rle(s): if not s: return \\"\\" encoded = [] prev_char = s[0] count = 1 for char in s[1:]: if char == prev_char: count += 1 else: encoded.append(f\\"{count}{prev_char}\\") prev_char = char count = 1 encoded.append(f\\"{count}{prev_char}\\") return \\"\\".join(encoded) def decode_rle(s): if not s: return \\"\\" decoded = [] count = 0 for char in s: if char.isdigit(): count = count * 10 + int(char) else: decoded.append(char * count) count = 0 return \\"\\".join(decoded) def run_rle(test_cases): results = [] for case in test_cases: if case[0].isdigit(): results.append(decode_rle(case)) else: results.append(encode_rle(case)) return results"},{"question":"def solve(test_cases): Determine if each array in the test cases can be split into two parts with equal sum. Parameters: test_cases (List[Tuple[int, List[int]]]): List of test cases where each test case contains the size of the array and the list of integers in the array. Returns: List[str]: List containing \\"YES\\" if the array can be split into two parts with equal sum, and \\"NO\\" otherwise. >>> solve([(4, [5, 2, 3, 6]), (6, [10, 5, 5, 5, 2, 3]), (8, [2, 2, 2, 2, 2, 2, 2, 2])]) [\\"YES\\", \\"YES\\", \\"YES\\"] >>> solve([(4, [1, 1, 2, 2]), (5, [2, 1, 1, 1, 1, 3]), (5, [3, 3, 3, 3, 3])]) [\\"YES\\", \\"NO\\", \\"NO\\"] >>> solve([(2, [7, 7]), (2, [10, 10])]) [\\"YES\\", \\"YES\\"] >>> solve([(200000, [1] * 100000 + [2] * 100000)]) [\\"YES\\"]","solution":"def can_split_equally(n, arr): total_sum = sum(arr) if total_sum % 2 != 0: return \\"NO\\" half_sum = total_sum // 2 current_sum = 0 for number in arr: current_sum += number if current_sum == half_sum: return \\"YES\\" if current_sum > half_sum: if (current_sum - half_sum) in arr: return \\"YES\\" else: return \\"NO\\" return \\"NO\\" # this line is redundant due to the problem guarantee, added for safe coding def solve(test_cases): results = [] for n, arr in test_cases: results.append(can_split_equally(n, arr)) return results"},{"question":"def can_form_strictly_increasing_sequence(arr): Determines whether the given list can be rearranged to form a strictly increasing sequence. Parameters: arr (list): A list of integers Returns: str: 'possible' if the list can be rearranged to form a strictly increasing sequence, otherwise 'impossible' >>> can_form_strictly_increasing_sequence([1, 3, 2, 4, 5]) == 'possible' >>> can_form_strictly_increasing_sequence([5, 5, 3, 4]) == 'impossible' >>> can_form_strictly_increasing_sequence([3, 1, 2]) == 'possible' >>> can_form_strictly_increasing_sequence([-1000, 1000]) == 'possible' >>> can_form_strictly_increasing_sequence([7, 7, 7, 7]) == 'impossible' if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() N = int(data[0]) arr = list(map(int, data[1:])) print(can_form_strictly_increasing_sequence(arr))","solution":"def can_form_strictly_increasing_sequence(arr): Determines whether the given list can be rearranged to form a strictly increasing sequence. Parameters: arr (list): A list of integers Returns: str: 'possible' if the list can be rearranged to form a strictly increasing sequence, otherwise 'impossible' arr_sorted = sorted(arr) for i in range(len(arr_sorted) - 1): if arr_sorted[i] >= arr_sorted[i + 1]: return 'impossible' return 'possible' # Handling the input as mentioned in the problem statement if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() N = int(data[0]) arr = list(map(int, data[1:])) print(can_form_strictly_increasing_sequence(arr))"},{"question":"def validate_ip(ip_address: str) -> bool: Validate whether the given string is a valid IPv4 address. >>> validate_ip(\\"192.168.1.1\\") True >>> validate_ip(\\"255.255.255.255\\") True >>> validate_ip(\\"256.256.256.256\\") False >>> validate_ip(\\"192.168.1.1.1\\") False >>> validate_ip(\\"abc.def.ghi.jkl\\") False","solution":"def validate_ip(ip_address): Returns True if the given string is a valid IPv4 address, False otherwise. parts = ip_address.split('.') if len(parts) != 4: return False for part in parts: if not part.isdigit(): return False num = int(part) if num < 0 or num > 255: return False return True"},{"question":"import math def total_passwords() -> int: Returns the total number of different passwords Harry can set using four distinct uppercase English letters. >>> total_passwords() 358800","solution":"import math def total_passwords(): Returns the total number of different passwords Harry can set using four distinct uppercase English letters. n = 26 k = 4 combinations = math.comb(n, k) permutations = math.perm(k) return combinations * permutations # Print the result print(total_passwords())"},{"question":"from collections import defaultdict, deque from typing import List, Tuple def find_longest_path_length(n: int, m: int, edges: List[Tuple[int, int]], queries: List[int]) -> List[int]: Determine the longest path length from the specified starting vertex for each query. Args: n (int): Number of vertices. m (int): Number of directed edges. edges (List[Tuple[int, int]]): List of directed edges. queries (List[int]): List of starting vertices for each query. Returns: List[int]: List containing the longest path length for each query. Example: >>> n = 5 >>> m = 6 >>> edges = [(1, 2), (1, 3), (2, 4), (2, 5), (3, 4), (4, 5)] >>> queries = [1, 2, 3] >>> find_longest_path_length(n, m, edges, queries) [4, 3, 2] pass def test_find_longest_path_length(): n = 5 m = 6 edges = [ (1, 2), (1, 3), (2, 4), (2, 5), (3, 4), (4, 5) ] queries = [1, 2, 3] result = find_longest_path_length(n, m, edges, queries) assert result == [4, 3, 2] def test_single_vertex_no_edges(): n = 1 m = 0 edges = [] queries = [1] result = find_longest_path_length(n, m, edges, queries) assert result == [1] def test_linear_graph(): n = 4 m = 3 edges = [ (1, 2), (2, 3), (3, 4) ] queries = [1, 2, 3] result = find_longest_path_length(n, m, edges, queries) assert result == [4, 3, 2] def test_star_graph(): n = 5 m = 4 edges = [ (1, 2), (1, 3), (1, 4), (1, 5) ] queries = [1, 2, 3] result = find_longest_path_length(n, m, edges, queries) assert result == [2, 1, 1] def test_disconnected_graph(): n = 6 m = 5 edges = [ (1, 2), (1, 3), (3, 4), (5, 6) ] queries = [1, 2, 5] result = find_longest_path_length(n, m, edges, queries) assert result == [3, 1, 2] # Run the tests if __name__ == \\"__main__\\": test_find_longest_path_length() test_single_vertex_no_edges() test_linear_graph() test_star_graph() test_disconnected_graph() print(\\"All tests passed!\\")","solution":"from collections import defaultdict, deque def find_longest_path_length(n, m, edges, queries): # Create adjacency list adj = defaultdict(list) for u, v in edges: adj[u].append(v) # Function to perform topological sort def topological_sort(): indegree = [0] * (n + 1) for u in adj: for v in adj[u]: indegree[v] += 1 zero_indegree_queue = deque([i for i in range(1, n + 1) if indegree[i] == 0]) top_order = [] while zero_indegree_queue: node = zero_indegree_queue.popleft() top_order.append(node) for neighbor in adj[node]: indegree[neighbor] -= 1 if indegree[neighbor] == 0: zero_indegree_queue.append(neighbor) return top_order # Get topological order topo_order = topological_sort() # Function to get the longest path length from the given source vertex def longest_path_from_source(source): dp = [-1] * (n + 1) dp[source] = 0 for u in topo_order: if dp[u] != -1: for v in adj[u]: if dp[v] < dp[u] + 1: dp[v] = dp[u] + 1 return max(dp) result = [] for query in queries: result.append(longest_path_from_source(query) + 1) # +1 to include the source vertex in the count return result"},{"question":"def max_fortunate_segment_length(n, k, array): Returns the maximum length of a fortunate segment in the array where the sum of its elements is greater than or equal to a given number k. >>> max_fortunate_segment_length(5, 10, [1, 2, 3, 4, 5]) 4 >>> max_fortunate_segment_length(6, 15, [1, 2, 3, 4, 5, 6]) 5 >>> max_fortunate_segment_length(3, 100, [1, 2, 3]) 0","solution":"def max_fortunate_segment_length(n, k, array): Returns the maximum length of a fortunate segment in the array where the sum of its elements is greater than or equal to a given number k. max_length = 0 current_sum = 0 left = 0 for right in range(n): current_sum += array[right] while current_sum >= k: max_length = max(max_length, right - left + 1) current_sum -= array[left] left += 1 return max_length"},{"question":"from typing import List def alternateReverse(arr: List[int]) -> List[int]: This function takes a list of integers and returns a new list with the elements in an alternate reversed order. >>> alternateReverse([1, 2, 3, 4, 5, 6]) [6, 1, 5, 2, 4, 3] >>> alternateReverse([0, -1, 2, -3, 4, -5, 6]) [6, 0, -5, -1, 4, 2, -3] >>> alternateReverse([7]) [7]","solution":"def alternateReverse(arr): This function takes a list of integers and returns a new list with the elements in an alternate reversed order. n = len(arr) if n == 1: return arr result = [] for i in range((n + 1) // 2): result.append(arr[-(i + 1)]) if i != n - (i + 1): # To avoid adding the middle element twice result.append(arr[i]) return result"},{"question":"def can_form_arithmetic_progression(n, sequence): Determine if it's possible to rearrange the sequence to form an arithmetic progression. Parameters: n (int): The length of the sequence sequence (list of int): The elements of the sequence Returns: str: \\"YES\\" if an arithmetic progression can be formed, otherwise \\"NO\\" >>> can_form_arithmetic_progression(5, [3, 1, 5, 7, 9]) 'YES' >>> can_form_arithmetic_progression(4, [1, 3, 6, 8]) 'NO' from solution import can_form_arithmetic_progression def test_can_form_arithmetic_progression_yes(): assert can_form_arithmetic_progression(5, [3, 1, 5, 7, 9]) == \\"YES\\" assert can_form_arithmetic_progression(3, [10, 5, 0]) == \\"YES\\" assert can_form_arithmetic_progression(4, [1, 3, 5, 7]) == \\"YES\\" def test_can_form_arithmetic_progression_no(): assert can_form_arithmetic_progression(4, [1, 3, 6, 8]) == \\"NO\\" assert can_form_arithmetic_progression(5, [1, 2, 4, 4, 5]) == \\"NO\\" def test_can_form_arithmetic_progression_edge_cases(): assert can_form_arithmetic_progression(2, [1, 2]) == \\"YES\\" assert can_form_arithmetic_progression(2, [2, 2]) == \\"YES\\" assert can_form_arithmetic_progression(2, [1000000000, -1000000000]) == \\"YES\\" def test_can_form_arithmetic_progression_large_input(): large_sequence = list(range(100000, 0, -1)) assert can_form_arithmetic_progression(100000, large_sequence) == \\"YES\\"","solution":"def can_form_arithmetic_progression(n, sequence): Determine if it's possible to rearrange the sequence to form an arithmetic progression. Parameters: n (int): The length of the sequence sequence (list of int): The elements of the sequence Returns: str: \\"YES\\" if an arithmetic progression can be formed, otherwise \\"NO\\" if n <= 2: return \\"YES\\" sequence.sort() common_diff = sequence[1] - sequence[0] for i in range(2, n): if sequence[i] - sequence[i - 1] != common_diff: return \\"NO\\" return \\"YES\\""},{"question":"def count_trees(N: int) -> int: Count the number of distinct structurally unique Balanced Prime Binary Trees that can be formed with N prime numbers. Result should be returned modulo 10^9+7. >>> count_trees(3) 1 >>> count_trees(4) 0 >>> count_trees(7) 1 >>> count_trees(8) 0","solution":"def count_trees(N): MOD = 10**9 + 7 def is_power_of_two_minus_one(x): return (x & (x + 1)) == 0 and x != 0 if is_power_of_two_minus_one(N): return 1 else: return 0"},{"question":"def has_direct_edge(matrix, u, v): Check if there's a direct edge between vertices u and v in an undirected graph. :param matrix: The adjacency matrix of the graph. :param u: Vertex u (1-based index). :param v: Vertex v (1-based index). :return: 'YES' if there's a direct edge, 'NO' otherwise. >>> has_direct_edge([[0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 1], [0, 0, 1, 0]], 1, 2) 'YES' >>> has_direct_edge([[0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 1], [0, 0, 1, 0]], 1, 3) 'NO' >>> has_direct_edge([[0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 1], [0, 0, 1, 0]], 4, 2) 'NO' >>> has_direct_edge([[0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 1], [0, 0, 1, 0]], 3, 4) 'YES' pass def process_queries(T, test_cases): Process multiple test cases and queries to check for a direct edge in a graph. :param T: Number of test cases. :param test_cases: List of tuples containing test case data with N, Q, adjacency matrix, and queries. :return: List of results for each query, either 'YES' or 'NO'. >>> T = 1 >>> test_cases = [(4, 3, [[0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 1], [0, 0, 1, 0]], [(1, 2), (1, 3), (4, 2)])] ['YES', 'NO', 'NO'] >>> T = 2 >>> test_cases = [(3, 2, [[0, 1, 0], [1, 0, 1], [0, 1, 0]], [(1, 2), (2, 3)]), (2, 2, [[0, 1], [1, 0]], [(1, 2), (2, 1)])] ['YES', 'YES', 'YES', 'YES'] pass","solution":"def has_direct_edge(matrix, u, v): This function checks if there's a direct edge between vertices u and v in the matrix. :param matrix: The adjacency matrix representing the graph. :param u: Vertex u (1-based index). :param v: Vertex v (1-based index). :return: 'YES' if there's a direct edge, 'NO' otherwise. return \\"YES\\" if matrix[u-1][v-1] == 1 else \\"NO\\" def process_queries(T, test_cases): results = [] for i in range(T): N, Q, matrix, queries = test_cases[i] for u, v in queries: results.append(has_direct_edge(matrix, u, v)) return results"},{"question":"def max_subsequence_sum(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Returns the maximum sum of a subsequence of consecutive integers for each test case. >>> max_subsequence_sum(1, [(5, [1, -2, 3, 4, -5])]) [7] >>> max_subsequence_sum(1, [(4, [-1, -2, -3, -4])]) [-1] >>> max_subsequence_sum(1, [(6, [2, -1, 2, 3, 4, -5])]) [10]","solution":"def max_subsequence_sum(t, test_cases): Returns the maximum sum of a subsequence of consecutive integers for each test case. results = [] for case in test_cases: n, sequence = case max_current = max_global = sequence[0] for num in sequence[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current results.append(max_global) return results"},{"question":"def findLongestSubsequence(nums): Returns the length of the longest strictly increasing subsequence. :param nums: List of integers :return: Length of the longest strictly increasing subsequence >>> findLongestSubsequence([10, 9, 2, 5, 3, 7, 101, 18]) == 4 >>> findLongestSubsequence([0, 1, 0, 3, 2, 3]) == 4 >>> findLongestSubsequence([7, 7, 7, 7, 7, 7, 7]) == 1 >>> findLongestSubsequence([]) == 0 >>> findLongestSubsequence([5]) == 1 >>> findLongestSubsequence([1, 2, 3, 4, 5]) == 5 >>> findLongestSubsequence([5, 4, 3, 2, 1]) == 1","solution":"def findLongestSubsequence(nums): Returns the length of the longest strictly increasing subsequence. :param nums: List of integers :return: Length of the longest strictly increasing subsequence if not nums: return 0 dp = [1] * len(nums) for i in range(1, len(nums)): for j in range(i): if nums[i] > nums[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"def max_non_overlapping_jobs(N, jobs): Returns the maximum number of non-overlapping job offers that can be accepted. Parameters: N (int): The number of job offers. jobs (list of tuple): A list of (start, end) tuples describing the job offers. Returns: int: Maximum number of non-overlapping job offers. >>> max_non_overlapping_jobs(3, [(1, 3), (2, 5), (4, 6)]) 2 >>> max_non_overlapping_jobs(4, [(1, 2), (2, 3), (3, 4), (1, 4)]) 3","solution":"def max_non_overlapping_jobs(N, jobs): Returns the maximum number of non-overlapping job offers that can be accepted. Parameters: N (int): The number of job offers. jobs (list of tuple): A list of (start, end) tuples describing the job offers. Returns: int: Maximum number of non-overlapping job offers. # Sort jobs by their end time jobs.sort(key=lambda x: x[1]) # Track the count of non-overlapping jobs and the end time of the last added job count = 0 last_end_time = 0 for start, end in jobs: if start >= last_end_time: # Accept this job offer count += 1 last_end_time = end return count"},{"question":"from typing import List def transform_to_k_distance_apart(n: int, k: int, permutation: List[int]) -> List[int]: Transforms the given permutation into a new permutation where for every pair of elements (i, j), where i < j and j - i = k (k-distance apart), the value of the element at position j is strictly greater than the value of the element at position i. If it is not possible, returns [-1]. >>> transform_to_k_distance_apart(5, 2, [1, 3, 2, 5, 4]) [2, 3, 1, 5, 4] >>> transform_to_k_distance_apart(4, 3, [4, 2, 3, 1]) [-1]","solution":"def transform_to_k_distance_apart(n, k, permutation): Transforms the given permutation into a new permutation where for every pair of elements (i, j), where i < j and j - i = k (k-distance apart), the value of the element at position j is strictly greater than the value of the element at position i. If it is not possible, returns -1. # Checking feasibility by ensuring there is enough distance to make the swaps or comparisons. if k >= n: return -1 # Try to construct a valid permutation for i in range(n - k): if permutation[i] > permutation[i + k]: return -1 # If initial permutation is already valid return it return permutation def parse_input(input_str): lines = input_str.strip().split('n') n, k = map(int, lines[0].split()) permutation = list(map(int, lines[1].split())) return n, k, permutation def transform_to_k_distance_apart_from_input(input_str): n, k, permutation = parse_input(input_str) result = transform_to_k_distance_apart(n, k, permutation) if result == -1: return '-1' return ' '.join(map(str, result))"},{"question":"from typing import List, Dict def sort_tasks_by_priority(tasks: List[Dict[str, str]]) -> List[Dict[str, str]]: Sort a list of tasks based on their priority in descending order. Args: tasks (List[Dict[str, str]]): List of dictionary tasks with 'task' and 'priority' keys. Returns: List[Dict[str, str]]: List of tasks sorted by priority in descending order. Example: >>> tasks = [ ... {\\"task\\": \\"clean\\", \\"priority\\": \\"medium\\"}, ... {\\"task\\": \\"wash dishes\\", \\"priority\\": \\"high\\"}, ... {\\"task\\": \\"do laundry\\", \\"priority\\": \\"low\\"}, ... {\\"task\\": \\"pay bills\\", \\"priority\\": \\"high\\"}, ... {\\"task\\": \\"do homework\\", \\"priority\\": \\"medium\\"}, ... ] >>> sort_tasks_by_priority(tasks) [ {\\"task\\": \\"wash dishes\\", \\"priority\\": \\"high\\"}, {\\"task\\": \\"pay bills\\", \\"priority\\": \\"high\\"}, {\\"task\\": \\"clean\\", \\"priority\\": \\"medium\\"}, {\\"task\\": \\"do homework\\", \\"priority\\": \\"medium\\"}, {\\"task\\": \\"do laundry\\", \\"priority\\": \\"low\\"}, ]","solution":"from typing import List, Dict def sort_tasks_by_priority(tasks: List[Dict[str, str]]) -> List[Dict[str, str]]: Sorts a list of tasks based on their priority in descending order. priority_order = {'high': 1, 'medium': 2, 'low': 3} return sorted(tasks, key=lambda task: priority_order[task['priority']])"},{"question":"def check_firewall_rule_conflict(n: int, existing_rules: List[Tuple[int, int]], new_rule: Tuple[int, int]) -> str: Determine if a new firewall rule conflicts with existing rules. Args: n (int): Number of existing rules. existing_rules (List[Tuple[int, int]]): The start and end of the range for each existing rule. new_rule (Tuple[int, int]): The start and end of the range for the new rule. Returns: str: \\"Conflict\\" if the new rule conflicts with any existing rule, otherwise \\"No Conflict\\". Examples: >>> check_firewall_rule_conflict(3, [(1, 5), (8, 10), (15, 20)], (4, 9)) 'Conflict' >>> check_firewall_rule_conflict(2, [(1, 3), (5, 8)], (10, 12)) 'No Conflict'","solution":"def check_firewall_rule_conflict(n, existing_rules, new_rule): x, y = new_rule for ai, bi in existing_rules: if max(ai, x) < min(bi, y): return \\"Conflict\\" return \\"No Conflict\\""},{"question":"def max_guests_use_room(k: int, guests: List[Tuple[int, int]]) -> int: Calculates the maximum number of guests that can use the special room without overlapping times. Parameters: k (int): The number of guests. guests (list): A list of tuples where each tuple represents (arrival, departure) times. Returns: int: Maximum number of non-overlapping guests that can use the room. >>> max_guests_use_room(4, [(1, 2), (2, 3), (3, 4), (1, 3)]) 2 >>> max_guests_use_room(4, [(1, 2), (3, 4), (5, 6), (7, 8)]) 4 >>> max_guests_use_room(4, [(1, 5), (2, 4), (3, 6), (4, 7)]) 1 >>> max_guests_use_room(4, [(1, 2), (1, 3), (2, 4), (3, 5)]) 2 >>> max_guests_use_room(1, [(1, 3)]) 1 >>> max_guests_use_room(2, [(1, 1000000000), (1, 1000000001)]) 1 >>> max_guests_use_room(4, [(1, 2), (1, 2), (1, 2), (1, 2)]) 1 >>> max_guests_use_room(1, [(1, 1)]) 1","solution":"def max_guests_use_room(k, guests): Calculates the maximum number of guests that can use the special room without overlapping times. Parameters: k (int): The number of guests. guests (list): A list of tuples where each tuple represents (arrival, departure) times. Returns: int: Maximum number of non-overlapping guests that can use the room. # Sort guests based on their departure times guests.sort(key=lambda guest: guest[1]) max_guests = 0 last_departure = 0 for arrival, departure in guests: if arrival > last_departure: max_guests += 1 last_departure = departure return max_guests # Example usage (should not be part of the final code) # Input: 4 guests => [(1, 2), (2, 3), (3, 4), (1, 3)] guests = [(1, 2), (2, 3), (3, 4), (1, 3)] print(max_guests_use_room(4, guests)) # Output: 2"},{"question":"def has_pair_with_sum(n: int, lst: list, target: int) -> str: Determines if any two distinct elements in the list sum up to the target integer. Args: n (int): Number of integers in the list. lst (list): List of integers. target (int): Target sum. Returns: str: \\"YES\\" if there exists such a pair, otherwise \\"NO\\". Examples: >>> has_pair_with_sum(5, [1, 2, 3, 4, 5], 9) 'YES' >>> has_pair_with_sum(5, [1, 2, 3, 4, 5], 10) 'NO'","solution":"def has_pair_with_sum(n, lst, target): Determines if any two distinct elements in the list sum up to the target integer. Args: n (int): Number of integers in the list. lst (list): List of integers. target (int): Target sum. Returns: str: \\"YES\\" if there exists such a pair, otherwise \\"NO\\". seen = set() for num in lst: complement = target - num if complement in seen: return \\"YES\\" seen.add(num) return \\"NO\\""},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def diameterOfBinaryTree(root): Returns the diameter of the binary tree. The diameter is defined as the number of nodes on the longest path between two nodes in the tree. >>> tree = TreeNode(1) >>> tree.left = TreeNode(2) >>> tree.right = TreeNode(3) >>> tree.left.left = TreeNode(4) >>> tree.left.right = TreeNode(5) >>> diameterOfBinaryTree(tree) 4 >>> tree = TreeNode(1) >>> tree.left = TreeNode(2) >>> tree.left.left = TreeNode(3) >>> tree.left.right = TreeNode(4) >>> tree.left.left.left = TreeNode(5) >>> diameterOfBinaryTree(tree) 4","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def diameterOfBinaryTree(root): Returns the diameter of the binary tree. def depth(node): Helper function to calculate the depth of the tree. During this process, it also updates the diameter. nonlocal diameter if not node: return 0 left_depth = depth(node.left) right_depth = depth(node.right) diameter = max(diameter, left_depth + right_depth) return max(left_depth, right_depth) + 1 diameter = 0 depth(root) return diameter + 1 if root else 0"},{"question":"def shortest_palindrome(s: str) -> str: Returns the shortest palindrome by adding characters to the front of the given string. >>> shortest_palindrome(\\"abcd\\") \\"dcbabcd\\" >>> shortest_palindrome(\\"aacecaaa\\") \\"aaacecaaa\\" >>> shortest_palindrome(\\"a\\") \\"a\\" >>> shortest_palindrome(\\"racecar\\") \\"racecar\\" >>> shortest_palindrome(\\"\\") \\"\\"","solution":"def shortest_palindrome(s: str) -> str: Returns the shortest palindrome by adding characters to the front of the given string. if s == s[::-1]: return s # Find the longest palindromic prefix for i in range(len(s), 0, -1): if s[:i] == s[:i][::-1]: break # Add the reverse of the suffix to the front return s[i:][::-1] + s"},{"question":"def longest_substring_with_n_distinct_chars(s: str, n: int) -> int: Given a string \`s\` consisting of lowercase English letters and an integer \`n\`, find the length of the longest substring of \`s\` that contains exactly \`n\` distinct characters. >>> longest_substring_with_n_distinct_chars(\\"abcba\\", 2) 3 >>> longest_substring_with_n_distinct_chars(\\"a\\", 1) 1 >>> longest_substring_with_n_distinct_chars(\\"abc\\", 4) 0 >>> longest_substring_with_n_distinct_chars(\\"aabacbebebe\\", 3) 7 >>> longest_substring_with_n_distinct_chars(\\"aabbcc\\", 3) 6 >>> longest_substring_with_n_distinct_chars(\\"abcba\\", 0) 0 >>> longest_substring_with_n_distinct_chars(\\"ababab\\", 2) 6 >>> longest_substring_with_n_distinct_chars(\\"abcdef\\", 3) 3","solution":"def longest_substring_with_n_distinct_chars(s, n): from collections import defaultdict if n == 0: return 0 left = 0 right = 0 max_len = 0 char_count = defaultdict(int) while right < len(s): char_count[s[right]] += 1 while len(char_count) > n: char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 if len(char_count) == n: max_len = max(max_len, right - left + 1) right += 1 return max_len"},{"question":"def find_starting_point(n: int, elements: List[int]) -> int: Given a circular list of integers, find the starting point where you can traverse the entire list such that the cumulative sum of the elements is non-negative at every step. If no such starting point exists, return -1. >>> find_starting_point(5, [1, -5, 4, 3, -2]) == 2 >>> find_starting_point(4, [-1, -2, -3, -4]) == -1 >>> find_starting_point(6, [2, 3, -4, 1, -1, 2]) == 0 >>> find_starting_point(3, [0, 0, 0]) == 0 >>> find_starting_point(5, [3, -1, 2, -2, 4]) == 0 >>> find_starting_point(5, [-5, 1, 2, 3, 4]) == 1 >>> find_starting_point(6, [-1, 2, -1, 2, -1, 2]) == 1","solution":"def find_starting_point(n, elements): total_sum = sum(elements) if total_sum < 0: return -1 current_sum = 0 starting_index = 0 for i in range(n): current_sum += elements[i] if current_sum < 0: current_sum = 0 starting_index = i + 1 return starting_index if sum(elements[starting_index:] + elements[:starting_index]) >= 0 else -1"},{"question":"def count_peaks(N: int, arr: List[int]) -> int: Returns the number of peaks in the list. Parameters: N (int): Number of elements in the list arr (list of int): List of elements Returns: int: Number of peaks in the list >>> count_peaks(6, [1, 3, 2, 4, 1, 5]) 2 >>> count_peaks(5, [1, 2, 3, 4, 5]) 0 >>> count_peaks(5, [5, 4, 3, 2, 1]) 0 >>> count_peaks(5, [4, 4, 4, 4, 4]) 0 >>> count_peaks(3, [1, 2, 1]) 1 >>> count_peaks(7, [1, 2, 1, 3, 1, 4, 1]) 3 >>> count_peaks(1, [1]) 0 >>> count_peaks(2, [1, 2]) 0 >>> count_peaks(5, [999999999, 1000000000, 999999999, 1000000000, 999999999]) 2 pass","solution":"def count_peaks(N, arr): Returns the number of peaks in the list. Parameters: N (int): Number of elements in the list arr (list of int): List of elements Returns: int: Number of peaks in the list peak_count = 0 for i in range(1, N-1): if arr[i] > arr[i-1] and arr[i] > arr[i+1]: peak_count += 1 return peak_count"},{"question":"def is_subarray_sum_divisible(n: int, k: int, A: List[int], queries: List[Tuple[int, int]]) -> List[str]: Determines if the sum of the elements of the subarray A[L...R] is divisible by k for each query. Parameters: - n: number of elements in the array A - k: the divisor - A: the array of integers - queries: list of tuples containing the queries (L, R) Returns: - List of \\"YES\\" or \\"NO\\" for each query >>> is_subarray_sum_divisible(5, 3, [1, 2, 3, 4, 5], [(1, 3), (2, 5), (1, 5)]) ['YES', 'NO', 'YES'] >>> is_subarray_sum_divisible(4, 2, [2, 5, 3, 8], [(1, 1), (2, 2), (3, 3), (4, 4)]) ['YES', 'NO', 'NO', 'YES']","solution":"def is_subarray_sum_divisible(n, k, A, queries): Determines if the sum of the elements of the subarray A[L...R] is divisible by k for each query. :param n: int, number of elements in the array A :param k: int, the divisor :param A: list of int, the array :param queries: list of tuples, each containing two integers (L, R) :return: list of str, \\"YES\\" or \\"NO\\" for each query # Precompute prefix sums prefix_sum = [0] * (n + 1) for i in range(1, n + 1): prefix_sum[i] = prefix_sum[i - 1] + A[i - 1] results = [] for L, R in queries: # Note: Adjusting L and R from 1-based index to 0-based index subarray_sum = prefix_sum[R] - prefix_sum[L - 1] if subarray_sum % k == 0: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def most_frequent_character(s: str) -> str: Returns the most frequent character in the string s. If multiple characters have the same maximum frequency, returns the lexicographically smallest one among them. If the string is empty, returns an empty string. >>> most_frequent_character(\\"abracadabra\\") 'a' >>> most_frequent_character(\\"mississippi\\") 'i' >>> most_frequent_character(\\"xyzxyzxyz\\") 'x' >>> most_frequent_character(\\"abcde\\") 'a' >>> most_frequent_character(\\"aabbbccddeee\\") 'b' >>> most_frequent_character(\\"\\") '' >>> most_frequent_character(\\"z\\") 'z' >>> most_frequent_character(\\"abcdefghijklmnopqrstuvwxyz\\") 'a' >>> most_frequent_character(\\"aaaaaa\\") 'a' >>> most_frequent_character(\\"zaabbbccdeeffgg\\") 'b' # Your code here","solution":"def most_frequent_character(s): Returns the most frequent character in the string s. If multiple characters have the same maximum frequency, returns the lexicographically smallest one among them. If the string is empty, returns an empty string. if not s: return '' # Dictionary to store the frequency of each character frequency = {} for ch in s: if ch in frequency: frequency[ch] += 1 else: frequency[ch] = 1 # Find the maximum frequency max_freq = max(frequency.values()) # Find the smallest lexicographical character among the most frequent ones most_freq_char = min([ch for ch in frequency if frequency[ch] == max_freq]) return most_freq_char"},{"question":"def can_partition_k_subsets(arr, k): Given an array of positive integers \`arr\` and an integer \`k\`, determine if the array can be divided into \`k\` non-empty subsets with equal sums. >>> can_partition_k_subsets([4, 3, 2, 3], 2) \\"YES\\" >>> can_partition_k_subsets([1, 2, 3, 4], 3) \\"NO\\"","solution":"def can_partition_k_subsets(arr, k): def can_partition(start_index, k, current_sum, target_sum, visited): if k == 1: return True if current_sum == target_sum: return can_partition(0, k - 1, 0, target_sum, visited) for i in range(start_index, len(arr)): if not visited[i] and current_sum + arr[i] <= target_sum: visited[i] = True if can_partition(i + 1, k, current_sum + arr[i], target_sum, visited): return True visited[i] = False return False total_sum = sum(arr) if total_sum % k != 0 or k > len(arr): return \\"NO\\" target_sum = total_sum // k visited = [False] * len(arr) return \\"YES\\" if can_partition(0, k, 0, target_sum, visited) else \\"NO\\" # Example usage n, k = 4, 2 arr = [4, 3, 2, 3] print(can_partition_k_subsets(arr, k)) # Output: YES n, k = 4, 3 arr = [1, 2, 3, 4] print(can_partition_k_subsets(arr, k)) # Output: NO"},{"question":"def check_string(s): Prints \\"Present\\" if the string contains \\"hello\\". Prints \\"Absent\\" if the string contains \\"world\\" but does not contain \\"hello\\". Prints \\"Not Found\\" if the string contains neither \\"hello\\" nor \\"world\\". >>> check_string(\\"hellothere\\") # should print \\"Present\\" >>> check_string(\\"worldofcode\\") # should print \\"Absent\\" >>> check_string(\\"codingisfun\\") # should print \\"Not Found\\"","solution":"def check_string(s): Prints \\"Present\\" if the string contains \\"hello\\". Prints \\"Absent\\" if the string contains \\"world\\" but does not contain \\"hello\\". Prints \\"Not Found\\" if the string contains neither \\"hello\\" nor \\"world\\". if \\"hello\\" in s: print(\\"Present\\") elif \\"world\\" in s: print(\\"Absent\\") else: print(\\"Not Found\\")"},{"question":"def is_path_exists(n: int, m: int, grid: List[List[str]]) -> str: Determines if there is a path from the top-left corner to the bottom-right corner in a given maze grid. Uses Depth First Search (DFS) for pathfinding. Args: n (int): The number of rows in the maze grid. m (int): The number of columns in the maze grid. grid (list of list of str): The maze grid where '.' denotes empty space and '#' denotes obstacles. Returns: str: \\"YES\\" if a path exists, \\"NO\\" otherwise. >>> is_path_exists(3, 3, [['.', '.', '.'], ['#', '#', '.'], ['.', '.', '.']]) \\"YES\\" >>> is_path_exists(3, 3, [['.', '#', '.'], ['#', '#', '.'], ['.', '.', '.']]) \\"NO\\"","solution":"def is_path_exists(n, m, grid): Determines if there is a path from the top-left corner to the bottom-right corner in a given maze grid. Uses Depth First Search (DFS) for pathfinding. Args: n (int): The number of rows in the maze grid. m (int): The number of columns in the maze grid. grid (list of list of str): The maze grid where '.' denotes empty space and '#' denotes obstacles. Returns: str: \\"YES\\" if a path exists, \\"NO\\" otherwise. directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] def valid_move(x, y): return 0 <= x < n and 0 <= y < m and grid[x][y] == '.' def dfs(x, y): if not valid_move(x, y) or visited[x][y]: return False if (x, y) == (n-1, m-1): return True visited[x][y] = True for dx, dy in directions: if dfs(x + dx, y + dy): return True return False visited = [[False] * m for _ in range(n)] return \\"YES\\" if dfs(0, 0) else \\"NO\\""},{"question":"def max_consecutive_increasing_days(T: int, test_cases: list) -> list: Determine the maximum number of consecutive days during which the growth was strictly increasing. Args: T: An integer representing the number of test cases. test_cases: A list of tuples where each tuple contains an integer N and a list of N integers, representing the number of days and the growth measurements respectively. Returns: A list of integers where each integer represents the maximum number of consecutive days the plant's growth was strictly increasing for the corresponding test case. Example: >>> max_consecutive_increasing_days(2, [(7, [3, 2, 10, 5, 7, 8, 6]), (5, [1, 2, 3, 4, 5])]) [3, 5]","solution":"def max_consecutive_increasing_days(T, test_cases): results = [] for case in test_cases: N, growth_measurements = case max_length = 0 current_length = 1 for i in range(1, N): if growth_measurements[i] > growth_measurements[i-1]: current_length += 1 else: if current_length > max_length: max_length = current_length current_length = 1 # To check last sequence length if it was the longest if current_length > max_length: max_length = current_length results.append(max_length) return results"},{"question":"def smallest_isolated_region(n: int, m: int, bridges: List[Tuple[int, int]]) -> int: Determine the size of the smallest isolated sub-region of islands that cannot be reached from the mainland. Args: n (int): number of islands. m (int): number of bridges. bridges (List[Tuple[int, int]]): list of tuples representing the bridges between islands. Returns: int: the size of the smallest isolated sub-region, or -1 if no such region exists. Example: >>> smallest_isolated_region(7, 6, [(1, 2), (1, 3), (2, 4), (2, 5), (4, 5), (6, 7)]) 2 >>> smallest_isolated_region(5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)]) -1 >>> smallest_isolated_region(5, 3, [(1, 2), (2, 3), (3, 4)]) 1 >>> smallest_isolated_region(8, 5, [(1, 2), (2, 3), (4, 5), (6, 7), (7, 8)]) 2 >>> smallest_isolated_region(3, 0, []) 1 pass","solution":"def smallest_isolated_region(n, m, bridges): from collections import defaultdict, deque def bfs(start, visited, graph): queue = deque([start]) visited[start] = True component = [] while queue: node = queue.popleft() component.append(node) for neighbor in graph[node]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) return component graph = defaultdict(list) for u, v in bridges: graph[u].append(v) graph[v].append(u) visited = [False] * (n + 1) # Perform BFS from island 1 to determine the mainland mainland = bfs(1, visited, graph) # Find all isolated regions isolated_regions = [] for i in range(1, n + 1): if not visited[i]: component = bfs(i, visited, graph) isolated_regions.append(len(component)) # If there are no isolated regions, return -1 if not isolated_regions: return -1 # Return the size of the smallest isolated region return min(isolated_regions) # Example usage: # Input: Number of islands = 7, Number of bridges = 6 # Bridges: (1, 2), (1, 3), (2, 4), (2, 5), (4, 5), (6, 7) # Output: 2 print(smallest_isolated_region(7, 6, [(1, 2), (1, 3), (2, 4), (2, 5), (4, 5), (6, 7)])) # Output: 2"},{"question":"def longest_streak(N, T, hours): This function returns the longest streak of consecutive days where the employee has worked more than T hours. Parameters: N (int): Number of days T (int): Threshold of hours hours (list): List of integers representing hours worked each day Returns: int: Length of the longest streak of working more than T hours >>> longest_streak(10, 5, [6, 3, 8, 4, 5, 7, 9, 10, 2, 3]) 3 >>> longest_streak(5, 10, [1, 2, 3, 4, 5]) 0 >>> longest_streak(7, 3, [4, 5, 6, 7, 8, 9, 10]) 7 >>> longest_streak(10, 5, [6, 6, 1, 6, 6]) 2 >>> longest_streak(1, 5, [6]) 1 >>> longest_streak(1, 5, [4]) 0","solution":"def longest_streak(N, T, hours): This function returns the longest streak of consecutive days where the employee has worked more than T hours. Parameters: N (int): Number of days T (int): Threshold of hours hours (list): List of integers representing hours worked each day Returns: int: Length of the longest streak of working more than T hours max_streak = 0 current_streak = 0 for hour in hours: if hour > T: current_streak += 1 max_streak = max(max_streak, current_streak) else: current_streak = 0 return max_streak"},{"question":"def encrypt(text: str, shift: int) -> str: Encrypts the given text by shifting each alphabetical character by the specified number of places. >>> encrypt(\\"Hello, World!\\", 3) \\"Khoor, Zruog!\\" >>> encrypt(\\"abc\\", 29) \\"def\\" >>> encrypt(\\"Hello, World!\\", 0) \\"Hello, World!\\" >>> encrypt(\\"aBcDef\\", 3) \\"dEfGhi\\" >>> encrypt(\\"123, Hello!\\", 4) \\"123, Lipps!\\" def decrypt(text: str, shift: int) -> str: Decrypts the given encrypted text by shifting each alphabetical character back by the specified number of places. >>> decrypt(\\"Khoor, Zruog!\\", 3) \\"Hello, World!\\" >>> decrypt(\\"def\\", 29) \\"abc\\" >>> decrypt(\\"Khoor, Zruog!\\", 0) \\"Khoor, Zruog!\\" >>> decrypt(\\"dEfGhi\\", 3) \\"aBcDef\\" >>> decrypt(\\"123, Lipps!\\", 4) \\"123, Hello!\\"","solution":"def encrypt(text: str, shift: int) -> str: result = [] for char in text: if char.isalpha(): shift_mod = shift % 26 # Ensure the shift works within the bounds of the alphabet if char.islower(): shifted_char = chr(((ord(char) - ord('a') + shift_mod) % 26) + ord('a')) else: shifted_char = chr(((ord(char) - ord('A') + shift_mod) % 26) + ord('A')) result.append(shifted_char) else: result.append(char) return ''.join(result) def decrypt(text: str, shift: int) -> str: result = [] for char in text: if char.isalpha(): shift_mod = shift % 26 # Ensure the shift works within the bounds of the alphabet if char.islower(): shifted_char = chr(((ord(char) - ord('a') - shift_mod) % 26) + ord('a')) else: shifted_char = chr(((ord(char) - ord('A') - shift_mod) % 26) + ord('A')) result.append(shifted_char) else: result.append(char) return ''.join(result)"},{"question":"def min_operations_to_palindrome(T: int, test_cases: List[Tuple[int, str]]) -> List[int]: Calculate the minimum number of operations to turn string S into a palindrome. Args: T : int : Number of test cases test_cases : List[Tuple[int, str]] : List of tuples where each tuple contains: - N : int : Length of string S - S : str : The string S of length N consisting of lowercase English letters Returns: List[int] : List of integers corresponding to the minimum number of operations required to turn each string S into a palindrome Example: >>> min_operations_to_palindrome(2, [(3, \\"abc\\"), (4, \\"abca\\")]) [2, 1]","solution":"def min_operations_to_palindrome(T, test_cases): results = [] for case in test_cases: N, S = case reversals = [[0 for _ in range(N)] for _ in range(N)] for length in range(2, N + 1): for i in range(N - length + 1): j = i + length - 1 if S[i] == S[j]: reversals[i][j] = reversals[i + 1][j - 1] else: reversals[i][j] = min(reversals[i + 1][j], reversals[i][j - 1]) + 1 results.append(reversals[0][N - 1]) return results"},{"question":"def sum_of_prefix_frequencies(n: int, sequence: List[int]) -> int: Returns the sum of frequencies of each unique prefix sum. Args: n : int : length of the sequence sequence : list : list of integers representing the sequence Returns: int : sum of frequencies of unique prefix sums >>> sum_of_prefix_frequencies(5, [1, 2, 3, 2, -4]) 5 >>> sum_of_prefix_frequencies(4, [4, 0, -2, 2]) 4","solution":"def sum_of_prefix_frequencies(n, sequence): Returns the sum of frequencies of each unique prefix sum. Args: n : int : length of the sequence sequence : list : list of integers representing the sequence Returns: int : sum of frequencies of unique prefix sums prefix_sums = {} current_sum = 0 for num in sequence: current_sum += num if current_sum in prefix_sums: prefix_sums[current_sum] += 1 else: prefix_sums[current_sum] = 1 return sum(prefix_sums.values())"},{"question":"from typing import List def largestSquare(matrix: List[List[int]]) -> int: Determine the size (side length) of the largest square (subgrid) that can be formed using only traversable cells (0s). >>> largestSquare([ ... [1, 0, 1, 0, 0], ... [1, 0, 0, 0, 0], ... [1, 0, 0, 1, 0], ... [0, 1, 1, 1, 0] ... ]) 2 >>> largestSquare([ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) 3","solution":"def largestSquare(matrix): if not matrix or not matrix[0]: return 0 n = len(matrix) m = len(matrix[0]) dp = [[0] * m for _ in range(n)] max_side = 0 for i in range(n): for j in range(m): if matrix[i][j] == 0: if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side = max(max_side, dp[i][j]) return max_side"},{"question":"def largestDivisibleSubset(arr: List[int], N: int) -> int: Returns the size of the largest subset of arr such that for every pair (x, y), y % x == 0. >>> largestDivisibleSubset([1, 3, 6], 3) == 3 >>> largestDivisibleSubset([1, 2, 3, 8, 24], 5) == 4 >>> largestDivisibleSubset([10], 1) == 1 >>> largestDivisibleSubset([], 0) == 0 >>> largestDivisibleSubset([1, 2, 4, 8, 16], 5) == 5 >>> largestDivisibleSubset([1, 17, 34, 55, 68], 5) == 4 >>> largestDivisibleSubset([1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024], 11) == 11","solution":"def largestDivisibleSubset(arr, N): if N == 0: return 0 arr.sort() dp = [1] * N max_subset_size = 1 for i in range(1, N): for j in range(i): if arr[i] % arr[j] == 0: dp[i] = max(dp[i], dp[j] + 1) max_subset_size = max(max_subset_size, dp[i]) return max_subset_size"},{"question":"def is_well_ordered_possible(b): Determines if there exists a subsequence of b that forms a \\"well-ordered\\" array. A \\"well-ordered\\" array satisfies the following conditions: 1. The first element is the smallest element in the entire array. 2. The last element is the largest element in the entire array. 3. The array is non-decreasing. >>> is_well_ordered_possible([1, 5, 3, 2, 4]) True >>> is_well_ordered_possible([6, 5, 4, 3, 2, 1]) False def process_test_cases(test_cases): Processes multiple test cases to determine if there exists a subsequence of each array that forms a \\"well-ordered\\" array. >>> test_cases = [ ... [1, 5, 3, 2, 4], ... [6, 5, 4, 3, 2, 1], ... [2, 3, 4, 1, 5, 6, 7] ... ] >>> process_test_cases(test_cases) [\\"YES\\", \\"NO\\", \\"YES\\"] def parse_input(input_str): Parses input string to extract test cases. >>> input_str = \\"3n5n1 5 3 2 4n6n6 5 4 3 2 1n7n2 3 4 1 5 6 7\\" >>> parse_input(input_str) [ [1, 5, 3, 2, 4], [6, 5, 4, 3, 2, 1], [2, 3, 4, 1, 5, 6, 7] ]","solution":"def is_well_ordered_possible(b): Determines if there exists a subsequence of b that forms a \\"well-ordered\\" array. smallest = min(b) largest = max(b) # Check if there is a non-decreasing subsequence from smallest to largest in_sequence = False for num in b: if num == smallest: in_sequence = True elif in_sequence and num == largest: return True elif in_sequence and num >= smallest and num <= largest: smallest = num return False def process_test_cases(test_cases): results = [] for b in test_cases: if is_well_ordered_possible(b): results.append(\\"YES\\") else: results.append(\\"NO\\") return results # Utility function to convert input into structure test cases def parse_input(input_str): input_lines = input_str.strip().split('n') t = int(input_lines[0]) test_cases = [] idx = 1 for _ in range(t): m = int(input_lines[idx]) b = list(map(int, input_lines[idx + 1].split())) test_cases.append(b) idx += 2 return test_cases # Example usage input_str = 3 5 1 5 3 2 4 6 6 5 4 3 2 1 7 2 3 4 1 5 6 7 test_cases = parse_input(input_str) results = process_test_cases(test_cases) print(\\"n\\".join(results))"},{"question":"def process_commands(n: int, commands: List[str]) -> List[str]: Processes a list of commands to manage a collection of numbers. Commands: - \\"add x\\": Add the number x to the collection. - \\"delete x\\": Remove the number x from the collection if it exists. - \\"query x\\": Check if the number x exists in the collection. Returns 'found' or 'not found'. - \\"max\\": Returns the largest number in the collection or 'empty' if the collection is empty. - \\"min\\": Returns the smallest number in the collection or 'empty' if the collection is empty. Parameters: n (int): Number of commands. commands (list of str): List of commands to execute. Returns: list of str: Results of the 'query', 'max', and 'min' commands. Examples: >>> process_commands(10, [\\"add 5\\", \\"add 10\\", \\"query 5\\", \\"query 7\\", \\"max\\", \\"min\\", \\"delete 5\\", \\"query 5\\", \\"max\\", \\"min\\"]) [\\"found\\", \\"not found\\", \\"10\\", \\"5\\", \\"not found\\", \\"10\\", \\"10\\"] >>> process_commands(5, [\\"add 7\\", \\"delete 7\\", \\"query 7\\", \\"max\\", \\"min\\"]) [\\"not found\\", \\"empty\\", \\"empty\\"] >>> process_commands(5, [\\"add 1\\", \\"add 2\\", \\"add 3\\", \\"max\\", \\"min\\"]) [\\"3\\", \\"1\\"] >>> process_commands(4, [\\"max\\", \\"min\\", \\"query 100\\", \\"delete 100\\"]) [\\"empty\\", \\"empty\\", \\"not found\\"] >>> process_commands(5, [\\"add 10\\", \\"add 20\\", \\"query 10\\", \\"query 20\\", \\"query 30\\"]) [\\"found\\", \\"found\\", \\"not found\\"] pass","solution":"def process_commands(n, commands): Processes a list of commands to manage a collection of numbers. Parameters: n (int): The number of commands. commands (list of str): The commands to be processed. Returns: list of str: The results of 'query', 'max', and 'min' commands. collection = set() results = [] for command in commands: parts = command.split() action = parts[0] if action == \\"add\\": x = int(parts[1]) collection.add(x) elif action == \\"delete\\": x = int(parts[1]) collection.discard(x) elif action == \\"query\\": x = int(parts[1]) if x in collection: results.append(\\"found\\") else: results.append(\\"not found\\") elif action == \\"max\\": if collection: results.append(str(max(collection))) else: results.append(\\"empty\\") elif action == \\"min\\": if collection: results.append(str(min(collection))) else: results.append(\\"empty\\") return results"},{"question":"def sawtooth_patterns(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Determine if it is possible to cut down trees to achieve a sawtooth pattern. Args: T: int - number of test cases test_cases: List of tuples where each tuple contains an integer and a list of integers representing the heights of trees Returns: List of strings where each element is \\"YES\\" or \\"NO\\" indicating if the sawtooth pattern is possible. >>> sawtooth_patterns(3, [(5, [3, 1, 4, 1, 5]), (4, [1, 2, 3, 4]), (3, [10, 20, 10])]) [\\"YES\\", \\"NO\\", \\"YES\\"] >>> sawtooth_patterns(2, [(6, [1, 3, 1, 3, 1, 3]), (3, [1, 1, 1])]) [\\"YES\\", \\"NO\\"] >>> sawtooth_patterns(1, [(4, [9, 8, 10, 7])]) [\\"YES\\"] >>> sawtooth_patterns(1, [(3, [5, 5, 5])]) [\\"NO\\"]","solution":"def can_form_sawtooth_pattern(heights): n = len(heights) if n < 2: return False def check_pattern(direction): for i in range(1, n - 1): if direction: # Increase then decrease if heights[i - 1] >= heights[i] or heights[i] <= heights[i + 1]: return False else: # Decrease then increase if heights[i - 1] <= heights[i] or heights[i] >= heights[i + 1]: return False direction = not direction return True return check_pattern(True) or check_pattern(False) def sawtooth_patterns(T, test_cases): results = [] for i in range(T): n, heights = test_cases[i] if can_form_sawtooth_pattern(heights): results.append(\\"YES\\") else: results.append(\\"NO\\") return results # Example usage T = 3 test_cases = [ (5, [3, 1, 4, 1, 5]), (4, [1, 2, 3, 4]), (3, [10, 20, 10]) ] print(sawtooth_patterns(T, test_cases))"},{"question":"def rotate_array(arr, k): Rotates the array to the right by k steps. Args: - arr: list of integers - k: non-negative integer, number of steps to rotate Returns: - list of integers, rotated array Examples: >>> rotate_array([1, 2, 3, 4, 5, 6, 7], 3) [5, 6, 7, 1, 2, 3, 4] >>> rotate_array([1, 2, 3, 4], 6) [3, 4, 1, 2]","solution":"def rotate_array(arr, k): Rotates the array to the right by k steps. Args: - arr: list of integers - k: non-negative integer, number of steps to rotate Returns: - list of integers, rotated array n = len(arr) k = k % n # In case k is greater than array length return arr[-k:] + arr[:-k]"},{"question":"def filter_and_group_logs(logs): Filters out logs with \\"UNKNOWN\\" activities and groups the valid logs by date. Parameters: logs (list of str): List of log entries in the format \\"YYYY-MM-DD:USER:ACTION\\". Returns: dict: Dictionary with dates as keys and lists of \\"USER:ACTION\\" as values. >>> filter_and_group_logs([ ... \\"2023-08-01:John:Login\\", ... \\"2023-08-01:Jane:Logout\\", ... \\"2023-08-02:John:Login\\" ... ]) == { ... \\"2023-08-01\\": [\\"John:Login\\", \\"Jane:Logout\\"], ... \\"2023-08-02\\": [\\"John:Login\\"] ... } >>> filter_and_group_logs([ ... \\"2023-08-01:John:Login\\", ... \\"2023-08-01:Jane:UNKNOWN\\", ... \\"2023-08-02:John:Login\\" ... ]) == { ... \\"2023-08-01\\": [\\"John:Login\\"], ... \\"2023-08-02\\": [\\"John:Login\\"] ... } >>> filter_and_group_logs([ ... \\"2023-08-01:John:UNKNOWN\\", ... \\"2023-08-02:Jane:UNKNOWN\\" ... ]) == {}","solution":"def filter_and_group_logs(logs): Filters out logs with \\"UNKNOWN\\" activities and groups the valid logs by date. Parameters: logs (list of str): List of log entries in the format \\"YYYY-MM-DD:USER:ACTION\\". Returns: dict: Dictionary with dates as keys and lists of \\"USER:ACTION\\" as values. grouped_logs = {} for log in logs: date, user, action = log.split(\\":\\", 2) if action != \\"UNKNOWN\\": if date not in grouped_logs: grouped_logs[date] = [] grouped_logs[date].append(f\\"{user}:{action}\\") return grouped_logs"},{"question":"from typing import List def minTeamSize(skills: List[str], required: str) -> int: Determine the minimum number of team members required to complete a project that needs a certain set of skills. >>> minTeamSize(['101', '110', '011'], '111') 2 >>> minTeamSize(['101', '110', '011', '000'], '111') 2 >>> minTeamSize(['100', '010', '001'], '111') 3 >>> minTeamSize(['111', '000', '010', '001'], '111') 1 >>> minTeamSize(['100', '110', '011'], '111') 2 >>> minTeamSize(['000', '000'], '000') 1 >>> minTeamSize(['000', '000'], '111') -1","solution":"from itertools import combinations def minTeamSize(skills, required): n = len(skills) req_bits = [i for i, bit in enumerate(required) if bit == '1'] def covered_by_team(team): covered = set() for member in team: for i in req_bits: if skills[member][i] == '1': covered.add(i) return covered for team_size in range(1, n+1): for team in combinations(range(n), team_size): if len(covered_by_team(team)) == len(req_bits): return team_size return -1 # In case no team is found, which shouldn't happen in a valid problem setup."},{"question":"def process_operations(N: int, M: int, operations: List[str]) -> List[str]: Process a sequence of operations in a library system. Args: - N: number of members in the library. - M: number of books in the library. - operations: a list of operations to be performed in the library system. Returns: - A list of strings corresponding to the results of CHECK, MEMBER-BOOKS, and BOOK-MEMBER operations. Each operation in the list \`operations\` has one of the following forms: - \\"BORROW A B\\": Member A borrows book B. - \\"RETURN A B\\": Member A returns book B. - \\"CHECK A B\\": Check whether member A currently has book B. - \\"MEMBER-BOOKS A\\": List all book IDs currently borrowed by member A. - \\"BOOK-MEMBER B\\": Show the member ID who has borrowed book B. Example: >>> N = 3 >>> M = 5 >>> operations = [ ... \\"BORROW 1 3\\", ... \\"BORROW 2 4\\", ... \\"CHECK 1 3\\", ... \\"CHECK 2 3\\", ... \\"MEMBER-BOOKS 1\\", ... \\"BOOK-MEMBER 4\\", ... \\"RETURN 1 3\\", ... \\"BOOK-MEMBER 3\\", ... \\"MEMBER-BOOKS 1\\" ... ] >>> process_operations(N, M, operations) ['YES', 'NO', '3', '2', 'NONE', 'NONE'] from collections import defaultdict class LibrarySystem: def __init__(self, N, M): self.N = N self.M = M self.members_books = defaultdict(set) self.books_member = dict() def borrow(self, A, B): if B not in self.books_member: self.members_books[A].add(B) self.books_member[B] = A def return_book(self, A, B): if self.books_member.get(B) == A: self.members_books[A].remove(B) del self.books_member[B] def check(self, A, B): return \\"YES\\" if self.books_member.get(B) == A else \\"NO\\" def member_books(self, A): if self.members_books[A]: return ' '.join(map(str, sorted(self.members_books[A]))) else: return \\"NONE\\" def book_member(self, B): return str(self.books_member[B]) if B in self.books_member else \\"NONE\\" def process_operations(N, M, operations): library = LibrarySystem(N, M) result = [] for operation in operations: parts = operation.split() cmd = parts[0] if cmd == \\"BORROW\\": A, B = int(parts[1]), int(parts[2]) library.borrow(A, B) elif cmd == \\"RETURN\\": A, B = int(parts[1]), int(parts[2]) library.return_book(A, B) elif cmd == \\"CHECK\\": A, B = int(parts[1]), int(parts[2]) result.append(library.check(A, B)) elif cmd == \\"MEMBER-BOOKS\\": A = int(parts[1]) result.append(library.member_books(A)) elif cmd == \\"BOOK-MEMBER\\": B = int(parts[1]) result.append(library.book_member(B)) return result def test_sample_operations(): N = 3 M = 5 operations = [ \\"BORROW 1 3\\", \\"BORROW 2 4\\", \\"CHECK 1 3\\", \\"CHECK 2 3\\", \\"MEMBER-BOOKS 1\\", \\"BOOK-MEMBER 4\\", \\"RETURN 1 3\\", \\"BOOK-MEMBER 3\\", \\"MEMBER-BOOKS 1\\" ] expected_output = [ \\"YES\\", \\"NO\\", \\"3\\", \\"2\\", \\"NONE\\", \\"NONE\\" ] assert process_operations(N, M, operations) == expected_output def test_no_borrows(): N = 2 M = 3 operations = [ \\"CHECK 1 1\\", \\"CHECK 2 2\\", \\"MEMBER-BOOKS 1\\", \\"MEMBER-BOOKS 2\\", \\"BOOK-MEMBER 1\\", \\"BOOK-MEMBER 2\\" ] expected_output = [ \\"NO\\", \\"NO\\", \\"NONE\\", \\"NONE\\", \\"NONE\\", \\"NONE\\" ] assert process_operations(N, M, operations) == expected_output def test_borrow_and_return(): N = 2 M = 3 operations = [ \\"BORROW 1 1\\", \\"BORROW 2 2\\", \\"CHECK 1 1\\", \\"CHECK 2 2\\", \\"RETURN 1 1\\", \\"CHECK 1 1\\", \\"MEMBER-BOOKS 1\\", \\"MEMBER-BOOKS 2\\", \\"BOOK-MEMBER 1\\", \\"BOOK-MEMBER 2\\" ] expected_output = [ \\"YES\\", \\"YES\\", \\"NO\\", \\"NONE\\", \\"2\\", \\"NONE\\", \\"2\\" ] assert process_operations(N, M, operations) == expected_output def test_multiple_borrows(): N = 3 M = 3 operations = [ \\"BORROW 1 1\\", \\"BORROW 1 2\\", \\"BORROW 2 3\\", \\"MEMBER-BOOKS 1\\", \\"MEMBER-BOOKS 2\\", \\"BOOK-MEMBER 1\\", \\"BOOK-MEMBER 2\\", \\"BOOK-MEMBER 3\\" ] expected_output = [ \\"1 2\\", \\"3\\", \\"1\\", \\"1\\", \\"2\\" ] assert process_operations(N, M, operations) == expected_output","solution":"from collections import defaultdict class LibrarySystem: def __init__(self, N, M): self.N = N self.M = M self.members_books = defaultdict(set) self.books_member = dict() def borrow(self, A, B): if B not in self.books_member: self.members_books[A].add(B) self.books_member[B] = A def return_book(self, A, B): if self.books_member.get(B) == A: self.members_books[A].remove(B) del self.books_member[B] def check(self, A, B): return \\"YES\\" if self.books_member.get(B) == A else \\"NO\\" def member_books(self, A): if self.members_books[A]: return ' '.join(map(str, sorted(self.members_books[A]))) else: return \\"NONE\\" def book_member(self, B): return str(self.books_member[B]) if B in self.books_member else \\"NONE\\" def process_operations(N, M, operations): library = LibrarySystem(N, M) result = [] for operation in operations: parts = operation.split() cmd = parts[0] if cmd == \\"BORROW\\": A, B = int(parts[1]), int(parts[2]) library.borrow(A, B) elif cmd == \\"RETURN\\": A, B = int(parts[1]), int(parts[2]) library.return_book(A, B) elif cmd == \\"CHECK\\": A, B = int(parts[1]), int(parts[2]) result.append(library.check(A, B)) elif cmd == \\"MEMBER-BOOKS\\": A = int(parts[1]) result.append(library.member_books(A)) elif cmd == \\"BOOK-MEMBER\\": B = int(parts[1]) result.append(library.book_member(B)) return result"},{"question":"from typing import List, Tuple def max_distance_per_day(test_cases: List[Tuple[int, List[int]]]) -> List[int]: Given the number of test cases, and for each test case, the number of days and the distances run each day, returns a list of maximum distances run on any single day for each test case. >>> max_distance_per_day([(3, [5, 0, 10]), (4, [0, 0, 0, 0])]) [10, 0] >>> max_distance_per_day([(1, [6]), (1, [0])]) [6, 0]","solution":"def max_distance_per_day(test_cases): Given the number of test cases, and for each test case, the number of days and the distances run each day, this function returns a list of maximum distances run on any single day for each test case. results = [] for case in test_cases: days, distances = case results.append(max(distances)) return results # Example usage # test_cases = [ # (3, [5, 0, 10]), # (4, [0, 0, 0, 0]) # ] # print(max_distance_per_day(test_cases)) # Output: [10, 0]"},{"question":"from typing import List def compute_decimal_value(n: int, fractions: List[str]) -> List[str]: Compute decimal values of fractions up to 5 decimal places. Parameters: n (int): The number of fractions to process. fractions (list of str): List of fraction representations in the form 'x | : | y'. Returns: list of str: The decimal values up to 5 decimal places. def test_compute_decimal_value(): assert compute_decimal_value(4, [\\"1 | : | 2\\", \\"3 | : | 4\\", \\"10 | : | 5\\", \\"7 | : | 3\\"]) == [\\"0.50000\\", \\"0.75000\\", \\"2.00000\\", \\"2.33333\\"] assert compute_decimal_value(2, [\\"1 | : | 3\\", \\"2 | : | 5\\"]) == [\\"0.33333\\", \\"0.40000\\"] assert compute_decimal_value(3, [\\"99 | : | 100\\", \\"4 | : | 7\\", \\"9 | : | 18\\"]) == [\\"0.99000\\", \\"0.57143\\", \\"0.50000\\"] assert compute_decimal_value(1, [\\"1 | : | 1\\"]) == [\\"1.00000\\"] assert compute_decimal_value(1, [\\"0 | : | 5\\"]) == [\\"0.00000\\"] if __name__ == \\"__main__\\": test_compute_decimal_value() print(\\"All tests passed.\\")","solution":"def compute_decimal_value(n, fractions): Compute decimal values of fractions up to 5 decimal places. Parameters: n (int): The number of fractions to process. fractions (list of str): List of fraction representations in the form 'x | : | y'. Returns: list of str: The decimal values up to 5 decimal places. results = [] for fraction in fractions: # Split the fraction into numerator and denominator numerator, denominator = map(int, fraction.split(' | : | ')) # Compute the decimal value decimal_value = numerator / denominator # Format the result to 5 decimal places and add it to the results results.append(f\\"{decimal_value:.5f}\\") return results"},{"question":"def minimal_integer_with_digit_sum(N): Given an integer N, finds the minimal integer X such that the sum of all digits of X equals N. If no such integer exists, returns -1. >>> minimal_integer_with_digit_sum(9) == 9 >>> minimal_integer_with_digit_sum(15) == 69 >>> minimal_integer_with_digit_sum(0) == -1","solution":"def minimal_integer_with_digit_sum(N): Given an integer N, finds the minimal integer X such that the sum of all digits of X equals N. If no such integer exists, returns -1. if N == 0: return -1 result = [] while N > 0: digit = min(9, N) result.append(str(digit)) N -= digit return int(''.join(result[::-1]))"},{"question":"def second_smallest_unique(nums: str): Reads a list of integers from a string and prints the second smallest unique integer from the list. If there is no second smallest unique integer, prints \\"Not found\\". Examples: >>> second_smallest_unique(\\"2 3 4 2 1 5 3\\") 3 >>> second_smallest_unique(\\"1 1 1 1\\") Not found >>> second_smallest_unique(\\"5 5 4 4 3 3 2 2 1 1 0 0 -1 -1 -2 -2\\") -1 >>> second_smallest_unique(\\"10 20 30 40\\") 20 >>> second_smallest_unique(\\"-10000 9999 0 -50 50 50 -50\\") 0","solution":"def second_smallest_unique(nums): Finds and prints the second smallest unique integer from the list. If there is no second smallest unique integer, prints \\"Not found\\". Args: nums (str): A string of space-separated integers. # Parse the input string to a list of integers nums = list(map(int, nums.split())) # Filter out the unique elements and sort them unique_nums = sorted(set(nums)) # Check if there are at least two unique elements if len(unique_nums) < 2: print(\\"Not found\\") else: print(unique_nums[1])"},{"question":"from typing import List def minimize_difference_sum(n: int, P: List[int]) -> List[int]: Rearranges the list of stone powers to minimize the sum of absolute differences of consecutive stone values. Parameters: n (int): The number of magical stones. P (list): A list of integers representing the power of each stone. Returns: list: The permutation of the stone powers that minimizes the difference sum. >>> minimize_difference_sum(4, [4, 1, 3, 2]) [1, 2, 3, 4] >>> minimize_difference_sum(5, [1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> minimize_difference_sum(5, [5, 4, 3, 2, 1]) [1, 2, 3, 4, 5] >>> minimize_difference_sum(1, [10]) [10] >>> minimize_difference_sum(5, [4, 4, 2, 2, 3]) [2, 2, 3, 4, 4] >>> minimize_difference_sum(4, [100000, 1, 99999, 2]) [1, 2, 99999, 100000] >>> minimize_difference_sum(2, [100000, 1]) [1, 100000]","solution":"def minimize_difference_sum(n, P): Rearranges the list of stone powers to minimize the sum of absolute differences of consecutive stone values. Parameters: n (int): The number of magical stones. P (list): A list of integers representing the power of each stone. Returns: list: The permutation of the stone powers that minimizes the difference sum. # Sort the stone powers in ascending order P_sorted = sorted(P) return P_sorted"},{"question":"import string from typing import Dict def word_frequency(sentence: str) -> Dict[str, int]: Write a function that takes a sentence as input and returns a dictionary with the frequency of each word in the sentence. The function should be case-insensitive and ignore any punctuation. :param sentence: A string representing the sentence. :return: A dictionary with words as keys and their frequency as values. Example: >>> word_frequency(\\"Hello, hello! How are you? You look great.\\") {'hello': 2, 'how': 1, 'are': 1, 'you': 2, 'look': 1, 'great': 1}","solution":"import string def word_frequency(sentence): Returns a dictionary with the frequency of each word in the sentence. The function is case-insensitive and ignores any punctuation. :param sentence: A string representing the sentence. :return: A dictionary with words as keys and their frequency as values. # Remove punctuation translator = str.maketrans('', '', string.punctuation) cleaned_sentence = sentence.translate(translator) # Convert to lowercase and split into words words = cleaned_sentence.lower().split() # Count frequencies frequency = {} for word in words: if word in frequency: frequency[word] += 1 else: frequency[word] = 1 return frequency"},{"question":"def count_unique_pairs(nums: List[int], target_sum: int) -> int: Determines the number of unique pairs that sum up to the target sum. Args: nums (list): List of integers. target_sum (int): The target sum. Returns: int: The count of unique pairs. # Your code here # Unit Tests def test_count_unique_pairs_sample(): nums = [1, 5, 7, -1, 5] target_sum = 6 assert count_unique_pairs(nums, target_sum) == 2 def test_count_unique_pairs_no_pairs(): nums = [1, 2, 3, 4, 5] target_sum = 10 assert count_unique_pairs(nums, target_sum) == 0 def test_count_unique_pairs_all_negative(): nums = [-1, -2, -3, -4, -5] target_sum = -3 assert count_unique_pairs(nums, target_sum) == 1 def test_count_unique_pairs_mixed_signs(): nums = [-1, 1, -2, 2, -3, 3] target_sum = 0 assert count_unique_pairs(nums, target_sum) == 3 def test_count_unique_pairs_duplicates(): nums = [1, 2, 2, 3, 4, 4, 5] target_sum = 6 assert count_unique_pairs(nums, target_sum) == 2 def test_count_unique_pairs_large_numbers(): nums = [1000000000, -1000000000, 2000000000, -2000000000, 0] target_sum = 0 assert count_unique_pairs(nums, target_sum) == 2","solution":"def count_unique_pairs(nums, target_sum): Determines the number of unique pairs that sum up to the target sum. Args: nums (list): List of integers. target_sum (int): The target sum. Returns: int: The count of unique pairs. seen = set() pairs = set() for num in nums: complement = target_sum - num if complement in seen: pairs.add(tuple(sorted((num, complement)))) seen.add(num) return len(pairs)"},{"question":"def count_symmetry_trees(n: int) -> int: Returns the number of distinct Symmetry Trees that can be created with exactly n nodes. Note: The result should be modulo 10^9 + 7. >>> count_symmetry_trees(4) 2 >>> count_symmetry_trees(2) 1 MOD = 10**9 + 7 if n % 2 != 0: return 0 # This DP array will store the count of BSTs possible with different number of nodes dp = [0] * (n + 1) dp[0] = 1 dp[2] = 1 for nodes in range(4, n + 1, 2): total = 0 for left_nodes in range(0, nodes, 2): right_nodes = nodes - 2 - left_nodes total += dp[left_nodes] * dp[right_nodes] total %= MOD dp[nodes] = total return dp[n] # Unit tests for count_symmetry_trees def test_symmetry_tree_base_case(): assert count_symmetry_trees(2) == 1 def test_symmetry_tree_example_case(): assert count_symmetry_trees(4) == 2 # From the provided example output def test_symmetry_tree_larger_case(): assert count_symmetry_trees(6) > 0 # There should be more than zero symmetry trees for 6 nodes def test_symmetry_tree_modulo_case(): assert count_symmetry_trees(50) < 10**9 + 7 # Verify that the number is less than the modulo def test_symmetry_tree_non_multiple_case(): assert count_symmetry_trees(3) == 0 # odd number (not even) def test_symmetry_tree_all_valid_cases(): assert count_symmetry_trees(8) == 14 # verifying for 8 which is a next valid even number","solution":"MOD = 10**9 + 7 def count_symmetry_trees(n): Returns the number of distinct Symmetry Trees that can be created with exactly n nodes. if n % 2 != 0: return 0 # This DP array will store the count of BSTs possible with different number of nodes dp = [0] * (n + 1) dp[0] = 1 dp[2] = 1 for nodes in range(4, n + 1, 2): total = 0 for left_nodes in range(0, nodes, 2): right_nodes = nodes - 2 - left_nodes total += dp[left_nodes] * dp[right_nodes] total %= MOD dp[nodes] = total return dp[n] # Example Usage print(count_symmetry_trees(4)) # Example from the problem: Expected output is 2"},{"question":"from typing import List def find_smallest_missing_positive(nums: List[int]) -> int: Finds the smallest positive integer missing from the list nums. >>> find_smallest_missing_positive([3, 4, -1, 1, 2, 6]) 5 >>> find_smallest_missing_positive([1, 2, 3, 4, 5]) 6","solution":"def find_smallest_missing_positive(nums): Finds the smallest positive integer missing from the list nums. nums = set(nums) # Convert list to a set to remove duplicates and for O(1) lookups smallest_missing = 1 while smallest_missing in nums: smallest_missing += 1 return smallest_missing"},{"question":"from typing import List, Tuple def exhibitions(n: int, k: int) -> Tuple[int, List[Tuple[int, ...]]]: Returns a list of all possible unique exhibitions that can be organized with k items from n items. >>> exhibitions(5, 2) (10, [(1, 2), (1, 3), (1, 4), (1, 5), (2, 3), (2, 4), (2, 5), (3, 4), (3, 5), (4, 5)]) >>> exhibitions(4, 4) (1, [(1, 2, 3, 4)]) >>> exhibitions(3, 4) (0, []) >>> exhibitions(1, 1) (1, [(1,)]) >>> exhibitions(6, 2) (15, [(1, 2), (1, 3), (1, 4), (1, 5), (1, 6), (2, 3), (2, 4), (2, 5), (2, 6), (3, 4), (3, 5), (3, 6), (4, 5), (4, 6), (5, 6)])","solution":"from itertools import combinations def exhibitions(n, k): Returns a list of all possible unique exhibitions that can be organized with k items from n items. if k > n: return 0, [] item_ids = list(range(1, n+1)) exhibits = list(combinations(item_ids, k)) return len(exhibits), exhibits # Example usage n, k = 5, 2 count, exhibitions_list = exhibitions(n, k) print(count) for exhibition in exhibitions_list: print(*exhibition)"},{"question":"from typing import List def filter_primes(nums: List[int]) -> List[int]: Returns a list of prime numbers from the input list of integers. >>> filter_primes([2, 4, 5, 6, 9, 11, 13]) [2, 5, 11, 13] >>> filter_primes([-3, 0, 1, 4, 7, 8]) [7]","solution":"def is_prime(n): Returns True if n is a prime number, otherwise False. if n <= 1: return False if n == 2: return True # 2 is the only even prime number if n % 2 == 0: return False for i in range(3, int(n**0.5) + 1, 2): if n % i == 0: return False return True def filter_primes(nums): Returns a list of prime numbers from the input list of integers. return [num for num in nums if is_prime(num)]"},{"question":"def tournament_champion(n: int, skills: List[int]) -> int: Determine the champion of the tournament. Args: n (int): The number of players. skills (list of int): The skill ratings of the players. Returns: int: The skill rating of the tournament champion. Examples: >>> tournament_champion(5, [4, 1, 7, 3, 2]) 7 >>> tournament_champion(6, [5, 3, 2, 8, 6, 4]) 8 >>> tournament_champion(3, [6, 1, 9]) 9","solution":"def tournament_champion(n, skills): Determine the champion of the tournament. Args: n (int): The number of players. skills (list of int): The skill ratings of the players. Returns: int: The skill rating of the tournament champion. while len(skills) > 1: next_round = [] for i in range(0, len(skills) - 1, 2): if skills[i] > skills[i + 1]: next_round.append(skills[i]) else: next_round.append(skills[i + 1]) if len(skills) % 2 == 1: next_round.append(skills[-1]) skills = next_round return skills[0]"},{"question":"class Grid: def __init__(self, n, m): Initialize the grid with zero values. Args: n (int): number of rows. m (int): number of columns. self.n = n self.m = m self.grid = [[0] * (m + 1) for _ in range(n + 1)] def update(self, x, y, v): Update the value at cell (x, y) to v. Args: x (int): row index. y (int): column index. v (int): value to be updated. pass def query(self, x0, y0, x1, y1): Query the sum of the sub-grid from (x0, y0) to (x1, y1). Args: x0 (int): starting row index. y0 (int): starting column index. x1 (int): ending row index. y1 (int): ending column index. Returns: int: sum of the elements in the specified subgrid. pass def main(operations): Execute a series of update and query operations on the grid. Args: operations (list of tuples): operations to be performed. Returns: list: results of the query operations. >>> operations = [(6, 5), (2, 2, 1, 5), (2, 3, 2, 3), (1, 1, 1, 3, 3), (2, 1, 4, 2), (1, 1, 1, 4, 4)] >>> main(operations) [8, 10] pass # Unit test cases import pytest def test_example_case(): operations = [ (6, 5), (2, 2, 1, 5), (2, 3, 2, 3), (1, 1, 1, 3, 3), (2, 1, 4, 2), (1, 1, 1, 4, 4) ] assert main(operations) == [8, 10] def test_all_zeros_query(): operations = [ (3, 2), (1, 1, 1, 3, 3), (1, 2, 2, 2, 2) ] assert main(operations) == [0, 0] def test_full_update_query(): operations = [ (3, 4), (2, 1, 1, 1), (2, 2, 2, 2), (2, 3, 3, 3), (1, 1, 1, 3, 3) ] assert main(operations) == [6] def test_partial_update_query(): operations = [ (5, 3), (2, 2, 2, 10), (2, 3, 4, 5), (1, 2, 2, 3, 4) ] assert main(operations) == [15] def test_edge_case_query_and_update(): operations = [ (1000, 3), (2, 1, 1, 100), (1, 1, 1, 1, 1), (1, 2, 2, 1000, 1000) ] assert main(operations) == [100, 0]","solution":"class Grid: def __init__(self, n, m): self.n = n self.m = m self.grid = [[0] * (m + 1) for _ in range(n + 1)] def update(self, x, y, v): self.grid[x][y] = v def query(self, x0, y0, x1, y1): total_sum = 0 for i in range(x0, x1 + 1): for j in range(y0, y1 + 1): total_sum += self.grid[i][j] return total_sum def main(operations): n, q = operations[0][0], operations[0][1] grid = Grid(n, n) result = [] for op in operations[1:]: if op[0] == 1: result.append(grid.query(op[1], op[2], op[3], op[4])) elif op[0] == 2: grid.update(op[1], op[2], op[3]) return result # Example usage: operations = [ (6, 5), (2, 2, 1, 5), (2, 3, 2, 3), (1, 1, 1, 3, 3), (2, 1, 4, 2), (1, 1, 1, 4, 4) ] print(main(operations)) # Output should be [8, 10]"},{"question":"def organizeBooks(readBooks, newBooks): This function organizes new books by sorting them alphabetically, excluding those that have already been read by Mike. Parameters: readBooks (list of str): Titles of books Mike has already read. newBooks (list of str): Titles of newly arrived books. Returns: list of str: Titles of books to be organized, in alphabetical order. # Test cases def test_organizeBooks_all_new_books(): assert organizeBooks([\\"Moby Dick\\", \\"To Kill a Mockingbird\\"], [\\"December 6\\", \\"Night\\"]) == [\\"December 6\\", \\"Night\\"] def test_organizeBooks_some_already_read(): assert organizeBooks([\\"Moby Dick\\", \\"To Kill a Mockingbird\\"], [\\"December 6\\", \\"Moby Dick\\", \\"Night\\", \\"To Kill a Mockingbird\\"]) == [\\"December 6\\", \\"Night\\"] def test_organizeBooks_none_new_books(): assert organizeBooks([\\"Moby Dick\\", \\"To Kill a Mockingbird\\"], [\\"Moby Dick\\", \\"To Kill a Mockingbird\\"]) == [] def test_organizeBooks_no_read_books(): assert organizeBooks([], [\\"December 6\\", \\"Night\\"]) == [\\"December 6\\", \\"Night\\"] def test_organizeBooks_no_new_books(): assert organizeBooks([\\"Moby Dick\\", \\"To Kill a Mockingbird\\"], []) == [] def test_organizeBooks_mixed_case_titles(): assert organizeBooks([\\"Moby Dick\\"], [\\"moby dick\\", \\"Night\\"]) == [\\"Night\\", \\"moby dick\\"]","solution":"def organizeBooks(readBooks, newBooks): This function organizes new books by sorting them alphabetically, excluding those that have already been read by Mike. Parameters: readBooks (list of str): Titles of books Mike has already read. newBooks (list of str): Titles of newly arrived books. Returns: list of str: Titles of books to be organized, in alphabetical order. # Filter out the books that have already been read booksToOrganize = [book for book in newBooks if book not in readBooks] # Sort the remaining books alphabetically booksToOrganize.sort() return booksToOrganize"},{"question":"from typing import List, Tuple def is_cycle_in_graphs(cases: List[Tuple[int, int, List[Tuple[int, int]]]]) -> List[str]: Given a list of test cases, each containing the number of nodes, the number of edges, and a list of edges, determine if there is a cycle in the graph for each test case. >>> is_cycle_in_graphs([(4, 4, [(1, 2), (2, 3), (3, 4), (4, 2)]), (3, 2, [(1, 2), (2, 3)])]) [\\"YES\\", \\"NO\\"] >>> is_cycle_in_graphs([(5, 5, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 1)]), (4, 3, [(1, 2), (2, 3), (3, 4)])]) [\\"YES\\", \\"NO\\"]","solution":"def detect_cycle(N, M, edges): from collections import defaultdict, deque def bfs(start_node, graph, visited): parent = {start_node: -1} queue = deque([start_node]) visited[start_node] = True while queue: node = queue.popleft() for neighbor in graph[node]: if not visited[neighbor]: visited[neighbor] = True parent[neighbor] = node queue.append(neighbor) elif parent[node] != neighbor: return True return False graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) visited = {i: False for i in range(1, N + 1)} for node in range(1, N + 1): if not visited[node]: if bfs(node, graph, visited): return \\"YES\\" return \\"NO\\" def is_cycle_in_graphs(cases): results = [] for case in cases: N, M, edges = case result = detect_cycle(N, M, edges) results.append(result) return results"},{"question":"def calculate_overlap_time(device_times): Calculate the overlap time during which all devices are on simultaneously. Args: device_times: List of tuples, where each tuple consists of (turn_on_time, turn_off_time). Returns: Total overlap time during which all devices are on simultaneously. >>> calculate_overlap_time([(1, 5), (2, 6), (4, 8)]) 1 >>> calculate_overlap_time([(0, 4), (5, 10)]) 0 >>> calculate_overlap_time([(1, 3), (2, 5), (6, 8), (7, 9)]) 0 >>> calculate_overlap_time([]) 0 >>> calculate_overlap_time([(1, 10)]) 9 >>> calculate_overlap_time([(1, 10), (2, 7), (3, 9)]) 4 >>> calculate_overlap_time([(1, 5), (4, 8), (2, 6)]) 1","solution":"def calculate_overlap_time(device_times): Calculate the overlap time during which all devices are on simultaneously. Args: device_times: List of tuples, where each tuple consists of (turn_on_time, turn_off_time). Returns: Total overlap time during which all devices are on simultaneously. if not device_times: return 0 # Initial min_on_time is the maximum starting time min_on_time = max(device[0] for device in device_times) # Initial max_off_time is the minimum ending time max_off_time = min(device[1] for device in device_times) # Calculate the total overlap time overlap_time = max(0, max_off_time - min_on_time) return overlap_time"},{"question":"from typing import List, Tuple def process_queries(n: int, m: int, edges: List[Tuple[int, int]], q: int, queries: List[Tuple[int, int, int]]) -> List: Process queries to find shortest paths and direct connections in a graph. Parameters: n (int): number of nodes m (int): number of edges edges (List[Tuple[int, int]]): list of edges q (int): number of queries queries (List[Tuple[int, int, int]]): list of queries Returns: List: results of the queries Example: >>> n = 6 >>> m = 5 >>> edges = [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)] >>> q = 4 >>> queries = [(1, 1, 6), (2, 3, 4), (1, 2, 5), (2, 1, 6)] >>> process_queries(n, m, edges, q, queries) [5, \\"yes\\", 3, \\"no\\"] pass def test_process_queries(): n = 6 m = 5 edges = [ (1, 2), (2, 3), (3, 4), (4, 5), (5, 6) ] q = 4 queries = [ (1, 1, 6), (2, 3, 4), (1, 2, 5), (2, 1, 6) ] expected_output = [5, \\"yes\\", 3, \\"no\\"] assert process_queries(n, m, edges, q, queries) == expected_output def test_directly_connected_nodes(): n = 4 m = 3 edges = [ (1, 2), (2, 3), (3, 4) ] q = 2 queries = [ (2, 1, 2), (2, 1, 3) ] expected_output = [\\"yes\\", \\"no\\"] assert process_queries(n, m, edges, q, queries) == expected_output def test_shortest_path_multiple_components(): n = 6 m = 3 edges = [ (1, 2), (2, 3), (4, 5) ] q = 2 queries = [ (1, 1, 3), (1, 3, 4) ] expected_output = [2, -1] assert process_queries(n, m, edges, q, queries) == expected_output def test_self_loop_zero_distance(): n = 5 m = 4 edges = [ (1, 2), (2, 3), (3, 4), (4, 5) ] q = 1 queries = [ (1, 1, 1) ] expected_output = [0] assert process_queries(n, m, edges, q, queries) == expected_output","solution":"from collections import defaultdict, deque def process_queries(n, m, edges, q, queries): # Create the adjacency list for the graph graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) def bfs_shortest_path(start, end): if start == end: return 0 visited = set() queue = deque([(start, 0)]) while queue: current, distance = queue.popleft() if current == end: return distance for neighbor in graph[current]: if neighbor not in visited: visited.add(neighbor) queue.append((neighbor, distance + 1)) return -1 def is_directly_connected(x, y): return \\"yes\\" if y in graph[x] else \\"no\\" results = [] for t, x, y in queries: if t == 1: results.append(bfs_shortest_path(x, y)) elif t == 2: results.append(is_directly_connected(x, y)) return results"},{"question":"def find_subordinates(N: int, relationships: List[Tuple[int, int]]) -> List[int]: Find the number of direct and indirect subordinates (all levels below) each employee has. Args: N: int: The number of employees (including the CEO). relationships: List[Tuple[int, int]]: The supervisor-subordinate relationship (employee, supervisor). Returns: List[int]: A list where the i-th element is the number of subordinates of employee with ID i+1. Example: >>> find_subordinates(5, [(2, 1), (3, 1), (4, 2), (5, 2)]) [4, 2, 0, 0, 0] >>> find_subordinates(2, [(2, 1)]) [1, 0] pass # Your code here","solution":"def find_subordinates(N, relationships): from collections import defaultdict, deque # Build the graph subordinates = defaultdict(list) for employee, supervisor in relationships: subordinates[supervisor].append(employee) # Initialize the count of subordinates for each employee sub_count = {i: 0 for i in range(1, N + 1)} # Function to perform DFS and count subordinates def dfs(employee): count = 0 for sub in subordinates[employee]: count += 1 + dfs(sub) sub_count[employee] = count return count # Finding the CEO (employee with no supervisor) all_ids = set(range(1, N + 1)) supervised_ids = {employee for employee, supervisor in relationships} ceo = list(all_ids - supervised_ids)[0] # Perform DFS starting from the CEO dfs(ceo) # Return the subordinate counts in order of employee ID return [sub_count[i] for i in range(1, N + 1)]"},{"question":"def min_deletions_to_palindrome(s: str) -> int: Returns the minimum number of characters that need to be removed to make the given string a palindrome. >>> min_deletions_to_palindrome(\\"abca\\") 1 >>> min_deletions_to_palindrome(\\"racecar\\") 0 def test_min_deletions_to_palindrome(): assert min_deletions_to_palindrome(\\"abca\\") == 1 assert min_deletions_to_palindrome(\\"racecar\\") == 0 assert min_deletions_to_palindrome(\\"abc\\") == 2 assert min_deletions_to_palindrome(\\"aabcca\\") == 2 assert min_deletions_to_palindrome(\\"abcba\\") == 0 assert min_deletions_to_palindrome(\\"abcd\\") == 3 assert min_deletions_to_palindrome(\\"abcbdda\\") == 2 assert min_deletions_to_palindrome(\\"abccba\\") == 0 assert min_deletions_to_palindrome(\\"a\\") == 0 assert min_deletions_to_palindrome(\\"aaaa\\") == 0","solution":"def min_deletions_to_palindrome(s): Returns the minimum number of characters that need to be removed to make the given string a palindrome. def longest_palindromic_subsequence(s): n = len(s) dp = [[0] * n for _ in range(n)] for i in range(n): dp[i][i] = 1 for length in range(2, n+1): for i in range(n-length+1): j = i+length-1 if s[i] == s[j]: dp[i][j] = dp[i+1][j-1] + 2 else: dp[i][j] = max(dp[i+1][j], dp[i][j-1]) return dp[0][n-1] lps_length = longest_palindromic_subsequence(s) return len(s) - lps_length"},{"question":"def count_derangements(n: int) -> int: Calculate the number of derangements for n people, where no one receives their own gift back. Parameters: n (int): The number of people in the group. Returns: int: The number of possible derangements. Examples: >>> count_derangements(3) 2 >>> count_derangements(4) 9 pass import pytest def test_count_derangements(): assert count_derangements(0) == 1 assert count_derangements(1) == 0 assert count_derangements(2) == 1 assert count_derangements(3) == 2 assert count_derangements(4) == 9 assert count_derangements(5) == 44 assert count_derangements(20) == 895014631192902121","solution":"def count_derangements(n: int) -> int: Returns the number of derangements (permutations where no element appears in its original position) for n items. if n == 0: return 1 # By definition, there's 1 way to derange 0 items. if n == 1: return 0 # No way to derange 1 item. if n == 2: return 1 # Only 1 possible derangement: (2, 1) # Use a list to store the results for intermediate values derangements = [0] * (n + 1) derangements[0] = 1 derangements[1] = 0 derangements[2] = 1 for i in range(3, n + 1): derangements[i] = (i - 1) * (derangements[i - 1] + derangements[i - 2]) return derangements[n]"},{"question":"from typing import List def sort_even_odd(arr: List[int]) -> List[int]: Returns a new array where all even numbers are placed before odd numbers, while maintaining their original relative order within each group. >>> sort_even_odd([3, 1, 2, 4, 7, 6, 5, 8, 9]) [2, 4, 6, 8, 3, 1, 7, 5, 9] >>> sort_even_odd([3, 1, 7, 5, 9]) [3, 1, 7, 5, 9] >>> sort_even_odd([2, 4, 6, 8]) [2, 4, 6, 8] >>> sort_even_odd([]) [] >>> sort_even_odd([2]) [2] >>> sort_even_odd([3]) [3] >>> sort_even_odd([1, 4, 5, 6, 7, 8]) [4, 6, 8, 1, 5, 7]","solution":"from typing import List def sort_even_odd(arr: List[int]) -> List[int]: Returns a new array where all even numbers are placed before odd numbers, while maintaining their original relative order within each group. evens = [x for x in arr if x % 2 == 0] odds = [x for x in arr if x % 2 != 0] return evens + odds"},{"question":"def calculate_trips(n, parcels, x): Calculate the minimum number of trips each robot needs to make and the total number of trips. Parameters: n (int): Number of robots parcels (list): List of integers where each integer represents the number of parcels assigned to each robot x (int): Maximum number of parcels each robot can carry per trip Returns: tuple: A tuple containing two elements: - A list of integers where each integer indicates the number of trips made by each corresponding robot - An integer representing the total number of trips made by all robots >>> calculate_trips(5, [10, 20, 30, 40, 50], 10) ([1, 2, 3, 4, 5], 15) >>> calculate_trips(1, [14], 5) ([3], 3) >>> calculate_trips(3, [30, 40, 50], 10) ([3, 4, 5], 12) >>> calculate_trips(3, [0, 20, 0], 10) ([0, 2, 0], 2) >>> calculate_trips(2, [1000000, 2000000], 100000) ([10, 20], 30)","solution":"def calculate_trips(n, parcels, x): Calculate the minimum number of trips each robot needs to make and the total number of trips. Parameters: n (int): Number of robots parcels (list): List of integers where each integer represents the number of parcels assigned to each robot x (int): Maximum number of parcels each robot can carry per trip Returns: tuple: A tuple containing two elements: - A list of integers where each integer indicates the number of trips made by each corresponding robot - An integer representing the total number of trips made by all robots trips = [(p + x - 1) // x for p in parcels] total_trips = sum(trips) return trips, total_trips # Example Usage n = 5 parcels = [10, 20, 30, 40, 50] x = 10 result = calculate_trips(n, parcels, x) print(result[0]) # [1, 2, 3, 4, 5] print(result[1]) # 15"},{"question":"def max_path_sum(grid): Given a grid with rows and columns, this function finds a path from the top-left corner to the bottom-right corner and returns the maximum sum of values possible along any valid path. The moves allowed are either to the right or downward cells. Parameters: grid (list of list of int): 2D array representing the grid values Returns: int: maximum sum of values along any valid path >>> max_path_sum([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 12 >>> max_path_sum([[2, 2], [1, 3]]) 7","solution":"def max_path_sum(grid): Returns the maximum sum of values possible along any valid path from the top-left to the bottom-right corner of the grid. Parameters: grid (list of list of int): 2D array representing the grid values Returns: int: maximum sum of values along any valid path if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) # Use dynamic programming to store the maximum path sums dp = [[0] * n for _ in range(m)] dp[0][0] = grid[0][0] # Initialize the first row for j in range(1, n): dp[0][j] = dp[0][j-1] + grid[0][j] # Initialize the first column for i in range(1, m): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill in the rest of the dp table for i in range(1, m): for j in range(1, n): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[m-1][n-1]"}]`),E={name:"App",components:{PoemCard:A},data(){return{searchQuery:"",visibleCount:4,poemsData:S,isLoading:!1}},computed:{filteredPoems(){const i=this.searchQuery.trim().toLowerCase();return i?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(i)||e.solution&&e.solution.toLowerCase().includes(i)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(i=>setTimeout(i,1e3)),this.visibleCount+=4,this.isLoading=!1}}},z={class:"search-container"},C={class:"card-container"},P={key:0,class:"empty-state"},j=["disabled"],D={key:0},F={key:1};function O(i,e,u,_,n,a){const f=h("PoemCard");return s(),r("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",z,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),g(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>n.searchQuery=o),placeholder:"Search..."},null,512),[[b,n.searchQuery]]),n.searchQuery?(s(),r("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>n.searchQuery="")}," ✕ ")):l("",!0)]),t("div",C,[(s(!0),r(y,null,x(a.displayedPoems,(o,p)=>(s(),v(f,{key:p,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(s(),r("div",P,' No results found for "'+d(n.searchQuery)+'". ',1)):l("",!0)]),a.hasMorePoems?(s(),r("button",{key:0,class:"load-more-button",disabled:n.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[n.isLoading?(s(),r("span",F,"Loading...")):(s(),r("span",D,"See more"))],8,j)):l("",!0)])}const B=m(E,[["render",O],["__scopeId","data-v-d72adc82"]]),M=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"guide/60.md","filePath":"guide/60.md"}'),I={name:"guide/60.md"},G=Object.assign(I,{setup(i){return(e,u)=>(s(),r("div",null,[w(B)]))}});export{M as __pageData,G as default};
