import{_ as c,o as n,c as i,a as t,m as h,t as d,C as g,M as _,U as y,f as u,F as b,p as w,e as v,q as x}from"./chunks/framework.B1z0IdBH.js";const k={name:"PoemCard",props:{poem:{type:Object,required:!0}}},T={class:"poem-container"},q={class:"review"},E={class:"review-title"},I={class:"review-content"};function A(r,e,l,p,s,a){return n(),i("div",T,[t("div",q,[t("div",E,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),h(d(l.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",I,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),h(d(l.poem.solution),1)])])])}const C=c(k,[["render",A],["__scopeId","data-v-28cb631c"]]),S=JSON.parse('[{"question":"# Working with Heaps: Implementing a Min-Heap Objective Build and manage a Min-Heap data structure from scratch to understand the underpinning mechanics and algorithm implementations. Task Implement a `MinHeap` class that supports the following operations: 1. **Insert**: Insert a new element into the heap, ensuring the min-heap property is maintained. 2. **Extract-Min**: Remove and return the minimum element from the heap, ensuring the min-heap property is maintained. 3. **Decrease-Key**: Given an index and a new key, update the value at that index to the new key, assuming the new key is smaller than the current key. 4. **Heapify**: Convert an arbitrary list of integers into a valid Min-Heap. Requirements - Ensure that the heap is implemented using an underlying array (or list in Python). - Implement the operations with the following method signatures: ```python def insert(self, key: int) -> None: pass def extract_min(self) -> int: pass def decrease_key(self, i: int, new_key: int) -> None: pass def heapify(self, arr: list[int]) -> None: pass ``` Input and Output Formats - **Insert**: - **Input**: An integer `key` - **Output**: None - **Extract-Min**: - **Input**: None - **Output**: Minimum integer in the heap - **Decrease-Key**: - **Input**: An integer `i` (index in the heap) and an integer `new_key` - **Output**: None - **Heapify**: - **Input**: A list of integers `arr` - **Output**: None Constraints - The heap can have up to 10,000 elements. - The integer keys are between `-10^6` and `10^6`. - The `insert` and `extract_min` operations should perform in O(log n) time. - The `decrease_key` and `heapify` operations should handle edge cases and maintain O(log n) and O(n) time complexities, respectively. Example ```python # Initialize MinHeap min_heap = MinHeap() # Insert elements min_heap.insert(10) min_heap.insert(5) min_heap.insert(20) min_heap.insert(2) # Extract the minimum element print(min_heap.extract_min()) # Output: 2 # Decrease key at index 2 to 1 min_heap.decrease_key(2, 1) # Extract the minimum element print(min_heap.extract_min()) # Output: 1 # Heapify an arbitrary array arr = [10, 3, 15, 8, 2, 7] min_heap.heapify(arr) # After heapify, extract the minimum element print(min_heap.extract_min()) # Output: 2 ``` Implement and thoroughly test all the functionalities to ensure the robustness and efficiency of your `MinHeap` class.","solution":"class MinHeap: def __init__(self): self.heap = [] def insert(self, key: int) -> None: self.heap.append(key) self._sift_up(len(self.heap) - 1) def extract_min(self) -> int: if len(self.heap) == 0: raise IndexError(\\"Extracting from an empty heap\\") min_element = self.heap[0] if len(self.heap) > 1: self.heap[0] = self.heap.pop() self._sift_down(0) else: self.heap.pop() return min_element def decrease_key(self, i: int, new_key: int) -> None: if new_key > self.heap[i]: raise ValueError(\\"new_key should be smaller than the current key\\") self.heap[i] = new_key self._sift_up(i) def heapify(self, arr: list[int]) -> None: self.heap = arr[:] for i in range((len(self.heap) // 2) - 1, -1, -1): self._sift_down(i) def _sift_up(self, index): parent = (index - 1) // 2 while index > 0 and self.heap[index] < self.heap[parent]: self.heap[index], self.heap[parent] = self.heap[parent], self.heap[index] index = parent parent = (index - 1) // 2 def _sift_down(self, index): smallest = index left = 2 * index + 1 right = 2 * index + 2 if left < len(self.heap) and self.heap[left] < self.heap[smallest]: smallest = left if right < len(self.heap) and self.heap[right] < self.heap[smallest]: smallest = right if smallest != index: self.heap[index], self.heap[smallest] = self.heap[smallest], self.heap[index] self._sift_down(smallest)"},{"question":"# Max Sum Rectangle in a 2D Matrix Context You are tasked with finding the maximum sum of any rectangle within a given 2D matrix. The rectangle can be of any size and can start and end at any row or column. Task Implement a function `max_sum_rectangle(matrix: List[List[int]]) -> int` that finds the maximum sum of any rectangle within the matrix. Input Specifications - `matrix` (List[List[int]]): A 2D grid of integers representing the input matrix. Output Specifications - (int): The maximum sum of any rectangle within the matrix. Constraints - The matrix will have dimensions `M x N`, where `1 <= M, N <= 100`. - The elements of the matrix will be integers in the range `[-10^5, 10^5]`. Example ```python matrix = [ [1, 2, -1, -4, -20], [-8, -3, 4, 2, 1], [3, 8, 10, 1, 3], [-4, -1, 1, 7, -6] ] max_sum_rectangle(matrix) ``` Output: ```python 29 ``` # Explanation The maximum sum rectangle is: ``` 3, 8, 10 -4, -1, 1, 7 ``` Which sums to: `3 + 8 + 10 + (-4) + (-1) + 1 + 7 = 24` # Implementation Implement the function `max_sum_rectangle` using the template below: ```python from typing import List def max_sum_rectangle(matrix: List[List[int]]) -> int: def kadane(arr: List[int]) -> int: max_end_here = max_so_far = arr[0] for x in arr[1:]: max_end_here = max(x, max_end_here + x) max_so_far = max(max_so_far, max_end_here) return max_so_far if not matrix or not matrix[0]: return 0 max_sum = float(\'-inf\') rows, cols = len(matrix), len(matrix[0]) for left in range(cols): temp = [0] * rows for right in range(left, cols): for row in range(rows): temp[row] += matrix[row][right] current_max = kadane(temp) max_sum = max(max_sum, current_max) return max_sum ``` This function utilizes Kadane\'s algorithm to find the maximum sum sub-array in a 1D array, and then applies it to sum columns of subarrays for different start and end columns. This approach ensures that the function runs efficiently even for larger matrices.","solution":"from typing import List def max_sum_rectangle(matrix: List[List[int]]) -> int: def kadane(arr: List[int]) -> int: max_end_here = max_so_far = arr[0] for x in arr[1:]: max_end_here = max(x, max_end_here + x) max_so_far = max(max_so_far, max_end_here) return max_so_far if not matrix or not matrix[0]: return 0 max_sum = float(\'-inf\') rows, cols = len(matrix), len(matrix[0]) for left in range(cols): temp = [0] * rows for right in range(left, cols): for row in range(rows): temp[row] += matrix[row][right] current_max = kadane(temp) max_sum = max(max_sum, current_max) return max_sum"},{"question":"# Objective Write a function `floor` to implement the floor function, which will return the largest integer that is less than or equal to a given floating-point number. # Input & Output * **Input**: A single floating-point number `x`. * **Output**: An integer representing the floor of `x`. # Constraints 1. You may not use the math library\'s floor function. 2. Assume the input is always a valid floating-point number and within the range of typical float representation. 3. Optimize the function to have O(1) time complexity and O(1) space complexity. # Example ```python # Example 1 # Input: 3.7 # Output: 3 # Example 2 # Input: -1.2 # Output: -2 # Example 3 # Input: 4.0 # Output: 4 ``` # Scenario Imagine you are developing a data processing tool where you need to round down floating-point values to their nearest lower integer for certain cumulative calculations. Implementing a custom `floor` function will provide you with precise control over these calculations. # Function Signature ```python def floor(x: float) -> int: pass ```","solution":"def floor(x): Returns the largest integer less than or equal to x. if x == int(x) or x > 0: return int(x) return int(x) - 1"},{"question":"Sorting a List of Custom Objects You are given a list of `Person` objects, where each object has three attributes: `first_name`, `last_name`, and `age`. Your task is to implement a function that sorts this list of `Person` instances first by `last_name` (in ascending order), then by `first_name` (in ascending order for those with the same `last_name`), and finally by `age` (in descending order for those with the same `first_name` and `last_name`). # Class Definition ```python class Person: def __init__(self, first_name: str, last_name: str, age: int): self.first_name = first_name self.last_name = last_name self.age = age def __repr__(self): return f\\"{self.first_name} {self.last_name} ({self.age})\\" ``` # Function Specification ```python def sort_people(people: list[Person]) -> list[Person]: # Implement your solution here ``` # Input * `people`: A list of `Person` objects. Each object has three attributes: `first_name` (a string), `last_name` (a string), and `age` (an integer). # Output * A sorted list of `Person` objects based on the specified criteria. # Constraints * The list will contain at least one `Person` object. * `1 <= len(people) <= 1000` * Any string attributes will have a length between 1 and 100 characters. * Age will be a non-negative integer (0 <= age <= 150). # Example ```python people = [ Person(\\"John\\", \\"Doe\\", 30), Person(\\"Jane\\", \\"Doe\\", 25), Person(\\"Alice\\", \\"Smith\\", 25), Person(\\"Alice\\", \\"Jones\\", 35), Person(\\"Bob\\", \\"Smith\\", 20), Person(\\"Alice\\", \\"Doe\\", 40) ] sorted_people = sort_people(people) assert sorted_people == [ Person(\\"Alice\\", \\"Doe\\", 40), Person(\\"Jane\\", \\"Doe\\", 25), Person(\\"John\\", \\"Doe\\", 30), Person(\\"Alice\\", \\"Jones\\", 35), Person(\\"Alice\\", \\"Smith\\", 25), Person(\\"Bob\\", \\"Smith\\", 20) ] ``` # Explanation Given a list of six `Person` objects with different `first_name`, `last_name`, and `age` attributes, the `sort_people` function returns a list of `Person` objects sorted first by `last_name`, then by `first_name`, and finally by `age` in descending order.","solution":"from typing import List class Person: def __init__(self, first_name: str, last_name: str, age: int): self.first_name = first_name self.last_name = last_name self.age = age def __repr__(self): return f\\"{self.first_name} {self.last_name} ({self.age})\\" def __eq__(self, other): return (self.first_name, self.last_name, self.age) == (other.first_name, other.last_name, other.age) def sort_people(people: List[Person]) -> List[Person]: return sorted(people, key=lambda p: (p.last_name, p.first_name, -p.age))"},{"question":"# Coding Challenge Context You need to write an algorithm that processes a sequence of strings and counts the number of times each string appears. The challenge involves designing a function that accepts a list of strings and returns a dictionary with the string counts. Task Implement a function: ```python def count_string_occurrences(strings: List[str]) -> Dict[str, int]: pass ``` Function Signature ```python from typing import List, Dict def count_string_occurrences(strings: List[str]) -> Dict[str, int]: ``` Input * A list of strings with length ( 1 leq text{len(strings)} leq 10^6 ). * Each string in the list contains only lowercase letters and has a length ( 1 leq text{len(string)} leq 100 ). Output * A dictionary where the keys are the unique strings from the input list and the values are their respective counts. Examples ```python >>> count_string_occurrences([\\"apple\\", \\"banana\\", \\"apple\\", \\"orange\\", \\"banana\\", \\"banana\\"]) {\'apple\': 2, \'banana\': 3, \'orange\': 1} >>> count_string_occurrences([\\"cat\\", \\"dog\\", \\"cat\\", \\"cat\\", \\"dog\\", \\"mouse\\"]) {\'cat\': 3, \'dog\': 2, \'mouse\': 1} ``` Constraints * Ensure that your algorithm efficiently handles the constraints. * Consider edge cases such as an empty list or a list with all unique strings to verify the robustness of your solution.","solution":"from typing import List, Dict def count_string_occurrences(strings: List[str]) -> Dict[str, int]: Counts the occurrences of each string in the given list of strings. Parameters: strings (List[str]): A list of strings containing lowercase letters. Returns: Dict[str, int]: A dictionary with strings as keys and their counts as values. # Initialize an empty dictionary to store the counts. string_counts = {} # Iterate over each string in the list. for string in strings: # If the string is already in the dictionary, increment its count. if string in string_counts: string_counts[string] += 1 # Otherwise, add the string to the dictionary with a count of 1. else: string_counts[string] = 1 return string_counts"},{"question":"# Problem: Implement a Simple Recursive Descent Parser You are tasked with implementing a simple recursive descent parser for a subset of arithmetic expressions. The expressions consist of non-negative integers and the operators `+`, `-`, `*`, and `/`, with correct handling of operator precedence and use of parentheses for grouping. # Constraints and Requirements 1. **Input**: A string representing the arithmetic expression. 2. **Output**: An integer or floating-point number that represents the evaluated value of the expression. # Specifications 1. The input expression will be a valid arithmetic expression with non-negative integers and the operators `+`, `-`, `*`, and `/`. 2. The expression may include parentheses `(` and `)` for altering the default precedence. 3. Division by zero must be handled by raising a `ZeroDivisionError`. 4. Report any syntactically incorrect expressions by raising a `ValueError`. # Function Signature ```python def parse_expression(expression: str) -> float: pass ``` # Example Usage ```python # Example 1 expression = \\"2 + 3 * 4 / (1 - 5)\\" assert parse_expression(expression) == 2 + 3 * 4 / (1 - 5) # Example 2 expression = \\"(2 + 3) * (4 - 1)\\" assert parse_expression(expression) == (2 + 3) * (4 - 1) # Example 3 - Division by Zero try: parse_expression(\\"10 / 0\\") except ZeroDivisionError as e: assert str(e) == \\"division by zero\\" # Example 4 - Syntactically incorrect expression try: parse_expression(\\"3 + * 2\\") except ValueError as e: assert str(e) == \\"Invalid expression\\" ``` # Additional Considerations 1. Your function should tokenize the input first and then apply recursive descent parsing techniques for evaluation. 2. Implement helper functions to handle different precedence levels and parenthesis. 3. Ensure all edge cases are correctly handled, such as invalid characters or misplaced operators.","solution":"import re def parse_expression(expression: str) -> float: tokens = tokenize(expression) tokens.append(\'\') # End of input marker index = 0 def next_token(): nonlocal index return tokens[index] def consume_token(): nonlocal index index += 1 def error(): raise ValueError(\\"Invalid expression\\") def eat(token): if next_token() == token: consume_token() else: error() def parse_factor(): token = next_token() if re.match(r\'^d+\', token): consume_token() return float(token) elif token == \'(\': consume_token() value = parse_expression() eat(\')\') return value else: error() def parse_term(): value = parse_factor() while next_token() in (\'*\', \'/\'): token = next_token() consume_token() factor = parse_factor() if token == \'*\': value *= factor elif token == \'/\': if factor == 0: raise ZeroDivisionError(\\"Division by zero\\") value /= factor return value def parse_expression(): value = parse_term() while next_token() in (\'+\', \'-\'): token = next_token() consume_token() term = parse_term() if token == \'+\': value += term elif token == \'-\': value -= term return value result = parse_expression() if next_token() != \'\': error() return result def tokenize(expression): tokens = re.findall(r\'d+|[()+-*/]\', expression) return tokens"},{"question":"# Problem Statement You\'re tasked with creating a function that determines the minimum steps required to transform a given string `s` into a palindrome by deleting characters. A palindrome reads the same forward and backward. # Function Signature ```python def min_steps_to_palindrome(s: str) -> int: Returns the minimum number of steps needed to make string `s` a palindrome by deleting characters. Parameters: - s (str): The input string, consisting of lowercase letters only (1 ≤ len(s) ≤ 10,000). Returns: int: The minimum number of character deletions required. ``` # Inputs * `s (str)`: A string consisting of lowercase letters. # Outputs * An integer representing the minimum number of steps (deletions) required to make the string a palindrome. # Constraints * 1 ≤ len(s) ≤ 10,000 # Example ```python >>> min_steps_to_palindrome(\\"abca\\") 1 >>> min_steps_to_palindrome(\\"racecar\\") 0 >>> min_steps_to_palindrome(\\"google\\") 2 ``` # Explanation 1. For `s = \\"abca\\"`, the minimum deletions required to make the string a palindrome is 1 (e.g., removing \'b\' or \'c\' results in \\"aca\\" or \\"aba\\"). 2. For `s = \\"racecar\\"`, no deletions are required as it\'s already a palindrome. 3. For `s = \\"google\\"`, the minimum deletions required is 2 (e.g., removing \'g\' and \'e\' results in \\"goog\\"). # Notes * Consider edge cases where the string `s` is already a palindrome or has complex repeating patterns. * Optimize your solution to handle large strings efficiently.","solution":"def min_steps_to_palindrome(s: str) -> int: Returns the minimum number of steps needed to make string `s` a palindrome by deleting characters. Parameters: - s (str): The input string, consisting of lowercase letters only (1 ≤ len(s) ≤ 10,000). Returns: int: The minimum number of character deletions required. n = len(s) # Create a dp array to store the results of subproblems dp = [[0] * n for _ in range(n)] # Fill the dp array for length in range(2, n + 1): for start in range(n - length + 1): end = start + length - 1 if s[start] == s[end]: dp[start][end] = dp[start + 1][end - 1] else: dp[start][end] = min(dp[start + 1][end], dp[start][end - 1]) + 1 return dp[0][n - 1]"},{"question":"Problem Statement You are given a list of integers, where each integer represents the height of a building in a straight line. A building can \\"see\\" the ocean if no taller building is to its right. The goal is to find the indices of all buildings that can see the ocean. Write a function `find_buildings_with_ocean_view(heights: List[int]) -> List[int]` that meets the following criteria: * Takes a list of positive integers representing the heights of the buildings. * Returns a list of indices (0-based) of buildings that can see the ocean. # Input * A list of integers `heights` where 1 ≤ len(heights) ≤ 10^5 and each element 1 ≤ heights[i] ≤ 10^9. # Output * A list of integers representing the indices of buildings that can see the ocean. The indices should be in ascending order. # Constraints * The solution needs to be efficient to handle the upper constraint limits effectively. # Example Input: ```python heights = [4, 2, 3, 1] ``` Output: ```python [0, 2, 3] ``` Explanation: - Building 0 (height 4) can see the ocean as there\'s no taller building to its right. - Building 1 (height 2) cannot see the ocean as building 2 (height 3) is taller. - Building 2 (height 3) can see the ocean as no building taller or equal in height lies to its right. - Building 3 (height 1) can see the ocean as it\'s the last building. Input: ```python heights = [4, 3, 2, 1] ``` Output: ```python [0, 1, 2, 3] ``` Explanation: All buildings can see the ocean as each building is taller than all those to its right. # Additional Requirements * Aim for an O(n) time complexity where n is the number of elements in the input list. * The space complexity should be optimized and reasonable concerning the nature of the problem.","solution":"from typing import List def find_buildings_with_ocean_view(heights: List[int]) -> List[int]: n = len(heights) result = [] max_height = 0 # Start with 0, as no building is 0 height for i in range(n - 1, -1, -1): if heights[i] > max_height: result.append(i) max_height = heights[i] result.reverse() # Since we need to return indices in ascending order return result"},{"question":"# Problem Statement You are given a list of strings where each string represents a sentence. Implement a function that determines the shortest sentence by word count and returns the sentence along with its word count. If there are multiple sentences with the same shortest word count, return the one that appears first in the list. # Function Signature ```python def shortest_sentence(sentences: list[str]) -> tuple[str, int]: pass ``` # Input - `sentences`: A list of strings, where each string represents a sentence. Each sentence consists of words separated by spaces. # Output - The function should return a tuple: * The sentence with the shortest word count. * An integer representing the word count of that shortest sentence. # Constraints - 1 ≤ len(sentences) ≤ 100 - 1 ≤ len(sentence) ≤ 1000 # Example ```python sentences = [ \\"The quick brown fox jumps over the lazy dog\\", \\"Short sentence\\", \\"A much longer sentence that has more words in it\\", \\"Tiny\\" ] shortest, word_count = shortest_sentence(sentences) print(shortest) # Expected: \\"Tiny\\" print(word_count) # Expected: 1 ``` # Notes - Ensure to properly handle sentences of varying lengths. - Consider edge cases with sentences that have the same word count. - A word is defined as any sequence of non-space characters.","solution":"def shortest_sentence(sentences): Determines the sentence with the shortest word count. Parameters: sentences (list of str): A list of sentences in string format. Returns: tuple: A tuple containing the shortest sentence and its word count. # Initialize variables to keep track of the shortest sentence and its length shortest = None min_word_count = float(\'inf\') # Iterate through each sentence in the list for sentence in sentences: # Split the sentence into words and count them word_count = len(sentence.split()) # Check if the current sentence has the shortest word count so far if word_count < min_word_count: shortest = sentence min_word_count = word_count return (shortest, min_word_count)"},{"question":"# Coding Assessment Question Context You\'ve been assigned to develop a utility function for a tree structure. Specifically, you need to create a method to find the maximum depth of a binary tree. This problem will test your understanding of recursive tree traversal algorithms. Task Implement a method `max_depth` in the `TreeNode` class that finds the depth of the binary tree. The depth of a binary tree is the number of nodes along the longest path from the root node down to the farthest leaf node. Function Specification ```python def max_depth(self) -> int: Returns the maximum depth of the binary tree. Examples: >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> root.max_depth() 3 When the tree is empty: >>> root = None >>> if root: ... root.max_depth() ... else: ... 0 0 When the tree has one element: >>> root = TreeNode(1) >>> root.max_depth() 1 Returns: int: The maximum depth of the tree. pass ``` Constraints * The tree node class `TreeNode` has the following structure: ```python class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right ``` * The solution should run in O(n) time complexity, where n is the number of nodes in the tree. * You should use a recursive approach to solve this problem. Input Format A method `max_depth` within the `TreeNode` class invoked without any parameters. Output Format An integer representing the maximum depth of the binary tree. Examples * Input: A binary tree represented by root node with values `[1, 2, 3, 4, 5]` * Expected Output: `3` * Input: An empty binary tree * Expected Output: `0` * Input: A binary tree with a single node `[1]` * Expected Output: `1`","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def max_depth(self) -> int: Returns the maximum depth of the binary tree. if self is None: return 0 def depth(node): if not node: return 0 left_depth = depth(node.left) right_depth = depth(node.right) return max(left_depth, right_depth) + 1 return depth(self)"},{"question":"# Coding Assessment Question Scenario You are working on the back-end of a logistics company that manages the delivery of packages. Each package needs to go through multiple stages, such as \'Processed\', \'In Transit\', \'Delivered\', etc. Sometimes, unexpected delays may happen based on traffic conditions or other issues. To maintain efficiency, you are asked to write a function to track the number of packages currently at each stage. Problem Statement Implement a function `track_packages(packages: list[tuple[int, str]]) -> dict[str, int]` that takes a list of tuples representing packages and their current stages, and returns a dictionary that maps each stage to the number of packages currently in that stage. # Input: * A list `packages` of tuples, where each tuple contains an integer (the package ID) and a string (the current stage of the package). # Output: * A dictionary that maps each unique stage (string) to the count of packages (integer) in that stage. # Constraints: * (1 leq text{number of packages} leq 10^5) * Package IDs are unique integers. * Stages are non-empty strings. # Example: ```python packages = [(1, \'Processed\'), (2, \'In Transit\'), (3, \'Delivered\'), (4, \'In Transit\'), (5, \'Processed\')] assert track_packages(packages) == {\'Processed\': 2, \'In Transit\': 2, \'Delivered\': 1} packages = [(1, \'Delivered\'), (2, \'Delivered\'), (3, \'In Transit\')] assert track_packages(packages) == {\'Delivered\': 2, \'In Transit\': 1} ``` Function Signature ```python def track_packages(packages: list[tuple[int, str]]) -> dict[str, int]: pass ``` # Notes: * The function should efficiently compute the counts of packages at each stage. * Consider using a dictionary for easy lookup and update of stage counts.","solution":"def track_packages(packages: list[tuple[int, str]]) -> dict[str, int]: Tracks the number of packages at each stage. Args: packages (list[tuple[int, str]]): A list of tuples where each tuple contains a package ID and its current stage. Returns: dict[str, int]: A dictionary mapping each unique stage to the count of packages in that stage. stage_counts = {} for _, stage in packages: if stage in stage_counts: stage_counts[stage] += 1 else: stage_counts[stage] = 1 return stage_counts"},{"question":"# Coding Question: Valid Parenthesis Expressions Using a Stack You are tasked with implementing a function that checks if a given string consisting of only parentheses characters `(` and `)` is a valid expression. A valid parenthesis expression is one where every opening parenthesis has a corresponding closing parenthesis and they are correctly nested. Function Signature ```python def is_valid_parenthesis(s: str) -> bool: Determine if the input string is a valid parenthesis expression. Parameters: s (str): The input string consisting of only `(` and `)`. Returns: bool: True if the string is a valid parenthesis expression, False otherwise. pass ``` # Input * A string `s` consisting of `(` and `)` where `0 <= len(s) <= 10^5` # Output * A boolean, True if the string represents a valid parenthesis expression, otherwise False # Constraints * Your function should be efficient in terms of both time and space. * Perform input validation and handle invalid characters with an appropriate message. # Performance Requirements * Time Complexity: O(n) * Space Complexity: O(n) # Example Given input: ```python print(is_valid_parenthesis(\\"()()\\")) ``` Expected output: ```python True ``` Given input: ```python print(is_valid_parenthesis(\\"(()\\")) ``` Expected output: ```python False ``` # Scenario Imagine you are developing a compiler or interpreter for a programming language, where verifying the correctness of parenthesis expressions is a fundamental task. Efficiently checking these expressions ensures the parser can proceed with further analysis without errors.","solution":"def is_valid_parenthesis(s: str) -> bool: Determine if the input string is a valid parenthesis expression. Parameters: s (str): The input string consisting of only `(` and `)`. Returns: bool: True if the string is a valid parenthesis expression, False otherwise. stack = [] for char in s: if char == \'(\': stack.append(char) elif char == \')\': if not stack: return False stack.pop() else: return False # invalid character other than parentheses return len(stack) == 0"},{"question":"**Optimizing Delivery Routes Using Dijkstra\'s Algorithm** You are tasked with finding the shortest delivery route in a city represented as a weighted graph. Given a dataset of locations (nodes) and the distances (weights) between them, use Dijkstra\'s algorithm to determine the minimum travel cost from a given starting point to all other locations. # Objective Implement a function `find_shortest_paths(start_location: str, city_map: dict) -> dict` that computes the shortest paths from a specified starting location to all other locations in the city. # Input - `start_location` (str): The starting node in the graph. - `city_map` (dict): A dictionary representing the adjacency list of the graph where keys are node names and values are dictionaries of neighboring nodes along with corresponding edge weights. # Output - A dictionary where keys are location names and values are the minimum travel costs from the `start_location` to those locations. # Constraints - The city graph is connected and undirected. - The weights are positive integers. - Handle inputs where the starting location may not be connected to some nodes. # Example ```python city_map = { \'A\': {\'B\': 1, \'C\': 4}, \'B\': {\'A\': 1, \'C\': 2, \'D\': 5}, \'C\': {\'A\': 4, \'B\': 2, \'D\': 1}, \'D\': {\'B\': 5, \'C\': 1} } shortest_paths = find_shortest_paths(\'A\', city_map) print(shortest_paths) ``` # Expected Behavior The output should be a dictionary containing the shortest paths from \'A\' to all other locations. # Notes - Use Dijkstra\'s algorithm for computing the shortest paths. - Ensure the algorithm efficiently handles large graphs. - Carefully manage the priority queue operations for optimal performance. # Example Output for Provided Input ```python { \'A\': 0, \'B\': 1, \'C\': 3, \'D\': 4 } ```","solution":"import heapq def find_shortest_paths(start_location, city_map): Computes the shortest paths from start_location to all other locations using Dijkstra\'s algorithm. # Initialize the minimum cost dictionary with infinity for all nodes except the starting location min_costs = {node: float(\'inf\') for node in city_map} min_costs[start_location] = 0 # Priority queue to explore the nodes in the order of their current path cost priority_queue = [(0, start_location)] while priority_queue: current_cost, current_node = heapq.heappop(priority_queue) # Skip processing if we have found a cheaper path in the meantime if current_cost > min_costs[current_node]: continue # Explore neighboring nodes for neighbor, weight in city_map[current_node].items(): cost = current_cost + weight if cost < min_costs[neighbor]: min_costs[neighbor] = cost heapq.heappush(priority_queue, (cost, neighbor)) return min_costs"},{"question":"# Data Structure Question: Circular Array Rotation Given an array of integers and a number of right rotations, your task is to rotate the array to the right and then return the rotated array. **Function Signature**: `def circular_array_rotation(arr: List[int], k: int) -> List[int]:` # Input: - `arr`: A list of integers where (1 leq text{len(arr)} leq 10^5). - `k`: An integer where (0 leq k leq 10^5). # Output: - A list of integers representing the rotated array. # Example: ```python >>> circular_array_rotation([1, 2, 3, 4, 5], 2) [4, 5, 1, 2, 3] >>> circular_array_rotation([1, 2, 3], 4) [3, 1, 2] >>> circular_array_rotation([10, 20, 30], 0) [10, 20, 30] >>> circular_array_rotation([5, 8, 12, 14], 6) [12, 14, 5, 8] ``` # Constraints: - The solution should handle edge cases where `k` is greater than the length of the array. - Make sure the solution is efficient in terms of time complexity, particularly when dealing with the upper limits. - Avoid using unnecessary extra space; strive for an in-place solution if possible.","solution":"from typing import List def circular_array_rotation(arr: List[int], k: int) -> List[int]: Returns the array after performing k right rotations. Parameters: arr (List[int]): The input array. k (int): Number of right rotations. Returns: List[int]: The rotated array. n = len(arr) k = k % n # To handle cases where k is larger than the length of the array # Rotate the array return arr[-k:] + arr[:-k] if k != 0 else arr"},{"question":"# Question: String Edit Distance You are given two strings `str1` and `str2`. Your task is to implement a function to compute the minimum number of operations required to convert `str1` into `str2`. The allowed operations are insertion, deletion, or substitution of a single character. Function Signature: ```python def edit_distance(str1: str, str2: str) -> int: pass ``` Input: * `str1` and `str2`: Two strings consisting of lowercase English letters. Output: * Return an integer representing the minimum number of operations required to convert `str1` into `str2`. Constraints: * 0 <= len(str1), len(str2) <= 1000 Example: ```python assert edit_distance(\\"kitten\\", \\"sitting\\") == 3 assert edit_distance(\\"flaw\\", \\"lawn\\") == 2 assert edit_distance(\\"\\", \\"\\") == 0 assert edit_distance(\\"a\\", \\"a\\") == 0 assert edit_distance(\\"intention\\", \\"execution\\") == 5 ``` Notes: * Implement the function using dynamic programming to ensure efficiency. * Consider edge cases such as empty strings and strings that are already identical. * Ensure that your implementation has a time complexity of O(m * n), where m and n are the lengths of `str1` and `str2`. Good luck!","solution":"def edit_distance(str1: str, str2: str) -> int: # Get the lengths of both strings len1, len2 = len(str1), len(str2) # Initialize a DP table where dp[i][j] represents the edit distance # between str1[0..i-1] and str2[0..j-1] dp = [[0 for _ in range(len2 + 1)] for _ in range(len1 + 1)] # Fill dp table for the base case: transforming an empty string to another for i in range(len1 + 1): dp[i][0] = i # i insertions to transform str1 to empty str2 for j in range(len2 + 1): dp[0][j] = j # j insertions to transform empty str1 to str2 # Fill the dp table for all other cases for i in range(1, len1 + 1): for j in range(1, len2 + 1): if str1[i - 1] == str2[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = min( dp[i - 1][j] + 1, # Deletion dp[i][j - 1] + 1, # Insertion dp[i - 1][j - 1] + 1 # Substitution ) return dp[len1][len2]"},{"question":"**Context**: You need to implement a function that calculates the minimal number of steps required to convert a start word into an end word by changing only one letter at a time, with each intermediate word being a valid word from a given dictionary. **Task**: Write a Python function that determines the minimal transformation steps from a start word to an end word using Breadth-First Search (BFS). **Requirements**: - Write a function `word_ladder` that: - Takes a start word, an end word, and a dictionary of valid words. - Uses BFS to find the shortest transformation sequence from the start word to the end word. - Returns the number of transformations required, or -1 if the transformation is not possible. **Function Signature**: ```python def word_ladder(start: str, end: str, word_list: set[str]) -> int: ... ``` **Input Format**: - `start`: A string representing the starting word. - `end`: A string representing the target word. - `word_list`: A set of strings representing the valid intermediate words. **Output Format**: - An integer representing the minimum number of transformation steps needed to get from the start word to the end word. If the transformation is not possible, return -1. **Example**: ```python start = \\"hit\\" end = \\"cog\\" word_list = {\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\", \\"cog\\"} print(word_ladder(start, end, word_list)) # Output: 5 (hit -> hot -> dot -> dog -> cog) ``` **Constraints**: - Each word has the same length. - Only one letter can be changed at a time. - Each intermediate word must exist in the dictionary (i.e., word_list). - Both the start and end words are guaranteed to be different and included in the word_list. **Performance Notes**: - Consider the efficiency of the solution when dealing with large dictionaries and words of significant length.","solution":"from collections import deque def word_ladder(start: str, end: str, word_list: set[str]) -> int: if end not in word_list: return -1 word_list.add(end) # Ensure the end word is in the dictionary queue = deque([(start, 1)]) # Queue of (current_word, transformation_steps) visited = set([start]) while queue: current_word, steps = queue.popleft() if current_word == end: return steps for i in range(len(current_word)): for c in \'abcdefghijklmnopqrstuvwxyz\': next_word = current_word[:i] + c + current_word[i+1:] if next_word in word_list and next_word not in visited: visited.add(next_word) queue.append((next_word, steps + 1)) return -1"},{"question":"# Problem Statement In this task, you are required to develop a function that checks if a given string represents a valid hexadecimal number and returns its decimal equivalent. The goal is to assess your ability to work with string processing, validation, and conversion between number systems in Python. # Function Signature ```python def hex_to_decimal(hex_string: str) -> int: This function takes a string representing a hexadecimal number and returns its decimal equivalent. :param hex_string: A string representing the hexadecimal number. :return: An integer representing the decimal equivalent of the hexadecimal number, or -1 if the input is not valid. ``` # Expected Input and Output - **Input**: A single string `hex_string` that may or may not represent a valid hexadecimal number. The string may include characters from \'0\'-\'9\', \'a\'-\'f\', and \'A\'-\'F\', optionally prefixed with \'0x\' or \'0X\'. - Example: `hex_to_decimal(\\"1A3F\\")` - **Output**: A single integer representing the decimal equivalent of the given hexadecimal number. If the input is an invalid hexadecimal string, return `-1`. - Example: `6719` (since \\"1A3F\\" in hexadecimal is 6719 in decimal) # Constraints and Limitations 1. Handle case-insensitive inputs, where \'A\' and \'a\' represent the same value. 2. Handle optional prefixes \'0x\' and \'0X\' which indicate a hexadecimal number. 3. Return `-1` for any input that is not a valid hexadecimal string. 4. An empty string should be considered invalid and should return `-1`. 5. The function should handle both lowercase and uppercase letters appropriately as per hexadecimal representation. # Example Scenarios 1. **Scenario 1**: - Input: `hex_to_decimal(\\"0xFF\\")` - Output: `255` 2. **Scenario 2**: - Input: `hex_to_decimal(\\"10\\")` - Output: `16` 3. **Scenario 3**: - Input: `hex_to_decimal(\\"Z12\\")` - Output: `-1` 4. **Scenario 4**: - Input: `hex_to_decimal(\\"\\")` - Output: `-1` 5. **Scenario 5**: - Input: `hex_to_decimal(\\"1A3f\\")` - Output: `6719` # Performance Requirements Ensure your implementation efficiently handles validation and conversion operations within a reasonable time frame. The constraints guarantee standard hexadecimal number sizes, so ensure the solution is robust and correct for typical string lengths encountered in hexadecimal representations.","solution":"def hex_to_decimal(hex_string: str) -> int: This function takes a string representing a hexadecimal number and returns its decimal equivalent. :param hex_string: A string representing the hexadecimal number. :return: An integer representing the decimal equivalent of the hexadecimal number, or -1 if the input is not valid. # If the input is an empty string, return -1 if not hex_string: return -1 try: # Convert the hex string to decimal return int(hex_string, 16) except ValueError: # If conversion fails, return -1 return -1"},{"question":"# Coding Assessment Question Snake Matrix Generation You are working on a project that involves generating a matrix with an interesting pattern. Specifically, you need to create a \\"snake\\" matrix, where the numbers start from 1 and increase continuously in a snake-like pattern. The snake-like pattern should fill the matrix row by row, but alternate direction for each row: left to right for the first row, right to left for the second row, left to right for the third row, and so on. # Problem Statement Implement a function `snake_matrix` in Python to generate such a matrix given the number of rows and columns. # Function Signature ```python def snake_matrix(rows: int, columns: int) -> List[List[int]]: pass ``` # Parameters - `rows`: An integer representing the number of rows in the matrix. - `columns`: An integer representing the number of columns in the matrix. # Output * Returns a 2D list (matrix) of integers, filled with the given snake-like pattern. # Constraints * 1 <= `rows` <= 100 * 1 <= `columns` <= 100 # Example For the function call `snake_matrix(3, 4)`, the output should be: ```python [ [1, 2, 3, 4], [8, 7, 6, 5], [9, 10, 11, 12] ] ``` For the function call `snake_matrix(4, 3)`, the output should be: ```python [ [1, 2, 3], [6, 5, 4], [7, 8, 9], [12, 11, 10] ] ``` # Additional Instructions * Make sure your implementation handles the edge cases (e.g., minimal input values like 1 row or 1 column). * Document your code with comments where necessary to explain the implementation. * You may write helper functions to keep your code organized and improve readability. --- This question aims to test your ability to manipulate 2D lists and create iterative patterns in programming, all while dealing with directional changes and carefully maintaining indices within bounds.","solution":"from typing import List def snake_matrix(rows: int, columns: int) -> List[List[int]]: Generates a snake-like pattern matrix with the given number of rows and columns. matrix = [[0] * columns for _ in range(rows)] num = 1 for r in range(rows): if r % 2 == 0: for c in range(columns): matrix[r][c] = num num += 1 else: for c in range(columns - 1, -1, -1): matrix[r][c] = num num += 1 return matrix"},{"question":"# Question: Sum Combinations Finder In this task, you will write a function to find all unique combinations of elements in a given list that sum up to a specific target. The elements in the list can be repeated if necessary to reach the target sum. All combinations should be returned in ascending order of their elements, and each combination must be unique with no duplicates. Function Signature ```python def find_sum_combinations(numbers: list[int], target_sum: int) -> list[list[int]]: ``` # Input - **numbers** (list of `int`): The list of integers to form combinations with. - **target_sum** (int): The target sum that each combination of numbers should add up to. # Output - A list of lists, where each inner list is a unique combination of numbers that sums to the target sum. # Constraints - All numbers in the list are positive integers. - The `numbers` list is not empty. - The `target_sum` is a positive integer. # Performance - Aim for a clean, readable, and efficient solution that considers edge cases and handles constraint validations correctly. - The solution should avoid generating duplicate combinations. # Example ```python # Example 1 numbers = [2, 3, 5] target_sum = 8 print(find_sum_combinations(numbers, target_sum)) # Output: [[3, 5], [2, 2, 2, 2], [2, 2, 2, 2]] #Example 2 numbers = [2, 4, 6, 8] target_sum = 8 print(find_sum_combinations(numbers, target_sum)) # Output: [[2, 2, 2, 2], [2, 2, 4], [4, 4], [2, 6], [8]] # Example 3 numbers = [1] target_sum = 2 print(find_sum_combinations(numbers, target_sum)) # Output: [[1, 1]] ``` # Additional Notes - The function should use backtracking to find all combinations efficiently. - Ensure the solution handles various edge cases, such as when no combination can sum to the target or when the `numbers` list contains only one element. - Consider managing duplicates in the input to avoid duplicated combinations in the output.","solution":"def find_sum_combinations(numbers: list[int], target_sum: int) -> list[list[int]]: def backtrack(start, target, path): if target == 0: result.append(path[:]) return for i in range(start, len(numbers)): if numbers[i] > target: break path.append(numbers[i]) backtrack(i, target - numbers[i], path) path.pop() numbers.sort() result = [] backtrack(0, target_sum, []) return result"},{"question":"# Coding Assessment Question: Scenario: You are developing a utility for a large-scale online shopping platform. One crucial feature is an order summarization tool that aggregates essential statistics about orders placed by customers. One of the key statistics is determining the most expensive order out of a list of orders to monitor any unusually high transactions. Task: Write a function `most_expensive_order(orders: List[Dict[str, Any]]) -> Dict[str, Any]` that takes a list of orders, where each order is represented as a dictionary containing \'order_id\', \'customer_id\', and \'total_amount\'. The function should return the dictionary representing the order with the highest total amount. Input: - A list of dictionaries, `orders`, where each dictionary contains: - `order_id` (str): A unique identifier for the order. - `customer_id` (str): A unique identifier for the customer who placed the order. - `total_amount` (float): The total amount of the order. Output: - A dictionary representing the order with the highest `total_amount`. Constraints: - The list of orders will always contain at least one order. - Each `order_id` is unique within the list. - `total_amount` will always be a positive float number. Examples: ```python orders = [ {\\"order_id\\": \\"A123\\", \\"customer_id\\": \\"C101\\", \\"total_amount\\": 150.75}, {\\"order_id\\": \\"A124\\", \\"customer_id\\": \\"C102\\", \\"total_amount\\": 250.00}, {\\"order_id\\": \\"A125\\", \\"customer_id\\": \\"C103\\", \\"total_amount\\": 100.00} ] most_expensive_order(orders) # Returns: {\\"order_id\\": \\"A124\\", \\"customer_id\\": \\"C102\\", \\"total_amount\\": 250.00} orders = [ {\\"order_id\\": \\"B342\\", \\"customer_id\\": \\"C354\\", \\"total_amount\\": 599.99} ] most_expensive_order(orders) # Returns: {\\"order_id\\": \\"B342\\", \\"customer_id\\": \\"C354\\", \\"total_amount\\": 599.99} ``` You can assume that the list of orders will not be empty, and each order will have the required fields with appropriate data types.","solution":"from typing import List, Dict, Any def most_expensive_order(orders: List[Dict[str, Any]]) -> Dict[str, Any]: Determines the most expensive order from a list of orders. Parameters: orders (List[Dict[str, Any]]): A list of dictionaries where each dictionary represents an order. Returns: Dict[str, Any]: The dictionary representing the order with the highest total_amount. return max(orders, key=lambda order: order[\'total_amount\'])"},{"question":"# String Permutations Validator **Context**: You work as a software engineer at a company that deals with secure data transmission. One of the key operations in ensuring data integrity is verifying that two strings are permutations of each other. This ensures that no data is lost or altered during transmission, except for changes in the order of characters. **Objective**: Write a function that checks if two provided strings are permutations of each other. The function should be optimized and handle various edge cases efficiently. **Function Signature**: ```python def are_permutations(s1: str, s2: str) -> bool: pass ``` **Input and Output Format**: * **Input**: Two strings `s1` and `s2`. * **Output**: Boolean value `True` if the strings are permutations of each other, otherwise `False`. **Constraints**: * The strings can contain any ASCII characters. * Handle strings of varying lengths efficiently. * Consider edge cases such as empty strings or strings with special characters. # Example ```python assert are_permutations(\\"abc\\", \\"bca\\") == True assert are_permutations(\\"abc\\", \\"abcd\\") == False assert are_permutations(\\"\\", \\"\\") == True assert are_permutations(\\"aabbcc\\", \\"abcabc\\") == True assert are_permutations(\\"aabbcc\\", \\"abccba \\") == False assert are_permutations(\\"123!@\\", \\"@!321\\") == True ``` **Performance Requirements**: * Strive for an O(n log n) or O(n) complexity solution, where n is the length of the input strings. * Utilize efficient data structures like dictionaries or counters where applicable. **Sample Output**: ``` are_permutations(\\"abc\\", \\"bca\\") => True are_permutations(\\"abc\\", \\"abcd\\") => False are_permutations(\\"\\", \\"\\") => True are_permutations(\\"aabbcc\\", \\"abcabc\\") => True are_permutations(\\"aabbcc\\", \\"abccba \\") => False are_permutations(\\"123!@\\", \\"@!321\\") => True ``` **Notes**: You are encouraged to think about edge cases such as handling large inputs and strings with diverse character sets. Ensure the function returns results in a timely manner without compromising correctness.","solution":"from collections import Counter def are_permutations(s1: str, s2: str) -> bool: Checks if two strings are permutations of each other. :param s1: First string :param s2: Second string :return: True if the strings are permutations of each other, False otherwise if len(s1) != len(s2): return False return Counter(s1) == Counter(s2)"},{"question":"New Question **Scenario**: You have been hired by an e-commerce company to optimize their product recommendation system. The existing system is slow and inefficient because it repeatedly computes the similarity between products from scratch every time a user requests recommendations. To improve performance, you decide to implement a cache system that stores and retrieves product similarities efficiently. **Task**: Create a class `ProductSimilarityCache` that implements a caching mechanism for product similarities. The class should support the following functionalities: 1. Add a similarity score between two products. 2. Retrieve the similarity score between two products if it is cached. 3. Return a list of products that are most similar to a given product, based on the cached similarities. # Class Definition ```python class ProductSimilarityCache: def __init__(self): # Initialize your cache structure pass def add_similarity(self, product1: int, product2: int, similarity: float): # Add a similarity score between two products pass def get_similarity(self, product1: int, product2: int) -> float: # Retrieve the similarity score between two products, or return -1 if not cached pass def get_most_similar(self, product: int, top_n: int) -> List[int]: # Retrieve top_n most similar products, based on cached similarities pass ``` # Input * `product1, product2`: Integers representing product IDs. * `similarity`: A float score representing how similar the products are. * `top_n`: An integer indicating the number of most similar products to retrieve. # Output * `add_similarity`: Nothing. * `get_similarity`: Returns a float score or -1 if similarity is not cached. * `get_most_similar`: A list of product IDs representing the top_n most similar products to the given product. # Usage Example ```python cache = ProductSimilarityCache() cache.add_similarity(1, 2, 0.9) cache.add_similarity(1, 3, 0.8) cache.add_similarity(1, 4, 0.4) cache.add_similarity(2, 3, 0.5) print(cache.get_similarity(1, 2)) # Output: 0.9 print(cache.get_similarity(1, 5)) # Output: -1 print(cache.get_most_similar(1, 2)) # Output: [2, 3] print(cache.get_most_similar(2, 1)) # Output: [1] ``` # Constraints: * Assume product IDs are unique positive integers. * The similarity score is a float between 0.0 and 1.0. * The `get_most_similar` method should handle cases where there are fewer than `top_n` similar products cached. * The class should be efficient in terms of both time and space complexity. Implement the class to demonstrate your understanding and proficiency in caching mechanisms and handling similarity scores.","solution":"from typing import List, Dict from collections import defaultdict class ProductSimilarityCache: def __init__(self): # Initialize the cache to store similarity scores self.similarity_cache = defaultdict(dict) def add_similarity(self, product1: int, product2: int, similarity: float): # Ensure to store similarity in both directions self.similarity_cache[product1][product2] = similarity self.similarity_cache[product2][product1] = similarity def get_similarity(self, product1: int, product2: int) -> float: return self.similarity_cache[product1].get(product2, -1.0) def get_most_similar(self, product: int, top_n: int) -> List[int]: similarities = self.similarity_cache[product] sorted_similarities = sorted(similarities.items(), key=lambda item: item[1], reverse=True) return [product_id for product_id, _ in sorted_similarities[:top_n]]"},{"question":"# Question You are given the task of writing a function `reverse_words(sentence: str) -> str` that takes a string containing a sentence and returns a new string where the words are in reverse order, but the characters within each word remain in the same order. Words are defined as sequences of non-space characters and should be separated by a single space in the output. Input - A string `sentence` representing a sentence of words separated by spaces. (The sentence will not have multiple consecutive spaces and will not start or end with a space). Output - A string with the words in reverse order, separated by a single space. Constraints - The input string is non-empty and contains only printable ASCII characters (including spaces). - The input string has a length of at most 10^4 characters. Expected Time Complexity - O(n), where n is the number of characters in the input string. Example ```python >>> reverse_words(\\"hello world\\") \'world hello\' >>> reverse_words(\\"The quick brown fox\\") \'fox brown quick The\' >>> reverse_words(\\"OpenAI is creating amazing technology\\") \'technology amazing creating is OpenAI\' >>> reverse_words(\\"Python is fun\\") \'fun is Python\' ``` Notes - Ensure that the returned string has exactly one space separating the words and contains no leading or trailing spaces. Write the function `reverse_words` with the described specifications, ensuring that it performs efficiently with large input sizes and correctly handles all edge cases.","solution":"def reverse_words(sentence: str) -> str: Returns a new string where the words are in reverse order, but the characters within each word remain in the same order. :param sentence: The input sentence with words to be reversed. :return: A string with the words in reverse order. words = sentence.split() reversed_words = words[::-1] return \' \'.join(reversed_words)"},{"question":"Context: You are developing a feature for an e-commerce platform to manage \\"flash sales\\" which offer a limited number of products at a discounted price for a short duration. Due to the limited quantity and high demand, the platform needs to efficiently handle transactions to ensure fairness. Task: Implement a function `process_flash_sale(available_items: int, orders: List[int]) -> List[int]` which processes the flash sale orders. Each order is represented as the number of items requested by a customer. The function should return a list where each element corresponds to the actual number of items successfully purchased by each order in the same sequence. * If the requested items in an order exceed the available items, fulfill as many as possible and set the remaining to zero. * Ensure transactions are processed in the order they arrive based on the input list. Constraints: * `1 <= available_items <= 10^5` * `1 <= len(orders) <= 10^5` * `1 <= orders[i] <= 10^3` Input: * An integer `available_items` where `1 <= available_items <= 10^5` * A list of integers `orders` where each element represents the number of items requested in the order and `1 <= orders[i] <= 10^3` Output: * A list of integers representing the actual number of items purchased for each order in the same sequence as the input list Example: ```python assert process_flash_sale(50, [10, 20, 30, 40]) == [10, 20, 20, 0] assert process_flash_sale(100, [20, 15, 80, 5]) == [20, 15, 65, 0] ``` Requirements: * Your solution should be efficient in terms of both time and space complexity. * Ensure that any edge cases are properly handled.","solution":"from typing import List def process_flash_sale(available_items: int, orders: List[int]) -> List[int]: result = [] for order in orders: if available_items >= order: result.append(order) available_items -= order else: result.append(available_items) available_items = 0 return result"},{"question":"# Problem Statement Context In various applications such as geographical mapping, gaming, and robotics, it\'s critical to determine the shortest path between two nodes in a weighted, directed graph. This problem can be solved using a famous algorithm known as Dijkstra’s algorithm. Task Your task is to implement Dijkstra’s algorithm to find the shortest path from a starting node to all other nodes in a weighted, directed graph. The program should return the shortest distances from the start node to all other nodes. Input 1. An integer `n` representing the number of nodes in the graph (1 ≤ n ≤ 1000). 2. An integer `m` representing the number of edges in the graph (0 ≤ m ≤ 10000). 3. A list of edges, where each edge is represented by three integers `u`, `v`, and `w`. `u` and `v` represent the nodes connected by the edge, and `w` is the weight of the edge (1 ≤ u, v ≤ n, 1 ≤ w ≤ 100). Output Return a list of integers where the i-th integer represents the shortest distance from the starting node (node 1) to node i. If node i is not reachable from the starting node, the distance should be represented as `-1`. Example ```python # Input n = 5 m = 6 edges = [ (1, 2, 2), (1, 3, 4), (2, 3, 1), (2, 4, 7), (3, 5, 3), (4, 5, 1) ] # Expected Output [0, 2, 3, 9, 6] ``` Constraints - There are no negative weight cycles in the graph. - The graph may be disconnected.","solution":"import heapq def dijkstra(n, m, edges): Implements Dijkstra\'s algorithm to find the shortest path from the start node (node 1) to all other nodes in the graph. Parameters: n (int): number of nodes. m (int): number of edges. edges (list): list of tuples representing the edges (u, v, w). Returns: list: shortest distance from node 1 to all other nodes. graph = [[] for _ in range(n + 1)] for u, v, w in edges: graph[u].append((v, w)) distances = [float(\'inf\')] * (n + 1) distances[1] = 0 priority_queue = [(0, 1)] # (distance, node) while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return [-1 if dist == float(\'inf\') else dist for dist in distances[1:]]"},{"question":"# Unique Elements Extraction from Nested Lists You are assigned a task to clean and extract unique elements from nested lists of integers. Each nested list may contain duplicate elements, and your goal is to return a single list of unique elements preserving the overall order of their first appearances with respect to all nested lists. Task: Write a Python function `extract_unique_elements` that takes a list of nested lists, where each nested list contains integers, and returns a list of unique integers in the order of their first appearance. Function Signature: ```python def extract_unique_elements(nested_lists: List[List[int]]) -> List[int]: ``` Input: * `nested_lists` - A list of nested lists of integers (0 <= len(nested_lists) <= 10^4), where each nested list contains a variable number of integers. Output: * A list of unique integers extracted from the nested lists preserving their first appearance order. Constraints: * Each nested list can be empty or contain up to 10^3 integers. * The entire nested structure up to 10^7 integers must be handled efficiently. * The function should be optimized for both time and space complexity. Example: ```python >>> extract_unique_elements([[1, 2, 2, 3], [3, 4, 5], [5, 6, 1]]) [1, 2, 3, 4, 5, 6] >>> extract_unique_elements([[], [7, 8, 8, 9], [10, 7, 9]]) [7, 8, 9, 10] >>> extract_unique_elements([[2, 1], [1], [2, 3]]) [2, 1, 3] ``` # Scenario: Imagine your role in data cleaning involves processing datasets represented as nested lists. Extracting unique elements from these lists is a precursor to further analysis and reporting. Efficiency is crucial to manage and process large datasets accurately and promptly.","solution":"from typing import List def extract_unique_elements(nested_lists: List[List[int]]) -> List[int]: Extract unique elements from nested lists while preserving the order of their first appearance. seen = set() unique_elements = [] for sublist in nested_lists: for num in sublist: if num not in seen: seen.add(num) unique_elements.append(num) return unique_elements"},{"question":"# Context In a social network graph, users are represented as nodes, and friendships between them are represented as edges. Given such a graph, we want to determine the shortest path between two users. The shortest path is the minimum number of edges required to travel from one user to another. If the users are not connected, return -1. # Task Write a function to find the shortest path between two specified users in a social network graph. # Implementation You will have to implement the following function: 1. **`shortest_path(graph: dict[int, list[int]], start: int, end: int) -> int`**: - Given a dictionary representing the graph, where keys are user IDs and values are lists of friends (user IDs), find the number of edges in the shortest path from the `start` user to the `end` user. If no such path exists, return -1. - Example: ```python graph = { 1: [2, 3], 2: [1, 4], 3: [1], 4: [2, 5], 5: [4] } assert shortest_path(graph, 1, 5) == 3 assert shortest_path(graph, 1, 6) == -1 ``` # Constraints * The number of users (nodes) in the graph will not exceed 1000. * Each user can have up to 1000 friends (edges). * Each user is represented by a unique positive integer. * If the `start` user is the same as the `end` user, the shortest path is 0. # Input/Output - **Input**: A dictionary representing the graph, and two integers representing the start and end user IDs. - **Output**: An integer representing the number of edges in the shortest path between the two users, or -1 if they are not connected. # Example Scenario ```python # Example use graph = { 1: [2, 3], 2: [1, 4], 3: [1], 4: [2, 5], 5: [4] } shortest_path_length = shortest_path(graph, 1, 5) # Output: 3 print(shortest_path_length) # Output: 3 shortest_path_length = shortest_path(graph, 1, 6) # Output: -1 print(shortest_path_length) # Output: -1 ``` Submit your complete solution in a Python file.","solution":"from collections import deque def shortest_path(graph, start, end): Returns the number of edges in the shortest path between start and end user in the given graph. If no such path exists, returns -1. if start == end: return 0 visited = set() queue = deque([(start, 0)]) # (current_node, current_distance) while queue: current_node, distance = queue.popleft() if current_node == end: return distance if current_node not in visited: visited.add(current_node) for neighbor in graph.get(current_node, []): if neighbor not in visited: queue.append((neighbor, distance + 1)) return -1"},{"question":"# Coding Assessment Question You are given a basic sorting function `simple_sort` that sorts a list of integers in ascending order using the bubble sort algorithm. Your task is to extend this function to provide additional functionalities. Write a function named `advanced_sort` that not only sorts a list of integers but can also determine the k-th smallest and k-th largest elements in the list. The function should take an additional parameter `operation` that specifies the operation to perform: \'sort\', \'kth_smallest\', or \'kth_largest\'. The `k` parameter should be used only when performing the \'kth_smallest\' or \'kth_largest\' operations. Function Signature: ```python def advanced_sort(nums: list[int], operation: str, k: int = None) -> any: pass ``` # Requirements - **Parameters**: - `nums`: A list of integers to be sorted or analyzed. - `operation`: A string which can be \'sort\', \'kth_smallest\', or \'kth_largest\'. - `k`: An integer representing the position of the k-th smallest or k-th largest element when \'kth_smallest\' or \'kth_largest\' operation is selected. It is optional and defaults to None. - **Returns**: - The sorted list if operation is \'sort\'. - The k-th smallest element if operation is \'kth_smallest\'. - The k-th largest element if operation is \'kth_largest\'. - **Constraints**: - The length of `nums` is at least 1. - k must be a valid index within the range of the list when \'kth_smallest\' or \'kth_largest\' operation is selected. - For simplicity, only the \'sort\' functionality needs to be implemented using the bubble sort algorithm. For finding k-th smallest or largest elements, you can use the sorted list. # Examples 1. ```python advanced_sort([4, 2, 5, 1, 3], \'sort\') ``` Should return the sorted list `[1, 2, 3, 4, 5]`. 2. ```python advanced_sort([4, 2, 5, 1, 3], \'kth_smallest\', 2) ``` Should return the 2nd smallest element `2`. 3. ```python advanced_sort([4, 2, 5, 1, 3], \'kth_largest\', 3) ``` Should return the 3rd largest element `3`.","solution":"def advanced_sort(nums: list[int], operation: str, k: int = None) -> any: def bubble_sort(arr): n = len(arr) for i in range(n): for j in range(0, n-i-1): if arr[j] > arr[j+1]: arr[j], arr[j+1] = arr[j+1], arr[j] return arr sorted_nums = bubble_sort(nums.copy()) if operation == \'sort\': return sorted_nums elif operation == \'kth_smallest\': if k is not None and 1 <= k <= len(sorted_nums): return sorted_nums[k-1] else: raise ValueError(\\"k is out of range\\") elif operation == \'kth_largest\': if k is not None and 1 <= k <= len(sorted_nums): return sorted_nums[-k] else: raise ValueError(\\"k is out of range\\") else: raise ValueError(\\"Invalid operation\\")"},{"question":"# Scenario You are working as a consultant for a logistics company that manages a fleet of delivery trucks. Each truck has a set of delivery stops assigned to it, and each stop requires a specific amount of time to complete. To improve efficiency, you want to minimize the maximum amount of time any single truck spends on its deliveries while ensuring all stops are covered. # Problem Statement Implement the function `minimize_max_delivery_time(stops: list, num_trucks: int) -> int` to find the smallest possible maximum delivery time any truck will need to spend on its assigned stops. Input: * `stops`: A list of integers where each integer represents the time required for a delivery stop. * `num_trucks`: An integer representing the number of trucks available. Output: * An integer representing the minimized maximum delivery time any truck will spend on deliveries. Constraints: * 1 ≤ len(stops) ≤ 10,000 * 1 ≤ num_trucks ≤ 10,000 * 1 ≤ stops[i] ≤ 10,000 for all stops Example: ```python stops = [10, 20, 30, 40, 50] num_trucks = 3 print(minimize_max_delivery_time(stops, num_trucks)) # Output could be 60 ``` # Notes: - Each truck can take any number of stops. - Your solution should aim for optimal allocation of stops to minimize the maximum time any truck spends on deliveries. - Consider using binary search in combination with a greedy algorithm to achieve the optimal result efficiently.","solution":"def minimize_max_delivery_time(stops, num_trucks): def can_distribute_with_time_cap(cap): current_sum = 0 required_trucks = 1 for stop in stops: if current_sum + stop > cap: required_trucks += 1 current_sum = stop if required_trucks > num_trucks: return False else: current_sum += stop return True if num_trucks >= len(stops): return max(stops) low, high = max(stops), sum(stops) result = high while low <= high: mid = (low + high) // 2 if can_distribute_with_time_cap(mid): result = mid high = mid - 1 else: low = mid + 1 return result"},{"question":"Problem Statement You are tasked with implementing a function that takes a list of integers and an integer `k`, and returns a list of all unique pairs of integers in the input list that sum up to `k`. Each pair should be returned as a tuple and sorted in ascending order within the pair. # Function signature ```python def find_pairs_with_sum(nums: list[int], k: int) -> list[tuple[int, int]]: pass ``` # Input - `nums`: A list of integers (0 <= len(nums) <= 1000). - `k`: An integer which represents the target sum. # Output - Returns a list of tuples, each containing a unique pair of integers from the input list that sum up to `k`. Each tuple should be sorted in ascending order. # Constraints - If the input list is empty, return an empty list. - Each element in the resulting list of tuples must be unique. # Example ```python assert find_pairs_with_sum([1, 5, 7, -1, 5], 6) == [(1, 5), (-1, 7)] assert find_pairs_with_sum([1, 2, 3, 4, 3], 6) == [(2, 4), (3, 3)] assert find_pairs_with_sum([1, 2, 3, 4], 8) == [] assert find_pairs_with_sum([], 5) == [] ``` # Notes * Consider using a set to track seen elements to avoid duplicate pairs. * The output should only include unique pairs that sum up to `k`. * Ensure each pair returned is sorted in ascending order, and the overall list of pairs is sorted lexicographically if necessary.","solution":"def find_pairs_with_sum(nums: list[int], k: int) -> list[tuple[int, int]]: seen = set() pairs = set() for num in nums: complement = k - num if complement in seen: pair = tuple(sorted((num, complement))) pairs.add(pair) seen.add(num) return sorted(pairs)"},{"question":"# Coding Assessment Question Given a code snippet for a binary search tree (BST), enhance the `BinarySearchTree` class by adding two new operations: 1. `find_height()` - Computes the height of the binary search tree. 2. `is_balanced()` - Checks if the binary search tree is height-balanced. Implement the following methods with the exact signatures and constraints as shown. Expected Input and Output Formats: ```python class BinarySearchTree: ... def find_height(self) -> int: Computes the height of the binary search tree. >>> bst = BinarySearchTree() >>> bst.insert(15) >>> bst.insert(10) >>> bst.insert(20) >>> bst.insert(8) >>> bst.insert(12) >>> bst.find_height() 2 >>> def is_balanced(self) -> bool: Checks if the binary search tree is height-balanced. >>> bst = BinarySearchTree() >>> bst.insert(15) >>> bst.insert(10) >>> bst.insert(20) >>> bst.insert(8) >>> bst.insert(12) >>> bst.is_balanced() True >>> ``` Constraints: - Memory usage should be efficient. - The operations should be performed in place. - The methods should handle edge cases gracefully (e.g., empty tree, single node tree). - Performance targets: - Finding the height of the BST in O(N) time complexity. - Checking if the BST is balanced in O(N) time complexity. **Scenario/Context**: You are developing a software to manage a dynamic database of user records stored in a binary search tree. The database must be checked regularly for height balance to ensure optimal query performance. Additionally, calculating the height of the tree is crucial for maintenance tasks. Implement these functionalities efficiently to maintain a well-optimized data structure.","solution":"class Node: def __init__(self, key): self.left = None self.right = None self.val = key class BinarySearchTree: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = Node(key) else: self._insert(self.root, key) def _insert(self, current_node, key): if key < current_node.val: if current_node.left is None: current_node.left = Node(key) else: self._insert(current_node.left, key) else: if current_node.right is None: current_node.right = Node(key) else: self._insert(current_node.right, key) def find_height(self) -> int: Computes the height of the binary search tree. return self._find_height(self.root) def _find_height(self, node) -> int: if node is None: return -1 left_height = self._find_height(node.left) right_height = self._find_height(node.right) return max(left_height, right_height) + 1 def is_balanced(self) -> bool: Checks if the binary search tree is height-balanced. return self._is_balanced(self.root)[1] def _is_balanced(self, node): if node is None: return (0, True) left_height, left_balanced = self._is_balanced(node.left) right_height, right_balanced = self._is_balanced(node.right) current_height = max(left_height, right_height) + 1 if abs(left_height - right_height) <= 1 and left_balanced and right_balanced: return (current_height, True) else: return (current_height, False)"},{"question":"# Problem Statement Given a `n x m` grid where each cell has a number representing the cost of passing through that cell, starting from the top-left cell, find the minimum cost to reach the bottom-right cell. You can only move either down or right at any point in time. Write a function `minPathSum(grid: List[List[int]]) -> int` that returns the minimum cost to get from the top-left to the bottom-right cell. # Input Format - A 2D list `grid` of size `n x m` (1 ≤ n, m ≤ 1000) where each element of `grid` (1 ≤ `grid[i][j]` ≤ 1000) represents the cost to traverse through that cell. # Output Format - A single integer representing the minimum cost to travel from the top-left cell to the bottom-right cell. # Example ```python >>> grid = [ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ] >>> minPathSum(grid) 7 >>> grid = [ ... [1, 2, 3], ... [4, 5, 6], ... ] >>> minPathSum(grid) 12 ``` # Constraints - The length of the grid and the length of the sublists do not exceed 1000. - The grid always contains at least one element. # Guidelines - Use dynamic programming to solve this problem efficiently. - Create a 2D table to store the minimum cost to reach each cell. - Update the table by following the constraints of moving only right or down.","solution":"from typing import List def minPathSum(grid: List[List[int]]) -> int: Returns the minimum cost to get from the top-left to the bottom-right cell. n = len(grid) m = len(grid[0]) # Create a 2D DP table initialised to 0. dp = [[0] * m for _ in range(n)] # Initialize the first cell with the grid\'s first cell value. dp[0][0] = grid[0][0] # Initialize the first row of the DP table. for j in range(1, m): dp[0][j] = dp[0][j - 1] + grid[0][j] # Initialize the first column of the DP table. for i in range(1, n): dp[i][0] = dp[i - 1][0] + grid[i][0] # Fill the rest of the DP table. for i in range(1, n): for j in range(1, m): dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] return dp[n - 1][m - 1]"},{"question":"# Scenario: You are part of a software development team tasked with building a project management tool. One feature requested is a task duration estimator, where the completion times of individual tasks vary and need to be displayed in a normalized format. Different tasks can have their estimated durations specified in days, hours, minutes, or even weeks. # Task: Implement a function named `normalize_task_duration` that can convert the given task durations into a standard format - hours. The function should support multiple input formats and handle a variety of input cases. # Requirements: 1. The function should accept the following time units: - weeks, days, hours, minutes. 2. The function must validate both the `duration` value and `unit` string and raise a `ValueError` if either is invalid. 3. Ensure it handles edge cases gracefully, such as extremely small values or invalid inputs. # Expected Input and Output: * **Input:** - `duration` (float): The numeric value representing the task duration. - `unit` (str): The unit of the duration. * **Output:** - Returns a float representing the duration converted into hours. # Constraints: * Use reliable conversion factors: - 1 week = 168 hours - 1 day = 24 hours - 1 hour = 1 hour - 1 minute = 1/60 hours * Assume input values are non-negative. * Implement the necessary validations and edge-case handling. # Example: ```python >>> normalize_task_duration(2, \\"days\\") 48.0 >>> normalize_task_duration(3, \\"weeks\\") 504.0 >>> normalize_task_duration(120, \\"minutes\\") 2.0 >>> normalize_task_duration(5, \\"years\\") Traceback (most recent call last): ... ValueError: Invalid \'unit\' value: \'years\'. Supported values are: weeks, days, hours, minutes >>> normalize_task_duration(4, \\"hours\\") 4.0 ``` # Hint: Utilize a dictionary to store the conversion factors for the different units and apply these factors during the conversion process.","solution":"def normalize_task_duration(duration, unit): Converts the given task duration into hours. Parameters: duration (float): The numeric value representing the task duration. unit (str): The unit of the duration. Returns: float: The duration converted into hours. Raises: ValueError: If either the duration value or unit string is invalid. if not isinstance(duration, (int, float)) or duration < 0: raise ValueError(f\\"Invalid \'duration\' value: {duration}. Must be a non-negative number.\\") conversion_factors = { \'weeks\': 168, \'days\': 24, \'hours\': 1, \'minutes\': 1/60 } if unit not in conversion_factors: raise ValueError(f\\"Invalid \'unit\' value: \'{unit}\'. Supported values are: weeks, days, hours, minutes\\") return duration * conversion_factors[unit]"},{"question":"# Anagram Problem You are developing a text processing tool that detects relationships between different words in a large corpus. One key feature is to identify anagrams—pairs of words that contain the exact same characters in a different order. Write a function `find_anagrams` that takes a list of words and returns a list of lists containing all sets of anagrams. Each list in the output should contain words that are anagrams of one another. # Input: - A list of strings `words` of length m (0 <= m <= 10^5) # Output: - A list of lists, where each list contains words that are anagrams of each other. Each set of anagrams should be unique. # Constraints: - Each word in `words` is composed of lowercase English letters only. - The length of each word is between 1 and 100 characters. # Example: ```python >>> find_anagrams([\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"]) [[\'eat\', \'tea\', \'ate\'], [\'tan\', \'nat\'], [\'bat\']] >>> find_anagrams([\\"listen\\", \\"silent\\", \\"enlist\\", \\"google\\", \\"gogole\\"]) [[\'listen\', \'silent\', \'enlist\'], [\'google\', \'gogole\']] >>> find_anagrams([\\"hello\\", \\"world\\"]) [[\'hello\'], [\'world\']] ``` # Performance: Aim for a solution that processes the list of words in O(m * k log k) time complexity, where m is the number of words and k is the maximum length of a word. # Note: - The function should only return lists that have at least 2 words (i.e., single word \\"anagrams\\" should not be included in the output). - Consider using a hash map to efficiently group words that are anagrams of each other.","solution":"from collections import defaultdict def find_anagrams(words): This function takes a list of words and returns a list of lists containing anagrams. anagrams = defaultdict(list) for word in words: sorted_word = \'\'.join(sorted(word)) anagrams[sorted_word].append(word) result = [group for group in anagrams.values() if len(group) > 1] return result"},{"question":"# Coding Assessment Question You are required to write a function to convert an integer to a string version of its binary representation without using Python\'s built-in binary conversion methods (such as `bin()`), and then return the count of \'1\'s in this binary representation. Function Signature `def count_ones_in_binary(num: int) -> int:` Input * `num`: A non-negative integer Output * Returns the count of \'1\'s in the binary representation of the input number. Constraints * The function should not use Python’s built-in binary conversion methods. * Handle an input of 0 which should return a count of 0. Examples ```python >>> count_ones_in_binary(5) 2 # binary representation is \'101\' >>> count_ones_in_binary(10) 2 # binary representation is \'1010\' >>> count_ones_in_binary(0) 0 # binary representation is \'0\' >>> count_ones_in_binary(255) 8 # binary representation is \'11111111\' >>> count_ones_in_binary(1) 1 # binary representation is \'1\' ``` # Your Implementation ```python def count_ones_in_binary(num: int) -> int: if num == 0: return 0 count = 0 while num > 0: if num % 2 == 1: # check if the least significant bit is 1 count += 1 num = num // 2 # shift right return count ``` Notes Make sure to verify your function with the provided examples and handle edge cases such as the input being zero. Ensure the function meets the constraints and does not use built-in functions for converting to binary.","solution":"def count_ones_in_binary(num: int) -> int: if num == 0: return 0 count = 0 while num > 0: if num % 2 == 1: # check if the least significant bit is 1 count += 1 num = num // 2 # shift right return count"},{"question":"# Coding Question: Rotate Matrix Elements Clockwise Context: Given an N x M matrix, you need to rotate the matrix elements in a clockwise direction. That is, you have to move the elements in such a way that the outermost elements come to the next position in the clockwise direction, and this continues for inner elements iteratively. Task: 1. Implement the `rotate_matrix_clockwise` function as defined below. 2. The function should rotate the elements of a given N x M matrix in a clockwise direction by one position. Function Signature: ```python def rotate_matrix_clockwise(matrix: list) -> list: Rotates the elements of the matrix in a clockwise direction by one position. Parameters: matrix (list): A list of lists representing the matrix. Returns: list: The rotated matrix. ``` Example: ```python # Example input matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] # Expected output [ [4, 1, 2], [7, 5, 3], [8, 9, 6] ] ``` Constraints: * The input matrix can contain negative and positive integers and will fit in memory. * The matrix will have at least one row and one column. * The matrix dimensions N and M can be different. Objective: Ensure your implementation correctly rotates the matrix elements in a clockwise direction by one position.","solution":"def rotate_matrix_clockwise(matrix: list) -> list: Rotates the elements of the matrix in a clockwise direction by one position. Parameters: matrix (list): A list of lists representing the matrix. Returns: list: The rotated matrix. if not matrix or not matrix[0]: return matrix N, M = len(matrix), len(matrix[0]) rotated = [[0] * M for _ in range(N)] layers = (min(N, M) + 1) // 2 for layer in range(layers): top = layer bottom = N - layer - 1 left = layer right = M - layer - 1 # Check if there\'s more than a single row or column in the layer to rotate if top == bottom or left == right: continue # Save the top-left element to move after we shift other elements prev = matrix[top][left] # Move elements from the top row (left to right) for col in range(left + 1, right + 1): rotated[top][col] = matrix[top][col - 1] # Move elements from the right column (top to bottom) for row in range(top + 1, bottom + 1): rotated[row][right] = matrix[row - 1][right] # Move elements from the bottom row (right to left) for col in range(right - 1, left - 1, -1): rotated[bottom][col] = matrix[bottom][col + 1] # Move elements from the left column (bottom to top) for row in range(bottom - 1, top - 1, -1): rotated[row][left] = matrix[row + 1][left] # Place the previously saved top-left element one step right rotated[top][left + 1] = prev # For single-layered border elements if layers * 2 > min(N, M): for i in range(N): for j in range(M): if rotated[i][j] == 0: rotated[i][j] = matrix[i][j] return rotated"},{"question":"# Question: Implement the Binary Search Algorithm to Find the Square Root (without using built-in functions) Given a non-negative integer `n`, implement a function to find the integer square root of `n` using the binary search algorithm. The integer square root of a number `n` is the largest integer `x` such that `x^2` is less than or equal to `n`. Write a function `integer_square_root(n: int) -> int` that returns the integer square root of `n`. Input - `n` (integer): A non-negative integer whose square root needs to be found. Output - `int`: The integer square root of `n`. Constraints - `0 <= n <= 10^9` Example ```python assert integer_square_root(16) == 4 assert integer_square_root(8) == 2 assert integer_square_root(1) == 1 assert integer_square_root(0) == 0 assert integer_square_root(1000000000) == 31622 ``` Explanation: - For `n = 16`, the integer square root is `4` since `4^2 = 16`. - For `n = 8`, the integer square root is `2` since `3^2 = 9` is greater than `8`, but `2^2 = 4` is less than or equal to `8`. Please implement the `integer_square_root` function using the binary search algorithm for efficient computation within the provided constraints.","solution":"def integer_square_root(n: int) -> int: Returns the integer square root of a non-negative integer n using binary search. if n < 2: return n left, right = 1, n // 2 while left <= right: mid = (left + right) // 2 square = mid * mid if square == n: return mid elif square < n: left = mid + 1 else: right = mid - 1 return right"},{"question":"# Database Query Optimization: Advanced Query Refinement In this task, you are required to enhance a database query\'s performance by refactoring and introducing optimization techniques. Implement a class `QueryOptimizer` that encapsulates the functionality of rewriting and optimizing SQL queries. The optimization will focus on reducing query execution time by implementing and validating indexes, refining query structure, and managing joins. # Class and Methods Specification: Class: ```python class QueryOptimizer: def __init__(self, query: str): self.original_query = query def add_index(self, table: str, column: str) -> str: pass def optimize_query_structure(self) -> str: pass def optimize_joins(self) -> str: pass def execute_optimized_query(self) -> dict: pass def validate_query(self, query: str) -> None: pass ``` # Method Description: * `__init__(self, query: str)`: Initialize the `QueryOptimizer` instance with the original query to be optimized. * `add_index(self, table: str, column: str) -> str`: Adds an index on the specified column of the given table. This can improve query performance involving that column. Validates input using the `validate_query` method. * `optimize_query_structure(self) -> str`: Refactors the input SQL query to enhance performance by optimizing its structure, such as reducing subqueries, avoiding unnecessary use of wildcards (`*`), and promoting proper selection criteria. * `optimize_joins(self) -> str`: Rewrites and optimizes joins in the query for faster execution, such as converting nested loops to more efficient join operations and ensuring that indexes are properly utilized. * `execute_optimized_query(self) -> dict`: Executes the optimized query and returns the execution result as a dictionary containing the execution time and result set. Assumes access to a database connection for execution. * `validate_query(self, query: str) -> None`: Validates that the SQL query is syntactically correct and does not contain any dangerous or invalid operations. # Constraints: - The SQL query follows standard SQL conventions and is executed in a relational database. - The provided query is assumed to be well-formed but not optimized. - Tables and columns specified in the methods exist and are valid. - The database connection and execution are simulated, and results are returned as mock data for demonstration purposes. # Examples: ```python query = \\"SELECT * FROM customers WHERE city = \'New York\';\\" optimizer = QueryOptimizer(query) # Example for adding index: index_cmd = optimizer.add_index(\\"customers\\", \\"city\\") print(index_cmd) # Output: \\"CREATE INDEX idx_city ON customers(city);\\" # Example for optimizing query structure: optimized_structure = optimizer.optimize_query_structure() print(optimized_structure) # Optimized query string without changing the results # Example for optimizing joins: optimized_joins = optimizer.optimize_joins() print(optimized_joins) # Optimized query with improved join performance # Example of executing the optimized query: execution_result = optimizer.execute_optimized_query() print(execution_result) # Output: {\'execution_time\': 0.034, \'result_set\': [...]} # Validation error example: try: optimizer.add_index(\\"\\", \\"city\\") except ValueError as e: print(e) # Output: \'Invalid query. Ensure the query is well-formed and the inputs are valid.\' ``` By maintaining consistent style, complexity, and scope, this question aligns with the provided [Question 1], offering an engaging and challenging task for candidates.","solution":"class QueryOptimizer: def __init__(self, query: str): self.original_query = query self.optimized_query = query def add_index(self, table: str, column: str) -> str: query = f\\"CREATE INDEX idx_{column} ON {table}({column});\\" self.validate_query(query) return query def optimize_query_structure(self) -> str: # Example optimization: removing wildcards and unnecessary subqueries optimized_query = self.original_query.replace(\\"SELECT *\\", \\"SELECT specific_columns\\") self.validate_query(optimized_query) self.optimized_query = optimized_query return self.optimized_query def optimize_joins(self) -> str: # Example optimization: improving join by aliasing optimized_query = self.original_query.replace(\\"INNER JOIN\\", \\"JOIN\\") self.validate_query(optimized_query) self.optimized_query = optimized_query return self.optimized_query def execute_optimized_query(self) -> dict: # Mocking execution time and result set return { \'execution_time\': 0.034, \'result_set\': [{\'id\': 1, \'name\': \'John Doe\'}, {\'id\': 2, \'name\': \'Jane Smith\'}] } def validate_query(self, query: str) -> None: if not query or \';\' not in query: raise ValueError(\\"Invalid query. Ensure the query is well-formed and the inputs are valid.\\")"},{"question":"# Problem: Binary Tree Right Side View Context: Given a binary tree, imagine yourself standing on the right side of it. Your task is to return the values of the nodes you can see ordered from top to bottom. Function Signature: ```python def right_side_view(root: TreeNode | None) -> List[int]: pass ``` Input: - `root` (TreeNode | None): The root node of the binary tree (or None for an empty tree). Output: - `List[int]`: A list of node values visible from the right side view of the binary tree, ordered from top to bottom. Constraints: - The number of nodes in the tree can be up to 10^4. - Node values are integers within the range of -100 <= node.value <= 100. Requirements: 1. Implement a level-order traversal (BFS) to determine the rightmost node at each level. 2. Ensure your solution handles large trees efficiently. 3. Consider edge cases such as empty trees and single-node trees. Example: ```python # Example 1: # Input: # 1 # / # 2 3 # / # 4 5 6 # Output: [1, 3, 6] # Example 2: # Input: # 1 # / # 2 3 # # 5 # Output: [1, 3, 5] # Example Usage: root = TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3, None, TreeNode(6))) assert right_side_view(root) == [1, 3, 6] root = TreeNode(1, TreeNode(2, None, TreeNode(5)), TreeNode(3)) assert right_side_view(root) == [1, 3, 5] root = TreeNode(1) assert right_side_view(root) == [1] ``` Notes: - **Algorithm Choice**: Using BFS ensures we process each level from left to right, capturing the rightmost node efficiently. - **Edge Cases**: Test your function with varying tree shapes like perfectly balanced, skewed, and trees with missing nodes.","solution":"from typing import List, Optional from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def right_side_view(root: Optional[TreeNode]) -> List[int]: if not root: return [] queue = deque([root]) right_side = [] while queue: level_length = len(queue) for i in range(level_length): node = queue.popleft() if i == level_length - 1: # last node in the current level right_side.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) return right_side"},{"question":"# Question: Array Median Finder You are tasked with implementing two functions to find the median of a list of numbers. The goal is to assess your understanding of basic statistics and sorting. Implement the following two functions according to the specifications given: 1. **find_median_sorted_list** - **Input**: A sorted list of numbers (integers or floats). - **Output**: The median of the list. - **Constraints**: 1. The function must raise a `ValueError` if the list is empty. 2. The function should assume the list is pre-sorted, and the running time should be O(1). 2. **find_median_unsorted_list** - **Input**: A list of numbers (integers or floats). - **Output**: The median of the list. - **Constraints**: 1. The function must raise a `ValueError` if the list is empty. 2. The function should sort the list internally before finding the median. **Function Definitions**: ```python def find_median_sorted_list(nums: list[int | float]) -> int | float: # Your code here def find_median_unsorted_list(nums: list[int | float]) -> int | float: # Your code here ``` **Example Test Cases**: ```python # Test cases for find_median_sorted_list assert find_median_sorted_list([1, 2, 3]) == 2 assert find_median_sorted_list([1, 2, 3, 4]) == 2.5 assert find_median_sorted_list([-1, 0, 1]) == 0 assert find_median_sorted_list([3.0, 4.0, 5.0]) == 4.0 try: find_median_sorted_list([]) except ValueError: print(\\"Caught ValueError as expected\\") # Test cases for find_median_unsorted_list assert find_median_unsorted_list([3, 1, 2]) == 2 assert find_median_unsorted_list([4, 3, 1, 2]) == 2.5 assert find_median_unsorted_list([0, -1, 1]) == 0 assert find_median_unsorted_list([5.0, 3.0, 4.0]) == 4.0 try: find_median_unsorted_list([]) except ValueError: print(\\"Caught ValueError as expected\\") ``` **Requirements**: - Ensure handling of both even and odd-length lists appropriately. - Optimize the handling of the median calculation where possible. - Adhere to the provided function signatures and constraints. Good luck!","solution":"def find_median_sorted_list(nums): Returns the median of a sorted list of numbers. Raises a ValueError if the list is empty. Assumes the list is pre-sorted. if not nums: raise ValueError(\\"The list is empty\\") n = len(nums) middle = n // 2 if n % 2 == 0: return (nums[middle - 1] + nums[middle]) / 2.0 else: return nums[middle] def find_median_unsorted_list(nums): Returns the median of an unsorted list of numbers. Raises a ValueError if the list is empty. Sorts the list internally before finding the median. if not nums: raise ValueError(\\"The list is empty\\") nums.sort() return find_median_sorted_list(nums)"},{"question":"# Task You are required to implement a function that checks if a given directed graph is a Tree. A tree is a connected graph with no cycles and containing `n` vertices and `n-1` edges. # Objective Given a directed graph represented as an adjacency list, write a function `is_tree` that returns `True` if the graph is a tree, and `False` otherwise. # Input - `graph` (Dict[int, List[int]]): A dictionary where keys are node identifiers (integers) and values are lists of nodes that the key node has directed edges to. # Output - `bool`: Returns `True` if the graph is a tree, `False` otherwise. # Constraints 1. The graph should contain at least one node. 2. The nodes are labeled with unique integers starting from 0. 3. The graph only contains directed edges. 4. There are no self-loops (i.e., a node cannot have an edge to itself). # Examples ```python is_tree({0: [1, 2], 1: [3], 2: [], 3: []}) # Output: True is_tree({0: [1], 1: [2], 2: [3], 3: [1]}) # Output: False is_tree({0: [1], 1: [2], 2: [3], 3: []}) # Output: True is_tree({0: [1, 2], 1: [3], 2: [3], 3: []}) # Output: False is_tree({0: [1], 1: [2], 2: []}) # Output: True ``` # Guidelines - Make sure to handle graphs with only one node (it is a tree as long as it has no edges). - Handle disconnected graphs appropriately (they are not trees). - Avoid cycles by utilizing appropriate graph traversal techniques like Depth-First Search (DFS). - Verify the graph has `n-1` edges where `n` is the number of nodes, and it is fully connected.","solution":"def is_tree(graph): def has_cycle(v, visited, rec_stack): visited.add(v) rec_stack.add(v) for neighbor in graph[v]: if neighbor not in visited: if has_cycle(neighbor, visited, rec_stack): return True elif neighbor in rec_stack: return True rec_stack.remove(v) return False if not graph: return False n = len(graph) visited = set() rec_stack = set() if has_cycle(0, visited, rec_stack): return False if len(visited) != n: return False edge_count = sum(len(edges) for edges in graph.values()) if edge_count != n - 1: return False return True"},{"question":"# Problem Statement You are tasked with creating a function that analyzes and reports details about the data types used within a Python script. Your function should provide insights into the variables, their types, and the frequency of each type\'s usage within the given script. Function Signature ```python def analyze_data_types(script: str) -> dict[str, int]: ``` Input * `script` (str): A string containing the entire Python script to analyze. Output * Returns a dictionary where keys are data type names (e.g., \'int\', \'str\', etc.) and values are the counts of each type\'s occurrence in the script. Constraints * The input script can be of any length but should be syntactically correct Python code. * You should account only for user-defined variables (not including imported modules or built-ins). * Consider basic data types, such as `int`, `float`, `str`, `list`, `tuple`, `dict`, `set`, and `bool`. Requirements * Use Python\'s `ast` module to parse the Python script and analyze variable assignments. * Handle scripts that include various scopes, such as functions, classes, and global variables. * Ensure the solution works within a reasonable time frame for scripts with up to 1000 lines of code. # Example ```python sample_script = \'\'\' a = 10 b = \'hello\' c = [1, 2, 3] d = {\'key\': \'value\'} e = (4, 5) f = 3.14 g = True \'\'\' data_type_analysis = analyze_data_types(sample_script) print(data_type_analysis) # Example Output: {\'int\': 1, \'str\': 1, \'list\': 1, \'dict\': 1, \'tuple\': 1, \'float\': 1, \'bool\': 1} ``` # Testing * Test with scripts that contain complex data structures, nested assignments, and multiple scopes (functions/classes). * Ensure that the function correctly identifies and counts each data type. * Handle edge cases such as scripts with no assignments, scripts with comments, and scripts with unusual but valid Python syntax.","solution":"import ast def analyze_data_types(script: str) -> dict: type_counter = { \'int\': 0, \'str\': 0, \'list\': 0, \'tuple\': 0, \'dict\': 0, \'set\': 0, \'float\': 0, \'bool\': 0 } def get_type_name(node): if isinstance(node, ast.Num): if isinstance(node.n, int): return \'int\' elif isinstance(node.n, float): return \'float\' elif isinstance(node, ast.Str): return \'str\' elif isinstance(node, ast.List): return \'list\' elif isinstance(node, ast.Tuple): return \'tuple\' elif isinstance(node, ast.Dict): return \'dict\' elif isinstance(node, ast.Set): return \'set\' elif isinstance(node, ast.NameConstant): if node.value in (True, False): return \'bool\' return None tree = ast.parse(script) for node in ast.walk(tree): if isinstance(node, ast.Assign): for target in node.targets: if isinstance(target, ast.Name): type_name = get_type_name(node.value) if type_name and type_name in type_counter: type_counter[type_name] += 1 return {k: v for k, v in type_counter.items() if v > 0}"},{"question":"# Problem Statement You are given a list of integers representing the heights of buildings in a skyline, where each element in the list represents the height of a building. You need to compute the total area that the skyline silhouette would cover when viewed from a distant vantage point. Each building is assumed to be of unit width and all buildings stand side-by-side. # Task Write a function `calculate_skyline_area` that takes in a list of integers `heights` and returns the integer value of the total area covered by the skyline. # Input * `heights`: A list of integers representing the heights of buildings. # Output * An integer representing the total skyline area. # Constraints * The length of `heights` will not exceed 10,000 elements. * Each height value in `heights` will be a non-negative integer and will not exceed 10,000. # Example ```python def calculate_skyline_area(heights: list[int]) -> int: pass # Example Usage heights = [1, 3, 2, 1, 2] print(calculate_skyline_area(heights)) # Output: 9 ``` # Notes Consider edge cases where the list `heights` might be empty or contain only one building. Make sure your function handles these scenarios gracefully.","solution":"def calculate_skyline_area(heights: list[int]) -> int: Calculate the total area covered by the skyline silhouette. Args: heights: A list of integers representing the heights of buildings. Returns: An integer representing the total area of the skyline. return sum(heights)"},{"question":"# Problem: Implement a Dynamic Hash Map Class with Collision Handling You are tasked with implementing a dynamic hash map class in Python. The hash map should support dynamic resizing and must handle collisions using chaining. Implement the following methods: `put`, `get`, and `delete`. Ensure to consider edge cases and provide validations to handle potential errors. # Function Signatures ```python class MyHashMap: def __init__(self): self.size = 16 self.count = 0 self.buckets = [[] for _ in range(self.size)] def put(self, key: int, value: int) -> None: pass def get(self, key: int) -> int: pass def delete(self, key: int) -> None: pass ``` # Requirements 1. Implement the `put` method that inserts a key-value pair into the hash map. - If the load factor exceeds 0.75, double the size of the hash map and rehash all existing keys. - Handle collisions using separate chaining with linked lists. 2. Implement the `get` method that retrieves the value for a given key. - If the key does not exist, return -1. 3. Implement the `delete` method that removes the key-value pair from the hash map. - If the key does not exist, do nothing. 4. Ensure all operations (put, get, delete) are as efficient as possible. # Constraints - The keys will be non-negative integers. - The values can be any integers. - Initial size of the hash map is 16, and the load factor threshold is 0.75. # Example ```python >>> hashmap = MyHashMap() >>> hashmap.put(1, 1) >>> hashmap.put(2, 2) >>> hashmap.get(1) # returns 1 1 >>> hashmap.get(3) # returns -1 (not found) -1 >>> hashmap.put(2, 1) # update the existing value >>> hashmap.get(2) # returns 1 1 >>> hashmap.delete(2) # remove the mapping for 2 >>> hashmap.get(2) # returns -1 (not found) -1 ```","solution":"class MyHashMap: def __init__(self): self.size = 16 self.count = 0 self.buckets = [[] for _ in range(self.size)] def put(self, key: int, value: int) -> None: self._resize_if_needed() bucket_index = key % self.size bucket = self.buckets[bucket_index] for i, (k, v) in enumerate(bucket): if k == key: bucket[i] = (key, value) return bucket.append((key, value)) self.count += 1 def get(self, key: int) -> int: bucket_index = key % self.size bucket = self.buckets[bucket_index] for k, v in bucket: if k == key: return v return -1 def delete(self, key: int) -> None: bucket_index = key % self.size bucket = self.buckets[bucket_index] for i, (k, v) in enumerate(bucket): if k == key: del bucket[i] self.count -= 1 return def _resize_if_needed(self): if self.count / self.size > 0.75: new_size = self.size * 2 new_buckets = [[] for _ in range(new_size)] for bucket in self.buckets: for k, v in bucket: new_bucket_index = k % new_size new_buckets[new_bucket_index].append((k, v)) self.buckets = new_buckets self.size = new_size"},{"question":"# Coding Assessment Question **Problem Context:** You are given an array of integers and tasked with finding the longest contiguous subarray that has a sum equal to a given target. This problem assesses your understanding of prefix sums, hashmap usage, and subarray identification techniques. # Problem Statement: Write a function `longest_subarray_with_sum` that finds the length of the longest contiguous subarray within a given array such that the sum of the subarray is equal to a specified target sum. # Function Signature: ```python def longest_subarray_with_sum(nums: list[int], target: int) -> int: pass ``` # Input: - `nums` (list[int]): A list of integers. - `target` (int): The target sum for the subarray. # Output: - (int): The length of the longest contiguous subarray with a sum equal to the target. # Constraints: - ( 1 leq text{len(nums)} leq 10^5 ) - ( -10^4 leq text{nums[i]}, text{target} leq 10^4 ) # Example: ```python assert longest_subarray_with_sum([1, -1, 5, -2, 3], 3) == 4 assert longest_subarray_with_sum([-2, -1, 2, 1], 1) == 2 assert longest_subarray_with_sum([1, 2, 3, 4], 10) == 4 ``` # Requirements: - Implement the function using efficient algorithms to handle large input sizes. - Consider using a hashmap to store running sums and their first occurrences to find subarrays quickly. - Ensure that your solution handles negative and positive numbers within the array. # Notes: - The approach should focus on finding the maximum length efficiently, avoiding brute force methods. - Be mindful of edge cases, such as arrays containing only one element or sums that cannot be achieved by any subarray.","solution":"def longest_subarray_with_sum(nums, target): Finds the length of the longest contiguous subarray such that the sum of the subarray is equal to the target sum. sum_map = {} # Dictionary to store the first occurrence of sums current_sum = 0 max_length = 0 for i in range(len(nums)): current_sum += nums[i] # Check if current_sum is equal to target if current_sum == target: max_length = i + 1 # Check if current_sum - target exists in the map if (current_sum - target) in sum_map: max_length = max(max_length, i - sum_map[current_sum - target]) # Store the current sum if it\'s not already in the map if current_sum not in sum_map: sum_map[current_sum] = i return max_length"},{"question":"# Coding Assessment Question Scenario & Context You are a software developer working on a new feature for an educational platform that helps students understand and visualize data structures, particularly trees. You need to create a function that evaluates the balance of a binary tree and another function to merge two binary trees. Problem Statement Implement two functions `is_balanced` and `merge_trees` that respectively check if a binary tree is height-balanced and merge two binary trees into one. 1. **is_balanced**: This function should determine if a binary tree is height-balanced. A binary tree is height-balanced if, for every node in the tree, the difference in height between the left and right subtrees is at most 1. 2. **merge_trees**: This function should merge two binary trees by summing the values of nodes that overlap while preserving non-overlapping nodes. Function Specifications 1. **is_balanced** function: - **Input**: - `root` (TreeNode): The root node of the binary tree. - **Output**: - (bool): True if the binary tree is height-balanced, otherwise False. - **Constraints**: - The tree can have up to (10^4) nodes. - **Error Handling**: - Handle an empty tree by returning True (an empty tree is considered balanced). 2. **merge_trees** function: - **Input**: - `t1` (TreeNode): The root node of the first binary tree. - `t2` (TreeNode): The root node of the second binary tree. - **Output**: - (TreeNode): The root node of the merged binary tree. - **Constraints**: - Each tree can have up to (10^4) nodes. - **Error Handling**: - Handle the cases where one or both trees are empty appropriately. # Example ```python # Example usage: # Define TreeNode class class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right # is_balanced function example root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) root.left.left.left = TreeNode(8) print(is_balanced(root)) # Output: False # merge_trees function example t1 = TreeNode(1) t1.left = TreeNode(3) t1.right = TreeNode(2) t1.left.left = TreeNode(5) t2 = TreeNode(2) t2.left = TreeNode(1) t2.right = TreeNode(3) t2.left.right = TreeNode(4) t2.right.right = TreeNode(7) merged_root = merge_trees(t1, t2) # The resulting tree: # merged_root.val = 3 # merged_root.left.val = 4 # merged_root.right.val = 5 # merged_root.left.left.val = 5 # merged_root.left.right.val = 4 # merged_root.right.right.val = 7 ``` Note * Implement the `TreeNode` class if it is not already provided in the environment. * Ensure to handle edge cases where one or both trees are empty.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_balanced(root): def check_height(node): if not node: return 0, True left_height, left_balanced = check_height(node.left) right_height, right_balanced = check_height(node.right) current_balanced = left_balanced and right_balanced and abs(left_height - right_height <= 1) return max(left_height, right_height) + 1, current_balanced height, balanced = check_height(root) return balanced def merge_trees(t1, t2): if not t1 and not t2: return None if not t1: return t2 if not t2: return t1 t1.val += t2.val t1.left = merge_trees(t1.left, t2.left) t1.right = merge_trees(t1.right, t2.right) return t1"},{"question":"# Coding Assessment Question Context You are working on a graph-based social networking platform. The task is to identify the \\"mutual friends\\" between two users represented as nodes in an undirected graph. A mutual friend is a common neighbor of both nodes. Objective Write a function to find all the mutual friends between two specified users in an undirected graph. Function Signature ```python def find_mutual_friends(graph: dict, user1: str, user2: str) -> list: Finds all mutual friends between two users in an undirected graph. Args: graph (dict): Dictionary representing the graph where each key is a node (user), and its value is a list of neighbors (friends). { \\"userA\\": [\\"friend1\\", \\"friend2\\", ...], ... } user1 (str): The first user. user2 (str): The second user. Returns: list: A list of mutual friends\' usernames. If there are no mutual friends, return an empty list. pass ``` Input & Output * **Input**: The function takes a dictionary representing the graph, and two strings representing the users. * `graph`: A dictionary where each key is a user (node), and the value is a list of neighbors (friends). * `user1`: A string indicating the first user. * `user2`: A string indicating the second user. * **Output**: The function should return a list of strings representing the mutual friends. If there are no mutual friends, return an empty list. Constraints * The users and their friends are represented as strings. * You may assume all nodes are unique and the graph is connected. * The graph is guaranteed to be an undirected graph, meaning if userA is a friend of userB, userB is also a friend of userA. Example ```python graph = { \\"Alice\\": [\\"Bob\\", \\"Charlie\\", \\"David\\"], \\"Bob\\": [\\"Alice\\", \\"Charlie\\"], \\"Charlie\\": [\\"Alice\\", \\"Bob\\", \\"Eve\\"], \\"David\\": [\\"Alice\\"], \\"Eve\\": [\\"Charlie\\"] } user1 = \\"Alice\\" user2 = \\"Charlie\\" assert find_mutual_friends(graph, user1, user2) == [\\"Bob\\"] ``` Performance Requirements * The implementation should efficiently handle graphs with up to 1,000 nodes and 5,000 edges.","solution":"def find_mutual_friends(graph: dict, user1: str, user2: str) -> list: Finds all mutual friends between two users in an undirected graph. Args: graph (dict): Dictionary representing the graph where each key is a node (user), and its value is a list of neighbors (friends). { \\"userA\\": [\\"friend1\\", \\"friend2\\", ...], ... } user1 (str): The first user. user2 (str): The second user. Returns: list: A list of mutual friends\' usernames. If there are no mutual friends, return an empty list. if user1 not in graph or user2 not in graph: return [] user1_friends = set(graph[user1]) user2_friends = set(graph[user2]) mutual_friends = user1_friends.intersection(user2_friends) return list(mutual_friends)"},{"question":"# Coding Question **Scenario**: You are developing a warehouse management system that must efficiently compute the optimal storage arrangement. The available space in the warehouse is organized into a grid, and certain cells are marked as unusable due to damage. Your task is to write a function that calculates the number of distinct paths from the top-left corner to the bottom-right corner of the grid while avoiding unusable cells. Each cell in the grid can be either empty (`0`) or unusable (`1`). You can only move either right or down from any cell. **Question**: Implement a function `unique_paths_with_obstacles(grid: List[List[int]]) -> int` that determines the number of unique paths from the top-left corner to the bottom-right corner of a given grid while avoiding unusable cells. **Input**: - `grid` (a list of lists of integers): A 2D grid where each element is either `0` (empty) or `1` (unusable). The grid dimensions are at most `100 x 100`. **Output**: - An integer representing the number of unique paths from the top-left to the bottom-right corner. **Constraints**: - The top-left corner is always empty (`0`). - The bottom-right corner is always empty (`0`). - Moving into a cell marked `1` is not allowed. # Examples 1. `unique_paths_with_obstacles([[0, 0, 0], [0, 1, 0], [0, 0, 0]])` should return `2`. 2. `unique_paths_with_obstacles([[0, 1], [0, 0]])` should return `1`. # Function Signature ```python def unique_paths_with_obstacles(grid: List[List[int]]) -> int: pass ``` **Hint**: - Use dynamic programming to accumulate the number of ways to reach each cell, considering the given constraints. # Solution Preview ```python def unique_paths_with_obstacles(grid: List[List[int]]) -> int: if not grid: return 0 m, n = len(grid), len(grid[0]) if grid[0][0] == 1 or grid[m-1][n-1] == 1: return 0 dp = [[0] * n for _ in range(m)] dp[0][0] = 1 for i in range(m): for j in range(n): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[m-1][n-1] ```","solution":"from typing import List def unique_paths_with_obstacles(grid: List[List[int]]) -> int: if not grid or grid[0][0] == 1 or grid[-1][-1] == 1: return 0 m, n = len(grid), len(grid[0]) dp = [[0] * n for _ in range(m)] dp[0][0] = 1 for i in range(m): for j in range(n): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[m-1][n-1]"},{"question":"Scenario Understanding basic data structures such as stacks and queues is fundamental in programming. A common issue is converting one data structure to another efficiently while maintaining specific properties of the data. # Problem Statement Implement a Python function `queue_from_stack_operations(operations: List[str]) -> List[Any]` that simulates a queue using stack operations. The stack operations are simple and only allow pushing elements on top of the stack, popping elements from the top of the stack, and checking if the stack is empty. The operations are provided as a list of strings where each string is either: * `\\"push x\\"`: Pushes the integer `x` onto the back of the queue. * `\\"pop\\"`: Removes the integer from the front of the queue and returns it. * `\\"empty\\"`: Returns a boolean indicating whether the queue is empty. # Input - `operations` (1 ≤ len(operations) ≤ 10^4): A list of strings representing the operations. # Output - Return a list of results for the operations in the order they were processed. For `\\"pop\\"`, include the value that was removed from the front of the queue. For `\\"empty\\"`, include the boolean result of the check. Do not include any result for `\\"push x\\"` operations. # Constraints - The total number of `\\"pop\\"` operations is guaranteed to be less than or equal to the number of `\\"push x\\"` operations. # Performance Requirements Your solution should operate efficiently with time complexity approximating that of the queue operations. # Example ```python def queue_from_stack_operations(operations: List[str]) -> List[Any]: # Implement your function here # Example usage: print(queue_from_stack_operations([\\"push 1\\", \\"push 2\\", \\"pop\\", \\"empty\\", \\"pop\\", \\"empty\\"])) # Output: [1, False, 2, True] ``` In this example, the function should simulate the queue operations using stack operations and produce the correct output list. # Notes 1. You may use two stacks internally, one for pushing new elements and one for popping elements to simulate the queue. 2. Your function must handle all operations efficiently and ensure that the integrity of the queue behavior is maintained.","solution":"from typing import List, Any def queue_from_stack_operations(operations: List[str]) -> List[Any]: push_stack = [] pop_stack = [] result = [] for operation in operations: if operation.startswith(\\"push\\"): _, x = operation.split() push_stack.append(int(x)) elif operation == \\"pop\\": if not pop_stack: while push_stack: pop_stack.append(push_stack.pop()) result.append(pop_stack.pop()) elif operation == \\"empty\\": result.append(not push_stack and not pop_stack) return result"},{"question":"# Coding Question Scenario You are tasked with developing a simple simulation of a queue management system where people arrive at different times and the queue processes one person at a time. The objective is to process the queue such that each person has a specific arrival time and processing time. Requirements Implement a function `process_queue` that takes a list of tuples, each representing a person\'s arrival time and the time they take to be processed. The function should return a list representing the order in which each person is processed. Function Signature ```python def process_queue(arrivals: list[tuple[int, int]]) -> list[int]: ``` Input * `arrivals`: A list of tuples where each tuple contains two integers. The first integer represents the arrival time of a person and the second integer represents the processing time for that person. Output * A list of integers, where each integer represents the index of the person (based on their initial order in the input list) in the order they are processed. Constraints 1. Assume arrival times are given in non-decreasing order. 2. If multiple people have the same arrival time, they are processed in the order they appear in the list. 3. The length of `arrivals` will not exceed 50. Example ```python >>> process_queue([(0, 3), (2, 2), (3, 1), (4, 2)]) [0, 1, 2, 3] >>> process_queue([(1, 4), (2, 3), (5, 1), (6, 2)]) [0, 1, 2, 3] ``` Note that the output list indices are based on the initial order of people in the input list. Edge Cases 1. `arrivals` is empty. 2. All people have the same arrival time. 3. People have arrival times but zero processing times.","solution":"def process_queue(arrivals): Takes a list of tuples, each representing a person\'s arrival time and processing time, and returns a list representing the order in which each person is processed. Parameters: arrivals (list of tuple of int, int): A list of tuples where each tuple contains two integers. The first integer represents the arrival time, and the second integer represents the processing time. Returns: List[int]: A list of integers representing the order in which each person is processed based on their index in the `arrivals` list. order = [] current_time = 0 for i, (arrival, processing) in enumerate(arrivals): if current_time < arrival: current_time = arrival current_time += processing order.append(i) return order"},{"question":"# Shopping Cart Implementation with Dynamic Pricing You are tasked with implementing a dynamic pricing feature for an online shopping cart. The goal is to apply discounts based on the total cart value. Specifically, if the total value exceeds certain thresholds, different discount rates will be applied. # Instructions: 1. Create a class `ShoppingCart` that contains methods to add items, remove items, and calculate the total cost. 2. Implement dynamic pricing in the `total_cost` method which applies the following discount rates: * No discount if the total value is less than 100. * 10% discount if the total value is between 100 and 200 (inclusive). * 20% discount if the total value exceeds 200. # Input: * A method to add items to the cart. Each item has a price. * A method to remove items from the cart. Removal is based on item name. * A method to calculate the total cart value after applying the appropriate discount. # Output: * Total cart value after applying the discount. # Constraints: * An item cannot be added more than once. * When an item is removed from the cart, it should not affect the cart if it does not exist in the cart. * Ensure to handle edge cases such as trying to remove an item that is not present in the cart. # Example: ```python cart = ShoppingCart() cart.add_item(\\"Laptop\\", 150) cart.add_item(\\"Mouse\\", 50) print(cart.total_cost()) # Should return 180.0 (10% discount applied) cart.add_item(\\"Monitor\\", 100) print(cart.total_cost()) # Should return 240.0 (20% discount applied) cart.remove_item(\\"Mouse\\") print(cart.total_cost()) # Should return 200.0 (10% discount applied) cart.remove_item(\\"Keyboard\\") # Trying to remove an item not present in the cart print(cart.total_cost()) # Should return 200.0 (10% discount applied) cart.remove_item(\\"Monitor\\") print(cart.total_cost()) # Should return 150.0 (no discount applied) ``` # Function Signature: ```python class ShoppingCart: def __init__(self): self.items = {} def add_item(self, item_name: str, item_price: float): pass def remove_item(self, item_name: str): pass def total_cost(self) -> float: pass # Usage Example cart = ShoppingCart() cart.add_item(\\"Laptop\\", 150) cart.add_item(\\"Mouse\\", 50) print(cart.total_cost()) # Should return 180.0 (10% discount applied) cart.add_item(\\"Monitor\\", 100) print(cart.total_cost()) # Should return 240.0 (20% discount applied) cart.remove_item(\\"Mouse\\") print(cart.total_cost()) # Should return 200.0 (10% discount applied) ```","solution":"class ShoppingCart: def __init__(self): self.items = {} def add_item(self, item_name: str, item_price: float): if item_name not in self.items: self.items[item_name] = item_price def remove_item(self, item_name: str): if item_name in self.items: del self.items[item_name] def total_cost(self) -> float: total = sum(self.items.values()) if total > 200: discount = 0.20 elif total >= 100: discount = 0.10 else: discount = 0.0 return total * (1 - discount)"},{"question":"# Find Median from Data Stream The goal is to implement a data structure that supports adding new numbers from a data stream and finding the median of all numbers added so far. Input: * Sequence of integers, one-by-one, added to the data structure. Output: * After each insertion, return the median of the current set of numbers. Constraints: * Each integer will be between -10^5 and 10^5. * At most 10^4 integers will be added. Requirements: * Design the data structure to support the dynamic updates efficiently. * Each insertion and median query should be optimized for time complexity. # Function Signature: ```python class MedianFinder: def __init__(self): pass def addNum(self, num: int) -> None: pass def findMedian(self) -> float: pass ``` # Example: ```python # Example usage mf = MedianFinder() mf.addNum(1) print(mf.findMedian()) # Output: 1.0 mf.addNum(2) print(mf.findMedian()) # Output: 1.5 mf.addNum(3) print(mf.findMedian()) # Output: 2.0 ``` # Additional Information: * You may use any standard data structures and algorithms. * Ensure to handle both even and odd number of elements inserted. * Consider edge cases such as a single element and large variations in magnitude of integers.","solution":"import heapq class MedianFinder: def __init__(self): # Two heaps: one max-heap for the lower half and one min-heap for the upper half self.small = [] # max-heap (inverted min-heap) self.large = [] # min-heap def addNum(self, num: int) -> None: # Maintain the order: small heap has the smaller half and large heap has the larger half heapq.heappush(self.small, -num) # Ensure the smallest number in `large` is greater than or equal to the largest number in `small` if self.small and self.large and (-self.small[0]) > self.large[0]: val = -heapq.heappop(self.small) heapq.heappush(self.large, val) # Balance the sizes of the heaps (small can have 1 more element than large) if len(self.small) > len(self.large) + 1: val = -heapq.heappop(self.small) heapq.heappush(self.large, val) if len(self.large) > len(self.small): val = heapq.heappop(self.large) heapq.heappush(self.small, -val) def findMedian(self) -> float: if len(self.small) > len(self.large): return -self.small[0] return (-self.small[0] + self.large[0]) / 2.0"},{"question":"# Question: Implement a Recursive Merge Sort You have to implement the merge sort algorithm recursively. Given a list of integers, return the list sorted in ascending order using a recursive merge sort. Function Signature ```python def recursive_merge_sort(arr: list[int]) -> list[int]: pass ``` Input * A list of integers called `arr`. Output * A list of integers sorted in ascending order. Constraints * The input list will have a length between 0 and 1000. * Elements in the list are between -10^6 and 10^6. * Sorting must be performed using a merge sort algorithm. Requirements * Ensure the provided function is recursive. * Avoid using built-in sorting functions. Example ```python print(recursive_merge_sort([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5 ])) # Output: [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9] ``` Notes * Ensure to handle edge cases such as empty lists and lists with a single element. * Your solution should be efficient in terms of both time and space complexity.","solution":"def recursive_merge_sort(arr: list[int]) -> list[int]: if len(arr) <= 1: return arr mid = len(arr) // 2 left_half = recursive_merge_sort(arr[:mid]) right_half = recursive_merge_sort(arr[mid:]) return merge(left_half, right_half) def merge(left: list[int], right: list[int]) -> list[int]: sorted_arr = [] i = j = 0 while i < len(left) and j < len(right): if left[i] < right[j]: sorted_arr.append(left[i]) i += 1 else: sorted_arr.append(right[j]) j += 1 sorted_arr.extend(left[i:]) sorted_arr.extend(right[j:]) return sorted_arr"},{"question":"# Context In this assessment, you are expected to implement a function that involves manipulating strings and applying algorithmic thinking to achieve the desired transformation. Your knowledge of string manipulation and recursion will be necessary for solving this problem effectively. # Problem Statement Design a function `reverse_words_recursively` that takes a string as input and reverses the words in the string using a recursive approach. # Function Signature ```python def reverse_words_recursively(s: str) -> str: ``` # Input * A string `s` containing words separated by spaces. # Output * Returns a new string with the words in reversed order. # Constraints * You must use a recursive approach. * You may not use any built-in functions specifically meant for reversing the order of words directly. * The words will be separated by exactly one space, and there will be no leading or trailing spaces. # Examples ```python # Example 1 s = \\"hello world\\" result = reverse_words_recursively(s) print(result) # Output: \\"world hello\\" # Example 2 s = \\"the quick brown fox\\" result = reverse_words_recursively(s) print(result) # Output: \\"fox brown quick the\\" # Example 3 s = \\"a b c d\\" result = reverse_words_recursively(s) print(result) # Output: \\"d c b a\\" ``` # Hints * Consider how you can divide the problem into smaller subproblems. * Think about what the base case and the recursive step should be.","solution":"def reverse_words_recursively(s: str) -> str: Recursively reverses the words in the input string. Args: s (str): A string containing words separated by spaces. Returns: str: A new string with the words in reversed order. def helper(words): if len(words) == 0: return [] return [words[-1]] + helper(words[:-1]) words = s.split() reversed_words = helper(words) return \' \'.join(reversed_words)"},{"question":"# Question: Matrix Transposition You are tasked with implementing a function that transposes a given matrix. Transposing a matrix means converting its rows into columns and vice versa. # Function Specification Implement the function `transpose_matrix(matrix: List[List[int]]) -> List[List[int]]` with the following behavior: 1. **`transpose_matrix(matrix: List[List[int]]) -> List[List[int]]`** - **Description**: Transposes the given matrix. - **Input**: `matrix` (List[List[int]]) – A two-dimensional list of integers. - **Output**: A new two-dimensional list containing the transposed matrix. # Constraints - The number of rows and columns in the matrix can be different. - Each sublist within the matrix represents a row. The matrix is guaranteed to be non-empty. - Input values are integers within the range [-10^4, 10^4]. # Example Usage ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] print(transpose_matrix(matrix)) # Output: # [ # [1, 4, 7], # [2, 5, 8], # [3, 6, 9] # ] ``` ```python matrix = [ [1, 2, 3], [4, 5, 6] ] print(transpose_matrix(matrix)) # Output: # [ # [1, 4], # [2, 5], # [3, 6] # ] ``` # Notes - Ensure your solution correctly handles rectangular matrices. - Consider edge cases such as a matrix with only one row or one column. - Aim for a time complexity of O(m * n), where m is the number of rows and n is the number of columns in the original matrix.","solution":"from typing import List def transpose_matrix(matrix: List[List[int]]) -> List[List[int]]: Transposes the given matrix. :param matrix: List[List[int]] - A two-dimensional list of integers. :return: A new two-dimensional list containing the transposed matrix. return [[matrix[j][i] for j in range(len(matrix))] for i in range(len(matrix[0]))]"},{"question":"# Scenario You are tasked with writing a function to simulate a basic cache system with a Least Recently Used (LRU) replacement policy. The cache needs to support standard operations such as retrieving and storing key-value pairs. # Task Write a Python class `LRUCache` that initializes with a fixed capacity and provides the following methods: 1. `get(key: int) -> int`: Retrieve the value associated with the given key from the cache. If the key does not exist, return `-1`. 2. `put(key: int, value: int) -> None`: Insert a key-value pair into the cache. If the cache is at its capacity, it should remove the least recently used item before inserting the new item. # Example ```python # Example of usage cache = LRUCache(2) cache.put(1, 1) # cache is {1=1} cache.put(2, 2) # cache is {1=1, 2=2} print(cache.get(1)) # returns 1, cache is {2=2, 1=1} cache.put(3, 3) # removes key 2, cache is {1=1, 3=3} print(cache.get(2)) # returns -1 (not found) cache.put(4, 4) # removes key 1, cache is {4=4, 3=3} print(cache.get(1)) # returns -1 (not found) print(cache.get(3)) # returns 3 print(cache.get(4)) # returns 4 ``` # Constraints * The capacity will always be a positive integer. * The keys and values are all non-negative integers. # Output Provide the functionality as specified for retrieving and storing key-value pairs with LRU cache eviction policy. # Note Your implementation should aim for an average time complexity of O(1) for both `get` and `put` operations.","solution":"from collections import OrderedDict class LRUCache: def __init__(self, capacity: int): self.cache = OrderedDict() self.capacity = capacity def get(self, key: int) -> int: if key not in self.cache: return -1 else: self.cache.move_to_end(key) return self.cache[key] def put(self, key: int, value: int) -> None: if key in self.cache: self.cache.move_to_end(key) self.cache[key] = value if len(self.cache) > self.capacity: self.cache.popitem(last=False)"},{"question":"# Problem Description You are given a list of integers and your task is to find the element in the list that appears the most frequently. If there is a tie (i.e., two or more elements appear the same maximum number of times), return all such elements as a list, sorted in ascending order. # Task Write a function `most_frequent_elements` that takes a list of integers as input and returns the element(s) that appear(s) the most frequently in the list. # Input * `input_list` (List[int]): A list of integers. # Output * (List[int]): A list containing the most frequent element(s) sorted in ascending order. # Constraints * The list can contain negative integers. * The list can be empty. In such a case, return an empty list. * There will not be duplicate counts for non-most frequent elements (unique tie for most frequent elements). # Performance Requirements * Your solution should aim for a linear run-time complexity, i.e., O(n). # Example ```python def most_frequent_elements(input_list: list) -> list: pass # Example usage: print(most_frequent_elements([1, 3, 2, 3, 1, 1, 2, 4])) # Output: [1] print(most_frequent_elements([3, 3, 1, 3, 2, 1, 2, 4, 2])) # Output: [2, 3] print(most_frequent_elements([1, 2, 3, 4, 5])) # Output: [1, 2, 3, 4, 5] print(most_frequent_elements([7, 7, 8, 8, 9])) # Output: [7, 8] print(most_frequent_elements([])) # Output: [] ```","solution":"from collections import Counter def most_frequent_elements(input_list): Returns the list of most frequent element(s) sorted in ascending order. if not input_list: return [] counter = Counter(input_list) max_count = max(counter.values()) most_freq_elements = [element for element, count in counter.items() if count == max_count] return sorted(most_freq_elements)"},{"question":"# Coding Problem: Calculate the Voltage, Resistance, or Current in DC Circuits **Context**: In Direct Current (DC) circuits, Ohm\'s Law is fundamental for determining the relationship between voltage (V), current (I), and resistance (R). This context leads you to develop an algorithm to calculate one of these electrical properties when provided with the other two. **Problem Statement**: Write a function `ohms_law(voltage: float, resistance: float, current: float) -> dict[str, float]` that calculates and returns one of the unknown electrical properties (voltage, resistance, or current) based on the two given input values. The function should return a dictionary with the name of the calculated property as the key and its value as the value. # Input Constraints: - Exactly one of the three input values (`voltage`, `resistance`, `current`) will be zero. - Input values are non-negative. If any input value is negative, raise a `ValueError` with a relevant message. - If none or more than one of the input values are zero, raise a `ValueError` with the message \\"One and only one argument must be 0\\". # Expected Output: - A dictionary with a single key-value pair where the key is either `[\\"voltage\\", \\"resistance\\", \\"current\\"]` and its calculated value. # Function Definitions: ```python def ohms_law(voltage: float, resistance: float, current: float) -> dict[str, float]: Calculate voltage, resistance, or current from two given electrical properties. Parameters: voltage (float): Voltage in Volts resistance (float): Resistance in Ohms current (float): Current in Amperes Returns: dict[str, float]: Dictionary with the name/value pair of the calculated property. Raises: ValueError: If invalid inputs are provided as per the constraints. # Input validation if (voltage, resistance, current).count(0) != 1: raise ValueError(\\"One and only one argument must be 0\\") if voltage < 0: raise ValueError(\\"Voltage cannot be negative\\") if resistance < 0: raise ValueError(\\"Resistance cannot be negative\\") if current < 0: raise ValueError(\\"Current cannot be negative\\") # Calculate the unknown property if voltage == 0: return {\\"voltage\\": resistance * current} elif resistance == 0: return {\\"resistance\\": voltage / current} elif current == 0: return {\\"current\\": voltage / resistance} else: raise ValueError(\\"Exactly one argument must be 0\\") ``` # Examples: 1. `ohms_law(0, 10, 5)` should return `{\'voltage\': 50.0}` 2. `ohms_law(24, 0, 3)` should return `{\'resistance\': 8.0}` 3. `ohms_law(12, 6, 0)` should return `{\'current\': 2.0}` Ensure your function properly handles various test cases and edge cases.","solution":"def ohms_law(voltage: float, resistance: float, current: float) -> dict[str, float]: Calculate voltage, resistance, or current from two given electrical properties. Parameters: voltage (float): Voltage in Volts resistance (float): Resistance in Ohms current (float): Current in Amperes Returns: dict[str, float]: Dictionary with the name/value pair of the calculated property. Raises: ValueError: If invalid inputs are provided as per the constraints. # Input validation if (voltage, resistance, current).count(0) != 1: raise ValueError(\\"One and only one argument must be 0\\") if voltage < 0: raise ValueError(\\"Voltage cannot be negative\\") if resistance < 0: raise ValueError(\\"Resistance cannot be negative\\") if current < 0: raise ValueError(\\"Current cannot be negative\\") # Calculate the unknown property if voltage == 0: return {\\"voltage\\": resistance * current} elif resistance == 0: return {\\"resistance\\": voltage / current} elif current == 0: return {\\"current\\": voltage / resistance} else: raise ValueError(\\"Exactly one argument must be 0\\")"},{"question":"# Sum of Unique Elements Context: You are given an array of integers which may contain duplicates. Your goal is to implement a function that returns the sum of the unique elements in the array, i.e., elements that appear exactly once. Specifications: * Function Signature: `def sum_of_unique_elements(nums: Sequence[int] | None = None) -> int` * Input: * A sequence of integers `nums` * Output: * An integer representing the sum of the unique elements in the sequence. Constraints: 1. The input list, if provided, is not necessarily empty. Your implementation should handle an empty list by raising a `ValueError` with the message \\"Input sequence should not be empty\\". 2. The elements in the list can be negative or positive integers. 3. Your solution must operate in O(n) time and O(n) space. Example: ```python sum_of_unique_elements([1, 2, 2, 3, 4, 4, 5]) # Returns 9 (1 + 3 + 5) sum_of_unique_elements([-1, -2, -2, -3, -1]) # Returns -3 (-3) sum_of_unique_elements([]) # Raises ValueError: Input sequence should not be empty ``` Task: Implement `sum_of_unique_elements()` that meets the above specifications. Include appropriate error handling and edge case analysis as discussed.","solution":"from typing import Sequence def sum_of_unique_elements(nums: Sequence[int] | None = None) -> int: Returns the sum of the unique elements in the list `nums`. Args: nums (Sequence[int] | None): A sequence of integers. Returns: int: The sum of the unique elements in the sequence. Raises: ValueError: If the input sequence is empty or None. if not nums: raise ValueError(\\"Input sequence should not be empty\\") # Use a dictionary to count occurrences of each element count = {} for num in nums: count[num] = count.get(num, 0) + 1 # Sum elements that appear exactly once unique_sum = sum(num for num, cnt in count.items() if cnt == 1) return unique_sum"},{"question":"# Coding Assessment Question Question: You are required to develop a function that calculates the Longest Consecutive Subsequence (LCS) in a given list of integers. The LCS is defined as the length of the longest subsequence of consecutive integers in the list. **Function Signature**: ```python def longest_consecutive_subsequence(nums: list[int]) -> int: ``` **Input**: - `nums`: A list of integers where each element can be positive or negative and integers can be repeated. **Output**: - Returns an integer representing the length of the longest consecutive subsequence in the list. **Constraints**: 1. The length of the list `nums` is ( n ) (0 ≤ ( n ) ≤ 10^5). 2. Each element of `nums` is an integer ( x ) (-10^9 ≤ ( x ) ≤ 10^9). **Performance Requirements**: - The time complexity of your solution should be ( O(n) ). - The space complexity should be ( O(n) ). **Examples**: ```python print(longest_consecutive_subsequence([100, 4, 200, 1, 3, 2])) # Output: 4 (sequence: 1, 2, 3, 4) print(longest_consecutive_subsequence([0, -1, 1])) # Output: 3 (sequence: -1, 0, 1) print(longest_consecutive_subsequence([1, 2, 0, 1])) # Output: 3 (sequence: 0, 1, 2) ``` **Notes**: - Handle cases with duplicate elements without counting them multiple times in the sequence. - Consider edge cases where the list is empty (should return 0). - Assume the input list can be arbitrarily large within the given limits. Implement the function `longest_consecutive_subsequence` to meet the above specifications and handle the examples correctly.","solution":"def longest_consecutive_subsequence(nums: list[int]) -> int: if not nums: return 0 num_set = set(nums) max_length = 0 for num in num_set: if num - 1 not in num_set: current_num = num current_streak = 1 while current_num + 1 in num_set: current_num += 1 current_streak += 1 max_length = max(max_length, current_streak) return max_length"},{"question":"# Question: Implement an Efficient In-Place Heap Sort You are given a list of integers that needs to be sorted using the heap sort algorithm. The algorithm should be implemented efficiently, with consideration to both time and space complexity. Objective Develop a heap sort algorithm that sorts a list of integers in ascending order by following the principles of in-place sorting. Expected Input and Output * **Input**: A list of integers. ```python [int, int, ..., int] ``` * **Output**: The same list of integers sorted in ascending order. ```python [int, int, ..., int] ``` Constraints * The input list will contain at most 100,000 elements. * Each integer in the list will fit within the 32-bit signed integer range: [−2³¹, 2³¹ − 1]. Performance Requirements * Time complexity: O(n log n) * Space complexity: O(1) (in-place sorting) Scenario Imagine you are a software engineer tasked with improving the efficiency of a sorting function used for maintaining a priority queue. The function must sort large data sets in-place without using additional space. # Your Task: Write a Python function `heap_sort_inplace` that takes a list of integers and sorts it in-place in ascending order. ```python def heap_sort_inplace(collection): :param collection: list of integers :return: None (the list is sorted in-place) # Implement your in-place heap sort logic here pass # Helper functions (if any) go here ``` **Example**: ```python >>> arr = [3, 1, 4, 1, 5, 9, 2, 6] >>> heap_sort_inplace(arr) >>> print(arr) [1, 1, 2, 3, 4, 5, 6, 9] ``` **Note**: Do not use Python’s built-in sort functions or any other sort algorithm. Focus on the principles of the heap sort algorithm and ensure it is implemented in-place.","solution":"def heap_sort_inplace(collection): Sorts a list of integers in-place using heap sort algorithm. :param collection: list of integers :return: None def heapify(arr, n, i): Helper function to maintain the heap property. largest = i # Initialize largest as root left = 2 * i + 1 # left child right = 2 * i + 2 # right child # See if left child of root exists and is greater than root if left < n and arr[largest] < arr[left]: largest = left # See if right child of root exists and is greater than root if right < n and arr[largest] < arr[right]: largest = right # Change root, if needed if largest != i: arr[i], arr[largest] = arr[largest], arr[i] # swap # Heapify the root. heapify(arr, n, largest) n = len(collection) # Build a maxheap. for i in range(n // 2 - 1, -1, -1): heapify(collection, n, i) # One by one extract elements for i in range(n-1, 0, -1): collection[i], collection[0] = collection[0], collection[i] # swap heapify(collection, i, 0)"},{"question":"# Problem Statement You are given a list of integers representing the height of coins stacked on each other in a line. You can remove any number of coins from the top of a stack, but you cannot remove coins from more than one stack at a time in a single move. Write a function to determine the minimum number of moves required to make all stacks equal in height. # Function Signature ```python def min_moves_to_equal_heights(heights: list) -> int: ``` # Input - `heights` (list): A list of positive integers representing the heights of different stacks of coins. # Output - (int): The minimum number of moves required to make all stacks equal in height. # Constraints - (1 leq len(heights) leq 10^5) - (1 leq text{heights}[i] leq 10^9) # Requirements - Your solution should strive to be efficient in both time and space. # Example ```python assert min_moves_to_equal_heights([5, 3, 1]) == 4 # Convert heights to [1, 1, 1] assert min_moves_to_equal_heights([4, 4, 4, 4]) == 0 # All stacks are already equal assert min_moves_to_equal_heights([7, 5, 2, 5]) == 8 # Convert heights to [2, 2, 2, 2] ``` # Note You can assume that the input list `heights` will always contain positive integers within the given constraints.","solution":"def min_moves_to_equal_heights(heights): Determines the minimum number of moves required to make all stacks equal in height. :param heights: List of positive integers representing the heights of different stacks of coins. :return: Minimum number of moves required to make all stacks equal in height. min_height = min(heights) moves = sum(height - min_height for height in heights) return moves"},{"question":"# Problem Statement You need to implement a basic yet efficient data structure to simulate a stack with an additional functionality of retrieving the minimum element in constant time. Design and implement a class `MinStack` that supports the following operations: 1. `push(val: int)`: Pushes the integer `val` onto the stack. 2. `pop()`: Removes the top element from the stack. 3. `top() -> int`: Gets the top element of the stack. 4. `get_min() -> int`: Retrieves the minimum element in the stack. # Class Specifications Method 1: `__init__` - **Input**: None - **Output**: None Method 2: `push` - **Input**: An integer `val` to push onto the stack. - **Output**: None Method 3: `pop` - **Input**: None - **Output**: None Method 4: `top` - **Input**: None - **Output**: Returns the top element of the stack as an integer. Method 5: `get_min` - **Input**: None - **Output**: Returns the minimum element in the stack as an integer. # Constraints - All methods (except `__init__`) should be performed in constant time (O(1)). - The stack will not exceed a maximum length of 100,000 elements, and the values pushed will be within the range of `-10^9` to `10^9`. # Example ```python min_stack = MinStack() min_stack.push(-2) min_stack.push(0) min_stack.push(-3) print(min_stack.get_min()) # Expected output: -3 min_stack.pop() print(min_stack.top()) # Expected output: 0 print(min_stack.get_min()) # Expected output: -2 ``` # Notes - You need to handle edge cases such as popping from an empty stack or querying the minimum element when the stack is empty. - Ensure your implementation is optimized to manage stack and auxiliary data structures efficiently. - Both `push` and `pop` operations must maintain the integrity of the stack and the auxiliary structure that keeps track of the minimum element. ```python class MinStack: def __init__(self): self.stack = [] self.min_stack = [] def push(self, val: int) -> None: self.stack.append(val) if not self.min_stack or val <= self.min_stack[-1]: self.min_stack.append(val) def pop(self) -> None: if self.stack: if self.stack[-1] == self.min_stack[-1]: self.min_stack.pop() self.stack.pop() def top(self) -> int: if self.stack: return self.stack[-1] def get_min(self) -> int: if self.min_stack: return self.min_stack[-1] ```","solution":"class MinStack: def __init__(self): self.stack = [] self.min_stack = [] def push(self, val: int) -> None: self.stack.append(val) if not self.min_stack or val <= self.min_stack[-1]: self.min_stack.append(val) def pop(self) -> None: if self.stack: if self.stack[-1] == self.min_stack[-1]: self.min_stack.pop() self.stack.pop() def top(self) -> int: if self.stack: return self.stack[-1] def get_min(self) -> int: if self.min_stack: return self.min_stack[-1]"},{"question":"# Task Given a list of unique positive integers, write a Python function `lowest_positive_integer_not_in_list(lst: List[int]) -> int` to find the lowest positive integer that is not present in the list. # Function Signature ```python def lowest_positive_integer_not_in_list(lst: List[int]) -> int: pass ``` # Input * **lst**: A list of unique positive integers (1 ≤ |lst| ≤ 10,000, 1 ≤ lst[i] ≤ 100,000). # Output * Returns the smallest positive integer not present in the list. # Constraints * The function should efficiently handle lists up to the maximum size and range constraints. # Example Consider the list `lst = [1, 2, 3, 5, 7, 8]`. The smallest positive integer not in the list is 4. Therefore, the function should return 4. ```python >>> lowest_positive_integer_not_in_list([1, 2, 3, 5, 7, 8]) 4 ``` # Note Ensure the function efficiently handles large input sizes and utilizes appropriate data structures to optimize the solution. **Analysis Steps**: 1. Create a set of all positive integers up to the length of the list plus one (since the missing integer could be just beyond the largest list element). 2. Iterate through the integers and find the smallest one not present in the input list.","solution":"from typing import List def lowest_positive_integer_not_in_list(lst: List[int]) -> int: Returns the smallest positive integer that is not present in the list. # Create a set of all elements in lst for O(1) lookups elements_set = set(lst) # Check sequentially from 1 upwards to find the missing positive integer for i in range(1, len(lst) + 2): if i not in elements_set: return i"},{"question":"# Question You need to implement a function to determine the minimum edit distance between two strings. The edit distance is defined as the minimum number of operations required to convert one string into the other. The allowed operations are insertion, deletion, or substitution of a single character. Problem Statement Given two strings `word1` and `word2`, implement a function `min_edit_distance` that computes the minimum number of operations needed to convert `word1` into `word2`. Function Signature ```python def min_edit_distance(word1: str, word2: str) -> int: ``` Input - `word1` (str): A string of characters with length in the range [0, 500]. - `word2` (str): A string of characters with length in the range [0, 500]. Output - `int`: The minimum number of operations required to convert `word1` into `word2`. Constraints 1. The length of both strings is in the range [0, 500]. 2. Strings consist of lowercase English letters. Example ```python print(min_edit_distance(\\"horse\\", \\"ros\\")) # Output: 3 # Explanation: horse -> rorse (replace \'h\' with \'r\') # rorse -> rose (remove \'r\') # rose -> ros (remove \'e\') print(min_edit_distance(\\"intention\\", \\"execution\\")) # Output: 5 # Explanation: intention -> inention (remove \'t\') # inention -> enention (replace \'i\' with \'e\') # enention -> exention (replace \'n\' with \'x\') # exention -> exection (replace \'n\' with \'c\') # exection -> execution (insert \'u\') ``` Requirements - Implement the `min_edit_distance` function using dynamic programming to ensure efficiency. - Handle edge cases such as one or both strings being empty. - Ensure the function performs well with the maximum input size constraints.","solution":"def min_edit_distance(word1: str, word2: str) -> int: # Length of the two words m, n = len(word1), len(word2) # Initialize the DP table with dimensions (m+1) x (n+1) dp = [[0] * (n + 1) for _ in range(m + 1)] # Base cases: transforming from empty string to word2 and vice versa for i in range(1, m+1): dp[i][0] = i for j in range(1, n+1): dp[0][j] = j # Fill the DP table for i in range(1, m+1): for j in range(1, n+1): if word1[i-1] == word2[j-1]: dp[i][j] = dp[i-1][j-1] # No operation needed else: # Minimum of deleting from word1, inserting into word1, or replacing character dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 return dp[m][n]"},{"question":"# Context: You have been hired as a data analyst for a retail company. Your task is to analyze the sales data and implement a function that identifies the top-selling products within a specified time frame. Your function should be able to handle large volumes of sales data efficiently. # Problem Statement: Implement the function `top_selling_products` using the given skeleton code. The function should take as input a sales data frame along with the start and end dates for the analysis period and return the top N selling products. # Function Signature: ```python import pandas as pd def top_selling_products(sales_data: pd.DataFrame, start_date: str, end_date: str, N: int) -> pd.DataFrame: ``` # Input: * **sales_data**: A pandas DataFrame with columns [\'product_id\', \'product_name\', \'quantity_sold\', \'sale_date\']. - **product_id**: A unique identifier for each product (str). - **product_name**: The name of the product (str). - **quantity_sold**: The quantity of the product sold (int). - **sale_date**: The date of the sale in \'YYYY-MM-DD\' format (str). * **start_date**: A string specifying the start date of the analysis period in \'YYYY-MM-DD\' format. * **end_date**: A string specifying the end date of the analysis period in \'YYYY-MM-DD\' format. * **N**: An integer representing the number of top-selling products to return. # Output: * **top_products_df**: A pandas DataFrame with columns [\'product_id\', \'product_name\', \'total_quantity_sold\'] sorted by \'total_quantity_sold\' in descending order. It returns the top N selling products within the specified time frame. # Constraints: * Ensure the code handles large data efficiently. * Properly filter the data based on the specified date range. * Handle cases where the specified date range has no sales data by returning an empty DataFrame. # Example: ```python import pandas as pd # Sample sales data sales_data = pd.DataFrame({ \'product_id\': [\'p1\', \'p2\', \'p3\', \'p1\', \'p4\', \'p2\'], \'product_name\': [\'Product A\', \'Product B\', \'Product C\', \'Product A\', \'Product D\', \'Product B\'], \'quantity_sold\': [10, 5, 8, 7, 6, 3], \'sale_date\': [\'2023-01-01\', \'2023-01-02\', \'2023-01-02\', \'2023-01-03\', \'2023-01-03\', \'2023-01-04\'] }) # Parameters start_date = \'2023-01-01\' end_date = \'2023-01-03\' N = 2 # Identifying top-selling products top_products_df = top_selling_products(sales_data, start_date, end_date, N) # The output `top_products_df` should be a pandas DataFrame with the top N selling products print(top_products_df) ``` # Notes: 1. Ensure the date filtering is correctly implemented and handles edge cases, such as date formats or empty dataframes. 2. The function should efficiently aggregate and sort the sales data to find the top-selling products. 3. Make use of pandas functions for data manipulation to ensure optimal performance. # Evaluation Criteria: * **Correctness**: The function should correctly identify and return the top N selling products within the specified date range. * **Efficiency**: The implementation should be able to handle large datasets efficiently. * **Edge Handling**: The function should handle cases with no sales data or invalid date ranges gracefully. * **Code Quality**: The solution should be clean, readable, and properly documented.","solution":"import pandas as pd def top_selling_products(sales_data: pd.DataFrame, start_date: str, end_date: str, N: int) -> pd.DataFrame: Returns the top N selling products within the specified date range. Args: - sales_data (pd.DataFrame): DataFrame containing sales data with columns [\'product_id\', \'product_name\', \'quantity_sold\', \'sale_date\']. - start_date (str): Start date of the analysis period in \'YYYY-MM-DD\' format. - end_date (str): End date of the analysis period in \'YYYY-MM-DD\' format. - N (int): The number of top-selling products to return. Returns: - pd.DataFrame: DataFrame with columns [\'product_id\', \'product_name\', \'total_quantity_sold\'] sorted by \'total_quantity_sold\' in descending order. # Convert \'sale_date\' to datetime sales_data[\'sale_date\'] = pd.to_datetime(sales_data[\'sale_date\']) # Filter data based on the date range mask = (sales_data[\'sale_date\'] >= start_date) & (sales_data[\'sale_date\'] <= end_date) filtered_data = sales_data[mask] if filtered_data.empty: return pd.DataFrame(columns=[\'product_id\', \'product_name\', \'total_quantity_sold\']) # Group by \'product_id\' and \'product_name\', then sum \'quantity_sold\' top_products = ( filtered_data.groupby([\'product_id\', \'product_name\'])[\'quantity_sold\'] .sum() .reset_index() .rename(columns={\'quantity_sold\': \'total_quantity_sold\'}) .sort_values(by=\'total_quantity_sold\', ascending=False) .head(N) ) return top_products"},{"question":"# Coding Assessment Question Scenario As part of a security software development team, you are tasked with writing a function to encode messages using a custom encryption scheme. The scheme will shift each letter in the message by a given number of positions down the alphabet. Different from typical Caesar cipher implementations, this scheme will wrap around the alphabet and only encrypt alphabetical characters while preserving the original case of each letter. Function Specification **Function Name**: `custom_caesar_cipher` **Parameters**: - `message`: A string representing the message to be encoded. - `shift`: An integer representing the number of positions each letter in the message will be shifted. **Returns**: - A string representing the encrypted message. **Constraints**: - The `message` can contain letters (both uppercase and lowercase), spaces, and punctuation marks. Only alphabetical characters will be shifted. - The `shift` will be a non-negative integer. - The length of the `message` will not exceed 100 characters. Example ```python assert custom_caesar_cipher(\\"Hello, World!\\", 3) == \\"Khoor, Zruog!\\" assert custom_caesar_cipher(\\"abcdef\\", 1) == \\"bcdefg\\" assert custom_caesar_cipher(\\"ABC XYZ\\", 4) == \\"EFG BCD\\" assert custom_caesar_cipher(\\"\\", 5) == \\"\\" ``` Task 1. Write the function `custom_caesar_cipher(message, shift)` to encode the provided message using the described encryption scheme. 2. Ensure your implementation passes the provided example cases. 3. Consider edge cases and handle them appropriately within your function. 4. Focus on maintaining the case and non-alphabetical characters while only shifting the letters. Provide any additional notes or comments in your code to explain key steps or decisions in your implementation. --- ```python def custom_caesar_cipher(message, shift): def shift_char(c, shift): if \'a\' <= c <= \'z\': return chr(((ord(c) - ord(\'a\') + shift) % 26) + ord(\'a\')) elif \'A\' <= c <= \'Z\': return chr(((ord(c) - ord(\'A\') + shift) % 26) + ord(\'A\')) else: return c encrypted_message = \'\'.join(shift_char(c, shift) for c in message) return encrypted_message # Example usage and testing print(custom_caesar_cipher(\\"Hello, World!\\", 3)) # \\"Khoor, Zruog!\\" ``` This question requires a combination of string manipulation and understanding of character encoding in programming, which aligns well with the skill set tested by the existing questions.","solution":"def custom_caesar_cipher(message, shift): def shift_char(c, shift): if \'a\' <= c <= \'z\': return chr(((ord(c) - ord(\'a\') + shift) % 26) + ord(\'a\')) elif \'A\' <= c <= \'Z\': return chr(((ord(c) - ord(\'A\') + shift) % 26) + ord(\'A\')) else: return c encrypted_message = \'\'.join(shift_char(c, shift) for c in message) return encrypted_message"},{"question":"# Coding Assessment Question Context: Sorting algorithms are fundamental in computer science and are frequently used in tasks like data organization, searching, and database indexing. It is common to evaluate the time complexity and efficiency of different sorting techniques through practical implementation. Problem Statement: Given an unsorted list of integers, implement a simplified version of the Merge Sort algorithm without recursion. Your goal is to sort the list in ascending order using an iterative approach. Guidelines: 1. Implement a function to perform the merge sort iteratively. 2. Use a bottom-up approach to merge sorted sublists, starting with sublists of size 1 and progressively doubling the size. 3. Write a function `iterative_merge_sort(arr: List[int]) -> List[int]` which sorts the input list in ascending order and returns the sorted list. Input Format: - A list of integers ( arr ). Output Format: - A list of integers representing the sorted ( arr ) in ascending order. Example: Input: ```python arr = [38, 27, 43, 3, 9, 82, 10] ``` Output: ```python [3, 9, 10, 27, 38, 43, 82] ``` Constraints: - The list can contain up to 100,000 integer elements. - Elements of the list are in the range of -10^6 to 10^6. Function Signature: ```python from typing import List def iterative_merge_sort(arr: List[int]) -> List[int]: pass ``` Performance Requirements: - The solution should efficiently handle large lists within a reasonable time frame. - Ensure that the solution works within the given constraints and performs the sort in ( O(n log n) ) time complexity, where ( n ) is the number of elements in the input list.","solution":"from typing import List def iterative_merge_sort(arr: List[int]) -> List[int]: width = 1 n = len(arr) while width < n: for i in range(0, n, 2 * width): left = arr[i:i + width] right = arr[i + width:i + 2 * width] merged = _merge(left, right) arr[i:i + 2 * width] = merged width *= 2 return arr def _merge(left: List[int], right: List[int]) -> List[int]: result = [] i = j = 0 while i < len(left) and j < len(right): if left[i] <= right[j]: result.append(left[i]) i += 1 else: result.append(right[j]) j += 1 result.extend(left[i:]) result.extend(right[j:]) return result"},{"question":"# Water Jug Problem Given two water jugs of different capacities, design a function that determines if it\'s possible to measure exactly a target amount of water using the two jugs. You are given two integers representing the capacities of each jug and a target amount of water to measure. The operations you can perform are: 1. Fill either jug fully. 2. Empty either jug completely. 3. Pour water from one jug to the other until one of the jugs is either full or empty. Write a function `can_measure_water` that returns `True` if it is possible to measure the exact target amount using the provided jugs, or `False` otherwise. # Function Signature: ```python def can_measure_water(jug1_capacity: int, jug2_capacity: int, target: int) -> bool: ``` # Inputs: - `jug1_capacity` (`int`): Capacity of the first jug. - `jug2_capacity` (`int`): Capacity of the second jug. - `target` (`int`): The target amount to measure. # Output: - `bool`: `True` if it is possible to measure the target amount, `False` otherwise. # Constraints: - `jug1_capacity`, `jug2_capacity`, and `target` are non-negative integers, no greater than `2^31 - 1`. - If both jugs are of capacity zero, the target must also be zero for the function to return `True`. # Example Usage: ```python print(can_measure_water(3, 5, 4)) # Expected output: True print(can_measure_water(2, 6, 5)) # Expected output: False ``` # Notes: 1. Take into account constraints posed by the jug capacities and the operations allowed. 2. To determine if the target amount can be measured, one possible approach is to use Bézout\'s identity related to the greatest common divisor (GCD) of the capacities. Specifically, it is possible to measure the target amount if and only if the target is a multiple of the GCD of the two jug capacities and the target does not exceed the sum of the capacities. Implement the `can_measure_water` function ensuring to handle edge cases and optimize for performance given the constraints.","solution":"def can_measure_water(jug1_capacity: int, jug2_capacity: int, target: int) -> bool: Determine if it is possible to measure exactly the target amount of water using the two jugs. def gcd(a, b): while b != 0: a, b = b, a % b return a if target > jug1_capacity + jug2_capacity: return False if target == 0: return True gcd_value = gcd(jug1_capacity, jug2_capacity) return target % gcd_value == 0"},{"question":"# Question: Optimized File Download with Chunking You are tasked with improving the file download functionality in a Python application that retrieves large files from the internet. Your goal is to enhance performance by implementing chunked downloads and adding retries for network resilience. **Task** 1. Modify the `download_file` function to download the file in smaller chunks. 2. Add a retry mechanism to handle transient network errors. 3. Implement logging to record the progress of the download and any errors encountered. 4. Ensure the function supports pausing and resuming downloads without restarting from the beginning. # Requirements **Function Signature** ```python import requests # You may use this library for HTTP requests import logging # You may use this library for logging CHUNK_SIZE = 1024 # Size of each chunk (in bytes) RETRIES = 3 # Number of retry attempts for network errors def download_file(url: str, destination: str) -> None: pass # Your implementation here ``` **Input** - `url` (str): The URL of the file to be downloaded. - `destination` (str): The local file path where the downloaded file should be saved. **Output** - No return value. The function should save the file to the specified destination. **Constraints** - The function should handle downloading files of significant size (e.g., several gigabytes) efficiently. - Use chunked downloading to handle large files. - Implement a retry mechanism with exponential backoff for handling network errors. - Ensure that the function can resume interrupted downloads. # Example ```python # Assuming your function implementation is complete try: download_file(\\"https://example.com/largefile.zip\\", \\"/path/to/save/largefile.zip\\") print(\\"Download completed successfully.\\") except Exception as e: print(f\\"Error: {e}\\") ``` # Note - Use appropriate logging to record download progress and handle errors. - Ensure the retry mechanism only retries for network-related errors (e.g., connection timeouts). - Implement the download resumption by checking how much of the file has already been downloaded and continuing from that point.","solution":"import requests import logging import os import time logging.basicConfig(level=logging.INFO) CHUNK_SIZE = 1024 # Size of each chunk (in bytes) RETRIES = 3 # Number of retry attempts for network errors def download_file(url: str, destination: str) -> None: session = requests.Session() headers = {} # Check if there is a partial download if os.path.exists(destination): downloaded_size = os.path.getsize(destination) headers[\'Range\'] = f\'bytes={downloaded_size}-\' else: downloaded_size = 0 try: response = session.get(url, headers=headers, stream=True) response.raise_for_status() # Will throw an error for bad status codes with open(destination, \'ab\') as f: for chunk in response.iter_content(CHUNK_SIZE): if chunk: f.write(chunk) f.flush() downloaded_size += len(chunk) logging.info(f\\"Download progress: {downloaded_size} bytes\\") except requests.RequestException as e: logging.error(\\"Download failed due to a network error: %s\\", e) for retry in range(RETRIES): logging.info(\\"Retry attempt %d/%d\\", retry + 1, RETRIES) try: time.sleep(2 ** retry) # Exponential backoff response = session.get(url, headers=headers, stream=True) response.raise_for_status() with open(destination, \'ab\') as f: for chunk in response.iter_content(CHUNK_SIZE): if chunk: f.write(chunk) f.flush() downloaded_size += len(chunk) logging.info(f\\"Download progress: {downloaded_size} bytes\\") break # Exit retry loop if download is successful except requests.RequestException as e: logging.error(\\"Retry failed due to a network error: %s\\", e) if retry == RETRIES - 1: logging.critical(\\"All retries failed. Download aborted.\\") raise"},{"question":"# Pascal\'s Triangle Generation Objective Create a function that generates Pascal\'s Triangle up to a given number of rows. Task 1. Implement the function to build Pascal\'s Triangle with a specified number of rows. 2. Handle edge cases such as zero or a negative number of rows. 3. Ensure that the function works efficiently for larger number of rows. Instructions - Implement the function `generate_pascals_triangle(num_rows: int) -> list`. - Your function must return a list of lists, representing Pascal\'s Triangle up to the given number of rows. - The first row is considered as row 0 and should be [1]. Example ```python def generate_pascals_triangle(num_rows: int) -> list: # Your implementation here pass # Example Usage print(generate_pascals_triangle(5)) # Output: [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]] print(generate_pascals_triangle(1)) # Output: [[1]] print(generate_pascals_triangle(0)) # Output: [] print(generate_pascals_triangle(-1)) # Output: [] ``` Constraints - The number of rows will be an integer where (0 leq num_rows leq 1000).","solution":"def generate_pascals_triangle(num_rows: int) -> list: Generates Pascal\'s Triangle up to a given number of rows. Args: num_rows (int): Number of rows for the Pascal\'s Triangle. Returns: list: Pascal\'s Triangle up to the given number of rows. if num_rows <= 0: return [] triangle = [[1]] for i in range(1, num_rows): row = [1] prev_row = triangle[i - 1] for j in range(1, i): row.append(prev_row[j - 1] + prev_row[j]) row.append(1) triangle.append(row) return triangle"},{"question":"# Problem Statement You are tasked with implementing a function that finds all permutations of a given list of unique integers. Your function should utilize recursion to generate the permutations. # Function Signature ```python def generate_permutations(nums: list[int]) -> list[list[int]]: pass ``` # Input * `nums` (list of integers): A list of unique integers. The length of this list can range from 0 to 9, inclusive. # Output * Returns a list of lists, where each inner list is a permutation of the input list `nums`. # Constraints * The input list `nums` will contain only unique integers. * You must handle the case where `nums` is an empty list, returning a list containing an empty list `[[]]`. # Requirements * Your solution should have a time complexity of ( O(n!) ), where ( n ) is the length of the input list `nums`. * Make sure your function is efficient in terms of memory usage and running time. # Example ```python generate_permutations([1, 2, 3]) # Expected output: # [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]] generate_permutations([1]) # Expected output: # [[1]] generate_permutations([]) # Expected output: # [[]] ``` # Notes * Ensure your solution handles all edge cases effectively. * Avoid using the `itertools.permutations` function for this task. Instead, implement the permutation generation recursively. * Focus on writing clean, modular, and efficient code.","solution":"def generate_permutations(nums): Generates all permutations of the list of unique integers provided. :param nums: List of unique integers. :return: List of lists, where each inner list is a permutation of the input list `nums`. # Base case: if nums is empty, return a list containing an empty list if len(nums) == 0: return [[]] permutations = [] # to store all permutations for i in range(len(nums)): # Choose the element at the current index current_num = nums[i] # Remaining list after removing the chosen element remaining_nums = nums[:i] + nums[i+1:] # Generate all permutations of the remaining list for perm in generate_permutations(remaining_nums): # Append the current element to the beginning of each permutation of the remaining list permutations.append([current_num] + perm) return permutations"},{"question":"# Question Design a function that generates prime numbers up to a specified integer, `n`, and another function to compute their product. Requirements - Implement the function `generate_primes(n: int) -> list[int]`: * This function should return a list of all prime numbers less than or equal to `n`. * If `n` is less than 2, return an empty list. * If the input is not an integer, raise a `ValueError`. - Implement the function `product_of_primes(n: int) -> int`: * This function should return the product of all prime numbers less than or equal to `n`. * If `n` is less than 2, return `1`. * If the result is too large to be computed, it should return `-1`. * If the input is not an integer, raise a `ValueError`. Input Format * `n`: A positive integer. Output Format * `generate_primes`: Return a list of integers that are prime numbers up to `n`. * `product_of_primes`: Return an integer that is the product of prime numbers up to `n`, or `-1` if the product is too large. # Examples ```python >>> generate_primes(10) [2, 3, 5, 7] >>> generate_primes(20) [2, 3, 5, 7, 11, 13, 17, 19] >>> generate_primes(1) [] >>> generate_primes(2) [2] >>> product_of_primes(10) 210 >>> product_of_primes(20) 9699690 >>> product_of_primes(1) 1 >>> product_of_primes(2) 2 ``` Constraints * The input `n` must be a positive integer. * The functions must handle erroneous inputs gracefully by raising `ValueError` with appropriate messages. * Define the threshold for when the product is considered too large as it may vary depending on the implementation and system capabilities; a good threshold is when the product exceeds `2^63 - 1`. Additional Information Prime number generation is useful for mathematical computations where prime factorization and other number-theoretic algorithms are involved. Calculating the product of primes is often useful in cryptographic applications and requires careful handling due to potential overflow issues.","solution":"def generate_primes(n: int) -> list[int]: Generates a list of prime numbers less than or equal to n. if not isinstance(n, int): raise ValueError(\\"The input must be an integer.\\") if n < 2: return [] sieve = [True] * (n + 1) sieve[0:2] = [False, False] # 0 and 1 are not primes for start in range(2, int(n**0.5) + 1): if sieve[start]: for multiple in range(start * start, n + 1, start): sieve[multiple] = False primes = [num for num in range(n + 1) if sieve[num]] return primes def product_of_primes(n: int) -> int: Computes the product of all prime numbers less than or equal to n. Returns -1 if the product is too large. if not isinstance(n, int): raise ValueError(\\"The input must be an integer.\\") if n < 2: return 1 primes = generate_primes(n) product = 1 threshold = 2**63 - 1 for prime in primes: product *= prime if product > threshold: return -1 return product"},{"question":"# Scenario You\'re tasked with implementing a simple text editor feature that capitalizes the first letter of each word in a given string. Your function should ensure that the rest of the characters in each word are lowercase, and punctuation or special characters should not affect the capitalization. # Task Implement the function `capitalize_words(text: str) -> str` that takes a string input and returns a new string where the first letter of each word is capitalized, and the other letters are in lowercase. # Function Signature ```python def capitalize_words(text: str) -> str: pass ``` # Input: * `text` (str): A string containing one or more words. Words are delimited by space, and may include punctuation marks. # Output: * Returns a string with each word\'s first letter capitalized and the remaining characters in lowercase. # Constraints: * The input string can contain letters, numbers, punctuation marks, and whitespace. * Words are separated by one or more spaces. # Examples: 1. Input: `text = \\"hello world\\"` Output: `\\"Hello World\\"` 2. Input: `text = \\"tHis Is a TeSt!\\"` Output: `\\"This Is A Test!\\"` 3. Input: `text = \\"PYTHON programming\\"` Output: `\\"Python Programming\\"` # Note: The function should handle multiple spaces between words and punctuation correctly, ensuring consistent capitalization of the first letter of each word while converting other letters to lowercase. Ensure the function is efficient for processing longer texts.","solution":"def capitalize_words(text: str) -> str: Returns the input string with the first letter of each word capitalized and the rest of the letters in lowercase. # Split the text into words based on space words = text.split() # Capitalize the first letter of each word and make other letters lowercase capitalized_words = [word.capitalize() for word in words] # Join the words back with a single space return \' \'.join(capitalized_words)"},{"question":"# Problem Statement Context: You are tasked with analyzing the lexicographical order of permutations of a list of characters. This involves generating and sorting all permutations and returning the k-th permutation in the sorted order. Problem: Your task is to write a function that, given a list of characters and an integer k, returns the k-th permutation of the list in lexicographical order. Function Signature: ```python def find_kth_permutation(character_list: List[str], k: int) -> str: pass ``` # Input: 1. `character_list` (List[str]): A list of distinct characters. 2. `k` (int): The 1-based index of the permutation to return. # Output: * Return a string representing the k-th permutation of the input list in lexicographical order. # Constraints: - The character list will have at least 1 and at most 9 characters. - Characters will be unique and can include lowercase, uppercase, and digits. - `k` will be a valid 1-based index within the total number of permutations (i.e., 1 ≤ k ≤ n!, where n is the length of the character list). # Examples: ```python >>> find_kth_permutation([\'a\', \'b\', \'c\'], 3) # Expected output: \'bac\' >>> find_kth_permutation([\'1\', \'2\', \'3\'], 5) # Expected output: \'312\' ``` # Notes: - Ensure the program efficiently handles generation and sorting of permutations. - Avoid generating all permutations explicitly if possible; consider approaches that find the k-th permutation directly. - Your solution should handle edge cases where k = 1 and k = n!. # Approach: - Consider using factorial number system or choose-based approach to directly fetch the k-th permutation. - Ensure your function handles invalid inputs by either raising an appropriate exception or returning a specific error message.","solution":"from itertools import permutations from typing import List def find_kth_permutation(character_list: List[str], k: int) -> str: Returns the k-th permutation of the character_list in lexicographical order. char_list_sorted = sorted(character_list) all_permutations = list(permutations(char_list_sorted)) kth_permutation = all_permutations[k-1] return \'\'.join(kth_permutation)"},{"question":"# Coding Assessment Question Context: You are tasked with implementing a sorting algorithm that not only sorts an array of integers but also maintains the relative order of the elements that have the same value in the original array. Problem Statement: Write a function `stable_sort` that takes an array of integers and sorts it in non-decreasing order while preserving the stability of the sorting (i.e., equal values should appear in the same order as they did in the input). ```python def stable_sort(arr: List[int]) -> List[int]: Sorts the array in non-decreasing order while maintaining the relative order of equal elements. pass ``` Input: - `arr`: A list of integers, where 1 ≤ len(arr) ≤ 10000 and the elements of the array are between -10000 and 10000. Output: - Return a list of integers sorted in non-decreasing order with stable sorting. Constraints: - The elements are integers in the range -10000 ≤ element ≤ 10000. - The length of the list is at most 10000. Performance Requirements: - The function should run in O(n log n) time complexity. Examples: 1. `stable_sort([3, 1, 2, 2, 3])` should return `[1, 2, 2, 3, 3]`. 2. `stable_sort([4, -1, 0, 4, 2])` should return `[-1, 0, 2, 4, 4]`. Notes: - You can use stable sorting algorithms like merge sort or Timsort (which is the default sorting algorithm in Python\'s built-in sorted() function). - Make sure that the implementation preserves the relative order of elements that are equal.","solution":"from typing import List def stable_sort(arr: List[int]) -> List[int]: Sorts the array in non-decreasing order while maintaining the relative order of equal elements. return sorted(arr)"},{"question":"# Problem Statement: You have been given a function that checks if a number is prime. Your task is to implement a new function named `prime_indices_in_list(arr: List[int]) -> List[int]` that identifies the indices of prime numbers in the provided list. # Requirements: 1. Treat the input list as zero-indexed. 2. If no prime numbers are found in the list, return an empty list. 3. Ensure the function handles all edge cases appropriately, such as empty lists or lists with only one element. # Function Signature: ```python def prime_indices_in_list(arr: List[int]) -> List[int]: pass ``` # Input Format: * `arr`: A list of integers. # Output Format: * A list of integers representing the indices of prime numbers in the given list. # Example: ```python # Example 1 arr = [2, 3, 4, 5, 6] # Prime indices: [0, 1, 3] print(prime_indices_in_list(arr)) # Example 2 arr = [8, 10, 12, 15, 20] # Prime indices: [] print(prime_indices_in_list(arr)) # Example 3 arr = [17, 19, 23, 29, 31] # Prime indices: [0, 1, 2, 3, 4] print(prime_indices_in_list(arr)) ``` # Constraints: * The elements of `arr` can be any integer within the range of 32-bit signed integers. * The length of `arr` can be between 0 and (10^6).","solution":"from typing import List def is_prime(n: int) -> bool: Helper function to check if a number is a prime. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def prime_indices_in_list(arr: List[int]) -> List[int]: Returns a list of indices where the elements of the list are prime numbers. return [index for index, value in enumerate(arr) if is_prime(value)]"},{"question":"# Task Write a function that converts a given non-negative integer to its binary string representation without using built-in functions for binary conversion. # Requirements 1. The input will be a non-negative integer. 2. Your function should return a string that represents the binary equivalent of the given integer. 3. If the integer is 0, the function should return `\\"0\\"`. 4. Use an iterative approach to generate the binary string. # Function Signature ```python def integer_to_binary_string(num: int) -> str: Converts a non-negative integer to its binary string representation. Args: num: A non-negative integer. Returns: A string representing the binary equivalent of num. Example: >>> integer_to_binary_string(0) \'0\' >>> integer_to_binary_string(5) \'101\' >>> integer_to_binary_string(10) \'1010\' >>> integer_to_binary_string(255) \'11111111\' >>> integer_to_binary_string(1024) \'10000000000\' pass ```","solution":"def integer_to_binary_string(num: int) -> str: Converts a non-negative integer to its binary string representation. Args: num: A non-negative integer. Returns: A string representing the binary equivalent of num. if num == 0: return \\"0\\" binary_str = \\"\\" while num > 0: binary_str = str(num % 2) + binary_str num //= 2 return binary_str"},{"question":"# Coding Assessment Question Problem Statement **Context**: Alex is an avid user of social media and often analyses patterns in the data streams from various platforms. One day he got curious about the frequency of certain events and wanted to perform some analysis on a list of timestamps. Alex wants to write a program to determine how many events there are in given time ranges. **Task**: Implement a function `count_events(timestamps: List[int], queries: List[Tuple[int, int]]) -> List[int]` that determines the number of events that occurred within the provided time ranges. **Function Signature**: ```python def count_events(timestamps: List[int], queries: List[Tuple[int, int]]) -> List[int]: ``` **Parameters**: - `timestamps` (List[int]): A list of integers representing the times at which events occurred, sorted in ascending order. - `queries` (List[Tuple[int, int]]): A list of tuples, each containing two integers where the first integer is the start time and the second integer is the end time of the range. **Returns**: - List[int]: A list of integers where each integer represents the count of events that occurred within the corresponding time range specified in `queries`. **Examples**: ```python assert count_events([1, 2, 2, 3, 5, 7, 10], [(2, 3), (1, 5), (4, 10), (8, 10)]) == [3, 5, 3, 1] assert count_events([1, 1, 2, 4, 5, 6, 7], [(1, 1), (2, 4), (3, 7), (7, 7)]) == [2, 2, 4, 1] assert count_events([], [(1, 10), (5, 15)]) == [0, 0] assert count_events([3, 6, 9], [(1, 2), (10, 20), (3, 9)]) == [0, 0, 3] ``` **Notes**: * The list of timestamps is guaranteed to be sorted in non-decreasing order. * Ensure the function can handle the edge cases where there are no events or the time ranges do not overlap with any events. * Performance is key; aim for efficient algorithms that handle large inputs efficiently. **Constraints**: * `0 <= len(timestamps) <= 10^5` * `1 <= len(queries) <= 10^4` * `-10^9 <= timestamps[i] <= 10^9` * `-10^9 <= start, end <= 10^9` **Scenario**: Alex is working on a comprehensive analysis project that will give valuable insights into event frequencies in given ranges. Help him by writing this efficient function.","solution":"from typing import List, Tuple import bisect def count_events(timestamps: List[int], queries: List[Tuple[int, int]]) -> List[int]: Determines the number of events that occurred within the provided time ranges. Parameters: timestamps (List[int]): Sorted list of event timestamps. queries (List[Tuple[int, int]]): List of (start, end) time ranges. Returns: List[int]: Number of events in each of the provided ranges. counts = [] for start, end in queries: # Find the leftmost index where start could be inserted to maintain sorted order left_index = bisect.bisect_left(timestamps, start) # Find the rightmost index where end could be inserted to maintain sorted order right_index = bisect.bisect_right(timestamps, end) # Count of events in the range is the difference between found indices counts.append(right_index - left_index) return counts"},{"question":"# Question Design and implement a function `multiply_large_numbers(a: str, b: str) -> str` that multiplies two non-negative integers represented as strings and returns the result as a string. The function must handle the multiplication without converting the strings to integers directly, simulating manual multiplication. # Specifications - The input `a` and `b` are strings consisting of numeric characters (\'0\'-\'9\'). - The input values won\'t have leading zeros unless they are \\"0\\". - The implementation should handle large numbers that may exceed the maximum value supported by native integer types in Python. - Do not use any built-in functions provided by Python or any libraries to perform arithmetic operations directly on the entire numbers. # Constraints - 1 <= len(a), len(b) <= 200 - The result will fit within a 400-character string. # Input and Output Formats Input - `a`: str - a string representing a non-negative integer (e.g., \\"123456789\\"). - `b`: str - a string representing a non-negative integer (e.g., \\"987654321\\"). Output - Returns a string representing the product of `a` and `b`. # Sample Input and Output Example 1 **Input**: ```python a = \\"123\\" b = \\"456\\" ``` **Output**: ```python \\"56088\\" ``` Example 2 **Input**: ```python a = \\"999\\" b = \\"999\\" ``` **Output**: ```python \\"998001\\" ``` # Implementation Notes - Consider simulating the long multiplication process, typically taught in elementary arithmetic classes. - Utilize arrays or lists to store intermediate results of the multiplication and handling the carry-over manually. - Follow a systematic approach to store partial results and combine them to produce the final product. # Skeleton Code ```python def multiply_large_numbers(a: str, b: str) -> str: Multiplies two non-negative integers represented as strings without directly converting them to integers. Arguments: a (str): The first non-negative integer string. b (str): The second non-negative integer string. Returns: str: The product of the two numbers as a string. # Handles special cases if a == \\"0\\" or b == \\"0\\": return \\"0\\" # Initialize an array to store the results of the multiplication result = [0] * (len(a) + len(b)) # Perform manual multiplication for i in range(len(a) - 1, -1, -1): for j in range(len(b) - 1, -1, -1): mul = int(a[i]) * int(b[j]) sum_ = mul + result[i + j + 1] result[i + j + 1] = sum_ % 10 result[i + j] += sum_ // 10 # Convert the result array back to a string result_str = \'\'.join(map(str, result)) # Remove leading zeros if present return result_str.lstrip(\'0\') # Test cases print(multiply_large_numbers(\\"123\\", \\"456\\")) # Should return \\"56088\\" print(multiply_large_numbers(\\"999\\", \\"999\\")) # Should return \\"998001\\" ```","solution":"def multiply_large_numbers(a: str, b: str) -> str: Multiplies two non-negative integers represented as strings without directly converting them to integers. Arguments: a (str): The first non-negative integer string. b (str): The second non-negative integer string. Returns: str: The product of the two numbers as a string. # Handle special case where any of the numbers is \'0\' if a == \\"0\\" or b == \\"0\\": return \\"0\\" # Result can be at most len(a) + len(b) digits result = [0] * (len(a) + len(b)) # Reverse both strings to facilitate the multiplication a = a[::-1] b = b[::-1] # Perform multiplication for i in range(len(a)): for j in range(len(b)): # Multiply and add to the correct position in the result array result[i + j] += int(a[i]) * int(b[j]) result[i + j + 1] += result[i + j] // 10 result[i + j] %= 10 # Convert the result array back to a string and strip any leading zeros result_str = \'\'.join(map(str, result[::-1])).lstrip(\'0\') return result_str"},{"question":"# Coding Assessment Question Context You are given a list of strings and your task is to determine the most common word among them using a dictionary for counting occurrences. Problem Statement Given a list of lowercase strings `words`, find and return the most common word. If there is a tie, return the word that comes first lexicographically. Write a function `most_common_word` that implements this logic. Function Signature ```python def most_common_word(words: List[str]) -> str: Returns the most common word in the list \'words\'. If there is a tie, the word that comes first lexicographically is returned. Args: words : List[str] : a list of lowercase words (1 ≤ len(words) ≤ 10^5, 1 ≤ len(words[i]) ≤ 10) Returns: str: The most common word, or the lexicographically smallest word in case of a tie. pass ``` Constraints - Each word in the input list `words` will be a string consisting of only lowercase English letters. - The function should handle up to ( 10^5 ) strings efficiently. Examples ```python # Example 1 print(most_common_word([\\"apple\\", \\"banana\\", \\"apple\\", \\"orange\\", \\"banana\\", \\"apple\\"])) # Output: \\"apple\\" # Example 2 print(most_common_word([\\"cat\\", \\"dog\\", \\"cat\\", \\"bird\\", \\"dog\\", \\"dog\\"])) # Output: \\"dog\\" # Example 3 print(most_common_word([\\"a\\", \\"b\\", \\"b\\", \\"a\\", \\"a\\"])) # Output: \\"a\\" # Example 4 print(most_common_word([\\"zoo\\", \\"zeus\\", \\"alpha\\", \\"beta\\", \\"gamma\\", \\"alpha\\"])) # Output: \\"alpha\\" ``` **Note**: Ensure to use a dictionary or other appropriate data structure to efficiently count word occurrences and determine the result.","solution":"from typing import List from collections import defaultdict def most_common_word(words: List[str]) -> str: Returns the most common word in the list \'words\'. If there is a tie, the word that comes first lexicographically is returned. Args: words : List[str] : a list of lowercase words (1 ≤ len(words) ≤ 10^5, 1 ≤ len(words[i]) ≤ 10) Returns: str: The most common word, or the lexicographically smallest word in case of a tie. word_count = defaultdict(int) # Count occurrences of each word for word in words: word_count[word] += 1 # Find the most common word most_common = None max_count = 0 for word, count in word_count.items(): if count > max_count or (count == max_count and word < most_common): most_common = word max_count = count return most_common"},{"question":"# Coding Assessment Question **Problem Statement**: Given a list of strings, return a list of the longest common prefixes for sequential pairs of strings in the input list. If no common prefix exists between two strings, return an empty string for that pair. **Function Signature**: ```python def longest_common_prefix_pairs(strings: List[str]) -> List[str]: pass ``` **Description**: - Write a function `longest_common_prefix_pairs` that computes the longest common prefix for every two consecutive strings in the given list. **Input**: - A list of strings `strings` where `1 ≤ len(strings) ≤ 100` and each string has length `1 ≤ len(string) ≤ 1000`. **Output**: - A list of strings where each element is the longest common prefix of two consecutive strings in the input list. **Constraints**: - The function should handle lists where strings might have different lengths and characters. - Aim for efficient comparison to find the longest common prefix. **Performance Requirements**: - The solution should be able to handle the upper constraint limits efficiently. - Consider both time and space complexity during implementation. **Example**: ```python assert longest_common_prefix_pairs([\\"apple\\", \\"apricot\\", \\"banana\\", \\"bandana\\", \\"cherry\\"]) == [\\"ap\\", \\"\\", \\"ban\\", \\"\\"] assert longest_common_prefix_pairs([\\"hello\\", \\"helium\\", \\"hero\\", \\"herald\\"]) == [\\"hel\\", \\"he\\", \\"her\\"] assert longest_common_prefix_pairs([\\"abc\\", \\"abcd\\", \\"abcde\\"]) == [\\"abc\\", \\"abcd\\"] ``` **Explanation**: For the input list `[\\"apple\\", \\"apricot\\", \\"banana\\", \\"bandana\\", \\"cherry\\"]`, the longest common prefixes are: - Between \\"apple\\" and \\"apricot\\": \\"ap\\" - Between \\"apricot\\" and \\"banana\\": no common prefix, thus \\"\\" - Between \\"banana\\" and \\"bandana\\": \\"ban\\" - Between \\"bandana\\" and \\"cherry\\": no common prefix, thus \\"\\" **Edge Cases to Consider**: - Ensure the function handles lists with a single string, returning an empty list. - Consider strings with no common prefix at all. - Ensure efficient handling of large strings nearing the input length constraints.","solution":"from typing import List def longest_common_prefix_pairs(strings: List[str]) -> List[str]: def common_prefix(str1, str2): min_len = min(len(str1), len(str2)) for i in range(min_len): if str1[i] != str2[i]: return str1[:i] return str1[:min_len] result = [] for i in range(len(strings) - 1): result.append(common_prefix(strings[i], strings[i + 1])) return result"},{"question":"**Program Execution Time Measurement** You are tasked with measuring and reporting the execution time of a given Python function. The function to be measured will be a simple, predefined computational task, such as calculating factorials of a series of numbers. 1. **Define the Task Function**: Your task function, named `compute_factorials`, takes a list of integers and returns a list of their factorials. 2. **Measure Execution Time**: Your second task function, named `measure_execution_time`, takes the `compute_factorials` function and a list of integers, returns the output of the factorial computation as well as the time taken to execute the function. # Input: - A list of integers for which the factorials should be computed. - The length of the list can be up to 10,000 integers, each integer can be between 0 and 100. # Output: - A tuple where the first element is the list of computed factorials, and the second element is a float representing the execution time in seconds. # Function Signatures: ```python def compute_factorials(numbers: list) -> list: pass def measure_execution_time(func: callable, numbers: list) -> tuple: pass ``` # Example: ```python numbers = [5, 10, 15] factorials, exec_time = measure_execution_time(compute_factorials, numbers) print(f\\"Factorials: {factorials}\\") # Output: [120, 3628800, 1307674368000] print(f\\"Execution Time: {exec_time:.6f} seconds\\") ``` # Constraints: - The input list may contain up to 10,000 integers. - Each integer in the list will be between 0 and 100 (inclusive). # Performance Requirements: - The `compute_factorials` function should efficiently compute factorials to handle the upper constraint limits effectively. - The `measure_execution_time` function should accurately measure the execution time using Python\'s `time` module or similar. **Hints**: - Utilize Python’s `time` module to measure the execution time. - Consider the efficiency of the factorial computation, possibly leveraging memoization techniques.","solution":"import math import time from typing import List, Callable, Tuple def compute_factorials(numbers: List[int]) -> List[int]: Computes the factorial of each number in the provided list. :param numbers: List of integers whose factorials need to be computed. :return: List of factorials corresponding to the input list. return [math.factorial(num) for num in numbers] def measure_execution_time(func: Callable[[List[int]], List[int]], numbers: List[int]) -> Tuple[List[int], float]: Measures the execution time of the provided function when applied to the input list. :param func: The function to measure. :param numbers: The list of integers to be passed to the function. :return: A tuple where the first element is the output of the function and the second element is the execution time. start_time = time.time() result = func(numbers) end_time = time.time() execution_time = end_time - start_time return result, execution_time"},{"question":"# Merge Sorted Arrays **Context**: Imagine you are working on a data integration project at a tech company. Part of your task involves merging multiple sorted datasets from different sources into a single sorted list. **Objective**: Write a function that takes a list of k sorted arrays and merges them into a single sorted array. The function should be efficient, taking advantage of the fact that the input arrays are already sorted. **Function Signature**: ```python def merge_sorted_arrays(arrays: List[List[int]]) -> List[int]: pass ``` **Input**: * `arrays`: A list of k sorted arrays. Each individual array is sorted in ascending order. **Output**: * A single sorted array containing all the elements from the input arrays in ascending order. **Constraints**: * Each sorted array contains at most `n` elements, where `n` is the number of elements in the largest array. * `1 <= k <= 1000` - the number of sorted arrays. * `0 <= number of elements in any array <= 1000`. * The value of elements is an integer in the range `[-10^9, 10^9]`. **Example**: ```python arrays = [ [1, 4, 5], [1, 3, 4], [2, 6] ] result = merge_sorted_arrays(arrays) assert result == [1, 1, 2, 3, 4, 4, 5, 6] ``` **Additional Notes**: * Consider performance optimizations to efficiently merge the sorted arrays. * Make use of existing algorithms or data structures that are optimal for merging sorted lists.","solution":"from typing import List import heapq def merge_sorted_arrays(arrays: List[List[int]]) -> List[int]: Merges k sorted arrays into a single sorted array. :param arrays: A list of k sorted arrays. Each individual array is sorted in ascending order. :return: A single sorted array containing all the elements from the input arrays in ascending order. merged_array = [] heap = [] # Initialize the min heap with the first element from each array for i, array in enumerate(arrays): if array: heapq.heappush(heap, (array[0], i, 0)) # (value, array_index, element_index) while heap: value, array_index, element_index = heapq.heappop(heap) merged_array.append(value) # If there is a next element in the same array, push it to the heap if element_index + 1 < len(arrays[array_index]): next_value = arrays[array_index][element_index + 1] heapq.heappush(heap, (next_value, array_index, element_index + 1)) return merged_array"},{"question":"# Dog Age Conversion **Problem Statement:** Write a function `convert_dog_age` that converts a dog\'s age from human years to dog years. The conversion factor varies depending on the dog\'s age. The first two human years each count as 10.5 dog years. Each additional human year counts as 4 dog years. Your task is to implement the function to perform this conversion. **Function Signature:** ```python def convert_dog_age(human_years: float) -> float: pass ``` **Input:** - `human_years` (float): The dog\'s age in human years. **Output:** - (float): The dog\'s age in dog years, rounded to one decimal place. **Constraints:** - The input human_years will be a non-negative float. **Examples:** ```python >>> convert_dog_age(1) 10.5 >>> convert_dog_age(2) 21.0 >>> convert_dog_age(3) 25.0 >>> convert_dog_age(5) 33.0 >>> convert_dog_age(10) 53.0 ``` **Technical Notes:** 1. For the first two years, each human year is equivalent to 10.5 dog years. 2. For each year beyond the first two, each human year is equivalent to 4 dog years. 3. Ensure your function handles the conversion accurately and rounds the result to one decimal place.","solution":"def convert_dog_age(human_years: float) -> float: Converts a dog\'s age in human years to dog years. Parameters: human_years (float): The dog\'s age in human years. Returns: float: The dog\'s age in dog years, rounded to one decimal place. if human_years <= 2: dog_years = human_years * 10.5 else: dog_years = 2 * 10.5 + (human_years - 2) * 4 return round(dog_years, 1)"},{"question":"# Scenario You are developing a basic text editor application. One of the features required is a \\"find and replace\\" functionality. In this scenario, you need to identify all occurrences of a specific word in the text and replace them with another word. # Task Implement a function that replaces all occurrences of a target word in a given text with a replacement word. # Function Signature ```python def find_and_replace(text: str, target: str, replacement: str) -> str: Replace all occurrences of the target word with the replacement word in the given text. :param text: The original text string. :param target: The target word to be replaced. :param replacement: The word to replace the target word. :return: The modified text with all occurrences of the target word replaced. :raises ValueError: If any of the inputs are empty strings. ``` # Input * `text`: a string representing the original text. * `target`: a string representing the word to be replaced. * `replacement`: a string representing the word to replace the target word. # Output Returns the modified text with all occurrences of the target word replaced by the replacement word. # Constraints * All inputs (`text`, `target`, and `replacement`) must be non-empty strings. * If any input is an empty string, the function should raise a `ValueError`. * The function should be case-sensitive. # Example ```python >>> find_and_replace(\\"Hello world, welcome to the world of coding!\\", \\"world\\", \\"universe\\") \\"Hello universe, welcome to the universe of coding!\\" >>> find_and_replace(\\"The rain in Spain stays mainly in the plain.\\", \\"Spain\\", \\"London\\") \\"The rain in London stays mainly in the plain.\\" >>> find_and_replace(\\"Test the function, test the code.\\", \\"test\\", \\"run\\") \\"Test the function, run the code.\\" >>> find_and_replace(\\"Repeat after me: practice, practice, practice.\\", \\"practice\\", \\"learn\\") \\"Repeat after me: learn, learn, learn.\\" >>> find_and_replace(\\"\\", \\"world\\", \\"universe\\") Traceback (most recent call last): ... ValueError: All inputs must be non-empty strings >>> find_and_replace(\\"Hello world!\\", \\"\\", \\"universe\\") Traceback (most recent call last): ... ValueError: All inputs must be non-empty strings >>> find_and_replace(\\"Hello world!\\", \\"world\\", \\"\\") Traceback (most recent call last): ... ValueError: All inputs must be non-empty strings ``` # Notes * Ensure the function correctly handles scenarios where the target word appears multiple times within the text. * The implementation should run efficiently even with lengthy text inputs. * Proper validation should be done to ensure input constraints are met.","solution":"def find_and_replace(text: str, target: str, replacement: str) -> str: Replace all occurrences of the target word with the replacement word in the given text. :param text: The original text string. :param target: The target word to be replaced. :param replacement: The word to replace the target word. :return: The modified text with all occurrences of the target word replaced. :raises ValueError: If any of the inputs are empty strings. if not text or not target or not replacement: raise ValueError(\\"All inputs must be non-empty strings\\") return text.replace(target, replacement)"},{"question":"# Optimal Investment Portfolio **Problem Statement**: You are required to create a function that helps in identifying the optimal investment portfolio based on historical returns. Given a list of yearly returns for different investments and an available amount of money, the function should determine the percentage of the total amount to invest in each option to maximize the overall return. Your function will receive a list of annual returns (in percentages) for each investment and the total amount of money available. The goal is to maximize the total return at the end of the year. **Function Signature**: ```python def optimal_portfolio(returns: List[float], total_money: float) -> List[float]: Approach: - Analyze the list of annual returns for each investment option. - Allocate the total amount of money to maximize the overall return. - Determine the percentage of total_money to be invested in each option. Params: - returns (List[float]): A list of annual returns (in percentages) for each investment option. - total_money (float): The total amount of money available to invest. Returns: - List[float]: A list of percentages (in decimal form) representing the portion of total_money to invest in each option. pass ``` **Input**: * `returns` - A list of floats where each float represents the annual return (in percentage) for an investment option. * `total_money` - A float representing the total amount of money available to invest. **Output**: * A list of floats where each float represents the percentage (in decimal form) of the total money to be invested in each respective investment option. **Constraints**: * `len(returns) > 0` * `total_money > 0` **Example**: ```python # Example use-case with 3 investment options investment_returns = [5.0, 10.0, 6.5] # Annual returns in percentages total_investment = 1000.0 # Total money available to invest # Optimal investment portfolio print(optimal_portfolio(investment_returns, total_investment)) # Output: [0.0, 1.0, 0.0] (invest all money in the option with the highest return, the second one) investment_returns = [3.0, 4.0, 5.0] # Annual returns in percentages total_investment = 5000.0 # Total money available to invest # Optimal investment portfolio print(optimal_portfolio(investment_returns, total_investment)) # Output: [0.0, 0.0, 1.0] (invest all money in the option with the highest return, the third one) ``` **Note**: - Test your function with various lists of returns and different total amounts of money to ensure its correctness and robustness. - Consider edge cases such as lists with equal returns or very small investment amounts.","solution":"from typing import List def optimal_portfolio(returns: List[float], total_money: float) -> List[float]: Determines the optimal investment portfolio by investing all the money into the option with the maximum yearly return. Parameters: - returns (List[float]): A list of annual returns (in percentages) for each investment option. - total_money (float): The total amount of money available to invest. Returns: - List[float]: A list of percentages (in decimal form) representing the portion of total_money to invest in each option. # Find the index of the investment with the highest return max_return_index = returns.index(max(returns)) # Create a portfolio where 100% investment is made in the option with the highest return portfolio = [0.0] * len(returns) portfolio[max_return_index] = 1.0 return portfolio"},{"question":"# Reversing Words in a String Write a function that takes a string as input and returns a string with the words in reverse order. Words are separated by spaces and the output should preserve the order of characters within each word, but the words themselves should be in reverse order. Function Signature ```python def reverse_words_in_string(s: str) -> str: ``` Input - `s` (str): A string containing words separated by spaces. Constraints: 1 ≤ len(s) ≤ 10^5 Output - (str): A string with the words in reverse order. Constraints - Your function should raise a `TypeError` if the input is not a string. - Ensure that the function works efficiently for large input strings. - Do not modify the characters within each word. Examples ```python print(reverse_words_in_string(\\"hello world\\")) # Output: \\"world hello\\" print(reverse_words_in_string(\\"one two three four\\")) # Output: \\"four three two one\\" print(reverse_words_in_string(\\"Python is awesome\\")) # Output: \\"awesome is Python\\" print(reverse_words_in_string(\\"a b c d e f g\\")) # Output: \\"g f e d c b a\\" print(reverse_words_in_string(\\"OpenAI Code Generation\\")) # Output: \\"Generation Code OpenAI\\" print(reverse_words_in_string(\\" \\")) # Output: \\" \\" print(reverse_words_in_string(\\"singleword\\")) # Output: \\"singleword\\" ``` Notes - Handle edge cases such as a single word or multiple spaces between words gracefully. - Split the input string on spaces to retrieve the words, then join them back in reversed order. - Be mindful of the function\'s performance, especially for large input strings.","solution":"def reverse_words_in_string(s: str) -> str: if not isinstance(s, str): raise TypeError(\\"Input must be a string\\") # Splitting the string by spaces to get the words words = s.split() # Reversing the list of words reversed_words = words[::-1] # Joining the reversed words with a space separator return \\" \\".join(reversed_words)"},{"question":"# Implement a Function to Find the Lowest Common Ancestor in a Binary Search Tree Given the root of a Binary Search Tree (BST) and two nodes, implement a function called `lowest_common_ancestor` that finds the lowest common ancestor of the two given nodes. The lowest common ancestor is defined as the deepest node that is an ancestor of both given nodes. # Function Signature ```python def lowest_common_ancestor(root: TreeNode, node1: TreeNode, node2: TreeNode) -> TreeNode: ``` # Parameters and Constraints - `root`, `node1`, and `node2` are instances of `TreeNode`. - Assume that both `node1` and `node2` are present in the Binary Search Tree. - The BST property (left subtree has smaller elements, right subtree has larger elements) is maintained. - The function should have an average time complexity of O(log n), where n is the number of nodes in the BST. # Example ```python class TreeNode: def __init__(self, key: int, left: \'TreeNode\' = None, right: \'TreeNode\' = None): self.key = key self.left = left self.right = right # Constructed BST: # 6 # / # 2 8 # / / # 0 4 7 9 # / # 3 5 root = TreeNode(6) root.left = TreeNode(2) root.right = TreeNode(8) root.left.left = TreeNode(0) root.left.right = TreeNode(4) root.left.right.left = TreeNode(3) root.left.right.right = TreeNode(5) root.right.left = TreeNode(7) root.right.right = TreeNode(9) node1 = root.left # Node with key 2 node2 = root.right # Node with key 8 lca = lowest_common_ancestor(root, node1, node2) assert lca.key == 6 node1 = root.left # Node with key 2 node2 = root.left.right.right # Node with key 5 lca = lowest_common_ancestor(root, node1, node2) assert lca.key == 2 ``` # Additional Notes - The function should not assume any specific tree traversal order. - Ensure that the code handles disparate depths of the tree correctly. - Take advantage of the BST properties for an optimized solution.","solution":"class TreeNode: def __init__(self, key: int, left=None, right=None): self.key = key self.left = left self.right = right def lowest_common_ancestor(root: TreeNode, node1: TreeNode, node2: TreeNode) -> TreeNode: Finds the lowest common ancestor (LCA) of two nodes in a Binary Search Tree (BST). Parameters: root (TreeNode): The root node of the BST. node1 (TreeNode): The first node for which to find the LCA. node2 (TreeNode): The second node for which to find the LCA. Returns: TreeNode: The lowest common ancestor of node1 and node2. current = root while current: if node1.key < current.key and node2.key < current.key: current = current.left elif node1.key > current.key and node2.key > current.key: current = current.right else: return current"},{"question":"# Coding Question: Common Elements in Sorted Arrays Scenario You\'re developing a feature in an analytics tool to compare sorted lists of user IDs obtained from different sources. One critical requirement is to find common IDs that appear in all the provided lists. Problem Write a function to identify the common elements in three sorted arrays of user IDs. Function Signature ```python def common_elements(arr1: List[int], arr2: List[int], arr3: List[int]) -> List[int]: ``` Input * Three lists, `arr1`, `arr2`, and `arr3`, each containing `n` sorted integers (1 ≤ n ≤ 10^5). Output * A list of integers, sorted in ascending order, representing the common elements found in all three arrays. Constraints * The elements in each array are unique and sorted in non-decreasing order. * Each integer in the arrays is a positive number up to 10^9. * The solution should be optimized for efficiency. Example ```python >>> common_elements([1, 2, 3, 4], [2, 3, 5, 7], [1, 2, 3, 6]) [2, 3] >>> common_elements([1, 2, 3], [4, 5, 6], [7, 8, 9]) [] >>> common_elements([2, 5, 10], [2, 10, 12], [2, 9, 10]) [2, 10] ``` Note: * The function `common_elements([1, 2, 3, 4], [2, 3, 5, 7], [1, 2, 3, 6])` should return `[2, 3]` because 2 and 3 are common in all three lists. * `common_elements([1, 2, 3], [4, 5, 6], [7, 8, 9])` yields an empty list since there are no common elements. * For `common_elements([2, 5, 10], [2, 10, 12], [2, 9, 10])`, the result is `[2, 10]`. Edge Cases * All arrays are empty: Should return an empty list. * One of the arrays is empty: Should return an empty list. * All arrays have no common elements: Should return an empty list. Implement the function `common_elements`.","solution":"from typing import List def common_elements(arr1: List[int], arr2: List[int], arr3: List[int]) -> List[int]: Find common elements in three sorted arrays. i, j, k = 0, 0, 0 result = [] while i < len(arr1) and j < len(arr2) and k < len(arr3): if arr1[i] == arr2[j] == arr3[k]: result.append(arr1[i]) i += 1 j += 1 k += 1 elif arr1[i] < arr2[j]: i += 1 elif arr2[j] < arr3[k]: j += 1 else: k += 1 return result"},{"question":"# Objective Create an efficient program to determine the shortest path in a weighted matrix. # Question Write a Python function `shortest_path_weighted_matrix` that finds the shortest path in a grid where each cell has a non-negative weight. The function should find the minimum sum of weights from the top-left corner to the bottom-right corner of the matrix. The rules for movement are: - You can only move right or down. - You must start at the top-left corner (matrix[0][0]) and reach the bottom-right corner (matrix[N-1][M-1]). **Function Signature:** ```python def shortest_path_weighted_matrix(matrix: List[List[int]]) -> int: pass ``` # Input * A 2D list `matrix` of size `N x M` where `matrix[i][j]` is a non-negative integer representing the weight of cell `(i, j)`. # Output * An integer representing the minimum sum of weights from the top-left corner to the bottom-right corner. # Constraints * The matrix dimensions, `N` and `M`, will be at least 1 and at most 100. * Each weight in the matrix will be a non-negative integer not exceeding 1000. * If the matrix size is 1x1, the output should be the weight of that single cell. # Example ```python assert shortest_path_weighted_matrix([[1,3,1],[1,5,1],[4,2,1]]) == 7 assert shortest_path_weighted_matrix([[1,2,3],[4,5,6],[7,8,9]]) == 21 assert shortest_path_weighted_matrix([[1]]) == 1 ``` # Notes * Utilize dynamic programming or similar techniques to ensure the solution is efficient. * Consider edge cases, such as a single-element matrix or the largest possible grid sizes. * Ensure that all possible paths are considered to find the minimal path sum.","solution":"from typing import List def shortest_path_weighted_matrix(matrix: List[List[int]]) -> int: Returns the minimum sum of weights from the top-left corner to the bottom-right corner in a weighted matrix. if not matrix or not matrix[0]: return 0 n = len(matrix) m = len(matrix[0]) # Create a DP table dp = [[0] * m for _ in range(n)] # Initialize the top-left corner dp[0][0] = matrix[0][0] # Fill the first row for j in range(1, m): dp[0][j] = dp[0][j-1] + matrix[0][j] # Fill the first column for i in range(1, n): dp[i][0] = dp[i-1][0] + matrix[i][0] # Fill the rest of the DP table for i in range(1, n): for j in range(1, m): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + matrix[i][j] # The bottom-right corner contains the minimum path sum return dp[-1][-1]"},{"question":"# Problem Statement: You need to implement a function that, given a list of integers representing the prices of items in a store, calculates the maximum price difference between any two items in the list. The difference is calculated as the price of the item appearing later in the list minus the price of the item appearing earlier. If there is no valid price difference (i.e., the list is empty or consists of only one element), the function should return 0. # Function Signature: ```python def max_price_difference(prices: List[int]) -> int: pass ``` # Input: * A list of integers `prices` (0 <= len(prices) <= 10^5) where each element (0 <= price <= 10^6). # Output: * An integer representing the maximum price difference. # Example Test Cases: ```python assert max_price_difference([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]) == 8 assert max_price_difference([7, 1, 5, 3, 6, 4]) == 5 assert max_price_difference([7, 6, 4, 3, 1]) == 0 assert max_price_difference([1, 2, 3, 4, 5]) == 4 assert max_price_difference([]) == 0 assert max_price_difference([5]) == 0 ``` # Constraints: 1. The list may be empty or contain up to 100,000 elements. 2. Implement the solution with a time complexity of O(n), where n is the length of the list. 3. Use only constant additional space. # Performance Requirements: Your solution should process the input list in linear time and with constant additional space, making it efficient even for large inputs.","solution":"def max_price_difference(prices): Calculate the maximum price difference between any two items. The difference is calculated as the price of the item appearing later in the list minus the price of the item appearing earlier. :param prices: List of integers representing prices. :return: Maximum price difference or 0 if no valid price difference exists. if len(prices) < 2: return 0 min_price = prices[0] max_diff = 0 for price in prices[1:]: max_diff = max(max_diff, price - min_price) min_price = min(min_price, price) return max_diff"},{"question":"# Comparing File Checksums to Detect Changes Problem Statement: You are tasked with determining if the contents of two files have changed over a period of time by comparing their checksums. Each file has undergone multiple changes, and you must identify the index of the first difference in the list of checksums that represents the contents of these files over time. Function Signature: ```python def detect_changes( checksums_file1: list[str], checksums_file2: list[str] ) -> int: ``` Parameters: - `checksums_file1 (list[str])`: List of checksum strings for the first file recorded over time. - `checksums_file2 (list[str])`: List of checksum strings for the second file recorded over time. Returns: An integer representing the index of the first difference in checksums between the two files. If the lists are identical, return `-1`. Constraints: - The checksums list for each file will be non-empty and of the same length. - The checksums are represented as strings. Examples: ```python detect_changes([\\"abc123\\", \\"def456\\", \\"ghi789\\"], [\\"abc123\\", \\"def456\\", \\"xyz987\\"]) # Expected Output: 2 detect_changes([\\"abc123\\", \\"def456\\", \\"ghi789\\"], [\\"abc123\\", \\"def456\\", \\"ghi789\\"]) # Expected Output: -1 detect_changes([\\"a1b2c3\\", \\"d4e5f6\\"], [\\"a1b2c3\\", \\"x7y8z9\\"]) # Expected Output: 1 ``` Notes: - The function should iterate through the lists and compare checksums pair by pair. - Ensure that your function handles lists efficiently, considering the possibility of lengthy input lists.","solution":"def detect_changes(checksums_file1: list[str], checksums_file2: list[str]) -> int: Determines the index of the first difference in the list of checksums between two files over time. If the lists are identical, returns -1. Args: checksums_file1 (list[str]): List of checksum strings for the first file recorded over time. checksums_file2 (list[str]): List of checksum strings for the second file recorded over time. Returns: int: The index of the first difference. If identical, return -1. for index in range(len(checksums_file1)): if checksums_file1[index] != checksums_file2[index]: return index return -1"},{"question":"# Scenario: You are a software engineer responsible for optimizing the storage and retrieval of user-generated content on a social media platform. To efficiently manage the storage, you need to serialize and deserialize the social media posts, which consist of nested lists, dictionaries, and strings. # Task: Implement a class `PostSerializer`, which provides methods to serialize and deserialize the social media posts. The posts are represented as nested data structures consisting of lists, dictionaries, and strings. # Function Signature: ```python class PostSerializer: def serialize(self, data: Any) -> str: Serialize the nested data structure into a JSON string. Parameters: - data (Any): The data to serialize, which can be a nested combination of lists, dictionaries, and strings. Returns: - str: The serialized JSON string representation of the data. def deserialize(self, data: str) -> Any: Deserialize the JSON string back into the original nested data structure. Parameters: - data (str): The JSON string representation of the data to deserialize. Returns: - Any: The original nested data structure. ``` # Constraints: - The nested data structures can be arbitrarily nested and can contain empty lists and dictionaries. - All strings in the data structure are UTF-8 encoded. - You are not allowed to use any third-party serialization libraries other than the built-in `json` module in Python. # Performance: - The serialization and deserialization methods should handle data structures with up to 1000 nested elements efficiently. - Ensure that the serialization and deserialization functions maintain the integrity and consistency of the data. # Example Usage: ```python serializer = PostSerializer() # Example post data post = { \\"user\\": \\"john_doe\\", \\"content\\": [ \\"Hello, world!\\", {\\"comments\\": [\\"Nice post!\\", \\"Thanks for sharing!\\"]}, {\\"likes\\": [\\"alice\\", \\"bob\\"]} ] } # Serialize the post serialized_post = serializer.serialize(post) print(serialized_post) # Deserialize the post deserialized_post = serializer.deserialize(serialized_post) print(deserialized_post) ``` # Evaluation: - Your solution will be evaluated on its correctness, efficiency, and ability to handle complex and deeply nested data structures. - Consider edge cases such as empty lists and dictionaries, as well as deeply nested structures.","solution":"import json from typing import Any class PostSerializer: def serialize(self, data: Any) -> str: Serialize the nested data structure into a JSON string. Parameters: - data (Any): The data to serialize, which can be a nested combination of lists, dictionaries, and strings. Returns: - str: The serialized JSON string representation of the data. return json.dumps(data) def deserialize(self, data: str) -> Any: Deserialize the JSON string back into the original nested data structure. Parameters: - data (str): The JSON string representation of the data to deserialize. Returns: - Any: The original nested data structure. return json.loads(data)"},{"question":"# Task Implement a data structure, `CircularDeque`, which supports operations on a double-ended queue with a fixed maximum size in a circular manner. # Function Signature ```python class CircularDeque: def __init__(self, k: int): pass def insertFront(self, value: int) -> bool: pass def insertLast(self, value: int) -> bool: pass def deleteFront(self) -> bool: pass def deleteLast(self) -> bool: pass def getFront(self) -> int: pass def getRear(self) -> int: pass def isEmpty(self) -> bool: pass def isFull(self) -> bool: pass ``` # Input * `k (int)`: The maximum size of the circular deque. # Output * The appropriate return type based on each method description. # Method Descriptions - `__init__(self, k: int)` Initializes the deque with a size `k`. - `insertFront(self, value: int) -> bool` Adds an item at the front of Deque. Return `true` if the operation is successful, or `false` otherwise. - `insertLast(self, value: int) -> bool` Adds an item at the rear of Deque. Return `true` if the operation is successful, or `false` otherwise. - `deleteFront(self) -> bool` Deletes an item from the front of Deque. Return `true` if the operation is successful, or `false` otherwise. - `deleteLast(self) -> bool` Deletes an item from the rear of Deque. Return `true` if the operation is successful, or `false` otherwise. - `getFront(self) -> int` Gets the front item from the Deque. If the deque is empty, return `-1`. - `getRear(self) -> int` Gets the last item from the Deque. If the deque is empty, return `-1`. - `isEmpty(self) -> bool` Checks whether the circular deque is empty or not. - `isFull(self) -> bool` Checks whether the circular deque is full or not. # Constraints - All function calls should be `O(1)`. - 1 <= `k` <= 1000 - 0 <= `value` <= 1000 - The functions `getFront`, `getRear`, `isEmpty`, and `isFull` must always operate in constant time. # Example ```python circularDeque = CircularDeque(3) # set the size to be 3 print(circularDeque.insertLast(1)) # return true print(circularDeque.insertLast(2)) # return true print(circularDeque.insertFront(3)) # return true print(circularDeque.insertFront(4)) # return false, the queue is full print(circularDeque.getRear()) # return 2 print(circularDeque.isFull()) # return true print(circularDeque.deleteLast()) # return true print(circularDeque.insertFront(4)) # return true print(circularDeque.getFront()) # return 4 ```","solution":"class CircularDeque: def __init__(self, k: int): self.size = k self.deque = [0] * k self.front = -1 self.rear = -1 self.count = 0 def insertFront(self, value: int) -> bool: if self.isFull(): return False if self.isEmpty(): self.front = self.rear = 0 else: self.front = (self.front - 1) % self.size self.deque[self.front] = value self.count += 1 return True def insertLast(self, value: int) -> bool: if self.isFull(): return False if self.isEmpty(): self.front = self.rear = 0 else: self.rear = (self.rear + 1) % self.size self.deque[self.rear] = value self.count += 1 return True def deleteFront(self) -> bool: if self.isEmpty(): return False if self.front == self.rear: self.front = self.rear = -1 else: self.front = (self.front + 1) % self.size self.count -= 1 return True def deleteLast(self) -> bool: if self.isEmpty(): return False if self.front == self.rear: self.front = self.rear = -1 else: self.rear = (self.rear - 1) % self.size self.count -= 1 return True def getFront(self) -> int: if self.isEmpty(): return -1 return self.deque[self.front] def getRear(self) -> int: if self.isEmpty(): return -1 return self.deque[self.rear] def isEmpty(self) -> bool: return self.count == 0 def isFull(self) -> bool: return self.count == self.size"},{"question":"# Task Description You are required to implement a function `find_next_square(number: int) -> int` that returns the next perfect square greater than the given non-negative integer. Ensure that your function gracefully handles edge cases, including non-integer inputs and negative values. # Function Signature ```python def find_next_square(number: int) -> int: pass ``` # Input - An integer `number` which must be non-negative. # Output - The next perfect square greater than `number`. # Constraints - `number` will be a non-negative integer. - If the input is already a perfect square, the function should return the next perfect square. # Performance Requirements - The solution must have a time complexity of O(1) and space complexity of O(1). # Examples 1. `find_next_square(0)` returns `1`. 2. `find_next_square(10)` returns `16`. 3. `find_next_square(16)` returns `25`. 4. `find_next_square(24)` returns `25`. # Notes - Raise a `ValueError` for any input that is not a non-negative integer. - You are not allowed to use any external libraries for directly computing the next perfect square. # Example Usage ```python # Valid usage print(find_next_square(5)) # Output: 9 print(find_next_square(17)) # Output: 25 # Edge case handling try: print(find_next_square(-1)) except ValueError as ve: print(ve) # Output: Input must be a non-negative integer try: print(find_next_square(6.75)) except ValueError as ve: print(ve) # Output: Input must be a non-negative integer ```","solution":"import math def find_next_square(number: int) -> int: Returns the next perfect square greater than the given non-negative integer. :param number: int - a non-negative integer. :return: int - the next perfect square greater than the input number. if not isinstance(number, int) or number < 0: raise ValueError(\\"Input must be a non-negative integer\\") root = int(math.sqrt(number)) next_root = root + 1 return next_root * next_root"},{"question":"# Coding Assessment Question **Context**: You are tasked with developing a function for a statistical data analysis tool that fits a polynomial to a given set of data points using the least squares method. Your function will help in estimating the relationship between variables by minimizing the sum of the squares of the differences between the observed and estimated values. **Task**: Write a function `fit_polynomial` that fits a polynomial of a given degree to a set of data points. Function Signature: ```python def fit_polynomial(x_points: np.ndarray, y_points: np.ndarray, degree: int) -> np.ndarray: ``` Parameters: * `x_points` (np.ndarray): A 1D numpy array of x-coordinates of the data points. * `y_points` (np.ndarray): A 1D numpy array of y-coordinates of the data points. * `degree` (int): The degree of the polynomial to fit to the data points. Returns: * `np.ndarray`: A 1D numpy array containing the polynomial coefficients starting from the highest degree term. Examples: ```python >>> fit_polynomial(np.array([0, 1, 2, 3]), np.array([1, 2, 3, 4]), 1) array([1., 1.]) >>> fit_polynomial(np.array([0, 1, 2, 3]), np.array([1, 2, 3, 4]), 2) array([0., 1., 1.]) >>> fit_polynomial(np.array([-1, 0, 1]), np.array([1, 0, 1]), 2) array([1., 0., 0.]) ``` # Constraints: * The values in `x_points` and `y_points` are real numbers. * The inputs `x_points` and `y_points` have the same length, which is at least `degree + 1`. * Ensure the implementation handles small and large datasets efficiently. * Numerical stability and potential overfitting for higher-degree polynomials should be considered. Additional Information: You can use the numpy library for polynomial fitting. Specifically, consider using `numpy.polyfit`.","solution":"import numpy as np def fit_polynomial(x_points: np.ndarray, y_points: np.ndarray, degree: int) -> np.ndarray: Fits a polynomial of a given degree to the provided data points using the least squares method. Parameters: - x_points (np.ndarray): A 1D numpy array of x-coordinates of the data points. - y_points (np.ndarray): A 1D numpy array of y-coordinates of the data points. - degree (int): The degree of the polynomial to fit to the data points. Returns: - np.ndarray: A 1D numpy array containing the polynomial coefficients starting from the highest degree term. coefficients = np.polyfit(x_points, y_points, degree) return coefficients"},{"question":"# Scenario: You are developing a data analysis tool that includes a feature for time-series smoothing. The tool uses a customized smoothing algorithm called Weighted Running Average (WRA) which applies unique weights to a moving window of data points to produce a smoothed average. # Task: Write a function that computes the Weighted Running Average for a series of data points within a given window size. The function should apply different weights to each position within the window and slide this window over the data points to compute the smoothed result. # Function Signature: ```python def weighted_running_average( data: np.ndarray, window_size: int, weights: np.ndarray ) -> np.ndarray: pass ``` # Input: - `data`: A numpy ndarray of shape (n,) containing n floating-point numbers representing the time-series data. - `window_size`: An integer determining the number of data points within each window. - `weights`: A numpy ndarray of shape (window_size,) containing floating-point numbers representing the weights to apply within the window. # Output: - Returns a numpy ndarray of shape (n - window_size + 1,) where each element is the weighted average of the corresponding window of data points. # Constraints: - Ensure the function can handle data arrays up to length 10^6 efficiently. - The length of the `weights` array will always be equal to `window_size`. - The window will slide one position at a time from the beginning to the end of the data array. - Handle edge cases where weights may include very small or very large values gracefully. # Example: ```python >>> data = np.array([1.0, 2.0, 3.0, 4.0, 5.0]) >>> window_size = 3 >>> weights = np.array([0.2, 0.5, 0.3]) >>> weighted_running_average(data, window_size, weights) array([2.1, 3.1, 4.1]) ``` # Notes: - Use numpy for efficient numerical computations. - Carefully handle overlap of the windows to ensure accurate calculations. - Make sure that the function operates within a reasonable time for large input sizes.","solution":"import numpy as np def weighted_running_average(data: np.ndarray, window_size: int, weights: np.ndarray) -> np.ndarray: Computes the Weighted Running Average for a series of data points within a given window size. Args: data: A numpy ndarray of shape (n,) containing n floating-point numbers representing the time-series data. window_size: An integer determining the number of data points within each window. weights: A numpy ndarray of shape (window_size,) containing floating-point numbers representing the weights to apply within the window. Returns: A numpy ndarray of shape (n - window_size + 1,) containing the weighted running average for each window. if len(weights) != window_size: raise ValueError(\\"Length of weights array must be equal to the window size.\\") n = len(data) if n < window_size: raise ValueError(\\"Length of data array must be greater than or equal to the window size.\\") weights = weights / np.sum(weights) result = np.zeros(n - window_size + 1) for i in range(n - window_size + 1): window = data[i:i + window_size] result[i] = np.dot(window, weights) return result"},{"question":"# Problem Statement: You are given a list of integers. Your task is to write a function `find_most_frequent_digit` that finds and returns the digit (0-9) that appears most frequently across all numbers in the list. If there is a tie (i.e., multiple digits appear with the same maximum frequency), return the smallest digit among them. Function Signature: ```python def find_most_frequent_digit(numbers: List[int]) -> int: # Your code here ``` Input: * A list of integers `numbers` where each integer `n` is such that ( 0 le n < 10^6 ) Output: * An integer representing the most frequent digit Constraints: * The list `numbers` contains at least one number. # Example: *Example 1*: ```python numbers = [123, 456, 789, 123] find_most_frequent_digit(numbers) ``` *Output*: ``` 1 ``` *Example 2*: ```python numbers = [341, 414, 916, 114] find_most_frequent_digit(numbers) ``` *Output*: ``` 1 ``` *Example 3*: ```python numbers = [10, 20, 30, 40, 50] find_most_frequent_digit(numbers) ``` *Output*: ``` 0 ``` Explanation: In the first example, digit \'1\' appears most frequently across all numbers. In the second example, \'1\' is the most frequent digit appearing six times. In the third example, \'0\' appears most frequently, albeit only once per number from the list.","solution":"from typing import List def find_most_frequent_digit(numbers: List[int]) -> int: digit_count = [0] * 10 # Initialize array to count occurrences of each digit 0-9 # Count the occurrences of each digit in the numbers list for number in numbers: while number > 0: digit = number % 10 digit_count[digit] += 1 number //= 10 # Find the digit with the maximum occurrences, preferring smaller digits in case of ties max_count = -1 most_frequent_digit = 0 for i in range(10): if digit_count[i] > max_count: max_count = digit_count[i] most_frequent_digit = i return most_frequent_digit"},{"question":"# Question: Implement a Simple To-Do List Manager In this exercise, you are to implement a Python class that manages a simple to-do list. This class should be capable of adding tasks, removing tasks, and displaying all tasks. Class Definition ```python class ToDoListManager: ``` Methods * `__init__(self) -> None`: Initializes an empty to-do list. * `add_task(self, task: str) -> None`: Adds a new task to the to-do list. * `remove_task(self, task: str) -> bool`: Removes a task from the to-do list by its name. Returns `True` if the task was successfully removed, `False` otherwise. * `view_tasks(self) -> list`: Returns a list of all tasks currently in the to-do list. Constraints * The task names are case-sensitive. * Tasks should maintain the order they were added in. * If a task is not found during removal, the method should handle it gracefully without raising an error. Example Usage ```python # Initialize the to-do list manager to_do = ToDoListManager() # Add tasks to_do.add_task(\\"Buy groceries\\") to_do.add_task(\\"Complete assignment\\") # View tasks print(to_do.view_tasks()) # Output: [\'Buy groceries\', \'Complete assignment\'] # Remove a task to_do.remove_task(\\"Buy groceries\\") # Returns: True # View tasks print(to_do.view_tasks()) # Output: [\'Complete assignment\'] ``` Sample Output ```python # Adding a task example tasks_manager = ToDoListManager() tasks_manager.add_task(\\"Finish homework\\") print(tasks_manager.view_tasks()) # Expected Output: [\'Finish homework\'] # Removing a task example tasks_manager.add_task(\\"Go to the gym\\") print(tasks_manager.view_tasks()) # Expected Output: [\'Finish homework\', \'Go to the gym\'] result = tasks_manager.remove_task(\\"Finish homework\\") print(result) # Expected Output: True print(tasks_manager.view_tasks()) # Expected Output: [\'Go to the gym\'] result = tasks_manager.remove_task(\\"Non-existent task\\") print(result) # Expected Output: False ``` Additional Notes * Ensure your code adheres to Python\'s best coding practices. * Properly manage list operations to avoid common pitfalls such as modifying a list while iterating over it.","solution":"class ToDoListManager: def __init__(self) -> None: Initializes an empty to-do list. self.tasks = [] def add_task(self, task: str) -> None: Adds a new task to the to-do list. self.tasks.append(task) def remove_task(self, task: str) -> bool: Removes a task from the to-do list by its name. Returns True if the task was successfully removed, False otherwise. if task in self.tasks: self.tasks.remove(task) return True return False def view_tasks(self) -> list: Returns a list of all tasks currently in the to-do list. return self.tasks"},{"question":"# Scenario You work for a local library that recently digitized its catalog. However, the search functionality in the catalog is limited, and patrons are frequently requesting more advanced search features to find books by various criteria. # Problem Statement You have been assigned to enhance the library’s search functionality by implementing a feature that allows users to search for books based on a set of criteria. Each book in the catalog is represented by a dictionary containing its title, author, publication year, genre, and ISBN. # Requirements You need to implement the `search_books` function that takes two parameters: 1. `library` (List[Dict[str, Any]]): A list of dictionaries where each dictionary represents a book. 2. `criteria` (Dict[str, Any]): A dictionary where the keys are the search fields (\\"title\\", \\"author\\", \\"year\\", \\"genre\\", \\"ISBN\\") and the values are the search values (can be `None` if that field is not being filtered). Your function should return a list of book dictionaries that match all specified criteria. If a criterion is `None`, it should be ignored in the search. # Input - `library`: a list of dictionaries, each containing the book details: ```python [ {\\"title\\": \\"1984\\", \\"author\\": \\"George Orwell\\", \\"year\\": 1949, \\"genre\\": \\"Dystopian\\", \\"ISBN\\": \\"1234567890\\"}, {\\"title\\": \\"To Kill a Mockingbird\\", \\"author\\": \\"Harper Lee\\", \\"year\\": 1960, \\"genre\\": \\"Fiction\\", \\"ISBN\\": \\"1234567891\\"}, ... ] ``` - `criteria`: a dictionary with search criteria: ```python {\\"title\\": \\"1984\\", \\"author\\": None, \\"year\\": None, \\"genre\\": None, \\"ISBN\\": None} ``` # Output - Returns a list of dictionaries representing books that match the search criteria. # Constraints - The `library` list will contain between 0 and 10^4 books. - Each book dictionary will contain the keys: \\"title\\", \\"author\\", \\"year\\", \\"genre\\", and \\"ISBN\\". - The `criteria` dictionary may have `None` for any of the criteria that should not be filtered. # Example ```python from typing import List, Dict, Any def search_books(library: List[Dict[str, Any]], criteria: Dict[str, Any]) -> List[Dict[str, Any]]: Filters a list of books by given search criteria. Parameters: library (List[Dict[str, Any]]): The list of books to search within. criteria (Dict[str, Any]): The criteria to filter books by. Returns: List[Dict[str, Any]]: List of books matching all criteria. result = [] for book in library: match = True for key, value in criteria.items(): if value is not None and book.get(key) != value: match = False break if match: result.append(book) return result # Example usage: library = [ {\\"title\\": \\"1984\\", \\"author\\": \\"George Orwell\\", \\"year\\": 1949, \\"genre\\": \\"Dystopian\\", \\"ISBN\\": \\"1234567890\\"}, {\\"title\\": \\"To Kill a Mockingbird\\", \\"author\\": \\"Harper Lee\\", \\"year\\": 1960, \\"genre\\": \\"Fiction\\", \\"ISBN\\": \\"1234567891\\"}, ] criteria_1 = {\\"title\\": \\"1984\\", \\"author\\": None, \\"year\\": None, \\"genre\\": None, \\"ISBN\\": None} criteria_2 = {\\"title\\": None, \\"author\\": \\"Harper Lee\\", \\"year\\": None, \\"genre\\": None, \\"ISBN\\": None} print(search_books(library, criteria_1)) # Should output: [{\'title\': \'1984\', \'author\': \'George Orwell\', \'year\': 1949, \'genre\': \'Dystopian\', \'ISBN\': \'1234567890\'}] print(search_books(library, criteria_2)) # Should output: [{\'title\': \'To Kill a Mockingbird\', \'author\': \'Harper Lee\', \'year\': 1960, \'genre\': \'Fiction\', \'ISBN\': \'1234567891\'}] ```","solution":"from typing import List, Dict, Any def search_books(library: List[Dict[str, Any]], criteria: Dict[str, Any]) -> List[Dict[str, Any]]: Filters a list of books by given search criteria. Parameters: library (List[Dict[str, Any]]): The list of books to search within. criteria (Dict[str, Any]): The criteria to filter books by. Returns: List[Dict[str, Any]]: List of books matching all criteria. result = [] for book in library: match = True for key, value in criteria.items(): if value is not None and book.get(key) != value: match = False break if match: result.append(book) return result # Example usage: library = [ {\\"title\\": \\"1984\\", \\"author\\": \\"George Orwell\\", \\"year\\": 1949, \\"genre\\": \\"Dystopian\\", \\"ISBN\\": \\"1234567890\\"}, {\\"title\\": \\"To Kill a Mockingbird\\", \\"author\\": \\"Harper Lee\\", \\"year\\": 1960, \\"genre\\": \\"Fiction\\", \\"ISBN\\": \\"1234567891\\"}, ] criteria_1 = {\\"title\\": \\"1984\\", \\"author\\": None, \\"year\\": None, \\"genre\\": None, \\"ISBN\\": None} criteria_2 = {\\"title\\": None, \\"author\\": \\"Harper Lee\\", \\"year\\": None, \\"genre\\": None, \\"ISBN\\": None} print(search_books(library, criteria_1)) # Should output: [{\'title\': \'1984\', \'author\': \'George Orwell\', \'year\': 1949, \'genre\': \'Dystopian\', \'ISBN\': \'1234567890\'}] print(search_books(library, criteria_2)) # Should output: [{\'title\': \'To Kill a Mockingbird\', \'author\': \'Harper Lee\', \'year\': 1960, \'genre\': \'Fiction\', \'ISBN\': \'1234567891\'}]"},{"question":"# Coding Assessment Question Scenario You are developing an application to manage a library inventory system. One of the requirements is to search for books by their titles effectively. Write a function that allows searching for book titles that start with a given prefix. Task Implement a Python function to search for book titles that start with a given prefix from a sorted list of book titles. Function Signature ```python def search_books_by_prefix(titles: List[str], prefix: str) -> List[str]: ``` Input - `titles`: A list of strings representing the book titles sorted in lexicographical order. - `prefix`: A string representing the prefix to search for. Output - A list of strings representing the book titles that start with the given prefix. Constraints - All book titles consist of lowercase Latin letters and spaces. - The prefix will be a non-empty string consisting of lowercase Latin letters. - The list of book titles will have at most 10^4 titles. - Each book title will have a length not exceeding 100 characters. Example ```python assert search_books_by_prefix([\\"a tale of two cities\\", \\"a study in scarlet\\", \\"moby dick\\", \\"the great gatsby\\"], \\"a\\") == [\\"a study in scarlet\\", \\"a tale of two cities\\"] assert search_books_by_prefix([\\"brave new world\\", \\"catch-22\\", \\"to kill a mockingbird\\"], \\"t\\") == [\\"to kill a mockingbird\\"] assert search_books_by_prefix([\\"dune\\", \\"frankenstein\\", \\"dracula\\"], \\"f\\") == [\\"frankenstein\\"] assert search_books_by_prefix([\\"game of thrones\\", \\"harry potter\\", \\"lord of the rings\\"], \\"b\\") == [] ``` Note Consider the efficiency of your search algorithm given the constraints. A linear scan of the list to find matches may not be optimal for large lists, so think of better searching techniques.","solution":"from typing import List def search_books_by_prefix(titles: List[str], prefix: str) -> List[str]: Searches for book titles that start with the given prefix. :param titles: List[str] - List of book titles sorted in lexicographical order :param prefix: str - The prefix to search for :return: List[str] - List of book titles that start with the given prefix left, right = 0, len(titles) - 1 result = [] # Use binary search to find the starting point while left < right: mid = left + (right - left) // 2 if titles[mid] < prefix: left = mid + 1 else: right = mid # From the starting point, collect all titles that match the prefix while left < len(titles) and titles[left].startswith(prefix): result.append(titles[left]) left += 1 return result"},{"question":"# Coding Assessment Question: Implementing a Custom Sort Function **Scenario:** You work on a file management system that deals with large numbers of files having different priorities. Each file has a unique priority score and you need to sort files based on these scores for quicker access and better organization. **Problem Statement:** Write a function named `custom_sort` that implements a custom sorting algorithm similar to merge sort. The function should take a list of tuples as input, where each tuple contains a file name and its associated priority score. The function should output a list of file names sorted in ascending order of their priority scores. **Function Signature:** ```python def custom_sort(files: List[Tuple[str, int]]) -> List[str]: ``` **Input:** - `files` (List[Tuple[str, int]]): A list of `n` tuples (0 ≤ n ≤ 10^5) where each tuple consists of: - `file_name` (str): The name of the file. Size of file name ≤ 100. - `priority_score` (int): An integer representing the priority score of the file. (-10^6 ≤ priority_score ≤ 10^6). **Output:** - A list of `file_names` sorted in ascending order according to their priority scores. **Constraints:** - If two files have the same priority score, they should appear in the same order as they are in the input list (stable sort). **Requirements:** - Implement a divide-and-conquer sorting algorithm similar to merge sort. - Demonstrate the ability to handle lists with up to 100,000 elements efficiently. **Examples:** ```python >>> custom_sort([(\'file1\', 3), (\'file2\', 1), (\'file3\', 2)]) [\'file2\', \'file3\', \'file1\'] >>> custom_sort([(\'red\', 10), (\'blue\', -5), (\'green\', 0), (\'yellow\', 0)]) [\'blue\', \'green\', \'yellow\', \'red\'] >>> custom_sort([]) [] ``` **Note:** - Ensure the sorting algorithm is efficient for large lists. - The function needs to handle edge cases like an empty list without errors. - Maintain the stability of the sort by preserving the original order of files with equal priority scores.","solution":"from typing import List, Tuple def custom_sort(files: List[Tuple[str, int]]) -> List[str]: if not files: return [] def merge_sort(arr): if len(arr) <= 1: return arr mid = len(arr) // 2 left = merge_sort(arr[:mid]) right = merge_sort(arr[mid:]) return merge(left, right) def merge(left, right): sorted_list = [] i = j = 0 while i < len(left) and j < len(right): if left[i][1] <= right[j][1]: sorted_list.append(left[i]) i += 1 else: sorted_list.append(right[j]) j += 1 sorted_list.extend(left[i:]) sorted_list.extend(right[j:]) return sorted_list sorted_files = merge_sort(files) return [file_name for file_name, _ in sorted_files]"},{"question":"# Question: Distinct Integer Sums in Triangular Numbers Background A triangular number or triangle number is a number that can form an equilateral triangle when represented as dots. The ( n )-th triangular number is given by the formula ( T_n = frac{n(n+1)}{2} ). For example, the first few triangular numbers are 1, 3, 6, 10, and 15. We want to find the smallest triangular number which can be represented as a sum of exactly `k` distinct triangular numbers. Task Write a function `smallest_triangular_sum(k: int) -> int` that returns the smallest possible triangular number which can be expressed as the sum of exactly `k` distinct triangular numbers. Input * An integer `k` (1 ≤ k ≤ 100) Output * Returns an integer representing the smallest triangular number that is the sum of exactly `k` distinct triangular numbers. Example ```python def smallest_triangular_sum(k: int) -> int: # Your code here # Example usage: print(smallest_triangular_sum(3)) # Expected output: 10 (1 + 3 + 6) ``` Constraints 1. Use only distinct triangular numbers in the sum. 2. The sum should be as small as possible while meeting constraints. Hints 1. Start by calculating the first few triangular numbers. 2. Use a greedy algorithm to find the minimum sum, or explore combinations efficiently using dynamic programming or backtracking approaches.","solution":"def triangular_number(n): return n * (n + 1) // 2 def smallest_triangular_sum(k: int) -> int: triangular_numbers = [triangular_number(i) for i in range(1, k+1)] return sum(triangular_numbers)"},{"question":"# Problem Statement: Implement a function `text_editor(commands: List[str]) -> str` that simulates a very simple text editor. The function should process a list of commands and return the final text. Each command in the list will be one of the following types: 1. `\\"APPEND text\\"`: Appends the given text to the current text. 2. `\\"DELETE k\\"`: Deletes the last `k` characters from the current text. 3. `\\"UNDO\\"`: Undoes the last operation (either `APPEND` or `DELETE`). You need to handle these operations correctly and return the final text. # Requirements: 1. **Handling Commands:** - Implement the `text_editor` function to process the list of commands and update the text accordingly. - Maintain a history of operations to be able to undo them when required. 2. **Operations Order:** - Commands should be processed in the order they appear in the list. - The `UNDO` command should reverse the last `APPEND` or `DELETE` operation performed. # Input/Output Formats: * **Input:** - `commands`: A list of strings, where each string is a command of the form `\\"APPEND text\\"`, `\\"DELETE k\\"`, or `\\"UNDO\\"`. * **Output:** - A single string representing the final text after all commands have been processed. # Constraints: - The total number of commands will not exceed 1000. - The length of the text to be appended by a single `APPEND` operation will not exceed 100 characters. - The value of `k` for the `DELETE` command will be such that it will not delete more characters than currently exist in the text. # Example Usage: ```python commands = [ \\"APPEND Hello\\", \\"APPEND World\\", \\"DELETE 5\\", \\"UNDO\\", \\"APPEND !!\\", ] result = text_editor(commands) print(result) # Should output \\"HelloWorld!!\\" ``` # Sample Test Cases: ```python # Test Case 1 commands = [\\"APPEND abc\\", \\"APPEND def\\", \\"DELETE 3\\", \\"UNDO\\", \\"APPEND gh\\"] assert text_editor(commands) == \\"abcdefgh\\" # Test Case 2 commands = [\\"APPEND xyz\\", \\"DELETE 1\\", \\"UNDO\\"] assert text_editor(commands) == \\"xyz\\" # Test Case 3 commands = [\\"APPEND pqr\\", \\"DELETE 2\\", \\"APPEND st\\", \\"UNDO\\", \\"UNDO\\"] assert text_editor(commands) == \\"pq\\" # Test Case 4 commands = [\\"APPEND a\\", \\"APPEND b\\", \\"APPEND c\\", \\"UNDO\\", \\"UNDO\\", \\"UNDO\\"] assert text_editor(commands) == \\"\\" ``` **Note:** Ensure that the `UNDO` operation can handle consecutive calls accurately and returns the correct text after all operations are processed.","solution":"def text_editor(commands): Simulates a simple text editor that processes a list of commands and returns the final text. Args: commands (list of str): List of commands to be processed. Returns: str: The final text after all commands have been processed. text = \\"\\" history = [] for command in commands: if command.startswith(\\"APPEND\\"): _, to_append = command.split(maxsplit=1) history.append((\\"APPEND\\", to_append)) text += to_append elif command.startswith(\\"DELETE\\"): _, count = command.split() count = int(count) deleted_text = text[-count:] history.append((\\"DELETE\\", deleted_text)) text = text[:-count] elif command == \\"UNDO\\": if history: last_command, last_value = history.pop() if last_command == \\"APPEND\\": text = text[:-len(last_value)] elif last_command == \\"DELETE\\": text += last_value return text"},{"question":"# Prime Factorial Count You are tasked with writing a function that calculates the number of times a given prime number p appears in the factorial of a given number n. Function Signature: ```python def prime_factor_count(n: int, p: int) -> int: # your code here ``` Parameters: - `n` (int): A non-negative integer representing the number n. - `p` (int): A prime number for which you need to find its count in the factorial of n. Returns: - `int`: The count of the prime number p in the factorial of n. Constraints: - 0 ≤ n ≤ ( 10^7 ) - 2 ≤ p ≤ ( 10^7 ), and p is always prime. Example: ```python # Example Input n = 10 p = 2 # Expected Output 8 # Explanation: # The factorial of 10 (10!) is 3628800. # In the prime factorization of 3628800, the number 2 appears 8 times: # 3628800 = 2^8 * 3^4 * 5^2 * 7 # Therefore, the function should return 8. ``` Notes: - Prime factorization of a number n! involves counting the number of multiples of p, p^2, p^3, ..., up to p^k, where p^k ≤ n. - The count of the prime p in n! is calculated by summing the integer division results of n by p, p^2, p^3, ..., until p^k > n. - Ensure your implementation handles large values of n efficiently.","solution":"def prime_factor_count(n: int, p: int) -> int: Calculate the number of times a prime number p appears in the factorial of n. count = 0 power = p while n >= power: count += n // power power *= p return count"},{"question":"# Problem Statement You are given a string consisting of lowercase English letters and a target number `n`. Your task is to design and implement a function `nth_distinct_character` that returns the `n`-th distinct character in the string (considering all unique characters present in the string). If there are fewer than `n` distinct characters in the string, the function should return an empty string. **Function Signature:** ```python def nth_distinct_character(s: str, n: int) -> str: pass ``` **Input:** * `s`: A string consisting of lowercase English letters (0 <= len(s) <= 10^5). * `n`: An integer representing the position of the distinct character to find (1 <= n <= 26). **Output:** * A single character that is the `n`-th distinct character in the string, or an empty string if there are fewer than `n` distinct characters. **Constraints:** - All characters in the string `s` are lowercase English letters. - `n` is between 1 and 26 (inclusive). **Example:** ```python assert nth_distinct_character(\\"hello\\", 1) == \'h\' assert nth_distinct_character(\\"hello\\", 3) == \'o\' assert nth_distinct_character(\\"banana\\", 2) == \'n\' assert nth_distinct_character(\\"abc\\", 4) == \'\' assert nth_distinct_character(\\"\\", 1) == \'\' assert nth_distinct_character(\\"aabbcc\\", 3) == \'c\' ``` **Explanation**: The function should identify unique characters in the order they appear in the input string `s`. It should then return the `n`-th unique character if `n` is a valid position within the unique characters. If `n` exceeds the number of unique characters, the function should return an empty string. The function handles normal strings as well as edge cases such as empty input or where `n` is larger than the total number of distinct characters.","solution":"def nth_distinct_character(s: str, n: int) -> str: Return the n-th distinct character in the string s. If there are fewer than n distinct characters, return an empty string. distinct_chars = [] seen_chars = set() for char in s: if char not in seen_chars: distinct_chars.append(char) seen_chars.add(char) if n <= len(distinct_chars): return distinct_chars[n-1] else: return \'\'"},{"question":"# Problem Statement You have been hired to implement a text normalization system that processes textual data and produces a clean and structured output. Text normalization typically involves converting all characters to lowercase, removing punctuation, and ensuring consistent spacing. # Tasks 1. **Normalize Function**: Implement a function `normalize_text(text: str) -> str` that takes a string and returns the normalized version of it. 2. **Tokenize Function**: Implement a complementary function `tokenize_text(text: str) -> list` that splits the normalized text into tokens and returns a list of these tokens. # Input and Output Formats - **Input for Normalization**: - A non-empty string `text` containing alphabetical characters, digits, punctuation, and whitespace. - **Output for Normalization**: - A string where all characters are converted to lowercase and all punctuation is removed. Multiple spaces should be reduced to a single space. - **Input for Tokenization**: - A string of normalized text returned from the `normalize_text` function. - **Output for Tokenization**: - A list of strings (tokens), where each token is a sequence of consecutive alphabetical characters or digits, split by spaces. # Performance Requirements - The functions should run efficiently with an expected time complexity of O(n). - The space complexity should be O(n), meaning the total space utilized should be proportional to the size of the input. # Example - **Normalization** ```python input_text = \\"Hello, World!! Isn\'t this an amazing, task? Yes, it is.\\" output = normalize_text(input_text) print(output) # Output: \\"hello world isnt this an amazing task yes it is\\" ``` - **Tokenization** ```python normalized_text = \\"hello world isnt this an amazing task yes it is\\" output = tokenize_text(normalized_text) print(output) # Output: [\\"hello\\", \\"world\\", \\"isnt\\", \\"this\\", \\"an\\", \\"amazing\\", \\"task\\", \\"yes\\", \\"it\\", \\"is\\"] ``` # Constraints - The input string for the normalization function will have a length between 1 and 10^6. - The normalized text used as input for the tokenization function will have a length between 1 and 10^6. # Tests Write tests to ensure your implementation works correctly: - Test with a string containing various punctuation marks. - Test with a string containing multiple consecutive spaces. - Test with a string that is already normalized. - Test with very large strings within the specified constraints.","solution":"import re def normalize_text(text: str) -> str: Returns a normalized version of the input text with all characters in lowercase, punctuation removed, and multiple spaces reduced to a single space. # Convert text to lowercase text = text.lower() # Remove punctuation using regex text = re.sub(r\'[^ws]\', \'\', text) # Replace multiple spaces with a single space text = re.sub(r\'s+\', \' \', text) # Strip leading and trailing spaces text = text.strip() return text def tokenize_text(text: str) -> list: Split the normalized text into tokens and return a list of these tokens. # Split text by spaces to get the tokens tokens = text.split(\' \') return tokens"},{"question":"# Weather Data Analysis and Plotting Task You are tasked with creating a small utility to fetch and analyze weather data from a provided API endpoint, and then visualize this data to identify trends in temperature over a set period. Implement the following two functions: 1. **fetch_weather_data**: This function should make an HTTP request to a given URL to retrieve weather data, such as daily temperatures over the past week, and return this data in a structured format. * **Input**: A string representing the URL of the weather API. * **Output**: A list of dictionaries, each containing the date (str) and temperature (float). * **Constraints**: - Ensure the function handles network timeouts appropriately. - The function must correctly parse the required elements from the JSON response. 2. **plot_temperature_trends**: This function should take the weather data returned by `fetch_weather_data` and plot a graph showing the temperature trends over the past week. * **Input**: A list of dictionaries containing the date and temperature. * **Output**: None (side effect of displaying the plot). * **Constraints**: - The function must handle cases where there is missing or incomplete data. - Ensure the plot is well-labeled with dates on the x-axis and temperatures on the y-axis. # Example ```python # Example usage if __name__ == \\"__main__\\": weather_url = \\"https://example-weather-api.com/data/last_week\\" weather_data = fetch_weather_data(weather_url) plot_temperature_trends(weather_data) ``` # Notes - Use common libraries like `requests` for HTTP requests and `matplotlib` for plotting. - Ensure robust error handling and consider edge cases such as malformed JSON responses. - For testing purposes, you can use mock URLs or predefined JSON content to simulate different scenarios. - Performance considerations: minimize the number of API calls and handle network-related delays efficiently.","solution":"import requests import matplotlib.pyplot as plt from typing import List, Dict def fetch_weather_data(url: str) -> List[Dict[str, float]]: Fetch weather data from the provided URL. Parameters: url (str): The URL of the weather API. Returns: List[Dict[str, float]]: A list of dictionaries containing the date (str) and temperature (float). try: response = requests.get(url, timeout=10) response.raise_for_status() # Raise HTTPError for bad responses data = response.json() weather_data = [] for entry in data: if \'date\' in entry and \'temperature\' in entry: weather_data.append({ \'date\': entry[\'date\'], \'temperature\': float(entry[\'temperature\']) }) return weather_data except requests.RequestException as e: print(f\\"An error occurred: {e}\\") return [] def plot_temperature_trends(weather_data: List[Dict[str, float]]): Plot temperature trends over the past week. Parameters: weather_data (List[Dict[str, float]]): A list of dictionaries containing the date and temperature. Returns: None if not weather_data: print(\\"No data available to plot.\\") return dates = [entry[\'date\'] for entry in weather_data] temperatures = [entry[\'temperature\'] for entry in weather_data] plt.figure(figsize=(10, 5)) plt.plot(dates, temperatures, marker=\'o\', linestyle=\'-\', color=\'b\') plt.xlabel(\'Date\') plt.ylabel(\'Temperature (°C)\') plt.title(\'Temperature Trends Over the Past Week\') plt.xticks(rotation=45) plt.tight_layout() plt.grid(True) plt.show()"},{"question":"# Coding Question **Context**: Emily is a developer working on a large-scale analysis project where she needs to frequently aggregate and summarize data quickly. To make her work easier, she wants to write a function that will handle common aggregations on a list of numbers. **Task**: Write a Python function `aggregate_numbers` that: 1. Computes the sum, minimum, maximum, and average of a given list of numbers. 2. Returns the results as a dictionary. 3. Handles empty lists gracefully by returning `None` for all values. **Function Signature**: ```python def aggregate_numbers(numbers: list) -> dict: Computes the sum, minimum, maximum, and average of a given list of numbers. Returns a dictionary with keys \'sum\', \'min\', \'max\', and \'average\'. :param numbers: list - the list of numbers to aggregate :return: dict - a dictionary containing the sum, min, max, and average of the numbers, or None for each key if the list is empty pass ``` **Constraints**: * The function should handle lists with negative numbers. * The function should handle lists with zero correctly. * Ensure the function returns the correct type and accurate values. **Example**: When calling `aggregate_numbers([1, 2, 3, 4, 5])`, the function should return: ```python { \'sum\': 15, \'min\': 1, \'max\': 4, \'average\': 3.0 } ``` When calling `aggregate_numbers([-10, 20, 0, 5])`, the function should return: ```python { \'sum\': 15, \'min\': -10, \'max\': 20, \'average\': 3.75 } ``` When calling `aggregate_numbers([])`, the function should return: ```python { \'sum\': None, \'min\': None, \'max\': None, \'average\': None } ``` Ensure the function is efficient and handles large lists of numbers without significant performance degradation.","solution":"def aggregate_numbers(numbers: list) -> dict: Computes the sum, minimum, maximum, and average of a given list of numbers. Returns a dictionary with keys \'sum\', \'min\', \'max\', and \'average\'. :param numbers: list - the list of numbers to aggregate :return: dict - a dictionary containing the sum, min, max, and average of the numbers, or None for each key if the list is empty if not numbers: return { \'sum\': None, \'min\': None, \'max\': None, \'average\': None } total_sum = sum(numbers) minimum = min(numbers) maximum = max(numbers) average = total_sum / len(numbers) return { \'sum\': total_sum, \'min\': minimum, \'max\': maximum, \'average\': average }"},{"question":"# Fibonacci-like Array Check A Fibonacci-like sequence is a sequence of integers where each element is the sum of the previous two elements. As a programmer, your task is to write a function that checks if a given list of integers is a Fibonacci-like sequence. The sequence should have at least three elements to be considered Fibonacci-like. Requirements: 1. The input will be a list of integers. 2. The output should be a boolean value: `True` if the array is Fibonacci-like, otherwise `False`. 3. The solution should efficiently handle large input sizes. Constraints: * The array can have up to (10^6) elements. * The elements of the array will be integers between (-10^9) and (10^9). Function Signature: ```python def is_fibonacci_like(arr: list[int]) -> bool: # Your code goes here ``` # Example: Input: ```python arr = [1, 1, 2, 3, 5, 8] ``` Output: ```python True ``` *Explanation*: The given sequence follows the Fibonacci-like property where each element is the sum of the previous two elements: ``` 1 + 1 = 2, 1 + 2 = 3, 2 + 3 = 5, 3 + 5 = 8 ``` # Additional Examples: Example 1: ```python arr = [2, 4, 6, 10, 16] ``` *Output*: ```python False ``` *Explanation*: The given sequence does not follow the Fibonacci-like property. Example 2: ```python arr = [0, 1, 1, 2, 3, 5, 8] ``` *Output*: ```python True ``` *Explanation*: The given sequence follows the Fibonacci-like property. Additional Notes: * Please ensure to handle edge cases where the array could be empty or have fewer than three elements. Use the following code template to get started: ```python def is_fibonacci_like(arr: list[int]) -> bool: Check if an array is a Fibonacci-like sequence. Args: arr (list[int]): The input array of integers. Returns: bool: True if the sequence is Fibonacci-like, False otherwise. if len(arr) < 3: return False for i in range(2, len(arr)): if arr[i] != arr[i-1] + arr[i-2]: return False return True ```","solution":"def is_fibonacci_like(arr: list[int]) -> bool: Check if an array is a Fibonacci-like sequence. Args: arr (list[int]): The input array of integers. Returns: bool: True if the sequence is Fibonacci-like, False otherwise. if len(arr) < 3: return False for i in range(2, len(arr)): if arr[i] != arr[i-1] + arr[i-2]: return False return True"},{"question":"# Implementing a Custom Binary Tree Traversal Context You are tasked with implementing a unique traversal method for a binary tree as part of a new algorithm that optimizes specific operations in a data structure you are designing. This traversal, called the \\"zigzag level order traversal,\\" combines properties of both breadth-first and depth-first searches. Problem Statement Implement a function `zigzag_level_order` which takes the root node of a binary tree as input and returns a list of lists, where each sublist contains the values of the nodes at each level of the tree. The traversal should follow these rules: 1. Start at the root node (level 0), and traverse each level alternately from left to right and right to left. 2. For even-indexed levels (0, 2, 4, ...), traverse from left to right. 3. For odd-indexed levels (1, 3, 5, ...), traverse from right to left. Requirements 1. **Input and Output Formats**: - Input for `zigzag_level_order`: The root node of a binary tree where nodes contain integer values. - Output for `zigzag_level_order`: A list of lists, each containing the node values at each tree level in zigzag order. 2. **Constraints**: - The tree can have zero or more nodes. - Node values are integers within the range `-10^5` to `10^5`. 3. **Performance**: - Ensure the function runs efficiently with a time complexity of O(N), where N is the number of nodes in the tree. - Implement an auxiliary function to handle node insertions or tree creation for testing purposes. Example ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def zigzag_level_order(root: TreeNode) -> list[list[int]]: # Implement this function pass # Example usage: # Creating a binary tree for testing purposes # 1 # / # 2 3 # / / # 4 5 6 7 root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) root.right.left = TreeNode(6) root.right.right = TreeNode(7) result = zigzag_level_order(root) # Expected output: [[1], [3, 2], [4, 5, 6, 7]] ``` Notes - Pay special attention to alternating the traversal direction on each level. - Consider edge cases such as an empty tree or a tree with only one node. - Optimize the solution for both time and space, ensuring it handles large trees efficiently.","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def zigzag_level_order(root: TreeNode) -> list[list[int]]: if not root: return [] result = [] queue = deque([root]) left_to_right = True while queue: level_size = len(queue) level_nodes = deque() for _ in range(level_size): node = queue.popleft() if left_to_right: level_nodes.append(node.val) else: level_nodes.appendleft(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(list(level_nodes)) left_to_right = not left_to_right return result"},{"question":"# Problem Statement You are given a list of strings where each string represents a binary number. The task is to find the binary number in the list that has the highest decimal value and return it in binary format without any leading zeros. # Function Signature ```python def highest_binary_value(binaries: List[str]) -> str: pass ``` # Input * `binaries`: A list of binary strings (`1 <= len(binaries) <= 10^4`, each string\'s length is between 1 and 32 characters, consisting only of \'0\'s and \'1\'s). # Output * Return the binary string that represents the highest decimal value. # Constraints 1. The binary strings do not contain leading zeros except for the string \\"0\\". 2. The comparison should be efficient and take into account the size of binary numbers. 3. Return the binary number without any leading zeros, except for the special case \\"0\\". # Example ```python assert highest_binary_value([\\"101\\", \\"111\\", \\"10\\", \\"110\\", \\"0\\"]) == \\"111\\" assert highest_binary_value([\\"001\\", \\"010\\", \\"011\\", \\"100\\", \\"101\\"]) == \\"101\\" assert highest_binary_value([\\"0\\", \\"1\\", \\"10\\", \\"1100\\"]) == \\"1100\\" assert highest_binary_value([\\"1010\\", \\"0110\\", \\"1111\\", \\"0001\\"]) == \\"1111\\" ``` # Description 1. Convert each binary string into its decimal value. 2. Compare the decimal values to find the highest one. 3. Return the binary string corresponding to the highest decimal value without any leading zeros. 4. Ensure to handle all edge cases, including the case with only one binary string in the list or if all strings are \\"0\\".","solution":"from typing import List def highest_binary_value(binaries: List[str]) -> str: # Convert all binaries to (decimal_value, binary_string) tuples decimal_values = [(int(b, 2), b) for b in binaries] # Find the tuple with the maximum decimal value max_value_tuple = max(decimal_values, key=lambda x: x[0]) # Return the binary string of the tuple with the maximum decimal value return max_value_tuple[1]"},{"question":"# Problem Statement You are given a list of integers representing different heights of water columns. Your task is to compute the amount of water trapped after raining. Each value in the list represents the height of a water column at that position. Objective Write a function `water_trapped(heights: List[int]) -> int` that calculates the total units of water trapped between the columns. Input - `heights`: A list of non-negative integers representing the height of each column. Output - An integer representing the total amount of water trapped. Constraints - The length of `heights` is between 1 and 10^5 inclusive. - Each height value is a non-negative integer between 0 and 10^4 inclusive. - The solution should efficiently handle the upper limit of the input constraints. Requirements 1. Implement the function `water_trapped` to solve the problem with a time complexity of O(n), where n is the number of columns. 2. Use appropriate space complexity to handle large inputs. # Example ```python water_trapped([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) # Output: 6 water_trapped([4, 2, 0, 3, 2, 5]) # Output: 9 water_trapped([2, 0, 2]) # Output: 2 ```","solution":"def water_trapped(heights): Returns the total units of water trapped between columns. if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i-1], heights[i]) right_max[-1] = heights[-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], heights[i]) water = 0 for i in range(n): water += min(left_max[i], right_max[i]) - heights[i] return water"},{"question":"# Palindrome Number Detection **Overview**: A palindrome number is a number that remains the same when its digits are reversed. For example, 121 is a palindrome while 123 is not. **Task**: Write a function `find_first_n_palindrome_numbers(n: int) -> List[int]` that returns the first `n` palindrome numbers in ascending order. Your function should: 1. Validate the input to ensure `n` is a positive integer. 2. Utilize the principles of detecting palindrome numbers to find the first `n` palindrome numbers. 3. Return a list of the first `n` palindrome numbers. **Function Signature**: ```python def find_first_n_palindrome_numbers(n: int) -> List[int]: ``` **Input**: - `n` (integer): The number of palindrome numbers to find. **Output**: - List of integers: A list containing the first `n` palindrome numbers in ascending order. **Example**: ```python >>> find_first_n_palindrome_numbers(5) [1, 2, 3, 4, 5] >>> find_first_n_palindrome_numbers(10) [1, 2, 3, 4, 5, 6, 7, 8, 9, 11] ``` **Constraints**: - `1 <= n <= 100` **Requirements**: 1. Your function should include proper validation to handle invalid input and raise appropriate errors. 2. The solution should be efficient in terms of both time and space. **Hints**: - Check if a number is a palindrome by converting it to a string and comparing it to its reverse. - Iterate over positive integers sequentially to find the first `n` palindrome numbers. **Scenario/Context**: Imagine you\'re developing a feature for a mathematics learning app that requires generating lists of palindrome numbers to introduce students to this concept. Implement these capabilities to enhance the educational tool.","solution":"from typing import List def find_first_n_palindrome_numbers(n: int) -> List[int]: Returns the first n palindrome numbers in ascending order. if not isinstance(n, int) or n <= 0: raise ValueError(\\"n should be a positive integer\\") def is_palindrome(num: int) -> bool: s = str(num) return s == s[::-1] result = [] num = 1 while len(result) < n: if is_palindrome(num): result.append(num) num += 1 return result"},{"question":"**Dynamic Programming: Longest Increasing Subsequence** To efficiently manage inventory in a large warehouse, you decided to analyze the trends in product demand over time. The goal is to identify the longest period over which demand consistently increases. This will help in understanding the patterns and optimizing stock levels. # Problem Statement Given an array `demand` where each element represents the demand for a product at a given time, calculate the length of the longest increasing subsequence in the array. The increasing subsequence does not need to be contiguous in the original array. # Task Implement the function `longest_increasing_subsequence(demand: List[int]) -> int` that returns the length of the longest increasing subsequence. # Expected Input and Output Formats ```python def longest_increasing_subsequence(demand: List[int]) -> int: pass ``` - `demand`: A list of integers where each integer represents the demand for a product at a given time. **Output**: An integer representing the length of the longest increasing subsequence. # Constraints 1. `1 <= len(demand) <= 1000` 2. `0 <= demand[i] <= 10^6` # Performance Requirements Your solution should run efficiently, preferably in O(n log n) time complexity using dynamic programming with binary search, though an O(n^2) solution is acceptable for this problem size. # Scenario You are managing a warehouse and observing the demand trends of various products over a period. The analysis of these trends will help in making informed decisions on stocking and inventory controls for maximizing efficiency and meeting customer demands. # Example ```python demand = [10, 22, 9, 33, 21, 50, 41, 60, 80] print(longest_increasing_subsequence(demand)) # Output: 6 ``` In this example, the longest increasing subsequence is `[10, 22, 33, 50, 60, 80]`, which has a length of 6.","solution":"from typing import List def longest_increasing_subsequence(demand: List[int]) -> int: if not demand: return 0 n = len(demand) lis = [1] * n for i in range(1, n): for j in range(i): if demand[i] > demand[j]: lis[i] = max(lis[i], lis[j] + 1) return max(lis)"},{"question":"Context You are tasked with developing an inventory management system for a retail store. The system should keep track of the stock levels of various products and provide functionality to add new stock, remove stock, and check current stock levels. Each product is identified by a unique product code, and the quantities are always whole numbers. Task Create a class `Inventory` that supports inventory management operations. Implement the following methods: - `add_stock(product_code: str, quantity: int) -> None`: Adds the specified quantity of stock to the product identified by `product_code`. - `remove_stock(product_code: str, quantity: int) -> bool`: Removes the specified quantity of stock from the product identified by `product_code`. If the quantity to be removed exceeds the available stock, it should not remove any stock and return `False`. Otherwise, it should return `True` after successfully removing the stock. - `check_stock(product_code: str) -> int`: Returns the current stock level of the product identified by `product_code`. If the product code does not exist in the inventory, it should return `0`. Function Signature ```python class Inventory: def __init__(self): self.stock = {} def add_stock(self, product_code: str, quantity: int) -> None: pass def remove_stock(self, product_code: str, quantity: int) -> bool: pass def check_stock(self, product_code: str) -> int: pass ``` Input - `product_code`: A string representing the unique identifier of a product. - `quantity`: An integer representing the quantity of stock to add or remove. Output - Methods should perform their respective operations as described and return appropriate values. Example ```python inventory = Inventory() inventory.add_stock(\\"A001\\", 50) print(inventory.check_stock(\\"A001\\")) # Output: 50 inventory.remove_stock(\\"A001\\", 20) print(inventory.check_stock(\\"A001\\")) # Output: 30 result = inventory.remove_stock(\\"A001\\", 40) print(result) # Output: False print(inventory.check_stock(\\"A001\\")) # Output: 30 inventory.add_stock(\\"A002\\", 100) print(inventory.check_stock(\\"A002\\")) # Output: 100 ``` Notes - Ensure that the `Inventory` class simplifies interaction through its methods. - Handle edge cases such as adding or removing zero or negative quantities appropriately (in such cases, the inventory should remain unchanged). Good luck with managing your inventory efficiently!","solution":"class Inventory: def __init__(self): self.stock = {} def add_stock(self, product_code: str, quantity: int) -> None: if quantity <= 0: return if product_code in self.stock: self.stock[product_code] += quantity else: self.stock[product_code] = quantity def remove_stock(self, product_code: str, quantity: int) -> bool: if quantity <= 0: return False if product_code in self.stock and self.stock[product_code] >= quantity: self.stock[product_code] -= quantity return True return False def check_stock(self, product_code: str) -> int: return self.stock.get(product_code, 0)"},{"question":"# Problem Statement Write a function that takes a list of event objects describing entertainment events and sorts them based on multiple criteria. # Task Description 1. **Function: `sort_events(events: List[dict]) -> List[dict]`** - Sort the provided list of event objects based on the following criteria: - **Start Date and Time**: Events starting earlier should come first. - **Duration**: For events starting at the same time, those with shorter durations come first. - **Alphabetical Order**: For events starting at the same time and with the same duration, those with names that come first alphabetically should come first. - An event object contains the following keys: - `name` (str): The name of the event. - `start` (str): The start time of the event in the format \'YYYY-MM-DD HH:MM:SS\'. - `duration` (int): The duration of the event in minutes. # Input - A list of dictionaries `events`, where each dictionary represents an event. # Output - A list of dictionaries sorted by the specified criteria. # Example The input list of events: ```python events = [ {\\"name\\": \\"Music Concert\\", \\"start\\": \\"2023-03-21 20:00:00\\", \\"duration\\": 90}, {\\"name\\": \\"Art Exhibition\\", \\"start\\": \\"2023-03-21 20:00:00\\", \\"duration\\": 60}, {\\"name\\": \\"Workshop\\", \\"start\\": \\"2023-03-21 18:00:00\\", \\"duration\\": 120}, {\\"name\\": \\"Gallery Opening\\", \\"start\\": \\"2023-03-22 10:00:00\\", \\"duration\\": 120} ] ``` After sorting by start date and time, duration, and then name, the output should be: ```python [ {\\"name\\": \\"Workshop\\", \\"start\\": \\"2023-03-21 18:00:00\\", \\"duration\\": 120}, {\\"name\\": \\"Art Exhibition\\", \\"start\\": \\"2023-03-21 20:00:00\\", \\"duration\\": 60}, {\\"name\\": \\"Music Concert\\", \\"start\\": \\"2023-03-21 20:00:00\\", \\"duration\\": 90}, {\\"name\\": \\"Gallery Opening\\", \\"start\\": \\"2023-03-22 10:00:00\\", \\"duration\\": 120} ] ``` # Constraints - The list of events will contain at most 1000 event objects. - The `start` time will be given in a valid \'YYYY-MM-DD HH:MM:SS\' format. - Assume `name` will be unique for each event. # Exception Handling - Raise `ValueError` if any event object in the list is missing required keys (`\'name\'`, `\'start\'`, `\'duration\'`). - Raise `ValueError` if the `start` key value is not in the correct \'YYYY-MM-DD HH:MM:SS\' format. - Raise `TypeError` if the `duration` is not an integer or `name` is not a string.","solution":"from typing import List, Dict import datetime def sort_events(events: List[Dict[str, str]]) -> List[Dict[str, str]]: def validate_event(event: Dict[str, str]): required_keys = [\'name\', \'start\', \'duration\'] for key in required_keys: if key not in event: raise ValueError(f\\"Event object is missing required key: {key}\\") try: datetime.datetime.strptime(event[\'start\'], \'%Y-%m-%d %H:%M:%S\') except ValueError: raise ValueError(f\\"The start time {event[\'start\']} is not in the valid format \'YYYY-MM-DD HH:MM:SS\'\\") if not isinstance(event[\'name\'], str): raise TypeError(f\\"The name {event[\'name\']} is not a string\\") if not isinstance(event[\'duration\'], int): raise TypeError(f\\"The duration {event[\'duration\']} is not an integer\\") for event in events: validate_event(event) return sorted(events, key=lambda x: (x[\'start\'], x[\'duration\'], x[\'name\']))"},{"question":"Alternating Digit Sum Objective Write a Python function to calculate the alternating sum and difference of the digits of a given integer, starting from the leftmost digit. If the integer is negative, the function should consider the absolute value. # Detailed Description **Task**: Create a function `alternating_digit_sum` that takes a single integer input and computes the alternating sum, starting with an addition of the first digit, then subtraction of the second, addition of the third, and so on. Constraints: * The function should handle both positive and negative integers. * Ensure the solution correctly iterates over each digit in the integer. * Manage any possible edge cases, such as single-digit inputs and zeros. Function Signature: ```python def alternating_digit_sum(n: int) -> int: pass ``` # Input: * An integer `n`, which can be positive or negative. [ -10^6 leq n leq 10^6 ] # Output: * Integer representing the alternating sum and difference of the digits of `n`. # Example Usage: ```python print(alternating_digit_sum(1234)) # Expected output: 2 (i.e., 1 - 2 + 3 - 4 = -2) print(alternating_digit_sum(-56789)) # Expected output: 2 (i.e., 5 - 6 + 7 - 8 + 9 = 7) ``` # Hints: * Use the absolute value of `n` to simplify digit extraction. * Convert the integer to a string to easily iterate over each digit. * Accumulate the result using alternating addition and subtraction operations. # Example Walkthrough: For `n = 1234`: * Convert to string: \\"1234\\" * Compute alternating sum: (1 - 2 + 3 - 4 = -2) For `n = -56789`: * Convert to string (ignoring sign): \\"56789\\" * Compute alternating sum: (5 - 6 + 7 - 8 + 9 = 7)","solution":"def alternating_digit_sum(n: int) -> int: Returns the alternating sum and difference of the digits of a given integer n, starting from the leftmost digit. # Convert the number to its absolute value and then to a string to iterate over digits abs_str = str(abs(n)) # Initialize the result result = 0 # Iterate over the digits for i in range(len(abs_str)): # Convert the current character to an integer digit = int(abs_str[i]) # Add or subtract the digit based on the position if i % 2 == 0: result += digit else: result -= digit return result"},{"question":"# Coding Assessment Question **Scenario**: You are tasked with developing a warehouse management system to efficiently track the inventory. One important feature is the ability to automatically reorder items when their inventory falls below a certain threshold. To achieve this, you need to write several functions that handle the process of checking inventory levels, placing orders, and calculating the total cost of items ordered. # Task Implement three functions: `check_inventory`, `place_order`, and `calculate_cost`. # Specifications 1. **check_inventory**: * **Input**: - `inventory` (dict): A dictionary where keys are item names (strings) and values are the quantities (integers) in stock. - `thresholds` (dict): A dictionary where keys are item names (strings) and values are the reorder thresholds (integers). * **Output**: - List of item names (strings) that need to be reordered. * **Constraints**: - Both dictionaries will have the same set of item names. - Ensure to account for non-positive inventory quantities properly. 2. **place_order**: * **Input**: - `items_to_order` (list): A list of item names (strings) that need to be reordered. - `unit_prices` (dict): A dictionary where keys are item names (strings) and values are the price per unit (floats). - `order_quantity` (int): The number of units to order for each item. * **Output**: - Dictionary where keys are item names (strings) and values are the total costs (floats) for the ordered quantity. * **Constraints**: - Ensure to validate that the `order_quantity` is a positive integer. - All items in the `items_to_order` list will have corresponding prices in the `unit_prices` dictionary. 3. **calculate_cost**: * **Input**: - `order_costs` (dict): A dictionary where keys are item names (strings) and values are the total costs (floats) for the ordered quantities. * **Output**: - Total cost (float) for all ordered items. * **Constraints**: - Ensure to handle edge cases where the dictionary might be empty. # Implementation Write your solution in Python. The overall time complexity for each function should be efficient and reasonable given the operations required. # Example Usage ```python inventory = {\\"item_A\\": 5, \\"item_B\\": 2, \\"item_C\\": 0} thresholds = {\\"item_A\\": 10, \\"item_B\\": 3, \\"item_C\\": 1} unit_prices = {\\"item_A\\": 2.5, \\"item_B\\": 1.75, \\"item_C\\": 3.0} items_to_order = check_inventory(inventory, thresholds) print(items_to_order) # Output: [\'item_A\', \'item_B\', \'item_C\'] order_quantity = 5 order_costs = place_order(items_to_order, unit_prices, order_quantity) print(order_costs) # Output: {\'item_A\': 12.5, \'item_B\': 8.75, \'item_C\': 15.0} total_cost = calculate_cost(order_costs) print(total_cost) # Output: 36.25 ```","solution":"def check_inventory(inventory, thresholds): Returns a list of item names that need to be reordered based on inventory levels and thresholds. items_to_reorder = [] for item, quantity in inventory.items(): if quantity <= thresholds[item]: items_to_reorder.append(item) return items_to_reorder def place_order(items_to_order, unit_prices, order_quantity): Returns a dictionary where keys are item names and values are the total costs for the ordered quantity. if order_quantity <= 0: raise ValueError(\\"Order quantity must be a positive integer\\") order_costs = {} for item in items_to_order: order_costs[item] = unit_prices[item] * order_quantity return order_costs def calculate_cost(order_costs): Returns the total cost for all ordered items. return sum(order_costs.values())"},{"question":"# Coding Challenge Consider the problem where you need to identify unique substrings from a given string with a certain length constraint. A substring is defined as a contiguous sequence of characters within a string. **Objective**: Write a function `unique_substrings(s: str, k: int) -> List[str]` that: * **Input**: - `s`: A string consisting of lowercase English letters. - `k`: The length of substrings to be considered, an integer (1 ≤ k ≤ 10). * **Output**: Returns a list of unique substrings of length `k` in lexicographical order. # Example Usage: ```python assert unique_substrings(\\"abcabc\\", 2) == [\'ab\', \'bc\', \'ca\'] assert unique_substrings(\\"banana\\", 3) == [\'ana\', \'ban\', \'nan\'] assert unique_substrings(\\"abcdef\\", 4) == [\'abcd\', \'bcde\', \'cdef\'] ``` # Constraints: 1. Substrings should be of the specified length `k`. 2. Return a list of substrings in lexicographical order. 3. Ensure the substrings are unique. # Guidelines: - Utilize sliding window or set data structures to extract unique substrings. - Sort the resulting substrings in lexicographical order before returning. - Optimize the solution for performance given the constraints. **Note**: Handle cases where the length `k` exceeds the length of the string `s` by returning an empty list.","solution":"def unique_substrings(s: str, k: int) -> list: Returns a list of unique substrings of length `k` in lexicographical order. Parameters: s (str): The input string. k (int): The length of substrings to consider. Returns: list: A list of unique substrings of length `k` sorted in lexicographical order. if k > len(s): return [] substrings = set() for i in range(len(s) - k + 1): substrings.add(s[i:i + k]) return sorted(substrings)"},{"question":"# Coding Question You are given an integer array `nums`, where each element represents the value of a coin. You need to determine whether it is possible to exact change for a given amount using any combination of these coins. Implement a function to check if the exact change is achievable. The function should use Dynamic Programming for efficiency. Function Signature ```python def can_make_change(nums: List[int], amount: int) -> bool: pass ``` Task 1. **Determine Exact Change**: - Implement the `can_make_change` function to determine if you can achieve the exact given `amount` using any combination of coins in `nums`. - Return `True` if it\'s possible to make the exact amount, otherwise return `False`. 2. **Constraints**: - Ensure the function runs in O(m * n) complexity, where `m` is the number of different coins, and `n` is the required `amount`. Input - A list of integers `nums` representing coin denominations. - An integer `amount` representing the target amount of money. Output - Return `True` if you can make the exact `amount` using any combination of the coins in `nums`. - Return `False` otherwise. Constraints - `1 <= len(nums) <= 100` - `1 <= nums[i] <= 10^4` - `0 <= amount <= 10^4` Example Usage ```python assert can_make_change([1, 2, 5], 11) == True assert can_make_change([2], 3) == False assert can_make_change([10], 10) == True assert can_make_change([1, 2, 3], 0) == True assert can_make_change([1, 5, 10, 25], 30) == True ``` Notes - Consider scenarios with varying `nums` lengths and values. - Prevent redundant computations by storing results in a memoization table or similar structure.","solution":"from typing import List def can_make_change(nums: List[int], amount: int) -> bool: Determine if it\'s possible to achieve the exact amount using any combination of coins in nums. # Initialize a list to track possible amounts to make up to \\"amount\\" dp = [False] * (amount + 1) # Base case: zero amount is always possible (using zero coins) dp[0] = True # Iterate over each coin for coin in nums: # Update dp table for all amounts that can be reached by adding this coin for i in range(coin, amount + 1): if dp[i - coin] == True: dp[i] = True return dp[amount]"},{"question":"# Question Given a list of strings `words`, return the list of all the strings that are anagrams of another string in the list. A string is an anagram of another string if it can be formed by rearranging the letters of the other string. Implement the function `find_anagrams(words: list[str]) -> list[str]` that takes a list of strings and returns a list of all the strings that are anagrams of another string in the list. The returned list should be sorted in lexicographical order. Function Signature ```python def find_anagrams(words: list[str]) -> list[str]: pass ``` # Input * `words`: A list of strings, where each string consists of lowercase English letters. # Output * A list of strings containing all the anagrams found in the input list, sorted in lexicographical order. # Examples ```python assert find_anagrams([\\"listen\\", \\"silent\\", \\"enlist\\", \\"rat\\", \\"tar\\", \\"art\\", \\"evil\\", \\"vile\\", \\"live\\"]) == [\\"art\\", \\"enlist\\", \\"evil\\", \\"listen\\", \\"live\\", \\"rat\\", \\"silent\\", \\"tar\\", \\"vile\\"] assert find_anagrams([\\"abcd\\", \\"bcda\\", \\"dabc\\", \\"eabcd\\", \\"efgh\\"]) == [\\"abcd\\", \\"dabc\\", \\"bcda\\"] assert find_anagrams([\\"abcd\\", \\"efgh\\", \\"ijkl\\", \\"mnop\\"]) == [] ``` # Constraints * The input list contains at most 10,000 strings. * Each string has a length between 1 and 100 characters.","solution":"def find_anagrams(words: list[str]) -> list[str]: from collections import defaultdict anagrams_map = defaultdict(list) for word in words: key = \\"\\".join(sorted(word)) anagrams_map[key].append(word) result = [] for value in anagrams_map.values(): if len(value) > 1: result.extend(value) return sorted(result)"},{"question":"# Coding Assessment Question **Island Perimeter in a Grid** You are given a 2D grid with dimensions ( m times n ). Each cell in the grid can either be land or water: * Land is represented by the integer `1`. * Water is represented by the integer `0`. An island is a group of land cells connected 4-directionally (horizontally or vertically). You may assume that the edges of the grid are all surrounded by water. Your task is to calculate the perimeter of the island in the grid. Implement the function `island_perimeter(grid: List[List[int]]) -> int` that takes a 2D list ( grid ) and returns the perimeter of the island. Input * A 2D list `grid` where each element is either `1` (land) or `0` (water). * The dimensions ( m ) and ( n ) can be up to ( 100 ). Output * An integer representing the perimeter of the island. Examples 1. **Input**: ``` grid = [ [0,1,0,0], [1,1,1,0], [0,1,0,0], [1,1,0,0] ] ``` **Output**: `16` 2. **Input**: ``` grid = [ [1] ] ``` **Output**: `4` 3. **Input**: ``` grid = [ [1,0] ] ``` **Output**: `4` Your implementation should efficiently handle the constraints and provide correct results. Make sure to test your function on edge cases, such as very small grids and grids with no land cells.","solution":"def island_perimeter(grid): Returns the perimeter of the island in the given grid. if not grid or not grid[0]: return 0 rows, cols = len(grid), len(grid[0]) perimeter = 0 for r in range(rows): for c in range(cols): if grid[r][c] == 1: perimeter += 4 if r > 0 and grid[r-1][c] == 1: # check up perimeter -= 2 if c > 0 and grid[r][c-1] == 1: # check left perimeter -= 2 return perimeter"},{"question":"# Knapsack Problem - Dynamic Programming Optimization You are given the task of optimizing the provided `knapsack.py` code that implements the Dynamic Programming (DP) solution for solving the 0/1 Knapsack Problem. Your focus should be on enhancing the space complexity of the dynamic programming solution. Problem Statement You need to write a function that optimizes the `knapsack` method in the given code. This function should ensure efficient use of memory, reducing the space complexity from (O(n * W)) to (O(W)). # Function Signature ```python def optimized_knapsack(values, weights, max_weight): Optimized implementation of the 0/1 Knapsack problem using dynamic programming with reduced space complexity. :param values: List of item values. :param weights: List of item weights. :param max_weight: Integer representing the maximum weight capacity of the knapsack. :return: Maximum value that can be attained within the given weight constraint. pass ``` # Requirements 1. **Function Implementation**: Implement the `optimized_knapsack` function. It should take a list of item values, a list of item weights, and the maximum weight capacity of the knapsack. 2. **Space Complexity**: Ensure that the dynamic programming solution is optimized to use (O(W)) space. 3. **Correctness**: Ensure that the function correctly calculates the maximum value attainable within the given weight constraint. 4. **Constraints**: Assume all values and weights are positive integers. # Input - `values`: List of integers representing the values of the items. - `weights`: List of integers representing the weights of the items. - `max_weight`: Integer representing the maximum weight capacity of the knapsack. Example Input ```python values = [60, 100, 120] weights = [10, 20, 30] max_weight = 50 ``` # Output - Return the maximum value that can be attained within the given weight constraint. Example Output ```python 220 ``` # Constraints - The number of items ( n ) will be at most 1000. - The maximum weight capacity `max_weight` will be at most 2000. # Detailed Explanation In the given example: - We have 3 items with values `[60, 100, 120]` and weights `[10, 20, 30]`. - The maximum weight capacity of the knapsack is 50. - The optimal solution is to take the second and third items, yielding a maximum value of 220.","solution":"def optimized_knapsack(values, weights, max_weight): Optimized implementation of the 0/1 Knapsack problem using dynamic programming with reduced space complexity. :param values: List of item values. :param weights: List of item weights. :param max_weight: Integer representing the maximum weight capacity of the knapsack. :return: Maximum value that can be attained within the given weight constraint. n = len(values) dp = [0] * (max_weight + 1) for i in range(n): for w in range(max_weight, weights[i] - 1, -1): dp[w] = max(dp[w], dp[w - weights[i]] + values[i]) return dp[max_weight]"},{"question":"# Optimized String Rotation Detection You are provided with a function that checks if one string is a rotation of another, but it lacks efficiency. The current implementation uses a nested loop approach which can be improved for performance. Objective Optimize the existing function to detect if one string is a rotation of another string efficiently. Requirements 1. **Function Update**: Rewrite the function to eliminate the nested loops and achieve the same result with improved time complexity. 2. **Input and Output**: - **Input**: Two strings `s1` and `s2`. - **Output**: A boolean value - `True` if `s2` is a rotation of `s1`, otherwise `False`. 3. **Constraints**: - Assume the function name and signature cannot be changed. - Both strings only contain printable ASCII characters. - Avoid using excessive additional space, strive for O(1) or minimal addition of space. 4. **Performance Requirements**: Optimize the function to operate in linear time O(N) where N is the length of the input strings. Example Here is the current function. Optimize it to meet the new requirements. ```python def is_rotation(s1: str, s2: str) -> bool: Check if s2 is a rotation of s1. >>> is_rotation(\'waterbottle\', \'erbottlewat\') True >>> is_rotation(\'abcd\', \'dacb\') False >>> is_rotation(\'rotation\', \'rotation\') True >>> is_rotation(\'hello\', \'llohe\') True >>> is_rotation(\'hello\', \'lehlo\') False if len(s1) != len(s2): return False return s2 in s1 + s1 ``` Task Rewrite the `is_rotation` function to achieve the same functionality with optimized performance. Ensure all provided examples pass with the updated implementation while adhering to the constraints and requirements.","solution":"def is_rotation(s1: str, s2: str) -> bool: Check if s2 is a rotation of s1. Parameters: s1 (str): The original string. s2 (str): The string to be checked if it is a rotation of s1. Returns: bool: True if s2 is a rotation of s1, False otherwise. >>> is_rotation(\'waterbottle\', \'erbottlewat\') True >>> is_rotation(\'abcd\', \'dacb\') False >>> is_rotation(\'rotation\', \'rotation\') True >>> is_rotation(\'hello\', \'llohe\') True >>> is_rotation(\'hello\', \'lehlo\') False if len(s1) != len(s2): return False concatenated = s1 + s1 return s2 in concatenated"},{"question":"# Problem Description You are tasked with implementing a function that finds the k-th missing positive integer from an input list `arr` of positive integers sorted in ascending order. The missing positive integers are those that are not present in `arr`. # Function Specifications Function Name ```python def find_kth_missing_positive(arr: List[int], k: int) -> int ``` Input - `arr` (List[int]): A sorted list of positive integers. Constraints: 1 ≤ len(arr) ≤ 1000. - `k` (int): A positive integer representing which missing positive integer to find. Constraints: 1 ≤ k ≤ 1000. Output - Returns the k-th missing positive integer. Error Handling - If `k` is not a positive integer, raise an appropriate exception. - If `arr` is not sorted or contains non-positive integers, raise an appropriate exception. # Constraints 1. Ensure your solution is efficient and can handle the given input sizes. 2. Your solution should account for edge cases where input is invalid (e.g., non-integers, non-positive integers, unsorted list). # Example ```python # Examples of calling find_kth_missing_positive(arr, k) assert find_kth_missing_positive([2, 3, 4, 7, 11], 5) == 9 assert find_kth_missing_positive([1, 2, 3, 4], 2) == 6 # Examples of handling invalid inputs: try: find_kth_missing_positive([1, 2, -3, 4], 2) except ValueError as e: print(str(e)) # should output something akin to \\"Input list must only contain positive integers\\" try: find_kth_missing_positive([3, 2, 1], 1) except ValueError as e: print(str(e)) # should output something akin to \\"Input list must be sorted in ascending order\\" try: find_kth_missing_positive([1, 2, 3], -5) except ValueError as e: print(str(e)) # should output something akin to \\"k must be a positive integer\\" try: find_kth_missing_positive([1, 2, 3], 2.5) except TypeError as e: print(str(e)) # should output something akin to \\"k must be an integer\\" ``` # Notes 1. Ensure the function is optimized for both time and space requirements. 2. Take special care to validate the input and handle edge cases, raising descriptive errors accordingly.","solution":"def find_kth_missing_positive(arr, k): Finds the k-th missing positive integer in the sorted array of positive integers. if not isinstance(k, int) or k <= 0: raise ValueError(\\"k must be a positive integer\\") if not all(isinstance(x, int) and x > 0 for x in arr): raise ValueError(\\"Input list must only contain positive integers\\") if arr != sorted(arr): raise ValueError(\\"Input list must be sorted in ascending order\\") missing_count = 0 current = 1 idx = 0 while True: if idx < len(arr) and arr[idx] == current: idx += 1 else: missing_count += 1 if missing_count == k: return current current += 1"},{"question":"Problem Statement You are provided with a text document and tasked to implement an algorithm that finds and highlights all occurrences of a given set of patterns within the text. Each occurrence should be highlighted by wrapping the pattern in square brackets. For instance, if the pattern is \\"code\\" and appears in the text as \\"code\\", it should be converted to \\"[code]\\". The algorithm should be efficient, handling large text inputs and multiple patterns. # Function Signature ```python def highlight_patterns(text: str, patterns: list) -> str: :param text: the source text in which to search for patterns. :param patterns: a list of string patterns to search for and highlight in the text. :return: a string with all patterns highlighted. ``` # Input * A string (`text`) representing the document in which to look for patterns. * A list of strings (`patterns`), each representing a pattern to highlight within the text. # Output * A single string where all occurrences of each pattern are found and wrapped in square brackets. # Constraints * Preferred approach is efficient in handling large texts and numerous patterns. * Do not use any high-level third-party libraries like regex; rely only on basic string operations and data structures. # Examples ```python text = \\"The quick brown fox jumps over the lazy dog. The dog was not amused.\\" patterns = [\\"The\\", \\"dog\\", \\"fox\\"] result = highlight_patterns(text, patterns) print(result) # Output: \\"[The] quick brown [fox] jumps over [the] lazy [dog]. [The] [dog] was not amused.\\" text2 = \\"Writing code can be fun if you understand the basics of coding.\\" patterns2 = [\\"code\\", \\"fun\\", \\"coding\\"] result2 = highlight_patterns(text2, patterns2) print(result2) # Output: \\"Writing [code] can be [fun] if you understand the basics of [coding].\\" ``` # Hints * Consider using a trie structure to efficiently search for multiple patterns at once. * Handle overlapping occurrences carefully, ensuring each pattern is highlighted correctly even if they overlap. * Managing character casing may require preprocessing of input and patterns if case-insensitivity is desired. # Additional Requirements * The function should handle cases where the same pattern appears multiple times in different contexts within the text. * Ensure that the function is tested for edge cases like empty patterns list, patterns not present in the text, or patterns that are substrings of other patterns.","solution":"def highlight_patterns(text: str, patterns: list) -> str: Finds and highlights all occurrences of a given set of patterns within the text by wrapping patterns in square brackets. :param text: the source text in which to search for patterns. :param patterns: a list of string patterns to search for and highlight in the text. :return: a string with all patterns highlighted. # Generate a list of patterns sorted by length in reverse order to avoid overlapping issues patterns = sorted(patterns, key=len, reverse=True) for pattern in patterns: start = 0 while True: start = text.find(pattern, start) if start == -1: break end = start + len(pattern) # Insert brackets around the pattern text = text[:start] + \'[\' + pattern + \']\' + text[end:] # Move the start position to the end of newly inserted brackets start = end + 2 return text"},{"question":"Title: Replace Multiple Spaces with Single Space # Description You are to write a function that takes a string and replaces any sequence of multiple spaces with a single space. It should also remove leading and trailing spaces. Your function should handle cases where the input is not a string by raising a `ValueError` with the message \\"Input must be a string.\\" # Function Signature ```python def simplify_spaces(text: str) -> str: pass ``` # Input * `text` (str): A string which may contain multiple spaces. # Output * Returns a new string where all sequences of multiple spaces are replaced by a single space, and leading/trailing spaces are removed. # Constraints * The function should only accept strings. * If the input `text` is not a string, raise a `ValueError` with the message \\"Input must be a string\\". * Aim to solve the problem with a time complexity of O(N) and space complexity of O(N), where N is the length of the input string. # Examples ```python simplify_spaces(\\" This is a test string. \\") # returns \\"This is a test string.\\" simplify_spaces(\\"NoExtra Spaces\\") # returns \\"NoExtra Spaces\\" simplify_spaces(\\" Leading and trailing \\") # returns \\"Leading and trailing\\" simplify_spaces(\\"\\") # returns \\"\\" simplify_spaces(\\"SingleSpace\\") # returns \\"SingleSpace\\" ``` # Notes * Make sure to handle edge cases such as an empty string or strings without any spaces. * Consider using string manipulation methods to achieve the desired results efficiently.","solution":"def simplify_spaces(text: str) -> str: Replaces multiple spaces in the text with a single space and removes leading/trailing spaces. Args: text (str): The input text to be simplified. Returns: str: The simplified text. Raises: ValueError: If the input is not a string. if not isinstance(text, str): raise ValueError(\\"Input must be a string\\") # Split the string into words and join with a single space return \' \'.join(text.split())"},{"question":"# Problem Statement: You are required to write a function `find_min_diff(num_list: List[int], n: int) -> int` that finds the smallest absolute difference between any two elements in a list of integers. # Input - `num_list` (List[int]): A list of integers containing at least `n` integers. - `n` (int): The number of unique pairs to consider. (1 ≤ n ≤ len(num_list) * (len(num_list) - 1) / 2) # Output - An integer representing the smallest absolute difference between any two elements in the list among the first `n` unique pairs considered. # Examples ```python >>> find_min_diff([10, 3, 20, 50, 42, 5], 5) 2 >>> find_min_diff([1, 9, 4, 12, 3], 3) 1 >>> find_min_diff([5, 8, 13, 20, 7], 6) 1 ``` # Constraints - The list `num_list` will contain at least 2 elements. - `num_list` may contain duplicates. - Your function should be optimized for performance with larger lists and values of `n`. # Hints - Consider sorting the list to potentially simplify the problem and reduce the number of comparisons needed. - Implement efficient loop structures and breaking conditions to avoid excessive computation. # Additional Information: Your goal is to find the smallest absolute difference considering only the first `n` unique pairs of numbers from the list. If `n` exceeds the possible number of unique pairs, simply find the smallest absolute difference from all possible pairs.","solution":"def find_min_diff(num_list, n): Returns the smallest absolute difference between any two elements in the list considering up to n unique pairs. # Sort the list to make it easier to find the smallest difference between consecutive elements num_list.sort() # Initialize the minimum difference to a large number min_diff = float(\'inf\') # Iterate through the sorted list and find the smallest difference for i in range(len(num_list) - 1): if i == n: break diff = abs(num_list[i+1] - num_list[i]) if diff < min_diff: min_diff = diff return min_diff"},{"question":"# Problem Statement A positive integer `n` is called a Narcissistic Number if it is equal to the sum of its own digits each raised to the power of the number of digits. Write a function, `find_nth_narcissistic_number(n: int) -> List[int]`, which returns a list containing the first \'n\' narcissistic numbers. # Function Signature ```python def find_nth_narcissistic_number(n: int) -> List[int]: ``` # Input * `n` (int): A positive integer representing the number of narcissistic numbers required (1 <= n <= 10). # Output * The function should return a list of the first \'n\' narcissistic numbers. # Constraints * The input `n` will be a positive integer. * You can assume that 1 <= n <= 10 for reasonable execution time. # Example ```python >>> find_nth_narcissistic_number(1) [1] >>> find_nth_narcissistic_number(3) [1, 2, 3] >>> find_nth_narcissistic_number(5) [1, 2, 3, 4, 5] >>> find_nth_narcissistic_number(0) [] >>> find_nth_narcissistic_number(11) TypeError: Input n must be between 1 and 10 (inclusive) ``` # Notes - The function should validate the input and raise an appropriate error for invalid values. - You may use the provided helper function to check if a number is narcissistic. # Further Explanation * A helper function `is_narcissistic` can be used to check if an integer is a narcissistic number. * Efficiently find the numbers by checking each integer sequentially.","solution":"def is_narcissistic(num): Checks if a given number is a narcissistic number. digits = str(num) power = len(digits) return num == sum(int(digit) ** power for digit in digits) def find_nth_narcissistic_number(n: int): Returns a list of the first n narcissistic numbers. if not (1 <= n <= 10): raise ValueError(\\"Input n must be between 1 and 10 (inclusive)\\") narcissistic_numbers = [] i = 1 while len(narcissistic_numbers) < n: if is_narcissistic(i): narcissistic_numbers.append(i) i += 1 return narcissistic_numbers"},{"question":"# Context: You need to design a function that decodes a string encoded with the following run-length encoding (RLE) method: for any sequence of characters, the encoding is composed of pairs, where each pair consists of a number and a character. For example, the string `aaabcc` would be encoded as `3a1b2c`. # Problem Statement: Write a function `decode_rle(encoded: str) -> str` that decodes a run-length encoded string back into its original form. Ensure that the input string follows the encoding rules and provide adequate error handling for invalid formats. # Input Format: - A string `encoded` representing the run-length encoded string. # Output Format: - A string representing the decoded version of the input string. - Raise a `ValueError` if the input string is not a valid run-length encoded format. # Constraints: - The input string will only contain digits (0-9) and letters (a-z, A-Z). - The input string will always be a valid encoded string according to the specified RLE format. # Function Signature: ```python def decode_rle(encoded: str) -> str: ``` # Example: Example 1: ```python input: \\"3a1b2c\\" output: \\"aaabcc\\" ``` Example 2: ```python input: \\"1a3b2c4d\\" output: \\"abbbccdddd\\" ``` Example 3: ```python input: \\"2x5y1z\\" output: \\"xxyyyyyz\\" ``` Example 4: ```python input: \\"10a2b3c\\" output: \\"aaaaaaaaaabbccc\\" ``` # Notes: - Consider edge cases such as empty input strings, although these should be valid outputs, returning an empty string. - Implement efficient error handling to capture and raise exceptions for invalid encoded format cases, such as missing numbers or letters in the encoded string.","solution":"import re def decode_rle(encoded: str) -> str: Decodes a run-length encoded string back to its original form. Parameters: encoded (str) : The run-length encoded string. Returns: str : The decoded string. Raises: ValueError : If the input string is not in valid run-length encoded format. if not encoded: return \\"\\" if not re.fullmatch(r\'(d+[a-zA-Z])+\', encoded): raise ValueError(\\"Invalid run-length encoded format\\") decoded = [] i = 0 while i < len(encoded): j = i while j < len(encoded) and encoded[j].isdigit(): j += 1 count = int(encoded[i:j]) char = encoded[j] decoded.append(char * count) i = j + 1 return \\"\\".join(decoded)"},{"question":"# Sum of Squares Problem Statement: Write a function `sum_of_squares` that computes the sum of the squares of the first `n` positive integers. The sum of squares for the first `n` positive integers is given by the formula: [ S = 1^2 + 2^2 + 3^2 + ldots + n^2 ] Input: - An integer `n` (1 ≤ n ≤ 1000), representing the number of the first positive integers to sum the squares of. Output: - An integer representing the sum of the squares of the first `n` positive integers. Constraints: - The input `n` must be a positive integer. - The solution should be efficient and capable of handling the upper limits of the input size. Example: **Input:** ```python 4 ``` **Output:** ```python 30 ``` Notes: - (1^2 + 2^2 + 3^2 + 4^2 = 1 + 4 + 9 + 16 = 30) - Ensure to handle edge cases such as minimum and maximum values of `n`.","solution":"def sum_of_squares(n): Compute the sum of the squares of the first n positive integers. Args: n (int): The number of the first positive integers to sum the squares of. Returns: int: The sum of the squares of the first n positive integers. return sum(i**2 for i in range(1, n + 1))"},{"question":"# Lowest Common Ancestor in a Binary Tree Problem Statement: Given a binary tree, your task is to find the lowest common ancestor (LCA) of two given nodes. The lowest common ancestor of two nodes p and q in a binary tree is defined as the lowest node that has both p and q as descendants (where we allow a node to be a descendant of itself). Task: 1. Implement the `lowest_common_ancestor` function within a BinaryTree class. 2. Ensure the function finds and returns the LCA of two given nodes. 3. If either of the nodes does not exist in the tree, the function should return `None`. Expected Function Signature: ```python def lowest_common_ancestor(self, root: TreeNode, p: TreeNode, q: TreeNode) -> TreeNode ``` Example: ```python class TreeNode: def __init__(self, val: int = 0, left: \'TreeNode\' = None, right: \'TreeNode\' = None): self.val = val self.left = left self.right = right class BinaryTree: def __init__(self): self.root = None def add(self, val: int): if self.root is None: self.root = TreeNode(val) else: self._add(self.root, val) def _add(self, node: TreeNode, val: int): if val < node.val: if node.left is None: node.left = TreeNode(val) else: self._add(node.left, val) else: if node.right is None: node.right = TreeNode(val) else: self._add(node.right, val) def lowest_common_ancestor(self, root: TreeNode, p: TreeNode, q: TreeNode) -> TreeNode: # Your code goes here # Example Usage: bt = BinaryTree() bt.add(6) bt.add(2) bt.add(8) bt.add(0) bt.add(4) bt.add(7) bt.add(9) bt.add(3) bt.add(5) node4 = bt.root.left.right node7 = bt.root.right.left lca = bt.lowest_common_ancestor(bt.root, node4, node7) print(lca.val) # Output should be 6 ``` Constraints: 1. The number of nodes in the tree will be in the range [2, 10^3]. 2. The values of the nodes are unique. 3. Both nodes `p` and `q` will exist in the binary tree. Hint: You may perform a recursive traversal of the tree and make use of the properties of binary trees to determine the LCA efficiently.","solution":"class TreeNode: def __init__(self, val: int = 0, left: \'TreeNode\' = None, right: \'TreeNode\' = None): self.val = val self.left = left self.right = right class BinaryTree: def __init__(self): self.root = None def add(self, val: int): if self.root is None: self.root = TreeNode(val) else: self._add(self.root, val) def _add(self, node: TreeNode, val: int): if val < node.val: if node.left is None: node.left = TreeNode(val) else: self._add(node.left, val) else: if node.right is None: node.right = TreeNode(val) else: self._add(node.right, val) def lowest_common_ancestor(self, root: TreeNode, p: TreeNode, q: TreeNode) -> TreeNode: if not root or root == p or root == q: return root left = self.lowest_common_ancestor(root.left, p, q) right = self.lowest_common_ancestor(root.right, p, q) if left and right: return root return left if left else right"},{"question":"# Cache System with LFU Eviction Policy An LFU (Least Frequently Used) Cache is a type of cache algorithm that removes the least frequently accessed item in the cache when the cache hits its limit. If there are multiple items with the same frequency, the least recently used item will be removed. Design and implement an LFU Cache class that supports the following operations: 1. **set(key, value)**: Insert or update the key with the corresponding value. If the cache is full, remove the least frequently used item before inserting. 2. **get(key)**: Retrieve the value associated with the key, increasing its frequency count. Return `-1` if the key is not found. # Class Definition **Class: `LFUCache`** ```python class LFUCache: def __init__(self, capacity: int): pass def set(self, key: int, value: int) -> None: pass def get(self, key: int) -> int: pass ``` * **Description**: An implementation of an LFU Caching system. * **Constructor**: Initializes the cache with a given capacity. * **Method `set`**: * **Input**: An integer `key` representing the unique key, and an integer `value` representing the value to be cached. * **Output**: None. * **Method `get`**: * **Input**: An integer `key` representing the unique key. * **Output**: Returns the integer value associated with the key if found in the cache, otherwise returns `-1`. * **Constraints**: Cache should operate efficiently with a combination of hash tables and linked lists or similar structures to manage entries and frequencies effectively. # Example Usage ```python cache = LFUCache(2) cache.set(1, 1) # Cache is {1=1} cache.set(2, 2) # Cache is {1=1, 2=2} print(cache.get(1)) # Returns 1 and increases the frequency of key 1, Cache is {1=1 (freq 2), 2=2} cache.set(3, 3) # Removes key 2 since it is the least frequently used, Cache is {1=1 (freq 2), 3=3} print(cache.get(2)) # Returns -1, as key 2 has been removed print(cache.get(3)) # Returns 3 and increases the frequency of key 3, Cache is {1=1 (freq 2), 3=3 (freq 2)} cache.set(4, 4) # Removes key 1 since both keys 1 and 3 have the same frequency, but 1 is least recently used, Cache is {3=3 (freq 2), 4=4} print(cache.get(1)) # Returns -1, as key 1 has been removed print(cache.get(3)) # Returns 3, Cache is {3=3 (freq 3), 4=4} print(cache.get(4)) # Returns 4, Cache is {3=3 (freq 3), 4=4 (freq 2)} ``` # Additional Constraints 1. The number of keys and values will be within the range [0, 10^4]. 2. The operations `set` and `get` must each run in O(1) average time complexity. Implement the `LFUCache` class ensuring it efficiently handles the frequency and order of element accesses to meet the Least Frequently Used eviction policy.","solution":"from collections import defaultdict, OrderedDict class LFUCache: def __init__(self, capacity: int): self.capacity = capacity self.size = 0 self.min_freq = 0 self.node = {} self.freq = defaultdict(OrderedDict) def _update(self, key, value=None): node = self.node[key] if value is not None: node[\'value\'] = value old_freq = node[\'freq\'] new_freq = old_freq + 1 node[\'freq\'] = new_freq del self.freq[old_freq][key] if not self.freq[old_freq]: if old_freq == self.min_freq: self.min_freq += 1 del self.freq[old_freq] self.freq[new_freq][key] = node def set(self, key: int, value: int) -> None: if self.capacity <= 0: return if key in self.node: self._update(key, value) else: if self.size >= self.capacity: k, _ = self.freq[self.min_freq].popitem(last=False) del self.node[k] self.size -= 1 node = {\'value\': value, \'freq\': 1} self.node[key] = node self.freq[1][key] = node self.min_freq = 1 self.size += 1 def get(self, key: int) -> int: if key not in self.node: return -1 self._update(key) return self.node[key][\'value\']"},{"question":"# Problem Statement **Scenario**: You are building a tool for data analysis that processes a list of integers to extract certain statistical properties. This task involves identifying and counting distinct elements that occur in both a given list and its left-rotated version. **Task**: Implement a function `count_common_elements(arr: List[int], k: int) -> int` that returns the number of distinct elements that occur in both the original list `arr` and a left-rotated version of the list by `k` positions. **Function Signature**: ```python def count_common_elements(arr: List[int], k: int) -> int ``` **Input**: - `arr`: a list of integers (`1 <= len(arr) <= 10^5`, `-10^9 <= arr[i] <= 10^9`). - `k`: an integer (`0 <= k < len(arr)`). **Output**: - An integer representing the number of distinct elements that appear in both the original and left-rotated version of the list. # Constraints: - All elements in `arr` are distinct. # Requirements: - Handle the rotation operation efficiently without explicitly creating a new list. - Use appropriate data structures to ensure efficient comparison of elements between the original and rotated lists. # Performance: - Ensure the solution handles the upper limits efficiently, ideally running in linear time with respect to the length of the list. # Example: ```python assert count_common_elements([1, 2, 3, 4, 5], 2) == 3 # Original: [1, 2, 3, 4, 5], Rotated: [3, 4, 5, 1, 2] assert count_common_elements([10, 20, 30, 40, 50], 3) == 2 # Original: [10, 20, 30, 40, 50], Rotated: [40, 50, 10, 20, 30] assert count_common_elements([7, 8, 9, 10, 11, 12], 0) == 6 # No rotation, all elements match ``` **Note**: The function should efficiently handle both small and large lists, ensuring accurate results within the given constraints.","solution":"from typing import List def count_common_elements(arr: List[int], k: int) -> int: Counts the number of distinct elements that are common between the original list `arr` and its left-rotated version by `k` positions. n = len(arr) if n == 0 or k == 0: return n # Calculate the rotated version\'s starting index rotated_start_index = k % n # Capture the rotated version of the array using slicing (efficient as it doesn\'t create an additional list) rotated_set = set(arr[rotated_start_index:] + arr[:rotated_start_index]) # Compare this set with the original array to find common elements original_set = set(arr) common_elements = original_set.intersection(rotated_set) return len(common_elements)"},{"question":"# Context In many social networking services, friend recommendations play an important role in helping users connect with each other. One common approach is to suggest friends of friends to a user. This approach leverages the network graph to identify potential connections that are not directly linked to the user but are connected through mutual friends. # Task Your task is to implement a function that takes a user ID and a graph representing user connections, then returns a list of friend recommendations for that user based on friends of friends approach. The graph is provided as an adjacency list. # Function to Implement ```python def recommend_friends(user_id: int, connections: dict[int, list[int]]) -> list[int]: Args: user_id: An integer representing the ID of the user for whom the friends are to be recommended. connections: A dictionary where keys are user IDs and values are lists of user IDs representing the friends of the key user. Returns: A list of integers representing the recommended friends for the given user. The recommendations should exclude the user itself and the user\'s direct friends. The resulting list should be sorted in increasing order of user IDs. pass ``` # Expected Constraints and Limitations - The `user_id` provided will exist in the `connections` dictionary. - Every user ID in the `connections` dictionary will have a list of friends (possibly empty). - User IDs are non-negative integers. # Requirements - Validate inputs ensuring `user_id` exists in the `connections`. - Determine the user\'s direct friends and the friends of these friends. - Exclude the user itself and direct friends from the recommendations. - The result should be sorted in increasing order of user IDs for consistent output. # Example ```python connections = { 1: [2, 3], 2: [1, 4], 3: [1, 4, 5], 4: [2, 3, 6], 5: [3], 6: [4] } output = recommend_friends(1, connections) print(output) # Expected Output: [4, 5] ``` # Explanation - User 1\'s direct friends are 2 and 3. - Friends of user 1\'s friends (excluding 1, 2, and 3) are: 4 (friend of 2 and 3), 5 (friend of 3), and 6 (friend of 4). - After sorting, the recommended friends for user 1 are: [4, 5]","solution":"def recommend_friends(user_id: int, connections: dict[int, list[int]]) -> list[int]: Args: user_id: An integer representing the ID of the user for whom the friends are to be recommended. connections: A dictionary where keys are user IDs and values are lists of user IDs representing the friends of the key user. Returns: A list of integers representing the recommended friends for the given user. The recommendations should exclude the user itself and the user\'s direct friends. The resulting list should be sorted in increasing order of user IDs. # Get the user\'s direct friends direct_friends = connections.get(user_id, []) # Use a set to avoid potential duplicate entries potential_friends = set() # Get friends of friends for friend in direct_friends: for fof in connections.get(friend, []): if fof != user_id and fof not in direct_friends: potential_friends.add(fof) # Convert set to a sorted list return sorted(potential_friends)"},{"question":"# Problem Statement Context: You need to enhance a function that processes a sequence of operations on a nested list structure and applies various transformations based on a set of commands. Instructions: 1. **Modify the `process_operations` function**: - Add input validation to confirm the commands are properly formatted tuples containing a valid operation keyword and corresponding parameters. - Extend the function to support additional operations such as `reverse`, which reverses the order of the top-level list. 2. **Implement and validate the extended operations `append`, `insert`, `delete`, and `reverse`**: - `append`: Add an element to the end of the list. - `insert`: Insert an element at a specific position. - `delete`: Remove an element at a specified position. - `reverse`: Reverse the order of elements in the list. Specifications: - **Function Signatures**: ```python def process_operations(lst: list, operations: list) -> list: ... ``` - **Input/Output Examples**: ```python >>> process_operations([1, 2, 3], [(\'append\', 4), (\'insert\', 1, 5)]) [1, 5, 2, 3, 4] >>> process_operations([1, 2, 3, 4], [(\'delete\', 2), (\'reverse\', )]) [4, 2, 1] >>> process_operations([1, 2], [(\'append\', 3), (\'delete\', 1), (\'reverse\', )]) Traceback (most recent call last): ... IndexError: Delete operation index out of range. >>> process_operations(\\"string\\", [(\'append\', 3)]) Traceback (most recent call last): ... TypeError: List must be provided as input. >>> process_operations([1, 2], [(\'insert\', 3)]) Traceback (most recent call last): ... ValueError: Operation not correctly formatted or unsupported. ``` - **Constraints**: - The input list `lst` must be of type list. - The `operations` list should only contain tuples with format and supported operations as specified above. - Ensure input validation checks for correct types and valid indexes, handling edge cases with appropriate exception messages. - Functions should handle erroneous inputs gracefully, providing informative error messages. - **Performance Requirements**: - The implementation should be efficient, considering the complexity for list operations: `append` O(1), `insert` O(n) where n is the position, `delete` O(n) considering the reindexing, and `reverse` O(n).","solution":"def process_operations(lst, operations): Processes a list of operations on a given list. Args: lst (list): The list to be processed. operations (list): A list of tuples where the first element is an operation keyword and the subsequent elements are parameters for that operation. Returns: list: The modified list after all operations have been applied. Raises: TypeError: If the first argument is not a list. ValueError: If any operation is not properly formatted or unsupported. IndexError: If a delete operation index is out of range. if not isinstance(lst, list): raise TypeError(\\"List must be provided as input.\\") for operation in operations: if not isinstance(operation, tuple) or len(operation) < 1: raise ValueError(\\"Operation not correctly formatted or unsupported.\\") op = operation[0] if op == \'append\' and len(operation) == 2: lst.append(operation[1]) elif op == \'insert\' and len(operation) == 3: index, element = operation[1], operation[2] lst.insert(index, element) elif op == \'delete\' and len(operation) == 2: index = operation[1] if index < 0 or index >= len(lst): raise IndexError(\\"Delete operation index out of range.\\") lst.pop(index) elif op == \'reverse\' and len(operation) == 1: lst.reverse() else: raise ValueError(\\"Operation not correctly formatted or unsupported.\\") return lst"},{"question":"# Problem Statement You are required to implement a function that rotates a square matrix by 90 degrees clockwise. Your task is to complete the function `rotate_matrix_90` which takes a square matrix (a list of lists) as input and returns a new matrix that is the original matrix rotated by 90 degrees clockwise. # Function Signature ```python def rotate_matrix_90(matrix: list[list[int]]) -> list[list[int]]: Rotates a square matrix by 90 degrees clockwise. Parameters: matrix (list[list[int]]): A square matrix of integers Returns: list[list[int]]: A new square matrix rotated by 90 degrees clockwise Raises: TypeError: If the input is not a list of lists of integers ValueError: If the input matrix is not square Examples: >>> rotate_matrix_90([[1, 2], [3, 4]]) [[3, 1], [4, 2]] >>> rotate_matrix_90([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> rotate_matrix_90([[1]]) [[1]] >>> rotate_matrix_90([[1, 2], [3, 4, 5]]) Traceback (most recent call last): ... ValueError: The input matrix MUST be square! >>> rotate_matrix_90(\\"invalid input\\") Traceback (most recent call last): ... TypeError: The input MUST be a list of lists of integers! pass ``` # Requirements * Your implementation should handle all edge cases, including non-square or non-list inputs, raising appropriate exceptions: `TypeError` and `ValueError`. * You must only return a new rotated matrix and not modify the input matrix. # Constraints * The dimensions of the matrix will be within typical constraints (e.g., 1x1 to 100x100). # Testing Your solution will be tested with various input sizes, including edge cases and performance benchmarks. Ensure to test with non-square matrices and invalid inputs to guarantee robustness of exception handling.","solution":"def rotate_matrix_90(matrix: list[list[int]]) -> list[list[int]]: Rotates a square matrix by 90 degrees clockwise. Parameters: matrix (list[list[int]]): A square matrix of integers Returns: list[list[int]]: A new square matrix rotated by 90 degrees clockwise Raises: TypeError: If the input is not a list of lists of integers ValueError: If the input matrix is not square if not isinstance(matrix, list) or not all(isinstance(row, list) for row in matrix): raise TypeError(\\"The input MUST be a list of lists of integers!\\") n = len(matrix) if not all(len(row) == n for row in matrix): raise ValueError(\\"The input matrix MUST be square!\\") rotated_matrix = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): rotated_matrix[j][n - 1 - i] = matrix[i][j] return rotated_matrix"},{"question":"# Sum of Elements at Even Indices **Scenario**: As a software engineer, you are tasked with developing a function to analyze financial data represented as a list of integers. Specifically, you need to calculate the sum of all elements at even indices in the list, which represent monthly revenue figures. **Task**: Implement a function to compute the sum of elements that are located at even indices in a given list. An index is considered even if it is divisible by 2 (i.e., 0, 2, 4, ...). **Function Signature**: ```python def sum_even_indices(list_data: list) -> int: Calculate the sum of elements at even indices in the list. Args: list_data (list): the list of integers. Returns: int: the sum of elements at even indices. If the list is empty, return 0. ``` **Input**: - `list_data`: a list of integers where `0 <= len(list_data) <= 10^5`. **Output**: - The function should return an integer representing the sum of elements at even indices. **Constraints**: - The list can be empty, in which case the function should return 0. - The function should have a time complexity of O(n). **Examples**: ```python # Sample Input/Output 1 >>> sum_even_indices([1, 2, 3, 4, 5]) 9 # The elements at indices 0, 2, 4 are 1, 3, 5; their sum is 9. # Sample Input/Output 2 >>> sum_even_indices([10, 20, 30]) 40 # The elements at indices 0, 2 are 10, 30; their sum is 40. # Sample Input/Output 3 >>> sum_even_indices([]) 0 # The list is empty, so the sum is 0. # Sample Input/Output 4 >>> sum_even_indices([3, 3, 3, 3, 3, 3]) 12 # The elements at indices 0, 2, 4 are 3, 3, 3; their sum is 9. # Sample Input/Output 5 >>> sum_even_indices([1, -2, 3, -4]) 2 # The elements at indices 0, 2 are 1, 3; their sum is 4. ``` **Requirements**: - The solution should efficiently handle the edge cases such as an empty list. - Include test cases for validation.","solution":"def sum_even_indices(list_data: list) -> int: Calculate the sum of elements at even indices in the list. Args: list_data (list): the list of integers. Returns: int: the sum of elements at even indices. If the list is empty, return 0. return sum(list_data[i] for i in range(0, len(list_data), 2))"},{"question":"# Event Log Analyzer **Background**: You are asked to implement a class that manages an event log for a server. The log holds entries describing actions that occur on the server, where each entry is a tuple containing a timestamp and a description of the event. The server admin needs the ability to efficiently query the log for events, retrieve the oldest and newest entries, and remove entries based on the description. **Objective**: Implement the functionality to: 1. Add a new event entry to the log. 2. Retrieve the oldest event entry from the log. 3. Retrieve the newest event entry from the log. 4. Remove all entries that match a specific description from the log. 5. Retrieve all events that happened within a specific time range. # Requirements 1. **add_entry(timestamp, description)**: This function should add a new event entry to the log. 2. **get_oldest()**: This function should return the oldest event entry as a tuple of (timestamp, description). If the log is empty, return `None`. 3. **get_newest()**: This function should return the newest event entry as a tuple of (timestamp, description). If the log is empty, return `None`. 4. **remove_by_description(description)**: This function should remove all entries that match the provided description. 5. **get_events_in_time_range(start_time, end_time)**: This function should return a list of all event entries as tuples of (timestamp, description) that occurred within the specified time range [start_time, end_time] **Function Signatures**: ```python class EventLog: def __init__(self): self.log = [] def add_entry(self, timestamp, description): pass def get_oldest(self): pass def get_newest(self): pass def remove_by_description(self, description): pass def get_events_in_time_range(self, start_time, end_time): pass ``` # Input and Output **Add Entry** * **Input**: A timestamp `t` (represented as an integer) and a description `d` (string). * **Output**: None. **Get Oldest** * **Input**: None. * **Output**: The oldest event entry as a tuple of (timestamp, description). **Get Newest** * **Input**: None. * **Output**: The newest event entry as a tuple of (timestamp, description). **Remove by Description** * **Input**: A description `d` (string). * **Output**: None. **Get Events in Time Range** * **Input**: Two timestamps `start_time` and `end_time` (both integers). * **Output**: A list of event entries (tuples) within the specified time range. # Example ```python >>> log = EventLog() >>> log.add_entry(1609459200, \'Server started\') >>> log.add_entry(1609462800, \'User login\') >>> log.add_entry(1609466400, \'Error: Disk full\') >>> log.add_entry(1609470000, \'User logout\') >>> log.get_oldest() (1609459200, \'Server started\') >>> log.get_newest() (1609470000, \'User logout\') >>> log.remove_by_description(\'User login\') >>> log.get_oldest() (1609459200, \'Server started\') >>> log.get_events_in_time_range(1609460000, 1609470000) [(1609466400, \'Error: Disk full\'), (1609470000, \'User logout\')] ``` Complete the implementation of the `EventLog` class to meet these requirements.","solution":"class EventLog: def __init__(self): self.log = [] def add_entry(self, timestamp, description): self.log.append((timestamp, description)) self.log.sort() # Keep log sorted by timestamp def get_oldest(self): if not self.log: return None return self.log[0] def get_newest(self): if not self.log: return None return self.log[-1] def remove_by_description(self, description): self.log = [entry for entry in self.log if entry[1] != description] def get_events_in_time_range(self, start_time, end_time): return [entry for entry in self.log if start_time <= entry[0] <= end_time]"},{"question":"# Coding Challenge: Circuit Board Shortest Path Scenario: You are designing a circuit board and need to find the shortest path to connect two components. The circuit board can be represented as a grid where each cell is either an open path (represented by 0) or a blocked path (represented by 1). You need to find the shortest path from the top-left corner (0, 0) to the bottom-right corner (n-1, m-1) of the grid. The movement is allowed only to the right, left, up, or down. Task: Implement a function `shortest_path` that takes the grid as input and returns the length of the shortest path from the top-left corner to the bottom-right corner. If there is no such path, return -1. Function Signature: ```python def shortest_path(grid: list[list[int]]) -> int: ``` Input: - `grid` (list of list of int): The grid representing the circuit board where `grid[i][j]` is either 0 (open path) or 1 (blocked path). Output: - `int`: The length of the shortest path from the top-left corner to the bottom-right corner, or -1 if no such path exists. Constraints: - The grid is at most 1000x1000. - Each cell in the grid is either 0 or 1. - Movement is allowed only to adjacent cells (up, down, left, right). Example: ```python grid = [ [0, 0, 1, 0], [1, 0, 0, 1], [0, 0, 0, 0], [0, 1, 1, 0] ] print(shortest_path(grid)) # Expected Output: 7 ``` Requirements: - Utilize a graph traversal algorithm like BFS to ensure the shortest path is found. - Ensure the solution handles edge cases like blocked starting or ending cells and multiple disjoint path segments. - Write additional helper functions if necessary. Notes: - The path length is defined as the number of cells from the start to the end, including both the start and end cells. - Consider edge cases such as the grid being entirely blocked and the grid\'s size being the minimum (e.g., 1x1 grid).","solution":"from collections import deque def shortest_path(grid): Returns the length of the shortest path from the top-left corner to the bottom-right corner of the grid. If there is no such path, return -1. if not grid or grid[0][0] == 1 or grid[-1][-1] == 1: return -1 n = len(grid) m = len(grid[0]) queue = deque([(0, 0, 1)]) # store (x, y, distance) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] visited = set() visited.add((0, 0)) while queue: x, y, dist = queue.popleft() if (x, y) == (n-1, m-1): return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited and grid[nx][ny] == 0: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1"},{"question":"# Question: You are tasked with implementing a function to determine whether a given sequence of integers can be split into two subsets such that the sum of the elements in both subsets is equal. This problem is often referred to as the \\"Partition Problem,\\" which is a well-known problem in computer science and combinatorial optimization. Write a function `can_partition(nums: List[int]) -> bool` that takes a list of integers `nums` and returns a boolean value indicating whether the list can be partitioned into two subsets with equal sum. Input: * `nums` (List[int]) - A list of integers, where each integer is non-negative. Output: * A boolean value that is `True` if the list can be partitioned into two subsets with equal sum, and `False` otherwise. Constraints: * The length of the list `nums` will be between 1 and 200. * Each integer in `nums` will be between 0 and 100. Requirements: 1. Implement the solution using dynamic programming to ensure efficiency. 2. Handle edge cases such as when the list contains only one element or all elements are zero. 3. Ensure your solution works for the upper constraint limits efficiently. # Examples: ```python can_partition([1, 5, 11, 5]) => True can_partition([1, 2, 3, 5]) => False can_partition([1, 1, 1, 1, 1, 1]) => True can_partition([1, 1, 3, 4, 7, 12]) => True can_partition([3, 3, 3, 4, 5]) => True can_partition([2, 2, 7, 1, 5, 3, 6]) => True can_partition([2, 2, 7, 1, 5, 99]) => False ``` # Note: * The function should return `False` if the sum of the elements in the list is odd, as it would be impossible to split an odd sum into two equal parts. * Dynamic programming is required to achieve an optimal solution for larger inputs.","solution":"def can_partition(nums): Determines if the list can be partitioned into two subsets with equal sum. total_sum = sum(nums) # If total_sum is odd, it\'s not possible to partition it into two equal parts if total_sum % 2 != 0: return False target = total_sum // 2 # Dynamic programming approach to check if we can achieve the target sum n = len(nums) dp = [False] * (target + 1) dp[0] = True for num in nums: for j in range(target, num - 1, -1): dp[j] = dp[j] or dp[j - num] return dp[target]"},{"question":"**Matrix Path Sum** **Context:** You are required to develop a function that calculates the maximum path sum in a matrix, starting from the top-left corner and moving to the bottom-right corner. The movement is restricted to only right and down directions. **Task:** Implement a function `max_path_sum(matrix: list) -> int` that takes a 2D list `matrix` as input and returns the maximum sum achievable by traversing from the top-left corner to the bottom-right corner, adhering to the movement constraints (right and down only). **Input:** - `matrix`: A 2D list (list of lists) of integers with dimensions `n x m`. **Output:** - Returns an integer representing the maximum path sum. **Constraints:** - `1 <= n, m <= 10` - Elements of `matrix` are integers between -100 and 100. **Examples:** ```python >>> max_path_sum([ ... [5, 3, 2, 1], ... [1, 9, 1, 3], ... [3, 2, 8, 2], ... [4, 6, 7, 1] ... ]) 35 # The path is 5 -> 3 -> 9 -> 2 -> 8 -> 7 -> 1 >>> max_path_sum([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) 29 # The path is 1 -> 2 -> 3 -> 6 -> 9 ``` **Instructions:** 1. Implement the `max_path_sum` function in Python. 2. Use dynamic programming to calculate the maximum path sum with an auxiliary table to store intermediate results. 3. Ensure your implementation handles edge cases efficiently, such as matrices of dimension 1 x m or n x 1, and negative values.","solution":"def max_path_sum(matrix): Calculate the maximum path sum in a matrix from the top-left to the bottom-right corner, only moving right or down. :param matrix: List of lists of integers :return: Integer representing the maximum path sum if not matrix or not matrix[0]: return 0 rows = len(matrix) cols = len(matrix[0]) # Create a dp (Dynamic Programming) table with the same dimensions as matrix dp = [[0] * cols for _ in range(rows)] # Initialize the starting point with the top-left corner of the matrix dp[0][0] = matrix[0][0] # Fill the first row (can only come from the left) for j in range(1, cols): dp[0][j] = dp[0][j-1] + matrix[0][j] # Fill the first column (can only come from above) for i in range(1, rows): dp[i][0] = dp[i-1][0] + matrix[i][0] # Fill the rest of the dp table for i in range(1, rows): for j in range(1, cols): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + matrix[i][j] # The bottom-right corner holds the maximum path sum return dp[rows-1][cols-1]"},{"question":"# Odd Digit Sum Check You are given a list of integers. Write a function that returns the sum of all numbers in the list that contain only odd digits. # Function Signature ```python def sum_odd_digit_numbers(numbers: List[int]) -> int: Calculates the sum of all numbers in the given list that contain only odd digits. Args: numbers (List[int]): A list of integers. Returns: int: The sum of integers that contain only odd digits. ``` # Input & Output - **Input**: A list of integers ( text{numbers} ). - **Output**: Returns a single integer, the sum of integers in the list that contain only odd digits. # Constraints - Each number in the input list will be non-negative. - The input list can contain up to (10^4) integers. - Optimize for efficiency given the constraints. # Performance Requirements - The function should efficiently handle the provided constraints. # Examples ```python assert sum_odd_digit_numbers([135, 246, 579, 111, 202]) == 825 # 135 + 579 + 111 = 825 assert sum_odd_digit_numbers([24, 68, 90, 482]) == 0 # no number with only odd digits assert sum_odd_digit_numbers([37, 55, 71, 333]) == 496 # 37 + 55 + 71 + 333 = 496 ``` # Explanation - 135, 579, and 111 are the only numbers in the input list containing only odd digits, hence their sum is 825. - In the second example, none of the numbers contain only odd digits, so the sum is 0. - In the third example, 37, 55, 71, and 333 contain only odd digits, so their sum is 496.","solution":"from typing import List def sum_odd_digit_numbers(numbers: List[int]) -> int: def has_only_odd_digits(n: int) -> bool: odd_digits = {\'1\', \'3\', \'5\', \'7\', \'9\'} return all(digit in odd_digits for digit in str(n)) return sum(num for num in numbers if has_only_odd_digits(num))"},{"question":"# Musical Note Scheduler Implement a system to schedule musical notes, where each note has a pitch and a time duration it should be played. There are two parts to this task: Part A: NoteScheduler This class manages a list of notes, ensuring they play in the order they\'re scheduled. Implement the following methods: 1. `__init__(self)`: Initializes an empty list for notes. 2. `add(self, pitch: str, duration: int)`: Adds a note with the given pitch (a string representing the musical note, e.g., \\"C4\\", \\"D#5\\") and duration (an integer representing milliseconds). Raise `ValueError` if the duration is not positive. 3. `remove(self) -> tuple`: Removes and returns the next note to be played (the first added note). Raise `ValueError` if the list is empty. 4. `__str__(self) -> str`: Returns a string representation of all notes in the scheduler. Part B: DynamicNoteScheduler This class extends `NoteScheduler`, allowing dynamic reordering based on priority. 1. `__init__(self)`: Initializes the superclass and adds an empty priority list. 2. `add(self, pitch: str, duration: int, priority: int)`: Adds a note with the given pitch, duration, and priority (higher priority values are played first). Raise `ValueError` if the duration is not positive or priority is not an integer. 3. `remove(self) -> tuple`: Removes and returns the highest-priority note (if two notes have the same priority, follow FIFO order). Raise `ValueError` if no notes are available. 4. `__str__(self) -> str`: Returns a string representation of all notes in the scheduler, ordered by priority and time added. # Input and Output * `add(pitch, duration)` accepts a pitch (string) and duration (integer). * `add(pitch, duration, priority)` accepts a pitch (string), duration (integer), and priority (integer). * `remove()` returns and removes the appropriate note tuple (pitch, duration). * Instances of the classes should handle situations where notes are added or removed correctly. # Performance Requirements Ensure that your implementation meets the following requirements: * `add`: O(1) * `remove`: O(n) for DynamicNoteScheduler * String representation should be clear and efficient. # Example ```python # Part A: NoteScheduler ns = NoteScheduler() ns.add(\\"C4\\", 500) ns.add(\\"E4\\", 300) ns.add(\\"G4\\", 200) print(ns) # [(\\"C4\\", 500), (\\"E4\\", 300), (\\"G4\\", 200)] ns.remove() # (\\"C4\\", 500) print(ns) # [(\\"E4\\", 300), (\\"G4\\", 200)] # Part B: DynamicNoteScheduler dns = DynamicNoteScheduler() dns.add(\\"C4\\", 500, 1) dns.add(\\"E4\\", 300, 2) dns.add(\\"G4\\", 200, 1) print(dns) # [(\\"E4\\", 300), (\\"C4\\", 500), (\\"G4\\", 200)] dns.remove() # (\\"E4\\", 300) print(dns) # [(\\"C4\\", 500), (\\"G4\\", 200)] ``` Implement the classes `NoteScheduler` and `DynamicNoteScheduler` with the specified methods and ensure your code passes the above examples.","solution":"class NoteScheduler: def __init__(self): self.notes = [] def add(self, pitch: str, duration: int): if duration <= 0: raise ValueError(\\"Duration must be positive\\") self.notes.append((pitch, duration)) def remove(self) -> tuple: if not self.notes: raise ValueError(\\"No notes to remove\\") return self.notes.pop(0) def __str__(self) -> str: return str(self.notes) class DynamicNoteScheduler(NoteScheduler): def __init__(self): super().__init__() self.priority_notes = [] def add(self, pitch: str, duration: int, priority: int): if duration <= 0: raise ValueError(\\"Duration must be positive\\") if not isinstance(priority, int): raise ValueError(\\"Priority must be an integer\\") self.priority_notes.append((priority, pitch, duration)) self.priority_notes.sort(key=lambda x: (-x[0], len(self.priority_notes))) def remove(self) -> tuple: if not self.priority_notes: raise ValueError(\\"No notes to remove\\") note = self.priority_notes.pop(0) return (note[1], note[2]) def __str__(self) -> str: return str([(note[1], note[2]) for note in self.priority_notes])"},{"question":"# Problem Statement A logistics company needs software that helps in efficiently managing their delivery routes. The software should calculate the shortest path for a delivery truck to visit multiple locations exactly once, starting and ending at the company\'s warehouse. Your task is to implement the Traveling Salesman Problem (TSP) using Dynamic Programming and memoization to find the shortest possible route that visits all given locations once and returns to the warehouse. # Requirements 1. Implement the Traveling Salesman Problem using Dynamic Programming. 2. Ensure efficient use of memoization to avoid redundant calculations. 3. Provide clear comments/documentation of the code to explain the logic. # Function Signature ```python def tsp_dp(locations: List[Tuple[int, int]], start: int = 0) -> Tuple[float, List[int]]: tsp_dp : solve the TSP using Dynamic Programming and memoization Parameters: locations (List[Tuple[int, int]]): List of (x, y) coordinates representing the locations. start (int): Starting location index, default is 0. Returns: Tuple[float, List[int]]: Minimum distance and the order of visiting locations. ``` # Input Constraints 1. **Locations**: List of tuples where each tuple represents coordinates (x, y) of a location. Length of the list is between 2 and 20. 2. **Starting Point**: An index in the list of locations indicating the starting location. # Output Return a tuple containing: 1. The minimum distance the delivery truck needs to travel to visit all locations and return to the starting point. 2. The order of visiting locations in the optimal route. # Example **Test the function with the following:** ```python locations = [(0, 0), (2, 3), (5, 6), (8, 8), (1, 5)] minimum_distance, optimal_route = tsp_dp(locations, start=0) print(f\\"Minimum Distance: {minimum_distance}\\") print(f\\"Optimal Route: {optimal_route}\\") ``` Expected Output: ```python Minimum Distance: XX.X # The computed minimum distance Optimal Route: [0, 1, 4, 2, 3, 0] # An example route where 0 is the index of the starting/ending point. ``` # Notes - Use Euclidean distance to calculate the distance between two locations. - Ensure the algorithm handles edge cases where the number of locations is minimal (e.g., 2 locations). - Test the solution with locations array of varying lengths and coordinates to ensure robustness.","solution":"from typing import List, Tuple import math import functools def tsp_dp(locations: List[Tuple[int, int]], start: int = 0) -> Tuple[float, List[int]]: tsp_dp : solve the TSP using Dynamic Programming and memoization Parameters: locations (List[Tuple[int, int]]): List of (x, y) coordinates representing the locations. start (int): Starting location index, default is 0. Returns: Tuple[float, List[int]]: Minimum distance and the order of visiting locations. def euclidean_distance(p1, p2): return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) n = len(locations) @functools.lru_cache(None) def dp(mask, pos): if mask == (1 << n) - 1: return euclidean_distance(locations[pos], locations[start]), [start] min_cost = float(\'inf\') next_pos_route = [] for next_pos in range(n): if mask & (1 << next_pos) == 0: new_mask = mask | (1 << next_pos) cost, route = dp(new_mask, next_pos) cost += euclidean_distance(locations[pos], locations[next_pos]) if cost < min_cost: min_cost = cost next_pos_route = [next_pos] + route return min_cost, next_pos_route min_distance, route = dp(1 << start, start) return min_distance, [start] + route"},{"question":"# Problem Statement You are required to implement a class that simulates the behavior of an online restaurant reservation system. The system should support adding new reservations, removing existing reservations, and querying available and booked time slots. # Requirements 1. **Class Definition**: Define the class `ReservationSystem`. 2. **Add Reservation Method**: Implement the `add_reservation` method that takes a `name` and a `time_slot` as input and adds the reservation to the system. 3. **Remove Reservation Method**: Implement the `remove_reservation` method that takes a `name` and `time_slot` and removes the corresponding reservation. 4. **Get Reservations Method**: Implement the `get_reservations` method that returns a list of all current reservations in the system. 5. **Get Available Slots Method**: Implement the `get_available_slots` method that returns a list of available time slots. 6. **Edge Cases Handling**: Handle edge cases such as trying to add a reservation for a time slot that is already booked or removing a reservation that doesn\'t exist. # Function Signature ```python class ReservationSystem: def __init__(self, available_slots: List[int]): self.available_slots = available_slots self.booked_slots = {} def add_reservation(self, name: str, time_slot: int) -> None: # Your code here def remove_reservation(self, name: str, time_slot: int) -> None: # Your code here def get_reservations(self) -> List[Tuple[str, int]]: # Your code here def get_available_slots(self) -> List[int]: # Your code here ``` # Input and Output * `__init__(self, available_slots: List[int]) -> None`: initializes the available time slots for the day. * `add_reservation(name: str, time_slot: int) -> None`: adds a reservation to the specified time slot. * `remove_reservation(name: str, time_slot: int) -> None`: removes the reservation from the specified time slot. * `get_reservations() -> List[Tuple[str, int]]`: returns a list of current reservations in the format (name, time_slot). * `get_available_slots() -> List[int]`: returns a list of time slots that are still available. # Example ```python # Initialize the system with available slots system = ReservationSystem([12, 13, 14, 15, 16]) system.add_reservation(\'Alice\', 14) system.add_reservation(\'Bob\', 15) print(system.get_reservations()) # Output: [(\'Alice\', 14), (\'Bob\', 15)] print(system.get_available_slots()) # Output: [12, 13, 16] system.remove_reservation(\'Alice\', 14) print(system.get_reservations()) # Output: [(\'Bob\', 15)] print(system.get_available_slots()) # Output: [12, 13, 14, 16] ``` # Performance Requirements * Ensure that all operations adhere to O(1) or O(n) time complexity where applicable. * Handle at least 10^5 reservation operations efficiently. # Evaluation Criteria * **Correctness**: Accurate implementation of all required methods. * **Efficiency**: Time and space complexity of the solution must meet the requirements. * **Robustness**: Handling edge cases and constraints properly. * **Code Quality**: Clean, readable, and maintainable code.","solution":"from typing import List, Tuple class ReservationSystem: def __init__(self, available_slots: List[int]): self.available_slots = set(available_slots) self.booked_slots = {} def add_reservation(self, name: str, time_slot: int) -> None: if time_slot in self.available_slots and time_slot not in self.booked_slots: self.booked_slots[time_slot] = name self.available_slots.remove(time_slot) def remove_reservation(self, name: str, time_slot: int) -> None: if time_slot in self.booked_slots and self.booked_slots[time_slot] == name: del self.booked_slots[time_slot] self.available_slots.add(time_slot) def get_reservations(self) -> List[Tuple[str, int]]: return [(name, time_slot) for time_slot, name in self.booked_slots.items()] def get_available_slots(self) -> List[int]: return sorted(self.available_slots)"},{"question":"# Question Scenario: You are working on a data analysis project and need to compute the Pearson correlation coefficient between two lists of numbers. The Pearson correlation coefficient is a measure of the linear relationship between two datasets. Task: Write a function `compute_pearson_correlation(list_x: List[float], list_y: List[float]) -> float:` that calculates the Pearson correlation coefficient between two lists of numbers. Your implementation should handle edge cases appropriately, including lists with little to no variation. **Input:** - `list_x` (List[float]): A list of floats representing the first dataset. - `list_y` (List[float]): A list of floats representing the second dataset. **Output:** - `float`: The Pearson correlation coefficient between `list_x` and `list_y`, ranging from -1 to 1. **Constraints:** - `1 <= len(list_x) == len(list_y) <= 10^5` - Each float value in `list_x` and `list_y` will be in the range of `-10^6` to `10^6` - Handle cases where variance in lists is zero, which implies no linear correlation can be calculated (should return 0.0). **Performance Requirement:** - Your solution should be optimized to work efficiently for the upper limit of input constraints. Example: ```python assert compute_pearson_correlation([1, 2, 3], [4, 5, 6]) == 1.0 assert compute_pearson_correlation([1, 0, -1], [-1, 0, 1]) == -1.0 assert compute_pearson_correlation([1, 2, 3], [1, 2, 3]) == 1.0 assert compute_pearson_correlation([1, 2, 3], [0, 0, 0]) == 0.0 # Zero variance case ```","solution":"from typing import List import math def compute_pearson_correlation(list_x: List[float], list_y: List[float]) -> float: if len(list_x) != len(list_y): raise ValueError(\\"Lists must have the same length\\") n = len(list_x) if n == 0: raise ValueError(\\"Lists must not be empty\\") mean_x = sum(list_x) / n mean_y = sum(list_y) / n sum_diff_prod = sum((x - mean_x) * (y - mean_y) for x, y in zip(list_x, list_y)) sum_diff_sq_x = sum((x - mean_x) ** 2 for x in list_x) sum_diff_sq_y = sum((y - mean_y) ** 2 for y in list_y) if sum_diff_sq_x == 0 or sum_diff_sq_y == 0: return 0.0 return sum_diff_prod / math.sqrt(sum_diff_sq_x * sum_diff_sq_y)"},{"question":"# Coding Assessment Question Context: You are designing a health tracking application that records users\' daily step counts. To encourage healthy habits, the app sends a personalized notification when a user reaches specific milestones in their step count goal. Your task is to implement a function that determines when to send these notifications based on predefined milestone thresholds. Task: Create a function `notify_milestones` that processes users\' step data and determines which milestones have been hit on a given day. Requirements: 1. **Function Signature**: ```python def notify_milestones(step_data: dict, milestones: list) -> dict: ``` 2. **Input**: * `step_data` (dict): A dictionary where keys are user IDs (strings) and values are lists of daily step counts (integers). * `milestones` (list): A list of integers representing the step count milestones to be notified about (in ascending order). 3. **Output**: * `dict`: A dictionary where each key is a user ID and each value is a list of milestones achieved on the most recent day. 4. **Constraints**: * Ensure milestones are notified in the order they were reached. * Skip any user whose latest step count does not reach any new milestone. 5. **Example Usage**: ```python step_data = { \\"user1\\": [1000, 2000, 3000], \\"user2\\": [500, 1500, 2500], \\"user3\\": [6000, 7000, 8000] } milestones = [1000, 5000, 10000] result = notify_milestones(step_data, milestones) # Expected Output # { # \\"user1\\": [1000], # \\"user2\\": [], # \\"user3\\": [1000, 5000] # } ``` Hints: * Ensure you check only the latest step count for each user. * Consider using a set or an ordered collection to track milestones in an efficient manner. Good luck!","solution":"def notify_milestones(step_data: dict, milestones: list) -> dict: Determines which milestones have been hit for each user on the most recent day. Parameters: step_data (dict): A dictionary where keys are user IDs (strings) and values are lists of daily step counts (integers). milestones (list): A list of integers representing the step count milestones. Returns: dict: A dictionary where each key is a user ID and each value is a list of milestones achieved on the most recent day. result = {} for user_id, steps in step_data.items(): latest_steps = steps[-1] # Get the most recent step count user_milestones = [] for milestone in milestones: if milestone <= latest_steps: user_milestones.append(milestone) result[user_id] = user_milestones return result"},{"question":"# Fibonacci Sequence Generation You have been asked to implement a function that generates the first `n` numbers in the Fibonacci sequence. The Fibonacci sequence is defined as follows: - `F(0) = 0` - `F(1) = 1` - For all `n ≥ 2`, `F(n) = F(n-1) + F(n-2)` Your tasks are to complete the following functions: 1. **`fibonacci_a_b(a: int, b: int) -> list[int]`**: - Generates the Fibonacci sequence starting with values `a` and `b`. - Returns a list of Fibonacci numbers starting with `a` and `b`. 2. **`first_n_fibonacci(n: int) -> list[int]`**: - Generates the first `n` numbers in the Fibonacci sequence using the `fibonacci_a_b` function. - Should raise a `ValueError` if `n` is less than 1. # Function Signatures ```python def fibonacci_a_b(a: int, b: int) -> list[int]: Generates a Fibonacci sequence starting with the values a and b. :param a: int, the first number in the sequence. :param b: int, the second number in the sequence. :return: list[int], the Fibonacci sequence starting with a and b. pass def first_n_fibonacci(n: int) -> list[int]: Generates the first n numbers in the Fibonacci sequence. :param n: int, the number of Fibonacci numbers to generate. :return: list[int], the first n numbers in the Fibonacci sequence. :raises ValueError: if n is less than 1. pass ``` # Constraints - `n >= 1` - `a` and `b` must be non-negative integers. # Performance Requirements Your solution should aim to minimize both time and space complexity. # Example ```python if __name__ == \\"__main__\\": # Example for the task try: n = int(input(\\"Please enter the number of Fibonacci numbers to generate: \\").strip()) fibonacci_numbers = first_n_fibonacci(n) print(f\\"First {n} Fibonacci numbers: {fibonacci_numbers}\\") except ValueError as e: print(e) ``` Write your code to implement the `fibonacci_a_b` and `first_n_fibonacci` functions.","solution":"def fibonacci_a_b(a: int, b: int) -> list[int]: Generates a Fibonacci sequence starting with the values a and b. :param a: int, the first number in the sequence. :param b: int, the second number in the sequence. :return: list[int], the Fibonacci sequence starting with a and b. sequence = [a, b] return sequence def first_n_fibonacci(n: int) -> list[int]: Generates the first n numbers in the Fibonacci sequence. :param n: int, the number of Fibonacci numbers to generate. :return: list[int], the first n numbers in the Fibonacci sequence. :raises ValueError: if n is less than 1. if n < 1: raise ValueError(\\"n must be greater than 0\\") sequence = fibonacci_a_b(0, 1) while len(sequence) < n: sequence.append(sequence[-1] + sequence[-2]) return sequence[:n]"},{"question":"# Problem Statement You are given a string of lowercase letters. Your task is to construct a compressed version of the string using the Run-Length Encoding (RLE) technique. You will implement: 1. A function to compress the given string. 2. A function to decompress the compressed string back to its original form. # Function Specifications Function 1: `compress_string` - **Input**: A string `input_string`. - **Output**: A compressed string using the RLE technique. ```python def compress_string(input_string: str) -> str: pass ``` Function 2: `decompress_string` - **Input**: A compressed string `compressed_string` in RLE format. - **Output**: The original string before compression. ```python def decompress_string(compressed_string: str) -> str: pass ``` # Constraints - The input string will have a length between 1 and 200,000. - The input string will consist of lowercase English letters only. - Ensure compression results in a string where letters are followed directly by their count. If a letter appears once, it should still be followed by \'1\'. # Example ```python input_string = \\"aaabbcdee\\" compressed_string = compress_string(input_string) print(compressed_string) # Expected output: \\"a3b2c1d1e2\\" decompressed_string = decompress_string(compressed_string) print(decompressed_string) # Expected output: \\"aaabbcdee\\" input_string = \\"a\\" compressed_string = compress_string(input_string) print(compressed_string) # Expected output: \\"a1\\" decompressed_string = decompress_string(compressed_string) print(decompressed_string) # Expected output: \\"a\\" ``` # Notes - Ensure your RLE compression correctly handles edge cases such as strings with no repeated characters or strings entirely made up of repeated characters. - The decompression function should accurately reconstruct the original string even if the compressed version contains single character runs. - Optimize your solution to handle the largest input sizes efficiently, both in terms of time and space.","solution":"def compress_string(input_string: str) -> str: if not input_string: return \\"\\" compressed = [] count = 1 for i in range(1, len(input_string)): if input_string[i] == input_string[i - 1]: count += 1 else: compressed.append(input_string[i - 1] + str(count)) count = 1 compressed.append(input_string[-1] + str(count)) return \\"\\".join(compressed) def decompress_string(compressed_string: str) -> str: if not compressed_string: return \\"\\" decompressed = [] i = 0 while i < len(compressed_string): char = compressed_string[i] count = 0 i += 1 while i < len(compressed_string) and compressed_string[i].isdigit(): count = count * 10 + int(compressed_string[i]) i += 1 decompressed.append(char * count) return \\"\\".join(decompressed)"},{"question":"# Context: You are tasked with writing a function that evaluates postfix arithmetic expressions (which involve standard binary operators: +, -, *, /, ^) and return the result as an integer. The function should handle edge cases and provide meaningful error messages for invalid expressions, such as malformed expressions or division by zero. # Problem Statement: Write a function `evaluate_postfix(postfix: str) -> int` that evaluates a postfix expression and returns the result as an integer. The function should ignore any spaces in the input string and ensure valid arithmetic expressions are considered. Your function should raise a `ValueError` for expressions with invalid formats or operations, such as division by zero. # Input Format: - A string `postfix` representing the arithmetic expression. # Output Format: - Return an integer representing the result of the postfix expression. - Raise a `ValueError` if the input expression is malformed or contains invalid operations. # Constraints: - The input string may contain spaces, digits (0-9), and the operators `+`, `-`, `*`, `/`, `^`. # Function Signature: ```python def evaluate_postfix(postfix: str) -> int: ``` # Example: Example 1: ```python input: \\"3 4 +\\" output: 7 ``` Example 2: ```python input: \\"10 2 /\\" output: 5 ``` Example 3: ```python input: \\"5 1 2 + 4 * + 3 -\\" output: 14 ``` Example 4: ```python input: \\"4 0 /\\" Raises ValueError: \\"division by zero\\" ``` Example 5: ```python input: \\"4 +\\" Raises ValueError: \\"invalid expression\\" ``` # Notes: - Ensure your implementation can correctly parse and evaluate the expression format as specified. - Implement proper error handling for invalid expressions and division by zero. - Efficiency in terms of time and space complexity is crucial for handling long expressions.","solution":"def evaluate_postfix(postfix: str) -> int: Evaluates a postfix arithmetic expression and returns the result as an integer. Parameters: postfix (str): A string representing the postfix arithmetic expression. Returns: int: The result of the expression. Raises: ValueError: If the expression is malformed or contains invalid operations. if not postfix: raise ValueError(\\"invalid expression\\") postfix = postfix.strip() stack = [] operators = set([\'+\', \'-\', \'*\', \'/\', \'^\']) tokens = postfix.split() for token in tokens: if token.isdigit(): stack.append(int(token)) elif token in operators: if len(stack) < 2: raise ValueError(\\"invalid expression\\") b = stack.pop() a = stack.pop() if token == \'+\': stack.append(a + b) elif token == \'-\': stack.append(a - b) elif token == \'*\': stack.append(a * b) elif token == \'/\': if b == 0: raise ValueError(\\"division by zero\\") stack.append(a // b) elif token == \'^\': stack.append(a ** b) else: raise ValueError(f\\"invalid token: {token}\\") if len(stack) != 1: raise ValueError(\\"invalid expression\\") return stack[0]"},{"question":"# Warehouse Management using Depth-First Search Scenario You are tasked with designing a navigation system for an autonomous drone that operates inside a warehouse. The drone needs to find a path from its current location to ensure it can reach any specified item location within the warehouse. The warehouse is modeled as a grid, where some cells are occupied by shelves (obstacles) that the drone cannot pass through. Objective Implement the `DepthFirstSearchPath` class to find a path from the drone\'s starting position to the target item using Depth-First Search (DFS). Your solution should demonstrate an understanding of stack-based search algorithms. Requirements 1. **Input**: - A grid represented as a 2D list of integers, where `0` represents free space and `1` represents obstacles. - A tuple `start` representing the starting coordinates `(row, col)`. - A tuple `goal` representing the coordinates of the target item `(row, col)`. 2. **Output**: - A list of coordinates (tuples) forming the path from `start` to `goal`, or `None` if no path exists. 3. **Constraints**: - The grid will have dimensions `m x n`, where `1 <= m, n <= 1000`. - The start and goal coordinates will always be valid and within bounds. - The path should avoid revisiting any already visited nodes to prevent infinite loops. 4. **Performance**: - The solution should efficiently handle grids up to the maximum size of `1000x1000`. Function Signature ```python class DepthFirstSearchPath: def __init__(self, grid: list[list[int]], start: tuple[int, int], goal: tuple[int, int]): # initialization code def search(self) -> list[tuple[int, int]] | None: # code to perform search and return the path ``` Hints - Use a stack to implement the DFS algorithm for pathfinding. - Keep track of visited nodes to avoid cycles and infinite loops. - Ensure that you manage the stack and visited nodes efficiently to maintain performance. Example ```python grid = [ [0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0], [1, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0], ] dfs = DepthFirstSearchPath(grid, (0, 0), (6, 6)) path = dfs.search() print(path) # Expected output: [(0, 0), (1, 0), (2, 0), ..., (6, 6)] if a path exists ```","solution":"class DepthFirstSearchPath: def __init__(self, grid: list[list[int]], start: tuple[int, int], goal: tuple[int, int]): self.grid = grid self.start = start self.goal = goal self.m = len(grid) self.n = len(grid[0]) self.visited = set() self.path = [] def search(self) -> list[tuple[int, int]] | None: stack = [(self.start, [self.start])] while stack: (current_position, current_path) = stack.pop() if current_position == self.goal: return current_path if current_position in self.visited: continue self.visited.add(current_position) row, col = current_position for row_offset, col_offset in [(-1, 0), (1, 0), (0, -1), (0, 1)]: new_row, new_col = row + row_offset, col + col_offset if 0 <= new_row < self.m and 0 <= new_col < self.n and self.grid[new_row][new_col] == 0: stack.append(((new_row, new_col), current_path + [(new_row, new_col)])) return None"},{"question":"# Problem Statement Implement functions to rotate a square matrix by 90 degrees clockwise and check if the rotation maintains matrix properties. These operations are fundamental in image processing and matrix manipulation algorithms. # Function Definitions 1. `rotate_matrix_90(matrix: np.ndarray) -> np.ndarray` - **Input**: A square matrix represented as a 2D numpy array. - **Output**: The matrix after it has been rotated by 90 degrees clockwise. 2. `is_property_preserved(original_matrix: np.ndarray, rotated_matrix: np.ndarray) -> bool` - **Input**: - `original_matrix`: A square matrix represented as a 2D numpy array. - `rotated_matrix`: The matrix obtained after rotating `original_matrix` by 90 degrees clockwise. - **Output**: `True` if the rotated matrix preserves the specified properties of the original matrix (e.g., symmetry, identity), `False` otherwise. - **Constraints**: - The matrices are square. - Ensure valid handling even if the matrix size is 1x1. # Example ```python import numpy as np matrix = np.array([ [1, 2, 3], [4, 5, 6], [7, 8, 9] ]) rotated_matrix = np.array([ [7, 4, 1], [8, 5, 2], [9, 6, 3] ]) assert np.array_equal(rotate_matrix_90(matrix), rotated_matrix) assert is_property_preserved(matrix, rotated_matrix) == False sym_matrix = np.array([ [1, 0, 0], [0, 1, 0], [0, 0, 1] ]) rotated_sym_matrix = np.array([ [0, 0, 1], [0, 1, 0], [1, 0, 0] ]) assert np.array_equal(rotate_matrix_90(sym_matrix), rotated_sym_matrix) assert is_property_preserved(sym_matrix, rotated_sym_matrix) == True ``` # Note - Use assertions to validate the functionality and correctness of the output. - Include edge case handling such as when the matrix is of the smallest possible size (e.g., 1x1). - The specified properties to be preserved can include symmetry (if a matrix is symmetric before rotation) or identity properties.","solution":"import numpy as np def rotate_matrix_90(matrix): Rotates the given square matrix by 90 degrees clockwise. :param matrix: 2D numpy array representing the square matrix :return: 2D numpy array representing the rotated matrix return np.rot90(matrix, -1) def is_property_preserved(original_matrix, rotated_matrix): Checks if the rotated matrix preserves properties of the original matrix. :param original_matrix: 2D numpy array representing the original square matrix :param rotated_matrix: 2D numpy array representing the rotated matrix :return: Boolean indicating if specified properties are preserved # Let\'s consider symmetry preservation for this example return np.array_equal(original_matrix, original_matrix.T) and np.array_equal(rotated_matrix, rotated_matrix.T)"},{"question":"# Problem Description You are working for a company that analyzes data from various sensors. One of your tasks involves implementing a system that processes signals represented as time series data. The system needs to identify peaks in the signal, which are defined as points that are higher than their immediate neighbors. # Task Write a function `find_peaks` which: 1. Takes an input list of integers representing time series data. 2. Identifies the indices of all peaks in the list. 3. Returns a list of indices where the data has peaks. # Function Signature ```python def find_peaks(data: List[int]) -> List[int]: # Your implementation here ``` # Input - `data`: A list of integers representing time series data points. # Output - Returns a list of integers representing the indices of peaks in the input list. # Example ```python data = [2, 4, 1, 3, 5, 1] result = find_peaks(data) print(result) # Output: [1, 4] ``` # Constraints 1. The input list length `n` is between 1 and 10^6. 2. Each data point is an integer between -10^9 and 10^9. # Performance Requirements - Your implementation should efficiently handle large lists up to the maximum constraint. # Notes - A peak is defined as a data point that is greater than its immediate neighbors. - If a peak occurs at the first or last element (single valid neighbor), it should also be considered a peak. - Ensure the solution handles edge cases, such as an empty list or list with all identical values.","solution":"from typing import List def find_peaks(data: List[int]) -> List[int]: Identifies the indices of peaks in the time series data. Parameters: data (List[int]): A list of integers representing time series data points. Returns: List[int]: A list of indices where the data has peaks. if not data: return [] n = len(data) peaks = [] for i in range(n): if i == 0: if n == 1 or data[i] > data[i + 1]: peaks.append(i) elif i == n - 1: if data[i] > data[i - 1]: peaks.append(i) else: if data[i] > data[i - 1] and data[i] > data[i + 1]: peaks.append(i) return peaks"},{"question":"# Sorting and Filtering Students by Grade You are working for an educational software company that handles student records for various courses. Each student has a name and a grade, and these records are represented as a list of dictionaries. You need to implement a filtering and sorting function that can process these records based on specific criteria. # Task: Write a function `filter_and_sort_students(students: List[Dict[str, Union[str, int]]], passing_grade: int) -> List[str]` that takes as input a list of student records and a passing grade, and returns a list of names of students who passed, sorted by their grades in descending order. If two students have the same grade, sort their names alphabetically in ascending order. # Input: * `students` - A list of dictionaries, where each dictionary has two keys: `\\"name\\"` (a string representing the student\'s name) and `\\"grade\\"` (an integer between 0 and 100 representing the student\'s grade). * `passing_grade` - An integer between 0 and 100 representing the minimum grade required to pass. # Output: * A list of names of students who have grades greater than or equal to the `passing_grade`, sorted by their grades in descending order, and by their names alphabetically if grades are equal. # Constraints: * The number of students will be between 1 and 1000. * Names will be non-empty strings consisting of up to 100 characters. * Grades are integers between 0 and 100. # Example: ```python students = [ {\\"name\\": \\"Alice\\", \\"grade\\": 85}, {\\"name\\": \\"Bob\\", \\"grade\\": 95}, {\\"name\\": \\"Charlie\\", \\"grade\\": 85}, {\\"name\\": \\"David\\", \\"grade\\": 78} ] passing_grade = 80 output = filter_and_sort_students(students, passing_grade) # Expected output: [\\"Bob\\", \\"Alice\\", \\"Charlie\\"] ``` # Instructions: 1. Filter the list of students to include only those whose grade is greater than or equal to the `passing_grade`. 2. Sort the filtered list primarily by the student\'s grade in descending order. 3. For students with the same grade, sort their names alphabetically in ascending order. 4. Extract and return the list of names from the sorted records.","solution":"from typing import List, Dict, Union def filter_and_sort_students(students: List[Dict[str, Union[str, int]]], passing_grade: int) -> List[str]: # Filter students who passed passed_students = [student for student in students if student[\'grade\'] >= passing_grade] # Sort primarily by grade in descending order, then by name in ascending order passed_students.sort(key=lambda x: (-x[\'grade\'], x[\'name\'])) # Extract and return the list of names return [student[\'name\'] for student in passed_students]"},{"question":"# Scenario You are developing a library management system. A central feature is tracking which books are in stock and which have been checked out. Each book in the library has a unique identifier and a title. Users can borrow and return books, changing the status of each book between \'in stock\' and \'checked out\'. # Task Write a function to manage the borrowing and returning of books. The function should update the status of a book based on the action (\'borrow\' or \'return\') performed and track the number of times each book has been borrowed. # Function Signature ```python def update_book_status(action: str, book_id: str, catalog: dict) -> dict: pass ``` # Input and Output * **Input**: * `action`: A string indicating the action, which can either be \'borrow\' or \'return\'. * `book_id`: A string representing the unique identifier of the book. * `catalog`: A dictionary where keys are book IDs and values are dictionaries containing \'title\', \'status\', and \'borrow_count\'. * **Output**: * Returns the updated catalog dictionary. # Constraints * The `action` should be strictly \'borrow\' or \'return\'. * The `book_id` should exist in the `catalog`. * If the action is \'borrow\' and the book is already checked out, no changes should be made. * If the action is \'return\' and the book is already in stock, no changes should be made. * The `catalog` dictionary format is as follows: ```python catalog = { \\"book1\\": {\\"title\\": \\"Book One\\", \\"status\\": \\"in stock\\", \\"borrow_count\\": 0}, \\"book2\\": {\\"title\\": \\"Book Two\\", \\"status\\": \\"checked out\\", \\"borrow_count\\": 1}, ... } ``` # Example ```python catalog = { \\"book1\\": {\\"title\\": \\"Book One\\", \\"status\\": \\"in stock\\", \\"borrow_count\\": 0}, \\"book2\\": {\\"title\\": \\"Book Two\\", \\"status\\": \\"checked out\\", \\"borrow_count\\": 1} } # Borrowing a book that is in stock updated_catalog = update_book_status(\'borrow\', \'book1\', catalog) print(updated_catalog) # Expected output: # { # \\"book1\\": {\\"title\\": \\"Book One\\", \\"status\\": \\"checked out\\", \\"borrow_count\\": 1}, # \\"book2\\": {\\"title\\": \\"Book Two\\", \\"status\\": \\"checked out\\", \\"borrow_count\\": 1} # } # Returning a book that is checked out updated_catalog = update_book_status(\'return\', \'book2\', updated_catalog) print(updated_catalog) # Expected output: # { # \\"book1\\": {\\"title\\": \\"Book One\\", \\"status\\": \\"checked out\\", \\"borrow_count\\": 1}, # \\"book2\\": {\\"title\\": \\"Book Two\\", \\"status\\": \\"in stock\\", \\"borrow_count\\": 1} # } ``` # Performance Requirements Ensure the function handles large catalogs efficiently and accurately updates the book statuses and borrow counts based on the actions performed.","solution":"def update_book_status(action: str, book_id: str, catalog: dict) -> dict: Updates the status of a book in the catalog based on the given action. Args: action (str): The action to perform - \'borrow\' or \'return\'. book_id (str): The unique identifier of the book. catalog (dict): The catalog of books with their details. Returns: dict: The updated catalog dictionary. if book_id not in catalog: raise ValueError(f\\"Book ID \'{book_id}\' does not exist in the catalog.\\") if action not in [\'borrow\', \'return\']: raise ValueError(\\"Action must be either \'borrow\' or \'return\'.\\") book_details = catalog[book_id] if action == \'borrow\' and book_details[\'status\'] == \'in stock\': book_details[\'status\'] = \'checked out\' book_details[\'borrow_count\'] += 1 elif action == \'return\' and book_details[\'status\'] == \'checked out\': book_details[\'status\'] = \'in stock\' return catalog"},{"question":"# Problem Statement Given a square matrix `n x n`, write a function `rotate_matrix` that rotates the matrix 90 degrees clockwise in place. # Function Signature ```python def rotate_matrix(matrix: list[list[int]]) -> None: pass ``` # Input * `matrix`: A list of lists of integers, representing an `n x n` matrix where 1 <= n <= 1000. # Output The function should mutate the input matrix to be rotated 90 degrees clockwise. No return is necessary. # Constraints * The function should rotate the matrix in place, meaning you cannot use additional arrays or lists. * The solution should have a time complexity of O(n^2) and a space complexity of O(1). # Example ```python matrix1 = [ [1, 2, 3], [4, 5, 6], [7, 8, 9], ] rotate_matrix(matrix1) assert matrix1 == [ [7, 4, 1], [8, 5, 2], [9, 6, 3], ] matrix2 = [ [5, 1, 9, 11], [2, 4, 8, 10], [13, 3, 6, 7], [15, 14, 12, 16], ] rotate_matrix(matrix2) assert matrix2 == [ [15, 13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7, 10, 11], ] ``` # Notes * You can assume all elements in the input matrix are integers. * Remember to handle edge cases, such as the smallest possible matrix (1x1).","solution":"def rotate_matrix(matrix: list[list[int]]) -> None: Rotates an n x n matrix 90 degrees clockwise in place. n = len(matrix) # Transpose the matrix (rows become columns) for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row to get the final rotated matrix for i in range(n): matrix[i].reverse()"},{"question":"**Rotate Array** You are given an array of integers `arr` and a non-negative integer `k`. Your task is to rotate the array to the right by `k` steps, where `k` is non-negative. # Input - An integer array `arr` which can have any length from 1 to (10^5). - An integer `k` where (0 leq k leq 10^5). # Output - The rotated array as a list. # Constraints - The array `arr` can contain both negative and positive integers. - The array can be very large, so your solution should be efficient. # Example ```python arr = [1, 2, 3, 4, 5, 6, 7] k = 3 def rotate_array(arr: list, k: int) -> list: # Your code here if __name__ == \\"__main__\\": print(rotate_array(arr, k)) # Output should be [5, 6, 7, 1, 2, 3, 4] ``` Write the function `rotate_array` such that passing the above example `arr` and `k` returns the rotated array after shifting elements to the right by `k` steps.","solution":"def rotate_array(arr: list, k: int) -> list: Rotates the array to the right by k steps. :param arr: List of integers. :param k: Non-negative integer denoting steps to rotate. :return: Rotated list of integers. if len(arr) == 0: return arr k = k % len(arr) # Normalize k to prevent unnecessary full rotations return arr[-k:] + arr[:-k]"},{"question":"# Coding Question Problem Statement A peak element in an array is an element that is strictly greater than its neighbors. Given an input array `nums`, write a function `find_peak_element` that finds a peak element in the array and returns its index. Suppose the array contains at least one peak element, and you may assume the array elements are distinct. The array boundary is considered to wrap around, meaning the first and last elements are also considered neighbors of each other. Function Signature ```python def find_peak_element(nums: list[int]) -> int: pass ``` Input - `nums` (List[int]): A list of integers representing the elements of the array. Output - Returns an integer representing the index of a peak element. Constraints - 1 <= len(nums) <= 10^4 - -10^4 <= nums[i] <= 10^4 for all valid `i`. Example ```python find_peak_element([1, 2, 3, 1]) # Output: 2 (3 is a peak element) find_peak_element([1, 2, 1, 3, 5, 6, 4]) # Output: 1 or 5 (both 2 and 6 are peak elements) find_peak_element([1]) # Output: 0 (1 is the only and thus peak element) find_peak_element([3, 4, 3, 2, 1]) # Output: 1 (4 is a peak element) ``` Performance Requirements - The function should run with an average time complexity of O(log n). # Edge Cases to Consider 1. An array with a single element should return that element\'s index as the peak. 2. Arrays with increasing or decreasing sequences. 3. Ensure the peak can be found efficiently in large arrays. Additional Information - The function should handle the wrap-around boundary condition where the first and last elements are considered neighbors. - If there are multiple peak elements, return the index of any one of them. - Ensure the function does not use more than O(n) space. Notes - Do not use any external libraries; rely on built-in functionalities and basic algorithmic approaches. - Focus particularly on achieving a logarithmic time complexity solution using techniques such as binary search.","solution":"def find_peak_element(nums: list[int]) -> int: Finds the index of a peak element in the array nums. A peak element is one that is strictly greater than its neighbors. left, right = 0, len(nums) - 1 while left < right: mid = (left + right) // 2 if nums[mid] > nums[(mid + 1) % len(nums)]: right = mid else: left = mid + 1 return left"},{"question":"# Question: Anagram Groups Identifier You are given a list of strings where each string may or may not have anagrams present within the list. Your task is to write a function that groups the anagrams together. Function Signature: ```python def group_anagrams(words: List[str]) -> List[List[str]]: ``` Input: - **words**: A list of strings. Each string contains only lowercase alphabets. Output: - **Result**: A list of lists, where each inner list contains strings that are anagrams of each other. Constraints & Notes: - Each string in the input list will have a length between 1 and 100. - The total number of strings will not exceed 10,000. - The order of the groups and the order of words within each group does not matter. Example: **Input**: ```python words = [\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"] ``` **Output**: ```python [ [\\"eat\\", \\"tea\\", \\"ate\\"], [\\"tan\\", \\"nat\\"], [\\"bat\\"] ] ``` Implementation Details: - An efficient way to find anagrams is to use the sorted string as a key. - Consider edge cases such as an empty list of words. - Optimize for time and space complexity, ensuring that your solution scales with larger inputs. # Notes: - You\'ll need to utilize appropriate data structures, like dictionaries, to facilitate the grouping process. - Ensure proper handling of input strings, and consider using helper functions where appropriate for clarity and modularity. Now, try coding the solution considering the given constraints and example.","solution":"from typing import List from collections import defaultdict def group_anagrams(words: List[str]) -> List[List[str]]: Groups the list of words into lists of anagrams. Args: words: List[str] - A list of strings containing only lowercase alphabets Returns: List[List[str]] - A list of lists, where each list contains words that are anagrams of each other anagram_dict = defaultdict(list) for word in words: sorted_word = \'\'.join(sorted(word)) anagram_dict[sorted_word].append(word) return list(anagram_dict.values())"},{"question":"# Find All Anagrams in a String Challenge You are given two strings, `s` and `p`. Your task is to find all the start indices of `p`\'s anagrams in `s`. The order of output does not matter. Requirements: 1. **Function**: Implement the function `find_anagrams(s: str, p: str) -> List[int]` which takes the two strings and returns a list of starting indices where anagrams of `p` begin in `s`. 2. **Anagram Definition**: An anagram is a permutation of a string, thus for example \\"abc\\" is an anagram of \\"bca\\". # Input: * `s: str` - The source string in which to search for anagrams. * `p: str` - The target anagram string. # Output: * A list of integers representing starting indices of the anagrams found in `s`. If none, the list should be empty. # Constraints: * `1 <= len(s) <= 10^4` * `1 <= len(p) <= 10^3` * Strings `s` and `p` consist of lowercase English letters only. # Example: Given `s = \\"cbaebabacd\\"` and `p = \\"abc\\"`, The output should be `[0, 6]` because: * The substring starting at index 0 is `\\"cba\\"` which is an anagram of `\\"abc\\"`. * The substring starting at index 6 is `\\"bac\\"` which is an anagram of `\\"abc\\"`. Given `s = \\"abab\\"` and `p = \\"ab\\"`, The output should be `[0, 1, 2]` because: * The substring starting at index 0 is `\\"ab\\"` which is an anagram of `\\"ab\\"`. * The substring starting at index 1 is `\\"ba\\"` which is an anagram of `\\"ab\\"`. * The substring starting at index 2 is `\\"ab\\"` which is an anagram of `\\"ab\\"`. # Note: - Make efficient use of sliding window technique or hash maps to avoid time complexity issues, especially given the maximum constraints. - Ensure the function returns indices in ascending order, but the order of discovering and returning them does not need to adhere to that. Good luck and happy coding!","solution":"from typing import List from collections import Counter def find_anagrams(s: str, p: str) -> List[int]: Find all start indices of p\'s anagrams in s. :param s: Source string to search in. :param p: Target anagram string. :return: List of starting indices of anagrams of p in s. len_s, len_p = len(s), len(p) if len_p > len_s: return [] # Count characters in p p_count = Counter(p) s_count = Counter() result = [] # Sliding window initially covering the first len_p-1 characters of s for i in range(len_p - 1): s_count[s[i]] += 1 # Slide the window over s, from len_p - 1 to len_s - 1 for i in range(len_p - 1, len_s): # Add the new character to the current window\'s character count s_count[s[i]] += 1 # Check if the current window matches the target anagram count if s_count == p_count: result.append(i - len_p + 1) # Remove the character that\'s sliding out of the window start_char = s[i - len_p + 1] if s_count[start_char] == 1: del s_count[start_char] else: s_count[start_char] -= 1 return result"},{"question":"# Challenging Coding Assessment Question Context Graphs are a fundamental data structure in computer science, utilized to model relationships between entities. Algorithms for traversing such graphs are crucial for various applications ranging from network routing to social networking services. The task today is to implement a graph traversal algorithm to detect cycles within a directed graph. Task Implement a function `detect_cycle_in_directed_graph(graph: Dict[int, List[int]]) -> bool` that determines whether there is a cycle within a given directed graph. Use the following guidelines and constraints to optimize the solution: Input and Output Formats: ```python def detect_cycle_in_directed_graph(graph: Dict[int, List[int]]) -> bool: pass # Example usage: print(detect_cycle_in_directed_graph({1: [2], 2: [3], 3: [4], 4: [5], 5: [1]})) # Output: True print(detect_cycle_in_directed_graph({1: [2], 2: [3], 3: [4], 4: [5], 5: []})) # Output: False ``` Constraints: * The graph is represented as an adjacency list. * The graph can consist of up to (10^4) nodes. * The graph may have multiple edges and self-loops. * Consider performance both in terms of time and space complexity. Requirements: 1. **Cycle Detection Algorithm:** Implement an efficient algorithm for detecting cycles, such as Depth-First Search (DFS) with recursion stack or Kahn’s algorithm for topological sorting. 2. **Tracking Visited Nodes:** Use a method to track which nodes have been visited and are part of the current recursion stack. 3. **Edge Case Handling:** Ensure the function handles various edge cases, including graphs with no edges, graphs with self-loops, and densely connected graphs. Performance Goals: * Aim for O(V + E) time complexity, ensuring the solution scales linearly with the number of vertices and edges. * Optimize space utilization to handle large input sizes without excessive memory usage. Implement the `detect_cycle_in_directed_graph` function, ensuring it adheres to the above specifications and performs optimally for all given constraints.","solution":"def detect_cycle_in_directed_graph(graph): Detects if there\'s a cycle in a directed graph. :param graph: A dictionary representing the graph as an adjacency list. :return: True if there is a cycle, False otherwise. visited = set() rec_stack = set() def dfs(node): if node in rec_stack: return True if node in visited: return False visited.add(node) rec_stack.add(node) for neighbor in graph.get(node, []): if dfs(neighbor): return True rec_stack.remove(node) return False for node in graph: if dfs(node): return True return False"},{"question":"# Problem Description: You are required to implement a function to find the k-th largest element in an unsorted list of integers. This problem tests your understanding of sorting algorithms and data manipulation techniques. # Function Signature: ```python def kth_largest_element(nums: list[int], k: int) -> int: This function finds the k-th largest element in an unsorted list of integers. Params: - nums (list[int]): A list of integers. - k (int): The position (1-based) of the largest element to find. Returns: - int: The k-th largest element in the list. Raises: - ValueError: If k is not a valid position for the given list. ``` # Input: * A list of integers `nums`, where the length of the list can range from `1` to `10^5`. * An integer `k` such that `1 <= k <= len(nums)`. # Output: * The k-th largest element in the list of integers. # Examples: ```python kth_largest_element([3, 2, 1, 5, 6, 4], 2) # should return 5 kth_largest_element([3, 2, 3, 1, 2, 4, 5, 5, 6], 4) # should return 4 kth_largest_element([1], 1) # should return 1 kth_largest_element([-1, -3, -2], 2) # should return -2 kth_largest_element([1, 1, 1, 1], 1) # should return 1 kth_largest_element([9, 8, 3, 4, 2], 5) # should return 2 ``` # Constraints: * Ensure that the function handles edge cases such as when the list contains duplicates or when extreme values are present. * The implementation should be efficient and capable of handling the upper limits of input size. # Notes: * You may assume that the inputs will always be valid integers within the list. * Consider using efficient algorithms such as Quickselect or Heap for optimal performance. # Guidelines: * Handle cases where `k` might be at the boundaries (i.e., 1 or the length of the list). * Ensure that the solution is efficient in terms of both time and space complexity, ideally aiming for O(n) time complexity on average. * Treat `k` as a 1-based index according to the problem description. This new question integrates well with the existing set by maintaining a similar level of complexity, ensuring efficient implementation, and covering a core programming concept related to data manipulation and algorithms.","solution":"import heapq def kth_largest_element(nums: list[int], k: int) -> int: Finds the k-th largest element in an unsorted list of integers. Params: - nums (list[int]): A list of integers. - k (int): The position (1-based) of the largest element to find. Returns: - int: The k-th largest element in the list. Raises: - ValueError: If k is not a valid position for the given list. if k < 1 or k > len(nums): raise ValueError(\\"k is not a valid position for the given list.\\") # Use a min-heap (of size k) to find the k-th largest element. heap = nums[:k] heapq.heapify(heap) for num in nums[k:]: if num > heap[0]: heapq.heappop(heap) heapq.heappush(heap, num) return heap[0]"},{"question":"# Prime Number Sequence Checker Background You are developing a gaming application that involves a numeric puzzle. One of the challenges requires identifying special sequences of numbers that have unique properties. Each sequence is a series of prime numbers following a specific pattern. Task Implement a function `is_prime_pattern` that checks if a given list of numbers forms a valid prime pattern as defined by the game\'s rules. Requirements 1. A valid prime pattern is a sequence where each term after the first is the next consecutive prime number. 2. Implement a helper function `is_prime(n)` to check if a number is prime. 3. Implement the main function `is_prime_pattern` that: * Takes a list of integers as input. * Returns `True` if the sequence forms a valid prime pattern, otherwise returns `False`. Function Signature ```python def is_prime_pattern(sequence: list) -> bool: ``` Parameters * `sequence` (list): A list of integers to check for the prime pattern. Constraints * Sequence length can be from 1 to 1000. * The integers in the sequence are positive numbers. Example Usage ```python # Check if the sequence [3, 5, 7, 11, 13] forms a valid prime pattern result = is_prime_pattern([3, 5, 7, 11, 13]) print(result) # Output: True # Check if the sequence [2, 4, 6, 8] forms a valid prime pattern result = is_prime_pattern([2, 4, 6, 8]) print(result) # Output: False # Check if the sequence [17, 19, 23, 29] forms a valid prime pattern result = is_prime_pattern([17, 19, 23, 29]) print(result) # Output: True # Check if the sequence [5] forms a valid prime pattern (single prime number is valid) result = is_prime_pattern([5]) print(result) # Output: True ``` # Solution ```python def is_prime(n): if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def next_prime(n): prime = n + 1 while not is_prime(prime): prime += 1 return prime def is_prime_pattern(sequence): if not sequence: return False if len(sequence) == 1: return is_prime(sequence[0]) for i in range(len(sequence) - 1): if not is_prime(sequence[i]) or sequence[i + 1] != next_prime(sequence[i]): return False return True # Example usage print(is_prime_pattern([3, 5, 7, 11, 13])) # Output: True print(is_prime_pattern([2, 4, 6, 8])) # Output: False print(is_prime_pattern([17, 19, 23, 29])) # Output: True print(is_prime_pattern([5])) # Output: True ```","solution":"def is_prime(n): Check if a number n is prime. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def next_prime(n): Get the next prime number after n. prime = n + 1 while not is_prime(prime): prime += 1 return prime def is_prime_pattern(sequence): Check if the given sequence is a valid prime pattern. if not sequence: return False if len(sequence) == 1: return is_prime(sequence[0]) for i in range(len(sequence) - 1): if not is_prime(sequence[i]) or sequence[i + 1] != next_prime(sequence[i]): return False return True"},{"question":"# Problem: **Circular Queue Implementation** You are assigned to implement a circular queue, an advanced data structure that efficiently utilizes space by treating the queue as a circular buffer. This problem will assess your understanding of queues, buffer handling, and edge cases. Required Methods and Constraints: 1. **enqueue(element)**: Add an element to the end of the circular queue. - Input: An integer element - Output: None - Constraint: Prevent queue overflow. 2. **dequeue()**: Remove an element from the front of the circular queue. - Input: None - Output: An integer element that was removed - Constraint: Prevent queue underflow. 3. **front()**: Get the front item from the queue without removing it. - Input: None - Output: The front item of the queue (integer) 4. **rear()**: Get the last item from the queue without removing it. - Input: None - Output: The last item of the queue (integer) 5. **isEmpty()**: Check whether the queue is empty. - Input: None - Output: Boolean value indicating if the queue is empty 6. **isFull()**: Check whether the queue is full. - Input: None - Output: Boolean value indicating if the queue is full Input and Output Formats: 1. **enqueue(element)**: - Input: Integer element - Output: None 2. **dequeue()**: - Input: None - Output: Integer element 3. **front()**: - Input: None - Output: Integer element 4. **rear()**: - Input: None - Output: Integer element 5. **isEmpty()**: - Input: None - Output: Boolean 6. **isFull()**: - Input: None - Output: Boolean # Constraints: - All operations must perform in O(1) time complexity. - Handle the circular nature of enqueue and dequeue operations properly. - Ensure checking for overflow and underflow conditions correctly. Example: ```python CQ = CircularQueue(3) CQ.enqueue(1) CQ.enqueue(2) CQ.enqueue(3) print(CQ.isFull()) # Output: True print(CQ.front()) # Output: 1 print(CQ.rear()) # Output: 3 CQ.dequeue() CQ.enqueue(4) print(CQ.front()) # Output: 2 print(CQ.rear()) # Output: 4 print(CQ.isEmpty()) # Output: False ``` Implement the `CircularQueue` class that includes these methods and thoroughly test them to ensure correctness.","solution":"class CircularQueue: def __init__(self, k): Initialize the data structure with maximum size k. self.k = k self.queue = [None] * k self.head = -1 self.tail = -1 def enqueue(self, value): Insert an element into the circular queue. if self.isFull(): raise Exception(\\"Queue is full.\\") if self.isEmpty(): self.head = 0 self.tail = (self.tail + 1) % self.k self.queue[self.tail] = value def dequeue(self): Delete an element from the circular queue. if self.isEmpty(): raise Exception(\\"Queue is empty.\\") removed_element = self.queue[self.head] self.queue[self.head] = None if self.head == self.tail: self.head = -1 self.tail = -1 else: self.head = (self.head + 1) % self.k return removed_element def front(self): Get the front element of the queue. if self.isEmpty(): raise Exception(\\"Queue is empty.\\") return self.queue[self.head] def rear(self): Get the last element of the queue. if self.isEmpty(): raise Exception(\\"Queue is empty.\\") return self.queue[self.tail] def isEmpty(self): Check if the queue is empty. return self.head == -1 def isFull(self): Check if the queue is full. return (self.tail + 1) % self.k == self.head"},{"question":"# Coding Question: Efficient Task Assignment in a Task Queue **Scenario**: You are developing a task management system that handles the assignment of tasks to workers. The system should ensure that tasks are distributed evenly amongst workers to prevent any one worker from being overloaded. You also want to maintain efficiency and avoid any redundant task assignment checks. **Requirements**: 1. Implement a function `assign_tasks(tasks: List[str], workers: List[str]) -> Dict[str, List[str]]` that assigns tasks to workers in a round-robin fashion. 2. The function should return a dictionary where each key is a worker’s name, and the value is a list of tasks assigned to that worker. 3. Ensure that tasks are distributed as evenly as possible amongst the workers. **Input**: * `tasks` - A list of task names (non-empty strings). * `workers` - A list of worker names (non-empty strings). **Output**: * A dictionary where keys are worker names and values are lists of tasks assigned to that worker. **Constraints**: * The number of tasks will be between 1 and 1000. * The number of workers will be between 1 and 50. * Each task and worker name is a non-empty string with a maximum length of 100 characters. **Example**: ```python from typing import List, Dict def assign_tasks(tasks: List[str], workers: List[str]) -> Dict[str, List[str]]: # Your implementation here pass # Example use case tasks = [\\"Task1\\", \\"Task2\\", \\"Task3\\", \\"Task4\\", \\"Task5\\"] workers = [\\"Worker1\\", \\"Worker2\\", \\"Worker3\\"] print(assign_tasks(tasks, workers)) # Expected Output: # { # \\"Worker1\\": [\\"Task1\\", \\"Task4\\"], # \\"Worker2\\": [\\"Task2\\", \\"Task5\\"], # \\"Worker3\\": [\\"Task3\\"] # } ``` **Hints**: * Use Python\'s modulus operator to implement the round-robin distribution. * Consider validating the inputs to ensure there are no empty task or worker names. # Additional Notes: * The provided example demonstrates a straightforward case with a small number of tasks and workers. Your solution should efficiently handle larger inputs as specified in the constraints.","solution":"from typing import List, Dict def assign_tasks(tasks: List[str], workers: List[str]) -> Dict[str, List[str]]: # Initialize a dictionary with worker names as keys and empty lists as values task_distribution = {worker: [] for worker in workers} # Assign each task to a worker in a round-robin fashion for i, task in enumerate(tasks): worker = workers[i % len(workers)] task_distribution[worker].append(task) return task_distribution"},{"question":"# Question Scenario You are developing a feature for a file system management tool that allows users to identify and remove directories that do not contain any files. Each directory is represented as a node in a tree, and each node has a list of child directories. The goal is to traverse the directory tree and remove all directories that are empty, i.e., do not contain any files or non-empty subdirectories. Task Write a function `remove_empty_directories(root: Dict[str, Any]) -> Dict[str, Any]` that takes the root directory as input and removes all empty directories from the tree. The function should return the pruned directory tree. Input and Output formats * **Input**: * `root`: A dictionary where keys are strings representing the directory names and values are lists containing strings (file names) or dictionaries (subdirectories). * **Output**: * A dictionary representing the directory tree after removing all empty directories. Constraints * The depth of the directory tree is at most 10. * The total number of directories (nodes) and files (leaf nodes) is at most 1000. * There are no cyclic references in the directory structure. * Directory names, file names, and keys in the dictionaries are strings with maximum length of 50. Example ```python root_directory = { \\"root\\": [ \\"file1.txt\\", { \\"subdir1\\": [ \\"file2.txt\\", { \\"subsubdir1\\": [] } ], \\"subdir2\\": [], \\"subdir3\\": [\\"file3.txt\\"] } ] } print(remove_empty_directories(root_directory)) # Output: # { # \\"root\\": [ # \\"file1.txt\\", # { # \\"subdir1\\": [ # \\"file2.txt\\", # # The empty \\"subsubdir1\\" is removed # ], # # The empty \\"subdir2\\" is removed # \\"subdir3\\": [\\"file3.txt\\"] # } # ] # } ``` Use the given root directory structure to demonstrate the function in action.","solution":"from typing import Dict, Any, List, Union def remove_empty_directories(root: Dict[str, Any]) -> Dict[str, Any]: def prune(d: Dict[str, Any]) -> Dict[str, Any]: new_tree = {} for key, value in d.items(): if isinstance(value, list): pruned_value = [] for item in value: if isinstance(item, dict): pruned_subdir = prune(item) if pruned_subdir: # Only add non-empty directories pruned_value.append(pruned_subdir) elif isinstance(item, str): pruned_value.append(item) if any(isinstance(v, str) or isinstance(v, dict) and v for v in pruned_value): new_tree[key] = pruned_value return new_tree return prune(root)"},{"question":"# Problem Statement: Circular Array Rotation You are given a circular array and a number of rotations to perform. Your task is to implement a function that returns the state of the circular array after the specified number of rotations. Requirements 1. **Function Signature**: `def circular_array_rotation(arr: List[int], rotations: int) -> List[int]` 2. **Input**: - A list of integers `arr` representing the elements of the circular array. - An integer `rotations` representing the number of rotations to perform. 3. **Output**: A list of integers representing the circular array after the specified number of rotations. Example ```python >>> circular_array_rotation([1, 2, 3, 4, 5], 2) [4, 5, 1, 2, 3] >>> circular_array_rotation([1, 2, 3, 4, 5], 7) [4, 5, 1, 2, 3] >>> circular_array_rotation([1, 2, 3], 0) [1, 2, 3] >>> circular_array_rotation([1], 10) [1] ``` Constraints - The list `arr` can have up to (10^5) elements. - The integer `rotations` can be up to (10^9). - The input list `arr` will have at least one element. # Task Implement the function `circular_array_rotation` according to the requirements outlined. Ensure the function handles edge cases such as large numbers of rotations efficiently by not performing unnecessary operations. Notes - Focus on optimizing the solution to avoid costly operations for large values of `rotations`. - Remember to handle cases where the number of rotations is larger than the size of the array.","solution":"from typing import List def circular_array_rotation(arr: List[int], rotations: int) -> List[int]: Returns the state of the circular array after the specified number of rotations. n = len(arr) # Effective rotations are rotations % n effective_rotations = rotations % n # Perform the rotations return arr[-effective_rotations:] + arr[:-effective_rotations]"},{"question":"Problem Description You are tasked with creating a utility that manipulates strings by shifting their characters and identifying palindromes in a list of strings. This will include providing functions for character shifting and a function to detect palindromes efficiently in bulk operations. Task 1. **Shift Characters Function (`shift_string`)**: * Implement a function that receives a string and shifts each alphabetic character by a given number of positions in the alphabet, wrapping around if necessary. * Shift both uppercase and lowercase letters appropriately and leave non-alphabetic characters unchanged. * Example: Shifting \\"Hello, World!\\" by 2 results in \\"Jgnnq, Yqtnf!\\" 2. **Palindrome Detection Function (`bulk_palindrome_check`)**: * Create a function to handle multiple strings and determine if each string is a palindrome. * A palindrome is a string that reads the same forward and backward. * The function should return a list of boolean values corresponding to each input string. # Input and Output Formats Function 1: `shift_string` * **Input**: * A string `s` containing alphabetic characters and possibly other characters such as spaces and punctuation. * An integer `n` which indicates the number of positions each alphabetic character should be shifted. * Constraints: `0 <= n <= 25` * **Output**: * A string where each alphabetic character in the input has been shifted by `n` positions in the alphabet, preserving case. Non-alphabetic characters remain unchanged. * **Example**: ```python shift_string(\\"Hello, World!\\", 2) == \\"Jgnnq, Yqtnf!\\" ``` Function 2: `bulk_palindrome_check` * **Input**: * A list of strings `words` where each string is comprised of alphabetic characters only. * Example: `[\\"madam\\", \\"racecar\\", \\"hello\\"]` * **Output**: * A list of boolean values, where each value indicates whether the corresponding string in the input list is a palindrome. * Example: `[True, True, False]` * **Example**: ```python bulk_palindrome_check([\\"madam\\", \\"racecar\\", \\"hello\\"]) == [True, True, False] ``` Implementation Details 1. Implement the `shift_string` function to shift the characters in the string as specified. 2. Implement the `bulk_palindrome_check` function to evaluate palindromes efficiently for a list of strings.","solution":"def shift_string(s, n): Shifts each alphabetic character in the string by `n` positions. result = [] for char in s: if \'a\' <= char <= \'z\': shifted = chr((ord(char) - ord(\'a\') + n) % 26 + ord(\'a\')) result.append(shifted) elif \'A\' <= char <= \'Z\': shifted = chr((ord(char) - ord(\'A\') + n) % 26 + ord(\'A\')) result.append(shifted) else: result.append(char) return \'\'.join(result) def bulk_palindrome_check(words): Checks if each string in the list is a palindrome. return [word == word[::-1] for word in words]"},{"question":"# Array Rotation and Sum Challenge Write a Python function that rotates a list of integers to the right by `k` steps and returns the resulting list. Furthermore, write another function to calculate the sum of all elements in the rotated list that are divisible by a given number `d`. 1. **rotate_list(nums, k)**: - **Input**: A list of integers `nums` and an integer `k`. - **Output**: Return the rotated list after rotating `nums` to the right by `k` steps. - **Constraints**: - Try to make your solution as efficient as possible. 2. **sum_of_divisibles(rotated_list, d)**: - **Input**: A list of integers `rotated_list` and an integer `d`. - **Output**: Return the sum of all elements in `rotated_list` that are divisible by `d`. - **Constraints**: - Assume `d` is always greater than `0`. **Function Signatures**: ```python def rotate_list(nums: list[int], k: int) -> list[int]: pass def sum_of_divisibles(rotated_list: list[int], d: int) -> int: pass ``` # Example ```python # Example usage: nums = [1, 2, 3, 4, 5, 6, 7] # Test rotate_list assert rotate_list(nums, 3) == [5, 6, 7, 1, 2, 3, 4] assert rotate_list([1, 2, 3], 1) == [3, 1, 2] assert rotate_list([1, 2, 3], 4) == [3, 1, 2] # Note: 4 % 3 = 1, equivalent to rotating by 1 step # Test sum_of_divisibles rotated = rotate_list(nums, 3) assert sum_of_divisibles(rotated, 2) == 12 # 6 + 2 + 4 assert sum_of_divisibles([10, 20, 30], 5) == 60 assert sum_of_divisibles([1, 3, 5, 7], 2) == 0 # No element is divisible by 2 ``` **Note**: - For `rotate_list`, rotating by `k` steps means that each element of the array is shifted to the right by `k` positions, with wrap-around occurring (elements shifted out of the end reappear at the beginning). - For `sum_of_divisibles`, add the elements which are exactly divisible by `d` from the rotated list.","solution":"def rotate_list(nums, k): Rotates the list nums to the right by k steps. :param nums: List[int] - list of integers to be rotated :param k: int - number of steps to rotate :return: List[int] - rotated list n = len(nums) k = k % n # To handle cases where k is greater than the length of the list return nums[-k:] + nums[:-k] def sum_of_divisibles(rotated_list, d): Returns the sum of all elements in the rotated_list that are divisible by d. :param rotated_list: List[int] - list of rotated integers :param d: int - integer divisor :return: int - sum of elements divisible by d return sum(x for x in rotated_list if x % d == 0)"},{"question":"# Coding Assessment Question You are given a function implemented using the NumPy library: 1. **is_symmetric(matrix: np.ndarray) -> bool**: This function checks if a given matrix is symmetric. Your task is to extend the given functionality in the following ways: 1. Implement a function `max_eigenvalue(matrix: np.ndarray) -> Tuple[np.ndarray, float]` that takes in a symmetric matrix and returns the eigenvector corresponding to the largest eigenvalue and the value of this eigenvalue. 2. Ensure your function handles edge cases, such as non-square or non-symmetric matrices, raising appropriate errors if necessary. 3. Provide adequate tests for your solution. Function Signature: ```python def max_eigenvalue(matrix: np.ndarray) -> Tuple[np.ndarray, float]: pass ``` # Input: * `matrix`: A square real matrix (n times n) (NumPy array). # Output: * Returns a tuple with: * The eigenvector (NumPy array) corresponding to the largest eigenvalue. * The value of this largest eigenvalue. # Constraints: * The input `matrix` is guaranteed to be square but not necessarily symmetric. # Example: ```python import numpy as np A = np.array([ [2, 1, 0], [1, 2, 0], [0, 0, 1] ]) eigenvector, eigenvalue = max_eigenvalue(A) print(\\"Eigenvector:\\", eigenvector) print(\\"Eigenvalue:\\", eigenvalue) ``` # Expected Outputs: 1. `eigenvector` should be the eigenvector corresponding to the largest eigenvalue. 2. `eigenvalue` should be the numerical value of the largest eigenvalue. Ensure to test your solution thoroughly and consider edge cases.","solution":"import numpy as np from typing import Tuple def max_eigenvalue(matrix: np.ndarray) -> Tuple[np.ndarray, float]: Returns the eigenvector corresponding to the largest eigenvalue and the value of this eigenvalue. Args: - matrix (np.ndarray): A square real matrix (n x n). Returns: - Tuple[np.ndarray, float]: The eigenvector and the largest eigenvalue. Raises: - ValueError: If the matrix is not square or not symmetric. # Check if the matrix is square if matrix.shape[0] != matrix.shape[1]: raise ValueError(\\"The matrix must be square.\\") # Check if the matrix is symmetric if not np.allclose(matrix, matrix.T): raise ValueError(\\"The matrix must be symmetric.\\") # Compute the eigenvalues and eigenvectors eigenvalues, eigenvectors = np.linalg.eigh(matrix) # Extract the largest eigenvalue and corresponding eigenvector max_index = np.argmax(eigenvalues) largest_eigenvalue = eigenvalues[max_index] corresponding_eigenvector = eigenvectors[:, max_index] return corresponding_eigenvector, largest_eigenvalue"},{"question":"# Question You are developing a feature that involves processing and filtering log files to extract valuable information. The logs contain various events recorded in a specific format, and your task is to write a function that extracts and processes these events according to the given criteria. # Task Write a Python function, `process_log_events(logfile_path, event_type)`, that reads a log file, filters out events of a specific type, and returns the list of filtered events. Each event is represented by a dictionary. Requirements: - Each log entry is a JSON object on a new line. - Filter entries based on the `event_type` key. - Handle scenarios where the log file is non-existent or contains malformed JSON with appropriate error handling. Input: - `logfile_path` (str): Path to the log file. - `event_type` (str): The type of event you want to filter. Output: - List of dictionaries containing the filtered events. Constraints: - The log file can grow significantly large; consider efficient file handling. - You should handle IOError when the log file does not exist. - Invalid JSON should be gracefully skipped to ensure the function processes the rest of the valid events. # Example: Consider a log file with the following entries: ``` {\\"event_type\\": \\"INFO\\", \\"timestamp\\": \\"2023-01-01T12:00:00Z\\", \\"message\\": \\"Information message\\"} {\\"event_type\\": \\"ERROR\\", \\"timestamp\\": \\"2023-01-01T12:05:00Z\\", \\"message\\": \\"Error message\\"} {\\"event_type\\": \\"DEBUG\\", \\"timestamp\\": \\"2023-01-01T12:10:00Z\\", \\"message\\": \\"Debug message\\"} {\\"event_type\\": \\"INFO\\", \\"timestamp\\": \\"2023-01-01T12:15:00Z\\", \\"message\\": \\"Another information message\\"} ``` For event_type \\"INFO\\", the function should return: ```python [ {\\"event_type\\": \\"INFO\\", \\"timestamp\\": \\"2023-01-01T12:00:00Z\\", \\"message\\": \\"Information message\\"}, {\\"event_type\\": \\"INFO\\", \\"timestamp\\": \\"2023-01-01T12:15:00Z\\", \\"message\\": \\"Another information message\\"} ] ``` For event_type \\"ERROR\\", the function should return: ```python [ {\\"event_type\\": \\"ERROR\\", \\"timestamp\\": \\"2023-01-01T12:05:00Z\\", \\"message\\": \\"Error message\\"} ] ```","solution":"import json def process_log_events(logfile_path, event_type): Processes a log file and filters events based on the provided event_type. Args: logfile_path (str): Path to the log file. event_type (str): The type of event to filter. Returns: list of dict: List of filtered events. filtered_events = [] try: with open(logfile_path, \'r\') as file: for line in file: try: event = json.loads(line.strip()) if event.get(\\"event_type\\") == event_type: filtered_events.append(event) except json.JSONDecodeError: # Skip malformed JSON lines continue except IOError: print(f\\"Error: File \'{logfile_path}\' not found.\\") return filtered_events"},{"question":"# Problem Description You are given a list of `N` unsorted integers. Your goal is to sort the list using the Merge Sort algorithm and return the sorted list. # Input * An integer `N`, the number of integers in the list (1 ≤ N ≤ 10000). * A list `arr` of `N` integers, where each integer lies in the range `(-10^5, 10^5)`. # Output A list of `N` integers representing the sorted order of the input list. # Constraints * The input list can contain duplicate integers. * The merge sort implementation should follow a divide-and-conquer strategy, achieving `O(N log N)` time complexity. # Function Signature ```python def merge_sort(arr: List[int]) -> List[int]: ``` # Example **Input:** ```python N = 5 arr = [3, -2, 5, 1, 0] ``` **Output:** ```python [-2, 0, 1, 3, 5] ``` # Note In the given example, the sorted order of the list `[3, -2, 5, 1, 0]` is `[-2, 0, 1, 3, 5]`. Your function should implement the merge sort algorithm efficiently to ensure correct sorting.","solution":"from typing import List def merge_sort(arr: List[int]) -> List[int]: if len(arr) <= 1: return arr def merge(left, right): result = [] i = j = 0 while i < len(left) and j < len(right): if left[i] <= right[j]: result.append(left[i]) i += 1 else: result.append(right[j]) j += 1 result.extend(left[i:]) result.extend(right[j:]) return result mid = len(arr) // 2 left_half = merge_sort(arr[:mid]) right_half = merge_sort(arr[mid:]) return merge(left_half, right_half)"},{"question":"# Task: Implement a Function to Parse and Validate Log Entries Problem Statement: You are tasked with implementing a function `parse_log_entry(log_entry: str) -> dict` that parses a log entry string and returns a dictionary containing structured data. The log entry follows a specific format, and the function must also validate certain fields. Details: - **Input**: - `log_entry (str)`: A log entry in the format: `\\"<timestamp> <log_level> <module>: <message>\\"` - `timestamp` (str) : The date and time in the format `YYYY-MM-DD HH:MM:SS` - `log_level` (str) : One of `INFO`, `WARN`, `ERROR`, `DEBUG` - `module` (str) : The module name containing only alphanumeric characters and underscores. - `message` (str) : The log message which can contain any characters. - **Output**: - `dict` : A dictionary with keys `timestamp`, `log_level`, `module`, and `message`, containing the corresponding values from the log entry. Constraints: - The function should raise a `ValueError` if the log entry does not conform to the specified format. - The function should ensure that the `timestamp` is a valid date-time in the specified format. - The log level should be one of `INFO`, `WARN`, `ERROR`, `DEBUG`. - The `module` should only contain alphanumeric characters and underscores. Example: - **Input**: ```python log_entry = \\"2023-09-30 14:22:00 INFO auth_module: User login succeeded\\" ``` - **Output**: ```python { \\"timestamp\\": \\"2023-09-30 14:22:00\\", \\"log_level\\": \\"INFO\\", \\"module\\": \\"auth_module\\", \\"message\\": \\"User login succeeded\\" } ``` Skeleton Code: ```python import re from datetime import datetime def parse_log_entry(log_entry: str) -> dict: # Define a regex pattern for the log entry pattern = r\'^(?P<timestamp>d{4}-d{2}-d{2} d{2}:d{2}:d{2}) (?P<log_level>INFO|WARN|ERROR|DEBUG) (?P<module>w+): (?P<message>.+)\' match = re.match(pattern, log_entry) if not match: raise ValueError(\\"Log entry does not conform to the required format.\\") # Extract values using named groups timestamp = match.group(\'timestamp\') log_level = match.group(\'log_level\') module = match.group(\'module\') message = match.group(\'message\') # Validate the timestamp try: datetime.strptime(timestamp, \'%Y-%m-%d %H:%M:%S\') except ValueError: raise ValueError(\\"Invalid timestamp format.\\") # Validate the module name if not module.isidentifier(): raise ValueError(\\"Invalid module name.\\") return { \\"timestamp\\": timestamp, \\"log_level\\": log_level, \\"module\\": module, \\"message\\": message } # Example usage if __name__ == \\"__main__\\": log_entry = \\"2023-09-30 14:22:00 INFO auth_module: User login succeeded\\" print(parse_log_entry(log_entry)) ``` # Hints: 1. Use regular expressions to parse log entries. 2. Validate each part of the log entry according to the specified rules. 3. Raise appropriate exceptions for invalid input to ensure robustness. 4. Consider edge cases such as invalid date, unsupported log level, or malformed log entries.","solution":"import re from datetime import datetime def parse_log_entry(log_entry: str) -> dict: # Define a regex pattern for the log entry pattern = r\'^(?P<timestamp>d{4}-d{2}-d{2} d{2}:d{2}:d{2}) (?P<log_level>INFO|WARN|ERROR|DEBUG) (?P<module>[a-zA-Z0-9_]+): (?P<message>.+)\' match = re.match(pattern, log_entry) if not match: raise ValueError(\\"Log entry does not conform to the required format.\\") # Extract values using named groups timestamp = match.group(\'timestamp\') log_level = match.group(\'log_level\') module = match.group(\'module\') message = match.group(\'message\') # Validate the timestamp try: datetime.strptime(timestamp, \'%Y-%m-%d %H:%M:%S\') except ValueError: raise ValueError(\\"Invalid timestamp format.\\") return { \\"timestamp\\": timestamp, \\"log_level\\": log_level, \\"module\\": module, \\"message\\": message }"},{"question":"# Problem: Balanced String Checker **Context**: You are tasked with creating a system for checking the balance of strings composed of different types of brackets (parentheses, square brackets, and curly braces). The balanced string checker should determine whether the brackets in a string are appropriately balanced and correctly nested. # Task: Implement the class `BalancedStringChecker` with the following methods: 1. **__init__()**: Initialize the balanced string checker. 2. **is_balanced(s: str) -> bool**: - Check if the given string `s` is balanced. Return `True` if it is, otherwise `False`. # Constraints: - The input string `s` contains only the bracket characters `()[]{}`. - The length of the input string `s` is at most 10^4 characters. # Example: ```python checker = BalancedStringChecker() assert checker.is_balanced(\\"()[]{}\\") == True assert checker.is_balanced(\\"([{}])\\") == True assert checker.is_balanced(\\"(]\\") == False assert checker.is_balanced(\\"([)]\\") == False assert checker.is_balanced(\\"{[]}\\") == True ``` # Note: - A string is considered balanced if every opening bracket has a corresponding closing bracket of the same type and the pairs of brackets are correctly nested. *Implement `BalancedStringChecker` below:* ```python class BalancedStringChecker: def __init__(self): pass def is_balanced(self, s: str) -> bool: stack = [] bracket_map = {\')\': \'(\', \']\': \'[\', \'}\': \'{\'} for char in s: if char in bracket_map: top_element = stack.pop() if stack else \'#\' if bracket_map[char] != top_element: return False else: stack.append(char) return not stack # Example usage, thorough testing with various string combinations is recommended. ```","solution":"class BalancedStringChecker: def __init__(self): pass def is_balanced(self, s: str) -> bool: stack = [] bracket_map = {\')\': \'(\', \']\': \'[\', \'}\': \'{\'} for char in s: if char in bracket_map: top_element = stack.pop() if stack else \'#\' if bracket_map[char] != top_element: return False else: stack.append(char) return not stack"},{"question":"# Programming Question: Missing Number in Sequence **Context**: There is a common problem in computer science where you need to find a missing number in an arithmetic sequence. This type of problem can be found in error-checking algorithms and data integrity checks. **Problem Statement**: Write a function `find_missing_number(sequence: List[int]) -> int` that finds and returns the missing number in a sequence of integers that is supposed to form an arithmetic progression (AP). An arithmetic progression is a sequence of numbers in which the difference of any two successive members is a constant. **Function Signature**: ```python def find_missing_number(sequence: List[int]) -> int: pass ``` **Input**: * A list of integers `sequence` representing an arithmetic progression with exactly one number missing. **Output**: * An integer representing the missing number in the sequence. **Constraints**: * The list `sequence` will contain at least three numbers. * The elements in the list are guaranteed to form an arithmetic progression except for the single missing number. * The sequence list will have integers within the range of -10^6 to 10^6. **Examples**: ```python find_missing_number([1, 3, 5, 9, 11]) # Output: 7 find_missing_number([10, 20, 30, 50, 60]) # Output: 40 ``` **Notes**: * You may assume that there is exactly one number missing in the progression. * The function should handle both positive and negative integers as well as sequences with large values.","solution":"def find_missing_number(sequence): Find the missing number in the arithmetic progression. Parameters: sequence (list): A list of integers representing an arithmetic progression with one number missing. Returns: int: The missing number in the sequence. n = len(sequence) # Calculate the expected common difference of the arithmetic progression common_diff = (sequence[-1] - sequence[0]) // n # Use binary search to find the missing number left, right = 0, n - 1 while left < right: mid = (left + right) // 2 expected_value = sequence[0] + mid * common_diff if sequence[mid] == expected_value: left = mid + 1 else: right = mid return sequence[0] + left * common_diff"},{"question":"# Problem Statement Scenario: You are hired as a software engineer to create a text-based adventure game in which a player navigates through a maze. The maze is represented as a grid of cells, where each cell can be either open (\'.\') or blocked (\'#\'). The player can move horizontally or vertically but cannot move diagonally or pass through walls. The goal is to find the shortest path from the player\'s starting position to the destination position, if one exists. Task: Implement various functions required to determine the shortest path in the grid. If a path exists, return it; otherwise, return an empty list. Requirements: - Define a class `MazeSolver` with the following methods: - `__init__(self, grid: List[List[str]]) -> None`: Initialize the maze solver with the given grid. - `is_valid(self, row: int, col: int) -> bool`: Check if a cell `(row, col)` is within the grid bounds and is open. - `find_shortest_path(self, start: Tuple[int, int], destination: Tuple[int, int]) -> List[Tuple[int, int]]`: Find and return the shortest path from `start` to `destination`. If no path exists, return an empty list. Inputs: 1. `grid: List[List[str]]`: A 2D list representing the maze, where each element is either \'.\' or \'#\'. 2. `start: Tuple[int, int]`: A tuple representing the starting cell `(row, col)`. 3. `destination: Tuple[int, int]`: A tuple representing the destination cell `(row, col)`. Outputs: - Returns a list of tuples representing the shortest path from `start` to `destination`. If no path exists, return an empty list. Constraints: - The grid will always have at least one cell: 1 ≤ len(grid), len(grid[0]) ≤ 100 - The `start` and `destination` cells are always within the grid bounds and contain \'.\'. Example: ```python # Example input maze and start/destination positions grid = [ [\'.\', \'#\', \'.\', \'.\', \'.\'], [\'.\', \'#\', \'.\', \'#\', \'.\'], [\'.\', \'.\', \'.\', \'#\', \'.\'], [\'#\', \'#\', \'.\', \'#\', \'.\'], [\'.\', \'.\', \'.\', \'.\', \'.\'] ] start = (0, 0) destination = (4, 4) solver = MazeSolver(grid) path = solver.find_shortest_path(start, destination) # Expected Output: # [(0, 0), (1, 0), (2, 0), (2, 1), (2, 2), (3, 2), (4, 2), (4, 3), (4, 4)] ``` Code Usage: ```python if __name__ == \\"__main__\\": maze = [ [\'.\', \'#\', \'.\', \'.\', \'.\'], [\'.\', \'#\', \'.\', \'#\', \'.\'], [\'.\', \'.\', \'.\', \'#\', \'.\'], [\'#\', \'#\', \'.\', \'#\', \'.\'], [\'.\', \'.\', \'.\', \'.\', \'.\'] ] start = (0, 0) destination = (4, 4) solver = MazeSolver(maze) path = solver.find_shortest_path(start, destination) print(f\\"Path: {path}\\") ```","solution":"from typing import List, Tuple from collections import deque class MazeSolver: def __init__(self, grid: List[List[str]]) -> None: self.grid = grid self.rows = len(grid) self.cols = len(grid[0]) def is_valid(self, row: int, col: int) -> bool: if 0 <= row < self.rows and 0 <= col < self.cols and self.grid[row][col] == \'.\': return True return False def find_shortest_path(self, start: Tuple[int, int], destination: Tuple[int, int]) -> List[Tuple[int, int]]: if not self.is_valid(*start) or not self.is_valid(*destination): return [] directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(start, [start])]) visited = set([start]) while queue: (current_row, current_col), path = queue.popleft() if (current_row, current_col) == destination: return path for d_row, d_col in directions: new_row, new_col = current_row + d_row, current_col + d_col if self.is_valid(new_row, new_col) and (new_row, new_col) not in visited: visited.add((new_row, new_col)) queue.append(((new_row, new_col), path + [(new_row, new_col)])) return []"},{"question":"# Objective Write a Python function `count_asterisks` that takes a string `s` and counts the number of asterisks (`*`) that are not enclosed between a pair of vertical bars (`|`). A vertical bar is considered a delimiter, and there can be multiple pairs in the string. # Input * A string `s` consisting of lowercase letters, vertical bars (`|`), and asterisks (`*`). The length of `s` is between 1 and 1000. # Output Format An integer count of non-enclosed asterisks. # Function Signature ```python def count_asterisks(s: str) -> int: pass ``` # Example ```python assert count_asterisks(\\"l|*e*et|c*o|*de|\\") == 1 # Only the asterisk after the last vertical bar is counted assert count_asterisks(\\"*|*|*\\") == 2 # First and third asterisks are counted assert count_asterisks(\\"|||\\"\\") == 0 # No asterisks present assert count_asterisks(\\"|*||*|\\") == 0 # All asterisks are enclosed assert count_asterisks(\\"abc\\") == 0 # No asterisks present ``` # Constraints * The string `s` is non-empty and contains only lowercase letters, asterisks, and vertical bars. * You may assume the asterisks and vertical bars are always properly paired in the input string if it contains any vertical bars. # Notes * Focus on edge cases such as when there are no vertical bars or asterisks at all. * Consider the performance when the string length is at its maximum limit. --- This question tests the candidate\'s ability to correctly count characters in a string while respecting delimiter constraints, ensuring understanding of string manipulation and conditionals.","solution":"def count_asterisks(s: str) -> int: Counts the number of asterisks that are not enclosed between a pair of vertical bars in the string. count = 0 within_bars = False for char in s: if char == \'|\': within_bars = not within_bars elif char == \'*\' and not within_bars: count += 1 return count"},{"question":"# Task Description Create a function that generates a list of Fibonacci numbers up to a given limit `n` (inclusive), where `n` is a positive integer. # Function Specifications Implement the following function: ```python def generate_fibonacci_up_to_n(n: int) -> List[int]: Generates a list of Fibonacci numbers up to the given limit n (inclusive). Args: n (int): The upper limit for Fibonacci numbers to be generated. Returns: List[int]: A list containing Fibonacci numbers up to n. Example: >>> generate_fibonacci_up_to_n(10) [0, 1, 1, 2, 3, 5, 8] >>> generate_fibonacci_up_to_n(21) [0, 1, 1, 2, 3, 5, 8, 13, 21] # Your implementation here ``` # Constraints 1. `n` is a positive integer. 2. If `n` is less than the first Fibonacci number (0), return an empty list. # Detailed Example Given `n` as `10`: 1. The Fibonacci sequence starts as follows: `0, 1, 1, 2, 3, 5, 8, 13, ...` 2. The list of Fibonacci numbers up to 10 (inclusive) will be `[0, 1, 1, 2, 3, 5, 8]` since the next number (13) exceeds 10.","solution":"def generate_fibonacci_up_to_n(n: int) -> list: Generates a list of Fibonacci numbers up to the given limit n (inclusive). Args: n (int): The upper limit for Fibonacci numbers to be generated. Returns: List[int]: A list containing Fibonacci numbers up to n. if n < 0: return [] fibonacci_list = [] a, b = 0, 1 while a <= n: fibonacci_list.append(a) a, b = b, a + b return fibonacci_list"},{"question":"# Coding Exercise: Bank Account Management **Objective**: Using the concepts demonstrated in object-oriented programming and data management, implement a class that simulates basic bank account operations. # Specification: 1. Create a class `BankAccount` with the following attributes: - `account_number` (str): A unique identifying number for each account. - `account_holder` (str): The name of the account holder. - `balance` (float): The current balance of the account. 2. Implement the following methods: - `deposit(amount: float) -> None`: Adds the specified amount to the account balance. - `withdraw(amount: float) -> bool`: Subtracts the specified amount from the account balance if there are sufficient funds. Returns `True` if the transaction is successful, otherwise `False`. - `get_balance() -> float`: Returns the current account balance. - `transfer(amount: float, target_account: \'BankAccount\') -> bool`: Transfers the specified amount to another `BankAccount` instance if there are sufficient funds. Returns `True` if the transaction is successful, otherwise `False`. # Class Definition: ```python class BankAccount: def __init__(self, account_number: str, account_holder: str, initial_balance: float = 0.0): Initialize a new bank account. Parameters: account_number (str): The unique account number. account_holder (str): The name of the account holder. initial_balance (float): The starting balance for the account. Defaults to 0.0. self.account_number = account_number self.account_holder = account_holder self.balance = initial_balance def deposit(self, amount: float) -> None: Deposit the specified amount into the account. Parameters: amount (float): The amount to deposit. pass def withdraw(self, amount: float) -> bool: Withdraw the specified amount from the account, if sufficient funds exist. Parameters: amount (float): The amount to withdraw. Returns: bool: True if the withdrawal was successful, False otherwise. pass def get_balance(self) -> float: Retrieve the current balance of the account. Returns: float: The current account balance. pass def transfer(self, amount: float, target_account: \'BankAccount\') -> bool: Transfer the specified amount to another BankAccount instance, if sufficient funds exist. Parameters: amount (float): The amount to transfer. target_account (BankAccount): The account to transfer the funds to. Returns: bool: True if the transfer was successful, False otherwise. pass ``` # Constraints: * The `amount` for `deposit` and `withdraw` methods must be positive. * The `amount` for `transfer` must be positive and the `target_account` must be a valid `BankAccount` instance. # Examples: ```python # Example usage acc1 = BankAccount(\'123ABC\', \'Alice\', 500.0) acc2 = BankAccount(\'456DEF\', \'Bob\', 300.0) acc1.deposit(200.0) print(acc1.get_balance()) # Output: 700.0 acc1.withdraw(100.0) print(acc1.get_balance()) # Output: 600.0 print(acc1.transfer(200.0, acc2)) # Output: True print(acc1.get_balance()) # Output: 400.0 print(acc2.get_balance()) # Output: 500.0 print(acc1.withdraw(500.0)) # Output: False ``` # Context: You are tasked with developing a banking system that handles basic operations such as deposits, withdrawals, and transfers. Your solution must account for edge cases such as attempting to withdraw more funds than available and ensure transactions are processed accurately and efficiently.","solution":"class BankAccount: def __init__(self, account_number: str, account_holder: str, initial_balance: float = 0.0): Initialize a new bank account. Parameters: account_number (str): The unique account number. account_holder (str): The name of the account holder. initial_balance (float): The starting balance for the account. Defaults to 0.0. self.account_number = account_number self.account_holder = account_holder self.balance = initial_balance def deposit(self, amount: float) -> None: Deposit the specified amount into the account. Parameters: amount (float): The amount to deposit. if amount > 0: self.balance += amount def withdraw(self, amount: float) -> bool: Withdraw the specified amount from the account, if sufficient funds exist. Parameters: amount (float): The amount to withdraw. Returns: bool: True if the withdrawal was successful, False otherwise. if amount > 0 and self.balance >= amount: self.balance -= amount return True return False def get_balance(self) -> float: Retrieve the current balance of the account. Returns: float: The current account balance. return self.balance def transfer(self, amount: float, target_account: \'BankAccount\') -> bool: Transfer the specified amount to another BankAccount instance, if sufficient funds exist. Parameters: amount (float): The amount to transfer. target_account (BankAccount): The account to transfer the funds to. Returns: bool: True if the transfer was successful, False otherwise. if amount > 0 and self.balance >= amount and isinstance(target_account, BankAccount): self.balance -= amount target_account.deposit(amount) return True return False"},{"question":"**Objective**: Write a function to compute the number of unique paths an object can take from the top-left corner to the bottom-right corner of an MxN grid, given it can only move either down or right at any point in time. **Function Signature**: ```python def unique_paths(m: int, n: int) -> int: pass ``` **Input Format**: * `m`: An integer representing the number of rows in the grid. * `n`: An integer representing the number of columns in the grid. **Output Format**: * An integer representing the number of unique paths from the top-left corner to the bottom-right corner of the grid. **Constraints**: * (1 leq m, n leq 100) **Performance Requirements**: * The function should have a time and space complexity of (O(m times n)). **Example**: ```python m = 3 n = 7 unique_paths(m, n) # Expected output: 28 ``` **Scenario**: Consider a scenario in which you are navigating a robot or an object from the top-left corner to the bottom-right corner of a grid. The object can only move either down or right at any given step. Your task is to determine how many unique ways the object can travel to reach its destination. Your implementation should use dynamic programming or combinatorial methods to calculate the number of unique paths, starting by initializing a path grid and computing the number of ways to reach each cell considering only the allowed moves.","solution":"def unique_paths(m: int, n: int) -> int: Computes the number of unique paths from the top-left corner to the bottom-right corner of a grid of size m x n, where movement is restricted to down and right. # Create a 2D list initialized with 1s because the number of ways to reach # any cell in the first row and the first column is 1. dp = [[1] * n for _ in range(m)] # Iterate through the grid starting from the cell (1,1) # because the first row and column are already initialised to 1 for i in range(1, m): for j in range(1, n): # Number of ways to reach cell (i, j) is the sum of ways to reach # cells (i-1, j) and (i, j-1) dp[i][j] = dp[i-1][j] + dp[i][j-1] # The bottom-right cell contains the number of unique paths from top-left to bottom-right. return dp[m-1][n-1]"},{"question":"# Identifying the Longest Increasing Subsequence in Rotated Sorted Array Given a rotated sorted array (which may contain duplicates), write a function to find the length of the longest increasing subsequence. Function Signature ```python def longest_increasing_subsequence(nums: List[int]) -> int: pass ``` Input * `nums` (List[int]): A list of integers representing the rotated sorted array, where the size of the list can be up to 10^3 elements. Output * `int`: Length of the longest increasing subsequence in the given array. Constraints * 1 ≤ len(nums) ≤ 1000 * -10^4 ≤ nums[i] ≤ 10^4 Example ```python print(longest_increasing_subsequence([4, 5, 6, 7, 0, 1, 2, 4])) # should output 4 print(longest_increasing_subsequence([10, 11, 3, 4, 5])) # should output 3 print(longest_increasing_subsequence([9, 10, 2, 5, 7, 8])) # should output 4 ``` Explanation The function should identify the longest sequence of elements in the rotated array such that all elements in the subsequence are in ascending order. # Constraints & Guidelines * Ensure the function works efficiently for the upper limits of the list size. * Consider handling corner cases like arrays with all identical elements or when the array is already sorted. * Validate inputs to fit within the constraints and handle edge scenarios properly.","solution":"def longest_increasing_subsequence(nums): Returns the length of the longest increasing subsequence in a rotated sorted array. if not nums: return 0 # Let\'s define the LIS array LIS = [] for num in nums: pos = binary_search_insert_position(LIS, num) if pos < len(LIS): LIS[pos] = num else: LIS.append(num) return len(LIS) def binary_search_insert_position(LIS, num): low, high = 0, len(LIS) while low < high: mid = low + (high - low) // 2 if LIS[mid] < num: low = mid + 1 else: high = mid return low"},{"question":"# Problem Statement Suppose you are working on string manipulation functions and need to develop utilities to perform specific tasks. Implement the following functions: 1. `find_shifted_index(s: str, shifted: str) -> Optional[int]`: This function takes two strings, `s` and `shifted`. It returns the index `i` such that if we shift the characters of `s` at index `i` to the front, the resulting string is equal to `shifted`. If no such index exists, return `None`. 2. `are_rotations(str1: str, str2: str) -> bool`: This function checks if `str1` is a rotation of `str2`. Two strings are rotations if you can obtain one from the other by rotating the characters (i.e., continuously moving the characters from the beginning to the end). # Requirements * `find_shifted_index` should consider a cyclic shift, meaning the character at the end of the string can wrap around to the beginning. * `are_rotations` should use `find_shifted_index` to determine if the two strings are rotations of each other. * Both functions should handle edge cases gracefully and return consistent output even when the input strings are empty. # Function Definitions ```python def find_shifted_index(s: str, shifted: str) -> Optional[int]: # Your code here def are_rotations(str1: str, str2: str) -> bool: # Your code here ``` # Input/Output Examples ```python assert find_shifted_index(\\"hello\\", \\"lohel\\") == 3 assert find_shifted_index(\\"abcde\\", \\"deabc\\") == 3 assert find_shifted_index(\\"abcd\\", \\"bcda\\") == 1 assert find_shifted_index(\\"abcd\\", \\"abcd\\") == 0 assert find_shifted_index(\\"abcd\\", \\"dabc\\") == 2 assert find_shifted_index(\\"abcd\\", \\"acbd\\") == None assert are_rotations(\\"hello\\", \\"lohel\\") == True assert are_rotations(\\"abcde\\", \\"deabc\\") == True assert are_rotations(\\"abcde\\", \\"edbca\\") == False assert are_rotations(\\"abcd\\", \\"abcd\\") == True assert are_rotations(\\"abcd\\", \\"bcda\\") == True assert are_rotations(\\"\\", \\"\\") == True assert are_rotations(\\"a\\", \\"a\\") == True assert are_rotations(\\"abc\\", \\"\\") == False assert are_rotations(\\"\\", \\"abc\\") == False ``` # Constraints * The length of the input strings `s` and `shifted` in `find_shifted_index`, as well as `str1` and `str2` in `are_rotations`, will be ≤ 1000. * Assume inputs will always be valid strings. # Additional Context Rotations of strings are a common problem in text processing and pattern matching. Understanding rotations and cyclic shifts helps in solving problems related to circular queues, string matching algorithms, and cryptographic transformations.","solution":"from typing import Optional def find_shifted_index(s: str, shifted: str) -> Optional[int]: Returns the index i such that if we shift the characters of s at index i to the front, the resulting string is equal to shifted. If no such index exists, return None. if len(s) != len(shifted): return None concatenated = s + s index = concatenated.find(shifted) return index if index != -1 else None def are_rotations(str1: str, str2: str) -> bool: Checks if str1 is a rotation of str2. return find_shifted_index(str1, str2) is not None"},{"question":"# Binary Search Tree Balance Checker Objective Implement the following function to determine if a given binary search tree (BST) is height-balanced. A height-balanced BST is defined as a binary tree in which the depth of the two subtrees of every node differs by no more than 1. ```python class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def is_balanced_bst(root: TreeNode) -> bool: Determines if a given binary search tree is height-balanced. Parameters: root (TreeNode): The root node of the BST. Returns: bool: True if the tree is height-balanced, False otherwise. pass ``` Input Format * A binary search tree represented by the root node of the tree. Output Format * A boolean value: `True` if the tree is height-balanced, `False` otherwise. Constraints * The tree can be empty (`None`). * The tree contains nodes with integer values. Example ```python # Example of height-balanced BST: # 3 # / # 1 4 # / # 2 5 root = TreeNode(3) root.left = TreeNode(1) root.right = TreeNode(4, TreeNode(2), TreeNode(5)) print(is_balanced_bst(root)) # Expected output: True # Example of non-height-balanced BST: # 1 # # 2 # # 3 root = TreeNode(1, None, TreeNode(2, None, TreeNode(3))) print(is_balanced_bst(root)) # Expected output: False ``` Notes * Consider edge cases such as an empty tree, a single-node tree, or a highly unbalanced tree. * Ensure your solution has an optimal time complexity. * You may use helper functions or classes if necessary to structure your code.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def is_balanced_bst(root: TreeNode) -> bool: Determines if a given binary search tree is height-balanced. Parameters: root (TreeNode): The root node of the BST. Returns: bool: True if the tree is height-balanced, False otherwise. def check_height(node): if not node: return 0 left_height = check_height(node.left) if left_height == -1: return -1 right_height = check_height(node.right) if right_height == -1: return -1 if abs(left_height - right_height) > 1: return -1 return max(left_height, right_height) + 1 return check_height(root) != -1"},{"question":"**Compress String by Character Count** **Problem Statement**: You are given a string consisting of lowercase alphabetical characters only. Implement a function that compresses the string by replacing sequences of the same character with the character followed by the count of occurrences. The function should return the compressed string only if the length of the compressed string is shorter than or equal to the original string. If the compressed string\'s length is longer than the original, return the original string instead. **Function Signature**: ```python def compress_string(s: str) -> str: ``` **Input**: - A string `s` consisting of lowercase alphabetical characters only. **Output**: - The compressed string if it is shorter or equal in length to the original string, otherwise the original string. **Constraints**: - The input string length will not exceed 10^5. - The string consists only of lowercase alphabetical characters (a-z). **Examples**: ```python assert compress_string(\\"aabcccccaaa\\") == \\"a2b1c5a3\\" assert compress_string(\\"abcdef\\") == \\"abcdef\\" # Compression would result in a longer string \\"a1b1c1d1e1f1\\" assert compress_string(\\"aabbcc\\") == \\"a2b2c2\\" assert compress_string(\\"zzzzzzzz\\") == \\"z8\\" ``` **Edge Cases**: - If the input string is empty, the output should be an empty string. - If the input string is a single character repeating once or multiple times, the function should handle it correctly. - If all characters in the string are distinct, the function should return the original string. **Hint**: Iterate through the string to count consecutive characters and build the compressed string. Compare the length of the compressed string with the original string to decide the final output.","solution":"def compress_string(s: str) -> str: if not s: return s compressed = [] count = 1 prev_char = s[0] for i in range(1, len(s)): if s[i] == prev_char: count += 1 else: compressed.append(prev_char + str(count)) prev_char = s[i] count = 1 compressed.append(prev_char + str(count)) # Add the last set of characters compressed_string = \'\'.join(compressed) if len(compressed_string) <= len(s): return compressed_string else: return s"},{"question":"# Question **Context**: In developing a text processing application, you often need to find substrings that match specific patterns. One robust way to achieve this is through the use of the KMP (Knuth-Morris-Pratt) algorithm, which efficiently searches for patterns within text. **Goal**: Implement the KMP algorithm to search for all occurrences of a pattern within a given text string. **Function to Implement**: ```python def kmp_search(text: str, pattern: str) -> list[int]: Searches for all occurrences of the pattern in the given text using the KMP algorithm. :param text: the text string where the pattern is to be searched :param pattern: the pattern string to be searched in the text :return: a list of starting indices where pattern is found in text ``` **Input**: - Two strings, `text` and `pattern`, where 1 <= len(pattern) <= len(text) <= 10^5 and both consist of lowercase English letters. **Output**: - Return a list of starting indices (0-based) where the pattern is found within the text. If the pattern is not found, return an empty list. **Constraints**: - The solution should have a time complexity of O(n + m), where n is the length of the text and m is the length of the pattern. - You should not use any inbuilt string matching functions. **Example**: ```python >>> kmp_search(\\"ababcabcabababd\\", \\"ababd\\") [10] >>> kmp_search(\\"ababcabcabababdab\\", \\"abcd\\") [] ``` **Hint**: - First, create the longest proper prefix which is also suffix (LPS) array to preprocess the pattern. - Use the LPS array to skip characters during the main search phase.","solution":"def compute_lps(pattern): Computes the longest proper prefix which is also suffix array for the given pattern. :param pattern: the pattern string :return: LPS array m = len(pattern) lps = [0] * m length = 0 # length of the previous longest prefix suffix i = 1 while i < m: if pattern[i] == pattern[length]: length += 1 lps[i] = length i += 1 else: if length != 0: length = lps[length - 1] else: lps[i] = 0 i += 1 return lps def kmp_search(text, pattern): Searches for all occurrences of the pattern in the given text using the KMP algorithm. :param text: the text string where the pattern is to be searched :param pattern: the pattern string to be searched in the text :return: a list of starting indices where pattern is found in text n = len(text) m = len(pattern) if m == 0: return [] lps = compute_lps(pattern) result = [] i = 0 # index for text j = 0 # index for pattern while i < n: if pattern[j] == text[i]: i += 1 j += 1 if j == m: result.append(i - j) j = lps[j - 1] elif i < n and pattern[j] != text[i]: if j != 0: j = lps[j - 1] else: i += 1 return result"},{"question":"# Implement a Min-Heap A Min-Heap is a complete binary tree where the value of each node is less than or equal to the values of its children. Your task is to implement a Min-Heap in Python. Instructions 1. **Define a `MinHeap` class:** - Implement methods: - `insert`: to insert a value into the heap. - `get_min`: to get the minimum value from the heap (the root node). - `extract_min`: to remove and return the smallest element (the root node), then reheapify. - `heapify`: to maintain the heap property after inserting or extracting elements. - `__len__`: to return the number of elements in the heap. 2. **Define a `heap_sort` function:** - Takes a list of integers as input. - Uses a `MinHeap` to sort the elements. - Returns a list of sorted elements. Function Signature ```python def heap_sort(arr: list[int]) -> list[int]: ``` Examples - `heap_sort([]) -> []` - `heap_sort([1]) -> [1]` - `heap_sort([3, 1, 2]) -> [1, 2, 3]` - `heap_sort([4, -1, 2, 6]) -> [-1, 2, 4, 6]` - `heap_sort([10, 9, 8, 0]) -> [0, 8, 9, 10]` Constraints - The input list may contain up to 10^5 elements. Performance Expectations - Aim for time complexity of O(n log n) for sorting and space complexity of O(n). **Edge Cases**: - Handle empty lists. - Ensure proper handling of large integers. - Handle duplicate values gracefully. --- Example Implementation ```python class MinHeap: def __init__(self): self.heap = [] def insert(self, val): self.heap.append(val) self._heapify_up(len(self.heap) - 1) def get_min(self): return self.heap[0] if self.heap else None def extract_min(self): if len(self.heap) == 0: return None if len(self.heap) == 1: return self.heap.pop() root_val = self.heap[0] self.heap[0] = self.heap.pop() self._heapify_down(0) return root_val def _heapify_up(self, index): parent = (index - 1) // 2 if index > 0 and self.heap[index] < self.heap[parent]: self.heap[index], self.heap[parent] = self.heap[parent], self.heap[index] self._heapify_up(parent) def _heapify_down(self, index): smallest = index left = 2 * index + 1 right = 2 * index + 2 if left < len(self.heap) and self.heap[left] < self.heap[smallest]: smallest = left if right < len(self.heap) and self.heap[right] < self.heap[smallest]: smallest = right if smallest != index: self.heap[index], self.heap[smallest] = self.heap[smallest], self.heap[index] self._heapify_down(smallest) def __len__(self): return len(self.heap) def heap_sort(arr): heap = MinHeap() for elem in arr: heap.insert(elem) sorted_arr = [] while len(heap): sorted_arr.append(heap.extract_min()) return sorted_arr ``` This question assesses your understanding of heap data structures and sorting algorithms, ensuring you can implement and utilize a Min-Heap for efficient sorting.","solution":"class MinHeap: def __init__(self): self.heap = [] def insert(self, val): self.heap.append(val) self._heapify_up(len(self.heap) - 1) def get_min(self): return self.heap[0] if self.heap else None def extract_min(self): if len(self.heap) == 0: return None if len(self.heap) == 1: return self.heap.pop() root_val = self.heap[0] self.heap[0] = self.heap.pop() self._heapify_down(0) return root_val def _heapify_up(self, index): parent = (index - 1) // 2 if index > 0 and self.heap[index] < self.heap[parent]: self.heap[index], self.heap[parent] = self.heap[parent], self.heap[index] self._heapify_up(parent) def _heapify_down(self, index): smallest = index left = 2 * index + 1 right = 2 * index + 2 if left < len(self.heap) and self.heap[left] < self.heap[smallest]: smallest = left if right < len(self.heap) and self.heap[right] < self.heap[smallest]: smallest = right if smallest != index: self.heap[index], self.heap[smallest] = self.heap[smallest], self.heap[index] self._heapify_down(smallest) def __len__(self): return len(self.heap) def heap_sort(arr): heap = MinHeap() for elem in arr: heap.insert(elem) sorted_arr = [] while len(heap): sorted_arr.append(heap.extract_min()) return sorted_arr"},{"question":"Question # Scenario You are given a problem related to string manipulation and pattern matching. In particular, you need to determine how many substrings within a given string are valid palindrome substrings. A palindrome is a string that reads the same forward and backward. # Problem Statement Given a string ( s ), you need to count the number of unique substrings of ( s ) that are palindromes. Write a function that returns the number of these unique palindromic substrings. # Function Signature ```python def count_unique_palindromic_substrings(s: str) -> int: ``` # Input * A string, `s`, consisting of lowercase English letters (1 ≤ |s| ≤ 1000). # Output * An integer representing the number of unique substrings of `s` that are palindromes. # Example ```python >>> count_unique_palindromic_substrings(\\"ababa\\") 5 >>> count_unique_palindromic_substrings(\\"abc\\") 3 >>> count_unique_palindromic_substrings(\\"aaa\\") 3 ``` # Explanation - For \\"ababa\\", the unique palindrome substrings are: \\"a\\", \\"b\\", \\"aba\\", \\"bab\\", \\"ababa\\". - For \\"abc\\", the unique palindrome substrings are: \\"a\\", \\"b\\", \\"c\\". - For \\"aaa\\", the unique palindrome substrings are: \\"a\\", \\"aa\\", \\"aaa\\". # Constraints * Each substring must be considered unique based on its placement in the string. * Optimize your solution to handle up to the maximum string length efficiently. # Implementation Reminder * Use appropriate data structures to efficiently track and ensure the uniqueness of substrings. * Make sure the function handles edge cases such as a single-character string or a string with repeated characters accurately.","solution":"def count_unique_palindromic_substrings(s: str) -> int: def is_palindrome(sub: str) -> bool: return sub == sub[::-1] unique_palindromes = set() n = len(s) for i in range(n): for j in range(i + 1, n + 1): sub = s[i:j] if is_palindrome(sub): unique_palindromes.add(sub) return len(unique_palindromes)"},{"question":"# Challenge: You are given a list of words and a list of characters. Your task is to find the longest word in the list that can be constructed using the characters from the given characters list. Each character in the list of characters can only be used once. If there are multiple results, return the word that appears first in the list of words. **Function Signature**: ```python def longest_constructible_word(words: list, chars: list) -> str: pass ``` # Requirements: - **Input**: - `words`: A list of non-empty strings representing the words. - `chars`: A list of characters representing the available characters. - **Output**: - A string, which is the longest word that can be constructed from the given characters. - If no word can be constructed, return an empty string. # Constraints: - The length of `words` is up to 10^3. - Each word in `words` and the list `chars` contains only lowercase English letters. - The lengths of each word and `chars` are not more than 100. # Example: **Input**: ```python words = [\\"apple\\", \\"plea\\", \\"tan\\", \\"tree\\"] chars = [\'e\', \'t\', \'a\', \'e\', \'p\', \'l\', \'r\'] ``` **Output**: ```python \\"plea\\" ``` # Additional Examples: **Example 2**: **Input**: ```python words = [\\"rat\\", \\"bat\\", \\"cat\\"] chars = [\'t\', \'a\', \'c\'] ``` **Output**: ```python \\"cat\\" ``` **Example 3**: **Input**: ```python words = [\\"house\\", \\"sun\\", \\"moon\\"] chars = [\'o\', \'n\', \'m\'] ``` **Output**: ```python \\"\\" ``` # Notes: 1. You need to check whether a word can be constructed with the given characters without reusing any character more than once. 2. Be sure to consider the order in which words appear if more than one can be constructed. 3. While checking multiple words of the same length, the word that appears first in the input list should be chosen. Provide an implementation for the `longest_constructible_word` function to correctly solve the above problem, handling all edge and boundary cases effectively.","solution":"def longest_constructible_word(words: list, chars: list) -> str: from collections import Counter def can_construct(word, char_count): word_count = Counter(word) for char, count in word_count.items(): if char_count[char] < count: return False return True char_count = Counter(chars) longest_word = \\"\\" for word in words: if can_construct(word, char_count): if len(word) > len(longest_word): longest_word = word return longest_word"},{"question":"# Task: Implement a Custom Range Sum Function Write a function to calculate the sum of integers in a given range, with additional features and error handling. Specifically: 1. **Input Validation**: Ensure that both inputs (`start` and `end`) are integers. In case of invalid input, raise a ValueError with the message \\"Invalid input: Both start and end must be integers\\". 2. **Range Handling**: The function should return the sum of all integers from `start` to `end` (inclusive). If `start` is greater than `end`, raise a ValueError with the message \\"Invalid range: Start must be less than or equal to End\\". 3. **Large Range Issue Handling**: If the range given results in more than 10,000 integers to sum, raise a ValueError with the message \\"Invalid range: Range too large to handle\\". # Function Signature ```python def custom_range_sum(start, end): Calculate the sum of integers in the range from start to end, with enhanced features and error handling. :param start: int, the starting integer of the range :param end: int, the ending integer of the range :return: int, the sum of integers from start to end inclusive >>> custom_range_sum(1, 5) 15 >>> custom_range_sum(10, 10) 10 >>> custom_range_sum(5, 1) Traceback (most recent call last): ... ValueError: Invalid range: Start must be less than or equal to End >>> custom_range_sum(1, 10001) Traceback (most recent call last): ... ValueError: Invalid range: Range too large to handle >>> custom_range_sum(1, \'a\') Traceback (most recent call last): ... ValueError: Invalid input: Both start and end must be integers # Your implementation here ``` # Constraints 1. Both `start` and `end` must be integers. 2. If `start` is greater than `end`, raise a ValueError with the message \\"Invalid range: Start must be less than or equal to End\\". 3. If the range results in more than 10,000 integers, raise a ValueError with the message \\"Invalid range: Range too large to handle\\". # Example Usages - `custom_range_sum(1, 5)` should return `15`. - `custom_range_sum(10, 10)` should return `10`. - `custom_range_sum(1, 10000)` should return `50005000`. - `custom_range_sum(1, 10001)` should raise `ValueError: Invalid range: Range too large to handle`. - `custom_range_sum(10, 5)` should raise `ValueError: Invalid range: Start must be less than or equal to End`. - `custom_range_sum(1, \'a\')` should raise `ValueError: Invalid input: Both start and end must be integers`.","solution":"def custom_range_sum(start, end): Calculate the sum of integers in the range from start to end, with enhanced features and error handling. :param start: int, the starting integer of the range :param end: int, the ending integer of the range :return: int, the sum of integers from start to end inclusive if not isinstance(start, int) or not isinstance(end, int): raise ValueError(\\"Invalid input: Both start and end must be integers\\") if start > end: raise ValueError(\\"Invalid range: Start must be less than or equal to End\\") if end - start + 1 > 10000: raise ValueError(\\"Invalid range: Range too large to handle\\") return sum(range(start, end + 1))"},{"question":"Context A common problem in computer science is determining the shortest path through a grid. You are given a 2D grid that represents a map of obstacles, where `0` represents free space and `1` represents an obstacle. You can move up, down, left, or right, but you cannot move through obstacles. The task is to find the shortest path from the top-left corner to the bottom-right corner of the grid. Problem Statement Implement a function `shortest_path` to compute the minimum number of steps required to reach the bottom-right corner from the top-left corner in a given 2D grid. If there is no valid path, return -1. 1. **shortest_path(grid: list[list[int]]) -> int** - **Input**: - `grid`: A 2D list of integers representing the map of obstacles and free spaces. - **Output**: - An integer representing the minimum number of steps required to reach the bottom-right corner from the top-left corner. Return -1 if no path exists. - **Example**: ```python >>> shortest_path([[0, 1, 0, 0, 0], [0, 1, 0, 1, 0], [0, 0, 0, 1, 0], [1, 1, 0, 1, 1], [0, 0, 0, 0, 0]]) 9 ``` 2. **Constraints**: - `1 <= len(grid), len(grid[0]) <= 500` - `grid[i][j]` is either `0` or `1`. Additional Requirements - Your implementation should efficiently handle edge cases such as: - The start or end position being an obstacle. - Narrow pathways and dead-ends within the grid. - Consider using appropriate algorithms (e.g., Breadth-First Search) to ensure that the shortest path is found. Aim for an optimal time-complexity solution to handle large grids.","solution":"from collections import deque def shortest_path(grid): Computes the minimum number of steps required to reach the bottom-right corner from the top-left corner of the grid. Parameters: grid (list[list[int]]): 2D list of integers representing the map Returns: int: The minimum number of steps required, or -1 if no path exists if not grid or not grid[0]: return -1 rows, cols = len(grid), len(grid[0]) # If the start or end position is an obstacle, return -1 immediately if grid[0][0] == 1 or grid[rows-1][cols-1] == 1: return -1 # BFS initialization directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] queue = deque([(0, 0, 1)]) # (row, col, distance) visited = set((0, 0)) while queue: r, c, dist = queue.popleft() # If we\'ve reached the bottom-right corner, return the distance if r == rows - 1 and c == cols - 1: return dist for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < rows and 0 <= nc < cols and (nr, nc) not in visited and grid[nr][nc] == 0: visited.add((nr, nc)) queue.append((nr, nc, dist + 1)) # If there\'s no path, return -1 return -1"},{"question":"# Recursive Binary Search Tree Operations Background As a software developer, you are tasked with implementing a Binary Search Tree (BST) to efficiently manage a collection of numerical data. The BST is a fundamental data structure that facilitates fast data insertion, deletion, and lookup operations. You need to implement basic operations and ensure the tree maintains its properties. Task Implement the `BinarySearchTree` class with the following methods: - `insert`: Add a value to the BST. - `delete`: Remove a value from the BST. - `search`: Find whether a value exists in the BST. - `inorder_traversal`: Return the values in the BST in sorted order. All methods should be implemented recursively. Requirements - Each method must manage the tree structure such that the BST properties are maintained. - Methods should handle edge cases like duplicate values (ignore insertion of duplicates) and deletion of nodes with zero or one child. Input - For `insert` and `delete`: A value (integer) to be inserted or deleted. - For `search`: A value (integer) to be checked for existence. - For `inorder_traversal`: No input required. Output - For `insert` and `delete`: No output is needed, but the tree structure should be updated accordingly. - For `search`: A boolean indicating whether the value exists in the tree (True if it exists, False otherwise). - For `inorder_traversal`: A list of integers representing the in-order traversal of the BST. Example Usage ```python class Node: def __init__(self, key): self.left = None self.right = None self.value = key class BinarySearchTree: def __init__(self): self.root = None def insert(self, key): if not self.root: self.root = Node(key) else: self._insert(self.root, key) def _insert(self, node, key): if key < node.value: if node.left: self._insert(node.left, key) else: node.left = Node(key) elif key > node.value: if node.right: self._insert(node.right, key) else: node.right = Node(key) def delete(self, key): self.root = self._delete(self.root, key) def _delete(self, node, key): if not node: return node if key < node.value: node.left = self._delete(node.left, key) elif key > node.value: node.right = self._delete(node.right, key) else: if not node.left: return node.right elif not node.right: return node.left temp = self._find_min(node.right) node.value = temp.value node.right = self._delete(node.right, temp.value) return node def _find_min(self, node): current = node while current.left: current = current.left return current def search(self, key): return self._search(self.root, key) def _search(self, node, key): if not node: return False if key == node.value: return True elif key < node.value: return self._search(node.left, key) else: return self._search(node.right, key) def inorder_traversal(self): values = [] self._inorder(self.root, values) return values def _inorder(self, node, values): if node: self._inorder(node.left, values) values.append(node.value) self._inorder(node.right, values) # Example Usage bst = BinarySearchTree() bst.insert(10) bst.insert(5) bst.insert(15) bst.insert(3) bst.insert(7) bst.insert(12) bst.insert(18) print(bst.inorder_traversal()) # Outputs: [3, 5, 7, 10, 12, 15, 18] print(bst.search(7)) # Outputs: True print(bst.search(13)) # Outputs: False bst.delete(10) print(bst.inorder_traversal()) # Outputs: [3, 5, 7, 12, 15, 18] ``` Constraints - The tree should properly handle insertion, deletion, and searching for any integer values. - Ensure that the methods work correctly on a balanced as well as a skewed BST. Good luck!","solution":"class Node: def __init__(self, key): self.left = None self.right = None self.value = key class BinarySearchTree: def __init__(self): self.root = None def insert(self, key): if not self.root: self.root = Node(key) else: self._insert(self.root, key) def _insert(self, node, key): if key < node.value: if node.left: self._insert(node.left, key) else: node.left = Node(key) elif key > node.value: if node.right: self._insert(node.right, key) else: node.right = Node(key) def delete(self, key): self.root = self._delete(self.root, key) def _delete(self, node, key): if not node: return node if key < node.value: node.left = self._delete(node.left, key) elif key > node.value: node.right = self._delete(node.right, key) else: if not node.left: return node.right elif not node.right: return node.left temp = self._find_min(node.right) node.value = temp.value node.right = self._delete(node.right, temp.value) return node def _find_min(self, node): current = node while current.left: current = current.left return current def search(self, key): return self._search(self.root, key) def _search(self, node, key): if not node: return False if key == node.value: return True elif key < node.value: return self._search(node.left, key) else: return self._search(node.right, key) def inorder_traversal(self): values = [] self._inorder(self.root, values) return values def _inorder(self, node, values): if node: self._inorder(node.left, values) values.append(node.value) self._inorder(node.right, values)"},{"question":"Advanced Sorting Algorithms - Hybrid Merge-Quick Sort In this task, you are required to create an enhanced sorting algorithm that combines the best features of Merge Sort and Quick Sort. This hybrid sorting algorithm should switch from Quick Sort to Merge Sort once the recursion depth exceeds a certain threshold. This is intended to reap the benefits of Quick Sort for smaller and moderately sized arrays while avoiding its worst-case scenario through Merge Sort on larger arrays. # Requirements 1. Implement a `hybrid_sort` function that uses Quick Sort as the primary sorting mechanism, but switches to Merge Sort when the recursion depth exceeds a predetermined threshold. 2. Keep input validation logic intact. 3. The threshold for switching can be a function of the array size (e.g., log(n) or a constant value). # Input and Output Formats `hybrid_sort` * **Input**: - `values`: A list of integers. * **Output**: - A sorted list of integers. # Constraints - The input list can contain up to 10^6 elements. - Elements in the list are integers and can include negative values. - The hybrid algorithm should efficiently handle the worst-case scenarios. # Example ```python # Example usage of `hybrid_sort` values = [3, 6, 8, 10, 1, 2, 1] result = hybrid_sort(values) # Expected Output: [1, 1, 2, 3, 6, 8, 10] values = [10, -1, 0, 5, 3] result = hybrid_sort(values) # Expected Output: [-1, 0, 3, 5, 10] ``` # Your Task: 1. Develop the `hybrid_sort` function to effectively integrate both sorting algorithms. 2. Ensure that the function switches to Merge Sort at an appropriate recursion depth. # Implementation Details - Quick Sort is a divide-and-conquer algorithm that is highly efficient for average cases. - Merge Sort is stable and performs well on larger data sets, especially in the worst-case scenarios. - Choosing an appropriate threshold (e.g., log(n) or a fixed constant) is crucial for optimizing the sort efficiency. Implement your solution with consideration of both time and space complexity to handle large data inputs effectively.","solution":"import math def hybrid_sort(values): Sorts the provided list of integers using a hybrid of Quick Sort and Merge Sort. Switches to Merge Sort when the recursion depth exceeds log(n). Parameters: - values: List[int] Returns: - List[int] if len(values) <= 1: return values threshold = int(math.log2(len(values))) def quick_sort(vals, depth): if len(vals) <= 1: return vals if depth > threshold: return merge_sort(vals) pivot = vals[len(vals) // 2] left = [x for x in vals if x < pivot] middle = [x for x in vals if x == pivot] right = [x for x in vals if x > pivot] return quick_sort(left, depth + 1) + middle + quick_sort(right, depth + 1) def merge_sort(vals): if len(vals) <= 1: return vals middle = len(vals) // 2 left = merge_sort(vals[:middle]) right = merge_sort(vals[middle:]) return merge(left, right) def merge(left, right): result = [] i = j = 0 while i < len(left) and j < len(right): if left[i] < right[j]: result.append(left[i]) i += 1 else: result.append(right[j]) j += 1 result.extend(left[i:]) result.extend(right[j:]) return result return quick_sort(values, 0)"},{"question":"You are working on a software project that requires implementing a feature for sorting and managing a list of integers. Specifically, you need a function capable of merging two pre-sorted lists into one sorted list. # Task: Write a function `merge_sorted_lists` that takes two sorted lists of integers and returns a new list that contains all the elements of the input lists in a single sorted order. Function Signature: ```python def merge_sorted_lists(list1: list[int], list2: list[int]) -> list[int]: pass ``` # Input: 1. `list1` (list<int>): A sorted list of integers (0 ≤ len(list1) ≤ 1000). 2. `list2` (list<int>): A sorted list of integers (0 ≤ len(list2) ≤ 1000). # Output: - A list of integers representing the merged and sorted list. # Examples: ```python # Example 1: list1 = [1, 3, 5] list2 = [2, 4, 6] # Expected output: [1, 2, 3, 4, 5, 6] # Example 2: list1 = [0, 10, 20] list2 = [15, 25] # Expected output: [0, 10, 15, 20, 25] # Example 3: list1 = [] list2 = [1, 2, 3] # Expected output: [1, 2, 3] ``` # Constraints: - Both input lists are guaranteed to be sorted in non-decreasing order. - The merged list should also be sorted in non-decreasing order. - Duplicate elements are allowed and should appear in the output list. # Notes: - You should aim for an efficient solution with a time complexity of O(n + m), where n and m are the lengths of the input lists. - Consider edge cases such as one or both lists being empty.","solution":"def merge_sorted_lists(list1: list[int], list2: list[int]) -> list[int]: Merges two sorted lists into a single sorted list. Parameters: - list1 (list<int>): The first sorted list. - list2 (list<int>): The second sorted list. Returns: - list<int>: A merged and sorted list containing all elements from list1 and list2. merged_list = [] i, j = 0, 0 # Traverse both lists and insert smaller elements into the merged list while i < len(list1) and j < len(list2): if list1[i] < list2[j]: merged_list.append(list1[i]) i += 1 else: merged_list.append(list2[j]) j += 1 # Collect any remaining elements from list1 while i < len(list1): merged_list.append(list1[i]) i += 1 # Collect any remaining elements from list2 while j < len(list2): merged_list.append(list2[j]) j += 1 return merged_list"},{"question":"# Problem Statement You are tasked with implementing a system to generate and validate International Bank Account Numbers (IBAN). The system should support both generating IBANs for bank accounts and verifying their validity. # Function to Implement 1. `generate_iban(account_number: str, bank_code: str, country_code: str) -> str` 2. `validate_iban(iban: str) -> bool` Requirements * **generate_iban**: - **Input**: * `account_number` (str): Numeric account number of the bank account. (Constraints: Length between 8 and 20 digits) * `bank_code` (str): Numeric code representing the bank. (Constraints: 4 to 8 digits) * `country_code` (str): The ISO 3166-1 alpha-2 country code. (Constraints: exactly 2 uppercase letters) - **Output**: * Generated IBAN (str). * **validate_iban**: - **Input**: * `iban` (str): The IBAN string to validate. - **Output**: * Boolean indicating whether the IBAN is valid (True) or not (False). Constraints - Account numbers must contain only numeric characters and be between 8 and 20 digits long. - Bank codes must be between 4 and 8 digits long and contain only numeric characters. - Country codes must be exactly 2 uppercase letters. - The generated IBAN should follow IBAN format and be validated using the modulus 97 check. Example ```python def test_iban_functions(): account_number = \\"12345678\\" bank_code = \\"1234\\" country_code = \\"DE\\" # Generate the IBAN iban = generate_iban(account_number, bank_code, country_code) # Example generated IBAN might be \\"DE89123400001234567800\\" (The check digits and format vary based on the provided inputs) # Validate the IBAN is_valid = validate_iban(iban) assert is_valid == True, f\\"Expected True but got {is_valid}\\" # Test with an invalid IBAN is_valid_invalid = validate_iban(\\"DE0089234500012345678XX\\") assert is_valid_invalid == False, f\\"Expected False but got {is_valid_invalid}\\" test_iban_functions() ``` **Note**: Ensure the generated IBAN conforms to the IBAN standard with appropriate check digits, and the validation function properly checks the IBAN format and performs the modulus 97 check accurately.","solution":"def generate_iban(account_number: str, bank_code: str, country_code: str) -> str: def mod97(value: str) -> int: return int(value) % 97 # Validate inputs if not (8 <= len(account_number) <= 20 and account_number.isdigit()): raise ValueError(\\"Account number must be between 8 and 20 digits\\") if not (4 <= len(bank_code) <= 8 and bank_code.isdigit()): raise ValueError(\\"Bank code must be between 4 and 8 digits\\") if not (len(country_code) == 2 and country_code.isalpha() and country_code.isupper()): raise ValueError(\\"Country code must be exactly 2 uppercase letters\\") # Step 1: Assemble the IBAN without check digits partial_iban = bank_code + account_number + country_code + \\"00\\" # Step 2: Move country code and \\"00\\" to the end and convert letters to numbers (A=10, B=11, ..., Z=35) modified_iban = \'\' for char in partial_iban: if char.isdigit(): modified_iban += char else: modified_iban += str(ord(char) - 55) # Step 3: Calculate check digits check_digits = 98 - mod97(modified_iban) # Step 4: Create the full IBAN with check digits check_digits_str = str(check_digits).zfill(2) # Ensure check digits are two characters long full_iban = country_code + check_digits_str + bank_code + account_number return full_iban def validate_iban(iban: str) -> bool: # Step 1: Rearrange the IBAN by moving the first four characters to the end rearranged_iban = iban[4:] + iban[:4] # Step 2: Convert letters to numbers (A=10, B=11, ..., Z=35) numeric_iban = \'\' for char in rearranged_iban: if char.isdigit(): numeric_iban += char else: numeric_iban += str(ord(char) - 55) # Step 3: Perform the mod-97 operation return int(numeric_iban) % 97 == 1"},{"question":"# Task Write a function that checks if a given integer is a perfect square using bit manipulation techniques and mathematical insights without using any built-in library functions or floating-point arithmetic. # Requirements Create a function `is_perfect_square` that takes an integer as input and returns a boolean indicating whether the integer is a perfect square. # Inputs: * `n` (integer): The integer to be checked. # Outputs: * `True` if `n` is a perfect square, otherwise `False`. # Constraints: 1. The input `n` is a non-negative 32-bit signed integer. 2. The function should be efficient and not use any loops longer than O(log n). # Example ```python def is_perfect_square(n: int) -> bool: Check if a given integer is a perfect square. Parameters: n (int): The integer to check. Returns: bool: True if the integer is a perfect square, False otherwise Examples: >>> is_perfect_square(16) True >>> is_perfect_square(15) False >>> is_perfect_square(1) True >>> is_perfect_square(0) True >>> is_perfect_square(25) True pass # Test cases assert is_perfect_square(16) == True, \\"Test case 1 failed\\" assert is_perfect_square(15) == False, \\"Test case 2 failed\\" assert is_perfect_square(1) == True, \\"Test case 3 failed\\" assert is_perfect_square(0) == True, \\"Test case 4 failed\\" assert is_perfect_square(25) == True, \\"Test case 5 failed\\" print(\\"All test cases pass\\") ``` Write the function `is_perfect_square` based on the above description and ensure it passes the provided test cases.","solution":"def is_perfect_square(n: int) -> bool: Check if a given integer is a perfect square. Parameters: n (int): The integer to check. Returns: bool: True if the integer is a perfect square, False otherwise if n < 0: return False # Approach: Use bit manipulation and binary search techniques to find if `n` is a perfect square. if n == 0 or n == 1: return True left, right = 2, n // 2 while left <= right: mid = (left + right) // 2 squared = mid * mid if squared == n: return True elif squared < n: left = mid + 1 else: right = mid - 1 return False"},{"question":"# Heap Sort Implementation and Analysis Implement the Heap Sort algorithm and provide an analysis of its time complexity when sorting an array of integers. Problem Statement 1. Implement a function `heap_sort(arr: List[int]) -> List[int]` that uses Heap Sort to sort the provided list of integers in ascending order. 2. Explain the time complexity of the Heap Sort algorithm for the average, best, and worst-case scenarios. Function Signature ```python from typing import List def heap_sort(arr: List[int]) -> List[int]: pass ``` Input and Output Formats 1. **Function `heap_sort(arr: List[int]) -> List[int]`**: - **Input**: - `arr` (List[int]) - A list of integers. - **Output**: - A new list of integers sorted in ascending order. Explanation 1. Use the following steps to perform Heap Sort: - Build a max heap from the input list. - Repeatedly extract the maximum element from the heap, swap it to the end of the list, and reduce the heap size. - Heapify the root element after each extraction to maintain the heap property. 2. **Time Complexity Analysis**: - **Average Case**: Discuss the typical time complexity of operations involved when sorting an unsorted list. - **Best Case**: Define the scenario where the input list is already sorted and how it affects the time complexity. - **Worst Case**: Consider the input scenario that results in the maximum number of required operations and discuss its complexity. Constraints - The list `arr` can contain any integers, including negative numbers. - Handle edge cases such as empty lists and lists with a single element. - Raise `TypeError` with a suitable message if `arr` is not a list or contains non-integer elements. Scenario and Context You are designing a system that frequently needs to sort large datasets as part of data analysis and reporting. Implementing an efficient sorting algorithm like Heap Sort will improve the overall performance of your system considerably. Ensure your implementation is robust and handles both typical and edge case scenarios effectively. Your solution should also include a clear explanation of how the Heap Sort algorithm works and an analysis of its time complexity to help understand its performance characteristics.","solution":"from typing import List def heapify(arr: List[int], n: int, i: int) -> None: Helper function to maintain the heap property of a subtree rooted at index \'i\', for a heap of size \'n\'. largest = i # Initialize largest as root left = 2 * i + 1 # left child right = 2 * i + 2 # right child # If left child exists and is greater than root if left < n and arr[left] > arr[largest]: largest = left # If right child exists and is greater than the largest so far if right < n and arr[right] > arr[largest]: largest = right # If largest is not root if largest != i: arr[i], arr[largest] = arr[largest], arr[i] # Swap # Recursively heapify the affected subtree heapify(arr, n, largest) def heap_sort(arr: List[int]) -> List[int]: if not isinstance(arr, list): raise TypeError(\\"Input must be a list.\\") if not all(isinstance(x, int) for x in arr): raise TypeError(\\"All elements must be integers.\\") n = len(arr) # Build a max heap for i in range(n // 2 - 1, -1, -1): heapify(arr, n, i) # One by one extract elements from heap and reduce heap size for i in range(n - 1, 0, -1): # Move current root to end arr[i], arr[0] = arr[0], arr[i] # Call heapify on the reduced heap heapify(arr, i, 0) return arr # Example usage: # sorted_list = heap_sort([4, 10, 3, 5, 1]) # print(sorted_list) # Output should be: [1, 3, 4, 5, 10]"},{"question":"# Problem Statement You are tasked with designing a function `process_data_logs` that processes log entries and identifies unique error codes and the count of their occurrences. Each log entry is represented as a string consisting of a timestamp and an error message, where the error code is prefixed with \\"Error:\\". # Input - **logs**: A list of strings where each string represents a log entry in the format `\\"[timestamp] Error: [error_code] - [error message]\\"`. # Output - A dictionary where the keys are unique error codes, and the values are integers representing the count of occurrences for each error code. # Constraints - The error codes consist only of alphanumeric characters. - The input can have up to 10,000 log entries. - The error message may contain any character except newline. # Examples ```python >>> logs = [ \\"2023-05-01 14:55 [123] Error: ERR001 - An unknown error occurred.\\", \\"2023-05-01 14:57 [124] Error: ERR002 - Network timeout.\\", \\"2023-05-01 14:59 [125] Error: ERR001 - An unknown error occurred again.\\", \\"2023-05-01 15:01 [126] Error: ERR003 - Insufficient permissions.\\", \\"2023-05-01 15:03 [127] Error: ERR002 - Network timeout.\\", ] >>> process_data_logs(logs) {\'ERR001\': 2, \'ERR002\': 2, \'ERR003\': 1} ``` # Function Signature ```python def process_data_logs(logs: list) -> dict: pass ``` # Context You are working for a company that monitors system performance and error logs in real-time for thousands of clients. Your job is to analyze these logs to provide insights into common issues by frequency, enabling the team to prioritize which problems to address first.","solution":"def process_data_logs(logs): Processes log entries and identifies unique error codes and the count of their occurrences. Args: logs: A list of strings where each string represents a log entry in the format \\"[timestamp] - Error: [error_code] - [error message]\\" Returns: A dictionary where the keys are unique error codes and the values are the count of occurrences of each error code. error_count = {} for log in logs: # Extract the error code from the log entry error_code_start = log.find(\\"Error: \\") + len(\\"Error: \\") error_code_end = log.find(\\" - \\", error_code_start) error_code = log[error_code_start:error_code_end] # Increment the count for this error code if error_code in error_count: error_count[error_code] += 1 else: error_count[error_code] = 1 return error_count"},{"question":"# Coding Assessment Question Context: You are required to implement an algorithm that finds the shortest path in a weighted directed graph using Dijkstra\'s Algorithm. The algorithm should handle graphs with non-negative weights and return the shortest path from a specified start node to all other nodes. Task: Implement the function `find_shortest_paths(graph: List[List[Tuple[int, float]]], start_node: int) -> List[float]` which: 1. Accepts a graph represented as an adjacency list, where each node points to a list of tuples (neighbor, weight). 2. Returns a list of floats representing the shortest path distance from the start node to every other node. Input: - `graph`: A list of lists of tuples `(int, float)`, where `graph[i]` contains the list of `(neighbor, weight)` pairs representing the edges from node `i`. - `start_node`: An integer representing the start node. Output: - A list of floats representing the shortest path distances from the start node to all other nodes. If a node is not reachable, its distance should be `float(\'inf\')`. Constraints: 1. The number of nodes in the graph `n` will be at most `100`. 2. The weights of the edges are non-negative. 3. The graph may be sparse with `m` edges, where `m <= 1000`. Example: ```python graph = [ [(1, 4), (2, 1)], # Edges from node 0 to 1 (weight 4) and to 2 (weight 1) [(3, 1)], # Edge from node 1 to 3 (weight 1) [(1, 2), (3, 5)], # Edges from node 2 to 1 (weight 2) and to 3 (weight 5) [] # Node 3 has no outgoing edges ] start_node = 0 assert find_shortest_paths(graph, start_node) == [0, 3, 1, 4] ``` Note: Handle errors appropriately for cases where: - The graph contains negative weights or cycles (optional for this task). You may use the following function skeleton: ```python def find_shortest_paths(graph: List[List[Tuple[int, float]]], start_node: int) -> List[float]: pass ```","solution":"import heapq from typing import List, Tuple def find_shortest_paths(graph: List[List[Tuple[int, float]]], start_node: int) -> List[float]: Implements Dijkstra\'s Algorithm to find the shortest paths in a weighted directed graph. :param graph: Adjacency list representation of the graph where every element graph[i] is a list of tuples (neighbor, weight). :param start_node: The starting node for Dijkstra\'s algorithm. :return: List of shortest path distances from the start_node to every other node. If a node is not reachable, its distance will be float(\'inf\'). n = len(graph) distances = [float(\'inf\')] * n distances[start_node] = 0 priority_queue = [(0, start_node)] # (distance, node) while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances"},{"question":"# Coding Question Create a new function that finds the longest word in a list of words and returns its length. If there are multiple words with the same maximum length, return the length of the first one found. # Function Signature ```python def longest_word_length(words: list) -> int: ``` # Input - `words` (list): A list of strings representing the words. # Output - An integer representing the length of the longest word. # Constraints - The list `words` contains at least one word. - Each word is a non-empty string made up of alphabetical characters (uppercase or lowercase). # Performance Requirements - The solution should efficiently handle the list traversal to find the longest word\'s length. - Aim to perform the check in a single pass through the list. # Example ```python assert longest_word_length([\\"apple\\", \\"banana\\", \\"cherry\\", \\"date\\"]) == 6 assert longest_word_length([\\"dog\\", \\"elephant\\", \\"wolf\\"]) == 8 assert longest_word_length([\\"kiwi\\", \\"fig\\", \\"grape\\"]) == 5 ``` # Notes - Consider edge cases such as all words having the same length or the list containing words of different lengths. - Ensure your function accurately returns the length of only the first longest word found in case of ties.","solution":"def longest_word_length(words: list) -> int: Returns the length of the longest word in the list. If multiple words have the same maximum length, the length of the first one found is returned. Args: words (list): A list of strings representing words. Returns: int: Length of the longest word. max_length = 0 for word in words: if len(word) > max_length: max_length = len(word) return max_length"},{"question":"# Implementing a Simple File-Based Key-Value Store You are asked to implement a simplified version of a file-based key-value store using Python. The key-value store should allow storing, retrieving, and deleting key-value pairs on disk, ensuring that the data persists across program runs. # Instructions: 1. Implement a class `KeyValueStore` with the following methods: - `__init__(self, file_path: str)`: Initializes the key-value store with the specified file path. - `set(self, key: str, value: str) -> None`: Stores the key-value pair in the file. If the key already exists, its value should be updated. - `get(self, key: str) -> Optional[str]`: Retrieves the value associated with the key. Returns `None` if the key does not exist. - `delete(self, key: str) -> None`: Deletes the key-value pair from the file. Does nothing if the key does not exist. 2. Ensure that the store handles file I/O efficiently and maintains data integrity. # Input: * File path to the key-value store. * Key-value pairs to set, get, or delete. # Output: * Appropriate values for the operations performed (`set`, `get`, `delete`). # Constraints: * Assume keys and values are strings. * Implement efficient file handling to prevent data corruption. * Handle cases where the file may not exist. # Example: ```python # Initializing the KeyValueStore store = KeyValueStore(\\"kv_store.txt\\") # Setting key-value pairs store.set(\\"name\\", \\"Alice\\") store.set(\\"age\\", \\"30\\") # Retrieving a value print(store.get(\\"name\\")) # Should return \\"Alice\\" print(store.get(\\"age\\")) # Should return \\"30\\" # Deleting a key store.delete(\\"name\\") print(store.get(\\"name\\")) # Should return None ``` # Function Signature: ```python class KeyValueStore: def __init__(self, file_path: str): pass def set(self, key: str, value: str) -> None: pass def get(self, key: str) -> Optional[str]: pass def delete(self, key: str) -> None: pass # Usage Example store = KeyValueStore(\\"kv_store.txt\\") store.set(\\"name\\", \\"Alice\\") store.set(\\"age\\", \\"30\\") print(store.get(\\"name\\")) # Should return \\"Alice\\" store.delete(\\"name\\") print(store.get(\\"name\\")) # Should return None ```","solution":"import os import json from typing import Optional class KeyValueStore: def __init__(self, file_path: str): self.file_path = file_path # Initialize the file if it does not exist if not os.path.exists(file_path): with open(file_path, \'w\') as file: json.dump({}, file) def _read_store(self) -> dict: with open(self.file_path, \'r\') as file: return json.load(file) def _write_store(self, store: dict) -> None: with open(self.file_path, \'w\') as file: json.dump(store, file) def set(self, key: str, value: str) -> None: store = self._read_store() store[key] = value self._write_store(store) def get(self, key: str) -> Optional[str]: store = self._read_store() return store.get(key) def delete(self, key: str) -> None: store = self._read_store() if key in store: del store[key] self._write_store(store)"},{"question":"# Coding Challenge: Implementing a Custom Function in a Trie You have been provided the implementation of a Trie (prefix tree) that supports insertion and searching. Your task is to implement a new feature that can find if there is any word in the Trie that starts with a given prefix. # Task **Function to Implement:** ```python def starts_with(trie, prefix): Given a Trie `trie` and a string `prefix`, return True if there is any word in the Trie that starts with the given prefix, otherwise return False. Parameters: trie (Trie): A Trie object. prefix (str): The prefix to search for in the Trie. Returns: bool: True if there is any word in the Trie that starts with `prefix`, otherwise False. pass ``` **Expected Input and Output:** - **Input**: - `trie`: A `Trie` object representing the root of the Trie. - `prefix`: A string indicating the prefix to search for in the Trie. - **Output**: - A boolean value: `True` if there is any word in the Trie that starts with `prefix`, `False` otherwise. # Constraints - The Trie is case-sensitive and only contains lowercase English letters. - The length of the prefix is between 1 and 100. - The number of words in the Trie is at most 10^4, and the length of each word is at most 100. # Example ```python trie = Trie() words = [\\"apple\\", \\"app\\", \\"banana\\", \\"bat\\", \\"batman\\", \\"cat\\"] for word in words: trie.insert(word) print(starts_with(trie, \\"app\\")) # Output should be True print(starts_with(trie, \\"batm\\")) # Output should be True print(starts_with(trie, \\"ca\\")) # Output should be True print(starts_with(trie, \\"dog\\")) # Output should be False ``` # Implementation Notes - You can make use of any helper functions or methods provided in the `Trie` class. - Aim for an efficient implementation that leverages the structure of the Trie for optimal performance.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word): node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def starts_with(self, prefix): node = self.root for char in prefix: if char not in node.children: return False node = node.children[char] return True def starts_with(trie, prefix): return trie.starts_with(prefix)"},{"question":"# Coding Assessment Question Context You are building a software to manage a collection of books in a library. Each book is represented as a dictionary with specific attributes. One of the tasks involves searching for books that match multiple criteria. You need to implement a function that filters books based on flexible query parameters. Task Implement a function `filter_books` that filters a list of books based on given query parameters and handles various edge cases gracefully. Function Signature ```python def filter_books(books: list, query: dict) -> list: pass ``` Input * `books` is a list of dictionaries, where each dictionary contains attributes of a book (such as \'title\', \'author\', \'year\', \'genre\', etc.). * `query` is a dictionary containing key-value pairs that the books must match. Output * Returns a list of filtered books that match all the query parameters. Constraints * The input `books` must be a list of dictionaries. * The input `query` must be a dictionary. * Raise `TypeError` if `books` is not a list or if any item in `books` is not a dictionary. * Raise `TypeError` if `query` is not a dictionary. * The function should be case-insensitive for string comparisons. * If the query contains criteria that a book does not have, the book should not be included in the result. Example ```python books = [ {\\"title\\": \\"The Great Gatsby\\", \\"author\\": \\"F. Scott Fitzgerald\\", \\"year\\": 1925, \\"genre\\": \\"Fiction\\"}, {\\"title\\": \\"To Kill a Mockingbird\\", \\"author\\": \\"Harper Lee\\", \\"year\\": 1960, \\"genre\\": \\"Fiction\\"}, {\\"title\\": \\"1984\\", \\"author\\": \\"George Orwell\\", \\"year\\": 1949, \\"genre\\": \\"Dystopian\\"}, ] query1 = {\\"author\\": \\"harper lee\\"} query2 = {\\"year\\": 1925, \\"genre\\": \\"fiction\\"} assert filter_books(books, query1) == [{\\"title\\": \\"To Kill a Mockingbird\\", \\"author\\": \\"Harper Lee\\", \\"year\\": 1960, \\"genre\\": \\"Fiction\\"}] assert filter_books(books, query2) == [{\\"title\\": \\"The Great Gatsby\\", \\"author\\": \\"F. Scott Fitzgerald\\", \\"year\\": 1925, \\"genre\\": \\"Fiction\\"}] assert filter_books(books, {}) == books # An empty query should return all books ``` Edge Cases * Invalid input types for `books`: `filter_books(\\"not_a_list\\", query1)` should raise `TypeError`. * Invalid input type for `query`: `filter_books(books, \\"not_a_dict\\")` should raise `TypeError`. * A book missing an attribute in the query: `filter_books(books, {\\"publisher\\": \\"some_publisher\\"})` should return an empty list.","solution":"def filter_books(books: list, query: dict) -> list: if not isinstance(books, list): raise TypeError(\\"The books parameter must be a list.\\") if not all(isinstance(book, dict) for book in books): raise TypeError(\\"All items in the books list must be dictionaries.\\") if not isinstance(query, dict): raise TypeError(\\"The query parameter must be a dictionary.\\") def matches(book, query): for key, value in query.items(): if key not in book: return False if isinstance(value, str): if book[key].lower() != value.lower(): return False else: if book[key] != value: return False return True return [book for book in books if matches(book, query)]"},{"question":"# Coding Assessment Question Problem Statement You are tasked with creating a function that determines whether a given integer is a prime number. Currently, the system does not have a function to perform primality testing, and your goal is to fill this gap. Detailed Description * **Function Name**: `is_prime` * **Inputs**: * `n` (int): The integer to be tested for primality. * **Output**: * Returns `True` if `n` is a prime number, otherwise `False`. * **Constraints**: * The input integer `n` must be non-negative. * Raise appropriate exceptions with helpful error messages if the constraint is violated. Definition A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself. Example ```python >>> is_prime(2) True >>> is_prime(17) True >>> is_prime(18) False >>> is_prime(1) False >>> is_prime(-5) Traceback (most recent call last): ... Exception: Input must be a non-negative integer ``` Implementation Implement the function in Python, structured as follows: ```python def is_prime(n: int) -> bool: Takes an integer n and returns True if n is a prime number, otherwise False. Examples: >>> is_prime(2) True >>> is_prime(17) True >>> is_prime(18) False >>> is_prime(1) False >>> is_prime(-5) Traceback (most recent call last): ... Exception: Input must be a non-negative integer if n < 0: raise Exception(\\"Input must be a non-negative integer\\") if n <= 1: return False if n == 2: return True if n % 2 == 0: return False for i in range(3, int(n ** 0.5) + 1, 2): if n % i == 0: return False return True ```","solution":"def is_prime(n: int) -> bool: Takes an integer n and returns True if n is a prime number, otherwise False. Examples: >>> is_prime(2) True >>> is_prime(17) True >>> is_prime(18) False >>> is_prime(1) False >>> is_prime(-5) Traceback (most recent call last): ... Exception: Input must be a non-negative integer if not isinstance(n, int): raise Exception(\\"Input must be an integer\\") if n < 0: raise Exception(\\"Input must be a non-negative integer\\") if n <= 1: return False if n == 2: return True if n % 2 == 0: return False for i in range(3, int(n ** 0.5) + 1, 2): if n % i == 0: return False return True"},{"question":"# Coding Challenge: Efficient Element Search in a Rotated Array Given a rotated sorted array, the task is to create an efficient algorithm to find the index of an element in this array. If the element is not found, return -1. # Task Implement the `search_rotated_array` method to efficiently find the index of a target element in a rotated sorted array. # Function Signature ```python def search_rotated_array(nums: list[int], target: int) -> int: ``` # Inputs - `nums`: A list of integers representing a rotated sorted array. - `target`: An integer representing the element to be searched in the array. # Outputs - Returns the index of the target element if found; otherwise, returns -1. # Constraints 1. The input list contains between 1 and 10^4 elements. 2. The elements of the list are unique. 3. Each element in the list is between -10^4 and 10^4. 4. The search algorithm should have O(log n) complexity. # Example ```python nums = [4, 5, 6, 7, 0, 1, 2] target = 0 print(search_rotated_array(nums, target)) # Expected Output: 4 nums = [4, 5, 6, 7, 0, 1, 2] target = 3 print(search_rotated_array(nums, target)) # Expected Output: -1 ``` # Additional Information - The provided array is originally sorted in ascending order but has been rotated at some pivot unknown to you beforehand (e.g., [0, 1, 2, 4, 5, 6, 7] becomes [4, 5, 6, 7, 0, 1, 2]). - You must use an efficient algorithm with a time complexity of O(log n). # Hints - Consider using a modified binary search to handle the rotation. - Determine in which portion of the array the target might reside, and then perform binary search accordingly. Implement an efficient solution considering both the structure of the rotated array and the requirement for logarithmic time complexity.","solution":"def search_rotated_array(nums: list[int], target: int) -> int: Returns the index of the target element in a rotated sorted array. If the target is not found, return -1. left, right = 0, len(nums) - 1 while left <= right: mid = (left + right) // 2 if nums[mid] == target: return mid if nums[left] <= nums[mid]: if nums[left] <= target < nums[mid]: right = mid - 1 else: left = mid + 1 else: if nums[mid] < target <= nums[right]: left = mid + 1 else: right = mid - 1 return -1"},{"question":"**Problem Statement** You are given an unsorted list `arr` of integers and an integer `k`. Implement the function `find_first_k_largest(arr: List[int], k: int) -> List[int]` which returns a new list containing the first `k` largest distinct elements in the given list, sorted in descending order. If `k` is out of the bounds of the list, the function should return an empty list. **Input Format**: * `arr`: A list of integers. * `k`: An integer representing the number of elements to select (1 ≤ k ≤ number of distinct elements in the list). **Output Format**: * A list of integers representing the first `k` largest distinct elements sorted in descending order. **Constraints**: * Integers in the array can be positive, negative, or zero. * The length of `arr` is not fixed and can vary within reasonable limits (0 ≤ len(arr) ≤ 10^5). * The number of distinct elements in `arr` will always be greater than or equal to `k`. **Performance Requirements**: * Your solution should aim to have an average time complexity of O(n log k) where n is the number of elements in `arr`. **Example**: ```python def find_first_k_largest(arr, k): # your code here print(find_first_k_largest([2, 4, 5, 7, 899, 54, 32], 3)) # Output: [899, 54, 32] print(find_first_k_largest([5, 4, 3, 2], 2)) # Output: [5, 4] print(find_first_k_largest([3, 5, 7, 10, 2, 12, 7, 3, 3], 4)) # Output: [12, 10, 7, 5] print(find_first_k_largest([1], 1)) # Output: [1] print(find_first_k_largest([10, 9, 8, 10, 6, 5, 4], 3)) # Output: [10, 9, 8] print(find_first_k_largest([], 1)) # Output: [] ``` **Your Task**: * Implement the `find_first_k_largest` function by ensuring that the solution is efficient and handles potential edge cases effectively.","solution":"from typing import List def find_first_k_largest(arr: List[int], k: int) -> List[int]: # Use a set to remove duplicates and a list to sort and take the top k unique_sorted_list = sorted(set(arr), reverse=True) if k > len(unique_sorted_list): return [] # If k is out of bounds, return an empty list return unique_sorted_list[:k]"},{"question":"# Array Duplicate Finder # Objective Implement a function that determines if there are any duplicates in a given list of integers. # Problem Statement You are required to write a function `contains_duplicates(numbers: List[int]) -> bool` to determine if any value appears at least twice in the list. # Input * A list `numbers` of integers. # Output * A boolean value `True` if there are duplicate integers in the list; otherwise, `False`. # Constraints * The list `numbers` can have a length of up to `10^5`. * The integers in the list range from `-10^9` to `10^9`. # Example ```python >>> contains_duplicates([1, 2, 3, 4, 5]) False >>> contains_duplicates([1, 2, 3, 4, 5, 2]) True >>> contains_duplicates([1000000000, -1000000000, 0]) False >>> contains_duplicates([1, 1, 1, 1]) True >>> contains_duplicates([]) False ``` # Notes - Ensure the function is efficient to handle the upper limit of the input size. - Think about the most optimal way to solve the problem within the given constraints.","solution":"from typing import List def contains_duplicates(numbers: List[int]) -> bool: Determines if there are any duplicates in the given list of integers. Args: numbers (List[int]): A list of integers. Returns: bool: True if there are duplicate integers in the list; False otherwise. seen = set() for number in numbers: if number in seen: return True seen.add(number) return False"},{"question":"# Scenario You are responsible for developing a file versioning system that keeps track of changes to a set of files and allows for operations like creating a file, updating a file, retrieving a file version, and rolling back to a previous version. # Task Description Implement a `FileVersionSystem` class that uses a data structure to manage multiple versions of files. The `FileVersionSystem` class should provide the following functionalities: 1. Create a new file. 2. Update an existing file. 3. Retrieve a specific version of a file. 4. Roll back to a previous version of a file. # Input and Output Formats `FileVersionSystem` class should have the following methods: - `create_file(file_name: str, content: str)`: Creates a new file with the given name and content. - `update_file(file_name: str, content: str)`: Updates the file with the given name with the new content, storing the old content as a previous version. - `get_version(file_name: str, version: int) -> str`: Returns the content of the specified version of the file. - `rollback(file_name: str, version: int)`: Reverts the file to the specified version, discarding newer versions. # Constraints - File names are unique. - Initial versions start from 0. - The number of files (`n`) and the number of operations (`m`) will not exceed (10^5). # Example ```python version_system = FileVersionSystem() version_system.create_file(\\"File1\\", \\"Initial content\\") version_system.update_file(\\"File1\\", \\"Updated content v1\\") version_system.update_file(\\"File1\\", \\"Updated content v2\\") assert version_system.get_version(\\"File1\\", 0) == \\"Initial content\\" assert version_system.get_version(\\"File1\\", 1) == \\"Updated content v1\\" assert version_system.get_version(\\"File1\\", 2) == \\"Updated content v2\\" version_system.rollback(\\"File1\\", 1) assert version_system.get_version(\\"File1\\", 2) == \\"Updated content v1\\" ``` # Requirements Ensure that your implementation handles edge cases and efficiently manages file versioning with a large number of files and operations.","solution":"class FileVersionSystem: def __init__(self): self.files = {} def create_file(self, file_name: str, content: str): if file_name not in self.files: self.files[file_name] = [content] def update_file(self, file_name: str, content: str): if file_name in self.files: self.files[file_name].append(content) def get_version(self, file_name: str, version: int) -> str: if file_name in self.files and 0 <= version < len(self.files[file_name]): return self.files[file_name][version] raise ValueError(f\\"Version {version} does not exist for file {file_name}.\\") def rollback(self, file_name: str, version: int): if file_name in self.files and 0 <= version < len(self.files[file_name]): self.files[file_name] = self.files[file_name][:version + 1] else: raise ValueError(f\\"Version {version} does not exist for file {file_name}.\\")"},{"question":"# Problem Statement: You are required to implement a system that can process a directory of files and produce a summary report based on specific criteria. The system should scan all the `.txt` files in a given directory, calculate word frequencies for each file, and identify the file with the highest occurrence of a specific target word. # Function Requirements: 1. **`calculate_word_frequencies(directory: str) -> Dict[str, Dict[str, int]]`**: - **Input**: - `directory` (string): The path to the directory containing `.txt` files. - **Output**: - Return a dictionary where each key is a filename (string) and the value is another dictionary containing word frequencies (word as key, frequency as value). 2. **`find_file_with_max_target_word(directory: str, target_word: str) -> Tuple[str, int]`**: - **Input**: - `directory` (string): The path to the directory containing `.txt` files. - `target_word` (string): The word to search for in the files. - **Output**: - Return a tuple containing the filename with the highest occurrence of the target word and the corresponding occurrence count. # Constraints: - The directory will only contain text files (`.txt`). - Words should be considered case-insensitive. - Ignore punctuation and numbers while processing the text. - If multiple files have the same target word count, return any one of them. - Your implementation should handle empty files and empty directories appropriately. # Example: ```python # Assuming the directory structure and files are as follows: # /testdir/file1.txt -> \\"Hello world. Hello!\\" # /testdir/file2.txt -> \\"Hello once. And then another hello.\\" # /testdir/file3.txt -> \\"This file is hello free.\\" directory = \\"testdir\\" # Example Word Frequencies Calculation word_frequencies = calculate_word_frequencies(directory) assert word_frequencies == { \'file1.txt\': {\'hello\': 2, \'world\': 1}, \'file2.txt\': {\'hello\': 2, \'once\': 1, \'and\': 1, \'then\': 1, \'another\': 1}, \'file3.txt\': {\'this\': 1, \'file\': 1, \'is\': 1, \'hello\': 1, \'free\': 1} } # Example Find File with Maximum Target Word target_word = \\"hello\\" file_with_max_hello = find_file_with_max_target_word(directory, target_word) assert file_with_max_hello == (\'file1.txt\', 2) or file_with_max_hello == (\'file2.txt\', 2) ``` # Additional Requirements: - Focus on time and space efficiency. - Ensure all processes are clearly legible and well-commented. - Take care of edge cases like non-existent directories and files without text. - Provide proper verification using assert statements.","solution":"import os import re from collections import defaultdict from typing import Dict, Tuple def calculate_word_frequencies(directory: str) -> Dict[str, Dict[str, int]]: word_frequencies = defaultdict(lambda: defaultdict(int)) for filename in os.listdir(directory): if filename.endswith(\\".txt\\"): with open(os.path.join(directory, filename), \'r\', encoding=\'utf-8\') as file: content = file.read().lower() words = re.findall(r\'b[a-z]+b\', content) for word in words: word_frequencies[filename][word] += 1 return dict(word_frequencies) def find_file_with_max_target_word(directory: str, target_word: str) -> Tuple[str, int]: target_word = target_word.lower() word_frequencies = calculate_word_frequencies(directory) max_count = 0 max_file = None for filename, frequencies in word_frequencies.items(): count = frequencies.get(target_word, 0) if count > max_count: max_count = count max_file = filename return (max_file, max_count) if max_file else (\\"\\", 0)"},{"question":"# Finding the Missing Number in an Array # Problem Statement You are required to implement a function `find_missing_number` that finds the missing number in a list containing `n` unique numbers from `0` to `n`, with exactly one number missing. The function should return the missing number. # Function Signature ```python def find_missing_number(arr: list) -> int: pass ``` # Input * A single list `arr` containing `n` unique integers from `0` to `n`, with exactly one number missing. # Output * Return the missing number. # Constraints * The function should handle the list efficiently. * The length of the input list will be `n`, where `1 <= n <= 10^6`. # Examples ```python >>> find_missing_number([3, 0, 1]) 2 >>> find_missing_number([0, 1, 2, 4, 5]) 3 >>> find_missing_number([0]) 1 >>> find_missing_number([1]) 0 >>> find_missing_number([6, 2, 1, 4, 0, 5]) 3 ``` # Explanation Consider the list `arr`: * For `[3, 0, 1]`, the list contains the numbers from `0` to `3` with `2` missing. * For `[0, 1, 2, 4, 5]`, the numbers are from `0` to `5` with `3` missing. * For `[0]`, the expected numbers are from `0` to `1` with `1` missing. * For `[1]`, the expected numbers are from `0` to `1` with `0` missing. * For `[6, 2, 1, 4, 0, 5]`, the numbers should be from `0` to `6` with `3` missing. # Implementation Notes * Calculate the sum of numbers from `0` to `n` (i.e., `n*(n+1)//2`). * Subtract the sum of the list `arr` from this expected sum to find the missing number.","solution":"def find_missing_number(arr): Given a list arr containing n unique numbers from 0 to n with exactly one number missing, this function returns the missing number. n = len(arr) expected_sum = n * (n + 1) // 2 actual_sum = sum(arr) return expected_sum - actual_sum"},{"question":"# Question: Implement and Integrate a Logistic Regression Model with L2 Regularization You are given a base implementation of Logistic Regression. Your task is to augment this implementation by integrating L2 regularization and enhance the optimization process using gradient descent. Furthermore, you need to implement a feature that dynamically tunes the regularization parameter (λ) using cross-validation over a set of candidate values. Step 1: Implement Dynamic Regularization Parameter Selection 1. **Function Signature**: ```python def optimal_lambda_selection( x_train: np.ndarray, y_train: np.ndarray, candidate_lambdas: List[float], k: int ) -> float: ``` 2. **Inputs**: - `x_train`: Numpy array of shape (m, n) with the training data. - `y_train`: Numpy array of shape (m,) with the training labels. - `candidate_lambdas`: List of candidate regularization (λ) values. - `k`: Integer, number of folds for k-fold cross-validation. 3. **Outputs**: - `best_lambda`: The candidate value of λ that gives the best cross-validation mean squared error. 4. **Procedure**: - Implement k-fold cross-validation. - For each value in `candidate_lambdas`, perform logistic regression with L2 regularization and compute the cross-entropy loss over k folds. - Choose the regularization parameter with the smallest cross-validation error. Step 2: Add Enhancements to Logistic Regression 1. **Optimization**: - Integrate L2 regularization term into the logistic regression cost function. - Implement gradient descent optimization, including the regularization term in both the cost function and gradient computation. 2. **Error Handling**: - Add robust error handling for edge cases and potential numerical stability issues. You can modify the existing `logistic_regression` function or create a new one. Step 3: Performance Verification 1. Verify your enhanced algorithm with a dataset, such as the Iris dataset from `sklearn.datasets`. 2. Show that your solution efficiently finds the best regularization parameter and improves model performance compared to using no regularization. ```python # Example usage: from sklearn.datasets import load_iris data = load_iris() x_train, y_train = data.data, data.target candidate_lambdas = [0.01, 0.1, 1, 10, 100] optimal_lambda = optimal_lambda_selection(x_train, y_train, candidate_lambdas, 5) optimized_model = improved_logistic_regression(x_train, y_train, optimal_lambda) validate_results(optimized_model, x_train, y_train) ``` **Note**: Do not use libraries such as `scikit-learn` for cross-validation or model training, implement them manually.","solution":"import numpy as np from typing import List def sigmoid(z): return 1 / (1 + np.exp(-z)) def compute_cost(X, y, theta, lambda_reg): Compute the cost for logistic regression with L2 regularization X: input features, numpy array of shape (m, n) y: labels, numpy array of shape (m,) theta: parameters, numpy array of shape (n,) lambda_reg: regularization parameter m = len(y) h = sigmoid(X @ theta) cost = -(1/m) * (y @ np.log(h) + (1 - y) @ np.log(1 - h)) + (lambda_reg/(2*m)) * np.sum(np.square(theta[1:])) return cost def gradient_descent(X, y, theta, learning_rate, lambda_reg, num_iterations): Perform gradient descent to learn theta values X: input features, numpy array of shape (m, n) y: labels, numpy array of shape (m,) theta: parameters, numpy array of shape (n,) learning_rate: learning rate for gradient descent lambda_reg: regularization parameter num_iterations: number of iterations for gradient descent m = len(y) for i in range(num_iterations): h = sigmoid(X @ theta) theta = theta - (learning_rate/m) * (X.T @ (h - y) + lambda_reg * np.r_[[0], theta[1:]]) return theta def k_fold_cross_validation(X, y, k, lambda_reg, learning_rate, num_iterations): Perform k-fold cross-validation on the training data X: input features, numpy array of shape (m, n) y: labels, numpy array of shape (m,) k: number of folds lambda_reg: regularization parameter learning_rate: learning rate for gradient descent num_iterations: number of iterations for gradient descent m, n = X.shape fold_size = m // k errors = [] for i in range(k): start_index = i * fold_size end_index = start_index + fold_size if (i+1) * fold_size <= m else m X_val_fold = X[start_index:end_index, :] y_val_fold = y[start_index:end_index] X_train_fold = np.concatenate([X[:start_index, :], X[end_index:, :]], axis=0) y_train_fold = np.concatenate([y[:start_index], y[end_index:]], axis=0) theta = np.zeros(n) theta = gradient_descent(X_train_fold, y_train_fold, theta, learning_rate, lambda_reg, num_iterations) cost_val = compute_cost(X_val_fold, y_val_fold, theta, lambda_reg) errors.append(cost_val) return np.mean(errors) def optimal_lambda_selection(x_train: np.ndarray, y_train: np.ndarray, candidate_lambdas: List[float], k: int) -> float: Find the optimal lambda using k-fold cross validation x_train: training data features, numpy array of shape (m, n) y_train: training data labels, numpy array of shape (m,) candidate_lambdas: list of candidate lambda values k: number of folds for cross-validation best_lambda = None best_error = float(\'inf\') learning_rate = 0.01 num_iterations = 1000 for lambda_reg in candidate_lambdas: error = k_fold_cross_validation(x_train, y_train, k, lambda_reg, learning_rate, num_iterations) if error < best_error: best_error = error best_lambda = lambda_reg return best_lambda def improved_logistic_regression(x_train: np.ndarray, y_train: np.ndarray, optimal_lambda: float): Train logistic regression model with optimal lambda x_train: training data features, numpy array of shape (m, n) y_train: training data labels, numpy array of shape (m,) optimal_lambda: optimal lambda value found from cross-validation m, n = x_train.shape theta = np.zeros(n) learning_rate = 0.01 num_iterations = 1000 theta = gradient_descent(x_train, y_train, theta, learning_rate, optimal_lambda, num_iterations) return theta"},{"question":"# Problem Statement You are provided with a class `LinkedList` for basic operations on a singly linked list of integers. Your task is to extend this functionality by adding a new method to the `LinkedList` class. The new method should implement the detection of a loop in the linked list using Floyd’s Cycle-Finding Algorithm (the Tortoise and the Hare algorithm). # Function Signature ```python class LinkedList: ... def has_cycle(self) -> bool: This method should return True if there is a cycle in the linked list, otherwise return False. ``` # Input & Output - **Input**: - No input parameters are required for the method. Use the internal state of the linked list. - **Output**: - The method should return a boolean value `True` if there is a cycle in the linked list and `False` otherwise. # Examples 1. **Example 1**: ```python ll = LinkedList() ll.append(1) ll.append(2) ll.append(3) ll.head.next.next.next = ll.head # Creating a cycle print(ll.has_cycle()) ``` **Output**: ``` True ``` 2. **Example 2**: ```python ll = LinkedList() ll.append(1) ll.append(2) ll.append(3) print(ll.has_cycle()) ``` **Output**: ``` False ``` # Constraints - The number of nodes in the linked list will not exceed 1000. - You may assume that the `LinkedList` class and all its basic methods like `append` are already defined as shown in the provided code snippet. # Notes - Using extra space (like a HashSet to store visited nodes) is not allowed; the solution needs to be implemented using Floyd’s Cycle-Finding Algorithm. Implement the `has_cycle` method in the `LinkedList` class.","solution":"class Node: def __init__(self, value=0, next=None): self.value = value self.next = next class LinkedList: def __init__(self): self.head = None def append(self, value): if not self.head: self.head = Node(value) else: current = self.head while current.next: current = current.next current.next = Node(value) def has_cycle(self) -> bool: This method uses Floyd\'s Cycle-Finding Algorithm to detect if there is a cycle in the linked list. Returns True if there is a cycle, otherwise returns False. slow = self.head fast = self.head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: return True return False"},{"question":"You are given a list of transactions where each transaction is represented by a tuple (id, amount). Your task is to determine the transaction ID that has the highest amount. If there are multiple transactions with the highest amount, return the one that appears first in the list. # Requirements: 1. Process the list of transactions to find the one with the highest amount. 2. Return the transaction ID of the highest amount transaction. Write a function called `highest_transaction_id(transactions: List[Tuple[int, float]]) -> int` which takes a list of tuples `transactions` and returns the transaction ID with the highest amount. # Input Format - A list of tuples `transactions` where each tuple contains an integer (transaction ID) and a float (transaction amount). # Output Format - Return an integer representing the transaction ID with the highest amount. # Example ```python def test_highest_transaction_id(): assert highest_transaction_id([(1, 100.0), (2, 200.0), (3, 150.0)]) == 2 assert highest_transaction_id([(1, 150.0), (2, 150.0), (3, 100.0)]) == 1 test_highest_transaction_id() ``` # Performance Requirements * The function should operate efficiently even for large lists of transactions, with a reasonable runtime performance.","solution":"from typing import List, Tuple def highest_transaction_id(transactions: List[Tuple[int, float]]) -> int: Returns the transaction ID with the highest amount. Args: transactions (List[Tuple[int, float]]): List of transactions where each transaction is a tuple (id, amount). Returns: int: The transaction ID with the highest amount. if not transactions: raise ValueError(\\"The transactions list cannot be empty\\") highest_id, highest_amount = transactions[0] for trans_id, amount in transactions[1:]: if amount > highest_amount: highest_id, highest_amount = trans_id, amount return highest_id"},{"question":"# Sparse Matrix Representation Sparse matrices are matrices that are predominantly composed of zeroes. In order to save memory, these matrices can be represented in a more efficient way. Objective Create a class `SparseMatrix` that supports the following operations: 1. Initialization of a sparse matrix given its dense form (a 2D list). 2. Conversion of the matrix to its CSR (Compressed Sparse Row) format. 3. Matrix-vector multiplication using the CSR format. 4. Retrieving the element at a specific position (row, column). Your task is to: - Implement the `SparseMatrix` class with the specified methods. - Optimize the operations to handle large sparse matrices efficiently. # Class Definition ```python class SparseMatrix: def __init__(self, dense_matrix: List[List[int]]): pass def to_csr(self) -> Tuple[List[int], List[int], List[int]]: pass def multiply(self, vector: List[int]) -> List[int]: pass def get_element(self, row: int, col: int) -> int: pass ``` Input - `dense_matrix`: A 2D list of integers representing the dense form of the matrix (can be empty). - `vector`: A list of integers representing the vector for multiplication. - `row`, `col`: Integers representing the row and column to retrieve the element from. Output - `to_csr`: A tuple containing three lists: `values`, `columns`, and `row_pointer`. - `multiply`: A list of integers representing the result of the matrix-vector multiplication. - `get_element`: An integer which is the element at the specified position in the dense form of the matrix. Example ```python matrix = [ [0, 0, 3, 0], [22, 0, 0, 0], [0, 0, 0, 0], [0, 5, 0, 0] ] vector = [1, 2, 3, 4] sparse_matrix = SparseMatrix(matrix) # Convert to CSR format csr = sparse_matrix.to_csr() print(csr) # Output example: ([3, 22, 5], [2, 0, 1], [0, 1, 2, 2, 3]) # Matrix-vector multiplication result = sparse_matrix.multiply(vector) print(result) # Output example: [9, 22, 0, 10] # Retrieve element at position (1, 0) elem = sparse_matrix.get_element(1, 0) print(elem) # Output: 22 ``` # Constraints - The matrix can be large but mostly composed of zeroes. - Handle edge cases such as an empty matrix or vectors with lengths unrelated to the matrix\'s dimensions. - Ensure matrix-vector multiplication is performed efficiently, taking advantage of the sparse structure.","solution":"from typing import List, Tuple class SparseMatrix: def __init__(self, dense_matrix: List[List[int]]): self.dense_matrix = dense_matrix self.csr_values = [] self.csr_columns = [] self.csr_row_pointer = [] if dense_matrix: self.rows = len(dense_matrix) self.cols = len(dense_matrix[0]) else: self.rows = 0 self.cols = 0 self._to_csr() def _to_csr(self): values = [] columns = [] row_pointer = [0] nz_count = 0 for row in self.dense_matrix: for col_index, value in enumerate(row): if value != 0: values.append(value) columns.append(col_index) nz_count += 1 row_pointer.append(nz_count) self.csr_values = values self.csr_columns = columns self.csr_row_pointer = row_pointer def to_csr(self) -> Tuple[List[int], List[int], List[int]]: return (self.csr_values, self.csr_columns, self.csr_row_pointer) def multiply(self, vector: List[int]) -> List[int]: if len(vector) != self.cols: raise ValueError(\\"Vector size does not match matrix dimensions.\\") result = [0] * self.rows for i in range(self.rows): row_start = self.csr_row_pointer[i] row_end = self.csr_row_pointer[i+1] for index in range(row_start, row_end): result[i] += self.csr_values[index] * vector[self.csr_columns[index]] return result def get_element(self, row: int, col: int) -> int: if row < 0 or row >= self.rows or col < 0 or col >= self.cols: raise ValueError(\\"Row or column out of bounds.\\") row_start = self.csr_row_pointer[row] row_end = self.csr_row_pointer[row+1] for index in range(row_start, row_end): if self.csr_columns[index] == col: return self.csr_values[index] return 0"},{"question":"# Sum of Squares of Digits As part of a computational mathematics module, your task is to implement a function that returns the sum of the squares of the digits of a given integer. This will require an understanding of number manipulation and digit extraction techniques. The solution should efficiently handle a wide range of input sizes. Function Signature ```python def sum_of_squares_of_digits(n: int) -> int: ``` Input * `n` - An integer which can be positive, negative, or zero. Output * Returns the sum of the squares of the digits of the given integer. Constraints * The function should only accept integer inputs; if the input is non-integral, raise a `TypeError`. * The solution should handle both positive and negative integers by considering the absolute value of the number. # Example Scenarios ```python >>> sum_of_squares_of_digits(123) 14 >>> sum_of_squares_of_digits(-456) 77 >>> sum_of_squares_of_digits(0) 0 >>> sum_of_squares_of_digits(\'abc\') Traceback (most recent call last): ... TypeError: sum_of_squares_of_digits() only accepts integers ``` # Guidelines 1. Implement digit extraction and squaring each digit. 2. Handle negative inputs by converting them to their absolute value. 3. Ensure non-integer inputs raise an appropriate error. 4. Efficiently calculate the result with a focus on clarity and performance. Happy coding!","solution":"def sum_of_squares_of_digits(n: int) -> int: Returns the sum of the squares of the digits of a given integer. Parameters: n: int - the input integer which can be positive, negative or zero. Returns: int - sum of the squares of the digits. if not isinstance(n, int): raise TypeError(\\"sum_of_squares_of_digits() only accepts integers\\") n = abs(n) return sum(int(digit) ** 2 for digit in str(n))"},{"question":"# Coding Question **Context**: Given a matrix and a target number, your task is to determine whether the target number exists within the matrix. The matrix has specific properties that restrict the movement and the approach you can use to find the target efficiently. **Objective**: Write a function `search_matrix(matrix: List[List[int]], target: int) -> bool` that returns `True` if the target number exists in the matrix, and `False` otherwise. # Criteria: 1. **Input**: * A list of lists of integers `matrix`, where each sublist represents a row in the matrix. * The matrix follows these rules: * Each row is sorted in ascending order. * Each column is sorted in ascending order. * An integer `target` representing the number to search for. 2. **Output**: * A boolean value `True` if the target is found, `False` otherwise. 3. **Constraints**: * Each element in `matrix` will be an integer. * The matrix will have at least 1 row and 1 column. * The matrix dimensions will be at most `100x100`. 4. **Performance**: * Implement the search with an algorithm that optimally exploits the sorted properties of the matrix. # Example: ```python def search_matrix(matrix: List[List[int]], target: int) -> bool: # Your implementation here matrix = [ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ] target = 5 print(search_matrix(matrix, target)) # Expected: True target = 20 print(search_matrix(matrix, target)) # Expected: False ``` # Approach: * You can start from the top-right corner of the matrix: * If the current number is greater than the target, move left. * If the current number is less than the target, move down. This method leverages the sorted properties of the matrix efficiently. Write your function to solve this problem, ensuring that it handles both small and large inputs within the given constraints.","solution":"from typing import List def search_matrix(matrix: List[List[int]], target: int) -> bool: Searches for the target in the matrix. Returns True if found, otherwise False. The matrix has properties that each row is sorted in ascending order and each column is sorted in ascending order. :param matrix: List of Lists of integers representing the matrix :param target: Integer target number to search for :return: Boolean indicating if target is found or not if not matrix or not matrix[0]: return False rows, cols = len(matrix), len(matrix[0]) row, col = 0, cols - 1 while row < rows and col >= 0: if matrix[row][col] == target: return True elif matrix[row][col] > target: col -= 1 else: row += 1 return False"},{"question":"# User Registration and Login System Problem Statement You are given a task to implement a basic user registration and login system for a web application. Your task is to implement two functions: `register_user` and `login_user`. Function Signatures ```python def register_user(username: str, password: str) -> bool: pass def login_user(username: str, password: str) -> bool: pass ``` Detailed Description * `register_user(username: str, password: str) -> bool`: - Registers a new user with the provided username and password. - Returns `True` if the registration is successful. - Returns `False` if the username is already taken. * `login_user(username: str, password: str) -> bool`: - Authenticates the user with the provided username and password. - Returns `True` if the login is successful. - Returns `False` if the username is not registered or the password is incorrect. Input Constraints - `username` should be a non-empty string. - `password` should be a non-empty string. - Usernames are unique, meaning no two users can have the same username. Output - The functions return boolean values based on the success or failure of their operations. Example Usage Implement the functions with the following behavior: ```python >>> register_user(\\"john_doe\\", \\"password123\\") True >>> register_user(\\"john_doe\\", \\"newpassword\\") False >>> login_user(\\"john_doe\\", \\"password123\\") True >>> login_user(\\"john_doe\\", \\"wrongpassword\\") False >>> login_user(\\"jane_doe\\", \\"password123\\") False ``` Hints - Use a dictionary to store registered users, where the keys are usernames and values are passwords. - Ensure that user data is handled securely (consider hashing passwords for a real-world application, though this is not required for this task). - Validate inputs to ensure they are non-empty strings.","solution":"# Dictionary to store registered users users_db = {} def register_user(username: str, password: str) -> bool: if username in users_db or not username or not password: return False users_db[username] = password return True def login_user(username: str, password: str) -> bool: if username in users_db and users_db[username] == password: return True return False"},{"question":"# Optimal Path Through a Grid with Obstacles **Scenario**: You are working on a mapping application that helps to find the shortest path across a grid layout where certain cells may be blocked due to obstacles. To improve the application\'s performance, the shortest path needs to be computed efficiently even for large grids. **Task**: Write a program that calculates the shortest path from the top-left corner to the bottom-right corner of a grid, considering obstacles. Use Breadth-First Search (BFS) to navigate through the grid. **Input**: - A 2D list (list of lists) representing the grid, where each element is either 0 (open cell) or 1 (blocked cell). **Output**: - The length of the shortest path from the top-left corner to the bottom-right corner, or -1 if no such path exists. **Constraints**: - The grid dimensions will be `m x n`, where `1 <= m, n <= 500`. - The top-left and bottom-right cells will always be open (i.e., 0). **Performance Requirements**: - Ensure efficient computation for grids up to 250,000 cells using BFS to handle the large input sizes appropriately. **Function Signature**: ```python def shortest_path(grid: list[list[int]]) -> int: pass ``` **Example**: ```python # Test with a 5x5 grid with obstacles grid = [ [0, 1, 0, 0, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 0], [1, 1, 1, 1, 0], [0, 0, 0, 0, 0] ] print(shortest_path(grid)) # Output: 9 (The shortest path has 9 steps) ``` # Explanation: - The function uses BFS starting from the top-left corner of the grid (0,0). - It explores all available paths and keeps track of the shortest one. - If it encounters the bottom-right corner (m-1, n-1) during the search, it returns the length of the current path. - If no path exists, it returns -1.","solution":"from collections import deque def shortest_path(grid: list[list[int]]) -> int: Uses Breadth-First Search (BFS) to find the shortest path from the top-left corner to the bottom-right corner of a grid with obstacles. Args: grid (list of list of int): 2D grid where 0 indicates an open cell and 1 indicates a blocked cell. Returns: int: The length of the shortest path or -1 if no such path exists. if not grid or grid[0][0] == 1 or grid[-1][-1] == 1: return -1 m, n = len(grid), len(grid[0]) directions = [(1, 0), (0, 1), (-1, 0), (0, -1)] # down, right, up, left queue = deque([(0, 0, 1)]) # (row, column, path_length) visited = set((0, 0)) while queue: r, c, length = queue.popleft() if r == m - 1 and c == n - 1: return length for dr, dc in directions: new_r, new_c = r + dr, c + dc if 0 <= new_r < m and 0 <= new_c < n and grid[new_r][new_c] == 0 and (new_r, new_c) not in visited: visited.add((new_r, new_c)) queue.append((new_r, new_c, length + 1)) return -1"},{"question":"# Check if a String Contains All Unique Characters You are given an incomplete implementation of a function that checks if a given string contains all unique characters. Your task is to complete this function. Function Signature ```python def has_unique_chars(s: str) -> bool: ``` Parameters * **s** (str): The input string to be checked. Returns * **bool**: Returns `True` if the string contains all unique characters, `False` otherwise. Constraints 1. The string length will be between 1 to 100, inclusive. 2. The string will consist of only ASCII characters. 3. The implementation should use a constant extra space, not dependent on the length of the string. Example ```python >>> has_unique_chars(\\"abcdef\\") True >>> has_unique_chars(\\"hello\\") False >>> has_unique_chars(\\"AaBbCc\\") True ``` Additional Notes * You may not use additional data structures that grow with the input size. * Consider edge cases where the string length is minimal (1 character) and maximal (100 characters). Implement the `has_unique_chars` function with the provided specifications.","solution":"def has_unique_chars(s: str) -> bool: Checks if a given string contains all unique characters. :param s: The input string to be checked. :return: True if the string contains all unique characters, False otherwise. # Since the constraints guarantee ASCII characters only if len(s) > 128: # There are only 128 unique ASCII characters return False char_set = [False] * 128 # Array to track the presence of characters for char in s: ascii_val = ord(char) if char_set[ascii_val]: return False char_set[ascii_val] = True return True"},{"question":"# Problem Statement: Unique Substrings of a Given Length You are required to write a function that finds all unique substrings of a given length from an input string. The substrings should be distinct and sorted lexicographically in the final output. Function Specification **Function Name**: `unique_substrings` **Parameters**: - `input_string` (str): The string from which substrings are to be extracted. - `length` (int): The length of each substring to be extracted. **Returns**: - A list of strings representing the unique substrings of the specified length, sorted lexicographically. **Constraints**: - The input string will contain only lowercase English letters. - The length of the input string will be between 1 and 100. - The specified length for substrings will be between 1 and the length of the input string. **Example Usage**: ```python unique_substrings(\'banana\', 3) # Expected Output: [\'ana\', \'ban\', \'nan\'] unique_substrings(\'abracadabra\', 2) # Expected Output: [\'ab\', \'ad\', \'ac\', \'br\', \'ca\', \'da\', \'ra\'] unique_substrings(\'apple\', 1) # Expected Output: [\'a\', \'e\', \'l\', \'p\'] ``` Explanation: - In the first example, the substrings of length 3 extracted from \\"banana\\" are [\'ban\', \'ana\', \'nan\', \'ana\']. Removing duplicates and sorting lexicographically results in [\'ana\', \'ban\', \'nan\']. - In the second example, the 2-length substrings from \\"abracadabra\\" are first extracted, then duplicates are removed, and the list is sorted. - The third example, with length 1, simply extracts each character, removes duplicates, and sorts the characters lexicographically.","solution":"def unique_substrings(input_string, length): Returns a list of unique substrings of the specified length from the input string, sorted lexicographically. substrings = set(input_string[i:i+length] for i in range(len(input_string) - length + 1)) return sorted(substrings)"},{"question":"# Coding Assessment Question Problem: You are tasked with developing a function that calculates the factorial of a given integer using both iterative and recursive approaches. Each approach should be implemented as a separate internal function within the main function. The main function should return a dictionary that contains the results of both approaches. Function Signature: ```python def factorial_comparison(n: int) -> dict: Calculate the factorial of a given number using both iterative and recursive methods. Input Parameters: ----------------- n: A non-negative integer whose factorial needs to be calculated. Returns: -------- A dictionary with keys \'iterative\' and \'recursive\' holding the respective factorial values. pass ``` Input: - `n` is a non-negative integer. Output: - Return a dictionary with two keys: `\'iterative\'` and `\'recursive\'`. Each key should be paired with the computed factorial value of `n` using the respective method. Constraints: * `0 <= n <= 20` * The function should handle edge cases such as `n = 0` where the factorial is 1. Example: ```python factorial_comparison(5) # Output: {\\"iterative\\": 120, \\"recursive\\": 120} factorial_comparison(0) # Output: {\\"iterative\\": 1, \\"recursive\\": 1} ``` In implementing this function, ensure to catch any potential exceptions that may arise and provide appropriate handling mechanisms for them. Do not assume the validity of input without appropriate checks and validations. Additionally, aim to demonstrate clean coding practices and efficient computation where possible.","solution":"def factorial_comparison(n: int) -> dict: def iterative_factorial(n): result = 1 for i in range(2, n + 1): result *= i return result def recursive_factorial(n): if n == 0: return 1 else: return n * recursive_factorial(n - 1) if n < 0: raise ValueError(\\"Input must be a non-negative integer.\\") return { \\"iterative\\": iterative_factorial(n), \\"recursive\\": recursive_factorial(n) }"},{"question":"# Path Finder in a Grid You need to implement a function to find a path from the top-left corner to the bottom-right corner of an NxN grid. The grid contains obstacles, represented as 1s, and free spaces, represented as 0s. You can only move right or down through the grid. Your function should return True if there is a path from the start to the end; otherwise, False. Function Signature ```python def path_exists(grid: list[list[int]]) -> bool: pass ``` Input 1. `grid`: A list of lists of integers representing the grid, where \'0\' indicates a free space and \'1\' indicates an obstacle. Output The function should return a boolean value indicating whether a path exists from the top-left corner (0,0) to the bottom-right corner (N-1,N-1). Constraints - Grid size is between 1x1 and 20x20. - The grid will always contain integer values 0 or 1. - Both the start (grid[0][0]) and end (grid[N-1][N-1]) cells will always contain 0 (free space). Example ```python grid = [ [0, 0, 1], [1, 0, 1], [1, 0, 0] ] path_exists(grid) # Output: True ``` Doctests The following doctests should also pass: ```python def test_path_exists(): assert path_exists( [ [0, 1, 0], [0, 0, 1], [1, 0, 0] ] ) == True assert path_exists( [ [0, 1], [1, 0] ] ) == False assert path_exists( [ [0] ] ) == True assert path_exists( [ [0, 0], [0, 0] ] ) == True ``` Notes - Implement your function considering the constraints mentioned. - Make sure the function is efficient to handle the given grid size. - The function should be tested to handle various edge cases.","solution":"def path_exists(grid: list[list[int]]) -> bool: def dfs(x, y): if x >= len(grid) or y >= len(grid) or grid[x][y] == 1: return False if x == len(grid) - 1 and y == len(grid) - 1: return True grid[x][y] = 1 # mark as visited return dfs(x + 1, y) or dfs(x, y + 1) return dfs(0, 0)"},{"question":"# Coding Assessment Question **Background**: A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself. A prime pair (p1, p2) is a pair of prime numbers such that p1 and p2 differ by a fixed integer `g`. **Task**: Write a function `prime_pairs(g: int, n: int) -> List[Tuple[int, int]]` that returns all prime pairs (p1, p2) such that `p1` and `p2` both are prime and `p2 - p1 = g`, where both primes are less than or equal to `n`. # Function Signature ```python from typing import List, Tuple def prime_pairs(g: int, n: int) -> List[Tuple[int, int]]: pass ``` # Input - An integer `g` (1 ≤ g ≤ 10^6). - An integer `n` (2 ≤ n ≤ 10^6). # Output - A list of tuples representing all prime pairs (p1, p2) where `p2 - p1 = g`. # Constraints - Ensure that the function is optimized for large values of `n`. # Performance - Design the function to handle the input `10^6` efficiently. # Examples ```python >>> g = 2 >>> n = 20 >>> prime_pairs(g, n) [(3, 5), (5, 7), (11, 13), (17, 19)] >>> g = 4 >>> n = 50 >>> prime_pairs(g, n) [(3, 7), (7, 11), (13, 17), (19, 23), (37, 41), (43, 47)] >>> g = 6 >>> n = 30 >>> prime_pairs(g, n) [(5, 11), (7, 13), (11, 17), (13, 19), (17, 23), (23, 29)] ``` # Notes 1. Use the Sieve of Eratosthenes or any other efficient algorithm for prime number generation. 2. Consider edge cases where `n` might be very large. 3. Ensure tuples in the returned list are in ascending order based on the first element.","solution":"from typing import List, Tuple def sieve_of_eratosthenes(limit: int) -> List[bool]: Returns a list of boolean values where True indicates that the index is a prime number. sieve = [True] * (limit + 1) sieve[0] = sieve[1] = False for start in range(2, int(limit**0.5) + 1): if sieve[start]: for multiple in range(start*start, limit + 1, start): sieve[multiple] = False return sieve def prime_pairs(g: int, n: int) -> List[Tuple[int, int]]: Returns all prime pairs (p1, p2) such that p1 and p2 are primes and p2 - p1 = g, where both primes are less than or equal to n. primes = sieve_of_eratosthenes(n) result = [] for p1 in range(2, n - g + 1): p2 = p1 + g if primes[p1] and primes[p2]: result.append((p1, p2)) return result"},{"question":"# Coding Assessment Question **Scenario**: You are developing a library catalog system that allows users to search for books by keywords in their titles. The system should return the titles and authors of matching books, as well as their availability status. **Task**: Implement a function `search_books` that takes a keyword as input and returns a list of dictionaries each containing the book\'s title, author, and availability status. **Function Signature**: ```python def search_books(keyword: str) -> list: Searches for books containing the given keyword in their title and returns a list of dictionaries with the book title, author, and availability status. Args: keyword (str): Substring to search for in book titles. Returns: list: List of dictionaries {\'title\': str, \'author\': str, \'available\': bool}. ``` **Example**: ```python results = search_books(\\"python\\") for book in results: title = book[\'title\'] author = book[\'author\'] available = book[\'available\'] print(f\\"Title: {title}nAuthor: {author}nAvailable: {\'Yes\' if available else \'No\'}n\\") ``` **Constraints**: 1. Your function must: - Use the provided base URL `https://api.openlibrary.org/search.json`. - Determine the availability status by checking if there are lending options available. - Handle exceptions and edge cases gracefully, such as network errors or empty results. - Have a timeout of 10 seconds for HTTP requests. 2. Implement the function in an efficient manner, considering the overhead of network requests. **Performance Boundaries**: - Ensure that your function can handle up to 100 search queries per minute without significant performance degradation. **Additional Notes**: - You may use libraries like `requests` for HTTP requests and JSON handling. - Ensure your code is well-structured and commented for readability and maintainability.","solution":"import requests def search_books(keyword: str) -> list: Searches for books containing the given keyword in their title and returns a list of dictionaries with the book title, author, and availability status. Args: keyword (str): Substring to search for in book titles. Returns: list: List of dictionaries {\'title\': str, \'author\': str, \'available\': bool}. url = f\\"https://openlibrary.org/search.json\\" params = {\'title\': keyword} response = requests.get(url, params=params, timeout=10) if response.status_code != 200: return [] data = response.json() books = [] for doc in data.get(\'docs\', []): book_info = { \'title\': doc.get(\'title\', \'N/A\'), \'author\': \', \'.join(doc.get(\'author_name\', [\'N/A\'])), \'available\': bool(doc.get(\'ebook_count_i\', 0)) } books.append(book_info) return books"},{"question":"Scenario You are tasked with implementing a simplified text editor feature that tracks changes within a document. Specifically, you need to design an undo feature that can revert the last change made to the text content. Your implementation should support basic operations: typing new text at the end of the document and undoing the last change. # Question Write a class `TextEditor` that supports the following methods: 1. `type_text(text: str)`: Appends the given text to the end of the document. 2. `undo()`: Reverts the last change made to the document. 3. `get_content()`: Returns the current content of the document. # Input * `type_text(text: str)` - A string representing the text to append to the document. * `undo()` - No parameters. * `get_content()` - No parameters. # Output * For `type_text(text: str)`, there is no return value. * For `undo()`, there is no return value. * For `get_content()`, returns the current content of the document as a string. # Constraints 1. The text strings will contain only printable ASCII characters. 2. The combined length of all text operations will not exceed (10^6) characters. # Example ```python # Create an instance of TextEditor editor = TextEditor() # Type some text editor.type_text(\\"hello\\") editor.get_content() # Output: \\"hello\\" editor.type_text(\\" world\\") editor.get_content() # Output: \\"hello world\\" # Undo the last change editor.undo() editor.get_content() # Output: \\"hello\\" ``` # Notes * If `undo()` is called when there are no changes to undo, the state of the document should remain unchanged. * The class should handle edge cases such as consecutive undo operations and no text being typed initially. # Class Definition ```python class TextEditor: def __init__(self): self.content = \\"\\" self.history = [] def type_text(self, text: str): self.history.append(self.content) self.content += text def undo(self): if self.history: self.content = self.history.pop() def get_content(self) -> str: return self.content ```","solution":"class TextEditor: def __init__(self): self.content = \\"\\" self.history = [] def type_text(self, text: str): self.history.append(self.content) self.content += text def undo(self): if self.history: self.content = self.history.pop() def get_content(self) -> str: return self.content"},{"question":"# Problem Statement Implement a function `evaluate_expression(expression: str) -> int` that calculates the value of a mathematical expression provided as a string. The function should support the four basic arithmetic operations (addition, subtraction, multiplication, and division) and respect the order of operations (PEMDAS/BODMAS rules). Additionally, the function should handle parentheses for explicit prioritization of sub-expressions. # Requirements: - Correctly parse and evaluate the given arithmetic expression. - Support nested parentheses to any arbitrary depth. - Handle spaces in the input string gracefully. # Expected Input and Output: - **Input**: - `expression` (str): A string representing a mathematical expression composed of integers, the operators (+, -, *, /), and parentheses. Constraints: - The expression will be a valid mathematical expression. - The expression will not contain any variables, only integers and the permitted operators. - The length of the expression string will not exceed 1000 characters. - Division by zero will not be an issue within the input expressions. # Example Usage: ```python def evaluate_expression(expression: str) -> int: ... # Examples: evaluate_expression(\\"2 + 3 * 4\\") -> 14 evaluate_expression(\\"(1 + 2) * (3 + 4)\\") -> 21 evaluate_expression(\\"10 / 2 + 3 * (8 - 2)\\") -> 19 evaluate_expression(\\"10 + (2 * 5) / (6 - 1)\\") -> 12 evaluate_expression(\\"100 - (3 + 7) * 2\\") -> 80 ``` # Notes: - Ensure that the function handles various combinations of nested parentheses correctly. - Use efficient algorithms to parse and evaluate the string expression to optimize performance. - Make sure to validate and sanitize input as necessary to prevent potential errors. # Hints: - Consider using the Shunting Yard algorithm or a Recursive Descent Parser to handle the parsing of the arithmetic expression. - Implement a helper function to manage the evaluation of sub-expressions within parentheses.","solution":"def evaluate_expression(expression: str) -> int: Function to evaluate a mathematical expression given as a string. Supports +, -, *, / and respects parentheses and the order of operations. import re def evaluate(tokens): # This will convert the tokens into Reverse Polish Notation using the Shunting Yard algorithm def shunting_yard(tokens): precedence = {\'+\': 1, \'-\': 1, \'*\': 2, \'/\': 2} output = [] operators = [] for token in tokens: if token.isdigit(): output.append(token) elif token == \'(\': operators.append(token) elif token == \')\': while operators and operators[-1] != \'(\': output.append(operators.pop()) operators.pop() else: while (operators and operators[-1] in precedence and precedence[operators[-1]] >= precedence[token]): output.append(operators.pop()) operators.append(token) while operators: output.append(operators.pop()) return output def evaluate_rpn(rpn): stack = [] for token in rpn: if token.isdigit(): stack.append(int(token)) else: b = stack.pop() a = stack.pop() if token == \'+\': stack.append(a + b) elif token == \'-\': stack.append(a - b) elif token == \'*\': stack.append(a * b) elif token == \'/\': stack.append(int(a / b)) # Use int() to ensure integer division return stack[0] return evaluate_rpn(shunting_yard(tokens)) # Tokenize the expression by splitting on space, digit, operators, and parentheses tokens = re.findall(r\'d+|+|-|*|/|(|)\', expression.replace(\' \', \'\')) return evaluate(tokens)"},{"question":"The **Floyd-Warshall Algorithm** is a dynamic programming technique used for finding shortest paths in a weighted graph with positive or negative edge weights (but no negative cycles). Your task is to implement a function that utilizes the Floyd-Warshall algorithm to find the shortest path between all pairs of nodes in a given graph. # Problem Statement Given a graph represented by an adjacency matrix, where `graph[i][j]` represents the weight of the edge from node `i` to node `j`, your task is to calculate the shortest paths between all pairs of nodes. # Function Signature ```python def floyd_warshall(graph: List[List[int]]) -> List[List[int]]: pass ``` # Input - **graph**: `List[List[int]]` - A 2D list representing the adjacency matrix of the graph, where `graph[i][j]` is the weight of the edge from node `i` to node `j`. If there is no edge, the weight is represented as `float(\'inf\')`. The graph does not contain negative cycles. # Output - `List[List[int]]` - A 2D list where the `i`-th row and `j`-th column entry represents the length of the shortest path from node `i` to node `j`. # Constraints - The number of vertices in the graph will be within a reasonable range (e.g., 1 <= vertices <= 500). # Example ```python graph = [ [0, 3, float(\'inf\'), 5], [2, 0, float(\'inf\'), 4], [float(\'inf\'), 1, 0, float(\'inf\')], [float(\'inf\'), float(\'inf\'), 2, 0] ] print(floyd_warshall(graph)) ``` Expected Output: ``` [[0, 3, 7, 5], [2, 0, 6, 4], [3, 1, 0, 5], [5, 3, 2, 0]] ``` # Instructions 1. Initialize the distances using the input adjacency matrix. 2. Update the distances by considering all pairs of nodes, and checking if a shorter path exists through an intermediate node. 3. Implement the Floyd-Warshall algorithm to compute the shortest path between all pairs of nodes. 4. Make sure to handle edge cases such as graph containing `float(\'inf\')` to indicate no direct path between nodes. 5. Return the updated distance matrix representing the shortest path between all pairs of nodes. Good luck!","solution":"from typing import List def floyd_warshall(graph: List[List[int]]) -> List[List[int]]: Implements the Floyd-Warshall algorithm to find the shortest paths between all pairs of nodes in a given graph. :param graph: A 2D list representing the adjacency matrix of the graph, where graph[i][j] is the weight of the edge from node i to node j. If there is no edge, the weight is represented as float(\'inf\'). :return: A 2D list where the i-th row and j-th column entry represents the length of the shortest path from node i to node j. num_vertices = len(graph) # Initialize the distance matrix with the given graph distance = [row[:] for row in graph] # Floyd-Warshall algorithm for k in range(num_vertices): for i in range(num_vertices): for j in range(num_vertices): if distance[i][j] > distance[i][k] + distance[k][j]: distance[i][j] = distance[i][k] + distance[k][j] return distance"},{"question":"# Coding Assessment Question Context You are building a library management system where we need to maintain a record of books and track their availability status for lending. A significant aspect of the system involves a function that can check whether a specific book is available and update the status as needed. Task Implement a class `Library` that simulates a basic library management system. The class should include methods to add books, lend a book to a user, and return a book back to the library. Implementation * Your class should have the following methods: - `add_book(book_name: str) -> None`: Adds a new book to the library. - `lend_book(book_name: str) -> bool`: Lends a book to a user if it is available and returns `True`. If the book is not available, return `False`. - `return_book(book_name: str) -> None`: Returns a lent book back to the library. * Ensure that: - A book can only be lent out if it exists in the library and is not already lent out. - Returning a book that isn\'t lent out has no effect. - The library can contain multiple books, but each book is tracked individually regarding its availability. Constraints - Book names are unique strings of length between 1 and 100 characters. - The number of books the library can store will not exceed 1000. - All methods should perform their operations in O(1) average time complexity. Example ```python class Library: def add_book(self, book_name: str) -> None: # Your implementation here def lend_book(self, book_name: str) -> bool: # Your implementation here def return_book(self, book_name: str) -> None: # Your implementation here # Example usage: library = Library() library.add_book(\\"The Great Gatsby\\") print(library.lend_book(\\"The Great Gatsby\\")) # Output: True print(library.lend_book(\\"The Great Gatsby\\")) # Output: False library.return_book(\\"The Great Gatsby\\") print(library.lend_book(\\"The Great Gatsby\\")) # Output: True ``` The submitted code will be evaluated for correctness, efficiency, and adherence to problem constraints.","solution":"class Library: def __init__(self): self.books = {} def add_book(self, book_name: str) -> None: # Add the book to the library if it doesn\'t already exist if book_name not in self.books: self.books[book_name] = True # True indicates the book is available def lend_book(self, book_name: str) -> bool: if book_name in self.books and self.books[book_name]: self.books[book_name] = False # Mark the book as lent out return True return False # Book is either not present or already lent out def return_book(self, book_name: str) -> None: if book_name in self.books and not self.books[book_name]: self.books[book_name] = True # Mark the book as available again"},{"question":"# Coding Question Context As part of a project management tool, you are developing a feature to analyze work logs and ensure project milestones are being achieved on schedule. A critical component of this tool is the ability to parse and interpret work logs to calculate the total hours worked by each team member over a given period. Problem Given a list of work logs, each formatted as a string with the team member\'s name, the date, and the number of hours worked, implement a function that calculates the total hours worked by each team member over the course of the entire provided log list. Requirements 1. Parse the list of logs to extract the relevant information (team member\'s name, date, and hours worked). 2. Accumulate the total hours worked for each team member. 3. Return the results as a dictionary where the keys are the team members\' names and the values are the total hours worked. Function Signature ```python def calculate_work_hours(logs: list[str]) -> dict[str, float]: Calculates the total hours worked by each team member based on provided work logs. :param logs: List of work log entries as strings. :return: Dictionary mapping team members\' names to total hours worked. Examples: >>> calculate_work_hours([\\"Alice,2023-01-01,5\\", \\"Bob,2023-01-01,3\\", \\"Alice,2023-01-02,4\\"]) {\'Alice\': 9.0, \'Bob\': 3.0} >>> calculate_work_hours([]) {} >>> calculate_work_hours([\\"Chris,2023-01-01,8\\", \\"Chris,2023-01-02,7.5\\", \\"Chris,2023-01-03,6.25\\"]) {\'Chris\': 21.75} >>> calculate_work_hours([\\"Dana,2023-01-01,7\\", \\"Eve,2023-01-01,8\\", \\"Dana,2023-01-02,6\\", \\"Eve,2023-01-02,5\\"]) {\'Dana\': 13.0, \'Eve\': 13.0} ``` Constraints 1. You may assume that each log entry is formatted correctly as `\\"Name,yyyy-mm-dd,hours\\"` where `Name` is a string, `yyyy-mm-dd` is a date string, and `hours` is a floating-point number representing hours worked. 2. Handle various date formats and ensure that the log entries are parsed correctly. 3. Consider edge cases such as empty logs and logs with names not previously encountered. Input/Output Format * **Input**: A list of work log entries as strings. * **Output**: A dictionary mapping team members\' names to total hours worked. Examples 1. `calculate_work_hours([\\"Anna,2023-01-10,3\\", \\"Martin,2023-01-10,4\\", \\"Anna,2023-01-11,5\\"])` should return `{\'Anna\': 8.0, \'Martin\': 4.0}`. 2. `calculate_work_hours([\\"Mike,2023-02-01,7.5\\", \\"Jane,2023-02-01,6.25\\", \\"Mike,2023-02-02,4.75\\"])` should return `{\'Mike\': 12.25, \'Jane\': 6.25}`. Notes 1. Write comprehensive tests to ensure your implementation is correct and handles different scenarios. 2. Carefully consider edge cases such as empty input and ensure your function handles them gracefully.","solution":"def calculate_work_hours(logs: list[str]) -> dict[str, float]: Calculates the total hours worked by each team member based on the provided work logs. :param logs: List of work log entries as strings. :return: Dictionary mapping team members\' names to total hours worked. work_hours = {} for log in logs: name, date, hours = log.split(\',\') hours = float(hours) if name in work_hours: work_hours[name] += hours else: work_hours[name] = hours return work_hours"},{"question":"# Problem Statement You are tasked with developing a system to process a list of bank transactions to calculate an account\'s final balance. Implement two functions, `apply_transactions` and `calculate_balance`, that handle the respective tasks. Task 1: `apply_transactions(transactions: List[Tuple[str, float]], initial_balance: float) -> List[float]` - **Input**: - `transactions`: A list of tuples where each tuple consists of a transaction type (\\"deposit\\" or \\"withdraw\\") and a transaction amount (float). - `initial_balance`: A float representing the starting balance of the account. - **Output**: - Returns a list of balances after each transaction is applied. Task 2: `calculate_balance(transactions: List[Tuple[str, float]], initial_balance: float) -> float` - **Input**: - `transactions`: A list of tuples where each tuple consists of a transaction type (\\"deposit\\" or \\"withdraw\\") and a transaction amount (float). - `initial_balance`: A float representing the starting balance of the account. - **Output**: - Returns the final account balance after all transactions have been applied. Requirements and Constraints 1. **Assumptions**: - The transaction type will always be a valid string (\\"deposit\\" or \\"withdraw\\"). - The transaction amounts and initial balance are non-negative floats. 2. **Constraints**: - The list of transactions will not exceed 10000 items. - The resulting balance should not go negative; any withdrawal that would result in a negative balance should be ignored. Implementation Details - Handle edge cases such as empty transaction lists and invalid input gracefully. - Ensure your functions validate input parameters before processing. - Optimize for performance with large transaction lists. # Example ```python def apply_transactions(transactions: List[Tuple[str, float]], initial_balance: float) -> List[float]: # implementation here def calculate_balance(transactions: List[Tuple[str, float]], initial_balance: float) -> float: # implementation here # Example usage: transactions = [(\\"deposit\\", 100.0), (\\"withdraw\\", 50.0), (\\"withdraw\\", 10.0)] initial_balance = 50.0 balances = apply_transactions(transactions, initial_balance) # Expected output for balances: [150.0, 100.0, 90.0] final_balance = calculate_balance(transactions, initial_balance) # Expected output for final balance: 90.0 ``` Note: - Your solution should produce deterministic results. - Include test cases in your code to demonstrate the functionality.","solution":"from typing import List, Tuple def apply_transactions(transactions: List[Tuple[str, float]], initial_balance: float) -> List[float]: balances = [] current_balance = initial_balance for transaction in transactions: transaction_type, amount = transaction if transaction_type == \\"deposit\\": current_balance += amount elif transaction_type == \\"withdraw\\": if current_balance >= amount: current_balance -= amount balances.append(current_balance) return balances def calculate_balance(transactions: List[Tuple[str, float]], initial_balance: float) -> float: current_balance = initial_balance for transaction in transactions: transaction_type, amount = transaction if transaction_type == \\"deposit\\": current_balance += amount elif transaction_type == \\"withdraw\\": if current_balance >= amount: current_balance -= amount return current_balance"},{"question":"# Dynamic String Decompression Context You have been provided with a compressed string and you are asked to decompress it. The compression format includes numbers followed by a sequence of characters they should replicate. Numbers can be multiple digits and the sequence of characters can include nested sequences. Task Implement a function `decompress_string(compressed: str) -> str` that decompresses the given string according to the specified rules. Compression Rules 1. Numbers represent how many times the immediately following sequence of characters should be repeated. 2. The sequence of characters can include nested sequences like \\"2[2[ab]c]\\". Input Specifications - `compressed` (str): A string representing the compressed form. Output Specifications - (str): The decompressed string. Constraints - The compressed string will only contain alphanumeric characters and the special characters `[`, `]`. - The length of the uncompressed string will not exceed 100,000 characters. - The depth of nested sequences will not exceed 50 levels. Example ```python compressed = \\"3[a2[c]]\\" decompress_string(compressed) ``` Output: ```python \\"accaccacc\\" ``` # Implementation Implement the function `decompress_string` using the template below: ```python def decompress_string(compressed: str) -> str: stack = [] current_num = 0 current_string = \'\' for char in compressed: if char.isdigit(): current_num = current_num * 10 + int(char) elif char == \'[\': stack.append((current_string, current_num)) current_string = \'\' current_num = 0 elif char == \']\': prev_string, num = stack.pop() current_string = prev_string + num * current_string else: current_string += char return current_string # Example usage: # compressed = \\"3[a2[c]]\\" # print(decompress_string(compressed)) # Output: \\"accaccacc\\" ```","solution":"def decompress_string(compressed: str) -> str: stack = [] current_num = 0 current_string = \'\' for char in compressed: if char.isdigit(): current_num = current_num * 10 + int(char) elif char == \'[\': stack.append((current_string, current_num)) current_string = \'\' current_num = 0 elif char == \']\': prev_string, num = stack.pop() current_string = prev_string + num * current_string else: current_string += char return current_string"},{"question":"# Problem Statement Write a function `rolling_average` that takes a list of integers and a window size `k`, and returns a list of the rolling averages for each consecutive sublist of length `k`. The rolling average for a sublist is defined as the sum of the elements in the sublist divided by `k`. # Input * A list of integers `nums`, where all integers are between -10^3 and 10^3. * An integer `k`, where 1 <= k <= len(nums). # Output * A list of floating-point numbers representing the rolling averages of all consecutive sublists of length `k` in `nums`. # Constraints * Raise a `ValueError` if `k` is not a positive integer or if `k` is greater than the length of `nums`. # Performance Requirements * Ensure the function operates efficiently, especially for larger input sizes where len(nums) can be up to 10^5. # Example ```python rolling_average([1, 2, 3, 4, 5], 3) # Returns [2.0, 3.0, 4.0] rolling_average([10, 20, 10, 40, 50], 2) # Returns [15.0, 15.0, 25.0, 45.0] rolling_average([-1, -2, -3, -4, -5], 2) # Returns [-1.5, -2.5, -3.5, -4.5] rolling_average([1], 1) # Returns [1.0] rolling_average([1, 2, 3, 4, 5], 5) # Returns [3.0] ``` # Hints * Consider using a sliding window technique to keep track of the sum of the elements in the current window, updating it efficiently as you move the window across the list.","solution":"def rolling_average(nums, k): Returns a list of rolling averages for each consecutive sublist of length k in nums. Parameters: nums (list of int): The list of integers. k (int): The window size for calculating the rolling average. Returns: list of float: List of rolling averages. Raises: ValueError: If k is not a positive integer or if k is greater than the length of nums. if not isinstance(k, int) or k <= 0 or k > len(nums): raise ValueError(\\"k must be a positive integer and less than or equal to the length of nums\\") result = [] window_sum = sum(nums[:k]) result.append(window_sum / k) for i in range(1, len(nums) - k + 1): window_sum = window_sum - nums[i - 1] + nums[i + k - 1] result.append(window_sum / k) return result"},{"question":"# Graph Traversal with Cost and Discount You are to implement a graph traversal algorithm that finds the shortest path from a start node to a goal node in a weighted, directed graph. Additionally, for edges traversed an even number of times, a discount is applied to the edge cost. # Problem Given a graph represented as an adjacency list where each edge has a cost, the task is to find the shortest path from a start node to a goal node, taking into account a discount applied to the cost of edges that are traversed an even number of times. # Function Signature ```python def find_shortest_path( graph: dict[int, list[tuple[int, int]]], start: int, goal: int, discount: float ) -> list[int]: ``` # Input * `graph` (`dict[int, list[tuple[int, int]]`): A dictionary representing the adjacency list of the graph where the keys are nodes and the values are lists of tuples, each containing a neighbor and the associated edge cost. * `start` (`int`): The starting node. * `goal` (`int`): The target node. * `discount` (`float`): The discount applied to the cost of edges traversed an even number of times. # Output * Returns a list of nodes representing the shortest path from the start node to the goal node considering the discount. # Constraints * The graph has no negative edge weights. * Graph has at least one node and a valid path from start to goal. * Discount is a non-negative float value less than 1. # Example ```python graph = { 0: [(1, 4), (2, 1)], 1: [(3, 1)], 2: [(1, 2), (3, 5)], 3: [] } start = 0 goal = 3 discount = 0.5 path = find_shortest_path(graph, start, goal, discount) print(path) ``` # Notes 1. Use a priority queue to implement the traversal. 2. Ensure the path returned is optimal considering the edge cost discount. 3. An edge cost is halved only when it has been traversed an even number of times. # Solution Approach 1. Utilize a modified Dijkstra\'s algorithm with an additional dictionary to manage discounted edges. 2. Track edge traversals to apply discounts appropriately. 3. Ensure each possible path is evaluated considering discount application to determine the optimal shortest path.","solution":"import heapq def find_shortest_path(graph, start, goal, discount): Finds the shortest path from start to goal in a graph with discounted edge costs for edges traversed an even number of times. # Priority queue pq = [(0, start, [])] # (total_cost, current_node, path) # Distances dictionary dist = {start: 0} # Keep track of edges traversed traversed_edges_count = {start: {}} while pq: curr_dist, curr_node, path = heapq.heappop(pq) # If we reach the goal if curr_node == goal: return path + [goal] for neighbor, cost in graph.get(curr_node, []): # Compute the times the edge is traversed edge_count = traversed_edges_count[curr_node].get(neighbor, 0) if edge_count % 2 == 1: discounted_cost = cost * discount else: discounted_cost = cost new_dist = curr_dist + discounted_cost if new_dist < dist.get(neighbor, float(\'inf\')): dist[neighbor] = new_dist heapq.heappush(pq, (new_dist, neighbor, path + [curr_node])) # Update the edge count if neighbor not in traversed_edges_count: traversed_edges_count[neighbor] = {} traversed_edges_count[neighbor][curr_node] = edge_count + 1 traversed_edges_count[curr_node][neighbor] = edge_count + 1 return [] # Example usage graph = { 0: [(1, 4), (2, 1)], 1: [(3, 1)], 2: [(1, 2), (3, 5)], 3: [] } start = 0 goal = 3 discount = 0.5 path = find_shortest_path(graph, start, goal, discount) print(path) # Output should be an optimal path from start to goal"},{"question":"**Least Common Multiple (LCM) Calculation with Queries** **Objective**: Develop a function to find the Least Common Multiple (LCM) of two integers, and extend the functionality to handle multiple queries, each consisting of a pair of integers. **Problem Statement**: Write a function `batch_lcm(queries: list) -> list` that performs the following tasks: 1. Computes the LCM of pairs of integers provided in the query list. 2. Returns the LCM result for each query in the given order. **Function Signature**: ```python def batch_lcm(queries: list) -> list: pass ``` **Input**: * `queries` (list of tuples, 1 ≤ len(queries) ≤ 10^5): List of tuples, where each tuple `(a, b)` contains two integers (1 ≤ a, b ≤ 10^6) whose LCM needs to be calculated. **Output**: * List of integers where the `i-th` element is the LCM of the integers in `queries[i]`. **Constraints**: * Efficiently calculate the LCM for each pair of integers. * Minimize the computational overhead for larger inputs. **Example**: ```python queries = [(1, 2), (3, 5), (10, 15), (7, 21)] result = batch_lcm(queries) print(result) # Expected result should be [2, 15, 30, 21] ``` **Explanation**: For the given `queries`, the LCM calculations should yield: * LCM(1, 2) = 2 * LCM(3, 5) = 15 * LCM(10, 15) = 30 * LCM(7, 21) = 21 These results should be returned in the matching order within the query list. The LCM of two numbers, `a` and `b`, can be calculated using the formula: [ text{LCM}(a, b) = frac{|a times b|}{text{GCD}(a, b)} ] where GCD is the Greatest Common Divisor. The `math` module in Python provides the `gcd` function which can be utilized for this calculation. Here\'s an example implementation outline: ```python import math def batch_lcm(queries): result = [] for a, b in queries: lcm = abs(a * b) // math.gcd(a, b) result.append(lcm) return result queries = [(1, 2), (3, 5), (10, 15), (7, 21)] result = batch_lcm(queries) print(result) # Expected result should be [2, 15, 30, 21] ```","solution":"import math def batch_lcm(queries): Computes the LCM for each pair of integers in the queries list. :param queries: List of tuples where each tuple consists of two integers. :return: List of LCM results for each query. def lcm(a, b): return abs(a * b) // math.gcd(a, b) return [lcm(a, b) for a, b in queries]"},{"question":"# Scenario You are developing a game where players navigate a 2D grid. Each cell in the grid can either be empty or contain an obstacle. Players can move up, down, left, or right, but cannot pass through obstacles. You need to implement a function that determines the shortest path from a starting position to a target position while avoiding obstacles. # Task Given a 2D grid, a starting position, and a target position, implement the `find_shortest_path` function that returns the shortest path length. If there is no valid path, return -1. # Function Signature ```python def find_shortest_path(grid: List[List[int]], start: Tuple[int, int], target: Tuple[int, int]) -> int: pass ``` # Input - `grid`: A 2D list of integers where \'0\' represents an empty cell and \'1\' represents an obstacle. - `start`: A tuple (`x1`, `y1`) representing the starting position. - `target`: A tuple (`x2`, `y2`) representing the target position. # Output - Returns an integer representing the length of the shortest path from start to target. If no path exists, return -1. # Constraints - The dimensions of `grid` will be between 1x1 and 1000x1000. - Both `start` and `target` will be valid positions within the grid. - Both `start` and `target` will refer to empty cells (grid value = 0). - There will not be more than 10 obstacles in the grid. # Example ```python grid = [ [0, 0, 0, 1, 0], [0, 1, 0, 1, 0], [0, 1, 0, 0, 0], [0, 0, 0, 1, 0], [1, 1, 0, 0, 0] ] start = (0, 0) target = (4, 4) result = find_shortest_path(grid, start, target) # The function should return 8 since the shortest path is: # (0,0) -> (1,0) -> (2,0) -> (2,1) -> (2,2) -> (2,3) -> (3,3) -> (4,3) -> (4,4) ``` # Notes - Consider using breadth-first search (BFS) for finding the shortest path in an unweighted grid. - Ensure the function handles edge cases such as grids with no obstacles or all obstacles. - Validate the performance for large grids and multiple paths to ensure efficiency.","solution":"from collections import deque from typing import List, Tuple def find_shortest_path(grid: List[List[int]], start: Tuple[int, int], target: Tuple[int, int]) -> int: if start == target: return 0 rows, cols = len(grid), len(grid[0]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(start[0], start[1], 0)]) visited = set() visited.add(start) while queue: x, y, dist = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and (nx, ny) not in visited and grid[nx][ny] == 0: if (nx, ny) == target: return dist + 1 queue.append((nx, ny, dist + 1)) visited.add((nx, ny)) return -1"},{"question":"# Problem Scenario You are collaborating with a cybersecurity firm specializing in encryption and decryption technologies. Your task is to develop an algorithm that analyzes a given string to find the longest substring which forms a palindromic permutation. A palindromic permutation is a string that can be rearranged to form a palindrome. # Problem Statement Write a function `longest_palindromic_permutation(s: str) -> str` that takes a string `s` and returns the longest substring which can be permuted to form a palindrome. If there are multiple such substrings of the same length, return the first one found. If no such palindromic substring exists, return an empty string. # Input * `s` (0 ≤ `len(s)` ≤ (10^4)) - The input string consisting of ASCII characters. # Output * `str` - The longest substring that can be permuted to form a palindrome. # Example ```python assert longest_palindromic_permutation(\\"abacab\\") == \\"bacab\\" or longest_palindromic_permutation(\\"abacab\\") == \\"ababa\\" assert longest_palindromic_permutation(\\"abcd\\") == \\"a\\" or longest_palindromic_permutation(\\"abcd\\") == \\"b\\" or longest_palindromic_permutation(\\"abcd\\") == \\"c\\" or longest_palindromic_permutation(\\"abcd\\") == \\"d\\" ``` # Explanation * In the first example, \\"bacab\\" and \\"ababa\\" are both the longest substrings that can form a palindrome. * In the second example, each character is its own longest palindromic permutation since all characters are distinct. # Constraints * Ensure the function handles edge cases, such as an empty string or a very long input string. * Optimize the function to efficiently handle the maximum input length. # Function Signature ```python def longest_palindromic_permutation(s: str) -> str: pass ```","solution":"def can_form_palindrome(s: str) -> bool: from collections import Counter counts = Counter(s) odd_count = sum(1 for count in counts.values() if count % 2 != 0) return odd_count <= 1 def longest_palindromic_permutation(s: str) -> str: n = len(s) if n == 0: return \\"\\" max_len = 0 longest_substr = \\"\\" for i in range(n): for j in range(i, n): substring = s[i:j+1] if can_form_palindrome(substring): if j - i + 1 > max_len: max_len = j - i + 1 longest_substr = substring return longest_substr"},{"question":"# Scenario: You are working on a social media application where users can create short posts called \\"blips\\". Each blip can mention other users using the \\"@\\" symbol followed by the user’s username. Your task is to detect and extract all mentioned usernames from a given blip to notify the mentioned users. # Task: Implement a Python function `extract_usernames(blip: str) -> List[str]` that takes a blip string as input and returns a list of mentioned usernames in the order they appear. Usernames consist of alphanumeric characters and underscores and are case sensitive. # Function Specification: Input: - A single string `blip` representing the content of the blip. Output: - A list of strings, where each string is a username mentioned in the blip. Constraints: - Usernames can only contain alphanumeric characters and underscores. - The function should handle edge cases like blips with no mentions, consecutive mentions, and usernames at different positions within the blip. - The function should have a linear time complexity in terms of the length of the blip. # Example: ```python # Example usage blip = \\"Hello @john_doe, how are you? Have you seen @janedoe\'s post?\\" mentions = extract_usernames(blip) print(mentions) ``` Expected Output: ```python [\'john_doe\', \'janedoe\'] ```","solution":"import re from typing import List def extract_usernames(blip: str) -> List[str]: Extracts and returns a list of mentioned usernames in the order they appear in the blip. Usernames consist of alphanumeric characters and underscores. # Using regex to find all mentions starting with \\"@\\" followed by alphanumeric characters and underscores usernames = re.findall(r\'@(w+)\', blip) return usernames"},{"question":"# Question: Build a Custom HashMap with Automatic Resizing Context A HashMap (or hashmap) is a data structure that implements an associative array abstract data type, a structure that can map keys to values. This question requires you to implement a HashMap with automatic resizing to ensure efficient look-up times as the map grows. Task 1. Implement a class `CustomHashMap` that supports the following operations: `put`, `get`, and `remove`. 2. Implement automatic resizing when the load factor exceeds 0.7 to maintain efficient operations. 3. The internal bucket array should initially have a size of 8, and it should double in size each time the load factor threshold is exceeded. Class Signature ```python class CustomHashMap: def __init__(self): pass def put(self, key: int, value: int) -> None: pass def get(self, key: int) -> Optional[int]: pass def remove(self, key: int) -> None: pass ``` Methods and Parameters * `__init__(self)`: Initializes the HashMap. * `put(self, key: int, value: int) -> None`: Inserts the key-value pair into the HashMap. If the key already exists, it updates the value. * `get(self, key: int) -> Optional[int]`: Returns the value to which the specified key is mapped, or `None` if the key is not present. * `remove(self, key: int) -> None`: Removes the mapping for the specified key if it exists. Constraints * The keys and values are integers. * All function calls within `put`, `get`, and `remove` must be `O(1)` on average. Example ```python >>> cmap = CustomHashMap() >>> cmap.put(1, 1) >>> cmap.put(2, 2) >>> cmap.get(1) 1 >>> cmap.get(3) None >>> cmap.put(2, 1) >>> cmap.get(2) 1 >>> cmap.remove(2) >>> cmap.get(2) None ``` Notes * Ensure that the `put` operation handles collisions using chaining or open addressing. * The load factor is defined as the number of elements in the HashMap divided by the size of the bucket array. * Implement detailed handling of resize operations to maintain efficiency. * Include comprehensive tests to validate your `CustomHashMap` implementation, ensuring it works correctly with multiple inserts, updates, deletions, and look-ups.","solution":"class CustomHashMap: def __init__(self): self.initial_size = 8 self.load_factor_threshold = 0.7 self.buckets = [[] for _ in range(self.initial_size)] self.size = 0 def _hash(self, key): return key % len(self.buckets) def _resize(self): new_buckets = [[] for _ in range(len(self.buckets) * 2)] for bucket in self.buckets: for key, value in bucket: index = key % len(new_buckets) new_buckets[index].append((key, value)) self.buckets = new_buckets def put(self, key: int, value: int) -> None: if self.size / len(self.buckets) > self.load_factor_threshold: self._resize() index = self._hash(key) bucket = self.buckets[index] for i, (k, v) in enumerate(bucket): if k == key: bucket[i] = (key, value) return bucket.append((key, value)) self.size += 1 def get(self, key: int): index = self._hash(key) bucket = self.buckets[index] for k, v in bucket: if k == key: return v return None def remove(self, key: int) -> None: index = self._hash(key) bucket = self.buckets[index] for i, (k, v) in enumerate(bucket): if k == key: del bucket[i] self.size -= 1 return"},{"question":"**Scenario**: You have been tasked to create a navigation system for a Mars rover. The rover needs to follow a sequence of commands to navigate the Martian terrain. Each command can move the rover in cardinal directions (north, south, east, west) or instruct it to pick up or drop an item at its current location. **Problem**: Implement a function `rover_navigation` that calculates the final position of the rover and the items it picked up, given a starting position and a sequence of commands. # Function Signature: ```python def rover_navigation(start: tuple[int, int], commands: list[str]) -> dict: Parameters: start (tuple[int, int]): Initial position of the rover as (x, y) coordinates. commands (list[str]): List of commands for the rover. Each command is a string. Returns: dict: A dictionary with two keys: - \'position\': The final position of the rover as (x, y) coordinates. - \'items\': A list of items the rover has picked up. ``` # Inputs: * `start`: The initial position of the rover as (x, y) coordinates. * `commands`: A list of commands where each is a string indicating an action: - \\"N\\": Move north (increase y by 1). - \\"S\\": Move south (decrease y by 1). - \\"E\\": Move east (increase x by 1). - \\"W\\": Move west (decrease x by 1). - \\"P <item>\\": Pick up an item at the current location. - \\"D <item>\\": Drop an item at the current location. # Outputs: * Return a dictionary with: - \'position\': The final position of the rover as an (x, y) coordinate tuple. - \'items\': A list of items the rover has picked up. # Constraints: * `-1,000 ≤ x, y ≤ 1,000` (initial coordinates and final coordinates after moves). * The list of commands will not exceed 1,000. # Example: ```python assert rover_navigation((0, 0), [\\"N\\", \\"E\\", \\"E\\", \\"P rock\\", \\"S\\", \\"W\\", \\"N\\", \\"D rock\\", \\"E\\"]) == {\'position\': (1, 1), \'items\': []} assert rover_navigation((5, 5), [\\"N\\", \\"N\\", \\"P sample\\", \\"W\\", \\"S\\", \\"D sample\\", \\"E\\", \\"S\\"]) == {\'position\': (5, 5), \'items\': []} assert rover_navigation((2, 3), [\\"P tool\\", \\"E\\", \\"E\\", \\"N\\", \\"P part\\", \\"W\\", \\"W\\", \\"S\\"]) == {\'position\': (2, 3), \'items\': [\\"tool\\", \\"part\\"]} ``` Hint: Use dictionaries to manage items when picked up and dropped, and update positions based on directions. Consider splitting the \\"P\\" and \\"D\\" commands to handle items properly.","solution":"def rover_navigation(start, commands): Calculates the final position of the rover and the items it picked up, given a starting position and a sequence of commands. Parameters: - start (tuple[int, int]): Initial position of the rover as (x, y) coordinates. - commands (list[str]): List of commands for the rover. Each command is a string. Returns: - dict: A dictionary with two keys: - \'position\': The final position of the rover as (x, y) coordinates. - \'items\': A list of items the rover has picked up. x, y = start items = [] for command in commands: if command == \'N\': y += 1 elif command == \'S\': y -= 1 elif command == \'E\': x += 1 elif command == \'W\': x -= 1 elif command.startswith(\'P \'): item = command[2:] items.append(item) elif command.startswith(\'D \'): item = command[2:] if item in items: items.remove(item) return {\'position\': (x, y), \'items\': items}"},{"question":"Coding Assessment Question # Longest Path in a Binary Tree Scenario: A binary tree is a structure where each node has at most two children referred to as the left child and the right child. You need to determine the longest path between any two nodes in the tree. The path may include or exclude the root node. Task: Write a function `longest_path(root: TreeNode) -> int` that takes the root of the binary tree and returns the length of the longest path between any two nodes in the tree. The length is defined as the number of edges in this path. Function Signature: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def longest_path(root: TreeNode) -> int: pass ``` Input: * `root`: A TreeNode representing the root of the binary tree. Output: * Returns an integer representing the length of the longest path in the tree. Constraints: * The number of nodes in the tree is in the range `[0, 10^4]`. * The value of each node is an integer within the range `[-10^5, 10^5]`. Example Usage: * Example 1: ```python # Tree diagram: # 1 # / # 2 3 # / # 4 5 root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) longest_path(root) # Output: 3 ``` * Example 2: ```python # Tree diagram: # 1 # / # 2 root = TreeNode(1) root.left = TreeNode(2) longest_path(root) # Output: 1 ``` * Example 3: ```python # Tree diagram is empty root = None longest_path(root) # Output: 0 ``` # Instructions: 1. Implement the function `longest_path` as described. 2. Ensure your solution handles edge cases such as an empty tree or a tree with only one node. 3. Aim for O(n) time complexity where n is the number of nodes in the tree. 4. Thoroughly test your implementation against various scenarios to ensure correctness.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def longest_path(root: TreeNode) -> int: Returns the length of the longest path in the binary tree. def diameter_and_height(node): if not node: return 0, -1 left_diameter, left_height = diameter_and_height(node.left) right_diameter, right_height = diameter_and_height(node.right) current_height = max(left_height, right_height) + 1 current_diameter = max(left_diameter, right_diameter, left_height + right_height + 2) return current_diameter, current_height diameter, _ = diameter_and_height(root) return diameter"},{"question":"# Multi-Stage Encryption Key Generator You have been tasked with designing a multi-stage encryption key generator for a confidential data storage system. The generator must securely produce encryption keys based on a series of transformations and randomization steps. **Requirements**: 1. Implement a function to initialize and reset the key generator\'s state. 2. Implement a function that sets an initial seed for all subsequent generating operations. 3. Implement a function to apply multiple transformation steps to the current state to derive the final encryption key. 4. Ensure the generator can be reset at any point to a clean initial state. # Objectives: - **Function**: `initialize_generator(n: int, stages: List[int])` - **Input**: - `n`: Integer, length of the initial state vector. - `stages`: List of integers representing the number of transformation steps for each stage. - **Output**: Initializes or resets the generator state. - **Function**: `set_seed(seed: int)` - **Input**: - `seed`: Integer to initialize the state vector. - **Output**: Sets the initial state using the provided seed. - **Function**: `generate_key() -> List[int]` - **Input**: None - **Output**: Returns a list of integers representing the final encryption key after all transformation stages. - **Function**: `reset_generator()` - **Input**: None - **Output**: Resets the generator state to initial parameters. Constraints: - The initial state vector `n` should be based on non-negative integers. - Transformation stages should manipulate the state vector through a combination of bitwise operations and modular arithmetic. - Ensure the final generated key is within the bounds of 32-bit unsigned integers. - Efficient handling of multiple stages to avoid performance bottlenecks. # Example Scenario: 1. Initialize the generator using: ```python initialize_generator(5, [2, 3, 5]) ``` 2. Set an initial seed for the key generation process. ```python set_seed(12345) ``` 3. Generate an encryption key based on the state transformations. ```python key = generate_key() ``` 4. Print the generated encryption key to validate the implementation. 5. Reset the generator state and verify the initial conditions. # Guidelines: - Comment on potential edge cases and ensure the functions are robust against varied inputs. - Test the system for different lengths of the initial state vector and numbers of transformation stages. - Consider optimization strategies to handle large transformation stages efficiently. Are you ready to generate the most secure encryption keys for the future of digital confidentiality?","solution":"import random class MultiStageEncryptionKeyGenerator: def __init__(self): self.initial_state = [] self.stages = [] self.current_state = [] def initialize_generator(self, n: int, stages: list): Initializes or resets the generator state. :param n: Length of the initial state vector. :param stages: List of integers representing the number of transformation steps for each stage. self.initial_state = [0] * n self.stages = stages self.current_state = self.initial_state.copy() def set_seed(self, seed: int): Sets the initial state using the provided seed. :param seed: Integer to initialize the state vector. random.seed(seed) self.initial_state = [random.randint(0, 2**32 - 1) for _ in range(len(self.initial_state))] self.current_state = self.initial_state.copy() def transform_stage(self, state: list, steps: int) -> list: Apply transformation steps to the state. :param state: Current state vector. :param steps: Number of transformation steps. :return: New transformed state vector. new_state = state.copy() for _ in range(steps): new_state = [(x * 1103515245 + 12345) % (2**32) for x in new_state] new_state = [((x >> 16) ^ x) & 0xFFFFFFFF for x in new_state] return new_state def generate_key(self) -> list: Returns a list of integers representing the final encryption key after all transformation stages. :return: List of integers as the final encryption key. for stage_steps in self.stages: self.current_state = self.transform_stage(self.current_state, stage_steps) return self.current_state def reset_generator(self): Resets the generator state to initial parameters. self.current_state = self.initial_state.copy() # Wrapper functions generator = MultiStageEncryptionKeyGenerator() def initialize_generator(n: int, stages: list): generator.initialize_generator(n, stages) def set_seed(seed: int): generator.set_seed(seed) def generate_key() -> list: return generator.generate_key() def reset_generator(): generator.reset_generator()"},{"question":"# Prompt You are asked to determine the smallest window in a string that contains all the distinct characters of a given pattern at least once. # Requirements * Implement the function `smallest_window(s: str, pattern: str) -> str` that returns the smallest substring of `s` that contains all characters from `pattern`. # Input * `s`: A string (1 ≤ len(s) ≤ 10^5). * `pattern`: A string (1 ≤ len(pattern) ≤ 10^5). # Output * A string representing the smallest window in `s` that contains all characters from `pattern`. If no such window exists, return an empty string `\\"\\"`. # Constraints * Both `s` and `pattern` will contain only lowercase English letters. * Ensure the solution is optimized for time complexity. # Example ```python assert smallest_window(\\"thisisateststring\\", \\"tist\\") == \\"tstri\\" assert smallest_window(\\"geeksforgeeks\\", \\"ork\\") == \\"ksfor\\" assert smallest_window(\\"abcdef\\", \\"xyz\\") == \\"\\" ``` # Performance Requirements * The implementation should ideally run in linear time, O(n + m), where `n` is the length of `s` and `m` is the length of `pattern`. # Notes * Use an efficient sliding window technique to minimize the window size. * Consider edge cases such as characters in `pattern` not being present in `s` or very small input sizes.","solution":"from collections import Counter, defaultdict def smallest_window(s: str, pattern: str) -> str: Returns the smallest substring of s that contains all characters from pattern. if not s or not pattern: return \\"\\" pattern_count = Counter(pattern) s_count = defaultdict(int) required = len(pattern_count) formed = 0 l, r = 0, 0 min_len = float(\'inf\') start_idx = 0 while r < len(s): char = s[r] s_count[char] += 1 if char in pattern_count and s_count[char] == pattern_count[char]: formed += 1 while l <= r and formed == required: char = s[l] if r - l + 1 < min_len: min_len = r - l + 1 start_idx = l s_count[char] -= 1 if char in pattern_count and s_count[char] < pattern_count[char]: formed -= 1 l += 1 r += 1 if min_len == float(\'inf\'): return \\"\\" return s[start_idx:start_idx + min_len]"},{"question":"# Question: Implement a Scheduler for Task Execution Based on Dependencies You are required to implement a Python class that schedules a set of tasks based on their dependencies. Each task is represented by a unique integer identifier and may depend on the completion of one or more other tasks. The scheduler should determine an order of execution such that all dependencies are respected. Requirements: 1. Implement a class named `TaskScheduler`. 2. Add a method `add_task(task_id: int, dependencies: List[int])` which adds a task along with its dependencies to the scheduler. 3. Implement a method `get_execution_order() -> List[int]` that returns a list of task IDs in the order they should be executed to respect dependencies. 4. If a circular dependency is detected, raise a `ValueError` with an appropriate message. 5. Ensure efficiency in terms of both time and space by optimizing your solution. Input: * Task IDs will be unique integers. * Dependencies will be represented as a list of integers. Output: * A list of integers representing the task IDs in the correct execution order. Constraints: * Task IDs will be non-negative integers. * The scheduler should handle various combinations of tasks and dependencies. Example: ```python >>> scheduler = TaskScheduler() >>> scheduler.add_task(1, [2, 3]) >>> scheduler.add_task(2, [4]) >>> scheduler.add_task(3, [4]) >>> scheduler.add_task(4, []) >>> scheduler.get_execution_order() [4, 2, 3, 1] >>> scheduler.add_task(1, [2]) >>> scheduler.add_task(2, [3]) >>> scheduler.add_task(3, [1]) # Circular dependency >>> scheduler.get_execution_order() Traceback (most recent call last): ... ValueError: Circular dependency detected ``` Your implementation should demonstrate efficient task scheduling while correctly handling dependencies and detecting any circular dependencies.","solution":"from collections import defaultdict, deque from typing import List class TaskScheduler: def __init__(self): self.graph = defaultdict(list) self.indegree = defaultdict(int) def add_task(self, task_id: int, dependencies: List[int]): if task_id not in self.graph: self.graph[task_id] = [] for dep in dependencies: self.graph[dep].append(task_id) self.indegree[task_id] += 1 if dep not in self.indegree: self.indegree[dep] = 0 def get_execution_order(self) -> List[int]: zero_indegree = deque([node for node in self.graph if self.indegree[node] == 0]) order = [] while zero_indegree: current = zero_indegree.popleft() order.append(current) for neighbor in self.graph[current]: self.indegree[neighbor] -= 1 if self.indegree[neighbor] == 0: zero_indegree.append(neighbor) if len(order) == len(self.graph): return order else: raise ValueError(\\"Circular dependency detected\\")"},{"question":"# Problem Statement Write a function that generates a report of the top `n` occurring words in a given text file. The report should include the word and its frequency, sorted by frequency in descending order. # Function Signature ```python def most_frequent_words(file_path: str, n: int) -> List[Tuple[str, int]]: ``` # Input: * `file_path`: A string representing the path to the text file. * `n`: An integer representing the number of top occurring words to include in the report. (1 ≤ `n` ≤ 100) # Output: * A list of tuples, where each tuple contains a word (string) and its frequency (int), sorted by frequency in descending order. If words have the same frequency, they should be sorted alphabetically. # Constraints: * The text file will contain only alphabetical characters and spaces. * Ignore case (e.g., \\"Word\\" and \\"word\\" should be treated as the same). * The report should be case-insensitive but the output should be in lowercase. # Example Usage: ```python file_path = \\"sample_text.txt\\" result = most_frequent_words(file_path, 5) print(result) # Output: [(\'the\', 15), (\'of\', 12), (\'to\', 10), (\'and\', 9), (\'a\', 8)] ``` # Example Content of `sample_text.txt`: ```text This is a sample text file. It contains a simple paragraphs with words. Words in this file will be counted, and the most frequent words will be reported. ``` # Notes: * Ensure your implementation reads the file efficiently, considering both time and space complexity. * Handle cases where the file contains fewer than `n` unique words gracefully by returning all unique words in sorted order. * Strip punctuations and handle various word delimiters properly. # Evaluation Criteria: * Correctness: Accurately counting and reporting the top `n` words. * Robustness: Handling various file reading and parsing edge cases. * Efficiency: Reasonable time and space complexity for large files. # Bonus: * Add an option to exclude common stop words (like \\"the\\", \\"and\\", etc.) from the report. * Include functionality to output the report to a new text file.","solution":"from typing import List, Tuple import re from collections import Counter def most_frequent_words(file_path: str, n: int) -> List[Tuple[str, int]]: Generates a report of the top `n` occurring words in a given text file. Args: - file_path: a string representing the path to the text file. - n: an integer representing the number of top occurring words to include in the report. (1 ≤ `n` ≤ 100) Returns: - A list of tuples, where each tuple contains a word (string) and its frequency (int), sorted by frequency in descending order. with open(file_path, \'r\') as file: text = file.read().lower() # Remove punctuation and split into words words = re.findall(r\'bw+b\', text) # Count word frequencies word_counts = Counter(words) # Get the top `n` words sorted by frequency and then alphabetically most_common_words = word_counts.most_common() most_common_words.sort(key=lambda x: (-x[1], x[0])) return most_common_words[:n]"},{"question":"# Question: Advanced List Filtering and Transformation You need to implement a function that filters and transforms a list of integers based on a specified condition. The function should return a new list with only the even integers from the original list, each transformed by squaring it. Function Signature ```python def filter_and_transform(nums: list[int]) -> list[int]: # Your code here ``` # Input - `nums` (list[int]): A list of integers. # Output - Returns a list of integers where all elements are even and each element is the square of the original even integer. # Constraints - The input list should only contain integer elements. - The function should maintain the order of the input list in the output list. # Example ```python assert filter_and_transform([1, 2, 3, 4, 5]) == [4, 16] assert filter_and_transform([10, 15, 20, 25]) == [100, 400] assert filter_and_transform([1, 3, 5, 7]) == [] assert filter_and_transform([2, 4, 6, 8]) == [4, 16, 36, 64] assert filter_and_transform([0, -2, -4]) == [0, 4, 16] assert filter_and_transform([]) == [] ``` # Notes - The function should handle large lists efficiently. - It should preserve the order of even numbers from the original list in the output list. - Only even integers (including zero) should be squared and included in the output list. - Use built-in Python functions and list comprehensions optimally to achieve the required functionality and performance.","solution":"def filter_and_transform(nums: list[int]) -> list[int]: Returns a new list with only the even integers from the original list, each transformed by squaring it. return [x ** 2 for x in nums if x % 2 == 0]"},{"question":"# Coding Challenge: Inventory Management System **Context**: An inventory management system is essential for tracking products within a warehouse. A common operation within such a system is efficiently maintaining the inventory and retrieving product information. # Task Implement a class `Inventory` using a combination of a dictionary and a list. Your class should support the following operations: 1. **Add Product**: Add a product to the inventory with a specified quantity. 2. **Remove Product**: Remove a specified quantity of a product from the inventory. 3. **Get Product Quantity**: Retrieve the quantity of a specific product. 4. **Print Inventory**: Print the entire inventory with each product and its corresponding quantity. # Input and Output - **Add Product**: - Method: `add_product(name: str, quantity: int) -> None` - Input: String product name and integer quantity. - Output: None. - **Remove Product**: - Method: `remove_product(name: str, quantity: int) -> None` - Input: String product name and integer quantity. - Output: None. - **Get Product Quantity**: - Method: `get_product_quantity(name: str) -> int | None` - Input: String product name. - Output: Integer quantity or None if product does not exist. - **Print Inventory**: - Method: `print_inventory() -> None` - Output: Print each product and its quantity in the inventory. # Constraints 1. Ensure that the product names are unique within the inventory. 2. The system should handle attempts to remove more quantity than available by either setting the quantity to zero or raising an error. 3. Implement all required functions and handle edge cases such as adding or removing invalid quantities. # Scenario Create an `Inventory` instance and perform various add, remove, and retrieval operations while ensuring the correct functionality of the inventory system. ```python class Inventory: def __init__(self): self.inventory = {} def add_product(self, name: str, quantity: int) -> None: if name in self.inventory: self.inventory[name] += quantity else: self.inventory[name] = quantity def remove_product(self, name: str, quantity: int) -> None: if name in self.inventory: self.inventory[name] = max(0, self.inventory[name] - quantity) if self.inventory[name] == 0: del self.inventory[name] else: print(f\\"Product {name} does not exist in the inventory.\\") def get_product_quantity(self, name: str) -> int | None: return self.inventory.get(name, None) def print_inventory(self) -> None: for product, quantity in self.inventory.items(): print(f\\"{product}: {quantity}\\") if __name__ == \\"__main__\\": inventory = Inventory() inventory.add_product(\\"apple\\", 50) inventory.add_product(\\"banana\\", 30) inventory.add_product(\\"apple\\", 20) inventory.print_inventory() # Expected Output: apple: 70, banana: 30 inventory.remove_product(\\"banana\\", 10) inventory.print_inventory() # Expected Output: apple: 70, banana: 20 print(inventory.get_product_quantity(\\"banana\\")) # Expected Output: 20 inventory.remove_product(\\"apple\\", 80) inventory.print_inventory() # Expected Output: banana: 20, apple removed as quantity becomes 0 print(inventory.get_product_quantity(\\"apple\\")) # Expected Output: None ``` Ensure to include edge cases such as removing a product that does not exist, adding a product with zero quantity, and printing an empty inventory.","solution":"class Inventory: def __init__(self): self.inventory = {} def add_product(self, name: str, quantity: int) -> None: if quantity < 0: raise ValueError(\\"Quantity cannot be negative.\\") if name in self.inventory: self.inventory[name] += quantity else: self.inventory[name] = quantity def remove_product(self, name: str, quantity: int) -> None: if quantity < 0: raise ValueError(\\"Quantity cannot be negative.\\") if name in self.inventory: self.inventory[name] = max(0, self.inventory[name] - quantity) if self.inventory[name] == 0: del self.inventory[name] else: raise KeyError(f\\"Product {name} does not exist in the inventory.\\") def get_product_quantity(self, name: str) -> int | None: return self.inventory.get(name, None) def print_inventory(self) -> None: if not self.inventory: print(\\"Inventory is empty.\\") for product, quantity in self.inventory.items(): print(f\\"{product}: {quantity}\\")"},{"question":"# Tetris-like Block Fitting Algorithm You are to implement a function that will determine if a given tetris-like block can be placed on a grid without overlapping existing filled cells. The block can be rotated 90 degrees at a time but cannot be flipped. # Problem Given a grid with certain cells already filled and a block that can be rotated in 90-degree increments, your task is to determine if there is a way to place the block on the grid without overlapping any filled cells. # Function Signature ```python def can_place_block( grid: list[list[int]], block: list[list[int]], position: list[int] ) -> bool: ``` # Input * `grid` (`list[list[int]]`): A 2D list representing the grid where 1 indicates a filled cell and 0 indicates an empty cell. * `block` (`list[list[int]]`): A 2D list representing the block, where 1 indicates part of the block and 0 indicates empty space. * `position` (`list[int]`): The top-left position on the grid where you attempt to place the block given as [y, x]. # Output * Returns a boolean value `True` if the block can be placed starting from the given position without overlapping filled cells (considering all rotations), otherwise `False`. # Constraints * `0 <= grid[i][j] <= 1` where 0 represents an empty cell, 1 represents a filled cell. * `0 <= block[i][j] <= 1` where 0 represents an empty cell, 1 represents a part of the block. * The block can be rotated by 90 degrees increment (i.e., 0, 90, 180, and 270 degrees) but cannot be flipped. * `0 <= position[0] < len(grid)` and `0 <= position[1] < len(grid[0])` # Example ```python grid = [ [0, 0, 0, 0, 0], [0, 1, 0, 0, 0], [0, 1, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], ] block = [ [1, 1], [1, 1] ] position = [2, 2] # True because the block can be placed at [2, 2] without overlapping print(can_place_block(grid, block, position)) block2 = [ [1, 1, 1], [1, 0, 0] ] position2 = [1, 0] # False because the block in any rotation would overlap the existing 1s in the grid print(can_place_block(grid, block2, position2)) ``` # Notes 1. Implement a function that checks all four rotations of the block to see if it can fit in the grid without overlaps. 2. Any position out of grid bounds or overlapping filled cells should return `False`.","solution":"def rotate_90(matrix): Rotates the given 2D list matrix by 90 degrees clockwise. return [list(row) for row in zip(*matrix[::-1])] def can_place_block(grid, block, position): def fits(grid, block, y, x): block_h = len(block) block_w = len(block[0]) grid_h = len(grid) grid_w = len(grid[0]) if y + block_h > grid_h or x + block_w > grid_w: return False for i in range(block_h): for j in range(block_w): if block[i][j] == 1 and grid[y + i][x + j] == 1: return False return True for _ in range(4): if fits(grid, block, position[0], position[1]): return True block = rotate_90(block) return False"},{"question":"# Sentence Anagram Finder You are tasked with creating a function to find all possible anagrams of a given sentence. The function should consider the anagrams only within the list of provided valid words. Task Implement a function named `find_sentence_anagrams` which takes an input sentence and a list of valid words. It returns a list of all possible anagrams of the sentence that consist solely of the valid words. Each anagram should be a string with words separated by a single space. The function should handle punctuation and be case-insensitive. Anagrams should include the same number of each character (ignoring spaces and punctuation), and they should be constructed from the valid words list. Function Signature ```python def find_sentence_anagrams(sentence: str, valid_words: list[str]) -> list[str]: pass ``` Constraints 1. The input sentence will be a non-empty string containing alphabetic characters and possibly spaces and punctuation. 2. The valid words list will contain non-empty lowercase alphabetic strings. 3. The function should be case-insensitive and ignore punctuation. 4. You may assume that the valid words list contains all possible words that can form anagrams of the input sentence. 5. The output list should not contain any duplicate anagrams. Example ```python sentence = \\"Listen\\" valid_words = [\\"enlist\\", \\"tinsel\\", \\"silent\\", \\"listen\\", \\"inlets\\"] # Function call anagrams = find_sentence_anagrams(sentence, valid_words) # Expected output # [\'listen\', \'silent\', \'inlets\', \'enlist\', \'tinsel\'] ``` Evaluation Criteria 1. Correctness: The function must return all correct unique anagrams. 2. Efficiency: The function should handle reasonably large inputs efficiently. 3. Robustness: The function must handle various input cases such as different punctuations and cases correctly. 4. Code quality and readability, including meaningful variable names and comments. By completing this problem, you will demonstrate your understanding of string manipulation, anagram construction, and efficient iteration.","solution":"from collections import Counter import re def find_sentence_anagrams(sentence: str, valid_words: list[str]) -> list[str]: Returns all possible anagrams of the given sentence using the valid words. # Preprocess the input sentence: remove punctuation, convert to lowercase, and remove spaces cleaned_sentence = re.sub(r\'[^a-zA-Z]\', \'\', sentence).lower() # Remain a Counter (multiset) of the sentence to compare letter counts sentence_counter = Counter(cleaned_sentence) def is_valid_anagram(word): Checks if the word can be formed by using the letters of the given sentence. word_counter = Counter(word) return all(sentence_counter[letter] >= count for letter, count in word_counter.items()) # Find all valid words that can be constructed from the sentence letters valid_anagrams = [word for word in valid_words if is_valid_anagram(word)] # Remove duplicates and sort return sorted(set(valid_anagrams)) # Test Example sentence = \\"Listen\\" valid_words = [\\"enlist\\", \\"tinsel\\", \\"silent\\", \\"listen\\", \\"inlets\\"] anagrams = find_sentence_anagrams(sentence, valid_words) print(anagrams) # Output: [\'enlist\', \'inlets\', \'listen\', \'silent\', \'tinsel\']"},{"question":"# Unique Coding Question You are developing a software tool used in healthcare to analyze patient heart rate data over time. The tool must detect periods of abnormal heart rate, which can indicate potential health issues. Your task is to implement the `detect_abnormal_heart_rates` function. This function takes a list of heart rate readings (in beats per minute) and two thresholds: `low_threshold` and `high_threshold`. It should return a list of tuples, each representing a period where the heart rate was abnormal—either below the `low_threshold` or above the `high_threshold`. **Function Signature** ```python def detect_abnormal_heart_rates( heart_rates: List[int], low_threshold: int, high_threshold: int ) -> List[Tuple[int, int]]: ``` ```python def detect_abnormal_heart_rates( heart_rates: List[int], low_threshold: int, high_threshold: int ) -> List[Tuple[int, int]]: Detect periods of abnormal heart rates. Parameters ---------- heart_rates : List[int] List of heart rate readings in beats per minute. low_threshold : int Threshold below which the heart rate is considered abnormally low. high_threshold : int Threshold above which the heart rate is considered abnormally high. Returns ------- List[Tuple[int, int]] A list of tuples where each tuple represents the start and end indices of periods with abnormal heart rates. Example ------- >>> detect_abnormal_heart_rates([70, 45, 80, 60, 120, 55, 30, 90, 70, 80, 110], 50, 100) [(1, 1), (4, 4), (6, 6), (10, 10)] periods = [] start = None for i, rate in enumerate(heart_rates): if rate < low_threshold or rate > high_threshold: if start is None: start = i else: if start is not None: periods.append((start, i - 1)) start = None if start is not None: periods.append((start, len(heart_rates) - 1)) return periods ``` **Constraints** - `heart_rates` should be a list of integer values representing heart rates in beats per minute. - Both `low_threshold` and `high_threshold` should be positive integers. **Notes** - The returned list of tuples should not contain overlapping periods. - Each tuple in the list represents a start and end index (inclusive) of an abnormal heart rate period. If consecutive readings are abnormal, they should be reported as a single period. - Examples of abnormal heart rates include readings that fall strictly below `low_threshold` or strictly above `high_threshold`. This question aligns with the format, complexity, and scope of linking multiple concepts like loops, conditional statements, and list operations. It also tests the ability to handle and process array data and to manage edge cases and constraints.","solution":"from typing import List, Tuple def detect_abnormal_heart_rates( heart_rates: List[int], low_threshold: int, high_threshold: int ) -> List[Tuple[int, int]]: Detect periods of abnormal heart rates. Parameters ---------- heart_rates : List[int] List of heart rate readings in beats per minute. low_threshold : int Threshold below which the heart rate is considered abnormally low. high_threshold : int Threshold above which the heart rate is considered abnormally high. Returns ------- List[Tuple[int, int]] A list of tuples where each tuple represents the start and end indices of periods with abnormal heart rates. Example ------- >>> detect_abnormal_heart_rates([70, 45, 80, 60, 120, 55, 30, 90, 70, 80, 110], 50, 100) [(1, 1), (4, 4), (6, 6), (10, 10)] periods = [] start = None for i, rate in enumerate(heart_rates): if rate < low_threshold or rate > high_threshold: if start is None: start = i else: if start is not None: periods.append((start, i - 1)) start = None if start is not None: periods.append((start, len(heart_rates) - 1)) return periods"},{"question":"# Problem Statement You are required to write functions for analyzing data related to students who received scholarships based on their GPA and attendance percentage. The goal is to determine how many students qualify for the scholarship and what the average GPA of these students is. # Function Definitions 1. **qualified_students_count** ```python def qualified_students_count(gpas: list[float], attendance: list[float], min_gpa: float, min_attendance: float) -> int | ValueError: Input Parameters: ----------------- gpas: List of GPA scores of students. attendance: List of attendance percentages of students. min_gpa: Minimum GPA required to qualify for the scholarship. min_attendance: Minimum attendance percentage required to qualify for the scholarship. Returns: -------- The count of students who qualify for the scholarship as an integer. Raises a ValueError if the length of gpas and attendance lists are not the same or if any input GPA or attendance value is out of the valid range (0.0 - 4.0 for GPA and 0.0 - 100.0 for attendance). ``` 2. **average_gpa_of_qualified** ```python def average_gpa_of_qualified(gpas: list[float], attendance: list[float], min_gpa: float, min_attendance: float) -> float | ValueError: Input Parameters: ----------------- gpas: List of GPA scores of students. attendance: List of attendance percentages of students. min_gpa: Minimum GPA required to qualify for the scholarship. min_attendance: Minimum attendance percentage required to qualify for the scholarship. Returns: -------- The average GPA of students who qualify for the scholarship as a float rounded to 2 decimal places. Raises a ValueError if the length of gpas and attendance lists are not the same or if any input GPA or attendance value is out of the valid range (0.0 - 4.0 for GPA and 0.0 - 100.0 for attendance). ``` # Constraints * Input values for GPA should be between 0.0 and 4.0. * Input values for attendance percentage should be between 0.0 and 100.0. * Both lists `gpas` and `attendance` will have the same length. * Results should be rounded to 2 decimal places for the average GPA. # Example Scenarios: **Example 1**: ```python # Count of qualified students qualified_students_count([3.5, 2.8, 3.9], [85, 70, 90], 3.0, 80) # Expected: 2 # Average GPA of qualified students average_gpa_of_qualified([3.5, 2.8, 3.9], [85, 70, 90], 3.0, 80) # Expected: 3.70 ``` **Example 2**: ```python # Invalid input will result in ValueError qualified_students_count([3.5, 2.8, 5.0], [85, 70, 90], 3.0, 80) # Expected: ValueError(\'Input Error: GPA values must be between 0.0 and 4.0.\') average_gpa_of_qualified([3.5, 2.8, 3.9], [85, 70, 110], 3.0, 80) # Expected: ValueError(\'Input Error: Attendance values must be between 0.0 and 100.0.\') ```","solution":"def qualified_students_count(gpas, attendance, min_gpa, min_attendance): Returns the count of students who qualify for the scholarship. Parameters: - gpas: List of GPA scores of students. - attendance: List of attendance percentages of students. - min_gpa: Minimum GPA required to qualify for scholarship. - min_attendance: Minimum attendance percentage required to qualify for scholarship. Returns: - Integer count of qualified students. Raises: - ValueError if GPA is not in range [0.0, 4.0] or attendance is not in range [0.0, 100.0]. if len(gpas) != len(attendance): raise ValueError(\\"Input Error: Length of GPA and attendance lists must be the same.\\") for gpa in gpas: if gpa < 0.0 or gpa > 4.0: raise ValueError(\\"Input Error: GPA values must be between 0.0 and 4.0.\\") for att in attendance: if att < 0.0 or att > 100.0: raise ValueError(\\"Input Error: Attendance values must be between 0.0 and 100.0.\\") count = 0 for gpa, att in zip(gpas, attendance): if gpa >= min_gpa and att >= min_attendance: count += 1 return count def average_gpa_of_qualified(gpas, attendance, min_gpa, min_attendance): Returns the average GPA of students who qualify for the scholarship. Parameters: - gpas: List of GPA scores of students. - attendance: List of attendance percentages of students. - min_gpa: Minimum GPA required to qualify for scholarship. - min_attendance: Minimum attendance percentage required to qualify for scholarship. Returns: - Average GPA of qualified students as a float rounded to 2 decimal places. Raises: - ValueError if GPA is not in range [0.0, 4.0] or attendance is not in range [0.0, 100.0]. if len(gpas) != len(attendance): raise ValueError(\\"Input Error: Length of GPA and attendance lists must be the same.\\") for gpa in gpas: if gpa < 0.0 or gpa > 4.0: raise ValueError(\\"Input Error: GPA values must be between 0.0 and 4.0.\\") for att in attendance: if att < 0.0 or att > 100.0: raise ValueError(\\"Input Error: Attendance values must be between 0.0 and 100.0.\\") qualified_gpas = [gpa for gpa, att in zip(gpas, attendance) if gpa >= min_gpa and att >= min_attendance] if not qualified_gpas: return 0.0 average_gpa = round(sum(qualified_gpas) / len(qualified_gpas), 2) return average_gpa"},{"question":"# Array Rotation Instructions: Write a function `rotate_array` that rotates an array to the right by a given number of steps. The array should be rotated in-place, meaning you should not use extra space for another array. Function Signature: ```python def rotate_array(arr: List[int], k: int) -> None: Rotates the array to the right by k steps. Parameters: arr (List[int]): A list of integers. k (int): Number of steps to rotate the array. Returns: None: The function modifies the array in-place. ``` Input and Output: - **Input**: - `arr`: A list of integers. - `k`: An integer representing the number of steps to rotate the array. - **Output**: - The function does not return anything. It modifies the array in-place. Example: ```python arr = [1, 2, 3, 4, 5, 6, 7] k = 3 rotate_array(arr, k) print(arr) ``` Expected output for the provided array after rotating by 3 steps: ``` [5, 6, 7, 1, 2, 3, 4] ``` Constraints: 1. The length of `arr` is between 1 and ( 10^5 ) inclusive. 2. The rotation steps `k` will be a non-negative integer. # Additional Notes: * You must solve the problem in O(n) time complexity and O(1) space complexity. * Consider rotating the array in three specific parts to achieve the desired right rotation without additional space: 1. Reverse the entire array. 2. Reverse the first `k` elements. 3. Reverse the remaining elements.","solution":"from typing import List def rotate_array(arr: List[int], k: int) -> None: Rotates the array to the right by k steps. Parameters: arr (List[int]): A list of integers. k (int): Number of steps to rotate the array. Returns: None: The function modifies the array in-place. n = len(arr) k %= n # In case k is larger than the length of the array def reverse(start: int, end: int) -> None: while start < end: arr[start], arr[end] = arr[end], arr[start] start += 1 end -= 1 # Reverse the entire array reverse(0, n - 1) # Reverse the first k elements reverse(0, k - 1) # Reverse the remaining elements reverse(k, n - 1)"},{"question":"# Problem Statement: You are provided with a dictionary-based key-value store implementation. Extend the key-value store with the following functionalities: 1. **merge(other_store)**: Implement a method that merges another key-value store into the current one. If there are conflicting keys, the value from the `other_store` should be used. 2. **find_key(value)**: Implement a method that finds all keys associated with a given value. It should return a list of keys that map to the given value. If no such keys exist, return an empty list. # Expected Input and Output Formats: * For `merge(other_store)`: * **Input**: * `other_store` (KeyValueStore): Another instance of the KeyValueStore class. * **Output**: The method modifies the current store and returns `None`. * For `find_key(value)`: * **Input**: * `value` (any): The value to search for. * **Output**: A list of keys that map to the given value. If no such keys exist, return an empty list. # Constraints: 1. The store can have up to `N = 10^5` keys. 2. The values stored can be of any type but will be comparable using the `==` operator. # Example: ```python store1 = KeyValueStore() store1.set_item(\'a\', 1) store1.set_item(\'b\', 2) store1.set_item(\'c\', 3) store2 = KeyValueStore() store2.set_item(\'b\', 20) store2.set_item(\'d\', 4) store2.set_item(\'e\', 5) store1.merge(store2) print(store1.get_item(\'b\')) # 20 print(store1.find_key(3)) # [\'c\'] print(store1.find_key(10)) # [] ``` # Solution Template: You may start with the provided code snippet and extend the class as described in the task. ```python class KeyValueStore: def __init__(self): self.store = {} def set_item(self, key, value): self.store[key] = value def get_item(self, key): return self.store.get(key) def delete_item(self, key): if key in self.store: del self.store[key] def merge(self, other_store): Merge another store into the current store. # Implement merge functionality for key, value in other_store.store.items(): self.store[key] = value def find_key(self, value): Find all keys that map to a given value. # Implement find_key functionality result = [key for key, val in self.store.items() if val == value] return result # You can run your tests here store1 = KeyValueStore() store1.set_item(\'a\', 1) store1.set_item(\'b\', 2) store1.set_item(\'c\', 3) store2 = KeyValueStore() store2.set_item(\'b\', 20) store2.set_item(\'d\', 4) store2.set_item(\'e\', 5) store1.merge(store2) print(store1.get_item(\'b\')) # Expected: 20 print(store1.find_key(3)) # Expected: [\'c\'] print(store1.find_key(10)) # Expected: [] ```","solution":"class KeyValueStore: def __init__(self): self.store = {} def set_item(self, key, value): self.store[key] = value def get_item(self, key): return self.store.get(key) def delete_item(self, key): if key in self.store: del self.store[key] def merge(self, other_store): Merge another store into the current store. for key, value in other_store.store.items(): self.store[key] = value def find_key(self, value): Find all keys that map to a given value. result = [key for key, val in self.store.items() if val == value] return result"},{"question":"# Problem Statement Implement a function `reverse_list_between` in the `LinkedList` class that reverses the nodes of the linked list between positions `m` and `n`. Note that the position numbering starts from 1. # Function Signature ```python def reverse_list_between(self, m: int, n: int) -> None: ``` # Requirements 1. Implement the `reverse_list_between` method within the `LinkedList` class. 2. The function should reverse the nodes from position `m` to position `n`, inclusive. 3. If the positions are invalid (e.g., m or n are out of the list\'s bounds, or m is greater than n), the function should leave the list unchanged. 4. You must complete the task in one traversal of the linked list, achieving a time complexity of O(n), where n is the number of nodes in the list. # Input/Output Format * **Input**: Two integers, `m` and `n`, which represent the start and end positions of the sublist to reverse. * **Output**: None. The function should modify the linked list in place. # Constraints - Assume 1 ≤ m ≤ n ≤ list length. - The list can contain any data type in its nodes. # Example ```python linked_list = LinkedList() linked_list.insert_tail(1) linked_list.insert_tail(2) linked_list.insert_tail(3) linked_list.insert_tail(4) linked_list.insert_tail(5) linked_list.reverse_list_between(2, 4) # The list should now be: 1 -> 4 -> 3 -> 2 -> 5 linked_list.reverse_list_between(1, 5) # The list should now be: 5 -> 2 -> 3 -> 4 -> 1 ``` Demonstrate the handling of various cases like reversing a sublist that includes the head, tail, or the entire list, as well as edge cases where `m` and `n` refer to the same position. **Additional Notes**: - You can use helper functions or methods within the class if necessary but should avoid modifying existing methods unless essential.","solution":"class Node: def __init__(self, data): self.data = data self.next = None class LinkedList: def __init__(self): self.head = None def insert_tail(self, data): new_node = Node(data) if not self.head: self.head = new_node else: current = self.head while current.next: current = current.next current.next = new_node def reverse_list_between(self, m: int, n: int) -> None: if m >= n: return dummy = Node(0) dummy.next = self.head pre = dummy for _ in range(m - 1): pre = pre.next cur = pre.next nxt = cur.next for _ in range(n - m): cur.next = nxt.next nxt.next = pre.next pre.next = nxt nxt = cur.next if m == 1: self.head = dummy.next def display(self): elems = [] cur = self.head while cur: elems.append(cur.data) cur = cur.next return elems"},{"question":"# Problem Statement You are developing a scheduling system for a conference. The conference consists of multiple events, and you need to determine the maximum number of non-overlapping events a single attendee can attend. Events are represented by their start and end times. # Implementation Details 1. **Function Signature**: Implement the function `max_non_overlapping_events(events: List[Tuple[int, int]]) -> int` 2. **Input**: - `events` (List[Tuple[int, int]]): A list of tuples where each tuple contains two integers representing the start and end time of an event (start, end). 3. **Output**: - An integer representing the maximum number of non-overlapping events an attendee can attend. 4. **Constraints**: - The list of events will have at most 10,000 events. - Events are guaranteed to have non-negative integer start and end times. - The end time of an event is always greater than its start time. # Example ```python events = [ (1, 3), (2, 4), (3, 5), (7, 8), (5, 6) ] assert max_non_overlapping_events(events) == 4 # The maximum number of non-overlapping events is 4 corresponding to the events (1, 3), (3, 5), (5, 6), and (7, 8). ``` # Additional Notes - Sort the events by their end times to facilitate the selection of non-overlapping events. - Use a greedy algorithm to select events, always choosing the next event with the earliest end time that does not overlap with the previously selected event. - Ensure to test edge cases with no events or events with large time ranges.","solution":"from typing import List, Tuple def max_non_overlapping_events(events: List[Tuple[int, int]]) -> int: Returns the maximum number of non-overlapping events a single attendee can attend using a greedy algorithm approach. # Sort events by their end time events.sort(key=lambda x: x[1]) # Initialize count of non-overlapping events and end time of the last selected event count, last_end_time = 0, float(\'-inf\') for start, end in events: if start >= last_end_time: # If the event does not overlap, add it to the schedule count += 1 last_end_time = end return count"},{"question":"# Fibonacci Sequence with Caching You are working on a project that involves generating large Fibonacci numbers frequently. To make the computation efficient, you need to implement a caching mechanism that stores previously computed Fibonacci numbers. Your task is to implement the following two functions: 1. **`fibonacci(n: int) -> int`**: - Input: - `n`: the position in the Fibonacci sequence (0-indexed). - Output: - Return the `n`th Fibonacci number. 2. **`clear_cache() -> None`**: - This function should clear the cache of previously computed Fibonacci numbers. Your implementation should make use of a dictionary to store the Fibonacci numbers as they are computed and retrieve them from the cache when needed to avoid redundant calculations. # Constraints - Assume `n` will always be a non-negative integer. - The value of `n` will be small enough to compute within reasonable time limits for a coding assessment. # Example ```python # Example usage: print(fibonacci(10)) # Output: 55 print(fibonacci(0)) # Output: 0 print(fibonacci(1)) # Output: 1 # Caching efficiency test print(fibonacci(50)) # Output: 12586269025 (This should be computed efficiently with caching) clear_cache() print(fibonacci(50)) # Output: 12586269025 (This should recompute as the cache is cleared) ``` # Notes - Ensure you implement a caching mechanism effectively. - The `clear_cache` function should reset any stored Fibonacci numbers. - You may use a simple global dictionary or any other suitable method for caching. # Solution Template ```python cache = {} def fibonacci(n: int) -> int: if n in cache: return cache[n] if n == 0: result = 0 elif n == 1: result = 1 else: result = fibonacci(n - 1) + fibonacci(n - 2) cache[n] = result return result def clear_cache() -> None: global cache cache = {} ```","solution":"cache = {} def fibonacci(n: int) -> int: if n in cache: return cache[n] if n == 0: result = 0 elif n == 1: result = 1 else: result = fibonacci(n - 1) + fibonacci(n - 2) cache[n] = result return result def clear_cache() -> None: global cache cache = {}"},{"question":"# Context A new tech exhibition has introduced a unique robot that can perform simple arithmetic operations. However, the robot is only capable of understanding inputs in the form of encoded commands. You have been tasked with designing a function that decodes these commands and performs the corresponding arithmetic operation. # Task Implement a function called `robot_arithmetic(commands)` that takes a list of encoded strings, each representing an arithmetic operation, and returns a list of results after performing each operation. The encoding format is as follows: - Addition: `\\"ADD:x,y\\"` - Subtraction: `\\"SUB:x,y\\"` - Multiplication: `\\"MUL:x,y\\"` - Division: `\\"DIV:x,y\\"` In each string, `x` and `y` are integers. The function should correctly parse the encoded commands, perform the relevant arithmetic operation, and return the results. # Specifications * **Input Format**: - A list of strings, `commands`, where each string represents an encoded arithmetic operation. * **Constraints**: - The operations should be performed in the order they appear in the list. - Division by zero should return `float(\'inf\')`. - Assume all inputs are valid and follow the given encoding format. * **Output Format**: - A list of results from performing each arithmetic operation in the order they appear in the input list. # Example ```python >>> commands = [\\"ADD:1,2\\", \\"SUB:10,5\\", \\"MUL:3,4\\", \\"DIV:8,2\\"] >>> robot_arithmetic(commands) [3, 5, 12, 4.0] >>> commands = [\\"ADD:0,0\\", \\"SUB:5,9\\", \\"MUL:7,6\\", \\"DIV:9,0\\"] >>> robot_arithmetic(commands) [0, -4, 42, inf] ``` # Notes * Ensure your function handles division by zero appropriately by returning `float(\'inf\')`. * Ensure all operations return results in their appropriate type (e.g., integer results for addition, subtraction, and multiplication; float results for division).","solution":"def robot_arithmetic(commands): Decodes a list of encoded arithmetic commands and performs the corresponding operation. Parameters: commands (list): A list of encoded strings representing arithmetic operations. Returns: list: A list of results from performing each arithmetic operation. results = [] for command in commands: operation, values = command.split(\\":\\") x, y = map(int, values.split(\\",\\")) if operation == \\"ADD\\": results.append(x + y) elif operation == \\"SUB\\": results.append(x - y) elif operation == \\"MUL\\": results.append(x * y) elif operation == \\"DIV\\": if y == 0: results.append(float(\'inf\')) else: results.append(x / y) return results"},{"question":"# Coding Assessment Question Your task is to implement this function: ```python def reverse_k_nodes(head: \'ListNode\', k: int) -> \'ListNode\': Reverse the nodes of the given linked list k at a time and return its modified list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as is. You may not alter the values in the nodes, only the nodes themselves may be changed. Args: head: The head of the linked list. k: Number of nodes to be reversed at a time. Returns: The head of the modified list. # Your implementation here pass ``` # Detailed Specifications and Constraints: 1. **Inputs**: - `head` (ListNode): The head of the input linked list. - `k` (int): The number of nodes to reverse at a time (1 <= k <= length of list). 2. **Outputs**: - Returns a `ListNode`, which is the head of the modified list. 3. **Edge Cases**: - Empty list or single node list, where no changes are necessary. - `k` larger than the number of nodes in the list, where the list should remain unchanged. 4. **Performance Requirements**: - The function should run in linear time O(n). - The function should use constant space O(1) (excluding the input and output space). # Example: ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def print_list(head: \'ListNode\') -> None: while head: print(head.val, end=\\" -> \\") head = head.next print(\\"None\\") # Example usage and assertions to validate the solution: # Example 1: # Input: 1->2->3->4->5, k = 2 # Output: 2->1->4->3->5 head = ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5))))) k = 2 print_list(reverse_k_nodes(head, k)) #Expected: 2 -> 1 -> 4 -> 3 -> 5 -> None # Example 2: # Input: 1->2->3->4->5->6, k = 3 # Output: 3->2->1->6->5->4 head = ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5, ListNode(6)))))) k = 3 print_list(reverse_k_nodes(head, k)) # Expected: 3 -> 2 -> 1 -> 6 -> 5 -> 4 -> None # Example 3: # Input: 1->2->3->4->5, k = 1 # Output: 1->2->3->4->5 head = ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5))))) k = 1 print_list(reverse_k_nodes(head, k)) # Expected: 1 -> 2 -> 3 -> 4 -> 5 -> None # Edge cases: # Input: 1->2->3, k = 4 (k greater than length of list) # Output: 1->2->3 head = ListNode(1, ListNode(2, ListNode(3))) k = 4 print_list(reverse_k_nodes(head, k)) # Expected: 1 -> 2 -> 3 -> None # Input: Empty list # Output: None head = None k = 3 print_list(reverse_k_nodes(head, k)) # Expected: None ``` Make sure to test your implementation thoroughly using both provided and additional test cases to cover various scenarios and edge cases.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_k_nodes(head: \'ListNode\', k: int) -> \'ListNode\': if not head or k == 1: return head # Helper function to reverse a portion of the list def reverse(start: \'ListNode\', end: \'ListNode\') -> \'ListNode\': prev, curr = None, start while curr != end: next_node = curr.next curr.next = prev prev = curr curr = next_node return prev # Initialize pointers dummy = ListNode(0) dummy.next = head group_prev = dummy while True: kth = group_prev count = 0 # Find the kth node while count < k and kth.next: kth = kth.next count += 1 if count < k: break group_next = kth.next # Reverse the group group_start = group_prev.next group_end = kth.next reverse(group_start, group_end) group_prev.next = kth group_start.next = group_next group_prev = group_start return dummy.next"},{"question":"# Unique Binary Search Trees In this task, you need to implement a function that calculates the number of unique Binary Search Trees (BSTs) that can be created with `n` distinct nodes. Each BST must adhere to the properties of a binary search tree. **Function Signature**: - Implement the function `def num_trees(n: int) -> int:` # Requirements: 1. **num_trees(n: int) -> int**: - Accepts an integer `n` representing the number of distinct nodes. - Returns the number of unique BSTs that can be formed using these `n` nodes. # Constraints: - `0 <= n <= 19` # Explanation: - A binary search tree is a tree where for each node, the values in the left subtree are less than the node\'s value, and the values in the right subtree are greater than the node\'s value. - The number of unique BSTs with `n` nodes corresponds to the `n`th Catalan number, which can be calculated using dynamic programming. # Formula: The number of unique BSTs with `n` nodes can be given by the formula: [ C(n) = frac{1}{n+1} binom{2n}{n} ] where ( C(n) ) is the `n`th Catalan number. Alternatively, the recursive formula is: [ C(n) = sum_{i=0}^{n-1} C(i) times C(n-1-i) ] with ( C(0) = 1 ). # Example: ```python # Example usage assert num_trees(3) == 5 # Possible BSTs with 3 nodes: [1,2,3], [1,3,2], [2,1,3], [3,1,2], [3,2,1] assert num_trees(1) == 1 # Only one BST possible with a single node # Edge cases assert num_trees(0) == 1 # Empty tree is one valid BST assert num_trees(19) == 1767263190 ``` # Tests: Your implementation will be tested on various cases, including but not limited to: - Small values of `n` to verify basic functionality. - Edge cases such as `n = 0` and `n = 1`. - Large values of `n` to check performance and correct implementation of the dynamic programming approach.","solution":"def num_trees(n: int) -> int: Calculate the number of unique Binary Search Trees (BSTs) that can be created with `n` distinct nodes. if n == 0: return 1 # By definition, there\'s one BST with 0 nodes: the empty tree # Create a list to store the number of unique BSTs for each count of nodes dp = [0] * (n + 1) dp[0] = 1 # Base case: there\'s one BST with 0 nodes (the empty tree) # Calculate the number of unique BSTs for each count of nodes from 1 to n for nodes in range(1, n + 1): total_trees = 0 for root in range(1, nodes + 1): left_trees = dp[root - 1] right_trees = dp[nodes - root] total_trees += left_trees * right_trees dp[nodes] = total_trees return dp[n]"},{"question":"# Prefix Free Binary Sequences **Scenario:** In computer networks and data compression, it is often useful to have a set of sequences where no sequence is a prefix of another. This prefix-free property is essential for efficient coding schemes and accurate data transmission. Your task is to determine if a given set of binary sequences has this prefix-free property. **Function Specification:** ```python def is_prefix_free(sequence_list: list) -> bool: Determines if the given list of binary sequences are prefix-free. Parameters: sequence_list (list): A list of binary sequences (strings) to be checked. Returns: bool: True if the set is prefix-free, False otherwise. Raises: TypeError: If the input is not a list of strings. Example: >>> is_prefix_free([\\"101\\", \\"110\\", \\"1111\\"]) True >>> is_prefix_free([\\"101\\", \\"10\\", \\"1111\\"]) False >>> is_prefix_free([\\"0\\", \\"1\\"]) True >>> is_prefix_free([\\"\\"]) True ``` **Requirements:** 1. The function should accept one parameter `sequence_list` which is expected to be a list of binary strings. 2. The function should validate the input: - Ensure that the input is a list. - Ensure that every element in the list is a binary string consisting of \'0\' and \'1\' characters. 3. The function should check if no sequence in the list is a prefix of another sequence. 4. Raise a `TypeError` if the input is not a list of strings. 5. Return `True` if the sequences are prefix-free, otherwise return `False`. **Constraints:** - The list may contain an empty string, which is a valid binary sequence. - Each binary string should be only composed of \'0\' and \'1\'. - An empty list should also be considered prefix-free. # Examples: ```python assert is_prefix_free([\\"101\\", \\"110\\", \\"1111\\"]) == True assert is_prefix_free([\\"101\\", \\"10\\", \\"1111\\"]) == False assert is_prefix_free([\\"0\\", \\"1\\"]) == True assert is_prefix_free([\\"\\"]) == True # An empty sequence does not conflict with other sequences assert is_prefix_free([\\"01\\", \\"011\\", \\"0111\\"]) == False assert is_prefix_free([]) == True # An empty list is considered prefix-free assert is_prefix_free([\\"101\\", 101, \\"1111\\"]) == False # Raises TypeError ```","solution":"def is_prefix_free(sequence_list: list) -> bool: Determines if the given list of binary sequences are prefix-free. Parameters: sequence_list (list): A list of binary sequences (strings) to be checked. Returns: bool: True if the set is prefix-free, False otherwise. Raises: TypeError: If the input is not a list of strings. # Input validation if not isinstance(sequence_list, list): raise TypeError(\\"Input should be a list of strings.\\") for seq in sequence_list: if not isinstance(seq, str) or not all(c in \'01\' for c in seq): raise TypeError(\\"All elements in the list should be binary strings.\\") # Check for prefix-free property sorted_sequences = sorted(sequence_list, key=len) for i in range(len(sorted_sequences)): for j in range(i + 1, len(sorted_sequences)): if sorted_sequences[j].startswith(sorted_sequences[i]): return False return True"},{"question":"# Problem Statement: Hexadecimal Color Converter You are building a custom web-based design tool that allows users to select colors for their designs. The tool stores colors internally as RGB (Red, Green, Blue) values but needs to display them to the user in hexadecimal format (e.g., #RRGGBB). To achieve this, you need to implement two functions, `rgb_to_hex` and `hex_to_rgb`, that convert between RGB and hexadecimal color representations. **Objective:** Implement two functions, `rgb_to_hex` and `hex_to_rgb`. The `rgb_to_hex` function should take three integers representing the red, green, and blue color components and return a hexadecimal string. The `hex_to_rgb` function should take a hexadecimal color string and return a tuple containing the red, green, and blue components as integers. # Function 1: rgb_to_hex **Input:** - `r: int` - An integer representing the red component (0 to 255). - `g: int` - An integer representing the green component (0 to 255). - `b: int` - An integer representing the blue component (0 to 255). **Output:** - `hex_color: str` - The hexadecimal string representation of the color (e.g., \\"#RRGGBB\\"). # Function 2: hex_to_rgb **Input:** - `hex_color: str` - A hexadecimal string representing the color (e.g., \\"#RRGGBB\\"). **Output:** - `rgb: tuple[int, int, int]` - A tuple containing the red, green, and blue components as integers. # Constraints: 1. The values for RGB input to `rgb_to_hex` must be integers in the range 0 to 255. 2. The input to `hex_to_rgb` must be a valid hexadecimal color string starting with \'#\' and followed by six hexadecimal digits. 3. Your implementation should handle edge cases such as minimum and maximum RGB values and proper format validation for the hexadecimal string. # Example: ```python def rgb_to_hex(r: int, g: int, b: int) -> str: # Your implementation here pass def hex_to_rgb(hex_color: str) -> tuple[int, int, int]: # Your implementation here pass # Test cases: # RGB to Hex assert rgb_to_hex(255, 0, 0) == \\"#FF0000\\" assert rgb_to_hex(0, 255, 0) == \\"#00FF00\\" assert rgb_to_hex(0, 0, 255) == \\"#0000FF\\" assert rgb_to_hex(255, 255, 255) == \\"#FFFFFF\\" assert rgb_to_hex(0, 0, 0) == \\"#000000\\" # Hex to RGB assert hex_to_rgb(\\"#FF0000\\") == (255, 0, 0) assert hex_to_rgb(\\"#00FF00\\") == (0, 255, 0) assert hex_to_rgb(\\"#0000FF\\") == (0, 0, 255) assert hex_to_rgb(\\"#FFFFFF\\") == (255, 255, 255) assert hex_to_rgb(\\"#000000\\") == (0, 0, 0) ``` Your solution should be accurate, efficiently converting between RGB and hexadecimal formats, and should include proper validation and handling of edge cases. **Good Luck!**","solution":"def rgb_to_hex(r, g, b): Converts RGB values to a hexadecimal string. Args: r (int): Red component (0 - 255) g (int): Green component (0 - 255) b (int): Blue component (0 - 255) Returns: str: Hexadecimal string of the color. return f\\"#{r:02X}{g:02X}{b:02X}\\" def hex_to_rgb(hex_color): Converts a hexadecimal string to RGB values. Args: hex_color (str): Hexadecimal color string (e.g., \\"#RRGGBB\\") Returns: tuple: A tuple (r, g, b) with each component in the range 0 - 255. hex_color = hex_color.lstrip(\'#\') return tuple(int(hex_color[i:i+2], 16) for i in (0, 2, 4))"},{"question":"# Question: Implement a Stack with Minimum Operation Using Two Stacks You are tasked with implementing a stack data structure that supports the following operations efficiently: - `push(x)` - Push element `x` onto the stack. - `pop()` - Remove the element on the top of the stack. - `top()` - Get the top element. - `get_min()` - Retrieve the minimum element in the stack. Scenario For this task, you will create a class `MinStack` that uses two separate stacks internally. One stack will maintain the regular stack data (`main_stack`), and the other stack (`min_stack`) will keep track of the minimum values. Your implementation should ensure that all operations run in constant time ( O(1) ). Specification * **Class Name:** `MinStack` * **Operations:** * `push(x: int|float) -> None` - Push element `x` onto the stack. * `pop() -> None` - Remove the element on the top of the stack. * `top() -> int|float` - Get the top element. * `get_min() -> int|float` - Retrieve the minimum element in the stack. Constraints: * Only non-empty stacks will have `pop()`, `top()`, or `get_min()` called. * Elements pushed to the stack will be numerical (integers or floating-point numbers). Example Usage: ```python class MinStack: def __init__(self): self.main_stack = [] self.min_stack = [] def push(self, x: int|float) -> None: self.main_stack.append(x) if not self.min_stack or x <= self.min_stack[-1]: self.min_stack.append(x) def pop(self) -> None: if self.main_stack: popped = self.main_stack.pop() if popped == self.min_stack[-1]: self.min_stack.pop() def top(self) -> int|float: if self.main_stack: return self.main_stack[-1] def get_min(self) -> int|float: if self.min_stack: return self.min_stack[-1] # Example: min_stack = MinStack() min_stack.push(-2) min_stack.push(0) min_stack.push(-3) print(min_stack.get_min()) # Should output -3 min_stack.pop() print(min_stack.top()) # Should output 0 print(min_stack.get_min()) # Should output -2 ``` Performance Requirements: * All operations (`push`, `pop`, `top`, `get_min`) should run in constant time (O(1)). Ensure your implementation handles edge cases correctly, and adheres to the constraints for efficient performance.","solution":"class MinStack: def __init__(self): self.main_stack = [] self.min_stack = [] def push(self, x: int|float) -> None: self.main_stack.append(x) if not self.min_stack or x <= self.min_stack[-1]: self.min_stack.append(x) def pop(self) -> None: if self.main_stack: popped = self.main_stack.pop() if popped == self.min_stack[-1]: self.min_stack.pop() def top(self) -> int|float: if self.main_stack: return self.main_stack[-1] def get_min(self) -> int|float: if self.min_stack: return self.min_stack[-1]"},{"question":"# Problem Statement You need to determine the number of rectangles within a grid formed by the points on a Cartesian plane from coordinates (0,0) to (n,m). A rectangle is defined by two pairs of parallel line segments such that its diagonals are perpendicular and equal in length. # Function Signature ```python def count_rectangles(n: int, m: int) -> int: ``` # Input - **n**: An integer representing the number of divisions along the x-axis (1 ≤ n ≤ 1000). - **m**: An integer representing the number of divisions along the y-axis (1 ≤ m ≤ 1000). # Output - Returns an integer representing the number of rectangles that can be formed within the specified grid. # Constraints - The grid is defined by (x, y) coordinates where 0 ≤ x ≤ n and 0 ≤ y ≤ m. - Rectangles are counted without distinguishing their orientation since they are defined by the coordinate lines. # Example ```python print(count_rectangles(2, 3)) # Output: 18 ``` # Requirements 1. Analyze the Cartesian plane grid defined by `n` and `m`. 2. Consider each set of parallel horizontal and vertical lines to identify potential rectangle corners. 3. Ensure the solution counts every possible rectangle efficiently. **Note**: Pay careful attention to combinatorial aspects and optimize the calculation of the total number of rectangles by not manually enumerating all possible rectangles but rather leveraging mathematical relationships and properties of combinatorics to achieve an optimal solution.","solution":"def count_rectangles(n: int, m: int) -> int: Return the number of rectangles that can be formed within a grid of size (n+1) x (m+1). The formula for counting the number of rectangles is based on combinatorics: A rectangle is defined by choosing two horizontal and two vertical lines from the (n+1) horizontal lines and (m+1) vertical lines, respectively. Count rectangles using: C(n+1, 2) * C(m+1, 2) where C(k, 2) = k * (k-1) // 2 is the combination formula. :param n: Number of divisions along the x-axis. :param m: Number of divisions along the y-axis. :return: Number of rectangles in the grid. return (n * (n + 1) // 2) * (m * (m + 1) // 2) # Example usage: print(count_rectangles(2, 3)) # Output: 18"},{"question":"Problem A \\"happy number\\" is defined as a number which eventually reaches 1 when replaced by the sum of the square of each digit. If a number never reaches 1, it is referred to as an \\"unhappy number\\". Your task is to write a function that checks multiple numbers for happiness and returns the largest happy number in the list. # Function Signature ```python def largest_happy_number(numbers: List[int]) -> int: pass ``` # Input: * `numbers (List[int])`: A list of integers to check for happiness. # Output: * `int`: The largest happy number in the list. If no happy numbers are found, return `-1`. # Constraints: * `1 <= len(numbers) <= 10^5` * `1 <= numbers[i] <= 10^6` # Performance Requirements: * Ensure an efficient check for happy numbers to handle the provided list size. # Example: ```python assert largest_happy_number([19, 2, 20, 7, 28, 125]) == 28 ``` Explanation: * Among the given numbers, 19 and 28 are happy numbers as they eventually reach 1. The largest of these is 28. # Notes: * You may use a helper function to determine whether a number is \\"happy\\" by repeating the sum-of-squares process until the number reaches 1 or falls into a cycle that does not include 1.","solution":"def is_happy_number(n: int) -> bool: seen = set() while n != 1 and n not in seen: seen.add(n) n = sum(int(digit) ** 2 for digit in str(n)) return n == 1 def largest_happy_number(numbers): happy_numbers = [num for num in numbers if is_happy_number(num)] if not happy_numbers: return -1 return max(happy_numbers)"},{"question":"# Longest Common Subsequence (LCS) Calculation You are asked to implement the algorithm to find the length of the Longest Common Subsequence (LCS) between two strings. The LCS problem is to find the longest subsequence common to two sequences. A subsequence is a sequence derived by deleting some or no elements without changing the order of the remaining elements. Function Specifications: 1. Implement the function `lcs_length(X: str, Y: str) -> int`. * **Input**: * `X`: A string representing the first sequence. * `Y`: A string representing the second sequence. * **Output**: * Returns an integer representing the length of the longest common subsequence between X and Y. 2. Implement a main function to read the inputs and print the results. Example: ```python X = \\"AGGTAB\\" Y = \\"GXTXAYB\\" length = lcs_length(X, Y) print(f\\"The length of the Longest Common Subsequence is {length}\\") # Output: # The length of the Longest Common Subsequence is 4 ``` In this example, the LCS is \\"GTAB\\" which has a length of 4. Constraints: * 1 ≤ length of X, Y ≤ 1000 * X and Y consist of uppercase English alphabets. Notes: * Use dynamic programming to optimize the calculation of the LCS. * Ensure your implementation handles edge cases such as empty strings or no common subsequence. * Test with diverse scenarios for comprehensive validation.","solution":"def lcs_length(X: str, Y: str) -> int: Returns the length of the Longest Common Subsequence (LCS) of X and Y. m = len(X) n = len(Y) # Create a 2D table to store lengths of LCS of substrings dp = [[0] * (n + 1) for _ in range(m + 1)] # Fill dp array from bottom up for i in range(m + 1): for j in range(n + 1): if i == 0 or j == 0: dp[i][j] = 0 elif X[i - 1] == Y[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[m][n]"},{"question":"# Coding Assessment Question: Computing the Longest Palindromic Subsequence **Scenario**: You are developing a text analysis application that needs to determine structural patterns within texts. One important feature is to identify the longest palindromic subsequence within a given string. This feature will help in analyzing the palindromic structures, which can be crucial in certain text analytics tasks. **Problem Statement**: Write a function `longest_palindromic_subsequence(s: str) -> int` that computes the length of the longest palindromic subsequence in the input string `s`. **Input**: - `s`: A string consisting of lowercase and uppercase ASCII characters. **Output**: - An integer representing the length of the longest palindromic subsequence within the input string. **Constraints**: - `1 <= len(s) <= 1000` **Performance Requirements**: - The implementation should be efficient enough to handle strings of length up to 1000 within a reasonable time frame. **Example**: Consider the input string `\\"bbbab\\"`, the function call `longest_palindromic_subsequence(\\"bbbab\\")` should return `4`, since the longest palindromic subsequence is `\\"bbbb\\"`. For another input string `\\"cbbd\\"`, the function call `longest_palindromic_subsequence(\\"cbbd\\")` should return `2`, since the longest palindromic subsequence is `\\"bb\\"`. **Additional Notes**: - The longest palindromic subsequence is not necessarily contiguous, but it should read the same backward and forward. - Consider using dynamic programming to achieve an efficient solution. - Edge cases such as a single-character string or an entirely non-palindromic string should be handled gracefully. # Function Signature ```python def longest_palindromic_subsequence(s: str) -> int: # Your code here ``` # Function Example ```python assert longest_palindromic_subsequence(\\"bbbab\\") == 4 assert longest_palindromic_subsequence(\\"cbbd\\") == 2 ```","solution":"def longest_palindromic_subsequence(s: str) -> int: Computes the length of the longest palindromic subsequence in the input string s. n = len(s) # Create a 2D array dp to store the lengths of palindromic subsequences. dp = [[0 for _ in range(n)] for _ in range(n)] # Each character on its own is a palindrome of length 1. for i in range(n): dp[i][i] = 1 # Fill the dp array. for length in range(2, n + 1): for i in range(n - length + 1): j = i + length - 1 if s[i] == s[j] and length == 2: dp[i][j] = 2 elif s[i] == s[j]: dp[i][j] = dp[i + 1][j - 1] + 2 else: dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]) return dp[0][n - 1]"},{"question":"# Problem Statement: You are given an array of integers and a target integer. Your task is to determine if there are two distinct indices `i` and `j` in the array such that the elements at these indices sum up to the target integer. **Function Signature**: ```python def two_sum(nums: List[int], target: int) -> Tuple[int, int]: This function returns a tuple of two integers representing the indices of the elements in the array that sum up to the given target. If there are no such indices, return an empty tuple. ``` # Input: * A list of integers `nums` with length `n` where `2 <= n <= 10^6`. * An integer `target` where `-10^9 <= target <= 10^9`. # Output: * A tuple of two integers representing the indices of the elements in the array that sum up to the target. # Constraints: * The list of integers will contain unique elements. * The function should run in linear time O(n), with respect to the length of the array. # Examples: ```python assert set(two_sum([2, 7, 11, 15], 9)) == set((0, 1)) assert set(two_sum([3, 2, 4], 6)) == set((1, 2)) assert set(two_sum([3, 3], 6)) == set((0, 1)) assert two_sum([1, 2, 3, 4, 5], 10) == () assert set(two_sum([10, 15, 3, 7], 17)) == set((0, 3)) ``` # Explanation of Examples: 1. For the array `[2, 7, 11, 15]` and target `9`, the indices 0 and 1 refer to the elements `2` and `7`, which sum up to 9. 2. For the array `[3, 2, 4]` and target `6`, the indices 1 and 2 refer to the elements `2` and `4`. 3. For the array `[3, 3]` and target `6`, the indices 0 and 1 refer to the elements `3` and `3`. 4. For the array `[1, 2, 3, 4, 5]` and target `10`, there are no such indices where elements sum up to 10. 5. For the array `[10, 15, 3, 7]` and target `17`, the indices 0 and 3 refer to the elements `10` and `7`. # Notes: * Ensure that the indices are distinct, meaning `i != j`. * Utilize a hash map to achieve the desired time complexity efficiently.","solution":"from typing import List, Tuple def two_sum(nums: List[int], target: int) -> Tuple[int, int]: This function returns a tuple of two integers representing the indices of the elements in the array that sum up to the given target. If there are no such indices, return an empty tuple. num_indices = {} for i, num in enumerate(nums): complement = target - num if complement in num_indices: return (num_indices[complement], i) num_indices[num] = i return ()"},{"question":"# File Parser for Config Data # Background In many software systems, configuration files are used to store settings and options that influence the behavior of the software. These configuration files are often written in a simple key-value pair format. For this problem, we will assume a configuration file format where each line represents a key-value pair separated by an equal sign (`=`). Lines starting with a hash (`#`) are comments and should be ignored. Empty lines should also be ignored. # Problem You are required to write a function `parse_config(file_path: str) -> dict` that reads a configuration file from the specified path and returns a dictionary containing the configuration key-value pairs. # Inputs - `file_path`: A string representing the path to the configuration file. # Outputs A dictionary where keys are the configuration keys (strings) and values are the configuration values (strings). # Constraints - Keys and values are non-empty strings consisting of alphanumeric characters and underscores. - Each key should be unique within the configuration file. - The configuration file should be properly formatted (no need to handle malformed files for this problem). - Ignore lines starting with a hash (`#`) and empty lines. # Examples Assume the configuration file at `config.txt` contains the following content: ```text # This is a comment server_host=localhost server_port=8080 # Another comment log_level=DEBUG max_connections=100 ``` ```python assert parse_config(\'config.txt\') == { \'server_host\': \'localhost\', \'server_port\': \'8080\', \'log_level\': \'DEBUG\', \'max_connections\': \'100\' } ``` **Your task** is to implement the `parse_config` function that reads the configuration file and returns the dictionary accurately. Ensure that your function: - Reads the file correctly. - Ignores comments and empty lines. - Parses key-value pairs accurately and returns them in the correct format.","solution":"def parse_config(file_path: str) -> dict: Parses a configuration file and returns a dictionary of key-value pairs. config = {} with open(file_path, \'r\') as file: for line in file: line = line.strip() if line and not line.startswith(\'#\'): key, value = line.split(\'=\', 1) config[key.strip()] = value.strip() return config"},{"question":"# Implementing a Trie with Autocomplete Functionality Scenario You are developing a predictive text feature for a messaging application. The goal is to suggest possible completions as the user types each word. To achieve this, you will implement a Trie data structure which supports efficient word insertion and prefix-based lookups. Objective * **Implement**: Implement a Trie (prefix tree) class with methods to insert words and find autocomplete suggestions. * **Test**: Write test cases to ensure your implementation is correct. # Requirements `Trie` Class 1. **Init method**: Initialize the class with an empty root node. ```python def __init__(self): pass ``` 2. **Insert method**: Implement a method to add a word to the trie. ```python def insert(self, word: str): pass ``` 3. **Autocomplete method**: Implement a method to return a list of all words in the trie that start with a given prefix. ```python def autocomplete(self, prefix: str) -> list: pass ``` # Example Usage ```python # Initialize the trie trie = Trie() # Insert words trie.insert(\\"hello\\") trie.insert(\\"hell\\") trie.insert(\\"heaven\\") trie.insert(\\"heavy\\") # Autocomplete suggestions assert trie.autocomplete(\\"he\\") == [\\"hello\\", \\"hell\\", \\"heaven\\", \\"heavy\\"] assert trie.autocomplete(\\"hell\\") == [\\"hello\\", \\"hell\\"] assert trie.autocomplete(\\"heav\\") == [\\"heaven\\", \\"heavy\\"] assert trie.autocomplete(\\"ho\\") == [] assert trie.autocomplete(\\"\\") == [\\"hello\\", \\"hell\\", \\"heaven\\", \\"heavy\\"] ``` # Constraints * 1 ≤ len(word) ≤ 100 * The words and prefix contain only lowercase English letters * The total number of words in the Trie will not exceed 10^5 # Performance Requirements Your solution must: * Insert a word in O(k) time, where k is the length of the word. * Autocomplete suggestions should be fetched in O(n + m) time, where n is the number of matching words and m is the length of the longest matching word. # Instructions 1. Implement the class and its methods as described. 2. Create a suite of test cases to verify the correctness of your implementation. 3. Ensure your implementation is efficient and can handle edge cases.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str): node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def autocomplete(self, prefix: str) -> list: def dfs(node, prefix, results): if node.is_end_of_word: results.append(prefix) for char, child_node in node.children.items(): dfs(child_node, prefix + char, results) node = self.root for char in prefix: if char not in node.children: return [] node = node.children[char] results = [] dfs(node, prefix, results) return results"},{"question":"# Problem Statement You are given a list of integers, and your task is to reorganize the list such that all even numbers appear before all odd numbers, while maintaining the relative order of even and odd numbers. Write a function `reorderEvenOdd(arr: List[int]) -> List[int]` that returns the reordered list. # Input Format - A list of integers `arr` of length `n` (1 ≤ n ≤ 10^5). # Output Format - A list of integers where all even numbers appear before all odd numbers, while preserving their original order. # Example ```python >>> reorderEvenOdd([3, 1, 2, 4]) [2, 4, 3, 1] >>> reorderEvenOdd([1, 2, 3, 4, 5, 6]) [2, 4, 6, 1, 3, 5] >>> reorderEvenOdd([4, 2, 1, 3]) [4, 2, 1, 3] ``` # Constraints - The function should work efficiently for lists up to length 100,000. - The relative order of the even and odd numbers in the original list must be preserved. # Guidelines - Initialize two separate lists to collect even and odd numbers. - Iterate through the input list, appending each number to the appropriate list based on whether it is even or odd. - Concatenate the even and odd lists to form the final reordered list.","solution":"from typing import List def reorderEvenOdd(arr: List[int]) -> List[int]: Reorganizes the list such that all even numbers come before all the odd numbers while preserving their relative order. evens = [] odds = [] for num in arr: if num % 2 == 0: evens.append(num) else: odds.append(num) return evens + odds"},{"question":"# Word Frequency Counter Context You are tasked with creating a tool that analyzes the frequency of words in a given text. The tool should be able to add new text, compute the frequency of each word, and return the most frequently occurring word efficiently. Requirements Write a class `WordFrequencyCounter` with the following methods: 1. **`__init__(self)`**: Initialize your word frequency counter. This method should properly initialize any data structures used to store word counts. 2. **`add_text(self, text: str)`**: Add new text to the word frequency counter. This method should update the internal word counts. 3. **`most_frequent_word(self) -> str`**: Return the word with the highest frequency. If there are multiple words with the same highest frequency, return the one that appears first in alphabetical order. 4. **`__len__(self) -> int`**: Return the number of unique words currently in the text. Input and Output * **Input**: * `add_text` method should accept a string `text`. * `most_frequent_word` method should return a string. * **Output**: * `__len__` method should return the number of unique words. * **Constraints**: * The text will only contain alphanumeric characters and spaces. * Words are case insensitive (\\"Word\\" and \\"word\\" are considered the same). * The total length of the text passed to the `add_text` method will not exceed (10^6) characters. Example ```python counter = WordFrequencyCounter() counter.add_text(\\"apple banana apple\\") assert counter.most_frequent_word() == \\"apple\\" assert len(counter) == 2 counter.add_text(\\"banana banana apple\\") assert counter.most_frequent_word() == \\"banana\\" assert len(counter) == 2 ```","solution":"class WordFrequencyCounter: def __init__(self): # Initialize an empty dictionary to store word counts self.word_count = {} def add_text(self, text: str): # Process the text, split into words, and update word counts words = text.lower().split() for word in words: if word in self.word_count: self.word_count[word] += 1 else: self.word_count[word] = 1 def most_frequent_word(self) -> str: # Find the word with the highest frequency if not self.word_count: return \\"\\" max_count = max(self.word_count.values()) most_freq_words = [word for word, count in self.word_count.items() if count == max_count] most_freq_words.sort() return most_freq_words[0] def __len__(self) -> int: # Return the number of unique words return len(self.word_count)"},{"question":"# Problem Statement: You are tasked with implementing a function that normalizes a given 2D NumPy array (matrix) such that the values in each row lie between 0 and 1. This is often a crucial step in data preprocessing for machine learning models. The normalization for each element in a row is done as follows: [ text{normalized_value} = frac{text{value} - text{row_min}}{text{row_max} - text{row_min}} ] where ( text{row_min} ) is the minimum value in the row, and ( text{row_max} ) is the maximum value in the row. Implement the function in Python to perform this row-wise normalization. # Function Signature: ```python def normalize_rows(matrix: np.ndarray) -> np.ndarray: Normalizes each row of the given 2D array so that the values range between 0 and 1. Parameters: matrix (np.ndarray): The input 2D array to be normalized. Returns: np.ndarray: The row-wise normalized 2D array. ``` # Input: - A 2D array of floating-point numbers representing some arbitrary data that needs to be normalized. - Constraints: The input 2D array can have dimensions up to (1000 times 1000). Each element will be in the range ([-1000, 1000]). # Output: - A 2D array of the same shape as the input, with each row\'s elements normalized to the range [0, 1]. # Examples: ```python import numpy as np # Example 1 input_matrix = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) print(normalize_rows(input_matrix)) # Expected Output: [[0. 0.5 1. ] # [0. 0.5 1. ] # [0. 0.5 1. ]] # Example 2 input_matrix = np.array([[10, -10, 0], [10, 10, 10], [-5, 5, 0]]) print(normalize_rows(input_matrix)) # Expected Output: [[1. 0. 0.5] # [0. 0. 0. ] # [0. 1. 0.5]] ``` **Note**: Ensure the solution handles edge cases, such as rows where all elements are the same, and leverages NumPy\'s functionalities for efficient computation.","solution":"import numpy as np def normalize_rows(matrix: np.ndarray) -> np.ndarray: Normalizes each row of the given 2D array so that the values range between 0 and 1. Parameters: matrix (np.ndarray): The input 2D array to be normalized. Returns: np.ndarray: The row-wise normalized 2D array. # Calculate the min and max of each row row_min = matrix.min(axis=1, keepdims=True) row_max = matrix.max(axis=1, keepdims=True) # Avoid division by zero in the case where all elements in the row are the same row_range = row_max - row_min row_range[row_range == 0] = 1 # Normalize the matrix normalized_matrix = (matrix - row_min) / row_range return normalized_matrix"},{"question":"# Question: Graph Traversal and Connected Components Context Graph traversal algorithms are fundamental in many applications of mathematics, computer science, and network analysis. Breadth-First Search (BFS) and Depth-First Search (DFS) are two common algorithms used to traverse graphs. Identifying connected components in a graph is an important application of these algorithms, especially when analyzing social networks, web pages, and other interconnected systems. Problem Write a function `find_connected_components(n: int, edges: list[tuple[int, int]]) -> list[list[int]]` that takes: - `n` (int): The number of nodes in the graph, labeled from 0 to n-1. - `edges` (list[tuple[int, int]]): A list where each tuple represents an undirected edge between two nodes. The function should output a list of connected components, where each connected component is represented as a list of nodes. The nodes within each connected component list should be in ascending order. Input and Output Format - **Input**: - An integer `n` representing the number of nodes. - A list `edges` containing tuples, each representing an undirected edge between two nodes. - **Output**: - A list of connected components, where each connected component is a list of node labels sorted in ascending order. Constraints - The number of nodes `n` will range from 1 to 1000. - The number of edges will range from 0 to 5000. - Nodes are labeled from 0 to n-1. Example ```python from typing import List, Tuple def find_connected_components(n: int, edges: List[Tuple[int, int]]) -> List[List[int]]: # Your implementation here # Example Usage n = 5 edges = [(0, 1), (1, 2), (3, 4)] print(find_connected_components(n, edges)) # Output: [[0, 1, 2], [3, 4]] ``` Clarify that the function implementations should take care of: - Constructing the graph from the given nodes and edges. - Using either BFS or DFS to explore all nodes and identify connected components. - Ensuring that each connected component\'s nodes are sorted in ascending order. Ensure your implementation is both efficient and scalable, considering edge cases and performance implications.","solution":"from typing import List, Tuple from collections import defaultdict, deque def find_connected_components(n: int, edges: List[Tuple[int, int]]) -> List[List[int]]: def bfs(start): queue = deque([start]) component = [] visited.add(start) while queue: node = queue.popleft() component.append(node) for neighbor in graph[node]: if neighbor not in visited: visited.add(neighbor) queue.append(neighbor) return sorted(component) # Initialize the graph as an adjacency list graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) visited = set() components = [] # Traverse all nodes and perform BFS for each unvisited node for node in range(n): if node not in visited: component = bfs(node) components.append(component) return sorted(components)"},{"question":"# Coding Challenge **Scenario**: You are given an array of integers, which represents the heights of buildings in a city, arranged in a row. Each element in the array is the height of a building. Your task is to find the area of the largest rectangle that can be formed by choosing buildings such that the rectangle is formed using buildings from consecutive positions in the array and their heights are limited by the shortest building in those positions. **Function Signature**: ```python def largest_rectangle_area(heights: list[int]) -> int: pass ``` # Input * `heights` (list of int): A list of integers representing the heights of the buildings. # Output * (int): The area of the largest rectangle that can be formed. # Constraints * (1 leq text{len(heights)} leq 100000) * (0 leq text{heights[i]} leq 10000) # Examples **Example 1** * Input: ```python heights = [2, 1, 5, 6, 2, 3] ``` * Output: `10` **Example 2** * Input: ```python heights = [2, 4] ``` * Output: `4` # Guidelines: * Implement a function that calculates the area of the largest rectangle using a stack-based approach. * Optimize the time complexity to O(N). * Consider edge cases, such as an array with all elements being zero or arrays with varying heights. * Ensure your solution efficiently handles the upper constraints.","solution":"def largest_rectangle_area(heights: list[int]) -> int: Returns the area of the largest rectangle that can be formed by choosing buildings such that the rectangle is formed using buildings from consecutive positions in the array and their heights are limited by the shortest building. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index) max_area = max(max_area, area) return max_area"},{"question":"Problem Statement You are tasked with writing a function that makes use of recursion to solve the following problem: find the number of distinct ways to climb a staircase with `n` steps, where you can either take one step or two steps at a time. # Function Signature: ```python def count_ways_to_climb(n: int) -> int: pass ``` # Input: * `n`: An integer representing the number of steps, 0 <= n <= 45 # Output: * Returns the number of distinct ways to climb the staircase. # Examples: ```python assert count_ways_to_climb(0) == 1 assert count_ways_to_climb(1) == 1 assert count_ways_to_climb(2) == 2 assert count_ways_to_climb(3) == 3 assert count_ways_to_climb(4) == 5 ``` # Constraints and Requirements: 1. Your solution should use recursion. 2. Consider edge cases where the number of steps is zero or one. 3. Aim for a solution that efficiently computes the number of ways using recursion and memoization. 4. Include error checking and handle possible exceptions that might arise. # Note: This problem is similar to the Fibonacci sequence, where each number is the sum of the two preceding ones, starting from 0 and 1. In this case, the number of ways to climb `n` steps is equivalent to the `n`-th Fibonacci number. Utilize memoization to optimize the recursive calls and reduce time complexity.","solution":"def count_ways_to_climb(n: int, memo=None) -> int: if memo is None: memo = {} if n in memo: return memo[n] if n == 0: return 1 if n == 1: return 1 memo[n] = count_ways_to_climb(n - 1, memo) + count_ways_to_climb(n - 2, memo) return memo[n]"},{"question":"# Coding Assessment Question Context: You are working on an automated system for evaluating arithmetic expressions. The system needs to handle inputs containing integers, the basic arithmetic operators (`+`, `-`, `*`, `/`), and parentheses to denote operation precedence. Task: Implement the function `evaluate_expression`, which takes a string representing an arithmetic expression and returns its value as a float. The function must correctly handle operator precedence and parenthetical grouping. Function Signature ```python def evaluate_expression(expression: str) -> float: Evaluates an arithmetic expression and returns its value. Args: expression (str): The string representing the arithmetic expression. Returns: float: The calculated value of the expression. ``` Expected Inputs and Outputs - Input: A string `expression` containing a valid arithmetic expression. - Output: A float representing the result of the evaluated expression. Constraints - The expression will contain only integers, the operators `+`, `-`, `*`, `/`, and parentheses `()`. - You may assume the input expression is well-formed and contains no invalid characters. - Implement proper handling of operator precedence and associativity. - Division by zero should raise a `ZeroDivisionError`. Example ```python assert evaluate_expression(\\"3 + 5 * 2\\") == 13.0 assert evaluate_expression(\\"(2 - 3) * 4\\") == -4.0 assert evaluate_expression(\\"2 * (3 + 4) / (7 - 3) + 1\\") == 4.5 ``` Notes - You are allowed to use helper functions if necessary. - Consider edge cases such as nested parentheses and operator precedence. - Testing your implementation with various expressions will ensure correctness.","solution":"def evaluate_expression(expression: str) -> float: Evaluates an arithmetic expression and returns its value. Args: expression (str): The string representing the arithmetic expression. Returns: float: The calculated value of the expression. import re # Remove any spaces in the expression for easier processing expression = expression.replace(\' \', \'\') def parse_expression(tokens): def parse_term(tokens): term, tokens = parse_factor(tokens) while tokens and tokens[0] in (\'*\', \'/\'): op = tokens.pop(0) factor, tokens = parse_factor(tokens) if op == \'*\': term *= factor else: term /= factor return term, tokens def parse_factor(tokens): if tokens[0] == \'(\': tokens.pop(0) expr, tokens = parse_expression(tokens) assert tokens.pop(0) == \')\' return expr, tokens match = re.match(r\'d+\', tokens.pop(0)) return float(match.group()), tokens term, tokens = parse_term(tokens) while tokens and tokens[0] in (\'+\', \'-\'): op = tokens.pop(0) term_next, tokens = parse_term(tokens) if op == \'+\': term += term_next else: term -= term_next return term, tokens def tokenize(expression): token_spec = [ (\'NUMBER\', r\'d+\'), (\'PLUS\', r\'+\'), (\'MINUS\', r\'-\'), (\'TIMES\', r\'*\'), (\'DIVIDE\', r\'/\'), (\'LPAREN\', r\'(\'), (\'RPAREN\', r\')\'), ] tok_regex = \'|\'.join(f\'(?P<{pair[0]}>{pair[1]})\' for pair in token_spec) for match in re.finditer(tok_regex, expression): yield match.group() tokens = list(tokenize(expression)) result, _ = parse_expression(tokens) return result"},{"question":"# Question: You are tasked with enhancing the efficiency of the merge step in the Merge Sort algorithm. Specifically, you need to optimize the `merge` function to minimize the number of comparisons made during the merge process. Function Signature: ```python def merge_optimized(left: List[int], right: List[int]) -> List[int]: ``` # Requirements: 1. Optimize the `merge` function to reduce the number of comparisons. 2. Return the merged list while maintaining sorted order. 3. Efficiently handle edge cases such as: - One or both input lists being empty. 4. Validate correctness using the provided test cases and create additional tests if necessary. # Expected input and output formats: - **Input**: Two sorted lists of integers. - **Output**: A merged list of integers, maintaining sorted order. # Performance requirements: - **Aim for O(n + m)** time complexity for `merge_optimized`, where `n` and `m` are the lengths of the input lists. # Sample Test Cases: ```python assert merge_optimized([1, 3, 5], [2, 4, 6]) == [1, 2, 3, 4, 5, 6] assert merge_optimized([1, 2], [3, 4, 5]) == [1, 2, 3, 4, 5] assert merge_optimized([], [1, 2, 3]) == [1, 2, 3] assert merge_optimized([7, 8, 9], []) == [7, 8, 9] assert merge_optimized([], []) == [] ``` # Additional Context: - Leverage efficient merging strategies and consider using additional data structures if it significantly improves the performance. - Ensure that no extraneous operations are performed that might increase time complexity.","solution":"def merge_optimized(left, right): Merge two sorted lists into a single sorted list, optimizing the number of comparisons. Parameters: left (List[int]): A sorted list of integers. right (List[int]): A sorted list of integers. Returns: List[int]: A single merged and sorted list. merged = [] i, j = 0, 0 len_left, len_right = len(left), len(right) while i < len_left and j < len_right: if left[i] <= right[j]: merged.append(left[i]) i += 1 else: merged.append(right[j]) j += 1 # This concatenation minimizes the number of comparisons if i < len_left: merged.extend(left[i:]) if j < len_right: merged.extend(right[j:]) return merged"},{"question":"# Problem Statement A perfect square is an integer that is the square of some integer. For example, 1, 4, 9, and 16 are perfect squares because: - 1 = 1 * 1 - 4 = 2 * 2 - 9 = 3 * 3 - 16 = 4 * 4 Write a function `is_perfect_square` that takes an integer `x` as input and returns `True` if the number is a perfect square, otherwise returns `False`. The function should handle edge cases, such as when `x` is zero or negative gracefully. Input Format - An integer `x` which needs to be checked if it is a perfect square. Output Format - A boolean value: `True` if `x` is a perfect square, otherwise `False`. Constraints - The function should be efficient and handle up to large values of `x` within practical limits. - You are not allowed to use the `sqrt` function from Python\'s math module. Example ```python assert is_perfect_square(16) == True assert is_perfect_square(14) == False assert is_perfect_square(1) == True assert is_perfect_square(0) == True assert is_perfect_square(-4) == False assert is_perfect_square(25) == True assert is_perfect_square(26) == False ```","solution":"def is_perfect_square(x): Returns True if x is a perfect square, otherwise False. Handles edge cases for zero and negative numbers. if x < 0: return False if x == 0: return True left, right = 1, x while left <= right: mid = (left + right) // 2 if mid * mid == x: return True elif mid * mid < x: left = mid + 1 else: right = mid - 1 return False"},{"question":"# Data Integrity Check for Multi-File System You are managing a distributed file system where file names and their associated checksums are periodically recorded to ensure data integrity. Write a function to verify that all files across several servers maintain their integrity. Specifically, ensure that for a given set of files and their checksums recorded over multiple servers, each file\'s recorded checksum is consistent across all servers. # Function Signature ```python def verify_checksums(file_records: dict[str, list[tuple[str, int]]]) -> list[str]: Returns a list of file names with inconsistent checksums. ``` # Input * A dictionary `file_records`, where each key is a string representing a file name, and its value is a list of tuples. Each tuple contains: * A string representing the server ID. * An integer representing the checksum of the file on that server. # Output * A list of strings, where each string is the name of a file that has inconsistent checksums across servers. # Constraints * Each file can be present in 1 to 50 servers. * There can be up to 100 different file names. * Server IDs will be unique strings. # Example ```python >>> verify_checksums({ ... \'file1.txt\': [(\'server1\', 1234), (\'server2\', 1234), (\'server3\', 5678)], ... \'file2.txt\': [(\'server1\', 2345), (\'server2\', 2345)], ... \'file3.txt\': [(\'server1\', 3456), (\'server2\', 3457), (\'server3\', 3456)] ... }) [\'file1.txt\', \'file3.txt\'] >>> verify_checksums({ ... \'image.png\': [(\'serverA\', 9999), (\'serverB\', 9999)], ... \'document.pdf\': [(\'server1\', 1111), (\'server2\', 2222), (\'server3\', 1111)], ... \'archive.zip\': [(\'serverX\', 5555), (\'serverY\', 5555)] ... }) [\'document.pdf\'] ``` # Scenario As a file manager for a large, distributed system, maintaining data integrity is critical. Your goal is to write a function that inspects the checksums of files stored on multiple servers to identify any discrepancies, ensuring reliable data storage and transfer across the network.","solution":"def verify_checksums(file_records): Returns a list of file names with inconsistent checksums. inconsistent_files = [] for file_name, records in file_records.items(): # Initialize a set to collect all unique checksums for the file checksums = set() # Add all checksums to the set for server_id, checksum in records: checksums.add(checksum) # If there is more than one unique checksum, the file is inconsistent if len(checksums) > 1: inconsistent_files.append(file_name) return inconsistent_files"},{"question":"# Problem Statement You are developing a feature for a collaborative text editor that tracks the number of edits each user makes to a document in real-time. The editor records the edits in a list where each entry is a tuple containing the username of the editor and the number of edits they made in a single action. Your task is to implement a function `total_edits` that takes this list of edit actions and calculates the total number of edits each user has made. # Function Signature ```python def total_edits(edits: list[tuple[str, int]]) -> dict: pass ``` # Input - `edits`: A list of tuples where each tuple contains: - `username` (a string): The username of the person who made the edit. - `edit_count` (an integer): The number of edits made in that action. # Output - Returns a dictionary where the keys are usernames and the values are the total number of edits made by that user. # Constraints - The list `edits` will contain between 1 and (10^5) entries. - Each username will be a string consisting of alphanumeric characters only and will be at most 100 characters long. - The `edit_count` will be an integer between 1 and (10^5). # Example ```python >>> total_edits([(\\"alice\\", 5), (\\"bob\\", 3), (\\"alice\\", 2), (\\"bob\\", 4), (\\"charlie\\", 7)]) {\'alice\': 7, \'bob\': 7, \'charlie\': 7} >>> total_edits([(\\"alice\\", 1)]) {\'alice\': 1} >>> total_edits([(\\"alice\\", 2), (\\"bob\\", 5), (\\"charlie\\", 3), (\\"alice\\", 10), (\\"charlie\\", 4)]) {\'alice\': 12, \'bob\': 5, \'charlie\': 7} ``` # Notes - Users may appear multiple times in the list of edits, and each edit should be cumulatively added to their total. - Your function should optimize for performance given the constraints.","solution":"def total_edits(edits: list[tuple[str, int]]) -> dict: Calculates the total number of edits each user has made. Parameters: edits (list of tuple): A list where each tuple contains a username and the number of edits made in a single action. Returns: dict: A dictionary where the keys are usernames and the values are the total number of edits made by that user. edit_counts = {} for user, count in edits: if user in edit_counts: edit_counts[user] += count else: edit_counts[user] = count return edit_counts"},{"question":"# Coding Assessment Question: Integer Partition Count **Objective**: Your task is to implement a function that counts the number of ways to partition a positive integer `n` into a sum of positive integers. # Problem Statement You are given an integer `n`. Implement a function `partition_count(n)` that returns the number of ways to partition `n` into a sum of positive integers. # Input * An integer `n` such that 1 ≤ n ≤ 100. # Output * An integer which is the number of ways to partition `n`. # Examples 1. `partition_count(4)` should return `5` since `4` can be partitioned as (4), (3+1), (2+2), (2+1+1), and (1+1+1+1). 2. `partition_count(5)` should return `7` (5, 4+1, 3+2, 3+1+1, 2+2+1, 2+1+1+1, 1+1+1+1+1). 3. `partition_count(6)` should return `11`. # Constraints 1. 1 ≤ `n` ≤ 100. 2. The function should efficiently compute the partition count. # Function Signature ```python def partition_count(n: int) -> int: # Your code here ``` # Additional Notes * Utilize dynamic programming to efficiently compute the number of partitions. * Consider creating an auxiliary array to store the partition counts and iteratively compute the values up to `n`. # Guidance To implement this, consider a dynamic programming approach where you maintain an array `dp` such that `dp[i]` represents the number of ways to partition the integer `i`. Iterate through each integer up to `n` and update the array based on the previously computed values.","solution":"def partition_count(n: int) -> int: Returns the number of ways to partition the integer n into a sum of positive integers. Uses dynamic programming to build up the count of partitions. # dp[i] will store the number of ways to partition the integer i dp = [0] * (n + 1) dp[0] = 1 # There is one way to partition 0 (with no numbers) # Iterate through all integers from 1 to n for i in range(1, n + 1): for j in range(i, n + 1): dp[j] += dp[j - i] return dp[n]"},{"question":"Word Transformation Game # Context A word transformation game involves finding the shortest sequence of transformations to change one word into another given a dictionary of valid words. In each transformation, only one letter can be changed, and the resulting word must exist in the given dictionary. This problem explores the use of breadth-first search (BFS) to find the shortest transformation path. # Task Write a Python function `word_transformation()` that takes a start word, an end word, and a set of valid words (dictionary). The function should return the shortest transformation sequence from the start word to the end word, or an empty list if no such sequence exists. # Function Signature ```python def word_transformation(start: str, end: str, dictionary: set) -> list: pass ``` # Input - `start`: A string representing the starting word. - `end`: A string representing the target word. - `dictionary`: A set of strings representing the dictionary of valid words. # Output - A list of words representing the shortest transformation sequence from the start word to the end word. If no sequence exists, return an empty list. # Requirements - Implement the function using BFS to find the shortest path. - Ensure that the start and end words are of the same length. - Include the start word and the end word in the transformation sequence. # Constraints 1. The length of both the start and end words will always be the same and strictly greater than 0. 2. Dictionary words will also have the same length as the start and end words. 3. The function should handle cases where no transformation is possible. # Example ```python dictionary = {\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\", \\"cog\\"} result = word_transformation(\\"hit\\", \\"cog\\", dictionary) print(result) # Expected output: [\'hit\', \'hot\', \'dot\', \'dog\', \'cog\'] ``` # Notes - Utilize a queue to perform the breadth-first search. - Use a set to keep track of visited words to avoid cycles. - For each word, generate all possible one-letter transformations and check if they exist in the dictionary or are the end word. # Reference: - [Breadth-First Search (BFS) Algorithm](https://en.wikipedia.org/wiki/Breadth-first_search)","solution":"from collections import deque def word_transformation(start: str, end: str, dictionary: set) -> list: if start == end: return [start] if end not in dictionary: return [] dictionary.add(end) queue = deque([(start, [start])]) visited = set([start]) while queue: current_word, path = queue.popleft() for i in range(len(current_word)): for c in \'abcdefghijklmnopqrstuvwxyz\': next_word = current_word[:i] + c + current_word[i+1:] if next_word == end: return path + [end] if next_word in dictionary and next_word not in visited: queue.append((next_word, path + [next_word])) visited.add(next_word) return []"},{"question":"# Vector Operations You will implement a Vector class that represents vectors in N-dimensional space and supports a variety of vector operations. Design your class to handle vectors efficiently. Problem Statement Implement the `Vector` class with the following functionality: 1. **Initialization**: - A constructor that initializes the vector with a given list of coordinates. The coordinates should be in the form of a list of numbers. 2. **Addition**: - Support addition of two vectors of the same dimension using the `+` operator. Raise a ValueError if the dimensions do not match. 3. **Subtraction**: - Support subtraction of two vectors of the same dimension using the `-` operator. Raise a ValueError if the dimensions do not match. 4. **Negation**: - Negate the vector using the unary `-` operator. 5. **Scalar Multiplication**: - Support multiplication of a vector by a scalar using the `*` operator (scalar on the right), or the scalar should be on the left for commutative property (using `__rmul__`). 6. **Dot Product**: - Compute the dot product of two vectors of the same dimension using the `@` operator. Raise a ValueError if the dimensions do not match. 7. **Magnitude**: - Compute the magnitude (length) of the vector. 8. **String Representation**: - Return a human-readable string representation of the vector. 9. **Equality**: - Support comparison of two vectors using `==` and `!=`. Example ```python v1 = Vector([1, 2, 3]) v2 = Vector([4, 5, 6]) print(v1 + v2) # Vector([5, 7, 9]) print(v1 - v2) # Vector([-3, -3, -3]) print(-v1) # Vector([-1, -2, -3]) print(v1 * 3) # Vector([3, 6, 9]) print(3 * v1) # Vector([3, 6, 9]) print(v1 @ v2) # 32 print(v1.magnitude()) # 3.7416573867739413 print(v1 == Vector([1, 2, 3])) # True print(v1 != v2) # True ``` Constraints - The vector dimension is a positive integer. - Each coordinate of the vector is a real number. - Vectors with different dimensions should raise a ValueError for operations requiring same dimensions. - The string representation should be something like `Vector([1, 2, 3])`. Implement the `Vector` class with the described methods and properties.","solution":"import math class Vector: def __init__(self, coordinates): self.coordinates = coordinates def __add__(self, other): if len(self.coordinates) != len(other.coordinates): raise ValueError(\\"Dimensions of both vectors must be the same for addition\\") return Vector([x + y for x, y in zip(self.coordinates, other.coordinates)]) def __sub__(self, other): if len(self.coordinates) != len(other.coordinates): raise ValueError(\\"Dimensions of both vectors must be the same for subtraction\\") return Vector([x - y for x, y in zip(self.coordinates, other.coordinates)]) def __neg__(self): return Vector([-x for x in self.coordinates]) def __mul__(self, scalar): return Vector([scalar * x for x in self.coordinates]) def __rmul__(self, scalar): return self * scalar def __matmul__(self, other): if len(self.coordinates) != len(other.coordinates): raise ValueError(\\"Dimensions of both vectors must be the same for dot product\\") return sum(x * y for x, y in zip(self.coordinates, other.coordinates)) def magnitude(self): return math.sqrt(sum(x ** 2 for x in self.coordinates)) def __str__(self): return f\\"Vector({self.coordinates})\\" def __eq__(self, other): return self.coordinates == other.coordinates def __ne__(self, other): return not self == other"},{"question":"# Number Sorting with Constraints Problem Description: You are tasked with implementing a function that sorts a given list of integers but with an added constraint: the list is partitioned into several segments, each of which needs to be sorted independently. Additionally, the segments need to be concatenated in an order based on a predefined sequence. # Input: * An integer `n` (1 ≤ `n` ≤ 1000), the length of the list. * A list of integers `arr` of length `n` containing the integers to be sorted. * An integer `m` (1 ≤ `m` ≤ 10), the number of segments. * A list of `m` integers `segments` that define the lengths of each segment. * A list of `m` integers `order` that define the order in which the segments should be concatenated after sorting each one independently. # Output: * A list of integers containing the concatenated sorted segments based on the given order. # Function Signature: ```python def sort_segments(n: int, arr: List[int], m: int, segments: List[int], order: List[int]) -> List[int]: pass ``` # Constraints: * The sum of the integers in `segments` will always be equal to `n`. * The integers in `order` will contain indices between `0` and `m-1`. # Example: ```python # Consider the list and segment information: n = 8 arr = [4, 1, 3, 2, 8, 7, 6, 5] m = 3 segments = [3, 3, 2] # segments will be [4, 1, 3], [2, 8, 7], [6, 5] order = [1, 0, 2] # After independently sorting each segment: # Sorted segments will be [1, 3, 4], [2, 7, 8], [5, 6] # Based on the order [1, 0, 2], the output will be [2, 7, 8, 1, 3, 4, 5, 6] sort_segments(n, arr, m, segments, order) # Output: [2, 7, 8, 1, 3, 4, 5, 6] ``` # Implementation Details: 1. Partition the list `arr` based on the segments specified by `segments`. 2. Sort each partitioned segment independently. 3. Concatenate the sorted segments in the order specified by `order`. 4. Return the concatenated list. Good luck!","solution":"from typing import List def sort_segments(n: int, arr: List[int], m: int, segments: List[int], order: List[int]) -> List[int]: Function to sort segments independently and concatenate them based on a given order # Initialize index to track the start of each segment in arr index = 0 # Initialize list to hold sorted segments sorted_segments = [] for segment_length in segments: # Extract the current segment based on its length segment = arr[index : index + segment_length] # Sort the segment sorted_segment = sorted(segment) # Append the sorted segment to the sorted_segments list sorted_segments.append(sorted_segment) # Move the index to the next segment start index += segment_length # Initialize list for the final result result = [] # Concatenate segments in the specified order for segment_index in order: result.extend(sorted_segments[segment_index]) return result"},{"question":"# Problem Statement You are given two lists of integers, `list1` and `list2`. Your task is to determine if these two lists are permutations of each other. Two lists are considered permutations of each other if they contain the same elements with the same frequencies, regardless of the order. # Function Signature ```python def are_permutations(list1: list, list2: list) -> bool: Check if two lists are permutations of each other. Parameters: - list1 (list): A list of integers. - list2 (list): Another list of integers. Returns: - bool: True if the lists are permutations of each other, False otherwise. pass ``` # Input - `list1` and `list2` are lists of integers where: - Each integer ( -10^9 leq a_i leq 10^9 ) - The length of each list ( 0 leq len(list1), len(list2) leq 10^5 ) # Output - A boolean value indicating whether the two lists are permutations of each other. # Constraints - The input lists can possibly be empty. - The length of `list1` and `list2` can differ. # Example ```python are_permutations([1, 2, 3], [3, 2, 1]) # Output: True are_permutations([1, 2, 2], [2, 2, 1]) # Output: True are_permutations([1, 2, 3], [1, 2, 2]) # Output: False are_permutations([], []) # Output: True ``` # Notes - Be mindful of edge cases such as empty lists. - Ensure the time complexity is efficient given the constraint on the length of the lists. - Consider handling the comparison of frequencies effectively to determine if two lists are permutations of each other.","solution":"def are_permutations(list1: list, list2: list) -> bool: Check if two lists are permutations of each other. Parameters: - list1 (list): A list of integers. - list2 (list): Another list of integers. Returns: - bool: True if the lists are permutations of each other, False otherwise. from collections import Counter # Count the frequencies of each element in both lists counter1 = Counter(list1) counter2 = Counter(list2) # Return True if both counters are equal, meaning lists are permutations return counter1 == counter2"},{"question":"**Problem Statement**: Write a function `robot_move` that simulates the movements of a robot on a grid. The function should interpret a sequence of commands and determine the final position of the robot. The commands are represented as a string of characters: `\'U\'` for up, `\'D\'` for down, `\'L\'` for left, and `\'R\'` for right. # Task Requirements: 1. Implement the function `robot_move(commands: str) -> Tuple[int, int]`: - **Input**: A string `commands` consisting of characters \'U\', \'D\', \'L\', \'R\' with ( 1 leq |commands| leq 10^5 ). - **Output**: A tuple `(x, y)` representing the final coordinates of the robot starting at the origin `(0, 0)`. # Constraints: 1. Ensure the function processes each command efficiently, even for the maximum length input. 2. Consider edge cases with the shortest and longest command sequences. 3. Use a tuple to return the final coordinates. # Function Signature: ```python def robot_move(commands: str) -> Tuple[int, int]: pass ``` # Example: ```python assert robot_move(\\"UURRDDLL\\") == (0, 0) assert robot_move(\\"UUU\\") == (0, 3) assert robot_move(\\"RRDD\\") == (2, -2) assert robot_move(\\"\\") == (0, 0) ```","solution":"def robot_move(commands: str) -> tuple[int, int]: Simulates the movements of a robot on a grid and determines the final position. :param commands: A string of commands consisting of \'U\', \'D\', \'L\', \'R\' :return: A tuple (x, y) representing the final coordinates of the robot. x, y = 0, 0 # Start at the origin for command in commands: if command == \'U\': y += 1 elif command == \'D\': y -= 1 elif command == \'L\': x -= 1 elif command == \'R\': x += 1 return (x, y)"},{"question":"# Prime Number Finder **Problem Statement**: You are to implement a function that finds all prime numbers up to a specified integer `n`. A prime number is a natural number greater than 1 that cannot be formed by multiplying two smaller natural numbers. **Function Signature**: ```python def find_primes(n: int) -> list[int]: pass ``` # Input Description: * **n**: A single integer representing the upper limit up to which the prime numbers need to be found. # Output Description: * Returns a list of all prime numbers less than or equal to `n`, sorted in ascending order. # Constraints: * `2 <= n <= 10^6` * If `n` is less than 2, return an empty list. # Examples: ```python assert find_primes(10) == [2, 3, 5, 7] assert find_primes(2) == [2] assert find_primes(30) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] assert find_primes(1) == [] ``` # Scenario: You are building a feature for a mathematical software application that needs to generate a list of prime numbers up to a specified limit. This feature will be used in various mathematical computations and cryptographic algorithms where prime numbers play a crucial role. **Implementation Advice**: 1. **Efficiency**: Utilize the Sieve of Eratosthenes algorithm for optimal performance, especially when `n` can go up to 1,000,000. 2. **Edge Cases**: Handle values less than 2 by returning an empty list straight away. 3. **Storage**: Consider the memory implications of storing large lists of numbers and optimize accordingly. 4. **Validation**: Ensure the function handles the maximum constraints efficiently without excessive time complexity.","solution":"def find_primes(n: int) -> list[int]: Returns a list of all prime numbers less than or equal to n. if n < 2: return [] sieve = [True] * (n + 1) sieve[0] = sieve[1] = False # 0 and 1 are not prime numbers for start in range(2, int(n**0.5) + 1): if sieve[start]: for multiple in range(start*start, n + 1, start): sieve[multiple] = False return [num for num in range(2, n + 1) if sieve[num]]"},{"question":"# Find the Maximum Depth of a Binary Tree Background: You are given a binary tree represented using a `Node` class. Your task is to determine the maximum depth of the tree. The maximum depth is defined as the number of nodes along the longest path from the root node down to the farthest leaf node. Task: Implement a method that computes the maximum depth of the given binary tree. Function Signature: ```python def max_depth(root: Node) -> int: ``` Input: - `root` (Node): The root node of the binary tree. The `Node` class is defined below. ```python @dataclass class Node: data: float left: Node | None = None right: Node | None = None ``` Output: - An integer value: - The maximum depth of the binary tree. Constraints: - The input tree can have 0 or more nodes. - Node values are of type `float`. Example: ```python # Define the tree structure root = Node(1.0) root.left = Node(2.0) root.right = Node(3.0) root.left.left = Node(4.0) root.left.right = Node(5.0) # Function call print(max_depth(root)) # Should print: 3 root.right.right = Node(6.0) print(max_depth(root)) # Should print: 3 ``` Implementation Guidelines: - Use a recursive approach to find the maximum depth. - Ensure proper handling of edge cases such as an empty tree. - Consider an iterative approach with the use of a stack or queue if preferred.","solution":"from typing import Optional from dataclasses import dataclass @dataclass class Node: data: float left: Optional[\'Node\'] = None right: Optional[\'Node\'] = None def max_depth(root: Optional[Node]) -> int: Returns the maximum depth of a binary tree. if root is None: return 0 left_depth = max_depth(root.left) right_depth = max_depth(root.right) return max(left_depth, right_depth) + 1"},{"question":"# Question You are tasked to implement a feature for a text editor that allows text justification. The text should be fully justified such that each line has exactly `maxWidth` characters, except for the last line which should be left-justified and no extra space is inserted between words. Implement a function `fullJustify` to achieve this: Function: `fullJustify` * **Input**: - A list of strings `words` which contains all the words of the text. - An integer `maxWidth` which represents the width of each line. * **Output**: A list of strings where each string represents a fully justified line of text. * **Constraints**: - 1 <= len(words) <= 300 - 1 <= len(words[i]) <= 20 - words[i] consists of only English letters and symbols. - 1 <= maxWidth <= 100 - The words can be separated by any number of spaces between words and lines. **Note**: - You cannot change the order of the words in the input list. - Use as few spaces as possible to achieve the justified lines of `maxWidth`. - Distribute the extra spaces evenly between the words. If the number of spaces on a line does not divide evenly between words, place the extra spaces starting from the left. - For the last line, words should be left-justified, and no extra space is inserted between words. **Example Usage**: ```python assert fullJustify([\\"This\\", \\"is\\", \\"an\\", \\"example\\", \\"of\\", \\"text\\", \\"justification.\\"], 16) == [ \\"This is an\\", \\"example of text\\", \\"justification. \\" ] assert fullJustify([\\"What\\",\\"must\\",\\"be\\",\\"acknowledgment\\",\\"shall\\",\\"be\\"], 16) == [ \\"What must be\\", \\"acknowledgment \\", \\"shall be \\" ] assert fullJustify([\\"Science\\",\\"is\\",\\"what\\",\\"we\\",\\"understand\\",\\"well\\",\\"enough\\",\\"to\\",\\"explain\\", \\"to\\",\\"a\\",\\"computer.\\",\\"Art\\",\\"is\\",\\"everything\\",\\"else\\",\\"we\\",\\"do\\"], 20) == [ \\"Science is what we\\", \\"understand well\\", \\"enough to explain to\\", \\"a computer. Art is\\", \\"everything else we\\", \\"do \\" ] ``` Solution Template Below is a possible template that would guide you in implementing the `fullJustify` function. ```python def fullJustify(words, maxWidth): def justify_line(words, max_width, is_last_line=False): if not words: return \'\' if is_last_line or len(words) == 1: # Left-justified for the last line or single word line. return \' \'.join(words).ljust(max_width) num_spaces = len(words) - 1 total_spaces = max_width - sum(len(word) for word in words) space_between, extra_spaces = divmod(total_spaces, num_spaces) for i in range(extra_spaces): words[i] += \' \' return (\' \' * space_between).join(words) current_line_words = [] current_line_length = 0 result = [] for word in words: if current_line_length + len(current_line_words) + len(word) > maxWidth: result.append(justify_line(current_line_words, maxWidth)) current_line_words = [] current_line_length = 0 current_line_words.append(word) current_line_length += len(word) result.append(justify_line(current_line_words, maxWidth, is_last_line=True)) return result # Example usage of the function assert fullJustify([\\"This\\", \\"is\\", \\"an\\", \\"example\\", \\"of\\", \\"text\\", \\"justification.\\"], 16) == [ \\"This is an\\", \\"example of text\\", \\"justification. \\" ] assert fullJustify([\\"What\\",\\"must\\",\\"be\\",\\"acknowledgment\\",\\"shall\\",\\"be\\"], 16) == [ \\"What must be\\", \\"acknowledgment \\", \\"shall be \\" ] assert fullJustify([\\"Science\\",\\"is\\",\\"what\\",\\"we\\",\\"understand\\",\\"well\\",\\"enough\\",\\"to\\",\\"explain\\", \\"to\\",\\"a\\",\\"computer.\\",\\"Art\\",\\"is\\",\\"everything\\",\\"else\\",\\"we\\",\\"do\\"], 20) == [ \\"Science is what we\\", \\"understand well\\", \\"enough to explain to\\", \\"a computer. Art is\\", \\"everything else we\\", \\"do \\" ] ```","solution":"def fullJustify(words, maxWidth): def justify_line(words, max_width, is_last_line=False): if not words: return \'\' if is_last_line or len(words) == 1: # Left-justified for the last line or single word line. return \' \'.join(words).ljust(max_width) num_spaces = len(words) - 1 total_spaces = max_width - sum(len(word) for word in words) space_between, extra_spaces = divmod(total_spaces, num_spaces) for i in range(extra_spaces): words[i] += \' \' return (\' \' * space_between).join(words) current_line_words = [] current_line_length = 0 result = [] for word in words: if current_line_length + len(current_line_words) + len(word) > maxWidth: result.append(justify_line(current_line_words, maxWidth)) current_line_words = [] current_line_length = 0 current_line_words.append(word) current_line_length += len(word) result.append(justify_line(current_line_words, maxWidth, is_last_line=True)) return result"},{"question":"# Scenario: You have been hired to develop a Python application that helps track and analyze user activity on a website. One feature of the application is to process server log files and extract insightful statistics about user visits. Your task is to implement a function that reads a log file and calculates the total number of visits per user. # Task: Write a function `calculate_visits(log_file: str) -> dict` that takes in one parameter: the path to a log file. This function should read the log file, process each line, and return a dictionary where the keys are user identifiers and the values are the total number of visits for each user. # Requirements: 1. The log file is a text file where each line represents a single visit. 2. Each line contains a user identifier followed by a timestamp, separated by a space. 3. The function should read the log file and build a dictionary mapping user identifiers to their visit counts. 4. Handle potential errors such as file not found or unreadable lines. 5. Ensure efficient reading and processing of the log file, even if it contains millions of lines. # Example: Sample log file (`log.txt`): ``` user1 2023-10-01T12:34:56 user2 2023-10-01T12:35:02 user1 2023-10-01T12:36:45 user3 2023-10-01T12:40:21 user2 2023-10-01T12:42:00 ``` ```python def calculate_visits(log_file: str) -> dict: pass # Implement the function here # Example usage: result = calculate_visits(\\"log.txt\\") print(result) ``` Input: - `log_file`: A string representing the path to the log file. Output: - A dictionary with user identifiers as keys and the number of visits as values. # Sample Output: ```python { \\"user1\\": 2, \\"user2\\": 2, \\"user3\\": 1 } ``` Constraints: - The log file must be in the specified format. - The function should handle large log files efficiently. - Assume well-formed timestamps and unique user identifiers.","solution":"def calculate_visits(log_file: str) -> dict: Reads a log file and calculates the total number of visits per user. Args: log_file (str): The path to the log file. Returns: dict: A dictionary where the keys are user identifiers and the values are the total number of visits for each user. visits = {} try: with open(log_file, \'r\') as file: for line in file: try: user_id, _ = line.strip().split() if user_id in visits: visits[user_id] += 1 else: visits[user_id] = 1 except ValueError: # Skipping the line if it does not have exactly two elements continue except FileNotFoundError: print(f\\"File not found: {log_file}\\") except Exception as e: print(f\\"An error occurred: {e}\\") return visits"},{"question":"# Advanced Problem: Sliding Window Maximum Scenario You are developing a feature for a financial analysis software that requires real-time monitoring of stock prices. Specifically, you need to compute the maximum stock price within a moving window of size `k` over a period of `n` time points efficiently. Requirements * **Function Signature**: Implement the function `sliding_window_max(nums: List[int], k: int) -> List[int]`. * **Input**: - `nums` (List[int]): A list of integers representing stock prices at different time points. - `k` (int): The size of the sliding window. * **Output**: - Return a list of integers representing the maximum stock price in each sliding window position. Constraints 1. `1 <= len(nums) <= 10^5` 2. `-10^4 <= nums[i] <= 10^4` 3. `1 <= k <= len(nums)` Performance Requirements - Aim for a time complexity of O(n), where n is the length of the `nums` list. Example ```python from collections import deque def sliding_window_max(nums: List[int], k: int) -> List[int]: # Implement the function using a deque to efficiently track the maximum in each window # Example usage: nums = [1, 3, -1, -3, 5, 3, 6, 7] k = 3 # Expected output: [3, 3, 5, 5, 6, 7] print(sliding_window_max(nums, k)) ``` Hints - Consider using a deque to store indices of elements in the current window. - Ensure to maintain the deque such that the front always contains the index of the maximum element for the current window. This problem helps develop skills in efficient data structure usage, particularly in the context of real-world applications like financial analysis.","solution":"from typing import List from collections import deque def sliding_window_max(nums: List[int], k: int) -> List[int]: Calculate the maximum value in each sliding window of size `k`. Args: nums: List of integers representing stock prices. k: An integer representing the size of the sliding window. Returns: A list of integers representing the maximum value in each sliding window. if not nums: return [] result = [] dq = deque() # Stores indices of useful elements for each window for i in range(len(nums)): # Remove elements not part of the window if dq and dq[0] == i - k: dq.popleft() # Remove elements from the deque which are less than the current element while dq and nums[dq[-1]] < nums[i]: dq.pop() dq.append(i) # Append the current max to the result list if i >= k - 1: result.append(nums[dq[0]]) return result"},{"question":"# Matrix Island Counter You are given a class `Matrix` which represents a 2D matrix of integers. Your task is to implement a method that counts the number of distinct islands within the matrix. An island is defined as a group of adjacent `1`s (horizontally or vertically), surrounded by `0`s or the edge of the matrix. Diagonal connections do not count. Method to Implement ```python class Matrix: # existing constructor and methods def count_islands(self) -> int: pass ``` # Input You do not need to modify the constructor or any existing methods of the `Matrix` class. You must implement the `count_islands` method, which does not take any inputs. # Output The method should return an integer representing the number of distinct islands in the matrix. # Example ```python matrix = [ [1, 1, 0, 0, 0], [1, 1, 0, 1, 1], [0, 0, 0, 1, 1], [0, 1, 0, 0, 0] ] matrix_obj = Matrix(matrix) print(matrix_obj.count_islands()) # should return 3 ``` # Constraints * The size of the matrix will be at most `1000 x 1000`. * The matrix contains only `0`s and `1`s. # Note 1. Consider edge cases such as matrices with no `1`s or entirely filled with `1`s. 2. Focus on the efficiency of your solution to handle upper constraint limits.","solution":"class Matrix: def __init__(self, matrix): self.matrix = matrix self.rows = len(matrix) self.cols = len(matrix[0]) if self.rows > 0 else 0 def count_islands(self) -> int: if not self.matrix: return 0 visited = [[False for _ in range(self.cols)] for _ in range(self.rows)] def dfs(r, c): if r < 0 or r >= self.rows or c < 0 or c >= self.cols or self.matrix[r][c] == 0 or visited[r][c]: return visited[r][c] = True dfs(r - 1, c) # up dfs(r + 1, c) # down dfs(r, c - 1) # left dfs(r, c + 1) # right island_count = 0 for r in range(self.rows): for c in range(self.cols): if self.matrix[r][c] == 1 and not visited[r][c]: island_count += 1 dfs(r, c) return island_count"},{"question":"Binary Tree Inversion Challenge In this problem, you are required to invert a binary tree. Inverting a binary tree means swapping the left and right children of every node in the tree. This is essentially a mirror operation. # Function Requirements Implement a function `invert_tree` that takes the root of the binary tree and inverts the tree in place. ```python class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def invert_tree(root: TreeNode) -> TreeNode: # Your implementation here ``` # Expected Input and Output - The input is the root node of a binary tree. - The output is the root node of the inverted binary tree. # Constraints - The tree nodes have integer values. - The number of nodes in the binary tree will not exceed 10^5. - The tree can be empty, in which case the input will be `None`. # Performance Requirements - Your solution should handle large trees efficiently. - Aim for a solution with a time complexity of O(n), where n is the number of nodes in the tree. # Example ```python # Example usage: # Construct the following binary tree # 4 # / # 2 7 # / / # 1 3 6 9 root = TreeNode(4) root.left = TreeNode(2, TreeNode(1), TreeNode(3)) root.right = TreeNode(7, TreeNode(6), TreeNode(9)) # Invert the binary tree inverted_root = invert_tree(root) # The inverted tree should be: # 4 # / # 7 2 # / / # 9 6 3 1 ``` # Explanation - After calling `invert_tree` with the initial `root`, the left and right children of each node in the binary tree are swapped. - The resulting tree structure is a mirrored version of the original tree.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def invert_tree(root: TreeNode) -> TreeNode: if root is None: return None # Swap the left and right children root.left, root.right = root.right, root.left # Recursively invert the left and right subtrees invert_tree(root.left) invert_tree(root.right) return root"},{"question":"# Introduction In modern text-processing workflows, it\'s quite common to clean up and format text input in various ways. One common task is to remove all duplicate characters from a string while preserving the order of their first occurrences. # Problem Write a function `remove_duplicates(text: str) -> str` that removes all duplicate characters from a given string, keeping only the first occurrence of each character in the resulting string. # Function Signature ```python def remove_duplicates(text: str) -> str: ``` # Input The input is a single string, `text`, which can be any length including: - an empty string - a string containing only whitespace - a string containing any set of characters including special characters and numbers. # Output The function should return a new string with duplicate characters removed while preserving the order of their first occurrences. # Constraints 1. If the input string is empty, the function should return an empty string. 2. The function should preserve the first occurrence of each character and remove subsequent duplicates. # Examples ```python assert remove_duplicates(\\"programming\\") == \\"progamin\\" assert remove_duplicates(\\"hello world\\") == \\"helo wrd\\" assert remove_duplicates(\\"aabbcc\\") == \\"abc\\" assert remove_duplicates(\\"\\") == \\"\\" assert remove_duplicates(\\" \\") == \\" \\" assert remove_duplicates(\\"123123\\") == \\"123\\" ``` Make sure your solution passes the above examples and adheres to the constraints provided.","solution":"def remove_duplicates(text: str) -> str: Removes all duplicate characters from the input string while preserving the order of their first occurrences. Args: text (str): Input string. Returns: str: String with duplicates removed. seen = set() result = [] for char in text: if char not in seen: seen.add(char) result.append(char) return \'\'.join(result)"},{"question":"# Problem Statement You are tasked with writing a function that, given a string `s`, finds the first non-repeating character in it and returns its index. If all characters are repeating, the function should return -1. Implement the function `first_non_repeating_character(s: str) -> int`. # Input * `s`: A string containing only lowercase Latin letters (1 ≤ len(s) ≤ 10^5). # Output * An integer representing the index of the first non-repeating character in the string. If no such character exists, return -1. # Constraints * The algorithm should run in O(n) time. * The algorithm should use O(1) additional space (excluding the input string). # Example ```python assert first_non_repeating_character(\\"leetcode\\") == 0 assert first_non_repeating_character(\\"loveleetcode\\") == 2 assert first_non_repeating_character(\\"aabbcc\\") == -1 assert first_non_repeating_character(\\"abcd\\") == 0 assert first_non_repeating_character(\\"zzyyxx\\") == -1 ``` # Explanation 1. In the first example, the string `s = \\"leetcode\\"`, the character \'l\' is the first non-repeating character. 2. In the second example, the string `s = \\"loveleetcode\\"`, the character \'v\' is the first non-repeating character at index 2. 3. In the third example, the string `s = \\"aabbcc\\"`, all characters repeat, so the function returns -1. 4. In the fourth example, the string `s = \\"abcd\\"`, the character \'a\' is the first non-repeating character. 5. In the fifth example, the string `s = \\"zzyyxx\\"`, all characters repeat, so the function returns -1. Write an efficient solution to find the first non-repeating character in the given string.","solution":"def first_non_repeating_character(s: str) -> int: Finds the index of the first non-repeating character in a string. If there is no non-repeating character, returns -1. # Dictionary to store character count char_count = {} # First pass to store count of each character for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Second pass to find the first non-repeating character for index, char in enumerate(s): if char_count[char] == 1: return index return -1"},{"question":"Problem Statement: You are given a string containing digits from 2 to 9 inclusive. Each digit maps to a set of letters as follows on a phone keypad: 2 -> \\"abc\\", 3 -> \\"def\\", 4 -> \\"ghi\\", 5 -> \\"jkl\\", 6 -> \\"mno\\", 7 -> \\"pqrs\\", 8 -> \\"tuv\\", 9 -> \\"wxyz\\". Write a function to return all possible letter combinations that the number could represent. # Function Signature ```python def letter_combinations(digits: str) -> list: pass ``` # Input * `digits`: A string of length `n` (1 <= n <= 4), which contains digits from \'2\' to \'9\' inclusive. # Output * Returns a list of strings containing all possible letter combinations. The output list can be in any order. # Constraints * The function should operate within a reasonable time complexity, considering the small size of the input. # Example ```python digits = \\"23\\" result = letter_combinations(digits) print(result) # Output should be [\\"ad\\",\\"ae\\",\\"af\\",\\"bd\\",\\"be\\",\\"bf\\",\\"cd\\",\\"ce\\",\\"cf\\"] ``` # Requirements * Your function should generate all possible letter combinations for the given input digits. * You should not use Python built-in functions directly related to permutations to solve this problem. * Ensure your code handles edge cases properly, such as the minimum and maximum input lengths. # Notes * Consider using recursion or iterative approaches to build the combinations. * You may use helper functions if necessary. * Avoid hardcoding or using Python\'s built-in libraries directly to generate all combinations.","solution":"def letter_combinations(digits: str) -> list: if not digits: return [] # Mapping of digits to corresponding letters phone_map = { \'2\': \'abc\', \'3\': \'def\', \'4\': \'ghi\', \'5\': \'jkl\', \'6\': \'mno\', \'7\': \'pqrs\', \'8\': \'tuv\', \'9\': \'wxyz\' } def backtrack(index, path): # If the current combination path has the same length as digits, we found a combination if len(path) == len(digits): combinations.append(\\"\\".join(path)) return # Get the letters that the current digit maps to, and loop through them possible_letters = phone_map[digits[index]] for letter in possible_letters: # Add the letter to the current combination path path.append(letter) # Move on to the next digit backtrack(index + 1, path) # Backtrack by removing the letter before moving onto the next path.pop() combinations = [] backtrack(0, []) return combinations"},{"question":"# Assignment: Implement a Simple Blockchain System You will be creating a basic Blockchain system. This will involve creating blocks, adding them to the blockchain, and validating the entire blockchain. # Task: 1. Improve the `hash_block` function to ensure it provides a unique and immutable hash for each block. Use the SHA-256 hashing algorithm. 2. Write the `add_block` function to add a new block to the blockchain. * Input: * `blockchain` - The existing blockchain as a list of blocks. * `data` - The data to be included in the new block. * Output: * Void. The function will append the new block to the blockchain. 3. Write the `is_valid_chain` function to validate the integrity of the blockchain. * Input: * `blockchain` - The blockchain to be validated as a list of blocks. * Output: * Boolean value indicating whether the blockchain is valid (True) or not (False). # Constraints: * Each block must contain: - An index indicating its position in the blockchain. - A timestamp of when the block was created. - The data to be included in the block. - The hash of the previous block. - The hash of the current block. * The genesis block (the first block in the blockchain) must be created manually and added before any other block. * You must handle edge cases such as invalid data input and tampering of data in the blockchain. # Example: ```python import hashlib import datetime def hash_block(block): block_str = f\\"{block[\'index\']}{block[\'timestamp\']}{block[\'data\']}{block[\'prev_hash\']}\\" return hashlib.sha256(block_str.encode()).hexdigest() def add_block(blockchain, data): index = len(blockchain) timestamp = datetime.datetime.now() prev_hash = blockchain[-1][\'hash\'] if blockchain else \'0\' new_block = { \'index\': index, \'timestamp\': timestamp, \'data\': data, \'prev_hash\': prev_hash, \'hash\': \'\' } new_block[\'hash\'] = hash_block(new_block) blockchain.append(new_block) def is_valid_chain(blockchain): for i in range(1, len(blockchain)): block = blockchain[i] prev_block = blockchain[i - 1] if block[\'prev_hash\'] != prev_block[\'hash\']: return False if block[\'hash\'] != hash_block(block): return False return True # Creating the genesis block blockchain = [] genesis_block = { \'index\': 0, \'timestamp\': datetime.datetime.now(), \'data\': \'Genesis Block\', \'prev_hash\': \'0\', \'hash\': \'\' } genesis_block[\'hash\'] = hash_block(genesis_block) blockchain.append(genesis_block) # Adding a new block data = \\"This is the second block\\" add_block(blockchain, data) # Validating the blockchain print(is_valid_chain(blockchain)) # Output: True ```","solution":"import hashlib import datetime def hash_block(block): Generates a SHA-256 hash for the given block. block_str = f\\"{block[\'index\']}{block[\'timestamp\']}{block[\'data\']}{block[\'prev_hash\']}\\" return hashlib.sha256(block_str.encode()).hexdigest() def add_block(blockchain, data): Adds a new block with the provided data to the blockchain. index = len(blockchain) timestamp = datetime.datetime.now() prev_hash = blockchain[-1][\'hash\'] if blockchain else \'0\' new_block = { \'index\': index, \'timestamp\': timestamp, \'data\': data, \'prev_hash\': prev_hash, \'hash\': \'\' } new_block[\'hash\'] = hash_block(new_block) blockchain.append(new_block) def is_valid_chain(blockchain): Validates the integrity of the entire blockchain. for i in range(1, len(blockchain)): block = blockchain[i] prev_block = blockchain[i - 1] if block[\'prev_hash\'] != prev_block[\'hash\']: return False if block[\'hash\'] != hash_block(block): return False return True # Creating the genesis block blockchain = [] genesis_block = { \'index\': 0, \'timestamp\': datetime.datetime.now(), \'data\': \'Genesis Block\', \'prev_hash\': \'0\', \'hash\': \'\' } genesis_block[\'hash\'] = hash_block(genesis_block) blockchain.append(genesis_block) # Adding a new block data = \\"This is the second block\\" add_block(blockchain, data) # Validating the blockchain print(is_valid_chain(blockchain)) # Output: True"},{"question":"# Binary Search Algorithm Implement the binary search algorithm to find the position of a given target value within a sorted array. Your solution should include a recursive approach to verify whether the target value is present, and if so, return its index; otherwise, return -1 indicating the target value is not present in the array. Problem Statement Implement the following function in Python: 1. **`binary_search(arr: list, target: int) -> int`**: - This function performs a binary search on a sorted list `arr` to find the index of the `target`. - **Input**: - `arr`: a sorted list of integers. - `target`: an integer representing the value to search for. - **Output**: An integer representing the index of `target` in `arr` if found; otherwise, `-1`. # Example ```python arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] target = 6 index = binary_search(arr, target) print(index) # Output: 5 target = 11 index = binary_search(arr, target) print(index) # Output: -1 ``` # Additional Details - Use a recursive approach to implement the binary search. - Ensure the function divides the array into halves and consistently narrows down the search area. # Function Signature ```python def binary_search(arr: list, target: int) -> int: \'\'\' Perform a binary search on a sorted list `arr` to find the target value `target`. Return the target\'s index if found; otherwise, return -1. \'\'\' # Helper function for recursive binary search def helper(arr: list, target: int, low: int, high: int) -> int: if low <= high: mid = (low + high) // 2 if arr[mid] == target: return mid elif arr[mid] < target: return helper(arr, target, mid + 1, high) else: return helper(arr, target, low, mid - 1) else: return -1 # Initial call to the helper function return helper(arr, target, 0, len(arr) - 1) ```","solution":"def binary_search(arr: list, target: int) -> int: \'\'\' Perform a binary search on a sorted list `arr` to find the target value `target`. Return the target\'s index if found; otherwise, return -1. \'\'\' def helper(arr: list, target: int, low: int, high: int) -> int: if low <= high: mid = (low + high) // 2 if arr[mid] == target: return mid elif arr[mid] < target: return helper(arr, target, mid + 1, high) else: return helper(arr, target, low, mid - 1) else: return -1 return helper(arr, target, 0, len(arr) - 1)"},{"question":"# Coding Assessment Question Problem Statement You are tasked with developing a temperature conversion utility that supports conversion between Fahrenheit, Celsius, and Kelvin. Extend the provided function to handle conversions efficiently. Detailed Description * **Function Name**: `convert_temperature` * **Inputs**: * `temperature` (float): The temperature value to convert. * `from_unit` (str): The unit of the input temperature. It can be `\'C\'`, `\'F\'`, or `\'K\'`. * `to_unit` (str): The unit of the output temperature. It can be `\'C\'`, `\'F\'`, or `\'K\'`. * **Output**: * Returns the converted temperature as a float. * **Constraints**: * `from_unit` and `to_unit` must be one of `\'C\'`, `\'F\'`, `\'K\'`. * Raise appropriate exceptions with helpful error messages if the constraints are violated. Conversion Formulas - Celsius to Fahrenheit: [(C * 9/5) + 32] - Fahrenheit to Celsius: [(F - 32) * 5/9] - Celsius to Kelvin: [(C + 273.15)] - Kelvin to Celsius: [(K - 273.15)] - Fahrenheit to Kelvin: [(F - 32) * 5/9 + 273.15] - Kelvin to Fahrenheit: [(K - 273.15) * 9/5 + 32] Example ```python >>> convert_temperature(0, \'C\', \'F\') 32.0 >>> convert_temperature(32, \'F\', \'C\') 0.0 >>> convert_temperature(100, \'C\', \'K\') 373.15 >>> convert_temperature(0, \'K\', \'C\') -273.15 >>> convert_temperature(212, \'F\', \'K\') 373.15 >>> convert_temperature(273.15, \'K\', \'F\') 32.0 >>> convert_temperature(-10, \'C\', \'F\') 14.0 >>> convert_temperature(100, \'C\', \'X\') # invalid unit Traceback (most recent call last): ... Exception: Units must be \'C\', \'F\', or \'K\' ``` Implementation Implement the function in Python, structured as follows: ```python def convert_temperature(temperature: float, from_unit: str, to_unit: str) -> float: Converts the temperature from one unit to another. :param temperature: The temperature value to convert. :param from_unit: Unit of input temperature (\'C\', \'F\', \'K\'). :param to_unit: Unit of output temperature (\'C\', \'F\', \'K\'). :return: Converted temperature as a float. Examples: >>> convert_temperature(0, \'C\', \'F\') 32.0 >>> convert_temperature(32, \'F\', \'C\') 0.0 >>> convert_temperature(100, \'C\', \'K\') 373.15 >>> convert_temperature(0, \'K\', \'C\') -273.15 >>> convert_temperature(212, \'F\', \'K\') 373.15 >>> convert_temperature(273.15, \'K\', \'F\') 32.0 >>> convert_temperature(-10, \'C\', \'F\') 14.0 >>> convert_temperature(100, \'C\', \'X\') # invalid unit Traceback (most recent call last): ... Exception: Units must be \'C\', \'F\', or \'K\' if from_unit not in [\'C\', \'F\', \'K\'] or to_unit not in [\'C\', \'F\', \'K\']: raise Exception(\\"Units must be \'C\', \'F\', or \'K\'\\") if from_unit == to_unit: return temperature # Convert from from_unit to Celsius first if from_unit == \'F\': temperature = (temperature - 32) * 5/9 elif from_unit == \'K\': temperature = temperature - 273.15 # Convert from Celsius to to_unit if to_unit == \'F\': return temperature * 9/5 + 32 elif to_unit == \'K\': return temperature + 273.15 else: return temperature ```","solution":"def convert_temperature(temperature: float, from_unit: str, to_unit: str) -> float: Converts the temperature from one unit to another. :param temperature: The temperature value to convert. :param from_unit: Unit of input temperature (\'C\', \'F\', \'K\'). :param to_unit: Unit of output temperature (\'C\', \'F\', \'K\'). :return: Converted temperature as a float. Examples: >>> convert_temperature(0, \'C\', \'F\') 32.0 >>> convert_temperature(32, \'F\', \'C\') 0.0 >>> convert_temperature(100, \'C\', \'K\') 373.15 >>> convert_temperature(0, \'K\', \'C\') -273.15 >>> convert_temperature(212, \'F\', \'K\') 373.15 >>> convert_temperature(273.15, \'K\', \'F\') 32.0 >>> convert_temperature(-10, \'C\', \'F\') 14.0 >>> convert_temperature(100, \'C\', \'X\') # invalid unit Traceback (most recent call last): ... Exception: Units must be \'C\', \'F\', or \'K\' if from_unit not in [\'C\', \'F\', \'K\'] or to_unit not in [\'C\', \'F\', \'K\']: raise Exception(\\"Units must be \'C\', \'F\', or \'K\'\\") if from_unit == to_unit: return temperature # Convert from from_unit to Celsius first if from_unit == \'F\': temperature = (temperature - 32) * 5/9 elif from_unit == \'K\': temperature = temperature - 273.15 # Convert from Celsius to to_unit if to_unit == \'F\': return temperature * 9/5 + 32 elif to_unit == \'K\': return temperature + 273.15 else: return temperature"},{"question":"# Question Write a function that takes a binary search tree (BST) and returns the height of the tree. The height of a binary search tree is defined as the number of edges on the longest path from the root node to a leaf node. If the tree is empty, the height should be -1. Function Signature ```python def find_bst_height(node: TreeNode) -> int: ``` Input * `node` (TreeNode): A root node of the binary search tree defined by the `TreeNode` class. Output * `int`: The height of the given binary search tree. Return -1 if the tree is empty. Constraints * The number of nodes in the tree can be up to `10^5`. Performance Requirements * The solution should run in O(n) time complexity, where n is the number of nodes in the tree. Example ```python # Definition for a binary tree node: class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right # Example # Create binary search tree: # 4 # / # 2 6 # / / # 1 3 5 7 root = TreeNode(4) root.left = TreeNode(2, TreeNode(1), TreeNode(3)) root.right = TreeNode(6, TreeNode(5), TreeNode(7)) # Find the height of the tree print(find_bst_height(root)) # Output: 2 ``` Note Consider edge cases such as an empty tree or a tree with a single node, and handle them appropriately in your implementation.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find_bst_height(node: TreeNode) -> int: Returns the height of the given binary search tree. if node is None: return -1 left_height = find_bst_height(node.left) right_height = find_bst_height(node.right) return 1 + max(left_height, right_height)"},{"question":"# Problem Statement Write a function `count_occurrences(sentence: str, word: str) -> int` that counts the number of occurrences of a given word in a string. Your implementation should only count whole word matches and should be case-insensitive. # Input and Output Formats - **Input** - `sentence`: A string representing a sentence or text in which to count occurrences. - `word`: A string representing the word to count occurrences of. - **Output** - An integer representing the number of times the word appears in the sentence. # Constraints - The sentence can have a length of up to `1,000,000` characters. - The word can have a length of up to `1,000` characters. - The function should handle different punctuations gracefully, considering only whole words without punctuation. # Examples - **Example 1:** ```python count_occurrences(\\"Hello world. Hello everyone!\\", \\"hello\\") ``` Expected Output: ```python 2 ``` - **Example 2:** ```python count_occurrences(\\"The quick brown fox jumps over the lazy dog\\", \\"the\\") ``` Expected Output: ```python 2 ``` - **Example 3:** ```python count_occurrences(\\"Python programming is fun. I love programming in Python.\\", \\"programming\\") ``` Expected Output: ```python 2 ``` # Note - Ensure that the function does not count partial matches (e.g., \\"hello\\" should not match \\"hello123\\"). - Consider common punctuation marks (like periods, commas, exclamation marks, etc.) and ensure they do not affect word matching. - The function should handle case insensitivity and splitting words effectively. Complete your implementation to make sure it addresses all edge cases and performs efficiently on large inputs.","solution":"import re def count_occurrences(sentence: str, word: str) -> int: Returns the number of occurrences of the given word in the sentence. Counts whole word matches and is case-insensitive. Args: - sentence (str): The sentence to count occurrences in. - word (str): The word to count occurrences of. Returns: - int: The number of occurrences of the word. # Use regular expression to find whole word matches and ignore case pattern = rf\'b{re.escape(word)}b\' matches = re.findall(pattern, sentence, re.IGNORECASE) return len(matches)"},{"question":"**Question**: Detect Cycle in a Directed Graph **Context**: Given a directed graph represented as an adjacency list, your task is to detect if the graph contains a cycle. A cycle in a directed graph is a path which starts and ends at the same node, and none of the edges within the cycle are repeated. **Details**: 1. Implement a function `detect_cycle(graph: Dict[int, List[int]], max_node: int) -> None` that: - Takes a graph (as an adjacency list) and the maximum node number. - Prints \\"Cycle Detected\\" if a cycle exists in the graph, otherwise prints \\"No Cycle Detected\\". 2. You may assume that the graph nodes are indexed from 1 to `max_node`. **Input Format**: - `graph` : A dictionary where keys are node identifiers (integers) and values are lists of integers representing adjacent nodes. - `max_node` : An integer representing the maximum node identifier. **Output Format**: - Print statements indicating whether the graph contains a cycle or not. **Constraints**: - The graph can have nodes that do not participate in any edges. - Graph can contain self-loops. **Examples**: ```python def detect_cycle(graph, max_node): # Your implementation here # Example usage: g1 = {1: [2], 2: [3], 3: [4, 5], 4: [2], 5: []} detect_cycle(g1, 5) # Output: # Cycle Detected g2 = {1: [2], 2: [3], 3: [4], 4: []} detect_cycle(g2, 4) # Output: # No Cycle Detected g3 = {1: [2, 3], 2: [3], 3: []} detect_cycle(g3, 3) # Output: # No Cycle Detected ```","solution":"def detect_cycle(graph, max_node): Function to detect a cycle in a directed graph. def dfs(node, visited, stack): visited[node] = True stack[node] = True for neighbor in graph.get(node, []): if not visited[neighbor]: if dfs(neighbor, visited, stack): return True elif stack[neighbor]: return True stack[node] = False return False visited = [False] * (max_node + 1) stack = [False] * (max_node + 1) for node in range(1, max_node + 1): if not visited[node]: if dfs(node, visited, stack): print(\\"Cycle Detected\\") return print(\\"No Cycle Detected\\")"},{"question":"# Coding Assignment: Implement a Balanced Binary Search Tree (BST) Scenario You are a software developer at a tech company that specializes in database management systems. Efficient query processing is critical for performance, and your task is to develop a balanced binary search tree (BST) to optimize the querying process. The balanced tree will ensure that operations such as insertion, deletion, and search maintain an efficient time complexity. Problem Statement Implement a balanced Binary Search Tree (BST) with insertion and search functionality. Your implementation should ensure that the tree remains balanced after each insertion to guarantee optimal performance. Requirements 1. **Class Definition**: Define a class `BalancedBST` with methods: - `insert(key: int) -> None` - `search(key: int) -> bool` 2. **Input Format**: - `key`: An integer value to be inserted or searched in the tree. 3. **Output Format**: - `insert` method does not return anything. - `search` method returns a boolean indicating whether the key is present in the tree or not. 4. **Constraints**: - Keys are unique integers for insertion. - The tree should remain balanced after each insertion. 5. **Performance Requirements**: - Aim for O(log n) time complexity for both insertion and search operations. 6. **Additional Requirements**: - Use a self-balancing BST approach (such as an AVL tree or a Red-Black tree). Example ```python bst = BalancedBST() bst.insert(10) bst.insert(20) bst.insert(30) bst.insert(25) assert bst.search(20) == True assert bst.search(15) == False ``` Notes 1. Implement the class `BalancedBST` with the specified methods. 2. Ensure the tree remains balanced after each insertion to maintain optimal time complexity for operations. 3. You may use additional helper methods if needed to support the balancing logic (e.g., rotations for AVL tree). 4. Test your implementation with various cases to ensure robustness and efficiency.","solution":"class Node: def __init__(self, key): self.key = key self.left = None self.right = None self.height = 1 class BalancedBST: def __init__(self): self.root = None def insert(self, key): if not self.root: self.root = Node(key) else: self.root = self._insert(self.root, key) def _insert(self, root, key): if not root: return Node(key) if key < root.key: root.left = self._insert(root.left, key) else: root.right = self._insert(root.right, key) root.height = 1 + max(self._get_height(root.left), self._get_height(root.right)) balance = self._get_balance(root) if balance > 1 and key < root.left.key: return self._right_rotate(root) if balance < -1 and key > root.right.key: return self._left_rotate(root) if balance > 1 and key > root.left.key: root.left = self._left_rotate(root.left) return self._right_rotate(root) if balance < -1 and key < root.right.key: root.right = self._right_rotate(root.right) return self._left_rotate(root) return root def search(self, key): return self._search(self.root, key) def _search(self, node, key): if not node: return False if node.key == key: return True elif key < node.key: return self._search(node.left, key) else: return self._search(node.right, key) def _left_rotate(self, z): y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def _right_rotate(self, z): y = z.left T3 = y.right y.right = z z.left = T3 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def _get_height(self, node): if not node: return 0 return node.height def _get_balance(self, node): if not node: return 0 return self._get_height(node.left) - self._get_height(node.right)"},{"question":"# Problem Description You are given a list of integers `arr` representing stock price changes over time. Write a function `max_profit(arr: List[int]) -> int` that computes the maximum possible profit from a single buy-sell transaction. You must buy before you sell, and the profit is defined as the difference between buying and selling prices. # Input * `arr` (List[int]): A list of integers where each integer represents a change in stock price from one day to the next. # Output * Returns an integer representing the maximum possible profit from a single buy-sell transaction. If no profit can be made, returns 0. # Constraints * 1 <= len(arr) <= 10^5 * -10^4 <= arr[i] <= 10^4 for each element in the list # Example ```python arr = [7, 1, 5, 3, 6, 4] print(max_profit(arr)) # Output should be 5 arr = [7, 6, 4, 3, 1] print(max_profit(arr)) # Output should be 0 ``` # Explanation Your function should find the largest difference between any two integers where the larger integer comes after the smaller integer in the list. The function returns this difference as the maximum possible profit. If no profit can be made (i.e., prices only decrease), the function should return 0. # Note * You are not allowed to use any library functions other than standard Python libraries for basic operations. * Consider edge cases, such as a list with only one element, where no transactions can be made.","solution":"from typing import List def max_profit(arr: List[int]) -> int: Computes the maximum possible profit from a single buy-sell transaction. If no profit can be made, returns 0. if len(arr) < 2: return 0 # no profit can be made with less than 2 prices min_price = float(\'inf\') max_profit = 0 for price in arr: if price < min_price: min_price = price potential_profit = price - min_price if potential_profit > max_profit: max_profit = potential_profit return max_profit"},{"question":"# Question: Implement a Word Occurrence Counter with Case Insensitivity Context: You are developing a text analysis tool that needs to count the occurrences of each word in a given string. The function should accurately count word frequencies regardless of case sensitivity and ignore punctuation. # Function Signature ```python def word_occurrence_counter(text: str) -> dict: pass ``` # Requirements 1. **Input**: A single string (`text`), which represents a block of text. 2. **Output**: A dictionary where the keys are words in lowercase and the values are the number of occurrences of each word. 3. **Constraints**: - Words are defined as sequences of alphanumeric characters. - The function should be case-insensitive. - The function should ignore punctuation (e.g., periods, commas, exclamation marks). # Examples ```python >>> word_occurrence_counter(\\"Hello world! Hello, how are you?\\") {\'hello\': 2, \'world\': 1, \'how\': 1, \'are\': 1, \'you\': 1} >>> word_occurrence_counter(\\"One fish, two fish. Red fish, blue fish.\\") {\'one\': 1, \'fish\': 4, \'two\': 1, \'red\': 1, \'blue\': 1} >>> word_occurrence_counter(\\"It\'s a small world after all. Indeed, a very small world.\\") {\'its\': 1, \'a\': 2, \'small\': 2, \'world\': 2, \'after\': 1, \'all\': 1, \'indeed\': 1, \'very\': 1} ``` # Error Handling 1. If the input `text` is None, raise a `ValueError` with the message \\"Input text cannot be None\\". 2. If the input `text` is not a string, raise a `TypeError` with the appropriate message indicating the type issue. # Examples of Error Handling ```python >>> word_occurrence_counter(None) Traceback (most recent call last): ... ValueError: Input text cannot be None >>> word_occurrence_counter(12345) Traceback (most recent call last): ... TypeError: Expected a string as input, found int ``` This question maintains consistency with the original examples in terms of style, length, complexity, and scope. It provides clear requirements, input-output specifications, example cases, and error handling necessary for a robust solution.","solution":"import re from collections import Counter def word_occurrence_counter(text: str) -> dict: if text is None: raise ValueError(\\"Input text cannot be None\\") if not isinstance(text, str): raise TypeError(f\\"Expected a string as input, found {type(text).__name__}\\") # Remove punctuation and convert to lowercase text = re.sub(r\'[^ws]\', \'\', text).lower() # Split the text into words words = text.split() # Count word occurrences using Counter word_counts = Counter(words) return dict(word_counts)"},{"question":"# Library Management System Database Design Problem Statement You are tasked with designing a simple Library Management System focusing on the relational database schema. The goal is to model the key entities and relationships of the system. Requirements Design the database schema with the following entities and their attributes: 1. **Books**: - `book_id` (integer): Primary key - `title` (string): The title of the book - `author_id` (integer): Foreign key referencing `Authors` - `genre` (string): Genre or category of the book - `published_year` (integer): The year the book was published 2. **Authors**: - `author_id` (integer): Primary key - `name` (string): The name of the author - `birth_year` (integer): The birth year of the author 3. **Members**: - `member_id` (integer): Primary key - `name` (string): The name of the member - `join_date` (date): The date the member joined the library 4. **Loans**: - `loan_id` (integer): Primary key - `member_id` (integer): Foreign key referencing `Members` - `book_id` (integer): Foreign key referencing `Books` - `loan_date` (date): The date the book was loaned - `return_date` (date, nullable): The date the book was returned Constraints - Each `book_id` and `author_id` should be unique within their respective tables. - Ensure that only existing `author_id` and `member_id` values are used in referencing tables. - The `loan_date` must always be before or equal to the `return_date` where `return_date` is not null. - A member can loan multiple books, and a book can be loaned to multiple members at different times. Output Produce the SQL statements to create the relational schema for the above requirements. Example Output Provide the SQL statements similar to the example below: ```sql CREATE TABLE Authors ( author_id INT PRIMARY KEY, name VARCHAR(255) NOT NULL, birth_year INT ); CREATE TABLE Books ( book_id INT PRIMARY KEY, title VARCHAR(255) NOT NULL, author_id INT, genre VARCHAR(100), published_year INT, FOREIGN KEY (author_id) REFERENCES Authors (author_id) ); CREATE TABLE Members ( member_id INT PRIMARY KEY, name VARCHAR(255) NOT NULL, join_date DATE NOT NULL ); CREATE TABLE Loans ( loan_id INT PRIMARY KEY, member_id INT, book_id INT, loan_date DATE NOT NULL, return_date DATE, FOREIGN KEY (member_id) REFERENCES Members (member_id), FOREIGN KEY (book_id) REFERENCES Books (book_id) ); ``` Hints - Use appropriate SQL data types for each attribute. - Make sure to define primary and foreign keys properly to maintain the integrity of data relationships. - Consider adding additional constraints such as `NOT NULL` and `CHECK` to meet the requirements. Ensure that your SQL statements create a fully functional and relationally consistent Library Management System database schema.","solution":"def create_library_management_schema(): schema = CREATE TABLE Authors ( author_id INT PRIMARY KEY, name VARCHAR(255) NOT NULL, birth_year INT ); CREATE TABLE Books ( book_id INT PRIMARY KEY, title VARCHAR(255) NOT NULL, author_id INT, genre VARCHAR(100), published_year INT, FOREIGN KEY (author_id) REFERENCES Authors (author_id) ); CREATE TABLE Members ( member_id INT PRIMARY KEY, name VARCHAR(255) NOT NULL, join_date DATE NOT NULL ); CREATE TABLE Loans ( loan_id INT PRIMARY KEY, member_id INT, book_id INT, loan_date DATE NOT NULL, return_date DATE, FOREIGN KEY (member_id) REFERENCES Members (member_id), FOREIGN KEY (book_id) REFERENCES Books (book_id), CHECK (loan_date <= return_date OR return_date IS NULL) ); return schema"},{"question":"# Sorting and Merging Two Sorted Lists You are developing a software that processes large datasets, and as part of this software, you need to implement a function that merges two sorted lists into a single sorted list. This function should take two lists of integers that are already sorted in non-decreasing order, and return a new sorted list containing all the elements from both input lists. # Function Signature ```python def merge_sorted_lists(list1: List[int], list2: List[int]) -> List[int]: ``` # Input - `list1` (List[int]): A list of integers sorted in non-decreasing order. - `list2` (List[int]): A list of integers sorted in non-decreasing order. # Output - `List[int]`: A new list containing all the elements from `list1` and `list2`, sorted in non-decreasing order. # Constraints - The lengths of `list1` and `list2` are within the range ([0, 10^6]). - The elements of `list1` and `list2` are integers in the range ([-10^9, 10^9]). - The function should have a time complexity of (O(n + m)), where (n) and (m) are the lengths of `list1` and `list2` respectively. # Examples 1. `merge_sorted_lists([1, 3, 5], [2, 4, 6])` should return `[1, 2, 3, 4, 5, 6]`. 2. `merge_sorted_lists([1, 2, 3], [ ])` should return `[1, 2, 3]`. 3. `merge_sorted_lists([ ], [4, 5, 6])` should return `[4, 5, 6]`. 4. `merge_sorted_lists([1, 4, 5], [2, 3, 6])` should return `[1, 2, 3, 4, 5, 6]`. 5. `merge_sorted_lists([-5, 0, 10], [-10, 0, 15])` should return `[-10, -5, 0, 0, 10, 15]`. Implement the function in Python, ensuring efficient merging of the two sorted lists.","solution":"def merge_sorted_lists(list1, list2): Merges two sorted lists into a single sorted list. i, j = 0, 0 merged_list = [] while i < len(list1) and j < len(list2): if list1[i] <= list2[j]: merged_list.append(list1[i]) i += 1 else: merged_list.append(list2[j]) j += 1 # Append remaining elements from list1 or list2 while i < len(list1): merged_list.append(list1[i]) i += 1 while j < len(list2): merged_list.append(list2[j]) j += 1 return merged_list"},{"question":"# Problem Summary You are given an undirected graph represented as an adjacency list. Your task is to write a function that determines the shortest path from a given start node to a target node using Breadth-First Search (BFS). # Function Definition Write a function `shortest_path(adj_list: Dict[int, List[int]], start_node: int, target_node: int) -> List[int]` that accepts the following parameters: * `adj_list` (Dict[int, List[int]]): A dictionary representing the adjacency list of the graph, where keys are node identifiers (integers) and values are lists of adjacent node identifiers. * `start_node` (int): The node to start the search from. * `target_node` (int): The node to find the shortest path to. # Output * The function should return a list of integers representing the nodes that form the shortest path from `start_node` to `target_node`, including both. If no path exists, return an empty list. # Constraints * The graph will have at most 1000 nodes. * The graph does not contain negative weights. * Nodes are uniquely identified with non-negative integers. # Example Suppose you have the following graph: ```python adj_list = { 0: [1, 2], 1: [0, 3, 4], 2: [0, 4], 3: [1, 4, 5], 4: [1, 2, 3, 5], 5: [3, 4] } ``` Calling `shortest_path(adj_list, 0, 5)` should return `[0, 1, 3, 5]` because that is the shortest path from node 0 to node 5. # Implementation Guidelines * Implement the Breadth-First Search (BFS) algorithm to traverse the graph. * Use a queue to manage the nodes to be explored. * Maintain a visited set to avoid revisiting nodes. * Use a parent dictionary to reconstruct the path from `start_node` to `target_node`. * Return the constructed path as a list of nodes. # Additional Notes Consider edge cases such as: * The graph has no edges. * The `start_node` is the same as the `target_node`. * Proper handling of graphs where nodes are isolated (no connections).","solution":"from collections import deque def shortest_path(adj_list, start_node, target_node): Returns the shortest path from start_node to target_node using BFS. Parameters: adj_list (Dict[int, List[int]]): adjacency list of the graph. start_node (int): the starting node. target_node (int): the target node. Returns: List[int]: the shortest path from start_node to target_node, empty if no path. if start_node == target_node: return [start_node] queue = deque([start_node]) visited = set([start_node]) parent = {start_node: None} while queue: current = queue.popleft() if current == target_node: path = [] while current is not None: path.append(current) current = parent[current] return path[::-1] for neighbor in adj_list.get(current, []): if neighbor not in visited: visited.add(neighbor) parent[neighbor] = current queue.append(neighbor) return [] # Example usage adj_list = { 0: [1, 2], 1: [0, 3, 4], 2: [0, 4], 3: [1, 4, 5], 4: [1, 2, 3, 5], 5: [3, 4] } print(shortest_path(adj_list, 0, 5)) # Output: [0, 1, 3, 5]"},{"question":"# Scenario You are developing a new feature for a social media platform where users can tag their posts with multiple hashtags. To implement this feature effectively, you need to ensure that each hashtag is unique within a post and that they follow specific formatting rules. Specifically, hashtags must start with the `#` symbol and can only contain alphanumeric characters. # Task Write a function `validate_hashtags(hashtags: List[str]) -> bool` that verifies a list of hashtags according to the following rules: 1. Each hashtag in the list must start with the `#` symbol. 2. Each hashtag must contain only alphanumeric characters after the `#` symbol. 3. No two hashtags in the list should be identical. # Input - A list of strings `hashtags` representing the hashtags in a single post (0 ≤ length of `hashtags` ≤ 10^3). - Each hashtag string has a length range of (1 ≤ length of each hashtag ≤ 50). # Output - Return a boolean value `True` if all hashtags meet the specified criteria. Otherwise, return `False`. # Example ```python input: [\'#love\', \'#sunshine\', \'#123\'] output: True input: [\'#love\', \'#love\', \'#sunshine\'] output: False input: [\'#love\', \'sunshine\', \'#123\'] output: False ``` # Constraints - Ensure that the function handles cases with an empty list of hashtags correctly. - The function should operate efficiently with respect to both time and space. # Notes - Consider edge cases such as repeated hashtags or invalid formats. - Use appropriate data structures to check for uniqueness effectively.","solution":"from typing import List def validate_hashtags(hashtags: List[str]) -> bool: Validates the list of hashtags according to the rules: 1. Each hashtag must start with the `#` symbol. 2. Each hashtag must contain only alphanumeric characters after the `#` symbol. 3. No two hashtags should be identical. seen = set() for hashtag in hashtags: if len(hashtag) < 2 or hashtag[0] != \'#\' or not hashtag[1:].isalnum(): return False if hashtag in seen: return False seen.add(hashtag) return True"},{"question":"# Coding Assessment Question: Scenario: You are tasked with developing a function to calculate the intersection of two lists of integers. The intersection of two lists is a list containing all the elements that appear in both lists, without duplicates. Task: Write a function `list_intersection(list1: List[int], list2: List[int]) -> List[int]` that: 1. Takes two lists of integers `list1` and `list2`. 2. Computes the intersection of these two lists. 3. Returns a list of integers that are present in both input lists, without duplicates. The result list should be sorted in ascending order. Input: - Two lists of integers `list1` and `list2`, where each list contains `0 <= len(list) <= 10^6` elements and each integer is in the range `-10^9` to `10^9`. Output: - A list of integers representing the intersection of the two input lists. Constraints: - If either of the input parameters is not a list, raise a `TypeError` with the message: \\"both inputs must be lists of integers\\". - If the elements of either list are not integers, raise a `ValueError` with the message: \\"all elements in the input lists must be integers\\". Example: ```python list_intersection([1, 2, 3, 4], [3, 4, 5, 6]) # Returns [3, 4] list_intersection([10, 20, 30, 40], [15, 20, 25, 30]) # Returns [20, 30] list_intersection([1, 1, 2, 3], [2, 2, 3, 4]) # Returns [2, 3] ``` Requirements: - Implement robust error handling for invalid inputs. - Optimize for performance, especially considering the potential size of the input lists. - Ensure clear and maintainable code, using Pythonic conventions where appropriate.","solution":"from typing import List def list_intersection(list1: List[int], list2: List[int]) -> List[int]: Returns a sorted list of the intersection of two input lists, containing only unique elements. Raises TypeError if inputs are not lists or ValueError if list elements are not integers. if not isinstance(list1, list) or not isinstance(list2, list): raise TypeError(\\"both inputs must be lists of integers\\") if not all(isinstance(x, int) for x in list1) or not all(isinstance(x, int) for x in list2): raise ValueError(\\"all elements in the input lists must be integers\\") set1 = set(list1) set2 = set(list2) intersection = sorted(set1 & set2) return intersection"},{"question":"# Coding Assessment Question Scenario You are given a matrix representing the layout of a garden where each cell contains an integer representing the height of a plant in that cell. Your task is to find the highest possible sum of the heights of plants in any rectangular submatrix of the garden. Problem Statement Write a function `max_sum_submatrix(matrix: List[List[int]]) -> int` that computes the highest possible sum of the heights of plants in any rectangular submatrix within the provided garden layout. Input - `matrix`: A list of lists containing integers representing the matrix of plant heights. Output - The function should return an integer representing the highest possible sum of the heights of plants in any rectangular submatrix. Constraints - 1 <= len(matrix), len(matrix[0]) <= 100 - Each element in the matrix is an integer with a value between -10^5 and 10^5. Example ```python def max_sum_submatrix(matrix: list[list[int]]) -> int: Returns the highest possible sum of the heights of plants in any rectangular submatrix >>> matrix = [ ... [1, 2, -1, -4, -20], ... [-8, -3, 4, 2, 1], ... [3, 8, 10, 1, 3], ... [-4, -1, 1, 7, -6], ... ] >>> max_sum_submatrix(matrix) 29 >>> matrix = [ ... [2, 2, -1], ... [0, -2, 3], ... [-1, 3, 1] ... ] >>> max_sum_submatrix(matrix) 7 >>> matrix = [ ... [-1] ... ] >>> max_sum_submatrix(matrix) -1 def max_sum_subarray(arr): max_sum = curr_sum = arr[0] for num in arr[1:]: curr_sum = max(num, curr_sum + num) max_sum = max(max_sum, curr_sum) return max_sum if not matrix or not matrix[0]: return 0 num_rows, num_cols = len(matrix), len(matrix[0]) max_sum = float(\'-inf\') for left_col in range(num_cols): temp = [0] * num_rows for right_col in range(left_col, num_cols): for row in range(num_rows): temp[row] += matrix[row][right_col] max_sum = max(max_sum, max_sum_subarray(temp)) return max_sum if __name__ == \\"__main__\\": import doctest doctest.testmod() ```","solution":"from typing import List def max_sum_submatrix(matrix: List[List[int]]) -> int: Returns the highest possible sum of the heights of plants in any rectangular submatrix. Args: matrix (List[List[int]]): The 2D matrix of integers representing plant heights. Returns: int: The highest possible sum of the heights of plants in any rectangular submatrix. def max_sum_subarray(arr): Helper function to calculate the max subarray sum using Kadane\'s algorithm max_sum = curr_sum = arr[0] for num in arr[1:]: curr_sum = max(num, curr_sum + num) max_sum = max(max_sum, curr_sum) return max_sum if not matrix or not matrix[0]: return 0 num_rows, num_cols = len(matrix), len(matrix[0]) max_sum = float(\'-inf\') for left_col in range(num_cols): temp = [0] * num_rows for right_col in range(left_col, num_cols): for row in range(num_rows): temp[row] += matrix[row][right_col] max_sum = max(max_sum, max_sum_subarray(temp)) return max_sum"},{"question":"# Question: Implement a Function to Calculate the Minimum Number of Platforms Required at a Railway Station **Context**: Your task is to write a function that calculates the minimum number of platforms required at a railway station so that no train has to wait. We have the arrival and departure times of all trains that reach the station. **Function**: `min_platforms(arrivals: List[str], departures: List[str]) -> int` **Input**: 1. `arrivals` (List of strings) - A list of arrival times of trains in 24-hour format (\'HH:MM\'). 2. `departures` (List of strings) - A list of departure times of trains in 24-hour format (\'HH:MM\'). **Output**: 1. `min_platforms` returns an integer which represents the minimum number of platforms required. **Constraints**: * 1 ≤ n ≤ 1000, where n is the number of trains. * Arrival times and corresponding departure times are correctly formatted and pairs belong to the same train. * Any train\'s departure time will always be after its arrival time on the same day (no overnight departures). **Examples**: 1. `min_platforms([\'09:00\', \'09:45\', \'10:00\'], [\'09:30\', \'10:15\', \'10:30\'])` returns `2` 2. `min_platforms([\'09:00\', \'09:40\', \'09:50\'], [\'09:30\', \'12:00\', \'11:20\'])` returns `2` 3. `min_platforms([\'09:00\', \'09:05\', \'09:10\'], [\'09:15\', \'09:20\', \'09:30\'])` returns `3` 4. `min_platforms([\'14:00\', \'14:05\'], [\'14:10\', \'14:15\'])` returns `2` **Performance Requirements**: * The function should handle the maximum input sizes efficiently.","solution":"def min_platforms(arrivals, departures): Calculate the minimum number of platforms required at a railway station so that no train has to wait. :param arrivals: List of arrival times of trains in 24-hour format (\'HH:MM\') :param departures: List of departure times of trains in 24-hour format (\'HH:MM\') :return: Minimum number of platforms required # Convert times into minutes since start of the day arrivals = [int(time[:2]) * 60 + int(time[3:]) for time in arrivals] departures = [int(time[:2]) * 60 + int(time[3:]) for time in departures] # Sort arrivals and departures arrivals.sort() departures.sort() n = len(arrivals) platform_count = 0 max_platforms = 0 i, j = 0, 0 while i < n and j < n: if arrivals[i] < departures[j]: platform_count += 1 max_platforms = max(max_platforms, platform_count) i += 1 else: platform_count -= 1 j += 1 return max_platforms"},{"question":"**Question**: Design a **LRU Cache** class that supports `get` and `put` operations with constant average time complexity. # Context Your task is to implement a Least Recently Used (LRU) cache. The LRU cache should evict the least recently used item when it reaches its capacity. This type of cache is widely used for optimizing memory usage in applications requiring fast access to previously accessed data. # Task Implement an `LRUCache` class: - `LRUCache(capacity: int)` Initializes the LRU cache with positive size `capacity`. - `get(key: int) -> int` Retrieve the value associated with the `key` if the key exists in the cache, otherwise return `-1`. - `put(key: int, value: int) -> None` Insert or update the value associated with the `key`. If the number of keys exceeds the capacity, evict the least recently used key. # Requirements - The `get` and `put` operations should run in ( O(1) ) average time complexity. - Capacity value is a positive integer and does not change after the cache is initialized. # Example ```python # Example usage cache = LRUCache(2) # LRU Cache capacity set to 2 cache.put(1, 1) cache.put(2, 2) assert cache.get(1) == 1 # returns 1 cache.put(3, 3) # evicts key 2 assert cache.get(2) == -1 # returns -1 (not found) cache.put(4, 4) # evicts key 1 assert cache.get(1) == -1 # returns -1 (not found) assert cache.get(3) == 3 # returns 3 assert cache.get(4) == 4 # returns 4 ``` # Implementation Details You may use a combination of a dictionary and a doubly linked list. The dictionary stores the keys and corresponding node addresses of the linked list, allowing O(1) access time. The doubly linked list maintains the order of usage, ensuring that once the cache exceeds its capacity, the least recently used item can be efficiently removed.","solution":"class LRUCache: class Node: def __init__(self, key: int, value: int): self.key = key self.value = value self.prev = None self.next = None def __init__(self, capacity: int): self.capacity = capacity self.cache = {} self.head = self.Node(0, 0) self.tail = self.Node(0, 0) self.head.next = self.tail self.tail.prev = self.head def _remove(self, node: Node): prev, next = node.prev, node.next prev.next, next.prev = next, prev def _add(self, node: Node): next = self.head.next node.next, node.prev = next, self.head self.head.next, next.prev = node, node def get(self, key: int) -> int: if key in self.cache: node = self.cache[key] self._remove(node) self._add(node) return node.value return -1 def put(self, key: int, value: int): if key in self.cache: self._remove(self.cache[key]) node = self.Node(key, value) self._add(node) self.cache[key] = node if len(self.cache) > self.capacity: node_to_remove = self.tail.prev self._remove(node_to_remove) del self.cache[node_to_remove.key]"},{"question":"# Coding Assessment Question **Context**: You are participating in a puzzle competition where you have to arrange blocks in a certain pattern. The pattern is such that every row has exactly one more block than the row above, starting with one block at the top. **Task**: Write a function `find_complete_rows(blocks: int) -> int` that: 1. Receives an integer `blocks` (1 ≤ blocks ≤ 10^9), representing the total number of blocks available. 2. Returns the number of complete rows that can be formed with these blocks. **Input**: - An integer `blocks` representing the total number of blocks. **Output**: - An integer representing the number of complete rows that can be formed. **Explanation**: To form the pattern, each row `i` requires `i` blocks. The goal is to determine how many full rows you can form before running out of blocks. **Examples**: ```python print(find_complete_rows(5)) # Output: 2 (Rows: 1, 2; Remaining blocks: 2) print(find_complete_rows(8)) # Output: 3 (Rows: 1, 2, 3; Remaining blocks: 2) print(find_complete_rows(15)) # Output: 5 (Rows: 1, 2, 3, 4, 5; Remaining blocks: 0) print(find_complete_rows(1)) # Output: 1 (Rows: 1; Remaining blocks: 0) print(find_complete_rows(10)) # Output: 4 (Rows: 1, 2, 3, 4; Remaining blocks: 0) ``` **Function Signature**: ```python def find_complete_rows(blocks: int) -> int: pass ``` Ensure your solution efficiently calculates the number of complete rows that can be formed with the given blocks, particularly handling large input values effectively.","solution":"def find_complete_rows(blocks: int) -> int: Given the total number of blocks, return the number of complete rows that can be formed. Every row i needs exactly i blocks. rows = 0 while blocks > 0: rows += 1 blocks -= rows if blocks < 0: rows -= 1 break return rows"},{"question":"# Problem Statement Sorting is a fundamental operation in computer science, often employed to arrange elements in a specific order. One common sorting algorithm is the Merge Sort, which uses the divide-and-conquer technique. Your task is to implement the Merge Sort algorithm to sort a list of integers. # Implement the Function ```python def merge_sort(array: list) -> list: Sort an array of integers using the Merge Sort algorithm. Parameters: - array (list): The list of integers to be sorted. Returns: - sorted_array (list): The sorted list of integers. Example: >>> merge_sort([4, 2, 5, 1, 6, 3]) [1, 2, 3, 4, 5, 6] >>> merge_sort([0, -1, 3, 8, 7, 2]) [-1, 0, 2, 3, 7, 8] >>> merge_sort([1]) [1] >>> merge_sort([]) [] Constraints: - The elements in the list are all integers. - The list can contain zero or more elements. - The list may contain negative integers. - The time complexity should be O(n log n). pass ``` # Requirements: 1. **Divide and Conquer Approach**: * Continuously split the array into halves until each sub-array contains a single element. 2. **Merge Function**: * Write a helper function to merge two sorted lists into a single sorted list. 3. **Recursive Sorting**: * Recursively sort the split arrays and merge them back together. 4. **Edge Cases**: * Handle edge cases such as empty lists and single-element lists appropriately. Implement the `merge_sort` function as described. Use the provided test cases to ensure your function works correctly.","solution":"def merge_sort(array: list) -> list: Sort an array of integers using the Merge Sort algorithm. Parameters: - array (list): The list of integers to be sorted. Returns: - sorted_array (list): The sorted list of integers. if len(array) <= 1: return array mid = len(array) // 2 left_half = merge_sort(array[:mid]) right_half = merge_sort(array[mid:]) return merge(left_half, right_half) def merge(left: list, right: list) -> list: Merge two sorted lists into a single sorted list. Parameters: - left (list): The first sorted list. - right (list): The second sorted list. Returns: - merged_list (list): The merged sorted list. merged_list = [] i = 0 j = 0 while i < len(left) and j < len(right): if left[i] <= right[j]: merged_list.append(left[i]) i += 1 else: merged_list.append(right[j]) j += 1 while i < len(left): merged_list.append(left[i]) i += 1 while j < len(right): merged_list.append(right[j]) j += 1 return merged_list"},{"question":"Linked List Cycle Detection # Context You are tasked with implementing a feature that detects if a linked list contains a cycle. A cycle occurs when a node\'s next pointer points back to a previous node, forming a loop. # Problem Statement Implement the function `has_cycle(head: ListNode) -> bool` that checks whether a given singly linked list contains a cycle. # Input - `head`: The head of the singly linked list. # Output - Returns `True` if there is a cycle in the linked list, otherwise `False`. # Constraints - The function should operate in (O(n)) time complexity and use (O(1)) space complexity. - The number of nodes in the linked list is in the range `[0, 10^4]`. - Node values and the linked list structure conform to standard singly linked list conventions. # Example Input/Output Pairs: Example 1 - **Input** - Linked list: `3 -> 2 -> 0 -> -4 -> (cycles back to node with value 2)` - **Output**: `True` - **Explanation**: There is a cycle in the linked list. Example 2 - **Input** - Linked list: `1 -> 2 -> (cycles back to node with value 1)` - **Output**: `True` - **Explanation**: There is a cycle in the linked list. Example 3 - **Input** - Linked list: `1 -> 2 -> 3` - **Output**: `False` - **Explanation**: There is no cycle in the linked list. # Implementation Make sure your solution is efficient and handles edge cases, such as an empty list or a single node without a cycle effectively.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def has_cycle(head: ListNode) -> bool: Detects if a linked list has a cycle. Args: head (ListNode): The head of the singly linked list. Returns: bool: True if there is a cycle in the linked list, False otherwise. if not head or not head.next: return False slow = head fast = head.next while fast and fast.next: if slow == fast: return True slow = slow.next fast = fast.next.next return False"},{"question":"Array Shuffling You need to create a function that takes a list of integers and rearranges its elements in such a way that every consecutive pair of elements are swapped. If the list has an odd number of elements, the last element should remain in its original position. # Function Specification **Function Name**: `shuffle_array` **Input**: 1. `arr` (List[int]): A list of integers. **Output**: - Returns a new list of integers where each consecutive pair of elements has been swapped. # Constraints: - The input list will contain at most 10^5 integers. - If the list is empty, return an empty list. - The list can contain both positive and negative integers, as well as zero. # Examples: ```python shuffle_array([1, 2, 3, 4]) # Output: [2, 1, 4, 3] shuffle_array([5, 6, 7]) # Output: [6, 5, 7] shuffle_array([9, 1, 8, 3, 4]) # Output: [1, 9, 3, 8, 4] shuffle_array([]) # Output: [] shuffle_array([10]) # Output: [10] ``` # Additional Notes: Ensure that your implementation handles lists with different lengths efficiently. Remember that if the list length is odd, the last element should not be altered. # Testing: * Handle empty lists. * Handle lists with a single element. * Handle lists with consecutive pairs to be swapped. * Ensure that the function can process large lists efficiently. Write the function `shuffle_array` that rearranges the elements based on the above rules.","solution":"def shuffle_array(arr): Rearranges the elements in such a way that every consecutive pair of elements is swapped. If the list has an odd number of elements, the last element should remain in its original position. :param arr: List[int] - A list of integers. :return: List[int] - A new list of integers where each consecutive pair of elements has been swapped. # Create a copy of the original list to avoid modifying it in-place new_arr = arr.copy() # Iterate over the list in steps of 2 for i in range(1, len(arr), 2): new_arr[i], new_arr[i-1] = arr[i-1], arr[i] return new_arr"},{"question":"Problem Statement # Context You are working on a text processing application where it is essential to analyze sentences and identify certain word patterns. Specifically, you need to determine if a sentence contains a particular sequence of words, regardless of case and punctuation. # Task Write a Python function `contains_word_sequence` that determines if a sentence contains a specific sequence of words in the given order. The function should ignore case and punctuation. # Requirements * **Input**: * `sentence` (str): A sentence that may contain punctuation marks (1 ≤ len(sentence) ≤ 1000). * `words` (list of str): A list of words in a sequence (1 ≤ len(words) ≤ 100, 1 ≤ len(words[i]) ≤ 50). * **Output**: * `True` if the sequence of words appears in the sentence in the given order, otherwise `False`. # Constraints 1. The function should ignore case and punctuation in the sentence. 2. The words in the list must appear consecutively in the provided order within the sentence. # Function Signature ```python def contains_word_sequence(sentence: str, words: list[str]) -> bool: pass ``` # Example ```python assert contains_word_sequence(\\"Hello, world! How are you today?\\", [\\"hello\\", \\"world\\"]) == True assert contains_word_sequence(\\"This is a simple test.\\", [\\"simple\\", \\"is\\"]) == False assert contains_word_sequence(\\"A quick brown fox; jumps over the lazy dog.\\", [\\"quick\\", \\"brown\\", \\"fox\\"]) == True assert contains_word_sequence(\\"The rain in Spain stays mainly in the plain.\\", [\\"The\\", \\"Spain\\", \\"plain\\"]) == True ``` # Implementation Details - The function should use a two-pointer technique to match the sequence of words in the sentence. - Normalize the sentence by converting it to lowercase and removing punctuation before performing the matching.","solution":"import re def contains_word_sequence(sentence: str, words: list[str]) -> bool: Determines if a sentence contains a specific sequence of words in the given order. The function ignores case and punctuation. Args: - sentence (str): A sentence that may contain punctuation marks. - words (list of str): A list of words in sequence. Returns: - bool: True if the sequence of words appears in the sentence in the given order, otherwise False. # Convert the sentence to lowercase sentence = sentence.lower() # Remove all punctuation using regex sentence = re.sub(r\'[^ws]\', \'\', sentence) # Split the sentence into words sentence_words = sentence.split() # Initialize pointers for sentence_words and words i, j = 0, 0 # Loop through sentence_words while i < len(sentence_words) and j < len(words): # If the current word matches, move to the next word in words if sentence_words[i] == words[j].lower(): j += 1 # Always move to the next word in sentence_words i += 1 # If we have matched all words in the list, return True return j == len(words)"},{"question":"Problem Statement You are tasked with implementing a function that performs matrix rotation. Given a square matrix, write a function that rotates the matrix 90 degrees clockwise in place. This means modifying the input matrix without using extra space. # Function Signature ```python def rotate_matrix(matrix: List[List[int]]) -> None: pass ``` # Input - `matrix` (List[List[int]]): An `n x n` matrix where `1 <= n <= 1000`. # Output - None. Modify the matrix in place. # Constraints - The matrix contains only integer elements. - Do not use extra space; perform the rotation in place. # Examples ```python matrix1 = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate_matrix(matrix1) assert matrix1 == [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] matrix2 = [ [ 5, 1, 9, 11], [ 2, 4, 8, 10], [13, 3, 6, 7], [15, 14, 12, 16] ] rotate_matrix(matrix2) assert matrix2 == [ [15, 13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7, 10, 11] ] ``` # Explanation 1. In the first example, matrix1 is initially: ``` 1 2 3 4 5 6 7 8 9 ``` After rotating 90 degrees clockwise, matrix1 becomes: ``` 7 4 1 8 5 2 9 6 3 ``` 2. In the second example, matrix2 is initially: ``` 5 1 9 11 2 4 8 10 13 3 6 7 15 14 12 16 ``` After rotating 90 degrees clockwise, matrix2 becomes: ``` 15 13 2 5 14 3 4 1 12 6 8 9 16 7 10 11 ``` # Notes - Instead of using additional memory, swap elements within the matrix to achieve the rotation. - Consider how you can perform the rotation through a series of swaps, saving space and ensuring in-place modification. # Additional Test Cases ```python matrix3 = [ [1] ] rotate_matrix(matrix3) assert matrix3 == [ [1] ] matrix4 = [ [2, 29, 20, 26, 16, 28], [12, 27, 9, 25, 13, 21], [32, 33, 32, 2, 28, 14], [13, 14, 32, 27, 22, 26], [33, 1, 20, 7, 21, 7], [4, 24, 1, 6, 32, 34] ] rotate_matrix(matrix4) assert matrix4 == [ [4, 33, 13, 32, 12, 2], [24, 1, 14, 33, 27, 29], [1, 20, 32, 32, 9, 20], [6, 7, 27, 2, 25, 26], [32, 21, 22, 28, 13, 16], [34, 7, 26, 14, 21, 28] ] ```","solution":"from typing import List def rotate_matrix(matrix: List[List[int]]) -> None: Rotates the given n x n matrix 90 degrees clockwise in place. n = len(matrix) # First step is to transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Then reverse each row to get the 90-degree rotated matrix for i in range(n): matrix[i].reverse()"},{"question":"In this challenge, you are required to implement functions related to matrix manipulation. You will focus on rotating a square matrix 90 degrees clockwise and counterclockwise and extracting the primary and secondary diagonals from a matrix. # Function to Implement 1. **rotate_matrix_clockwise**: This function should rotate a given NxN matrix 90 degrees clockwise. 2. **rotate_matrix_counterclockwise**: This function should rotate a given NxN matrix 90 degrees counterclockwise. 3. **extract_diagonals**: This function should extract both the primary and secondary diagonals from a given NxN matrix. # Input and Output * **Input**: - For **rotate_matrix_clockwise** and **rotate_matrix_counterclockwise**: A list of lists representing an NxN matrix. - For **extract_diagonals**: A list of lists representing an NxN matrix. * **Output**: - For **rotate_matrix_clockwise**: A list of lists representing the matrix rotated 90 degrees clockwise. - For **rotate_matrix_counterclockwise**: A list of lists representing the matrix rotated 90 degrees counterclockwise. - For **extract_diagonals**: A tuple containing two lists: the primary and secondary diagonals of the matrix. # Constraints * The matrix will always be square (NxN). * 1 ≤ N ≤ 100. * Matrix elements will be integers. # Example ```python def rotate_matrix_clockwise(matrix: list) -> list: pass def rotate_matrix_counterclockwise(matrix: list) -> list: pass def extract_diagonals(matrix: list) -> tuple: pass # Example usage: matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotated_cw = rotate_matrix_clockwise(matrix) # Output: [ # [7, 4, 1], # [8, 5, 2], # [9, 3, 0] # ] rotated_ccw = rotate_matrix_counterclockwise(matrix) # Output: [ # [3, 6, 9], # [2, 5, 8], # [1, 4, 7] # ] (diagonals_primary, diagonals_secondary) = extract_diagonals(matrix) # Output: ([1, 5, 9], [3, 5, 7]) ``` # Requirements 1. The **rotate_matrix_clockwise** function must rotate the given NxN matrix 90 degrees clockwise. 2. The **rotate_matrix_counterclockwise** function must rotate the given NxN matrix 90 degrees counterclockwise. 3. The **extract_diagonals** function must extract and return both the primary and secondary diagonals of the matrix as a tuple of lists.","solution":"def rotate_matrix_clockwise(matrix: list) -> list: n = len(matrix) return [[matrix[n - j - 1][i] for j in range(n)] for i in range(n)] def rotate_matrix_counterclockwise(matrix: list) -> list: n = len(matrix) return [[matrix[j][n - i - 1] for j in range(n)] for i in range(n)] def extract_diagonals(matrix: list) -> tuple: n = len(matrix) primary_diagonal = [matrix[i][i] for i in range(n)] secondary_diagonal = [matrix[i][n - i - 1] for i in range(n)] return (primary_diagonal, secondary_diagonal)"},{"question":"# Question: String Manipulation and Pattern Matching Challenge Context: Consider a utility class designed to handle advanced string manipulation and pattern matching operations. The class supports various methods for transforming strings, finding patterns, and validating specific string formats. Task: Extend the functionality of the existing string utility class with the following new methods: 1. `find_anagrams(word, candidates)`: Given a word and a list of candidates, find all anagrams of the word within the candidates. 2. `longest_palindromic_substring(s)`: Given a string `s`, find and return the longest palindromic substring. 3. `validate_brackets(s)`: Determine if the sequence of brackets in a given string `s` is valid. The string contains only the characters \'(\', \')\', \'[\', \']\', \'{\', and \'}\'. Implementation Details: - **find_anagrams(word, candidates)**: - Input: `word` (string), `candidates` (list of strings). - Output: List of strings that are anagrams of the given word. - **longest_palindromic_substring(s)**: - Input: `s` (string). - Output: Longest substring which is a palindrome. - **validate_brackets(s)**: - Input: `s` (string). - Output: Boolean indicating if the bracket sequence is valid. Constraints: - The input string length for each method will not exceed 10000 characters. - Only lower-case alphabets are considered for anagram matching. - Ignore case sensitivity for palindrome detection and anagram finding. - Empty string returns should be handled appropriately. Example: ```python string_util = StringUtility() # Anagram Finder print(string_util.find_anagrams(\\"listen\\", [\\"enlist\\", \\"google\\", \\"inlets\\", \\"banana\\"])) # Output: [\\"enlist\\", \\"inlets\\"] # Longest Palindromic Substring print(string_util.longest_palindromic_substring(\\"babad\\")) # Output: \\"bab\\" (or \\"aba\\") # Bracket Validator print(string_util.validate_brackets(\\"([]){}\\")) # Output: True print(string_util.validate_brackets(\\"([)]\\")) # Output: False ``` The crafting of these methods should foster a comprehensive understanding of string handling techniques, from pattern recognition to advanced substring operations and structural validation.","solution":"class StringUtility: def find_anagrams(self, word, candidates): from collections import Counter word_counter = Counter(word.lower()) anagrams = [candidate for candidate in candidates if Counter(candidate.lower()) == word_counter] return anagrams def longest_palindromic_substring(self, s): n = len(s) if n == 0: return \\"\\" def expand_around_center(left, right): while left >= 0 and right < n and s[left].lower() == s[right].lower(): left -= 1 right += 1 return s[left+1:right] longest = \\"\\" for i in range(n): # Odd length palindromes palindrome1 = expand_around_center(i, i) # Even length palindromes palindrome2 = expand_around_center(i, i+1) # Update longest palindrome found if len(palindrome1) > len(longest): longest = palindrome1 if len(palindrome2) > len(longest): longest = palindrome2 return longest def validate_brackets(self, s): stack = [] matching_bracket = {\')\': \'(\', \']\': \'[\', \'}\': \'{\'} for char in s: if char in matching_bracket.values(): stack.append(char) elif char in matching_bracket.keys(): if stack == [] or stack.pop() != matching_bracket[char]: return False else: # Invalid character for bracket validation return False return stack == [] # Valid if no unmatched brackets remain"},{"question":"# Matrix Transposition Challenge Background: Working with matrices is a common problem in computer science and various applications, including graphics, machine learning, and simulations. One fundamental operation is matrix transposition, which involves flipping a matrix over its diagonal. Objective: Write a function `transpose_matrix(matrix: List[List[int]]) -> List[List[int]]` to transpose a given matrix. In the transposed version, the rows and columns of the original matrix are swapped. Requirements: * Implement the function using the following signature: ```python def transpose_matrix(matrix: List[List[int]]) -> List[List[int]]: ``` * Your function should take a 2D list of integers representing a matrix and return its transpose. * The matrix you get as input can be any size, including square and rectangular matrices. Input and Output: * **Input**: A 2D list `matrix` of integers. * **Output**: A 2D list representing the transposed matrix. Constraints: * The number of rows and columns in the matrix will be between 1 and 1000. * Each element in the matrix will be an integer between -10^6 and 10^6. Performance Expectations: * Your implementation should efficiently handle matrices up to size 1000x1000. Example: ```python matrix1 = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] print(transpose_matrix(matrix1)) # Expected output: # [ # [1, 4, 7], # [2, 5, 8], # [3, 6, 9] # ] matrix2 = [ [1, 2, 3], [4, 5, 6] ] print(transpose_matrix(matrix2)) # Expected output: # [ # [1, 4], # [2, 5], # [3, 6] # ] ``` Edge cases to consider: * A matrix with only one row. * A matrix with only one column. * A matrix where all elements are the same value.","solution":"from typing import List def transpose_matrix(matrix: List[List[int]]) -> List[List[int]]: Transpose the given 2D matrix. Rows become columns and vice versa. :param matrix: List[List[int]] representing the original matrix. :return: List[List[int]] representing the transposed matrix. if not matrix or not matrix[0]: return [] rows, cols = len(matrix), len(matrix[0]) transposed = [[0] * rows for _ in range(cols)] for r in range(rows): for c in range(cols): transposed[c][r] = matrix[r][c] return transposed"},{"question":"# Coding Assessment Question You are given a list of tuples representing points in a 2D plane. Each tuple contains two integers `(x, y)` representing the coordinates of a point. Your task is to implement a function that returns the distance between the two closest points in the list. Write a function `find_min_distance` that takes a list of tuples `points` and returns a float representing the shortest distance between any two points. Function Signature ```python def find_min_distance(points: list[tuple[int, int]]) -> float: pass ``` Input Format - `points`: A list of tuples where each tuple is of the form `(x, y)` with `x` and `y` being integers. Output Format A float representing the minimum distance between any two points in the list, rounded to 5 decimal places. Constraints - The length of `points` will be at least 2 and at most 10^5. - The coordinates of the points will be between -10^4 and 10^4 inclusive. Example ```python points = [(0, 0), (1, 1), (4, 5), (1, 0)] min_dist = find_min_distance(points) print(min_dist) # Output: # 1.0 ``` Performance Requirements - Your solution should have a time complexity of **O(n log n)**. - The space complexity should be **O(n)**. Good luck!","solution":"import math def find_min_distance(points: list[tuple[int, int]]) -> float: def dist(p1, p2): return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2) def closest_pair_strip(strip, d): min_d = d strip.sort(key=lambda p: p[1]) # Sort strip according to y coordinate for i in range(len(strip)): for j in range(i + 1, len(strip)): if (strip[j][1] - strip[i][1]) < min_d: d = dist(strip[i], strip[j]) if d < min_d: min_d = d else: break return min_d def closest_pair_rec(points_sorted_x): if len(points_sorted_x) <= 3: min_d = float(\'inf\') for i in range(len(points_sorted_x)): for j in range(i + 1, len(points_sorted_x)): min_d = min(min_d, dist(points_sorted_x[i], points_sorted_x[j])) return min_d mid = len(points_sorted_x) // 2 mid_point = points_sorted_x[mid] dl = closest_pair_rec(points_sorted_x[:mid]) dr = closest_pair_rec(points_sorted_x[mid:]) d = min(dl, dr) strip = [] for point in points_sorted_x: if abs(point[0] - mid_point[0]) < d: strip.append(point) return min(d, closest_pair_strip(strip, d)) points_sorted_x = sorted(points, key=lambda p: p[0]) return round(closest_pair_rec(points_sorted_x), 5)"},{"question":"# Question Context You have been tasked with developing a simple temperature conversion library that supports both Celsius and Fahrenheit conversions. Accurate temperature conversion functionality is essential for applications that deal with weather data, environmental controls, and more. Task Implement a function that converts temperatures between Celsius and Fahrenheit. This function should accurately handle conversion in both directions and be robust against invalid inputs. Function Specification ```python def temperature_conversion(temperature: float, scale: str) -> tuple: This function should convert the temperature from Celsius to Fahrenheit or vice versa based on the provided scale. Arguments: temperature (float): The input temperature value. scale (str): The scale to convert FROM, it should be either \'C\' for Celsius or \'F\' for Fahrenheit. Returns: tuple: A tuple (\'scale\', value), where \'scale\' is a string indicating the provided scale (\'C\' or \'F\'), and value is the float result of the converted temperature. Raises: ValueError: if the scale is not \'C\' or \'F\'. Example: >>> temperature_conversion(0, \'C\') (\'F\', 32.0) >>> temperature_conversion(32, \'F\') (\'C\', 0.0) >>> temperature_conversion(100, \'F\') (\'C\', 37.7778) >> temperature_conversion(100, \'X\') Raises ValueError: Invalid temperature scale pass # Your code here ``` Constraints 1. The \'scale\' argument must be either \'C\' (for Celsius) or \'F\' (for Fahrenheit). 2. Conversion formulas: - From Celsius to Fahrenheit: ( F = C times frac{9}{5} + 32 ) - From Fahrenheit to Celsius: ( C = (F - 32) times frac{5}{9} ) 3. For up to four decimal places of accuracy in the result. Performance Requirements The expected time complexity should be O(1) and space complexity should be O(1). Your Task Implement the function `temperature_conversion` as specified. Ensure that your function passes all the given test cases.","solution":"def temperature_conversion(temperature: float, scale: str) -> tuple: This function should convert the temperature from Celsius to Fahrenheit or vice versa based on the provided scale. Arguments: temperature (float): The input temperature value. scale (str): The scale to convert FROM, it should be either \'C\' for Celsius or \'F\' for Fahrenheit. Returns: tuple: A tuple (\'scale\', value), where \'scale\' is a string indicating the resulting scale (\'C\' or \'F\'), and value is the float result of the converted temperature. Raises: ValueError: if the scale is not \'C\' or \'F\'. if scale not in [\'C\', \'F\']: raise ValueError(\\"Invalid temperature scale\\") if scale == \'C\': converted_temperature = (temperature * 9/5) + 32 return (\'F\', round(converted_temperature, 4)) else: converted_temperature = (temperature - 32) * 5/9 return (\'C\', round(converted_temperature, 4))"},{"question":"# Question: Maximize Sum by Choosing Non-Adjacent Elements Given an array of positive integers, write a function to return the maximum sum you can obtain by selecting non-adjacent elements from the array. Your task is to implement the following function: ```python def max_non_adjacent_sum(arr: list[int]) -> int: pass ``` Input - `arr`: A list of positive integers representing the array. `1 <= len(arr) <= 10^4` and `1 <= arr[i] <= 10^4`. Output - The function should return an integer representing the maximum sum of non-adjacent elements. # Constraints 1. The sum must be obtained by choosing elements such that no two chosen elements are adjacent in the list. # Example Example 1 ```python print(max_non_adjacent_sum([3, 2, 5, 10, 7])) ``` **Expected Output**: ``` 15 ``` **Explanation**: We select the elements 3, 10, and 2. The sum is 3+10+2 = 15. Example 2 ```python print(max_non_adjacent_sum([3, 2, 7, 10])) ``` **Expected Output**: ``` 13 ``` **Explanation**: We select the elements 3 and 10. The sum is 3+10 = 13. # Tips - Dynamic programming is a suitable approach to solve this problem. - Maintain an array to keep track of the maximum sum possible up to each index without selecting adjacent elements. - For each element, you have the choice to either include it or exclude it in the sum, considering the maximum sum obtained by selecting non-adjacent elements before it.","solution":"def max_non_adjacent_sum(arr: list[int]) -> int: n = len(arr) if n == 0: return 0 elif n == 1: return arr[0] # dp array where dp[i] represents the maximum sum we can get by considering up to the i-th element and not allowing adjacent selections dp = [0] * n # base cases dp[0] = arr[0] dp[1] = max(arr[0], arr[1]) for i in range(2, n): # take the element at i or skip it dp[i] = max(dp[i-1], arr[i] + dp[i-2]) return dp[-1]"},{"question":"# Problem Statement You need to write a function that evaluates an arithmetic expression given as a string and returns the result as an integer. The expression will consist only of non-negative integers, the operators `+`, `-`, `*`, `/`, and will follow the standard operator precedence rules. The expression may also contain parentheses `()`, which should be used to override the default precedence. Division should use integer division, i.e., truncate towards zero. # Function Signature ```python def evaluate_expression(expression: str) -> int: Evaluates a given arithmetic expression string and returns the result as an integer. Parameters: expression (str): A string containing the arithmetic expression. Returns: int: The integer result of the evaluated expression. Example: >>> evaluate_expression(\\"3 + 5 * 2\\") 13 >>> evaluate_expression(\\"(2 + 6) * 3\\") 24 >>> evaluate_expression(\\"14 / 3\\") 4 pass ``` # Constraints - The `expression` will be a valid string consisting of digits (`0-9`), operators (`+`, `-`, `*`, `/`), parentheses (`()`) and possibly spaces. - The length of `expression` will not exceed ( 10^4 ) characters. - The given expression will not contain any invalid characters or malformed sequences. # Performance Requirements - The function should handle typical mathematical expressions efficiently, respecting the standard precedence rules and integer division. # Example Usage ```python assert evaluate_expression(\\"3 + 5 * 2\\") == 13 assert evaluate_expression(\\"(2 + 6) * 3\\") == 24 assert evaluate_expression(\\"14 / 3\\") == 4 assert evaluate_expression(\\"2 + 2 * 2 / 2\\") == 4 assert evaluate_expression(\\"(1+(4+5+2)-3)+(6+8)\\") == 23 ``` # Implementation Notes To solve this problem, consider using a stack to handle operators and operands while evaluating the expression based on the correct precedence rules. Parentheses will change the default precedence, so you might need to implement a method to handle them properly. Use a helper function if needed to simplify the evaluation of substrings within parentheses.","solution":"def evaluate_expression(expression: str) -> int: Evaluates a given arithmetic expression string and returns the result as an integer. def calculate(s: str) -> int: stack = [] num = 0 sign = \\"+\\" i = 0 while i < len(s): char = s[i] if char.isdigit(): num = num * 10 + int(char) if char == \\"(\\": j = i count = 0 while i < len(s): if s[i] == \\"(\\": count += 1 elif s[i] == \\")\\": count -= 1 if count == 0: break i += 1 num = calculate(s[j + 1:i]) if char in \\"+-*/\\" or i == len(s) - 1 or char == \\")\\": if sign == \\"+\\": stack.append(num) elif sign == \\"-\\": stack.append(-num) elif sign == \\"*\\": stack.append(stack.pop() * num) elif sign == \\"/\\": stack.append(int(stack.pop() / num)) sign = char num = 0 i += 1 return sum(stack) # Remove spaces from the expression expression = expression.replace(\\" \\", \\"\\") return calculate(expression)"},{"question":"# Scenario You are developing software for analyzing waves and their properties in physics. Given the formula `velocity = frequency × wavelength`, your task is to implement a function that calculates any one of the three properties: velocity, frequency, or wavelength, provided the other two values. # Task Write a function `calculate_wave_property(velocity, frequency, wavelength)` that: 1. Calculates and returns the missing property if exactly two of the three input values are provided (the third should be zero). 2. Raises a `ValueError` if more or less than two values are provided. 3. Raises a `ValueError` for physically implausible negative values. # Input and Output Formats Input * `velocity` (float): Wave velocity (m/s). Set to 0 if unknown. * `frequency` (float): Wave frequency (Hz). Set to 0 if unknown. * `wavelength` (float): Wave wavelength (m). Set to 0 if unknown. Output * A tuple containing the name of the calculated property and its value. # Function Signature ```python def calculate_wave_property(velocity: float, frequency: float, wavelength: float) -> tuple[str, float]: ``` # Example ```python # Example 1 # Velocity and Frequency are provided, calculate Wavelength. print(calculate_wave_property(velocity=300, frequency=60, wavelength=0)) # Output: (\'wavelength\', 5.0) # Example 2 # Frequency and Wavelength are provided, calculate Velocity. print(calculate_wave_property(velocity=0, frequency=50, wavelength=2)) # Output: (\'velocity\', 100.0) # Example 3 # Velocity and Wavelength are provided, calculate Frequency. print(calculate_wave_property(velocity=340, frequency=0, wavelength=2)) # Output: (\'frequency\', 170.0) ``` # Constraints * Only exactly two of the three inputs must be non-zero. The remaining third input must be zero. * Inputs must be non-negative. # Notes * The product of frequency and wavelength always gives the velocity of the wave. **Complete the implementation in Python.**","solution":"def calculate_wave_property(velocity: float, frequency: float, wavelength: float) -> tuple[str, float]: Calculates the missing wave property (velocity, frequency, or wavelength) based on the provided two properties. Parameters: velocity (float): Wave velocity (m/s). Set to 0 if unknown. frequency (float): Wave frequency (Hz). Set to 0 if unknown. wavelength (float): Wave wavelength (m). Set to 0 if unknown. Returns: tuple: Tuple containing the name of the calculated property (\'velocity\', \'frequency\', or \'wavelength\') and its value. Raises: ValueError: If not exactly two values are provided or if any of the values are negative. if [velocity, frequency, wavelength].count(0) != 1: raise ValueError(\\"Exactly two of the properties must be provided.\\") if velocity < 0 or frequency < 0 or wavelength < 0: raise ValueError(\\"Negative values are not allowed.\\") if velocity == 0: return \\"velocity\\", frequency * wavelength if frequency == 0: return \\"frequency\\", velocity / wavelength if wavelength == 0: return \\"wavelength\\", velocity / frequency"},{"question":"# Question: Implement an Auto-formatter for JSON Strings Description You are given a JSON-like string that lacks proper indentation and line breaks. Implement a function that formats this string with appropriate line breaks and indentation to make it more readable. The JSON-like string may contain nested objects and arrays. Function Signature ```python def format_json(json_string: str) -> str: pass ``` Input 1. `json_string` (str): The JSON-like string to be formatted. It contains printable ASCII characters only. Output - Returns a string representing the input JSON but formatted with appropriate line breaks and indentation (2 spaces per level of depth). Constraints 1. The length of `json_string` will not exceed 50,000 characters. 2. The input string will be a valid JSON-like format. Example ```python json_input = \'{\\"name\\":\\"John\\",\\"age\\":30,\\"cars\\":[\\"Ford\\",\\"BMW\\",\\"Fiat\\"],\\"address\\":{\\"city\\":\\"New York\\",\\"zipcode\\":10001}}\' formatted_json = format_json(json_input) print(formatted_json) # Expected output: # { # \\"name\\": \\"John\\", # \\"age\\": 30, # \\"cars\\": [ # \\"Ford\\", # \\"BMW\\", # \\"Fiat\\" # ], # \\"address\\": { # \\"city\\": \\"New York\\", # \\"zipcode\\": 10001 # } # } ``` Detailed Explanation - Objects are denoted by `{}` and arrays by `[]`. Keys and values are separated by colons (`:`). - Indent each level of depth within objects and arrays by 2 spaces. - Place each key-value pair on a new line within objects. - Place each element on a new line within arrays. - Handle nested structures by correctly applying increased indentation levels. # Performance Requirements - Aim to parse and format the string in linear time with respect to its length. Notes - Handle the whitespace and newline characters appropriately to ensure the formatted JSON is compact yet readable. - Ensure the function works for deeply nested JSON structures and various edge cases, such as empty objects or arrays.","solution":"import json def format_json(json_string: str) -> str: parsed_json = json.loads(json_string) return json.dumps(parsed_json, indent=2, separators=(\',\', \': \'))"},{"question":"# Problem Statement You are tasked with writing a function that identifies and extracts all unique words from a given list of sentences. The function should convert all words to lowercase and remove any punctuation before identifying unique words. # Description Given a list of strings `sentences`, where each string represents a sentence, write a function to extract all unique words in lowercase without any punctuation. # Function Signature ```python def extract_unique_words(sentences: List[str]) -> List[str]: ``` # Input * `sentences`: A list of strings, where each string represents a sentence containing words separated by spaces. # Output * A list of unique words in lowercase, sorted alphabetically. # Constraints * `1 <= len(sentences) <= 100` * `1 <= len(sentences[i]) <= 1000` * Sentences contain only printable ASCII characters. # Example ```python # Example input sentences = [ \\"Hello, world! This is a test.\\", \\"Another test, another world.\\", \\"This is the final, FINAL test.\\" ] # Example output [ \'a\', \'another\', \'final\', \'hello\', \'is\', \'test\', \'the\', \'this\', \'world\' ] ``` # Requirements * Handle upper and lower case characters by converting everything to lowercase. * Remove any punctuation from the words before identifying them as unique. * Optimize your solution for both readability and efficiency. # Notes * You may assume that the input will not contain any contractions or possessives (e.g., \\"don\'t\\", \\"Alice\'s\\"). * Focus on correctly handling edge cases such as sentences with lots of punctuation.","solution":"import re from typing import List def extract_unique_words(sentences: List[str]) -> List[str]: Extract all unique words from a list of sentences. Words are converted to lowercase and punctuation is removed. :param sentences: List of strings, where each string represents a sentence :return: List of unique words in lowercase, sorted alphabetically word_set = set() for sentence in sentences: # Remove punctuation and convert to lowercase cleaned_sentence = re.sub(r\'[^ws]\', \'\', sentence).lower() words = cleaned_sentence.split() word_set.update(words) return sorted(word_set)"},{"question":"# Problem Statement Given a series of operations that manipulate a stack, implement the corresponding functions to mimic the behavior of a stack using a custom class. The stack must support the following functionalities: push, pop, top, and get_min, where get_min returns the minimum element currently in the stack. # Objectives 1. **Stack Initialization**: Implement the `Stack` class to initialize an empty stack. 2. **Push Operation**: Implement the `push` function to add an item to the top of the stack. 3. **Pop Operation**: Implement the `pop` function to remove the top item of the stack. 4. **Top Operation**: Implement the `top` function to retrieve the top item without removing it. 5. **Get Min Operation**: Implement the `get_min` function to retrieve the minimum element in the stack. # Function Signatures - `__init__(self)` - `push(self, item: int) -> None` - `pop(self) -> int` - `top(self) -> int` - `get_min(self) -> int` # Example ```python stack = Stack() stack.push(5) stack.push(3) stack.push(8) stack.push(2) stack.push(4) print(stack.get_min()) # Output: 2 stack.pop() stack.pop() print(stack.get_min()) # Output: 3 print(stack.top()) # Output: 8 stack.pop() print(stack.top()) # Output: 3 stack.pop() print(stack.top()) # Output: 5 ``` # Constraints - Each item pushed onto the stack will be an integer within the range of [-10^5, 10^5]. - Multiple operations on the stack will not exceed 10^6 in total. # Hints 1. Use an auxiliary stack to keep track of the minimum values to ensure that `get_min` operations can be performed in constant time. 2. Ensure the auxiliary stack is updated correctly during both push and pop operations to maintain the minimum value in the stack efficiently. # Performance Requirements - Your solution should efficiently handle up to the maximum constraints within acceptable time limits.","solution":"class Stack: def __init__(self): self.main_stack = [] self.min_stack = [] def push(self, item: int) -> None: self.main_stack.append(item) if not self.min_stack or item <= self.min_stack[-1]: self.min_stack.append(item) def pop(self) -> int: if not self.main_stack: raise IndexError(\\"pop from empty stack\\") popped_item = self.main_stack.pop() if popped_item == self.min_stack[-1]: self.min_stack.pop() return popped_item def top(self) -> int: if not self.main_stack: raise IndexError(\\"top from empty stack\\") return self.main_stack[-1] def get_min(self) -> int: if not self.min_stack: raise IndexError(\\"get_min from empty stack\\") return self.min_stack[-1]"},{"question":"# Coding Question You are tasked with implementing a function that simulates the stock prices over a given number of days based on a starting price and a list of daily changes (in percentage). **Task**: Write a function that calculates the stock price for each day, given the starting price and a list of daily percentage changes. Return the list of stock prices for each day. # Function Signature ```python def stock_prices(starting_price: float, changes: List[float]) -> List[float]: ``` # Input - `starting_price` (float): The initial price of the stock. - `changes` (List[float]): A list of daily percentage changes in stock price. A positive number indicates a percentage increase, and a negative number indicates a percentage decrease. # Output - A list of floats representing the stock price at the end of each day. # Constraints - `0 < starting_price <= 10^6` - `1 <= len(changes) <= 1000` - Each percentage in `changes` will be in the range `[-100.0, 100.0]`. # Performance Requirements - The solution should handle the calculations efficiently within the constraints. # Example ```python # For a starting price of 100 and daily changes of [10, -5, 7] assert stock_prices(100, [10, -5, 7]) == [110.0, 104.5, 111.815] ``` # Notes - Use precise floating-point arithmetic to ensure accuracy in your calculations. - Consider edge cases such as zero or constant percentage changes over the days.","solution":"from typing import List def stock_prices(starting_price: float, changes: List[float]) -> List[float]: Calculates the stock price for each day given the starting price and a list of daily percentage changes. Parameters: starting_price (float): The initial price of the stock. changes (List[float]): A list of daily percentage changes in stock price. Returns: List[float]: A list of stock prices for each day. prices = [] current_price = starting_price for change in changes: current_price += current_price * (change / 100) prices.append(round(current_price, 6)) # Round to maintain precision return prices"},{"question":"# Problem: Unique Character Count In many string manipulation problems, understanding the frequency of different characters can be crucial. In this task, your goal is to write a function that counts the number of unique characters in a given string and returns a dictionary where each key is a unique character and its value is the count of its occurrences in the string. # Task Write a function `unique_char_count(s: str) -> dict` that takes a string as input and returns a dictionary with each unique character and its corresponding count. # Input * `s` (str): A string that may contain alphabetic characters, digits, punctuation, and whitespaces. # Output * (dict): A dictionary where keys are unique characters from the input string and values are their respective counts. # Constraints * The input string\'s length will not exceed 1000 characters. * All characters in the string are ASCII. # Example ```python def unique_char_count(s: str) -> dict: # Implement this function pass # Example Usage print(unique_char_count(\\"hello world!\\")) # Output: {\'h\': 1, \'e\': 1, \'l\': 3, \'o\': 2, \' \': 1, \'w\': 1, \'r\': 1, \'d\': 1, \'!\': 1} print(unique_char_count(\\"aabbcc\\")) # Output: {\'a\': 2, \'b\': 2, \'c\': 2} print(unique_char_count(\\"\\")) # Output: {} print(unique_char_count(\\"aaAA\\")) # Output: {\'a\': 2, \'A\': 2} print(unique_char_count(\\"123 321\\")) # Output: {\'1\': 2, \'2\': 2, \'3\': 2, \' \': 1} ``` # Additional Information 1. The function should consider all characters, including whitespace, punctuation, and digits. 2. The function should be case-sensitive, meaning \'a\' and \'A\' should be considered different characters. 3. An empty string should return an empty dictionary. 4. The frequency count should accurately reflect the occurrences of each unique character in the input string.","solution":"def unique_char_count(s: str) -> dict: Returns a dictionary with unique characters and their corresponding count from the input string. char_count = {} for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 return char_count"},{"question":"# Playlist Reordering Algorithm: Integrity Check Objective Design and implement an algorithm for reordering a playlist while maintaining the integrity of certain groups of songs. This problem assesses your ability to manage arrays and handle constraints in sequence manipulation. Function Signature ```python def reorder_playlist(songs: List[str], pinned_groups: List[List[int]]) -> List[str]: ... ``` Instructions 1. **Functionality**: - You will design a function that takes two parameters: - `songs`: A list of song names (List[str]). - `pinned_groups`: A list of sublists (List[List[int]]), where each sublist contains zero-based indices indicating which songs in the `songs` list must remain in sequence. - Your function should output a new list of songs. - The groups specified in `pinned_groups` should appear in the same order, but their internal order can be shuffled within each group. 2. **Considerations**: - Each group must stay in sequence relative to each other in the output; their relative positions in the list should not change. - The order of songs not in any `pinned_groups` sublist can be rearranged randomly. - If there are overlapping indices in `pinned_groups`, raise a ValueError. - Ensure the function efficiently handles large playlists with many groups. 3. **Examples**: - ```python reorder_playlist([\\"song1\\", \\"song2\\", \\"song3\\", \\"song4\\", \\"song5\\"], [[0, 2], [3, 4]]) # Possible output: [\\"song1\\", \\"song3\\", \\"song2\\", \\"song4\\", \\"song5\\"] ``` - ```python reorder_playlist([\\"track1\\", \\"track2\\", \\"track3\\", \\"track4\\"], [[]]) # Output: [\\"track1\\", \\"track2\\", \\"track3\\", \\"track4\\"], as empty pinned_groups implies no changes ``` 4. **Constraints**: - Ensure `songs` list length does not exceed (10^4). - Each sublist in `pinned_groups` references valid indices within the `songs` list. - Handle up to 100 groups of pinned song sequences. Notes: - Pay special attention to edge cases where there are no pinned groups or all songs are part of multiple groups which may cause overlaps. - Efficiency is key for larger playlists; design the function to maintain performance under the given constraints.","solution":"from typing import List def reorder_playlist(songs: List[str], pinned_groups: List[List[int]]) -> List[str]: # Ensure no overlapping indices in pinned_groups all_pinned_indices = set() for group in pinned_groups: for idx in group: if idx in all_pinned_indices: raise ValueError(\\"Overlapping indices in pinned groups\\") all_pinned_indices.add(idx) result = [] # Collect all pinned group songs in order for group in pinned_groups: group_songs = [songs[idx] for idx in group] result.extend(group_songs) # Collect all non-pinned songs non_pinned_songs = [songs[i] for i in range(len(songs)) if i not in all_pinned_indices] result.extend(non_pinned_songs) return result"},{"question":"# Context: You are part of a software development team designing an application to manage the ticket booking system for a movie theater. One of your tasks is to implement a function that will help visualize the seating arrangement of the theater to ensure social distancing. The function should take the total number of seats (arranged linearly) and return the positions where seats can be booked ensuring that no two booked seats are next to each other. # Problem Statement: Implement the function `determine_seating_positions` using the given skeleton code. The function should take as input the total number of seats and return a list of positions where seats can be booked while maintaining social distancing. # Function Signature: ```python def determine_seating_positions(total_seats: int) -> List[int]: ``` # Input: * **total_seats**: An integer representing the total number of seats in a single row of the theater. # Output: * **seating_positions**: A list of integers representing the zero-based indices of the seats that can be booked while ensuring no two booked seats are next to each other. # Constraints: * 0 < total_seats ≤ 1000 # Example: ```python # Example 1 total_seats = 5 # Seats can be booked at positions 0, 2, and 4 print(determine_seating_positions(total_seats)) # Output: [0, 2, 4] # Example 2 total_seats = 8 # Seats can be booked at positions 0, 2, 4, and 6 print(determine_seating_positions(total_seats)) # Output: [0, 2, 4, 6] ``` # Notes: 1. The function should not book two consecutive seats to ensure social distancing. 2. The first seat (position 0) should preferably be booked to maximize the number of booked seats. 3. Handle edge cases appropriately, such as when there is only one seat or when no seats are available. # Evaluation Criteria: * **Correctness**: The function should correctly identify positions where seats can be booked without violating social distancing guidelines. * **Efficiency**: The function should efficiently process up to the maximum constraint. * **Edge Handling**: The function should properly handle edge cases, such as when the total number of seats is very low or at the maximum limit. * **Code Quality**: The solution should be clean, readable, and properly commented.","solution":"from typing import List def determine_seating_positions(total_seats: int) -> List[int]: Returns the positions of seats that can be booked while ensuring no two booked seats are next to each other. seating_positions = [] for i in range(0, total_seats, 2): seating_positions.append(i) return seating_positions"},{"question":"# **Reverse Words in a String** You are required to implement a function that reverses the words in a given string. The function should maintain the order of punctuation and spaces, but rearrange the words in reverse order. A word is defined as a maximal substring consisting of non-space characters only. Function Specifications: - **Function Name**: `reverse_words` - **Input**: A string `s` containing words separated by spaces, with possible punctuation. - **Output**: A string with the words in reverse order while retaining original spaces and punctuation. Constraints: * The input string can have up to (10^5) characters. * Leading and trailing spaces should be stripped in the output. * The function should handle multiple spaces between words correctly, replacing them with a single space. Performance Requirements: * The function should efficiently handle the input constraints and operate within a reasonable time. Example: ```python assert reverse_words(\\"Hello, world!\\") == \\"world! Hello,\\" assert reverse_words(\\"This is a test.\\") == \\"test. a is This\\" assert reverse_words(\\" The sky is blue \\") == \\"blue is sky The\\" assert reverse_words(\\"Hello\\") == \\"Hello\\" assert reverse_words(\\"\\") == \\"\\" ``` # Additional Challenge: Ensure the function can handle edge cases such as: 1. An empty string (`\\"\\"`). 2. Strings with one word (e.g., `\\"Hello\\"`). 3. Strings with multiple spaces between words (e.g., `\\" word1 word2 word3 \\"`). 4. Strings with punctuation within and around words (e.g., `\\"Hello, world! This is: a test.\\"`). # Hint: Consider how the function can split the input string by spaces, reverse the list of words, and then rejoin them while preserving the spaces and punctuation.","solution":"def reverse_words(s): Reverses the words in the given string while maintaining spaces and punctuation. Args: s (str): Input string containing words. Returns: str: String with words in reverse order. # Remove leading and trailing spaces s = s.strip() # Split the string into words words = s.split() # Reverse the list of words reversed_words = words[::-1] # Join the words back with a single space result = \' \'.join(reversed_words) return result"},{"question":"# Image Sharpening You are tasked with implementing a function to apply sharpening to an image using the Python Imaging Library (PIL). Your goal is to enhance the edges and details in the image to make it appear clearer and more defined. Function Signature ```python def sharpen_image(img: Image, factor: float) -> Image: Function to sharpen the image. :param img: The input PIL Image object :param factor: The sharpening factor to apply, where factor is a float between 1.0 and 10.0. :return: A new PIL Image object with sharpened detail ``` Constraints - The valid range for the sharpening factor is [1.0, 10.0]. - The function should handle edge cases where the sharpening factor is at its extreme bounds. - Ensure the function is both time-efficient and space-efficient. Example Usage ```python from PIL import Image # Load an image with Image.open(\\"example.jpg\\") as img: # Sharpen the image img_sharp = sharpen_image(img, 2.5) img_sharp.save(\\"sharp_example.jpg\\", format=\\"JPEG\\") # Apply stronger sharpening img_strong_sharp = sharpen_image(img, 7.0) img_strong_sharp.save(\\"strong_sharp_example.jpg\\", format=\\"JPEG\\") ``` Task 1. Implement the `sharpen_image` function as described. 2. Test the function with various images and sharpening factors to ensure it behaves correctly and efficiently. # Considerations - Test with both the lower and upper bounds of the sharpening factor. - Pay attention to images with fine details and how the sharpening adjustment affects these areas. - Ensure that the sharpened image maintains the original dimensions and pixel format.","solution":"from PIL import Image, ImageEnhance def sharpen_image(img: Image, factor: float) -> Image: Function to sharpen the image. :param img: The input PIL Image object :param factor: The sharpening factor to apply, where factor is a float between 1.0 and 10.0. :return: A new PIL Image object with sharpened detail if not (1.0 <= factor <= 10.0): raise ValueError(\\"Sharpening factor must be between 1.0 and 10.0\\") enhancer = ImageEnhance.Sharpness(img) return enhancer.enhance(factor)"},{"question":"# Question: Evaluate and Interpret Boolean Expressions Context You are a developer tasked with creating a tool for interpreting Boolean expressions. These expressions include `AND`, `OR`, and `NOT` operations, and can also handle parentheses for grouping. Task 1. Implement a function `evaluate_boolean_expression(expression: str) -> bool` that: - Takes a string `expression` representing a Boolean expression. - Returns the evaluated result as a Boolean value. 2. Ensure the function can handle: - Basic Boolean operations: `AND`, `OR`, `NOT`. - Parentheses for grouping expressions. Implementation Constraints - You must handle invalid Boolean expressions and return `None` in such cases. - Handle edge cases such as unbalanced parentheses or invalid characters. - Maintain a time complexity that is reasonable, targeting O(n), where n is the length of the expression string. Input and Output - **Input**: A string `expression` representing the Boolean expression. - **Output**: A Boolean value representing the evaluated result or `None` if the expression is invalid. Examples ```python assert evaluate_boolean_expression(\\"(TRUE AND (FALSE OR TRUE))\\") == True assert evaluate_boolean_expression(\\"((TRUE OR FALSE) AND NOT FALSE)\\") == True assert evaluate_boolean_expression(\\"(NOT TRUE AND TRUE)\\") == False assert evaluate_boolean_expression(\\"((TRUE AND FALSE) OR (NOT FALSE))\\") == True # Invalid cases assert evaluate_boolean_expression(\\"(TRUE AND )\\") == None assert evaluate_boolean_expression(\\"((TRUE OR FALSE)) AND\\") == None assert evaluate_boolean_expression(\\"()\\") == None ``` Notes 1. Extend the operator handling logic to properly manage `AND`, `OR`, and `NOT` operations. 2. Ensure correct precedence and associativity, especially with the `NOT` operator. 3. Enhance the parsing to recognize and properly process Boolean literals (`TRUE`, `FALSE`), operators, and group parentheses correctly.","solution":"def evaluate_boolean_expression(expression: str) -> bool: import re def parse_tokens(expression): tokens = re.findall(r\'bTRUEb|bFALSEb|bANDb|bORb|bNOTb|(|)\', expression) return tokens def precedence(op): if op == \'NOT\': return 3 if op in (\'AND\', \'OR\'): return 2 return 0 def apply_op(operands, op): if op == \'AND\': right = operands.pop() left = operands.pop() operands.append(left and right) elif op == \'OR\': right = operands.pop() left = operands.pop() operands.append(left or right) elif op == \'NOT\': operand = operands.pop() operands.append(not operand) def evaluate_tokens(tokens): operands = [] operators = [] i = 0 while i < len(tokens): token = tokens[i] if token == \'TRUE\': operands.append(True) elif token == \'FALSE\': operands.append(False) elif token == \'(\': operators.append(token) elif token == \')\': while operators and operators[-1] != \'(\': apply_op(operands, operators.pop()) operators.pop() # Remove \'(\' elif token in (\'AND\', \'OR\', \'NOT\'): while (operators and precedence(operators[-1]) >= precedence(token)): apply_op(operands, operators.pop()) operators.append(token) i += 1 while operators: apply_op(operands, operators.pop()) return operands[0] if operands else None tokens = parse_tokens(expression) if not tokens: # empty or invalid expression return None try: result = evaluate_tokens(tokens) except (IndexError, TypeError): return None return result"},{"question":"# Problem Statement You are tasked with implementing a `get_common_divisors` function, which takes two positive integers and returns a list of all their common divisors in ascending order. As a supplementary feature, if a third argument `return_count` is set to `True`, the function should return the count of the common divisors instead of the list. # Function Definition Implement a function `get_common_divisors(a: int, b: int, return_count: bool = False) -> Union[List[int], int]` which: - Computes the common divisors of the given integers `a` and `b`. - If `return_count` is `False`, returns a list of common divisors in ascending order. - If `return_count` is `True`, returns the count of common divisors. # Input - `a` (int): The first positive integer. - `b` (int): The second positive integer. - `return_count` (Optional, bool): Flag to indicate if the function should return the count of common divisors. Defaults to `False`. # Output - A list of common divisors in ascending order if `return_count` is `False`. - An integer representing the count of common divisors if `return_count` is `True`. # Examples ```python # Example 1: >>> get_common_divisors(12, 18) [1, 2, 3, 6] # Example 2: >>> get_common_divisors(12, 18, return_count=True) 4 # Example 3: >>> get_common_divisors(100, 75) [1, 5, 25] ``` # Constraints - The inputs `a` and `b` are positive integers within the range [1, 10^6]. - Edge cases such as `a` or `b` being prime numbers should be considered. - The function should handle cases where `a` and `b` are equal efficiently. - The time complexity should be optimized to O(sqrt(min(a, b))). # Notes - Implement the function to handle invalid inputs gracefully with appropriate error messages. - Document your approach and any assumptions you make.","solution":"from typing import List, Union def get_common_divisors(a: int, b: int, return_count: bool = False) -> Union[List[int], int]: Returns the common divisors of a and b, either as a list or as a count. Parameters: - a (int): First positive integer. - b (int): Second positive integer. - return_count (bool): If True, returns the count of common divisors. Defaults to False. Returns: - List[int]: List of common divisors if return_count is False. - int: Count of common divisors if return_count is True. if a <= 0 or b <= 0: raise ValueError(\\"Both numbers must be positive integers.\\") def gcd(x, y): while y: x, y = y, x % y return x def find_divisors(n): divisors = set() for i in range(1, int(n**0.5) + 1): if n % i == 0: divisors.add(i) divisors.add(n // i) return divisors common_divisors = sorted(find_divisors(gcd(a, b))) if return_count: return len(common_divisors) else: return common_divisors"},{"question":"# Problem Statement: You are given a string `s` and a dictionary of words `dict`. Your task is to implement a function, `wordBreak(s: str, dict: List[str]) -> List[str]`, that returns all possible sentences where each word is a valid word from the dictionary. Each combination should represent a possible sentence formed by string `s` being segmented into a space-separated sequence of dictionary words. # Input - A string `s` (1 ≤ `len(s)` ≤ 30) containing only lowercase letters. - A list of strings `dict` containing lowercase dictionary words, with each word length from 1 to 20. # Output - A list of strings, with each string representing a possible sentence where each word is from `dict`. # Requirements - Use a recursive approach with memoization to efficiently solve the problem. - Consider edge cases where `s` is a single character or where no valid segmentation is possible. # Example ```python >>> wordBreak(\\"catsanddog\\", [\\"cat\\", \\"cats\\", \\"and\\", \\"sand\\", \\"dog\\"]) [\\"cat sand dog\\", \\"cats and dog\\"] >>> wordBreak(\\"pineapplepenapple\\", [\\"apple\\", \\"pen\\", \\"applepen\\", \\"pine\\", \\"pineapple\\"]) [\\"pine apple pen apple\\", \\"pineapple pen apple\\", \\"pine applepen apple\\"] >>> wordBreak(\\"catsandog\\", [\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"]) [] ``` # Constraints - Your solution should handle the case where no possible sentences can be formed by returning an empty list. - Aim for a time complexity that avoids exponential blow-up through the use of memoization. Write your code below: ```python from typing import List def wordBreak(s: str, dict: List[str]) -> List[str]: def backtrack(start: int, memo={}) -> List[str]: if start in memo: return memo[start] if start == len(s): return [\\"\\"] sentences = [] for end in range(start + 1, len(s) + 1): word = s[start:end] if word in dict: following_sentences = backtrack(end) for sentence in following_sentences: sentences.append(word + (\\"\\" if sentence == \\"\\" else \\" \\") + sentence) memo[start] = sentences return sentences return backtrack(0) # Example usage if __name__ == \\"__main__\\": print(wordBreak(\\"catsanddog\\", [\\"cat\\", \\"cats\\", \\"and\\", \\"sand\\", \\"dog\\"])) ``` This question aligns with the dynamic programming theme in the provided sample, maintaining the complexity and scope while introducing a new problem scenario involving string manipulation and dictionary lookups.","solution":"from typing import List def wordBreak(s: str, dict: List[str]) -> List[str]: dict_set = set(dict) memo = {} def helper(start): if start in memo: return memo[start] if start == len(s): return [\\"\\"] results = [] for end in range(start + 1, len(s) + 1): word = s[start:end] if word in dict_set: remaining = helper(end) for rem in remaining: space = \\"\\" if rem == \\"\\" else \\" \\" results.append(word + space + rem) memo[start] = results return results return helper(0)"},{"question":"# Question Problem Statement A popular online game involves collecting various magical artifacts with unique powers. Each artifact has a particular `power` value and `fragility` score. The goal is to maximize the total power of the artifacts collected without exceeding a given fragility threshold. You need to implement a function to identify the best set of artifacts to collect using a dynamic programming approach. Function Signatures ```python def collect_artifacts(artifacts: list, max_fragility: int) -> tuple: # Your code here ``` Definitions - `artifacts`: A list of tuples, where each tuple represents an artifact with a `power` (an integer) and `fragility` (an integer). - `max_fragility`: An integer representing the maximum allowable fragility for the set of collected artifacts. Output The function should return a tuple containing: 1. A list of tuples representing the artifacts that have been selected. 2. The total power of the collected artifacts. Constraints - The combined fragility of the selected artifacts should not exceed `max_fragility`. - The selection should maximize the total power of the artifacts. - You must use a dynamic programming approach for the selection process to ensure optimal results. Example Usage ```python artifacts = [(100, 1), (200, 2), (300, 3), (400, 4), (500, 5)] max_fragility = 5 print(collect_artifacts(artifacts, max_fragility)) # Output should match a combination of artifacts with the highest possible power without exceeding the fragility threshold. ``` Notes - Ensure that your function handles edge cases such as exceedingly fragile artifacts with very low power. - The dynamic programming solution should efficiently compute the optimal set of artifacts. - Thoroughly test your function with various input sizes and fragility thresholds to ensure correctness and performance.","solution":"def collect_artifacts(artifacts, max_fragility): Identifies the best set of artifacts to collect, using dynamic programming, to maximize total power without exceeding the fragility threshold. Parameters: artifacts (list of tuples): Each tuple contains (power, fragility). max_fragility (int): The maximum allowable fragility. Returns: (list of tuples, int): A tuple containing the list of selected artifacts and the total power of the collected artifacts. n = len(artifacts) # DP table where dp[i][w] represents the maximum power that can be achieved with the first i artifacts and a maximum fragility of w. dp = [[0 for _ in range(max_fragility + 1)] for _ in range(n + 1)] # Backtracking table to find the selected artifacts keep = [[0 for _ in range(max_fragility + 1)] for _ in range(n + 1)] # Populate DP table and keep table for i in range(1, n + 1): power, fragility = artifacts[i - 1] for w in range(1, max_fragility + 1): if fragility <= w: # Consider taking the artifact if power + dp[i - 1][w - fragility] > dp[i - 1][w]: dp[i][w] = power + dp[i - 1][w - fragility] keep[i][w] = 1 else: dp[i][w] = dp[i - 1][w] else: dp[i][w] = dp[i - 1][w] # Backtrack to find the selected artifacts w = max_fragility selected_artifacts = [] for i in range(n, 0, -1): if keep[i][w] == 1: selected_artifacts.append(artifacts[i - 1]) w -= artifacts[i - 1][1] selected_artifacts.reverse() return selected_artifacts, dp[n][max_fragility]"},{"question":"# Context You are tasked with creating a Python class that models a simple version of a text editor. The editor should be able to handle basic text editing features including inserting text, deleting text, and undoing the most recent operation. # Problem Statement Implement an `Editor` class that supports the following methods: - `insert(self, text: str, position: int) -> None`: Inserts the given `text` at the specified `position` in the editor. If `position` is greater than the current text length, append the text at the end. - `delete(self, position: int, length: int) -> None`: Deletes `length` characters starting from the specified `position`. If `position` is out of bounds, raise an `IndexError`. - `undo(self) -> None`: Reverts the most recent insert or delete operation. If there are no operations to undo, raise an `IndexError`. - `get_text(self) -> str`: Retrieves the current text in the editor. # Requirements 1. Your implementation should manage a history of operations to support the undo feature. 2. The `insert` and `delete` methods should be optimized for performance. # Constraints - You can assume that any text and positions used in the methods will be valid strings and non-negative integers. - Your implementation should aim to handle operations efficiently, with typical use cases in mind. - The length of the text will not exceed (10^4) characters in typical use cases. # Input/Output - There is no direct input/output. Implement the class and methods as specified below: ```python class Editor: def __init__(self): # Initialize your data structure pass def insert(self, text: str, position: int) -> None: # Insert text at position pass def delete(self, position: int, length: int) -> None: # Delete length of characters at position pass def undo(self) -> None: # Undo the last operation pass def get_text(self) -> str: # Return the current contents of the editor pass ``` # Example Usage ```python editor = Editor() editor.insert(\\"Hello, world!\\", 0) editor.insert(\\" Welcome\\", 13) print(editor.get_text()) # Output: \\"Hello, world! Welcome\\" editor.delete(13, 8) print(editor.get_text()) # Output: \\"Hello, world!\\" editor.undo() print(editor.get_text()) # Output: \\"Hello, world! Welcome\\" editor.undo() print(editor.get_text()) # Output: \\"Hello, world!\\" ```","solution":"class Editor: def __init__(self): self.text = \\"\\" self.history = [] def insert(self, text: str, position: int) -> None: if position > len(self.text): position = len(self.text) self.history.append((\\"insert\\", text, position)) self.text = self.text[:position] + text + self.text[position:] def delete(self, position: int, length: int) -> None: if position < 0 or position >= len(self.text): raise IndexError(\\"Position out of bounds\\") actual_delete_length = min(length, len(self.text) - position) deleted_text = self.text[position:position + actual_delete_length] self.history.append((\\"delete\\", deleted_text, position)) self.text = self.text[:position] + self.text[position + actual_delete_length:] def undo(self) -> None: if not self.history: raise IndexError(\\"No operations to undo\\") last_op = self.history.pop() if last_op[0] == \\"insert\\": _, text, position = last_op self.text = self.text[:position] + self.text[position + len(text):] elif last_op[0] == \\"delete\\": _, text, position = last_op self.text = self.text[:position] + text + self.text[position:] def get_text(self) -> str: return self.text"},{"question":"# Problem Statement You are tasked with monitoring the temperature of a heat sensor in an industrial setting. The temperature readings are taken at regular intervals, and your task is to process these readings to ensure the temperature remains within a safe range. If the temperature is outside the permissible range continuously for a specified duration, an alert should be generated. # Task Write a function named `temperature_alert` that takes four parameters: 1. `readings` (List[float]): A list of temperature readings. 2. `min_temp` (float): The minimum permissible temperature. 3. `max_temp` (float): The maximum permissible temperature. 4. `duration` (int): The minimum number of consecutive readings that must be outside the permissible range to generate an alert. The function should return a boolean value: - `True` if there is any sequence of consecutive readings of the specified duration that are all outside the range `[min_temp, max_temp]`. - `False` otherwise. # Input and Output Format * **Input**: - A list of float `readings`: The recorded temperature readings. - A float `min_temp`: The minimum permissible temperature. - A float `max_temp`: The maximum permissible temperature. - An int `duration`: The number of consecutive readings outside the permissible range needed to trigger an alert. * **Output**: - A boolean value indicating whether an alert should be generated. # Constraints - The `readings` list will have a length between 1 and 1000 inclusive. - The `min_temp` and `max_temp` will be in the range from -100.0 to 100.0. - The `duration` will be between 1 and the length of the `readings` list inclusive. If any of the constraints are violated, the function should raise a `ValueError` with an appropriate error message. # Example ```python def temperature_alert(readings: List[float], min_temp: float, max_temp: float, duration: int) -> bool: # Your code here # Example Usage print(temperature_alert([20.5, 19.3, 22.8, 18.2, 17.9, 21.0], 18.0, 22.0, 3)) # Returns False print(temperature_alert([20.5, 19.3, 23.8, 24.2, 25.9, 21.0], 18.0, 22.0, 2)) # Returns True ``` # Notes 1. Your implementation should iterate through the reading list efficiently. 2. Ensure your function handles all edge cases as specified, raising `ValueError` for invalid inputs.","solution":"from typing import List def temperature_alert(readings: List[float], min_temp: float, max_temp: float, duration: int) -> bool: if not readings: raise ValueError(\\"Readings list cannot be empty.\\") if duration < 1 or duration > len(readings): raise ValueError(\\"Duration must be between 1 and the length of the readings list inclusive.\\") if min_temp < -100.0 or min_temp > 100.0 or max_temp < -100.0 or max_temp > 100.0: raise ValueError(\\"Temperatures must be within the range of -100.0 to 100.0.\\") if min_temp > max_temp: raise ValueError(\\"Minimum temperature should not be greater than maximum temperature.\\") consecutive_count = 0 for reading in readings: if reading < min_temp or reading > max_temp: consecutive_count += 1 if consecutive_count >= duration: return True else: consecutive_count = 0 return False"},{"question":"# Detect Cycle in a Directed Graph Context In graph theory, detecting cycles in a directed graph is a fundamental task that is useful in various applications such as deadlock detection and dependency resolution. A directed graph consists of vertices connected by directed edges, and a cycle occurs when there is a path from a vertex to itself following the graph\'s direction. Problem Write a Python function `has_cycle` to check whether a given directed graph contains a cycle. The graph is represented using adjacency lists. ```python def has_cycle(graph: dict) -> bool: pass ``` Input & Output **Input:** - **graph** (dict): A dictionary where keys are integers representing nodes, and the values are lists of integers representing the nodes\' neighbors in the directed graph. **Output:** - **Result:** (bool) Returns `True` if there is a cycle in the graph, otherwise `False`. Constraints 1. The graph will have at most 1000 nodes. 2. There will be no self-loops, i.e., no node will have an edge directed to itself. 3. Nodes in the graph are labeled with non-negative integers starting from 0. Performance Constraints The function should operate with a time complexity of (O(V + E)) and space complexity of (O(V)), where (V) is the number of vertices and (E) is the number of edges in the graph. Function Execution - If the input graph is empty, return `False`. - Use Depth-First Search (DFS) to detect cycles. # Examples ```python >>> has_cycle({0: [1], 1: [2], 2: [0]}) True >>> has_cycle({0: [1, 2], 1: [2], 2: [3], 3: []}) False >>> has_cycle({0: [1], 1: [2], 2: [3], 3: [1]}) True >>> has_cycle({}) False ``` Note Use DFS with a recursion stack (or colors) to keep track of the path you are currently visiting. If you encounter a node that is already in the current path, then a cycle exists.","solution":"def has_cycle(graph: dict) -> bool: Check if the directed graph contains a cycle. :param graph: Dict representing the adjacency list of the graph. :return: Bool indicating whether the graph has a cycle. def dfs(node): if node in rec_stack: return True if node in visited: return False visited.add(node) rec_stack.add(node) for neighbor in graph.get(node, []): if dfs(neighbor): return True rec_stack.remove(node) return False visited = set() rec_stack = set() for node in graph: if dfs(node): return True return False"},{"question":"# Coding Assessment Question Context You are working on a music recommendation system that suggests new songs to users based on their listening history. Each song can be described by multiple features such as tempo, genre, duration, etc. The system should recommend songs that are similar to what the user has listened to but still have a bit of novelty to keep things interesting. The K-Nearest Neighbors (KNN) algorithm can help in this scenario by finding the most similar songs to a given song. Task Write a function `recommend_songs` that, given historical data about songs (including their features) and a specific song, recommends a list of songs using the K-Nearest Neighbors algorithm. # Function Signature ```python def recommend_songs( song_features: np.ndarray, song_labels: np.ndarray, target_song_features: np.ndarray, k: int ) -> List[str]: Recommends a list of songs based on similarities to a target song using K-Nearest Neighbors. Args: song_features: 2D ndarray of shape (m, n) representing the features of m songs (each with n features). song_labels: 1D ndarray of shape (m,) containing the names of the m songs. target_song_features: 1D ndarray of shape (n,) representing the features of the specific song to base recommendations on. k: Integer specifying the number of songs to recommend. Returns: List[str]: A list of k song names that are most similar to the target song based on feature similarity. ``` # Input and Output Format - **Input**: - `song_features`: An array of shape `(m, n)` where `m` represents the number of songs and `n` represents the number of features per song. Each row corresponds to the features of one song. - `song_labels`: An array of shape `(m,)` containing the names of the songs corresponding to each row in `song_features`. - `target_song_features`: An array of shape `(n,)`, representing the feature values of the target song you want recommendations for. - `k`: An integer specifying the number of similar songs to recommend. - **Output**: A list of `k` strings representing the names of the recommended songs. # Constraints - Assume `1 <= m <= 10^6` and `1 <= n <= 100`. - All songs have unique labels (names) as strings. - The features are non-negative floats. - `1 <= k <= m`. # Example ```python song_features = np.array([ [120.0, 1.0, 180.0], # tempo, genre code, duration [130.0, 1.0, 200.0], [150.0, 2.0, 210.0], [140.0, 1.0, 190.0], [110.0, 2.0, 220.0] ]) song_labels = np.array([ \\"Song A\\", \\"Song B\\", \\"Song C\\", \\"Song D\\", \\"Song E\\" ]) target_song_features = np.array([135.0, 1.0, 205.0]) k = 2 recommended_songs = recommend_songs(song_features, song_labels, target_song_features, k) print(recommended_songs) # Expected output: A list of 2 song names such as [\\"Song B\\", \\"Song D\\"] ``` # Notes - You will need to compute Euclidean distances between the target song and each song in the dataset. - Use efficient methods to handle potentially large datasets. - Consider edge cases such as k being larger than the number of songs with exactly matching features. Hints 1. Compute the Euclidean distance between the target song and each song in the dataset. 2. Select the k songs with the smallest distances. 3. Return the corresponding song names from `song_labels`.","solution":"import numpy as np from typing import List from heapq import nlargest from math import sqrt def recommend_songs( song_features: np.ndarray, song_labels: np.ndarray, target_song_features: np.ndarray, k: int ) -> List[str]: Recommends a list of songs based on similarities to a target song using K-Nearest Neighbors. Args: song_features: 2D ndarray of shape (m, n) representing the features of m songs (each with n features). song_labels: 1D ndarray of shape (m,) containing the names of the m songs. target_song_features: 1D ndarray of shape (n,) representing the features of the specific song to base recommendations on. k: Integer specifying the number of songs to recommend. Returns: List[str]: A list of k song names that are most similar to the target song based on feature similarity. # Calculate Euclidean distance def euclidean_distance(x, y): return sqrt(np.sum((x - y) ** 2)) # Apply the distance calculation distances = [(euclidean_distance(song, target_song_features), label) for song, label in zip(song_features, song_labels)] # Find k smallest distances (songs) k_nearest_songs = nlargest(k, distances, key=lambda x: -x[0]) # Extract the song labels for the k-nearest songs return [song[1] for song in k_nearest_songs]"},{"question":"Problem Statement: You are given a list of integers `lst`. Your task is to find the smallest positive integer that is not present in the list. Write a function `find_smallest_missing_positive(lst: List[int]) -> int` that performs this task. Function Signature: ```python def find_smallest_missing_positive(lst: List[int]) -> int: ... ``` Input: * A list of integers `lst` (-10^6 <= lst[i] <= 10^6) with a length of (0 <= len(lst) <= 10^6) Output: * An integer representing the smallest positive integer that is not present in the list. Constraints: * The list length ensures that the solution needs to handle large inputs efficiently. * Negative numbers and zeros are irrelevant in finding the smallest positive integer missing. Example Usage: ```python print(find_smallest_missing_positive([3, 4, -1, 1])) # Output: 2 print(find_smallest_missing_positive([1, 2, 0])) # Output: 3 print(find_smallest_missing_positive([7, 8, 9, 11])) # Output: 1 print(find_smallest_missing_positive([])) # Output: 1 ``` Scenario: Imagine you are a software engineer working on a system that manages user IDs. Each user ID must be a unique positive integer starting from 1. When creating a new user, you need to find the smallest available positive integer that has not yet been assigned to ensure no duplicates and optimal usage of IDs. This function helps in determining the next available user ID efficiently. Notes: Ensure the function is optimized in terms of time and space complexity. Consider edge cases where the list is empty or contains a wide range of positive and negative integers.","solution":"def find_smallest_missing_positive(lst): Returns the smallest positive integer not present in the list. # Filtering out non-positive integers nums = [num for num in lst if num > 0] if not nums: return 1 nums.sort() smallest_missing = 1 for num in nums: if num == smallest_missing: smallest_missing += 1 elif num > smallest_missing: break return smallest_missing"},{"question":"# Problem Statement You are tasked with implementing a function that calculates the greatest common divisor (GCD) of two non-negative integers. The GCD of two integers is the largest integer that divides both of them without leaving a remainder. # Input - Two non-negative integers `a` and `b`. # Output - A single integer representing the GCD of the provided integers. # Constraints - The integers can vary between 0 and (10^6). # Function Signature ```python def find_gcd(a: int, b: int) -> int: ``` # Examples ```python >>> find_gcd(48, 18) 6 >>> find_gcd(0, 10) 10 >>> find_gcd(10, 0) 10 >>> find_gcd(25, 10) 5 >>> find_gcd(101, 103) 1 >>> find_gcd(0, 0) Traceback (most recent call last): ... ValueError: Both input numbers cannot be zero ``` # Implementation Guidance 1. Implement input validation to ensure both inputs are non-negative integers. 2. Handle the special case where both input numbers are zero by raising a `ValueError` exception. 3. Compute and return the GCD using an appropriate algorithm such as the Euclidean algorithm. # Note Consider utilizing the recursive or iterative version of the Euclidean algorithm to calculate the GCD efficiently.","solution":"def find_gcd(a: int, b: int) -> int: Returns the greatest common divisor (GCD) of two non-negative integers a and b. Parameters: a (int): First non-negative integer b (int): Second non-negative integer Returns: int: GCD of a and b Raises: ValueError: If both a and b are zero. if a == 0 and b == 0: raise ValueError(\\"Both input numbers cannot be zero\\") while b: a, b = b, a % b return abs(a)"},{"question":"# Question: Matrix Transposition Function You are tasked with implementing a function to transpose a given matrix. Function: `transpose_matrix(matrix: List[List[int]]) -> List[List[int]]` Implement a function that takes a 2D matrix (a list of lists) and returns its transpose. The transpose of a matrix flips the matrix over its diagonal, switching the row and column indices of each element. **Inputs:** * `matrix (List[List[int]])`: A 2D list where each sublist represents a row in the matrix. **Outputs:** * `List[List[int]]`: A 2D list representing the transposed matrix. **Constraints:** * The input matrix can have varying dimensions but will always be well-formed (i.e., each row will have the same number of columns). Input Examples: - `[[1, 2, 3], [4, 5, 6], [7, 8, 9]]` - `[[1, 2], [3, 4], [5, 6]]` Output Examples: - `[[1, 4, 7], [2, 5, 8], [3, 6, 9]]` - `[[1, 3, 5], [2, 4, 6]]` # Requirements 1. You must handle rectangular matrices of any valid size (m x n). 2. The input and output matrices must maintain their row-column integrity. 3. Efficiently process the matrix to minimize time complexity. 4. Implement proper error conditions where inputs do not meet expected formats or are empty. Examples Example 1: ```python >>> transpose_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[1, 4, 7], [2, 5, 8], [3, 6, 9]] ``` Example 2: ```python >>> transpose_matrix([[1, 2], [3, 4], [5, 6]]) [[1, 3, 5], [2, 4, 6]] ``` Write the implementation of the function `transpose_matrix` ensuring it fulfills the requirements and handles all edge cases appropriately.","solution":"def transpose_matrix(matrix): Transposes the given matrix. Args: matrix (list of list of int): The 2D list to be transposed. Returns: list of list of int: The transposed matrix. if not matrix or not matrix[0]: return [] return [[matrix[j][i] for j in range(len(matrix))] for i in range(len(matrix[0]))]"},{"question":"# Question: Implement String Permutation Detector You are developing a feature for a security system that needs to check if one string is a permutation of another. This feature ensures that critical security checks can detect rearranged sensitive data. Task Implement the function `check_permutation(s1: str, s2: str) -> bool` that determines whether one string is a permutation of the other. Two strings are permutations if they contain the same characters with the same frequencies. Function Signature ```python def check_permutation(s1: str, s2: str) -> bool: pass ``` Input * `s1`: a string to check against. - Constraints: (1 leq text{len}(s1) leq 10^6) * `s2`: another string to compare. - Constraints: (1 leq text{len}(s2) leq 10^6) Output * Returns `True` if `s1` and `s2` are permutations of each other, `False` otherwise. Constraints 1. The solution should handle the maximum input size efficiently. 2. Both strings `s1` and `s2` can consist of any ASCII characters. Example ```python print(check_permutation(\'abcd\', \'dcba\')) # Expected output: True print(check_permutation(\'abcd\', \'abcf\')) # Expected output: False print(check_permutation(\'aabbcc\', \'ccbbaa\')) # Expected output: True ``` Additional Requirements 1. **Performance**: Ensure the function is optimized to handle long strings efficiently (up to (10^6) characters). 2. **Correctness**: Handle different characters, including uppercase, lowercase, digits, and special characters.","solution":"def check_permutation(s1: str, s2: str) -> bool: Determine if s1 is a permutation of s2. if len(s1) != len(s2): return False from collections import Counter return Counter(s1) == Counter(s2)"},{"question":"# Matrix Multiplication Verification Problem Statement You are given two matrices `A` and `B` of size `n x m` and `m x p` respectively. Your task is to write a function `verify_matrix_multiplication(A: List[List[int]], B: List[List[int]], C: List[List[int]]) -> bool` that verifies if the provided matrix `C` is the correct result of multiplying matrices `A` and `B`. Requirements * Implement the function `verify_matrix_multiplication(A: List[List[int]], B: List[List[int]], C: List[List[int]]) -> bool`. * `A`, `B`, and `C` will contain integers and can have negative values. * Ensure the function works efficiently even for large matrices. # Expected Input and Output * **Input**: * `A (List[List[int]])`: a matrix of size `n x m`. * `B (List[List[int]])`: a matrix of size `m x p`. * `C (List[List[int]])`: a matrix of size `n x p` which needs to be verified. * **Output**: * Return `True` if `C` correctly represents the result of the multiplication of `A` and `B`, otherwise return `False`. # Constraints 1. `A`, `B`, and `C` will have dimensions such that multiplication is possible and valid. That is, the number of columns in `A` matches the number of rows in `B`. 2. The function should complete verification within a reasonable time frame for large matrices (up to 100x100). # Example ```python def verify_matrix_multiplication(A: List[List[int]], B: List[List[int]], C: List[List[int]]) -> bool: # Your implementation here A = [ [1, 2], [3, 4] ] B = [ [2, 0], [1, 2] ] C_correct = [ [4, 4], [10, 8] ] C_incorrect = [ [3, 4], [10, 7] ] print(verify_matrix_multiplication(A, B, C_correct)) # Output: True print(verify_matrix_multiplication(A, B, C_incorrect)) # Output: False ``` # Tips * Recall that matrix multiplication is defined as `C[i][j] = sum(A[i][k] * B[k][j] for all k)`. * Consider edge cases such as matrices containing zeros or having different ranges of values. * Use nested loops carefully to ensure computational efficiency.","solution":"from typing import List def verify_matrix_multiplication(A: List[List[int]], B: List[List[int]], C: List[List[int]]) -> bool: n = len(A) m = len(A[0]) p = len(B[0]) # Compute matrix multiplication of A and B for i in range(n): for j in range(p): computed_value = 0 for k in range(m): computed_value += A[i][k] * B[k][j] if computed_value != C[i][j]: return False return True"},{"question":"# Scenario In computer science, sorting algorithms are fundamental and come in various forms with different efficiencies, especially for smaller datasets. One common exercise to understand sorting algorithms better is to implement them and observe their behaviors. # Problem Statement You are required to write a function that implements a variation of the bubble sort algorithm, known as \\"Enhanced Bubble Sort\\". This version of bubble sort stops early if, during any complete pass through the array, no elements were swapped (indicating that the array is already sorted). # Function Signature ```python def enhanced_bubble_sort(arr: list) -> list: pass ``` # Input * `arr`: A list of integers (1 ≤ len(arr) ≤ 1000, -10^6 ≤ arr[i] ≤ 10^6). # Output * A list of integers representing the sorted version of the input array. # Constraints * The solution should efficiently terminate if the array is detected to be already sorted before completing all possible passes. * Only built-in list operations in Python should be used (no use of `sorted()` or similar). # Examples ```python assert enhanced_bubble_sort([64, 34, 25, 12, 22, 11, 90]) == [11, 12, 22, 25, 34, 64, 90] assert enhanced_bubble_sort([5, 1, 4, 2, 8]) == [1, 2, 4, 5, 8] assert enhanced_bubble_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] ``` # Explanation 1. For `[64, 34, 25, 12, 22, 11, 90]`, the function sorts the list into `[11, 12, 22, 25, 34, 64, 90]` using enhanced bubble sort principles. 2. For `[5, 1, 4, 2, 8]`, after sorting, the list becomes `[1, 2, 4, 5, 8]`. 3. For `[1, 2, 3, 4, 5]`, the array is already sorted, so the function detects no swaps and terminates early. # Note Enhanced bubble sort provides an early exit if the list becomes sorted before completing all passes, which can optimize performance for nearly sorted lists. The implementation should reflect this enhancement carefully.","solution":"def enhanced_bubble_sort(arr: list) -> list: Enhanced Bubble Sort algorithm that terminates early if the array is already sorted during a pass. n = len(arr) for i in range(n): # Track if any swaps were made during this pass swapped = False # Perform a pass for j in range(0, n-i-1): if arr[j] > arr[j+1]: # Swap elements arr[j], arr[j+1] = arr[j+1], arr[j] swapped = True # If no swaps were made, the array is already sorted if not swapped: break return arr"},{"question":"# Question: Inventory Management System # Context: In retail and supply chain management, keeping track of inventory levels is crucial for ensuring that adequate stock is available to meet demand without overstocking. An effective inventory management system helps in managing stock levels, recording sales, and facilitating reordering decisions. # Task: Implement a class `Inventory` that manages the inventory of items in a store. The class should provide methods to add new items, update the quantity of existing items, record sales, and generate a stock report. # Class Signature: ```python class Inventory: def __init__(self): pass def add_item(self, item_name: str, quantity: int, price: float) -> None: pass def update_quantity(self, item_name: str, quantity: int) -> None: pass def record_sale(self, item_name: str, quantity: int) -> None: pass def get_stock_report(self) -> dict: pass ``` # Input: - `item_name` (str): The name of the item. - `quantity` (int): The number of items to add, update, or sell. - `price` (float): The price per item. # Output: - `add_item` method does not return anything. - `update_quantity` method does not return anything. - `record_sale` method does not return anything. - `get_stock_report` method returns a dictionary where keys are item names and values are tuples containing the current quantity and price of each item. # Constraints: - `item_name` is a non-empty string with a maximum length of 100 characters. - `quantity` is an integer between -10^6 and 10^6. - `price` is a positive float up to two decimal points. # Example: ```python >>> inventory = Inventory() >>> inventory.add_item(\\"Apple\\", 50, 0.5) >>> inventory.add_item(\\"Banana\\", 100, 0.2) >>> inventory.update_quantity(\\"Apple\\", 20) >>> inventory.record_sale(\\"Banana\\", 30) >>> inventory.get_stock_report() {\'Apple\': (70, 0.50), \'Banana\': (70, 0.20)} >>> inventory.update_quantity(\\"Apple\\", -10) >>> inventory.record_sale(\\"Apple\\", 5) >>> inventory.get_stock_report() {\'Apple\': (55, 0.50), \'Banana\': (70, 0.20)} ``` # Notes: - If an attempt is made to update or sell an item that doesn\'t exist, raise a `ValueError` with an appropriate message. - If an attempt is made to sell more items than available, raise a `ValueError` with an appropriate message. - Ensure the price is always stored up to two decimal points in the stock report.","solution":"class Inventory: def __init__(self): self.items = {} def add_item(self, item_name: str, quantity: int, price: float) -> None: if item_name not in self.items: self.items[item_name] = (quantity, round(price, 2)) else: current_quantity, current_price = self.items[item_name] self.items[item_name] = (current_quantity + quantity, round(price, 2)) def update_quantity(self, item_name: str, quantity: int) -> None: if item_name in self.items: current_quantity, price = self.items[item_name] self.items[item_name] = (current_quantity + quantity, price) else: raise ValueError(f\\"Item \'{item_name}\' does not exist in inventory.\\") def record_sale(self, item_name: str, quantity: int) -> None: if item_name in self.items: current_quantity, price = self.items[item_name] if quantity > current_quantity: raise ValueError(f\\"Not enough quantity of \'{item_name}\' to record sale.\\") self.items[item_name] = (current_quantity - quantity, price) else: raise ValueError(f\\"Item \'{item_name}\' does not exist in inventory.\\") def get_stock_report(self) -> dict: return {item: (quantity, price) for item, (quantity, price) in self.items.items()}"},{"question":"# Problem Statement: You are implementing a function for matrix manipulation in the context of image processing. Specifically, you need to rotate a square matrix 90 degrees clockwise. This function will be useful for operations such as image orientation adjustment. # Requirements: 1. Implement a function `rotate_matrix` that takes in a `matrix` (a 2D list) and returns the new matrix obtained by rotating the original matrix 90 degrees clockwise. 2. Validate that the input matrix is non-empty and square (i.e., the number of rows equals the number of columns). If the matrix does not meet these criteria, raise a `ValueError` with an appropriate error message. 3. The function should perform the rotation in-place if possible; otherwise, it should return a new matrix. # Constraints: - Do not use any built-in matrix rotation functions or third-party libraries. - Handle edge cases such as empty matrices or matrices with non-square dimensions by raising exceptions. # Function Signature: ```python def rotate_matrix(matrix: list[list[int]]) -> list[list[int]]: pass ``` # Example: ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotated_matrix = rotate_matrix(matrix) print(rotated_matrix) # Output should be: # [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] matrix = [ [1, 2], [3, 4] ] rotated_matrix = rotate_matrix(matrix) print(rotated_matrix) # Output should be: # [ # [3, 1], # [4, 2] # ] ``` # Note: - Ensure your function performs efficiently for typical input sizes. - Validate input thoroughly and handle improper dimensions gracefully by raising the appropriate exceptions.","solution":"def rotate_matrix(matrix): Rotates a square matrix 90 degrees clockwise. Args: matrix (list of list of int): A 2D list representing the matrix. Returns: list of list of int: The rotated matrix. Raises: ValueError: If the matrix is not square or if it is empty. if not matrix or not matrix[0]: raise ValueError(\\"The matrix is empty\\") n = len(matrix) for row in matrix: if len(row) != n: raise ValueError(\\"The matrix is not square\\") # Rotating the matrix 90 degrees clockwise rotated_matrix = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): rotated_matrix[j][n-1-i] = matrix[i][j] return rotated_matrix"},{"question":"# Coding Question: Implementing a Custom Sorting Algorithm Context A logistics company has a list of delivery packages that need to be sorted according to their priority levels. The priority levels are represented as integers, where a lower number indicates a higher priority. Additionally, the system must proceed without using any built-in sorting functions, as it should emulate an in-house sorting mechanism. Problem Statement Implement the function `custom_priority_sort` that sorts the delivery packages based on their priority levels using the insertion sort technique. **Function Signature:** ```python def custom_priority_sort(package_priorities: list[int]) -> list[int] ``` **Input:** - `package_priorities` (List of integers): A list of integers representing the priority levels of delivery packages. **Output:** - Returns a list of integers, sorted in ascending order of priority levels. **Constraints:** - 0 <= len(package_priorities) <= 10^5 - Priority levels are represented by non-negative integers. - The function should have a time complexity of O(n^2) and must implement the insertion sort algorithm. **Example Usage:** ```python >>> custom_priority_sort([3, 1, 4, 1, 5, 9]) [1, 1, 3, 4, 5, 9] >>> custom_priority_sort([]) [] >>> custom_priority_sort([10, 8, 12, 6, 4, 15]) [4, 6, 8, 10, 12, 15] >>> custom_priority_sort([1]) [1] >>> custom_priority_sort([3, 2, 1]) [1, 2, 3] ``` Additional Notes: 1. Ensure the algorithm correctly handles edge cases such as an empty list or a list with one element. 2. The implementation must strictly follow the insertion sort algorithm without using any other internal or external sorting methods.","solution":"def custom_priority_sort(package_priorities: list[int]) -> list[int]: Sorts the delivery packages based on their priority levels using insertion sort technique. Parameters: package_priorities (list[int]): A list of integers representing the priority levels. Returns: list[int]: A list of integers sorted in ascending order of priority levels. n = len(package_priorities) for i in range(1, n): key = package_priorities[i] j = i - 1 while j >= 0 and package_priorities[j] > key: package_priorities[j + 1] = package_priorities[j] j -= 1 package_priorities[j + 1] = key return package_priorities"},{"question":"# Description Your task is to implement a function that simulates a miniature stack-based calculator. The calculator can perform a series of arithmetic operations based on a given sequence of commands that manipulate a stack of integers. # Requirements 1. **Inputs**: - `commands`: A list of strings, where each string represents an arithmetic operation or integer to be processed by the stack. - Valid operations are `\\"push X\\"`, `\\"pop\\"`, and `\\"add\\"`. - `\\"push X\\"`: Pushes integer `X` onto the stack. - `\\"pop\\"`: Removes the top element from the stack. - `\\"add\\"`: Pops the top two elements, adds them together, and then pushes the result back onto the stack. 2. **Output**: - An integer representing the final top of the stack. - If the stack is empty after processing all commands, return 0. # Constraints 1. You may assume all numeric values in the commands fit within standard integer limits. 2. Handle potential invalid operations gracefully, such as trying to \\"pop\\" from an empty stack or not having enough elements to \\"add\\". # Performance Requirements 1. The function should run efficiently with respect to both time and space complexity. 2. Ensure robustness in error handling while maintaining performance. # Function Signature ```python def stack_calculator(commands: list[str]) -> int: pass ``` # Examples ```python # Example 1: commands1 = [\\"push 5\\", \\"push 3\\", \\"add\\", \\"push 2\\", \\"add\\"] print(stack_calculator(commands1)) # Should output: 10 # Example 2: commands2 = [\\"push 1\\", \\"push 2\\", \\"pop\\", \\"add\\"] print(stack_calculator(commands2)) # Should output: 1 # Example 3: commands3 = [\\"push 7\\", \\"push 8\\", \\"add\\", \\"pop\\"] print(stack_calculator(commands3)) # Should output: 0 ``` # Note - Ensure the function properly handles edge cases, such as empty command lists or invalid operations. - Pay attention to the correctness and stability of the implementation, especially when dealing with stack underflows or repeated invalid commands.","solution":"def stack_calculator(commands): stack = [] for command in commands: if command.startswith(\\"push\\"): try: _, value = command.split() stack.append(int(value)) except ValueError: pass # Silently ignore invalid push commands elif command == \\"pop\\": if stack: stack.pop() elif command == \\"add\\": if len(stack) >= 2: a = stack.pop() b = stack.pop() stack.append(a + b) return stack[-1] if stack else 0"},{"question":"# Problem Statement You are given a string representing a binary number. Your task is to determine if this binary number is a palindrome when compared from both ends. A binary string is a palindrome if it reads the same forwards and backwards. For example, the binary string `101` is a palindrome, whereas `110` is not. # Input * A string `binary_str` of length `n` where `1 <= n <= 10^6`. # Output * Return `True` if the binary string is a palindrome, otherwise return `False`. # Implementation Implement the following function: ```python def is_binary_palindrome(binary_str: str) -> bool: Determine if a binary string is a palindrome. :param binary_str: String representing a binary number :return: Boolean indicating if the binary string is a palindrome >>> is_binary_palindrome(\\"101\\") True >>> is_binary_palindrome(\\"110\\") False >>> is_binary_palindrome(\\"1111\\") True >>> is_binary_palindrome(\\"1001\\") True >>> is_binary_palindrome(\\"1010\\") False pass ``` # Constraints * The binary string length can be up to `10^6`. # Edge Cases * A single-character string is always a palindrome. * Check for very large strings efficiently. # Example ```python print(is_binary_palindrome(\\"101\\")) # Output: True print(is_binary_palindrome(\\"110\\")) # Output: False print(is_binary_palindrome(\\"1111\\")) # Output: True print(is_binary_palindrome(\\"1001\\")) # Output: True print(is_binary_palindrome(\\"1010\\")) # Output: False ```","solution":"def is_binary_palindrome(binary_str: str) -> bool: Determine if a binary string is a palindrome. :param binary_str: String representing a binary number :return: Boolean indicating if the binary string is a palindrome >>> is_binary_palindrome(\\"101\\") True >>> is_binary_palindrome(\\"110\\") False >>> is_binary_palindrome(\\"1111\\") True >>> is_binary_palindrome(\\"1001\\") True >>> is_binary_palindrome(\\"1010\\") False return binary_str == binary_str[::-1]"},{"question":"# Coding Assessment Question **Scenario**: You are working on a project that involves processing and managing numerical data. One of the tasks requires you to classify numbers as prime or non-prime and then perform operations only on the prime numbers. A prime number is a natural number greater than 1 that cannot be formed by multiplying two smaller natural numbers. **Task**: Implement a class that can: 1. Check if a number is prime. 2. Store the primes in a list. 3. Calculate the sum of stored prime numbers. # Function Signature ```python class PrimeManager: def __init__(self): Initialize an empty list to store prime numbers. self.primes = [] def is_prime(self, n): Checks if a number n is prime. Arguments: n -- an integer to check for primality Returns: True if n is a prime number, False otherwise. pass def add_prime(self, n): Adds a prime number to the list of stored primes. Arguments: n -- an integer to add to the primes list Raises: ValueError if n is not a prime number. pass def get_primes(self): Returns the list of stored prime numbers. pass def sum_primes(self): Returns the sum of all stored prime numbers. Returns: The sum of the primes stored in the primes list. pass ``` # Requirements 1. **`PrimeManager` Class**: - **Initialization**: - Initializes with an empty list to store prime numbers. - **`is_prime(n)` Method**: - **Input**: An integer `n` to check for primality. - **Output**: `True` if `n` is prime, `False` otherwise. - **Constraints**: - Should handle edge cases like negative numbers and zero. - **`add_prime(n)` Method**: - **Input**: An integer `n` to add to the primes list. - **Behavior**: Adds `n` to the primes list if it is prime. - **Constraints**: - Raises a `ValueError` if `n` is not prime. - **`get_primes()` Method**: - **Output**: The list of stored prime numbers. - **`sum_primes()` Method**: - **Output**: The sum of all stored prime numbers. - **Constraints**: - Returns an integer value representing the sum of primes. # Example ```python pm = PrimeManager() assert pm.is_prime(11) == True assert pm.is_prime(15) == False pm.add_prime(17) pm.add_prime(2) assert pm.get_primes() == [17, 2] assert pm.sum_primes() == 19 try: pm.add_prime(18) # Should raise ValueError since 18 is not prime except ValueError as e: print(e) ``` # Constraints - **Time Complexity**: - The `is_prime` method should be efficient, ideally with a time complexity of O(sqrt(n)). - The `add_prime`, `get_primes`, and `sum_primes` methods should operate in linear time relative to the number of primes stored. - **Space Complexity**: - Minimize the additional memory usage, optimize for storing primes. # Note - Ensure your implementation handles edge cases, such as dealing with non-integer inputs and large prime checks. - Document any assumptions you make or specific conditions you handle.","solution":"class PrimeManager: def __init__(self): Initialize an empty list to store prime numbers. self.primes = [] def is_prime(self, n): Checks if a number n is prime. Arguments: n -- an integer to check for primality Returns: True if n is a prime number, False otherwise. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False sqrt_n = int(n**0.5) + 1 for i in range(3, sqrt_n, 2): if n % i == 0: return False return True def add_prime(self, n): Adds a prime number to the list of stored primes. Arguments: n -- an integer to add to the primes list Raises: ValueError if n is not a prime number. if self.is_prime(n): self.primes.append(n) else: raise ValueError(f\\"{n} is not a prime number\\") def get_primes(self): Returns the list of stored prime numbers. return self.primes def sum_primes(self): Returns the sum of all stored prime numbers. Returns: The sum of the primes stored in the primes list. return sum(self.primes)"},{"question":"# Generate a Fractal Image using the Mandelbrot Set Implement a function to generate a fractal image based on the Mandelbrot set. The Mandelbrot set is a famous fractal defined by iterating the function (z_{n+1} = z_n^2 + c), where both (z) and (c) are complex numbers, and counting how many iterations it takes for the magnitude of (z) to exceed a threshold (usually 2). # Input and Output Input * `width`: An integer representing the width of the output image. * `height`: An integer representing the height of the output image. * `max_iter`: An integer representing the maximum number of iterations to determine membership in the set (default: 100). Output * A 2D numpy array of size `(height, width)` with values representing the iteration count at which each point in the image exits the threshold. Points that remain within the threshold for the maximum number of iterations should be set to 0. # Constraints * The complex plane should be mapped to the output image such that: * The real part ranges from -2.0 to 1.0. * The imaginary part ranges from -1.5 to 1.5. * Use numpy for array operations. ```python import numpy as np def mandelbrot(width, height, max_iter=100): # Initialize the output image image = np.zeros((height, width)) for row in range(height): for col in range(width): # Map pixel coordinate to the complex plane c = complex(-2 + (col / width) * 3, -1.5 + (row / height) * 3) z = 0 + 0j iter_count = 0 # Iterate to check Mandelbrot condition while abs(z) <= 2 and iter_count < max_iter: z = z**2 + c iter_count += 1 # Store the iteration count, 0 if within set after max_iter image[row, col] = 0 if iter_count == max_iter else iter_count return image # Example usage mandelbrot(800, 800) ``` # Explanation: 1. We create a `mandelbrot` function that accepts `width`, `height`, and `max_iter`. 2. A 2D numpy array `image` is initialized to store the iteration counts for each point. 3. We loop through each pixel and map it to a point in the complex plane. 4. For each mapped point, we initialize `z` to 0 and iterate the function (z_{n+1} = z_n^2 + c). 5. If ( |z| ) exceeds 2 before reaching `max_iter` iterations, record the iteration count in `image`. 6. If ( |z| ) does not exceed 2 after `max_iter` iterations, set the corresponding pixel value to 0. 7. Return the generated 2D numpy array representing the fractal image.","solution":"import numpy as np def mandelbrot(width, height, max_iter=100): Generates a 2D array representing the Mandelbrot set. Parameters: - width (int): Width of the output image. - height (int): Height of the output image. - max_iter (int): Maximum number of iterations (default is 100). Returns: - numpy.ndarray: 2D array of size (height, width) with values representing the iteration count at which each point exits the threshold. # Initialize the output image image = np.zeros((height, width)) for row in range(height): for col in range(width): # Map pixel coordinate to the complex plane c = complex(-2 + (col / width) * 3, -1.5 + (row / height) * 3) z = 0 + 0j iter_count = 0 # Iterate to check Mandelbrot condition while abs(z) <= 2 and iter_count < max_iter: z = z**2 + c iter_count += 1 # Store the iteration count, 0 if within set after max_iter image[row, col] = 0 if iter_count == max_iter else iter_count return image"},{"question":"# Longest Common Substring Coding Challenge Context Finding the longest common substring between two strings is a classic problem in computer science, useful in various applications such as bioinformatics, text analysis, and plagiarism detection. You are tasked with implementing an efficient algorithm to solve this problem. Task Write a function `longest_common_substring(str1: str, str2: str) -> str` that finds the longest common substring between two given strings. Input/Output Formats * **Input**: Two strings `str1` and `str2` consisting of lowercase English letters. * Example: `str1 = \\"abcdef\\"`, `str2 = \\"zabcyf\\"` * **Output**: A string representing the longest common substring. If multiple substrings of maximum length exist, return any one of them. * Example: `\\"abc\\"` Constraints * The length of each string is between 1 and 1000. Performance Requirements * The function should run efficiently with a time complexity of O(m * n) and space complexity of O(m * n), where `m` and `n` are the lengths of `str1` and `str2`, respectively. Example Code ```python def longest_common_substring(str1: str, str2: str) -> str: m, n = len(str1), len(str2) dp = [[0] * (n + 1) for _ in range(m + 1)] longest_length = 0 end_index = 0 for i in range(1, m + 1): for j in range(1, n + 1): if str1[i - 1] == str2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 if dp[i][j] > longest_length: longest_length = dp[i][j] end_index = i else: dp[i][j] = 0 return str1[end_index - longest_length: end_index] # Test Cases print(longest_common_substring(\\"abcdef\\", \\"zabcyf\\")) # Output: \\"abc\\" print(longest_common_substring(\\"12345\\", \\"34512\\")) # Output: \\"345\\" print(longest_common_substring(\\"rainbow\\", \\"bowrain\\")) # Output: \\"bow\\" or \\"rain\\" ``` Note * Ensure that the function handles edge cases such as no common substring. * You may assume input strings will be non-empty, based on the constraints provided.","solution":"def longest_common_substring(str1: str, str2: str) -> str: Finds the longest common substring between two given strings. :param str1: First input string :param str2: Second input string :return: The longest common substring m, n = len(str1), len(str2) dp = [[0] * (n + 1) for _ in range(m + 1)] longest_length = 0 end_index = 0 for i in range(1, m + 1): for j in range(1, n + 1): if str1[i - 1] == str2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 if dp[i][j] > longest_length: longest_length = dp[i][j] end_index = i else: dp[i][j] = 0 return str1[end_index - longest_length: end_index]"},{"question":"# Task: Implement a BigInteger Class for Large Integer Arithmetic Scenario You are tasked with implementing a `BigInteger` class in Python to perform arithmetic operations on very large integers, as built-in data types may not support the precision required for certain applications. Your class should handle addition, subtraction, multiplication, and must support initialization from strings. Requirements 1. **Class Definition**: Define the class `BigInteger` that supports the following: * **Initialization**: * `__init__(self, value: str)`: - Takes a string `value` representing a large integer (can be positive or negative) and initializes the `BigInteger` instance. * **Addition**: * `__add__(self, other: \'BigInteger\') -> \'BigInteger\'`: - Supports addition between two `BigInteger` instances. * **Subtraction**: * `__sub__(self, other: \'BigInteger\') -> \'BigInteger\'`: - Supports subtraction between two `BigInteger` instances. * **Multiplication**: * `__mul__(self, other: \'BigInteger\') -> \'BigInteger\'`: - Supports multiplication between two `BigInteger` instances. * **String Representation**: * `__str__(self) -> str`: - Returns the string representation of the `BigInteger` instance. Input and Output Format * **Input**: * Instances will be created using strings representing large integers, e.g., `BigInteger(\\"12345678901234567890\\")`. * **Operations**: * `+`, `-`, `*` will be used to invoke the addition, subtraction, and multiplication functionality respectively. * **Output**: * Operations return a new `BigInteger` instance. * The `__str__` method should convert the `BigInteger` to its string representation for display. Example ```python a = BigInteger(\\"12345678901234567890\\") b = BigInteger(\\"98765432109876543210\\") c = a + b print(c) # Output: \\"111111111011111111100\\" d = b - a print(d) # Output: \\"86419753208641975320\\" e = a * b print(e) # Output: \\"1219326320073159603875937425101759561710\\" ``` Constraints * Input strings will contain only digits and an optional leading `-` for negative numbers. * The length of input strings will be between 1 and 1000 digits. * Ensure the implementation is efficient and handles edge cases, such as negative results and zero. Implement the `BigInteger` class and its methods to perform the required operations effectively.","solution":"class BigInteger: def __init__(self, value: str): self.value = value def __add__(self, other: \'BigInteger\') -> \'BigInteger\': result = int(self.value) + int(other.value) return BigInteger(str(result)) def __sub__(self, other: \'BigInteger\') -> \'BigInteger\': result = int(self.value) - int(other.value) return BigInteger(str(result)) def __mul__(self, other: \'BigInteger\') -> \'BigInteger\': result = int(self.value) * int(other.value) return BigInteger(str(result)) def __str__(self) -> str: return self.value"},{"question":"# Problem Statement You are given a list of points in a 2D plane and a point representing the center of a circle. Your task is to write a function `points_within_radius` that determines which of these points fall within a given radius from the center point. # Function Signature ```python def points_within_radius(points: List[Tuple[float, float]], center: Tuple[float, float], radius: float) -> List[Tuple[float, float]]: pass ``` # Parameters - `points`: A list of tuples where each tuple consists of two floats representing the x and y coordinates of a point in the 2D plane. - `center`: A tuple consisting of two floats representing the x and y coordinates of the center point of the circle. - `radius`: A float representing the radius of the circle. # Output - Returns a list of tuples representing the points that lie within or on the circle of the given radius centered at the specified point. # Constraints - The coordinates of points and center are within the range of -10^3 to 10^3. - The radius is a positive float within the range of 0.1 to 10^3. # Example ```python # Example 1: points = [(1, 2), (3, 4), (0, 0), (5, 5)] center = (0, 0) radius = 5.0 # The points (1, 2), (3, 4), and (0, 0) are within or on the circle centered at (0, 0) with radius 5. assert points_within_radius(points, center, radius) == [(1, 2), (3, 4), (0, 0)] # Example 2: points = [(1, 1), (2, 2), (3, 3)] center = (1, 1) radius = 1.0 # Only the point (1, 1) is within or on the circle centered at (1, 1) with radius 1. assert points_within_radius(points, center, radius) == [(1, 1)] ``` # Guidelines 1. Calculate the Euclidean distance between each point and the center point. 2. If the distance is less than or equal to the radius, include the point in the output list. 3. Handle edge cases such as when there are no points or when the radius is zero (though given it should never be zero as per constraints). # Hints - Use the distance formula: (sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2}) to find the distance between two points ((x_1, y_1)) and ((x_2, y_2)). - Loop through each point and check the distance from the center point.","solution":"import math from typing import List, Tuple def points_within_radius(points: List[Tuple[float, float]], center: Tuple[float, float], radius: float) -> List[Tuple[float, float]]: Returns the points that are within a given radius from the center point. result = [] cx, cy = center for px, py in points: distance = math.sqrt((px - cx) ** 2 + (py - cy) ** 2) if distance <= radius: result.append((px, py)) return result"},{"question":"# Stock Price Analyzer Context: You are a software developer working on a financial application that tracks and analyzes stock prices. One of the core features required is the ability to compute key metrics from historical stock price data, such as the average price over a given range and the maximum profit that could be obtained from a single buy-sell transaction within that range. Objective: Write a `StockPriceAnalyzer` class that can manage a series of stock prices and efficiently compute the specified metrics. Specifications: - **Class Name**: `StockPriceAnalyzer` - **Methods**: - `__init__(self, prices: List[int]) -> None`: Initializes the analyzer with a list of stock prices. - `average_price(self, start: int, end: int) -> float`: Returns the average stock price between the indices `start` and `end` (inclusive). - `max_profit(self, start: int, end: int) -> int`: Returns the maximum profit that could be made with a single buy-sell transaction within the given range. Input Format: The methods take indices (0-based) as arguments, representing the range of days to consider. The prices list contains integers representing the stock price for each day. Output Format: Return appropriate numeric values for each of the requested metrics without modifying the internal state of the stock prices list. Edge Cases: - Ensure that the `average_price` method handles cases where the `start` and `end` indices are the same. - Handle scenarios where `max_profit` might result in a no-op (buying and selling on the same day or when there is no profitable transaction possible). Example: ```python from typing import List class StockPriceAnalyzer: def __init__(self, prices: List[int]) -> None: self.prices = prices def average_price(self, start: int, end: int) -> float: total = sum(self.prices[start:end+1]) count = end - start + 1 return total / count def max_profit(self, start: int, end: int) -> int: min_price = float(\'inf\') max_profit = 0 for i in range(start, end + 1): price = self.prices[i] if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit # Testing the class with an example prices = [120, 180, 260, 310, 40, 535, 695] analyzer = StockPriceAnalyzer(prices) print(analyzer.average_price(0, 3)) # Output: 217.5 print(analyzer.max_profit(1, 4)) # Output: 270 ``` Ensure to test the code with various edge cases to confirm that the implementation is robust and handles different scenarios effectively.","solution":"from typing import List class StockPriceAnalyzer: def __init__(self, prices: List[int]) -> None: self.prices = prices def average_price(self, start: int, end: int) -> float: total = sum(self.prices[start:end+1]) count = end - start + 1 return total / count def max_profit(self, start: int, end: int) -> int: min_price = float(\'inf\') max_profit = 0 for i in range(start, end + 1): price = self.prices[i] if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"# Problem Statement You are working on a text processing module and need to implement a function that replaces every occurrence of a specified word in an input string with another specified word. The replacement should be case-sensitive, and the function should handle edge cases like punctuation and standalone occurrences of the word. # Requirements: 1. Your function should replace only standalone occurrences of the word, not substrings within other words. 2. Ensure punctuation and spaces around the replaced words are preserved accurately. 3. Do not use regular expressions for this task. # Function Signature: ```python def replace_word(input_text: str, target_word: str, replacement_word: str) -> str: pass ``` # Expected Input and Output: 1. **Input**: A string `input_text` containing the text to be processed, a string `target_word` for the word to be replaced, and a string `replacement_word` for the word to replace with. 2. **Output**: A string with all standalone occurrences of the `target_word` replaced by the `replacement_word`. **Example**: ```python replace_word(\\"The rain in Spain stays mainly in the plain.\\", \\"in\\", \\"on\\") # Output: \\"The rain on Spain stays mainly on the plain.\\" replace_word(\\"The quick brown fox jumps over the lazy dog.\\", \\"dog\\", \\"cat\\") # Output: \\"The quick brown fox jumps over the lazy cat.\\" ``` # Constraints: 1. The input `input_text` can have up to 10^4 characters. 2. The `target_word` and `replacement_word` will not contain punctuation marks but may have alphabetic characters and can be at most 100 characters in length. 3. Consider words to be space-separated, and preserve the original spaces and punctuation in the processed output text.","solution":"def replace_word(input_text: str, target_word: str, replacement_word: str) -> str: def is_valid_word_boundary(c): return c in [\' \', \'.\', \',\', \';\', \':\', \'!\', \'?\', \'(\', \')\', \'[\', \']\', \'-\', \'_\', \'n\', \'t\'] words = list(input_text) word_len = len(target_word) i = 0 while i <= len(words) - word_len: if words[i:i+word_len] == list(target_word): # Check word boundaries to ensure it\'s a standalone word if (i == 0 or is_valid_word_boundary(words[i-1])) and (i+word_len == len(words) or is_valid_word_boundary(words[i+word_len])): words[i:i+word_len] = list(replacement_word) i += word_len # Move past the replaced word else: i += 1 else: i += 1 return \'\'.join(words)"},{"question":"# Problem Statement You are tasked with creating a function to calculate the minimum cost to connect all cities in a given country. Each city is represented as a node, and each possible connection between two cities has an associated cost. The objective is to use the Mininum Spanning Tree (MST) algorithm to determine the minimum cost of constructing the road network. # Function Signature ```python def minimum_cost_to_connect_cities(n: int, roads: List[Tuple[int, int, int]]) -> int: pass ``` # Input 1. **n**: An integer representing the number of cities (nodes). 2. **roads**: A list of tuples where each tuple consists of three integers `(u, v, w)`, representing a bidirectional road between cities `u` and `v` with a cost `w`. # Output 1. An integer representing the minimum cost to connect all cities. If it is not possible to connect all cities, return `-1`. # Constraints 1. `1 <= n <= 1000` 2. `1 <= len(roads) <= 10000` 3. `1 <= u, v <= n` 4. `1 <= w <= 100000` # Performance Requirements - The solution should efficiently determine the minimum cost with a time complexity of O(E log E), where E is the number of edges (roads). # Examples ```python assert minimum_cost_to_connect_cities(4, [(1, 2, 3), (2, 3, 1), (3, 4, 4), (4, 1, 2)]) == 6 assert minimum_cost_to_connect_cities(3, [(1, 2, 5), (1, 3, 6)]) == 11 assert minimum_cost_to_connect_cities(4, [(1, 2, 1), (2, 3, 2)]) == -1 ``` # Error Handling - The function should raise a `TypeError` if the inputs `n` is not an integer or `roads` is not a list of tuples. - The function should raise a `ValueError` if any city `u` or `v` is outside the valid range of 1 to `n`. # Notes - It might help to use Kruskal\'s or Prim\'s algorithm for finding the Minimum Spanning Tree (MST). - If there are multiple ways to connect all cities, any minimum cost is acceptable.","solution":"from typing import List, Tuple def minimum_cost_to_connect_cities(n: int, roads: List[Tuple[int, int, int]]) -> int: Calculate the minimum cost to connect all cities using Minimum Spanning Tree (MST). if not isinstance(n, int) or n <= 0: raise ValueError(\\"Number of cities should be a positive integer\\") if not isinstance(roads, list): raise TypeError(\\"The roads parameter should be a list\\") for road in roads: if not (isinstance(road, tuple) and len(road) == 3 and isinstance(road[0], int) and isinstance(road[1], int) and isinstance(road[2], int)): raise TypeError(\\"Each road should be a tuple of three integers (u, v, w)\\") u, v, w = road if u < 1 or u > n or v < 1 or v > n: raise ValueError(\\"City identifiers should be within range 1 to n\\") # Helper function for finding the root of a node in the Disjoint Set def find(parent, i): if parent[i] == i: return i return find(parent, parent[i]) # Helper function to do union of two subsets def union(parent, rank, x, y): root_x = find(parent, x) root_y = find(parent, y) if rank[root_x] < rank[root_y]: parent[root_x] = root_y elif rank[root_x] > rank[root_y]: parent[root_y] = root_x else: parent[root_y] = root_x rank[root_x] += 1 # Implements Kruskal\'s algorithm roads.sort(key=lambda x: x[2]) parent = [] rank = [] # Create V subsets with single elements for node in range(n+1): parent.append(node) rank.append(0) mst_cost = 0 edges_used = 0 for road in roads: u, v, w = road root_u = find(parent, u) root_v = find(parent, v) if root_u != root_v: mst_cost += w union(parent, rank, root_u, root_v) edges_used += 1 if edges_used == n - 1: break # Check if all cities are connected if edges_used != n - 1: return -1 return mst_cost"},{"question":"# Coding Question: Parking Lot Occupancy Management Scenario You are responsible for designing a system to manage the occupancy of a parking lot. The parking lot is represented by a series of slots, where each slot can either be occupied by a car or empty. Your task is to implement a function `manage_parking_lot` that simulates the state of parking lot slots over a given number of time steps based on car arrival and departure patterns. Task Implement the function `manage_parking_lot` in Python that simulates the occupancy of parking slots over a series of time steps. Function Signature ```python def manage_parking_lot( number_of_slots: int, number_of_steps: int, arrivals: list, departures: list ) -> list: ``` Parameters * `number_of_slots` (int): Total number of parking slots. * `number_of_steps` (int): Total number of time steps to simulate. * `arrivals` (list): List of lists, where each sublist represents the time step and the slot index of a car arriving `[time_step, slot_index]`. * `departures` (list): List of lists, where each sublist represents the time step and the slot index of a car departing `[time_step, slot_index]`. Returns * `list`: The state of the parking lot at each time step as a list of lists, where each sublist depicts the parking lot at a specific time step (1 - occupied, 0 - empty). Constraints * (1 leq number_of_slots leq 1000) * (1 leq number_of_steps leq 100) * `arrivals` and `departures` will only contain valid time steps and slot indices based on the parameters defined. Example ```python # Example 1 result = manage_parking_lot(5, 4, [[0, 1], [1, 2], [3, 4]], [[2, 1], [3, 2]]) # Output: [[0, 1, 0, 0, 0], [0, 1, 1, 0, 0], [0, 0, 1, 0, 0], [0, 0, 0, 0, 1], [0, 0, 0, 0, 1]] # Example 2 result = manage_parking_lot(3, 3, [[0, 0], [1, 2]], [[1, 0], [2, 2]]) # Output: [[1, 0, 0], [0, 0, 1], [0, 0, 0], [0, 0, 0]] ``` A car can only occupy a slot if it is empty, and a car can only depart if it occupies the slot. Ensure your solution handles these conditions correctly and simulates the state transitions accurately.","solution":"def manage_parking_lot(number_of_slots: int, number_of_steps: int, arrivals: list, departures: list) -> list: # Initialize the state of the parking lot parking_lot_state = [[0] * number_of_slots for _ in range(number_of_steps + 1)] # Update the parking lot state based on arrivals and departures for t in range(number_of_steps): # Carry forward the previous state parking_lot_state[t + 1] = parking_lot_state[t].copy() # Process arrivals at time step t for arrival in arrivals: if arrival[0] == t: slot_index = arrival[1] parking_lot_state[t + 1][slot_index] = 1 # Occupy the slot if it\'s empty # Process departures at time step t for departure in departures: if departure[0] == t: slot_index = departure[1] parking_lot_state[t + 1][slot_index] = 0 # Clear the slot if it\'s occupied return parking_lot_state"},{"question":"# Sorting Challenge: Custom Sort by Factors Context: Sorting is a fundamental operation in many algorithms and applications. In this challenge, you are required to implement a custom sorting algorithm based on the number of factors (divisors) a number has. This type of sorting can be particularly useful in mathematical problems and optimizations where factors play a key role. # Function: Custom Sort by Number of Factors **Description**: Write a function, `custom_sort(numbers: List[int]) -> List[int]`, that takes a list of positive integers and sorts them in ascending order based on the number of factors (divisors) they have. If two numbers have the same number of factors, sort them by their values in ascending order. - **Input**: A list of integers `numbers` (1 ≤ len(numbers) ≤ 10^5, 1 ≤ numbers[i] ≤ 10^6) - **Output**: A list of integers sorted based on the number of their factors. - **Constraints**: - Efficiency is crucial, ensure your function performs well with the maximum constraints. - The number of factors of a number should be calculated optimally. ```python from typing import List def custom_sort(numbers: List[int]) -> List[int]: Sorts the input list of numbers based on the number of factors. If two numbers have the same number of factors, they are sorted by their values. pass # Implement the function # Example Usage: # custom_sort([10, 13, 12]) -> [13, 10, 12] # Explanation: 13 has 2 factors (1, 13); 10 has 4 factors (1, 2, 5, 10); 12 has 6 factors (1, 2, 3, 4, 6, 12) # Therefore, the order is based on the number of factors: [13, 10, 12]. ``` Notes: 1. You may want to precompute the number of factors for a range of numbers to optimize your solution. 2. Consider edge cases, such as all numbers having the same number of factors, or the list containing consecutive numbers. Ensure your solution is efficient and handles the constraints gracefully.","solution":"from typing import List def count_factors(n: int) -> int: Returns the number of factors of the given number n. count = 0 sqrt_n = int(n**0.5) for i in range(1, sqrt_n + 1): if n % i == 0: if i * i == n: count += 1 # Perfect square else: count += 2 # Both factor pairs (i and n/i) return count def custom_sort(numbers: List[int]) -> List[int]: Sorts the input list of numbers based on the number of factors. If two numbers have the same number of factors, they are sorted by their values. return sorted(numbers, key=lambda x: (count_factors(x), x))"},{"question":"# Coding Assessment Question Context You are working on a software that requires the management of events in a calendar-like structure. Each event has a start time and an end time. Your task is to implement an interval tree to efficiently add, remove, and query overlapping events. Task Implement the `EventCalendar` class with the following functionalities: 1. **AddEvent**: Add an event with a `start` and `end` time. 2. **RemoveEvent**: Remove an event with a specific `start` and `end` time. 3. **FindOverlappingEvents**: Find all events that overlap with a given event specified by `start` and `end` time. 4. **Clear**: Remove all events from the calendar. 5. **AllEvents**: Retrieve a sorted list of all events. Requirements - Implement the `EventCalendar` class with all the specified methods. - Ensure that events are stored in an interval tree to provide efficient queries. - Handle edge cases such as adding an event that overlaps with others and attempting to remove or find events in an empty calendar. Example Usage ```python ec = EventCalendar() ec.add_event(1, 5) ec.add_event(6, 10) ec.add_event(8, 12) overlapping_events = ec.find_overlapping_events(7, 11) print(overlapping_events) # Output: [(6, 10), (8, 12)] ec.remove_event(8, 12) all_events = ec.all_events() print(all_events) # Output: [(1, 5), (6, 10)] ec.clear() all_events = ec.all_events() print(all_events) # Output: [] ``` Input/Output Format - **AddEvent**: Accepts two integers `start` and `end`. - **RemoveEvent**: Accepts two integers `start` and `end` representing the event to be removed. - **FindOverlappingEvents**: Accepts two integers `start` and `end` and returns a list of tuples. - **Clear**: Clears all events from the calendar. - **AllEvents**: Returns a sorted list of all events as tuples `(start, end)`. Constraints - Event times are given as integers within the 24-hour format range `[0, 23]`. - No two events will have the exact same `start` and `end` time. Performance - Ensure that all operations perform efficiently to handle a large number of events.","solution":"class EventCalendar: def __init__(self): self.events = [] def add_event(self, start, end): self.events.append((start, end)) self.events.sort() def remove_event(self, start, end): if (start, end) in self.events: self.events.remove((start, end)) def find_overlapping_events(self, start, end): overlapping_events = [] for event in self.events: if event[0] < end and event[1] > start: overlapping_events.append(event) return overlapping_events def clear(self): self.events.clear() def all_events(self): return sorted(self.events)"},{"question":"# Maximum Subarray Sum Using Divide and Conquer Context As an algorithm engineer working on data analysis, you often encounter the need to find the maximum sum of a contiguous subarray within a one-dimensional array of numbers. This problem is frequently used in performance analytics, specifically when you need to analyze and optimize the performance of specific segments within a time series data. Given large arrays, an efficient algorithm is necessary to handle performance constraints. Task Implement the divide and conquer approach to write a function `max_subarray_sum` that computes the maximum sum of a contiguous subarray within the given array. **Function Signature**: ```python def max_subarray_sum(arr: List[int]) -> int: pass ``` Input - `arr` (List[int]): A list of integers where 1 ≤ len(arr) ≤ 100,000 and each element in the range [−10^4, 10^4]. Output - (int): The maximum sum of a contiguous subarray. Constraints - Employ the divide and conquer approach to solve the problem efficiently in O(n log n) time complexity. - Handle edge cases such as arrays with all negative numbers or all positive numbers. - Ensure the function runs efficiently for the upper limit of the array size. Examples 1. **Input**: `arr = [-2, 1, -3, 4, -1, 2, 1, -5, 4]` **Output**: `6` (because the subarray [4, -1, 2, 1] has the maximum sum 6) 2. **Input**: `arr = [1, 2, 3, 4, 5]` **Output**: `15` (because the entire array forms the maximum sum subarray) 3. **Input**: `arr = [-1, -2, -3, -4]` **Output**: `-1` (because the subarray [-1] is the maximum sum subarray) Implement the `max_subarray_sum` function that accurately and efficiently determines the maximum sum of a contiguous subarray for any given input array. Ensure all edge cases are tested and handled appropriately.","solution":"from typing import List def max_crossing_sum(arr, left, mid, right): # Include elements on left of mid. left_sum = float(\'-inf\') total = 0 for i in range(mid, left - 1, -1): total += arr[i] if total > left_sum: left_sum = total # Include elements on right of mid right_sum = float(\'-inf\') total = 0 for i in range(mid + 1, right + 1): total += arr[i] if total > right_sum: right_sum = total # Return the sum of elements on left and right of mid return left_sum + right_sum def max_subarray_sum_helper(arr, left, right): if left == right: return arr[left] mid = (left + right) // 2 # Return maximum of the following three possible cases return max(max_subarray_sum_helper(arr, left, mid), max_subarray_sum_helper(arr, mid + 1, right), max_crossing_sum(arr, left, mid, right)) def max_subarray_sum(arr: List[int]) -> int: return max_subarray_sum_helper(arr, 0, len(arr) - 1)"},{"question":"# Context Sorting algorithms are fundamental in computer science and software engineering. Various efficient algorithms like QuickSort, MergeSort, and HeapSort are commonly used to sort arrays or lists. One interesting aspect of sorting involves counting how many times elements are moved or swapped during the sorting process. You are asked to implement a function that sorts an array using Bubble Sort and returns the total number of swaps made. # Objective Write a Python function `count_bubble_sort_swaps` that sorts an integer list using the Bubble Sort algorithm and counts the number of swaps performed during the sorting process. # Requirements 1. The function should accept exactly one parameter: `arr`, which is a list of integers. 2. The function should sort the list using the Bubble Sort algorithm. 3. The function should return an integer which is the total number of swaps done during the sorting. 4. If the input list is empty, the function should return 0. 5. The function should handle input validation: - If the input is not a list, raise a `TypeError`. - If any element in the list is not an integer, raise a `ValueError`. # Implementation Details - Implement the Bubble Sort algorithm. - Track and count each swap performed during the sort. - Ensure input validation as specified. # Input Format - `arr` (list): A list of integers. # Output Format - An integer representing the total number of swaps performed during the Bubble Sort process. # Examples 1. `count_bubble_sort_swaps([4, 3, 1, 2])` returns `5` 2. `count_bubble_sort_swaps([1, 2, 3, 4, 5])` returns `0` 3. `count_bubble_sort_swaps([5, 4, 3, 2, 1])` returns `10` 4. `count_bubble_sort_swaps([])` returns `0` 5. `count_bubble_sort_swaps([3])` returns `0` 6. `count_bubble_sort_swaps([1, \'2\', 3, 4])` raises `ValueError: All elements in the list must be integers` 7. `count_bubble_sort_swaps(\'1, 2, 3, 4\')` raises `TypeError: Input must be a list` # Constraints - Ensure the function performs efficiently with typical input sizes. - Input values will be integers within a reasonable range to prevent overflow or excessive computational time in practice.","solution":"def count_bubble_sort_swaps(arr): Sorts the given list using Bubble Sort and returns the total number of swaps made. Args: arr -- a list of integers Returns: int -- the total number of swaps made during the sorting process Raises: TypeError -- if the input is not a list ValueError -- if any element in the list is not an integer if not isinstance(arr, list): raise TypeError(\\"Input must be a list\\") for x in arr: if not isinstance(x, int): raise ValueError(\\"All elements in the list must be integers\\") n = len(arr) swap_count = 0 for i in range(n - 1): for j in range(n - 1 - i): if arr[j] > arr[j + 1]: arr[j], arr[j + 1] = arr[j + 1], arr[j] swap_count += 1 return swap_count"},{"question":"Problem Description You are tasked with creating a system that compresses and decompresses a specific type of data using a simplified run-length encoding scheme. This will involve encoding sequences of repeated characters and decoding them back to their original form. Task 1. **Implement `run_length_encode` Function**: * Compress the given input string using run-length encoding. * For each group of consecutive repeated characters, output the character followed by the number of repetitions. * If a character appears only once, simply output the character. * Example: \\"aaabbc\\" becomes \\"a3b2c\\". 2. **Implement `run_length_decode` Function**: * Decompress the encoded input string back to its original form. * Parse the number following each character and repeat the character accordingly. * If a character is followed by no number, it means it appeared only once. * Example: \\"a3b2c\\" becomes \\"aaabbc\\". # Input and Output Formats Function 1: `run_length_encode` * **Input**: * A `text` (string) containing alphanumeric characters. * Constraints: The length of the string will not exceed `10^4` characters. * **Output**: * A string representing the run-length encoded version of the input. * **Example**: ```python run_length_encode(\\"aaabbc\\") == \\"a3b2c\\" ``` Function 2: `run_length_decode` * **Input**: * An `encoded_text` (string) representing the run-length encoded version of an original string. * Constraints: The length of the string will not exceed `10^4` characters. * **Output**: * A string representing the original uncompressed form. * **Example**: ```python run_length_decode(\\"a3b2c\\") == \\"aaabbc\\" ``` Implementation Details 1. Implement `run_length_encode` to compress the input string using run-length encoding. 2. Implement `run_length_decode` to decompress the encoded string back to the original string. Your solution should handle edge cases such as an empty string input, single character strings, and strings with no repeated characters.","solution":"def run_length_encode(text): Compresses the given input string using run-length encoding. if not text: return \\"\\" encoded = [] count = 1 previous_char = text[0] for char in text[1:]: if char == previous_char: count += 1 else: encoded.append(previous_char + (str(count) if count > 1 else \\"\\")) count = 1 previous_char = char encoded.append(previous_char + (str(count) if count > 1 else \\"\\")) return \\"\\".join(encoded) def run_length_decode(encoded_text): Decompresses the encoded input string back to its original form. if not encoded_text: return \\"\\" decoded = [] i = 0 while i < len(encoded_text): char = encoded_text[i] j = i + 1 count = 0 while j < len(encoded_text) and encoded_text[j].isdigit(): count = count * 10 + int(encoded_text[j]) j += 1 if count == 0: count = 1 decoded.append(char * count) i = j return \\"\\".join(decoded)"},{"question":"# Order of Characters in Alien Dictionary Problem Statement You are given a sorted dictionary of an alien language with words written in the alien language\'s lexicographical order. Write a function `alien_order(words: List[str]) -> str` that derives the order of characters in the alien language. Function Signature ```python def alien_order(words: List[str]) -> str: ``` Input - `words` (List[str]): A list of strings where each string represents a word in the alien dictionary. Output - A string representing the order of characters in the alien language. Constraints - All characters in the words are lowercase English letters. - The words are sorted according to the lexicographical order of the alien language. - There may be multiple valid character orders. Return any one of them. - If the input is invalid such that no valid character order can be derived, return an empty string. Example Given the following input: ```python words = [\\"wrt\\", \\"wrf\\", \\"er\\", \\"ett\\", \\"rftt\\"] ``` The function `alien_order(words)` should return either `\\"wertf\\"` or any other valid ordering respecting the given dictionary. Given the following input: ```python words = [\\"z\\", \\"x\\", \\"z\\"] ``` The function `alien_order(words)` should return `\\"\\"` indicating no valid ordering. Explanation 1. In the first example, based on the dictionary: - From \\"wrt\\" and \\"wrf\\", we can infer that \'t\' comes before \'f\'. - From \\"wrf\\" and \\"er\\", we can infer that \'w\' comes before \'e\'. - From \\"er\\" and \\"ett\\", we can infer that \'r\' comes before \'t\'. - From \\"ett\\" and \\"rftt\\", we can infer that \'e\' comes before \'r\'. Thus, one correct character order is \\"wertf\\". 2. In the second example, the input is invalid because \\"z\\" comes before \\"x\\" and then \\"x\\" should come before \\"z\\", which is a contradiction, hence an empty string is returned. Implementation Provide a complete implementation of the function that processes the list of words and calculates the character order efficiently using graph-based algorithms and topological sorting.","solution":"from typing import List from collections import defaultdict, deque def alien_order(words: List[str]) -> str: # Step 1: Create a graph and a dictionary to count in-degrees of each node graph = defaultdict(set) in_degree = {char: 0 for word in words for char in word} # Step 2: Build the graph by comparing adjacent words for i in range(len(words) - 1): first_word, second_word = words[i], words[i + 1] min_length = min(len(first_word), len(second_word)) # Check if it\'s an invalid case where prefix is longer and equal to the next word if len(first_word) > len(second_word) and first_word.startswith(second_word): return \\"\\" for j in range(min_length): if first_word[j] != second_word[j]: if second_word[j] not in graph[first_word[j]]: graph[first_word[j]].add(second_word[j]) in_degree[second_word[j]] += 1 break # Step 3: Perform topological sort using Kahn\'s algorithm queue = deque([char for char in in_degree if in_degree[char] == 0]) order = [] while queue: current_char = queue.popleft() order.append(current_char) for neighbor in graph[current_char]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) # If the order contains all the characters, return it, otherwise return \\"\\" if len(order) == len(in_degree): return \\"\\".join(order) else: return \\"\\""},{"question":"# Coding Assessment Question Context: Sorting and rearranging arrays are common tasks in programming. One interesting challenge is to reorder an array such that all occurrences of “0” are moved to the end while maintaining the relative order of the other elements. Problem: Given an array of integers, implement a function `move_zeros` that moves all zeroes to the end of the given array while maintaining the relative order of non-zero elements. Function Signature: ```python def move_zeros(arr: List[int]) -> List[int]: pass ``` Input: - `arr`: A list of integers that can contain both positive and negative values. Output: - A list of integers with all zeroes moved to the end, while the relative order of non-zero elements is preserved. Constraints: - Do not create a new array. Modify the input array in-place. - The length of the array will be between 1 and 10^4 inclusive. - The elements in the array will be between -10^8 and 10^8 inclusive. Example: ```python arr = [0, 1, 0, 3, 12] move_zeros(arr) # Output: [1, 3, 12, 0, 0] arr = [1, 2, 3, 4, 0, 0, 0] move_zeros(arr) # Output: [1, 2, 3, 4, 0, 0, 0] arr = [4, 2, 4, 3, 5, 0, 0, 1, 0] move_zeros(arr) # Output: [4, 2, 4, 3, 5, 1, 0, 0, 0] ``` Instructions: 1. Implement the `move_zeros` function to move all zeroes to the end of the array. 2. Preserve the relative order of the non-zero elements. 3. Modify the original list in-place without creating a new list. 4. Ensure your solution is efficient given the constraints.","solution":"def move_zeros(arr): Moves all zeros to the end of the list while maintaining the relative order of non-zero elements. zero_position = 0 # Pointer to place the next non-zero element for i in range(len(arr)): if arr[i] != 0: arr[zero_position] = arr[i] if zero_position != i: arr[i] = 0 zero_position += 1 return arr"},{"question":"# Balanced Binary Tree Validation Context As a software engineer, you are responsible for ensuring efficient data storage and retrieval. Balanced binary trees (e.g., AVL trees, Red-Black trees) are crucial in database indexing, competitive programming, and various real-time applications because they maintain O(log n) time complexity for insertion, deletion, and search operations. Task Your task is to implement a function that checks whether a given binary tree is balanced. A balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differs by more than one. Requirements 1. **Function Prototype**: Implement the function `is_balanced(root: Optional[TreeNode]) -> bool`. 2. **Input and Output**: - **Input**: - `root` (TreeNode): The root node of the binary tree, where a `TreeNode` is defined as: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` - **Output**: `True` if the tree is balanced; `False` otherwise. 3. **Constraints**: - The number of nodes in the tree is in the range [0, 104]. - The input will always be a TreeNode or None (representing an empty tree). Expectations - Use an efficient algorithm to determine if the tree is balanced, ideally O(n) time complexity. - Handle edge cases such as empty trees and single-node trees. - Clearly documented code for readability. Implementation Example Here is a template to get you started: ```python def is_balanced(root: Optional[TreeNode]) -> bool: def check_balance(node: Optional[TreeNode]) -> (bool, int): if not node: return True, 0 left_balanced, left_height = check_balance(node.left) right_balanced, right_height = check_balance(node.right) is_balanced = (left_balanced and right_balanced and abs(left_height - right_height) <= 1) return is_balanced, max(left_height, right_height) + 1 balanced, _ = check_balance(root) return balanced ``` Ensure the function correctly identifies balanced and unbalanced trees through comprehensive testing, taking into account the nuances of binary tree structures.","solution":"from typing import Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_balanced(root: Optional[TreeNode]) -> bool: def check_balance(node: Optional[TreeNode]) -> (bool, int): if not node: return True, 0 left_balanced, left_height = check_balance(node.left) right_balanced, right_height = check_balance(node.right) balanced = (left_balanced and right_balanced and abs(left_height - right_height) <= 1) return balanced, max(left_height, right_height) + 1 balanced, _ = check_balance(root) return balanced"},{"question":"# Coding Question: Valid Triangle Check **Objective:** Implement a function that determines if three given side lengths can form a valid triangle using the triangle inequality theorem. Problem Statement: You need to write a function `is_valid_triangle(side1: float, side2: float, side3: float) -> bool` that takes the lengths of three sides of a potential triangle and returns `True` if they form a valid triangle and `False` otherwise. Function Signature: ```python def is_valid_triangle(side1: float, side2: float, side3: float) -> bool: pass ``` Input: - Three parameters (side1, side2, side3), each of type `float`. Output: - A `bool`: `True` if the sides form a valid triangle, `False` otherwise. Constraints: - Each side length must be a positive number. Error Handling: - Raise a `ValueError` if any side length is not positive. Triangle Inequality Theorem: - The sum of the lengths of any two sides must be greater than the length of the remaining side: 1. `side1 + side2 > side3` 2. `side1 + side3 > side2` 3. `side2 + side3 > side1` Example: ```python # Example usage: result = is_valid_triangle(side1=3, side2=4, side3=5) # Expected output: True print(result) result = is_valid_triangle(side1=1, side2=1, side3=2) # Expected output: False print(result) result = is_valid_triangle(side1=0, side2=4, side3=5) # Expected output: ValueError: Side lengths must be positive. ``` Implement the `is_valid_triangle` function in Python and ensure it effectively verifies triangle validity according to the triangle inequality theorem.","solution":"def is_valid_triangle(side1: float, side2: float, side3: float) -> bool: Determines if three given side lengths can form a valid triangle. Parameters: side1 (float): The length of the first side. side2 (float): The length of the second side. side3 (float): The length of the third side. Returns: bool: True if the sides form a valid triangle, False otherwise. Raises: ValueError: If any of the side lengths is not positive. # Check if all sides are positive if side1 <= 0 or side2 <= 0 or side3 <= 0: raise ValueError(\\"Side lengths must be positive.\\") # Apply the triangle inequality theorem if (side1 + side2 > side3) and (side1 + side3 > side2) and (side2 + side3 > side1): return True else: return False"},{"question":"# Scenario You are creating a feature that allows users to create and manage their to-do lists. Each to-do list can contain multiple tasks, and tasks can be marked as completed. The to-do lists are saved in a JSON file, and the application must be able to add, remove, update, and list tasks within the to-do lists. # Task Write a Python class `TodoList` that implements the following functionalities: 1. `add_task(list_name, task_description)`: Adds a new task to the specified to-do list. 2. `remove_task(list_name, task_description)`: Removes the specified task from the specified to-do list. 3. `mark_completed(list_name, task_description)`: Marks the specified task as completed in the specified to-do list. 4. `get_tasks(list_name)`: Returns a list of tasks (with their completion status) for the specified to-do list. Additionally, write test code using the `unittest` framework to: 1. Test the addition of tasks to a to-do list. 2. Test the removal of tasks from a to-do list. 3. Test marking tasks as completed. 4. Test retrieving tasks from a to-do list. # Requirements 1. Implement the `TodoList` class with the outlined methods. 2. Implement a test class `TestTodoList` using the `unittest` framework to cover all specified methods. # Input & Output - **Input**: Method calls with appropriate arguments. - **Output**: The methods modify the internal state of the `TodoList` object and should return current task states as needed. # Constraints - Use a JSON format to store and manage to-do lists. - Ensure tasks within a list have unique descriptions. - Handle edge cases such as operations on non-existent lists or tasks gracefully. - Validate that methods handle new, empty, and populated to-do lists accurately. # Example ```python # Example usage of the TodoList class todo_list = TodoList() todo_list.add_task(\\"Daily Tasks\\", \\"Buy groceries\\") todo_list.add_task(\\"Daily Tasks\\", \\"Write code\\") todo_list.mark_completed(\\"Daily Tasks\\", \\"Buy groceries\\") tasks = todo_list.get_tasks(\\"Daily Tasks\\") print(tasks) # Expected output: [{\\"task\\": \\"Buy groceries\\", \\"completed\\": True}, {\\"task\\": \\"Write code\\", \\"completed\\": False}] ```","solution":"import json from collections import defaultdict class TodoList: def __init__(self): self.todo_lists = defaultdict(list) def add_task(self, list_name, task_description): # Check if task already exists in the list for task in self.todo_lists[list_name]: if task[\'task\'] == task_description: return # Task already exists, do nothing self.todo_lists[list_name].append({\\"task\\": task_description, \\"completed\\": False}) def remove_task(self, list_name, task_description): self.todo_lists[list_name] = [task for task in self.todo_lists[list_name] if task[\'task\'] != task_description] def mark_completed(self, list_name, task_description): for task in self.todo_lists[list_name]: if task[\'task\'] == task_description: task[\'completed\'] = True def get_tasks(self, list_name): return self.todo_lists[list_name]"},{"question":"# Question: Given a string of lowercase alphabets, write a function to return a dictionary where the keys are characters and the values are their respective frequencies in the string. Your solution should implement a function `char_frequency` in Python that processes the string efficiently. # Requirements: * The function signature should be: ```python def char_frequency(s: str) -> dict[str, int]: ``` * The function should return a dictionary mapping each character to its frequency count. * Raise a `ValueError` if the input string contains any characters that are not lowercase alphabets. * Optimize your implementation to handle long strings efficiently. * You may not use any in-built Python functions for counting (e.g., `str.count`). # Constraints: * The input string will have at most `10^6` characters. * Each character in the input string will be a lowercase alphabet (\'a\' to \'z\'). # Performance Requirements: * The function should have a time complexity of O(n), where n is the length of the input string. * Space complexity should be O(1), considering the fixed alphabet size (26 lowercase letters). # Example: ```python assert char_frequency(\\"aabc\\") == {\'a\': 2, \'b\': 1, \'c\': 1} assert char_frequency(\\"zzxyzz\\") == {\'z\': 4, \'x\': 1, \'y\': 1} try: char_frequency(\\"hello1world\\") except ValueError as e: print(e) # Expected output: Input string must only contain lowercase alphabets ```","solution":"def char_frequency(s: str) -> dict[str, int]: Returns a dictionary where the keys are characters and the values are their respective frequencies in the string. Raises a ValueError if the input string contains characters that are not lowercase alphabets. if any(char < \'a\' or char > \'z\' for char in s): raise ValueError(\\"Input string must only contain lowercase alphabets\\") frequency_dict = {} for char in s: if char in frequency_dict: frequency_dict[char] += 1 else: frequency_dict[char] = 1 return frequency_dict"},{"question":"# Coding Assessment Question Problem Statement You are given a utility function that processes a list of transactions, each containing a `date`, `amount`, and `type` (either \\"debit\\" or \\"credit\\"). Your task is to implement a function that calculates the daily balance of an account, given an initial balance and a list of transactions. The daily balance should be computed for each date present in the transactions and should reflect the sum of credits minus debits sequentially. Function to Implement ```python def calculate_daily_balance(initial_balance: float, transactions: List[Dict[str, Any]]) -> Dict[str, float]: Calculate the daily balance from a list of transactions. Parameters: - initial_balance (float): The starting balance of the account. - transactions (List[Dict[str, Any]]): A list of transactions where each transaction is a dictionary with keys \'date\', \'amount\', and \'type\'. Returns: - Dict[str, float]: A dictionary with dates as keys and the corresponding account balance as values. pass ``` Expectations 1. **Functionality**: - Your function should process the transactions in chronological order (sort by `date` if not already sorted). - For each date present in the transactions, compute the balance at the end of that day. - The balance for each subsequent day should include the balance from the previous day. 2. **Input/Output**: - The function takes two parameters: `initial_balance` (float) and `transactions` (List[Dict[str, Any]]) where each transaction contains: - `date` (str): The transaction date in \\"YYYY-MM-DD\\" format - `amount` (float): The amount of the transaction - `type` (str): Either \\"debit\\" or \\"credit\\" - It returns a dictionary where keys are dates (str) and values are the balances (float) calculated for those dates. 3. **Constraints**: - Transactions are all within a valid date range and have valid types (\\"debit\\" or \\"credit\\"). - Consider edge cases like multiple transactions on the same date. - Ensure correct handling of floating-point arithmetic to avoid precision issues. Example Usage ```python # Example usage when calling your function transactions = [ {\\"date\\": \\"2023-10-01\\", \\"amount\\": 100.0, \\"type\\": \\"credit\\"}, {\\"date\\": \\"2023-10-02\\", \\"amount\\": 50.0, \\"type\\": \\"debit\\"}, {\\"date\\": \\"2023-10-02\\", \\"amount\\": 150.0, \\"type\\": \\"credit\\"}, {\\"date\\": \\"2023-10-03\\", \\"amount\\": 200.0, \\"type\\": \\"debit\\"}, ] initial_balance = 1000.0 daily_balances = calculate_daily_balance(initial_balance, transactions) # Expected output: # { # \\"2023-10-01\\": 1100.0, # \\"2023-10-02\\": 1200.0, # \\"2023-10-03\\": 1000.0 # } ``` Integrate this question, considering it aligns with the existing questions\' style, length, difficulty level, and scope.","solution":"from typing import List, Dict, Any def calculate_daily_balance(initial_balance: float, transactions: List[Dict[str, Any]]) -> Dict[str, float]: Calculate the daily balance from a list of transactions. Parameters: - initial_balance (float): The starting balance of the account. - transactions (List[Dict[str, Any]]): A list of transactions where each transaction is a dictionary with keys \'date\', \'amount\', and \'type\'. Returns: - Dict[str, float]: A dictionary with dates as keys and the corresponding account balance as values. # Sort transactions by date transactions.sort(key=lambda x: x[\'date\']) # Initialize a dictionary to store daily balances daily_balances = {} current_balance = initial_balance for transaction in transactions: date = transaction[\'date\'] amount = transaction[\'amount\'] trans_type = transaction[\'type\'] # Calculate the new balance based on transaction type if trans_type == \'credit\': current_balance += amount elif trans_type == \'debit\': current_balance -= amount # Update the balance for the date daily_balances[date] = current_balance return daily_balances"},{"question":"# Maximum Sum Subarray with One Deletion You are given an integer array `nums`. Write a function `maximum_sum_subarray_with_deletion(nums: list[int]) -> int` that returns the maximum possible sum of a subarray that can be achieved by deleting at most one element. Input: - `nums`: A list of integers (1 ≤ len(nums) ≤ 10^5, -10^6 ≤ nums[i] ≤ 10^6) Output: - An integer representing the maximum sum of a subarray after deleting at most one element. Constraints: - You must achieve a time complexity of O(n) and a space complexity of O(n). Example: ```python >>> maximum_sum_subarray_with_deletion([1, -2, 0, 3]) 4 >>> maximum_sum_subarray_with_deletion([1, -2, -2, 3]) 3 >>> maximum_sum_subarray_with_deletion([-1, -1, -1, -1]) -1 ``` Context: In various fields such as finance and engineering, optimizing the value of sequences by allowing the omission of a single outlier can be crucial for more accurate analysis. Detecting the maximum possible sum of a subarray after deleting one element can help improve the robustness and accuracy of insights derived from the data. Your task is to efficiently compute this maximum sum given the constraints.","solution":"def maximum_sum_subarray_with_deletion(nums): Returns the maximum possible sum of a subarray that can be achieved by deleting at most one element. n = len(nums) if n == 1: return nums[0] # Initialize arrays to store the maximum sum subarray ending at each index max_ending_here = nums[0] max_ending_here_with_deletion = 0 max_sum = nums[0] for i in range(1, n): max_ending_here_with_deletion = max(max_ending_here, max_ending_here_with_deletion + nums[i]) max_ending_here = max(nums[i], max_ending_here + nums[i]) max_sum = max(max_sum, max_ending_here, max_ending_here_with_deletion) return max_sum"},{"question":"# Coding Challenge: Sum of Nested Lists **Objective**: Write a function that calculates the sum of all integer elements in a potentially nested list structure. The list can contain integers and/or other lists of integers to any depth. Function Signature ```python def sum_nested_list(nested_list: List[Any]) -> int: pass ``` Input - `nested_list` (list): A potentially nested list of integers. Output - `int`: The sum of all integer elements in the nested list. Constraints - The depth of nesting does not exceed 10 levels. - The list can contain up to 10^3 integers distributed across all nested levels. Examples ```python assert sum_nested_list([1, 2, 3, [4, 5], [6, [7, 8]]]) == 36 assert sum_nested_list([1, [2, [3, [4, [5]]]]]) == 15 assert sum_nested_list([[[[[10], 20], 30], 40], 50]) == 150 assert sum_nested_list([1, [2, [3, [4, [5, [6, [7, [8, [9, [10]]]]]]]]]]) == 55 assert sum_nested_list([]) == 0 ``` # Implementation Notes 1. Initialize a variable to store the sum of integers. 2. Define a helper function that processes each element of the list. If the element is an integer, add it to the sum. If it is a list, call the helper function recursively on that list. 3. Ensure to handle all levels of nested lists until all elements are processed. 4. Return the final sum after processing all elements. Good luck!","solution":"from typing import List, Any def sum_nested_list(nested_list: List[Any]) -> int: Calculate the sum of all integer elements in a potentially nested list. Args: nested_list (List[Any]): A potentially nested list of integers. Returns: int: The sum of all integer elements in the nested list. def helper(lst): total = 0 for elem in lst: if isinstance(elem, list): total += helper(elem) elif isinstance(elem, int): total += elem return total return helper(nested_list)"},{"question":"# Coding Assessment Question # Objective Your task is to implement a function that identifies all the prime numbers in a given range using the Sieve of Eratosthenes algorithm. This problem assesses your ability to work with algorithms related to prime number identification efficiently and handle the nuances of range-based computation. # Problem Statement Implement the function `sieve_of_eratosthenes(n: int) -> List[int]`. The function should return a list of all prime numbers less than or equal to `n` using the Sieve of Eratosthenes algorithm. # Function Signature ```python def sieve_of_eratosthenes(n: int) -> List[int]: ``` # Input - `n`: An integer (0 leq n leq 10^6). This value sets the upper bound of the range in which you need to find all prime numbers. # Output - Return a list of integers representing all prime numbers less than or equal to `n`, in ascending order. # Examples ```python assert sieve_of_eratosthenes(10) == [2, 3, 5, 7] assert sieve_of_eratosthenes(20) == [2, 3, 5, 7, 11, 13, 17, 19] assert sieve_of_eratosthenes(1) == [] ``` # Constraints - You must use the Sieve of Eratosthenes algorithm to solve this problem. - Your solution should efficiently handle the upper constraint of ( n = 10^6 ). # Note The Sieve of Eratosthenes algorithm is well-suited to finding all prime numbers up to a specified limit and is efficient in both time and space complexity for this problem\'s constraints.","solution":"from typing import List def sieve_of_eratosthenes(n: int) -> List[int]: if n < 2: return [] sieve = [True] * (n + 1) sieve[0], sieve[1] = False, False # 0 and 1 are not prime numbers for start in range(2, int(n**0.5) + 1): if sieve[start]: for multiple in range(start*start, n + 1, start): sieve[multiple] = False return [num for num, is_prime in enumerate(sieve) if is_prime]"},{"question":"# Scenario A startup tech company is developing an application that generates unique identifiers for their users. The identifiers must be composed of alphanumeric characters and must ensure a certain level of uniqueness by alternating between digits and letters in specific patterns. They need you to write a function that generates these unique user identifiers based on their specification. # Task Implement a function `generate_identifier(seed: str, length: int) -> str` that creates a unique identifier using a given seed and specified length. # Input - `seed`: A string containing alphanumeric characters (1 ≤ len(seed) ≤ 100), which serves as the base pattern for generating the identifier. - `length`: An integer (1 ≤ length ≤ 50), representing the desired length of the unique identifier. # Output - A string representing the generated unique identifier of the specified length. # Constraints and Notes - The identifier should strictly alternate between digits and letters. The seed will provide the initial pattern. - If the seed pattern is shorter than the required length, it should be repeated cyclically. - If the seed pattern leaves the identifier ending in the middle of a letter-digit alternation, the function should continue the pattern correctly from the beginning of the seed. - The order of characters in the seed must be preserved in the generated identifier. # Example ```python >>> generate_identifier(\'a1b2\', 10) \'a1b2a1b2a1\' >>> generate_identifier(\'x9\', 6) \'x9x9x9\' >>> generate_identifier(\'3g\', 5) \'3g3g3\' ``` # Performance Requirements - The function should execute efficiently within the given constraints. - Optimize for performance to handle the maximum input sizes smoothly. # Additional Notes - Carefully handle edge cases, such as very short seed patterns or minimum length values. - Validate your function with multiple test cases to ensure correctness and efficiency.","solution":"def generate_identifier(seed: str, length: int) -> str: Generate a unique identifier of specified length based on the given seed. Args: seed (str): The seed string containing alphanumeric characters. length (int): The desired length of the identifier. Returns: str: The generated unique identifier. identifier = [] seed_length = len(seed) seed_index = 0 for i in range(length): identifier.append(seed[seed_index]) seed_index = (seed_index + 1) % seed_length return \'\'.join(identifier)"},{"question":"# Coding Assessment Question Context You have a function `apply_filter` that applies a given filter function to a list of integers to remove specific elements based on certain conditions. Task Write a function `filter_and_sort(numbers: list[int], filter_fn: callable) -> list[int]` that: 1. Filters the given list of numbers using the provided `filter_fn` function. 2. Sorts the filtered list in ascending order. The provided `filter_fn` should return `True` for elements that should be kept in the list and `False` for elements that should be removed. Input - `numbers`: List of integers to be filtered and sorted. - `filter_fn`: A function that takes a single integer as an argument and returns a boolean. Output - A list of integers that have been filtered and sorted. Constraints - The length of `numbers` will be at most `10^5`. - The integers in `numbers` will be within the range of `-10^6` to `10^6`. - Assume `filter_fn` is a well-defined function that will produce correct results. Performance Requirements - Ensure the function completes within a reasonable time frame for up to `10^5` integers. Example ```python numbers = [10, -1, 4, 7, 6, -3, 2, 8] filter_fn = lambda x: x > 0 result = filter_and_sort(numbers, filter_fn) print(result) # Expected output: [2, 4, 6, 7, 8, 10] ```","solution":"def filter_and_sort(numbers, filter_fn): Filters the given list of numbers using the provided filter function, then sorts the filtered list in ascending order. :param numbers: List of integers to be filtered and sorted :param filter_fn: A function that takes a single integer as an argument and returns a boolean :return: A sorted list of integers that have been filtered filtered_numbers = filter(filter_fn, numbers) return sorted(filtered_numbers)"},{"question":"# Array Rotation Check Given two integer arrays, determine if one of the arrays is a rotation of the other. An array rotation involves moving some elements from the beginning of the array to the end without changing their order. For instance, the array `[1, 2, 3, 4, 5]` can be rotated to `[3, 4, 5, 1, 2]`. Task Write a function `is_rotation(a: List[int], b: List[int]) -> bool` which: - Accepts two lists of integers `a` and `b`. - Returns `True` if `b` is a rotation of `a`, otherwise `False`. Input & Output - **Input**: Two lists of integers `a` and `b` of the same length. - **Output**: A boolean value representing whether `b` is a rotation of `a`. Example ```python is_rotation([1, 2, 3, 4, 5], [3, 4, 5, 1, 2]) ``` Output: ```plaintext True ``` Explanation: - The array `[3, 4, 5, 1, 2]` is a rotation of `[1, 2, 3, 4, 5]`. ```python is_rotation([1, 2, 3, 4, 5], [2, 3, 4, 5, 1]) ``` Output: ```plaintext True ``` Explanation: - The array `[2, 3, 4, 5, 1]` is a rotation of `[1, 2, 3, 4, 5]`. ```python is_rotation([1, 2, 3, 4, 5], [4, 5, 3, 2, 1]) ``` Output: ```plaintext False ``` Explanation: - The array `[4, 5, 3, 2, 1]` is not a rotation of `[1, 2, 3, 4, 5]`. Constraints - Arrays `a` and `b` will be non-empty and contain only integers. - Arrays `a` and `b` will have the same length. Notes - Consider utilizing string manipulation or array slicing to simplify the rotation logic. - Ensure the solution is efficient and handles cases where the arrays are large.","solution":"def is_rotation(a, b): Checks if array b is a rotation of array a. if len(a) != len(b): return False # Convert both lists into strings a_str = \',\'.join(map(str, a)) b_str = \',\'.join(map(str, b)) # Check if b_str is a substring of a_str + a_str (which simulates all possible rotations) return b_str in a_str + \',\' + a_str"},{"question":"# Scenario You are developing a software module for a library management system. One of the features required is a function that calculates the overdue fine for a borrowed book based on the number of days it is overdue. # Function Details Implement a function `calculate_fine` that takes the following parameters: - `days_overdue` (int): The number of days the book is overdue. - `daily_fine` (float): The fine charged per day the book is overdue. - `max_fine` (float): The maximum fine that can be charged for a borrowed book. The function should compute the total fine based on the following rules: - If `days_overdue` is less than or equal to zero, no fine should be charged (i.e., return 0.0). - The fine is calculated as the product of `days_overdue` and `daily_fine`. - If the calculated fine exceeds `max_fine`, the function should return `max_fine`. # Requirements - The function should raise a `ValueError` if `days_overdue` is negative. - The result should be rounded to two decimal places. # Input and Output - **Input**: - `days_overdue` (int): Number of days the book is overdue. - `daily_fine` (float): Daily fine rate. - `max_fine` (float): Maximum allowable fine. - **Output**: - Return the calculated fine as a float rounded to two decimal places. # Constraints - `0 ≤ days_overdue ≤ 365` (Overdue duration cannot exceed one year) - `0.1 ≤ daily_fine ≤ 100` (Daily fine rate should be within reasonable limits) - `1 ≤ max_fine ≤ 10000` (Maximum fine must be within a set range) # Example ```python # Example of a function call fine = calculate_fine(5, 0.25, 10) print(fine) # Expected output: 1.25 fine = calculate_fine(50, 1.5, 50) print(fine) # Expected output: 50.0 fine = calculate_fine(0, 5, 50) print(fine) # Expected output: 0.0 fine = calculate_fine(400, 0.5, 200) print(fine) # Expected output: 200.0 ``` # Notes Handle edge cases such as when `days_overdue` is zero or negative, ensuring appropriate error management and validation logic. The function should efficiently compute the fine without unnecessary operations.","solution":"def calculate_fine(days_overdue, daily_fine, max_fine): Calculate the fine for overdue books. Parameters: days_overdue (int): Number of days the book is overdue. daily_fine (float): Fine charged per day the book is overdue. max_fine (float): Maximum fine that can be charged for a borrowed book. Returns: float: The calculated fine rounded to two decimal places. if days_overdue < 0: raise ValueError(\\"days_overdue cannot be negative\\") if days_overdue == 0: return 0.0 calculated_fine = days_overdue * daily_fine if calculated_fine > max_fine: return round(max_fine, 2) return round(calculated_fine, 2)"},{"question":"# Question: Book Information Extraction and Sorting You are tasked with writing a Python function `get_top_selling_books(book_list: List[str], top_n: int) -> List[str]` that processes a list of book information strings, extracts the details, and returns a list of the top N bestselling books sorted by their sales numbers in descending order. Requirements: 1. **Input Type Validation**: - The function should raise a `ValueError` if the input `book_list` is not a list. - The function should raise a `ValueError` if any element in `book_list` is not a properly formatted string. 2. **Details Extraction**: - Each book detail string is formatted as `\\"Title by Author - Sales: X\\"`, where: - `Title` is the name of the book. - `Author` is the name of the author. - `X` is the number of units sold. - The function should extract the number of units sold and book title from each string. 3. **Sorting and Output**: - The function should sort the extracted book details by the number of units sold in descending order. - If two books have the same number of units sold, their order should remain as they appeared in the input list. - The function should return the top N titles based on the sorted order. Function Signature: ```python def get_top_selling_books(book_list: List[str], top_n: int) -> List[str]: ``` Input: - `book_list (List[str])`: A list of strings, each containing book details. - `top_n (int)`: The number of top-selling books to return. Output: - Returns a list of the top N book titles sorted by the number of units sold in descending order. Examples: ```python >>> get_top_selling_books([ \\"The Great Gatsby by F. Scott Fitzgerald - Sales: 5000000\\", \\"Pride and Prejudice by Jane Austen - Sales: 2000000\\", \\"To Kill a Mockingbird by Harper Lee - Sales: 3000000\\", \\"1984 by George Orwell - Sales: 2500000\\", \\"The Catcher in the Rye by J.D. Salinger - Sales: 2750000\\" ], 3) [\\"The Great Gatsby\\", \\"To Kill a Mockingbird\\", \\"The Catcher in the Rye\\"] >>> get_top_selling_books([ \\"Moby Dick by Herman Melville - Sales: 1500000\\", \\"War and Peace by Leo Tolstoy - Sales: 1000000\\", \\"The Odyssey by Homer - Sales: 1250000\\" ], 2) [\\"Moby Dick\\", \\"The Odyssey\\"] >>> get_top_selling_books([ \\"Don Quixote by Miguel de Cervantes - Sales: 5000000\\", \\"Ulysses by James Joyce - Sales: 5000000\\", \\"One Hundred Years of Solitude by Gabriel Garcia Marquez - Sales: 4700000\\" ], 2) [\\"Don Quixote\\", \\"Ulysses\\"] ``` Notes: Ensure your solution efficiently handles the given input constraints and correctly implements the sorting and extraction logic as described.","solution":"from typing import List def get_top_selling_books(book_list: List[str], top_n: int) -> List[str]: if not isinstance(book_list, list): raise ValueError(\\"The book_list must be a list.\\") book_details = [] for book in book_list: if not isinstance(book, str): raise ValueError(\\"Each element in book_list must be a string.\\") parts = book.split(\' - Sales: \') if len(parts) != 2 or not parts[1].isdigit(): raise ValueError(\\"Each book detail string must be properly formatted as \'Title by Author - Sales: X\'.\\") title_and_author = parts[0] sales = int(parts[1]) book_details.append((sales, title_and_author.split(\' by \')[0])) book_details.sort(reverse=True, key=lambda x: x[0]) return [title for _, title in book_details[:top_n]]"},{"question":"# Coding Assessment Question Context A queue is a commonly used data structure that follows the First In, First Out (FIFO) principle. In some applications, it might be useful to track the maximum value in the queue at any time. Task Implement a class `MaxQueue` that supports the following operations: - `enqueue(val: int)`: Add an integer `val` to the end of the queue. - `dequeue() -> int`: Remove and return the integer at the front of the queue. If the queue is empty, raise an `IndexError` with the message `\\"Queue is empty\\"`. - `max_value() -> int`: Return the maximum value in the queue. If the queue is empty, raise an `IndexError` with the message `\\"Queue is empty\\"`. The class should maintain efficient operations, aiming for an average time complexity of O(1) for all methods. Class Signature ```python class MaxQueue: def __init__(self): pass def enqueue(self, val: int): pass def dequeue(self) -> int: pass def max_value(self) -> int: pass ``` Performance Requirements - Average Time Complexity for `enqueue`, `dequeue`, and `max_value`: O(1) - The space complexity of the additional data structures should be O(n), where `n` is the number of elements in the queue. Examples ```python mq = MaxQueue() mq.enqueue(1) mq.enqueue(3) mq.enqueue(2) print(mq.max_value()) # Output: 3 print(mq.dequeue()) # Output: 1 print(mq.max_value()) # Output: 3 mq.enqueue(0) mq.enqueue(5) print(mq.max_value()) # Output: 5 print(mq.dequeue()) # Output: 3 print(mq.max_value()) # Output: 5 print(mq.dequeue()) # Output: 2 print(mq.dequeue()) # Output: 0 print(mq.dequeue()) # Output: 5 ``` Hints - Consider using an additional data structure (like a deque) to keep track of the max values. - Think about how to maintain the additional data structure when elements are enqueued and dequeued. Constraints - The values of the integers are in the range of `[-10^9, 10^9]`. - The total number of operations will not exceed (10^6). Special Cases to Consider - Performing `max_value` on an empty queue. - Performing `dequeue` on an empty queue.","solution":"from collections import deque class MaxQueue: def __init__(self): self.queue = deque() self.max_deque = deque() def enqueue(self, val: int): self.queue.append(val) while self.max_deque and self.max_deque[-1] < val: self.max_deque.pop() self.max_deque.append(val) def dequeue(self) -> int: if not self.queue: raise IndexError(\\"Queue is empty\\") val = self.queue.popleft() if val == self.max_deque[0]: self.max_deque.popleft() return val def max_value(self) -> int: if not self.queue: raise IndexError(\\"Queue is empty\\") return self.max_deque[0]"},{"question":"# Matrix Rotation Validator You are tasked to implement a function that checks if one matrix can be obtained by rotating another matrix by 90-degree increments. This task will evaluate your understanding of matrix manipulation and rotations. Function Definition Write a function `can_obtain_by_rotation` that takes in two matrices and determines if the second matrix can be obtained by rotating the first matrix by 90, 180, or 270 degrees. - **Input**: Two matrices (lists of lists) of integers, where each matrix is guaranteed to be square (i.e., the number of rows is equal to the number of columns). - **Output**: A boolean indicating whether the second matrix can be obtained by rotating the first matrix by 90, 180, or 270 degrees. Expected Function Signature ```python def can_obtain_by_rotation(matrix1: list[list[int]], matrix2: list[list[int]]) -> bool: pass ``` Example Scenarios & Expected Outputs * `can_obtain_by_rotation([[1, 2], [3, 4]], [[3, 1], [4, 2]])` should return `False` * `can_obtain_by_rotation([[1, 2], [3, 4]], [[3, 1], [4, 2]])` should return `True` * `can_obtain_by_rotation([[1, 2, 3], [4, 5, 6], [7, 8, 9]], [[7, 4, 1], [8, 5, 2], [9, 6, 3]])` should return `True` * `can_obtain_by_rotation([[1, 2, 3], [4, 5, 6], [7, 8, 9]], [[9, 8, 7], [6, 5, 4], [3, 2, 1]])` should return `False` # Constraints & Conditions - Ensure the function handles edge cases where matrices might be small (e.g., 1x1). - The function should check rotations at 90, 180, and 270 degrees. - The input matrices are guaranteed to be non-empty and square. - Your solution should not rely on any external libraries for matrix operations. Implement this function and ensure you provide comprehensive test cases to validate its correctness. Handle all boundary cases and discuss the efficiency of your solution.","solution":"def rotate_90(matrix): Rotates the matrix by 90 degrees clockwise. n = len(matrix) return [[matrix[n - j - 1][i] for j in range(n)] for i in range(n)] def can_obtain_by_rotation(matrix1, matrix2): Checks if matrix2 can be obtained by rotating matrix1 by 90, 180, or 270 degrees. if matrix1 == matrix2: return True rotated_90 = rotate_90(matrix1) if rotated_90 == matrix2: return True rotated_180 = rotate_90(rotated_90) if rotated_180 == matrix2: return True rotated_270 = rotate_90(rotated_180) if rotated_270 == matrix2: return True return False"},{"question":"# Coding Assessment Question You are tasked with implementing a function to find the longest common prefix among a list of strings using a trie data structure. **Function Signature**: ```python def longest_common_prefix(strings: list[str]) -> str: ``` **Input**: - `strings`: A list of strings (1 ≤ |strings| ≤ 200, 1 ≤ |strings[i]| ≤ 200) containing only lowercase English letters. **Output**: - A string representing the longest common prefix shared among all strings in the list. **Constraints**: - If there is no common prefix, return an empty string `\\"\\"`. - The input list is non-empty and contains only lowercase English letters. **Examples**: 1. `longest_common_prefix([\'flower\', \'flow\', \'flight\'])` should return `\'fl\'`. 2. `longest_common_prefix([\'dog\', \'racecar\', \'car\'])` should return `\'\'`. 3. `longest_common_prefix([\'interspecies\', \'interstellar\', \'interstate\'])` should return `\'inters\'`. **Edge Cases**: 1. If the input list contains only a single string, the longest common prefix is the string itself. 2. If the strings have no common prefix, the function should return an empty string. 3. If all strings are identical, the longest common prefix is the string itself. # Testing: 1. Write tests to check if your function correctly identifies the longest common prefix using various examples. 2. Ensure your function handles edge cases such as a single string in the list or strings with no common prefix. 3. Verify the function\'s efficiency for large inputs. **Tasks**: 1. Write the function `longest_common_prefix` based on the provided signature. 2. Implement the trie data structure to facilitate the prefix finding process. 3. Ensure your function is correct and handles edge cases properly.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word): node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end = True def longest_common_prefix(self): prefix = [] node = self.root while len(node.children) == 1 and not node.is_end: char, next_node = next(iter(node.children.items())) prefix.append(char) node = next_node return \'\'.join(prefix) def longest_common_prefix(strings): if not strings: return \\"\\" trie = Trie() for string in strings: trie.insert(string) return trie.longest_common_prefix()"},{"question":"# Task You are developing a custom data processing library and want to implement a function that performs a rolling window computation on a 1-dimensional numpy array. The rolling window function computes the sum of elements within a specified window size as it slides over the array. # Requirements 1. Implement the `rolling_window_sum` function. 2. Optimize for performance using numpy. 3. Consider edge cases such as window size greater than the array length or non-positive window sizes. 4. Provide appropriate error handling for invalid inputs. # Function Signature ```python def rolling_window_sum(array: np.ndarray, window_size: int) -> np.ndarray: Applies a rolling window sum to the input array. Parameters: array (np.ndarray): The input array for the rolling window sum computation. window_size (int): The size of the window to compute the sum. Returns: np.ndarray: An array of the sums computed by the rolling window. Examples: >>> rolling_window_sum(np.array([1, 2, 3, 4, 5]), window_size=3) array([ 6, 9, 12]) >>> rolling_window_sum(np.array([1, -1, 1, -1, 1]), window_size=2) array([ 0, 0, 0, 0]) # Your implementation here ``` # Constraints - Ensure `array` is a numpy array before applying the function. Raise a `TypeError` if it isn\'t. - Ensure `window_size` is a positive integer. Raise a `ValueError` for non-positive or zero values. - Raise a `ValueError` if the window size is greater than the length of the array. - Do not use loops; leverage numpy\'s vectorized operations for performance. # Testing 1. Verify the implementation with varying sizes of input arrays and window sizes. 2. Validate the function with edge cases such as window size equal to array length, and single-element arrays. 3. Include several unit tests to check the correctness of the function.","solution":"import numpy as np def rolling_window_sum(array: np.ndarray, window_size: int) -> np.ndarray: if not isinstance(array, np.ndarray): raise TypeError(\\"Input must be a numpy array\\") if not isinstance(window_size, int) or window_size <= 0: raise ValueError(\\"window_size must be a positive integer\\") if window_size > len(array): raise ValueError(\\"window_size cannot be greater than the length of the input array\\") # Compute rolling window sum using numpy\'s stride tricks cumsum = np.cumsum(array) result = cumsum[window_size - 1:] - np.concatenate(([0], cumsum[:-window_size])) return result"},{"question":"# Problem Statement You are given a string `s` consisting of lowercase letters and the character `*`, which can replace any single character. Write a function `string_patterns(s: str) -> List[str]` that returns a list of all possible strings that can be formed by replacing each `*` with any letter from \'a\' to \'z\'. # Function Signature ```python def string_patterns(s: str) -> List[str]: pass ``` # Input * `s`: A string where each character is either a lowercase letter or `*`. - `1 <= len(s) <= 10`. # Output * Returns a list of strings, each representing a valid replacement of the `*` character(s). - The returned list should be sorted in lexicographical order. # Constraints * Each `*` in the input string can be replaced by any letter from \'a\' to \'z\'. * Maintain the order of the characters in the string. # Example ```python s = \\"a*b\\" string_patterns(s) # Output: [ # \'aab\', \'abb\', \'acb\', \'adb\', \'aeb\', \'afb\', # \'agb\', \'ahb\', \'aib\', \'ajb\', \'akb\', \'alb\', # \'amb\', \'anb\', \'aob\', \'apb\', \'aqb\', \'arb\', # \'asb\', \'atb\', \'aub\', \'avb\', \'awb\', \'axb\', # \'ayb\', \'azb\' # ] s = \\"**\\" string_patterns(s) # Output: [ # \'aa\', \'ab\', \'ac\', \'ad\', \'ae\', \'af\', \'ag\', \'ah\', \'ai\', # \'aj\', \'ak\', \'al\', \'am\', \'an\', \'ao\', \'ap\', \'aq\', \'ar\', # \'as\', \'at\', \'au\', \'av\', \'aw\', \'ax\', \'ay\', \'az\', \'ba\', # \'bb\', \'bc\', \'bd\', \'be\', \'bf\', \'bg\', \'bh\', \'bi\', \'bj\', # \'bk\', \'bl\', \'bm\', \'bn\', \'bo\', \'bp\', \'bq\', \'br\', \'bs\', # \'bt\', \'bu\', \'bv\', \'bw\', \'bx\', \'by\', \'bz\', \'ca\', \'cb\', # \'cc\', \'cd\', \'ce\', \'cf\', \'cg\', \'ch\', \'ci\', \'cj\', \'ck\', # \'cl\', \'cm\', \'cn\', \'co\', \'cp\', \'cq\', \'cr\', \'cs\', \'ct\', # \'cu\', \'cv\', \'cw\', \'cx\', \'cy\', \'cz\', ..., \'zy\', \'zz\' # ] ``` # Additional Notes * Think about using backtracking or iterative methods to generate all possible combinations. * Make sure to handle edge cases where the string may contain no `*` or is entirely composed of `*`.","solution":"from typing import List def string_patterns(s: str) -> List[str]: def backtrack(idx, path): if idx == len(s): result.append(\\"\\".join(path)) return if s[idx] == \'*\': for char in \'abcdefghijklmnopqrstuvwxyz\': path.append(char) backtrack(idx + 1, path) path.pop() else: path.append(s[idx]) backtrack(idx + 1, path) path.pop() result = [] backtrack(0, []) return sorted(result)"},{"question":"# Coding Question Context A popular way to measure the effectiveness of a programming course is to track the quiz scores of the students. A common task is to compute a student\'s total score after a series of quizzes. For this question, you are given a list of quiz scores, where each element in the list represents a quiz score for a particular student. However, some scores might be marked as invalid due to various reasons (for example, cheating, error in quiz submission, etc.), and these invalid scores are represented by a specific value. Task You need to implement the following function: 1. **final_score(scores: List[int], invalid_score: int) -> int**: * Calculate the total score by summing all valid quiz scores in the list. * A quiz score is considered valid if it is not equal to `invalid_score`. Input and Output Formats * `final_score`: * Input: A list of integers `scores` and an integer `invalid_score`. * Output: An integer representing the total valid score. Performance Requirements Ensure that your solution is efficient to handle lists with a length of up to 10^6 elements. Constraints * The length of the `scores` list will be an integer between 1 and 10^6. * Each score in the `scores` list and the `invalid_score` will be integers between -10^6 and 10^6. Example ```python # Test cases assert final_score([100, 95, -999, 86, -999, 90], -999) == 371 assert final_score([10, 20, 30], 0) == 60 assert final_score([-5, -10, -999, -3, -999], -999) == -18 ```","solution":"def final_score(scores, invalid_score): Calculate the total score by summing all valid quiz scores in the list. A score is considered valid if it is not equal to invalid_score. total = 0 for score in scores: if score != invalid_score: total += score return total"},{"question":"# Calculating Fibonacci Numbers Efficiently Problem Statement You are tasked with implementing a function `efficient_fibonacci` that computes the nth Fibonacci number using an optimized approach that reduces time complexity to O(log n). Specifically, use properties of matrix exponentiation to achieve this efficiency. Function Signature ```python def efficient_fibonacci(n: int) -> int: pass ``` Detailed Description - `n` (int): The position in the Fibonacci sequence (0-indexed). Input Constraints - The `n` should be a non-negative integer (0 ≤ n ≤ 10^6). Output - Return an integer representing the nth Fibonacci number. Example Usage Implement the function with the following behavior: ```python >>> efficient_fibonacci(0) 0 >>> efficient_fibonacci(1) 1 >>> efficient_fibonacci(10) 55 >>> efficient_fibonacci(50) 12586269025 >>> efficient_fibonacci(1000) 43466557686937456435688527675040625802564660517371780402481729089536555417949051890403879840079255169295922593080322634775209689623239873322471161642996440906533187938298969649928516003704476137795166849228875 ``` Hints - The nth Fibonacci number can be found using the matrix representation of Fibonacci sequence: [ begin{bmatrix} F(n+1) & F(n) F(n) & F(n-1) end{bmatrix} = begin{bmatrix} 1 & 1 1 & 0 end{bmatrix}^n ] - Use matrix exponentiation by squaring to achieve a logarithmic time complexity. - Consider edge cases such as calculating the 0th and 1st Fibonacci numbers directly. Ensure that your implementation is optimized for large values of `n` and returns correct results within the constraints provided.","solution":"def efficient_fibonacci(n: int) -> int: if n == 0: return 0 elif n == 1: return 1 def matrix_mult(A, B): return [[A[0][0]*B[0][0] + A[0][1]*B[1][0], A[0][0]*B[0][1] + A[0][1]*B[1][1]], [A[1][0]*B[0][0] + A[1][1]*B[1][0], A[1][0]*B[0][1] + A[1][1]*B[1][1]]] def matrix_pow(matrix, power): result = [[1, 0], [0, 1]] # Identity matrix base = matrix while power > 0: if power % 2 == 1: result = matrix_mult(result, base) base = matrix_mult(base, base) power //= 2 return result F = [[1, 1], [1, 0]] result = matrix_pow(F, n - 1) return result[0][0]"},{"question":"# Problem Description You are given a matrix of integers, and your task is to implement a function that calculates the sum of the largest prime number in each row of the matrix. If a row does not have any prime numbers, it should be ignored in the sum. # Function Signature ```python def sum_of_largest_primes(matrix: List[List[int]]) -> int: Calculates the sum of the largest prime number in each row of the matrix. If a row does not contain any prime numbers, it is ignored in the sum. Parameters: - matrix: List[List[int]] The input 2D list representing the matrix of integers. Returns: - int: The sum of the largest prime numbers from each row containing at least one prime number. ``` # Example ```python >>> sum_of_largest_primes([[10, 15, 3], [2, 1, 4], [16, 22, 9]]) 10 >>> sum_of_largest_primes([[10, 20, 30], [10, 11, 13, 14], [16, 23, 7]]) 36 ``` # Requirements 1. Implement a helper function to check if a number is prime. 2. Traverse each row in the matrix and identify the prime numbers within that row. 3. Calculate the largest prime number for each row and add it to the sum. 4. Ignore rows that do not contain any prime numbers. # Constraints - The input matrix can have dimensions up to (1000 times 1000). - The values inside the matrix will be non-negative integers within the range 0 to (10^6).","solution":"from typing import List def is_prime(n: int) -> bool: Helper function to check if a number is prime. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def sum_of_largest_primes(matrix: List[List[int]]) -> int: Calculates the sum of the largest prime number in each row of the matrix. total_sum = 0 for row in matrix: prime_numbers = [num for num in row if is_prime(num)] if prime_numbers: total_sum += max(prime_numbers) return total_sum"},{"question":"# Objective Implement and validate the provided functions to perform advanced text analysis and manipulation on a given input text containing a paragraph. The focus is to ensure both correct implementation and efficient handling of the input text and operations performed on it. # Question You are tasked to implement three functions: `count_words`, `most_frequent_word`, and `replace_words`. These functions perform different operations on a given paragraph of text. `count_words` This function calculates the total number of words in the input text. **Function Signature:** ```python def count_words(text: str) -> int: ``` **Input:** * `text` (str): a string representing a paragraph of text. **Output:** * Returns the total number of words as an integer. `most_frequent_word` This function finds the most frequently occurring word in the input text. If there are multiple words with the same frequency, return the one that comes first lexicographically. **Function Signature:** ```python def most_frequent_word(text: str) -> str: ``` **Input:** * `text` (str): a string representing a paragraph of text. **Output:** * Returns the most frequent word as a string. `replace_words` This function replaces every occurrence of a specific word in the text with another word. **Function Signature:** ```python def replace_words(text: str, target_word: str, replacement_word: str) -> str: ``` **Input:** * `text` (str): a string representing a paragraph of text. * `target_word` (str): the word to be replaced. * `replacement_word` (str): the word to replace with. **Output:** * Returns the updated text with all occurrences of `target_word` replaced by `replacement_word`. # Example ```python # Example function calls and expected results: text = \\"The quick brown fox jumps over the lazy dog. The lazy dog does not mind.\\" print(count_words(text)) # Expected output: 13 print(most_frequent_word(text)) # Expected output: \\"The\\" print(replace_words(text, \\"lazy\\", \\"active\\")) # Expected output: \\"The quick brown fox jumps over the active dog. The active dog does not mind.\\" ``` # Constraints 1. The input text will have at least one word. 2. Words are case-sensitive (e.g., \\"The\\" and \\"the\\" are considered different words). 3. Assume words are separated by spaces and punctuation. 4. Implement efficient solutions with respect to time and space complexity. 5. Ensure robustness in handling edge cases, including varying punctuation and capitalization.","solution":"import re from collections import Counter def count_words(text: str) -> int: Returns the total number of words in the input text. words = re.findall(r\'bw+b\', text) return len(words) def most_frequent_word(text: str) -> str: Finds and returns the most frequent word in the input text. In case of tie, returns the word that comes first lexicographically. words = re.findall(r\'bw+b\', text) word_count = Counter(words) most_frequent = max(sorted(word_count), key=word_count.get) return most_frequent def replace_words(text: str, target_word: str, replacement_word: str) -> str: Replaces every occurrence of target_word in the text with replacement_word. return re.sub(r\'b{}b\'.format(re.escape(target_word)), replacement_word, text)"},{"question":"# Problem Statement You need to implement a function that finds the longest contiguous subsequence in a given list of integers such that every element in this subsequence is in non-decreasing order. Your function should return the length of this subsequence. # Function Signature ```python def longest_non_decreasing_subsequence(sequence: list[int]) -> int: ``` # Input - A list `sequence` of `n` integers where 0 <= n <= 10^5. # Output - An integer representing the length of the longest contiguous non-decreasing subsequence in the input `sequence`. # Examples 1. **Example 1:** ```python longest_non_decreasing_subsequence([1, 3, 2, 3, 4, 1, 2]) ``` **Output:** ```python 3 ``` 2. **Example 2:** ```python longest_non_decreasing_subsequence([7, 7, 7, 7]) ``` **Output:** ```python 4 ``` 3. **Example 3:** ```python longest_non_decreasing_subsequence([5, 1, 2, 3, 4, 5]) ``` **Output:** ```python 5 ``` 4. **Example 4:** ```python longest_non_decreasing_subsequence([]) ``` **Output:** ```python 0 ``` # Constraints - 0 <= n <= 10^5 - Each element of `sequence` is an integer. # Performance Requirements - An efficient O(n) solution is expected to handle the upper constraint on the input size. # Notes - If the input sequence is empty, the function should return 0. - The function should handle possible edge cases such as all elements being the same. - Ensure your solution is optimized to handle large input sizes within the time limits.","solution":"def longest_non_decreasing_subsequence(sequence): if not sequence: # If the sequence is empty return 0 max_length = 1 current_length = 1 for i in range(1, len(sequence)): if sequence[i] >= sequence[i - 1]: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length"},{"question":"# Context You work for a logistics company that needs to optimize delivery routes. The company uses a grid-based map where certain cells are blocked and cannot be traversed. You are tasked with finding the shortest path from the top-left corner of the grid (0,0) to the bottom-right corner (n-1,m-1) while avoiding blocked cells. If it\'s impossible to reach the destination, return -1. # Task Implement a function to find the shortest path in a grid with blocked cells. The path can only be constructed from cells that are free (indicated by `0`). Movement is allowed horizontally and vertically to adjacent cells. # Shortest Path: - Start from the top-left corner (0,0) - End at the bottom-right corner (n-1, m-1) - Return the minimum number of steps required to reach the destination - If the destination is unreachable, return -1 **Function Signature**: ```python def shortest_path(grid: List[List[int]]) -> int: # Write your code here ``` # Input - `grid` (List[List[int]]): A 2D list where `grid[i][j]` is 0 if cell `(i,j)` is free and 1 if it is blocked. # Output - `int`: The minimum number of steps required to reach the destination or -1 if it is unreachable. # Constraints - The grid dimensions will be in the range `[1, 1000] x [1, 1000]`. - Each cell in the grid will be either 0 (free) or 1 (blocked). # Example ```python # Example 1: # Input: # [ # [0, 1, 0, 0, 0], # [0, 1, 0, 1, 0], # [0, 0, 0, 1, 0], # [0, 1, 1, 1, 0], # [0, 0, 0, 0, 0] # ] # Output: 8 # Example 2: # Input: # [ # [0, 1], # [1, 0] # ] # Output: -1 # Example 3: # Input: [[0]] # Output: 0 # Example 4: # Input: [[1]] # Output: -1 ``` Ensure correct handling of edge cases such as the smallest grid, blocked start or end cells, and navigating around strategically placed blockades.","solution":"from typing import List from collections import deque def shortest_path(grid: List[List[int]]) -> int: Finds the shortest path in a grid with blocked cells from (0,0) to (n-1,m-1). Parameters: - grid (List[List[int]]): A 2D list representing the grid. \'0\' indicates a free cell, \'1\' indicates a blocked cell. Returns: - int: The minimum number of steps to reach the destination, or -1 if unreachable. if not grid or grid[0][0] == 1 or grid[-1][-1] == 1: return -1 n, m = len(grid), len(grid[0]) # Directions for moving in the grid (right, down, left, up) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # Queue for BFS (stores tuples of (current_x, current_y, steps)) queue = deque([(0, 0, 0)]) visited = set((0, 0)) while queue: x, y, steps = queue.popleft() # If we reach the bottom-right corner, return the number of steps if (x, y) == (n-1, m-1): return steps # Explore in all directions for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited and grid[nx][ny] == 0: visited.add((nx, ny)) queue.append((nx, ny, steps + 1)) # If the destination is unreachable return -1"},{"question":"# Coding Assessment Question **Objective:** Implement a function to sanitize and merge user-submitted articles into a single document. Problem Statement You are given a dataset of user-submitted articles stored in individual text files. Each article may contain HTML tags, special characters, and certain banned words. Your task is to clean up these articles by removing HTML tags, special characters, and banned words, and then merge all cleaned articles into a single text file. Write a function `clean_and_merge_articles` that takes the following inputs: - `article_dir`: (str) Path to the directory containing article files. - `output_file`: (str) Path to the file where the merged articles should be saved. - `banned_words`: (list) List of banned words that need to be removed from the articles. The function should read all article files from the specified directory, clean each article, merge them into a single document, and save the result to the specified output file. Constraints - Article files are plain text files with a `.txt` extension. - HTML tags are enclosed in `<` and `>` brackets. - Special characters include any non-alphanumeric characters (excluding whitespace). - Banned words must be completely removed from the articles (substrings included). - Ensure the articles are merged in alphabetical order based on their filenames. Expected Input and Output ```python def clean_and_merge_articles( article_dir: str, output_file: str, banned_words: list ) -> None: # your implementation here # Example usage: clean_and_merge_articles(\\"/path/to/articles\\", \\"/path/to/merged_output.txt\\", [\\"bannedword1\\", \\"bannedword2\\"]) ``` * `Input`: * `article_dir`: \\"/path/to/articles\\" * `output_file`: \\"/path/to/merged_output.txt\\" * `banned_words`: [\\"bannedword1\\", \\"bannedword2\\"] * `Output`: A single file containing the merged, cleaned articles. Notes 1. Ensure code readability and provide meaningful comments. 2. Handle any potential exceptions related to file read/write operations. 3. Use efficient string manipulation techniques to handle large articles. 4. Preserve the order of merged articles based on their filenames. Function Signature ```python def clean_and_merge_articles(article_dir: str, output_file: str, banned_words: list) -> None: # your implementation here ``` [End of Question]","solution":"import os import re def clean_html_tags(text): Remove HTML tags from text cleanr = re.compile(\'<.*?>\') return re.sub(cleanr, \'\', text) def clean_special_characters(text): Remove special characters, keeping only alphanumeric and whitespace return re.sub(r\'[^A-Za-z0-9s]\', \'\', text) def remove_banned_words(text, banned_words): Remove banned words from text for word in banned_words: text = re.sub(r\'b\' + re.escape(word) + r\'b\', \'\', text, flags=re.IGNORECASE) return text def clean_and_merge_articles(article_dir, output_file, banned_words): articles = [] # Reading files and cleaning the contents for filename in sorted(os.listdir(article_dir)): if filename.endswith(\'.txt\'): filepath = os.path.join(article_dir, filename) # Read article file with open(filepath, \'r\', encoding=\'utf-8\') as file: content = file.read() # Clean content content = clean_html_tags(content) content = clean_special_characters(content) content = remove_banned_words(content, banned_words) articles.append(content) # Merging cleaned articles into a single file merged_content = \'n\'.join(articles) # Write merged content to the output file with open(output_file, \'w\', encoding=\'utf-8\') as file: file.write(merged_content)"},{"question":"# Problem Statement: You are tasked with developing a function to automate the process of grading students\' answers to a multiple-choice exam. Each question on the exam has exactly one correct answer. # Context: As part of a grading system, you need to compare students\' responses with the correct answers and calculate their scores based on the number of correct answers provided. **Purpose**: Implement a function that calculates the score for a student\'s set of answers given the correct answers. # Task: Write a function `calculate_score(answers: List[str], student_responses: List[str]) -> int` that takes in two arguments: 1. A list of strings `answers` representing the correct answers to the exam questions. 2. A list of strings `student_responses` representing the student\'s responses. The function should return the integer score, which is the count of correct answers given by the student. # Input: - A list of strings `answers` with length `n` (1 <= n <= 1000). - A list of strings `student_responses` with length `n`. # Output: - An integer representing the score of the student\'s responses. # Constraints: - Both lists will contain only uppercase alphabetic characters (\\"A\\", \\"B\\", \\"C\\", \\"D\\"). - The length of the `student_responses` list will always match the length of the `answers` list. # Performance Requirement: - Aim for a solution that iterates through the answers efficiently. # Example: ```python >>> calculate_score([\'A\', \'B\', \'C\', \'D\'], [\'A\', \'C\', \'C\', \'D\']) 3 # Explanation: The student\'s responses are compared to the correct answers. # Correct responses are \'A\', \'C\', and \'D\'. Hence, the score is 3. >>> calculate_score([\'A\', \'B\', \'C\'], [\'B\', \'B\', \'C\']) 2 # Explanation: The student\'s responses are compared to the correct answers. # Correct responses are \'B\' and \'C\'. Hence, the score is 2. ``` **Note**: Ensure your function handles comparisons accurately and efficiently iterates through the lists to count the correct responses. Use list comparison methods where applicable to streamline the process.","solution":"from typing import List def calculate_score(answers: List[str], student_responses: List[str]) -> int: Calculate the score of a student\'s responses based on correct answers. Parameters: answers (List[str]): The correct answers. student_responses (List[str]): The student\'s responses. Returns: int: The score based on the number of correct answers. return sum(1 for a, s in zip(answers, student_responses) if a == s)"},{"question":"# Pathfinding in a Maze **Problem Statement:** As a software engineer in a gaming company, you are asked to implement an algorithm to help a virtual robot navigate a maze. The maze is represented as a 2D grid where `1` indicates a wall and `0` indicates a passable path. The robot can only move up, down, left, and right. Given the starting point and the destination point, your task is to determine if there is a path from start to destination. **Requirements:** 1. Implement a function `has_path` that takes as input a 2D grid (`maze`), the starting point (`start`), and the destination point (`destination`). 2. The function should return a boolean indicating whether there is a path from the start to the destination. **Function Signature:** ```python def has_path(maze: List[List[int]], start: List[int], destination: List[int]) -> bool: ... ``` **Input:** - `maze` : A 2D list of integers (`N x M`), where \'1\' represents walls and \'0\' represents open paths. - `start` : A list of two integers representing the starting point `[row, col]`. - `destination` : A list of two integers representing the destination point `[row, col]`. **Output:** - A boolean indicating whether there is a path from the start to the destination. **Constraints:** - Both the start and destination points are valid positions within the maze. - The dimensions of the maze will not exceed `100 x 100`. **Performance Requirements:** 1. The algorithm should handle the worst-case scenarios efficiently both in terms of time and space. **Example:** ```python maze = [ [0, 1, 0, 0, 0], [0, 1, 0, 1, 0], [0, 0, 0, 1, 0], [0, 1, 0, 1, 0], [0, 0, 0, 0, 0] ] start = [0, 0] destination = [4, 4] result = has_path(maze, start, destination) print(result) # Expected output: True ``` **Note:** - You may use various pathfinding algorithms like Depth-First Search (DFS), Breadth-First Search (BFS), or Dijkstra’s algorithm. - Handling edge cases, such as starting point and destination point being the same, is crucial.","solution":"from collections import deque from typing import List def has_path(maze: List[List[int]], start: List[int], destination: List[int]) -> bool: Determines if there is a path in the maze from start to destination. :param maze: 2D list of integers (0 for paths, 1 for walls) :param start: Starting point [row, col] :param destination: Destination point [row, col] :return: True if there\'s a path from start to destination, False otherwise def valid_move(x, y): return 0 <= x < len(maze) and 0 <= y < len(maze[0]) and maze[x][y] == 0 directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] queue = deque([start]) visited = set() visited.add(tuple(start)) while queue: current = queue.popleft() if current == destination: return True for direction in directions: new_x, new_y = current # Move in the current direction until hitting a wall or the boundary while valid_move(new_x + direction[0], new_y + direction[1]): new_x += direction[0] new_y += direction[1] if (new_x, new_y) not in visited: visited.add((new_x, new_y)) queue.append([new_x, new_y]) return False"},{"question":"# Problem Statement You are given an array of `n` integers where each integer represents the height of a vertical line drawn to the x-axis at that position (1-indexed). Calculate how much water it can trap after raining. # Function Signature ```python def trap_rainwater(heights: list[int]) -> int: pass ``` # Input * `heights`: A list of integers with `0 <= heights[i] <= 10^4` and `1 <= len(heights) <= 10^5`. # Output * Returns an integer representing the total units of water trapped. # Constraints * The input array can contain zeros representing positions with no height. * The solution should run in linear time, O(n). # Example ```python >>> trap_rainwater([0,1,0,2,1,0,1,3,2,1,2,1]) 6 >>> trap_rainwater([4,2,0,3,2,5]) 9 ``` # Explanation In the first example, 6 units of rainwater are trapped between the positions. In the second example, the total trapped rainwater is 9 units. # Additional Information * Ensure your function handles edge cases such as arrays with fewer than three elements where no water can be trapped. * The solution should leverage two-pointer technique or stack-based approach to achieve the linear time complexity.","solution":"def trap_rainwater(heights: list[int]) -> int: Calculate how much water can be trapped after raining given the heights of vertical lines. Args: heights: A list of integers representing the height of vertical lines drawn to the x-axis at that position. Returns: An integer representing the total units of water trapped. if not heights or len(heights) < 3: return 0 left, right = 0, len(heights) - 1 left_max, right_max = heights[left], heights[right] water_trapped = 0 while left < right: if left_max < right_max: left += 1 left_max = max(left_max, heights[left]) water_trapped += max(0, left_max - heights[left]) else: right -= 1 right_max = max(right_max, heights[right]) water_trapped += max(0, right_max - heights[right]) return water_trapped"},{"question":"# Problem Statement You are given an encoded string that can contain integer values followed by a set of square brackets enclosing another encoded string. Your task is to implement a function to decode this string according to the following rules: 1. Integers followed by `[]` mean the content inside the brackets should repeat `n` times, where `n` is the integer. 2. The input string will always be valid; no need to check for invalid inputs. # Function Signature ```python def decode_string(s: str) -> str: Decodes the given encoded string according to the specified rules. Parameters: s (str): The encoded string. Returns: str: The decoded string. pass ``` # Input - `s` (str): A non-empty encoded string containing lowercase English letters and digits within square brackets. # Output - `str`: The decoded string. # Constraints - The length of `s` will not exceed 30,000 characters. - `s` is guaranteed to be a valid encoded string. # Performance Requirements - The solution should run efficiently within the input constraints. - It should handle nested encoding gracefully. # Example ```python s = \\"3[a]2[bc]\\" print(decode_string(s)) # Output: \\"aaabcbc\\" s = \\"3[a2[c]]\\" print(decode_string(s)) # Output: \\"accaccacc\\" s = \\"2[abc]3[cd]ef\\" print(decode_string(s)) # Output: \\"abcabccdcdcdef\\" s = \\"abc3[cd]xyz\\" print(decode_string(s)) # Output: \\"abccdcdcdxyz\\" ``` # Implementation Notes 1. Use a stack to keep track of the current string and the number of times it needs to be repeated. 2. Iterate over the string, pushing intermediate results onto the stack when encountering a new number or opening bracket \'[\'. 3. When encountering a closing bracket \']\', pop from the stack until the corresponding opening bracket is found, generating the decoded string for that segment. 4. Ensure the decoded segments are correctly repeated and concatenated as you proceed through the string.","solution":"def decode_string(s: str) -> str: Decodes the given encoded string according to the specified rules. Parameters: s (str): The encoded string. Returns: str: The decoded string. stack = [] current_num = 0 current_string = \\"\\" for char in s: if char.isdigit(): current_num = current_num * 10 + int(char) elif char == \'[\': stack.append((current_string, current_num)) current_string = \\"\\" current_num = 0 elif char == \']\': prev_string, repeat_num = stack.pop() current_string = prev_string + current_string * repeat_num else: current_string += char return current_string"},{"question":"# Scenario You are working on a simulation program for an amusement park that manages ticket sales for different rides. Each ride has a capacity limit, and you need to determine how many rides each group of visitors can attend without exceeding the capacity of any ride. # Coding Task Write a function `assign_rides(group_sizes: List[int], ride_capacities: List[int]) -> List[int]` that assigns each group to as many rides as possible without exceeding the capacity limits. # Input 1. `group_sizes` (List[int]): A list of integers representing the sizes of different groups of visitors. 2. `ride_capacities` (List[int]): A list of integers representing the capacity limits of each ride. # Output 1. A list of integers where each integer represents the number of rides a corresponding group can be assigned to without exceeding the capacity of any ride. # Constraints 1. The size of `group_sizes` and `ride_capacities` will each be at most `100`. 2. Each group size and ride capacity will be a positive integer between `1` and `100`. # Performance Requirements 1. The function should efficiently allocate rides to groups respecting the provided capacities. 2. Avoid reassigning groups to rides once the capacity limit is reached. # Starter Code ```python from typing import List def assign_rides(group_sizes: List[int], ride_capacities: List[int]) -> List[int]: group_rides = [] for group in group_sizes: rides_count = 0 for capacity in ride_capacities: if group <= capacity: rides_count += 1 group_rides.append(rides_count) return group_rides # Example: # group_sizes = [5, 10, 15] # ride_capacities = [10, 15] # result = assign_rides(group_sizes, ride_capacities) # print(result) # Output: [2, 2, 1] ``` # Evaluation Criteria * Correctness: The function should correctly assign the maximum number of rides to each group without exceeding capacity limits. * Efficiency: The function should effectively compute the assignments within the given constraints. * Edge Case Handling: Properly handle scenarios with minimal and maximal group sizes and ride capacities.","solution":"from typing import List def assign_rides(group_sizes: List[int], ride_capacities: List[int]) -> List[int]: group_rides = [] for group in group_sizes: rides_count = 0 for capacity in ride_capacities: if group <= capacity: rides_count += 1 group_rides.append(rides_count) return group_rides"},{"question":"# Linked List Clone with Random Pointer Context: Creating an exact copy of a linked list, which includes random pointers in addition to the standard next pointers, is a common interview question that tests knowledge of linked data structures and hash maps. Task: Implement a function that clones a linked list where each node contains an additional random pointer pointing to any node in the list or null. Function Signature: ```python class ListNode: def __init__(self, val=0, next=None, random=None): self.val = val self.next = next self.random = random def copyRandomList(head: Optional[ListNode]) -> Optional[ListNode]: pass ``` Input: - `head`: The head of the linked list where each node has three attributes: - `int val`: the value of the node. - `ListNode next`: the next pointer. - `ListNode random`: the random pointer that could point to any node in the list or null. Output: - The head of the new cloned linked list, which is a deep copy of the original list. Constraints: - The number of nodes in the list is in the range `[0, 10^4]`. - `-10000 <= Node.val <= 10000` - Node.random is null or points to any node in the linked list. Example: ```python # Example 1: # Original list: [7, 13, 11, 10, 1] # Random pointers: {None, 0, 4, 2, 0} # Explanation: # The linked list has nodes with values [7, 13, 11, 10, 1] and corresponding random pointers # such that the node with value 13 points to the node with value 7, and so on. node1 = ListNode(7) node2 = ListNode(13) node3 = ListNode(11) node4 = ListNode(10) node5 = ListNode(1) node1.next = node2 node2.next = node3 node3.next = node4 node4.next = node5 node1.random = None node2.random = node1 node3.random = node5 node4.random = node3 node5.random = node1 # Cloned list should replicate the above structure cloned_head = copyRandomList(node1) # Verify cloned list print(cloned_head.val) # Output: 7 print(cloned_head.next.val) # Output: 13 print(cloned_head.next.random.val) # Output: 7 # Example 2: # Original list is empty, should return None print(copyRandomList(None)) # Output: None ```","solution":"class ListNode: def __init__(self, val=0, next=None, random=None): self.val = val self.next = next self.random = random def copyRandomList(head: ListNode) -> ListNode: if not head: return None # Step 1: Create new nodes next to original nodes current = head while current: new_node = ListNode(current.val) new_node.next = current.next current.next = new_node current = new_node.next # Step 2: Assign random pointers for cloned nodes current = head while current: if current.random: current.next.random = current.random.next current = current.next.next # Step 3: Separate the cloned list from the original list pseudo_head = ListNode(0) current = head clone_current = pseudo_head while current: clone_current.next = current.next clone_current = clone_current.next current.next = current.next.next current = current.next return pseudo_head.next"},{"question":"# Binary Search Tree: Handling Duplicates and Range Queries Background: You\'re given an implementation of a Binary Search Tree (BST) that allows insertion, deletion, and lookup operations. The standard BST does not handle duplicates, and we\'re interested in adding functionality to manage duplicate values. Additionally, we want to extend the BST to support efficient range queries. Task: Enhance the BST implementation to: 1. **Duplicate Handling**: - Allow the BST to store duplicate values. - Ensure that lookup, insertion, and deletion operations correctly manage duplicates. 2. **Range Queries**: - Implement a function to retrieve all values within a specified range [low, high], inclusive. Requirements: 1. **Insertion**: - Modify the `insert` method to accommodate duplicate entries, possibly by storing duplicates in a list at each node. 2. **Deletion**: - Update the `delete` method to correctly handle the removal of specific instances of duplicates. 3. **Range Query**: - Implement a new method `range_query` that returns all values within the specified range [low, high]. Function Implementation: Modify the following methods as necessary and add new ones: - `insert` - `delete` - `range_query` Input and Output **Function Signatures**: ```python class TreeNode: def __init__(self, value): # Initialize with a list for the value to store duplicates self.values = [value] self.left = None self.right = None class BST: def __init__(self): self.root = None def insert(self, value: int) -> None: # Modify to handle duplicates def delete(self, value: int) -> None: # Modify to handle specific instances of duplicates def range_query(self, low: int, high: int) -> List[int]: # Implement the range query to return all values within [low, high] ``` **Example**: ```python # Assume the following usage bst = BST() bst.insert(10) bst.insert(5) bst.insert(20) bst.insert(10) # duplicate insertion bst.insert(15) bst.insert(25) assert bst.range_query(10, 20) == [10, 10, 15, 20] bst.delete(10) assert bst.range_query(10, 20) == [10, 15, 20] bst.delete(10) assert bst.range_query(10, 20) == [15, 20] ``` **Constraints**: - Value range for the nodes: -10^9 <= value <= 10^9 - Total number of nodes: 1 <= total_number_of_nodes <= 10^5 **Performance Requirements**: - The `range_query` method should run in O(n) where n is the number of nodes in the specified range. - Other operations such as `insert` and `delete` should maintain the O(log n) time complexity for a balanced BST.","solution":"class TreeNode: def __init__(self, value): # Initialize with a list for the value to store duplicates self.values = [value] self.left = None self.right = None class BST: def __init__(self): self.root = None def insert(self, value: int) -> None: if not self.root: self.root = TreeNode(value) else: self._insert(self.root, value) def _insert(self, node, value): if value < node.values[0]: if node.left: self._insert(node.left, value) else: node.left = TreeNode(value) elif value > node.values[0]: if node.right: self._insert(node.right, value) else: node.right = TreeNode(value) else: node.values.append(value) def delete(self, value: int) -> None: self.root = self._delete(self.root, value) def _delete(self, node, value): if not node: return node if value < node.values[0]: node.left = self._delete(node.left, value) elif value > node.values[0]: node.right = self._delete(node.right, value) else: # value found if len(node.values) > 1: node.values.pop() elif not node.left: return node.right elif not node.right: return node.left else: min_larger_node = self._get_min(node.right) node.values = min_larger_node.values node.right = self._delete(node.right, min_larger_node.values[0]) return node def _get_min(self, node): current = node while current.left: current = current.left return current def range_query(self, low: int, high: int) -> list: result = [] self._range_query(self.root, low, high, result) return result def _range_query(self, node, low, high, result): if not node: return if low <= node.values[0] <= high: result.extend(node.values) if low < node.values[0]: self._range_query(node.left, low, high, result) if node.values[0] < high: self._range_query(node.right, low, high, result)"},{"question":"Question: You are required to implement the Dijkstra algorithm to find the shortest path from a given source vertex to all other vertices in a graph with non-negative weights. Your implementation should correctly handle graphs with cycles and disconnected components. # Input - An integer `V` (1 ≤ `V` ≤ 1000) representing the number of vertices. - An integer `E` (0 ≤ `E` ≤ 10000) representing the number of edges. - A list of `E` edges, where each edge is represented by a tuple of three integers: `src`, `dest`, and `weight`. - An integer `src` representing the source vertex. # Output - A list of `V` floating-point numbers representing the shortest distance from the source vertex to each vertex. - If a vertex is unreachable from the source, the corresponding distance should be represented as `float(\\"inf\\")`. # Function Signature ```python def dijkstra(graph: list[tuple[int, int, int]], vertex_count: int, edge_count: int, src: int) -> list[float]: pass ``` # Constraints - All vertices are numbered from 0 to V-1. - Weights are non-negative integers. - If a vertex is unreachable from the source, the corresponding distance should be represented as `float(\\"inf\\")`. # Example ```python edges = [ (0, 1, 4), (0, 2, 2), (1, 2, 1), (1, 3, 5), (2, 3, 8), (2, 4, 10), (3, 4, 2) ] vertex_count = 5 edge_count = 7 src = 0 result = dijkstra(edges, vertex_count, edge_count, src) print(result) # Output: [0.0, 3.0, 2.0, 10.0, 12.0] ``` In this example, the function should return the shortest distances from the source vertex 0 to all other vertices. If any vertex is unreachable from the source, it should be represented by `float(\\"inf\\")`.","solution":"import heapq from typing import List, Tuple def dijkstra(graph: List[Tuple[int, int, int]], vertex_count: int, edge_count: int, src: int) -> List[float]: distances = [float(\'inf\')] * vertex_count distances[src] = 0 priority_queue = [(0, src)] adjacency_list = [[] for _ in range(vertex_count)] for edge in graph: u, v, w = edge adjacency_list[u].append((v, w)) while priority_queue: curr_distance, u = heapq.heappop(priority_queue) if curr_distance > distances[u]: continue for neighbor, weight in adjacency_list[u]: distance = curr_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances"},{"question":"**Problem Statement:** You are given a 2D grid representing a farm where each cell contains a value representing the number of crops in that cell. Each value is an integer between 0 and `10^4`. Your task is to find the maximum sum of crops from any sub-grid of size `k x k`. **Function Signature:** ```python def max_crops_in_subgrid(grid: list[list[int]], k: int) -> int: pass ``` # Input * `grid` - A 2D list of integers representing the farm grid, where the size of the grid is `m x n` and `1 <= m, n <= 1000`. * `k` - An integer `k` where `1 <= k <= min(m, n)` representing the size of the sub-grid. # Output * Return an integer representing the maximum sum of crops from any sub-grid of size `k x k`. # Constraints * Expected time complexity: O(m * n) * Expected space complexity: O(1) # Example ```python assert max_crops_in_subgrid([ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 2) == 54 assert max_crops_in_subgrid([ [1, 1, 1], [1, 1, 1], [1, 1, 1]], 2) == 4 assert max_crops_in_subgrid([ [1, -1, 0], [0, 1, 1], [1, 0, 1]], 1) == 1 assert max_crops_in_subgrid([ [1, 2], [3, 4]], 2) == 10 ``` # Explanation In the first example, the grid is: ``` 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 ``` A sub-grid of size 2x2 that has the maximum sum of crops is: ``` 10 11 14 15 ``` The sum of these cells is `10 + 11 + 14 + 15 = 54`. In the second example, the grid is filled with 1\'s, and the maximum sum for any 2x2 sub-grid is `4`. **Note:** Consider edge cases like grids filled with the same number or negative values.","solution":"def max_crops_in_subgrid(grid: list[list[int]], k: int) -> int: m, n = len(grid), len(grid[0]) max_sum = float(\'-inf\') # Create an auxiliary sum array to store sums of sub-grids sum_grid = [[0] * (n + 1) for _ in range(m + 1)] # Building the prefix sum grid for i in range(1, m + 1): for j in range(1, n + 1): sum_grid[i][j] = grid[i - 1][j - 1] + sum_grid[i - 1][j] + sum_grid[i][j - 1] - sum_grid[i - 1][j - 1] # Calculate the sum of each kxk sub-grid for i in range(k, m + 1): for j in range(k, n + 1): current_sum = sum_grid[i][j] - sum_grid[i - k][j] - sum_grid[i][j - k] + sum_grid[i - k][j - k] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"# Coding Question: Calculate the Binary Gap Context: Bob is working on an application that requires analyzing binary representations of integers. He is particularly interested in finding the longest sequence of consecutive zeros that is bordered by ones at both ends in the binary form of an integer. This sequence is called a \\"binary gap\\". Your task is to implement a function that identifies the length of the longest binary gap for a given non-negative integer. Task: Write a function `calculate_binary_gap(number: int) -> int` that returns the length of the longest binary gap in the binary representation of the given non-negative integer. If there are no binary gaps, the function should return 0. If the input is not an integer or is negative, the function should raise a `TypeError`. Input and Output Format: * **Input**: A single non-negative integer `number`. * Constraints: * `0 <= number <= 10^18` (Note: Ensure your function handles very large integers efficiently.) * **Output**: An integer representing the length of the longest binary gap. If there are no binary gaps, return 0. Example Cases: ```python >>> calculate_binary_gap(9) 2 >>> calculate_binary_gap(529) 4 >>> calculate_binary_gap(20) 1 >>> calculate_binary_gap(15) 0 >>> calculate_binary_gap(32) 0 >>> calculate_binary_gap(-1) Traceback (most recent call last): ... TypeError: Input value must be a non-negative \'int\' type ``` Constraints: * You are not allowed to use any built-in functions that directly solve this task. * Handle edge cases, including zero and extremely large integers. Performance Requirements: * Your solution should run efficiently for input values up to (10^{18}). Good luck and ensure your code passes the provided example cases!","solution":"def calculate_binary_gap(number): Returns the length of the longest binary gap in the binary representation of the given non-negative integer. If there are no binary gaps, returns 0. if not isinstance(number, int) or number < 0: raise TypeError(\\"Input value must be a non-negative \'int\' type\\") # Convert number to binary representation without the \'0b\' prefix binary_representation = bin(number)[2:] # Initialize the longest gap to 0 longest_gap = 0 current_gap = 0 in_gap = False for bit in binary_representation: if bit == \'1\': # If we are in a gap and we find a \'1\', end the gap and check its length if in_gap: longest_gap = max(longest_gap, current_gap) current_gap = 0 # reset current gap counter in_gap = True elif in_gap: # If we are in a gap and find a \'0\', increase the gap length current_gap += 1 return longest_gap"},{"question":"# Matrix Path Finder Context In pathfinding problems, navigating from one point to another on a grid-based map while obeying certain movement rules is a common challenge. You are given a two-dimensional grid representing a map and your goal is to determine if there is a path from the top-left corner to the bottom-right corner. The grid contains cells that are either passable (represented by `1`) or impassable (represented by `0`). You are tasked with implementing a function that uses a queue to determine if there is a path from the top-left to the bottom-right corner of the grid. Movement is restricted to upward, downward, left, and right steps. Task Implement a function `has_path(grid: List[List[int]]) -> bool` which takes a two-dimensional list `grid` as input and returns a boolean indicating whether there is a path from the top-left corner to the bottom-right corner of the grid. Input and Output Formats * **Input**: A two-dimensional list `grid` containing only `0`s and `1`s. * **Output**: A boolean `True` if there is a valid path, `False` otherwise. Constraints * The dimensions of the grid are at most 100x100. * The top-left and bottom-right corners of the grid will always contain `1`. * Movement is restricted to up, down, left, and right. Example ```python def has_path(grid: List[List[int]]) -> bool: >>> has_path([ ... [1, 0, 0, 0], ... [1, 1, 0, 0], ... [0, 1, 0, 0], ... [0, 1, 1, 1] ... ]) True >>> has_path([ ... [1, 0, 0, 0], ... [0, 1, 0, 0], ... [0, 1, 0, 0], ... [0, 0, 0, 1] ... ]) False pass ``` Requirements * Use breadth-first search (BFS) to navigate the grid. * The algorithm should run with a time complexity of O(n * m), where n and m are the dimensions of the grid.","solution":"from collections import deque from typing import List def has_path(grid: List[List[int]]) -> bool: if not grid or grid[0][0] == 0 or grid[-1][-1] == 0: return False rows, cols = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0)]) visited = set((0, 0)) while queue: x, y = queue.popleft() if (x, y) == (rows - 1, cols - 1): return True for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and grid[nx][ny] == 1 and (nx, ny) not in visited: queue.append((nx, ny)) visited.add((nx, ny)) return False"},{"question":"# Working with Strings and Character Frequencies In this exercise, you need to focus on character frequency counts and string transformations. You are tasked with implementing two functions: one that calculates the frequency of each character in a given string and another that reconstructs the string based on specific character frequency constraints. Requirements 1. **Character Frequency Calculation**: - Implement the `character_frequency` function, which calculates the frequency of each character in a given string. - Ensure that the function handles different cases such as empty strings or strings with special characters. 2. **Reconstruct String from Frequencies**: - Implement the `reconstruct_string` function, which reconstructs a string given a dictionary of character frequencies. - The dictionary contains characters as keys and their frequencies as values. Ensure appropriate handling of edge cases. Function Signatures ```python def character_frequency(string: str) -> dict: pass def reconstruct_string(char_freq: dict) -> str: pass ``` Input and Output Formats - **Character Frequency Calculation**: - **Input**: `string` (str) - **Output**: `dict` with characters as keys and their frequencies as values - **Reconstruct String from Frequencies**: - **Input**: `char_freq` (dict) with characters as keys and their frequencies as values - **Output**: `str` representing the reconstructed string Constraints - Strings can include letters (uppercase and lowercase), digits, spaces, and special characters. - Frequencies in the `char_freq` dictionary must be non-negative integers. If a non-integer value is passed, raise a ValueError with a relevant message. Performance Requirements All operations should maintain a linear time complexity O(n), where n is the length of the string or the number of characters in the dictionary. Example Usage ```python print(character_frequency(\\"hello world!\\")) # Output: {\'h\': 1, \'e\': 1, \'l\': 3, \'o\': 2, \' \': 1, \'w\': 1, \'r\': 1, \'d\': 1, \'!\': 1} print(reconstruct_string({\'h\': 1, \'e\': 1, \'l\': 3, \'o\': 2, \' \': 1, \'w\': 1, \'r\': 1, \'d\': 1, \'!\': 1})) # Output: \\"hello world!\\" ``` Implement the given functions based on these details while adhering to the input-output formats, constraints, and performance requirements.","solution":"def character_frequency(string: str) -> dict: Returns the frequency of each character in the string. frequency = {} for char in string: if char in frequency: frequency[char] += 1 else: frequency[char] = 1 return frequency def reconstruct_string(char_freq: dict) -> str: Reconstructs a string based on the given character frequency dictionary. if not isinstance(char_freq, dict): raise ValueError(\\"Input must be a dictionary.\\") reconstructed = [] for char, freq in char_freq.items(): if not isinstance(freq, int) or freq < 0: raise ValueError(\\"Frequencies must be non-negative integers.\\") reconstructed.append(char * freq) return \'\'.join(reconstructed)"},{"question":"You are tasked with creating a sorted merge function that combines two pre-sorted lists of integers into a single sorted list. The solution must efficiently handle large datasets and avoid unnecessary computations. Specifically, implement the following enhancements: 1. **Efficiency**: - Ensure the merge operation completes in O(n) time complexity, where n is the total number of elements in the two lists. - Avoid using built-in sorting functions; the goal is to take advantage of the fact that the input lists are already sorted. 2. **Memory Usage**: - Achieve the merge in-place if possible, or minimize additional space usage. 3. **Edge Cases**: - Handle cases where one or both lists are empty. - Manage duplicates effectively, i.e., they should appear in the result as they do in the input lists. Write the function `merge_sorted_lists` with the following signature: ```python def merge_sorted_lists(list1: List[int], list2: List[int]) -> List[int]: # Your implementation here ``` # Input: - `list1` (List of int): The first sorted list of integers. - `list2` (List of int): The second sorted list of integers. # Output: - Returns a single list that contains all integers from `list1` and `list2`, sorted in ascending order. # Constraints: - The length of each list (`list1` and `list2`) will not exceed 10^5. - The function should efficiently handle edge cases without significant performance degradation. # Example: ```python # Example usage result = merge_sorted_lists([1, 3, 5], [2, 4, 6]) print(result) # Output: [1, 2, 3, 4, 5, 6] result = merge_sorted_lists([], [2, 3, 5]) print(result) # Output: [2, 3, 5] result = merge_sorted_lists([1, 2, 3], [2, 3, 4]) print(result) # Output: [1, 2, 2, 3, 3, 4] ``` This code should print the merged list containing all integers from the two input lists in sorted order.","solution":"from typing import List def merge_sorted_lists(list1: List[int], list2: List[int]) -> List[int]: Takes two pre-sorted lists of integers and merges them into a single sorted list. merged_list = [] i, j = 0, 0 while i < len(list1) and j < len(list2): if list1[i] <= list2[j]: merged_list.append(list1[i]) i += 1 else: merged_list.append(list2[j]) j += 1 # Append any remaining elements in list1 or list2 while i < len(list1): merged_list.append(list1[i]) i += 1 while j < len(list2): merged_list.append(list2[j]) j += 1 return merged_list"},{"question":"**Context**: You are involved in a project that requires manipulating a binary tree to perform hierarchical data management. In particular, a common operation involves finding the lowest common ancestor (LCA) of two nodes in the tree. The LCA of two nodes `p` and `q` in a binary tree is defined as the lowest node that has both `p` and `q` as descendants (where we allow a node to be a descendant of itself). **Task**: Implement a function `find_lowest_common_ancestor` that, given the root of a binary tree and two node values, determines their lowest common ancestor. # Function Signature ```python class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def find_lowest_common_ancestor(root: TreeNode, p: int, q: int) -> int: Given the root of a binary tree and two distinct node values, find the lowest common ancestor (LCA) of the nodes with those values. Args: root (TreeNode): The root node of the binary tree. p (int): The value of the first node. q (int): The value of the second node. Returns: int: The value of the lowest common ancestor node. ``` # Input * `root` (TreeNode): The root node of the binary tree. * `p` (int): The value of the first node. * `q` (int): The value of the second node. # Output * Returns an integer: the value of the lowest common ancestor node. # Constraints * Assume the tree does not contain duplicate values. * The binary tree has at most 1000 nodes. * Node values are unique and within the range of 0 to 10^5. * Both `p` and `q` are guaranteed to exist in the binary tree. # Example Consider the following binary tree: ``` 3 / 5 1 / / 6 2 0 8 / 7 4 ``` ```python >>> root = TreeNode(3) >>> root.left = TreeNode(5) >>> root.right = TreeNode(1) >>> root.left.left = TreeNode(6) >>> root.left.right = TreeNode(2) >>> root.right.left = TreeNode(0) >>> root.right.right = TreeNode(8) >>> root.left.right.left = TreeNode(7) >>> root.left.right.right = TreeNode(4) >>> find_lowest_common_ancestor(root, 5, 1) 3 >>> find_lowest_common_ancestor(root, 5, 4) 5 >>> find_lowest_common_ancestor(root, 6, 4) 5 ``` Write your implementation to ensure it efficiently finds the lowest common ancestor while covering all edge cases.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def find_lowest_common_ancestor(root: TreeNode, p: int, q: int) -> int: def helper(node): if not node: return None if node.val == p or node.val == q: return node left = helper(node.left) right = helper(node.right) if left and right: return node return left if left else right lca = helper(root) return lca.val"},{"question":"# Unique Characters Finder You are required to implement a function that will determine if all characters in a string are unique. The function should disregard case sensitivity, meaning \'A\' and \'a\' are considered the same character. Your implementation should not use any additional data structures (like a set or dictionary). **Function Signature**: `def is_unique_chars(input_string: str) -> bool:` # Requirements: 1. Check if all characters in the given string are unique disregarding the case. 2. The function should be case insensitive. 3. Do not use additional data structures to store unique characters. # Input and Output Formats: * **Input**: A single string `input_string` which can contain letters, digits, and other printable ASCII characters. * **Output**: A boolean value `True` if all characters in the string are unique, otherwise `False`. # Constraints: * The length of `input_string` will be in the range [0, 1000]. # Examples: 1. `is_unique_chars(\\"abcdef\\")` should return `True`. 2. `is_unique_chars(\\"hello\\")` should return `False` because \'l\' is repeated. 3. `is_unique_chars(\\"AaBbCc\\")` should return `False` because \'A\' and \'a\' are the same character. 4. `is_unique_chars(\\"123!@#\\")` should return `True`. 5. `is_unique_chars(\\"\\")` should return `True` because there are no characters to compare. Ensure to handle edge cases such as empty strings, strings with all the same characters, and strings with mixed characters including digits and special characters. Also test your function for accuracy and performance within the given constraints.","solution":"def is_unique_chars(input_string: str) -> bool: Determines if all characters in the string are unique, ignoring case sensitivity. input_string = input_string.lower() # Make the string case insensitive length = len(input_string) for i in range(length): for j in range(i + 1, length): if input_string[i] == input_string[j]: return False return True"},{"question":"# Expense Tracker Enhancement You are tasked with improving an existing expense tracker application by writing a function `add_expense` that takes the current list of recorded expenses and a new expense item. The function should register the new expense and ensure the total expenses stay within a specified budget. If adding the new expense exceeds the budget, the function should return a warning message and not add the expense. # Function Signature ```python def add_expense(expenses: list, new_expense: dict, budget: float) -> dict: pass ``` # Input * `expenses`: A list of dictionaries where each dictionary contains two keys: \'description\' (a string) and \'amount\' (a float). * `new_expense`: A dictionary with the same structure as an item in `expenses`. * `budget`: A float representing the total budget limit. # Output * Returns the updated list of expenses if the new expense is added successfully, or a dictionary with a warning message if the new expense exceeds the budget. # Constraints * The amounts in `expenses` and `new_expense` will be non-negative floats. * The budget will be a non-negative float. * The output should ensure no change to the original list of expenses if adding the new expense exceeds the budget. # Example ```python >>> expenses = [{\'description\': \'Lunch\', \'amount\': 12.50}, {\'description\': \'Coffee\', \'amount\': 4.00}] >>> new_expense = {\'description\': \'Book\', \'amount\': 15.00} >>> budget = 35.00 >>> add_expense(expenses, new_expense, budget) [{\'description\': \'Lunch\', \'amount\': 12.50}, {\'description\': \'Coffee\', \'amount\': 4.00}, {\'description\': \'Book\', \'amount\': 15.00}] >>> expenses = [{\'description\': \'Lunch\', \'amount\': 12.50}, {\'description\': \'Coffee\', \'amount\': 4.00}] >>> new_expense = {\'description\': \'Book\', \'amount\': 25.00} >>> budget = 35.00 >>> add_expense(expenses, new_expense, budget) {\'warning\': \'Adding this expense exceeds the budget.\'} ``` This problem requires you to carefully manage the list of expenses while respecting budget constraints, demanding a firm grasp of list manipulation and conditional logic. Aim for a clear solution that checks the budget constraint before modifying the list.","solution":"def add_expense(expenses, new_expense, budget): Adds a new expense to the existing list of expenses if the total does not exceed the budget. :param expenses: List of dictionaries with keys \'description\' and \'amount\'. :param new_expense: Dictionary with keys \'description\' and \'amount\'. :param budget: Float representing the budget limit. :return: Updated list of expenses or a dictionary with a warning message. current_total = sum(expense[\'amount\'] for expense in expenses) new_total = current_total + new_expense[\'amount\'] if new_total <= budget: return expenses + [new_expense] else: return {\'warning\': \'Adding this expense exceeds the budget.\'}"},{"question":"# Coding Challenge: Implementing a Range Sum Query in a Binary Search Tree You have been provided the implementation of a Binary Search Tree (BST) that supports insertion, deletion, and standard search operations. Your task is to implement a new feature that can compute the sum of all elements within a given range [L, R]. # Task **Function to Implement:** ```python def range_sum_bst(bst, L, R): Given a binary search tree `bst` and two integers `L` and `R`, return the sum of node values between `L` and `R` (inclusive). Parameters: bst (BST): The root of the Binary Search Tree. L (int): The lower bound of the range (inclusive). R (int): The upper bound of the range (inclusive). Returns: int: The sum of node values between L and R inclusive. pass ``` **Expected Input and Output:** - **Input**: - `bst`: A `BST` object representing the root of the Binary Search Tree. - `L`: An integer indicating the lower bound of the sum range. - `R`: An integer indicating the upper bound of the sum range. - **Output**: - The sum of values within the range [L, R] (an integer). # Constraints - `L` and `R` are always positive integers where L ≤ R. - The number of elements (n) in the tree is always greater than 0. - If no elements fall within the range, the function should return 0. # Example ```python tree = BST() elements = [20, 15, 25, 10, 5, 1, 50] for elem in elements: tree = tree.insert(elem) print(range_sum_bst(tree, 5, 15)) # Output should be 30 (5 + 10 + 15) print(range_sum_bst(tree, 20, 25)) # Output should be 45 (20 + 25) print(range_sum_bst(tree, 51, 100)) # Output should be 0 (no elements in the range) ``` # Implementation Notes - You are free to use any of the tree traversal methods provided in the `BST` class. - Ensure that the function works efficiently with the given structure of the Binary Search Tree.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BST: def __init__(self, root=None): self.root = root def insert(self, val): if not self.root: self.root = TreeNode(val) else: self._insert(self.root, val) return self def _insert(self, node, val): if val < node.val: if node.left: self._insert(node.left, val) else: node.left = TreeNode(val) else: if node.right: self._insert(node.right, val) else: node.right = TreeNode(val) def range_sum_bst(bst, L, R): def dfs(node): if not node: return 0 if node.val < L: return dfs(node.right) elif node.val > R: return dfs(node.left) else: return node.val + dfs(node.left) + dfs(node.right) return dfs(bst.root)"},{"question":"# Coding Assessment Question Write a function that receives user details and a dictionary of allowed age ranges to determine user eligibility for activities. Function Specification Function Name: `check_activity_eligibility` Parameters: - `user_age` (int): The age of the user. - `activity_age_ranges` (dict): A dictionary where keys are activity names (strings) and values are tuples representing minimum and maximum age limits for the activity. e.g., `{\\"activity1\\": (10, 20), \\"activity2\\": (15, 25)}` Returns: - A list of strings representing the names of activities the user can participate in. Constraints - `user_age` must be a non-negative integer. - Age ranges in `activity_age_ranges` will have each tuple with valid minimum and maximum integers. - Assume `activity_age_ranges` will always contain at least one activity. Raising Exceptions - Raise a `ValueError` if `user_age` is negative. Examples ```python >>> check_activity_eligibility(18, {\\"swimming\\": (10, 25), \\"marathon\\": (20, 30), \\"chess\\": (5, 50)}) [\'swimming\', \'chess\'] >>> check_activity_eligibility(12, {\\"swimming\\": (10, 25), \\"marathon\\": (20, 30)}) [\'swimming\'] >>> check_activity_eligibility(40, {\\"archery\\": (15, 45), \\"basketball\\": (18, 35)}) [\'archery\'] >>> check_activity_eligibility(8, {\\"swimming\\": (10, 25), \\"basketball\\": (18, 35)}) [] ``` Write the function `check_activity_eligibility` to solve the problem using the constraints and requirements provided.","solution":"def check_activity_eligibility(user_age, activity_age_ranges): if user_age < 0: raise ValueError(\\"User age must be a non-negative integer.\\") eligible_activities = [] for activity, age_range in activity_age_ranges.items(): min_age, max_age = age_range if min_age <= user_age <= max_age: eligible_activities.append(activity) return eligible_activities"},{"question":"# Prime Factorization Optimizer Implement a class `PrimeFactorizer` that computes the prime factorization of a given positive integer using an optimized algorithm. **Task**: Define the class with the following structure: ```python class PrimeFactorizer: def __init__(self, number): Initialize with the number to be factorized. :param number: Integer to be factorized self.number = number def get_factors(self): Compute and return the prime factorization of the number. :return: Dictionary with prime factors as keys and their exponents as values. factors = {} n = self.number # Step 1: Handle factor of 2 separately while n % 2 == 0: factors[2] = factors.get(2, 0) + 1 n //= 2 # Step 2: Handle odd factors from 3 onward for i in range(3, int(n**0.5) + 1, 2): while n % i == 0: factors[i] = factors.get(i, 0) + 1 n //= i # Step 3: If remaining n is a prime number greater than 2 if n > 2: factors[n] = 1 return factors ``` **Objective**: Ensure the `get_factors` method efficiently computes prime factors and handles large numbers gracefully. **Input/Output**: * **Input**: A positive integer. * **Output**: A dictionary where keys are prime factors and values are their corresponding exponents. **Constraints**: * `number` is a positive integer in the range (1 leq text{number} leq 10^9). **Performance**: The algorithm should efficiently handle prime factorization for large integers by iterating up to the square root of the number. **Scenario**: You need to factorize large integers for cryptographic applications, numerical analysis, or mathematical research. Ensure your method performs well with various input sizes. Example: ```python # Factorize 100 factorizer = PrimeFactorizer(100) print(factorizer.get_factors()) # Output: {2: 2, 5: 2} # Factorize 97 factorizer2 = PrimeFactorizer(97) print(factorizer2.get_factors()) # Output: {97: 1} # Factorize 84 factorizer3 = PrimeFactorizer(84) print(factorizer3.get_factors()) # Output: {2: 2, 3: 1, 7: 1} ```","solution":"class PrimeFactorizer: def __init__(self, number): Initialize with the number to be factorized. :param number: Integer to be factorized self.number = number def get_factors(self): Compute and return the prime factorization of the number. :return: Dictionary with prime factors as keys and their exponents as values. factors = {} n = self.number # Step 1: Handle factor of 2 separately while n % 2 == 0: factors[2] = factors.get(2, 0) + 1 n //= 2 # Step 2: Handle odd factors from 3 onward for i in range(3, int(n**0.5) + 1, 2): while n % i == 0: factors[i] = factors.get(i, 0) + 1 n //= i # Step 3: If remaining n is a prime number greater than 2 if n > 2: factors[n] = 1 return factors"},{"question":"# Coding Assessment Question You are tasked with developing a function that can perform various set operations for a theoretical computer science library. Your goal is to showcase your understanding of set theory and its common operations by writing a function that efficiently handles multiple set operations. Write a function `set_operation(operation: str, sets: list[set], element: int = None) -> set | bool | int | None` that performs one of the following operations based on the input parameters: 1. **Union**: Returns the union of all provided sets. 2. **Intersection**: Returns the intersection of all provided sets. 3. **Difference**: Returns the difference between the first set and the second set. 4. **Symmetric Difference**: Returns the symmetric difference between the first set and the second set. 5. **Subset**: Checks if the first set is a subset of the second set. 6. **Superset**: Checks if the first set is a superset of the second set. 7. **Cardinality**: Returns the number of elements in the set. 8. **Membership**: Checks if an element is a member of the set. Your function should handle the following inputs: * **operation**: A string specifying the operation. It can take values \\"union\\", \\"intersection\\", \\"difference\\", \\"symmetric_difference\\", \\"subset\\", \\"superset\\", \\"cardinality\\", or \\"membership\\". * **sets**: A list of sets (for operations requiring more than one set) or a single set. * **element**: An optional integer for membership operations (default is None). Function Signature ```python def set_operation(operation: str, sets: list[set], element: int = None) -> set | bool | int | None: pass ``` Input Conditions and Prechecks * Sets should not be empty. * Union, intersection, difference, and symmetric_difference operations should have at least two sets. * Subset and superset operations require exactly two sets. * Cardinality and membership operations require exactly one set. * Element is required only for the membership operation. Expected Output Depending on the operation, the function should return: * A set for union, intersection, difference, and symmetric_difference. * A boolean for subset, superset, and membership. * An integer for cardinality. * `None` if inputs are invalid or conditions are not met. Example Usage ```python # Union of sets print(set_operation(\\"union\\", [{1, 2}, {2, 3}, {3, 4}])) # Output: {1, 2, 3, 4} # Intersection of sets print(set_operation(\\"intersection\\", [{1, 2, 3}, {2, 3, 4}, {3, 4, 5}])) # Output: {3} # Difference of two sets print(set_operation(\\"difference\\", [{1, 2, 3}, {2, 3}])) # Output: {1} # Symmetric Difference of two sets print(set_operation(\\"symmetric_difference\\", [{1, 2, 3}, {2, 3, 4}])) # Output: {1, 4} # Check subset print(set_operation(\\"subset\\", [{1, 2}, {1, 2, 3}])) # Output: True # Cardinality of a set print(set_operation(\\"cardinality\\", [{1, 2, 3}])) # Output: 3 # Membership in a set print(set_operation(\\"membership\\", [{1, 2, 3}], 2)) # Output: True ``` Ensure your implementation is clear, correctly handles edge cases, and is optimized for performance.","solution":"def set_operation(operation: str, sets: list[set], element: int = None): Performs set operations based on the input parameters. if operation == \\"union\\" and len(sets) >= 2: return set.union(*sets) elif operation == \\"intersection\\" and len(sets) >= 2: return set.intersection(*sets) elif operation == \\"difference\\" and len(sets) == 2: return sets[0].difference(sets[1]) elif operation == \\"symmetric_difference\\" and len(sets) == 2: return sets[0].symmetric_difference(sets[1]) elif operation == \\"subset\\" and len(sets) == 2: return sets[0].issubset(sets[1]) elif operation == \\"superset\\" and len(sets) == 2: return sets[0].issuperset(sets[1]) elif operation == \\"cardinality\\" and len(sets) == 1: return len(sets[0]) elif operation == \\"membership\\" and len(sets) == 1 and element is not None: return element in sets[0] return None"},{"question":"# Coding Assessment Question You are working on a library management system tasked with enhancing the functionality of the system to better manage book inventories and user accounts. Your tasks are: 1. **Implement a function to search and display book details from an external book database API.** - Use the API endpoint \\"https://book-api.com/books\\" to fetch book details. - Ensure the book details include Title, Author, Publication Date, and Genre. 2. **Enhance the user management system:** - Implement a robust error handling mechanism to manage user registration scenarios such as duplicate accounts, invalid input data, and database connection issues. - Ensure that your implementation logs appropriate error messages and gracefully handles each scenario. 3. **Extend the book checkout feature:** - Modify the `checkout_book` function to include an automated due date calculation based on the current date and a two-week loan period. - Ensure that the system handles edge cases such as weekends, holidays, and leap years while calculating the due date accurately. 4. **Optimize user search functionality:** - Improve the `search_user` function for better performance and accuracy, especially when dealing with large datasets and common user names. - Ensure it supports partial matches and various input formats such as email, username, and user ID. **Input:** - A string representing the search criteria for books (title, author, or keyword). - User details for registration including username, email, and password. - A string representing the search criteria for users (email, username, or user ID). **Output:** - A formatted list of books matching the search criteria from the external API. - Appropriate success or error messages for user registration and book checkout. - A formatted list of users matching the search criteria. **Constraints:** - The external book API must return data in a JSON format containing the book details. - Ensure to handle up to 3 retries for failed network requests when fetching book details. - User data (for registration and search) must comply with the system\'s validation rules, including unique email addresses and strong password requirements. **Scenario Context:** Imagine a university library system transitioning to a new book database provider. The library must ensure seamless integration of the new database while maintaining the functionality of existing services, including user management and book loans, to avoid disruption for students and staff.","solution":"import requests import datetime import re import logging BOOK_API_URL = \\"https://book-api.com/books\\" def fetch_book_details(query): Fetches book details from the external book API and returns relevant details. Args: query (str): Search query for books (title, author or keyword). Returns: list: List of dictionaries containing book details (Title, Author, Publication Date, Genre). try: response = requests.get(BOOK_API_URL, params={\'query\': query}, timeout=5) response.raise_for_status() except requests.exceptions.RequestException as e: logging.error(f\\"Error fetching book details: {e}\\") raise books = response.json() return [{\'Title\': book[\'title\'], \'Author\': book[\'author\'], \'Publication Date\': book[\'publication_date\'], \'Genre\': book[\'genre\']} for book in books] users_db = {\\"users\\": []} def validate_user_data(username, email, password): Validates user data. Args: username (str): Username for the user. email (str): Email of the user. password (str): Password for the user. Returns: bool: True if validation passes, otherwise raises ValueError. if not re.match(r\\"[^@]+@[^@]+.[^@]+\\", email): raise ValueError(\\"Invalid email address\\") if len(password) < 6: raise ValueError(\\"Password too short\\") if any(user[\'email\'] == email for user in users_db[\'users\']): raise ValueError(\\"Email address already registered\\") return True def register_user(username, email, password): Registers a new user in the system, handling possible errors. Args: username (str): Username for the user. email (str): Email of the user. password (str): Password for the user. Returns: str: Success message or appropriate error message. try: if validate_user_data(username, email, password): users_db[\'users\'].append({\'username\': username, \'email\': email, \'password\': password}) return \\"User registered successfully\\" except ValueError as e: logging.error(f\\"Error registering user: {e}\\") return str(e) def checkout_book(user_id, book_id, checkout_date=datetime.date.today()): Checks out a book for a user and returns the due date. Args: user_id (str): The user ID of the person checking out the book. book_id (str): The book ID of the book being checked out. checkout_date (datetime.date): The date of checkout. Default is today\'s date. Returns: str: Due date as a string in \\"YYYY-MM-DD\\" format. two_weeks = datetime.timedelta(weeks=2) due_date = checkout_date + two_weeks # Adjust for weekends and holidays (example weekends) while due_date.weekday() >= 5: due_date += datetime.timedelta(days=1) return due_date.strftime(\\"%Y-%m-%d\\") def search_user(query): Searches for users based on query (partial email, username, or user ID). Args: query (str): The search query for users. Returns: list: List of dictionaries containing user details that match the search criteria. results = [] for user in users_db[\'users\']: if query.lower() in user[\'username\'].lower() or query.lower() in user[\'email\'].lower(): results.append(user) return results"},{"question":"# Problem Statement You are asked to enhance a simple calculator function to support additional operations while gracefully handling edge cases and input validation. # Task **Implement a function `enhanced_calculator(operation, num1, num2)` that extends a basic calculator to include additional operations and validations.** **Specifications**: 1. The function should support the following operations: `\'add\'`, `\'subtract\'`, `\'multiply\'`, `\'divide\'`, `\'modulus\'`, and `\'power\'`. 2. Raise a `ValueError` if the `operation` is not one of the supported operations. 3. Raise a `ValueError` if `num1` or `num2` is not an integer or float. 4. For division and modulus operations, raise a `ZeroDivisionError` if `num2` is zero. 5. Ensure that the function can handle very large numbers efficiently. **Input Format**: - A string `operation` representing the operation to be performed. - Two numbers, `num1` and `num2`, which are the operands. **Output Format**: - The result of the operation as a number. **Examples**: ```python >>> enhanced_calculator(\'add\', 10, 5) 15 >>> enhanced_calculator(\'subtract\', 10, 5) 5 >>> enhanced_calculator(\'multiply\', 10, 5) 50 >>> enhanced_calculator(\'divide\', 10, 2) 5.0 >>> enhanced_calculator(\'modulus\', 10, 3) 1 >>> enhanced_calculator(\'power\', 2, 10) 1024 >>> enhanced_calculator(\'divide\', 10, 0) ZeroDivisionError: Division by zero is not allowed. >>> enhanced_calculator(\'modulus\', 10, 0) ZeroDivisionError: Division by zero is not allowed. >>> enhanced_calculator(\'add\', 10, \'five\') ValueError: Operands must be int or float. >>> enhanced_calculator(\'unknown\', 10, 5) ValueError: Unsupported operation. ``` # Constraints: - The function should handle inputs robustly and provide clear error messages for invalid inputs. - It should manage large integer and float computations efficiently.","solution":"def enhanced_calculator(operation, num1, num2): Performs the given operation on num1 and num2. Args: operation (str): The operation to perform (\'add\', \'subtract\', \'multiply\', \'divide\', \'modulus\', \'power\'). num1 (int or float): The first operand. num2 (int or float): The second operand. Returns: int or float: The result of the operation. Raises: ValueError: If the operation is unsupported or if num1 or num2 are not numbers. ZeroDivisionError: If num2 is zero for \'divide\' or \'modulus\' operations. if operation not in [\'add\', \'subtract\', \'multiply\', \'divide\', \'modulus\', \'power\']: raise ValueError(\\"Unsupported operation.\\") if not isinstance(num1, (int, float)) or not isinstance(num2, (int, float)): raise ValueError(\\"Operands must be int or float.\\") if (operation == \'divide\' or operation == \'modulus\') and num2 == 0: raise ZeroDivisionError(\\"Division by zero is not allowed.\\") operations = { \'add\': num1 + num2, \'subtract\': num1 - num2, \'multiply\': num1 * num2, \'divide\': num1 / num2, \'modulus\': num1 % num2, \'power\': num1 ** num2 } return operations[operation]"},{"question":"# Question: Find the First Repeating Character in a String You are required to write a Python function that finds the first repeating character in the given string. If there is no repeating character, the function should return `None`. Function Signature ```python def first_repeating_character(s: str) -> str: This function takes a string and returns the first repeating character in the string. Parameters: s (str) - a string in which to find the first repeating character. Returns: str - the first character that repeats in the string or None if there is no repeating character. ``` Parameters * **s** (str): A string to be analyzed for repeating characters. Constraints * 1 ≤ len(s) ≤ 10,000 * The input string will consist of printable ASCII characters. Expected Output * The function should return a single character that repeats first in the string. If no character repeats, it should return `None`. Example ```python print(first_repeating_character(\\"abracadabra\\")) # Should return \'a\' print(first_repeating_character(\\"abcdef\\")) # Should return None print(first_repeating_character(\\"aabbccddee\\")) # Should return \'a\' ``` Additional Notes 1. The function should iterate through the string efficiently without unnecessary complexity. 2. The first repeating character is defined as the first character that appears more than once when reading from left to right.","solution":"def first_repeating_character(s: str) -> str: This function takes a string and returns the first repeating character in the string. Parameters: s (str) - a string in which to find the first repeating character. Returns: str - the first character that repeats in the string or None if there is no repeating character. seen = set() for char in s: if char in seen: return char seen.add(char) return None"},{"question":"# Sorting Employee Data by Multiple Attributes Context: You are tasked to develop a function that sorts a list of employee data based on multiple attributes: age, then salary, and finally name. The sorting should be done in ascending order for age and salary, but in lexicographical order (A-Z) for names. Problem Description: Write a function `sort_employees` that takes a list of tuples where each tuple contains three elements: `(name, age, salary)`. The function should return the list of employees sorted by the specified criteria. Function Signature: ```python def sort_employees(employees: list) -> list: ``` Input: - `employees`: A list of tuples, where each tuple consists of: - `name` (a string representing the employee\'s name) - `age` (an integer representing the employee\'s age) - `salary` (an integer representing the employee\'s salary) The list may contain up to 10^5 employees. Output: - A list of tuples representing the sorted employees. Constraints: - Consider edge cases such as empty lists and employees with the same age and salary. - The function must handle large lists efficiently. Examples: ```python >>> sort_employees([(\\"Alice\\", 30, 50000), (\\"Bob\\", 25, 60000), (\\"Charlie\\", 30, 50000), (\\"David\\", 25, 60000)]) [(\\"Bob\\", 25, 60000), (\\"David\\", 25, 60000), (\\"Alice\\", 30, 50000), (\\"Charlie\\", 30, 50000)] >>> sort_employees([(\\"Alice\\", 22, 70000)]) [(\\"Alice\\", 22, 70000)] >>> sort_employees([]) [] >>> sort_employees([(\\"Eve\\", 30, 30000), (\\"Adam\\", 22, 40000)]) [(\\"Adam\\", 22, 40000), (\\"Eve\\", 30, 30000)] >>> sort_employees([(\\"John\\", 40, 45000), (\\"Jane\\", 40, 45000), (\\"Doe\\", 40, 45000)]) [(\\"Doe\\", 40, 45000), (\\"Jane\\", 40, 45000), (\\"John\\", 40, 45000)] ``` Notes: - The sorting criteria should be applied in a stable manner. - Ensure the function can sort lists with diverse data efficiently. - This exercise emphasizes the use of sorting algorithms that can handle multiple keys gracefully.","solution":"from typing import List, Tuple def sort_employees(employees: List[Tuple[str, int, int]]) -> List[Tuple[str, int, int]]: Takes a list of employee data and returns it sorted by age, salary, and name. :param employees: List of tuples containing employee data in form (name, age, salary) :return: List of tuples sorted by age, then by salary, and then by name lexicographically return sorted(employees, key=lambda x: (x[1], x[2], x[0]))"},{"question":"# Find the Shortest Path in a Weighted Graph with Limited Stops You are tasked with writing a function `shortest_path_with_stops` to find the shortest path between two nodes in a weighted directed graph, with the additional requirement that the path must not exceed a given number of stops. Function Signature ```python def shortest_path_with_stops(graph: dict, start: str, end: str, max_stops: int) -> int: pass ``` Input - `graph` (dict): A dictionary where keys represent nodes and values are lists of tuples (target_node, weight) indicating directed edges and their weights. - `start` (str): The starting node. - `end` (str): The destination node. - `max_stops` (int): The maximum number of stops (edges) allowed on the path (0 <= max_stops <= 100). Output - Returns an integer representing the weight of the shortest path from `start` to `end` that has at most `max_stops` edges. If no such path exists, return -1. Constraints - All node names are strings. - Weights are positive integers. - The graph may contain cycles. - Nodes in the graph are at most 100 in count. Examples ```python >>> graph = { ... \'A\': [(\'B\', 3), (\'C\', 1)], ... \'B\': [(\'A\', 3), (\'C\', 7), (\'D\', 5)], ... \'C\': [(\'A\', 1), (\'B\', 7), (\'D\', 2)], ... \'D\': [(\'B\', 5), (\'C\', 2)] ... } >>> shortest_path_with_stops(graph, \'A\', \'D\', 2) 3 >>> shortest_path_with_stops(graph, \'A\', \'D\', 1) -1 >>> shortest_path_with_stops(graph, \'A\', \'B\', 1) 3 ``` Notes - A path is defined by a sequence of edges connecting two nodes. The \\"number of stops\\" is the count of edges used. - Consider utilizing search algorithms such as Breadth-First Search (BFS) with a priority queue or a modified Dijkstra\'s algorithm that keeps track of the number of edges used. - Edge cases include scenarios where `max_stops` is 0, where there might be a direct connection from `start` to `end`.","solution":"import heapq def shortest_path_with_stops(graph, start, end, max_stops): Find the shortest path in a weighted directed graph with a limit on maximum stops. # Priority queue to store (cost, node, stops) queue = [(0, start, 0)] # Dictionary to track the minimum cost to reach each node with specific stops min_cost = {(start, 0): 0} while queue: cost, node, stops = heapq.heappop(queue) if stops > max_stops: continue if node == end: return cost for neighbor, weight in graph.get(node, []): new_cost = cost + weight if (neighbor, stops+1) not in min_cost or new_cost < min_cost[(neighbor, stops+1)]: min_cost[(neighbor, stops+1)] = new_cost heapq.heappush(queue, (new_cost, neighbor, stops+1)) return -1"},{"question":"# Question Write a function `find_all_substrings(s: str, query_size: int) -> List[str]` that returns all the unique substrings of a specified length `query_size` from the input string `s`. The substrings should be ordered in the order as they appear in the original string. Input - `s` (str): A string from which substrings are to be extracted. - `query_size` (int): The length of substrings to retrieve. Output - Returns a list of strings representing all unique substrings of length `query_size` from `s`. Constraints - 1 ≤ `len(s)` ≤ 10,000 - 1 ≤ `query_size` ≤ len(s) # Example ```python >>> find_all_substrings(\\"banana\\", 2) [\'ba\', \'an\', \'na\'] >>> find_all_substrings(\\"hello\\", 3) [\'hel\', \'ell\', \'llo\'] >>> find_all_substrings(\\"abcabc\\", 3) [\'abc\', \'bca\', \'cab\'] ``` Additional Notes - The substrings must be unique and in the order they appear in the original string. - Ensure the solution handles cases when `query_size` equals the length of the string efficiently.","solution":"def find_all_substrings(s: str, query_size: int) -> list: Returns all unique substrings of length `query_size` from the input string `s`. :param s: Input string :param query_size: Length of substrings :return: List of unique substrings in the order they appear in the original string seen = set() result = [] for i in range(len(s) - query_size + 1): substring = s[i:i + query_size] if substring not in seen: seen.add(substring) result.append(substring) return result"},{"question":"# Drone Delivery Pathfinding You are tasked with enhancing the functionality of an existing drone delivery system, which uses a graph to determine the shortest path for delivering packages. The graph consists of nodes representing delivery points and edges representing the path and distance between these points. You must extend the functionality of the provided graph by implementing the following additional features: 1. **Find Shortest Path**: Implement a function to find the shortest path between any two given delivery points using Dijkstra\'s algorithm. 2. **Calculate Total Distance**: Implement a function to calculate the total distance of a given delivery path. 3. **Find All Paths**: Implement a function to find all possible paths between two delivery points. 4. **Check Connectivity**: Implement a function to check if all delivery points in the graph are connected, meaning there exists a path between every pair of delivery points. Each function should take the graph and relevant nodes as arguments. # Function Signatures ```python def find_shortest_path(graph: Dict[int, List[Tuple[int, int]]], start: int, end: int) -> List[int]: pass def calculate_total_distance(graph: Dict[int, List[Tuple[int, int]]], path: List[int]) -> int: pass def find_all_paths(graph: Dict[int, List[Tuple[int, int]]], start: int, end: int) -> List[List[int]]: pass def is_connected(graph: Dict[int, List[Tuple[int, int]]]) -> bool: pass ``` # Input/Output * `find_shortest_path(graph: Dict[int, List[Tuple[int, int]]], start: int, end: int) -> List[int]`: Returns the nodes in the shortest path from `start` to `end` in order. If no path exists, return an empty list. * `calculate_total_distance(graph: Dict[int, List[Tuple[int, int]]], path: List[int]) -> int`: Returns the total distance of the given path. If the path is invalid, return `-1`. * `find_all_paths(graph: Dict[int, List[Tuple[int, int]]], start: int, end: int) -> List[List[int]]`: Returns a list of all possible paths from `start` to `end`. Each path is represented as a list of nodes. * `is_connected(graph: Dict[int, List[Tuple[int, int]]]) -> bool`: Returns `True` if the graph is connected, otherwise `False`. # Constraints * The graph is represented as an adjacency list, where each key is a node, and the value is a list of tuples, each containing a connected node and the distance to that node. * The graph will contain at least two nodes and no more than 100 nodes. * The edges’ distances are positive integers. # Examples ```python # Example graph creation graph = { 1: [(2, 5), (3, 10)], 2: [(3, 3)], 3: [(4, 1)], 4: [(1, 7)] } # Function outputs assert find_shortest_path(graph, 1, 4) == [1, 2, 3, 4] assert calculate_total_distance(graph, [1, 2, 3, 4]) == 9 assert find_all_paths(graph, 1, 4) == [[1, 2, 3, 4], [1, 3, 4]] assert is_connected(graph) == True ``` # Implementation Notes 1. **find_shortest_path**: Use Dijkstra\'s algorithm to find and return the shortest path from `start` to `end`. 2. **calculate_total_distance**: Iterate through the path and sum the distances of each edge. 3. **find_all_paths**: Use Depth-First Search (DFS) to explore all possible paths from `start` to `end`. 4. **is_connected**: Use Depth-First Search (DFS) or Breadth-First Search (BFS) to check if all nodes are reachable from any starting node.","solution":"from heapq import heappop, heappush from typing import Dict, List, Tuple, Set def find_shortest_path(graph: Dict[int, List[Tuple[int, int]]], start: int, end: int) -> List[int]: # Dijkstra\'s algorithm to find shortest path pq = [(0, start, [])] visited = set() while pq: cost, node, path = heappop(pq) if node in visited: continue visited.add(node) path = path + [node] if node == end: return path for neighbor, weight in graph.get(node, []): if neighbor not in visited: heappush(pq, (cost + weight, neighbor, path)) return [] def calculate_total_distance(graph: Dict[int, List[Tuple[int, int]]], path: List[int]) -> int: total_distance = 0 for i in range(len(path) - 1): found = False for neighbor, distance in graph[path[i]]: if neighbor == path[i+1]: total_distance += distance found = True break if not found: return -1 return total_distance def find_all_paths(graph: Dict[int, List[Tuple[int, int]]], start: int, end: int) -> List[List[int]]: def dfs(node: int, end: int, path: List[int], visited: Set[int], all_paths: List[List[int]]): path.append(node) visited.add(node) if node == end: all_paths.append(path.copy()) else: for neighbor, _ in graph.get(node, []): if neighbor not in visited: dfs(neighbor, end, path, visited, all_paths) path.pop() visited.remove(node) all_paths = [] dfs(start, end, [], set(), all_paths) return all_paths def is_connected(graph: Dict[int, List[Tuple[int, int]]]) -> bool: def dfs(node: int, visited: Set[int]): visited.add(node) for neighbor, _ in graph.get(node, []): if neighbor not in visited: dfs(neighbor, visited) visited = set() starting_node = next(iter(graph)) dfs(starting_node, visited) return len(visited) == len(graph)"},{"question":"# Problem Statement Write a function that finds all combinations of a given list of integers that sum up to a specific target number. The elements of the list are unique and the combination needs to be in non-decreasing order. Implement the function `combination_sum` which returns a list of all possible combinations. Function Signature ```python def combination_sum(nums: list[int], target: int) -> list[list[int]]: pass ``` Input * `nums`: A list of unique integers. * `target`: An integer value indicating the target sum. Output * A list of lists containing all possible combinations of integers from the input list that sum up to the target. Each list should be sorted in non-decreasing order. Constraints * All elements in `nums` are unique. * The order of the combinations in the output does not matter. * The input list `nums` can have at most 20 elements. # Example ```python combination_sum([2, 3, 6, 7], 7) ``` This function call should output: ```python [[7], [2, 2, 3]] ``` # Notes * You can use any combination approach (backtracking, recursion, etc.) to solve this problem. * Make sure the function handles edge cases such as empty input list, target being zero, etc. * Ensure the results are returned in non-decreasing order without duplicates.","solution":"def combination_sum(nums, target): def backtrack(start, target, path): if target == 0: result.append(path) return for i in range(start, len(nums)): if nums[i] > target: break backtrack(i, target - nums[i], path + [nums[i]]) nums.sort() result = [] backtrack(0, target, []) return result"},{"question":"# Problem Description You are tasked with writing a function `first_non_repeated_character` that takes a string as input and returns the first character that does not repeat. If all characters are repeated or the string is empty, the function should return `None`. # Input Format - A string `s` (0 <= len(s) <= 10^6) # Output Format - A character representing the first non-repeated character in the string, or `None` if all characters are repeated or the string is empty. # Constraints - The input string may contain any printable ASCII characters. - The solution should be efficient and aim to run in O(n) time complexity. - Additional space usage is allowed if necessary. # Example Scenarios 1. **Example 1:** - Input: s = \\"swiss\\" - Output: \'w\' 2. **Example 2:** - Input: s = \\"level\\" - Output: \'v\' 3. **Example 3:** - Input: s = \\"abracadabra\\" - Output: \'c\' # Edge Cases 1. **Empty String:** - Input: s = \\"\\" - Output: None 2. **All Characters Repeated:** - Input: s = \\"aabbcc\\" - Output: None 3. **Single Character String:** - Input: s = \\"z\\" - Output: \'z\' # Function Signature ```python def first_non_repeated_character(s: str) -> str | None: pass ``` # Write the function `first_non_repeated_character` to solve the problem:","solution":"def first_non_repeated_character(s: str) -> str | None: Finds the first non-repeated character in the given string. If all characters are repeated or the string is empty, returns None. :param s: Input string :return: First non-repeated character or None character_count = {} # Count appearance of each character for char in s: if char in character_count: character_count[char] += 1 else: character_count[char] = 1 # Find the first non-repeated character for char in s: if character_count[char] == 1: return char return None"},{"question":"# Question: Finding the Deepest Leaf Node Sum in a Binary Tree You are provided with a binary tree data structure. Your task is to calculate the sum of all the values of the leaf nodes that are present at the deepest level of the tree. # Function Signature ```python def deepest_leaves_sum(root: Node) -> int: Calculate the sum of the deepest leaf nodes values in a binary tree rooted at `root`. Args: root (Node): The root node of the binary tree. Returns: int: The sum of values of the deepest leaf nodes. ``` # Input - `root`: A `Node` object representing the root of the binary tree. The Node class is defined as: ```python class Node: def __init__(self, value: int) -> None: self.value = value self.left: Node | None = None self.right: Node | None = None ``` # Output - An integer representing the sum of the deepest leaf nodes\' values in the given binary tree. # Constraints - The number of nodes in the tree will be in the range `[0, 10^4]`. - The value of each node will be an integer in the range `[-1000, 1000]`. # Example ```python # Define the tree root = Node(1) root.left = Node(2) root.right = Node(3) root.left.left = Node(4) root.left.right = Node(5) root.left.left.left = Node(7) root.right.right = Node(6) root.right.right.right = Node(8) # Calculate the sum result = deepest_leaves_sum(root) # Output should be 15 (7 + 8) ``` # Edge Cases to Consider - Tree with only one node. - Tree with all leaf nodes at the same level. - Tree with large depth. - Tree with a mix of positive, negative, and zero values. Please implement the `deepest_leaves_sum` function accordingly.","solution":"class Node: def __init__(self, value: int) -> None: self.value = value self.left = None self.right = None def deepest_leaves_sum(root: Node) -> int: from collections import deque if not root: return 0 queue = deque([root]) while queue: level_sum = 0 level_size = len(queue) for _ in range(level_size): node = queue.popleft() level_sum += node.value if node.left: queue.append(node.left) if node.right: queue.append(node.right) return level_sum"},{"question":"# Currency Conversion Tool You are tasked with developing a function that converts an amount of money from one currency to several other major currencies. Specifically, you need to write a function that takes an input amount in a specified currency and converts it to US Dollars (USD), Euros (EUR), British Pounds (GBP), Japanese Yen (JPY), and Australian Dollars (AUD). Function Signature ```python def convert_currency(amount: float, currency: str, rates: dict, ndigits: int = 2) -> dict: Converts the given amount of money in the specified currency to several other major currencies. Args: amount: The amount of money to convert (as a float). currency: The currency of the input amount (e.g., \'USD\', \'EUR\', \'GBP\', \'JPY\', \'AUD\'). rates: A dictionary containing the conversion rates to USD for each currency. ndigits: The number of decimal places to round the converted amounts (default is 2). Returns: A dictionary containing the converted amounts in USD, EUR, GBP, JPY, and AUD. Example: >>> convert_currency(100, \'EUR\', {\'USD\': 1.18, \'EUR\': 1.0, \'GBP\': 0.86, \'JPY\': 130.2, \'AUD\': 1.55}) {\'USD\': 118.0, \'EUR\': 100.0, \'GBP\': 86.0, \'JPY\': 13020.0, \'AUD\': 155.0} >>> convert_currency(100, \'JPY\', {\'USD\': 0.0091, \'EUR\': 0.0077, \'GBP\': 0.0066, \'JPY\': 1.0, \'AUD\': 0.0119}) {\'USD\': 0.91, \'EUR\': 0.77, \'GBP\': 0.66, \'JPY\': 100.0, \'AUD\': 1.19} # Your code goes here ``` Input and Output * **Input**: * `amount` (float): The amount of money in the specified currency. * `currency` (str): The currency of the input amount. This could be any of \'USD\', \'EUR\', \'GBP\', \'JPY\', or \'AUD\'. * `rates` (dict): A dictionary containing the conversion rates to USD for each supported currency. * `ndigits` (int): The number of decimal places to which the converted amounts should be rounded (default is 2). * **Output**: - Return a dictionary with the converted amounts in USD, EUR, GBP, JPY, and AUD. The keys of the dictionary should be the currency codes, and the values should be the corresponding converted amounts. Constraints * The input currency will always be one of the allowed values (\'USD\', \'EUR\', \'GBP\', \'JPY\', \'AUD\'), and the amount will be a valid float. * The `rates` dictionary will always contain the conversion rates to USD for each of the supported currencies. Performance Requirements * The function should handle conversion efficiently, with constant time complexity for each conversion.","solution":"def convert_currency(amount: float, currency: str, rates: dict, ndigits: int = 2) -> dict: Converts the given amount of money in the specified currency to several other major currencies. Args: amount: The amount of money to convert (as a float). currency: The currency of the input amount (e.g., \'USD\', \'EUR\', \'GBP\', \'JPY\', \'AUD\'). rates: A dictionary containing the conversion rates to USD for each currency. ndigits: The number of decimal places to round the converted amounts (default is 2). Returns: A dictionary containing the converted amounts in USD, EUR, GBP, JPY, and AUD. # First, convert the amount to USD amount_in_usd = amount / rates[currency] # Then, convert USD to the other currencies converted_amounts = { \'USD\': round(amount_in_usd, ndigits), \'EUR\': round(amount_in_usd * rates[\'EUR\'], ndigits), \'GBP\': round(amount_in_usd * rates[\'GBP\'], ndigits), \'JPY\': round(amount_in_usd * rates[\'JPY\'], ndigits), \'AUD\': round(amount_in_usd * rates[\'AUD\'], ndigits) } return converted_amounts"},{"question":"# Largest Connected Component in a Graph You are developing a social network analytics tool that helps users understand the structure and connectivity of their network. One crucial metric is identifying the largest connected component within a user\'s network of friends. Task: Write a function `largest_connected_component` to find the largest connected component in an undirected graph representing the network. ```python def largest_connected_component(friends: Dict[int, List[int]]) -> List[int]: # implement the function pass ``` Parameters: * **friends** (Dict[int, List[int]]): A dictionary where each key is a user ID (integer) and the value is a list of user IDs (integers) representing the friends of the key user. Returns: * **List[int]**: A list of user IDs representing the members of the largest connected component of the graph. If there are multiple components with the same size, return the one with the smallest user ID first. Details: * An undirected graph is a set of nodes and edges where each edge connects two nodes, and the connection can be traversed in both directions. * A connected component is a subset of nodes such that there is a path between any two nodes within this subset. * You need to return the largest such subset in terms of the number of nodes. Examples: ```python >>> largest_connected_component({1: [2, 3], 2: [1, 4], 3: [1], 4: [2], 5: [6], 6: [5, 7], 7: [6]}) [1, 2, 3, 4] >>> largest_connected_component({1: [2], 2: [1, 3], 3: [2], 4: [5], 5: [4]}) [1, 2, 3] ``` Constraints: * The dictionary `friends` will have no more than 10^4 users. * Each user ID is a unique integer. Notes: * Ensure your solution efficiently handles graphs with a large number of nodes and connections. * Consider using Depth-First Search (DFS) or Breadth-First Search (BFS) to identify connected components. * If the graph is empty (i.e., no users), return an empty list. This task tests your ability to work with graph data structures, traverse graphs to find connected components, and handle large datasets efficiently.","solution":"from typing import Dict, List def largest_connected_component(friends: Dict[int, List[int]]) -> List[int]: def bfs(node): queue = [node] visited.add(node) component = [] while queue: current = queue.pop(0) component.append(current) for neighbor in friends[current]: if neighbor not in visited: visited.add(neighbor) queue.append(neighbor) return sorted(component) visited = set() largest_component = [] for node in friends: if node not in visited: component = bfs(node) if len(component) > len(largest_component): largest_component = component return largest_component"},{"question":"# Coding Assessment Question: Implementing Prime Number Sieve Context: A scientific research team is working on an algorithm to detect the largest prime number below a certain threshold for use in cryptographic applications. To aid their effort, you are asked to implement the Sieve of Eratosthenes algorithm to generate a list of all prime numbers below a given integer `n`. The team also requested that you identify the largest prime in this list efficiently. Your Task: Write a function called `largest_prime_below` that: 1. **Generates all prime numbers** below a given integer `n` using the Sieve of Eratosthenes. 2. **Identifies and returns** the largest prime number from the list. Function Signature: ```python def largest_prime_below(n: int) -> int: Finds the largest prime number below the given integer n using the Sieve of Eratosthenes. :param n: An integer representing the threshold. :return: An integer representing the largest prime number below n. Example: >>> largest_prime_below(20) 19 >>> largest_prime_below(50) 47 >>> largest_prime_below(100) 97 >>> largest_prime_below(2) None ``` # Constraints: * `2 <= n <= 10^6` # Edge Cases: * If `n` is less than or equal to 2, the function should return `None`. Implementation: Ensure the implementation is efficient and handles input sizes up to the maximum constraint. Use appropriate data structures to optimize the Sieve of Eratosthenes and correctly determine the largest prime number in the resulting list.","solution":"def largest_prime_below(n: int) -> int: Finds the largest prime number below the given integer n using the Sieve of Eratosthenes. :param n: An integer representing the threshold. :return: An integer representing the largest prime number below n or None if no such prime exists. if n <= 2: return None sieve = [True] * n sieve[0] = sieve[1] = False p = 2 while p * p < n: if sieve[p]: for i in range(p * p, n, p): sieve[i] = False p += 1 for i in range(n - 1, 1, -1): if sieve[i]: return i return None"},{"question":"# Question: Smallest Subarray with Sum Greater Than K Given an array of positive integers and a target integer ( K ), implement a function `smallest_subarray_with_sum_greater_than_k(arr: List[int], K: int) -> int` that finds the length of the smallest contiguous subarray whose sum is greater than ( K ). If no such subarray exists, return ( 0 ). # Input Format * `arr`: A list of positive integers ([1, 10^6]) with length (0 leq |arr| leq 10^5). * `K`: A positive integer ([1, 10^9]). # Output Format * Return the length of the smallest contiguous subarray whose sum is greater than ( K ). # Constraints * The time complexity should be at most ( O(n) ). # Example ```python >>> smallest_subarray_with_sum_greater_than_k([1, 4, 45, 6, 0, 19], 51) 3 >>> smallest_subarray_with_sum_greater_than_k([1, 10, 5, 2, 7], 9) 1 >>> smallest_subarray_with_sum_greater_than_k([1, 2, 4], 8) 0 ``` # Additional Notes 1. Explain how your algorithm efficiently finds the smallest subarray with a sum greater than ( K ). 2. Consider edge cases like arrays with all elements smaller than ( K ) and arrays with only one element greater than ( K ).","solution":"def smallest_subarray_with_sum_greater_than_k(arr, K): Finds the length of the smallest contiguous subarray whose sum is greater than K. If no such subarray exists, returns 0. n = len(arr) min_length = float(\'inf\') current_sum = 0 start = 0 for end in range(n): current_sum += arr[end] while current_sum > K: min_length = min(min_length, end - start + 1) current_sum -= arr[start] start += 1 return min_length if min_length != float(\'inf\') else 0"},{"question":"Maze Pathfinding Algorithm with Optimizations Create a pathfinding algorithm to navigate through a maze. The provided maze is represented as a 2D grid where \'1\' represents walls and \'0\' represents open pathways. The algorithm should find the shortest path from a given start position to an end position. Additionally, optimize the algorithm for performance and include enhancements for handling various edge cases. # Requirements: 1. **Pathfinding Algorithm**: - Implement the A* algorithm to find the shortest path through the maze. - The algorithm should be able to handle different heuristic functions (Manhattan distance, Euclidean distance) with an optional parameter to select the heuristic. 2. **Edge Case Handling**: - Ensure the algorithm manages mazes with no possible paths and returns an appropriate response. - Handle cases with multiple equally shortest paths, ensuring consistency in output. 3. **Performance Enhancement**: - Introduce optimizations in the data structure used for the open and closed sets to improve efficiency. - Ensure the algorithm is efficient in terms of both time and space complexity. 4. **Visualization**: - Add functionality to visualize the maze with the path found by the algorithm for better understanding and debugging. 5. **Documentation**: - Document the code with clear comments explaining each part of the algorithm. # Specification: - Input: - A 2D list representing the maze. - Start position as a tuple (row, col). - End position as a tuple (row, col). - Output: - List of tuples representing the path from start to end. If no path exists, return an empty list. - Constraints: - The start and end positions are guaranteed to be \'0\'. - The maze dimensions can vary, and the algorithm should handle large mazes efficiently. # Deliverables: - Complete the implementation of the pathfinding algorithm. - Demonstrate the algorithm by finding and visualizing the shortest path on sample maze data. - Provide a brief report including the challenges faced, design decisions, optimizations made, and the results obtained. ```python Enhanced Pathfinding Algorithm for Maze Navigation import heapq class Cell: def __init__(self, x, y, parent=None): self.x = x self.y = y self.parent = parent self.g = 0 self.h = 0 self.f = 0 def __lt__(self, other): return self.f < other.f class AStarPathfinder: def __init__(self, heuristic=\'manhattan\'): self.heuristic = heuristic def heuristic_cost_estimate(self, start, goal): if self.heuristic == \'manhattan\': return abs(start[0] - goal[0]) + abs(start[1] - goal[1]) elif self.heuristic == \'euclidean\': return ((start[0] - goal[0]) ** 2 + (start[1] - goal[1]) ** 2) ** 0.5 def find_path(self, maze, start, end): open_set = [] heapq.heappush(open_set, Cell(start[0], start[1])) closed_set = set() nodes = [[Cell(i, j) for j in range(len(maze[0]))] for i in range(len(maze))] while open_set: current = heapq.heappop(open_set) closed_set.add((current.x, current.y)) if (current.x, current.y) == end: return self.construct_path(current) neighbors = self.get_neighbors(maze, current, nodes) for neighbor in neighbors: if (neighbor.x, neighbor.y) in closed_set: continue tentative_g_score = current.g + 1 if tentative_g_score < neighbor.g or (neighbor.x, neighbor.y) not in open_set: neighbor.parent = current neighbor.g = tentative_g_score neighbor.h = self.heuristic_cost_estimate((neighbor.x, neighbor.y), end) neighbor.f = neighbor.g + neighbor.h if (neighbor.x, neighbor.y) not in open_set: heapq.heappush(open_set, neighbor) return [] def get_neighbors(self, maze, cell, nodes): neighbors = [] directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] for direction in directions: neighbor_x, neighbor_y = cell.x + direction[0], cell.y + direction[1] if self.is_within_bounds(maze, neighbor_x, neighbor_y) and maze[neighbor_x][neighbor_y] == 0: neighbors.append(nodes[neighbor_x][neighbor_y]) return neighbors def is_within_bounds(self, maze, x, y): return 0 <= x < len(maze) and 0 <= y < len(maze[0]) def construct_path(self, cell): path = [] while cell: path.append((cell.x, cell.y)) cell = cell.parent return path[::-1] if __name__ == \\"__main__\\": Example demonstrating the enhanced pathfinding functionality. maze = [ [0, 1, 0, 0, 0, 0], [0, 1, 0, 1, 1, 0], [0, 0, 0, 1, 0, 0], [0, 1, 0, 0, 0, 0], [0, 0, 0, 1, 1, 0], [0, 1, 0, 0, 0, 0], ] start = (0, 0) end = (5, 5) pathfinder = AStarPathfinder(heuristic=\'manhattan\') path = pathfinder.find_path(maze, start, end) print(\\"Path found:\\", path) # Visualize the maze and the path for r in range(len(maze)): for c in range(len(maze[0])): if (r, c) in path: print(\\"P\\", end=\\" \\") elif maze[r][c] == 1: print(\\"#\\", end=\\" \\") else: print(\\".\\", end=\\" \\") print() ```","solution":"Enhanced Pathfinding Algorithm for Maze Navigation import heapq class Cell: def __init__(self, x, y, parent=None): self.x = x self.y = y self.parent = parent self.g = 0 self.h = 0 self.f = 0 def __lt__(self, other): return self.f < other.f class AStarPathfinder: def __init__(self, heuristic=\'manhattan\'): self.heuristic = heuristic def heuristic_cost_estimate(self, start, goal): if self.heuristic == \'manhattan\': return abs(start[0] - goal[0]) + abs(start[1] - goal[1]) elif self.heuristic == \'euclidean\': return ((start[0] - goal[0]) ** 2 + (start[1] - goal[1]) ** 2) ** 0.5 def find_path(self, maze, start, end): open_set = [] heapq.heappush(open_set, Cell(start[0], start[1])) closed_set = set() nodes = [[Cell(i, j) for j in range(len(maze[0]))] for i in range(len(maze))] while open_set: current = heapq.heappop(open_set) closed_set.add((current.x, current.y)) if (current.x, current.y) == end: return self.construct_path(current) neighbors = self.get_neighbors(maze, current, nodes) for neighbor in neighbors: if (neighbor.x, neighbor.y) in closed_set: continue tentative_g_score = current.g + 1 if tentative_g_score < neighbor.g or (neighbor.x, neighbor.y) not in open_set: neighbor.parent = current neighbor.g = tentative_g_score neighbor.h = self.heuristic_cost_estimate((neighbor.x, neighbor.y), end) neighbor.f = neighbor.g + neighbor.h if (neighbor.x, neighbor.y) not in open_set: heapq.heappush(open_set, neighbor) return [] def get_neighbors(self, maze, cell, nodes): neighbors = [] directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] for direction in directions: neighbor_x, neighbor_y = cell.x + direction[0], cell.y + direction[1] if self.is_within_bounds(maze, neighbor_x, neighbor_y) and maze[neighbor_x][neighbor_y] == 0: neighbors.append(nodes[neighbor_x][neighbor_y]) return neighbors def is_within_bounds(self, maze, x, y): return 0 <= x < len(maze) and 0 <= y < len(maze[0]) def construct_path(self, cell): path = [] while cell: path.append((cell.x, cell.y)) cell = cell.parent return path[::-1] if __name__ == \\"__main__\\": Example demonstrating the enhanced pathfinding functionality. maze = [ [0, 1, 0, 0, 0, 0], [0, 1, 0, 1, 1, 0], [0, 0, 0, 1, 0, 0], [0, 1, 0, 0, 0, 0], [0, 0, 0, 1, 1, 0], [0, 1, 0, 0, 0, 0], ] start = (0, 0) end = (5, 5) pathfinder = AStarPathfinder(heuristic=\'manhattan\') path = pathfinder.find_path(maze, start, end) print(\\"Path found:\\", path) # Visualize the maze and the path for r in range(len(maze)): for c in range(len(maze[0])): if (r, c) in path: print(\\"P\\", end=\\" \\") elif maze[r][c] == 1: print(\\"#\\", end=\\" \\") else: print(\\".\\", end=\\" \\") print()"},{"question":"# Context: You are working with a data processing system that employs a custom sorting algorithm for performance optimization. The task is to extend its functionality to support sorting of data based on multiple criteria. The system should be able to handle complex sorting requirements effectively and accommodate edge cases for robust performance. # Problem: 1. Write a method `multi_sort(self, criteria)` that sorts a list of dictionaries based on multiple keys provided in the criteria. The sorting should be stable and should maintain relative order of records when values match. 2. Write a method `subset_sort(self, start_index, end_index)` that sorts a subset of the data in place, defined from `start_index` to `end_index` (inclusive). # Implementation Details: - Class definition: `class CustomSorter:` - Methods to implement: * `def multi_sort(self, criteria):` * `def subset_sort(self, start_index, end_index):` # Input: - `multi_sort(self, criteria)` takes a single parameter: * `criteria` (list of tuples): Each tuple contains a key (string) and a boolean flag indicating ascending (True) or descending (False) order. - `subset_sort(self, start_index, end_index)` takes two parameters: * `start_index` (int): The starting index of the subset to be sorted. * `end_index` (int): The ending index of the subset to be sorted. # Output: - `multi_sort(self, criteria)` will sort the data in place based on the given criteria and return `None`. - `subset_sort(self, start_index, end_index)` will sort the specified subset of data in place and return `None`. # Constraints: - Assume the data is a list of dictionaries where each dictionary has keys corresponding to the sorting criteria. - `start_index` and `end_index` will be valid indices within the list. - The length of the list will not exceed 10,000 elements. # Performance Requirements: - `multi_sort(self, criteria)` should have an average time complexity of O(n log n), where n is the number of elements in the list. - `subset_sort(self, start_index, end_index)` should optimally handle sorting within the range defined. # Example Usage: ```python custom_sorter = CustomSorter(data=[ {\'name\': \'Alice\', \'age\': 30, \'score\': 88}, {\'name\': \'Bob\', \'age\': 25, \'score\': 95}, {\'name\': \'Charlie\', \'age\': 30, \'score\': 90}, {\'name\': \'Dave\', \'age\': 25, \'score\': 85} ]) # Sorting based on multiple criteria: age ascending and then score descending custom_sorter.multi_sort([(\'age\', True), (\'score\', False)]) # Sorting a subset from index 1 to 3 custom_sorter.subset_sort(1, 3) ```","solution":"class CustomSorter: def __init__(self, data): self.data = data def multi_sort(self, criteria): for key, reverse in reversed(criteria): self.data.sort(key=lambda x: x[key], reverse=not reverse) def subset_sort(self, start_index, end_index): subset = self.data[start_index:end_index+1] subset.sort() self.data[start_index:end_index+1] = subset"},{"question":"File Processing for Employee Records You have been hired to write a function that reads and processes employee records from a text file. Each employee record is on a single line and contains the following comma-separated fields: `id`, `name`, `age`, `department`, and `salary`. Your task is to implement a function that reads the file, processes the data, and returns a list of employee data dictionaries, sorted by employee `id` in ascending order. # Function Signature ```python def process_employee_records(file_path: str) -> list: ``` # Input: - `file_path` (str): A string representing the path to the file containing the employee records. # Output: - Returns a list of dictionaries, where each dictionary represents an employee with the following keys: - `\'id\'` (int): The employee\'s id. - `\'name\'` (str): The employee\'s name. - `\'age\'` (int): The employee\'s age. - `\'department\'` (str): The employee\'s department. - `\'salary\'` (float): The employee\'s salary. # Constraints: - The input file is guaranteed to exist and is readable. - Each employee record is correctly formatted with valid data. - You must sort the employees by their `id` in ascending order. # Example: Assume the content of the file at `file_path` is: ``` 1,John Doe,30,Engineering,70000 2,Jane Smith,35,Marketing,65000 3,Emily Davis,28,Sales,60000 ``` ```python process_employee_records(\\"employees.txt\\") ``` The function should return: ```python [ {\\"id\\": 1, \\"name\\": \\"John Doe\\", \\"age\\": 30, \\"department\\": \\"Engineering\\", \\"salary\\": 70000.0}, {\\"id\\": 2, \\"name\\": \\"Jane Smith\\", \\"age\\": 35, \\"department\\": \\"Marketing\\", \\"salary\\": 65000.0}, {\\"id\\": 3, \\"name\\": \\"Emily Davis\\", \\"age\\": 28, \\"department\\": \\"Sales\\", \\"salary\\": 60000.0} ] ``` # Notes: - Ensure to handle file reading and parsing appropriately. - Handle any potential exceptions that could arise from reading files or data conversion. - Ensure the returned employee list is sorted by `id` in ascending order.","solution":"def process_employee_records(file_path: str) -> list: Reads and processes employee records from a file and returns a sorted list of dictionaries. Each dictionary represents an employee with the keys: \'id\', \'name\', \'age\', \'department\', and \'salary\'. The returned list is sorted by employee \'id\' in ascending order. with open(file_path, \'r\') as file: lines = file.readlines() employees = [] for line in lines: id, name, age, department, salary = line.strip().split(\',\') employees.append({ \'id\': int(id), \'name\': name, \'age\': int(age), \'department\': department, \'salary\': float(salary) }) employees.sort(key=lambda employee: employee[\'id\']) return employees"},{"question":"# Sorting Expressions with Custom Order Assessment Context You are to implement a sorting function that sorts strings based on a custom alphabetical order. For instance, if the custom order is `\\"dbcafghijklmnopqrstuvwxyz\\"`, the letter `d` should be considered smallest, followed by `b`, `c`, `a`, and so on. This will help ensure comprehension of string manipulation, sorting algorithms, and custom comparator functions. Task 1. **Implement the Custom Sorting Function**: - Write a function that takes a list of strings and a custom alphabetical order string, then sorts the list based on the custom order. 2. **Handle Edge Cases**: - Ensure that the function can handle the scenarios where the input string list might contain strings with characters not specified in the custom order by placing these strings at the end of the sorted list. 3. **Maintain Stability**: - If two strings are equal in positioning based on the custom alphabetical order, maintain their relative order from the input list (which means the sort should be stable). Expected Function Implementation 1. **Custom Sorting Function**: ```python def custom_sort(strings: List[str], custom_order: str) -> List[str]: # Your code here ``` Input and Output **Input**: - A list of strings (e.g., `[\\"cat\\", \\"bat\\", \\"apple\\", \\"dog\\", \\"elephant\\"]`) - A custom alphabetical order string (e.g., `\\"dbcafghijklmnopqrstuvwxyz\\"`) **Output**: - A list of strings sorted based on the custom order (e.g., `[\\"dog\\", \\"bat\\", \\"cat\\", \\"apple\\", \\"elephant\\"]`) Constraints - The strings in the input list will each have a length of at most 100 characters. - The custom order string will have a length of 26 characters without any repetitions. - The individual strings in the list and the custom order string will only contain lowercase English letters. - The list of strings will have at most 1000 elements. Scenario Implement the required function to sort a list of strings according to the specified custom alphabetical order. Ensure the edge cases are properly handled and the sorting is stable. Evaluate the correctness of the implementation with a series of test cases covering various scenarios.","solution":"from typing import List def custom_sort(strings: List[str], custom_order: str) -> List[str]: # Create a priority dictionary based on custom order order_dict = {char: index for index, char in enumerate(custom_order)} # Define a custom key function for sorting def custom_key(word): # Convert each character in the string to its corresponding priority return [order_dict.get(char, len(custom_order)) for char in word] # Sort the strings using the custom key function, ensuring stability return sorted(strings, key=custom_key)"},{"question":"# Finding Cycles in an Undirected Graph **Context:** You are given an undirected graph represented by `n` vertices and `m` edges. Your task is to determine if the graph contains any cycles. A cycle is a path of edges and vertices wherein a vertex is reachable from itself. **Function Signature:** ```python def has_cycle(n: int, edges: List[Tuple[int, int]]) -> bool: ``` **Input:** * `n`: An integer representing the number of vertices (0 <= n <= 10^5). * `edges`: A list of tuples, where each tuple (u, v) represents an undirected edge between vertex `u` and vertex `v`. **Output:** * A boolean value. Return `True` if the graph contains any cycles, `False` otherwise. **Constraints:** * 1 <= m <= 2*10^5 * The vertices are zero-indexed. **Performance Requirements:** * The solution must efficiently handle the upper constraint limits for both time and space. **Example:** ```python # Example 1 n = 4 edges = [(0, 1), (1, 2), (2, 3), (3, 1)] has_cycle(n, edges) # Output: True # Example 2 n = 3 edges = [(0, 1), (1, 2)] has_cycle(n, edges) # Output: False ``` **Assignment:** Implement the `has_cycle` function to detect cycles in an undirected graph using Depth First Search (DFS) based on the provided signature. **Evaluation Criteria:** * Correctness and Efficiency of the solution. * Handling of edge cases. * Clarity and readability of the implemented code.","solution":"from typing import List, Tuple def has_cycle(n: int, edges: List[Tuple[int, int]]) -> bool: def dfs(v, parent): visited[v] = True for neighbor in adjacency_list[v]: if not visited[neighbor]: if dfs(neighbor, v): return True elif neighbor != parent: return True return False if n <= 1: return False adjacency_list = [[] for _ in range(n)] for u, v in edges: adjacency_list[u].append(v) adjacency_list[v].append(u) visited = [False] * n for i in range(n): if not visited[i]: if dfs(i, -1): return True return False"},{"question":"# Coding Assessment Question: Background In certain cryptographic systems, matrices are used to transform plaintext into ciphertext through multiplication. Understanding and manipulating matrices is crucial in fields such as cryptography, graphics, and scientific computing. Task Implement a function `matrix_transformation(matrix_1, matrix_2)` that takes two square matrices of the same dimension and returns their product. The function should meet the following requirements: - **Input**: - `matrix_1`: A list of lists representing the first square matrix (n x n). - `matrix_2`: A list of lists representing the second square matrix (n x n). - **Output**: - A list of lists representing the product of the two matrices. - **Constraints**: - The elements of the matrices should be integers. - Raise a `ValueError` if the matrices are not square or if they do not have the same dimensions. Function Signature ```python def matrix_transformation(matrix_1: list[list[int]], matrix_2: list[list[int]]) -> list[list[int]]: pass ``` Examples ```python matrix_1 = [ [1, 2], [3, 4] ] matrix_2 = [ [2, 0], [1, 2] ] assert matrix_transformation(matrix_1, matrix_2) == [ [4, 4], [10, 8] ] matrix_1 = [ [1, 0, 0], [0, 1, 0], [0, 0, 1] ] matrix_2 = [ [2, 3, 4], [1, 0, 0], [0, 0, 5] ] assert matrix_transformation(matrix_1, matrix_2) == [ [2, 3, 4], [1, 0, 0], [0, 0, 5] ] ``` Additional Notes - Assume matrix dimensions are always valid square matrices as inputs unless they violate the constraints mentioned. - The matrix multiplication follows the standard mathematical rules: `(AB)_{ij} = Σ(A_{ik} * B_{kj})`. # Solution Example Here is a possible implementation: ```python def matrix_transformation(matrix_1, matrix_2): n = len(matrix_1) if n != len(matrix_2) or any(len(row) != n for row in matrix_1) or any(len(row) != n for row in matrix_2): raise ValueError(\\"Both matrices must be square and of the same dimensions.\\") result = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): result[i][j] = sum(matrix_1[i][k] * matrix_2[k][j] for k in range(n)) return result ``` Replace this solution example with the actual implementation in your test system.","solution":"def matrix_transformation(matrix_1, matrix_2): n = len(matrix_1) if n != len(matrix_2) or any(len(row) != n for row in matrix_1) or any(len(row) != n for row in matrix_2): raise ValueError(\\"Both matrices must be square and of the same dimensions.\\") result = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): result[i][j] = sum(matrix_1[i][k] * matrix_2[k][j] for k in range(n)) return result"},{"question":"# Problem Statement You are tasked with implementing a class called `VectorOperations` that performs various vector arithmetic operations for two-dimensional vectors. Your implementation should handle the basic operations of addition, subtraction, dot product, and cross product. # Function Signature ```python class VectorOperations: def __init__(self): pass def add(self, vector1, vector2): pass def subtract(self, vector1, vector2): pass def dot_product(self, vector1, vector2): pass def cross_product(self, vector1, vector2): pass ``` # Implementation Details Class Initialization * **Constructor**: - Does not require any parameter and should initialize the class. Methods to Implement * **add**: Vector addition. - Input: Two vectors `vector1` and `vector2` represented as lists of two numbers. - Output: A vector representing the sum of `vector1` and `vector2`. * **subtract**: Vector subtraction. - Input: Two vectors `vector1` and `vector2` represented as lists of two numbers. - Output: A vector representing the difference `vector1` - `vector2`. * **dot_product**: Dot product of two vectors. - Input: Two vectors `vector1` and `vector2` represented as lists of two numbers. - Output: A scalar representing the dot product of `vector1` and `vector2`. * **cross_product**: Cross product of two vectors. - Input: Two vectors `vector1` and `vector2` represented as lists of two numbers. - Output: A scalar representing the cross product (technically the Z-component) of `vector1` and `vector2`. Constraints 1. Both `vector1` and `vector2` are lists containing exactly two integers or floats. # Example Usage ```python # Initialize the operations class vec_ops = VectorOperations() # Vectors v1 = [2, 3] v2 = [4, 1] # Perform operations sum_result = vec_ops.add(v1, v2) sub_result = vec_ops.subtract(v1, v2) dot_result = vec_ops.dot_product(v1, v2) cross_result = vec_ops.cross_product(v1, v2) print(\\"Addition:\\", sum_result) print(\\"Subtraction:\\", sub_result) print(\\"Dot Product:\\", dot_result) print(\\"Cross Product:\\", cross_result) ``` # Expected Output ```plaintext Addition: [6, 4] Subtraction: [-2, 2] Dot Product: 11 Cross Product: -10 ``` Submit your implementation of the `VectorOperations` class.","solution":"class VectorOperations: def __init__(self): pass def add(self, vector1, vector2): return [vector1[0] + vector2[0], vector1[1] + vector2[1]] def subtract(self, vector1, vector2): return [vector1[0] - vector2[0], vector1[1] - vector2[1]] def dot_product(self, vector1, vector2): return vector1[0] * vector2[0] + vector1[1] * vector2[1] def cross_product(self, vector1, vector2): return vector1[0] * vector2[1] - vector1[1] * vector2[0]"},{"question":"# Sorting a List of Student Objects by GPA **Objective**: Create a Python class to manage a list of students and implement the functionality to sort this list based on GPA in descending order. **Requirements**: 1. Implement the `Student` class which includes: - **Initialization (`__init__(self, name: str, gpa: float)`)**: Construct a student with a given name and GPA. - **`__repr__(self)`**: Provide a string representation of the student in the format `name (GPA)`. 2. Implement the `StudentManager` class which supports the following operations: - **Initialization (`__init__(self)`)**: Construct an empty student manager. - **`add_student(self, name: str, gpa: float)`**: Add a student to the manager. - **`remove_student(self, name: str)`**: Remove a student by their name. - **`sort_by_gpa_desc(self)`**: Sort the list of students by GPA in descending order. **Inputs**: - `name`: A string representing the student\'s name. - `gpa`: A float representing the student\'s GPA. **Outputs**: - Various methods will behave accordingly, such as returning a sorted list or confirming the addition/removal of students. **Constraints**: - GPA should be a float between 0.0 and 4.0. - Student names should be unique within the manager. - Ensure robust handling of edge cases, such as attempting to remove a non-existent student. **Testing**: You should write test cases to verify the correctness of the implementation, particularly focusing on adding, removing, and sorting students. **Example Usage**: ```python class Student: def __init__(self, name: str, gpa: float): self.name = name self.gpa = gpa def __repr__(self): return f\\"{self.name} ({self.gpa})\\" class StudentManager: def __init__(self): self.students = [] def add_student(self, name: str, gpa: float): self.students.append(Student(name, gpa)) def remove_student(self, name: str): self.students = [student for student in self.students if student.name != name] def sort_by_gpa_desc(self): self.students.sort(key=lambda student: student.gpa, reverse=True) # Example usage: manager = StudentManager() manager.add_student(\\"Alice\\", 3.5) manager.add_student(\\"Bob\\", 3.8) manager.add_student(\\"Charlie\\", 3.2) print(manager.students) # Output: [Alice (3.5), Bob (3.8), Charlie (3.2)] manager.sort_by_gpa_desc() print(manager.students) # Output: [Bob (3.8), Alice (3.5), Charlie (3.2)] manager.remove_student(\\"Alice\\") print(manager.students) # Output: [Bob (3.8), Charlie (3.2)] ```","solution":"class Student: def __init__(self, name: str, gpa: float): self.name = name self.gpa = gpa def __repr__(self): return f\\"{self.name} ({self.gpa})\\" class StudentManager: def __init__(self): self.students = [] def add_student(self, name: str, gpa: float): self.students.append(Student(name, gpa)) def remove_student(self, name: str): self.students = [student for student in self.students if student.name != name] def sort_by_gpa_desc(self): self.students.sort(key=lambda student: student.gpa, reverse=True)"},{"question":"# Palindrome Substring Check You are required to implement a function `is_palindromic_substring` that checks if a specific substring of the input string is a palindrome. The function should return `True` if the substring is a palindrome, and `False` otherwise. Function Signature ```python def is_palindromic_substring(input_string: str, start: int, end: int) -> bool: ``` # Input * `input_string` (str): A non-empty string of characters. * `start` (int): The starting index of the substring (inclusive). * `end` (int): The ending index of the substring (inclusive). # Output * Return `True` if the specific substring from `start` to `end` is a palindrome, `False` otherwise. # Constraints * The length of `input_string` will be at most 1000 characters. * `0 <= start <= end < len(input_string)`. # Performance Requirements The function should be efficient enough to handle the maximum input size under reasonable time limits. # Example ```python # Example 1: input_string = \\"racecar\\" start = 0 end = 6 print(is_palindromic_substring(input_string, start, end)) # Output: True # Example 2: input_string = \\"level\\" start = 0 end = 4 print(is_palindromic_substring(input_string, start, end)) # Output: True # Example 3: input_string = \\"hello\\" start = 1 end = 3 print(is_palindromic_substring(input_string, start, end)) # Output: False ``` # Guidelines 1. Check the substring boundaries to ensure they fall within the given input string length. 2. Create a helper function that will determine if a given substring is a palindrome by comparing characters from the start and end indices moving towards the center. 3. Avoid using extra space for storing the substring; manipulate indices directly to determine if the substring is a palindrome. 4. Handle edge cases such as single-character substrings gracefully.","solution":"def is_palindromic_substring(input_string: str, start: int, end: int) -> bool: Checks if the substring of input_string from start to end (inclusive) is a palindrome. while start < end: if input_string[start] != input_string[end]: return False start += 1 end -= 1 return True"},{"question":"# Question: Maze Solver with Backtracking You are tasked with writing a class `Maze` that solves a given maze using the backtracking algorithm. The maze is represented as a 2D grid where \'0\' represents an open path and \'1\' represents a wall. The goal is to find a path from the upper-left corner (0, 0) to the bottom-right corner (n-1, n-1), moving only through open paths (0s). # Task 1. Implement the `Maze` class with the following methods: - `is_safe`: Check if a given cell (row, column) can be included in the path. - `solve_maze`: Find the path from the start to the goal using backtracking. # Requirements 1. **Implement** the following methods in the `Maze` class: - `is_safe`: to check if moving to a cell (row, column) is safe (i.e., within bounds and not a wall). - `solve_maze`: to solve the maze starting from the upper-left corner and ending at the bottom-right corner. 2. **Output**: - The maze with the path represented by a specific marker, say \'P\', from start to goal. - If no path exists, return the original maze grid. # Input: - A 2D list representing the maze grid. # Output: - The maze grid with the path marked, if exists. # Constraints: - You can move in four directions only: up, down, left, and right. - The maze grid size will be at most 10x10. # Example: ```python maze = [ [0, 1, 0, 0, 0, 0, 0], [0, 1, 0, 1, 1, 1, 0], [0, 0, 0, 0, 0, 1, 0], [0, 1, 1, 1, 0, 1, 0], [1, 1, 0, 0, 0, 0, 0], [0, 0, 0, 1, 1, 1, 0], [0, 1, 0, 0, 0, 0, 0] ] m = Maze(maze) if m.solve_maze(): m.print_maze_with_path() else: print(\\"No path found\\") ``` # Function Signatures: 1. `def is_safe(self, row: int, col: int) -> bool:` 2. `def solve_maze(self) -> bool:` # Example Output: If a path exists, the maze grid could be modified to: ``` [ [\'P\', \'1\', \'P\', \'P\', \'P\', \'P\', \'0\'], [\'P\', \'1\', \'P\', \'1\', \'1\', \'1\', \'0\'], [\'P\', \'P\', \'P\', \'P\', \'P\', \'1\', \'0\'], [\'0\', \'1\', \'1\', \'1\', \'P\', \'1\', \'0\'], [\'1\', \'1\', \'0\', \'0\', \'P\', \'P\', \'P\'], [\'0\', \'0\', \'0\', \'1\', \'1\', \'1\', \'P\'], [\'0\', \'1\', \'0\', \'0\', \'0\', \'0\', \'P\'] ] ``` If no path found, print `No path found`. # Note: Ensure that your backtracking algorithm efficiently finds a path, if one exists, within the provided grid constraints.","solution":"class Maze: def __init__(self, maze): self.maze = maze self.n = len(maze) self.path_found = False self.path = [[0] * self.n for _ in range(self.n)] def is_safe(self, row, col): Checks if a cell (row, col) is a valid move. return 0 <= row < self.n and 0 <= col < self.n and self.maze[row][col] == 0 and self.path[row][col] == 0 def solve_maze(self): Solves the maze using backtracking algorithm. if self._solve_maze_util(0, 0): self.path_found = True self._mark_path() return True else: return False def _solve_maze_util(self, row, col): Utility function to solve the maze using backtracking. # If (row, col) is the goal, mark it and return True if row == self.n - 1 and col == self.n - 1: self.path[row][col] = 1 return True # Check if maze[row][col] is a valid move if self.is_safe(row, col): # Mark the cell as part of the solution path self.path[row][col] = 1 # Move forward in each direction - down, right, up, left if self._solve_maze_util(row + 1, col): return True if self._solve_maze_util(row, col + 1): return True if self._solve_maze_util(row - 1, col): return True if self._solve_maze_util(row, col - 1): return True # If none of the above movements work, unmark the cell (backtrack) self.path[row][col] = 0 return False def _mark_path(self): Marks the path found in the original maze. for row in range(self.n): for col in range(self.n): if self.path[row][col] == 1: self.maze[row][col] = \'P\' def print_maze_with_path(self): Prints the maze with the path marked. for row in self.maze: print(\' \'.join(str(cell) for cell in row))"},{"question":"# Task: Unique Email Address Formatter Scenario As part of an email validation system, you need to process email addresses and ensure they all have a unique format for future business communications. For simplifying the email handling, you\'ll follow specific rules to standardize the email addresses. Construct a function `unique_email_formatter(email: str) -> str` which, given an email address, returns a standardized and unique format. The rules for standardizing are as follows: - Any dots (\'.\') before the \'@\' symbol should be removed. - Any substring after a plus (\'+\') and before the \'@\' symbol should be ignored. - Nothing after the \'@\' symbol should be modified. Input - `email` (str): A valid email address, such as \\"user.name+extension@example.com\\". Output - Returns a string representing the standardized email address, such as \\"username@example.com\\". Constraints - The email address will always be in a valid format containing an \'@\' symbol and a domain. - Length of the email address will not exceed 320 characters. Performance Requirements - The function should be able to process up to 1,000 email addresses per minute without significant performance degradation. # Implementation Implement the function following these requirements and consider the described edge cases, performance bottlenecks, and potential error scenarios. Example ```python print(unique_email_formatter(\\"user.name+extension@example.com\\")) # Returns \\"username@example.com\\" print(unique_email_formatter(\\"user.name.email+filter@domain.com\\")) # Returns \\"useremail@domain.com\\" ``` **Note:** 1. Focus on string manipulation to meet the requirements precisely. 2. Be sure to handle emails with no plus (\'+\') or dots (\'.\') appropriately.","solution":"def unique_email_formatter(email: str) -> str: Transforms the given email to a standardized unique format: - Removes any dots before the \'@\' symbol. - Ignores any substring after a plus (\'+\') and before the \'@\' symbol. - Leaves the part after the \'@\' symbol unchanged. Args: email (str): The original email address. Returns: str: The standardized email address. local, domain = email.split(\'@\') # Ignore substring after \'+\' if any if \'+\' in local: local = local.split(\'+\')[0] # Remove all dots from the local part local = local.replace(\'.\', \'\') return f\\"{local}@{domain}\\""},{"question":"# Context In a recent software system upgrade, you were given the responsibility to enhance the logging system which records various events happening within the system. One critical requirement is to filter and aggregate logs based on time intervals for analysis purposes. This requires efficiently managing and querying log entries. # Task Using the provided `LogAggregator` class, you need to write methods that can do the following: 1. Add a log entry with a timestamp. 2. Retrieve all logs within a specified time range. Implement the class with the following specifications: # Class Definition ```python class LogAggregator: def __init__(self): self.logs = [] def add_log(self, timestamp: int, log_entry: str) -> None: Adds a log entry to the list of logs. Args: timestamp (int): The timestamp of the log entry. log_entry (str): The log entry message. self.logs.append((timestamp, log_entry)) def get_logs_in_range(self, start: int, end: int) -> list[str]: Retrieves all log entries within the specified time range [start, end]. Args: start (int): The start timestamp. end (int): The end timestamp. Returns: list[str]: A list of log entries within the time range. return [log for (timestamp, log) in self.logs if start <= timestamp <= end] ``` # Example ```python aggregator = LogAggregator() aggregator.add_log(1627889187, \\"System rebooted.\\") aggregator.add_log(1627889200, \\"User login.\\") aggregator.add_log(1627889300, \\"File uploaded.\\") logs_in_range = aggregator.get_logs_in_range(1627889187, 1627889200) print(logs_in_range) # Output: [\\"System rebooted.\\", \\"User login.\\"] logs_in_range = aggregator.get_logs_in_range(1627889300, 1627889300) print(logs_in_range) # Output: [\\"File uploaded.\\"] ``` # Note - Ensure that the `LogAggregator` effectively handles a large number of log entries (up to (10^6)). - The timestamps will be non-negative integers representing Unix time in seconds. - The log entries are non-empty strings and can be up to 500 characters long. - The start and end timestamps provided in `get_logs_in_range` method should be inclusive.","solution":"class LogAggregator: def __init__(self): self.logs = [] def add_log(self, timestamp: int, log_entry: str) -> None: Adds a log entry to the list of logs. Args: timestamp (int): The timestamp of the log entry. log_entry (str): The log entry message. self.logs.append((timestamp, log_entry)) def get_logs_in_range(self, start: int, end: int) -> list[str]: Retrieves all log entries within the specified time range [start, end]. Args: start (int): The start timestamp. end (int): The end timestamp. Returns: list[str]: A list of log entries within the time range. return [log for (timestamp, log) in self.logs if start <= timestamp <= end]"},{"question":"# Coding Assessment Question Context Imagine you are developing a system for a bookstore where you need to manage a stock of books. One common task is to identify all the books that are currently out of stock. Task Write a function `out_of_stock_books` that takes a single list parameter `books` and returns a list of titles of the books that are out of stock. * **Input**: * `books` (list of dict): A list where each dictionary contains information about a book with keys `title` (str) and `stock` (int). * **Output**: * A list of strings representing the titles of the books that have `stock` set to 0. For example: ```python >>> books = [ {\\"title\\": \\"Book A\\", \\"stock\\": 10}, {\\"title\\": \\"Book B\\", \\"stock\\": 0}, {\\"title\\": \\"Book C\\", \\"stock\\": 2}, {\\"title\\": \\"Book D\\", \\"stock\\": 0} ] >>> out_of_stock_books(books) [\'Book B\', \'Book D\'] ``` Constraints * The input `books` will be a list of dictionaries where each dictionary contains `title` (a non-empty string) and `stock` (a non-negative integer). * Each book title is unique within the list. * The list will contain at most 100,000 books. Requirements * The solution should efficiently iterate through the list and collect titles with a `stock` of 0. * Ensure proper handling of different edge cases, such as an empty list of books. * Your function should process the input efficiently, ensuring at most `O(n)` time complexity. Edge Cases: * Handle cases where `books` list is empty. * Ensure `stock` values are properly checked and titles are correctly identified even if all books are in stock. # Example The following illustrates the expected result: ```python >>> books = [ {\\"title\\": \\"Book E\\", \\"stock\\": 5}, {\\"title\\": \\"Book F\\", \\"stock\\": 0} ] >>> out_of_stock_books(books) [\'Book F\'] >>> out_of_stock_books([]) [] ``` # Implement the function below: ```python def out_of_stock_books(books): # Your code here pass ```","solution":"def out_of_stock_books(books): Returns a list of titles of books that are out of stock. :param books: List of dictionaries, where each dictionary contains \'title\' (str) and \'stock\' (int) :return: List of titles of books with stock equal to 0 return [book[\'title\'] for book in books if book[\'stock\'] == 0]"},{"question":"# Optimal Meeting Point in a 1D Grid Given a list of integers representing the positions of meeting attendees in a 1-dimensional grid, write a function to determine the optimal meeting point that minimizes the sum of the travel distances for all attendees. Note that the attendees can only move along the grid. You need to implement the function `optimal_meeting_point`, which takes in a list of integers representing the positions of the attendees and returns the optimal meeting point as an integer. # Function Definition and Signature ```python def optimal_meeting_point(positions: list[int]) -> int: Determine the optimal meeting point in a 1D grid that minimizes the total travel distance for all attendees. Parameters: positions (list of int): A list of integers representing the positions of attendees. Returns: int: The optimal meeting point that minimizes travel distances. ``` # Constraints - The length of the positions list will not exceed 100. - The positions will be positive integers up to (10^{6}). # Input - `positions`: A list of integers representing the positions of attendees. # Output - The optimal meeting point as an integer. # Examples ```python >>> optimal_meeting_point([1, 2, 3]) 2 >>> optimal_meeting_point([1, 2, 6]) 2 >>> optimal_meeting_point([10, 15, 17, 20]) 17 ``` # Additional Note The optimal meeting point in a 1-dimensional grid corresponds to the median of the list of positions, as the sum of absolute deviations from the median is minimized compared to any other point. Implement your solution accordingly.","solution":"def optimal_meeting_point(positions: list[int]) -> int: Determine the optimal meeting point in a 1D grid that minimizes the total travel distance for all attendees. Parameters: positions (list of int): A list of integers representing the positions of attendees. Returns: int: The optimal meeting point that minimizes travel distances. # Sort the positions list sorted_positions = sorted(positions) # The optimal meeting point is the median position n = len(sorted_positions) if n % 2 == 1: # If the list length is odd, return the middle element return sorted_positions[n // 2] else: # If the list length is even, return the lower middle element return sorted_positions[n // 2 - 1]"},{"question":"# Problem Statement You are given an integer array `arr` of size `n` and an integer `k`. Your task is to determine if there is a continuous subarray of size at least `2` that sums up to a multiple of `k`. A continuous subarray of `arr` is a sequence of consecutive elements in `arr`. Implement the function `check_subarray_sum(arr: List[int], k: int) -> bool` which returns `True` if there is a continuous subarray that sums up to a multiple of `k`, otherwise returns `False`. # Function Signature ```python def check_subarray_sum(arr: List[int], k: int) -> bool: pass ``` # Input * `arr` (List[int]): A list of integers representing the array. * `k` (int): An integer value representing the multiple to check against. # Output * Returns a boolean value (`True` or `False`). # Constraints * 1 <= len(arr) <= 10^4 * -10^9 <= arr[i] <= 10^9 * 0 <= k <= 10^9 # Example 1. Input: `arr = [23, 2, 4, 6, 7], k = 6` Output: `True` Explanation: `[2, 4]` is a subarray that sums up to 6, which is a multiple of 6. 2. Input: `arr = [23, 2, 6, 4, 7], k = 6` Output: `True` Explanation: `[23, 2, 6, 4, 7]` is a subarray that sums up to 42, which is a multiple of 6. 3. Input: `arr = [23, 2, 6, 4, 7], k = 13` Output: `False` Explanation: No subarray sums up to a multiple of 13. # Notes 1. `k` can be `0`, in which case you need to check if there is a subarray with a sum of `0`. 2. The subarray length should be at least `2`. 3. Handle edge cases such as when `arr` has fewer than 2 elements or if all elements are negative. # Hints * Use a hashmap to keep track of the modulus and its index. * If the same modulus is encountered again, there is a subarray sum that is a multiple of `k`.","solution":"from typing import List def check_subarray_sum(arr: List[int], k: int) -> bool: # Dictionary to store the remainder and its index remainder_map = {0: -1} current_sum = 0 for i in range(len(arr)): current_sum += arr[i] if k != 0: remainder = current_sum % k else: remainder = current_sum if remainder in remainder_map: if i - remainder_map[remainder] >= 2: return True else: remainder_map[remainder] = i return False"},{"question":"# Problem Statement You are given a list of integers where each integer appears exactly twice, except for one integer which appears only once. Write a function that finds and returns the integer that appears exactly once. The solution should leverage the property of XOR operation to achieve a linear time complexity with O(1) space complexity. # Function Signature ```python def find_unique(nums: list) -> int: Finds the integer that appears exactly once in the list where every other integer appears twice. :param nums: A list of integers where every element appears twice except for one. :return: The integer that appears exactly once. Example: >>> find_unique([2, 3, 4, 2, 4, 1, 1]) 3 >>> find_unique([1, 2, 3, 1, 2, 3, 4]) 4 >>> find_unique([0, 0, 1]) 1 ``` # Input - `nums` (list): A list of integers where each integer appears exactly twice except for one integer. The length of the list will not exceed 10,000 elements. # Output - Returns the integer that appears exactly once in the list. # Constraints - Each integer in the list appears exactly twice, except for one integer. - The integers can be any valid integer within the range of a 32-bit integer. # Performance Requirements - The solution should run in linear time, i.e., O(N) time complexity, and it should use constant space, i.e., O(1) space complexity. # Examples 1. `find_unique([2, 3, 2, 3, 4])` should return `4`. 2. `find_unique([1, 1, 2, 3, 2])` should return `3`. 3. `find_unique([5, 5, 6])` should return `6`. # Additional Notes - The XOR operation has useful properties: `a ^ a = 0` and `a ^ 0 = a`. This makes it ideal for solving the problem in linear time and constant space. - Ensure to consider edge cases, such as the list containing only one element or the unique element being zero.","solution":"def find_unique(nums): Finds the integer that appears exactly once in the list where every other integer appears twice. :param nums: A list of integers where every element appears twice except for one. :return: The integer that appears exactly once. unique = 0 for num in nums: unique ^= num return unique"},{"question":"# Array Disjoint Sets Verification **Context**: In many computational problems, especially those involving sets and databases, it is crucial to verify whether two sets are disjoint. Disjoint sets, by definition, share no common elements. **Your Task**: Implement a function that checks if two given lists (sets of integers) are disjoint. Function Signature ```python def are_disjoint_sets(set1: List[int], set2: List[int]) -> bool: ``` Input - `set1`: A list of integers representing the first set. - `set2`: A list of integers representing the second set. Output - Returns `True` if the two sets are disjoint (i.e., do not contain any common elements), otherwise returns `False`. Constraints - Each list will contain at least 1 element and at most (10^5) elements. - Elements within a list are unique. - The integers can range from (-10^9) to (10^9). Example ```python >>> are_disjoint_sets([1, 2, 3, 4], [5, 6, 7, 8]) True >>> are_disjoint_sets([1, 2, 3, 4], [4, 5, 6, 7]) False ``` Requirements - The solution should handle large inputs efficiently. - Avoid using nested loops as it would not be efficient for the upper input limits. Hints - Using a set data structure can help in achieving an optimal solution regarding time complexity.","solution":"from typing import List def are_disjoint_sets(set1: List[int], set2: List[int]) -> bool: Checks if two provided lists (sets) are disjoint. Parameters: - set1: List[int] : First set of integers. - set2: List[int] : Second set of integers. Returns: - bool: True if the sets are disjoint, False otherwise. set1_elements = set(set1) for element in set2: if element in set1_elements: return False return True"},{"question":"# Coding Assessment Question: Scenario: You are developing a feature for a spreadsheet application that automatically fills out missing values in a sequence column. The sequence follows a specific arithmetic pattern (either increasing or decreasing by the same constant of 1). Your task is to identify the missing value and complete the sequence. Task: Write a function `fill_missing_value(sequence: List[int]) -> List[int]` that: 1. Takes a list of integers representing the sequence, which contains exactly one missing value represented by `None`. 2. Determines the common difference (`d`) by analyzing the existing numbers in the sequence. 3. Replaces `None` with the correct integer to complete the sequence. 4. Returns the modified list with the sequence filled. Input: - A list of integers `sequence` where length of the list is between 3 and 10, and contains exactly one `None`. The sequence follows an arithmetic pattern with a common difference of ( pm 1 ). Output: - A list of integers with no `None` values. Constraints: - If the input list does not have exactly one `None`, raise a `ValueError` with the message: \\"The sequence must contain exactly one \'None\' value.\\" - If the input list is not of type `List[int]`, raise a `TypeError`. Example: ```python fill_missing_value([3, 4, None, 6, 7]) # Returns [3, 4, 5, 6, 7] fill_missing_value([None, 9, 10, 11]) # Returns [8, 9, 10, 11] fill_missing_value([15, 14, 13, None, 11]) # Returns [15, 14, 13, 12, 11] ``` Requirements: - Implement robust error handling for invalid inputs. - Ensure your solution handles the smallest and largest possible list lengths efficiently. With this question, the objective is to test problem-solving skills related to identifying patterns and handling errors efficiently while maintaining simplicity and clarity in code.","solution":"from typing import List def fill_missing_value(sequence: List[int]) -> List[int]: Takes a list of integers representing an arithmetic sequence with exactly one missing value (represented by `None`), finds the missing number, and returns the complete sequence. # Ensure the sequence contains exactly one `None` if sequence.count(None) != 1: raise ValueError(\\"The sequence must contain exactly one \'None\' value.\\") # Find the index of the missing value missing_index = sequence.index(None) # Determine the common difference if missing_index > 1: d = sequence[1] - sequence[0] else: d = sequence[-2] - sequence[-3] # Compute the missing value if missing_index == 0: missing_value = sequence[1] - d else: missing_value = sequence[missing_index - 1] + d if sequence[missing_index - 1] is not None else sequence[missing_index + 1] - d # Replace `None` with the correct value sequence[missing_index] = missing_value return sequence"},{"question":"# Binary Search Tree (BST) Iterator Implement a `BSTIterator` class that simplifies the process of iterating through a binary search tree (BST) using the `next` and `hasNext` methods. The iterator should iterate through the nodes of the BST in ascending order. # Input and Output Formats: - **`BSTIterator` class**: * **Input**: The root node of the BST. * **Output**: None (initializes the iterator). - **`next`** method: * **Input**: None. * **Output**: The next smallest number in the BST. - **`hasNext`** method: * **Input**: None. * **Output**: Boolean indicating whether there are more elements to be iterated in the BST. # Constraints: - The number of nodes in the BST will be between 0 and 10,000. - The value of each node will be a non-negative integer. # Context Example: Suppose you need to traverse through all nodes of a BST in ascending order to process elements one by one in a memory-efficient way as the complete tree might be too large to fit into memory at once. ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BSTIterator: def __init__(self, root: TreeNode): Initialize your data structure here. pass def next(self) -> int: @return the next smallest number in the BST. pass def hasNext(self) -> bool: @return whether we have a next smallest number. pass # Tests root = TreeNode(7) root.left = TreeNode(3) root.right = TreeNode(15) root.right.left = TreeNode(9) root.right.right = TreeNode(20) iterator = BSTIterator(root) assert iterator.next() == 3 # returns 3 assert iterator.next() == 7 # returns 7 assert iterator.hasNext() == True # returns True assert iterator.next() == 9 # returns 9 assert iterator.hasNext() == True # returns True assert iterator.next() == 15 # returns 15 assert iterator.hasNext() == True # returns True assert iterator.next() == 20 # returns 20 assert iterator.hasNext() == False# returns False ``` # Note: - Design your iterator such that it uses O(h) memory, where h is the height of the tree. - Consider using a controlled iterative in-order traversal to achieve this aim.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BSTIterator: def __init__(self, root: TreeNode): Initialize your data structure here. self.stack = [] self._leftmost_inorder(root) def _leftmost_inorder(self, root): while root: self.stack.append(root) root = root.left def next(self) -> int: @return the next smallest number in the BST. topmost_node = self.stack.pop() if topmost_node.right: self._leftmost_inorder(topmost_node.right) return topmost_node.val def hasNext(self) -> bool: @return whether we have a next smallest number. return len(self.stack) > 0"},{"question":"Question: Busiest Hour in the Store Given a list of tuples, where each tuple contains a timestamp and the number of customers entering or leaving the store at that timestamp, determine the timestamp at which the store reached its maximum occupancy for the first time. If the maximum occupancy is reached multiple times, return the earliest timestamp. Each tuple contains: 1. A string representing the timestamp in the format \\"YYYY-MM-DD HH:MM:SS\\". 2. An integer representing the change in the number of customers: a positive number for customers entering and a negative number for customers leaving. You should implement a function `busiest_hour` which takes a list of such tuples and returns the timestamp as a string. # Input: - A list of tuples `records` where (1 leq text{len}(records) leq 10^6). - The timestamp strings are valid and well-formatted. - Customer changes are valid integers between (-10^3) and (10^3). # Output: - A string representing the timestamp at which the store reached its maximum occupancy. # Function Signature: ```python def busiest_hour(records: List[Tuple[str, int]]) -> str: ``` # Constraints: - The timestamps are given in chronological order. - Efficient implementation is required due to large input size. # Example: ```python >>> busiest_hour([(\\"2023-01-01 10:00:00\\", 10), (\\"2023-01-01 10:30:00\\", 5), (\\"2023-01-01 11:00:00\\", -3), >>> (\\"2023-01-01 11:30:00\\", 8), (\\"2023-01-01 12:00:00\\", -10), (\\"2023-01-01 12:30:00\\", 5)]) \\"2023-01-01 11:30:00\\" >>> busiest_hour([(\\"2023-01-01 08:00:00\\", 3), (\\"2023-01-01 09:00:00\\", -1), (\\"2023-01-01 10:00:00\\", 2), >>> (\\"2023-01-01 11:00:00\\", -2), (\\"2023-01-01 12:00:00\\", 5)]) \\"2023-01-01 12:00:00\\" ``` # Explanation: - For the first example, the occupancy at each timestamp changes as follows: - \\"2023-01-01 10:00:00\\": 10 - \\"2023-01-01 10:30:00\\": 15 (max occupancy so far) - \\"2023-01-01 11:00:00\\": 12 - \\"2023-01-01 11:30:00\\": 20 (new max occupancy) - \\"2023-01-01 12:00:00\\": 10 - \\"2023-01-01 12:30:00\\": 15 The maximum occupancy is 20, first reached at \\"2023-01-01 11:30:00\\". - For the second example, the occupancy at each timestamp changes as follows: - \\"2023-01-01 08:00:00\\": 3 - \\"2023-01-01 09:00:00\\": 2 - \\"2023-01-01 10:00:00\\": 4 - \\"2023-01-01 11:00:00\\": 2 - \\"2023-01-01 12:00:00\\": 7 (max occupancy so far) The maximum occupancy is 7, reached at \\"2023-01-01 12:00:00\\". # Notes: - Assume all timestamps in `records` are unique. - Handle edge cases like no entries in the list.","solution":"from typing import List, Tuple def busiest_hour(records: List[Tuple[str, int]]) -> str: max_occupancy = 0 current_occupancy = 0 max_occupancy_timestamp = \\"\\" for timestamp, change in records: current_occupancy += change if current_occupancy > max_occupancy: max_occupancy = current_occupancy max_occupancy_timestamp = timestamp return max_occupancy_timestamp"},{"question":"# Context You are working on a simulation of a traffic light system for a four-way intersection. The lights change in a specific sequence allowing either north-south or east-west traffic to pass, with a certain amount of time for each green light phase. The task is to create a function that simulates the traffic light changes over a period, synchronizing the lights correctly. # Requirements Implement a function `traffic_light_simulation` that will simulate the traffic light changes over a specified period. The function should output the state of the lights at each time step. # Function Specification ```python def traffic_light_simulation(total_time: int, green_time_ns: int, green_time_ew: int) -> List[str]: Simulate the traffic light changes for a given period. :param total_time: int, total time to run the simulation. :param green_time_ns: int, duration of green light for north-south direction. :param green_time_ew: int, duration of green light for east-west direction. :return: List[str], sequence of traffic light states at each time step. Each state is represented as a string: \\"NS_GREEN\\", \\"NS_YELLOW\\", \\"EW_GREEN\\", \\"EW_YELLOW\\". pass ``` # Input - `total_time` - Positive integer representing the total time to run the simulation. - `green_time_ns` - Positive integer that specifies the green light duration for the north-south direction. - `green_time_ew` - Positive integer that specifies the green light duration for the east-west direction. # Output - Returns a list of strings, where each string represents the state of the lights at each time step. # Example ```python # Running the simulation sequence = traffic_light_simulation(total_time=10, green_time_ns=3, green_time_ew=2) print(sequence) # Example Output: [\\"NS_GREEN\\", \\"NS_GREEN\\", \\"NS_GREEN\\", \\"NS_YELLOW\\", \\"EW_GREEN\\", \\"EW_GREEN\\", \\"EW_YELLOW\\", \\"NS_GREEN\\", \\"NS_GREEN\\", \\"NS_GREEN\\"] ``` # Constraints - Ensure `total_time` is a positive integer. - Ensure `green_time_ns` and `green_time_ew` are positive integers. - The yellow light duration should be 1 time unit for both directions. - The lights change in the following sequence: `NS_GREEN` -> `NS_YELLOW` -> `EW_GREEN` -> `EW_YELLOW`. # Notes - The sequence should repeat if the total simulation time exceeds one full cycle duration. - Make sure the function efficiently handles various time steps and correctly updates the light states in the sequence provided.","solution":"from typing import List def traffic_light_simulation(total_time: int, green_time_ns: int, green_time_ew: int) -> List[str]: sequence = [] pattern = [\'NS_GREEN\'] * green_time_ns + [\'NS_YELLOW\'] + [\'EW_GREEN\'] * green_time_ew + [\'EW_YELLOW\'] pattern_length = len(pattern) for time_step in range(total_time): sequence.append(pattern[time_step % pattern_length]) return sequence"},{"question":"You are required to implement a dynamic array data structure similar to Python\'s built-in list. This dynamic array should support basic operations such as adding, removing, and accessing elements, along with resizing itself when it becomes full. # Implementation Details Implement the class `DynamicArray` that supports the following methods: 1. `__init__(self) -> None`: - Initializes an empty dynamic array with an initial capacity of 4. 2. `append(self, value: T) -> None`: - Adds a value to the end of the array. Resizes the array (doubles its capacity) if it is full. 3. `pop(self) -> T`: - Removes the last element from the array and returns it. Raises `IndexError` if the array is empty. 4. `insert(self, index: int, value: T) -> None`: - Inserts a value at the specified index. Resizes the array if it is full. Raises `IndexError` if the index is out of bounds. 5. `remove(self, value: T) -> None`: - Removes the first occurrence of the value in the array. Raises `ValueError` if the value is not found. 6. `get(self, index: int) -> T`: - Returns the value at the specified index. Raises `IndexError` if the index is out of bounds. 7. `size(self) -> int`: - Returns the current number of elements in the array. 8. `capacity(self) -> int`: - Returns the current capacity of the array. # Constraints - The array should resize dynamically by doubling its size when full. - The resizing operation should be handled efficiently to minimize complexity. - Index out of bounds and value errors should be properly handled. # Example ```python arr = DynamicArray() arr.append(1) arr.append(2) arr.append(3) arr.append(4) assert arr.size() == 4 assert arr.capacity() == 4 arr.append(5) assert arr.size() == 5 assert arr.capacity() == 8 assert arr.get(0) == 1 assert arr.get(4) == 5 arr.insert(1, 10) assert arr.get(1) == 10 arr.remove(10) assert arr.size() == 5 value = arr.pop() assert value == 5 assert arr.size() == 4 try: arr.get(10) except IndexError: print(\\"Caught IndexError as expected.\\") try: arr.remove(100) except ValueError: print(\\"Caught ValueError as expected.\\") ``` # Notes - Ensure that the array resizes only when necessary and handles reallocation efficiently. - Edge cases such as removing from an empty array, accessing an invalid index, and inserting beyond bounds should be carefully handled. - The implementation should provide O(1) amortized time complexity for `append` operation.","solution":"class DynamicArray: def __init__(self) -> None: self._size = 0 self._capacity = 4 self._array = [None] * self._capacity def append(self, value) -> None: if self._size == self._capacity: self._resize() self._array[self._size] = value self._size += 1 def pop(self): if self._size == 0: raise IndexError(\\"pop from empty array\\") value = self._array[self._size - 1] self._array[self._size - 1] = None self._size -= 1 return value def insert(self, index: int, value) -> None: if index < 0 or index > self._size: raise IndexError(\\"index out of bounds\\") if self._size == self._capacity: self._resize() for i in range(self._size, index, -1): self._array[i] = self._array[i-1] self._array[index] = value self._size += 1 def remove(self, value) -> None: for i in range(self._size): if self._array[i] == value: for j in range(i, self._size - 1): self._array[j] = self._array[j + 1] self._array[self._size - 1] = None self._size -= 1 return raise ValueError(\\"value not found\\") def get(self, index: int): if index < 0 or index >= self._size: raise IndexError(\\"index out of bounds\\") return self._array[index] def size(self) -> int: return self._size def capacity(self) -> int: return self._capacity def _resize(self) -> None: new_capacity = self._capacity * 2 new_array = [None] * new_capacity for i in range(self._size): new_array[i] = self._array[i] self._array = new_array self._capacity = new_capacity"},{"question":"# Coding Assessment Question You are tasked with creating a function that analyzes time intervals of CPU usage data and determines the periods of high utilization. Your function should identify periods where the CPU usage exceeds a certain threshold and return the corresponding start and end timestamps of these intervals. Function Specification **Function Name**: `detect_high_cpu_usage` **Input Parameters**: 1. `cpu_data`: (list of tuples) Each tuple contains two elements `(timestamp, cpu_usage)` where `timestamp` is a string in `YYYY-MM-DD HH:MM:SS` format, and `cpu_usage` is a float representing CPU usage percentage. 2. `threshold`: (float) A threshold value above which CPU usage is considered high. **Output**: - Returns a list of tuples where each tuple contains the start and end timestamps (as strings) of periods where the CPU usage consistently exceeded the threshold. **Constraints**: - The input `cpu_data` is sorted in chronological order. - The CPU usage percentage is a value between 0 and 100. - Periods of high usage are contiguous intervals where CPU usage remains above the threshold. Example Usage ```python def detect_high_cpu_usage(cpu_data: list, threshold: float) -> list: # Your implementation here pass # Example call cpu_records = [ (\\"2021-09-01 00:00:00\\", 45.6), (\\"2021-09-01 00:05:00\\", 75.3), (\\"2021-09-01 00:10:00\\", 82.1), (\\"2021-09-01 00:15:00\\", 67.0), (\\"2021-09-01 00:20:00\\", 90.4), (\\"2021-09-01 00:25:00\\", 55.2), (\\"2021-09-01 00:30:00\\", 99.9) ] high_usage_intervals = detect_high_cpu_usage(cpu_records, 70.0) for interval in high_usage_intervals: print(interval) # Output Example # [(\'2021-09-01 00:05:00\', \'2021-09-01 00:10:00\'), (\'2021-09-01 00:20:00\', \'2021-09-01 00:20:00\'), (\'2021-09-01 00:30:00\', \'2021-09-01 00:30:00\')] ``` # Requirements 1. **Continuous High-Usage Periods**: Your implementation should correctly segment continuous high-usage intervals. 2. **Threshold Handling**: The function should accurately use the threshold value to determine high usage. 3. **Efficiency**: Ensure that the solution processes the list in a single pass for optimal efficiency. 4. **Clear Documentation and Code**: Provide meaningful function and variable names, and ensure your code is well-documented.","solution":"def detect_high_cpu_usage(cpu_data: list, threshold: float) -> list: Detects periods of high CPU usage based on the provided threshold. Parameters: cpu_data (list of tuples): Each tuple contains a timestamp (str) and the CPU usage (float) threshold (float): The threshold value above which CPU usage is considered high. Returns: list of tuples: Each tuple contains the start and end timestamps of high usage intervals. high_usage_intervals = [] start = None for timestamp, cpu_usage in cpu_data: if cpu_usage > threshold: if start is None: start = timestamp end = timestamp else: if start is not None: high_usage_intervals.append((start, end)) start = None if start is not None: high_usage_intervals.append((start, end)) return high_usage_intervals"},{"question":"**Question 2: Implement an Event Scheduler** Design a class-based event scheduler system that can manage events scheduling with priority levels. The scheduler should ensure that higher priority events are executed before lower priority ones if they are scheduled for the same time. 1. **Class Definition & Initialization**: - Define `EventScheduler` with methods to add, remove, and process events. 2. **Priority Handling**: - Implement priority handling such that events with higher priority (lower numerical value) are executed before those with lower priority. 3. **Event Processing**: - Ensure the system can handle concurrent events scheduled at the same time appropriately. 4. **Input and Output Formats**: - **add_event(time, event_name, priority)**: Adds an event to be scheduled at a specific time with a given priority. - **remove_event(event_name)**: Removes the specified event from the scheduler if it exists. - **process_events()**: Processes and executes all scheduled events in order according to time and priority. 5. **Constraints**: - Time will be represented in a fixed format (e.g., \\"HH:MM\\"). - Priorities will range from 1 to 10, with 1 being the highest priority. - Event names will be unique strings. 6. **Performance Requirements**: - Ensure the operations for adding and removing events are efficient, aiming for O(log n) time complexity for those operations. - Processing events should respect the order of execution based on time and priority. # Example ```python # Creating an Event Scheduler scheduler = EventScheduler() # Adding events to the scheduler scheduler.add_event(\\"08:00\\", \\"Breakfast\\", 5) scheduler.add_event(\\"09:00\\", \\"Meeting\\", 1) scheduler.add_event(\\"08:30\\", \\"Workout\\", 2) # Adding an event that should override an existing one due to duplicate event name scheduler.add_event(\\"08:30\\", \\"Workout\\", 3) # A new priority/action will override the previous one. # Removing an event before it happens scheduler.remove_event(\\"Breakfast\\") # Processing all events in the scheduler scheduler.process_events() # Output: # Executing Event: Workout at 08:30 # Executing Event: Meeting at 09:00 # Adding a set of concurrent events scheduler.add_event(\\"10:00\\", \\"Project Work\\", 4) scheduler.add_event(\\"10:00\\", \\"Emails\\", 3) scheduler.add_event(\\"10:00\\", \\"Tea Break\\", 5) # Processing concurrent events scheduler.process_events() # Output: # Executing Event: Emails at 10:00 # Executing Event: Project Work at 10:00 # Executing Event: Tea Break at 10:00 ``` Implement the `EventScheduler` class to handle these requirements efficiently. Use appropriate data structures to ensure the operations above meet the specified constraints and performance requirements.","solution":"import heapq class EventScheduler: def __init__(self): self.events = [] self.event_map = {} def add_event(self, time, event_name, priority): if event_name in self.event_map: self.remove_event(event_name) heapq.heappush(self.events, (time, priority, event_name)) self.event_map[event_name] = (time, priority, event_name) def remove_event(self, event_name): if event_name in self.event_map: del self.event_map[event_name] self.events = [event for event in self.events if event[2] != event_name] heapq.heapify(self.events) def process_events(self): while self.events: time, priority, event_name = heapq.heappop(self.events) if event_name in self.event_map: print(f\\"Executing Event: {event_name} at {time}\\") del self.event_map[event_name]"},{"question":"# Scenario You are given a string representing a mathematical expression consisting of non-negative integers, +, -, *, / operators, and parentheses. Your task is to evaluate the expression using correct operator precedence and parenthetical grouping. The operators have the following precedence, from highest to lowest: 1. Parentheses: () 2. Multiplication and Division: *, / 3. Addition and Subtraction: +, - Operators of equal precedence are evaluated left to right. # Task Write a function `evaluate_expression(expression: str) -> int` that takes a string representing a mathematical expression and returns an integer which is the result of evaluating the expression with the correct precedence. Function Signature ```python def evaluate_expression(expression: str) -> int: ``` # Input - `expression`: A string representing a valid mathematical expression containing non-negative integers, +, -, *, / operators, and parentheses. The length of `expression` is at least 1 and at most 1000. # Output - An integer representing the evaluated result of the mathematical expression. # Constraints - The expression contains well-formed, valid mathematical expressions. - Division is integer division that truncates towards zero. - No division by zero will occur in the given test cases. - The input will always be a valid expression within the provided constraints. - Parentheses are always balanced and properly nested. # Example ```python expression = \\"3+(2*2)\\" assert evaluate_expression(expression) == 7 expression = \\" 3/2 \\" assert evaluate_expression(expression) == 1 expression = \\" 3+5 / 2 \\" assert evaluate_expression(expression) == 5 ``` # Implementation Details - Make use of a stack or recursive approach to handle the evaluation of the expression given operator precedence. - Carefully handle whitespace within the expression and ensure correct parsing of numbers and operators. - Implement the function to handle nested expressions via parentheses correctly.","solution":"def evaluate_expression(expression: str) -> int: def helper(tokens): stack = [] num = 0 sign = \'+\' while len(tokens) > 0: token = tokens.pop(0) if token.isdigit(): num = int(token) if token == \'(\': num = helper(tokens) if (not token.isdigit() and token != \' \') or len(tokens) == 0: if sign == \'+\': stack.append(num) elif sign == \'-\': stack.append(-num) elif sign == \'*\': stack.append(stack.pop() * num) elif sign == \'/\': stack.append(int(float(stack.pop()) / num)) sign = token num = 0 if token == \')\': break return sum(stack) tokens = list(expression.replace(\' \', \'\')) return helper(tokens)"},{"question":"# Substring Permutation Checker Given two strings, determine if one is a permutation of the other. A permutation of a string is another string that contains the same characters, only the order of the characters can be different. Function Signature `def is_permutation(s1: str, s2: str) -> bool:` Input - `s1`: a string representing the first string (1 ≤ len(s1) ≤ 10^5). - `s2`: a string representing the second string (1 ≤ len(s2) ≤ 10^5). Output - Returns a boolean value `True` if one string is a permutation of the other string, otherwise returns `False`. Constraints - The function should handle strings up to 100,000 characters long. Performance Requirements - Time Complexity should ideally be O(n). - Space Complexity should be minimized. # Example ```python >>> is_permutation(\\"abc\\", \\"bca\\") True >>> is_permutation(\\"abcd\\", \\"bcda\\") True >>> is_permutation(\\"abc\\", \\"def\\") False >>> is_permutation(\\"aabbcc\\", \\"abcabc\\") True >>> is_permutation(\\"aabbcc\\", \\"ababcd\\") False ``` # Hints 1. Consider using a dictionary or collections.Counter to tally character counts in both strings and compare. 2. Edge cases include strings of different lengths which cannot be permutations of each other.","solution":"from collections import Counter def is_permutation(s1: str, s2: str) -> bool: Determines if one string is a permutation of the other. if len(s1) != len(s2): return False return Counter(s1) == Counter(s2)"},{"question":"# Scenario You are developing a financial application that analyzes stock prices over time to identify trends and volatility. One of the key components of this analysis is to calculate the Simple Moving Average (SMA) of a given series of stock prices. The SMA is a popular technical indicator used in market analysis. # Problem Statement Implement a Python function called `simple_moving_average` that calculates the Simple Moving Average for a given list of stock prices over a specified period `k`. # Function Signature ```python def simple_moving_average(prices: list[float], k: int) -> list[float]: ``` # Inputs * `prices`: A list of floating-point numbers representing stock prices. The list can contain any numeric values. * `k`: An integer representing the period over which to calculate the moving average. # Outputs * A list of floating-point numbers representing the Simple Moving Average of the input stock prices over the specified period. If there are fewer than `k` prices, the result should be an empty list. # Constraints * The function must raise a `ValueError` with the message \\"Invalid period\\" if the period `k` is less than or equal to zero. * The function must raise a `ValueError` with the message \\"Insufficient data\\" if the length of the prices list is less than `k`. * The list could contain negative numbers. * The function should handle floating-point precision correctly. # Performance Requirements * The solution should have a time complexity of O(n) and a space complexity of O(n), where `n` is the length of the `prices` list. # Example ```python assert simple_moving_average([1.0, 2.0, 3.0, 4.0, 5.0], 3) == [2.0, 3.0, 4.0] assert simple_moving_average([10.0, 20.0, 30.0, 40.0, 50.0], 2) == [15.0, 25.0, 35.0, 45.0] assert simple_moving_average([7.0, 14.0, 21.0], 4) == [] try: simple_moving_average([1.0, 2.0], 3) except ValueError as e: assert str(e) == \\"Insufficient data\\" try: simple_moving_average([1.0, 2.0, 3.0], 0) except ValueError as e: assert str(e) == \\"Invalid period\\" ``` Implement the `simple_moving_average` function to meet the given requirements and optimize for performance. Provide sufficient error handling for edge cases. Write clear and concise code, ensuring maintainability and readability.","solution":"def simple_moving_average(prices: list[float], k: int) -> list[float]: Calculate the Simple Moving Average (SMA) for a given list of stock prices over a specified period `k`. :param prices: List of stock prices (float) :param k: Period over which to calculate the moving average (int) :return: List of SMA values (float) or empty list if there are fewer than `k` prices if k <= 0: raise ValueError(\\"Invalid period\\") if len(prices) < k: raise ValueError(\\"Insufficient data\\") sma = [] window_sum = sum(prices[:k]) sma.append(window_sum / k) for i in range(k, len(prices)): window_sum += prices[i] - prices[i - k] sma.append(window_sum / k) return sma"},{"question":"# Problem Statement You are tasked with implementing a function that calculates all prime numbers up to a given number `n` using the Sieve of Eratosthenes algorithm. This function should return a list of all prime numbers up to and including `n`. # Objective Write a function `sieve_of_eratosthenes(n: int) -> list` that computes the prime numbers up to `n`. # Input * **`n`**: An integer (2 leq n leq 10^6). # Output A list `primes` such that: * `primes` contains all the prime numbers up to and including `n`, in ascending order. # Example ```python n = 10 output = sieve_of_eratosthenes(n) print(output) # Output will be a list of prime numbers up to 10 # Expected output: # [ # 2, # First prime number # 3, # Next prime number # 5, # Next prime number # 7, # Next prime number # ] ``` # Constraints * Ensure your implementation efficiently handles the upper limits of `n` within a reasonable time frame. # Notes * The Sieve of Eratosthenes algorithm marks the multiples of each prime number starting from 2. * Use an array to keep track of potential primes: initially, assume all numbers are prime. * The time complexity is (O(n log log n)), making it suitable for large inputs up to (10^6). Good luck! Now, let’s write the function: ```python def sieve_of_eratosthenes(n: int) -> list: if n < 2: return [] # Initialize a list of boolean values, where index `i` will be True if `i` is a prime number. is_prime = [True] * (n + 1) is_prime[0] = is_prime[1] = False # 0 and 1 are not prime numbers. p = 2 while (p * p <= n): # If is_prime[p] is still True, then it is a prime. if is_prime[p]: # Updating all multiples of p to not prime for i in range(p * p, n + 1, p): is_prime[i] = False p += 1 # Collecting all prime numbers from the is_prime array primes = [p for p in range(n + 1) if is_prime[p]] return primes # Example usage: n = 10 output = sieve_of_eratosthenes(n) print(output) # Expected: [2, 3, 5, 7] ```","solution":"def sieve_of_eratosthenes(n: int) -> list: if n < 2: return [] # Initialize a list of boolean values, where index `i` will be True if `i` is a prime number. is_prime = [True] * (n + 1) is_prime[0] = is_prime[1] = False # 0 and 1 are not prime numbers. p = 2 while (p * p <= n): # If is_prime[p] is still True, then it is a prime. if is_prime[p]: # Updating all multiples of p to not prime for i in range(p * p, n + 1, p): is_prime[i] = False p += 1 # Collecting all prime numbers from the is_prime array primes = [p for p in range(n + 1) if is_prime[p]] return primes"},{"question":"**Binary Search for Target in a Sorted Array** You are given the task to implement a function that performs a binary search on a sorted array to find the index of a given target value. The array is guaranteed to be sorted in non-decreasing order. # Input Format: * A list of integers `nums` representing the sorted array. * An integer `target` which is the value you need to find in the array. ``` binary_search(nums, target) ``` # Output Format: * An integer representing the index of the target value in the array. If the target value is not present in the array, return `-1`. # Constraints: * The array `nums` can have a length between `0` and `10^5`. * Each integer in `nums` can lie between `-10^9` and `10^9`. * The `target` value can also lie between `-10^9` and `10^9`. # Example: ```python nums1 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] target1 = 5 print(binary_search(nums1, target1)) # Output: 4 nums2 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] target2 = 11 print(binary_search(nums2, target2)) # Output: -1 nums3 = [] target3 = 7 print(binary_search(nums3, target3)) # Output: -1 ``` # Performance Requirements: * The function should run in O(log n) time complexity, where n is the length of the array. # Scenario Imagine you are tasked with implementing this function for a search feature in a large-scale database where records are stored in sorted order. This function will allow for quick lookup times, which is crucial for the performance and responsiveness of the database. Implement the function `binary_search` to meet the requirements and satisfy the above test cases. # Function Signature ```python def binary_search(nums: List[int], target: int) -> int: # Your code here pass ```","solution":"def binary_search(nums, target): Perform a binary search on a sorted array to find the index of a given target value. Parameters: nums (list of int): The sorted array of integers. target (int): The integer value to search for in the array. Returns: int: The index of the target in the array if found, otherwise -1. left, right = 0, len(nums) - 1 while left <= right: mid = (left + right) // 2 if nums[mid] == target: return mid elif nums[mid] < target: left = mid + 1 else: right = mid - 1 return -1"},{"question":"# Sorting Orders in Dynamic Arrays Scenario: You are tasked with implementing a system that maintains an array of customer orders for an online store. The system should support operations for handling a dynamic list of orders where each order is identified by a unique order ID and has an associated order amount. Requirements: 1. **Order Addition**: Implement a method to add new orders to the array. 2. **Order Removal**: Implement a method to remove orders from the array by their order ID. 3. **Order Retrieval**: Implement a method to retrieve an array of orders sorted by order amount in descending order. 4. **Error Handling**: Ensure proper handling of invalid removal requests (e.g., order ID not found). Input & Output: * **Function Signatures**: ```python class OrderSystem: def __init__(self): # Initialize an empty list to store orders pass def add_order(self, order_id: str, amount: float) -> None: # Add a new order with the specified order ID and amount pass def remove_order(self, order_id: str) -> None: # Remove the order with the specified order ID pass def get_sorted_orders(self) -> List[Dict[str, Any]]: # Return a list of all orders sorted by amount in descending order pass ``` * **Constraints**: * `order_id` should be a non-empty string consisting of alphanumeric characters and dashes. * `amount` should be a non-negative floating point number. * Duplicate `order_id`s should not be allowed; adding an order with an existing `order_id` should raise a `ValueError` with the message \\"Order ID already exists\\". * Removing an order with a non-existing `order_id` should raise a `ValueError` with the message \\"Order ID not found\\". Example: ```python # Example usage: system = OrderSystem() # Add orders system.add_order(\\"order-1\\", 100.5) system.add_order(\\"order-2\\", 250.0) system.add_order(\\"order-3\\", 75.25) # Remove an order system.remove_order(\\"order-1\\") # Get sorted orders sorted_orders = system.get_sorted_orders() # Expected output: [{\\"order_id\\": \\"order-2\\", \\"amount\\": 250.0}, {\\"order_id\\":\\"order-3\\", \\"amount\\": 75.25}] assert sorted_orders == [{\\"order_id\\": \\"order-2\\", \\"amount\\": 250.0}, {\\"order_id\\":\\"order-3\\", \\"amount\\": 75.25}] ``` Implementation Details: Provide your implementation for the `OrderSystem` class following the specifications and requirements provided. Ensure the system efficiently handles the operations and adheres to the constraints and error handling as described. Implementing this will test the ability to manage dynamic data structures, sorting algorithm usage, and handling typical issues with identifier uniqueness and error management.","solution":"from typing import List, Dict, Any class OrderSystem: def __init__(self): # Initialize an empty list to store orders self.orders = {} def add_order(self, order_id: str, amount: float) -> None: if order_id in self.orders: raise ValueError(\\"Order ID already exists\\") self.orders[order_id] = amount def remove_order(self, order_id: str) -> None: if order_id not in self.orders: raise ValueError(\\"Order ID not found\\") del self.orders[order_id] def get_sorted_orders(self) -> List[Dict[str, Any]]: sorted_orders = sorted(self.orders.items(), key=lambda x: x[1], reverse=True) return [{\\"order_id\\": order[0], \\"amount\\": order[1]} for order in sorted_orders]"},{"question":"# Word Ladder Transformation Scenario You are working on a word-puzzle game where players need to transform a start word into an end word by changing exactly one letter at a time, such that each intermediate word also exists in a given dictionary. The task is to determine the minimum number of transformations required to achieve this. Implement a function that computes the shortest transformation sequence from the start word to the end word. Function Signature ```python def word_ladder(start: str, end: str, dictionary: List[str]) -> int: ``` Input * `start` (str): A non-empty string representing the start word. * `end` (str): A non-empty string representing the end word. * `dictionary` (List[str]): A list of strings representing the word dictionary, where each string is of the same length as the start word. Output * Returns an integer representing the minimum number of transformations from start to end word, or -1 if no such transformation is possible. Constraints * The function should have a time complexity not exceeding (O(n cdot m)), where (n) is the number of words in the dictionary and (m) is the length of the words. * All words contain only lowercase alphabetical characters, and the start and end words are assumed to be of the same length. Example **Input:** ```python start = \\"hit\\" end = \\"cog\\" dictionary = [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\", \\"cog\\"] ``` **Output:** ```python 5 ``` **Explanation** The shortest transformation sequence from \\"hit\\" to \\"cog\\" is: 1. \\"hit\\" -> \\"hot\\" 2. \\"hot\\" -> \\"dot\\" 3. \\"dot\\" -> \\"dog\\" 4. \\"dog\\" -> \\"cog\\" Thus, the minimum number of transformations required is 5. **Additional Example** **Input:** ```python start = \\"hit\\" end = \\"cog\\" dictionary = [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\"] ``` **Output:** ```python -1 ``` **Explanation** There is no possible transformation from \\"hit\\" to \\"cog\\" using the given dictionary, so the function should return -1.","solution":"from typing import List from collections import deque def word_ladder(start: str, end: str, dictionary: List[str]) -> int: if end not in dictionary: return -1 word_set = set(dictionary) queue = deque([(start, 1)]) # (current word, current length of transformation sequence) # BFS while queue: current_word, length = queue.popleft() if current_word == end: return length for i in range(len(current_word)): for c in \'abcdefghijklmnopqrstuvwxyz\': if c != current_word[i]: next_word = current_word[:i] + c + current_word[i+1:] if next_word in word_set: word_set.remove(next_word) queue.append((next_word, length + 1)) return -1"},{"question":"# Coding Question: The Number Wall Problem Statement: You are given a sequence of integers and a series of operations to determine the nature of the sequence. Your task is to find the number of integers in the longest contiguous subsequence within the given sequence that satisfies a given condition. Write a function `longest_subsequence(arr: List[int], condition: callable) -> int` where: - **Input**: - `arr` (a list of integers) - the sequence of integers. - `condition` (a callable function) - a function that returns `True` for values that meet the condition and `False` otherwise. - **Output**: Output the length of the longest contiguous subsequence within `arr` where every integer meets the `condition`. Function Signature: `def longest_subsequence(arr: List[int], condition: callable) -> int` **Examples**: ```python assert longest_subsequence([1, 2, 3, 4, 5, 6, 7, 8], lambda x: x % 2 == 0) == 4 # 2, 4, 6, 8 assert longest_subsequence([1, -2, -3, 4, -5, 6, 7, -8], lambda x: x < 0) == 2 # -2, -3 assert longest_subsequence([10, 15, 20, 25, 30, 35], lambda x: x % 5 == 0) == 6 ``` Constraints: - Each element in `arr` will be an integer between -10^9 and 10^9. - The length of `arr` will be at least 1 and at most 10^6. **Hint**: Consider simple loop-based methods first, then optimize for larger dataset sizes. # Explanation: Given an input array and a condition function, your task is to determine the longest contiguous subsequence in which all elements satisfy the condition. This question tests the ability to work with sequences and condition checks in a practical and efficient manner.","solution":"from typing import List, Callable def longest_subsequence(arr: List[int], condition: Callable[[int], bool]) -> int: Returns the length of the longest contiguous subsequence within arr where every integer meets the condition. max_length = 0 current_length = 0 for num in arr: if condition(num): current_length += 1 if current_length > max_length: max_length = current_length else: current_length = 0 return max_length"},{"question":"# Coding Problem Implement a `RateLimiter` class that controls the rate at which a function can be called. The class should ensure that the function is not invoked more often than a specified rate, defined in terms of maximum calls per second. Specifications 1. **Class Structure**: Implement the `RateLimiter` class with the following methods: - `__init__(self, rate: float) -> None` - `call(self, func: Callable[..., T], *args: Any, **kwargs: Any) -> T` 2. **Rate Limiting**: - The rate is specified as a float, representing the maximum number of calls per second. - Ensure that `call` method invokes the provided function `func` while respecting the rate limit. 3. **Functionality**: - `__init__(rate: float) -> None`: Initializes the rate limiter with the specified rate. - `call(func: Callable[..., T], *args: Any, **kwargs: Any) -> T`: Calls the given function with the provided arguments, ensuring the calls respect the rate limit. 4. **Performance Requirements**: - The rate limiting mechanism should effectively prevent the function from being called more frequently than allowed. - Handle edge cases such as calling `call` method multiple times almost simultaneously. Example Usage ```python import time def print_message(msg): print(msg) rate_limiter = RateLimiter(2) # Allow at most 2 calls per second rate_limiter.call(print_message, \\"Hello\\") rate_limiter.call(print_message, \\"World\\") time.sleep(0.5) # Sleep for less than the rate limit interval, next call should be delayed rate_limiter.call(print_message, \\"This should be delayed\\") # Assuming the sleep accounts for rate limiting, all calls within short intervals should respect the rate limit. ``` Notes * The `RateLimiter` should ensure that if calls are made faster than the allowed rate, they are executed with appropriate delays. * Ensure that the implementation is thread-safe, meaning it should behave correctly if accessed from multiple threads concurrently. * You may use the `time` module to track the timing of calls.","solution":"import time import threading from typing import Callable, Any, TypeVar T = TypeVar(\'T\') class RateLimiter: def __init__(self, rate: float) -> None: self.rate = rate self.interval = 1.0 / rate self.lock = threading.Lock() self.last_call_time = 0.0 def call(self, func: Callable[..., T], *args: Any, **kwargs: Any) -> T: with self.lock: current_time = time.time() elapsed = current_time - self.last_call_time if elapsed < self.interval: time.sleep(self.interval - elapsed) self.last_call_time = time.time() return func(*args, **kwargs)"},{"question":"# Problem Statement You are required to implement a function `group_by_oddeven` that groups the numbers in a list into two separate lists: one containing the odd numbers and the other containing the even numbers. The function should return a tuple of the two lists, with the list of odd numbers first and the list of even numbers second. # Function Signature ```python def group_by_oddeven(numbers: List[int]) -> Tuple[List[int], List[int]]: pass ``` # Input - `numbers` (List[int]): A list of integers. # Output - Returns a tuple containing two lists: - The first list contains all the odd numbers from the input list. - The second list contains all the even numbers from the input list. # Constraints - The list `numbers` will contain between 0 and 10^5 integers inclusive. - Each integer in the list will be between -10^9 and 10^9 inclusive. # Examples ```python >>> group_by_oddeven([1, 2, 3, 4, 5]) ([1, 3, 5], [2, 4]) >>> group_by_oddeven([10, 15, 20, 25, 30]) ([15, 25], [10, 20, 30]) >>> group_by_oddeven([7, 21, 14, 28, 42]) ([7, 21], [14, 28, 42]) >>> group_by_oddeven([]) ([], []) >>> group_by_oddeven([0, -1, -2, -3, -4]) ([-1, -3], [0, -2, -4]) ``` # Notes 1. Odd numbers are those that are not divisible by 2 (i.e., n % 2 != 0). 2. Even numbers are those that are divisible by 2 (i.e., n % 2 == 0). 3. The order of numbers in each group should match the order in the original list.","solution":"from typing import List, Tuple def group_by_oddeven(numbers: List[int]) -> Tuple[List[int], List[int]]: odd_numbers = [num for num in numbers if num % 2 != 0] even_numbers = [num for num in numbers if num % 2 == 0] return (odd_numbers, even_numbers)"},{"question":"# Reverse Words in a String Scenario: You are working on a text processing module for a social media platform where users often post messages with messy spacing. To improve readability, your task is to write a function that reverses the words in a given string while trimming any extra spaces. Task: Implement the function `reverse_words(s: str) -> str` that reverses the words in the given string `s`. Details: - A word is defined as a sequence of non-space characters. - The input string may contain leading, trailing, or multiple spaces between words. - Your solution should trim the leading and trailing spaces, and reduce multiple spaces between words to a single space in the output. Input: 1. **s (str)** - a string containing words and spaces. Output: - **str** - a string in which the words are reversed and spaces are managed according to the details. Examples: ```python # Example 1 s = \\" hello world \\" # Trim the input to \\"hello world\\" then reverse words to \\"world hello\\" print(reverse_words(s)) # Output: \\"world hello\\" # Example 2 s = \\"a good example\\" # Trim the input to \\"a good example\\" then reverse words to \\"example good a\\" print(reverse_words(s)) # Output: \\"example good a\\" # Example 3 s = \\" Bob loves Alice \\" # Trim the input to \\"Bob loves Alice\\" then reverse words to \\"Alice loves Bob\\" print(reverse_words(s)) # Output: \\"Alice loves Bob\\" ``` Constraints: - Ensure that your solution runs efficiently for strings up to 10<sup>5</sup> characters in length. Tips: 1. Split the string into words, reverse the list of words, and join them with a single space. 2. Use Python\'s built-in string methods for convenience and efficiency.","solution":"def reverse_words(s: str) -> str: Reverses the words in the given string `s` while trimming any extra spaces. Args: s (str): The input string containing words and spaces. Returns: str: The string with reversed words and managed spaces. # Split the string into words by spaces words = s.split() # Reverse the list of words reversed_words = words[::-1] # Join the reversed words with a single space reversed_string = \' \'.join(reversed_words) return reversed_string"},{"question":"# Matrix Path Sum Algorithm Background You are tasked with developing an algorithm to find the minimum sum of a path from the top-left corner to the bottom-right corner of a matrix. Each cell in the matrix contains a non-negative integer representing a cost. The movement is restricted to either down or right at any point in time. Task Implement the function `min_path_sum(matrix: List[List[int]]) -> int` that calculates the minimum path sum from the top-left to the bottom-right. Requirements - Use dynamic programming to solve the problem efficiently. - The function should return the minimum path sum. Input - `matrix`: a 2D list of integers with dimensions ( m times n ) (1 ≤ ( m ), ( n ) ≤ 1000). Each element in the matrix is a non-negative integer. Output - An integer representing the minimum sum of the path from the top-left to the bottom-right corner of the matrix. Example Usage ```python def min_path_sum(matrix: List[List[int]]) -> int: if not matrix or not matrix[0]: return 0 m, n = len(matrix), len(matrix[0]) # Create a DP table with the same dimensions as the input matrix dp = [[0]*n for _ in range(m)] # Initialize the DP table with the cost of the first cell dp[0][0] = matrix[0][0] # Fill the first row (can only come from the left) for j in range(1, n): dp[0][j] = dp[0][j-1] + matrix[0][j] # Fill the first column (can only come from above) for i in range(1, m): dp[i][0] = dp[i-1][0] + matrix[i][0] # Fill the rest of the DP table for i in range(1, m): for j in range(1, n): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + matrix[i][j] # The bottom-right corner contains the minimum path sum return dp[m-1][n-1] # Example: Finding the minimum path sum in a matrix matrix = [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] print(min_path_sum(matrix)) # Output: 7 ``` Constraints - Ensure that the algorithm runs efficiently for large matrices. - Handle edge cases where the input matrix dimensions are minimal (e.g., 1x1). Good luck!","solution":"from typing import List def min_path_sum(matrix: List[List[int]]) -> int: if not matrix or not matrix[0]: return 0 m, n = len(matrix), len(matrix[0]) # Create a DP table with the same dimensions as the input matrix dp = [[0]*n for _ in range(m)] # Initialize the DP table with the cost of the first cell dp[0][0] = matrix[0][0] # Fill the first row (can only come from the left) for j in range(1, n): dp[0][j] = dp[0][j-1] + matrix[0][j] # Fill the first column (can only come from above) for i in range(1, m): dp[i][0] = dp[i-1][0] + matrix[i][0] # Fill the rest of the DP table for i in range(1, m): for j in range(1, n): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + matrix[i][j] # The bottom-right corner contains the minimum path sum return dp[m-1][n-1]"},{"question":"# Question: Custom Sorting of Mixed Data Types You are required to implement a function that sorts a list containing a mixture of integers and strings. The sorting should be based on the following rules: 1. **Integers before Strings**: All integer elements should appear before any string elements. 2. **Natural Ordering within Subgroups**: - Integers should be sorted in ascending order. - Strings should be sorted lexicographically (dictionary order). Implement the Following Function: **1. Function `custom_sort_mixed(data: list) -> list`:** * **Input**: A list containing integers and strings. * **Output**: A new list with elements sorted according to the specified rules. * **Constraints**: * The list can contain duplicate integers and strings. * The input list should have at least one element. * Raise a `TypeError` if the list contains elements other than integers and strings. * Raise a `ValueError` if the list is empty. Example ```python >>> custom_sort_mixed([3, \\"apple\\", 2, \\"banana\\", \\"cherry\\", 1]) [1, 2, 3, \'apple\', \'banana\', \'cherry\'] >>> custom_sort_mixed([\\"dog\\", 22, \\"cat\\", 8, 15, \\"bird\\"]) [8, 15, 22, \'bird\', \'cat\', \'dog\'] >>> custom_sort_mixed([4, 3, \\"apple\\", \\"banana\\"]) [3, 4, \'apple\', \'banana\'] >>> custom_sort_mixed([\\"orange\\", \\"lemon\\", 5, 3]) [3, 5, \'lemon\', \'orange\'] >>> custom_sort_mixed([3, 3, \\"grape\\", \\"grape\\"]) [3, 3, \'grape\', \'grape\'] ``` Notes: * Ensure the function maintains the given constraints. * Consider edge cases, such as lists with only one type of element (all integers or all strings) and lists with varying positions of the mixed elements. * A raised `TypeError` should have an appropriate message indicating the issue with element types. * A raised `ValueError` should have an appropriate message indicating the issue of an empty list. Performance Requirements * Your implementation should aim for O(n log n) time complexity considering the sort operation, where n is the length of the input list. **Good Luck!**","solution":"def custom_sort_mixed(data: list) -> list: if not data: raise ValueError(\\"The input list is empty\\") integers = [] strings = [] for item in data: if isinstance(item, int): integers.append(item) elif isinstance(item, str): strings.append(item) else: raise TypeError(\\"The list contains elements other than integers and strings\\") integers.sort() strings.sort() return integers + strings"},{"question":"# Coding Challenge: Perfect Number and Divisor Sum Context: You have been tasked with implementing a set of functions related to divisors and perfect numbers. These capabilities are useful in number theory and various mathematical applications. Ensure your implementations are efficient and handle various edge cases gracefully. # Function 1: Sum of Divisors **Description**: Write a function, `sum_of_divisors(n: int) -> int`, that takes a positive integer `n` and returns the sum of all its divisors, excluding `n` itself. - **Input**: An integer `n` (1 ≤ n ≤ 10^6) - **Output**: An integer representing the sum of the divisors of `n` - **Constraints**: - Ensure the function efficiently computes the divisors using an optimized approach. # Function 2: Perfect Number Check **Description**: Write a function, `is_perfect_number(n: int) -> bool`, that takes a positive integer `n` and returns `True` if `n` is a perfect number, otherwise `False`. A perfect number is a positive integer that is equal to the sum of its proper divisors. - **Input**: An integer `n` (1 ≤ n ≤ 10^6) - **Output**: A boolean `True` if `n` is a perfect number, otherwise `False`. ```python def sum_of_divisors(n: int) -> int: Returns the sum of all divisors of the given number n, excluding n itself. pass # Implement the function def is_perfect_number(n: int) -> bool: Returns True if the given number n is a perfect number, otherwise False. pass # Implement the function # Example Usage: # sum_of_divisors(28) -> 28 (1 + 2 + 4 + 7 + 14) # is_perfect_number(28) -> True # is_perfect_number(30) -> False ``` Notes: 1. Ensure your solutions are optimized for the given constraints. 2. Your functions should include necessary input validation and handle edge cases appropriately.","solution":"def sum_of_divisors(n: int) -> int: Returns the sum of all divisors of the given number n, excluding n itself. if n <= 1: return 0 sum_divisors = 1 sqrt_n = int(n**0.5) for i in range(2, sqrt_n + 1): if n % i == 0: if i == n // i: sum_divisors += i else: sum_divisors += i + n // i return sum_divisors def is_perfect_number(n: int) -> bool: Returns True if the given number n is a perfect number, otherwise False. if n <= 1: return False return sum_of_divisors(n) == n # Example Usage: # sum_of_divisors(28) -> 28 (1 + 2 + 4 + 7 + 14) # is_perfect_number(28) -> True # is_perfect_number(30) -> False"},{"question":"# String Abbreviation Matching # Problem Statement: Given two strings, `s` and `abbr`, implement a function that determines if `abbr` is a valid abbreviation for string `s`. A valid abbreviation follows these rules: 1. Letters in `abbr` must match the corresponding letters in `s`. 2. Any sequence of digits in `abbr` represents the number of characters to skip in `s`. The number cannot have leading zeros. 3. Check the full match of `abbr` to the segments of `s`. # Function Signature: ```python def valid_abbreviation(s: str, abbr: str) -> bool: Determines if abbr is a valid abbreviation of s. :param s: The original string. :param abbr: The abbreviated string. :return: True if abbr is a valid abbreviation of s, False otherwise. ``` # Constraints: * 1 ≤ len(s), len(abbr) ≤ 1000 * `s` contains only lowercase letters. * `abbr` contains only lowercase letters and digits. # Input/Output Examples: ```python s = \\"internationalization\\" abbr = \\"i12iz4n\\" print(valid_abbreviation(s, abbr)) # Expected Output: True s = \\"hello\\" abbr = \\"h2o\\" print(valid_abbreviation(s, abbr)) # Expected Output: False s = \\"substitution\\" abbr = \\"s10n\\" print(valid_abbreviation(s, abbr)) # Expected Output: True ``` Implement the function `valid_abbreviation` to determine whether `abbr` is a valid abbreviation for `s`, adhering to the specified rules.","solution":"def valid_abbreviation(s: str, abbr: str) -> bool: Determines if abbr is a valid abbreviation of s. :param s: The original string. :param abbr: The abbreviated string. :return: True if abbr is a valid abbreviation of s, False otherwise. i, j = 0, 0 n, m = len(s), len(abbr) while i < n and j < m: if abbr[j].isdigit(): if abbr[j] == \'0\': return False num = 0 while j < m and abbr[j].isdigit(): num = num * 10 + int(abbr[j]) j += 1 i += num else: if s[i] != abbr[j]: return False i += 1 j += 1 return i == n and j == m"},{"question":"# Coding Question Context You have joined an e-commerce company that is looking to improve its recommendation engine. One of the key features is to identify frequently bought together items, which is based on summarizing customer purchase lists. Problem You are given a list of lists, where each sublist represents items purchased together in a single transaction. Your task is to implement a function that returns a dictionary where the keys are the individual items and the values are the counts of how often each item appears in the transactions. Requirements 1. Implement a function to count the frequency of each item appearing in a list of purchase lists. 2. Ensure that your function can handle a large number of transactions efficiently. Function Signature ```python def count_item_frequency(transactions: list[list[str]]) -> dict[str, int]: Counts the frequency of each item in the list of transactions. :param transactions: List of lists of items representing transactions. :return: Dictionary with item names as keys and their frequencies as values. Example: >>> count_item_frequency([[\\"apple\\", \\"banana\\"], [\\"banana\\", \\"carrot\\"], [\\"apple\\", \\"carrot\\", \\"banana\\"]]) {\'apple\': 2, \'banana\': 3, \'carrot\': 2} >>> count_item_frequency([[\\"apple\\"], [\\"banana\\"], [\\"apple\\", \\"banana\\"], [\\"banana\\", \\"banana\\"]]) {\'apple\': 2, \'banana\': 4} >>> count_item_frequency([[\\"milk\\", \\"bread\\"], [\\"milk\\"], [\\"bread\\"]]) {\'milk\': 2, \'bread\': 2} >>> count_item_frequency([[]]) {} ``` Constraints 1. The input list can include empty sublists. 2. Each sublist will contain strings representing the items. 3. Consider performance and ensure that the function handles large datasets efficiently. Input/Output Format * **Input**: A list of lists of strings. * **Output**: A dictionary with item names as keys and their frequencies as values. Examples 1. `count_item_frequency([[\\"apple\\", \\"banana\\"], [\\"banana\\", \\"carrot\\"], [\\"apple\\", \\"carrot\\", \\"banana\\"]])` should return `{\'apple\': 2, \'banana\': 3, \'carrot\': 2}`. 2. `count_item_frequency([[\\"milk\\", \\"bread\\"], [\\"milk\\"], [\\"bread\\"]])` should return `{\'milk\': 2, \'bread\': 2}`. Notes 1. Write comprehensive tests to ensure your implementation is accurate. 2. Consider edge cases such as transactions with repeated items, empty lists of transactions, and single-item transactions.","solution":"def count_item_frequency(transactions: list[list[str]]) -> dict[str, int]: Counts the frequency of each item in the list of transactions. :param transactions: List of lists of items representing transactions. :return: Dictionary with item names as keys and their frequencies as values. Example: >>> count_item_frequency([[\\"apple\\", \\"banana\\"], [\\"banana\\", \\"carrot\\"], [\\"apple\\", \\"carrot\\", \\"banana\\"]]) {\'apple\': 2, \'banana\': 3, \'carrot\': 2} >>> count_item_frequency([[\\"apple\\"], [\\"banana\\"], [\\"apple\\", \\"banana\\"], [\\"banana\\", \\"banana\\"]]) {\'apple\': 2, \'banana\': 4} >>> count_item_frequency([[\\"milk\\", \\"bread\\"], [\\"milk\\"], [\\"bread\\"]]) {\'milk\': 2, \'bread\': 2} >>> count_item_frequency([[]]) {} frequency = {} for transaction in transactions: for item in transaction: if item in frequency: frequency[item] += 1 else: frequency[item] = 1 return frequency"},{"question":"# Coding Assessment Question Context: Suppose you are given an array of integers where each element represents the height of a vertical line drawn at that index. The task is to identify the maximum area of water that can be contained between any two vertical lines. Problem: Your task is to write a Python function `max_area(height: List[int]) -> int` that takes a list of integers as input and returns an integer representing the maximum area of water that can be contained between two lines in the array. The area is calculated based on the shorter line between the two chosen lines and the distance between them. Function Signature: ```python def max_area(height: List[int]) -> int: pass ``` Input: - A list of integers `height` where `1 ≤ len(height) ≤ 10^5` and `0 ≤ height[i] ≤ 10^4`. Output: - An integer representing the maximum area of water that can be contained. Example: ```python assert max_area([1,8,6,2,5,4,8,3,7]) == 49 assert max_area([1,1]) == 1 assert max_area([4,3,2,1,4]) == 16 assert max_area([1,2,1]) == 2 ``` Constraints: 1. You should aim for an efficient solution with a time complexity of O(n). 2. The function iterates through the list to find the maximum possible area trapped between any two vertical lines. 3. Consider edge cases and scenarios where the array length is minimal. Steps to Guide Your Solution: 1. Use two pointers, initializing one at the beginning and the other at the end of the array. 2. Calculate the area for each pair of lines pointed by the two pointers. 3. Move the pointer that points to the shorter line towards the center to potentially find a taller line and a larger area. 4. Keep track of the maximum area found during the iteration. 5. Return the maximum area after the iteration completes. Good luck and remember to strive for an optimal implementation with careful consideration of edge cases and performance!","solution":"from typing import List def max_area(height: List[int]) -> int: Returns the maximum area of water that can be contained between two vertical lines. left, right = 0, len(height) - 1 max_area = 0 while left < right: # Calculate the area with the current pair of lines area = min(height[left], height[right]) * (right - left) max_area = max(max_area, area) # Move the pointer that points to the shorter line if height[left] < height[right]: left += 1 else: right -= 1 return max_area"},{"question":"# Fibonacci-like Sequence Finder **Scenario**: You are designing a sequence generator that identifies sequences similar to the Fibonacci sequence but with arbitrary starting values. Your goal is to find all possible starting values within a given range that form sequences following this pattern. **Problem**: Write a function to generate and identify sequences that adhere to specific rules: each number in the sequence (from the third term onward) must be the sum of the two preceding numbers. The first two terms of each sequence will lie within a given range. **Function Signature**: ```python def fibonacci_like_sequences(min_start: int, max_start: int, length: int) -> List[List[int]]: Function to generate Fibonacci-like sequences with specified starting values and length. Args: min_start (int): The minimum starting value for the first term. max_start (int): The maximum starting value for the first term. length (int): The length of the sequences to be generated. Returns: List[List[int]]: A list of valid Fibonacci-like sequences. ``` **Input**: - `min_start`: An integer representing the minimum value for the first term of the sequence. - `max_start`: An integer representing the maximum value for the first term of the sequence. - `length`: An integer representing the desired length of each sequence. **Output**: - A list of lists where each nested list is a valid Fibonacci-like sequence of the specified length with starting values between `min_start` and `max_start`. **Constraints**: - `0 <= min_start <= max_start <= 10^6` - `3 <= length <= 20` **Examples**: ```python >>> fibonacci_like_sequences(1, 2, 5) [ [1, 1, 2, 3, 5], [1, 2, 3, 5, 8], [2, 1, 3, 4, 7], [2, 2, 4, 6, 10] ] >>> fibonacci_like_sequences(3, 3, 4) [ [3, 3, 6, 9] ] ``` **Note**: The sequences must maintain the properties of the Fibonacci sequence where each subsequent number is the sum of the two preceding numbers, but the starting values are not fixed as in the traditional Fibonacci sequence.","solution":"from typing import List def fibonacci_like_sequences(min_start: int, max_start: int, length: int) -> List[List[int]]: Function to generate Fibonacci-like sequences with specified starting values and length. Args: min_start (int): The minimum starting value for the first term. max_start (int): The maximum starting value for the first term. length (int): The length of the sequences to be generated. Returns: List[List[int]]: A list of valid Fibonacci-like sequences. sequences = [] for first in range(min_start, max_start + 1): for second in range(min_start, max_start + 1): sequence = [first, second] for i in range(2, length): next_value = sequence[-1] + sequence[-2] sequence.append(next_value) sequences.append(sequence) return sequences"},{"question":"# Coding Question Problem Statement You have been appointed to develop a function that simulates a social media platform\'s like and unlike feature for posts. A single user can like or unlike a post multiple times, but the final state should reflect only the last action they performed. Write a function `post_like_status(actions: List[Tuple[str, str]]) -> Dict[str, int]` that takes a list of actions and calculates the final like count for each post. Each action is represented as a tuple of two strings `(username, action_post)`, where `username` specifies the user performing the action, and `action_post` specifies the action in the format \\"like post_id\\" or \\"unlike post_id\\". Input Format * A list of tuples `actions`, each tuple consisting of two strings representing a user\'s action. Output Format * A dictionary where keys are `post_id` and values are the final like count for that post. Constraints * The number of actions will be between 0 and 1,000,000. * Usernames and post IDs will consist of alphanumeric characters and be no longer than 20 characters. * Assume all actions will have valid formats (\\"like\\" or \\"unlike\\"). Example Input and Output ```python assert post_like_status([(\\"user1\\", \\"like post1\\"), (\\"user2\\", \\"like post1\\"), (\\"user1\\", \\"unlike post1\\"), (\\"user3\\", \\"like post2\\"), (\\"user2\\", \\"like post2\\"), (\\"user2\\", \\"unlike post2\\")]) == {\\"post1\\": 1, \\"post2\\": 1} assert post_like_status([(\\"user1\\", \\"like post1\\"), (\\"user2\\", \\"like post1\\"), (\\"user1\\", \\"unlike post1\\"), (\\"user1\\", \\"like post1\\")]) == {\\"post1\\": 2} assert post_like_status([]) == {} assert post_like_status([(\\"user1\\", \\"like post1\\"), (\\"user2\\", \\"unlike post1\\"), (\\"user3\\", \\"like post1\\"), (\\"user1\\", \\"unlike post2\\")]) == {\\"post1\\": 1, \\"post2\\": -1} ``` Guidance * Consider using a dictionary to keep track of users\' last actions on each post. * Ensure the function handles cases where users change their actions multiple times efficiently. * Optimize for time complexity to handle the upper constraint.","solution":"from typing import List, Tuple, Dict def post_like_status(actions: List[Tuple[str, str]]) -> Dict[str, int]: # Dictionary to keep track of each user\'s last action on each post user_actions = {} # Dictionary to keep final like counts for each post post_likes = {} for username, action_post in actions: action, post_id = action_post.split() if username not in user_actions: user_actions[username] = {} previous_action = user_actions[username].get(post_id) if previous_action == action: continue elif previous_action == \\"like\\" and action == \\"unlike\\": post_likes[post_id] = post_likes.get(post_id, 0) - 1 elif previous_action == \\"unlike\\" and action == \\"like\\": post_likes[post_id] = post_likes.get(post_id, 0) + 1 elif previous_action is None and action == \\"like\\": post_likes[post_id] = post_likes.get(post_id, 0) + 1 elif previous_action is None and action == \\"unlike\\": post_likes[post_id] = post_likes.get(post_id, 0) - 1 user_actions[username][post_id] = action return post_likes"},{"question":"# Coding Challenge: Sum of Array Except Self Background You are given an array of integers. Return a new array such that each element at index `i` of the new array is the sum of all the elements in the original array except the one at `i`. Task Write a function `sum_except_self(arr: List[int]) -> List[int]` that computes this new array. Input - A list of integers `arr` where 1 <= len(arr) <= 10^5 and -10^4 <= arr[i] <= 10^4. Output - A list of integers where each element is the sum of all elements in the original array except the one at the same index. Examples ```python assert sum_except_self([1, 2, 3, 4]) == [9, 8, 7, 6] assert sum_except_self([0, 0, 0, 0]) == [0, 0, 0, 0] assert sum_except_self([1, -1, 1, -1]) == [-1, 1, -1, 1] assert sum_except_self([5, -3, 4, 0]) == [1, 9, 2, 6] assert sum_except_self([3]) == [0] ``` # Constraints - The input list `arr` will contain at least one element and up to 100,000 elements. - The solution should not use division and should be optimized for both time and space efficiency.","solution":"from typing import List def sum_except_self(arr: List[int]) -> List[int]: Returns a list such that each element at index \'i\' is the sum of all the elements in the original list except the one at \'i\'. total_sum = sum(arr) result = [total_sum - x for x in arr] return result"},{"question":"In this exercise, you are tasked with implementing a basic text auto-correction system. The system should suggest the most probable correct word for each misspelled word in a given text segment. The suggestions will be based on a provided dictionary of correctly spelled words. # Function to Implement 1. **generate_suggestions**: This function should take a list of words (dictionary) and a misspelled word, then return a list of closest correct matches from the dictionary. 2. **correct_text**: This function should take a text segment and the dictionary, then replace each misspelled word with the most probable correct word based on the suggestions. # Input and Output * **Input**: - A dictionary list containing correctly spelled words (all lowercase). - A text segment string, in which words may be misspelled. Words are separated by spaces and punctuation marks may be present. * **Output**: - For **generate_suggestions**: A list of correctly spelled words from the dictionary that are the most similar to the misspelled word. - For **correct_text**: A corrected text segment string where each misspelled word is replaced by the closest match from the dictionary. # Constraints * The dictionary list will contain at most 10^4 words. * The text segment string will contain at most 10^3 characters. # Example ```python def generate_suggestions(dictionary: list[str], word: str) -> list[str]: pass def correct_text(segment: str, dictionary: list[str]) -> str: pass # Example usage: dictionary = [\\"hello\\", \\"world\\", \\"welcome\\", \\"to\\", \\"the\\", \\"autocorrect\\", \\"system\\"] text = \\"Helo, wrld! Welcome to the auotcorrect systm.\\" suggestions = generate_suggestions(dictionary, \\"Helo\\") print(suggestions) # Example Output: [\\"hello\\"] corrected_text = correct_text(text, dictionary) print(corrected_text) # Example Output: \\"Hello, world! Welcome to the autocorrect system.\\" ``` # Requirements 1. You must use the `generate_suggestions` function to generate the closest matches for each misspelled word. Implement an appropriate algorithm for computing word similarity (e.g., Levenshtein distance). 2. Your correction function (`correct_text`) must handle common punctuation marks (like commas, periods, exclamation marks) appropriately, preserving them in the corrected text and only modifying the misspelled words. 3. Ensure that the corrected text maintains the original casing of the words where appropriate. For example, proper nouns and the first word of a sentence should remain capitalized.","solution":"import re from difflib import get_close_matches def generate_suggestions(dictionary: list[str], word: str) -> list[str]: Returns a list of words that are the closest match to the given misspelled word from the dictionary. # Using difflib.get_close_matches to find the closest matches closest_matches = get_close_matches(word.lower(), dictionary, n=5, cutoff=0.6) return closest_matches def correct_text(segment: str, dictionary: list[str]) -> str: Corrects the text segment by replacing each misspelled word with the closest match from the dictionary. def replace_match(match): word = match.group() match_lc = word.lower() if match_lc in dictionary: return word suggestions = generate_suggestions(dictionary, match_lc) if suggestions: # Preserving the original casing suggestion = suggestions[0] if word[0].isupper(): suggestion = suggestion.capitalize() return suggestion return word # Regular expression to match words word_pattern = re.compile(r\'bw+b\') # Correcting the text corrected_text = re.sub(word_pattern, replace_match, segment) return corrected_text"},{"question":"# Question: Implementing and Solving the Rat in a Maze Problem You are given an N x N maze represented as a 2D list. Some cells are blocked, and some are unblocked. A rat starts at the top-left corner of the maze and needs to find its way to the bottom-right corner. The rat can only move in four directions: up, down, left, and right. Your task is to implement a function that finds one of the possible paths for the rat to take to get to the target. If no path exists, your function should return an empty list. **Your tasks are:** 1. Implement a function that solves the maze using a recursive approach. 2. Ensure that your implementation handles edge cases and larger mazes efficiently. # Input and Output Specification * Function to be implemented: ```python def solve_maze(maze: List[List[int]]) -> List[Tuple[int, int]]: ``` * **Input**: A 2D list representing the maze, where `0` indicates a blocked cell, and `1` indicates an unblocked cell. * The rat starts at `(0, 0)` and needs to reach `(N-1, N-1)`. * **Output**: A list of tuples representing the path from start to finish. If no path exists, return an empty list. **Example:** ```python maze = [[1, 0, 0, 0], [1, 1, 0, 1], [0, 1, 0, 0], [1, 1, 1, 1]] result = solve_maze(maze) print(result) # Expected: A valid path e.g., [(0, 0), (1, 0), (1, 1), (2, 1), (3, 1), (3, 2), (3, 3)] ``` # Requirements: * Implement the `solve_maze` function using a recursive backtracking approach. * The function should check all possible moves and backtrack if a path is blocked. * Ensure the function does not enter an infinite loop and properly handles grid boundaries. # Constraints: * The size of the maze will be at least (2 times 2) and at most (100 times 100). * Cells are either `0` (blocked) or `1` (unblocked).","solution":"from typing import List, Tuple def solve_maze(maze: List[List[int]]) -> List[Tuple[int, int]]: n = len(maze) path = [] # to store the path def is_safe(x, y): if x >= 0 and x < n and y >= 0 and y < n and maze[x][y] == 1: return True return False def solve(x, y): if x == n - 1 and y == n - 1: # Destination is reached path.append((x, y)) return True if is_safe(x, y): path.append((x, y)) # Move Right if solve(x, y + 1): return True # Move Down if solve(x + 1, y): return True # Move Left if solve(x, y - 1): return True # Move Up if solve(x - 1, y): return True # If none of the above moves work, then BACKTRACK: unmark (x, y) as part of solution path path.pop() return False return False # Start from (0, 0) if solve(0, 0): return path else: return []"},{"question":"# Matrix Multiplication You are tasked with implementing a function that performs matrix multiplication on two matrices. Matrices will be represented as lists of lists, where the inner lists are rows of the matrix. Problem Statement: Implement a **matrix_multiply** function that takes in two matrices and returns their product. Matrix multiplication involves taking the dot product of rows and columns from the two input matrices. Function Signature: ```python def matrix_multiply(matrix_a: list, matrix_b: list) -> list: pass ``` Input: * `matrix_a`: A list of lists where each inner list represents a row of the first matrix. * `matrix_b`: A list of lists where each inner list represents a row of the second matrix. Output: * Returns a list of lists representing the resultant matrix product. If multiplication is not possible due to mismatched dimensions, return an empty list. Constraints: * Assume that all rows of a given matrix have the same length. * The number of columns in `matrix_a` should equal the number of rows in `matrix_b` to perform matrix multiplication. Guidelines: 1. If `matrix_a` is an (m times n) matrix and `matrix_b` is an (n times p) matrix, the result will be an (m times p) matrix. 2. For each element in the resulting matrix, compute the dot product of the corresponding row from `matrix_a` and column from `matrix_b`. 3. Return an empty list if matrix multiplication is not possible due to mismatched dimensions. Example: ```python >>> matrix_multiply([[1, 2], [3, 4]], [[2, 0], [1, 2]]) [[4, 4], [10, 8]] >>> matrix_multiply([[1, 0, 2], [-1, 3, 1]], [[3, 1], [2, 1], [1, 0]]) [[5, 1], [4, 2]] >>> matrix_multiply([[1, 2, 3]], [[4], [5], [6]]) [[32]] ```","solution":"def matrix_multiply(matrix_a, matrix_b): Multiplies two matrices and returns the resulting matrix. If the matrices cannot be multiplied due to dimension mismatch, returns an empty list. # Get dimensions of the matrices rows_a = len(matrix_a) cols_a = len(matrix_a[0]) rows_b = len(matrix_b) cols_b = len(matrix_b[0]) # Check if multiplication is possible if cols_a != rows_b: return [] # Initialize the result matrix with zeros result = [[0] * cols_b for _ in range(rows_a)] # Perform the multiplication for i in range(rows_a): for j in range(cols_b): for k in range(cols_a): result[i][j] += matrix_a[i][k] * matrix_b[k][j] return result"},{"question":"# Coding Task: Building a Simple LRU Cache __Context:__ Implement a simple Least Recently Used (LRU) Cache. This cache should support the `get` and `put` operations as described below. The `get` operation retrieves an item from the cache, while the `put` operation inserts or updates an item in the cache. When the cache reaches its maximum capacity, it should evict the least recently used item before inserting a new one. __Question:__ Implement a class `LRUCache` with the following methods: - `__init__(self, capacity: int) -> None`: Initializes the cache with a given positive capacity. - `get(self, key: int) -> int`: Returns the value of the key if the key exists in the cache, otherwise returns `-1`. - `put(self, key: int, value: int) -> None`: Updates the value of the key if the key exists, otherwise adds the key-value pair to the cache. If the number of keys exceeds the capacity, it should evict the least recently used key before adding the new key-value pair. __Expected Input and Output:__ - **Input**: A sequence of `get` and `put` operations. - **Output**: The results of the `get` operations. __Constraints:__ - The number of `get` and `put` operations will be within the range of 0 to 10^5. - The keys and values will be non-negative integers within the range of a 32-bit integer. __Performance Requirements:__ - Both `get` and `put` operations should operate in O(1) average time complexity. __Class Signature:__ ```python class LRUCache: def __init__(self, capacity: int): pass def get(self, key: int) -> int: pass def put(self, key: int, value: int) -> None: pass ``` __Example:__ ```python >>> lru_cache = LRUCache(2) >>> lru_cache.put(1, 1) >>> lru_cache.put(2, 2) >>> lru_cache.get(1) 1 >>> lru_cache.put(3, 3) >>> lru_cache.get(2) -1 >>> lru_cache.put(4, 4) >>> lru_cache.get(1) -1 >>> lru_cache.get(3) 3 >>> lru_cache.get(4) 4 ``` __Additional Notes:__ 1. Use an ordered dictionary or a doubly linked list to efficiently manage the order of elements in the cache. 2. Ensure the cache automatically removes the least recently used item when the capacity is exceeded.","solution":"from collections import OrderedDict class LRUCache: def __init__(self, capacity: int): Initialize the LRU cache with a given positive capacity. self.capacity = capacity self.cache = OrderedDict() def get(self, key: int) -> int: Return the value of the key if it exists, otherwise return -1. Move the key to the end to show it was recently used. if key not in self.cache: return -1 value = self.cache.pop(key) self.cache[key] = value return value def put(self, key: int, value: int) -> None: Update the value of the key if it exists, otherwise add the key-value pair. If the cache exceeds the capacity, remove the least recently used item. if key in self.cache: self.cache.pop(key) elif len(self.cache) >= self.capacity: self.cache.popitem(last=False) self.cache[key] = value"},{"question":"# Anagram Pair Finder Objective Create a function to identify all pairs of anagram strings within a given list. Specification * Implement a function `find_anagram_pairs(words: list[str]) -> list[list[str]]`. * The function should return a list of lists, where each sub-list contains a pair of anagram strings from the input list. * An anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once. Input * A list of strings `words` (1 ≤ len(words) ≤ 1000, 1 ≤ len(word) ≤ 100). Output * A list of lists: Each sub-list containing exactly two strings which are anagrams of each other. Performance Requirements * Time Complexity: O(n * m log m) where n is the length of the `words` list and m is the maximum length of a word. Constraints * Consider case-insensitive anagrams. * Optimize for scenarios with a large number of short words and fewer long words. * Handle edge cases such as no anagram pairs found or list with a single word. Examples ```python def find_anagram_pairs(words: list[str]) -> list[list[str]]: print(find_anagram_pairs([\\"listen\\", \\"silent\\", \\"enlist\\", \\"hello\\", \\"olleh\\", \\"world\\"])) # Should print: [[\'listen\', \'silent\'], [\'listen\', \'enlist\'], [\'silent\', \'enlist\'], [\'hello\', \'olleh\']] print(find_anagram_pairs([\\"test\\", \\"sett\\", \\"tset\\", \\"test\\"])) # Should print: [[\'test\', \'sett\'], [\'test\', \'tset\'], [\'test\', \'test\'], [\'sett\', \'tset\'], [\'sett\', \'test\'], [\'tset\', \'test\']] ``` Challenge Beyond basic implementation, consider optimizing the function for larger datasets and reducing the time complexity where possible. Handle varying word lengths efficiently.","solution":"def find_anagram_pairs(words: list[str]) -> list[list[str]]: from collections import defaultdict # A dictionary to store the sorted tuple of characters as key and original words as values anagrams = defaultdict(list) # Iterate over each word and add it to the correct list in the dictionary for word in words: sorted_word = \'\'.join(sorted(word.lower())) # Sort characters alphabetically and convert to lower case anagrams[sorted_word].append(word) # Generate pairs of anagrams from the lists in the dictionary anagram_pairs = [] for key, group in anagrams.items(): for i in range(len(group)): for j in range(i + 1, len(group)): anagram_pairs.append([group[i], group[j]]) return anagram_pairs"},{"question":"# **Coding Assessment Question:** # Context: You are tasked with developing a text-based game inventory system. The inventory should be able to hold different items, support adding and removing items, and it must properly manage the quantities of each item type. # Question: Implement a Python class that represents an inventory system for a text-based game. Your implementation should allow adding items, removing items, and querying the quantity of any item. Ensure the system handles attempts to remove more items than are present gracefully and provides appropriate feedback. # Class Signature: ```python class GameInventory: def __init__(self): pass def add_item(self, item_name: str, quantity: int) -> None: pass def remove_item(self, item_name: str, quantity: int) -> None: pass def get_quantity(self, item_name: str) -> int: pass ``` # Method Descriptions: - **add_item(item_name: str, quantity: int) -> None**: Adds the given quantity of the specified item to the inventory. If the item already exists, it increments its quantity. - **remove_item(item_name: str, quantity: int) -> None**: Removes the specified quantity of the item from the inventory. If the quantity to be removed exceeds the current quantity, it removes all the items and prints a warning message. - **get_quantity(item_name: str) -> int**: Returns the current quantity of the specified item in the inventory. If the item does not exist, it returns 0. # Constraints: - All item names are non-empty strings made up of alphabetic characters. - Quantities are non-negative integers. - Items that are not present in the inventory are considered to have a quantity of 0. # Example: ```python inventory = GameInventory() inventory.add_item(\\"sword\\", 3) inventory.add_item(\\"shield\\", 2) inventory.add_item(\\"potion\\", 5) print(inventory.get_quantity(\\"sword\\")) # Expected Output: 3 inventory.remove_item(\\"sword\\", 1) print(inventory.get_quantity(\\"sword\\")) # Expected Output: 2 inventory.remove_item(\\"potion\\", 6) # Expected Output: Warning (could be print statement): \\"Attempt to remove more items than present. Remove all potions instead.\\" print(inventory.get_quantity(\\"potion\\")) # Expected Output: 0 ``` # Note: - Ensure your class can handle various edge cases such as trying to add or remove items with invalid quantities. - Document any assumptions and provide clear error or warning messages when needed to guide the user. - Focus on readability and maintainability of your code by following best practices and including necessary comments.","solution":"class GameInventory: def __init__(self): self.inventory = {} def add_item(self, item_name: str, quantity: int) -> None: if quantity < 0: raise ValueError(\\"Quantity must be a non-negative integer.\\") if item_name in self.inventory: self.inventory[item_name] += quantity else: self.inventory[item_name] = quantity def remove_item(self, item_name: str, quantity: int) -> None: if quantity < 0: raise ValueError(\\"Quantity must be a non-negative integer.\\") if item_name in self.inventory: if self.inventory[item_name] > quantity: self.inventory[item_name] -= quantity else: print(f\\"Attempt to remove more items than present. Remove all {item_name}s instead.\\") self.inventory[item_name] = 0 def get_quantity(self, item_name: str) -> int: return self.inventory.get(item_name, 0)"},{"question":"# Scenario In music composition, the structure of a chord often exemplifies the relationship between notes and their intervals. Different types of chords are built by stacking notes at specific intervals. # Problem Create a function `get_major_chord(root_note: str) -> List[str]` that, given a root note, returns the notes of the major chord built from it. # Requirements - Implement this function to correctly identify and return the notes of a major chord. - The function should raise a `ValueError` with an appropriate message if the input root note is not in the range A-G, optionally followed by a sharp (#) or flat (b). # Function Signature ```python from typing import List def get_major_chord(root_note: str) -> List[str]: ... ``` # Input and Output - `get_major_chord`: - **Input**: A string `root_note` representing the root note of the chord (e.g., \\"C\\", \\"G#\\", \\"Bb\\"). - **Output**: A list of three strings representing the notes of the major chord. # Constraints - The input root note will be a valid musical note from the set {A, A#, Bb, B, C, C#, Db, D, D#, Eb, E, F, F#, Gb, G, G#}. - The root note can be uppercase or lowercase (e.g., \\"C\\" and \\"c\\" should be treated as the same note). - Handling of input validation for invalid notes is required. # Examples - `get_major_chord(\\"C\\")` should return `[\\"C\\", \\"E\\", \\"G\\"]`. - `get_major_chord(\\"g#\\")` should return `[\\"G#\\", \\"C\\", \\"D#\\"]`. - `get_major_chord(\\"D\\")` should return `[\\"D\\", \\"F#\\", \\"A\\"]`. - `get_major_chord(\\"Ab\\")` should return `[\\"Ab\\", \\"C\\", \\"Eb\\"]`. - `get_major_chord(\\"H\\")` should raise a `ValueError` with the message \\"Invalid root note.\\" # Testing Use Python\'s built-in `doctest` module to provide test cases demonstrating the usage and correctness of the function. ```python def get_major_chord(root_note: str) -> List[str]: Given a root note, return the notes of the major chord built from it. Examples: >>> get_major_chord(\\"C\\") [\'C\', \'E\', \'G\'] >>> get_major_chord(\\"G#\\") [\'G#\', \'C\', \'D#\'] >>> get_major_chord(\\"D\\") [\'D\', \'F#\', \'A\'] >>> get_major_chord(\\"Bb\\") [\'Bb\', \'D\', \'F\'] >>> get_major_chord(\\"H\\") Traceback (most recent call last): ValueError: Invalid root note. NOTES_SHARP = [\\"C\\", \\"C#\\", \\"D\\", \\"D#\\", \\"E\\", \\"F\\", \\"F#\\", \\"G\\", \\"G#\\", \\"A\\", \\"A#\\", \\"B\\"] NOTES_FLAT = [\\"C\\", \\"Db\\", \\"D\\", \\"Eb\\", \\"E\\", \\"F\\", \\"Gb\\", \\"G\\", \\"Ab\\", \\"A\\", \\"Bb\\", \\"B\\"] root_note = root_note.upper().replace(\'B#\', \'C\').replace(\'E#\', \'F\') if root_note in NOTES_SHARP: note_index = NOTES_SHARP.index(root_note) elif root_note in NOTES_FLAT: note_index = NOTES_FLAT.index(root_note) else: raise ValueError(\\"Invalid root note.\\") major_chord = [ NOTES_SHARP[note_index], NOTES_SHARP[(note_index + 4) % 12], NOTES_SHARP[(note_index + 7) % 12] ] return major_chord ``` This question fits well with the existing set in terms of style, complexity, and scope, as it requires an understanding of music theory and manipulation of lists and strings in Python. The provided examples and constraints ensure the function is implemented correctly and handles various edge cases.","solution":"from typing import List def get_major_chord(root_note: str) -> List[str]: Given a root note, return the notes of the major chord built from it. Examples: >>> get_major_chord(\\"C\\") [\'C\', \'E\', \'G\'] >>> get_major_chord(\\"G#\\") [\'G#\', \'C\', \'D#\'] >>> get_major_chord(\\"D\\") [\'D\', \'F#\', \'A\'] >>> get_major_chord(\\"Bb\\") [\'Bb\', \'D\', \'F\'] >>> get_major_chord(\\"H\\") Traceback (most recent call last): ValueError: Invalid root note. NOTES_SHARP = [\\"C\\", \\"C#\\", \\"D\\", \\"D#\\", \\"E\\", \\"F\\", \\"F#\\", \\"G\\", \\"G#\\", \\"A\\", \\"A#\\", \\"B\\"] NOTES_FLAT = [\\"C\\", \\"Db\\", \\"D\\", \\"Eb\\", \\"E\\", \\"F\\", \\"Gb\\", \\"G\\", \\"Ab\\", \\"A\\", \\"Bb\\", \\"B\\"] root_note = root_note.capitalize() # normalize root note input if root_note in NOTES_SHARP: note_index = NOTES_SHARP.index(root_note) major_chord = [ NOTES_SHARP[note_index], NOTES_SHARP[(note_index + 4) % 12], NOTES_SHARP[(note_index + 7) % 12] ] elif root_note in NOTES_FLAT: note_index = NOTES_FLAT.index(root_note) major_chord = [ NOTES_FLAT[note_index], NOTES_FLAT[(note_index + 4) % 12], NOTES_FLAT[(note_index + 7) % 12] ] else: raise ValueError(\\"Invalid root note.\\") return major_chord"},{"question":"# Context In a classic search problem, finding the optimal solution efficiently is crucial, especially when the search space is vast. Binary search is a highly efficient, divide-and-conquer algorithm that identifies the target element within a sorted array by halving the search space with each iteration. # Problem Statement Implement a function `binary_search` that takes a sorted list of integers and a target value. The function should return the index of the target value if it is present in the list, and `-1` otherwise. Ensure that the function handles edge cases such as empty lists and invalid inputs correctly. # Function Signature ```python def binary_search(arr: list, target: int) -> int: Performs binary search on a sorted list and returns the index of the target value if found. :param arr: A sorted list of integers. :param target: An integer value to search for. :return: The index of the target value if present, otherwise -1. ``` # Input * `arr` (list): A list of sorted integers. * `target` (int): An integer value representing the target to search for in the list. # Output * An integer representing the index of the target value in the list, or `-1` if the target is not found. # Constraints * The function should handle all valid and invalid inputs gracefully. * The list may contain duplicate values, but the function should return the index of one occurrence of the target value. * The target value may not be present in the list. # Examples ```python >>> binary_search([1, 2, 3, 4, 5], 3) 2 >>> binary_search([1, 2, 3, 4, 5], 6) -1 >>> binary_search([], 3) -1 >>> binary_search([1, 2, 2, 2, 3], 2) 1 >>> binary_search([1], 1) 0 >>> binary_search(\\"not a list\\", 2) Traceback (most recent call last): ... ValueError: Invalid input ``` # Note * Ensure that the function operates within (O(log n)) time complexity where ( n ) is the length of the list. * Validate the input list and target value, raising appropriate exceptions for invalid inputs. * Consider edge cases such as empty lists and single-element lists.","solution":"def binary_search(arr, target): Performs binary search on a sorted list and returns the index of the target value if found. :param arr: A sorted list of integers. :param target: An integer value to search for. :return: The index of the target value if present, otherwise -1. :raises: ValueError if the input is invalid if not isinstance(arr, list) or not all(isinstance(x, int) for x in arr): raise ValueError(\\"Invalid input: arr must be a list of integers.\\") if not isinstance(target, int): raise ValueError(\\"Invalid input: target must be an integer.\\") left, right = 0, len(arr) - 1 while left <= right: mid = (left + right) // 2 if arr[mid] == target: return mid elif arr[mid] < target: left = mid + 1 else: right = mid - 1 return -1"},{"question":"# Context Graphs are a fundamental data structure for representing and solving problems involving networks, connectivity, and paths. An efficient way to manage dynamic connectivity queries on a graph is by using the Disjoint Set Union (DSU) or Union-Find data structure. This approach is particularly useful in applications like network connectivity, image processing, and clustering. # Task Implement a class `GraphConnectivity` using the Disjoint Set Union data structure. This class should support the following functionalities: 1. **Adding an edge to the graph**. 2. **Checking if two nodes are connected**. 3. **Counting the number of connected components**. # Your Task Function Implementations **Class**: `GraphConnectivity` 1. **__init__(self, n: int)** - **Input**: An integer `n` representing the number of nodes in the graph (nodes are numbered from 0 to `n-1`). - **Functionality**: Initializes the DSU with `n` nodes. - **Time Complexity**: O(n). 2. **add_edge(self, u: int, v: int)** - **Input**: Two integers `u` and `v` representing an undirected edge between nodes `u` and `v`. - **Functionality**: Adds an edge between `u` and `v` by updating the DSU structure. - **Time Complexity**: O(α(n)), where α is the inverse Ackermann function. 3. **are_connected(self, u: int, v: int) -> bool** - **Input**: Two integers `u` and `v`. - **Output**: Returns `True` if nodes `u` and `v` are in the same connected component, otherwise `False`. - **Time Complexity**: O(α(n)), where α is the inverse Ackermann function. 4. **count_components(self) -> int** - **Output**: Returns the number of connected components in the graph. - **Time Complexity**: O(n). Constraints - The number of nodes `n` will not exceed `10^5`. - The values of `u` and `v` will be between `0` and `n-1`. # Example ```python # Assuming the implementation is already done. gc = GraphConnectivity(5) # Add edges between the nodes gc.add_edge(0, 1) gc.add_edge(1, 2) gc.add_edge(3, 4) # Check if certain nodes are connected print(gc.are_connected(0, 2)) # Output: True print(gc.are_connected(0, 3)) # Output: False # Count the number of connected components print(gc.count_components()) # Output: 2 ```","solution":"class GraphConnectivity: def __init__(self, n: int): Initializes the DSU with `n` nodes. self.parent = list(range(n)) self.rank = [0] * n self.components = n def find(self, u: int) -> int: Finds the root of the set containing `u`, with path compression. if self.parent[u] != u: self.parent[u] = self.find(self.parent[u]) return self.parent[u] def union(self, u: int, v: int): Unites the sets containing `u` and `v`, with union by rank. root_u = self.find(u) root_v = self.find(v) if root_u != root_v: if self.rank[root_u] > self.rank[root_v]: self.parent[root_v] = root_u elif self.rank[root_u] < self.rank[root_v]: self.parent[root_u] = root_v else: self.parent[root_v] = root_u self.rank[root_u] += 1 self.components -= 1 def add_edge(self, u: int, v: int): Adds an edge between `u` and `v` by updating the DSU structure. self.union(u, v) def are_connected(self, u: int, v: int) -> bool: Returns `True` if nodes `u` and `v` are in the same connected component, otherwise `False`. return self.find(u) == self.find(v) def count_components(self) -> int: Returns the number of connected components in the graph. return self.components"},{"question":"# Coding Assessment Question: **Scenario**: You are developing a software module for a basic inventory management system used in a small warehouse. One of the essential features is to track and manage the stock levels of various items. You need to write a function that can handle the insertion of stock entries and notify when the stock level of any item goes below a specified threshold. **Problem Statement**: Create a function to manage the stock level of items in the warehouse. 1. **Function: `manage_stock`** Input: - `items` (list of dicts): A list of dictionaries where each dictionary contains: - `name` (string): Name of the item. - `current_stock` (int): The current stock level of the item. - `threshold` (int): The threshold below which a restock notification should be triggered. Output: - `list`: A list of item names for which the stock level is below the threshold. Constraints: - The `name` must be a non-empty string. - The `current_stock` and `threshold` must be non-negative integers. - Raise a `ValueError` if any item dictionary is missing the required keys, or if any value does not meet the constraints. **Example:** ```python # Example of manage_stock items_list = [ {\'name\': \'itemA\', \'current_stock\': 5}, {\'name\': \'itemB\', \'current_stock\': 3}, {\'name\': \'itemC\', \'current_stock\': 10}, ] print(manage_stock(items_list, 6)) # Output: [\'itemA\', \'itemB\'] items_list = [ {\'name\': \'widget\', \'current_stock\': 13}, {\'name\': \'gadget\', \'current_stock\': 7}, {\'name\': \'thing\', \'current_stock\': 4}, ] print(manage_stock(items_list, 5)) # Output: [\'thing\'] ``` **Performance Requirements**: - Ensure that the function runs in linear time relative to the number of items, with time complexity O(n) where n is the number of items in the list. - The space complexity should be O(n) for the output list. **Note**: - The function should handle edge cases such as an empty list of items gracefully by returning an empty list. - Proper validation for the non-negativity of stock values and threshold must be enforced, raising exceptions as necessary.","solution":"def manage_stock(items, threshold): Manages the stock level of items in the warehouse and returns a list of item names for which the stock level is below the specified threshold. Args: items (list of dicts): A list of dictionaries where each dictionary contains: - \'name\' (string): Name of the item. - \'current_stock\' (int): The current stock level of the item. threshold (int): The threshold below which a restock notification should be triggered. Returns: list: A list of item names for which the stock level is below the threshold. Raises: ValueError: If any dictionary is missing required keys, or if any value does not meet the constraints. if not isinstance(threshold, int) or threshold < 0: raise ValueError(\\"Threshold must be a non-negative integer.\\") low_stock_items = [] for item in items: if not all(key in item for key in (\'name\', \'current_stock\')): raise ValueError(\\"Each item must have \'name\' and \'current_stock\' keys.\\") if not isinstance(item[\'name\'], str) or not item[\'name\']: raise ValueError(\\"Item \'name\' must be a non-empty string.\\") if not isinstance(item[\'current_stock\'], int) or item[\'current_stock\'] < 0: raise ValueError(\\"Item \'current_stock\' must be a non-negative integer.\\") if item[\'current_stock\'] < threshold: low_stock_items.append(item[\'name\']) return low_stock_items"},{"question":"You are required to implement a custom data structure called `CircularQueue` representing a circular queue with a fixed size. This implementation should ensure that the queue efficiently handles enqueue, dequeue, and peek operations with constant time complexity. # Objectives: 1. Write a class `CircularQueue` to initialize the queue with a specified size. 2. Implement the `enqueue` method to add an element to the queue. 3. Implement the `dequeue` method to remove and return an element from the queue. 4. Implement the `peek` method to view the front element without removing it. 5. Implement the `is_empty` method to check if the queue is empty. 6. Implement the `is_full` method to check if the queue is full. # Class and Method Definitions: - `class CircularQueue(size: int)` - **Input**: - size: Integer representing the maximum size of the queue. - **Attributes**: - Initialize necessary attributes, such as the queue array, front pointer, rear pointer, and a count of elements. - `enqueue(value: int) -> bool` - **Input**: - value: An integer value to be added to the queue. - **Output**: Returns `True` if the element was added successfully, `False` if the queue is full. - `dequeue() -> int` - **Output**: Returns the integer value that was removed from the queue. Returns `-1` if the queue is empty. - `peek() -> int` - **Output**: Returns the front element without removing it. Returns `-1` if the queue is empty. - `is_empty() -> bool` - **Output**: Returns `True` if the queue is empty, `False` otherwise. - `is_full() -> bool` - **Output**: Returns `True` if the queue is full, `False` otherwise. # Constraints: - The circular queue should handle at least one element but may handle up to any reasonable size. - Ensure the `enqueue`, `dequeue`, and `peek` operations are performed in constant time. - Do not use Python collections or external libraries to implement the circular queue. # Example Usage: ```python # Creating a queue of size 3 cq = CircularQueue(3) # Enqueue elements print(cq.enqueue(1)) # Output: True print(cq.enqueue(2)) # Output: True print(cq.enqueue(3)) # Output: True print(cq.enqueue(4)) # Output: False (Queue is full) # Peek front element print(cq.peek()) # Output: 1 # Dequeue elements print(cq.dequeue()) # Output: 1 print(cq.dequeue()) # Output: 2 # Check if queue is empty print(cq.is_empty()) # Output: False # Enqueue another element print(cq.enqueue(4)) # Output: True # Check if queue is full print(cq.is_full()) # Output: True # Peek front element print(cq.peek()) # Output: 3 ``` Implement the `CircularQueue` class and its methods in Python following the provided specifications and constraints. Ensure the queue operations conform to the principles of a circular buffer.","solution":"class CircularQueue: def __init__(self, size: int): self.size = size self.queue = [None] * size self.front = self.rear = -1 def enqueue(self, value: int) -> bool: if self.is_full(): return False if self.front == -1: # First element to be inserted self.front = 0 self.rear = (self.rear + 1) % self.size self.queue[self.rear] = value return True def dequeue(self) -> int: if self.is_empty(): return -1 value = self.queue[self.front] if self.front == self.rear: # Queue has only one element self.front = self.rear = -1 else: self.front = (self.front + 1) % self.size return value def peek(self) -> int: if self.is_empty(): return -1 return self.queue[self.front] def is_empty(self) -> bool: return self.front == -1 def is_full(self) -> bool: return (self.rear + 1) % self.size == self.front"},{"question":"# Matrix Diagonal Traversal You are given a 2D matrix of integers. Implement a function to return an array of integers representing the elements of the matrix traversed diagonally (zig-zag order). Function Signature ```python def diagonal_order(matrix: List[List[int]]) -> List[int]: pass ``` # Input - `matrix` (List[List[int]]): A 2D list of integers where 1 <= len(matrix), len(matrix[0]) <= 100. # Output - `List[int]`: A list of integers representing the matrix elements in diagonal order. # Example ```python matrix = [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]] diagonal_order(matrix) # Output: [1, 2, 5, 9, 6, 3, 4, 7, 10, 11, 8, 12] ``` # Constraints - You cannot modify the input matrix. - The function should handle edge cases such as empty matrices, single-row matrices, and single-column matrices. Performance Requirements - The algorithm should run within O(m * n) time complexity. - The space complexity outside the output should be optimized as much as possible, ideally O(1) extra space. # Notes - You may use helper functions if necessary. - Consider the boundary conditions and transitions between rows and columns as you implement the zig-zag order. **Hint:** Carefully manage the traversal logic to switch between upward and downward zig-zag directions, and adjust your indices to stay within matrix bounds.","solution":"from typing import List def diagonal_order(matrix: List[List[int]]) -> List[int]: if not matrix or not matrix[0]: return [] rows, cols = len(matrix), len(matrix[0]) result = [] for d in range(rows + cols - 1): if d % 2 == 0: # even index sum, traverse upwards r = min(d, rows - 1) c = d - r while r >= 0 and c < cols: result.append(matrix[r][c]) r -= 1 c += 1 else: # odd index sum, traverse downwards c = min(d, cols - 1) r = d - c while c >= 0 and r < rows: result.append(matrix[r][c]) c -= 1 r += 1 return result"},{"question":"# Data Analysis: Moving Average Calculation You are provided with a list of daily stock prices for a particular company. Your task is to implement a function to calculate the `n`-day simple moving average for the stock prices. The simple moving average is the unweighted mean of the previous `n` data points. Function Signature: ```python def calculate_moving_average(prices: List[float], n: int) -> List[float]: ``` Inputs: - `prices` (`List[float]`): A list of daily stock prices. - `n` (`int`): The number of days over which the average is calculated. Outputs: - `List[float]`: A list of moving averages. If there are fewer than `n` prices available, the function should return an empty list for those days. Constraints: - The input list of stock prices will have at least `n` elements. - The moving average for the first `n-1` elements should be an empty list since there are not enough elements to compute the moving average. - The solution should handle large lists efficiently. Example Usage: ```python prices = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] n = 3 print(calculate_moving_average(prices, n)) # Expected output: [None, None, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0] ``` Implement `calculate_moving_average` to calculate the `n`-day simple moving average for the provided list of prices. Make sure to handle edge cases effectively and optimize for performance where necessary.","solution":"from typing import List def calculate_moving_average(prices: List[float], n: int) -> List[float]: if len(prices) < n: return [None] * len(prices) moving_averages = [None] * (n - 1) sum_window = sum(prices[:n-1]) for i in range(n-1, len(prices)): sum_window += prices[i] moving_averages.append(sum_window / n) sum_window -= prices[i - n + 1] return moving_averages"},{"question":"**[Question 2]: Sudoku Solver** You are tasked with creating a solver for a standard 9x9 Sudoku puzzle. A Sudoku puzzle consists of a 9x9 grid of cells, which are subdivided into 3x3 subgrids. The puzzle starts with some cells already filled with digits from 1 to 9. Your objective is to fill in the remaining cells such that each row, each column, and each of the nine 3x3 subgrids contain all the digits from 1 to 9 exactly once. # Task Requirements 1. **Backtracking Algorithm**: Implement a backtracking algorithm to solve the Sudoku puzzle. 2. **Validity Check**: Ensure that the placement of each digit respects Sudoku rules. 3. **Partial Solution**: Return the partially filled grid if no complete solution can be determined within a reasonable time frame (e.g., 5 seconds). # Input and Output * **Input**: * `board`: A 9x9 list of lists containing integers between 0 and 9, where 0 represents an empty cell. * **Output**: * The function should return a boolean indicating whether a solution was found and the solved board (9x9 list of lists). If a solution is found, modify the input `board` in place to represent the solution. # Performance Requirements Ensure that the implementation can handle typical Sudoku puzzles efficiently. Optimize for both speed and memory usage, considering the constraints of a 9x9 grid. # Constraints * The input `board` will always be a 9x9 grid. * Each cell contains an integer between 0 and 9 (inclusive). # Context Sudoku puzzles are a popular cognitive challenge that tests logic and pattern recognition skills. Developing an efficient solver involves implementing a robust backtracking algorithm and performing valid placements checks. # Function Template ```python def is_valid(board: list[list[int]], row: int, col: int, num: int) -> bool: Check if it\'s valid to place the `num` at `board[row][col]` # Check current row for i in range(9): if board[row][i] == num: return False # Check current column for i in range(9): if board[i][col] == num: return False # Check 3x3 subgrid start_row, start_col = 3 * (row // 3), 3 * (col // 3) for i in range(start_row, start_row + 3): for j in range(start_col, start_col + 3): if board[i][j] == num: return False return True def sudoku_solver(board: list[list[int]]) -> bool: Implement a backtracking algorithm to solve the Sudoku puzzle. Modifies the board in place and returns True if a solution is found. for row in range(9): for col in range(9): if board[row][col] == 0: for num in range(1, 10): if is_valid(board, row, col, num): board[row][col] = num if sudoku_solver(board): return True board[row][col] = 0 return False return True def solve_sudoku(board: list[list[int]]) -> list[list[int]]: Main function to solve the Sudoku puzzle and return the completed board. If the puzzle is unsolvable, return the board in its current state. import time start_time = time.time() if not sudoku_solver(board): # Return partial solution if no complete solution is found within 5 seconds if time.time() - start_time > 5: return board return board if __name__ == \\"__main__\\": # Example Sudoku puzzle puzzle = [ [5, 3, 0, 0, 7, 0, 0, 0, 0], [6, 0, 0, 1, 9, 5, 0, 0, 0], [0, 9, 8, 0, 0, 0, 0, 6, 0], [8, 0, 0, 0, 6, 0, 0, 0, 3], [4, 0, 0, 8, 0, 3, 0, 0, 1], [7, 0, 0, 0, 2, 0, 0, 0, 6], [0, 6, 0, 0, 0, 0, 2, 8, 0], [0, 0, 0, 4, 1, 9, 0, 0, 5], [0, 0, 0, 0, 8, 0, 0, 7, 9] ] solved_board = solve_sudoku(puzzle) for row in solved_board: print(row) ``` Your task is to implement the Sudoku solver to meet the requirements mentioned above, ensuring correctness, efficiency, and the ability to return a partial solution if necessary.","solution":"def is_valid(board, row, col, num): Check if it\'s valid to place the `num` at `board[row][col]` for i in range(9): if board[row][i] == num: return False if board[i][col] == num: return False start_row, start_col = 3 * (row // 3), 3 * (col // 3) for i in range(start_row, start_row + 3): for j in range(start_col, start_col + 3): if board[i][j] == num: return False return True def sudoku_solver(board): Implement a backtracking algorithm to solve the Sudoku puzzle. Modifies the board in place and returns True if a solution is found. for row in range(9): for col in range(9): if board[row][col] == 0: for num in range(1, 10): if is_valid(board, row, col, num): board[row][col] = num if sudoku_solver(board): return True board[row][col] = 0 return False return True def solve_sudoku(board): Main function to solve the Sudoku puzzle and return the completed board. If the puzzle is unsolvable, return the board in its current state. import time start_time = time.time() if not sudoku_solver(board): if time.time() - start_time > 5: return board return board"},{"question":"# Scenario You work as a software engineer for a logistics company that wants to optimize its fleet management system. One of the tasks involves tracking the maintenance history of each vehicle and predicting the next maintenance period. You need to build a function that calculates the average distance traveled between maintenance checks and predicts the next maintenance date based on past data. # Task Implement the function `predict_next_maintenance` that follows these steps: 1. Groups the vehicles\' maintenance history by vehicle ID. 2. Calculates the average distance traveled between maintenance checks for each vehicle. 3. Predicts the next maintenance distance for each vehicle based on the calculated average. # Function Signature ```python def predict_next_maintenance(maintenance_data: pd.DataFrame) -> pd.DataFrame: ``` # Input - `maintenance_data`: A pandas DataFrame with the following columns: - `vehicle_id`: A string representing the vehicle\'s identifier. - `date`: A string representing the maintenance date in \'YYYY-MM-DD\' format. - `odometer`: An integer representing the odometer reading at the time of maintenance. # Output - Returns a pandas DataFrame with the following columns: - `vehicle_id`: The vehicle\'s identifier. - `next_maintenance_odometer`: The predicted odometer reading for the next maintenance. # Constraints - Each vehicle has at least two maintenance records. - The dates in the DataFrame are in chronological order for each vehicle. # Example ```python import pandas as pd data = pd.DataFrame({ \'vehicle_id\': [\'A123\', \'A123\', \'A123\', \'B456\', \'B456\', \'C789\', \'C789\', \'C789\', \'C789\'], \'date\': [\'2023-01-01\', \'2023-05-01\', \'2023-09-01\', \'2023-02-15\', \'2023-07-15\', \'2023-03-01\', \'2023-06-01\', \'2023-09-01\', \'2023-12-01\'], \'odometer\': [10000, 20000, 30000, 15000, 25000, 12000, 22000, 32000, 42000] }) print(predict_next_maintenance(data)) # Should output: # vehicle_id next_maintenance_odometer # 0 A123 40000 # 1 B456 35000 # 2 C789 52000 ``` Use the provided method signature and implement the logic within the `predict_next_maintenance` function to achieve the described functionality.","solution":"import pandas as pd def predict_next_maintenance(maintenance_data: pd.DataFrame) -> pd.DataFrame: Predicts the next maintenance odometer reading for each vehicle based on the average distance traveled between maintenance checks. Parameters: maintenance_data (pd.DataFrame): DataFrame containing the maintenance history with columns \'vehicle_id\', \'date\', and \'odometer\'. Returns: pd.DataFrame: DataFrame with columns \'vehicle_id\' and \'next_maintenance_odometer\'. # Initialize an empty list to store results results = [] # Group the data by vehicle_id grouped = maintenance_data.groupby(\'vehicle_id\') for vehicle_id, group in grouped: # Sort the group by date (though it is mentioned the data is already in chronological order) group = group.sort_values(by=\'date\') # Calculate the differences in odometer readings distances = group[\'odometer\'].diff().dropna() # Calculate the average distance avg_distance = distances.mean() # Get the latest odometer reading last_odometer = group[\'odometer\'].iloc[-1] # Predict the next maintenance odometer reading next_maintenance_odometer = last_odometer + avg_distance # Append the result as a dictionary results.append({ \'vehicle_id\': vehicle_id, \'next_maintenance_odometer\': next_maintenance_odometer }) # Convert the results list to a DataFrame result_df = pd.DataFrame(results) return result_df"},{"question":"# Problem Statement You are required to write a Python function that generates all possible permutations of a list of unique integers and returns them in lexicographical order. # Function Signature Your task is to implement the following function: ```python def generate_permutations(arr: list) -> list: This function returns a list of all possible permutations of the given list of unique integers, sorted in lexicographical order. :param arr: List of unique integers :type arr: list :return: List of all permutations of arr in lexicographical order :rtype: list :raises ValueError: If the input list contains non-unique elements, or if the list is empty. Example: >>> generate_permutations([1, 2, 3]) [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]] >>> generate_permutations([1, 3, 2]) [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]] pass ``` # Input * A list `arr` of unique integers (where 1 <= len(arr) <= 9). # Output * A list containing all permutations of the input list sorted in lexicographical order. # Constraints * The input list `arr` will always contain unique integers. * The length of the list `arr` will be between 1 and 9 inclusive. * The function should raise a `ValueError` if the list is empty. # Example ```python >>> generate_permutations([1, 2, 3]) [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]] >>> generate_permutations([1, 3, 2]) [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]] >>> generate_permutations([2, 1]) [[1, 2], [2, 1]] ```","solution":"import itertools def generate_permutations(arr: list) -> list: This function returns a list of all possible permutations of the given list of unique integers, sorted in lexicographical order. :param arr: List of unique integers :type arr: list :return: List of all permutations of arr in lexicographical order :rtype: list :raises ValueError: If the input list contains non-unique elements, or if the list is empty. if not arr: raise ValueError(\\"Input list should not be empty\\") # Generate all permutations permutations = list(itertools.permutations(arr)) # Convert tuples to lists permutations = [list(p) for p in permutations] # Sort permutations in lexicographical order permutations.sort() return permutations"},{"question":"# Coding Assessment Question: Matrix Class Enhancement with Transposition Context You\'ve been provided with a matrix class that supports a wide range of operations, including row and column manipulations, matrix arithmetic, determinants, and more. However, the matrix class currently lacks methods to handle transposition efficiently. The transpose of a matrix is formed by turning all the columns of the original matrix into the rows of a new matrix. This operation is widely used in mathematical contexts and practical applications. Task Implement a method within the provided `Matrix` class to compute the transpose of the matrix. Function Signature ```python def transpose(self) -> \'Matrix\': Computes the transpose of the matrix. Returns: Matrix: A new Matrix instance that is the transpose of the original matrix. ``` Input - The matrix is already initialized using the provided `Matrix` class. - No additional inputs are required. Output - The function should return a new `Matrix` object that is the transpose of the original matrix. Constraints - You must use the existing `Matrix` class and its methods where applicable. - Consider edge cases such as empty matrices or single-element matrices. - Ensure the method maintains the integrity of the input matrix (i.e., the original matrix should not be altered). Example ```python # Example 1 matrix1 = Matrix([ [1, 2, 3], [4, 5, 6] ]) transposed_matrix1 = matrix1.transpose() print(transposed_matrix1.data) # Expected output: [[1, 4], [2, 5], [3, 6]] # Example 2 matrix2 = Matrix([ [1, 2], [3, 4], [5, 6] ]) transposed_matrix2 = matrix2.transpose() print(transposed_matrix2.data) # Expected output: [[1, 3, 5], [2, 4, 6]] # Example 3 matrix3 = Matrix([ [7] ]) transposed_matrix3 = matrix3.transpose() print(transposed_matrix3.data) # Expected output: [[7]] ``` Additional Notes - You can utilize list comprehensions or nested loops to accomplish the transposition. - Ensure to create a deep copy when forming the new matrix to avoid unintended side-effects on the original matrix.","solution":"class Matrix: def __init__(self, data): self.data = data def transpose(self): Computes the transpose of the matrix. Returns: Matrix: A new Matrix instance that is the transpose of the original matrix. transposed_data = [list(row) for row in zip(*self.data)] return Matrix(transposed_data)"},{"question":"**Question:** You have been given a list of positive integers. Your task is to find the first missing positive integer that is not present in the list. Your solution must be optimized to run in O(n) time and use O(1) extra space. # Task: Implement the function `find_missing_positive` which finds the first missing positive integer from the list and returns it. # Input: - **Input Type**: List of integers - **Description**: A list of positive integers containing at least one element. # Output: - **Return Type**: Integer - **Description**: The first missing positive integer that is not present in the list. # Constraints and Notes: - The integers in the list are all positive. - The list may contain duplicates. - The list size is not fixed, but you need to ensure the solution is efficient. # Example: ``` find_missing_positive([3, 4, -1, 1]) -> 2 find_missing_positive([1, 2, 0]) -> 3 find_missing_positive([7, 8, 9, 11, 12]) -> 1 ``` ```python def find_missing_positive(nums: list[int]) -> int: Finds the first missing positive integer from a given list of positive integers. :param nums: List of integers :type nums: list[int] :return: The first missing positive integer :rtype: int n = len(nums) # Place each number in its right place, i.e., 1 at index 0, 2 at index 1, etc. for i in range(n): while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]: nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1] # After all numbers are placed correctly, the first place where # the index doesn\'t match the value will be our answer. for i in range(n): if nums[i] != i + 1: return i + 1 return n + 1 if __name__ == \\"__main__\\": print(find_missing_positive([3, 4, -1, 1])) # Output: 2 print(find_missing_positive([1, 2, 0])) # Output: 3 print(find_missing_positive([7, 8, 9, 11, 12])) # Output: 1 ```","solution":"def find_missing_positive(nums: list[int]) -> int: Finds the first missing positive integer from a given list of positive integers. :param nums: List of integers :type nums: list[int] :return: The first missing positive integer :rtype: int n = len(nums) # Place each number in its right place, i.e., 1 at index 0, 2 at index 1, etc. for i in range(n): while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]: nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1] # After all numbers are placed correctly, the first place where # the index doesn\'t match the value will be our answer. for i in range(n): if nums[i] != i + 1: return i + 1 return n + 1"},{"question":"# Implement Stack with Minimum Element Retrieval You are tasked with implementing a stack data structure that, in addition to the standard stack operations, supports retrieving the minimum element in constant time. Tasks: 1. **Stack Class Implementation**: - **Initialization**: Initialize an empty stack. - **Push**: Add an element to the top of the stack. - **Pop**: Remove and return the element at the top of the stack. - **Top**: Return the element at the top without removing it. - **Get Minimum**: Retrieve the minimum element in the stack in constant time. - **Is Empty**: Check if the stack is empty. Constraints: - The elements of the stack will be integers within the range of -1000 and 1000. - The number of push and pop operations will not exceed 10^4. Expected Input and Output Format: - **Input**: Operations by calling various methods. - **Output**: Results of operations printed as needed. Example: ```python stack = MinStack() # Push elements stack.push(-2) stack.push(0) stack.push(-3) # Retrieve the minimum element print(stack.get_minimum()) # Output: -3 # Pop the top element stack.pop() # Retrieve the top element print(stack.top()) # Output: 0 # Retrieve the minimum element print(stack.get_minimum()) # Output: -2 ``` Implement the `MinStack` class such that it satisfies the constraints above, handling any edge cases appropriately.","solution":"class MinStack: def __init__(self): Initialize an empty stack. self.stack = [] self.min_stack = [] def push(self, val: int) -> None: Push an element onto the stack. self.stack.append(val) if not self.min_stack or val <= self.min_stack[-1]: self.min_stack.append(val) def pop(self) -> None: Remove and return the top element from the stack. if self.stack: top = self.stack.pop() if top == self.min_stack[-1]: self.min_stack.pop() return top def top(self) -> int: Get the top element of the stack. if self.stack: return self.stack[-1] return None # Should ideally handle the case where stack is empty def get_minimum(self) -> int: Retrieve the minimum element in the stack. if self.min_stack: return self.min_stack[-1] return None # Should ideally handle the case where stack is empty def is_empty(self) -> bool: Check if the stack is empty. return len(self.stack) == 0"},{"question":"# Coding Question: Scheduled Email Reminder System **Scenario**: You are developing a system to send email reminders on a scheduled basis. The system should ensure that the reminders are sent at the correct times and can handle transient issues like temporary mail server downtimes. Additionally, if the reminder cannot be sent after multiple attempts, the system should log the failure for further investigation. **Requirements**: 1. Implement a function `send_scheduled_email(recipient_email: str, subject: str, body: str, send_time: datetime.datetime, server_url: str) -> None` that sends an email reminder. 2. The function should check the current time and send the email at or after the scheduled time specified by `send_time`. 3. The function should retry sending the email up to 3 times if it encounters any network issues or receives a non-200 status code from the mail server. 4. If all attempts fail, the function should log the failure by writing an error message to a file named `email_failures.log`. **Input**: * `recipient_email` - The email address of the recipient (a valid email string). * `subject` - The subject of the email (a non-empty string). * `body` - The body of the email (a non-empty string). * `send_time` - The scheduled time to send the email (a `datetime.datetime` object). * `server_url` - The mail server API URL (a valid URL string). **Output**: * None if the email is sent successfully. * Logs failure messages to `email_failures.log` after 3 unsuccessful attempts. **Constraints**: * The subject will not exceed 255 characters. * The body will not exceed 1000 characters. * The email address will be valid. * The server URL will be a valid mail server URL. * Ensure to import the necessary libraries for handling datetime and logging. **Example**: ```python import datetime import requests import time import logging def send_scheduled_email(recipient_email: str, subject: str, body: str, send_time: datetime.datetime, server_url: str) -> None: current_time = datetime.datetime.now() if current_time < send_time: time_to_wait = (send_time - current_time).total_seconds() time.sleep(max(time_to_wait, 0)) attempts = 3 for attempt in range(attempts): try: response = requests.post(server_url, json={ \'recipient\': recipient_email, \'subject\': subject, \'body\': body }) if response.status_code == 200: return except requests.RequestException as e: pass time.sleep(2) # Delay before retry logging.basicConfig(filename=\'email_failures.log\', level=logging.ERROR) logging.error(f\\"Failed to send email to {recipient_email} after {attempts} attempts\\") # Example use case try: send_scheduled_email( \\"recipient@example.com\\", \\"Scheduled Reminder\\", \\"This is a scheduled reminder email.\\", datetime.datetime(2023, 10, 30, 14, 0), \\"<MAIL_SERVER_API_URL>\\" ) print(\\"Email sent successfully\\") except Exception as e: print(f\\"An error occurred: {e}\\") ``` **Hints**: * Use Python\'s `requests` library for HTTP requests. * Use the `datetime` library to handle the scheduling time. * Use Python\'s `logging` module for logging errors to a file.","solution":"import datetime import requests import time import logging def send_scheduled_email(recipient_email: str, subject: str, body: str, send_time: datetime.datetime, server_url: str) -> None: current_time = datetime.datetime.now() if current_time < send_time: time_to_wait = (send_time - current_time).total_seconds() time.sleep(max(time_to_wait, 0)) attempts = 3 for attempt in range(attempts): try: response = requests.post(server_url, json={ \'recipient\': recipient_email, \'subject\': subject, \'body\': body }) if response.status_code == 200: return except requests.RequestException: pass time.sleep(2) # Delay before retry logging.basicConfig(filename=\'email_failures.log\', level=logging.ERROR) logging.error(f\\"Failed to send email to {recipient_email} after {attempts} attempts\\")"},{"question":"# Question: Implement a Pathfinding Algorithm for Hexagonal Grids. Context: You are tasked with implementing a pathfinding algorithm to navigate a hexagonal grid. Each cell in the grid has coordinates `(q, r, s)` where `q`, `r`, and `s` are integers, and they satisfy the condition `q + r + s = 0`. The goal is to calculate the shortest path from a start cell to an end cell, taking into account blocked cells that cannot be traversed. Task: Implement a function `find_hex_path` to find the shortest path in a hexagonal grid. The path should avoid blocked cells. Specifications: 1. **Input**: - `start`: A tuple representing the starting cell in the format `(q, r, s)`. - `end`: A tuple representing the ending cell in the format `(q, r, s)`. - `blocked_cells`: A list of tuples, where each tuple represents a blocked cell in the format `(q, r, s)`. 2. **Output**: - `shortest_path`: A list of tuples representing the cells in the shortest path from `start` to `end`, inclusive. If no path exists, return an empty list. 3. **Constraints**: - The function must handle grids of varying sizes, depending on the specified `start`, `end`, and blocked cells. - Cells are valid only if they satisfy the condition `q + r + s = 0`. - The distance between adjacent hexagonal cells is 1. - If `start` or `end` is a blocked cell, return an empty list. Example Input: ```python start = (0, 0, 0) end = (2, -1, -1) blocked_cells = [(1, 0, -1)] ``` Example Output: ```python [(0, 0, 0), (1, -1, 0), (2, -1, -1)] ``` This output indicates the shortest path from the start cell `(0, 0, 0)` to the end cell `(2, -1, -1)` that avoids the blocked cell `(1, 0, -1)`. Instructions: 1. **Valid Moves**: Implement logic for determining valid neighboring cells. 2. **Pathfinding Algorithm**: Use A* or another suitable pathfinding algorithm to find the shortest path. 3. **Edge Cases**: Consider edge cases such as the start or end cell being blocked. 4. **Testing**: Write at least 3 test cases to verify your implementation. Write a function `find_hex_path(start, end, blocked_cells)` that follows the specifications and returns the correct output.","solution":"from collections import deque def find_hex_path(start, end, blocked_cells): Finds the shortest path from start to end on a hexagonal grid, avoiding blocked cells. Parameters: start (tuple): The starting cell (q, r, s). end (tuple): The ending cell (q, r, s). blocked_cells (list): List of blocked cells on the grid. Returns: list: The shortest path from start to end as a list of cells, or an empty list if no path exists. def get_neighbors(cell): q, r, s = cell return [ (q+1, r-1, s), (q-1, r+1, s), (q, r+1, s-1), (q, r-1, s+1), (q+1, r, s-1), (q-1, r, s+1) ] blocked_set = set(blocked_cells) if start in blocked_set or end in blocked_set: return [] queue = deque([(start, [start])]) seen = set([start]) while queue: current, path = queue.popleft() if current == end: return path for neighbor in get_neighbors(current): if neighbor not in seen and neighbor not in blocked_set and sum(neighbor) == 0: seen.add(neighbor) queue.append((neighbor, path + [neighbor])) return []"},{"question":"# Linked List Problem with Complexity Analysis **Scenario**: As a software developer, you often work with different data structures. In a recent project, you are required to manipulate a singly linked list to perform specific operations efficiently. One of the tasks is to reverse the linked list, which is fundamental for several algorithms you implement. **Task**: Implement a function `reverse_linked_list` that takes the head of a singly linked list and returns the head of the reversed list. Clearly understand the structure of a ListNode as shown in the constraints. **Function Signature**: ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_linked_list(head: ListNode) -> ListNode: Reverses a singly linked list. Parameters: head (ListNode): The head of the singly linked list. Returns: ListNode: The head of the reversed linked list. Example Usage: >>> node1 = ListNode(1) >>> node2 = ListNode(2) >>> node3 = ListNode(3) >>> node1.next = node2 >>> node2.next = node3 >>> new_head = reverse_linked_list(node1) >>> new_head.val 3 >>> new_head.next.val 2 >>> new_head.next.next.val 1 # Your code here ``` **Constraints**: - Assume that the ListNode class is defined with an integer value `val` and a pointer to the next node `next`. - The linked list nodes contain integer values. Each node is created using `ListNode(val)`. - The function should handle cases where the linked list is empty or contains only one node efficiently. The problem is designed to test your understanding of linked lists and your ability to manipulate pointers directly in such data structures. The solution should be linear in time complexity, O(n), where n is the number of nodes in the linked list, and constant in space complexity, O(1), not including the input data structures.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_linked_list(head: ListNode) -> ListNode: Reverses a singly linked list. Parameters: head (ListNode): The head of the singly linked list. Returns: ListNode: The head of the reversed linked list. prev = None current = head while current: next_node = current.next # store the next node current.next = prev # reverse the link prev = current # move prev one step ahead current = next_node # move current one step ahead return prev"},{"question":"**Balanced String Partition** A balanced string is defined as a string with an equal number of \'L\' and \'R\' characters. Given a balanced string `s`, subdivide it into the minimum number of balanced substrings. Write a function `min_balanced_substrings` that takes a single argument, a balanced string `s`, and returns an integer representing the minimum number of balanced substrings you can obtain. # Function Signature ```python def min_balanced_substrings(s: str) -> int: ``` # Input - `s`: A balanced string consisting of the characters \'L\' and \'R\'. # Output - Returns an integer representing the minimum number of balanced substrings. # Constraints - The length of `s` will be between 2 and 1000. - `s` will always be a balanced string. # Example ```python >>> min_balanced_substrings(\\"RLRRLLRLRL\\") 4 >>> min_balanced_substrings(\\"RLLLLRRRLR\\") 3 >>> min_balanced_substrings(\\"LLLLRRRR\\") 1 ``` # Notes - Ensure the function efficiently partitions the string with a linear scan. - Consider the balance point where the number of \'L\' and \'R\' characters are equal while traversing the string from the start. # Explanation - In the example \\"RLRRLLRLRL\\", the balanced substrings are [\\"RL\\", \\"RRLL\\", \\"RL\\", \\"RL\\"]. - In the example \\"RLLLLRRRLR\\", the balanced substrings are [\\"RL\\", \\"LLLRRR\\", \\"LR\\"]. - In the example \\"LLLLRRRR\\", the entire string is already balanced.","solution":"def min_balanced_substrings(s: str) -> int: count = 0 balance = 0 for char in s: if char == \'L\': balance += 1 else: balance -= 1 if balance == 0: count += 1 return count"},{"question":"# Meeting Scheduler Objective: You are organizing a team meeting and have a list of available time intervals for each team member. The goal is to find a time slot that all team members can attend, which is at least `duration` minutes long. If no such slot exists, return an empty list. # Function Signature: ```python def find_meeting_slot(available_times: list[list[tuple[int, int]]], duration: int) -> list[int]: pass ``` Input: * `available_times` is a list where each element is a list of tuples. Each tuple represents a time interval in the format `(start, end)` where `start` and `end` are integers denoting time in minutes from the start of the day (0 ≤ start < end ≤ 1440). * `duration` is an integer representing the required duration of the meeting in minutes. Output: * Return a list with two integers `[start, end]` representing the start and end times of the earliest meeting slot that fits the criteria. If no suitable slot is found, return an empty list. Constraints: * 1 ≤ len(available_times) ≤ 50 * 1 ≤ len(available_times[i]) ≤ 100 * 0 ≤ available_times[i][j][0] < available_times[i][j][1] ≤ 1440 * 1 ≤ duration ≤ 1440 Examples: 1. `find_meeting_slot([[(60, 120), (150, 210)], [(0, 30), (90, 150), (180, 240)]], 30)` => Returns `[90, 120]` 2. `find_meeting_slot([[(540, 600)], [(600, 660), (720, 780)]], 45)` => Returns `[]` Considerations: * The function should be efficient given the constraints of the problem. * Handle edge cases where one participant is only available after another participant\'s last slot ends. * Ensure the function can handle overlapping intervals correctly.","solution":"def find_meeting_slot(available_times: list[list[tuple[int, int]]], duration: int) -> list[int]: Finds the earliest time slot available for all team members that is at least `duration` minutes long. If no such slot exists, returns an empty list. if not available_times or duration <= 0: return [] # Flatten and sort all intervals all_intervals = sorted([interval for member in available_times for interval in member]) # Merge overlapping intervals merged_intervals = [] for interval in all_intervals: if merged_intervals and merged_intervals[-1][1] >= interval[0]: merged_intervals[-1] = (merged_intervals[-1][0], max(merged_intervals[-1][1], interval[1])) else: merged_intervals.append(interval) # Intersect merged intervals to find common time slots intersected_intervals = merged_intervals for member in available_times: new_intersected_intervals = [] for c_interval in intersected_intervals: for m_interval in member: start = max(c_interval[0], m_interval[0]) end = min(c_interval[1], m_interval[1]) if start + duration <= end: new_intersected_intervals.append((start, end)) intersected_intervals = new_intersected_intervals return [intersected_intervals[0][0], intersected_intervals[0][0] + duration] if intersected_intervals else []"},{"question":"# String Permutations with Case Changes You are provided with a string `s` containing only English letters. Your task is to generate all possible permutations of the given string by toggling the case of each character. This means each letter can either be in lowercase or uppercase, leading to `2^n` possible permutations, where `n` is the length of the string. You need to implement a function `string_case_permutations(s)` which returns all the possible permutations as a list of strings. Function Signature ```python def string_case_permutations(s: str) -> List[str]: pass ``` # Input Format - `s`: A string of length `1 <= len(s) <= 12`, consisting of only English letters. # Output Format - Return a list of strings containing all possible permutations with varied cases. # Constraints - The string will only contain alphabetical characters (both uppercase and lowercase). - The output list should contain unique permutations of the string. - Ensure efficient generation of permutations. Example ```python # Example 1 s = \\"a1b\\" # Permutations: [\\"a1b\\", \\"A1b\\", \\"a1B\\", \\"A1B\\"] assert sorted(string_case_permutations(s)) == [\\"A1B\\", \\"A1b\\", \\"a1B\\", \\"a1b\\"] # Example 2 s = \\"123\\" # Permutations: Since all characters are digits, only one permutation is possible. assert sorted(string_case_permutations(s)) == [\\"123\\"] # Example 3 s = \\"Ab\\" # Permutations: [\\"Ab\\", \\"AB\\", \\"ab\\", \\"aB\\"] assert sorted(string_case_permutations(s)) == [\\"AB\\", \\"Ab\\", \\"aB\\", \\"ab\\"] # Example 4 s = \\"\\" # There are no permutations of an empty string. assert sorted(string_case_permutations(s)) == [] ``` Implement the function such that it efficiently computes all variations by toggling the case of each character in the string. The solution should handle the given input examples correctly.","solution":"from typing import List def string_case_permutations(s: str) -> List[str]: def backtrack(sub=\\"\\", index=0): if index == len(s): result.append(sub) return if s[index].isalpha(): backtrack(sub + s[index].lower(), index + 1) backtrack(sub + s[index].upper(), index + 1) else: backtrack(sub + s[index], index + 1) result = [] backtrack() return result"},{"question":"# Matrix Transposition and Sum You are given a matrix (2D list) of integers. Your task is to enhance the provided function `transpose_and_sum` to perform the following operations: Enhanced Requirements: 1. **Matrix Validation**: Ensure the input is a 2D list where each row is of the same length and contains only integers. Raise a ValueError if not. 2. **Matrix Transposition**: Transpose the given matrix. The transpose of a matrix is obtained by swapping rows with columns. 3. **Element-wise Sum**: After transposing, return the element-wise sum of the original matrix and its transpose. 4. **Boundary Handling**: If the input matrix is empty, return an empty matrix. Input and Output Format: * **Input**: The function will receive a 2D list of integers. * **Output**: The function should return a 2D list representing the element-wise sum of the original matrix and its transpose. Constraints: * The matrix will have dimensions ( m times n ), where ( 1 leq m leq 100 ) and ( 1 leq n leq 100 ). * Each element in the matrix is an integer in the range ([-10^3, 10^3]). # Example Usage ```python >>> transpose_and_sum([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[2, 6, 10], [6, 10, 14], [10, 14, 18]] >>> transpose_and_sum([[1, -2], [3, 4]]) [[2, 1], [1, 8]] >>> transpose_and_sum([]) [] ``` # Function Signature ```python def transpose_and_sum(matrix: list[list[int]]) -> list[list[int]]: pass ```","solution":"def transpose_and_sum(matrix): Returns the element-wise sum of a matrix and its transpose. Validates the input matrix and returns error messages if needed. If the matrix is empty, returns an empty matrix. if not all(isinstance(row, list) for row in matrix): raise ValueError(\\"Input must be a 2D list\\") if not matrix: # Empty matrix check return [] row_length = len(matrix[0]) if any(len(row) != row_length for row in matrix): raise ValueError(\\"All rows in the matrix must be of the same length\\") if any(not all(isinstance(item, int) for item in row) for row in matrix): raise ValueError(\\"All elements of the matrix must be integers\\") m = len(matrix) n = len(matrix[0]) # Transpose the matrix transpose = [[matrix[j][i] for j in range(m)] for i in range(n)] # Calculate the element-wise sum of the original matrix and its transpose result = [[matrix[i][j] + transpose[i][j] for j in range(n)] for i in range(m)] return result"},{"question":"# Coding Assessment Question Problem Statement You are tasked with extending a system of functions that compute characteristics related to circular motion. Currently, functions are provided to determine the centripetal force and centripetal acceleration of an object in circular motion. Your objective is to implement an additional function to calculate the angular velocity of an object that completes a specified number of revolutions over a given period of time. Detailed Description * **Function Name**: `angular_velocity` * **Inputs**: * `revolutions` (float): The number of complete revolutions made by the object. * `time` (float): The time taken to complete the specified number of revolutions (in seconds). * **Output**: * Returns the angular velocity of the object in radians per second (rad/s). * **Constraints**: * `revolutions` must be non-negative. * `time` must be positive. * Raise appropriate exceptions with helpful error messages if the constraints are violated. Formulas The angular velocity (ω) can be calculated as: [ omega = frac{2pi cdot text{revolutions}}{text{time}} ] Where: * (2pi) is a constant representing one full revolution in radians. * `revolutions` is the number of complete cycles the object makes. * `time` is the duration in which the revolutions are made. Example ```python >>> angular_velocity(5, 10) # 5 revolutions in 10 seconds 3.141592653589793 >>> angular_velocity(3, 20) # 3 revolutions in 20 seconds 0.9424777960769379 >>> angular_velocity(-2, 10) # invalid number of revolutions Traceback (most recent call last): ... Exception: Number of revolutions cannot be negative >>> angular_velocity(2, 0) # invalid time Traceback (most recent call last): ... Exception: Time should be greater than 0 seconds ``` Implementation Implement the function in Python, structured as follows: ```python from math import pi def angular_velocity(revolutions: float, time: float) -> float: Takes the number of revolutions and the time (in seconds) and returns the angular velocity of the object in rad/s. Examples: >>> angular_velocity(5, 10) # 5 revolutions in 10 seconds 3.141592653589793 >>> angular_velocity(3, 20) # 3 revolutions in 20 seconds 0.9424777960769379 >>> angular_velocity(-2, 10) # invalid number of revolutions Traceback (most recent call last): ... Exception: Number of revolutions cannot be negative >>> angular_velocity(2, 0) # invalid time Traceback (most recent call last): ... Exception: Time should be greater than 0 seconds if revolutions < 0: raise Exception(\\"Number of revolutions cannot be negative\\") if time <= 0: raise Exception(\\"Time should be greater than 0 seconds\\") return (2 * pi * revolutions) / time ```","solution":"from math import pi def angular_velocity(revolutions: float, time: float) -> float: Takes the number of revolutions and the time (in seconds) and returns the angular velocity of the object in rad/s. :param revolutions: float, number of revolutions :param time: float, time in seconds :return: float, angular velocity in rad/s :raises Exception: if `revolutions` is negative :raises Exception: if `time` is not positive Examples: >>> angular_velocity(5, 10) # 5 revolutions in 10 seconds 3.141592653589793 >>> angular_velocity(3, 20) # 3 revolutions in 20 seconds 0.9424777960769379 >>> angular_velocity(-2, 10) # invalid number of revolutions Traceback (most recent call last): ... Exception: Number of revolutions cannot be negative >>> angular_velocity(2, 0) # invalid time Traceback (most recent call last): ... Exception: Time should be greater than 0 seconds if revolutions < 0: raise Exception(\\"Number of revolutions cannot be negative\\") if time <= 0: raise Exception(\\"Time should be greater than 0 seconds\\") return (2 * pi * revolutions) / time"},{"question":"# Shortest Path in a Weighted Graph using Dijkstra\'s Algorithm Background: You are tasked with writing a function to find the shortest path from a source node to all other nodes in a directed, weighted graph using Dijkstra\'s Algorithm. Task: Implement the function `dijkstra_shortest_path` which: - Accepts an integer `n` representing the number of nodes, an integer `src` representing the source node, and a 2D list `edges` where each element is a triplet `[u, v, w]` representing an edge from node `u` to node `v` with weight `w`. - Returns a list of shortest distances from the source node to all other nodes where the i-th position in the list represents the shortest distance to node `i`. - If a node is unreachable from the source node, its distance should be represented by `float(\'inf\')`. Input Format: * An integer `n` representing the number of nodes. * An integer `src` denoting the source node. * A 2D list, `edges`, where `edges[i] = [u, v, w]` is the edge from node `u` to node `v` with weight `w`. Output Format: * A list of length `n` with the shortest distances from the source node to each node. Constraints: * 1 <= n <= 100 * 0 <= src < n * 0 <= len(edges) <= 1000 * 0 <= u, v < n * -1000 <= w <= 1000 * The graph may contain negative weights, but no negative weight cycles. Example: ```python # Example 1 n = 5 src = 0 edges = [ [0, 1, 2], [0, 2, 4], [1, 2, 1], [1, 3, 7], [2, 4, 3], [3, 4, 1] ] distances = dijkstra_shortest_path(n, src, edges) print(distances) # Expected: [0, 2, 3, 9, 6] # Example 2 n = 3 src = 0 edges = [ [0, 1, 4], [1, 2, 6], [0, 2, 5] ] distances = dijkstra_shortest_path(n, src, edges) print(distances) # Expected: [0, 4, 5] ``` Notes: - Ensure correct handling of nodes that are not reachable from the source by returning `float(\'inf\')` for those nodes. - The function should efficiently manage the priority queue to ensure Dijkstra\'s algorithm is implemented optimally.","solution":"import heapq def dijkstra_shortest_path(n, src, edges): Find the shortest path from the source node to all other nodes using Dijkstra\'s Algorithm. :param n: Number of nodes :param src: Source node :param edges: List of edges represented as [u, v, w] :return: List of shortest distances from the source node to each node # Initialize graph as an adjacency list graph = [[] for _ in range(n)] for u, v, w in edges: graph[u].append((v, w)) # Initialize distances with infinity distances = [float(\'inf\')] * n distances[src] = 0 # Priority queue to process nodes pq = [(0, src)] # (distance, node) while pq: current_distance, u = heapq.heappop(pq) # If the distance is greater than the already found shortest distance, ignore it if current_distance > distances[u]: continue # Explore neighbors for v, weight in graph[u]: distance = current_distance + weight # Only consider this new path if it\'s shorter if distance < distances[v]: distances[v] = distance heapq.heappush(pq, (distance, v)) return distances"},{"question":"# Problem Statement **Cycle Detection in a Directed Graph** You are required to detect cycles in a directed graph. A cycle in a directed graph occurs when a vertex is reachable from itself, following the directed edges. Implement an algorithm that checks if the given directed graph contains any cycles. # Requirements: 1. You are provided with a directed graph represented as an adjacency list. 2. You need to implement the `GraphCycleDetector` class to check for cycles in the graph. # Implementation Details: - Implement the following methods: 1. `__init__(self, graph: dict[int, list[int]])` - Initializes the `GraphCycleDetector` with the given graph. 2. `detect_cycle(self) -> bool` - Performs the cycle detection and returns `True` if a cycle is found, otherwise `False`. # Expected Input and Output - **Input**: - A directed graph represented as an adjacency list, where the keys are vertex identifiers and the values are lists of vertices that the key vertex has directed edges to. - **Output**: - A boolean value indicating the presence of a cycle in the graph. Constraints: - The graph will have at least one vertex. - The vertex identifiers are integers starting from `0`. - The graph may have disconnected components. # Sample Usage: ```python # Define the directed graph layout graph = { 0: [1, 2], 1: [2], 2: [0, 3], 3: [3] } # Instantiating and checking for cycles cycle_detector = GraphCycleDetector(graph) has_cycle = cycle_detector.detect_cycle() print(has_cycle) # Expected output: True (due to the cycle 0 -> 2 -> 0 and 3 -> 3) ``` --- # Note: This problem requires understanding of graph theory, specifically cycle detection algorithms such as Depth-First Search (DFS) with recursion stack approach. Be sure to think about edge cases, such as graphs with no edges or isolated vertices. Good luck!","solution":"class GraphCycleDetector: def __init__(self, graph): self.graph = graph self.visited = set() self.rec_stack = set() def detect_cycle_util(self, vertex): # Mark the current node as visited and # adds it to the recursion stack self.visited.add(vertex) self.rec_stack.add(vertex) # Recur for all vertices adjacent to this vertex for neighbour in self.graph.get(vertex, []): if neighbour not in self.visited: if self.detect_cycle_util(neighbour): return True elif neighbour in self.rec_stack: return True # Remove the vertex from recursion stack self.rec_stack.remove(vertex) return False def detect_cycle(self): for node in self.graph.keys(): if node not in self.visited: if self.detect_cycle_util(node): return True return False"},{"question":"# Sorting Student Names Function Write a function in Python called `sort_students` that accepts a list of dictionaries, each representing a student. The dictionary for each student contains the following keys: 1. `name` (str): The name of the student. 2. `age` (int): The age of the student. 3. `gpa` (float): The GPA of the student. The function should sort this list of students based on the following criteria: 1. Primary: GPA in descending order. 2. Secondary: Age in ascending order. The function should return the sorted list of student dictionaries. # Constraints: * The list can contain up to `1000` students. * The name will be a string with a maximum length of `50` characters. * The age of the student will be an integer between `10` to `100`. * The GPA of the student will be a float between `0.0` to `4.0`. # Inputs: * `students`: A list of dictionaries where each dictionary represents a student. Each dictionary contains: * `name` (str): The name of the student. * `age` (int): The age of the student. * `gpa` (float): The GPA of the student. # Outputs: * A list of dictionaries sorted first by GPA in descending order, then by age in ascending order. # Example: ```python students = [ {\\"name\\": \\"Alice\\", \\"age\\": 20, \\"gpa\\": 3.9}, {\\"name\\": \\"Bob\\", \\"age\\": 19, \\"gpa\\": 3.9}, {\\"name\\": \\"Charlie\\", \\"age\\": 22, \\"gpa\\": 3.8}, ] sorted_students = sort_students(students) print(sorted_students) ``` Should return: ```python [ {\\"name\\": \\"Alice\\", \\"age\\": 20, \\"gpa\\": 3.9}, {\\"name\\": \\"Bob\\", \\"age\\": 19, \\"gpa\\": 3.9}, {\\"name\\": \\"Charlie\\", \\"age\\": 22, \\"gpa\\": 3.8}, ] ``` # Hints: * Use Python\'s `sorted()` function with an appropriate key parameter. * Consider using tuples in the key function to handle multiple sorting criteria efficiently.","solution":"def sort_students(students): Sorts students first by GPA in descending order, then by age in ascending order. :param students: List of dictionaries, each containing \'name\', \'age\', and \'gpa\'. :return: Sorted list of students based on the specified criteria. return sorted(students, key=lambda s: (-s[\'gpa\'], s[\'age\']))"},{"question":"# Optimized String Compression Algorithm with Memory Constraints You are tasked with implementing an optimized string compression algorithm tailored for scenarios with strict memory usage constraints. The objective is to compress strings containing large sequences of repeated characters, while ensuring the solution is both time and space efficient. Specific Requirements 1. **Input**: A string consisting of lowercase alphabets. 2. **Output**: A compressed version of the string where consecutive repeated characters are represented by the character followed by the count of repetitions. If the compressed string is not smaller than the original, return the original string. 3. **Constraints**: * The function should handle strings up to 100,000 characters efficiently. * Avoid using additional data structures like lists or dictionaries unnecessarily. * Implement in-place compression if possible to further reduce memory usage. Performance Requirements * The solution should run in O(n) time complexity, where n is the length of the input string. * Use minimum additional space beyond the input string itself. Scenario Your organization is storing large logs of repetitive data and needs an efficient compression algorithm to minimize storage space. The algorithm needs to be optimized for memory-constrained environments. You are tasked with implementing the following function: ```python def compress_string(s: str) -> str: Given a string s, return its run-length encoded representation if it is shorter than the original string. Otherwise, return the original string. Parameters: s (str): The input string to be compressed. Returns: str: The compressed string or the original string if compression does not reduce the size. pass ``` **Example Usage:** ```python result1 = compress_string(\\"aabcccccaaa\\") print(result1) # Output: \\"a2b1c5a3\\" result2 = compress_string(\\"abcdef\\") print(result2) # Output: \\"abcdef\\" (since compression would not reduce the size) ``` Ensure your solution is optimized for both time and space efficiency, handling large inputs effectively.","solution":"def compress_string(s: str) -> str: Given a string s, return its run-length encoded representation if it is shorter than the original string. Otherwise, return the original string. Parameters: s (str): The input string to be compressed. Returns: str: The compressed string or the original string if compression does not reduce the size. n = len(s) if n == 0: return s compressed = [] count = 1 for i in range(1, n): if s[i] == s[i - 1]: count += 1 else: compressed.append(s[i - 1] + str(count)) count = 1 compressed.append(s[-1] + str(count)) compressed_str = \'\'.join(compressed) if len(compressed_str) >= n: return s return compressed_str"},{"question":"# Problem: Implement Matrix Multiplication Given two matrices `A` and `B`, implement a function to perform matrix multiplication and return the resulting matrix. Matrix multiplication is defined as the dot product of the rows of `A` and the columns of `B`. Input * **A**: A list of lists of integers representing the first matrix. * **B**: A list of lists of integers representing the second matrix. Output * Return a list of lists of integers representing the resulting matrix after multiplication. # Constraints 1. The number of columns in `A` must be equal to the number of rows in `B`. 2. Elements in matrices `A` and `B` will be integers within the range `-1000 <= element <= 1000`. 3. The dimensions of `A` and `B` will be between 1 and 100 inclusive. # Example ```python A = [ [1, 2, 3], [4, 5, 6] ] B = [ [7, 8], [9, 10], [11, 12] ] print(matrix_multiplication(A, B)) # Outputs: # [ # [58, 64], # [139, 154] # ] A = [ [1, 4], [2, 5], [3, 6] ] B = [ [7, 8, 9], [10, 11, 12] ] print(matrix_multiplication(A, B)) # Outputs: # [ # [47, 52, 57], # [64, 71, 78], # [81, 90, 99] # ] ``` # Notes * Ensure to handle edge cases such as single-element matrices and non-square matrices. * Validate that multiplication is possible with given matrix dimensions and raise a `ValueError` with the message \\"Matrix dimensions mismatch\\" if they are not compatible. * Aim to optimize your solution for performance considering the constraints. # Function Signature ```python def matrix_multiplication(A: List[List[int]], B: List[List[int]]) -> List[List[int]]: # You need to implement this function ``` # Context Matrix multiplication is a fundamental operation in many fields, including computer graphics, machine learning, and scientific computing. This problem checks your ability to manipulate nested lists and implement basic linear algebra operations.","solution":"from typing import List def matrix_multiplication(A: List[List[int]], B: List[List[int]]) -> List[List[int]]: Perform matrix multiplication of A and B and return the result as a new matrix. The number of columns in A must be equal to the number of rows in B. Args: - A (List[List[int]]): The first matrix. - B (List[List[int]]): The second matrix. Returns: - List[List[int]]: The resulting matrix after multiplication. Raises: - ValueError: If the matrices dimensions do not match for multiplication. # Get the dimensions of the matrices rows_A, cols_A = len(A), len(A[0]) if A else 0 rows_B, cols_B = len(B), len(B[0]) if B else 0 # Check if matrices can be multiplied if cols_A != rows_B: raise ValueError(\\"Matrix dimensions mismatch\\") # Initialize the resultant matrix with zero values result = [[0 for _ in range(cols_B)] for _ in range(rows_A)] # Perform the matrix multiplication for i in range(rows_A): for j in range(cols_B): for k in range(cols_A): result[i][j] += A[i][k] * B[k][j] return result"},{"question":"# Problem Statement You are given a collection of \'n\' points in the 2D plane represented by two arrays `X` and `Y`, where `X[i]` and `Y[i]` represent the x-coordinate and y-coordinate of the i-th point respectively. Your task is to implement a function that finds the pair of points with the smallest Euclidean distance between them. # Function Signature ```python def closest_pair(points: list[tuple[float, float]]) -> tuple: pass ``` # Input The function `closest_pair` accepts a single argument: * `points`: A list of tuples, where each tuple contains two floating-point numbers representing a point\'s coordinates (x, y). # Output The function should return: * A tuple containing two tuples, each of which has the coordinates of the two points that are closest to each other. # Constraints * The input list will contain at least 2 points and at most 10^4 points. * Each coordinate will be a floating-point number within the range of -10^4 to 10^4. * If there are multiple pairs of points with the same minimum distance, return any one of them. # Example ```python points = [(0, 0), (1, 1), (2, 2), (3, 3)] closest_points = closest_pair(points) print(closest_points) ``` The expected output should be one of the following: ```python ((0, 0), (1, 1)) ``` OR ```python ((1, 1), (2, 2)) ``` OR ```python ((2, 2), (3, 3)) ``` # Performance Requirements The solution should aim to have a time complexity lower than O(n^2) if possible, ideally O(n log n) by utilizing efficient algorithms such as the divide and conquer approach. # Notes * Consider edge cases where points might have the same coordinates. * Use mathematical functions accurately to compute Euclidean distances. * Ensure that the function handles large inputs efficiently, taking advantage of efficient computational techniques.","solution":"import math from itertools import combinations def euclidean_distance(p1, p2): return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) def closest_pair(points): Brute-force solution to find the closest pair of points in the plane min_distance = float(\'inf\') closest_points = (points[0], points[1]) for p1, p2 in combinations(points, 2): dist = euclidean_distance(p1, p2) if dist < min_distance: min_distance = dist closest_points = (p1, p2) return closest_points"},{"question":"# Coding Assessment Question Context The task involves numerical transformations and checking the properties of numbers in binary representation. This concept is useful in areas such as computer architecture, low-level programming, and optimization routines where binary manipulations are frequently performed. Task Write a function `binary_gap(n: int) -> int` that returns the length of the longest sequence of consecutive zeros that are surrounded by ones at both ends in the binary representation of a positive integer n. This tests your ability to convert numbers to binary and accurately manage sequences within that representation. Input and Output Formats * **Input**: * `n (int)`: A positive integer, 1 ≤ n ≤ 1,000,000 * **Output**: * An integer representing the length of the longest binary gap in the binary representation of n. Constraints and Performance Requirements * Ensure the solution operates efficiently even for the maximum value of n. * Optimize for both time and space complexity, considering the limits. Special Notes 1. Review methods to convert a number to binary efficiently. 2. Focus on traversing the binary representation accurately to identify and measure gaps. Example ```python def binary_gap(n: int) -> int: pass ``` **Example Usage:** ```python >>> binary_gap(9) 2 >>> binary_gap(529) 4 >>> binary_gap(20) 1 >>> binary_gap(15) 0 >>> binary_gap(32) 0 ``` In these examples: - The binary representation of 9 is `1001`, with a binary gap of 2. - The binary representation of 529 is `1000010001`, with a binary gap of 4. - The binary representation of 20 is `10100`, with a binary gap of 1. - The binary representation of 15 is `1111`, with no gap. - The binary representation of 32 is `100000`, with no gap.","solution":"def binary_gap(n: int) -> int: Returns the length of the longest sequence of consecutive zeros that are surrounded by ones at both ends in the binary representation of a positive integer n. binary_representation = bin(n)[2:] # Get the binary representation as a string, stripping the \'0b\' prefix max_gap = 0 # Variable to hold the maximum length of binary gap found current_gap = 0 # Variable to count the current gap for digit in binary_representation: if digit == \'1\': # When we find a \'1\', it means we must finalize the count for the previous gap, if any max_gap = max(max_gap, current_gap) current_gap = 0 # Reset current gap counter else: # If it is \'0\', we increment the current_gap counter current_gap += 1 return max_gap"},{"question":"# Coding Assessment Question Context Image processing often involves flipping an image horizontally or vertically. You are tasked with implementing a function that flips a given matrix representing an image either horizontally or vertically based on user input. Task Implement a function `flip_image(matrix: List[List[int]], direction: str) -> List[List[int]]` that flips a given 2D matrix representing an image either horizontally or vertically, depending on the specified direction. Function Signature ```python def flip_image(matrix: List[List[int]], direction: str) -> List[List[int]]: pass ``` Input - `matrix`: A list of lists of integers where each nested list represents a row of the image. Each element of the matrix is a pixel value. - `direction`: A string that specifies the direction of the flip. It can be either \\"horizontal\\" or \\"vertical\\". Output - Returns the flipped matrix based on the specified direction. Examples ```python assert flip_image([[1, 2, 3], [4, 5, 6], [7, 8, 9]], \\"horizontal\\") == [[3, 2, 1], [6, 5, 4], [9, 8, 7]] assert flip_image([[1, 2, 3], [4, 5, 6], [7, 8, 9]], \\"vertical\\") == [[7, 8, 9], [4, 5, 6], [1, 2, 3]] assert flip_image([[1, 1, 1], [0, 0, 0], [1, 1, 1]], \\"horizontal\\") == [[1, 1, 1], [0, 0, 0], [1, 1, 1]] assert flip_image([[1, 1, 1], [0, 0, 0], [1, 1, 1]], \\"vertical\\") == [[1, 1, 1], [0, 0, 0], [1, 1, 1]] ``` Constraints - The `matrix` dimensions (m times n) where (1 le m, n le 1000). - The elements in the `matrix` are integers and can be either 0 or 1. - The `direction` is always a valid string and only takes the values \\"horizontal\\" or \\"vertical\\". Performance Requirements - Ensure your implementation is efficient and runs with a time complexity of O(m*n) where `m` is the number of rows and `n` is the number of columns. - The space complexity should be O(1) in terms of additional space used, aside from the input and output matrices.","solution":"from typing import List def flip_image(matrix: List[List[int]], direction: str) -> List[List[int]]: if direction == \\"horizontal\\": return [row[::-1] for row in matrix] elif direction == \\"vertical\\": return matrix[::-1] else: raise ValueError(\\"Invalid direction specified. Use \'horizontal\' or \'vertical\'.\\")"},{"question":"# Analyzing Customer Segments using K-Means Clustering Given a dataset containing various numerical features of customer behaviors, implement the K-Means Clustering algorithm to segment customers into different groups. The goal is to identify clusters of customers with similar behaviors based on the given features. **Input**: * A `data` list of lists, each containing multiple numeric values representing the features of the customers. * An integer `num_clusters` representing the number of clusters to form. **Output**: * A list of integers where each integer represents the cluster assignment of the corresponding customer in the input data. **Function Signature**: ```python def kmeans_cluster(data: list[list[float]], num_clusters: int) -> list[int]: # Function implementation ``` **Constraints**: * The value of `num_clusters` will always be positive and less than or equal to the number of samples in the dataset. * All feature values will be floats. **Example**: ```python # Customer Data data = [ [1.0, 2.0], [1.5, 1.8], [5.0, 8.0], [8.0, 8.0], [1.0, 0.6], [9.0, 11.0], [8.0, 2.0], [10.0, 2.0], [9.0, 3.0] ] num_clusters = 3 # Expected Output # The exact cluster assignments might vary due to the randomness in initial centroid selection. # An example output could be something like: [0, 0, 1, 1, 0, 2, 1, 2, 2] print(kmeans_cluster(data, num_clusters)) # Output: [0, 0, 1, 1, 0, 2, 1, 2, 2] ``` Ensure to consider the edge cases and properly handle the initialization and convergence of the algorithm.","solution":"import random from math import sqrt def euclidean_distance(point1, point2): Calculate the Euclidean distance between two points. return sqrt(sum((a - b) ** 2 for a, b in zip(point1, point2))) def assign_clusters(data, centroids): Assign each point in data to the nearest centroid. clusters = [] for point in data: distances = [euclidean_distance(point, centroid) for centroid in centroids] cluster = distances.index(min(distances)) clusters.append(cluster) return clusters def calculate_new_centroids(data, clusters, num_clusters): Calculate new centroids as the mean of assigned points. new_centroids = [] for k in range(num_clusters): cluster_points = [point for point, cluster in zip(data, clusters) if cluster == k] if cluster_points: centroid = [sum(feature) / len(cluster_points) for feature in zip(*cluster_points)] new_centroids.append(centroid) else: # No points assigned to this cluster; reinitialize the centroid randomly new_centroids.append(random.choice(data)) return new_centroids def kmeans_cluster(data, num_clusters): Implements K-Means Clustering to segment customers into different groups. Parameters: data (list[list[float]]): A list of lists containing numerical features of customers. num_clusters (int): Number of clusters to form. Returns: list[int]: Cluster assignments for each customer. # Randomly initialize centroids centroids = random.sample(data, num_clusters) while True: clusters = assign_clusters(data, centroids) new_centroids = calculate_new_centroids(data, clusters, num_clusters) if new_centroids == centroids: break centroids = new_centroids return clusters"},{"question":"# Problem Statement You are tasked with writing a function that determines the minimum number of parentheses that need to be added to a given string to make it valid. A string is considered valid if every opening parenthesis `(` has a corresponding closing parenthesis `)` and the pairs of parentheses are properly nested. # Function Signature ```python def min_add_to_make_valid(s: str) -> int: ``` # Input - `s` (string): a string consisting of only `(` and `)` characters (1 ≤ len(s) ≤ 10^6). # Output - Return an integer representing the minimum number of parentheses needed to be added to make the string valid. # Constraints - The solution should be efficient enough to handle large strings up to the maximum input size. # Example ```python >>> min_add_to_make_valid(\\"())\\") 1 >>> min_add_to_make_valid(\\"(((\\") 3 >>> min_add_to_make_valid(\\"())(\\") 2 >>> min_add_to_make_valid(\\"()\\") 0 ``` # Explanation - In the first example, adding 1 closing parenthesis makes the string valid: \\"())\\" -> \\"())()\\". - In the second example, adding 3 closing parentheses makes the string valid: \\"(((\\" -> \\"((()))\\". - In the third example, adding 1 opening parenthesis at the end and 1 closing parenthesis at the start makes the string valid: \\"())(\\" -> \\"(())()\\". - In the fourth example, the string is already valid and no additions are needed. # Edge Cases - For strings of length 1, such as \\"(\\" or \\")\\", the result should be 1 since only one parenthesis needs to be added to make them valid. - For very large strings, the algorithm should remain efficient, using linear time complexity relative to the length of the input string. **Note**: Consider an approach that uses a single pass through the string, leveraging a counting mechanism to track unmatched opening and closing parentheses.","solution":"def min_add_to_make_valid(s: str) -> int: # Initialize counters for unbalanced parentheses left_unmatched = 0 # Unmatched \'(\' right_unmatched = 0 # Unmatched \')\' for char in s: if char == \'(\': left_unmatched += 1 elif char == \')\': if left_unmatched > 0: left_unmatched -= 1 else: right_unmatched += 1 # Total unbalanced parentheses will be the number that needs to be added return left_unmatched + right_unmatched"},{"question":"Coding Assessment Question: Problem Context: In the world of software development, it\'s essential to analyze and manage text data, such as determining the frequency of words in a document. This ability plays a critical role in search engines, data analysis, and machine learning applications. Task: Write a function `word_frequencies(text: str) -> Dict[str, int]` that takes a string `text` representing a document and returns a dictionary where the keys are unique words and the values are their respective frequencies. Input: * A string `text` containing the document. * The string can include letters, numbers, and common punctuation marks. * The words are case-insensitive (i.e., \\"Word\\" and \\"word\\" should be considered the same). * Words are separated by whitespace or punctuation marks such as commas, periods, etc. Output: * A dictionary where keys are unique words (in lowercase) and values are integers representing their frequencies in the document. Constraints: * Words are defined as sequences of alphanumeric characters. * Ensure to handle edge cases, such as empty strings or strings with no valid words. Example: ```python word_frequencies(\\"Hello, world! Hello everyone. World peace.\\") ``` This should return `{\'hello\': 2, \'world\': 2, \'everyone\': 1, \'peace\': 1}` as there are 2 instances of \\"hello\\", 2 instances of \\"world\\", and 1 instance each of \\"everyone\\" and \\"peace\\". Additional Notes: * Consider utilizing regular expressions to extract words effectively. * Aim to ensure that your function is efficient, even for longer texts. # Solution Explanation: Implement a function `word_frequencies()` that converts all input text to lowercase, uses a regular expression to split the text into words, and then counts the frequency of each word using a dictionary.","solution":"import re from typing import Dict def word_frequencies(text: str) -> Dict[str, int]: Calculate the frequency of each word in the given text. Parameters: text (str): The text string to analyze. Returns: Dict[str, int]: A dictionary where keys are unique words in lowercase and values are their frequency. # Convert text to lowercase text = text.lower() # Use regex to find all words (alphanumeric sequences) words = re.findall(r\'bw+b\', text) # Calculate frequencies frequencies = {} for word in words: if word in frequencies: frequencies[word] += 1 else: frequencies[word] = 1 return frequencies"},{"question":"# Coding Question Context You have learned about simple data structures like stacks and queues, which use the Last-In-First-Out (LIFO) and First-In-First-Out (FIFO) principles respectively. In this task, you will implement a combined data structure called a `Deque` (Double-ended queue) that allows insertion and deletion of elements from both ends. This is a common structure used in real-world applications such as managing history or undo operations in software. Task You are required to implement a class `Deque` to handle operations for the double-ended queue. 1. **__init__(self)**: * Initialize the Deque with an empty list. 2. **add_front(self, item: Any) -> None**: * Add an item to the front of the Deque. 3. **add_rear(self, item: Any) -> None**: * Add an item to the rear of the Deque. 4. **remove_front(self) -> Any**: * Remove and return the front item of the Deque. If the deque is empty, return `None`. 5. **remove_rear(self) -> Any**: * Remove and return the rear item of the Deque. If the deque is empty, return `None`. 6. **size(self) -> int**: * Return the number of items in the Deque. 7. **is_empty(self) -> bool**: * Return `True` if the Deque is empty, otherwise `False`. Input and Output Formats * `__init__`: * Input: None * Output: None * `add_front`: * Input: An item to be added. * Output: None * `add_rear`: * Input: An item to be added. * Output: None * `remove_front`: * Input: None * Output: The removed item, or `None` if empty. * `remove_rear`: * Input: None * Output: The removed item, or `None` if empty. * `size`: * Input: None * Output: The number of items in the Deque. * `is_empty`: * Input: None * Output: `True` if empty, `False` otherwise. Performance Requirements Ensure that your solutions can handle frequent inserts and deletes efficiently, ideally, all operations should be O(1). Example ```python # Test cases deque = Deque() assert deque.is_empty() == True deque.add_rear(1) deque.add_rear(2) deque.add_front(0) assert deque.size() == 3 assert deque.remove_front() == 0 assert deque.remove_rear() == 2 assert deque.size() == 1 assert deque.remove_front() == 1 assert deque.is_empty() == True ```","solution":"class Deque: def __init__(self): Initialize the Deque with an empty list. self.items = [] def add_front(self, item): Add an item to the front of the Deque. self.items.insert(0, item) def add_rear(self, item): Add an item to the rear of the Deque. self.items.append(item) def remove_front(self): Remove and return the front item of the Deque. If the deque is empty, return None. if self.items: return self.items.pop(0) else: return None def remove_rear(self): Remove and return the rear item of the Deque. If the deque is empty, return None. if self.items: return self.items.pop() else: return None def size(self): Return the number of items in the Deque. return len(self.items) def is_empty(self): Return True if the Deque is empty, otherwise False. return len(self.items) == 0"},{"question":"# Scenario: A delivery company needs to determine the shortest path to deliver packages to all houses in a rectangular grid city. The city’s layout can be represented as a grid of `N` rows and `M` columns. Starting from the top-left corner of the grid, the delivery truck must navigate to each house located at the grid cells, including the top-left and bottom-right corners. The truck can move right, down, or diagonally (bottom-right). # Task: Write a Python function that calculates the minimum number of moves the truck needs to reach the bottom-right corner of the grid and deliver packages to all cells in the grid. # Function Signature: ```python def min_delivery_moves(N: int, M: int) -> int: pass ``` # Input: - `N` (int): The number of rows in the grid. - `M` (int): The number of columns in the grid. # Output: - Returns an integer representing the minimum number of moves needed to reach the bottom-right corner of the grid, covering all cells. # Constraints: - 1 ≤ N, M ≤ 1000 # Performance: - Optimize the function to handle the maximum constraints efficiently. # Example: ```python >>> min_delivery_moves(3, 3) 3 >>> min_delivery_moves(1, 5) 4 ``` # Requirements: - Implement your solution by taking into consideration the possible movements (right, down, diagonal). - Ensure that the function works efficiently for large grids.","solution":"def min_delivery_moves(N: int, M: int) -> int: Calculate the minimum number of moves the truck needs to reach the bottom-right corner of an N x M grid from the top-left corner. Moves can be right, down, or diagonally (bottom-right). # The minimum number of moves is given by max(N, M) - 1 since you can move diagonally # whenever possible, which minimizes the number of moves. return max(N, M) - 1"},{"question":"# Fibonacci Series with a Twist Description Implement a function to generate a list containing the first `n` numbers of a Fibonacci series with a twist. In this series, instead of the regular addition of the last two numbers, add the product of the last two numbers to get the next number in the series. If `n` is less than or equal to 0, return an empty list. Function Signature ```python def twisted_fibonacci_series(n: int) -> list: pass ``` Input * `n` (int): The number of terms in the Fibonacci series with a twist. Output * (list): A list containing the first `n` terms of the twisted Fibonacci series. Constraints * 0 ≤ n ≤ 30 Examples ```python # Example 1 twisted_fibonacci_series(1) # should return [0] # Example 2 twisted_fibonacci_series(2) # should return [0, 1] # Example 3 twisted_fibonacci_series(5) # should return [0, 1, 0, 0, 0] # Example 4 twisted_fibonacci_series(6) # should return [0, 1, 0, 0, 0, 0] # Example 5 twisted_fibonacci_series(0) # should return [] # Example 6 twisted_fibonacci_series(10) # should return [0, 1, 0, 0, 0, 0, 0, 0, 0, 0] ``` Notes Carefully consider edge cases like `n = 0` and `n = 1`. Ensure the function handles these cases without errors and returns the correct result. Focus on generating the sequence accurately based on the provided description.","solution":"def twisted_fibonacci_series(n: int) -> list: Generates a list containing the first n numbers of a twisted Fibonacci series. if n <= 0: return [] if n == 1: return [0] series = [0, 1] for i in range(2, n): next_val = series[-1] * series[-2] series.append(next_val) return series"},{"question":"# Context In the realm of data structures, linked lists offer a versatile method to handle data storage and manipulation. You are tasked with implementing a specific type of linked list operation that includes inserting and removing elements based on various conditions. # Problem Statement You need to create a class named `ConditionalLinkedList` that supports the following operations: 1. Insert a new element at the end of the list. 2. Remove elements based on a specified condition. 3. Display the current elements in the list. # Requirements - Implement the class `ConditionalLinkedList` with the following methods: * `insert(value: int) -> None`: Inserts a new element with the provided integer value at the end of the list. * `remove_if(condition: Callable[[int], bool]) -> None`: Removes all elements for which the given condition returns `True`. * `display() -> List[int]`: Returns the current list of elements in the linked list. # Input - `value (int)`: The integer value to be inserted into the linked list. - `condition (Callable[[int], bool])`: A function that returns `True` if the element should be removed, otherwise `False`. # Output - `insert` method: No output; just inserts the element. - `remove_if` method: No output; just removes elements meeting the condition. - `display` method: Returns a list of current elements. # Constraints - Ensure the linked list can handle a large number of elements (up to 10^6). - The condition function passed to `remove_if` will be a valid callable that operates on integers. # Example ```python ll = ConditionalLinkedList() ll.insert(1) ll.insert(2) ll.insert(3) ll.insert(4) condition = lambda x: x % 2 == 0 ll.remove_if(condition) output = ll.display() print(output) ``` Expected output: - `[1, 3]`","solution":"class Node: def __init__(self, value): self.value = value self.next = None class ConditionalLinkedList: def __init__(self): self.head = None def insert(self, value: int) -> None: new_node = Node(value) if not self.head: self.head = new_node return last = self.head while last.next: last = last.next last.next = new_node def remove_if(self, condition) -> None: prev = None current = self.head while current: if condition(current.value): if prev: prev.next = current.next else: self.head = current.next else: prev = current current = current.next def display(self) -> list: elements = [] current = self.head while current: elements.append(current.value) current = current.next return elements"},{"question":"# Multiplying Large Numbers Using Karatsuba Algorithm Given two large integers represented as strings, your task is to implement the Karatsuba algorithm for multiplication. The goal is to multiply the two numbers efficiently using this divide-and-conquer-based approach. Function Signature ```python def karatsuba_multiply(x: str, y: str) -> str: Multiply two large numbers using the Karatsuba algorithm. Arguments: x -- a string representing a large non-negative integer y -- a string representing a large non-negative integer Returns: A string representing the product of the two numbers. ``` Input - `x`: a string of digits representing a non-negative integer. - `y`: a string of digits representing a non-negative integer. Output - Returns a string representing the product of the two given numbers. Constraints - 1 ≤ len(x), len(y) ≤ 1000 - `x` and `y` will only contain digits (0-9) and will not have leading zeros (except for the number \\"0\\" itself). Example ```python x = \\"123456789\\" y = \\"987654321\\" result = karatsuba_multiply(x, y) # Verify the result print(result) # Expected Output: \'121932631112635269\' ``` # Detailed Requirements 1. Implement the Karatsuba multiplication algorithm which divides the problem into smaller subproblems. 2. Handle the base case where the length of the numbers is small enough to use direct multiplication. 3. Ensure that the function can handle numbers containing up to 1000 digits efficiently. 4. Convert the strings to integers when performing arithmetic operations and convert the final product back to string format. **Note:** This implementation should be done using pure python operations, explicitly avoiding the use of built-in large number multiplication functions to demonstrate understanding of the Karatsuba algorithm.","solution":"def karatsuba_multiply(x: str, y: str) -> str: Multiply two large numbers using the Karatsuba algorithm. Arguments: x -- a string representing a large non-negative integer y -- a string representing a large non-negative integer Returns: A string representing the product of the two numbers. # Base case for recursion - if the numbers are small enough if len(x) == 1 or len(y) == 1: return str(int(x) * int(y)) # Making sure both numbers are the same length by padding with zeros if len(x) < len(y): x = x.zfill(len(y)) elif len(y) < len(x): y = y.zfill(len(x)) n = len(x) m = n // 2 # Split x and y into two halves x_high = x[:-m] x_low = x[-m:] y_high = y[:-m] y_low = y[-m:] # Recursively calculate three products z0 = karatsuba_multiply(x_low, y_low) z1 = karatsuba_multiply(str(int(x_low) + int(x_high)), str(int(y_low) + int(y_high))) z2 = karatsuba_multiply(x_high, y_high) # Calculating the final product using Karatsuba formula product = int(z2) * 10**(2*m) + (int(z1) - int(z2) - int(z0)) * 10**m + int(z0) return str(product)"},{"question":"# Coding Assessment Question: Crossword Grid Analyzer You are given a square grid representing a partially filled crossword puzzle. Each cell in the grid contains either a blank space (\' \') indicating an empty cell or a letter indicating a filled cell. Your task is to write a function that identifies the longest sequence of consecutive empty cells in any row or column of the grid. The input to the function is a list of strings, where each string represents a single row of the grid. Each string is of equal length, and the number of strings is equal to the length of each string (square grid). Requirements: 1. **Function Name**: `longest_empty_sequence` 2. **Input**: - `grid`: A list of strings, each string representing a row in the grid. 3. **Output**: - An integer representing the length of the longest sequence of consecutive empty cells in any row or column of the grid. 4. **Performance**: Ensure the function operates efficiently even on larger grids (e.g., up to 100x100). # Function Signature ```python def longest_empty_sequence(grid: list) -> int: pass ``` # Constraints: - The grid will be a perfect square (i.e., the number of rows equals the number of columns). - Each row in the grid is a non-empty string containing only letters and spaces. - The grid is non-empty and contains at least one row and one column. # Example Suppose the input grid is: ```python [ \\"A B \\", \\" A \\", \\"B B\\", \\" \\" ] ``` Calling `longest_empty_sequence(grid)` should return `4`. The longest sequence of consecutive empty cells is the entire fourth row. **Steps to Achieve the Solution**: 1. Define the function `longest_empty_sequence` with the grid as input. 2. Traverse each row to find the longest sequence of consecutive empty cells. 3. Traverse each column in a similar manner to find the longest sequence of consecutive empty cells. 4. Return the maximum sequence length found in either rows or columns.","solution":"def longest_empty_sequence(grid: list) -> int: def longest_sequence_in_line(line): max_length = 0 current_length = 0 for char in line: if char == \' \': current_length += 1 max_length = max(max_length, current_length) else: current_length = 0 return max_length n = len(grid) max_sequence_length = 0 # Check all the rows for row in grid: max_sequence_length = max(max_sequence_length, longest_sequence_in_line(row)) # Check all the columns for col in range(n): column_string = \'\'.join(grid[row][col] for row in range(n)) max_sequence_length = max(max_sequence_length, longest_sequence_in_line(column_string)) return max_sequence_length"},{"question":"# Coding Assessment Question Problem Statement Implement a function `merge_two_dicts(dict1: dict, dict2: dict) -> dict` that merges two given dictionaries. If there are conflicting keys, the value from `dict2` should override the value from `dict1`. Additionally, all keys and values from both dictionaries should be of type `str`. Requirements 1. The function must check the types of all keys and values in both dictionaries to ensure they are strings. 2. If any non-string key or value is found, raise a `ValueError` with the message \\"All dictionary keys and values must be strings.\\" 3. The function should merge the dictionaries as described, with `dict2`\'s values overriding `dict1`\'s in case of conflict. Input * Two dictionaries, `dict1` and `dict2`, possibly empty. Output * A single dictionary that contains all the key-value pairs from both input dictionaries, with conflict resolution favoring `dict2`. Constraints * Time Complexity: O(n + m), where `n` and `m` are the lengths of `dict1` and `dict2`, respectively. * Space Complexity: O(n + m) Example ```python >>> merge_two_dicts({\'a\': \'1\', \'b\': \'2\'}, {\'b\': \'3\', \'c\': \'4\'}) {\'a\': \'1\', \'b\': \'3\', \'c\': \'4\'} >>> merge_two_dicts({}, {\'a\': \'1\'}) {\'a\': \'1\'} >>> merge_two_dicts({\'key1\': \'value1\'}, {}) {\'key1\': \'value1\'} >>> merge_two_dicts({\'a\': \'1\'}, {\'a\': \'2\', \'b\': \'3\'}) {\'a\': \'2\', \'b\': \'3\'} >>> merge_two_dicts({\'a\': \'1\', \'b\': 2}, {\'c\': \'3\'}) Traceback (most recent call last): ... ValueError: All dictionary keys and values must be strings. ``` Additional Notes * Ensure the function raises `ValueError` for any non-string key or value encountered. * Pay attention to edge cases, such as empty dictionaries or non-string data types.","solution":"def merge_two_dicts(dict1, dict2): Merges two dictionaries ensuring all keys and values are strings. In case of conflicting keys, the value from dict2 overrides the value from dict1. :param dict1: First dictionary :param dict2: Second dictionary :return: Merged dictionary :raises ValueError: If any key or value in the input dictionaries is not a string # Check for type consistency in dict1 for key, value in dict1.items(): if not isinstance(key, str) or not isinstance(value, str): raise ValueError(\\"All dictionary keys and values must be strings.\\") # Check for type consistency in dict2 for key, value in dict2.items(): if not isinstance(key, str) or not isinstance(value, str): raise ValueError(\\"All dictionary keys and values must be strings.\\") # Merge dictionaries, with dict2 values overriding dict1 values in case of conflicts merged_dict = dict1.copy() merged_dict.update(dict2) return merged_dict"},{"question":"# Coding Assessment Question Scenario You have been brought on to optimize the backend of a financial application. One of the requirements is to implement a system that validates International Bank Account Numbers (IBANs). Your task is to develop a function that checks whether a given IBAN is valid, adhering to official IBAN validation rules. Objectives Your task is to implement a function that validates an IBAN according to the ISO 13616 standard. Function Signature ```python def validate_iban(iban: str) -> bool: pass ``` Input * A string `iban` representing an IBAN. Output * A boolean value: `True` if the IBAN is valid, `False` otherwise. Constraints * The input `iban` will be a string containing only alphanumeric characters. * The length of the input string will be between 15 and 34 characters inclusive. Performance Requirements * The function should run in linear time complexity, O(n), where n is the length of the input IBAN string. Example ```python >>> validate_iban(\\"GB82WEST12345698765432\\") True >>> validate_iban(\\"DE89370400440532013000\\") True >>> validate_iban(\\"GB82TEST12345698765432\\") False ``` Instructions 1. Rearrange the IBAN to move the first four characters (the country code and check digits) to the end of the string. 2. Replace each letter in the rearranged IBAN with two digits, expanding the string where `A = 10`, `B = 11`, ..., `Z = 35`. 3. Interpret the transformed string as a large integer and perform the modulo 97 operation. 4. A valid IBAN will result in a remainder of 1 from the modulo 97 operation. 5. Ensure the function adheres to the specified input/output formats. 6. Do not import any additional libraries. Use only standard libraries available in Python.","solution":"def validate_iban(iban: str) -> bool: Validates an IBAN according to the ISO 13616 standard. Parameters: iban (str): The IBAN number as a string. Returns: bool: True if the IBAN is valid, False otherwise. # Move the first four characters to the end of the iban rearranged = iban[4:] + iban[:4] # Replace each letter in the rearranged IBAN with two digits expanded_iban = \'\' for char in rearranged: if char.isdigit(): expanded_iban += char else: expanded_iban += str(ord(char) - 55) # \'A\' is 65 in ASCII, so \'A\' -> 10, \'B\' -> 11, ..., \'Z\' -> 35 # Convert the expanded IBAN into an integer iban_as_int = int(expanded_iban) # Perform the modulo 97 operation return iban_as_int % 97 == 1"},{"question":"# Given Context You are developing a library management system for a local library. The system should allow users to borrow and return books, and also keep track of the availability and borrow history of each book. The library has specific rules about how many books a user can borrow at one time, and how long they can keep each book. # Task 1. Implement the `borrow_book` function that allows a user to borrow a book if it is available. 2. Implement the `return_book` function that allows a user to return a borrowed book. 3. Ensure that a user cannot borrow more than 5 books at a time. 4. Ensure that a user cannot borrow a book for more than 30 days. # Input and Output Formats * **Class to implement**: * `Library` - Manages the collection of books and user interactions. * **Functions to implement**: * `borrow_book(user_id: int, book_id: int) -> str` * `return_book(user_id: int, book_id: int) -> str` * **Constraints**: * Assume `books` is a dictionary with `book_id` as key and a dictionary containing book details as value. * Assume `users` is a dictionary with `user_id` as key and a dictionary containing user details as value. * Do not use any 3rd party libraries except those in the standard library. # Example Scenario A user wants to borrow a book. If the book is available and the user has not exceeded their borrow limit, they should be able to borrow the book. If they return the book within 30 days, the system should update the borrow history and mark the book as available again. # Starter Code ```python import datetime class Library: def __init__(self): self.books = { 1: {\'title\': \'1984\', \'author\': \'George Orwell\', \'available\': True, \'borrow_history\': []}, 2: {\'title\': \'To Kill a Mockingbird\', \'author\': \'Harper Lee\', \'available\': True, \'borrow_history\': []}, # More books can be added here } self.users = { 1: {\'name\': \'Alice\', \'borrowed_books\': {}}, 2: {\'name\': \'Bob\', \'borrowed_books\': {}}, # More users can be added here } def borrow_book(self, user_id: int, book_id: int) -> str: if book_id not in self.books: return \'Book does not exist\' if not self.books[book_id][\'available\']: return \'Book is not available\' if len(self.users[user_id][\'borrowed_books\']) >= 5: return \'User cannot borrow more than 5 books\' current_date = datetime.datetime.now() due_date = current_date + datetime.timedelta(days=30) self.books[book_id][\'available\'] = False self.books[book_id][\'borrow_history\'].append((user_id, current_date)) self.users[user_id][\'borrowed_books\'][book_id] = due_date return f\'Book borrowed successfully, due date: {due_date}\' def return_book(self, user_id: int, book_id: int) -> str: if book_id not in self.users[user_id][\'borrowed_books\']: return \'Book was not borrowed by user\' self.books[book_id][\'available\'] = True del self.users[user_id][\'borrowed_books\'][book_id] return \'Book returned successfully\' # Example usage: library = Library() print(library.borrow_book(1, 1)) # Borrow the book with id 1 by user with id 1 print(library.return_book(1, 1)) # Return the book with id 1 by user with id 1 ```","solution":"import datetime class Library: def __init__(self): self.books = { 1: {\'title\': \'1984\', \'author\': \'George Orwell\', \'available\': True, \'borrow_history\': []}, 2: {\'title\': \'To Kill a Mockingbird\', \'author\': \'Harper Lee\', \'available\': True, \'borrow_history\': []}, # More books can be added here } self.users = { 1: {\'name\': \'Alice\', \'borrowed_books\': {}}, 2: {\'name\': \'Bob\', \'borrowed_books\': {}}, # More users can be added here } def borrow_book(self, user_id: int, book_id: int) -> str: if book_id not in self.books: return \'Book does not exist\' if not self.books[book_id][\'available\']: return \'Book is not available\' if len(self.users[user_id][\'borrowed_books\']) >= 5: return \'User cannot borrow more than 5 books\' current_date = datetime.datetime.now() due_date = current_date + datetime.timedelta(days=30) self.books[book_id][\'available\'] = False self.books[book_id][\'borrow_history\'].append((user_id, current_date)) self.users[user_id][\'borrowed_books\'][book_id] = due_date return f\'Book borrowed successfully, due date: {due_date}\' def return_book(self, user_id: int, book_id: int) -> str: if book_id not in self.users[user_id][\'borrowed_books\']: return \'Book was not borrowed by user\' self.books[book_id][\'available\'] = True del self.users[user_id][\'borrowed_books\'][book_id] return \'Book returned successfully\'"},{"question":"# Problem: Find All Narcissistic Numbers A Narcissistic number (also known as an Armstrong number) is a number that is the sum of its digits each raised to the power of the number of digits in the number. For example, the number 153 is a Narcissistic number because (1^3 + 5^3 + 3^3 = 153). Write a function to find all the Narcissistic numbers within a given range and return them in a list. Input: - An integer `start` that represents the starting value of the range (inclusive). - An integer `end` that represents the ending value of the range (inclusive). Output: Your function should return a list containing all Narcissistic numbers found in the specified range. Example: ``` find_narcissistic_numbers(100, 500) ``` should return ``` [153, 370, 371, 407] ``` Constraints: - The range is between 1 and 10,000 inclusive. - The solution should be efficient and handle the upper limit in a reasonable time frame. Write a function `find_narcissistic_numbers` as described above. ```python def find_narcissistic_numbers(start: int, end: int) -> list: This function finds all Narcissistic (Armstrong) numbers within the given range. Parameters: start (int): The start of the range (inclusive). end (int): The end of the range (inclusive). Returns: list: A list of all Narcissistic numbers within the specified range. def is_narcissistic(number: int) -> bool: digits = [int(d) for d in str(number)] num_digits = len(digits) return number == sum(d ** num_digits for d in digits) return [num for num in range(start, end + 1) if is_narcissistic(num)] # Example of usage if __name__ == \\"__main__\\": print(find_narcissistic_numbers(100, 500)) ```","solution":"def find_narcissistic_numbers(start: int, end: int) -> list: This function finds all Narcissistic (Armstrong) numbers within the given range. Parameters: start (int): The start of the range (inclusive). end (int): The end of the range (inclusive). Returns: list: A list of all Narcissistic numbers within the specified range. def is_narcissistic(number: int) -> bool: digits = [int(d) for d in str(number)] num_digits = len(digits) return number == sum(d ** num_digits for d in digits) return [num for num in range(start, end + 1) if is_narcissistic(num)]"},{"question":"# Problem Statement **First Non-Repeating Character in a String** You are to implement a function that finds the first non-repeating character in a given string and returns its index. If there is no such character, return -1. The function should be case-sensitive. **Function Signature**: ```python def first_non_repeating_character(s: str) -> int: pass ``` # Input * `s` (str): The input string consisting of printable ASCII characters. # Output * `int`: The index of the first non-repeating character. Return -1 if all characters repeat. # Constraints * The function should raise the appropriate error if the input is not a string. * The length of the string `s` will be between 1 and 10^5 inclusive. # Example ```python print(first_non_repeating_character(\\"abcdcaf\\")) # Output: 1 (index of \'b\') print(first_non_repeating_character(\\"aabb\\")) # Output: -1 (no non-repeating character) print(first_non_repeating_character(\\"aAbBC\\")) # Output: 0 (index of \'a\') print(first_non_repeating_character(\\"xxyz\\")) # Output: 2 (index of \'y\') ``` # Additional Requirements 1. Ensure your function handles typical edge cases: empty strings (though not a valid input per constraints), strings with all repeating characters, strings with only non-repeating characters. 2. Efficiency is crucial due to the potential size of the input string. # Hints * Use data structures that can efficiently count and track character indices (e.g., dictionaries). * Consider the use of collections.Counter or similar built-in libraries for counting occurrences of characters.","solution":"def first_non_repeating_character(s: str) -> int: from collections import defaultdict if not isinstance(s, str): raise ValueError(\\"Input must be a string\\") char_count = defaultdict(int) char_index = {} for index, char in enumerate(s): char_count[char] += 1 if char not in char_index: char_index[char] = index for char, count in char_count.items(): if count == 1: return char_index[char] return -1"},{"question":"# Problem Statement: You are given a binary tree and must implement a function that returns the width of the binary tree. The width of a binary tree is the maximum width among all levels. The width of one level is defined as the number of nodes between the leftmost and rightmost non-null nodes in the level, including null nodes between them. # Function Signature: ```python def width_of_binary_tree(root: Optional[TreeNode]) -> int: ``` # Input: * `root`: A TreeNode that represents the root of the binary tree. The TreeNode class is defined as follows: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` # Output: * An integer representing the maximum width of the binary tree. # Constraints: * The number of nodes in the tree is in the range [1, 3000]. * The TreeNode values are integers within the range [-100, 100]. * The function should be efficient and handle a large number of nodes. # Examples: ```python # Example 1 # Given the following tree: # 1 # / # 3 2 # / # 5 3 9 # # The maximum width is 4. # Because level 3 has 4 nodes (5, 3, null, 9). root = TreeNode(1, TreeNode(3, TreeNode(5), TreeNode(3)), TreeNode(2, None, TreeNode(9))) assert width_of_binary_tree(root) == 4 # Example 2 # Given the following tree: # 1 # / # 3 # / # 5 3 # # The maximum width is 2. # Because level 2 has 2 nodes (5, 3). root = TreeNode(1, TreeNode(3, TreeNode(5), TreeNode(3))) assert width_of_binary_tree(root) == 2 # Example 3 # Given the following tree: # 1 # / # 3 2 # / # 5 # # The maximum width is 2. # Because level 1 has 2 nodes (3, 2). root = TreeNode(1, TreeNode(3, TreeNode(5)), TreeNode(2)) assert width_of_binary_tree(root) == 2 ``` # Scenario: Imagine a software engineer working on a project to visualize large and complex hierarchical data structures. They need to determine the width of these structures to optimize the display space and resources. Your function will help them compute the maximum width efficiently.","solution":"from typing import Optional from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def width_of_binary_tree(root: Optional[TreeNode]) -> int: if not root: return 0 max_width = 0 queue = deque([(root, 0)]) while queue: level_length = len(queue) _, first_index = queue[0] for _ in range(level_length): node, index = queue.popleft() if node.left: queue.append((node.left, 2 * index)) if node.right: queue.append((node.right, 2 * index + 1)) # Current level width is last_index - first_index + 1 last_index = queue[-1][1] if queue else index max_width = max(max_width, last_index - first_index + 1) return max_width"},{"question":"# Sorting and Filtering Question **Scenario**: As a data analyst, you often need to process and analyze large datasets. One common task is filtering and sorting the data based on specific criteria. Suppose you have a list of student records where each record consists of the student\'s name and their score. You need to implement a function to return the names of students who scored above a given threshold, sorted in descending order of their scores. **Task**: Implement a function `filter_and_sort_students` that takes a list of student records and a score threshold as input, and returns a sorted list of names of students who scored above the threshold. **Function Signature**: ```python def filter_and_sort_students(student_records: List[Tuple[str, int]], threshold: int) -> List[str]: Filter and sort students by score. Parameters: student_records (List[Tuple[str, int]]): A list of tuples where each tuple contains a student\'s name and score. threshold (int): The cutoff score. Returns: List[str]: A sorted list of names of students with scores above the threshold, sorted in descending order of scores. Example Usage: >>> student_records = [(\'Alice\', 85), (\'Bob\', 75), (\'Charlie\', 95), (\'David\', 65)] >>> filter_and_sort_students(student_records, 70) [\'Charlie\', \'Alice\', \'Bob\'] >>> student_records = [(\'Eve\', 55), (\'Frank\', 45), (\'Grace\', 75), (\'Hank\', 65)] >>> filter_and_sort_students(student_records, 60) [\'Grace\', \'Hank\'] # Your code here ``` **Constraints**: - Each student\'s name is a string of length between 1 and 100 inclusive, consisting of only alphabetical characters. - Each student\'s score is an integer between 0 and 100 inclusive. - The number of student records will not exceed 10^5. - The function should perform efficiently even for large datasets. Ensure that your implementation is efficient, correctly follows the constraints, and handles edge cases appropriately, such as when no student scores above the threshold.","solution":"from typing import List, Tuple def filter_and_sort_students(student_records: List[Tuple[str, int]], threshold: int) -> List[str]: Filter and sort students by score. Parameters: student_records (List[Tuple[str, int]]): A list of tuples where each tuple contains a student\'s name and score. threshold (int): The cutoff score. Returns: List[str]: A sorted list of names of students with scores above the threshold, sorted in descending order of scores. # Filter out students who scored above the threshold filtered_students = [student for student in student_records if student[1] > threshold] # Sort the students by their scores in descending order sorted_students = sorted(filtered_students, key=lambda x: x[1], reverse=True) # Extract the names of the students result = [student[0] for student in sorted_students] return result"},{"question":"# Question You are a backend engineer tasked with building a URL shortening service similar to Bitly or TinyURL. Your job is to implement the core functionality that encodes a long URL into a shortened version and decodes the shortened URL back to its original long form. # Requirements 1. **Class Name**: `UrlShortener` 2. **Methods**: - `encode(url: str) -> str`: This method takes a long URL and returns a shortened URL. - `decode(short_url: str) -> str`: This method takes a shortened URL and returns the original long URL. 3. **Attributes of the Class**: - A dictionary to store the mapping from the shortened URL to the original URL. - A dictionary to store the mapping from the original URL to the shortened URL to handle cases where the same URL is encoded multiple times. - A counter to ensure each shortened URL is unique. # Constraints - You can assume that URLs provided will be valid and well-formed. - The service should generate unique shortened URLs for unique long URLs. - The shortened URL should be sufficiently short and preferably alphanumeric. - The same long URL should always produce the same short URL if encoded again. # Example ```python shortener = UrlShortener() # Encode long URL short_url = shortener.encode(\\"https://www.example.com/some/long/page\\") print(short_url) # e.g. \\"http://short.url/abc123\\" # Decode short URL original_url = shortener.decode(short_url) print(original_url) # \\"https://www.example.com/some/long/page\\" ``` # Notes - Do not handle the actual storage or database connections in this implementation. - Focus on the logic for encoding and decoding URLs. - Make sure your code handles edge cases gracefully, for example, when trying to decode a URL that was never encoded.","solution":"class UrlShortener: def __init__(self): self.url_to_short = {} self.short_to_url = {} self.counter = 0 self.base_url = \\"http://short.url/\\" def _generate_short_url(self): alphabet = \\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\\" result = [] counter = self.counter while counter > 0: result.append(alphabet[counter % 62]) counter //= 62 return \'\'.join(result) or \'0\' def encode(self, url: str) -> str: if url in self.url_to_short: return self.url_to_short[url] short_url = self.base_url + self._generate_short_url() self.counter += 1 self.url_to_short[url] = short_url self.short_to_url[short_url] = url return short_url def decode(self, short_url: str) -> str: return self.short_to_url.get(short_url, None)"},{"question":"# Problem Statement: Write a function that finds the longest contiguous subarray where all elements are either increasing or stay the same. # Function Definition Implement a function `longest_non_decreasing_subarray(arr: List[int]) -> Tuple[int, List[int]]` that identifies the longest subarray in which the elements are non-decreasing (either increasing or staying the same). # Input - `arr`: A list of integers. # Output - Return a tuple containing two elements: - The length of the longest non-decreasing subarray. - The longest non-decreasing subarray itself. If there are multiple such subarrays with the maximum length, return the one that appears first. # Constraints - The length of `arr` is between 1 and 10^5. - The elements of `arr` are integers between -10^6 and 10^6. # Examples ```python # Example 1: >>> longest_non_decreasing_subarray([1, 3, 2, 3, 4, 1]) (3, [2, 3, 4]) # Example 2: >>> longest_non_decreasing_subarray([5, 5, 5, 5]) (4, [5, 5, 5, 5]) # Example 3: >>> longest_non_decreasing_subarray([1]) (1, [1]) # Example 4: >>> longest_non_decreasing_subarray([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]) (3, [1, 5, 9]) ``` # Notes - Ensure your solution handles large inputs efficiently. - Carefully consider edge cases, such as arrays with a single element or arrays where the longest subarray appears at the beginning or end.","solution":"def longest_non_decreasing_subarray(arr): n = len(arr) if n == 0: return (0, []) max_len = 1 max_subarray = [arr[0]] current_len = 1 current_start = 0 for i in range(1, n): if arr[i] >= arr[i-1]: current_len += 1 else: if current_len > max_len: max_len = current_len max_subarray = arr[current_start:i] current_len = 1 current_start = i # Check the last subarray if current_len > max_len: max_len = current_len max_subarray = arr[current_start:n] return (max_len, max_subarray)"}]'),N={name:"App",components:{PoemCard:C},data(){return{searchQuery:"",visibleCount:4,poemsData:S,isLoading:!1}},computed:{filteredPoems(){const r=this.searchQuery.trim().toLowerCase();return r?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(r)||e.solution&&e.solution.toLowerCase().includes(r)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(r=>setTimeout(r,1e3)),this.visibleCount+=4,this.isLoading=!1}}},O={class:"search-container"},L={class:"card-container"},F={key:0,class:"empty-state"},R=["disabled"],z={key:0},P={key:1};function D(r,e,l,p,s,a){const m=g("PoemCard");return n(),i("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",O,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),_(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>s.searchQuery=o),placeholder:"Search..."},null,512),[[y,s.searchQuery]]),s.searchQuery?(n(),i("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>s.searchQuery="")}," ✕ ")):u("",!0)]),t("div",L,[(n(!0),i(b,null,w(a.displayedPoems,(o,f)=>(n(),v(m,{key:f,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(n(),i("div",F,' No results found for "'+d(s.searchQuery)+'". ',1)):u("",!0)]),a.hasMorePoems?(n(),i("button",{key:0,class:"load-more-button",disabled:s.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[s.isLoading?(n(),i("span",P,"Loading...")):(n(),i("span",z,"See more"))],8,R)):u("",!0)])}const Y=c(N,[["render",D],["__scopeId","data-v-7926f456"]]),M=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"library/14.md","filePath":"library/14.md"}'),j={name:"library/14.md"},U=Object.assign(j,{setup(r){return(e,l)=>(n(),i("div",null,[x(Y)]))}});export{M as __pageData,U as default};
